t this into a separate routine so as not to
    impact the mainline code.

    N.B. This function is for use by memory management ONLY.

Arguments:

    TBD.

Return Value:

    Next relocation entry to process.

--*/

{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    ULONG Temp32;
    USHORT TempShort1;
    USHORT TempShort2;
    ULONGLONG Value64;
    LONGLONG Temp64;
    USHORT RelocationType;
    IN PVOID CurrentBase;

    RTL_PAGED_CODE();

    CurrentBase = (PVOID)((ULONG_PTR)OldDiff + OldBase);

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                //
                // Return the relocation to its original state, checking for
                // whether the entry was sign extended the 1st time it was
                // relocated.
                //
                FixupVA = (PUCHAR)((LONG_PTR)FixupVA & (LONG_PTR)~(LDRP_RELOCATION_FINAL | LDRP_RELOCATION_INCREMENT));
                Temp = *(PUSHORT)(FixupVA) << 16;

                ++NextOffset;
                --SizeOfBlock;

                // remove the carry bit from the low word
                Temp -= ((LONG)(*(PSHORT)NextOffset) + (USHORT)OldDiff + 0x8000) & ~0xFFFF;

                Temp -= (LONG)(OldDiff & ~0xffff);

                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

                //
                // Mark the relocation as needing no further reprocessing.
                //
                *(NextOffset - 1) |= LDRP_RELOCATION_FINAL;
                break;

           case IMAGE_REL_BASED_HIGH3ADJ :
               //
               // This type of relocation always results in a no-op when
               // done by the osloader for kernelmode drivers.  But the
               // subsequent relocation must be done very carefully.
               //
               TempShort1 = *(NextOffset + 1);
               TempShort2 = *(NextOffset + 2);

               Temp64 = (LONGLONG)((TempShort2 << 16) + TempShort1);
               Temp64 -= (LONGLONG)OldBase;
               Temp64 += (LONGLONG)CurrentBase;

               TempShort1 = (USHORT)Temp64;
               TempShort2 = (USHORT)(Temp64 >> 16);

               *(NextOffset + 1) = TempShort1;
               *(NextOffset + 2) = TempShort2;

               ++NextOffset;
               --SizeOfBlock;
               ++NextOffset;
               --SizeOfBlock;

               break;

            default :
               break;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldrlib\i386\mtldrtls.asm ===
page    ,132
    title       mtldrtls - TLS support object
;***
;atlssup.asm - Thread Local Storage support object (defines [_]_tls_array)
;
;       Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Defines the symbol [_]_tls_array which is the offset into the
;       TEB (thread environment block) of the thread local storage pointer.
;
;Revision History:
;       03-19-93  SKS   Initial version (from ChuckM)
;       03-22-93  SKS   One less leading underscore with new include file
;       10-06-94  SKS   Added header file comment
;
;*******************************************************************************

.xlist
%   .model small, C
.list

; This symbol is being defined in the C language model
; and will have an extra underscore character prepended.

                public  _tls_array
_tls_array      equ     04h       ; TIB.StackBase

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldrlib\mtldrp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    mtldrp.h

Abstract:

    Pre-compile header file for mtldr library

--*/

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntos.h>
#include <xtl.h>
#include <ldr.h>
#include <dm.h>
#include "sysload.h"

extern PLDR_CURRENT_IMAGE XeLdrImage;
extern IMAGE_TLS_DIRECTORY _tls_used;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldr\xtl.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xtl.cpp

Abstract:

    This module contains various XTL wrapper used by Xnet

--*/

#include "mtldrp.h"

EXTERN_C ULONG XDebugOutLevel = 0;

EXTERN_C
VOID
WINAPI
vXDebugPrint(
        ULONG Level,
        PCHAR Module,
        PCHAR Format,
        va_list arglist
        )
{
    CHAR string[MAX_PATH];

    if (Level <= XDebugOutLevel) {
        _vsnprintf(string, sizeof(string), Format, arglist);
        DbgPrint( "[%s]: %s\n", Module, string );
    }
}

VOID
WINAPI
XRegisterThreadNotifyRoutine(
    PXTHREAD_NOTIFICATION pThreadNotification,
    BOOL fRegister
    )
/*++

Routine Description:

    Register or deregister a notification routine which will be called
    when a thread is created or deleted.

    This routine currently does nothing as it's a wrapper for Xnet

Arguments:

    pThreadNotification - Points to a XTHREAD_NOTIFICATION structure
        NOTE: The XTHREAD_NOTIFICATION structure must remain
        valid until the thread notification routine is deregistered.
        For example, you can use a global variable for this.
        But you should NOT use a local variable inside a function.

    fRegister - TRUE to register a new thread notification routine
        FALSE to deregister a previously registered notification routine

Return Value:

    NONE

--*/
{
    UNREFERENCED_PARAMETER( pThreadNotification );
    UNREFERENCED_PARAMETER( fRegister );
}

DWORD
WINAPI
XQueryValue(
    IN ULONG ulValueIndex,
    OUT PULONG pulType,
    OUT PVOID pValue,
    IN ULONG cbValueLength,
    IN OUT PULONG pcbResultLength
    )
/*++

Routine Description:

    This routine currently does nothing as it's a wrapper for Xnet

Arguments:

    Unused

Return Value:

    Always zero

--*/
{
    UNREFERENCED_PARAMETER( ulValueIndex );
    UNREFERENCED_PARAMETER( pulType );
    UNREFERENCED_PARAMETER( pValue );
    UNREFERENCED_PARAMETER( cbValueLength );
    UNREFERENCED_PARAMETER( pcbResultLength );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldrlib\sysload.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sysload.c

Abstract:

    This module contains the code to load DLLs into the system portion of
    the address space and calls the DLL at its initialization entry point.

--*/

#include "mtldrp.h"

NTSTATUS
MiSnapThunk(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA NameThunk,
    OUT PIMAGE_THUNK_DATA AddrThunk,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN SnapForwarder
    );

VOID
LdrInitializeSystemLoader(
    PVOID KernelLoaderBlock
    )
{
    ULONG TlsSize;

    ASSERT( KernelLoaderBlock );

    //
    // Initialize the global loader lists and locks.
    //

    XeLdrImage = (PLDR_CURRENT_IMAGE)KernelLoaderBlock;

    TlsSize = (_tls_used.EndAddressOfRawData -
        _tls_used.StartAddressOfRawData) + _tls_used.SizeOfZeroFill;

    //
    // The base of the TLS section must be 16-byte aligned.  We know
    // that fs:StackBase is 16-byte aligned, ensuring that TlsSize is
    // 16-byte aligned is sufficient
    //
    TlsSize = (TlsSize + 15) & ~15;

    //
    // Add four bytes for the index pointer
    //
    TlsSize += 4;
    *(PULONG)(_tls_used.AddressOfIndex) = (int)TlsSize / -4;
}

NTSTATUS
MiLoadSystemImage(
    IN PVOID ImageBuffer,
    IN PSTRING ImageFileName,
    OUT PVOID *EntryPoint OPTIONAL
    )
/*++

Routine Description:

    This routine reads the image pages from the specified section into
    the system and returns the address of the DLL's header.

    At successful completion, the Section is referenced so it remains
    until the system image is unloaded.

Arguments:

    ImageFileName - Supplies the full path name (including the image name)
                    of the image to load.

    ImageHandle - Returns an opaque pointer to the referenced section object
                  of the image that was loaded.

    ImageBaseAddress - Returns the image base within the system.

Return Value:

    Status of the load operation.

--*/
{
    NTSTATUS status;
    PCHAR BaseAddress;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG ImportDescriptorSize;
    ULONG NumberOfImportDescriptors;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportDirectorySize;
    PIMAGE_THUNK_DATA OriginalThunk;
    PIMAGE_THUNK_DATA Thunk;
    ULONG DebugDirectorySize;

    BaseAddress = (PCHAR)ImageBuffer;

    //
    // Relocate the image at its new base address.
    //

    try {
        status = (NTSTATUS)LdrRelocateImage(BaseAddress, "SYSLDR",
            (ULONG)STATUS_SUCCESS, (ULONG)STATUS_CONFLICTING_ADDRESSES,
            (ULONG)STATUS_INVALID_IMAGE_FORMAT);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Bind to the images from the module's import table.
    //

    ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
        BaseAddress, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportDescriptorSize);

    if (ImportDescriptor != NULL) {

        //
        // Count the number of images that we'll need to bind to.
        //

        NumberOfImportDescriptors = 0;

        while (ImportDescriptor->Name != 0 && ImportDescriptor->FirstThunk != 0) {
            NumberOfImportDescriptors++;
            ImportDescriptor++;
        }

        //
        // Only xboxkrnl.exe imports will be binded
        //

        if (NumberOfImportDescriptors != 1) {
            KdPrint(( "LDR: invalid number of import descriptor (%lu)\n",NumberOfImportDescriptors ));
            return STATUS_INVALID_IMAGE_PROTECT;
        }

        ImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(
            BaseAddress, TRUE, IMAGE_DIRECTORY_ENTRY_IMPORT, &ImportDescriptorSize);

        if (ImportDescriptor->Name != 0 && ImportDescriptor->FirstThunk != 0) {

            //
            // Build the file name to the module.  This path won't be accurate
            // for xboxkrnl.exe and hal.dll, but the above code that checks for
            // already loaded modules ignores the directory so it doesn't
            // matter.
            //

            if ( _stricmp("xboxkrnl.exe", BaseAddress + ImportDescriptor->Name) ) {
                KdPrint(( "LDR: invalid import module (%s)\n", BaseAddress + ImportDescriptor->Name ));
                return STATUS_INVALID_IMAGE_PROTECT;
            }

            //
            // Snap the import thunk to the export directory.
            //

            ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                PsNtosImageBase, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT,
                &ExportDirectorySize);

            if (ExportDirectory == NULL) {
                status = STATUS_DRIVER_ENTRYPOINT_NOT_FOUND;
                goto CleanupAndExit;
            }

            OriginalThunk = (PIMAGE_THUNK_DATA)(BaseAddress +
                ImportDescriptor->OriginalFirstThunk);
            Thunk = (PIMAGE_THUNK_DATA)(BaseAddress +
                ImportDescriptor->FirstThunk);

            while (OriginalThunk->u1.AddressOfData != 0) {

                status = MiSnapThunk(PsNtosImageBase, BaseAddress,
                    OriginalThunk, Thunk, ExportDirectory, ExportDirectorySize,
                    FALSE);

                if (!NT_SUCCESS(status)) {
                    KdPrint(("MiLoadSystemImage: %Z couldn't bind to export from %s\n",
                        &ImageFileName, BaseAddress + ImportDescriptor->Name));
                    goto CleanupAndExit;
                }

                OriginalThunk++;
                Thunk++;
            }
        }
    }

    if (ARGUMENT_PRESENT(EntryPoint)) {
        *EntryPoint = BaseAddress + \
            RtlImageNtHeader(BaseAddress)->OptionalHeader.AddressOfEntryPoint;
    }

    //
    // Notify the debugger of the newly loaded module.
    //

    if (RtlImageDirectoryEntryToData(BaseAddress, TRUE, IMAGE_DIRECTORY_ENTRY_DEBUG,
        &DebugDirectorySize) != NULL) {

#ifdef DEVKIT

        //
        // Insert loaded module into loaded module list
        //

        PIMAGE_NT_HEADERS Hdr = RtlImageNtHeader(ImageBuffer);

        PLDR_DATA_TABLE_ENTRY Ldr = ExAllocatePoolWithTag( 
            sizeof(LDR_DATA_TABLE_ENTRY) + 
            ImageFileName->MaximumLength*sizeof(WCHAR), 'rdlM' );

        if ( Ldr ) {
            RtlZeroMemory( Ldr, sizeof(LDR_DATA_TABLE_ENTRY) );
            Ldr->DllBase = ImageBuffer;
            Ldr->SizeOfImage = Hdr->OptionalHeader.SizeOfImage;
            Ldr->CheckSum = Hdr->OptionalHeader.CheckSum;
            Ldr->LoadedImports = NULL;
            Ldr->LoadCount = 1;
            Ldr->Flags = LDRP_ENTRY_PROCESSED | LDRP_SYSTEM_MAPPED;
            Ldr->FullDllName.Buffer = (PWSTR)((ULONG_PTR)Ldr + sizeof(LDR_DATA_TABLE_ENTRY));
            Ldr->FullDllName.Length = 0;
            Ldr->FullDllName.MaximumLength = ImageFileName->MaximumLength * sizeof(WCHAR);
            RtlAnsiStringToUnicodeString( &Ldr->FullDllName, ImageFileName, FALSE );
            Ldr->BaseDllName = Ldr->FullDllName;

            ExInterlockedInsertTailList( DmGetCurrentDmi()->LoadedModuleList,
                &Ldr->InLoadOrderLinks );
        }

#endif

        DbgLoadImageSymbols(ImageFileName, BaseAddress, (ULONG_PTR)-1);
    }

    //
    // The module is now successfully loaded.
    //

    status = STATUS_SUCCESS;

CleanupAndExit:

    return status;
}

NTSTATUS
MiSnapThunk(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA NameThunk,
    OUT PIMAGE_THUNK_DATA AddrThunk,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN SnapForwarder
    )
/*++

Routine Description:

    This function snaps a thunk using the specified Export Section data.
    If the section data does not support the thunk, then the thunk is
    partially snapped (Dll field is still non-null, but snap address is
    set).

Arguments:

    DllBase - Base of DLL being snapped to.

    ImageBase - Base of image that contains the thunks to snap.

    Thunk - On input, supplies the thunk to snap.  When successfully
        snapped, the function field is set to point to the address in
        the DLL, and the DLL field is set to NULL.

    ExportDirectory - Supplies the Export Section data from a DLL.

    SnapForwarder - determine if the snap is for a forwarder, and therefore
       Address of Data is already setup.

Return Value:

    STATUS_SUCCESS or STATUS_DRIVER_ENTRYPOINT_NOT_FOUND or
        STATUS_DRIVER_ORDINAL_NOT_FOUND

--*/
{
    BOOLEAN Ordinal;
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG Addr;
    USHORT HintIndex;
    LONG High;
    LONG Low;
    LONG Middle;
    LONG Result;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Determine if snap is by name, or by ordinal
    //

    Ordinal = (BOOLEAN)IMAGE_SNAP_BY_ORDINAL(NameThunk->u1.Ordinal);

    if (Ordinal && !SnapForwarder) {

        OrdinalNumber = (USHORT)(IMAGE_ORDINAL(NameThunk->u1.Ordinal) -
                         ExportDirectory->Base);

    } else {

        //
        // Change AddressOfData from an RVA to a VA.
        //

        if (!SnapForwarder) {
            NameThunk->u1.AddressOfData = (ULONG_PTR)ImageBase + NameThunk->u1.AddressOfData;
        }

        //
        // Lookup Name in NameTable
        //

        NameTableBase = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNames);
        NameOrdinalTableBase = (PUSHORT)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNameOrdinals);

        //
        // Before dropping into binary search, see if
        // the hint index results in a successful
        // match. If the hint index is zero, then
        // drop into binary search.
        //

        HintIndex = ((PIMAGE_IMPORT_BY_NAME)NameThunk->u1.AddressOfData)->Hint;
        if ((ULONG)HintIndex < ExportDirectory->NumberOfNames &&
            !strcmp((PSZ)((PIMAGE_IMPORT_BY_NAME)NameThunk->u1.AddressOfData)->Name,
             (PSZ)((PCHAR)DllBase + NameTableBase[HintIndex]))) {
            OrdinalNumber = NameOrdinalTableBase[HintIndex];

        } else {

            //
            // Lookup the import name in the name table using a binary search.
            //

            Low = 0;
            Middle = 0;
            High = ExportDirectory->NumberOfNames - 1;

            while (High >= Low) {

                //
                // Compute the next probe index and compare the import name
                // with the export name entry.
                //

                Middle = (Low + High) >> 1;
                Result = strcmp(&((PIMAGE_IMPORT_BY_NAME)NameThunk->u1.AddressOfData)->Name[0],
                                (PCHAR)((PCHAR)DllBase + NameTableBase[Middle]));

                if (Result < 0) {
                    High = Middle - 1;

                } else if (Result > 0) {
                    Low = Middle + 1;

                } else {
                    break;
                }
            }

            //
            // If the high index is less than the low index, then a matching
            // table entry was not found. Otherwise, get the ordinal number
            // from the ordinal table.
            //

            if (High < Low) {
                return STATUS_DRIVER_ENTRYPOINT_NOT_FOUND;
            } else {
                OrdinalNumber = NameOrdinalTableBase[Middle];
            }
        }
    }

    //
    // If OrdinalNumber is not within the Export Address Table,
    // then DLL does not implement function. Snap to LDRP_BAD_DLL.
    //

    if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions) {
        Status = STATUS_DRIVER_ORDINAL_NOT_FOUND;

    } else {

        Addr = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions);
        *(PULONG_PTR)&AddrThunk->u1.Function = (ULONG_PTR)DllBase + Addr[OrdinalNumber];

        // AddrThunk s/b used from here on.

        Status = STATUS_SUCCESS;

#if DBG
        if ( ((ULONG_PTR)AddrThunk->u1.Function > (ULONG_PTR)ExportDirectory) &&
             ((ULONG_PTR)AddrThunk->u1.Function < ((ULONG_PTR)ExportDirectory + ExportSize)) ) {
            ASSERTMSG( "LDR: forward is not allowed", TRUE );
        }
#endif
    }

    return Status;
}

NTSTATUS
MiSnapTlsDirectory(
    PVOID ImageBase
    )
/*++

Routine Description:

    This routine snaps Thread Local Storage Directory of the caller thread
    (mtldr) to IMAGE_TLS_DIRECTORY of image loaded at specified ImageBase
    address.

Arguments:

    ImageBuffer - Pointer to location where image is loaded in memory

Return Value:

    NT status code

--*/
{
    PBYTE BaseAddress = (PBYTE)ImageBase;
    PIMAGE_TLS_DIRECTORY TlsDirectory;
    ULONG TlsDirectorySize;
    NTSTATUS Status;

    ASSERT( XeLdrImage );

    //
    // We don't have to validate image header if we get this far.
    // MiLoadSystemImage already verified the image format
    //

    TlsDirectory = (PIMAGE_TLS_DIRECTORY)RtlImageDirectoryEntryToData(
        BaseAddress, TRUE, IMAGE_DIRECTORY_ENTRY_TLS, &TlsDirectorySize);

    if ( TlsDirectory ) {
        XeLdrImage->ImageHeader->OptionalHeader.TlsDirectory = (ULONG_PTR)TlsDirectory;
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NOT_FOUND;
    }

    return Status;
}

ULONG
LdrLoadSystemImage(
    IN PVOID ImageBuffer,
    IN PCSTR ImageFileName
    )
/*++

Routine Description:

    This routine loads the image pages from the specified file into the system
    and calls its initialization routine.

Arguments:

    ImageBuffer - Pointer to location where image is loaded in memory

    ImagePathName - Supplies the full path name (including the image name)
                    of the image to load.

Return Value:

    Win32 error code of the load operation
--*/
{
    NTSTATUS Status;
    ULONG (__cdecl *EntryPoint)(PVOID);
    STRING ImageString;

    RtlInitAnsiString( &ImageString, ImageFileName );

    Status = (NTSTATUS)MiLoadSystemImage(
                            ImageBuffer,
                            &ImageString,
                            (PVOID*)&EntryPoint
                            );

    if ( NT_SUCCESS(Status) ) {
        Status = MiSnapTlsDirectory( ImageBuffer );
        if ( !NT_SUCCESS(Status) ) {
            KdPrint(( "LDR: failed to snap TLS directory, image may not run\n" ));
        }
        EntryPoint(XeLdrImage);
    }

    return RtlNtStatusToDosError( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldrlib\mtldrlib.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved

Module Name:

    mtldrlib.c

Abstract:

    This module contains useful routines to access kernel APIs

--*/

#include "mtldrp.h"

__declspec(thread) DWORD ThreadLastError = 0;

//
// Special symbols to mark start and end of Thread Local Storage area.
//

ULONG _tls_index = 0;

#pragma data_seg(".tls")

char _tls_start = 0;

#pragma data_seg(".tls$ZZZ")

char _tls_end = 0;

//
// Start and end sections for Thread Local Storage CallBack Array.
// Actual array is constructed using .CRT$XLA, .CRT$XLC, .CRT$XLL, .CRT$XLU,
// .CRT$XLZ similar to the way global static initializers are done for C++.
//

#pragma data_seg(".CRT$XLA")

PIMAGE_TLS_CALLBACK __xl_a = 0;

#pragma data_seg(".CRT$XLZ")

PIMAGE_TLS_CALLBACK __xl_z = 0;

#pragma data_seg(".rdata$T")

IMAGE_TLS_DIRECTORY _tls_used = {
    (ULONG)(ULONG_PTR)&_tls_start,  // start of tls data
    (ULONG)(ULONG_PTR)&_tls_end,    // end of tls data
    (ULONG)(ULONG_PTR)&_tls_index,  // address of tls_index
    (ULONG)(ULONG_PTR)&__xl_a,      // pointer to call back array
    (ULONG)0,                       // size of tls zero fill
    (ULONG)0                        // characteristics
};

#pragma data_seg()

#pragma comment(linker, "/merge:.CRT=.data")

PLDR_CURRENT_IMAGE XeLdrImage = NULL;

PLARGE_INTEGER
LdrpFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN ULONG Milliseconds
    )
/*++

Routine Description:

    This function translates a Win32 style timeout to an NT relative
    timeout value.

Arguments:

    TimeOut - Returns an initialized NT timeout value that is equivalent
         to the Milliseconds parameter.

    Milliseconds - Supplies the timeout value in milliseconds.  A value
         of -1 indicates indefinite timeout.

Return Value:


    NULL - A value of null should be used to mimic the behavior of the
        specified Milliseconds parameter.

    NON-NULL - Returns the TimeOut value.  The structure is properly
        initialized by this function.

--*/
{
    if ( (LONG) Milliseconds == -1 ) {
        TimeOut->LowPart = 0x0;
        TimeOut->HighPart = 0x80000000;
    } else {
        TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
        TimeOut->QuadPart *= -1;
    }

    return TimeOut;
}

VOID
NTAPI
SetLastError(
    DWORD dwErrCode
    )
/*++

Routine Description:

    This function set the most recent error code and error string in per
    thread storage.  Win32 API functions call this function whenever
    they return a failure indication (e.g.  FALSE, NULL or -1).

    This function is not called by Win32 API function calls that are
    successful, so that if three Win32 API function calls are made, and
    the first one fails and the second two succeed, the error code and
    string stored by the first one are still available after the second
    two succeed.

    Applications can retrieve the values saved by this function using
    GetLastError.  The use of this function is optional, as an
    application need only call if it is interested in knowing the
    specific reason for an API function failure.

    The last error code value is kept in thread local storage so that
    multiple threads do not overwrite each other's values.

Arguments:

    dwErrCode - Specifies the error code to store in per thread storage
        for the current thread.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    ASSERT( KeGetCurrentThread()->TlsData );
    ThreadLastError = dwErrCode;
}

DWORD
NTAPI
GetLastError(
    VOID
    )
/*++

Routine Description:

    This function returns the most recent error code set by a Win32 API
    call.  Applications should call this function immediately after a
    Win32 API call returns a failure indications (e.g.  FALSE, NULL or
    -1) to determine the cause of the failure.

    The last error code value is a per thread field, so that multiple
    threads do not overwrite each other's last error code value.

Arguments:

    None.

Return Value:

    The return value is the most recent error code as set by a Win32 API
    call.

--*/
{
    ASSERT( KeGetCurrentThread()->TlsData );
    return ThreadLastError;
}

BOOL
NTAPI
CloseHandle(
    HANDLE hObject
    )
/*++

Routine Description:

    An open handle to any object can be closed using CloseHandle.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    Closing an open handle to an object causes the handle to become
    invalid and the HandleCount of the associated object to be
    decremented and object retention checks to be performed.  Once the
    last open handle to an object is closed, the object is removed from
    the system.

Arguments:

    hObject - An open handle to an object.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtClose(hObject);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
        return FALSE;
    }
}

HANDLE
NTAPI
CreateEvent(
    PVOID lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    PCOSTR lpName
    )
/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - Ignore

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        pObja = &Obja;
        RtlInitObjectString(&ObjectName, lpName);
        InitializeObjectAttributes(
            &Obja,
            &ObjectName,
            OBJ_OPENIF,
            NULL,
            NULL
            );
    } else {
        pObja = NULL;
    }

    Status = NtCreateEvent(
                &Handle,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
        } else {
            SetLastError(0);
        }
        return Handle;
    } else {
        SetLastError(RtlNtStatusToDosError(Status));
        return NULL;
    }
}

BOOL
SetEvent(
    HANDLE hEvent
    )
/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
    } else {
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }
}

BOOL
ResetEvent(
    HANDLE hEvent
    )
/*++

Routine Description:

    The state of an event is set to the Not-Signaled state (FALSE) using
    the ClearEvent function.

    Once the event attains a state of Not-Signaled, any threads which
    wait on the event block, awaiting the event to become Signaled.  The
    reset event service sets the event count to zero for the state of
    the event.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtClearEvent(hEvent);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
    } else {
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }
}

HLOCAL
WINAPI
LocalAlloc(
    UINT uFlags,
    SIZE_T uBytes
    )
/*++

Routine Description:

    The LocalAlloc function allocates the specified number of bytes from the heap.
    In the linear Win32 API environment, there is no difference between the
    local heap and the global heap.

    NOTE: Moveable memory is not implemented. LMEM_FIXED is always on.

Arguments:

    UINT uFlags - allocation attributes
    UINT uBytes - number of bytes to allocate

Return Value:

    Returns pointer to newly allocated memory or NULL on failure.

--*/
{
    PVOID p = NULL;
    SIZE_T RegionSize = uBytes;

    NTSTATUS Status = NtAllocateVirtualMemory( &p, 0, &RegionSize, 
        MEM_COMMIT | MEM_NOZERO, PAGE_EXECUTE_READWRITE );

    if ( NT_SUCCESS(Status) )  {
        if ( uFlags & LMEM_ZEROINIT ) {
            RtlZeroMemory( p, uBytes );
        }
    } else {
        p = NULL;
        SetLastError( RtlNtStatusToDosError(Status) );
    }

    return (HLOCAL)p;
}

HLOCAL
WINAPI
LocalFree(
    HLOCAL hMem
    )
/*++

Routine Description:

    The LocalFree function frees the specified local memory object and
    invalidates its handle. Also implements GlobalFree().

Arguments:

    hMem - handle of local memory object

Return Value:

    If the function succeeds, the return value is NULL. If the function fails,
    the return value is equal to the handle of the local memory object.

--*/
{
    SIZE_T s = 0;
    PVOID p = (PVOID)hMem;

    if ( !p ) {
        return NULL;
    }

    NtFreeVirtualMemory( &p, &s, MEM_RELEASE );
    return NULL;
}

DWORD
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return WaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;

    pTimeOut = LdrpFormatTimeOut(&TimeOut,dwMilliseconds);
rewait:
    Status = NtWaitForSingleObjectEx(hHandle,
                                     UserMode,
                                     (BOOLEAN)bAlertable,
                                     pTimeOut);
    if ( !NT_SUCCESS(Status) ) {
        SetLastError(RtlNtStatusToDosError(Status));
        Status = (NTSTATUS)0xffffffff;
        }
    else {
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
        }
    return (DWORD)Status;
}

DWORD
WINAPI
WaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )
/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    HANDLE HandleArray[MAXIMUM_WAIT_OBJECTS];

    if (nCount > MAXIMUM_WAIT_OBJECTS) {
        SetLastError(RtlNtStatusToDosError(STATUS_INVALID_PARAMETER));
        return (DWORD)0xffffffff;
    }

    RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

    pTimeOut = LdrpFormatTimeOut(&TimeOut,dwMilliseconds);
rewait:
    Status = NtWaitForMultipleObjectsEx(
                 (CHAR)nCount,
                 HandleArray,
                 bWaitAll ? WaitAll : WaitAny,
                 UserMode,
                 (BOOLEAN)bAlertable,
                 pTimeOut
                 );
    if ( !NT_SUCCESS(Status) ) {
        SetLastError(RtlNtStatusToDosError(Status));
        Status = (NTSTATUS)0xffffffff;
    } else {
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
        }
    }

    return (DWORD)Status;
}

VOID
Sleep(
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the Sleep function.

    The Sleep function causes the current thread to enter a
    waiting state until the specified interval of time has passed.

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    None.

--*/

{
    SleepEx(dwMilliseconds,FALSE);
}

DWORD
APIENTRY
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the SleepEx function.

    The SleepEx function causes the current thread to enter a waiting
    state until the specified interval of time has passed.

    If the bAlertable parameter is FALSE, the only way the SleepEx
    returns is when the specified time interval has passed.  If the
    bAlertable parameter is TRUE, then the SleepEx can return due to the
    expiration of the time interval (return value of 0), or because an
    I/O completion callback terminated the SleepEx early (return value
    of WAIT_IO_COMPLETION).

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  A timeout value of -1 specifies an infinite
        timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        SleepEx may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    0 - The SleepEx terminated due to expiration of the time interval.

    WAIT_IO_COMPLETION - The SleepEx terminated due to one or more I/O
        completion callbacks.

--*/
{
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    NTSTATUS Status;

    pTimeOut = LdrpFormatTimeOut(&TimeOut,dwMilliseconds);
    if (pTimeOut == NULL) {
        //
        // If Sleep( -1 ) then delay for the longest possible integer
        // relative to now.
        //

        TimeOut.LowPart = 0x0;
        TimeOut.HighPart = 0x80000000;
        pTimeOut = &TimeOut;
        }

rewait:
    Status = KeDelayExecutionThread(
                UserMode,
                (BOOLEAN)bAlertable,
                pTimeOut
                );
    if ( bAlertable && Status == STATUS_ALERTED ) {
        goto rewait;
        }
    return Status == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

VOID
MtLdrThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )
/*++

Routine Description:

    Called by the kernel on thread startup. We set up the default exception handler
    and a data structure to keep track of TLS data.

Arguments:

    StartRoutine - address the thread should be started at.

    StartContext - an LPVOID pointer passed in to CreateThread to pass on to the thread.

Return Value:

    None.

--*/
{
    DWORD dwExitCode = 0;
    PULONG TlsData;
    DWORD RawDataSize;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // At the moment we don't wrap thread start routine in SEH.  We will let
    // the debugger catches second-chance exception (if any).  Debug will be
    // easier this way
    //
    // If you don't like this, remove the comment below
    //

    //try {

        //
        // Need to set up the TLS data
        //

        ASSERT(KeGetCurrentThread()->TlsData);

#if DBG
        //
        // First make sure the TLS data is where we think it should be
        //
        ASSERT((ULONG_PTR)KeGetCurrentThread()->TlsData -
            (ULONG_PTR)KeGetCurrentTlsDataTop() == *((PULONG)_tls_used.AddressOfIndex) * 4);
#endif

        //
        // Need to fill the first slot with a pointer to the remainder
        //
        TlsData = (PULONG)KeGetCurrentThread()->TlsData + 1;
        TlsData[-1] = (ULONG_PTR)TlsData;

        //
        // Ensure 16-byte alignment
        //
        ASSERT(((ULONG_PTR)TlsData & 15) == 0);

        RawDataSize = _tls_used.EndAddressOfRawData - _tls_used.StartAddressOfRawData;

        RtlCopyMemory(TlsData, (PVOID)_tls_used.StartAddressOfRawData,
            RawDataSize);

        if (_tls_used.SizeOfZeroFill != 0) {
            RtlZeroMemory((PBYTE)TlsData + RawDataSize, _tls_used.SizeOfZeroFill);
        }

        dwExitCode = (*(LPTHREAD_START_ROUTINE)StartRoutine)(StartContext);
    //} except (EXCEPTION_EXECUTE_HANDLER) {
        //ASSERT(FALSE);
    //}

    PsTerminateSystemThread(dwExitCode);
}

HANDLE
WINAPI
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )
/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    calling process using CreateThread.

    Creating a thread causes a new thread of execution to begin in the address
    space of the current process. The thread has access to all objects opened
    by the process.

    The thread begins executing at the address specified by the StartAddress
    parameter. If the thread returns from this procedure, the results are
    un-specified.

    The thread remains in the system until it has terminated and
    all handles to the thread
    have been closed through a call to CloseHandle.

    When a thread terminates, it attains a state of signaled satisfying all
    waits on the object.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for thread objects:

        - THREAD_QUERY_INFORMATION - This access is required to read
          certain information from the thread object.

        - SYNCHRONIZE - This access is required to wait on a thread
          object.

        - THREAD_GET_CONTEXT - This access is required to read the
          context of a thread using GetThreadContext.

        - THREAD_SET_CONTEXT - This access is required to write the
          context of a thread using SetThreadContext.

        - THREAD_SUSPEND_RESUME - This access is required to suspend or
          resume a thread using SuspendThread or ResumeThread.

        - THREAD_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for a thread object.

Arguments:

    hProcess - Supplies the handle to the process in which the thread is
        to be create in.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    dwStackSize - Supplies the size in bytes of the stack for the new thread.
        A value of zero specifies that the thread's stack size should be
        the same size as the stack size of the first thread in the process.
        This size is specified in the application's executable file.

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns and that
        accepts a single 32-bit pointer argument.

    lpParameter - Supplies a single parameter value passed to the thread.

    dwCreationFlags - Supplies additional flags that control the creation
        of the thread.

        dwCreationFlags Flags:

        CREATE_SUSPENDED - The thread is created in a suspended state.
            The creator can resume this thread using ResumeThread.
            Until this is done, the thread will not begin execution.

    lpThreadId - Returns the thread identifier of the thread.  The
        thread ID is valid until the thread terminates.

Return Value:

    NON-NULL - Returns a handle to the new thread.  The handle has full
        access to the new thread and may be used in any API that
        requires a handle to a thread object.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    HANDLE Handle;
    SIZE_T TlsSize;

    if (dwStackSize == 0) {
        dwStackSize = XeLdrImage->ImageHeader->OptionalHeader.SizeOfStackCommit;
    }

    TlsSize = (_tls_used.EndAddressOfRawData - _tls_used.StartAddressOfRawData) \
        + _tls_used.SizeOfZeroFill;

    //
    // The base of the TLS section must be 16-byte aligned.  We know
    // that fs:StackBase is 16-byte aligned, ensuring that TlsSize is
    // 16-byte aligned is sufficient
    //

    TlsSize = (TlsSize + 15) & ~15;

    //
    // Add four bytes for the index pointer
    //

    TlsSize += 4;

    Status = PsCreateSystemThreadEx(
                &Handle,
                0,
                dwStackSize,
                TlsSize,
                (PHANDLE)lpThreadId,
                (PKSTART_ROUTINE)lpStartAddress,
                lpParameter,
                (BOOLEAN)((dwCreationFlags & CREATE_SUSPENDED) ? TRUE : FALSE),
                FALSE,
                (PKSYSTEM_ROUTINE)MtLdrThreadStartup
                );

    if (!NT_SUCCESS(Status)) {
        SetLastError( RtlNtStatusToDosError(Status) );
        return NULL;
    }

    return Handle;
}

VOID
APIENTRY
OutputDebugStringA(
    IN LPCSTR lpOutputString
    )
/*++

Routine Description:

    This function allows an application to send a string to its debugger
    for display.  If the application is not being debugged, but the
    system debugger is active, the system debugger displays the string.
    Otherwise, this function has no effect.

Arguments:

    lpOutputString - Supplies the address of the debug string to be sent
        to the debugger.

Return Value:

    None.

--*/
{
    DbgPrint( (PSTR)lpOutputString );
}

DWORD
APIENTRY
GetCurrentThreadId(
    VOID
    )
/*++

Routine Description:

    The thread ID of the current thread may be retrieved using
    GetCurrentThreadId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the thread ID of the currently
    executing thread.  The return value may be used to identify a thread
    in the system.

--*/
{
    return HandleToUlong(PsGetCurrentThreadId());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldr\startup.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    startup.c

Abstract:

    This module contains routine to startup CRT and mtldr system.

--*/

#include "mtldrp.h"

#if __cplusplus
extern "C" {
#endif

int __cdecl main(int, char **, char **);
VOID WINAPI DbgBreakPoint( VOID );

#if __cplusplus
}
#endif

LONG
WINAPI
MtLdrUnhandledException(
    PEXCEPTION_POINTERS p
    )
{
    DbgPrint( "MTLDR: unhandled exception %p\n", p );
    DbgBreakPoint();
    return EXCEPTION_EXECUTE_HANDLER;
}

DWORD
WINAPI
MtLdrMainThread(
    PVOID KernelLoaderBlock
    )
/*++

Routine Description:

    This is a main entry point of boot-loader that call regular "C" main
    function.

Arguments:

    KernelLoaderBlock - The loader block required by LdrLoadSystemImage

Return Value:

    Always 0 (unused)

--*/
{
    UNREFERENCED_PARAMETER( KernelLoaderBlock );

    //__try {
        main( 0, NULL, NULL );
    //} __except( MtLdrUnhandledException(GetExceptionInformation()) ) {
    //}

    return 0;
}

BOOL
InitProcess(
    PVOID KernelLoaderBlock
    )
{
    HANDLE ThreadHandle;

    //
    // Initialize system loader and all TLS related stuff
    //

    LdrInitializeSystemLoader( KernelLoaderBlock );

    //
    // We have to create separate thread to execute any code that uses
    // Winsock APIs.  This is necessary because Winsock APIs rely on TLS
    // data to be initialized correctly and TLS data only gets initialized
    // in thread created by CreateThread (we are now running in the
    // context of kernel thread)
    //

    ThreadHandle = CreateThread( NULL, 0,
        (LPTHREAD_START_ROUTINE)MtLdrMainThread, KernelLoaderBlock, 0, NULL );

    if ( !ThreadHandle ) {
        DbgPrint( "MTLDR: unable to create main thread\n" );
    } else {
        CloseHandle( ThreadHandle );
    }

    return TRUE;
}

__declspec( naked )
VOID
__cdecl
mainCRTStartup(
    PVOID KernelLoaderBlock
    )
/*++

Routine Description:

    This is a absolute entry point of boot-loader. We need to define it here
    instead of using the version in XTL because we can't use XTL.  The code
    has to be written so that it contains the pattern at specific offset that
    imagebld looking for

Arguments:

    KernelLoaderBlock - The loader block required by LdrLoadSystemImage

Return Value:

    Always TRUE

--*/
{
    //
    // Use naked function and in-line assembly so that it contains particular
    // pattern at particular offset that imagebld is looking for
    //

    __asm {
        push    ebp
        mov     ebp, esp
        push    ecx
        xchg    ecx, ecx
        xchg    ecx, ecx
        xchg    ecx, ecx
        xchg    ecx, ecx
        nop
        mov     dword ptr [ebp-4], 0x0ff00110
    }

    InitProcess( KernelLoaderBlock );

    __asm {
        leave
        ret     0
    }
}

#define chartodigit(c)    ((c) >= '0' && (c) <= '9' ? (c) - '0' : -1)

long __cdecl atol(const CHAR *nptr)
{
    int c;              // current char
    long total;         // current total
    int sign;           // if '-', then negative, otherwise positive

    while ( *nptr == ' ' || *nptr == '\t' ) {
        ++nptr;
    }

    c = (int)(UCHAR)*nptr++;
    sign = c;           // save sign indication

    if (c == '-' || c == '+') {
        c = (int)(UCHAR)*nptr++;
    }

    total = 0;

    while ( (c = chartodigit(c)) != -1 ) {
        total = 10 * total + c; // accumulate digit
        c = (UCHAR)*nptr++;     // get next char
    }

    if (sign == '-') {
        return -total;
    } else {
        return total;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr2\main.c ===
#include "xtl.h"
#include "mfgtest.h"


void __cdecl main()
{
    HANDLE h;
    DWORD size;
    PBYTE buf;
    DWORD read;


    h = CreateFile ("D:\\FOO.XBE", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (h != INVALID_HANDLE_VALUE) {

        size = GetFileSize (h, NULL);
        buf = malloc (size * sizeof (BYTE));

        if (buf) {

            if (ReadFile (h, buf, size, &read, NULL) && read == size) {

                CloseHandle (h);
                if (MfgTestCopyImageToDrive ("Z:\\BAR.XBE", buf, size)) {

                    MfgTestReboot ("Z:\\BAR.XBE");
                }

            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr2\libsrc\mfgtest.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    mfgtest.c

Abstract:

    Test routines used by the Xbox Manufacturing Test code.

Author:

    Marc R. Whitten (marcw)  02-July-2001

Revision History:

--*/

#include <ntos.h>
#include <xtl.h>
#include <xboxp.h>
#include "xlaunch.h"
#include "xapip.h"
#include "dm.h"

#include "mfgtest.h"


static const OBJECT_STRING g_ZDosDevicePrefix =  CONSTANT_OBJECT_STRING(OTEXT("\\??\\Z:"));

extern PLAUNCH_DATA_PAGE *LaunchDataPage;

BOOL
WINAPI
MfgTestCopyImageToDrive (
    LPCSTR Name,
    PBYTE ImageBuffer,
    SIZE_T Size
    )
{

    //
    // Simple routine that dumps memory to the hard drive.
    //
    HANDLE h;
    DWORD bytesWritten;


    //
    // Mount the utility drive so that we have a place to store the XBE.
    //
    if (!XMountUtilityDrive(TRUE)) {
        XDBGWRN ("MfgTest", "Unable to mount utility drive.");
    }

    //
    // Create the new file and copy over the provided buffer.
    //
    h = CreateFile (Name, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (h == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (!WriteFile (h, ImageBuffer, Size, &bytesWritten, NULL)) {
        CloseHandle (h);
        return FALSE;
    }

    CloseHandle (h);

    return TRUE;
}

BOOL
MfgSaveLaunchPathAndReboot (
    PSTR Path
    )
/*
** This is based upon the XWriteTitleInfo* Routines in XAPI K32\LAUNCH.C. It is modified to work correctly in
** the slightly cheating mfg case.
*/

{

    PSTR launchPath;

    //
    // Make sure the LaunchDataPage is allocated and persisted.
    //
    if (NULL == *LaunchDataPage) {
        *LaunchDataPage = MmAllocateContiguousMemory(PAGE_SIZE);
    }

    if (NULL == *LaunchDataPage) {
        return FALSE;
    }

    MmPersistContiguousMemory(*LaunchDataPage, PAGE_SIZE, TRUE);
    RtlZeroMemory(*LaunchDataPage, PAGE_SIZE);


    launchPath = ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath;

    //
    // The Manufacturing test loader doesn't do anything with launch params.
    // Just zero this stuff out.
    //
    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwLaunchDataType = LDT_NONE;
    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwTitleId = 0;

    //
    // Persist the launch path to the new executable.
    //
    lstrcpynA (launchPath, Path, ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - 1);

    //
    // Reboot the machine.
    //
    #ifdef DEVKIT
        //
        // Notify the debugger that we're about to reboot and then reboot
        //
        DmTell(DMTELL_REBOOT, NULL);
    #endif

    HalReturnToFirmware(HalQuickRebootRoutine);
}



BOOL
WINAPI
MfgTestReboot (
    LPCSTR Name
    )
{

    OCHAR drivePath[MAX_PATH];
    OBJECT_ATTRIBUTES obja;
    NTSTATUS status;
    HANDLE linkHandle;
    OBJECT_STRING linkTarget;
    OCHAR linkBuffer[MAX_PATH * 2];

    //
    // Preserve mapping to cache partition, so we can reboot to the XBE we stuffed in there.
    //
    InitializeObjectAttributes (&obja, (POBJECT_STRING) &g_ZDosDevicePrefix, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenSymbolicLinkObject (&linkHandle, &obja);

    if (NT_SUCCESS(status)) {

        linkTarget.Buffer = linkBuffer;
        linkTarget.Length = 0;
        linkTarget.MaximumLength = sizeof (linkBuffer);

        status = NtQuerySymbolicLinkObject (linkHandle, &linkTarget, NULL);
        NtClose (linkHandle);
    }

    if (NT_SUCCESS(status)) {

        lstrcpynA (drivePath, linkBuffer, min(ARRAYSIZE(drivePath), (linkTarget.Length / sizeof(CHAR)) + 1));
        lstrcatA(drivePath,&Name[2]);
    }


    //
    // Write the necessary reboot information and reboot the machine.
    //
    return NT_SUCCESS(status) ? MfgSaveLaunchPathAndReboot (drivePath) : FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\netpeer\client\peerclient.cpp ===
//
//	peerclient.cpp
//		Client side of peer-to-peer ethernet bit error rate test.
//		Broadcast address and 'send data' message to server
//		Receive data from server
//
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>


const WORD  BROADCAST_PORT	= 10983;
const WORD  DATA_PORT		= 10984;
const INT	DATA_PACKETS	= 256;		// Number of packets to sent
const INT	DATA_BYTES		= 1024;		// Packet size


// Message IDs
enum {
	MSG_SEND_DATA,		// Server sends data
	MSG_QUIT			// Server quits
};


// Message payload
struct PEER_MESSAGE {
	BYTE Msg;
	XNADDR xnAddr;
};

// Globals
HANDLE ghGamePads[4];
// BOOL gbPause = FALSE;
BOOL gbQuit = FALSE;


VOID
InitGamePads() {
	DWORD i;
	XDEVICE_PREALLOC_TYPE xdpt;

	// Initialize gamepads
	xdpt.DeviceType = XDEVICE_TYPE_GAMEPAD;
	xdpt.dwPreallocCount = 4;

	XInitDevices(1, &xdpt);

	// Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    // Open the devices
	for(i = 0; i < 4; i++){
		// Initialize game pad array
		ghGamePads[i] = NULL;

        if( dwDeviceMask & (1<<i) ) {
            // Get a handle to the device
            ghGamePads[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );
			// xDebugStringA("Added Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
        }
	}
}


VOID
ReadGamePads() {
	DWORD dwInsertions, dwRemovals;
	DWORD b, i, Buttons = 0;
	XINPUT_STATE State;
	BOOL AnalogButtons[8];

	// Get gamepad insertions and removals
	XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals);
	for(i = 0; i < 4; i++) {
		// Handle removed devices.
		if(dwRemovals & (1<<i) ) {
			XInputClose( ghGamePads[i]);
			// xDebugStringA("HD SIT: Removed Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
			ghGamePads[i] = NULL;
		}

		// Handle inserted devices
		if(dwInsertions & (1<<i)) {
			ghGamePads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL);
			// xDebugStringA("HD SIT: Added Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
		}
	}

	// Init button variables
	Buttons = 0;
	for(b = 0; b < 8; b++) {
		AnalogButtons[b] = FALSE;
	}

	// Get button presses
	for(i = 0; i < 4; i++) {
		if(ghGamePads[i] != NULL) {
			XInputGetState(ghGamePads[i], &State);

			// Digital buttons
			Buttons |= State.Gamepad.wButtons;

			// Analog buttons (threshold = 25/256)
			for(b = 0; b < 8; b++) {
				AnalogButtons[b] |= (State.Gamepad.bAnalogButtons[b] > 25);
			}
		}
	}

	// Check button presses
	// Back button pauses app
	/*
	if((Buttons & XINPUT_GAMEPAD_BACK) > 0) {
		if(!gbPause) {
			xDebugStringA("HD SIT: Application Paused\n");
			gbPause = TRUE;
		}
	}

	// Start button unpauses app
	if((Buttons & XINPUT_GAMEPAD_START) > 0 ) {
		if(gbPause) {
			xDebugStringA("HD SIT: Application NOT Paused\n");
			gbPause = FALSE;
		}
	}
	*/

	// Both triggers plus Black button quits app (from Samples)
	if(AnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] & AnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] & AnalogButtons[XINPUT_GAMEPAD_BLACK]) {
		if(!gbQuit) {
			// xDebugStringA("HD SIT: Application Quiting...\n");
			gbQuit = TRUE;
		}
	}
}


VOID
CloseGamePads() {
	DWORD i;

	for(i = 0; i < 4; i++ ) {
		if(ghGamePads[i] != NULL) {
			XInputClose(ghGamePads[i]);
			// xDebugStringA("HD SIT: Removed Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
			ghGamePads[i] = NULL;
		}
	}
}


VOID 
PeerClientStartTest(HANDLE LogHandle) {
	DWORD dwStatus, dwLastTickCount, dwLogTime;
	XNetStartupParams xnsp;
	INT Err, Bytes,i, j, p, Errors;
	WSADATA wsaData;
	CHAR cAddr[20];
	SOCKET sBroadcast, sData;
	SOCKADDR_IN saBroadcast, saData;
	BOOL bBroadcast;
	PEER_MESSAGE ClientMsg;
	LARGE_INTEGER StartTime, EndTime,  Frequency;
	LARGE_INTEGER TotalTime, TotalBytes, TotalReps;
	DOUBLE Rate;

	UCHAR *Data, *cPtr;

	xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "PeerClient");
	QueryPerformanceFrequency(&Frequency);

	// Allocate receive data array
	xSetFunctionName(LogHandle, "GlobalAlloc");
	Data = (UCHAR *)GlobalAlloc(GPTR, DATA_PACKETS*DATA_BYTES);
	if(Data == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%d bytes) FAILED Returned %d", DATA_PACKETS*DATA_BYTES, GetLastError());
		return;
	}

	// Initialize gamepads
	InitGamePads();
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Press both triggers and the 'Black' button to quit the application");

	// Get link status
	xSetFunctionName(LogHandle, "XNetGetEthernetLinkStatus");
	dwStatus = XNetGetEthernetLinkStatus();
		if(dwStatus == 0) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "No Ethernet cable is connected");
	}
	if(dwStatus & XNET_ETHERNET_LINK_ACTIVE) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet cable is connected and active");
	}
	if(dwStatus & XNET_ETHERNET_LINK_100MBPS) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet link is set to 100 Mbps");
	}
	if(dwStatus & XNET_ETHERNET_LINK_10MBPS) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet link is set to 10 Mbps");
	}
	if(dwStatus & XNET_ETHERNET_LINK_FULL_DUPLEX) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet link is in full duplex mode");
	}
	if(dwStatus & XNET_ETHERNET_LINK_HALF_DUPLEX) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet link is in half duplex mode");
	}

	// Init XNet
	xSetFunctionName(LogHandle, "XNetStartup");
	memset(&xnsp, 0, sizeof(xnsp));
	xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
	xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
	Err = XNetStartup(&xnsp);
	if(Err != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "XNetStartup() FAILED Returned %d", Err);
		return;
	}

	// Init Winsock
	Err = WSAStartup(MAKEWORD(2,2), &wsaData);
	if(Err != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WSAStartup() FAILED Returned %d", Err);
		return;
	}

	// Get local address
	xSetFunctionName(LogHandle, "XNetGetTitleXnAddr");
	do {
		dwStatus = XNetGetTitleXnAddr(&ClientMsg.xnAddr);
	} while(dwStatus == XNET_GET_XNADDR_PENDING);
	XNetInAddrToString(ClientMsg.xnAddr.ina, cAddr, sizeof(cAddr));
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Client Address: %s", cAddr);

	// Broadcast socket
	xSetFunctionName(LogHandle, "Broadcast Socket");
	sBroadcast = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if(sBroadcast == INVALID_SOCKET) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "socket(sBroadcast) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}

	// Set broadcast mode
	bBroadcast = TRUE;
	Err = setsockopt(sBroadcast, SOL_SOCKET, SO_BROADCAST, (const char *)&bBroadcast, sizeof(bBroadcast));
	if(Err == SOCKET_ERROR) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "setsockopt(SO_BROADCAST) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}

	// Broadcast address
	ZeroMemory(&saBroadcast, sizeof(SOCKADDR_IN));
	saBroadcast.sin_family = AF_INET;
	saBroadcast.sin_addr.s_addr = INADDR_BROADCAST;
	saBroadcast.sin_port = htons(BROADCAST_PORT);

	// Data socket
	xSetFunctionName(LogHandle, "Data Socket");
	sData = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if(sData == INVALID_SOCKET) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "socket(sData) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}

	// Bind data address
	ZeroMemory(&saData, sizeof(SOCKADDR_IN));
	saData.sin_family = AF_INET;
	saData.sin_addr.s_addr = INADDR_ANY;
	saData.sin_port = htons(DATA_PORT);
	Err = bind(sData, (const sockaddr *)&saData, sizeof(SOCKADDR_IN));
	if(Err == SOCKET_ERROR) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "bind(INADDR_ANY) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}

	// Get LogTime from testini.ini
	xSetFunctionName(LogHandle, "Receive Data");
	dwLogTime = (DWORD)GetProfileIntA("peerclient", "LogMinutes", 1);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Logging every %d minutes", dwLogTime);
	dwLogTime *= 60*1000;	// ms
	TotalTime.QuadPart = 0;
	TotalBytes.QuadPart = 0;
	TotalReps.QuadPart = 0;
	dwLastTickCount = GetTickCount();
	Errors = 0;

	while(!gbQuit) {
		// Send 'send data' message to server
		ClientMsg.Msg = MSG_SEND_DATA;
		Err = sendto(sBroadcast, (const char *)&ClientMsg, sizeof(ClientMsg), 0, 
						(const sockaddr *)&saBroadcast, sizeof(SOCKADDR_IN));

		/*
		if(Err = SOCKET_ERROR) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "sendto(BROADCAST_PORT) FAILED WSALastError = %d", WSAGetLastError ());
			return;
		}
		*/
		
		// Receive test data
		xSetFunctionName(LogHandle, "Receive Data");
		QueryPerformanceCounter(&StartTime);
		for(p = 0; p < DATA_PACKETS; p++) {
			Bytes = recv(sData, (char *)(Data + p*DATA_BYTES), DATA_BYTES, 0);
			if(Bytes != DATA_BYTES) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "recv(%d) Rep %I64d FAILED WSALastError = %d", 
					p, TotalReps.QuadPart, WSAGetLastError());
				return;
			}
			TotalBytes.QuadPart += Bytes;
		}
		QueryPerformanceCounter(&EndTime);
		TotalTime.QuadPart += (EndTime.QuadPart - StartTime.QuadPart);

		// Check/clear data
		cPtr = Data;
		for(i = 0; i < DATA_PACKETS; i++) {
			for(j = 0; j < DATA_BYTES; j++) {
				if(*cPtr != i) {
					Errors++;
				}
				*cPtr = 0;
				cPtr++;
			}
		}

		if(GetTickCount() - dwLastTickCount > dwLogTime) {
			// Reset last tick count
			dwLastTickCount = GetTickCount();

			// Log data rate and errors
			Rate = (DOUBLE)TotalBytes.QuadPart;
			Rate *= 8.0;	// bit
			Rate /= (DOUBLE)TotalTime.QuadPart;
			Rate *= (DOUBLE)Frequency.QuadPart;
			Rate /= 1024.0;	// K bits
			Rate /= 1024.0;	// M bits
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Received Data Rate: %f Mbps Total Reps = %I64d Total Errors = %d ",
				Rate, TotalReps.QuadPart, Errors);

		}
		// Count reps
		TotalReps.QuadPart++;

		// Check for button presses
		ReadGamePads();
	}

	// Log data rate and errors
	Rate = (DOUBLE)TotalBytes.QuadPart;
	Rate *= 8.0;	// bit
	Rate /= (DOUBLE)TotalTime.QuadPart;
	Rate *= (DOUBLE)Frequency.QuadPart;
	Rate /= 1024.0;	// K bits
	Rate /= 1024.0;	// M bits
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Received Data Rate: %f Mbps Total Reps = %I64d Total Errors = %d ",
		Rate, TotalReps.QuadPart, Errors);

	// Send 'quit' message to server
	xSetFunctionName(LogHandle, "Quit");
	ClientMsg.Msg = MSG_QUIT;
	Err = sendto(sBroadcast, (const char *)&ClientMsg, sizeof(ClientMsg), 0, 
					(const sockaddr *)&saBroadcast, sizeof(SOCKADDR_IN));
	/*
	if(Err = SOCKET_ERROR) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "sendto(BROADCAST_PORT) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}
	*/

	// Check data
	// Shut down network
	xSetFunctionName(LogHandle, "Shut Down");
	closesocket(sData);
	closesocket(sBroadcast);
	WSACleanup();
	XNetCleanup();
	CloseGamePads();
	GlobalFree(Data);
}


VOID
PeerClientEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	HANDLE LogHandle;

	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);

	// xlog
	LogHandle = xCreateLog_A("t:\\peerclient.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "PeerClient: couldn't create log (%s)", WinErrorSymbolicName(GetLastError()));
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "PeerClient: End - Waiting for reboot...");
		Sleep(INFINITE);
    }

	gbConsoleOut = TRUE;

	// Start Test
	PeerClientStartTest(LogHandle);

	// End Test
	PeerClientEndTest();

	// xlog
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "PeerClient: End - Waiting for reboot...");
	xCloseLog(LogHandle);

	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( peerclient )
#pragma data_seg()

BEGIN_EXPORT_TABLE( peerclient )
    EXPORT_TABLE_ENTRY( "StartTest", PeerClientStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", PeerClientEndTest )
END_EXPORT_TABLE( peerclient )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\regress\regress437\Regress437.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    regress437.cpp

Abstract:

    test app that performs a power cycle

	Tests the feature where the SMC can control the poweroff time of the
	system.

--*/


///////////////////////////////////////////////////////
/*
	So heres how you program the off time.  
	I added a new write register 0x22.  
	The default value is 25 (25 * 20ms = 500ms.) 
	The time the system will be off when you use SMC reg 0x2  
	to cycle power will be the value in reg 0x22 multiplied 
	by 20ms.  After the system cycles power the value in the register 
	will be reset back to the default of 25 (500ms)  Im assuming that 
	reg 0x2 and the power switch wont be used at the same time.  If they 
	are, the timing could be screwy.  Note: Since I decrement then compare 
	in the code if you write the value of zero to the register it will 
	turn into -1 and the time off will be very long.
*/ 



#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>
#include <stdlib.h>
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>
#include <fscache.h>
#include <xbinput.h>



#define FILENAME "z:\\resets.txt"



// SMC Functions

extern "C"
    {
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

DWORD WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }




void DebugPrint(LPSTR format, ...)
    {
    va_list args;
    va_start(args, format);

    CHAR szBuffer[1024];

    sprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }


// performs SMC power cycle for the
// specified amount of milliseconds (minimum of 20 ms)
//
VOID SMCPowerCycle( DWORD milliseconds )
{
	if( milliseconds < 60 )
		milliseconds = 60;

	WriteSMC( 0x22, (UCHAR)(milliseconds / 20) );
	WriteSMC( 0x02, 0x40 );
}


void Menu()
{
	printf( "   X button - sleep for 60 ms\n");
	printf( "   Y button - sleep for 100 ms\n");
	printf( "   A button - sleep for 500 ms\n");
	printf( "   B button - sleep for 1s\n" );
	printf( "   Black button - sleep for 5s\n" );
	printf( "   White button - sleep for default time ( 500ms )\n");
}



void __cdecl main()
{
	XBGAMEPAD* pGamepads = NULL;
	

	
	//DebugBreak();


	// create console
	xCreateConsole( NULL );
	xSetBackgroundImage( NULL );
	xSetFont( 15.0, 18.0, NULL );


	// print menu
	Menu();

	// create gamepads
	XInitDevices(0, NULL);
	XBInput_CreateGamepads( &pGamepads );

	// poll for gamepad input
	//    X button - sleep for 20 ms
	//    Y button - sleep for 100 ms
	//    A button - sleep for 500 ms
	//    B button - sleep for 1s
	//    Black button - sleep for 5s
	//    White button - sleep for default time ( 500ms )

	while ( true )
	{
		XBInput_GetInput( pGamepads );
		for( int i = 0; i < 4; i++ )
		{
			if( pGamepads[i].hDevice )
			{
				if(  pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
				{
					//sleep for 25 ms
					SMCPowerCycle( 20 );
				}
				if (pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
				{
					//sleep for 100 ms
					SMCPowerCycle( 100 );
				}
				if (pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
				{
					//sleep for 500 ms
					SMCPowerCycle( 500 );
				}
				if (pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
				{
					//sleep for 1s
					SMCPowerCycle( 1000 );
				}
				if (pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ] )
				{
					// sleep for 5s
					SMCPowerCycle( 5000 );
				}

				if (pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_WHITE ] )
				{
					// sleep for default time (500ms)
					WriteSMC( 0x02, 0x40 );
				}


				
			}
		}
		
		Sleep( 50 );
	}



	
	

	Sleep( INFINITE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mu\mu.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mu.cpp

Abstract:

    Continuously read and write all attached MUs

Environment:

    Xbox

Revision History:

--*/
#include <stdio.h>
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xlogconio.h>


#if !defined(HARNESSLIB)
BOOL g_RunForever = TRUE;
BOOL g_Pause = FALSE;
#else
extern BOOL g_RunForever;
extern BOOL g_Pause;
#endif

// Globals
CHAR gMUs[4][2];			// Array of MU Drive Letters [Port][Slot]
CHAR *gWData, *gRData;		// Read and Write Buffers
SIZE_T gFileSize;			// Size of read and write buffers


VOID
InitWData(HANDLE LogHandle) {
	UCHAR Value;
	int RandomValue;
	SIZE_T i;
	
	RandomValue = GetProfileInt(TEXT("mu"), TEXT("RandomValue"), 1);
	Value = (CHAR)GetProfileInt(TEXT("mu"), TEXT("Value"), 0);

	// Initialize write buffer
	if(RandomValue == 1) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Data Value = RANDOM");
		for(i = 0; i < gFileSize; i++) {
			gWData[i] = (CHAR)rand()%256;
		}
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Data Value = %#x", Value);
		for(i = 0; i < gFileSize; i++) {
			gWData[i] = Value;
		}
	}
}


VOID
DeletAllFiles(HANDLE LogHandle, CHAR Drive) {
    char strFile[100];
    WIN32_FIND_DATA wfd;
    HANDLE hFind;

	wsprintfA(strFile, "%c:\\*", Drive);

    // Start the find and check for failure.
    hFind = FindFirstFile( strFile, &wfd );
	if(INVALID_HANDLE_VALUE == hFind) {
        return;
    } else {
        // Delete all files on mu
        do {
			if(lstrcmpA(wfd.cFileName, "TitleMeta.xbx") != 0) {
				wsprintfA(strFile, "%c:\\%s", Drive, wfd.cFileName);
				if(!DeleteFile(strFile)) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL,
							"DeleteFile(%s) FAILED LastError = %u", strFile, GetLastError());
				}
			}
        } while(FindNextFile( hFind, &wfd ));

        // Close the find handle.
        FindClose(hFind);
	}
}
    

VOID
MUWrite(HANDLE LogHandle, CHAR Drive) {
	CHAR File[100];
	HANDLE hFile;
	DWORD Bytes;

	xSetFunctionName( LogHandle, "MUWrite" );

	// Open file
	sprintf(File, "%c:\\testfile.dat", Drive);
	hFile = CreateFile(File, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"CreateFile(%s) returned INVALID_HANDLE_VALUE, Error Code = %u", File, GetLastError());
		return;
	}

	// Write to file
	if(!WriteFile(hFile, gWData, gFileSize, &Bytes, NULL)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"WriteFile failed Error Code = %u", GetLastError());
		CloseHandle(hFile);
		return;
	}

	// Close file
	if(!CloseHandle(hFile)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"CloseHande(%s) Error Code = %u", File, GetLastError());
		return;
	}

	xLog(gbConsoleOut, LogHandle, XLL_PASS, "MUWrite %c:\\ PASSED", Drive);
}


VOID
MURead(HANDLE LogHandle, CHAR Drive) {
	CHAR File[100];
	HANDLE hFile;
	DWORD Bytes;

	xSetFunctionName( LogHandle, "MURead" );

	// Create file name
	sprintf(File, "%c:\\testfile.dat", Drive);
	
	// Open file
	hFile = CreateFile(File, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_NO_BUFFERING, NULL);
	if(hFile == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"CreateFile(%s) returned INVALID_HANDLE_VALUE, Error Code = %u", File, GetLastError());
		return;
	}

	// Read from file
	if(!ReadFile(hFile, gRData, gFileSize, &Bytes, NULL)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"ReadFile failed Error Code = %u", GetLastError());
		CloseHandle(hFile);
		return;
	}

	// Close file
	if(!CloseHandle(hFile)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"CloseHande(%s) Error Code = %u", File, GetLastError());
		return;
	}
	
	// Check Data
	if(memcmp(gWData, gRData, gFileSize) != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"Read data does not match Write data - gWData[0] = %#x gRData[0] = %#x", gWData[0], gRData[0]);
	}

	xLog(gbConsoleOut, LogHandle, XLL_PASS, "MURead %c:\\ PASSED", Drive);
}


VOID
WINAPI
MUStartTest(HANDLE LogHandle) {
	DWORD i, j;
	DWORD dwDeviceMask, dwInsertions, dwRemovals;
	BOOL bRO, bWO, bRWOnlyOne, bOneDone;

	// Get read only flag from testini.ini
	if(GetProfileInt(TEXT("mu"), TEXT("RO"), 0)) {
		bRO = TRUE;
	} else {
		bRO = FALSE;
	}

	// Get write only flag from testini.ini
	if(GetProfileInt(TEXT("mu"), TEXT("WO"), 0)) {
		bWO = TRUE;
	} else {
		bWO = FALSE;
	}

	if(bRO && bWO) {
		xSetComponent( LogHandle, "EMC", "MU Read/Write" );
	} else if(bRO && !bWO) {
		xSetComponent( LogHandle, "EMC", "MU Read Only" );
	} else if(!bRO && bWO) {
		xSetComponent( LogHandle, "EMC", "MU Write Only" );
	} else {
		xSetComponent( LogHandle, "EMC", "MU Nothing" );
	}

	// Initialize configuration
	xSetOwnerAlias(LogHandle, "a-emebac");
    xSetFunctionName( LogHandle, "Initialization" );

	// Clear gMUs
	for(i=0; i<4; i++) {
		gMUs[i][XDEVICE_TOP_SLOT] = ' ';
		gMUs[i][XDEVICE_BOTTOM_SLOT] = ' ';
	}

	// Get FileSize from testini.ini
	gFileSize = GetProfileInt(TEXT("mu"), TEXT("FileSize"), 8192);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "FileSize = %u", gFileSize);

	// Get RWOnlyOne from testini.ini
	if(GetProfileInt(TEXT("mu"), TEXT("RWOnlyOne"), 0)) {
		bRWOnlyOne = TRUE;
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Using ONE MU only.");
	} else {
		bRWOnlyOne = FALSE;
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Using ALL MUs.");
	}
	
	// Allocate read and write buffers
	gRData = (CHAR *)VirtualAlloc(NULL, gFileSize, MEM_COMMIT, PAGE_READWRITE);
	if(gRData == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"gRData = VirtuallAlloc(%u) FAILED LastError = %u", gFileSize, GetLastError());
		return;
	}

	gWData = (CHAR *)VirtualAlloc(NULL, gFileSize, MEM_COMMIT, PAGE_READWRITE);
	if(gWData == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"gWData = VirtuallAlloc(%u) FAILED LastError = %u", gFileSize, GetLastError());
		return;
	}

	// Init write buffer
	InitWData(LogHandle);

	// Get a mask of all currently available devices
    dwDeviceMask = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);

    // Mount the MUs
    for( i=0; i<4; i++ ){
		// Top Slot
        if( dwDeviceMask & (1<<i) ) {
            // Mount MU
 			XMountMU(i, XDEVICE_TOP_SLOT, &gMUs[i][XDEVICE_TOP_SLOT]);
			xLog(gbConsoleOut, LogHandle, XLL_INFO, 
				"Added MU: Port: %ld Slot: %ld Drive: %c", i , XDEVICE_TOP_SLOT, gMUs[i][XDEVICE_TOP_SLOT]);
			DeletAllFiles(LogHandle, gMUs[i][XDEVICE_TOP_SLOT]);
			MUWrite(LogHandle, gMUs[i][XDEVICE_TOP_SLOT]);
        }

		// Bottom Slot
        if(dwDeviceMask & (1<<(i+16))) {
            // Mount MU
 			XMountMU(i, XDEVICE_BOTTOM_SLOT, &gMUs[i][XDEVICE_BOTTOM_SLOT]);
            xLog(gbConsoleOut, LogHandle, XLL_INFO, 
				"Added MU: Port: %ld Slot: %ld Drive: %c", i , XDEVICE_BOTTOM_SLOT, gMUs[i][XDEVICE_BOTTOM_SLOT]);
			DeletAllFiles(LogHandle, gMUs[i][XDEVICE_BOTTOM_SLOT]);
			MUWrite(LogHandle, gMUs[i][XDEVICE_BOTTOM_SLOT]);
        }
    }

	// Loop forever 
	xSetFunctionName( LogHandle, "Exercise MUs" );
	while (g_RunForever) {
		// Get gamepad insertions and removals
		XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwInsertions, &dwRemovals );
		// Loop through all gamepads
		for(i=0; i<4; i++) {
			// Handle removed devices
			// Top Slot
			if(dwRemovals & (1<<i)) {
				// UnMount MU
				XUnmountMU(i, XDEVICE_TOP_SLOT);
 				xLog(gbConsoleOut, LogHandle, XLL_INFO, 
					"Removed MU: Port: %ld Slot: %ld Drive: %c", i , XDEVICE_TOP_SLOT, gMUs[i][XDEVICE_TOP_SLOT]);
				gMUs[i][XDEVICE_TOP_SLOT] = ' ';
			}
			// Bottom Slot
			if(dwRemovals & (1<<(i+16))) {
				// UnMount MU
 				XUnmountMU(i, XDEVICE_BOTTOM_SLOT);
				xLog(gbConsoleOut, LogHandle, XLL_INFO, 
					"Removed MU: Port: %ld Slot: %ld Drive: %c", i , XDEVICE_BOTTOM_SLOT, gMUs[i][XDEVICE_BOTTOM_SLOT]);
				gMUs[i][XDEVICE_BOTTOM_SLOT] = ' ';
	        }

			// Handle inserted devices
			// Top Slot
	        if(dwInsertions & (1<<i) ) {
		        // Mount MU
 				XMountMU(i, XDEVICE_TOP_SLOT, &gMUs[i][XDEVICE_TOP_SLOT]);
	            xLog(gbConsoleOut, LogHandle, XLL_INFO, 
					"Added MU: Port: %ld Slot: %ld Drive: %c", i , XDEVICE_TOP_SLOT, gMUs[i][XDEVICE_TOP_SLOT]);
				DeletAllFiles(LogHandle, gMUs[i][XDEVICE_TOP_SLOT]);
				MUWrite(LogHandle, gMUs[i][XDEVICE_TOP_SLOT]);
			}
			// Bottom Slot
			if(dwInsertions & (1<<(i+16))) {
				// Mount MU
 				XMountMU(i, XDEVICE_BOTTOM_SLOT, &gMUs[i][XDEVICE_BOTTOM_SLOT]);
	            xLog(gbConsoleOut, LogHandle, XLL_INFO, 
					"Added MU: Port: %ld Slot: %ld Drive: %c", i , XDEVICE_BOTTOM_SLOT, gMUs[i][XDEVICE_BOTTOM_SLOT]);
				DeletAllFiles(LogHandle, gMUs[i][XDEVICE_BOTTOM_SLOT]);
				MUWrite(LogHandle, gMUs[i][XDEVICE_BOTTOM_SLOT]);
			}
		}

		// Read MUs if global Pause flag is not set
		if(!g_Pause) {
			bOneDone = FALSE;
			for(i=0; i<4; i++) {
				for(j=0; j<2; j++) {
					if((gMUs[i][j] != ' ') && !(bRWOnlyOne && bOneDone)) {
						if(bRO) {
							MURead(LogHandle, gMUs[i][j]);
						}
						if(bWO) {
							MUWrite(LogHandle, gMUs[i][j]);
						}
						bOneDone = TRUE;
					}
				}
			}
		} 
	}

	// Unmount MUs
	xSetFunctionName( LogHandle, "Unmount MUs" );
	for(i=0; i<4; i++) {
		// Top Slot
		if(gMUs[i][XDEVICE_TOP_SLOT] != ' ') {
			XUnmountMU(i, XDEVICE_TOP_SLOT);
			xLog(gbConsoleOut, LogHandle, XLL_INFO, 
				"Unmounted MU: Port: %ld Slot: %ld Drive: %c", i , XDEVICE_TOP_SLOT, gMUs[i][XDEVICE_TOP_SLOT]);
			gMUs[i][XDEVICE_TOP_SLOT] = ' ';

		}
		// Bottom Slot
		if(gMUs[i][XDEVICE_BOTTOM_SLOT] != ' ') {
			XUnmountMU(i, XDEVICE_BOTTOM_SLOT);
			xLog(gbConsoleOut, LogHandle, XLL_INFO, 
				"Unmounted MU: Port: %ld Slot: %ld Drive: %c", i , XDEVICE_BOTTOM_SLOT, gMUs[i][XDEVICE_BOTTOM_SLOT]);
			gMUs[i][XDEVICE_BOTTOM_SLOT] = ' ';
		}
	}

	// Free read and write buffers
	if(gRData != NULL) {
		if(!VirtualFree(gRData, 0, MEM_RELEASE)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"VirtuallFree(gRData) FAILED LastError = %u", GetLastError());
		}
	}

	if(gWData != NULL) {
		if(!VirtualFree(gWData, 0, MEM_RELEASE)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"VirtuallFree(gWData) FAILED LastError = %u", GetLastError());
		}
	}

}


VOID
WINAPI
MUEndTest(VOID) {
}


#if !defined(HARNESSLIB)
int __cdecl main() {
	HANDLE	LogHandle = NULL;

	// Do the initialization that the harness does
	// dxconio
	g_RunForever = TRUE;
	g_Pause = FALSE;

	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	gbConsoleOut = TRUE;
	
	// xlog
	LogHandle = xCreateLog(L"t:\\mu.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("MU: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	// Start Test
	XInitDevices(0, NULL);
	MUStartTest(LogHandle);

	// End Test
	MUEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	// Return to launcher
	XLaunchNewImage(NULL, NULL);
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( mu )
#pragma data_seg()

BEGIN_EXPORT_TABLE( mu )
    EXPORT_TABLE_ENTRY( "StartTest", MUStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MUEndTest )
END_EXPORT_TABLE( mu )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr2\libsrc\mfgtest.h ===
#ifndef _MFGTEST_H
#define _MFGTEST_H




#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))



BOOL WINAPI MfgTestCopyImageToDrive (
    LPCSTR Name,
    PBYTE ImageBuffer,
    SIZE_T Size
    );

BOOL WINAPI MfgTestMapDvdDrive (VOID);

BOOL WINAPI MfgTestReboot (LPCSTR Name);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\netpeer\server\peerserver.cpp ===
//
//	peerserver.cpp
//		Server side of peer-to-peer ethernet bit error rate test.
//		Sends data to address received from a broadcast
//
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>


const WORD  BROADCAST_PORT	= 10983;
const WORD  DATA_PORT		= 10984;
const INT	DATA_PACKETS	= 256;		// Number of packets to sent
const INT	DATA_BYTES		= 1024;		// Packet size


// Message IDs
enum {
	MSG_SEND_DATA,		// Server sends data
	MSG_QUIT			// Server quits
};


// Message payload
struct PEER_MESSAGE {
	BYTE Msg;
	XNADDR xnAddr;
};


VOID 
PeerServerStartTest(HANDLE LogHandle) {
	DWORD dwStatus;
	XNetStartupParams xnsp;
	INT Err, Bytes,i, j;
	WSADATA wsaData;
	XNADDR xnHostAddr;
	CHAR cAddr[20], cAddrLast[20];
	SOCKET sBroadcast, sData;
	SOCKADDR_IN saBroadcast, saData, saClient;
	BOOL bDone;
	PEER_MESSAGE ClientMsg;

	CHAR *Data, *cPtr;

	xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "PeerServer");

	// Prepare send data
	xSetFunctionName(LogHandle, "GlobalAlloc");
	Data = (CHAR *)GlobalAlloc(GPTR, DATA_PACKETS*DATA_BYTES);
	if(Data == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%d bytes) FAILED Returned %d", DATA_PACKETS*DATA_BYTES, GetLastError());
		return;
	}
	cPtr = Data;
	for(i = 0; i < DATA_PACKETS; i++) {
		for(j = 0; j < DATA_BYTES; j++) {
			*cPtr = (CHAR)i;
			cPtr++;
		}
	}

	// Get link status
	xSetFunctionName(LogHandle, "XNetGetEthernetLinkStatus");
	dwStatus = XNetGetEthernetLinkStatus();
	if(dwStatus == 0) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "No Ethernet cable is connected");
	}
	if(dwStatus & XNET_ETHERNET_LINK_ACTIVE) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet cable is connected and active");
	}
	if(dwStatus & XNET_ETHERNET_LINK_100MBPS) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet link is set to 100 Mbps");
	}
	if(dwStatus & XNET_ETHERNET_LINK_10MBPS) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet link is set to 10 Mbps");
	}
	if(dwStatus & XNET_ETHERNET_LINK_FULL_DUPLEX) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet link is in full duplex mode");
	}
	if(dwStatus & XNET_ETHERNET_LINK_HALF_DUPLEX) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Ethernet link is in half duplex mode");
	}

	// Init XNet
	xSetFunctionName(LogHandle, "XNetStartup");
	memset(&xnsp, 0, sizeof(xnsp));
	xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
	xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
	Err = XNetStartup(&xnsp);
	if(Err != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "XNetStartup() FAILED Returned %d", Err);
		return;
	}

	// Init Winsock
	Err = WSAStartup(MAKEWORD(2,2), &wsaData);
	if(Err != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WSAStartup() FAILED Returned %d", Err);
		return;
	}

	// Get local address
	xSetFunctionName(LogHandle, "XNetGetTitleXnAddr");
	do {
		dwStatus = XNetGetTitleXnAddr(&xnHostAddr);
	} while(dwStatus == XNET_GET_XNADDR_PENDING);
	XNetInAddrToString(xnHostAddr.ina, cAddr, sizeof(cAddr));
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Server Address: %s", cAddr);

	// Broadcast socket
	xSetFunctionName(LogHandle, "Broadcast Socket");
	sBroadcast = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if(sBroadcast == INVALID_SOCKET) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "socket(sBroadcast) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}

	// Bind to INADDR_ANY and broadcast port
	ZeroMemory(&saBroadcast, sizeof(SOCKADDR_IN));
	saBroadcast.sin_family = AF_INET;
	saBroadcast.sin_addr.s_addr = INADDR_ANY;
	saBroadcast.sin_port = htons(BROADCAST_PORT);
	Err = bind(sBroadcast, (const sockaddr *)&saBroadcast, sizeof(SOCKADDR_IN));
	if(Err == SOCKET_ERROR) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "bind(INADDR_ANY) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}

	// Data socket
	sData = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if(sData == INVALID_SOCKET) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "socket(sData) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}

	// Bind to data port
	ZeroMemory(&saData, sizeof(SOCKADDR_IN));
	saData.sin_family = AF_INET;
	saData.sin_addr.s_addr = INADDR_ANY;
	saData.sin_port = htons(DATA_PORT);
	Err = bind(sData, (const sockaddr *)&saData, sizeof(SOCKADDR_IN));
	if(Err == SOCKET_ERROR) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "bind(INADDR_ANY) FAILED WSALastError = %d", WSAGetLastError ());
		return;
	}

	// Process messages received from broadcast socket
	ZeroMemory(cAddrLast, 20);
	bDone = FALSE;
	while(!bDone) {
		// Wait to receive a peer message
		Bytes = recv(sBroadcast, (char *)&ClientMsg, sizeof(ClientMsg), 0);
		if(Bytes != sizeof(ClientMsg)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "recv(BROADCAST_PORT) FAILED WSALastError = %d", WSAGetLastError ());
			return;
		}

		switch(ClientMsg.Msg) {
			case MSG_SEND_DATA:
				xSetFunctionName(LogHandle, "Send Data");
				XNetInAddrToString(ClientMsg.xnAddr.ina, cAddr, sizeof(cAddr));
				if(lstrcmpA(cAddr, cAddrLast) != 0) {
					xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sending Data To: %s", cAddr);
					lstrcpyA(cAddrLast, cAddr);
				}

				ZeroMemory(&saClient, sizeof(SOCKADDR_IN));
				saClient.sin_family = AF_INET;
				CopyMemory(&saClient.sin_addr, &ClientMsg.xnAddr.ina, sizeof(in_addr));
				saClient.sin_port = htons(DATA_PORT);
				for(i = 0; i < DATA_PACKETS; i++) {
					Err = sendto(sData, (const char *)(Data + i*DATA_BYTES), DATA_BYTES, 0, 
						(const sockaddr *)&saClient, sizeof(SOCKADDR_IN));
					/*
					if(Err = SOCKET_ERROR) {
						xLog(gbConsoleOut, LogHandle, XLL_FAIL, "sendto(%d) FAILED WSALastError = %d", i, WSAGetLastError ());
						return;
					}
					*/
				}
				break;

			case MSG_QUIT:
				bDone = TRUE;
				break;
		}
	}


	// Shut down network
	xSetFunctionName(LogHandle, "Shut Down");
	closesocket(sData);
	closesocket(sBroadcast);
	WSACleanup();
	XNetCleanup();
}


VOID
PeerServerEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	HANDLE LogHandle;

	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);

	// xlog
	LogHandle = xCreateLog_A("t:\\peerserver.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "PeerServer: couldn't create log (%s)", WinErrorSymbolicName(GetLastError()));
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "PeerServer: End - Waiting for reboot...");
		Sleep(INFINITE);
    }

	gbConsoleOut = TRUE;

	// Start Test
	PeerServerStartTest(LogHandle);

	// End Test
	PeerServerEndTest();

	// xlog
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "PeerServer: End - Waiting for reboot...");
	xCloseLog(LogHandle);

	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( peerserver )
#pragma data_seg()

BEGIN_EXPORT_TABLE( peerserver )
    EXPORT_TABLE_ENTRY( "StartTest", PeerServerStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", PeerServerEndTest )
END_EXPORT_TABLE( peerserver )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\netdata\netdata.cpp ===
//
//	netdata
//
//	Description:	
//		Send data to and received echoed data from xbnettest and check for errors.
//
//	recvfrom(): sync with xbnettest
//	sendto(): send datagram to xbnettest
//	recvfrom(): receive echoed datagram
//	compare send and receive data


#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

#define BUFSIZE 1400

VOID
NetDataStartTest(HANDLE	LogHandle) {
	WSADATA			wsaData;
	SOCKET			sock;
	sockaddr_in		saLocalAddr, saFromAddr, saXbNetTestAddr;
	u_short			sXboxPort;
	int				iRet, iSize, iNumMsg, i;
	int				iBytesRecv, iBytesSent, iMiscompare;
	char			cSendBuf[BUFSIZE], cRecvBuf[BUFSIZE];
	char			cAddress[15];
	BOOL			bDone;

    xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "NetData");
    xSetFunctionName(LogHandle, "NetData");

	iBytesRecv = 0;
	iBytesSent = 0;
	iMiscompare = 0;
	bDone = FALSE;

	// random data for send buffer
	for(i = 0; i < BUFSIZE; i++) {
		cSendBuf[i] = (char)rand()%256;
	}

	// get number of messages from testini.ini
	iNumMsg = GetProfileInt(TEXT("netdata"), TEXT("NumMsg"), 1);

	// Initialize Winsock layer
	iRet = WSAStartup(0x202, &wsaData);
	if(iRet != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"NetData: WSAStartup FAILED: Return Value = %d", iRet);
		return;
	}

	// Create UDP socket
	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if(sock == INVALID_SOCKET) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"NetData: socket() FAILED: WSALastError = %d", WSAGetLastError());
		return;
	}

	// Bind socket to local address
	sXboxPort = IPPORT_RESERVED + 1;
	saLocalAddr.sin_family = AF_INET;
	saLocalAddr.sin_addr.s_addr = INADDR_ANY;
	saLocalAddr.sin_port = htons(sXboxPort);

	iRet = bind(sock, (sockaddr *)&saLocalAddr, sizeof(saLocalAddr));
	if(iRet == SOCKET_ERROR) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"NetData: bind() FAILED: WSALastError = %d", WSAGetLastError());
		return;
	}

	// Sync with xbnettest
	iSize = sizeof(saXbNetTestAddr);
	iRet = recvfrom(sock, cSendBuf, BUFSIZE, 0,(sockaddr *)&saXbNetTestAddr, &iSize);
	if((iRet == SOCKET_ERROR)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NetData: Sync recvfrom() FAILED: WSALastError = %d", WSAGetLastError());
		return;
	}

	// Output xbnettest info
	XNetInAddrToString(saXbNetTestAddr.sin_addr, cAddress, sizeof(cAddress));
	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"NetData: Connected to: %s Exchanging %d %d byte messages", cAddress, iNumMsg, BUFSIZE);

	i = 0;
	do {
		// Increment iteration counter
		i++;

		// Send test data 
		iRet = sendto(sock, cSendBuf, BUFSIZE, 0,(sockaddr *)&saXbNetTestAddr, sizeof(saXbNetTestAddr));
		if((iRet == SOCKET_ERROR)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"NetData: Rep %d: sendto() FAILED: WSALastError = %d", i, WSAGetLastError());
			break;
		}

		if(iRet != BUFSIZE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"NetData: Rep %d: sendto() FAILED: sent %d bytes of %d", i, iRet, BUFSIZE);
		}

		iBytesSent += iRet;

		// Receive echoed test data
		iSize = sizeof(saFromAddr);
		iRet = recvfrom(sock, cRecvBuf, BUFSIZE, 0,(sockaddr *)&saFromAddr, &iSize);
		if((iRet == SOCKET_ERROR)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"NetData: Rep %d: recvfrom() FAILED: WSALastError = %d", i, WSAGetLastError());
			break;
		}

		iBytesRecv += iRet;

		// compare send and receive
		for(int j = 0; j < BUFSIZE; j++) {
			if(cSendBuf[j] != cRecvBuf[j]) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
					"NetData: Rep %d: FAILED Data miscompare: cSendBuf[%d] = %c  cRecvBuf[%d] = %c", i, j, cSendBuf[j], j, cRecvBuf[j]);
				iMiscompare++;
			}
		}

		// Check for done
		if(iNumMsg != -1) {
			if(i >= iNumMsg) {
				bDone = TRUE;
			}
		}
	} while (!bDone);


	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"NetData: Finished %d messages: Sent %d Bytes Received %d Bytes %d Bytes did not match", 
		i, iBytesSent, iBytesRecv, iMiscompare);

	// Send stop to xbnettest
	iRet = sendto(sock, cSendBuf, 0, 0,(sockaddr *)&saXbNetTestAddr, sizeof(saXbNetTestAddr));
	if((iRet == SOCKET_ERROR)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"NetData: sendto() FAILED: WSALastError = %d", WSAGetLastError());
	}

	if(iRet != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"NetData: sendto() FAILED: sent %d bytes of %d", iRet, BUFSIZE);
	}

	// Clean up WSA and Xnet
	iRet = closesocket(sock);
	if(iRet != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "closesocket FAILED");
	}

	iRet = WSACleanup(); 
	if(iRet != 0) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WSACleanup FAILED");
	}

	iRet = XNetCleanup();
	if(iRet != NO_ERROR) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "XnetCleanup FAILED");
	}
}

VOID
NetDataEndTest() {
}

#if !defined(HARNESSLIB)
__cdecl main() {
	XNetStartupParams xnspParams;
	int iRet;
	HANDLE	LogHandle = NULL;

	// Get test configuration from ini file
	if (GetProfileInt(TEXT("GeneralSettings"), TEXT("StressTestMode"), 0) ||
		GetProfileInt(TEXT("GeneralSettings"), TEXT("ParallelTestMode"), 0)) {
		gbConsoleOut = FALSE;
	} else {
		// Start dxconio if in SerialTestMode
		xCreateConsole(NULL);
		xSetBackgroundImage(NULL);
		gbConsoleOut = TRUE;
	}

	// Do the initialization that the harness does
	// xlog
	LogHandle = xCreateLog_W(L"t:\\netdata.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("NetData: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

    xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "NetData");
    xSetFunctionName(LogHandle, "NetData");

	// Initialize Xbox network stack
	memset(&xnspParams, 0, sizeof(xnspParams));
	xnspParams.cfgSizeOfStruct = sizeof(xnspParams);
	xnspParams.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;
	iRet = XNetStartup(&xnspParams);
	if(iRet != NO_ERROR) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "XNetStartUp FAILED");
	} else {
		// Start Test
		NetDataStartTest(LogHandle);

		// End Test
		NetDataEndTest();
	}

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("NetData: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	return 0;
}
#endif


//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( netdata )
#pragma data_seg()

BEGIN_EXPORT_TABLE( netdata )
    EXPORT_TABLE_ENTRY( "StartTest", NetDataStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", NetDataEndTest )
END_EXPORT_TABLE( netdata )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\speedtest\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header file

Author:

    Sakphong Chanbai (schanbai) 17-Aug-2000

Environment:

    Xbox

Revision History:

--*/


extern "C" {
#include <nt.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <xtl.h>
#include "xlog.h"
#include "xtestlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\speedtest\speedtest.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    speedtest.c

Abstract:

    Routines to test CPU clock speed

Environment:

    Xbox

Revision History:

--*/
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

#define MAX_TRIES           200     // Maximum number of samplings
#define HIPERF_TICKS        50000
#define RDTSC               __asm _emit 0x0F __asm _emit 0x31	
#define GetCounter(pdwRet)  RDTSC __asm mov pdwRet, eax

DWORD
GetCPUSpeed(VOID) {
    LARGE_INTEGER liBegin, liEnd, liFreq;   // High Resolution Performance Counter frequency
    int iTries = 0;
    DWORD dwCycles, dwStamp0;               // Time Stamp Variable for beginning and end 
    DWORD dwStamp1, dwFreq = 0, dwFreq2 = 1, dwFreq3 = 2, dwTicks;
    int iPriority;
    HANDLE hThread = GetCurrentThread();

    // Must have a high resolution counter.
    if ( !QueryPerformanceFrequency(&liFreq) ) {
        return 0;
    }

    // Loop until all three frequencies match or we exeed MAX_TRIES.
    for ( iTries=0; (dwFreq != dwFreq2 || dwFreq != dwFreq3) && iTries < MAX_TRIES; iTries++ ) {           

        // Shift frequencies back to make room for new frequency.
        dwFreq3 = dwFreq2;  
        dwFreq2 = dwFreq;   

        iPriority = GetThreadPriority(hThread);

        if ( iPriority != THREAD_PRIORITY_ERROR_RETURN ) {
            SetThreadPriority( hThread, THREAD_PRIORITY_TIME_CRITICAL );
        }

        // Reset the initial time.
        QueryPerformanceCounter( &liBegin );
        GetCounter( dwStamp0 ); 

        do {
            // Loop until the hiperf timer has ticked HIPERF_TICKS ticks 
            // This allows for elapsed time for sampling.
            QueryPerformanceCounter( &liEnd );
            GetCounter( dwStamp1 );
        } while ( (DWORD)liEnd.LowPart - (DWORD)liBegin.LowPart < HIPERF_TICKS );

        // Reset priority
        if ( iPriority != THREAD_PRIORITY_ERROR_RETURN ) {
            SetThreadPriority( hThread, iPriority );
        }

        // Number of internal clock cycles is difference between 
        //   two time stamp readings.
        dwCycles = dwStamp1 - dwStamp0; 

        // Number of external ticks is difference between two
        //   hi-res counter reads.
        dwTicks = (DWORD)liEnd.LowPart - (DWORD)liBegin.LowPart;  
    
        dwFreq = \
            (DWORD) ((((float) dwCycles * (float) liFreq.LowPart) / 
                (float) dwTicks) / 100000.0f);
    } 

    // dwFreq is currently in this form: 4338 (433.8 MHz)
    // Take any fraction up to the next round number.
    dwFreq = (dwFreq + (dwFreq % 10)) / 10;

    return dwFreq;
}


VOID
WINAPI
SpeedTestStartTest(HANDLE LogHandle) {
	xSetOwnerAlias(LogHandle, "a-emebac");
    xSetComponent( LogHandle, "Hardware", "SpeedTest" );
    xSetFunctionName( LogHandle, "SpeedTest" );
	xStartVariation(gbConsoleOut, LogHandle, "SPEEDTEST");
    xLog(gbConsoleOut, LogHandle, XLL_PASS, "SPEEDTEST: CPU Speed = %d MHz", GetCPUSpeed());
	xEndVariation(LogHandle);
}


VOID
WINAPI
SpeedTestEndTest(VOID) {
}

#if !defined(HARNESSLIB)
/*************************************************************************************
Function:	main (...)
Purpose:	XBE Entry point
Params:
Notes:		
*************************************************************************************/
int __cdecl main() {
	BOOL RunForever = TRUE;
	HANDLE	LogHandle;

	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\speedtest.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if (LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("SPEEDTEST: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	// Get test configuration from ini file
	if (GetProfileInt(TEXT("GeneralSettings"), TEXT("StressTestMode"), 0) ||
		GetProfileInt(TEXT("GeneralSettings"), TEXT("ParallelTestMode"), 0)) {
		gbConsoleOut = FALSE;
	} else {
		gbConsoleOut = TRUE;
	}

	// Start Test
	SpeedTestStartTest(LogHandle);

	// End Test
	SpeedTestEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("SPEEDTEST: End - Waiting for reboot...\n");
	while (RunForever) {
	}

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	return 0;
}
#endif

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( speedtest )
#pragma data_seg()

BEGIN_EXPORT_TABLE( speedtest )
    EXPORT_TABLE_ENTRY( "StartTest", SpeedTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SpeedTestEndTest )
END_EXPORT_TABLE( speedtest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\smc\SMCVer\SMCVer.cpp ===
// 
// prints out the SMC version
//
// 




#include <xtl.h>
#include <dxconio.h>





extern "C"
    {
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

DWORD WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }

void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    wsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }






void main()
{
	
	char ver[4];


	xCreateConsole( NULL );
	xSetBackgroundImage( NULL );
	xSetFont( 15.0, 18.0, NULL );

	ver[0] = (char)ReadSMC( 0x01 );
	ver[1] = (char)ReadSMC( 0x01 );
	ver[2] = (char)ReadSMC( 0x01 );
	ver[3] = 0;

	DebugPrint( "SMC FW Version: %s\n", ver );
	printf( "   SMC FW Version: %s\n", ver );

	Sleep( INFINITE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\smc\xLogTemp\xLogTemp.cpp ===
/*
	logs SMC Temps
	logs AMD Temps
*/



//#define WIN32_LEAN_AND_MEAN
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <i2clib.h>



int __cdecl main(  )
{
	HANDLE		hLog;							// handle to the log
	WCHAR		lpszLogFileName[256];			// pointer to the log file name
	DWORD		dwSMCAirTemp;
	DWORD		dwSMCCPUTemp;
	DWORD		dwAMDAirTemp;
	DWORD		dwAMDCPUTemp;
	DWORD		dwFanSpeed;
	DWORD		dwQueryCount = 0;



	xCreateConsole( NULL );
	xSetBackgroundImage( NULL );
	xSetFont( 15.0, 18.0, NULL );

	GetPrivateProfileString( L"xLogTemp", L"LogFile", L"t:\\xLogTemp.txt", lpszLogFileName, 256, L"hwtestini.ini" );

	//
	// create the log
	//
	hLog = xCreateLog( lpszLogFileName,		// log file name
		               NULL,				// web server info
					   INVALID_SOCKET,		// socket info
					   XLL_LOGALL,			// log level
					   XLO_DEBUG );

	// check to make sure
	// the log was opened
	if( !hLog )
	{
		printf("Could not open log file (%s)\n", WinErrorSymbolicName(GetLastError()) );
		exit(1);
	}


	
	// set some logging options
	// this 
	xSetOwnerAlias( hLog, "sethmil" );		// set owner alias
	xSetComponent( hLog, "Console Thermal Test", "SMC" );
	xSetFunctionName( hLog, "Thermal Log" );
	xStartVariation( hLog, "15 Second Poll" );


	// write header to log file
	//
	xLog( hLog, XLL_INFO, "FAN_SPEED;SMC_AIR_TEMP;SMC_CPU_TEMP;AMD_AIR_TEMP;AMD_CPU_TEMP");
	printf( "LogTemp Running ...\n" );

	
	for( ; ; )  // while (true) 
	{
		Sleep( 2000 );
		

		// Get Fan Speed
		dwFanSpeed = ReadSMC( READFANSPEED );
		if( dwFanSpeed == 0xCCCCCCCC )
		{
			printf("Error getting SMC's fanspeed ... continuing\n");
			continue;
		}
		Sleep(10);
		

		// Get SMC's Air Temp
		dwSMCAirTemp = ReadSMC( AIRTEMP );
		if( dwSMCAirTemp == 0xCCCCCCCC )
		{
			printf("Error getting SMC's airtemp ... continuing\n");
			continue;
		}
		Sleep(10);
		

		// Get SMC's CPU Temp
		dwSMCCPUTemp = ReadSMC( CPUTEMP );
		if( dwSMCCPUTemp == 0xCCCCCCCC )
		{
			printf("Error getting SMC's cputemp ... continuing\n");
			continue;
		}
		Sleep(10);
		

		// Get AMD's Air Temp
		dwAMDAirTemp = ReadAMD( AMDAIRTEMP );
		if( dwAMDAirTemp == 0xCCCCCCCC )
		{
			printf("Error getting AMD's airtemp ... continuing\n");
			continue;
		}
		Sleep(10);
		

		// Get AMD's CPU Temp
		dwAMDCPUTemp = ReadAMD( AMDCPUTEMP );
		if( dwAMDCPUTemp == 0xCCCCCCCC )
		{
			printf("Error getting AMD's cputemp ... continuing\n");
			continue;
		}
		Sleep(10);
		


		// if there were no errors, we can now log the results
	
		xLog( hLog, XLL_INFO, "%d;%d;%d;%d;%d", 
													dwFanSpeed, 
													dwSMCAirTemp, 
													dwSMCCPUTemp, 
													dwAMDAirTemp, 
													dwAMDCPUTemp );

		dwQueryCount++;			// increment counter

		// print the results
		printf( "   Temp Query # %d\n", dwQueryCount );
		printf( "*************************\n" );
		printf( "    Fan Speed:    %d\n", dwFanSpeed );
		printf( "    SMC Air Temp: %d\n", dwSMCAirTemp );
		printf( "    SMC CPU Temp: %d\n", dwSMCCPUTemp );
		printf( "    AMD Air Temp: %d\n", dwAMDAirTemp );
		printf( "    AMD CPU Temp: %d\n", dwAMDCPUTemp );
		printf( "*************************\n" );
		printf( "\n" );

		
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\rumble\rumble.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rumble.cpp

Abstract:

    Cycle rumble motors 1sec, 50% duty, full on, full off

Environment:

    Xbox

Revision History:

--*/
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xlogconio.h>

const WORD MOTOR_MIN = 0;
const WORD MOTOR_MAX = 65535; 
const DWORD MIN_TIME = 500;
const DWORD MAX_TIME = 500;

// Used by hawk and mu to pause activity
BOOL g_RunForever = TRUE;
BOOL g_Pause = FALSE;


//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD
{
    // Device properties
    HANDLE     hDevice;
	XINPUT_FEEDBACK Feedback;
};

// Globals
XBGAMEPAD g_Gamepads[4];

VOID 
WINAPI
RumbleMotors(WORD Left, WORD Right) {
	WORD i;

	for(i=0; i<4; i++) {
		if(g_Gamepads[i].hDevice != NULL) {
			while(g_Gamepads[i].Feedback.Header.dwStatus == ERROR_IO_PENDING) {
				// Wait for I/O to complete
				Sleep(10);
			}
			// Set speed
			g_Gamepads[i].Feedback.Rumble.wLeftMotorSpeed = Left;
			g_Gamepads[i].Feedback.Rumble.wRightMotorSpeed = Right;
			XInputSetState(g_Gamepads[i].hDevice, &g_Gamepads[i].Feedback);
		}
	}
}


VOID
WINAPI
RumbleStartTest(HANDLE LogHandle) {
	DWORD dwInsertions, dwRemovals, SleepTime = MIN_TIME;
	XINPUT_STATE State;
	DWORD i, Buttons = 0;
	BOOL MotorMAXState = TRUE;

	xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "EMC", "Rumble");
    xSetFunctionName(LogHandle, "Initialization" );

	// Initialize configuration
	// Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
	for( i=0; i<4; i++ ){
		// Initialize game pad array
		g_Gamepads[i].hDevice = NULL;
		memset(&(g_Gamepads[i].Feedback), 0, sizeof(XINPUT_FEEDBACK));

        if( dwDeviceMask & (1<<i) ) {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );
			xLog(gbConsoleOut, LogHandle, XLL_INFO, 
				"Added Gamepad: Port: %ld Handle: %#x", i , g_Gamepads[i].hDevice);
        }
	}

	// Loop forever toggling motor speed and wait times
	xSetFunctionName(LogHandle, "Toggle Motors");
	while (g_RunForever) {
		// Get gamepad insertions and removals
		XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );
		for( i=0; i<4; i++ ) {
			// Handle removed devices.
			if( dwRemovals & (1<<i) ) {
				XInputClose( g_Gamepads[i].hDevice );
				xLog(gbConsoleOut, LogHandle, XLL_INFO, 
					"Removed Gamepad: Port: %ld Handle: %#x", i , g_Gamepads[i].hDevice);
				g_Gamepads[i].hDevice = NULL;
				memset(&(g_Gamepads[i].Feedback), 0, sizeof(XINPUT_FEEDBACK));
			}
			// Handle inserted devices
			if( dwInsertions & (1<<i) ) {
				g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );
				xLog(gbConsoleOut, LogHandle, XLL_INFO, 
					"Added Gamepad: Port: %ld Handle: %#x", i , g_Gamepads[i].hDevice);
			}
		}

		// Set motor speed
		if(!g_Pause) {
			if(MotorMAXState) {
				RumbleMotors(MOTOR_MAX, MOTOR_MAX);
				SleepTime = MAX_TIME;
				MotorMAXState = FALSE;
			} else {
				RumbleMotors(MOTOR_MIN, MOTOR_MIN);
				SleepTime = MIN_TIME;
				MotorMAXState = TRUE;
			}
		}

		// Get button presses
		Buttons = 0;
		for( i=0; i<4; i++ ) {
			if(g_Gamepads[i].hDevice != NULL) {
				XInputGetState(g_Gamepads[i].hDevice, &State);
				Buttons = Buttons | State.Gamepad.wButtons;
			}
		}

		// Back button pauses app
		if((Buttons & XINPUT_GAMEPAD_BACK) > 0) {
			if(!g_Pause) {
				xLog(gbConsoleOut, LogHandle, XLL_INFO, 
					"Application Paused");
				OutputDebugStringA("Application Paused\n");
				// xDebugStringA("Application Paused\n");
				g_Pause = TRUE;
				SleepTime = 0;
				RumbleMotors(MOTOR_MIN, MOTOR_MIN);
			}
		}

		// Start button unpauses app
		if((Buttons & XINPUT_GAMEPAD_START) > 0 ) {
			if(g_Pause) {
				xLog(gbConsoleOut, LogHandle, XLL_INFO, 
					"Application NOT Paused");
				OutputDebugStringA("Application NOT Paused\n");
				// xDebugStringA("Application NOT Paused\n");
				g_Pause = FALSE;
			}
		}

		// Wait specified time
		Sleep(SleepTime);
	}	// while(g_RunForever)
	
	// Close all gamepads
	xSetFunctionName(LogHandle, "EndTest");
	for(i=0; i<4; i++ ) {
		if(g_Gamepads[i].hDevice != NULL) {
			while(g_Gamepads[i].Feedback.Header.dwStatus == ERROR_IO_PENDING) {
				// Wait for I/O to complete
			}
			// XInputClose( g_Gamepads[i].hDevice );
			xLog(gbConsoleOut, LogHandle, XLL_INFO, 
				"Removed Gamepad: Port: %ld Handle: %#x", i , g_Gamepads[i].hDevice);
			g_Gamepads[i].hDevice = NULL;
			memset(&(g_Gamepads[i].Feedback), 0, sizeof(XINPUT_FEEDBACK));
		}
	}
}


VOID
WINAPI
RumbleEndTest(VOID) {
}

#if !defined(HARNESSLIB)
int __cdecl main() {
	HANDLE	LogHandle = NULL;

	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	gbConsoleOut = TRUE;
	g_RunForever = TRUE;
	g_Pause = FALSE;

	// xlog
	LogHandle = xCreateLog_W(L"t:\\rumble.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("RUMBLE: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	xDebugStringA("All attached Game Controllers will be exercised.\n");
	xDebugStringA("Press 'Back' to Pause\n");
	xDebugStringA("Press 'Start' to Resume\n");

	// Start Test
	XInitDevices(0, NULL);
	RumbleStartTest(LogHandle);

	// End Test
	RumbleEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	XLaunchNewImage(NULL, NULL);
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( rumble )
#pragma data_seg()

BEGIN_EXPORT_TABLE( rumble )
    EXPORT_TABLE_ENTRY( "StartTest", RumbleStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", RumbleEndTest )
END_EXPORT_TABLE( rumble )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\smc\smcpowercycle\SMCPowerCycle.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    smcpowercycle.cpp

Abstract:

    test app that performs a power cycle

	note:  the MFG boot loader, or a disk with the same image, must be in the drive

	note:  eventually, this should be expanded to check a whole lot of stuff
	after a powercycle, but for now it is concentrating on DVD.

--*/


#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>
#include <stdlib.h>
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>
#include <fscache.h>
#include <xbinput.h>



#define FILENAME "z:\\resets.txt"



// SMC Functions

extern "C"
    {
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

DWORD WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }




// performs a soft reset on the dvd
//

BOOL
DVDSoftReset(HANDLE hDevice, UCHAR Command) {

 WCHAR buff[256];
 ATA_PASS_THROUGH AtaPassThrough;
 DWORD cbBytesReturned;
 BOOL bReturn;
 memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
 AtaPassThrough.IdeReg.bCommandReg = Command;
 AtaPassThrough.IdeReg.bDriveHeadReg = 0xb0;      // Device 0
 AtaPassThrough.DataBuffer = NULL;
 bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
        &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
        &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
        &cbBytesReturned, NULL);
 if(!bReturn) {
  //xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SetPowerMode FAILED StatusReg=%#x ErrorReg=%#x LastError = %d",
   //AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
  //HDPerf_LogAtaPassThrough(AtaPassThrough);

  wsprintf( buff, L"\nReset error: Last Error: %d\n\n", GetLastError() );
  OutputDebugString ( buff );
  return FALSE;
 } else {
  return TRUE;
 }
}



void DebugPrint(LPWSTR format, ...)
    {
    va_list args;
    va_start(args, format);

    WCHAR szBuffer[1024];

    wsprintf(szBuffer, format, args);
    OutputDebugString(szBuffer);

    va_end(args);
    }



DWORD ReadFromFile( LPSTR lpFilename )
{
	HANDLE hFile;
	DWORD result;
	DWORD dwBytesRead;

	// open the file for reading
	hFile = CreateFile(     lpFilename, 
							GENERIC_READ, 
							0,
							NULL, 
							OPEN_EXISTING, 
							FILE_ATTRIBUTE_NORMAL, 
							NULL );


	// set reboots to 0 if file doesn't exist,
	// otherwise, read reboots from the file
	if( INVALID_HANDLE_VALUE == hFile )
	{
		result = 0;
	}
	else
	{
		// get current # of reboots
		ReadFile( hFile, (LPVOID)(&result), 4, &dwBytesRead, NULL );
	}


	// close the file
	CloseHandle( hFile );
	hFile = INVALID_HANDLE_VALUE;

	return result;
}





VOID WriteToFile( LPSTR lpFilename, DWORD value )
{
	HANDLE hFile;
	DWORD dwBytesWritten;

	// open the file for writing
	hFile = CreateFile(		lpFilename, 
							GENERIC_WRITE, 
							0, 
							NULL,
							CREATE_ALWAYS, 
							FILE_ATTRIBUTE_NORMAL, 
							NULL );


	WriteFile( hFile, (LPCVOID)(&value), 4, &dwBytesWritten, NULL );
	

	// close the file
	CloseHandle( hFile );
	hFile = INVALID_HANDLE_VALUE;

}





void __cdecl main()
{
	OBJECT_STRING objname;		// object name
	OBJECT_ATTRIBUTES oa;		// obj attributes
	IO_STATUS_BLOCK iosb;		// IO status block
	NTSTATUS status;			// status
	HANDLE hDevice;				// handle to the dvd
	HANDLE hLog;				// handle to the log file
	HANDLE hSearch;				// handle to a file search
	DWORD dwSMCTrayState;		// smc tray state
	WIN32_FIND_DATA fd;			// find find data
	DWORD dwResets = 0;				// counter
	XBGAMEPAD* pGamepads = NULL;
	DWORD dwPressedButtons = 0;
	DWORD dwPressedBlackButton = 0;

	BYTE buff[256];
	DWORD bytenum = 256;
	HANDLE hInFile;

	
	//DebugBreak();


	// create console
	xCreateConsole( NULL );
	xSetBackgroundImage( NULL );
	xSetFont( 15.0, 18.0, NULL );


	// create gamepads
	XInitDevices(0, NULL);
	XBInput_CreateGamepads( &pGamepads );


	// create log
	hLog = xCreateLog( L"t:\\SMCPowerCycle.log", NULL, INVALID_SOCKET, XLL_LOGALL, XLO_DEBUG );
	if( !hLog )
	{
		printf( "  Could not create Log\n");
		DebugBreak();
	}
	xSetOwnerAlias( hLog, "sethmil" );
	xSetComponent( hLog, "Sysreset", "SMC" );
	xSetFunctionName( hLog, "Sysreset" );
	xStartVariation( hLog, "Sysreset stress" );


	// get and increment the # of reboots
	dwResets = ReadFromFile( FILENAME );
	dwResets++;
	WriteToFile( FILENAME, dwResets );
	printf(" SysReset # %d\n", dwResets );
	xLog( hLog, XLL_INFO, "SYSReset #: %d", dwResets );


	// check for Gamepad input.
	// don't reboot if there is gamepad input
	Sleep( 500 );
	

	// if gamepad input, don't reboot, delete the reboot file
	if( dwPressedButtons )
	{
		printf("  Controller input detected\n");

		// reset count if black button was pressed
		if( dwPressedBlackButton )
		{
			printf("  Black button pressed\n");
			printf("  Resetting reboot count\n" );
			DeleteFile( FILENAME );
		}
		printf("\n  Stopped at %d resets\n", dwResets);
		printf("  Sleeping ..." );
		Sleep( INFINITE );
	}


	
	


	// test algorithm
	//	  pre test
	//          override reboot on tray open
	//
	//    . check for media detect
	//	  . Read a file from DVD
	//    . Open a file from DVD
	//    . Read a file from DVD
	//	  . perform a power cycle
	//
	
	// make sure we have media detect
	//
	dwSMCTrayState = (ReadSMC( 0x03 ) >> 4) & 0x0F ;
	if( dwSMCTrayState != 0x6 )
	{
		xLog( hLog, XLL_FAIL, "No Media Detect" );
	}

	

	// mount the DVD device
	//
	RtlInitObjectString(&objname, OTEXT("\\Device\\cdrom0"));
	InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);
	status = NtOpenFile(&hDevice, GENERIC_READ|SYNCHRONIZE, &oa, &iosb, 0, FILE_SYNCHRONOUS_IO_ALERT);
	

	// flush the file system cache
	FscInvalidateIdleBlocks();
	


	// open the DVDROM device
	//
	DebugPrint(L"opening dvd\n");
	hDevice = CreateFile("cdrom0:",	GENERIC_READ, 0, NULL, OPEN_EXISTING, 
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,NULL);
	if( hDevice == INVALID_HANDLE_VALUE )
	{
		DebugPrint( L"Could not open DVD after reset \n" );
		xLog( hLog, XLL_FAIL, "Could not open DVD after reset");
	}


	// search for 'VTS_01_1.VOB' on the mfg boot loader disk
	//
	DebugPrint(L"searghing for file\n");
	hSearch = FindFirstFile( "cdrom0:\\VIDEO_TS\\VTS_01_1.VOB", &fd );
	if( INVALID_HANDLE_VALUE == hSearch )
	{
		// fail
		xLog( hLog, XLL_FAIL, "Could not find cdrom:\\default.xbe" );
	}
	


	// open the file
	// from the DVD
	//
	DebugPrint(L"opening file\n");
	hInFile = CreateFile( "cdrom0:\\VIDEO_TS\\VTS_01_1.VOB", 
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL );
	if( INVALID_HANDLE_VALUE == hInFile )
	{
		//fail
		xLog( hLog, XLL_FAIL, "Could not open file cdrom:\\default.xbe" );
	}

	// read the first 1 megs from the file
	DebugPrint(L"reading file\n");
	bytenum = 256;
	int j = 0;
	for( j = 0; j < 4096 && ( bytenum == 256 ); j++ ) {
		if( !ReadFile( hInFile, buff, 256, &bytenum, NULL ) )
		{
			//fail
			xLog( hLog, XLL_FAIL, "Error reading default.xbe from DVD" );
			DebugPrint(L" \n\nHalt for failure\n\n");
			break;
		}
	}
	// check that the entire 1 meg was read
	if( j < 4096 || bytenum < 256 )
	{
		xLog( hLog, XLL_FAIL, "ERROR Reading entire 1 meg of data" );
		DebugBreak();
	}
		

	
	// log # of reboots
	//
	//xLog( hLog, XLL_INFO, "Reboot num: %d", dwResets );


	// close all the files
	CloseHandle( hSearch );
	CloseHandle( hInFile );
	CloseHandle( hDevice );
	//xCloseLog( hLog );
	


	// issue a power cycle
	Sleep( 500 );
	WriteSMC( 0x02, 0x40 );

	Sleep( INFINITE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\sysreset\SMCPowerCycle.cpp ===
//  Xbox app that cycles box power
//  by using the SMC power cycle command.
//





#include <xtl.h>
#include <dxconio.h>
#include <i2clib.h>
#include <xlog.h>
#include <xbgpinput.h>


#define FILENAME "t:\\reboots.txt"




DWORD ReadFromFile( LPSTR lpFilename )
{
	HANDLE hFile;
	DWORD result;
	DWORD dwBytesRead;

	// open the file for reading
	hFile = CreateFile( "t:\\reboots.txt", 
							GENERIC_READ, 
							0,
							NULL, 
							OPEN_EXISTING, 
							FILE_ATTRIBUTE_NORMAL, 
							NULL );


	// set reboots to 0 if file doesn't exist,
	// otherwise, read reboots from the file
	if( INVALID_HANDLE_VALUE == hFile )
	{
		result = 0;
	}
	else
	{
		// get current # of reboots
		ReadFile( hFile, (LPVOID)(&result), 4, &dwBytesRead, NULL );
	}


	// close the file
	CloseHandle( hFile );
	hFile = INVALID_HANDLE_VALUE;

	return result;
}





VOID WriteToFile( LPSTR lpFilename, DWORD value )
{
	HANDLE hFile;
	DWORD dwBytesWritten;

	// open the file for writing
	hFile = CreateFile(		lpFilename, 
							GENERIC_WRITE, 
							0, 
							NULL,
							CREATE_ALWAYS, 
							FILE_ATTRIBUTE_NORMAL, 
							NULL );


	WriteFile( hFile, (LPCVOID)(&value), 4, &dwBytesWritten, NULL );
	

	// close the file
	CloseHandle( hFile );
	hFile = INVALID_HANDLE_VALUE;

}







void __cdecl main()
{

	HANDLE hLog;
	DWORD dwPressedButtons = 0;
	DWORD dwPressedBlackButton = 0;
	XBGAMEPAD* pGamepads = NULL;
	DWORD dwReboots = 0;
	
	// create console
	xCreateConsole( NULL );
	xSetBackgroundImage( NULL );
	xSetFont( 15.0, 18.0, NULL );

	// create gamepads
	XBGPInput_InitGamepads();
	XBGPInput_CreateGamepads( &pGamepads );

	
	
	// create log
	hLog = xCreateLog( "t:\\SMCPowerCycle.log", NULL, INVALID_SOCKET, XLL_PASS, XLO_DEBUG );
	if( !hLog )
	{
		printf( "  Could not create Log\n");
		Sleep( INFINITE );
	}


	// get (& increment) the current # of reboots
	dwReboots = ReadFromFile( FILENAME );
	dwReboots++;
	WriteToFile( FILENAME, dwReboots );



	// log the reboot
	xSetOwnerAlias( hLog, "" );
	xSetComponent( hLog, "", "" );
	xSetFunctionName( hLog, "" );
	xStartVariation( hLog, "" );
	if( !xLog( hLog, XLL_PASS, "%d reboots", dwReboots ) )
	{
		printf( "  Could not write to log\n" );
		Sleep( INFINITE );
	}


	// check for Gamepad input.
	// don't reboot if there is gamepad input
	Sleep( 500 );
	XBGPInput_GetInput( pGamepads );
	for( int i = 0; i < 4; i++ )
	{
		if( pGamepads[i].hDevice )
		{
			dwPressedButtons = dwPressedButtons | pGamepads[i].wPressedButtons;
			dwPressedButtons = dwPressedButtons | pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_X ];
			dwPressedButtons = dwPressedButtons | pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ];
			dwPressedButtons = dwPressedButtons | pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_A ];
			dwPressedButtons = dwPressedButtons | pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_B ];
			dwPressedButtons = dwPressedButtons | pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ];
			dwPressedButtons = dwPressedButtons | pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_WHITE ];

			dwPressedBlackButton = pGamepads[i].bPressedAnalogButtons[ XINPUT_GAMEPAD_BLACK ];
		}
	}

	// if gamepad input, don't reboot, delete the reboot file
	if( dwPressedButtons )
	{
		printf("  Controller input detected\n");

		// reset count if black button was pressed
		if( dwPressedBlackButton )
		{
			printf("  Black button pressed\n");
			printf("  Resetting reboot count\n" );
			DeleteFile( FILENAME );
		}
		printf("\n  Stopped at %d reboots\n", dwReboots);
		printf("  Sleeping ..." );
		Sleep( INFINITE );
	}


	printf("  Reboot# %d\n", dwReboots );
	printf("  Initiating SMC \n  Power Cycle...");
	Sleep( 500 );
	
	

	WriteSMC( 0x02, 0x40 );


	Sleep( INFINITE );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\sysresetG\SMCPowerCycle.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    smcpowercycle.cpp

Abstract:

    test app that performs a power cycle

	note:  the MFG boot loader, or a disk with the same image, must be in the drive

	note:  eventually, this should be expanded to check a whole lot of stuff
	after a powercycle, but for now it is concentrating on DVD.

--*/


#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>
#include <stdlib.h>
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>
#include <fscache.h>
#include <xbinput.h>



#define FILENAME "t:\\resets.txt"



// SMC Functions

extern "C"
    {
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

DWORD WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }




void DebugPrint(LPWSTR format, ...)
    {
    va_list args;
    va_start(args, format);

    WCHAR szBuffer[1024];

    wsprintf(szBuffer, format, args);
    OutputDebugString(szBuffer);

    va_end(args);
    }



DWORD ReadFromFile( LPSTR lpFilename ,DWORD * pdwArray, DWORD dwSize)
{
	HANDLE hFile;
	DWORD result;
	DWORD dwBytesRead;

	// open the file for reading
	hFile = CreateFile(     lpFilename, 
							GENERIC_READ, 
							0,
							NULL, 
							OPEN_EXISTING, 
							FILE_ATTRIBUTE_NORMAL, 
							NULL );


	// set reboots to 0 if file doesn't exist,
	// otherwise, read reboots from the file
	if( INVALID_HANDLE_VALUE == hFile )
	{
		result = 0;
	}
	else
	{
		// get current # of reboots
		result = ReadFile( hFile, (LPVOID)pdwArray, dwSize, &dwBytesRead, NULL );
	}


	// close the file
	CloseHandle( hFile );
	hFile = INVALID_HANDLE_VALUE;

	return result;
}





VOID WriteToFile( LPSTR lpFilename, DWORD * pdwArray, DWORD dwSize )
{
	HANDLE hFile;
	DWORD dwBytesWritten;

	// open the file for writing
	hFile = CreateFile(		lpFilename, 
							GENERIC_WRITE, 
							0, 
							NULL,
							CREATE_ALWAYS, 
							FILE_ATTRIBUTE_NORMAL, 
							NULL );


	WriteFile( hFile, (LPCVOID)pdwArray, dwSize, &dwBytesWritten, NULL );
	

	// close the file
	CloseHandle( hFile );
	hFile = INVALID_HANDLE_VALUE;

}


enum {
	eResets,
	eGamePads,
	eMUs,
	eMikes,
	ePhones
};

USHORT GetSlort(DWORD SlotDiffs)
{
	USHORT Slot = 0;
	USHORT Port = 0;
	USHORT Slort;

	if(SlotDiffs & 0xff00)
	{
		Slot = 1;
	}
	SlotDiffs >>= 16 * Slot;
	Slort = Slot << 8; // put slot number in upper byte
	for(int i = 0; i<4; i++)
	{
		if(SlotDiffs & 1)
		{
			Port = (USHORT) i;
			break;
		}
		SlotDiffs >>= 1;
	}
	// build response
	Slort |= Port;
	return Slort;
}

void __cdecl main()
{
	HANDLE hLog;				// handle to the log file
	DWORD dwResets = 0;				// counter
//	XBGAMEPAD* pGamepads = NULL;
	DWORD dwGamepads,dwMUs,dwMicrophones,dwHeadphone;
	DWORD dwArray[5];
	DWORD dwResult;

	//DebugBreak();

	memset(dwArray,0x00,sizeof(dwArray));

	// create console
	xCreateConsole( NULL );
	xSetBackgroundImage( NULL );
	xSetFont( 15.0, 18.0, NULL );


	// create gamepads
	XInitDevices(0, NULL);
//	XBInput_CreateGamepads( &pGamepads );
	Sleep(2000); // allow enumeration time
	dwGamepads = XGetDevices(XDEVICE_TYPE_GAMEPAD);
	dwMUs = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
	dwMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
	dwHeadphone = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
	



	// create log
	hLog = xCreateLog( L"t:\\SMCPowerCycle.log", NULL, INVALID_SOCKET, XLL_LOGALL, XLO_DEBUG );
	if( !hLog )
	{
		printf( "  Could not create Log\n");
		DebugBreak();
	}
	xSetOwnerAlias( hLog, "sethmil" );
	xSetComponent( hLog, "Sysreset", "SMC" );
	xSetFunctionName( hLog, "Sysreset" );
	xStartVariation( hLog, "Sysreset stress" );

	// get and increment the # of reboots
	dwResult = ReadFromFile( FILENAME, dwArray, sizeof(dwArray) );
	if(dwResult)
	{
		dwArray[eResets]++; // increment cycle counter
		USHORT Slort;
		DWORD SlotDiffs ;
		int iPort , iSlot;
		SlotDiffs = iPort = iSlot = 0;
		if(dwArray[eGamePads] != dwGamepads)
		{
			DWORD diffs = dwArray[eGamePads] ^ dwGamepads;
			printf("     Diff found during reboot %d\n",dwArray[eResets]);

			int port = 0;
			for(int i = 0; i<4; i++)
			{
				if(diffs & 1)
				{
					port = i;
					break;
				}
				diffs >>= 1;
			}
			printf("\n     Change in Port %d\n",port);
			printf("  Resetting reboot count\n" );
			DeleteFile( FILENAME );
			Sleep( INFINITE );
		} else if(dwArray[eMUs] != dwMUs)
		{
			
			SlotDiffs = dwArray[eMUs] ^ dwMUs;
			Slort = GetSlort(SlotDiffs);
			printf("    Change in Memory Unit\n");
			printf("        Port %d\n",Slort & 0xff);
			printf("        Slot %d\n", (Slort & 0xff00) >> 16);
			DeleteFile(FILENAME);
			Sleep(INFINITE);

		} else if(dwArray[eMikes] != dwMicrophones)
		{
			SlotDiffs = dwArray[eMikes] ^ dwMicrophones;
			Slort = GetSlort(SlotDiffs);
			printf("    Change in Microphone\n");
			printf("        Port %d\n",Slort & 0xff);
			printf("        Slot %d\n", (Slort & 0xff00) >> 16);
			DeleteFile(FILENAME);
			Sleep(INFINITE);

		} else if(dwArray[ePhones] != dwHeadphone)
		{
			SlotDiffs = dwArray[ePhones] ^ dwHeadphone;
			Slort = GetSlort(SlotDiffs);
			printf("    Change in Headphone\n");
			printf("        Port %d\n",Slort & 0xff);
			printf("        Slot %d\n", (Slort & 0xff00) >> 16);
			DeleteFile(FILENAME);
			Sleep(INFINITE);
		}
		
		// inc resets, compare and rewrite
	} else 
	{
		// initialize and write
		dwArray[eResets] = 0;
		dwArray[eGamePads] = dwGamepads;
		dwArray[eMUs] = dwMUs;
		dwArray[eMikes] = dwMicrophones;
		dwArray[ePhones] = dwHeadphone;
	}

	WriteToFile( FILENAME, dwArray,sizeof(dwArray) );
	printf(" SysReset # %d\n", dwArray[eResets] );
	xLog( hLog, XLL_INFO, "SYSReset #: %d", dwResets );

	Sleep(1000); // allow enough time for cycle time printout to be seen by user

// now recycle power	

	WriteSMC( 0x02, 0x40 );

	Sleep( INFINITE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\xlogconio\xlogconio.cpp ===
//
// Overload xLog() to also call xDebugString
//
#include <xtl.h>
#include <xlog.h>
#include <dxconio.h>

// Global variable to turn on/off logging to console
BOOL gbConsoleOut = FALSE;

BOOL
WINAPI
xLog(
	IN	BOOL	bConsoleOut,
    IN  HANDLE  hLog,
    IN  DWORD   dwLogLevel,
    IN  LPSTR   lpszFormatString_A,
    IN  ...
)
{
	va_list argptr;

	// xLog() stuff
	va_start(argptr, lpszFormatString_A);
	xLog_va(hLog, dwLogLevel, lpszFormatString_A, argptr);

	if(bConsoleOut) {
		// xDebugString stuff
		va_start(argptr, lpszFormatString_A);
		xvprintf(lpszFormatString_A, argptr);
		xDebugStringA("\n");
	}
	return TRUE;
}

//
// Overload xStarVariation() to also call xDebugString
//
BOOL
WINAPI
xStartVariation(
	IN	BOOL	bConsoleOut,
    IN  HANDLE  hLog,
    IN  LPSTR   lpszVariationName_A
)
{
	xStartVariation(hLog, lpszVariationName_A);

	if(bConsoleOut) {
		xDebugStringA("%s: Start\n", lpszVariationName_A);	
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\cdda.cpp ===
#include "cdrip.h"
#include "cdda.h"

////////////////////////////////////////////////////////////////////////////

CCDDAStreamer::CCDDAStreamer( CNtIoctlCdromService* pDrive, DWORD dwRetries )
{
	ASSERT( pDrive != NULL );

	m_ibChunk = 0;
	m_pDrive = pDrive;
    m_dwRetries = dwRetries;
	m_dwCurFrame = 0;
    m_chunk = (BYTE*)XPhysicalAlloc( CDDA_BUFFER_SIZE, -1, 0, PAGE_READWRITE );
}

CCDDAStreamer::~CCDDAStreamer()
{
    if( m_chunk )
        XPhysicalFree( m_chunk );
}

int CCDDAStreamer::ReadFrames( void* pvBuffer, DWORD nFrameCount )
{
    DWORD nTotalFrames = m_pDrive->GetTrackFrame( m_pDrive->GetTrackCount() );
    nFrameCount = min( nFrameCount, nTotalFrames - m_dwCurFrame );
    ASSERT( (int)nFrameCount > 0 );

	HRESULT hr = m_pDrive->Read( m_dwCurFrame, nFrameCount, pvBuffer, m_dwRetries );
	if( FAILED(hr) )
	{
        ZeroMemory( pvBuffer, nFrameCount * CDAUDIO_BYTES_PER_FRAME );
        if( hr != HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) )
            return -1;
        else
            return 0;   // TODO: REVIEW: we probably hit end of the disc but need better way to detect this
	}

	m_dwCurFrame += nFrameCount;

	return nFrameCount * CDAUDIO_BYTES_PER_FRAME;
}

int CCDDAStreamer::Read( void* pvBuffer, int cbWanted )
{
    BYTE* pbBuffer = (BYTE*)pvBuffer;
    int cbRead;

    if( !m_chunk )
        return -1;

    if( m_ibChunk )
    {
        cbRead = min( cbWanted, CDDA_BUFFER_SIZE - m_ibChunk );

        CopyMemory( pbBuffer, m_chunk + m_ibChunk, cbRead );

        m_ibChunk += cbRead;
        m_ibChunk %= CDDA_BUFFER_SIZE;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    while( cbWanted >= CDDA_MAX_FRAMES_PER_READ * CDAUDIO_BYTES_PER_FRAME )
    {
        cbRead = ReadFrames( pbBuffer, CDDA_MAX_FRAMES_PER_READ );
        if( cbRead <= 0 )
            return cbRead;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    while( cbWanted >= CDDA_BUFFER_SIZE )
    {
        cbRead = ReadFrames( pbBuffer, CDDA_BUFFER_SIZE / CDAUDIO_BYTES_PER_FRAME );
        if( cbRead <= 0 )
            return cbRead;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    if( cbWanted )
    {
        cbRead = ReadFrames( m_chunk, CDDA_BUFFER_SIZE / CDAUDIO_BYTES_PER_FRAME );
        if( cbRead <= 0 )
            return cbRead;

        if( cbRead < CDDA_BUFFER_SIZE )
            ZeroMemory( m_chunk + cbRead, CDDA_BUFFER_SIZE - cbRead );

        m_ibChunk = cbWanted;
        cbRead = min( cbRead, cbWanted );
        CopyMemory( pbBuffer, m_chunk, cbRead );

        cbWanted -= cbRead;
        pbBuffer += cbRead;
	}

	return pbBuffer - (LPBYTE)pvBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\cdda.h ===
#pragma once
#include "ntiosvc.h"

#define CDDA_MAX_FRAMES_PER_READ 16
#define CDDA_BUFFER_SIZE (CDDA_MAX_FRAMES_PER_READ * CDAUDIO_BYTES_PER_FRAME)

class CCDDAStreamer
{
public:
	CCDDAStreamer( CNtIoctlCdromService* pDrive, DWORD dwRetries = 0 );
	~CCDDAStreamer();

	int Read( void* pvBuffer, int nBytes );
	
	inline DWORD GetFrame() const
	{
		return m_dwCurFrame;
	}
	
	inline void SetFrame( DWORD dwFrame )
	{
        DebugPrint( "CCDDAStreamer::SetFrame():Reseting CDDAStreamer frame to %d\n", dwFrame );
		m_dwCurFrame = dwFrame;
		m_ibChunk = 0;
	}

protected:
	int ReadFrames( void* pvBuffer, DWORD nFrameCount );

	BYTE* m_chunk;
	int m_ibChunk;

	CNtIoctlCdromService* m_pDrive;
    DWORD m_dwRetries;
	DWORD m_dwCurFrame;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\xbtools\xbnettest\xbnettest.cpp ===
#include <windows.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <XboxDbg.h>

#define BUFSIZE 1400

VOID
UsageFailure() {
	fprintf(stderr, "xbnettest\n Echos network data from the Xbox target system\n");
	fprintf(stderr, "\nusage: xbnettest address\n");
	fprintf(stderr, "\taddress = IP Address of target Xbox\n");
}

int
__cdecl
main(int argc, char* argv[]) {
	WSADATA			wsaData;
	SOCKET			sock;
	sockaddr_in		saXboxAddr, saLocalAddr, saFromAddr;
	u_short			sXboxPort;
	int				iRet, iBytesRecv, iBytesSent, iMsgs;
	char			cBuf[BUFSIZE];
	ULONG			ulXboxAddr;
	BYTE			*pb = (BYTE *)&ulXboxAddr;
	int				iSize;

	sXboxPort = IPPORT_RESERVED + 1;
	iBytesRecv = 0;
	iBytesSent = 0;

	// Get IP address from command line
	if(argc != 2) {
		// no IP address on command line
		UsageFailure();
		exit(1);
	}

	ulXboxAddr = inet_addr(argv[1]);
	printf("Xbox target system (%d.%d.%d.%d)\n", pb[0], pb[1], pb[2], pb[3]);

	// Start winsock
	if(WSAStartup( 0x202, &wsaData ) == SOCKET_ERROR) {
		fprintf(stderr,"WAStartup failed: error %d\n", WSAGetLastError());
		WSACleanup();
		return 1;
	}
	
	// Create UDP socket
	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if(sock == INVALID_SOCKET) {
		fprintf(stderr,"socket() failed: error %d\n", WSAGetLastError());
		WSACleanup();
		return 1;
	}

	// Bind socket to local address
	saLocalAddr.sin_family = AF_INET;
	saLocalAddr.sin_addr.s_addr = INADDR_ANY;
	saLocalAddr.sin_port = htons(sXboxPort);

	iRet = bind(sock, (sockaddr *)&saLocalAddr, sizeof(saLocalAddr));
	if(iRet == SOCKET_ERROR) {
		fprintf(stderr,"bind() failed: error %d\n", WSAGetLastError());
		WSACleanup();
		return 1;
	}

	// Populate Xbox address
	saXboxAddr.sin_family = AF_INET;
	saXboxAddr.sin_addr.s_addr = ulXboxAddr;
	saXboxAddr.sin_port = htons(sXboxPort);

	// Do a sendto() to inform Xbox of my address
	iRet = sendto(sock, cBuf, BUFSIZE, 0,(sockaddr *)&saXboxAddr, sizeof(saXboxAddr));
	if((iRet == SOCKET_ERROR)) {
		fprintf(stderr,"sendto() failed: error %d\n", WSAGetLastError());
		WSACleanup();
		return 1;
	}
	if(iRet != BUFSIZE) {
		fprintf(stderr,"sendto() only sent %d bytes of %d\n", iRet, BUFSIZE);
		WSACleanup();
		return 1;
	}

	// Echo data
	iMsgs = 0;
	for(;;) {
		// Receive data
		iSize = sizeof(saFromAddr);
		iRet = recvfrom(sock, cBuf, BUFSIZE, 0,(sockaddr *)&saFromAddr, &iSize);
		if((iRet == SOCKET_ERROR)) {
			fprintf(stderr,"recvfrom() failed: error %d\n", WSAGetLastError());
			WSACleanup();
			return 1;
		}
		if(iRet == 0) {
			// Xbox done, quit
			fprintf(stdout,"recvfrom() 0 bytes, exiting\n");
			break;
		}
		iBytesRecv += iRet;


		// Send data back
		iRet = sendto(sock, cBuf, BUFSIZE, 0,(sockaddr *)&saXboxAddr, sizeof(saXboxAddr));
		if((iRet == SOCKET_ERROR)) {
			fprintf(stderr,"sendto() failed: error %d\n", WSAGetLastError());
			WSACleanup();
			return 1;
		}
		if(iRet != BUFSIZE) {
			fprintf(stderr,"sendto() only sent %d bytes of %d\n", iRet, BUFSIZE);
			WSACleanup();
			return 1;
		}
		iBytesSent += iRet;

		iMsgs++;
	}

	fprintf(stderr, "%d Messages Echoed Bytes Read = %d, Sent = %d\n", iMsgs, iBytesRecv, iBytesSent);

	closesocket(sock);
	WSACleanup();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\cdrip.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CDRip.cpp

Abstract:

    Audio CD Ripping program

Notes:

*****************************************************************************/

#include "cdrip.h"
#include <xbeimage.h>
#include <mm.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

#pragma intrinsic( memcpy )


HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[XGetPortCount()*2] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

//
// config settings
//
ConfigSettings globalSettings;

//
// stats
//
DWORD g_dwTrackRipStartTime = 0;
DWORD g_dwTrackRipEndTime = 0;
DWORD g_dwTotalRipTime = 0;
DWORD g_dwNumTimesThrough = 0;
DWORD g_dwTestPassNumber = 1;
DWORD g_dwNumPass = 0;
DWORD g_dwNumFail = 0;
DWORD g_dwNumTracksRipped = 0;
DWORD g_dwTime = 0;
DWORD g_dwCurrentTrack = 0;
float g_fMegabytesRipped = 0.0f;
char g_pszModel[64], g_pszSerial[64], g_pszFirmware[64];

//
// Globals
//
CNtIoctlCdromService g_DVDRom;
BYTE* g_pbyTrackBuffer = NULL;
LAUNCH_DATA g_launchInfo;
ToTestData* g_pInitialParams = NULL;
HANDLE g_hThread = NULL;
CRITICAL_SECTION g_CritSect;
BOOL g_bExitThread = FALSE;             // Used to signal our thread to exit
DWORD* g_adwTracks = NULL;
char* g_iniConfig = NULL;

void ParseTestConfig( char *variable, char *value, void *userParam )
{
    ConfigSettings* pSettings = (ConfigSettings*)userParam;

    if(strstr(variable, "cdtitle") != NULL)             strcpy(pSettings->pszCDTitle, value);
    else if(strstr(variable, "cdserial") != NULL)       strcpy(pSettings->pszCDSerial, value);
    else if(strstr(variable, "starttrack") != NULL)     pSettings->dwStartTrack = GetNumber(value);
    else if(strstr(variable, "endtrack") != NULL)       pSettings->dwEndTrack = GetNumber(value);
    else if(strstr(variable, "ripsequence") != NULL)    pSettings->dwRipSequence = GetNumber(value);
    else if(strstr(variable, "randseed") != NULL)       pSettings->dwRandSeed = GetNumber(value);
    else if(strstr(variable, "pauseonexit") != NULL)    pSettings->dwPauseOnExit = GetNumber(value);

    // DebugPrint( "var - '%hs' = '%hs'\r\n", variable, value );
}

void _cdecl main(void)
{
    // TODO: Calculate the MBits and MBits per second

    //
    // Get the launch data (if any)
    //
    DWORD dwDataType = 0xCDCDCDCD;
    XGetLaunchInfo( &dwDataType, &g_launchInfo );
    g_pInitialParams = (ToTestData*)&g_launchInfo;

    //
    // cleanup old files
    //
    DeleteFile("T:\\testexit.txt");

    DWORD dwAddDevice, dwRemoveDevice;

    //
    // Grab the startup parameters
    //
    if( g_pInitialParams->titleID == HVSLAUNCHERID )
    {
        g_iniConfig = new char[strlen(g_pInitialParams->configSettings)+1];
        strcpy(g_iniConfig, g_pInitialParams->configSettings);
        ParseConfigSettings( g_pInitialParams->configSettings, &globalSettings, ParseTestConfig, &globalSettings );
    }
    else
    {
        FILE* pFile = fopen("D:\\CDRip.ini", "rb");
        if( NULL != pFile )
        {
            DWORD dwFilesize = _filelength( _fileno( pFile ) );
            g_iniConfig = new char[dwFilesize+1];
            if( 1 != fread( g_iniConfig, dwFilesize, 1, pFile ) ) DebugPrint( "Failed to read the starup params!!\r\n" );
            g_iniConfig[dwFilesize] = '\0';

            ParseConfigSettings( g_iniConfig, &globalSettings, ParseTestConfig, &globalSettings );
            if( 0 != fseek( pFile, 0, SEEK_SET ) ) DebugPrint( "Failed to seek properly!!\r\n" );
            if( 1 != fread( g_iniConfig, dwFilesize, 1, pFile ) ) DebugPrint( "Failed to read the starup params!!\r\n" );
            g_iniConfig[dwFilesize] = '\0';
            fclose( pFile );
        }
    }

    // Call SetSaveName BEFORE calling LogPrint or LogFlush
    SetSaveName( globalSettings.saveName, "CDRip.log" );
    LogFlush();

    Initialize();

    if( g_pInitialParams->titleID == HVSLAUNCHERID )
        LogPrint( "Launched from HVS\n  Test %u of %u\n\n", g_pInitialParams->testNumber, g_pInitialParams->totalTests );
    else
        LogPrint( "Running in stand a lone mode\n\n" );

    LogPrint("CD Rip (Built on " __DATE__ " at " __TIME__ ")\n");
    LogPrint("Copyright (C) Microsoft Corporation.  All rights reserved.\n\n");

    // Make sure the proper type of disc is in the drive
    int nDiscType = GetDiscType();
    if( DISC_AUDIO != nDiscType )
    {
        LogPrint( "Invalid Disc Type.  Must be CD Audio Disc!! - '%d'\n", nDiscType );
        CleanUp();
        RebootToShell( 0, 1, "Invalid Media Type Detected\\nMake sure an Audio CD is in the DVD Drive before\\nyou launch the test\n" );
    }

    //
    // Open the DVD / CD Drive
    //
    if( FAILED( g_DVDRom.Open() ) )
    {
        LogPrint( "Unable to open the DVD Drive!!\n" );
        CleanUp();
        RebootToShell( 0, 1, "Unable to open the DVD Drive!!\n" );
    }

    XCDROM_TOC* pTOC = g_DVDRom.GetTOC();
    // Debug Print the TOC
    DebugPrint( "TOC\n" );
    for( int iToc = 0; iToc <= pTOC->LastTrack; iToc++ )
        DebugPrint( "  Track %03d Address: 0x%08X\n", iToc, pTOC->TrackAddr[iToc] );

    // Check if our user wants to set the last track to the end of the CD, or if they specified an invalid last track
    if( ( 0 == globalSettings.dwEndTrack ) || ( (int)globalSettings.dwEndTrack > g_DVDRom.GetTOC()->LastTrack ) )
        globalSettings.dwEndTrack = g_DVDRom.GetTOC()->LastTrack;

    // Check to see if the first track is greater than the last track
    if( globalSettings.dwStartTrack > globalSettings.dwEndTrack )
    {
        LogPrint( "Start Track (%u) was greater than End Track (%u), setting Start to End\n", globalSettings.dwStartTrack, globalSettings.dwEndTrack );
        globalSettings.dwStartTrack = globalSettings.dwEndTrack;
    }

    // Set our random seed
    srand( globalSettings.dwRandSeed );

    // Setup our Track Index
    DWORD dwNumTracks = globalSettings.dwEndTrack - globalSettings.dwStartTrack + 1;
    g_adwTracks = new DWORD[dwNumTracks];
    unsigned int uiCount = 0;
    for( unsigned int x = globalSettings.dwStartTrack; x <= globalSettings.dwEndTrack; x++ )
    {
        g_adwTracks[uiCount] = x;
        uiCount++;
    }

    // Handle random mode
    if( 1 == globalSettings.dwRipSequence )     // 0 = Sequential, 1 = Random
        RandomizeTracks( g_adwTracks );

    // Set our current track to the first track in our list
    SetCurrentTrack( 0 );

    //
    // print out the drive info, disk geometry, and config settings
    //
    ZeroMemory( g_pszModel, 64 );
    ZeroMemory( g_pszSerial, 64 );
    ZeroMemory( g_pszFirmware, 64 );
    GetDriveID( g_DVDRom.GetDeviceHandle(), TRUE, g_pszModel, g_pszSerial, g_pszFirmware );

	LogPrint("DRIVE: Model:             %s\n", g_pszModel );
	LogPrint("DRIVE: Serial:            %s\n", g_pszSerial );
	LogPrint("DRIVE: Firmware:          %s\n", g_pszFirmware );

    //
    // allocate buffer space
    //
    g_pbyTrackBuffer = new BYTE[BLOCK_SIZE];
    if( NULL == g_pbyTrackBuffer )
    {
        DebugPrint( "\n\n\nUnable to allocate enough buffer space (%u)\n", BLOCK_SIZE );
        DebugPrint( "Rebooting...\n\n\n" );
        CleanUp();
        RebootToShell( 0, 1, "Unable to allocate enough buffer space!!\n" );

        return;
    }

    g_dwTime = GetTickCount();

    //
    // run the test
    //
    DebugPrint( "Pass Number: %u\n", g_dwTestPassNumber );

    while( TRUE )
    {
        XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwAddDevice, &dwRemoveDevice );
        InputDukeInsertions( dwAddDevice, dwRemoveDevice );
        XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwAddDevice, &dwRemoveDevice );
        InputMUInsertions( dwAddDevice, dwRemoveDevice );
        UpdateGraphics( DISPLAYMODE_RUN_TIME );

        // Check to see if we should stop
        if( globalSettings.stopAfter.duration )
        {
            if( ( globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && g_dwNumTimesThrough >= globalSettings.stopAfter.duration ) ||
                ( globalSettings.stopAfter.type == STOPAFTER_MINUTES    && TICK2MIN( GetTickCount() - g_dwTime ) >= globalSettings.stopAfter.duration ) ||
                ( globalSettings.stopAfter.type == STOPAFTER_HOURS      && TICK2HOUR( GetTickCount() - g_dwTime ) >= globalSettings.stopAfter.duration ) )
            {
                break;
            }
        }

        if( InputCheckDigitalButton( XINPUT_GAMEPAD_START ) ) GUI();

        if( InputCheckExitCombo() )
            break;

        DWORD dwThreadStatus;
        GetExitCodeThread( g_hThread, &dwThreadStatus );

        if( ( STILL_ACTIVE != dwThreadStatus ) && 
            ( GetCurrentTrack() < dwNumTracks ) )
        {
            // Check for Copy Error

            // Close our thread handle if it's still open
            if( NULL != g_hThread )
            {
                CloseHandle( g_hThread );
                g_hThread = NULL;
            }
            
            DWORD dwCurrentTrack = GetCurrentTrack();

            // Start our thread copying a track
            g_hThread = CreateThread( NULL,
                                    0,
                                    AudioTrackCopyThread,
                                    &g_adwTracks[dwCurrentTrack],
                                    0,
                                    NULL );

            if( NULL == g_hThread )
            {
                DebugPrint( "Unable to create our thread!! Error - '0x%08X (%d)'\n", GetLastError(), GetLastError() );
                break;
            }
        }

        // Check to see if we have ripped all of the tracks necessary
        if( GetCurrentTrack() >= dwNumTracks )
        {
            g_dwNumTimesThrough++;
            g_dwTestPassNumber++;
            if( globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && g_dwNumTimesThrough >= globalSettings.stopAfter.duration )
                g_dwTestPassNumber--;

            DebugPrint( "Pass Number: %u\n", g_dwTestPassNumber );

            //
            // Reset all of the parameters to start another loop
            //

            // Handle random mode
            if( 1 == globalSettings.dwRipSequence )     // 0 = Sequential, 1 = Random
                RandomizeTracks( g_adwTracks );
           
            SetCurrentTrack( 0 );

            continue;
        }
    } // While

    UpdateGraphics( DISPLAYMODE_RUN_TIME );

    LogPrint( "\nNumber of failures - '%u'\n", g_dwNumFail );
    LogPrint( "Number of passes   - '%u'\n", g_dwNumPass );

    // Figure out the test notes
    char pszNotes[MAX_PATH+1];
    pszNotes[MAX_PATH] = '\0';

    sprintf( pszNotes, "CD Title: %hs\\nCD Serial: %hs\\nRip Sequence: %hs\\nTotal Tracks Ripped: %u\\nTotal Time to Rip Tracks: %u seconds\\nTotal Megabytes Ripped: %0.2f\\nMegabytes Ripped per second: %0.2f\n", globalSettings.pszCDTitle, globalSettings.pszCDSerial, globalSettings.dwRipSequence?"Random":"Sequential", GetTracksRipped(), GetTotalRipTime() / 1000, GetMegabytesRipped(), GetMegabytesRippedPerSecond() );

    //
    // Post results if necessary
    //
    if( strncmp( globalSettings.resultsServer, "http://", 7 ) == 0 )
    {
        WSADATA wsaData;
        DBDATA results;
        unsigned short version = MAKEWORD(2, 2);
        WSAStartup( version, &wsaData );

        results.deviceType = "DVD";
        results.manufacturer = RightTrim( g_pszModel );
        results.firmwareVersion = RightTrim( g_pszFirmware );
        results.hardwareVersion = "";
        results.serialNumber = RightTrim( g_pszSerial );
        results.testName = "CD Rip";

        results.boxInformation = GetBoxInformation();
        results.configSettings = g_iniConfig;
        char variation[256];
        results.variation = variation;
        sprintf(variation, "Rip Sequence: %hs", globalSettings.dwRipSequence?"Random":"Sequential" );

        // passes
        results.status = 1;
        results.numOperations = g_dwNumPass;
        results.notes = pszNotes;
        PostResults( globalSettings.resultsServer, &results );

        // cleanup
        delete[] results.boxInformation;
    }

    // Cleanup
    CleanUp();

    // Close the drive
    g_DVDRom.Close();

    if( globalSettings.dwPauseOnExit )
        Pause();
    else
        g_pDevice->PersistDisplay();            // persist the display across the reboot

    //
    // test done, reboot
    //
    g_dwNumPass++;
    RebootToShell( g_dwNumPass, g_dwNumFail, pszNotes );
}

FORCEINLINE ULONG
REG_RD32(VOID* Ptr, ULONG Addr)
{
    return *((volatile DWORD*)((BYTE*)(Ptr) + (Addr)));
}

void Initialize( void )
{
    //
    // USB
    //
    XInitDevices(0, NULL);

    //
    // Network
    //
    XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    XNetStartup(&xnsp);

    //
    // Graphics
    //
    InitGraphics();

    //
    // Thread
    //
    ZeroMemory( &g_CritSect, sizeof( g_CritSect ) );
    InitializeCriticalSection( &g_CritSect );
}

void CleanUp( void )
{
    // Check to see if our thread is still active.  If so, end it
    DWORD dwThreadStatus;
    GetExitCodeThread( g_hThread, &dwThreadStatus );

    if( STILL_ACTIVE == dwThreadStatus )
    {
        SetExitThread( TRUE );

        // Wait 5 seconds for the thread to exit
        DWORD dwWaitStatus = WaitForSingleObject( g_hThread, INFINITE );
        if( WAIT_FAILED == dwWaitStatus )
            DebugPrint( "CleanUp():WaitForSingleObject Failed!! - '0x%08X (%d)'\n", GetLastError(), GetLastError() );
    }

    // Close our thread handle if it's still open
    if( NULL != g_hThread )
    {
        CloseHandle( g_hThread );
        g_hThread = NULL;
    }

    DeleteCriticalSection( &g_CritSect );

    // Clean up any allocated memory
    if( NULL != g_adwTracks ) delete[] g_adwTracks;
    g_adwTracks = NULL;

    if( g_iniConfig != NULL ) delete[] g_iniConfig;
    g_iniConfig = NULL;

    if( NULL != g_pbyTrackBuffer ) delete[] g_pbyTrackBuffer;
    g_pbyTrackBuffer = NULL;
}


// Used to reboot to our launching program
void RebootToShell( DWORD dwNumPassed, DWORD dwNumFailed, char* pszNotes )
{
    if(g_pInitialParams->titleID == HVSLAUNCHERID)
    {
        ToLauncherData* outParams = (ToLauncherData*)&g_launchInfo;
        outParams->titleID = XeImageHeader()->Certificate->TitleID;
        outParams->numPass = dwNumPassed;
        outParams->numFail = dwNumFailed;
        strcpy( outParams->notes, pszNotes );

        LogPrint( pszNotes );

        LaunchImage("D:\\default.xbe", &g_launchInfo);
    }
    else
    {
        XLaunchNewImage(NULL, NULL);
    }
}

void RandomizeTracks( DWORD* adwTracks )
{
    DWORD dwNumTracks = globalSettings.dwEndTrack - globalSettings.dwStartTrack + 1;
    for( unsigned int x = 0; x < dwNumTracks; x++ )
    {
        int iRand = rand() % dwNumTracks;

        DWORD dwTemp = adwTracks[x];
        adwTracks[x] = adwTracks[iRand];
        adwTracks[iRand] = dwTemp;
    }

    // TODO: DEBUG -- REMOVE
    DebugPrint( "Track Order\n" );
    for( x = 0; x < dwNumTracks; x++ )
        DebugPrint( "  Track #%d\n", g_adwTracks[x] );
}

//////
// Thread Functions
//////
DWORD GetCurrentTrack( void )
{
    DWORD dwReturn = 0;
    EnterCriticalSection( &g_CritSect );
    dwReturn = g_dwCurrentTrack;
    LeaveCriticalSection( &g_CritSect );

    return dwReturn;
}

void SetCurrentTrack( DWORD dwCurrentTrack )
{
    EnterCriticalSection( &g_CritSect );
    g_dwCurrentTrack = dwCurrentTrack;
    LeaveCriticalSection( &g_CritSect );
}

void IncCurrentTrack( void )
{
    EnterCriticalSection( &g_CritSect );
    g_dwCurrentTrack++;
    LeaveCriticalSection( &g_CritSect );
}


DWORD GetTracksRipped( void )
{
    DWORD dwReturn = 0;
    EnterCriticalSection( &g_CritSect );
    dwReturn = g_dwNumTracksRipped;
    LeaveCriticalSection( &g_CritSect );

    return dwReturn;
}

void SetTracksRipped( DWORD dwTracksRipped )
{
    EnterCriticalSection( &g_CritSect );
    g_dwNumTracksRipped = dwTracksRipped;
    LeaveCriticalSection( &g_CritSect );
}

void IncTracksRipped( void )
{
    EnterCriticalSection( &g_CritSect );
    g_dwNumTracksRipped++;
    LeaveCriticalSection( &g_CritSect );
}

BOOL GetExitThread( void )
{
    BOOL bReturn;
    EnterCriticalSection( &g_CritSect );
    bReturn = g_bExitThread;
    LeaveCriticalSection( &g_CritSect );

    return bReturn;
}

void SetExitThread( BOOL bThreadExit )
{
    EnterCriticalSection( &g_CritSect );
    g_bExitThread = bThreadExit;
    LeaveCriticalSection( &g_CritSect );
}


DWORD GetTotalRipTime( void )
{
    DWORD dwReturn;

    EnterCriticalSection( &g_CritSect );
    dwReturn = g_dwTotalRipTime;
    LeaveCriticalSection( &g_CritSect );

    return dwReturn;
}

void SetTotalRipTime( DWORD dwRipTime )
{
    EnterCriticalSection( &g_CritSect );
    g_dwTotalRipTime = dwRipTime;
    LeaveCriticalSection( &g_CritSect );
}


float GetMegabytesRipped( void )
{
    float fReturn;

    EnterCriticalSection( &g_CritSect );
    fReturn = g_fMegabytesRipped;
    LeaveCriticalSection( &g_CritSect );

    return fReturn;
}

void SetMegabytesRipped( float fMegabytesRipped )
{
    EnterCriticalSection( &g_CritSect );
    g_fMegabytesRipped = fMegabytesRipped;
    LeaveCriticalSection( &g_CritSect );
}


float GetMegabytesRippedPerSecond()
{
    float fMegabytesRipped = GetMegabytesRipped();
    
    // Let's make sure we don't divide by zero
    if( ( 0 == fMegabytesRipped ) || ( 0 == GetTotalRipTime() ) )
        return 0;

    return( fMegabytesRipped / (float)( GetTotalRipTime() / 1000 ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\cdrip.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    CDRip.h

Abstract:

    Audio CD Ripping program

Notes:

*****************************************************************************/

#ifndef _CDRIP_H_
#define _CDRIP_H_

#ifdef _VC
//#define DEVICE_TYPE ULONG
#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500
#endif

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <ntos.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>

#include <dm.h>
#include <xtl.h>
#include <stdio.h>
#include <smcdef.h>
#include <wmfencode.h>

#include "../utils/hvsUtils.h"
#include "bitfont.h"
#include "ntiosvc.h"
#include "cdda.h"

extern CNtIoctlCdromService g_DVDRom;


//
// utility functions
//
void DebugPrint( char* format,
                 ... );

long GetNumber( char *string );

void GetDriveID( HANDLE hDevice,
                 bool cdrom,
                 char* model,
                 char* serial,
                 char* firmware );

void RebootToShell( DWORD dwNumPassed,  // Used to reboot to our launching program
                    DWORD dwNumFailed,
                    char* pszNotes );

int CopyAudioTrack( int nTrack );      // Copy a Track from the Audio CD to the Hard Disc


bool CompressAudio( char* pszSrcPath,   // Compress our audio file in to a WMA File
                    char* pszDestPath,
                    short sMax );

DWORD WINAPI AudioTrackCopyThread( LPVOID lpParameter );    // Copy Audio Track Thread Function

//
// Initialization calls
//
void Initialize( void );
void CleanUp( void );
HRESULT DeInitGraphics( void );
HRESULT InitGraphics( void );

//
// User input
// 
void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);
bool InputCheckButton(int button);
bool InputCheckDigitalButton(int button);
void Pause(void);
int ThumbStickScale(int stick, int max);
void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale);


//
// Graphics / GUI methods
//
enum DISPLAY_MODE
    {
    DISPLAYMODE_PAUSE,
    DISPLAYMODE_RUN_TIME,
    DISPLAYMODE_CONFIG_READONLY,
    DISPLAYMODE_CONFIG_INTERACTIVE
    };
void UpdateGraphics(unsigned mode = DISPLAYMODE_RUN_TIME);
void GUI(void);
void GraphicPrint(IDirect3DSurface8* pd3ds,
                  unsigned x,
                  unsigned line,
                  DWORD color,
                  char* format,
                  ... );


//
// Utility functions
//
void HexDump(const unsigned char * buffer, DWORD length);
WCHAR* Ansi2UnicodeHack(char *str);
BOOL CompareBuff( unsigned char *buff1, unsigned char *buff2, unsigned length );
int GetDiscType();
void RandomizeTracks( DWORD* adwTracks );

//
// Protected/Shared Memory Functions
//
DWORD GetCurrentTrack( void );
void SetCurrentTrack( DWORD dwCurrentTrack );
void IncCurrentTrack( void );

DWORD GetTracksRipped( void );
void SetTracksRipped( DWORD dwTracksRipped );
void IncTracksRipped( void );

BOOL GetExitThread( void );
void SetExitThread( BOOL bThreadExit );

DWORD GetTotalRipTime( void );
void SetTotalRipTime( DWORD dwRipTime );

float GetMegabytesRipped( void );
float GetMegabytesRippedPerSecond();
void SetMegabytesRipped( float fMegabytesRipped );


//
// Media Types
//
#define DISC_NONE               0
#define DISC_BAD                1
#define DISC_TITLE              2
#define DISC_AUDIO              3
#define DISC_VIDEO              4

//
// CD Rip Info
//
#define BLOCK_SIZE              16384
#define COPY_NO_ERROR           0
#define COPY_HARDDISK_FULL      1
#define COPY_TOO_MANY_SONGS     2
#define COPY_DISC_EJECTED       3
#define COPY_DISC_READ_ERROR    4

//
// User input
//
extern HANDLE hDuke[XGetPortCount()];
extern HANDLE hSlot[XGetPortCount()*2];
static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };

//
// config settings
//
struct ConfigSettings : public CoreConfigSettings
{
    char pszCDTitle[MAX_PATH];
    char pszCDSerial[MAX_PATH];
    DWORD dwStartTrack;
    DWORD dwEndTrack;
    DWORD dwRipSequence;
    DWORD dwRandSeed;
    DWORD dwPauseOnExit;

    ConfigSettings()
    {
        ZeroMemory( pszCDTitle, MAX_PATH );
        ZeroMemory( pszCDSerial, MAX_PATH );
        dwStartTrack = 0;
        dwEndTrack = 0;
        dwRipSequence = 0;
        dwRandSeed = 0;
        dwPauseOnExit = 0;
    }
};

extern ConfigSettings globalSettings;

//
// stats
//
extern DWORD g_dwTrackRipStartTime;
extern DWORD g_dwTrackRipEndTime;
extern DWORD g_dwNumTimesThrough;
extern DWORD g_dwTestPassNumber;
extern DWORD g_dwNumPass;
extern DWORD g_dwNumFail;
extern DWORD g_dwTime;
extern char g_pszModel[64];
extern char g_pszSerial[64];
extern char g_pszFirmware[64];
extern BYTE* g_pbyTrackBuffer;
extern DWORD* g_adwTracks;

//
// graphics
//
extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;

#endif //_CDRIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\gui.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    gui.cpp

Abstract:

    Low level disk test scanner.

Notes:

*****************************************************************************/
#include "cdrip.h"

IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText	= NULL;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;

#define STICK_DEAD_ZONE         6400
#define BUTTON_PRESS_VALUE      100
#define BUTTON_SPEEP_VALUE      150         // in ms

#define COLUMN_1_OFFSET         25
#define COLUMN_2_OFFSET         165

int ThumbStickScale(int stick, int max)
    {
    if(stick > 0) stick -= STICK_DEAD_ZONE;
    else stick += STICK_DEAD_ZONE;

    return (stick*max)/(32768-STICK_DEAD_ZONE);
    }


void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale)
    {
    // UP
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
        {
        ++value;
        if(value > max) value = max;
        }
    if(input.Gamepad.sThumbLY > STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value > max) value = max;
        }

    // DOWN
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
        {
        --value;
        if(value < min) value = min;
        if(value > max) value = min;
        }
    if(input.Gamepad.sThumbLY < -STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value < min) value = min;
        if(value > max) value = min;
        }
    }

DWORD buttonXColor, buttonYColor, buttonAColor, buttonBColor, buttonBlkColor, buttonWhtColor;
DWORD currentSelection = 0;

void GUI(void)
{
    bool exit = false;
    DWORD addDevice, removeDevice;
    XINPUT_STATE state;

    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
        for(unsigned port=0; port<XGetPortCount(); port++)
        {
            if(hDuke[port])
            {
                XInputGetState(hDuke[port], &state);
                if(state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) exit = true;
            }
        }

        UpdateGraphics( DISPLAYMODE_CONFIG_READONLY );

        Sleep(BUTTON_SPEEP_VALUE);
}

    // sleep past any residual user input presses
    Sleep(BUTTON_SPEEP_VALUE);
    buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
    }


void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...)
    {
    char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, x, (line+1)*10, 0, color, 0);
    }


void UpdateGraphics(unsigned mode /*=DISPLAYMODE_RUN_TIME*/)
{
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // run time status mode
    //
    if( mode == DISPLAYMODE_RUN_TIME || mode == DISPLAYMODE_PAUSE )
    {
        GraphicPrint( pd3ds, COLUMN_1_OFFSET, 1, 0xFF4444FF, "CD Rip" );
	    GraphicPrint( pd3ds, COLUMN_1_OFFSET, 2, 0xFF4444FF, "DVD Drive Model: %hs", g_pszModel );
	    GraphicPrint( pd3ds, COLUMN_1_OFFSET, 3, 0xFF4444FF, "DVD Drive Firmware: %hs", g_pszFirmware );
        GraphicPrint( pd3ds, COLUMN_1_OFFSET, 4, 0xFF4444FF, "DVD Drive Serial #: %hs", g_pszSerial );

        unsigned line = 6;
        GraphicPrint( pd3ds, COLUMN_1_OFFSET, line, 0xFFFFFFFF, "CD Title: %hs", globalSettings.pszCDTitle );
        GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "CD Serial #: %hs", globalSettings.pszCDSerial );

        GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Starting Track: %u", globalSettings.dwStartTrack );
        GraphicPrint( pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, "Ending Track: %u", globalSettings.dwEndTrack );
        
        // GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Block Size: %u", globalSettings.dwBlockSize );

        GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Current Track: %u", g_adwTracks[GetCurrentTrack()] );
        DWORD dwTotalTracks = globalSettings.dwEndTrack - globalSettings.dwStartTrack + 1;
        GraphicPrint( pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, "Total Tracks: %u", dwTotalTracks );

        GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Rip Sequence: %hs", globalSettings.dwRipSequence?"Random":"Sequential" );
        GraphicPrint( pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, "Run Time: %u sec", ( GetTickCount() - g_dwTime ) / 1000 );

        GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Tracks Ripped: %u", GetTracksRipped() );
        GraphicPrint( pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, "Total Rip Time: %u sec", GetTotalRipTime() / 1000 );

        GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "MB Ripped: %0.2f", GetMegabytesRipped() );
        GraphicPrint( pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, "MB Ripped/sec: %0.2f", GetMegabytesRippedPerSecond() );

        GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Iteration #%u", g_dwTestPassNumber );

        if( globalSettings.stopAfter.type == STOPAFTER_ITERATIONS )
            GraphicPrint( pd3ds, COLUMN_2_OFFSET,  line, 0xFFFFFFFF, "Duration: %u iteration(s)", globalSettings.stopAfter.duration );
        else if( globalSettings.stopAfter.type == STOPAFTER_MINUTES )
            GraphicPrint( pd3ds, COLUMN_2_OFFSET,  line, 0xFFFFFFFF, "Duration: %u minute(s)", globalSettings.stopAfter.duration );
        else if( globalSettings.stopAfter.type == STOPAFTER_HOURS )
            GraphicPrint( pd3ds, COLUMN_2_OFFSET,  line, 0xFFFFFFFF, "Duration: %u hour(s)", globalSettings.stopAfter.duration );

        line++;

        // GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFF00FF00, "Pass %u", g_dwNumPass );
        // GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFF0000, "Fail %u", g_dwNumFail );

        if( mode == DISPLAYMODE_RUN_TIME )
        {
	        GraphicPrint( pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Press START to view the current settings" );
	        GraphicPrint( pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press Left Trigger + Right Trigger + Black to reboot" );
        }
        else if( mode == DISPLAYMODE_PAUSE )
        {
	        GraphicPrint( pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFF00,  "PAUSED" );
	        GraphicPrint( pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFF00,  "Press BACK to continue" );
        }
    }

    //
    // config setup gui
    //
    else if( mode == DISPLAYMODE_CONFIG_READONLY )
    {
        DWORD color;
        if(mode == 2) color = 0xFF777777;
        else color = 0xFFFFFFFF;

        if(mode == DISPLAYMODE_CONFIG_INTERACTIVE) // interactive
        {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Use the DPAD or Left Thumbstick UP/DOWN to change the values");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press START to continue");
        }
        else // non interactive
        {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press BACK to continue");
        }
    }

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
}



bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                {
                LogPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    // check for exit file
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile("T:\\testexit.txt", &FindFileData);
    FindClose(hFind);
    if(hFind != INVALID_HANDLE_VALUE)
        {
        LogPrint("\r\n\r\nFound Exit File (testexit.txt) - rebooting\r\n");
        return true;
        }

    return false;
    }


bool InputCheckButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE)
                {
                return true;
                }
            }
        }

    return false;
    }


bool InputCheckDigitalButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.wButtons & button)
                {
                return true;
                }
            }
        }

    return false;
    }


void Pause(void)
    {
    DWORD addDevice, removeDevice;
    OutputDebugStringA("*****************************************************************************\n");
    OutputDebugStringA("* Entered Paused State. Hit the BACK button to resume...\n");
    OutputDebugStringA("*****************************************************************************\n");
    while(!InputCheckDigitalButton(XINPUT_GAMEPAD_BACK))
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        UpdateGraphics(DISPLAYMODE_PAUSE);

        Sleep(BUTTON_SPEEP_VALUE);
        }
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            //LogPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }


void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned i=0; i<XGetPortCount()*2; i++)
        {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[i]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[i]), XMUSlotFromDriveLetter((char)hSlot[i]));
            hSlot[i] = NULL;
            }
        if(add & USBSlotMasks[i])
            {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
                {
                hSlot[i] = (HANDLE)drive;
                //LogPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[i])+1, XMUSlotFromDriveLetter((char)hSlot[i])+1);
                }
            }
        }
    }


/*

Routine Description:

	De-initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT DeInitGraphics(void)
{
    g_pDevice->Release();
    g_pDevice = NULL;

    g_pd3dtText->Release();
    g_pd3dtText = NULL;

    return S_OK;
}

/*

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT InitGraphics(void)
{
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;

    // Release D3D Object
    g_d3d->Release();
    g_d3d = NULL;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

    // Clear our persisted memory
    g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskRead\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\ntiosvc.cpp ===
#include "cdrip.h"
#include "ntiosvc.h"

////////////////////////////////////////////////////////////////////////////

CNtIoctlCdromService::CNtIoctlCdromService()
{
    m_hDevice = INVALID_HANDLE_VALUE;
}

CNtIoctlCdromService::~CNtIoctlCdromService()
{
    Close();
}

void CNtIoctlCdromService::Close()
{
    if( m_hDevice != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hDevice );
        m_hDevice = INVALID_HANDLE_VALUE;
    }

    m_toc.Delete();
}

HRESULT CNtIoctlCdromService::Open()
{
    // If the user calls this, make sure we're closed before trying to re-open
    if( IsOpen() )
        Close();

    ASSERT( m_hDevice == INVALID_HANDLE_VALUE );

    m_hDevice = CreateFile( "CDROM0:",
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if (m_hDevice == INVALID_HANDLE_VALUE)
    {
        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    if ( !GetTableOfContents() )
        Close();

    return S_OK;
}


bool CNtIoctlCdromService::GetTableOfContents()
{
    HRESULT hr;
    CDROM_TOC toc;

    for( int nRetry = 0; nRetry < 1; nRetry += 1 )
    {
        hr = DeviceIoControl( IOCTL_CDROM_READ_TOC, NULL, 0, &toc, sizeof(toc) );

        if( SUCCEEDED(hr) )
            break;

        if( hr != HRESULT_FROM_WIN32( ERROR_NOT_READY ) )
            return false;
        else
            DebugPrint( "CNtIoctlCdromService::GetTableOfContents():ERROR_NOT_READY\n" );
    }

    if( FAILED(hr) )
        return false;

    // BLOCK: Convert TOC format...
    {
        DebugPrint( "CNtIoctlCdromService::GetTableOfContents():Read TOC: %d tracks\n", toc.LastTrack );

        // Verify that the TOC is structurally correct and has at least one
        // track.
        if( toc.FirstTrack > toc.LastTrack )
            return false;

        BOOL fFoundEndTrack = FALSE;

        for( DWORD i = 0; i <= (DWORD)( toc.LastTrack - toc.FirstTrack + 1 ); i++ )
        {
#define TOC_DATA_TRACK              (0x04)
#define TOC_LAST_TRACK              (0xaa)

            m_toc.TrackAddr[i] = TocValToFrames( toc.TrackData[i].Address );

            // Break out if we find a last track marker.
            if( toc.TrackData[i].TrackNumber == TOC_LAST_TRACK )
            {
                fFoundEndTrack = TRUE;
                break;
            }

            // Break out if we find a data track.
            if( ( toc.TrackData[i].Control & TOC_DATA_TRACK ) != 0 )
            {
                // Knock off 2.5 minutes to account for the final leadin.
                toc.TrackData[i].Address[1] -= 2;
                toc.TrackData[i].Address[2] += 30;

                if( toc.TrackData[i].Address[2] < 60 )
                    toc.TrackData[i].Address[1] -= 1;
                else
                    toc.TrackData[i].Address[2] -= 60;

                m_toc.TrackAddr[i] = TocValToFrames( toc.TrackData[i].Address );

                fFoundEndTrack = TRUE;
                break;
            }
        }

        // If we didn't find an ending track, whether it be a data track or a
        // track with the last track marker, then knock off one track because we
        // don't know how long the last "audio" track might really be.  We can't
        // underflow "i" here because the above code already checked for an
        // empty TOC.
        if( !fFoundEndTrack )
            i--;

        m_toc.LastTrack = i;
    }

    return m_toc.LastTrack > 0;
}

HRESULT CNtIoctlCdromService::Read( DWORD dwReadStart, DWORD dwReadLength, LPVOID pvBuffer, DWORD dwRetries )
{
    RAW_READ_INFO rri;
    HRESULT hr;

    // NT drivers seem to want the disk offset to be (sector - 150) * 2048,
    // regardless of what the actual disk lead-in amount is.
    rri.DiskOffset.QuadPart = (ULONGLONG)( dwReadStart - 150 ) * (ULONGLONG)2048;
    rri.SectorCount = dwReadLength;
    rri.TrackMode = CDDA;

    do
    {
        hr = DeviceIoControl( IOCTL_CDROM_RAW_READ, &rri, sizeof( rri ), pvBuffer, CDAUDIO_BYTES_PER_FRAME * dwReadLength );
        if( SUCCEEDED(hr) )
            break;
    }
    while( dwRetries-- );

    return hr;
}

HRESULT CNtIoctlCdromService::DeviceIoControl( DWORD dwControlCode, LPVOID pvInBuffer, DWORD dwInBufferSize, LPVOID pvOutBuffer, DWORD dwOutBufferSize, LPDWORD pdwBytesReturned )
{
    DWORD dwBytesReturned;

    if( pdwBytesReturned == NULL )
        pdwBytesReturned = &dwBytesReturned;

    if( !::DeviceIoControl( m_hDevice, dwControlCode, pvInBuffer, dwInBufferSize, pvOutBuffer, dwOutBufferSize, pdwBytesReturned, NULL ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}

bool CNtIoctlCdromService::GetTotalLength( int* pnMinutes, int* pnSeconds, int* pnFrames )
{
    if( !IsOpen() )
        return false;

    DWORD dwFrames = m_toc.TrackAddr[GetTrackCount()] - m_toc.TrackAddr[0];
    DWORD dwMsf = FramesToMsf( dwFrames );

    if( pnMinutes != NULL )
        *pnMinutes = MCI_MSF_MINUTE( dwMsf );

    if( pnSeconds != NULL )
        *pnSeconds = MCI_MSF_SECOND( dwMsf );

    if( pnFrames != NULL )
        *pnFrames = MCI_MSF_FRAME( dwMsf );

    return true;
}

bool CNtIoctlCdromService::GetTrackLength( int nTrack, int* pnMinutes, int* pnSeconds, int* pnFrames )
{
    if ( !IsOpen() || ( nTrack < 0 ) || ( nTrack > ( GetTrackCount() - 1 ) ) )
        return false;

    DWORD dwFrames = m_toc.TrackAddr[nTrack + 1] - m_toc.TrackAddr[nTrack];
    DWORD dwMsf = FramesToMsf( dwFrames );

    if( pnMinutes != NULL )
        *pnMinutes = MCI_MSF_MINUTE( dwMsf );

    if( pnSeconds != NULL )
        *pnSeconds = MCI_MSF_SECOND( dwMsf );

    if( pnFrames != NULL )
        *pnFrames = MCI_MSF_FRAME( dwMsf );

    return true;
}

////////////////////////////////////////////////////////////////////////////

XCDROM_TOC::XCDROM_TOC()
{
    Clear();
}

XCDROM_TOC::~XCDROM_TOC()
{
    Delete();
}

void XCDROM_TOC::Delete()
{
    Clear();
}

void XCDROM_TOC::Clear()
{
    LastTrack = 0;
}

int XCDROM_TOC::GetTrackFromFrame( DWORD dwPosition ) const
{
    for( int i = 0; i < LastTrack; i++ )
    {
        if( dwPosition < TrackAddr[i + 1] )
            return i;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\ntiosvc.h ===
#pragma once
#include "xcddefs.h"

class CNtIoctlCdromService
{
private:
	HANDLE m_hDevice;

public:
	CNtIoctlCdromService();
	~CNtIoctlCdromService();
    
    inline HANDLE GetDeviceHandle() { return m_hDevice; };
    inline XCDROM_TOC* GetTOC() { return &m_toc; };

	HRESULT Open();
	
    void Close();
	
    HRESULT Read( DWORD dwReadStart,
                  DWORD dwReadLength,
                  LPVOID pvBuffer,
                  DWORD dwRetries = 0 );

	inline bool IsOpen() const
	{
		return m_hDevice != INVALID_HANDLE_VALUE;
	}

	inline int GetTrackCount() const
	{
		if ( !IsOpen() )
			return 0;

		return m_toc.LastTrack;
	}

	bool GetTotalLength( int* pnMinutes,
                         int* pnSeconds,
                         int* pnFrames );
	
    bool GetTrackLength( int nTrack,
                         int* pnMinutes,
                         int* pnSeconds,
                         int* pnFrames );

	inline DWORD GetTrackFrame( int nTrack ) const
	{
		if ( !IsOpen() )
			return 0;

		ASSERT( nTrack >= 0 && nTrack <= m_toc.LastTrack );
		return m_toc.TrackAddr[nTrack];
	}

	inline int GetTrackFromFrame( DWORD dwFrame ) const
	{
		return m_toc.GetTrackFromFrame( dwFrame );
	}

protected:
	XCDROM_TOC m_toc;
	bool GetTableOfContents();
	HRESULT DeviceIoControl( DWORD dwControlCode,
                             LPVOID pvInBuffer = NULL,
                             DWORD dwInBufferSize = 0,
                             LPVOID pvOutBuffer = NULL,
                             DWORD dwOutBufferSize = 0,
                             LPDWORD pdwBytesReturned = NULL );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    Helper functions

Notes:

*****************************************************************************/

#include "cdrip.h"

BOOL CompareBuff( unsigned char *buff1, unsigned char *buff2, unsigned length )
{
    BOOL bReturn = TRUE;

    for(unsigned i=0; i<length; i++)
    {
        if(buff1[i] != buff2[i])
        {
            // LogPrint("    %u: %02X %02X\n", i, buff1[i], buff2[i] );
            bReturn = FALSE;
            break;
        }
    }

    return bReturn;
}

/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    char *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
BOOL FileExists( const char* pszFilename )
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    BOOL fRetval = FALSE;

    hFind = FindFirstFile( pszFilename, &FindFileData );

    if( hFind != INVALID_HANDLE_VALUE )
        fRetval = true;

    FindClose( hFind );

    return fRetval;
}

struct DISCTYPECHECK
{
    char* szPath;
    char* szDiscType;
    int nDiscType;
};

static const DISCTYPECHECK rgddc [] =
{
    { "CDROM0:\\default.xbe",            "Title", DISC_TITLE },
    { "CDROM0:\\video_ts\\video_ts.ifo", "Video", DISC_VIDEO },
    { "CDROM0:\\track01.cda",            "Audio", DISC_AUDIO },
};


// Returns the type of disc that is inserted in to the Xbox DVD Rom Drive
int GetDiscType()
{
    int nDiscType = DISC_BAD;
    bool bRetry = true;

    if( g_DVDRom.IsOpen() )
        g_DVDRom.Close();

    OBJECT_STRING DeviceName;
    RtlInitObjectString(&DeviceName, "\\??\\CdRom0:");
    IoDismountVolumeByName( &DeviceName );

    NTSTATUS Status;
    ULONG TrayState;
    Status = HalReadSMCTrayState( &TrayState, NULL );
    if( NT_SUCCESS( Status ) && TrayState != SMC_TRAY_STATE_MEDIA_DETECT )
    {
        if( TrayState == SMC_TRAY_STATE_NO_MEDIA )
        {
            HANDLE hDevice;

            // At this point, the drive has told the SMC that media could not be
            // detected.  To decide whether this means that the tray is empty
            // versus the tray have unrecognized media, we need to send an IOCTL
            // to the device.

            hDevice = CreateFileA( "cdrom0:",
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL );

            if (hDevice != NULL)
            {
                BOOL fReturn;
                DWORD cbReturned;

                fReturn = DeviceIoControl( hDevice,
                                           IOCTL_CDROM_CHECK_VERIFY,
                                           NULL,
                                           0,
                                           NULL,
                                           0,
                                           &cbReturned,
                                           NULL );

                // If the device reports back that the unit is ready (which it
                // shouldn't since the SMC thinks the tray is empty) or if the
                // media is unrecognized, then the disc is bad.
                if( fReturn || ( GetLastError() == ERROR_UNRECOGNIZED_MEDIA ) )
                {
                    CloseHandle( hDevice );
                    return DISC_BAD;
                }

                CloseHandle( hDevice );
            }
        }
        return DISC_NONE;
    }

    g_DVDRom.Open();

    if( g_DVDRom.IsOpen() )
        return DISC_AUDIO;

    for( int i = 0; i < sizeof (rgddc) / sizeof (DISCTYPECHECK); )
    {
        if( FileExists( rgddc[i].szPath ) )
        {
            nDiscType = rgddc[i].nDiscType;
            break;
        }

        DWORD dwError = GetLastError();

        if( dwError != ERROR_FILE_NOT_FOUND && dwError != ERROR_PATH_NOT_FOUND )
        {
            DebugPrint( "GetDiscType():Error %d on %s\n", dwError, rgddc[i].szPath );

            if( bRetry )
            {
                DebugPrint( "GetDiscType():Retrying...\n" );
                bRetry = false;
                Sleep(100);
                continue;
            }
        }

        i++;
        bRetry = true;
    }

    return nDiscType;
}

void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware)
{
    unsigned i;
    DWORD returned;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;
    bool closeHandle = false;

    if(hDevice == NULL)
    {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        if(cdrom)
            RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        else
            RtlInitObjectString(&VolumeString, "\\Device\\Harddisk0\\Partition0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
    }

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(cdrom) atapt->IdeReg.bCommandReg = 0xA1;
    else atapt->IdeReg.bCommandReg = 0xEC;

    DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH, atapt, sizeof(ATA_PASS_THROUGH), atapt, sizeof(ATA_PASS_THROUGH), &returned, FALSE);
    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for(i=0; i<sizeof(IdData->ModelNumber); i+=2)
    {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
    }
    model[i] = 0;

    for(i=0; i<sizeof(IdData->SerialNumber); i+=2)
    {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
    }
    serial[i] = 0;

    for(i=0; i<sizeof(IdData->FirmwareRevision); i+=2)
    {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
    }
    firmware[i] = 0;

    if(closeHandle) NtClose(hDevice);
}

static HANDLE g_hFile;
static short* g_psNormalizeMap;
DWORD g_dwMusicCompressPos;
DWORD g_dwMusicCompressLength;
DWORD g_dwEncodeReadBufferPos;
DWORD g_dwEncodeReadBufferLength;
LPBYTE g_lpbEncodeReadBuffer;

// Copy a Track from the Audio CD to the Hard Disc
int CopyAudioTrack( int nTrack ) // CCopySong* pCopySong, TCHAR* pszTrackName )
{
    float fReadProgress = 0.0f;
    int nError = COPY_NO_ERROR;

    CCDDAStreamer streamer( &g_DVDRom, 5 );

    DWORD dwStartPosition = g_DVDRom.GetTrackFrame( nTrack );
    DWORD dwStopPosition = g_DVDRom.GetTrackFrame( nTrack + 1 );
    DWORD dwLength = ( dwStopPosition - dwStartPosition ) * 1000 / CDAUDIO_FRAMES_PER_SECOND;

    if (dwStopPosition < dwStartPosition)
        dwLength = 0;

    // Check if disc is ejected
    if( !g_DVDRom.IsOpen() )
    {
        nError = COPY_DISC_EJECTED;
        dwLength = 0;
    }
    else if( dwLength == 0 )
        nError = COPY_DISC_READ_ERROR;

    if( nError )
        goto end_ripping;

    streamer.SetFrame( dwStartPosition );

    char pszDestFile[MAX_PATH+1];
    pszDestFile[MAX_PATH] = '\0';

    strcpy( pszDestFile, "z:\\AudioCDTrack.pcm" );
    HANDLE hDestFile = CreateFileA( pszDestFile,
                                    GENERIC_WRITE | GENERIC_READ,
                                    0,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_FLAG_SEQUENTIAL_SCAN,
                                    NULL );
    if (hDestFile == INVALID_HANDLE_VALUE)
    {
        DebugPrint( "CreateFile(%hs)) failed\n", pszDestFile );
        nError = COPY_HARDDISK_FULL; // hard disk full
        return nError;
    }

    // Allocate the clusters for the file now.
    LARGE_INTEGER liDistanceToMove;
    liDistanceToMove.QuadPart = (LONGLONG)( dwStopPosition - dwStartPosition ) * CDAUDIO_BYTES_PER_FRAME;
    if ( !SetFilePointerEx( hDestFile, liDistanceToMove, NULL, FILE_BEGIN ) ||
         !SetEndOfFile( hDestFile ) )
    {
        DebugPrint( "SetEndOfFile(%hs) failed\n", pszDestFile );
        nError = COPY_HARDDISK_FULL; // hard disk full
    }

    // Check if we have enough space for WMA file
    ULARGE_INTEGER luiFreeBytesAvailable;
    if ( !GetDiskFreeSpaceEx( "Z:\\", &luiFreeBytesAvailable, 0, 0 ) || \
         luiFreeBytesAvailable.QuadPart < (ULONGLONG)liDistanceToMove.QuadPart )
    {
        DebugPrint( "Not enough space for WMA file\n" );
        nError = COPY_HARDDISK_FULL;
    }

    SetFilePointer( hDestFile, 0, NULL, FILE_BEGIN );

    DebugPrint( "Copying track %d from CD to %hs...\n", nTrack, pszDestFile );

    DWORD dwBytesRemaining = liDistanceToMove.LowPart;
    short sMax = -32767;
    while ( ( !nError ) && ( dwBytesRemaining > 0 ) && ( !GetExitThread() ) )
    {
        int nRead = streamer.Read( g_pbyTrackBuffer, min( BLOCK_SIZE, dwBytesRemaining ) );
        if( nRead == 0 )
            break;

        if( nRead < 0 )
        {
            nError = g_DVDRom.IsOpen() ? COPY_DISC_READ_ERROR : COPY_DISC_EJECTED;
            break;
        }

        DWORD dwWrite;
        if ( !WriteFile( hDestFile, g_pbyTrackBuffer, nRead, &dwWrite, NULL ) )
        {
            nError = COPY_HARDDISK_FULL; // hard disk full
            break;
        }

        int nSamples = nRead / 2;
        const short* samples = (const short*)g_pbyTrackBuffer;
        for( int i = 0; i < nSamples; i += 1, samples += 1 )
        {
            short s = *samples;
            if (s < 0)
                s = -s;
            if (s > sMax)
                sMax = s;
        }

        fReadProgress = (float)( min( streamer.GetFrame(), dwStopPosition ) -
            dwStartPosition ) / ( dwStopPosition - dwStartPosition );

        dwBytesRemaining -= nRead;
    }

    if( !SetEndOfFile( hDestFile ) )
    {
        DebugPrint( "SetEndOfFile(%hs) failed\n", pszDestFile );
        nError = COPY_HARDDISK_FULL; // hard disk full
    }

    if( !CloseHandle( hDestFile ) )
    {
        DebugPrint( "CloseHandle(%hs) failed\n", pszDestFile );
        nError = COPY_HARDDISK_FULL; // hard disk full
    }

    // Don't try to compress the file if the user is trying to end the thread
    if( GetExitThread() )
        goto end_ripping;

    char pszDestWMAFile[MAX_PATH+1];
    pszDestWMAFile[MAX_PATH] = '\0';

    sprintf( pszDestWMAFile, "z:\\AudioCDTrack_%d.wma", nTrack );
    if( !nError )
    {
        DebugPrint( "Compression audio file...\n" );
        nError = CompressAudio( pszDestFile, "z:\\1stwma.wma", sMax ) ? COPY_NO_ERROR : COPY_HARDDISK_FULL;

        if( !nError )
        {
            if( !MoveFileEx( "z:\\1stwma.wma", pszDestWMAFile, 0 ) )
            {
                DebugPrint( "MoveFileEx(%hs, %hs) failed (%d)\n", "z:\\1stwma.wma", pszDestWMAFile, GetLastError() );
                
                // Delete our 1st WMA File
                DeleteFileA( "z:\\1stwma.wma" );
            }
        }
    }

    // Delete the PCM File
    DeleteFileA( pszDestFile );

    // Delete the WMA File
    DeleteFileA( pszDestWMAFile );

    // Update our Megabyte's ripped if the user hasn't aborted the rip
    if( !GetExitThread() )
    {
        float fMegabytesRipped = GetMegabytesRipped();
        SetMegabytesRipped( fMegabytesRipped + ( (float)liDistanceToMove.QuadPart / (1024.0f*1024.0f) ) );
    }

end_ripping:
    NOTHING;

    return nError;
}

// Compress our audio file in to a WMA File
bool CompressAudio( char* pszSrcPath, char* pszDestPath, short sMax )
{
    g_hFile = CreateFileA( pszSrcPath,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL );
    if( g_hFile == INVALID_HANDLE_VALUE )
    {
        DebugPrint( "CompressAudio: Cannot open source file: %s\n", pszSrcPath );
        return false;
    }

    g_dwMusicCompressLength = GetFileSize( g_hFile, NULL );

    tWMFEncodeStatus tStatus;
    U32_WMF cbBuffer;
    char szAlteredPath [MAX_PATH];

    HWMFENCODER hWMFEnc = WMFCreateEncoderUsingProfile( &tStatus,
                                                        pszDestPath,
                                                        Profile_AudioOnly_CDAudiophileQuality_128K,
                                                        2,
                                                        44100,
                                                        16,
                                                        g_dwMusicCompressLength,
                                                        &cbBuffer,
                                                        0,
                                                        0,
                                                        0,
                                                        0,
                                                        0,
                                                        0,
                                                        0,
                                                        0,
                                                        0,
                                                        0,
                                                        WMF_NoPreProcess,
                                                        szAlteredPath );

    if( tStatus != WMF_Succeeded )
    {
        DebugPrint( "CompressAudio: WMFCreateEncoderUsingProfile failed (%d)\n", tStatus );
        g_dwMusicCompressLength = 0;
        return false;
    }

    ASSERT( hWMFEnc != NULL );

    BYTE* pbBuffer = new U8_WMF[cbBuffer];
    if( pbBuffer == NULL )
    {
        DebugPrint( "Not enough memory to compress audio!\n" );
        g_dwMusicCompressLength = 0;
        CloseHandle( g_hFile );
        WMFClose(hWMFEnc);
        return false;
    }

    g_dwEncodeReadBufferPos = 0;
    g_dwEncodeReadBufferLength = 0;
    g_lpbEncodeReadBuffer = new BYTE [cbBuffer];

    if( g_lpbEncodeReadBuffer == NULL )
    {
        DebugPrint( "Not enough memory to compress audio!\n" );
        g_dwMusicCompressLength = 0;
        CloseHandle( g_hFile );
        WMFClose(hWMFEnc);
        delete [] pbBuffer;
        return false;
    }

    if( sMax > 0 && sMax < 32767 )
    {
        g_psNormalizeMap = new short [65536];
        if( g_psNormalizeMap != NULL )
        {
            float f = 32767.0f / (float)sMax;
            for( int i = 0; i < 65536; i += 1 )
            {
                float s = (float)(i - 32768) / 32767.0f;
                g_psNormalizeMap[i] = (short)( ( s * f ) * 32767.0f );
            }
        }
    }

    tStatus = WMFEncode( hWMFEnc, pbBuffer, cbBuffer, 0, 0 );

    g_dwMusicCompressLength = 0;
    g_dwMusicCompressPos = 0;

    if( g_psNormalizeMap != NULL )
    {
        delete[] g_psNormalizeMap;
        g_psNormalizeMap = NULL;
    }

    if( g_lpbEncodeReadBuffer != NULL)
    {
        delete [] g_lpbEncodeReadBuffer;
        g_lpbEncodeReadBuffer = NULL;
    }

    if( tStatus != WMF_Succeeded )
    {
        DebugPrint( "CompressAudio: WMFEncode failed (%d)\n", tStatus );
        CloseHandle( g_hFile );
        WMFClose(hWMFEnc);
        delete [] pbBuffer;
        return false;
    }

    CloseHandle( g_hFile );
    DeleteFile( pszSrcPath );
    WMFClose( hWMFEnc );
    delete [] pbBuffer;

    DebugPrint( "CompressAudio: complete!\n" );

    return true;
}


I32_WMF WMFCBGetAudioData( U8_WMF** ppbAudioDataBuffer, U32_WMF nInputBufferLen, I64_WMF iSampleOffset, I32_WMF iNumSamplesWanted )
{
    DWORD nBytesNeeded;
    DWORD nBytesRead;
    DWORD nThrowAwayBytes;
    LPVOID lpvReadData;

    DebugPrint( "WMFCBGetAudioData: %d %d\n", (int)iSampleOffset, (int)iNumSamplesWanted );

    g_dwMusicCompressPos = (DWORD)iSampleOffset * sizeof( I16_WMF ) * 2;

    //
    // The WMA encoder ends up re-reading the same regions of the file over and
    // over, so to reduce I/O overhead, we add a buffer to keep the portions of
    // the file that we've already read.  The encoder appears to only read the
    // file in increasing sample offsets, so the cache only moves in one
    // direction.
    //

    nBytesNeeded = iNumSamplesWanted * sizeof( I16_WMF ) * 2;

    if( ( g_dwMusicCompressPos >= g_dwEncodeReadBufferPos ) &&
        ( g_dwMusicCompressPos < g_dwEncodeReadBufferPos + g_dwEncodeReadBufferLength ) )
    {

        nThrowAwayBytes = g_dwMusicCompressPos - g_dwEncodeReadBufferPos;

        g_dwEncodeReadBufferLength -= nThrowAwayBytes;

        MoveMemory( g_lpbEncodeReadBuffer, g_lpbEncodeReadBuffer + nThrowAwayBytes,
            g_dwEncodeReadBufferLength );

    } else {
        g_dwEncodeReadBufferLength = 0;
    }

    g_dwEncodeReadBufferPos = g_dwMusicCompressPos;

    if( g_dwEncodeReadBufferLength < nBytesNeeded ) {

        if( SetFilePointer( g_hFile, g_dwEncodeReadBufferPos +
            g_dwEncodeReadBufferLength, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER ) {
            return 0;
        }

        lpvReadData = g_lpbEncodeReadBuffer + g_dwEncodeReadBufferLength;

        if ( !ReadFile( g_hFile, lpvReadData, nBytesNeeded - g_dwEncodeReadBufferLength,
            &nBytesRead, NULL ) ) {
            return 0;
        }

        nBytesRead &= ~1;
        g_dwEncodeReadBufferLength += nBytesRead;

        if( g_psNormalizeMap != NULL ) {

            short* ps = (short*)lpvReadData;
            short* map = &g_psNormalizeMap[32768];
            for (UINT i = 0; i < nBytesRead; i += 2, ps += 1)
                *ps = map[*ps];
        }
    }

    nBytesRead = nBytesNeeded;

    if( nBytesRead > g_dwEncodeReadBufferLength ) {
        nBytesRead = g_dwEncodeReadBufferLength;
    }

    CopyMemory( *ppbAudioDataBuffer, g_lpbEncodeReadBuffer, nBytesRead );

    return (I32_WMF) nBytesRead;
}

// Thread Proc which will copy our song
DWORD WINAPI AudioTrackCopyThread( LPVOID lpParameter )
{
    int iTrackNum = *((int*)lpParameter);

    g_dwTrackRipStartTime = GetTickCount();
    int nReturn = CopyAudioTrack( iTrackNum - 1 );
    g_dwTrackRipEndTime = GetTickCount();

    // Make sure we increment our counters
    if( !GetExitThread() )
    {
        // Update our Total Rip Time
        DWORD dwTotRipTime = GetTotalRipTime();
        SetTotalRipTime( dwTotRipTime + ( g_dwTrackRipEndTime - g_dwTrackRipStartTime ) );
        g_dwTrackRipStartTime = 0;
        g_dwTrackRipEndTime = 0;

        IncTracksRipped();
        IncCurrentTrack();
    }

    return nReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskRead\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskRead\diskRead.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    diskRead.h

Abstract:

    Low level disk test scanner.

Notes:
    dvd player code:
        "\xboxsrc\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp"
    filesystem retry code:
        "\xboxsrc\private\ntos\idex\cdrom.c" (IdexCdRomFinishRequestSense)
    sense data format:
        "\xboxsrc\public\ddk\inc\scsi.h"


    DVD-X2 Supported Error Sense Codes
        Sense   Sense   Sense   Description
        Key	    Code    Code Qu
        ----------------------------------------------------------------------
        0x00	0x00	0x00	No Additional Sense information (= no error)
        0x01	0x80	0x00	Cache fill error, speed reduction requested
        0x02	0x04	0x00	Logical Unit not ready, cause not reported
        0x02	0x04	0x01	Logical Unit is in process of becoming ready
        0x02	0x30	0x00	Incompatible medium installed
        0x02	0x3A	0x00	Medium not present
        0x03	0x57	0x00	Unable to recover Table of Contents
        0x03	0x80	0x00	Read Error
        0x04	0x00	0x00	Hardware error
        0x04	0x08	0x03	Logical Unit Communication CRC Error - UDMA33
        0x05	0x21	0x00	Logical Block Address Out of Range
        0x05	0x55	0x00	System Resource Failure
        0x05	0x64	0x00	Illegal mode for this track
        0x05	0x6F	0x00	Authentication Failure - CSS
        0x05	0x80	0x00	Authentication Failure - Xbox
        0x05	0x81	0x00	Command error
        0x06	0x29	0x00	Power On, Reset or Bus Device Reset occurred
        0x06	0x2A	0x01	Mode Parameters changed
        0x06	0x2E	0x00	Insufficient time for operation

    Win32 Error code mapping:
        1/80:   ERROR_CRC                   23
        2/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        2/other ERROR_NOT_READY             21
        3/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        3/other ERROR_CRC                   23
        5/21:   ERROR_SECTOR_NOT_FOUND      27
        5/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        5/6F:   ERROR_TOO_MANY_SECRETS      1381
        5/80:   ERROR_TOO_MANY_SECRETS      1381
        other:  ERROR_IO_DEVICE             1117

    IOCTL_CDROM_SET_SPINDLE_SPEED
        speed 2     ~3000rpm      2x -    5x
        speed 1     ~2000rpm    4/3x - 10/3x
        speed 0     ~1000rpm    2/3x -  5/3x

    Hard Drive Partition Sizes
        \Device\Harddisk0\Partition0 19541088
        \Device\Harddisk0\Partition1  9997568
        \Device\Harddisk0\Partition2  1023840
        \Device\Harddisk0\Partition3  1535776
        \Device\Harddisk0\Partition4  1535776
        \Device\Harddisk0\Partition5  1535776

*****************************************************************************/

#ifndef _DISKREAD_H_
#define _DISKREAD_H_

#ifdef _VC
//#define DEVICE_TYPE ULONG
#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500
#endif

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>

#include <xtl.h>
#include <stdio.h>

#include "../utils/hvsUtils.h"
#include "bitfont.h"

//
// utility functions
//
void DebugPrint(char* format, ...);
long GetNumber(char *string);

enum READ_MODES
    {
    READMODE_DETECT = 0,
    READMODE_DVD,
    READMODE_CD,
    READMODE_HD,
    READMODE_MAX
    };

struct SCSIError
    {
    DWORD win32;
    SENSE_DATA sense;

    SCSIError() {win32=0; memset(&sense, 0, sizeof(SENSE_DATA)); }
    void Print(bool full=true)
        {
        unsigned char *s = (unsigned char*)&sense;
        if(full)
            LogPrint("(%u (%08X) [<%02X> %02X <%02X> %02X%02X%02X%02X %02X %02X%02X%02X%02X <%02X> <%02X> %02X %02X%02X%02X])",
                RtlNtStatusToDosError(win32), win32, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15], s[16], s[17]);
        else
            LogPrint("(%u (%08X) [<%02X> -- <%02X> -------- -- -------- <%02X> <%02X> -- ------])",
                RtlNtStatusToDosError(win32), win32, s[0], s[2], s[12], s[13]);
        }
    unsigned SPrint(char *output, bool full=true)
        {
        unsigned char *s = (unsigned char*)&sense;
        if(full)
            return sprintf(output, "(%u (%08X) [<%02X> %02X <%02X> %02X%02X%02X%02X %02X %02X%02X%02X%02X <%02X> <%02X> %02X %02X%02X%02X])",
                RtlNtStatusToDosError(win32), win32, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11], s[12], s[13], s[14], s[15], s[16], s[17]);
        else
            return sprintf(output, "(%u (%08X) [<%02X> -- <%02X> -------- -- -------- <%02X> <%02X> -- ------])",
                RtlNtStatusToDosError(win32), win32, s[0], s[2], s[12], s[13]);
        }
    };

class ErrorDistrubition
    {
    public:
        SCSIError error;
        DWORD count;
        ErrorDistrubition *next;

    public:
        ErrorDistrubition(SCSIError &e)
            {
            memcpy(&error, &e, sizeof(SCSIError));
            count = 1;
            next = NULL;
            }

        void AddError(SCSIError &e)
            {
            ErrorDistrubition *ptr = this;
            while(ptr)
                {
                if((ptr->error.sense.ErrorCode                     == e.sense.ErrorCode)           &&
                    (ptr->error.sense.Valid                        == e.sense.Valid)               &&
                    (ptr->error.sense.SenseKey                     == e.sense.SenseKey)            &&
                    (ptr->error.sense.Reserved                     == e.sense.Reserved)            &&
                    (ptr->error.sense.IncorrectLength              == e.sense.IncorrectLength)     &&
                    (ptr->error.sense.EndOfMedia                   == e.sense.EndOfMedia)          &&
                    (ptr->error.sense.FileMark                     == e.sense.FileMark)            &&
                    (ptr->error.sense.AdditionalSenseCode          == e.sense.AdditionalSenseCode) &&
                    (ptr->error.sense.AdditionalSenseCodeQualifier == e.sense.AdditionalSenseCodeQualifier))
                    {
                    ptr->count++;
                    return;
                    }
                else if(!ptr->next)
                    {
                    ptr->next = new ErrorDistrubition(e);
                    return;
                    }
                ptr = ptr->next;
                }
            }

        void RemoveError(SCSIError &e, DWORD count)
            {
            ErrorDistrubition *ptr = this;
            while(ptr)
                {
                if(memcmp(&ptr->error, &e, sizeof(SCSIError)) == 0)
                    {
                    ptr->count -= count;
                    return;
                    }
                ptr = ptr->next;
                }
            }

        void PrintErrors(void)
            {
            ErrorDistrubition *ptr = this;
            while(ptr)
                {
                LogPrint("*** %9u Errors of ", ptr->count);
                ptr->error.Print(false);
                LogPrint("\n");
                ptr = ptr->next;
                }
            }
        void SPrintErrors(char *output)
            {
            ErrorDistrubition *ptr = this;
            while(ptr)
                {
                output += sprintf(output, "%5u Errors of ", ptr->count);
                output += ptr->error.SPrint(output, false);
                output += sprintf(output, "\n");
                ptr = ptr->next;
                }
            }
    };


struct ExcludeList
    {
    DWORD lba1, lba2;
    ExcludeList *next;

    ExcludeList() { lba1=lba2=0; next=NULL; }
    ExcludeList(char *pair)
        {
        next = NULL;
        lba1 = GetNumber(pair);
        char *tmp = strchr(pair, '-');
        if(tmp) lba2 = GetNumber(tmp+1);
        else lba2 = lba1;
        }
    void Add(char *pair)
        {
        ExcludeList *ptr = this;
        while(ptr)
            {
            if(!ptr->next)
                {
                ptr->next = new ExcludeList(pair);
                return;
                }
            ptr = ptr->next;
            }
        }
    bool InList(DWORD lba, DWORD readSize)
        {
        ExcludeList *ptr = this;
        while(ptr)
            {
            if(lba+readSize >= ptr->lba1 && lba <= ptr->lba2)
                {
                return true;
                }
            ptr = ptr->next;
            }
        return false;
        }
    };





//
// Initialization calls
//
void Initialize(void);
HRESULT InitGraphics(void);

//
// User input
// 
void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);
bool InputCheckButton(int button);
bool InputCheckDigitalButton(int button);
void Pause(void);
int ThumbStickScale(int stick, int max);
void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale);


//
// Graphics / GUI methods
//
enum DISPLAY_MODE
    {
    DISPLAYMODE_PAUSE,
    DISPLAYMODE_RUN_TIME,
    DISPLAYMODE_CONFIG_READONLY,
    DISPLAYMODE_CONFIG_INTERACTIVE
    };
void UpdateGraphics(unsigned mode = DISPLAYMODE_RUN_TIME);
void GUI(void);
void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...);


//
// Utility functions
//
void HexDump(const unsigned char * buffer, DWORD length);
WCHAR* Ansi2UnicodeHack(char *str);
void PrintPreRetryError(DWORD block, SCSIError &err);
void CompareBuff(unsigned char *buff1, unsigned char *buff2, unsigned char *buff3, unsigned length);


//
// DVD utils
//
typedef SCSIError (*READ_FUNC)(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
SCSIError ReadDVDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
SCSIError ReadCDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
SCSIError ReadCDBlocks2(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
SCSIError ReadHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
void SeekLBA(HANDLE hDevice, DWORD LBA);
void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
void ChangeSpeed(HANDLE hDevice, DWORD newSpeed);
bool CDTestReady(HANDLE hDevice);
void RequestSense(HANDLE hDevice, SCSIError &sense);
DWORD GetDiskType(HANDLE hDevice);
DWORD DeviceIoControlWStatus(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);


//
// User input
//
extern HANDLE hDuke[XGetPortCount()];
extern HANDLE hSlot[XGetPortCount()*2];
static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };

enum MEDIA_TYPES
	{
	MEDIA_UNKNOWN,
	MEDIA_CDDA,
	MEDIA_CDROM,
	MEDIA_DVD_5_RO,
	MEDIA_DVD_5_RW,
	MEDIA_DVD_9_RO,
	MEDIA_DVD_9_RW,
	MEDIA_HD
	};

static const char *mediaTypeNames[] = 
    {
    "Unknown",
    "CD DA",
    "CD ROM",
    "DVD 5 RO",
    "DVD 5 RW",
    "DVD 9 RO",
    "DVD 9 RW",
    "Hard Disk"
    };

//
// config settings
//
struct ConfigSettings : public CoreConfigSettings
    {
    DWORD dumpData;
    DISK_GEOMETRY gDiskGeometry;
    int enableRetries;
    DWORD speedDelay0to1;
    DWORD speedDelay1to2;
    DWORD speedDelay2to1;
    DWORD speedDelay1to0;
    DWORD speedDelay0to2;
    DWORD speedDelay2to0;
    DWORD delayOn062E;
    DWORD seekOn062E;
    DWORD summaryInternalErrs;
    DWORD chunkSizeMin;
    DWORD chunkSizeMax;
    char deviceName[128];
    DWORD readSize;
    DWORD startLBA, endLBA ;
    DWORD compareBuffers;
    DWORD sequentialReads;
    DWORD pauseOnMismatch;
    DWORD pauseOnError;
    DWORD dvdUseReadFile;
    DWORD readMode;
    DWORD pauseOnExit;
    ExcludeList *exclude;
    DWORD requestSense;
    DWORD avgSpan;
    DWORD defaultSpeed;
    DWORD seed;
    DWORD mediaType;
    DWORD numberOfReads;

    ConfigSettings()
        {
        dumpData = 0;
        enableRetries = 0;
        speedDelay0to1 = 0;
        speedDelay1to2 = 0;
        speedDelay2to1 = 0;
        speedDelay1to0 = 0;
        speedDelay0to2 = 0;
        speedDelay2to0 = 0;
        delayOn062E = 300;
        seekOn062E = 0;
        summaryInternalErrs = 1;
        chunkSizeMin = 32;
        chunkSizeMax = 32;
        readSize = 32;
        startLBA=0;
        endLBA=0;
        compareBuffers = 0;
        sequentialReads = 1;
        numberOfReads = 2;
        pauseOnMismatch = 0;
        pauseOnError = 0;
        readMode = READMODE_DETECT;
        exclude = NULL;
        requestSense = 0;
        pauseOnExit = 0;
        avgSpan = 256;
        defaultSpeed = 2;
        seed = 1;
        mediaType = MEDIA_UNKNOWN;

        memset(&gDiskGeometry, 0, sizeof(gDiskGeometry));
        strcpy(deviceName, "\\Device\\cdrom0");
        }
    };

extern ConfigSettings globalSettings;


//
// stats
//
extern DWORD numFailThenFail;
extern DWORD numFailThenFailSame;
extern DWORD numFailThenPass;
extern DWORD numPassThenFail;
extern DWORD numBuffMisMatch;
extern unsigned __int64 numBlocksRead;
extern DWORD time;
extern char model[64], serial[64], firmware[64];
extern DWORD numTimesThrough;
extern DWORD avgTimeCount;
extern DWORD avgTime;
extern DWORD successfulReadSectors;
extern DWORD spindleSpeed;
extern ErrorDistrubition *errors;
extern DWORD lastReadTime;

//
// graphics
//
extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;




//
// Low level IOCTL stuff
//
#define CTL_CODE(DeviceType, Function, Method, Access) ( \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) )

#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_CONTROLLER          0x00000004

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define FILE_ANY_ACCESS                 0

#define IOCTL_DVD_BASE                  FILE_DEVICE_DVD
#define IOCTL_DVD_START_SESSION         CTL_CODE(IOCTL_DVD_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_READ_KEY              CTL_CODE(IOCTL_DVD_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY              CTL_CODE(IOCTL_DVD_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_END_SESSION           CTL_CODE(IOCTL_DVD_BASE, 0x0403, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SET_READ_AHEAD        CTL_CODE(IOCTL_DVD_BASE, 0x0404, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_GET_REGION            CTL_CODE(IOCTL_DVD_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY2             CTL_CODE(IOCTL_DVD_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DVD_READ_STRUCTURE        CTL_CODE(IOCTL_DVD_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_BASE                FILE_DEVICE_CD_ROM
#define IOCTL_CDROM_GET_DRIVE_GEOMETRY  CTL_CODE(IOCTL_CDROM_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SET_SPINDLE_SPEED   CTL_CODE(IOCTL_CDROM_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_CHECK_VERIFY        CTL_CODE(IOCTL_CDROM_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
//#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define CDAUDIO_BYTES_PER_FRAME         2352
#define CDAUDIO_BYTES_PER_SECOND        176400
#define CDAUDIO_BYTES_PER_MINUTE        10584000
#define CDAUDIO_FRAMES_PER_SECOND       75
#define CDAUDIO_FRAMES_PER_MINUTE       4500
#define CDAUDIO_SECTOR_OFFSET           150

// from private\ntos\idex\idex.h:
#define IDE_ATAPI_RAW_CD_SECTOR_SIZE            2352
#define IDE_ATAPI_CD_SECTOR_SHIFT               11


#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))


#endif //_DISKREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskWrite\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\CDRip\xcddefs.h ===
#pragma once


// CD audio type conversions

#define CDAUDIO_BYTES_PER_FRAME         2352
#define CDAUDIO_BYTES_PER_SECOND        176400
#define CDAUDIO_BYTES_PER_MINUTE        10584000

#define CDAUDIO_FRAMES_PER_SECOND       75
#define CDAUDIO_FRAMES_PER_MINUTE       4500

// MCI time format conversion macros

#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
                                        ((WORD)(s)<<8)) | \
                                        (((DWORD)(BYTE)(f))<<16)))

__inline DWORD MsfToFrames(DWORD dwMsf)
{
    return MCI_MSF_MINUTE(dwMsf) * CDAUDIO_FRAMES_PER_MINUTE +
           MCI_MSF_SECOND(dwMsf) * CDAUDIO_FRAMES_PER_SECOND +
           MCI_MSF_FRAME(dwMsf);
}

__inline DWORD FramesToMsf(DWORD dwFrames)
{
    return MCI_MAKE_MSF(
        dwFrames / CDAUDIO_FRAMES_PER_MINUTE,
        (dwFrames % CDAUDIO_FRAMES_PER_MINUTE) / CDAUDIO_FRAMES_PER_SECOND,
        (dwFrames % CDAUDIO_FRAMES_PER_MINUTE) % CDAUDIO_FRAMES_PER_SECOND);
}

__inline DWORD TocValToMsf(LPBYTE ab)
{
    return MCI_MAKE_MSF(ab[1], ab[2], ab[3]);
}

__inline DWORD TocValToFrames(LPBYTE ab)
{
    return MsfToFrames(TocValToMsf(ab));
}

struct XCDROM_TOC
{
public:
	XCDROM_TOC();
	~XCDROM_TOC();

	void Delete();
	int GetTrackFromFrame(DWORD dwPosition) const;

    int LastTrack;
    DWORD TrackAddr [100];

protected:
	void Clear();
};

typedef XCDROM_TOC* PXCDROM_TOC;

// FRAMES_PER_CHUNK should be kept small, to maximize granularity. We stop music on
// a chunk boundary.

// Some CD hardware (Thompson, .94 firmware revision) is happiest with 1 second reads.

#define FRAMES_PER_CHUNK (CDAUDIO_FRAMES_PER_SECOND)

#define CD_AUDIO_SEGMENTS_PER_BUFFER ((4*CDAUDIO_FRAMES_PER_SECOND)/FRAMES_PER_CHUNK)

#define BYTES_PER_CHUNK (FRAMES_PER_CHUNK * CDAUDIO_BYTES_PER_FRAME)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskRead\gui.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    gui.cpp

Abstract:

    Low level disk test scanner.

Notes:

*****************************************************************************/
#include "diskRead.h"

IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText	= NULL;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;

#define STICK_DEAD_ZONE         6400
#define BUTTON_PRESS_VALUE      100
#define BUTTON_SPEEP_VALUE      150         // in ms

#define COLUMN_1_OFFSET         25
#define COLUMN_2_OFFSET         165

int ThumbStickScale(int stick, int max)
    {
    if(stick > 0) stick -= STICK_DEAD_ZONE;
    else stick += STICK_DEAD_ZONE;

    return (stick*max)/(32768-STICK_DEAD_ZONE);
    }


void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale)
    {
    // UP
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
        {
        ++value;
        if(value > max) value = max;
        }
    if(input.Gamepad.sThumbLY > STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value > max) value = max;
        }

    // DOWN
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
        {
        --value;
        if(value < min) value = min;
        if(value > max) value = min;
        }
    if(input.Gamepad.sThumbLY < -STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value < min) value = min;
        if(value > max) value = min;
        }
    }

DWORD buttonXColor, buttonYColor, buttonAColor, buttonBColor, buttonBlkColor, buttonWhtColor;
DWORD currentSelection = 0;

void GUI(void)
    {
    bool exit = false;
    DWORD addDevice, removeDevice;
    XINPUT_STATE state;

    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
        for(unsigned port=0; port<XGetPortCount(); port++)
            {
            if(hDuke[port])
                {
                XInputGetState(hDuke[port], &state);
                if(state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) exit = true;
                }
            }

        UpdateGraphics(DISPLAYMODE_CONFIG_READONLY);

        Sleep(BUTTON_SPEEP_VALUE);
        }

    // sleep past any residual user input presses
    Sleep(BUTTON_SPEEP_VALUE);
    buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
    }


void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...)
    {
    char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, x, (line+1)*10, 0, color, 0);
    }


void UpdateGraphics(unsigned mode /*=DISPLAYMODE_RUN_TIME*/)
    {
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // run time status mode
    //
    if(mode == DISPLAYMODE_RUN_TIME || mode == DISPLAYMODE_PAUSE)
        {
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 1, 0xFF4444FF, "Model: %s", model);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 2, 0xFF4444FF, "Serial: %s", serial);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 3, 0xFF4444FF, "Firmware: %s", firmware);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 4, 0xFF4444FF, "Media: %s", mediaTypeNames[globalSettings.mediaType]);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 1, 0xFF4444FF, " Cylinders: %u", globalSettings.gDiskGeometry.Cylinders.QuadPart);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, 0xFF4444FF, " Tracks/Cylinder: %u", globalSettings.gDiskGeometry.TracksPerCylinder);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 3, 0xFF4444FF, " Sectors/Track: %u", globalSettings.gDiskGeometry.SectorsPerTrack);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 4, 0xFF4444FF, " Bytes/Sector: %u", globalSettings.gDiskGeometry.BytesPerSector);

        unsigned line = 5;
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, line, 0xFFFFFFFF, "Blocks Read: %I64u", numBlocksRead);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, " Run Time: %u sec", (GetTickCount() - time)/1000);

        if(globalSettings.sequentialReads)
            {
            if(globalSettings.stopAfter.type == STOPAFTER_ITERATIONS)
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u of %u", numTimesThrough, globalSettings.stopAfter.duration);
            else
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u", numTimesThrough);
            }

        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Buffer Mismatches: %u", numBuffMisMatch);
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "2 Diff Failures: %u", numFailThenFail);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET,   line, 0xFFFFFFFF, " Pass then Fail:  %u", numPassThenFail);
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "2 Same Failures: %u", numFailThenFailSame);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET,   line, 0xFFFFFFFF, " Fail then Pass:  %u", numFailThenPass);

        if(mode == DISPLAYMODE_RUN_TIME)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Press START to view the current settings");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press Left Trigger + Right Trigger + Black to reboot");
            }
        else if(mode == DISPLAYMODE_PAUSE)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFF00,  "PAUSED");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFF00,  "Press BACK to continue");
            }
        }

    //
    // config setup gui
    //
    else if(mode == DISPLAYMODE_CONFIG_READONLY)
        {
        DWORD color;
        if(mode == 2) color = 0xFF777777;
        else color = 0xFFFFFFFF;

	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  1, buttonXColor & color,  "X: Read Size Min: %u", globalSettings.chunkSizeMin);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET , 2, buttonAColor & color,  "A: Read Size Max: %u", globalSettings.chunkSizeMax);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 1, buttonYColor & color,  " Y: Start LBA: %u", globalSettings.startLBA);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, buttonBColor & color,  " B: End LBA: %u", globalSettings.endLBA);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  3, buttonWhtColor & color,  "White: ReadMode: %u", globalSettings.readMode);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 3, buttonBlkColor & color,  " Black: SequentialReads: %u", globalSettings.sequentialReads);


        if(mode == DISPLAYMODE_CONFIG_INTERACTIVE) // interactive
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Use the DPAD or Left Thumbstick UP/DOWN to change the values");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press START to continue");
            }
        else // non interactive
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press BACK to continue");
            }
        }

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    }



bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                {
                LogPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    // check for exit file
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile("T:\\testexit.txt", &FindFileData);
    FindClose(hFind);
    if(hFind != INVALID_HANDLE_VALUE)
        {
        LogPrint("\r\n\r\nFound Exit File (testexit.txt) - rebooting\r\n");
        return true;
        }

    return false;
    }


bool InputCheckButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE)
                {
                return true;
                }
            }
        }

    return false;
    }


bool InputCheckDigitalButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.wButtons & button)
                {
                return true;
                }
            }
        }

    return false;
    }


void Pause(void)
    {
    DWORD addDevice, removeDevice;
    OutputDebugStringA("*****************************************************************************\n");
    OutputDebugStringA("* Entered Paused State. Hit the BACK button to resume...\n");
    OutputDebugStringA("*****************************************************************************\n");
    while(!InputCheckDigitalButton(XINPUT_GAMEPAD_BACK))
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        UpdateGraphics(DISPLAYMODE_PAUSE);

        Sleep(BUTTON_SPEEP_VALUE);
        }
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            //LogPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }


void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned i=0; i<XGetPortCount()*2; i++)
        {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[i]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[i]), XMUSlotFromDriveLetter((char)hSlot[i]));
            hSlot[i] = NULL;
            }
        if(add & USBSlotMasks[i])
            {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
                {
                hSlot[i] = (HANDLE)drive;
                //LogPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[i])+1, XMUSlotFromDriveLetter((char)hSlot[i])+1);
                }
            }
        }
    }


/*

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT InitGraphics(void)
    {
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskRead\diskRead.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    diskRead.cpp

Abstract:

    Low level disk test scanner.

Notes:
    dvd player code:
        "\xboxsrc\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp"
    sense data format:
        "\xboxsrc\public\ddk\inc\scsi.h"

    DVD-X2 Supported Error Sense Codes
        Sense   Sense   Sense   Description
        Key	    Code    Code Qu
        ----------------------------------------------------------------------
        0x00	0x00	0x00	No Additional Sense information (= no error)
        0x01	0x80	0x00	Cache fill error, speed reduction requested
        0x02	0x04	0x00	Logical Unit not ready, cause not reported
        0x02	0x04	0x01	Logical Unit is in process of becoming ready
        0x02	0x30	0x00	Incompatible medium installed
        0x02	0x3A	0x00	Medium not present
        0x03	0x57	0x00	Unable to recover Table of Contents
        0x03	0x80	0x00	Read Error
        0x04	0x00	0x00	Hardware error
        0x04	0x08	0x03	Logical Unit Communication CRC Error - UDMA33
        0x05	0x21	0x00	Logical Block Address Out of Range
        0x05	0x55	0x00	System Resource Failure
        0x05	0x64	0x00	Illegal mode for this track
        0x05	0x6F	0x00	Authentication Failure - CSS
        0x05	0x80	0x00	Authentication Failure - Xbox
        0x05	0x81	0x00	Command error
        0x06	0x29	0x00	Power On, Reset or Bus Device Reset occurred
        0x06	0x2A	0x01	Mode Parameters changed
        0x06	0x2E	0x00	Insufficient time for operation

    Win32 Error code mapping:
        1/80:   ERROR_CRC                   23
        2/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        2/other ERROR_NOT_READY             21
        3/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        3/other ERROR_CRC                   23
        5/21:   ERROR_SECTOR_NOT_FOUND      27
        5/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        5/6F:   ERROR_TOO_MANY_SECRETS      1381
        5/80:   ERROR_TOO_MANY_SECRETS      1381
        other:  ERROR_IO_DEVICE             1117

    IOCTL_CDROM_SET_SPINDLE_SPEED
        speed 2     ~3000rpm      2x -    5x
        speed 1     ~2000rpm    4/3x - 10/3x
        speed 0     ~1000rpm    2/3x -  5/3x

    Hard Drive Partition Sizes
        \Device\Harddisk0\Partition0 19541088
        \Device\Harddisk0\Partition1  9997568   C:
        \Device\Harddisk0\Partition2  1023840   Y:
        \Device\Harddisk0\Partition3  1535776   Z:
        \Device\Harddisk0\Partition4  1535776   Z:
        \Device\Harddisk0\Partition5  1535776   Z:

*****************************************************************************/

#include "diskRead.h"
#include <xbeimage.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[XGetPortCount()*2] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

//
// config settings
//
ConfigSettings globalSettings;

//
// stats
//
DWORD numFailThenFail = 0;
DWORD numFailThenFailSame = 0;
DWORD numFailThenPass = 0;
DWORD numPassThenFail = 0;
DWORD numBuffMisMatch = 0;
DWORD numTimesThrough = 1;
unsigned __int64 numBlocksRead = 0;
DWORD time = 0;
char model[64], serial[64], firmware[64];

ErrorDistrubition *errors = NULL;
DWORD avgTimeCount;
DWORD avgTime;
DWORD lastReadTime;
DWORD spindleSpeed;
DWORD successfulReadSectors;

void ParseTestConfig(char *variable, char *value, void *userParam)
    {
    ConfigSettings *settings = (ConfigSettings*)userParam;

    if(strstr(variable, "device") != NULL) strcpy(settings->deviceName, value);
    else if(strstr(variable, "startlba") != NULL) settings->startLBA = GetNumber(value);
    else if(strstr(variable, "endlba") != NULL) settings->endLBA = GetNumber(value);
    else if(strstr(variable, "defaultspeed") != NULL) settings->defaultSpeed = atol(value);
    else if(strstr(variable, "enableretries") != NULL) settings->enableRetries = atol(value);
    else if(strstr(variable, "readsizemin") != NULL) settings->chunkSizeMin = GetNumber(value);
    else if(strstr(variable, "readsizemax") != NULL) settings->chunkSizeMax = GetNumber(value);
    else if(strstr(variable, "readsize") != NULL) settings->chunkSizeMax = settings->chunkSizeMin = GetNumber(value);
    else if(strstr(variable, "comparebuffers") != NULL) settings->compareBuffers = atol(value);
    else if(strstr(variable, "sequentialreads") != NULL) settings->sequentialReads = atol(value);
    else if(strstr(variable, "readmode") != NULL) settings->readMode = GetNumber(value);
    else if(strstr(variable, "dumpdata") != NULL) settings->dumpData = atol(value);
    else if(strstr(variable, "avgspan") != NULL) settings->avgSpan = atol(value);
    else if(strstr(variable, "requestsense") != NULL) settings->requestSense = atol(value);
    else if(strstr(variable, "summaryinternalerrs") != NULL) settings->summaryInternalErrs = atol(value);
    else if(strstr(variable, "pauseonexit") != NULL) settings->pauseOnExit = GetNumber(value);
    else if(strstr(variable, "speeddelay0to1") != NULL) settings->speedDelay0to1 = atol(value);
    else if(strstr(variable, "speeddelay1to2") != NULL) settings->speedDelay1to2 = atol(value);
    else if(strstr(variable, "speeddelay2to1") != NULL) settings->speedDelay2to1 = atol(value);
    else if(strstr(variable, "speeddelay1to0") != NULL) settings->speedDelay1to0 = atol(value);
    else if(strstr(variable, "speeddelay0to2") != NULL) settings->speedDelay0to2 = atol(value);
    else if(strstr(variable, "speeddelay2to0") != NULL) settings->speedDelay2to0 = atol(value);
    else if(strstr(variable, "delayon062e") != NULL) settings->delayOn062E = atol(value);
    else if(strstr(variable, "seekon062e") != NULL) settings->seekOn062E = atol(value);
    else if(strstr(variable, "numberofreads") != NULL) settings->numberOfReads = GetNumber(value);
    else if(strstr(variable, "pauseonmismatch") != NULL) settings->pauseOnMismatch = atol(value);
    else if(strstr(variable, "pauseonerror") != NULL) settings->pauseOnError = atol(value);
    else if(strstr(variable, "seed") != NULL) settings->seed = GetNumber(value);
    else if(strstr(variable, "exclude") != NULL)
        {
        if(!settings->exclude) settings->exclude = new ExcludeList(value);
        else settings->exclude->Add(value);
        }
    }

#pragma warning(disable : 4326) // return type of 'main' should be 'int or void' instead of 'ShutDown'
struct ShutDown
    {
    ShutDown(LAUNCH_DATA &launchInfo, unsigned __int64 pass, unsigned __int64 fail, char *format, ...)
        {
        ToLauncherData* outParams = (ToLauncherData*)&launchInfo;
        ToTestData* initialParams = (ToTestData*)&launchInfo;

        if(initialParams->titleID == HVSLAUNCHERID)
            {
            outParams->titleID = XeImageHeader()->Certificate->TitleID;
            outParams->numPass = pass;
            outParams->numFail = fail;
            va_list args;
            va_start(args, format);
            vsprintf(outParams->notes, format, args);
            va_end(args);

            LaunchImage("D:\\default.xbe", &launchInfo);
            }
        else
            XLaunchNewImage(NULL, NULL);
        }
    };

ShutDown _cdecl main(void)
    {
    //
    // Get the launch data (if any)
    //
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    XGetLaunchInfo(&dataType, &launchInfo);
    ToTestData* initialParams = (ToTestData*)&launchInfo;

    Initialize();

    //
    // cleanup old files
    //
    DeleteFile("T:\\testexit.txt");

    DWORD addDevice, removeDevice;
    DWORD status;
    READ_FUNC ReadBlocks;
    DWORD geometryIOCTL;
    DWORD geoSize;
    bool exit = false;
    DWORD rando = 0;
    ULONGLONG bigResult = 0;
    DWORD block = 0;
    SCSIError err1, err2, err3;
    DWORD numReads = 0;
    DWORD avgStartLBA = 0;
    unsigned numCommandErrors = 0;
    DWORD extraSpace = 0;
    char *iniConfig = NULL;



    //
    // Grab the startup parameters
    //
    if(initialParams->titleID == HVSLAUNCHERID)
        {
        iniConfig = new char[strlen(initialParams->configSettings)+1];
        strcpy(iniConfig, initialParams->configSettings);
        ParseConfigSettings(initialParams->configSettings, &globalSettings, ParseTestConfig, &globalSettings);
        }
    else
        {
        FILE *file = fopen("D:\\diskRead.ini", "rb");
        if(file)
            {
            DWORD filesize = _filelength(_fileno(file));
            iniConfig = new char[filesize+1];
            unsigned bytesRead = fread(iniConfig, 1, filesize, file);
            iniConfig[bytesRead] = '\0';

            ParseConfigSettings(iniConfig, &globalSettings, ParseTestConfig, &globalSettings);
            if(fseek(file, 0, SEEK_SET) == 0)
                {
                bytesRead = fread(iniConfig, 1, filesize, file);
                iniConfig[bytesRead] = '\0';
                }
            fclose(file);
            }
        }


    // Call SetSaveName BEFORE calling LogPrint or LogFlush
    SetSaveName(globalSettings.saveName, "diskRead.log");
    LogFlush();

    if(initialParams->titleID == HVSLAUNCHERID)
        LogPrint("Launched from HVS\n  Test %u of %u\n\n", initialParams->testNumber, initialParams->totalTests);
    else
        LogPrint("Running in stand a lone mode\n\n");

    LogPrint("DISK Read (Built on " __DATE__ " at " __TIME__ ")\n");
    LogPrint("Copyright (C) Microsoft Corporation.  All rights reserved.\n\n");


    //
    // seed random number generator
    //
    srand(globalSettings.seed);


    //
    // open the DVD / Hard drive
    //
    HANDLE hDevice;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    RtlInitObjectString(&VolumeString, globalSettings.deviceName);
    InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
    if(!NT_SUCCESS(status))
        {
        LogPrint("Unable to open the device '%s' (ec: %u)\n", globalSettings.deviceName, RtlNtStatusToDosError(status));
        DebugPrint("Rebooting...\n\n\n");
        return ShutDown(launchInfo, 0, 0, "Unable to open the device:\\n '%s' (ec: %u)", globalSettings.deviceName, RtlNtStatusToDosError(status));
        }

    _strlwr(globalSettings.deviceName);

    if(strstr(globalSettings.deviceName, "cdrom") != NULL) // target == DVD or CD
        {
        globalSettings.mediaType = GetDiskType(hDevice);
        if(globalSettings.readMode == READMODE_DETECT)
            {
            if(globalSettings.mediaType == MEDIA_CDDA) globalSettings.readMode = READMODE_CD;
            else globalSettings.readMode = READMODE_DVD;
            }

        if(globalSettings.readMode == READMODE_DVD)
            {
            ReadBlocks = ReadDVDBlocks;
            ChangeSpeed(hDevice, globalSettings.defaultSpeed);
            }
        else if(globalSettings.readMode == READMODE_CD)
            {
            ReadBlocks = ReadCDBlocks2;
            extraSpace = 304; // we read in chunks of an audio frame size not clustor size
            }
        else if(globalSettings.readMode == READMODE_HD)
            {
            ReadBlocks = ReadHDBlocks;
            }

        geometryIOCTL = IOCTL_CDROM_GET_DRIVE_GEOMETRY;
	    DeviceIoControl(hDevice, geometryIOCTL, NULL, 0, &globalSettings.gDiskGeometry, sizeof(globalSettings.gDiskGeometry), &geoSize, NULL);
        }
    else // target == hard disk
        {
        globalSettings.mediaType = MEDIA_HD;
        globalSettings.readMode = READMODE_HD;
        ReadBlocks = ReadHDBlocks;
        geometryIOCTL = IOCTL_DISK_GET_DRIVE_GEOMETRY;
	    DeviceIoControl(hDevice, geometryIOCTL, NULL, 0, &globalSettings.gDiskGeometry, sizeof(globalSettings.gDiskGeometry), &geoSize, NULL);

        // gDiskGeometry.Cylinders.QuadPart contains the size of the entire 
        // disk but we only want the size of the current partition so we 
        // need to query the size of the volume and adjust the value
        FILE_FS_SIZE_INFORMATION NormalSizeInfo;
        memset(&NormalSizeInfo, 0, sizeof(NormalSizeInfo));
        NtQueryVolumeInformationFile(
                    hDevice,
                    &IoStatusBlock,
                    &NormalSizeInfo,
                    sizeof(NormalSizeInfo),
                    FileFsSizeInformation
                    );
        globalSettings.gDiskGeometry.Cylinders.QuadPart = NormalSizeInfo.TotalAllocationUnits.QuadPart * NormalSizeInfo.SectorsPerAllocationUnit;
        }
    if(globalSettings.gDiskGeometry.Cylinders.QuadPart == 0)
        {
        NtClose(hDevice);
        LogPrint("No Media Detected\n");
        DebugPrint("Rebooting...\n\n\n");
        return ShutDown(launchInfo, 0, 0, "No Media Detected");
        }
    if(globalSettings.endLBA == 0) globalSettings.endLBA = (DWORD)globalSettings.gDiskGeometry.Cylinders.QuadPart;
    spindleSpeed = globalSettings.defaultSpeed;


    //
    // print out the drive info, disk geometry, and config settings
    //
    memset(model, 0, 64);
    memset(serial, 0, 64);
    memset(firmware, 0, 64);
    GetDriveID(hDevice, geometryIOCTL == IOCTL_CDROM_GET_DRIVE_GEOMETRY, model, serial, firmware);

	LogPrint("DRIVE: Model:             %s\n", model);
	LogPrint("DRIVE: Serial:            %s\n", serial);
	LogPrint("DRIVE: Firmware:          %s\n", firmware);
	LogPrint("MEDIA: Type:              %s\n", mediaTypeNames[globalSettings.mediaType]);
	LogPrint("MEDIA: Cylinders:         %u\n", globalSettings.gDiskGeometry.Cylinders.QuadPart);
	LogPrint("MEDIA: TracksPerCylinder: %u\n", globalSettings.gDiskGeometry.TracksPerCylinder);
	LogPrint("MEDIA: SectorsPerTrack:   %u\n", globalSettings.gDiskGeometry.SectorsPerTrack);
	LogPrint("MEDIA: BytesPerSector:    %u\n", globalSettings.gDiskGeometry.BytesPerSector);

    LogPrint("Config Settings:\n");
    LogPrint("  ResultsServer: %s\n", globalSettings.resultsServer);
    LogPrint("  SaveName:      %s\n", globalSettings.saveName);
    LogPrint("  StopAfter:     %u %s\n", globalSettings.stopAfter.duration, globalSettings.stopAfter.type==STOPAFTER_MINUTES?"min":(globalSettings.stopAfter.type==STOPAFTER_HOURS?"hours":"iterations"));
	LogPrint("\n");
    LogPrint("  Device:              %s\n", globalSettings.deviceName);
    LogPrint("  ReadSizeMin:         %u\n", globalSettings.chunkSizeMin);
    LogPrint("  ReadSizeMax:         %u\n", globalSettings.chunkSizeMax);
    LogPrint("  StartLBA:            %u\n", globalSettings.startLBA);
    LogPrint("  EndLBA:              %u\n", globalSettings.endLBA);
    LogPrint("  ReadMode:            %u\n", globalSettings.readMode);
    LogPrint("  NumberOfReads:       %u\n", globalSettings.numberOfReads);
    LogPrint("  SequentialReads:     %u\n", globalSettings.sequentialReads);
    LogPrint("  SummaryInternalErrs: %u\n", globalSettings.summaryInternalErrs);
    LogPrint("  CompareBuffers:      %u\n", globalSettings.compareBuffers);
    LogPrint("  PauseOnMismatch:     %u\n", globalSettings.pauseOnMismatch);
	LogPrint("\n");
    LogPrint("  RequestSense:        %u\n", globalSettings.requestSense);
    LogPrint("  EnableRetries:       %u\n", globalSettings.enableRetries);
    LogPrint("  DefaultSpeed:        %u\n", globalSettings.defaultSpeed);
    LogPrint("  SpeedDelay0to1:      %u\n", globalSettings.speedDelay0to1);
    LogPrint("  SpeedDelay1to2:      %u\n", globalSettings.speedDelay1to2);
    LogPrint("  SpeedDelay2to1:      %u\n", globalSettings.speedDelay2to1);
    LogPrint("  SpeedDelay1to0:      %u\n", globalSettings.speedDelay1to0);
    LogPrint("  SpeedDelay0to2:      %u\n", globalSettings.speedDelay0to2);
    LogPrint("  SpeedDelay2to0:      %u\n", globalSettings.speedDelay2to0);
    LogPrint("  DelayOn062E:         %u\n", globalSettings.delayOn062E);
    LogPrint("  SeekOn062E :         %u\n", globalSettings.seekOn062E );
    LogPrint("\n");

    //
    // allocate buffer space
    //
    unsigned char *buff1 = new unsigned char[globalSettings.chunkSizeMax * (globalSettings.gDiskGeometry.BytesPerSector+extraSpace)];
    unsigned char *buff2 = new unsigned char[globalSettings.chunkSizeMax * (globalSettings.gDiskGeometry.BytesPerSector+extraSpace)];
    unsigned char *buff3 = new unsigned char[globalSettings.chunkSizeMax * (globalSettings.gDiskGeometry.BytesPerSector+extraSpace)];
    if(!buff1 || !buff2 || !buff3)
        {
        LogPrint("Unable to allocate enough space (%u)\n", (globalSettings.chunkSizeMax * globalSettings.gDiskGeometry.BytesPerSector+extraSpace) * 3);
        LogPrint("Try lowering chunkSizeMin and chunkSizeMax\n");
        DebugPrint("Rebooting...\n\n\n");
        return ShutDown(launchInfo, 0, 0, "Unable to allocate enough space (%u).\\nTry lowering chunkSizeMin and chunkSizeMax", globalSettings.chunkSizeMax * globalSettings.gDiskGeometry.BytesPerSector * 3);
        }

    time = GetTickCount();

    //
    // run the test
    //
    avgStartLBA = block = globalSettings.startLBA;
    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
        UpdateGraphics(DISPLAYMODE_RUN_TIME);

        memset(buff1, 0, globalSettings.chunkSizeMax * globalSettings.gDiskGeometry.BytesPerSector);
        memset(buff2, 0, globalSettings.chunkSizeMax * globalSettings.gDiskGeometry.BytesPerSector);
        memset(buff3, 0, globalSettings.chunkSizeMax * globalSettings.gDiskGeometry.BytesPerSector);

        //
        // calculate the size of the next read
        //
        rando = rand();
        bigResult = (ULONGLONG)(rando*(ULONGLONG)(globalSettings.chunkSizeMax-globalSettings.chunkSizeMin));
        globalSettings.readSize = (DWORD)((bigResult/RAND_MAX) + globalSettings.chunkSizeMin);

        ++numReads;

        //
        // read from the disk
        //
        err1 = ReadBlocks(hDevice, block, globalSettings.readSize, buff1);
        numBlocksRead += globalSettings.readSize;
        if(globalSettings.pauseOnError && err1.win32 != 0) Pause();
        if(globalSettings.requestSense == 2 && err1.win32 == 0 && geometryIOCTL == IOCTL_CDROM_GET_DRIVE_GEOMETRY && globalSettings.readMode == READMODE_DVD) RequestSense(hDevice, err1);
        if(globalSettings.dumpData)
            {
            LogPrint("Block %u: ", block);
            err1.Print();
            LogPrint("\n");
            HexDump(buff1,globalSettings. readSize * globalSettings.gDiskGeometry.BytesPerSector);
            goto EOErrorCheck;
            }
        if(globalSettings.numberOfReads == 1) goto EOErrorCheck;

        err2 = ReadBlocks(hDevice, block, globalSettings.readSize, buff2);
        numBlocksRead += globalSettings.readSize;
        if(globalSettings.pauseOnError && err1.win32 != 0) Pause();
        if(globalSettings.requestSense == 2 && err2.win32 == 0 && geometryIOCTL == IOCTL_CDROM_GET_DRIVE_GEOMETRY && globalSettings.readMode == READMODE_DVD) RequestSense(hDevice, err2);

        //
        // check for errors
        //
        if(err1.win32 != 0 && err2.win32 == 0)
            {
            numCommandErrors = 0;
            if(!errors) errors = new ErrorDistrubition(err1);
            else errors->AddError(err1);
            ++numFailThenPass;
            LogPrint("Block %u: Read1 failed ", block);
            err1.Print();
            LogPrint(" Read2 succeeded ");
            err2.Print();
            LogPrint("\n");
            }
        else if(err1.win32 == 0 && err2.win32 != 0)
            {
            numCommandErrors = 0;
            if(!errors) errors = new ErrorDistrubition(err2);
            else errors->AddError(err2);
            ++numPassThenFail;
            LogPrint("Block %u: Read1 succeeded ", block);
            err1.Print();
            LogPrint(" Read2 failed ");
            err2.Print();
            LogPrint("\n");
            }
        else if((err1.sense.ErrorCode                    != err2.sense.ErrorCode)           ||
                (err1.sense.Valid                        != err2.sense.Valid)               ||
                (err1.sense.SenseKey                     != err2.sense.SenseKey)            ||
                (err1.sense.Reserved                     != err2.sense.Reserved)            ||
                (err1.sense.IncorrectLength              != err2.sense.IncorrectLength)     ||
                (err1.sense.EndOfMedia                   != err2.sense.EndOfMedia)          ||
                (err1.sense.FileMark                     != err2.sense.FileMark)            ||
                (err1.sense.AdditionalSenseCode          != err2.sense.AdditionalSenseCode) ||
                (err1.sense.AdditionalSenseCodeQualifier != err2.sense.AdditionalSenseCodeQualifier))
            {
            numCommandErrors = 0;
            if(!errors) errors = new ErrorDistrubition(err1);
            else errors->AddError(err1);
            if(!errors) errors = new ErrorDistrubition(err2);
            else errors->AddError(err2);
            ++numFailThenFail;
            LogPrint("Block %u: Err1", block);
            err1.Print();
            LogPrint(" != Err2");
            err2.Print();
            LogPrint("\n");
            }

        // errors are the same at this point
        else if(err1.win32!=0 || err2.win32!=0)
            {
            if(!errors) errors = new ErrorDistrubition(err1);
            else errors->AddError(err1);
            errors->AddError(err2);
            ++numFailThenFailSame;
            LogPrint("Block %u: Same Error Err1/2", block);
            err1.Print();
            LogPrint("\n");
            if(err1.sense.SenseKey == 0x05 && err1.sense.AdditionalSenseCode == 0x81) // command error
                {
                numCommandErrors += globalSettings.readSize;
                if(numCommandErrors >= 4096)
                    {
                    numCommandErrors = 0;
                    numFailThenFailSame -= (4096/globalSettings.readSize);
                    errors->RemoveError(err1, (4096/globalSettings.readSize) * 2);
                    LogPrint("End of security section.\n");
                    }
                }
            }
        else if(err1.win32==0 && err2.win32==0 && (memcmp(buff1, buff2, globalSettings.readSize*globalSettings.gDiskGeometry.BytesPerSector) != 0))
            {
            numCommandErrors = 0;
            if(globalSettings.requestSense == 1 && globalSettings.readMode == READMODE_DVD) RequestSense(hDevice, err2);
            if(globalSettings.pauseOnMismatch) Pause();
            int retry = 3;
            do {
                // do another read for reference
                err3 = ReadBlocks(hDevice, block, globalSettings.readSize, buff3);
                retry--;
                } while(err3.win32 != 0 && retry >= 0);

            numBlocksRead += globalSettings.readSize;

            ++numBuffMisMatch;
            LogPrint("Block %u: buff1 != buff2, Err1", block);
            err1.Print();
            LogPrint(", Err2");
            err2.Print();
            LogPrint("\n");
            if(globalSettings.compareBuffers) CompareBuff(buff1, buff2, buff3, globalSettings.readSize*globalSettings.gDiskGeometry.BytesPerSector);
            }

        EOErrorCheck:

        if(globalSettings.numberOfReads == 1)
            {
            if(err1.win32!=0)
                {
                if(!errors) errors = new ErrorDistrubition(err1);
                else errors->AddError(err1);
                ++numFailThenFailSame;
                LogPrint("Block %u: Single Error ", block);
                err1.Print();
                LogPrint("\n");
                if(err1.sense.SenseKey == 0x05 && err1.sense.AdditionalSenseCode == 0x81) // command error
                    {
                    numCommandErrors += globalSettings.readSize;
                    if(numCommandErrors >= 4096)
                        {
                        numCommandErrors = 0;
                        numFailThenFailSame -= (4096/globalSettings.readSize);
                        errors->RemoveError(err1, (4096/globalSettings.readSize) * 2);
                        LogPrint("End of security section.\n");
                        }
                    }
                }
            }


        //
        // adjust the read pointer (skipping any exclude areas)
        //
        do {
            if(globalSettings.sequentialReads)
                {
                block += globalSettings.readSize;
                if(block >= globalSettings.endLBA)
                    {
                    block = globalSettings.startLBA;
                    ++numTimesThrough;
                    }
                }
            else
                {
                rando = rand();
                bigResult = (ULONGLONG)(rando*(ULONGLONG)(globalSettings.endLBA-globalSettings.startLBA));
                block = (DWORD)((bigResult/RAND_MAX) + globalSettings.startLBA);
                }

            if(globalSettings.stopAfter.duration)
                {
                if((globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && numTimesThrough > globalSettings.stopAfter.duration) ||
                    (globalSettings.stopAfter.type == STOPAFTER_MINUTES && TICK2MIN(GetTickCount() - time) >= globalSettings.stopAfter.duration) ||
                    (globalSettings.stopAfter.type == STOPAFTER_HOURS && TICK2HOUR(GetTickCount() - time) >= globalSettings.stopAfter.duration) )
                    {
                    exit = true;
                    break;
                    }
                }
            } while((globalSettings.exclude && globalSettings.exclude->InList(block, globalSettings.chunkSizeMax)) || (block+globalSettings.chunkSizeMax >= globalSettings.endLBA));


        //
        // avg read time
        //
        if(globalSettings.avgSpan && (numReads % globalSettings.avgSpan == 0))
            {
            DWORD avg = 0;
            if(avgTimeCount != 0)
                avg = avgTime/avgTimeCount;

            if(globalSettings.sequentialReads)
                LogPrint("Blocks %u-%u: avg Read Time == %u ms\n", avgStartLBA, block, avg);
            else
                LogPrint("Read %u-%u: avg Read Time == %u ms\n", numReads-globalSettings.avgSpan, numReads, avg);

            avgTimeCount = 0;
            avgTime = 0;
            avgStartLBA = block;
            }

        if(InputCheckDigitalButton(XINPUT_GAMEPAD_START)) GUI();
        if(InputCheckExitCombo()) exit = true;
        } // while


    //
    // dump the stats
    //
    DWORD finalTime = (GetTickCount() - time)/1000;
    DWORD totalErrors = numFailThenFailSame*2 + numFailThenFail*2 + numFailThenPass + numPassThenFail;

    LogPrint("****Program Stats:\n");
    LogPrint("*** %9u sec run time\n", finalTime);
    LogPrint("*** %9I64u Total blocks read\n", numBlocksRead);
    LogPrint("****\n");
    if(globalSettings.numberOfReads == 1)
        LogPrint("*** %9u Single Failures\n", numFailThenFailSame);
    else
        {
        LogPrint("*** %9u Buffer mismatches (no failure reported)\n", numBuffMisMatch);
        LogPrint("*** %9u Failures then different failures\n", numFailThenFail);
        LogPrint("*** %9u Failures then same failures\n", numFailThenFailSame);
        LogPrint("*** %9u Failures then successes\n", numFailThenPass);
        LogPrint("*** %9u Successes then failures\n", numPassThenFail);
        }
    LogPrint("*** %9u Total Reported Errors\n", totalErrors);
    LogPrint("****\n");
    LogPrint("*** %9u errors / reads\n", numReads? totalErrors / numReads : 0);
    LogPrint("*** %9u errors / sec\n", finalTime? totalErrors / finalTime : 0);
    if(errors)
        {
        LogPrint("****Error Distribution:\n");
        errors->PrintErrors();
        }


    //
    // Post results if necessary
    //
    if(strncmp(globalSettings.resultsServer, "http://", 7) == 0)
        {
        WSADATA wsaData;
        unsigned short version = MAKEWORD(2, 2);
        WSAStartup(version, &wsaData);

        DBDATA results;
        if(geometryIOCTL == IOCTL_CDROM_GET_DRIVE_GEOMETRY)
            results.deviceType = "DVD";
        else
            results.deviceType = "Hard Drive";

        results.manufacturer = RightTrim(model);
        results.firmwareVersion = RightTrim(firmware);
        results.hardwareVersion = "";
        results.serialNumber = RightTrim(serial);
        results.testName = "Disk Read";

        char *modes[] = 
            {
            "Detect",
            "Raw DVD",
            "Raw CDDA",
            "Volume"
            };
        char variation[256];
        char *v = variation;
        v += sprintf(v, "%s reads of %u-%u blocks, ", globalSettings.sequentialReads?"Sequential":"Random", globalSettings.chunkSizeMin, globalSettings.chunkSizeMax);
        v += sprintf(v, "From LBA %u to %u, ", globalSettings.startLBA, globalSettings.endLBA);
        v += sprintf(v, "Read Mode: %s", modes[globalSettings.readMode]);
        results.variation = variation;
        results.boxInformation = GetBoxInformation();
        //DebugPrint("%s", results.boxInformation);
        results.configSettings = iniConfig;

        // passes
        results.status = 1;
        results.numOperations = numBlocksRead-(totalErrors+numBuffMisMatch);
        results.notes = "Successful Reads";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // failures (read errors)
        results.status = 0;
        results.numOperations = totalErrors;
        if(results.numOperations)
            {
            results.notes = new char[4*1024];
            if(results.notes)
                {
                char *temp = results.notes;
                temp += sprintf(temp, "Read Errors:\n");
                errors->SPrintErrors(temp);
                PostResults(globalSettings.resultsServer, &results);
                delete[] results.notes;
                }
            else
                {
                results.notes = "Read Errors";
                PostResults(globalSettings.resultsServer, &results);
                }
            }

        // failures (buffer mismatches)
        results.status = 0;
        results.numOperations = numBuffMisMatch;
        results.notes = "Buffer Mismatches";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // cleanup
        delete[] results.boxInformation;
        }

    delete[] iniConfig;
    delete[] buff1;
    delete[] buff2;
    delete[] buff3;
    NtClose(hDevice);

    if(globalSettings.pauseOnExit)
        {
        Pause();
        }
    else
        {
        // persist the display across the reboot
        g_pDevice->PersistDisplay();
        }

    //
    // test done, reboot
    //
    return ShutDown(launchInfo, numBlocksRead, totalErrors+numBuffMisMatch, "\0");
    }



void Initialize(void)
    {
    //
    // USB
    //
    XInitDevices(0, NULL);

    //
    // Network
    //
    XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    XNetStartup(&xnsp);

    //
    //
    //
    InitGraphics();
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskRead\diskUtils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    diskUtils.cpp

Abstract:

    Functions that talk to the DVD drive

Notes:
    dvd player code:
        "\xboxsrc\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp"
    filesystem retry code:
        "\xboxsrc\private\ntos\idex\cdrom.c" (IdexCdRomFinishRequestSense)
    sense data format:
        "\xboxsrc\public\ddk\inc\scsi.h"


    DVD-X2 Supported Error Sense Codes
        Sense   Sense   Sense   Description
        Key	    Code    Code Qu
        ----------------------------------------------------------------------
        0x00	0x00	0x00	No Additional Sense information (= no error)
        0x01	0x80	0x00	Cache fill error, speed reduction requested
        0x02	0x04	0x00	Logical Unit not ready, cause not reported
        0x02	0x04	0x01	Logical Unit is in process of becoming ready
        0x02	0x30	0x00	Incompatible medium installed
        0x02	0x3A	0x00	Medium not present
        0x03	0x57	0x00	Unable to recover Table of Contents
        0x03	0x80	0x00	Read Error
        0x04	0x00	0x00	Hardware error
        0x04	0x08	0x03	Logical Unit Communication CRC Error - UDMA33
        0x05	0x21	0x00	Logical Block Address Out of Range
        0x05	0x55	0x00	System Resource Failure
        0x05	0x64	0x00	Illegal mode for this track
        0x05	0x6F	0x00	Authentication Failure - CSS
        0x05	0x80	0x00	Authentication Failure - Xbox
        0x05	0x81	0x00	Command error
        0x06	0x29	0x00	Power On, Reset or Bus Device Reset occurred
        0x06	0x2A	0x01	Mode Parameters changed
        0x06	0x2E	0x00	Insufficient time for operation

    Win32 Error code mapping:
        1/80:   ERROR_CRC                   23
        2/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        2/other ERROR_NOT_READY             21
        3/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        3/other ERROR_CRC                   23
        5/21:   ERROR_SECTOR_NOT_FOUND      27
        5/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        5/6F:   ERROR_TOO_MANY_SECRETS      1381
        5/80:   ERROR_TOO_MANY_SECRETS      1381
        other:  ERROR_IO_DEVICE             1117

    IOCTL_CDROM_SET_SPINDLE_SPEED
        speed 2     ~3000rpm      2x -    5x
        speed 1     ~2000rpm    4/3x - 10/3x
        speed 0     ~1000rpm    2/3x -  5/3x

*****************************************************************************/

#include "diskRead.h"

/*
APIs in this file:

    SCSIError ReadDVDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
    SCSIError ReadCDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
    SCSIError ReadHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
    void SeekLBA(HANDLE hDevice, DWORD LBA);
    void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
    void ChangeSpeed(HANDLE hDevice, DWORD newSpeed);
    bool CDTestReady(HANDLE hDevice);
    void RequestSense(HANDLE hDevice, SCSIError &sense);

*/



DWORD
DeviceIoControlWStatus(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    An operation on a device may be performed by calling the device driver
    directly using the DeviceIoContrl function.

    The device driver must first be opened to get a valid handle.

Arguments:

    hDevice - Supplies an open handle a device on which the operation is to
        be performed.

    dwIoControlCode - Supplies the control code for the operation. This
        control code determines on which type of device the operation must
        be performed and determines exactly what operation is to be
        performed.

    lpInBuffer - Suplies an optional pointer to an input buffer that contains
        the data required to perform the operation.  Whether or not the
        buffer is actually optional is dependent on the IoControlCode.

    nInBufferSize - Supplies the length of the input buffer in bytes.

    lpOutBuffer - Suplies an optional pointer to an output buffer into which
        the output data will be copied. Whether or not the buffer is actually
        optional is dependent on the IoControlCode.

    nOutBufferSize - Supplies the length of the output buffer in bytes.

    lpBytesReturned - Supplies a pointer to a dword which will receive the
        actual length of the data returned in the output buffer.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the DeviceIoControl will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, DeviceIoControl may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    NTSTATUS Status;
    BOOLEAN DevIoCtl;

    if ( dwIoControlCode >> 16 == FILE_DEVICE_FILE_SYSTEM ) {
        DevIoCtl = FALSE;
        }
    else {
        DevIoCtl = TRUE;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        if ( DevIoCtl ) {

            Status = NtDeviceIoControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {

            Status = NtFsControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );

            }

        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) && ARGUMENT_PRESENT(lpBytesReturned) ) {
            *lpBytesReturned = (DWORD)lpOverlapped->InternalHigh;
            }
        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            return Status;
            }
        else {
            //XapiSetLastNTError(Status);
            return Status;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;

        if ( DevIoCtl ) {
            Status = NtDeviceIoControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {
            Status = NtFsControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)Iosb.Information;
            return Status;
            }
        else {
            // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
            if ( !NT_ERROR(Status) ) {
                *lpBytesReturned = (DWORD)Iosb.Information;
            }
            //XapiSetLastNTError(Status);
            return Status;
            }
        }
}



/*
    Retry Schema for the DeviceIoControl mode:

                                                action1                     action2                         action3                     action4
    Retry for 01/80/00:                         change speed wait retry.... change speed, wait, retry....   fail
    Retry for 03/80/00, 04/00/00 and 05/55/00:  retry...                    change speed, wait, retry....   change speed, wait, retry   fail
    Retry for 06/2E/00:                         delay 2 sec, retry...       change speed, wait, retry       change speed, wait, retry   fail
    Retry for 06/29/00:                         wait untill drive is ready
    Retry for 05/81/00:                         retry...                    fail
*/
SCSIError ReadDVDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    DWORD readTime = GetTickCount();
    ++avgTimeCount;

    DWORD status;
    SCSIError err;
    bool retry = false;
	PCDB Cdb;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    DWORD cbReturned;
    SENSE_DATA sense;
    SENSE_DATA previousSense;
    memset(&previousSense, 0, sizeof(SENSE_DATA));

    ZeroMemory(&PassThrough, sizeof(PassThrough));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = buffer;
    PassThrough.DataTransferLength = num*globalSettings.gDiskGeometry.BytesPerSector;

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->CDB10.OperationCode = SCSIOP_READ;
	Cdb->CDB10.ForceUnitAccess = 1;
	Cdb->CDB10.LogicalBlock = RtlUlongByteSwap(block);
	Cdb->CDB10.TransferBlocks = RtlUshortByteSwap((unsigned short)num);

    DWORD actionState = 1;
    DWORD retryCount = 0;

    do {
        if(retry) ++retryCount;
        SetLastError(0);
        memset(&err, 0, sizeof(SCSIError));
        memset(&sense, 0, sizeof(SENSE_DATA));
        retry = false;

        status = DeviceIoControlWStatus(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), &sense, sizeof(SENSE_DATA), &cbReturned, NULL);
        if(!NT_SUCCESS(status))
            {
            err.win32 = status;
            memcpy(&err.sense, &sense, sizeof(SENSE_DATA));
            successfulReadSectors = 0;
            }
        else if(sense.ErrorCode)
            {
            err.win32 = 99999;
            memcpy(&err.sense, &sense, sizeof(SENSE_DATA));

            if(globalSettings.enableRetries && sense.ErrorCode == 0x70)
                {
                if(actionState == 2 && memcmp(&previousSense, &sense, sizeof(SENSE_DATA)) != 0)
                    {
                    if(retryCount == 3)
                        {
                        retry = false;
                        actionState = 99;
                        }
                    else
                        {
                        actionState = 1;
                        }
                    }

                if(actionState == 1)
                    {
                    if((sense.SenseKey == 0x01 && sense.AdditionalSenseCode == 0x80))
                        {
                        if(spindleSpeed == 0) retry = false;
                        else { PrintPreRetryError(block, err); ChangeSpeed(hDevice, spindleSpeed-1); retry = true; }
                        }
                    else if((sense.SenseKey == 0x06 && sense.AdditionalSenseCode == 0x2E))
                        {
                        PrintPreRetryError(block, err);
                        if(globalSettings.seekOn062E)
                            {
                            SeekLBA(hDevice, 0);
                            }
                        Sleep(globalSettings.delayOn062E);

                        retry = true;
                        }
                    else if((sense.SenseKey == 0x06 && sense.AdditionalSenseCode == 0x29))
                        {
                        PrintPreRetryError(block, err);
                        while(CDTestReady(hDevice) == false)
                            {
                            // do nothing until drive is ready
                            }
                        retry = true;
                        }
                    else
                        {
                        PrintPreRetryError(block, err); 
                        retry = true;
                        }
                    }
                else if(actionState == 2)
                    {
                    if((sense.SenseKey == 0x01 && sense.AdditionalSenseCode == 0x80) ||
                       (sense.SenseKey == 0x03 && sense.AdditionalSenseCode == 0x80) ||
                       (sense.SenseKey == 0x04 && sense.AdditionalSenseCode == 0x00) ||
                       (sense.SenseKey == 0x05 && sense.AdditionalSenseCode == 0x55) ||
                       (sense.SenseKey == 0x06 && sense.AdditionalSenseCode == 0x2E) )
                        {
                        if(spindleSpeed == 0) retry = false;
                        else { PrintPreRetryError(block, err); ChangeSpeed(hDevice, spindleSpeed-1); retry = true; }
                        }
                    else
                        {
                        retry = false;
                        }
                    }
                else if(actionState == 3)
                    {
                    if((sense.SenseKey == 0x03 && sense.AdditionalSenseCode == 0x80) ||
                       (sense.SenseKey == 0x04 && sense.AdditionalSenseCode == 0x00) ||
                       (sense.SenseKey == 0x05 && sense.AdditionalSenseCode == 0x55) ||
                       (sense.SenseKey == 0x06 && sense.AdditionalSenseCode == 0x2E) )
                        {
                        if(spindleSpeed == 0) retry = false;
                        else { PrintPreRetryError(block, err); ChangeSpeed(hDevice, spindleSpeed-1); retry = true; }
                        }
                    else
                        {
                        retry = false;
                        }
                    }
                else
                    {
                    retry = false;
                    }
                }

            memcpy(&previousSense, &sense, sizeof(SENSE_DATA));
            successfulReadSectors = 0;
            }
        else
            {
            successfulReadSectors += num;
            }

        if(retry && globalSettings.summaryInternalErrs)
            {
            if(!errors) errors = new ErrorDistrubition(err);
            else errors->AddError(err);
            }

        ++actionState;
        } while(retry);

    if(globalSettings.enableRetries == 1 && spindleSpeed == 0 && successfulReadSectors >= 4096)
        {
        ChangeSpeed(hDevice, spindleSpeed+1);
        successfulReadSectors = 0;
        }
    else if(globalSettings.enableRetries == 1 && spindleSpeed == 1 && successfulReadSectors >= 16384)
        {
        ChangeSpeed(hDevice, spindleSpeed+1);
        successfulReadSectors = 0;
        }

    lastReadTime = GetTickCount()-readTime;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        LogPrint("Block %u: Read took %ums\n", block, lastReadTime);
    return err;
    }

SCSIError ReadCDBlocks2(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    // "E:\xboxsrc\private\ntos\idex\cdrom.c" (1519):IdexCdRomStartRawRead(
    DWORD readTime = GetTickCount();
    ++avgTimeCount;

	PCDB Cdb;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    DWORD cbReturned;
    SENSE_DATA sense;
    memset(&sense, 0, sizeof(SENSE_DATA));

    SCSIError err;

    // NT drivers seem to want the disk offset to be (sector - 150) * 2048,
    // regardless of what the actual disk lead-in amount is.
    RAW_READ_INFO rri;
    rri.DiskOffset.QuadPart = (unsigned __int64)(block - CDAUDIO_SECTOR_OFFSET) * (unsigned __int64)globalSettings.gDiskGeometry.BytesPerSector;
    rri.SectorCount = num;
    rri.TrackMode = CDDA;


    ZeroMemory(&PassThrough, sizeof(PassThrough));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = buffer;
    PassThrough.DataTransferLength = rri.SectorCount * IDE_ATAPI_RAW_CD_SECTOR_SIZE;

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->READ_CD.OperationCode = SCSIOP_READ_CD;
    *((PULONG)Cdb->READ_CD.StartingLBA) = RtlUlongByteSwap((ULONG)(rri.DiskOffset.QuadPart >>IDE_ATAPI_CD_SECTOR_SHIFT));
    Cdb->READ_CD.TransferBlocks[2] = (UCHAR)(rri.SectorCount);
    Cdb->READ_CD.TransferBlocks[1] = (UCHAR)(rri.SectorCount >> 8);
    Cdb->READ_CD.TransferBlocks[0] = (UCHAR)(rri.SectorCount >> 16);

    // TrackMode == CDDA
    Cdb->READ_CD.ExpectedSectorType = 1;
    Cdb->READ_CD.IncludeUserData = 1;
    Cdb->READ_CD.HeaderCode = 3;
    Cdb->READ_CD.IncludeSyncData = 1;

/*
    // TrackMode == YellowMode2
    Cdb.READ_CD.ExpectedSectorType = 3;
    Cdb.READ_CD.IncludeUserData = 1;
    Cdb.READ_CD.HeaderCode = 1;
    Cdb.READ_CD.IncludeSyncData = 1;

    // TrackMode == XAForm2
    Cdb.READ_CD.ExpectedSectorType = 5;
    Cdb.READ_CD.IncludeUserData = 1;
    Cdb.READ_CD.HeaderCode = 3;
    Cdb.READ_CD.IncludeSyncData = 1;
*/

    if(!DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), &sense, sizeof(SENSE_DATA), &cbReturned, NULL))
        {
        err.win32 = GetLastError();
        memcpy(&err.sense, &sense, sizeof(SENSE_DATA));
        }
    //status = DeviceIoControl(hDevice, IOCTL_CDROM_RAW_READ, &rri, sizeof(RAW_READ_INFO), buffer, CDAUDIO_BYTES_PER_FRAME * num, &cbReturned, NULL);
    //status = DeviceIoControl(hDevice, IOCTL_CDROM_RAW_READ, &rri, sizeof(RAW_READ_INFO), buffer, gDiskGeometry.BytesPerSector * num, &cbReturned, NULL);


    lastReadTime = GetTickCount()-readTime;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        LogPrint("Block %u: Read took %ums\n", block, lastReadTime);
    return err;
    }


SCSIError ReadCDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    DWORD readTime = GetTickCount();
    ++avgTimeCount;

    SCSIError err;
    NTSTATUS status;
    DWORD cbReturned;
    RAW_READ_INFO rri;

    // NT drivers seem to want the disk offset to be (sector - 150) * 2048,
    // regardless of what the actual disk lead-in amount is.
    rri.DiskOffset.QuadPart = (unsigned __int64)(block - CDAUDIO_SECTOR_OFFSET) * (unsigned __int64)globalSettings.gDiskGeometry.BytesPerSector;
    rri.SectorCount = num;
    rri.TrackMode = CDDA;

    status = DeviceIoControl(hDevice, IOCTL_CDROM_RAW_READ, &rri, sizeof(RAW_READ_INFO), buffer, CDAUDIO_BYTES_PER_FRAME * num, &cbReturned, NULL);
    //status = DeviceIoControl(hDevice, IOCTL_CDROM_RAW_READ, &rri, sizeof(RAW_READ_INFO), buffer, gDiskGeometry.BytesPerSector * num, &cbReturned, NULL);

    if(!NT_SUCCESS(status))
        {
        err.win32 = RtlNtStatusToDosError(status);
        }

    lastReadTime = GetTickCount()-readTime;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        LogPrint("Block %u: Read took %ums\n", block, lastReadTime);
    return err;
    }

SCSIError ReadHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    DWORD readTime = GetTickCount();
    ++avgTimeCount;

    SCSIError err;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    LARGE_INTEGER Offset;

    // Calculate Offset
    Offset.QuadPart = (unsigned __int64)block * (unsigned __int64)globalSettings.gDiskGeometry.BytesPerSector;

    // Read bytes at offset
    status = NtReadFile(hDevice, NULL, NULL, NULL, &ioStatusBlock, buffer, num * globalSettings.gDiskGeometry.BytesPerSector, &Offset);

    if(!NT_SUCCESS(status))
        {
        err.win32 = RtlNtStatusToDosError(status);
        }

    lastReadTime = GetTickCount()-readTime;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        LogPrint("Block %u: Read took %ums\n", block, lastReadTime);
    return err;
    }


void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware)
    {
    unsigned i;
    DWORD returned;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;
    bool closeHandle = false;

    if(hDevice == NULL)
        {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        if(cdrom)
            RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        else
            RtlInitObjectString(&VolumeString, "\\Device\\Harddisk0\\Partition0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
        }

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(cdrom) atapt->IdeReg.bCommandReg = 0xA1;
    else atapt->IdeReg.bCommandReg = 0xEC;

    DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH, atapt, sizeof(ATA_PASS_THROUGH), atapt, sizeof(ATA_PASS_THROUGH), &returned, FALSE);
    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for(i=0; i<sizeof(IdData->ModelNumber); i+=2)
        {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
        }
    model[i] = 0;

    for(i=0; i<sizeof(IdData->SerialNumber); i+=2)
        {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
        }
    serial[i] = 0;

    for(i=0; i<sizeof(IdData->FirmwareRevision); i+=2)
        {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
        }
    firmware[i] = 0;

    if(closeHandle) NtClose(hDevice);
    }


void ChangeSpeed(HANDLE hDevice, DWORD newSpeed)
    {
    DWORD cbReturned;

    if(spindleSpeed == newSpeed) return;

    DeviceIoControl(hDevice, IOCTL_CDROM_SET_SPINDLE_SPEED, &newSpeed, sizeof(newSpeed), NULL, 0, &cbReturned, NULL);
    LogPrint("Speed changed to %u (ec: %u)\n", newSpeed, GetLastError());

    if(spindleSpeed == 0 && newSpeed == 1) Sleep(globalSettings.speedDelay0to1);
    else if(spindleSpeed == 1 && newSpeed == 2) Sleep(globalSettings.speedDelay1to2);
    else if(spindleSpeed == 2 && newSpeed == 1) Sleep(globalSettings.speedDelay2to1);
    else if(spindleSpeed == 1 && newSpeed == 0) Sleep(globalSettings.speedDelay1to0);
    else if(spindleSpeed == 0 && newSpeed == 2) Sleep(globalSettings.speedDelay0to2);
    else if(spindleSpeed == 2 && newSpeed == 0) Sleep(globalSettings.speedDelay2to0);

    spindleSpeed = newSpeed;
    }


void SeekLBA(HANDLE hDevice, DWORD LBA)
    {
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    SENSE_DATA SenseData;
    DWORD cbBytesReturned;
    PCDB Cdb;

    RtlZeroMemory(&PassThrough, sizeof(PassThrough));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->SEEK.OperationCode = SCSIOP_SEEK;
    *((PULONG)Cdb->SEEK.LogicalBlockAddress) = RtlUlongByteSwap(LBA);

    DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
                                &SenseData, sizeof(SenseData),
                                &cbBytesReturned, NULL);
    
    
    LogPrint("Seek to %u (ec: %u)\n", LBA, GetLastError());
    }


bool CDTestReady(HANDLE hDevice)
    {
    DWORD cbReturned;

    BOOL fReturn = DeviceIoControl(hDevice, IOCTL_CDROM_CHECK_VERIFY, NULL, 0, NULL, 0, &cbReturned, NULL);

    if(fReturn || (GetLastError() == ERROR_UNRECOGNIZED_MEDIA))
        {
        return false;
        }
    
    return true;
    }


void RequestSense(HANDLE hDevice, SCSIError &err)
    {
	PCDB Cdb;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    DWORD cbReturned;
    SENSE_DATA sense;

    ZeroMemory(&PassThrough, sizeof(PassThrough));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = &sense;
    PassThrough.DataTransferLength = sizeof(SENSE_DATA);

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
	Cdb->CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

    SetLastError(0);
    memset(&err, 0, sizeof(SCSIError));
    memset(&sense, 0, sizeof(SENSE_DATA));

    DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT), &sense, sizeof(SENSE_DATA), &cbReturned, NULL);

    err.win32 = GetLastError();
    memcpy(&err.sense, &sense, sizeof(SENSE_DATA));
    }





DWORD GetDiskType(HANDLE hDevice)
    {
    DVD_READ_STRUCTURE readStruct;
    UCHAR readStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) + sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];

    bool closeHandle = false;

    if(hDevice == NULL)
        {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
        }

    memset(&readStruct, 0, sizeof(DVD_READ_STRUCTURE));
    memset(readStructureOutput, 0, sizeof(readStructureOutput));

    // try DVD Read Structure
    readStruct.Format = DvdPhysicalDescriptor;

    DWORD returned = 0;
    BOOL result = DeviceIoControl(hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(DVD_READ_STRUCTURE), readStructureOutput, sizeof(readStructureOutput), &returned, NULL);
    if(result)
        {
        if(closeHandle) NtClose(hDevice);
        DVD_LAYER_DESCRIPTOR *layerDescr = (DVD_LAYER_DESCRIPTOR *)(&readStructureOutput[sizeof(DVD_DESCRIPTOR_HEADER)]);
        BYTE layerType = (layerDescr->BookType) | (layerDescr->BookVersion << 4);
        if(layerDescr->LayerType == 1)
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RO;
            else return MEDIA_DVD_9_RO;
            }
        else
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RW;
            else return MEDIA_DVD_9_RW;
            }
        }

    // not a DVD disk...
    else
        {
	    CDROM_TOC toc;
        memset(&toc, 0, sizeof(CDROM_TOC));
		result = DeviceIoControl( hDevice, IOCTL_CDROM_READ_TOC, &toc, sizeof(CDROM_TOC), &toc, sizeof(CDROM_TOC), &returned, NULL);
        if(closeHandle) NtClose(hDevice);
        if(result)
            {
            if(toc.FirstTrack == toc.LastTrack) return MEDIA_CDROM;
            return MEDIA_CDDA;
            }
        else
            {
            return MEDIA_CDROM;
            }
        }

    return MEDIA_UNKNOWN;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskRead\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    Helper functions

Notes:

*****************************************************************************/

#include "diskRead.h"

void CompareBuff(unsigned char *buff1, unsigned char *buff2, unsigned char *buff3, unsigned length)
    {
    for(unsigned i=0; i<length; i++)
        {
        if(buff1[i] != buff2[i])
            {
            LogPrint("    %08X: %02X %02X %02X\n", i, buff1[i], buff2[i], buff3[i]);
            }
        }
    }

void PrintPreRetryError(DWORD block, SCSIError &err)
    {
    LogPrint("Block %u: Internal Error ", block);
    err.Print();
    LogPrint(" retrying\n");
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskWrite\diskWrite.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    diskWrite.cpp

Abstract:

    Disk scanner

Notes:
    Hard Drive Partition Sizes
        \Device\Harddisk0\Partition0 19541088
        \Device\Harddisk0\Partition1  9997568   C:
        \Device\Harddisk0\Partition2  1023840   Y:
        \Device\Harddisk0\Partition3  1535776   Z:
        \Device\Harddisk0\Partition4  1535776   Z:
        \Device\Harddisk0\Partition5  1535776   Z:

Tests:
    Read Write Read (low level)                     (test 0)
    Create Many Files (file system level)           (test 1)
    Massive Write then verify  (file system level)  (test 2)

*****************************************************************************/

#include "diskWrite.h"
#include <xbeimage.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[XGetPortCount()*2] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
DWORD addDevice, removeDevice;


//
// config settings
//
ConfigSettings globalSettings;

//
// stats
//
DWORD numFail = 0;
DWORD numPass = 0;
DWORD numErrors = 0;
DWORD numBuffMismatch = 0;
DWORD numTimesThrough = 1;
DWORD time = 0;
unsigned __int64 bytesWritten = 0;
unsigned __int64 numWrites = 0;
unsigned __int64 numBlocksRead = 0;
unsigned __int64 numBlocksWritten = 0;
char model[64], serial[64], firmware[64];
DWORD mediaType = MEDIA_UNKNOWN;
bool cleanup = false;
DWORD avgTimeCount;
DWORD avgTime;
DWORD lastReadTime;
LAUNCH_DATA launchInfo;

void TestReadWriteRead(void);
void TestCreateFile(void);
void TestWriteFile(void);

void ParseTestConfig(char *variable, char *value, void *userParam)
    {
    ConfigSettings *settings = (ConfigSettings*)userParam;

    if(strstr(variable, "drive") != NULL) strcpy(settings->drive, value);
    else if(strstr(variable, "test") != NULL) settings->test = GetNumber(value);
    else if(strstr(variable, "seed") != NULL) settings->seed = GetNumber(value);
    else if(strstr(variable, "writesize") != NULL) settings->writeSize = GetNumber(value);
    else if(strstr(variable, "pauseonexit") != NULL) settings->pauseOnExit = GetNumber(value);
    else if(strstr(variable, "startlba") != NULL) settings->startLBA = GetNumber(value);
    else if(strstr(variable, "endlba") != NULL) settings->endLBA = GetNumber(value);
    else if(strstr(variable, "sequentialreads") != NULL) settings->sequentialReads = GetNumber(value);
    else if(strstr(variable, "partition") != NULL) settings->partition = GetNumber(value);
    else if(strstr(variable, "pauseonmismatch") != NULL) settings->pauseOnMismatch = GetNumber(value);
    }


#pragma warning(disable : 4326) // return type of 'main' should be 'int or void' instead of 'ShutDown'
struct ShutDown
    {
    ShutDown(LAUNCH_DATA &launchInfo, unsigned __int64 pass, unsigned __int64 fail, char *format, ...)
        {
        ToLauncherData* outParams = (ToLauncherData*)&launchInfo;
        ToTestData* initialParams = (ToTestData*)&launchInfo;

        if(initialParams->titleID == HVSLAUNCHERID)
            {
            outParams->titleID = XeImageHeader()->Certificate->TitleID;
            outParams->numPass = pass;
            outParams->numFail = fail;
            va_list args;
            va_start(args, format);
            vsprintf(outParams->notes, format, args);
            va_end(args);

            LaunchImage("D:\\default.xbe", &launchInfo);
            }
        else
            XLaunchNewImage(NULL, NULL);
        }
    };


ShutDown _cdecl main(void)
    {
    DBDATA results;

    //
    // Get the launch data (if any)
    //
    DWORD dataType = 0xCDCDCDCD;
    XGetLaunchInfo(&dataType, &launchInfo);
    ToTestData* initialParams = (ToTestData*)&launchInfo;

    Initialize();

    //
    // cleanup old files
    //
    DeleteFile("T:\\testexit.txt");

    char *iniConfig = NULL;



    //
    // Grab the startup parameters
    //
    if(initialParams->titleID == HVSLAUNCHERID)
        {
        iniConfig = new char[strlen(initialParams->configSettings)+1];
        strcpy(iniConfig, initialParams->configSettings);
        ParseConfigSettings(initialParams->configSettings, &globalSettings, ParseTestConfig, &globalSettings);
        }
    else
        {
        FILE *file = fopen("D:\\diskWrite.ini", "rb");
        if(file)
            {
            DWORD filesize = _filelength(_fileno(file));
            iniConfig = new char[filesize+1];
            unsigned bytesRead = fread(iniConfig, 1, filesize, file);
            iniConfig[bytesRead] = '\0';

            ParseConfigSettings(iniConfig, &globalSettings, ParseTestConfig, &globalSettings);
            if(fseek(file, 0, SEEK_SET) == 0)
                {
                bytesRead = fread(iniConfig, 1, filesize, file);
                iniConfig[bytesRead] = '\0';
                }
            fclose(file);
            }
        }


    // Call SetSaveName BEFORE calling LogPrint or LogFlush
    SetSaveName(globalSettings.saveName, "diskWrite.log");
    LogFlush();

    if(initialParams->titleID == HVSLAUNCHERID)
        LogPrint("Launched from HVS\n  Test %u of %u\n\n", initialParams->testNumber, initialParams->totalTests);
    else
        LogPrint("Running in stand a lone mode\n\n");

    LogPrint("Disk Write (Built on " __DATE__ " at " __TIME__ ")\n");
    LogPrint("Copyright (C) Microsoft Corporation.  All rights reserved.\n\n");


    memset(model, 0, 64);
    memset(serial, 0, 64);
    memset(firmware, 0, 64);

    char driveLetter = CLEARFLAG(globalSettings.drive[0], 0x20); // make it caps

    if(globalSettings.test == TEST_READ_WRITE_READ) driveLetter = 'C'; // drive letter isnt used on this test...

    if(driveLetter == 'D') // can be either DVD or HD
        {
        ULARGE_INTEGER avail, total, free;
        GetDiskFreeSpaceEx("D:\\", &avail, &total, &free);
        if(free.QuadPart != 0) driveLetter = 'C'; // D points to hard disk
        }
    else if(driveLetter == 'A') // DVD
        driveLetter = 'D';

    if(driveLetter >= 'F' && driveLetter <= 'M') // MU
        {
        Sleep(2000); // let the mus get mounted

        strcpy(model, "MU");
        results.deviceType = "MU";
        mediaType = MEDIA_MU;
        }
    else if(driveLetter == 'D') // CD/DVD
        {
        results.deviceType = "DVD";
        GetDriveID(NULL, true, model, serial, firmware);
        mediaType = GetDiskType(NULL);
        // TODO error, cant write to a DVD / CD
        }

    // hard disk
    else if(driveLetter == 'C')
        {
        results.deviceType = "Hard Drive";
        GetDriveID(NULL, false, model, serial, firmware);
        mediaType = MEDIA_HD;
        MapDrive('C', "\\Device\\Harddisk0\\Partition1");
        }
    else if(driveLetter == 'Y')
        {
        results.deviceType = "Hard Drive";
        GetDriveID(NULL, false, model, serial, firmware);
        mediaType = MEDIA_HD;
        MapDrive('Y', "\\Device\\Harddisk0\\Partition2");
        }
    else
        {
        results.deviceType = "Hard Drive";
        GetDriveID(NULL, false, model, serial, firmware);
        mediaType = MEDIA_HD;
        }


    //
    // print out the drive info and config settings
    //
	LogPrint("DRIVE: Model:             %s\n", model);
	LogPrint("DRIVE: Serial:            %s\n", serial);
	LogPrint("DRIVE: Firmware:          %s\n", firmware);
    LogPrint("MEDIA: Type:              %s\n", mediaTypeNames[mediaType]);

    LogPrint("Config Settings:\n");
    LogPrint("  ResultsServer:    %s\n", globalSettings.resultsServer);
    LogPrint("  SaveName:         %s\n", globalSettings.saveName);
    LogPrint("  StopAfter:        %u %s\n", globalSettings.stopAfter.duration, globalSettings.stopAfter.type==STOPAFTER_MINUTES?"min":(globalSettings.stopAfter.type==STOPAFTER_HOURS?"hours":"iterations"));
	LogPrint("\n");
    LogPrint("  Drive:            %s\n", globalSettings.drive);
    LogPrint("  Test:             %u\n", globalSettings.test);
    LogPrint("  WriteSize:        %u\n", globalSettings.writeSize);
    LogPrint("\n");
    // TODO logPrint the rest of the settings

    srand(globalSettings.seed);

    // run test
    if(globalSettings.test == TEST_READ_WRITE_READ)
        {
        TestReadWriteRead();
        }
    else if(globalSettings.test == TEST_CREATE_FILES)
        {
        TestCreateFile();
        }
    else if(globalSettings.test == TEST_WRITE_FILE)
        {
        TestWriteFile();
        }


    //
    // dump the stats
    //
    DWORD finalTime = (GetTickCount() - time)/1000;

    LogPrint("****Program Stats:\n");
    LogPrint("*** %9u sec run time\n", finalTime);
    LogPrint("*** %9I64u Total bytes written\n", bytesWritten);
    LogPrint("****\n");
    LogPrint("*** %9u Failures\n", numFail);
    LogPrint("*** %9u Successes\n", numPass);
    LogPrint("****\n");
    LogPrint("*** %9u errors / attempts\n", (numFail+numPass)? numFail / (numFail+numPass) : 0);
    LogPrint("*** %9u errors / sec\n", finalTime? numFail / finalTime : 0);

    //
    // Post results if necessary
    //
    if(strncmp(globalSettings.resultsServer, "http://", 7) == 0)
        {
        WSADATA wsaData;
        unsigned short version = MAKEWORD(2, 2);
        WSAStartup(version, &wsaData);

        results.manufacturer = RightTrim(model);
        results.firmwareVersion = RightTrim(firmware);
        results.hardwareVersion = "";
        results.serialNumber = RightTrim(serial);
        results.testName = "Disk Write";

        char variation[256];
        results.boxInformation = GetBoxInformation();
        results.configSettings = iniConfig;
        results.variation = variation;

        if(globalSettings.test == TEST_READ_WRITE_READ)
            {
            sprintf(variation, "Test %s, Partition %u", testNames[globalSettings.test], globalSettings.partition);

            // failures (read/write errors)
            results.status = 0;
            results.numOperations = numErrors;
            results.notes = "Read/Write Errors";
            if(results.numOperations)
                PostResults(globalSettings.resultsServer, &results);

            // failures (buffer mismatches)
            results.status = 0;
            results.numOperations = numBuffMismatch;
            results.notes = "Buffer Mismatches";
            if(results.numOperations)
                PostResults(globalSettings.resultsServer, &results);
            }
        else if(globalSettings.test == TEST_CREATE_FILES)
            {
            sprintf(variation, "Test %s, Drive %s", testNames[globalSettings.test], globalSettings.drive);

            // failures (read errors)
            results.status = 0;
            results.numOperations = numFail;
            results.notes = "Read Errors";
            if(results.numOperations)
                PostResults(globalSettings.resultsServer, &results);
            }
        else if(globalSettings.test == TEST_WRITE_FILE)
            {
            sprintf(variation, "Test %s, Drive %s", testNames[globalSettings.test], globalSettings.drive);

            // TODO
            }

        // passes
        results.status = 1;
        results.numOperations = numPass;
        results.notes = "Successful Writes";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // cleanup
        delete[] results.boxInformation;
        }

    delete[] iniConfig;

    if(driveLetter == 'C')
        UnMapDrive('C');
    else if(driveLetter == 'Y')
        UnMapDrive('Y');

    if(globalSettings.pauseOnExit)
        {
        Pause();
        }
    else
        {
        // persist the display across the reboot
        g_pDevice->PersistDisplay();
        }

    //
    // test done, reboot
    //
    return ShutDown(launchInfo, numPass, numFail, "\0");
    }


void TestReadWriteRead(void)
    {
    DWORD rando = 0;
    ULONGLONG bigResult = 0;
    DWORD geoSize;
    DWORD status;
    DWORD err1=0, err2=0, err3=0;
    DWORD block = globalSettings.startLBA;

    char deviceName[48];
    sprintf(deviceName, "\\Device\\Harddisk0\\Partition%u", globalSettings.partition);

    //
    // open the Hard drive
    //
    HANDLE hDevice;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    RtlInitObjectString(&VolumeString, deviceName);
    InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING | FILE_FLAG_WRITE_THROUGH);
    if(!NT_SUCCESS(status))
        {
        LogPrint("Unable to open the device '%s' (ec: %u)\n", deviceName, RtlNtStatusToDosError(status));
        DebugPrint("Rebooting...\n\n\n");
        ShutDown(launchInfo, 0, 0, "Unable to open the device:\\n '%s' (ec: %u)", deviceName, RtlNtStatusToDosError(status));
        return;
        }

	DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &globalSettings.gDiskGeometry, sizeof(globalSettings.gDiskGeometry), &geoSize, NULL);
    if(globalSettings.gDiskGeometry.Cylinders.QuadPart == 0)
        {
        NtClose(hDevice);
        LogPrint("No Media Detected\n");
        DebugPrint("Rebooting...\n\n\n");
        ShutDown(launchInfo, 0, 0, "No Media Detected");
        return;
        }

    // gDiskGeometry.Cylinders.QuadPart contains the size of the entire 
    // disk but we only want the size of the current partition so we 
    // need to query the size of the volume and adjust the value
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;
    memset(&NormalSizeInfo, 0, sizeof(NormalSizeInfo));
    NtQueryVolumeInformationFile(
                hDevice,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );
    globalSettings.gDiskGeometry.Cylinders.QuadPart = NormalSizeInfo.TotalAllocationUnits.QuadPart * NormalSizeInfo.SectorsPerAllocationUnit;
    if(globalSettings.endLBA == 0) globalSettings.endLBA = (DWORD)globalSettings.gDiskGeometry.Cylinders.QuadPart;

    //
    // allocate buffer memory
    //
    unsigned char *buff1 = new unsigned char[globalSettings.writeSize * globalSettings.gDiskGeometry.BytesPerSector];
    unsigned char *buff2 = new unsigned char[globalSettings.writeSize * globalSettings.gDiskGeometry.BytesPerSector];
    unsigned char *buff3 = new unsigned char[globalSettings.writeSize * globalSettings.gDiskGeometry.BytesPerSector];
    if(!buff1 || !buff2 || !buff3)
        {
        LogPrint("Unable to allocate enough space (%u)\n", (globalSettings.writeSize * globalSettings.gDiskGeometry.BytesPerSector) * 3);
        LogPrint("Try lowering writeSize\n");
        DebugPrint("Rebooting...\n\n\n");
        NtClose(hDevice);
        ShutDown(launchInfo, 0, 0, "Unable to allocate enough space (%u)", (globalSettings.writeSize * globalSettings.gDiskGeometry.BytesPerSector) * 3);
        return;
        }

    time = GetTickCount();

    bool exit = false;
    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
        UpdateGraphics(DISPLAYMODE_RUN_TIME);

        err1 = err2 = err3 = 0;

        memset(buff1, 0, globalSettings.writeSize * globalSettings.gDiskGeometry.BytesPerSector);
        memset(buff2, 0, globalSettings.writeSize * globalSettings.gDiskGeometry.BytesPerSector);
        memset(buff3, 0, globalSettings.writeSize * globalSettings.gDiskGeometry.BytesPerSector);

        ++numWrites;

        err1 = ReadHDBlocks(hDevice, block, globalSettings.writeSize, buff1);
        numBlocksRead += globalSettings.writeSize;
        if(err1 == 0)
            {
            // if the read failed dont even try to write it
            err2 = WriteHDBlocks(hDevice, block, globalSettings.writeSize, buff1);
            numBlocksWritten += globalSettings.writeSize;
            err3 = ReadHDBlocks(hDevice, block, globalSettings.writeSize, buff2);
            numBlocksRead += globalSettings.writeSize;
            }

        if((err1 != err2) || (err1 != err3))
            {
            LogPrint("Block %u: Error1(%u, %08X) != Error2(%u, %08X) != Error3(%u, %08X)\n", block, RtlNtStatusToDosError(err1), err1, RtlNtStatusToDosError(err2), err2, RtlNtStatusToDosError(err3), err3);
            ++numErrors;
            // TODO if(err2) try rewriting buff1 becuase we may have just screwed up the disk
            }
        else if(memcmp(buff1, buff2, globalSettings.writeSize*globalSettings.gDiskGeometry.BytesPerSector) != 0)
            {
            if(globalSettings.pauseOnMismatch) Pause();

            LogPrint("Block %u: Buff1 != Buff2\n", block);
            ++numBuffMismatch;

            /*
            int retry = 3;
            do {
                // do another read for reference
                err4 = ReadBlocks(hDevice, block, globalSettings.writeSize, buff3);
                retry--;
                } while(err4 != 0 && retry >= 0);

            numBlocksRead += globalSettings.readSize;
            if(globalSettings.compareBuffers) CompareBuff(buff1, buff2, buff3, globalSettings.readSize*globalSettings.gDiskGeometry.BytesPerSector);
            */
            // TODO try rewriting buff1 becuase we may have just screwed up the disk
            }
        else
            {
            ++numPass;
            }

        //
        // adjust the read/write pointer
        //
        do {
            if(globalSettings.sequentialReads)
                {
                block += globalSettings.writeSize;
                if(block >= globalSettings.endLBA)
                    {
                    block = globalSettings.startLBA;
                    ++numTimesThrough;
                    }
                }
            else
                {
                rando = rand();
                bigResult = (ULONGLONG)(rando*(ULONGLONG)(globalSettings.endLBA-globalSettings.startLBA));
                block = (DWORD)((bigResult/RAND_MAX) + globalSettings.startLBA);
                }
            } while(block+globalSettings.writeSize >= globalSettings.endLBA);

        if(InputCheckDigitalButton(XINPUT_GAMEPAD_START)) GUI();
        if(InputCheckExitCombo()) exit = true;
        if(globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && numTimesThrough > globalSettings.stopAfter.duration) exit = true;
        if(globalSettings.stopAfter.duration)
            {
            if((globalSettings.stopAfter.type == STOPAFTER_MINUTES && TICK2MIN(GetTickCount() - time) >= globalSettings.stopAfter.duration) ||
                (globalSettings.stopAfter.type == STOPAFTER_HOURS && TICK2HOUR(GetTickCount() - time) >= globalSettings.stopAfter.duration) )
                {
                exit = true;
                }
            }
        }

    delete[] buff1;
    delete[] buff2;
    delete[] buff3;
    NtClose(hDevice);

    numFail = numErrors + numBuffMismatch;
    }



void TestCreateFile(void)
    {
    char path[MAX_PATH];
    char *filename;
    DWORD wSize, write;
    HANDLE hFile;
    filename = path + sprintf(path, "%s\\diskWriteDir", globalSettings.drive);

    unsigned char *buff1 = new unsigned char[globalSettings.writeSize];
    if(!buff1)
        {
        LogPrint("Unable to allocate enough space (%u)\n", globalSettings.writeSize);
        LogPrint("Try lowering writeSize\n");
        DebugPrint("Rebooting...\n\n\n");
        ShutDown(launchInfo, 0, 0, "Unable to allocate enough space (%u)", globalSettings.writeSize);
        return;
        }
    for(unsigned buffFiller=0; buffFiller<globalSettings.writeSize; buffFiller++) buff1[buffFiller] = (unsigned char)buffFiller;

    time = GetTickCount();

    if(!CreateDirectory(path, NULL))
        {
        LogPrint("Create directory '%s' failed (ec: %u)\n", path, GetLastError());
        delete[] buff1;
        return;
        }

    bool exit = false;
    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
        UpdateGraphics(DISPLAYMODE_RUN_TIME);

        sprintf(filename, "\\diskWrite%04X.tmp", numTimesThrough);
        hFile = CreateFile(path, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN|FILE_FLAG_WRITE_THROUGH, NULL);

        if(hFile == INVALID_HANDLE_VALUE)
            {
            LogPrint("CreateFile Failure: (ec: %u) on %s\n", GetLastError(), path);
            ++numFail;
            }
        else
            {
            write = rand() % globalSettings.writeSize;
            if(!WriteFile(hFile, buff1, write, &wSize, NULL))
                {
                LogPrint("Write Failure: (ec: %u) on %s\n", GetLastError(), path);
                ++numFail;
                }
            else if(write != wSize)
                {
                LogPrint("Write Failure: unable to write correct number of bytes (wrote %u, from %u) (ec: %u) on %s\n", wSize, write, GetLastError(), path);
                ++numFail;
                }
            else
                {
                bytesWritten += write;
                ++numPass;
                }
            CloseHandle(hFile);
            }

        ++numTimesThrough;

        if(InputCheckDigitalButton(XINPUT_GAMEPAD_START)) GUI();
        if(InputCheckExitCombo())
            {
            exit = true;
            break;
            }
        if(globalSettings.stopAfter.type == STOPAFTER_ITERATIONS)
            if(numTimesThrough > globalSettings.stopAfter.duration) exit = true;
        if(globalSettings.stopAfter.duration)
            {
            if((globalSettings.stopAfter.type == STOPAFTER_MINUTES && TICK2MIN(GetTickCount() - time) >= globalSettings.stopAfter.duration) ||
                (globalSettings.stopAfter.type == STOPAFTER_HOURS && TICK2HOUR(GetTickCount() - time) >= globalSettings.stopAfter.duration) )
                {
                exit = true;
                break;
                }
            }
        }

    cleanup = true;

    for(DWORD i=1; i<=numTimesThrough; i++)
        {
        sprintf(filename, "\\diskWrite%04X.tmp", i);
        if(!DeleteFile(path))
            {
            LogPrint("Delete Failure: %u on %s\n", GetLastError(), path);
            }
        }

    filename[0] = '\0';
    RemoveDirectory(path);
    delete[] buff1;
    }


void TestWriteFile(void)
    {
    time = GetTickCount();

    // Run the test
    bool exit = false;
    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
        UpdateGraphics(DISPLAYMODE_RUN_TIME);

        //TODO run test

        if(InputCheckDigitalButton(XINPUT_GAMEPAD_START)) GUI();
        if(InputCheckExitCombo())
            {
            exit = true;
            break;
            }
        if(globalSettings.stopAfter.type == STOPAFTER_ITERATIONS)
            if(numTimesThrough > globalSettings.stopAfter.duration) exit = true;
        if(globalSettings.stopAfter.duration)
            {
            if((globalSettings.stopAfter.type == STOPAFTER_MINUTES && TICK2MIN(GetTickCount() - time) >= globalSettings.stopAfter.duration) ||
                (globalSettings.stopAfter.type == STOPAFTER_HOURS && TICK2HOUR(GetTickCount() - time) >= globalSettings.stopAfter.duration) )
                {
                exit = true;
                break;
                }
            }
        }

    // TODO DeleteFile(globalSettings.fileName);
    }

void Initialize(void)
    {
    //
    // USB
    //
    XInitDevices(0, NULL);

    //
    // Network
    //
    XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    XNetStartup(&xnsp);

    //
    //
    //
    InitGraphics();
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskWrite\diskWrite.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    diskWrite.h

Abstract:

    File System disk scanner.

*****************************************************************************/

#ifndef _DISKWRITE_H_
#define _DISKWRITE_H_

#ifdef _VC
//#define DEVICE_TYPE ULONG
#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500
#endif

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>

#include <xtl.h>
#include <stdio.h>

#include "../utils/hvsUtils.h"
#include "bitfont.h"

#define CLEARFLAG(var, flag)    (var &= ~(flag))
#define SETFLAG(var, flag)      (var |=  (flag))

//
// Initialization calls
//
void Initialize(void);
HRESULT InitGraphics(void);

//
// User input
// 
void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);
bool InputCheckButton(int button);
bool InputCheckDigitalButton(int button);
void Pause(void);


//
// Graphics / GUI methods
//
enum DISPLAY_MODE
    {
    DISPLAYMODE_PAUSE,
    DISPLAYMODE_RUN_TIME,
    DISPLAYMODE_CONFIG_READONLY,
    DISPLAYMODE_CONFIG_INTERACTIVE
    };
void UpdateGraphics(unsigned mode = DISPLAYMODE_RUN_TIME);
void GUI(void);
void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...);


//
// Utility functions
//
void CompareBuff(unsigned char *buff1, unsigned char *buff2, unsigned char *buff3, unsigned length);
DWORD MapDrive( char cDriveLetter, char* pszPartition );
DWORD UnMapDrive( char cDriveLetter );


typedef bool (*PARSE_FUNC)(char *path, WIN32_FIND_DATA &data);
bool ParseFiles(char *path, PARSE_FUNC funct);



//
// User input
//
extern HANDLE hDuke[XGetPortCount()];
extern HANDLE hSlot[XGetPortCount()*2];
static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };

enum MEDIA_TYPES
	{
	MEDIA_UNKNOWN,
	MEDIA_CDDA,
	MEDIA_CDROM,
	MEDIA_DVD_5_RO,
	MEDIA_DVD_5_RW,
	MEDIA_DVD_9_RO,
	MEDIA_DVD_9_RW,
	MEDIA_HD,
    MEDIA_MU
	};

static const char *mediaTypeNames[] = 
    {
    "Unknown",
    "CD DA",
    "CD ROM",
    "DVD 5 RO",
    "DVD 5 RW",
    "DVD 9 RO",
    "DVD 9 RW",
    "Hard Disk",
    "MU"
    };

//
// config settings
//
struct ConfigSettings : public CoreConfigSettings
    {
    char drive[128];
    DISK_GEOMETRY gDiskGeometry;
    DWORD test;
    DWORD seed;
    DWORD writeSize;
    DWORD pauseOnExit;
    DWORD pauseOnMismatch;

    // test == TEST_READ_WRITE_READ
    DWORD startLBA;
    DWORD endLBA;
    DWORD sequentialReads;
    DWORD partition;

    // test == TEST_CREATE_FILES

    // test == TEST_WRITE_FILE

    ConfigSettings()
        {
        strcpy(drive, "U:");
        memset(&gDiskGeometry, 0, sizeof(gDiskGeometry));
        test = 0;

        seed = 0;
        writeSize = 64*KILOBYTE;
        pauseOnExit = 0;
        pauseOnMismatch = 0;

        // test == TEST_READ_WRITE_READ
        startLBA = 0;
        endLBA = 0;
        sequentialReads = 1;
        partition = 0;

        stopAfter.type = STOPAFTER_ITERATIONS;
        stopAfter.duration = 1;
        }
    };

extern ConfigSettings globalSettings;

enum TestTypes
    {
    TEST_READ_WRITE_READ,
    TEST_CREATE_FILES,
    TEST_WRITE_FILE
    };
static char *testNames[] = 
    {
    "Read Write Read",
    "Create Files",
    "Write File"
    };

//
// stats
//
extern DWORD numFail;
extern DWORD numPass;
extern DWORD numErrors;
extern DWORD numBuffMismatch;
extern DWORD numTimesThrough;
extern DWORD time;
extern char model[64], serial[64], firmware[64];
extern DWORD mediaType;
extern DWORD addDevice, removeDevice;
extern unsigned __int64 bytesWritten;
extern unsigned __int64 numWrites;
extern unsigned __int64 numBlocksRead;
extern unsigned __int64 numBlocksWritten;
extern bool cleanup;
extern DWORD avgTimeCount;
extern DWORD avgTime;
extern DWORD lastReadTime;

//
// graphics
//
extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;


void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
DWORD GetDiskType(HANDLE hDevice);
DWORD ReadHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);
DWORD WriteHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer);


//
// Low level IOCTL stuff
//
/*
#define CTL_CODE(DeviceType, Function, Method, Access) ( \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) )

#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_CONTROLLER          0x00000004

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define FILE_ANY_ACCESS                 0

#define IOCTL_DVD_BASE                  FILE_DEVICE_DVD
#define IOCTL_DVD_START_SESSION         CTL_CODE(IOCTL_DVD_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_READ_KEY              CTL_CODE(IOCTL_DVD_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY              CTL_CODE(IOCTL_DVD_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_END_SESSION           CTL_CODE(IOCTL_DVD_BASE, 0x0403, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SET_READ_AHEAD        CTL_CODE(IOCTL_DVD_BASE, 0x0404, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_GET_REGION            CTL_CODE(IOCTL_DVD_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY2             CTL_CODE(IOCTL_DVD_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DVD_READ_STRUCTURE        CTL_CODE(IOCTL_DVD_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_BASE                FILE_DEVICE_CD_ROM
#define IOCTL_CDROM_GET_DRIVE_GEOMETRY  CTL_CODE(IOCTL_CDROM_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SET_SPINDLE_SPEED   CTL_CODE(IOCTL_CDROM_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_CHECK_VERIFY        CTL_CODE(IOCTL_CDROM_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
//#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define CDAUDIO_BYTES_PER_FRAME         2352
#define CDAUDIO_BYTES_PER_SECOND        176400
#define CDAUDIO_BYTES_PER_MINUTE        10584000
#define CDAUDIO_FRAMES_PER_SECOND       75
#define CDAUDIO_FRAMES_PER_MINUTE       4500
#define CDAUDIO_SECTOR_OFFSET           150

// from private\ntos\idex\idex.h:
#define IDE_ATAPI_RAW_CD_SECTOR_SIZE            2352
#define IDE_ATAPI_CD_SECTOR_SHIFT               11
*/


#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#endif //_DISKWRITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskWrite\gui.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    gui.cpp

Abstract:

    File System disk scanner.

Notes:

*****************************************************************************/
#include "diskWrite.h"

IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText	= NULL;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;

#define STICK_DEAD_ZONE         6400
#define BUTTON_PRESS_VALUE      100
#define BUTTON_SPEEP_VALUE      150         // in ms

#define COLUMN_1_OFFSET         25
#define COLUMN_2_OFFSET         165

void GUI(void)
    {
    bool exit = false;
    XINPUT_STATE state;

    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        for(unsigned port=0; port<XGetPortCount(); port++)
            {
            if(hDuke[port])
                {
                XInputGetState(hDuke[port], &state);
                if(state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) exit = true;
                }
            }

        UpdateGraphics(DISPLAYMODE_CONFIG_READONLY);

        Sleep(BUTTON_SPEEP_VALUE);
        }

    // sleep past any residual user input presses
    Sleep(BUTTON_SPEEP_VALUE);
    }

void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...)
    {
    char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, x, (line+1)*10, 0, color, 0);
    }



void UpdateGraphics(unsigned mode /*=DISPLAYMODE_RUN_TIME*/)
    {
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // run time status mode
    //
    if(mode == DISPLAYMODE_RUN_TIME || mode == DISPLAYMODE_PAUSE)
        {
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 1, 0xFF4444FF, "DISK WRITE (%s)", testNames[globalSettings.test]);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 2, 0xFF4444FF, "Model: %s", model);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 3, 0xFF4444FF, "Serial: %s", serial);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 4, 0xFF4444FF, "Firmware: %s", firmware);


        unsigned line = 6;
        if(globalSettings.test == TEST_READ_WRITE_READ)
            {
	        GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, 0xFF4444FF, " Cylinders: %u", globalSettings.gDiskGeometry.Cylinders.QuadPart);
	        GraphicPrint(pd3ds, COLUMN_2_OFFSET, 3, 0xFF4444FF, " Tracks/Cylinder: %u", globalSettings.gDiskGeometry.TracksPerCylinder);
	        GraphicPrint(pd3ds, COLUMN_2_OFFSET, 4, 0xFF4444FF, " Sectors/Track: %u", globalSettings.gDiskGeometry.SectorsPerTrack);
	        GraphicPrint(pd3ds, COLUMN_2_OFFSET, 5, 0xFF4444FF, " Bytes/Sector: %u", globalSettings.gDiskGeometry.BytesPerSector);

            GraphicPrint(pd3ds, COLUMN_1_OFFSET, line, 0xFFFFFFFF, "Blocks Written: %I64u", numBlocksWritten);

            if(globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && globalSettings.stopAfter.duration != 0)
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u of %u", numTimesThrough, globalSettings.stopAfter.duration);
            else
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u", numTimesThrough);

            GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Buffer Mismatches: %u", numBuffMismatch);
            GraphicPrint(pd3ds, COLUMN_2_OFFSET,   line, 0xFFFFFFFF, " Errors: %u", numErrors);
            }
        else if(globalSettings.test == TEST_CREATE_FILES)
            {
            if(globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && globalSettings.stopAfter.duration != 0)
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  line, 0xFFFFFFFF, "Files Created %u of %u", numTimesThrough, globalSettings.stopAfter.duration);
            else
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  line, 0xFFFFFFFF, "Files Created %u", numTimesThrough);
            GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Bytes Written %I64u", bytesWritten);

            GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Errors: %u", numFail);

            if(cleanup)
                {
                GraphicPrint(pd3ds, COLUMN_1_OFFSET,  line+2, 0xFFFFFFFF, "Exit Detected, cleaning up files...");
                }
            }
        else if(globalSettings.test == TEST_WRITE_FILE)
            {
            // TODO
            }

        GraphicPrint(pd3ds, COLUMN_2_OFFSET, 6, 0xFFFFFFFF, " Run Time: %u sec", (GetTickCount() - time)/1000);

        if(mode == DISPLAYMODE_RUN_TIME)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Press START to view the current settings");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press Left Trigger + Right Trigger + Black to reboot");
            }
        else if(mode == DISPLAYMODE_PAUSE)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFF00,  "PAUSED");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFF00,  "Press BACK to continue");
            }
        }

    //
    // config setup gui
    //
    else if(mode == DISPLAYMODE_CONFIG_READONLY)
        {
        /* TODO
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 1, 0xFF777777,  "Drive: %s", globalSettings.drive);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 2, 0xFF777777,  "Read Size: %u bytes", globalSettings.readSize);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 1, 0xFF777777,  " Number of Reads: %u", globalSettings.numberOfReads);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, 0xFF777777,  " Compare Buffers: %u", globalSettings.compareBuffers);
        */
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press BACK to continue");
        }

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    }



bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                {
                LogPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    // check for exit file
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile("T:\\testexit.txt", &FindFileData);
    FindClose(hFind);
    if(hFind != INVALID_HANDLE_VALUE)
        {
        LogPrint("\r\n\r\nFound Exit File (testexit.txt) - rebooting\r\n");
        return true;
        }

    return false;
    }


bool InputCheckButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE)
                {
                return true;
                }
            }
        }

    return false;
    }


bool InputCheckDigitalButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.wButtons & button)
                {
                return true;
                }
            }
        }

    return false;
    }


void Pause(void)
    {
    OutputDebugStringA("*****************************************************************************\n");
    OutputDebugStringA("* Entered Paused State. Hit the BACK button to resume...\n");
    OutputDebugStringA("*****************************************************************************\n");
    while(!InputCheckDigitalButton(XINPUT_GAMEPAD_BACK))
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        UpdateGraphics(DISPLAYMODE_PAUSE);

        Sleep(BUTTON_SPEEP_VALUE);
        }
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            //LogPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }


void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned i=0; i<XGetPortCount()*2; i++)
        {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[i]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[i]), XMUSlotFromDriveLetter((char)hSlot[i]));
            hSlot[i] = NULL;
            }
        if(add & USBSlotMasks[i])
            {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
                {
                hSlot[i] = (HANDLE)drive;
                //LogPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[i])+1, XMUSlotFromDriveLetter((char)hSlot[i])+1);
                }
            }
        }
    }


/*

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT InitGraphics(void)
    {
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskWrite\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskWrite\diskUtils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    diskUtils.cpp

Abstract:

    Functions that talk to the DVD / Hard drive

Notes:

*****************************************************************************/

#include "diskWrite.h"

/*
APIs in this file:

    void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
    DWORD GetDiskType(HANDLE hDevice);

*/

DWORD ReadHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    DWORD accessTime = GetTickCount();
    ++avgTimeCount;

    IO_STATUS_BLOCK ioStatusBlock;
    DWORD status;
    LARGE_INTEGER Offset;

    // Calculate Offset
    Offset.QuadPart = (unsigned __int64)block * (unsigned __int64)globalSettings.gDiskGeometry.BytesPerSector;

    // Read bytes at offset
    status = NtReadFile(hDevice, NULL, NULL, NULL, &ioStatusBlock, buffer, num * globalSettings.gDiskGeometry.BytesPerSector, &Offset);

    lastReadTime = GetTickCount()-accessTime;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        LogPrint("Block %u: Read took %ums\n", block, lastReadTime);

    return status;
    }

DWORD WriteHDBlocks(HANDLE hDevice, DWORD block, DWORD num, BYTE *buffer)
    {
    DWORD accessTime = GetTickCount();
    ++avgTimeCount;

    IO_STATUS_BLOCK ioStatusBlock;
    DWORD status;
    LARGE_INTEGER Offset;

    // Calculate Offset
    Offset.QuadPart = (unsigned __int64)block * (unsigned __int64)globalSettings.gDiskGeometry.BytesPerSector;

    // Read bytes at offset
    status = NtWriteFile(hDevice, NULL, NULL, NULL, &ioStatusBlock, buffer, num * globalSettings.gDiskGeometry.BytesPerSector, &Offset);

    lastReadTime = GetTickCount()-accessTime;
    avgTime += lastReadTime;
    if(lastReadTime > 1000)
        LogPrint("Block %u: Write took %ums\n", block, lastReadTime);

    return status;
    }


void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware)
    {
    unsigned i;
    DWORD returned;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;
    bool closeHandle = false;

    if(hDevice == NULL)
        {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        if(cdrom)
            RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        else
            RtlInitObjectString(&VolumeString, "\\Device\\Harddisk0\\Partition0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
        }

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(cdrom) atapt->IdeReg.bCommandReg = 0xA1;
    else atapt->IdeReg.bCommandReg = 0xEC;

    DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH, atapt, sizeof(ATA_PASS_THROUGH), atapt, sizeof(ATA_PASS_THROUGH), &returned, FALSE);
    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for(i=0; i<sizeof(IdData->ModelNumber); i+=2)
        {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
        }
    model[i] = 0;

    for(i=0; i<sizeof(IdData->SerialNumber); i+=2)
        {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
        }
    serial[i] = 0;

    for(i=0; i<sizeof(IdData->FirmwareRevision); i+=2)
        {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
        }
    firmware[i] = 0;

    if(closeHandle) NtClose(hDevice);
    }


DWORD GetDiskType(HANDLE hDevice)
    {
    DVD_READ_STRUCTURE readStruct;
    UCHAR readStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) + sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];

    bool closeHandle = false;

    if(hDevice == NULL)
        {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
        }

    memset(&readStruct, 0, sizeof(DVD_READ_STRUCTURE));
    memset(readStructureOutput, 0, sizeof(readStructureOutput));

    // try DVD Read Structure
    readStruct.Format = DvdPhysicalDescriptor;

    DWORD returned = 0;
    BOOL result = DeviceIoControl(hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(DVD_READ_STRUCTURE), readStructureOutput, sizeof(readStructureOutput), &returned, NULL);
    if(result)
        {
        if(closeHandle) NtClose(hDevice);
        DVD_LAYER_DESCRIPTOR *layerDescr = (DVD_LAYER_DESCRIPTOR *)(&readStructureOutput[sizeof(DVD_DESCRIPTOR_HEADER)]);
        BYTE layerType = (layerDescr->BookType) | (layerDescr->BookVersion << 4);
        if(layerDescr->LayerType == 1)
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RO;
            else return MEDIA_DVD_9_RO;
            }
        else
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RW;
            else return MEDIA_DVD_9_RW;
            }
        }

    // not a DVD disk...
    else
        {
	    CDROM_TOC toc;
        memset(&toc, 0, sizeof(CDROM_TOC));
		result = DeviceIoControl( hDevice, IOCTL_CDROM_READ_TOC, &toc, sizeof(CDROM_TOC), &toc, sizeof(CDROM_TOC), &returned, NULL);
        if(closeHandle) NtClose(hDevice);
        if(result)
            {
            if(toc.FirstTrack == toc.LastTrack) return MEDIA_CDROM;
            return MEDIA_CDDA;
            }
        else
            {
            return MEDIA_CDROM;
            }
        }

    return MEDIA_UNKNOWN;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\diskWrite\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    Helper functions

Notes:

*****************************************************************************/

#include "diskWrite.h"


extern "C"
    {
	NTSYSCALLAPI
	NTSTATUS
	NTAPI
	IoCreateSymbolicLink(
		IN POBJECT_STRING SymbolicLinkName,
		IN POBJECT_STRING DeviceName
		);

	NTSYSCALLAPI
	NTSTATUS
	NTAPI
	IoDeleteSymbolicLink(
		IN POBJECT_STRING SymbolicLinkName
		);
    }


DWORD MapDrive( char cDriveLetter, char* pszPartition )
    {
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );

    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );

    ANSI_STRING ostDrive, ostPath;

    RtlInitObjectString( &ostDrive, pszDrive );
    RtlInitObjectString( &ostPath, pszPartition );
    NTSTATUS status = IoCreateSymbolicLink( &ostDrive, &ostPath );

    return RtlNtStatusToDosError( status );
    }

DWORD UnMapDrive( char cDriveLetter )
    {
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );

    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );

    ANSI_STRING ostDrive;

    RtlInitObjectString( &ostDrive, pszDrive );
    NTSTATUS status = IoDeleteSymbolicLink(&ostDrive);

    return RtlNtStatusToDosError( status );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\choosesavemenu.h ===
/*****************************************************
*** choosesavemenu.h
***
*** Header file for our Choose Save Menu class.
*** This menu will enumerate the saved games for a
*** memory area and allow the user to choose which
*** Saved Game they wish to interact with
***
*** by James N. Helm
*** November 30th, 2001
***
*****************************************************/

#ifndef _CHOOSESAVEMENU_H_
#define _CHOOSESAVEMENU_H_

#include "menuscreen.h"

///////////////////////////////////
// CSaveGameInfo
///////////////////////////////////
class CSaveGameInfo
{
public:
    CSaveGameInfo( void );
    ~CSaveGameInfo( void );

    // Properties
    char* m_pszSaveDirectory;                           // Directory of the saved game
    WCHAR* m_pwszSaveName;                              // Name of the saved game

    // Methods
    char* GetSaveDirectory( void )                      // Set the name of the Saved Game
        { return m_pszSaveDirectory; };
    WCHAR* GetSaveName( void )                          // Set the name of the Saved Game
        { return m_pwszSaveName; };

    HRESULT SetSaveDirectory( char* pszSaveDirectory ); // Set the name of the Saved Game
    HRESULT SetSaveName( WCHAR* pwszSaveName );         // Set the name of the Saved Game

    // Operators
    virtual BOOL operator>( const CSaveGameInfo& item );
    virtual BOOL operator<( const CSaveGameInfo& item );
    virtual BOOL operator==( const CSaveGameInfo& item );
};


const WCHAR gc_pwszNO_CONFIGURATIONS_ON_MA[] =  L"There are no configurations on this Memory Area";
const float gc_fNO_CONFIGURATIONS_TEXT_YPOS =   125.0f;

///////////////////////////////////
// CChooseSaveMenu
///////////////////////////////////
class CChooseSaveMenu : public CMenuScreen
{
public:
    // Constructors and Destructor
    CChooseSaveMenu( void );
    ~CChooseSaveMenu( void );

    // Public Methods
    HRESULT Init( XFONT* pMenuItemFont,             // Initialize the Menu
                  XFONT* pMenuTitleFont );
    void HandleInput( enum BUTTONS buttonPressed,   // Handles input (of the BUTTONS) for the current menu
                      BOOL bFirstPress );
    void Enter( void );                             // This should be called whenever the menu is entered or activated

    BOOL GetCancelled( void )                       // Returns the status of the menu (was it cancelled or not)
        { return m_bCancelled; };
    HRESULT SetInfo( char* pszDrivePath );          // Set the drive path of the Memory Area the menu will work with

    WCHAR* GetCurrentSaveName( void );              // Get the name of the currently selected Saved Game (NULL if none)
    char* GetCurrentSaveDirectory( void );          // Get the directory of the currently selected Saved Game (NULL if none)

private:
    // Properties
    char*                           m_pszDrivePath;         // Used to determine which Memory Area we should look at
    BOOL                            m_bCancelled;           // Used to track if the user cancelled the save game selection
    CLinkedList< CSaveGameInfo* >   m_SaveGameInfoList;     // Information for the Saved Games that have been found

    // Methods
    void RenderMenuItems( CUDTexture* pTexture );   // Render the menu items properly on our menu
    void Leave( CXItem* pItem );                    // This should be called whenever you leave the menu
    void PopulateMenuItems( void );                 // This function will look for Saved Games and populate our menu
};

#endif // _CHOOSESAVEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\configitems.cpp ===
/*****************************************************
*** configitems.cpp
***
*** CPP file for our config item classes.
*** This file will contain the definition for all
*** types of config items
*** 
*** by James N. Helm
*** November 27th, 2001
*** 
*****************************************************/

#include "stdafx.h"
#include "configitems.h"

/*****************************************************
/* CConfigItem( void )
/****************************************************/
CConfigItem::CConfigItem( void ) :
m_pwszFieldName( NULL ),
m_pwszHelpText( NULL ),
m_pwszType( NULL ),
m_bProcessed( FALSE )
{
}


CConfigItem::~CConfigItem( void )
{
    if( NULL != m_pwszFieldName )
    {
        delete[] m_pwszFieldName;
        m_pwszFieldName = NULL;
    }

    if( NULL != m_pwszHelpText )
    {
        delete[] m_pwszHelpText;
        m_pwszHelpText = NULL;
    }

    if( NULL != m_pwszType )
    {
        delete[] m_pwszType;
        m_pwszType = NULL;
    }
}

// Copy constructor
CConfigItem::CConfigItem( const CConfigItem& ConfigItem )
{
    *this = ConfigItem;
}


// Assignment Operator
CConfigItem& CConfigItem::operator=( const CConfigItem& ConfigItem )
{
    if( &ConfigItem == this )
        return *this;

    SetFieldName( ConfigItem.GetFieldName() );
    SetHelpText( ConfigItem.GetHelpText() );
    SetType( ConfigItem.GetType() );

    return *this;
}


BOOL CConfigItem::operator>( const CConfigItem& item )
{
    if( _wcsicmp( m_pwszFieldName, item.m_pwszFieldName ) > 0 )
        return TRUE;

    return FALSE;
}

BOOL CConfigItem::operator<( const CConfigItem& item )
{
    if( _wcsicmp( m_pwszFieldName, item.m_pwszFieldName ) < 0 )
        return TRUE;

    return FALSE;
}

BOOL CConfigItem::operator==( const CConfigItem& item )
{
    if( _wcsicmp( m_pwszFieldName, item.m_pwszFieldName ) == 0 )
        return TRUE;

    return FALSE;
}


// Set the Field Name
HRESULT CConfigItem::SetFieldName( WCHAR* pwszName )
{
    if( NULL == pwszName )
    {
        DebugPrint( "CConfigItem::SetFieldName():Invalid argument passed in!!\n" );

        return E_INVALIDARG;
    }

    if( NULL != m_pwszFieldName )
    {
        delete[] m_pwszFieldName;
        m_pwszFieldName = NULL;
    }

    m_pwszFieldName = new WCHAR[wcslen( pwszName ) + 1];
    if( NULL == m_pwszFieldName )
    {
        DebugPrint( "CConfigItem::SetFieldName():Unable to allocate memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Copy the user passed in value in to our string
    wcscpy( m_pwszFieldName, pwszName );

    return S_OK;
}


// Set the Help Text
HRESULT CConfigItem::SetHelpText( WCHAR* pwszText )
{
    if( NULL == pwszText )
    {
        DebugPrint( "CConfigItem::SetHelpText():Invalid argument passed in!!\n" );

        return E_INVALIDARG;
    }

    if( NULL != m_pwszHelpText )
    {
        delete[] m_pwszHelpText;
        m_pwszHelpText = NULL;
    }

    m_pwszHelpText = new WCHAR[wcslen( pwszText ) + 1];
    if( NULL == m_pwszHelpText )
    {
        DebugPrint( "CConfigItem::SetHelpText():Unable to allocate memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Copy the user passed in value in to our string
    wcscpy( m_pwszHelpText, pwszText );

    return S_OK;
}


// Type of item
HRESULT CConfigItem::SetType( WCHAR* pwszType )
{
    if( NULL == pwszType )
    {
        DebugPrint( "CConfigItem::SetType():Invalid argument passed in!!\n" );

        return E_INVALIDARG;
    }

    if( NULL != m_pwszType )
    {
        delete[] m_pwszType;
        m_pwszType = NULL;
    }

    m_pwszType = new WCHAR[wcslen( pwszType ) + 1];
    if( NULL == m_pwszType )
    {
        DebugPrint( "CConfigItem::SetType():Unable to allocate memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Copy the user passed in value in to our string
    wcscpy( m_pwszType, pwszType );

    return S_OK;
}


/*****************************************************
/* CConfigNumber( void )
/****************************************************/

// Constructor
CConfigNumber::CConfigNumber( void ) :
m_lDefault( 0l ),
m_lMinimum( 0l ),
m_lMaximum( 0l )
{
}


// Copy constructor
CConfigNumber::CConfigNumber( const CConfigNumber& ConfigNumber )
{
    *this = ConfigNumber;
}


// Destructor
CConfigNumber::~CConfigNumber( void )
{
}


// Assignment Operator
CConfigNumber& CConfigNumber::operator=( const CConfigNumber& ConfigNumber )
{
    if( &ConfigNumber == this )
        return *this;

    // Call the base class assignment operator
    *((CConfigItem*)this) = ConfigNumber;

    SetMinimum( ConfigNumber.GetMinimum() );
    SetMaximum( ConfigNumber.GetMaximum() );
    SetDefault( ConfigNumber.GetDefault() );

    return *this;
}


// Process a value that was passed to the item
HRESULT CConfigNumber::ProcessValue( char* pszValue )
{
    long lValue = m_lDefault;
    if( sscanf( pszValue, "%ld", &lValue ) != 1 )
    {
        DebugPrint( "CConfigNumber::ProcessValue():Failed to process the value!!\n" );

        return E_FAIL;
    }

    SetDefault( lValue );
    SetProcessed( TRUE );

    return S_OK;
}


// Set the Default value
void CConfigNumber::SetDefault( long lDefault )
{
    if( ( lDefault < GetMinimum() ) || ( lDefault > GetMaximum() ) )
    {
        DebugPrint( "CConfigNumber::SetDefault():Number was out of range!! Num - '%ld', Min - '%ld', Max - '%d'\n",
                            lDefault,
                            GetMinimum(),
                            GetMaximum() );

        return;
    }

    m_lDefault = lDefault;
};


// Allow the user to update all values at once
void CConfigNumber::UpdateItem( WCHAR* pwszName, WCHAR* pwszHelpText, WCHAR* pwszType, long lDefault, long lMinimum, long lMaximum )
{
    // Error checking will be done by the functions called below

    SetFieldName( pwszName );
    SetHelpText( pwszHelpText );
    SetType( pwszType );
    SetMinimum( lMinimum );
    SetMaximum( lMaximum );
    SetDefault( lDefault );
}


/*****************************************************
/* CConfigRange( void )
/****************************************************/

// Constructor
CConfigRange::CConfigRange( void ) :
m_lDefault1( 0l ),
m_lMinimum1( 0l ),
m_lMaximum1( 0l ),
m_lDefault2( 0l ),
m_lMinimum2( 0l ),
m_lMaximum2( 0l )
{
}


// Copy constructor
CConfigRange::CConfigRange( const CConfigRange& CConfigRange )
{
    *this = CConfigRange;
}


// Assignment Operator
CConfigRange& CConfigRange::operator=( const CConfigRange& ConfigRange )
{
    if( &ConfigRange == this )
        return *this;

    // Call the base class assignment operator
    *((CConfigItem*)this) = ConfigRange;

    SetMinimum1( ConfigRange.m_lMinimum1 );
    SetMaximum1( ConfigRange.m_lMaximum1 );
    SetDefault1( ConfigRange.m_lDefault1 );
    SetMinimum2( ConfigRange.m_lMinimum2 );
    SetMaximum2( ConfigRange.m_lMaximum2 );
    SetDefault2( ConfigRange.m_lDefault2 );
    
    return *this;
}


// Destructor
CConfigRange::~CConfigRange( void )
{
}


// Process a value that was passed to the item
HRESULT CConfigRange::ProcessValue( char* pszValue )
{
    long lDef1, lDef2;
    if( sscanf( pszValue, "%ld-%ld", &lDef1, &lDef2 ) != 2 )
    {
        DebugPrint( "CConfigRange::ProcessValue():Failed to process the value!!\n" );

        return E_FAIL;
    }

    SetDefault1( lDef1 );
    SetDefault2( lDef2 );
    SetProcessed( TRUE );
    
    return S_OK;
}


// Set the Default 1st value
void CConfigRange::SetDefault1( long lDefault )
{
    if( ( lDefault < GetMinimum1() ) || ( lDefault > GetMaximum1() ) )
    {
        DebugPrint( "CConfigRange::SetDefault1():Number was out of range!! Num - '%ld', Min - '%ld', Max - '%d'\n",
                            lDefault,
                            GetMinimum1(),
                            GetMaximum1() );

        return;
    }

    m_lDefault1 = lDefault;
};


// Set the Default 2nd value
void CConfigRange::SetDefault2( long lDefault )
{
    if( ( lDefault < GetMinimum2() ) || ( lDefault > GetMaximum2() ) )
    {
        DebugPrint( "CConfigRange::SetDefault2():Number was out of range!! Num - '%ld', Min - '%ld', Max - '%d'\n",
                            lDefault,
                            GetMinimum2(),
                            GetMaximum2() );

        return;
    }

    m_lDefault2 = lDefault;
};


// Allow the user to update all values at once
void CConfigRange::UpdateItem( WCHAR* pwszName, WCHAR* pwszHelpText, WCHAR* pwszType, long lDefault1, long lMinimum1, long lMaximum1, long lDefault2, long lMinimum2, long lMaximum2 )
{
    // Error checking will be done by the functions called below

    SetFieldName( pwszName );
    SetHelpText( pwszHelpText );
    SetType( pwszType );
    SetMinimum1( lMinimum1 );
    SetMaximum1( lMaximum1 );
    SetDefault1( lDefault1 );
    SetMinimum2( lMinimum2 );
    SetMaximum2( lMaximum2 );
    SetDefault2( lDefault2 );
}


/*****************************************************
/* CConfigString( void )
/****************************************************/
// Constructor
CConfigString::CConfigString( void )
{
    // Make sure, if we empty our list, that we delete our data item
    // to prevent a memory leak
    m_StringList.SetDeleteDataItem( TRUE );
}

// Destructor
CConfigString::~CConfigString( void )
{
    m_StringList.EmptyList();
}


// Copy constructor
CConfigString::CConfigString( const CConfigString& ConfigString )
{
    *this = ConfigString;
}


// Assignment Operator
CConfigString& CConfigString::operator=( const CConfigString& ConfigString )
{
    if( &ConfigString == this )
        return *this;

    // Call the base class assignment operator
    *((CConfigItem*)this) = ConfigString;

    for( unsigned int x = 0; x < ConfigString.GetNumStrings(); x++ )
        AddString( ConfigString.GetString( x ) );

    SetCurrentString( ConfigString.GetCurrentStringIndex() );

    return *this;
}


// Process a value that was passed to the item
HRESULT CConfigString::ProcessValue( char* pszValue )
{
    // Convert our value to a WCHAR string for comparison
    WCHAR* pwszNewValue = new WCHAR[strlen( pszValue ) + 1];
    if( NULL == pwszNewValue )
    {
        DebugPrint( "CConfigString::ProcessValue(): Unable to allocate memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Convert our string
    swprintf( pwszNewValue, L"%hs", pszValue );

    // Check to see if the string we read exists in our list
    BOOL bStringFound = FALSE;

    MoveFirstString();
    do
    {
        if( 0 == _wcsicmp( pwszNewValue, GetCurrentString() ) )
        {
            bStringFound = TRUE;

            break;
        }
    } while( MoveNextString() );

    // Clean up our memory
    delete[] pwszNewValue;
    pwszNewValue = NULL;

    if( !bStringFound )
    {
        DebugPrint( "CConfigString::ProcessValue():Did not find the string in our list!! - '%hs'\n", pszValue );

        MoveFirstString();

        return E_FAIL;
    }

    SetProcessed( TRUE );

    return S_OK;
}


// Add a string item to our list
HRESULT CConfigString::AddString( WCHAR* pwszString )
{
    if( NULL == pwszString )
    {
        DebugPrint( "CConfigString::AddString():Invalid arguments passed in!!\n" );

        return E_INVALIDARG;
    }

    WCHAR* pwszNewString = new WCHAR[wcslen( pwszString ) + 1];
    if( NULL == pwszNewString )
    {
        DebugPrint( "CConfigString::AddString():Unable to allocate memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Copy the user string to our new memory and store the pointer
    wcscpy( pwszNewString, pwszString );
    
    m_StringList.AddNode( pwszNewString );

    return S_OK;
}


// Update the informational part of the item
void CConfigString::UpdateItem( WCHAR* pwszName, WCHAR* pwszHelpText, WCHAR* pwszType )
{
    SetFieldName( pwszName );
    SetHelpText( pwszHelpText );
    SetType( pwszType );
}

// Move to the first string in the list
BOOL CConfigString::MoveFirstString( void )
{
    return m_StringList.MoveFirst();
};


// Move to the last string in the list
BOOL CConfigString::MoveLastString( void )
{
    return m_StringList.MoveLast();
}

// Move to the next string in the list
BOOL CConfigString::MoveNextString( void )
{ 
    return m_StringList.MoveNext();
}

// Move to the previous string in the list
BOOL CConfigString::MovePrevString( void )
{ 
    return m_StringList.MovePrev();
}


/*****************************************************
/* CConfigString2( void )
/****************************************************/
// Constructor
CConfigString2::CConfigString2( void ) :
m_pwszString( NULL )
{
}

// Destructor
CConfigString2::~CConfigString2( void )
{
    if( NULL != m_pwszString )
    {
        delete[] m_pwszString;
        m_pwszString = NULL;
    }
}

// Copy constructor
CConfigString2::CConfigString2( const CConfigString2& ConfigString2 )
{
    *this = ConfigString2;
}


// Assignment Operator
CConfigString2& CConfigString2::operator=( const CConfigString2& ConfigString2 )
{
    if( &ConfigString2 == this )
        return *this;

    // Call the base class assignment operator
    *((CConfigItem*)this) = ConfigString2;

    if( NULL != m_pwszString )
    {
        delete[] m_pwszString;
        m_pwszString = NULL;
    }

    SetString( ConfigString2.GetString() );

    return *this;
}


// Process a value that was passed to the item
HRESULT CConfigString2::ProcessValue( char* pszValue )
{
    if( NULL == pszValue )
    {
        SetString( L"" );
        
        return S_OK;
    }

    // Convert our value to a WCHAR string for comparison
    WCHAR* pwszNewValue = new WCHAR[strlen( pszValue ) + 1];
    if( NULL == pwszNewValue )
    {
        DebugPrint( "CConfigString::ProcessValue(): Unable to allocate memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Convert our string
    swprintf( pwszNewValue, L"%hs", pszValue );

    HRESULT hr = SetString( pwszNewValue );

    // Clean up our memory
    delete[] pwszNewValue;
    pwszNewValue = NULL;

    SetProcessed( TRUE );

    return hr;
}


// Add a string item to our list
HRESULT CConfigString2::SetString( WCHAR* pwszString )
{
    if( NULL == pwszString )
    {
        DebugPrint( "CConfigString2::AddString():Invalid arguments passed in!!\n" );

        return E_INVALIDARG;
    }

    // Free our memory
    if( NULL != m_pwszString )
    {
        delete[] m_pwszString;
        m_pwszString = NULL;
    }

    m_pwszString = new WCHAR[wcslen( pwszString ) + 1];
    if( NULL == m_pwszString )
    {
        DebugPrint( "CConfigString2::AddString():Unable to allocate memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Copy the user string to our new memory and store the pointer
    wcscpy( m_pwszString, pwszString );
    
    return S_OK;
}


// Update the informational part of the item
void CConfigString2::UpdateItem( WCHAR* pwszName, WCHAR* pwszHelpText, WCHAR* pwszType, WCHAR* pwszString )
{
    SetFieldName( pwszName );
    SetHelpText( pwszHelpText );
    SetType( pwszType );
    SetString( pwszString );
}


/*****************************************************
/* CConfigNumberString( void )
/****************************************************/
// Constructor
CConfigNumberString::CConfigNumberString( void ) :
m_lDefault( 0l ),
m_lMinimum( 0l ),
m_lMaximum( 0l )
{
    // Make sure, if we empty our list, that we delete our data item
    // to prevent a memory leak
    m_StringList.SetDeleteDataItem( TRUE );
}

// Destructor
CConfigNumberString::~CConfigNumberString( void )
{
    m_StringList.EmptyList();
}


// Copy constructor
CConfigNumberString::CConfigNumberString( const CConfigNumberString& ConfigNumberString )
{
    *this = ConfigNumberString;
}


// Assignment Operator
CConfigNumberString& CConfigNumberString::operator=( const CConfigNumberString& ConfigNumberString )
{
    if( &ConfigNumberString == this )
        return *this;

    // Call the base class assignment operator
    *((CConfigItem*)this) = ConfigNumberString;

    SetMinimum( ConfigNumberString.GetMinimum() );
    SetMaximum( ConfigNumberString.GetMaximum() );
    SetDefault( ConfigNumberString.GetDefault() );

    // Store all the string in the liked list
    for( unsigned int x = 0; x < ConfigNumberString.GetNumStrings(); x++ )
        AddString( ConfigNumberString.GetString( x ) );

    SetCurrentString( ConfigNumberString.GetCurrentStringIndex() );

    return *this;
}


// Set the Default value
void CConfigNumberString::SetDefault( long lDefault )
{
    if( ( lDefault < GetMinimum() ) || ( lDefault > GetMaximum() ) )
    {
        DebugPrint( "CConfigNumberString::SetDefault():Number was out of range!! Num - '%ld', Min - '%ld', Max - '%d'\n",
                            lDefault,
                            GetMinimum(),
                            GetMaximum() );

        return;
    }

    m_lDefault = lDefault;
};


// Process a value that was passed to the item
HRESULT CConfigNumberString::ProcessValue( char* pszValue )
{
    long lNumValue = 0l;
    WCHAR pwszStrValue[MAX_PATH+1];
    pwszStrValue[MAX_PATH] = L'\0';

    if( sscanf( pszValue, "%ld %ls", &lNumValue, pwszStrValue ) != 2 )
    {
        DebugPrint( "CConfigNumberString::ProcessValue():Failed to process the value!!\n" );

        return E_FAIL;
    }

    ///////////////////////////////////////
    // Set our string portion of the value
    ///////////////////////////////////////
    // Check to see if the string we read exists in our list
    BOOL bStringFound = FALSE;

    MoveFirstString();
    do
    {
        if( 0 == _wcsicmp( pwszStrValue, GetCurrentString() ) )
        {
            bStringFound = TRUE;

            break;
        }
    } while( MoveNextString() );

    if( !bStringFound )
    {
        DebugPrint( "CConfigNumberString::ProcessValue():Did not find the string in our list!! - '%ls'\n", pwszStrValue );

        MoveFirstString();

        return E_FAIL;
    }

    ///////////////////////////////////////
    // Set our number portion of the value
    ///////////////////////////////////////
    SetDefault( lNumValue );
    
    SetProcessed( TRUE );

    return S_OK;
}


// Add a string item to our list
HRESULT CConfigNumberString::AddString( WCHAR* pwszString )
{
    if( NULL == pwszString )
    {
        DebugPrint( "CConfigNumberString::AddString():Invalid arguments passed in!!\n" );

        return E_INVALIDARG;
    }

    WCHAR* pwszNewString = new WCHAR[wcslen( pwszString ) + 1];
    if( NULL == pwszNewString )
    {
        DebugPrint( "CConfigNumberString::AddString():Unable to allocate memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Copy the user string to our new memory and store the pointer
    wcscpy( pwszNewString, pwszString );
    
    m_StringList.AddNode( pwszNewString );

    return S_OK;
}


// Update the informational part of the item
void CConfigNumberString::UpdateItem( WCHAR* pwszName,
                                      WCHAR* pwszHelpText,
                                      WCHAR* pwszType,
                                      long lDefault,
                                      long lMinimum,
                                      long lMaximum )
{
    SetFieldName( pwszName );
    SetHelpText( pwszHelpText );
    SetType( pwszType );
    SetMinimum( lMinimum ); // Set the Minimum value
    SetMaximum( lMaximum ); // Set the Maximum value
    SetDefault( lDefault ); // Set the Default value
}

// Move to the first string in the list
BOOL CConfigNumberString::MoveFirstString( void )
{
    return m_StringList.MoveFirst();
};


// Move to the last string in the list
BOOL CConfigNumberString::MoveLastString( void )
{
    return m_StringList.MoveLast();
}

// Move to the next string in the list
BOOL CConfigNumberString::MoveNextString( void )
{ 
    return m_StringList.MoveNext();
}

// Move to the previous string in the list
BOOL CConfigNumberString::MovePrevString( void )
{ 
    return m_StringList.MovePrev();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\choosesavemenu.cpp ===
/*****************************************************
*** choosesavemenu.cpp
***
*** CPP file for our Choose Save Menu class.
*** This menu will enumerate the saved games for a
*** memory area and allow the user to choose which
*** Saved Game they wish to interact with
***
*** by James N. Helm
*** November 30th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "choosesavemenu.h"

///////////////////////////////////
// CSaveGameInfo
///////////////////////////////////

CSaveGameInfo::CSaveGameInfo( void ) :
m_pszSaveDirectory( NULL ),
m_pwszSaveName( NULL )
{
}

CSaveGameInfo::~CSaveGameInfo( void )
{
    if( NULL != m_pszSaveDirectory )
    {
        delete[] m_pszSaveDirectory;
        m_pszSaveDirectory = NULL;
    }

    if( NULL != m_pwszSaveName )
    {
        delete[] m_pwszSaveName;
        m_pwszSaveName = NULL;
    }
}

BOOL CSaveGameInfo::operator>( const CSaveGameInfo& item )
{
    if( _wcsicmp( m_pwszSaveName, item.m_pwszSaveName ) > 0 )
        return TRUE;

    return FALSE;
}

BOOL CSaveGameInfo::operator<( const CSaveGameInfo& item )
{
    if( _wcsicmp( m_pwszSaveName, item.m_pwszSaveName ) < 0 )
        return TRUE;

    return FALSE;
}

BOOL CSaveGameInfo::operator==( const CSaveGameInfo& item )
{
    if( _wcsicmp( m_pwszSaveName, item.m_pwszSaveName ) == 0 )
        return TRUE;

    return FALSE;
}

// Set the name of the Saved Game
HRESULT CSaveGameInfo::SetSaveDirectory( char* pszSaveDirectory )
{
    if( NULL == pszSaveDirectory )
    {
        DebugPrint( "CSaveGameInfo::SetSaveDirectory():Invalid arguments passed in!!\n" );

        return E_INVALIDARG;
    }

    if( NULL != m_pszSaveDirectory )
    {
        delete[] m_pszSaveDirectory;
        m_pszSaveDirectory = NULL;
    }

    m_pszSaveDirectory = new char[strlen(pszSaveDirectory)+1];
    if( NULL == m_pszSaveDirectory )
    {
        DebugPrint( "CSaveGameInfo::SetSaveDirectory():Unable to allocate memory!!\n" );
        
        return E_OUTOFMEMORY;
    }

    strcpy( m_pszSaveDirectory, pszSaveDirectory );

    return S_OK;
}


// Set the name of the Saved Game
HRESULT CSaveGameInfo::SetSaveName( WCHAR* pwszSaveName )
{
    if( NULL == pwszSaveName )
    {
        DebugPrint( "CSaveGameInfo::SetSaveName():Invalid arguments passed in!!\n" );

        return E_INVALIDARG;
    }

    if( NULL != m_pwszSaveName )
    {
        delete[] m_pwszSaveName;
        m_pwszSaveName = NULL;
    }

    m_pwszSaveName = new WCHAR[wcslen(pwszSaveName)+1];
    if( NULL == m_pwszSaveName )
    {
        DebugPrint( "CSaveGameInfo::SetSaveName():Unable to allocate memory!!\n" );
        
        return E_OUTOFMEMORY;
    }

    wcscpy( m_pwszSaveName, pwszSaveName );

    return S_OK;
}


///////////////////////////////////
// CChooseSaveMenu
///////////////////////////////////

// Constructors and Destructor
CChooseSaveMenu::CChooseSaveMenu( void ) :
m_pszDrivePath( NULL ),
m_bCancelled( FALSE )
{
    // Make sure we don't have a memory leak when deleting the data items
    m_SaveGameInfoList.SetSortedList( TRUE );
    m_SaveGameInfoList.SetDeleteDataItem( TRUE );
}

CChooseSaveMenu::~CChooseSaveMenu( void )
{
    if( NULL != m_pszDrivePath )
    {
        delete[] m_pszDrivePath;
        m_pszDrivePath = NULL;
    }
}

// Initialize the Menu
HRESULT CChooseSaveMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CChooseSaveMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Choose a Configuration" );

    // Add screen items here
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status bar column 1
    AddTextItem( GetButtonFont(), L"A",              gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Select",        gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"B",              gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Back / Cancel", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    // Status Bar Column 2
    AddTextItem( GetButtonFont(), L"C",              gc_fSTATUS_TEXT_COL2_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_X_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Delete Config", gc_fSTATUS_TEXT_COL2_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    return hr;
}

// Render the menu items properly on our menu
void CChooseSaveMenu::RenderMenuItems( CUDTexture* pTexture )
{
    if( 0 == GetNumMenuItems() )
    {
        // Show Message;
        float fXPos = gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), gc_pwszNO_CONFIGURATIONS_ON_MA ) / 2 );
        float fYPos = gc_fNO_CONFIGURATIONS_TEXT_YPOS;

        pTexture->DrawText( GetBodyFont(), fXPos, fYPos, m_dwMenuItemEnabledFGColor, m_dwMenuItemEnabledBGColor, L"%ls", gc_pwszNO_CONFIGURATIONS_ON_MA );
    }
    else
    {
        CMenuScreen::RenderMenuItems( pTexture );
    }
}


// Set the drive path of the Memory Area the menu will work with
HRESULT CChooseSaveMenu::SetInfo( char* pszDrivePath )
{
    if( NULL == pszDrivePath )
    {
        DebugPrint( "CChooseSaveMenu::SetInfo():Invalid argument passed in!!\n" );

        return E_INVALIDARG;
    }

    if( NULL != m_pszDrivePath )
    {
        delete[] m_pszDrivePath;
        m_pszDrivePath = NULL;
    }

    m_pszDrivePath = new char[strlen( pszDrivePath ) + 1];
    strcpy( m_pszDrivePath, pszDrivePath );

    return S_OK;
}


// Handles input (of the BUTTONS) for the current menu
void CChooseSaveMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            GoBack();

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            GoBack();

            break;
        }
    case BUTTON_X:
        {
            ////////////////////////////
            // Delete the Configuration
            ////////////////////////////
            
            // Check to see if there are any saves
            if( 0 == GetNumMenuItems() )
                break;

            UpdateTexture();

            DWORD dwResult = XDeleteSaveGame( m_pszDrivePath, GetCurrentSaveName() );
            if( ERROR_SUCCESS != dwResult )
                DebugPrint( "CChooseSaveMenu::HandleInput():Failed to delete the Saved Game!!\n" );
            else
                PopulateMenuItems();

            break;
        }
    }
}


// Get the name of the currently selected Saved Game (NULL if none)
WCHAR* CChooseSaveMenu::GetCurrentSaveName( void )
{
    if( 0 == GetNumMenuItems() )
        return NULL;

    return m_SaveGameInfoList[GetSelectedItem()]->GetSaveName();
}


// Get the directory of the currently selected Saved Game (NULL if none)
char* CChooseSaveMenu::GetCurrentSaveDirectory( void )
{
    if( 0 == GetNumMenuItems() )
        return NULL;

    return m_SaveGameInfoList[GetSelectedItem()]->GetSaveDirectory();
}


// This should be called whenever the menu is entered or activated
void CChooseSaveMenu::Enter( void )
{
    // Call the base class Enter
    CMenuScreen::Enter();

    m_bCancelled = FALSE;

    // Check to see if the user set the Drive Path
    if( NULL == m_pszDrivePath )
    {
        DebugPrint( "CChooseSaveMenu::Enter():Drive Path not set!! Call SetInfo()\n" );
        GoBack();
        
        return;
    }

    // Add menu items here
    PopulateMenuItems();
}

// This function will look for Saved Games and populate our menu
void CChooseSaveMenu::PopulateMenuItems( void )
{
    // Clear out our old menu items
    ClearMenuItems();
    m_SaveGameInfoList.EmptyList();

    // Add menu items here
    XGAME_FIND_DATA xgFindData;
    ZeroMemory( &xgFindData, sizeof( xgFindData ) );

    HANDLE hTestSaves = XFindFirstSaveGame( m_pszDrivePath, &xgFindData );
    if( INVALID_HANDLE_VALUE == hTestSaves )
        DebugPrint( "CChooseSaveMenu::PopulateMenuItems():Failed to find a saved game!!\n" );
    else
    {
        do
        {
            // Update our Save Game Info List
            CSaveGameInfo* pSaveGameInfo = new CSaveGameInfo;
            if( NULL == pSaveGameInfo )
            {
                DebugPrint( "CChooseSaveMenu::PopulateMenuItems():Failed to allocate memory!!\n" );

                GoBack();

                // Close our handle
                XFindClose( hTestSaves );
                hTestSaves = INVALID_HANDLE_VALUE;

                return;
            }
            pSaveGameInfo->SetSaveName( xgFindData.szSaveGameName );
            pSaveGameInfo->SetSaveDirectory( xgFindData.szSaveGameDirectory );
            m_SaveGameInfoList.AddNode( pSaveGameInfo );
        } while( XFindNextSaveGame( hTestSaves, &xgFindData ) );

        // Close our handle
        XFindClose( hTestSaves );
        hTestSaves = INVALID_HANDLE_VALUE;

        // Add our menu items (since our list is sorted, we have to do this second
        m_SaveGameInfoList.MoveFirst();
        for( unsigned int x = 0; x < m_SaveGameInfoList.GetNumItems(); x++ )
        {
            AddMenuItem( GetBodyFont(), m_SaveGameInfoList.GetCurrentNode()->GetSaveName(), FALSE, TRUE, x );
            m_SaveGameInfoList.MoveNext();
        }
    }
}

// This should be called whenever you leave the menu
void CChooseSaveMenu::Leave( CXItem* pItem )
{
    // Clear out our Drive Path
    if( NULL != m_pszDrivePath )
    {
        delete[] m_pszDrivePath;
        m_pszDrivePath = NULL;
    }

    CMenuScreen::Leave( pItem );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\configitems.h ===
/*****************************************************
*** configitems.h
***
*** Header file for our config item classes.
*** This file will contain the definition for all
*** types of config items
*** 
*** by James N. Helm
*** November 27th, 2001
*** 
*****************************************************/

#ifndef _CONFIGITEMS_H_
#define _CONFIGITEMS_H_

/*****************************************************
/* CConfigItem( void )
/****************************************************/
class CConfigItem
{
public:
    CConfigItem( void );
    CConfigItem( const CConfigItem& CConfigItem );
    virtual ~CConfigItem( void );
    
    // Operators
    virtual CConfigItem& operator=( const CConfigItem& CConfigItem );

    // Methods
    virtual HRESULT SetFieldName( WCHAR* pwszName );                                // Set the Field Name
    virtual HRESULT SetHelpText( WCHAR* pwszText );                                 // Set the Help Text
    virtual HRESULT SetType( WCHAR* pwszType );                                     // Type of item
    virtual void SetProcessed( BOOL bProcessed ) { m_bProcessed = bProcessed; };    // Should be set after an item is processed

    virtual BOOL GetProcessed( void ) { return m_bProcessed; };                     // Should be set after an item is processed
    virtual WCHAR* GetFieldName( void ) const { return m_pwszFieldName; };          // Get the Field Name
    virtual WCHAR* GetHelpText( void ) const { return m_pwszHelpText; };            // Get the Help Text
    virtual WCHAR* GetType( void ) const { return m_pwszType; };                    // Get the Type

    virtual HRESULT ProcessValue( char* pszValue ) = 0;                             // Process a value that was passed to the item

    // Operators
    virtual BOOL operator>( const CConfigItem& item );
    virtual BOOL operator<( const CConfigItem& item );
    virtual BOOL operator==( const CConfigItem& item );

protected:
    // Properties
    WCHAR* m_pwszFieldName;     // Name of the field we are dealing with
    WCHAR* m_pwszHelpText;      // Help text for the field we are dealing with
    WCHAR* m_pwszType;          // Type of item stored (string, number, etc)
    BOOL m_bProcessed;          // Determines if the item was processed
};


/*****************************************************
/* CConfigNumber( void )
/****************************************************/
class CConfigNumber : public CConfigItem
{
public:
    // Constructors and Destructors
    CConfigNumber( void );
    CConfigNumber( const CConfigNumber& ConfigNumber );
    ~CConfigNumber( void );
    
    // Operators
    CConfigNumber& operator=( const CConfigNumber& ConfigNumber );

    // Methods
    HRESULT ProcessValue( char* pszValue );     // Process a value that was passed to the item

    void SetDefault( long lDefault );                               // Set the Default value
    void SetMinimum( long lMinimum ) { m_lMinimum = lMinimum; };    // Set the Minimum value
    void SetMaximum( long lMaximum ) { m_lMaximum = lMaximum; };    // Set the Maximum value

    long GetDefault( void ) const { return m_lDefault; };           // Get the Default value
    long GetMinimum( void ) const { return m_lMinimum; };           // Get the Minimum value
    long GetMaximum( void ) const { return m_lMaximum; };           // Get the Maximum value

    void UpdateItem( WCHAR* pwszName,                               // Allow the user to update all values at once
                     WCHAR* pwszHelpText,
                     WCHAR* pwszType,
                     long lDefault,
                     long lMinimum,
                     long lMaximum );

private:
    long m_lDefault;    // Default Value
    long m_lMinimum;    // Minimum Value
    long m_lMaximum;    // Maximum Value
};


/*****************************************************
/* CConfigRange( void )
/****************************************************/
class CConfigRange : public CConfigItem
{
public:
    // Constructors and Destructors
    CConfigRange( void );
    CConfigRange( const CConfigRange& CConfigRange );
    ~CConfigRange( void );
    
    // Operators
    CConfigRange& operator=( const CConfigRange& CConfigRange );

    // Methods
    HRESULT ProcessValue( char* pszValue );     // Process a value that was passed to the item

    void SetDefault1( long lDefault );                              // Set the Default 1st value
    void SetMinimum1( long lMinimum ) { m_lMinimum1 = lMinimum; };  // Set the Minimum 1st value
    void SetMaximum1( long lMaximum ) { m_lMaximum1 = lMaximum; };  // Set the Maximum 1st value
    void SetDefault2( long lDefault );                              // Set the Default 2nd value
    void SetMinimum2( long lMinimum ) { m_lMinimum2 = lMinimum; };  // Set the Minimum 2nd value
    void SetMaximum2( long lMaximum ) { m_lMaximum2 = lMaximum; };  // Set the Maximum 2nd value

    long GetDefault1( void ) { return m_lDefault1; };               // Get the Default 1st value
    long GetMinimum1( void ) { return m_lMinimum1; };               // Get the Minimum 1st value
    long GetMaximum1( void ) { return m_lMaximum1; };               // Get the Maximum 1st value
    long GetDefault2( void ) { return m_lDefault2; };               // Get the Default 2nd value
    long GetMinimum2( void ) { return m_lMinimum2; };               // Get the Minimum 2nd value
    long GetMaximum2( void ) { return m_lMaximum2; };               // Get the Maximum 2nd value

    void UpdateItem( WCHAR* pwszName,                               // Allow the user to update all values at once
                     WCHAR* pwszHelpText,
                     WCHAR* pwszType,
                     long lDefault1,
                     long lMinimum1,
                     long lMaximum1, 
                     long lDefault2,
                     long lMinimum2,
                     long lMaximum2 );

private:
    long m_lDefault1;   // Default 1st Value
    long m_lMinimum1;   // Minimum 1st Value
    long m_lMaximum1;   // Maximum 1st Value
    long m_lDefault2;   // Default 2nd Value
    long m_lMinimum2;   // Minimum 2nd Value
    long m_lMaximum2;   // Maximum 2nd Value
};


/*****************************************************
/* CConfigString( void )
/****************************************************/
class CConfigString : public CConfigItem
{
public:
    // Constructors and Destructors
    CConfigString( void );
    CConfigString( const CConfigString& ConfigString );
    ~CConfigString( void );
    
    // Operators
    CConfigString& operator=( const CConfigString& ConfigString );

    // Methods
    HRESULT ProcessValue( char* pszValue );             // Process a value that was passed to the item
                                                        
    HRESULT AddString( WCHAR* pwszString );             // Add a string item to our list
                                                        
    WCHAR* GetString( unsigned int uiIndex ) const      // Return the pointer to the string at the specified index
        { return m_StringList[uiIndex]; };              
                                                        
    WCHAR* GetCurrentString( void ) const               // Return the pointer to the string currently being pointed at
        { return m_StringList.GetCurrentNode(); };      
                                                        
    BOOL MoveFirstString( void );                       // Move to the first string in the list
    BOOL MoveLastString( void );                        // Move to the last string in the list
    BOOL MoveNextString( void );                        // Move to the next string in the list
    BOOL MovePrevString( void );                        // Move to the previous string in the list
                                                        
    void SetCurrentString( unsigned int uiIndex )       // Set the current string via index
        { m_StringList.MoveTo( uiIndex ); };            
                                                        
    unsigned int GetCurrentStringIndex( void ) const    // Get the index of the current string
        { return m_StringList.GetCurrentIndex(); };     
                                                        
    unsigned int GetNumStrings( void ) const            // Get the number of strings in our config item
        { return m_StringList.GetNumItems(); };

    void UpdateItem( WCHAR* pwszName,                   // Update the informational part of the item
                     WCHAR* pwszHelpText,
                     WCHAR* pwszType );

private:
    // BUGBUG: This linked list class uses "delete", not "delete[]" to clear the data items.
    // BUGBUG: Since we are creating a WCHAR* (new []), this is a bug!!
    CLinkedList< WCHAR* > m_StringList;  // String list -- 1st item is default
};


/*****************************************************
/* CConfigString2( void )
/****************************************************/
class CConfigString2 : public CConfigItem
{
public:
    // Constructors and Destructors
    CConfigString2( void );
    CConfigString2( const CConfigString2& ConfigString2 );
    ~CConfigString2( void );
    
    // Operators
    CConfigString2& operator=( const CConfigString2& ConfigString2 );

    // Methods
    HRESULT ProcessValue( char* pszValue );             // Process a value that was passed to the item

    HRESULT SetString( WCHAR* pwszString );             // Set the string value
    WCHAR* GetString( void ) const                      // Return the pointer to the string
        { return m_pwszString; };

    void UpdateItem( WCHAR* pwszName,                   // Update the informational part of the item
                     WCHAR* pwszHelpText,
                     WCHAR* pwszType,
                     WCHAR* pwszString );

private:
    WCHAR* m_pwszString;                                // Value of our current item
};


/*****************************************************
/* CConfigNumberString( void )
/****************************************************/
class CConfigNumberString : public CConfigItem
{
public:
    // Constructors and Destructors
    CConfigNumberString( void );
    CConfigNumberString( const CConfigNumberString& ConfigNumberString );
    ~CConfigNumberString( void );
    
    // Operators
    CConfigNumberString& operator=( const CConfigNumberString& ConfigNumberString );

    // Methods
    HRESULT ProcessValue( char* pszValue );                         // Process a value that was passed to the item

    void SetDefault( long lDefault );                               // Set the Default value
    void SetMinimum( long lMinimum ) { m_lMinimum = lMinimum; };    // Set the Minimum value
    void SetMaximum( long lMaximum ) { m_lMaximum = lMaximum; };    // Set the Maximum value

    long GetDefault( void ) const { return m_lDefault; };           // Get the Default value
    long GetMinimum( void ) const { return m_lMinimum; };           // Get the Minimum value
    long GetMaximum( void ) const { return m_lMaximum; };           // Get the Maximum value

    HRESULT AddString( WCHAR* pwszString );                         // Add a string item to our list
    
    WCHAR* GetString( unsigned int uiIndex ) const                  // Return the pointer to the string at the specified index
        { return m_StringList[uiIndex]; };
    
    WCHAR* GetCurrentString( void ) const                           // Return the pointer to the string currently being pointed at
        { return m_StringList.GetCurrentNode(); };
    
BOOL MoveFirstString( void );                                       // Move to the first string in the list
BOOL MoveLastString( void );                                        // Move to the last string in the list
BOOL MoveNextString( void );                                        // Move to the next string in the list
BOOL MovePrevString( void );                                        // Move to the previous string in the list

    void SetCurrentString( unsigned int uiIndex )                   // Set the current string via index
        { m_StringList.MoveTo( uiIndex ); };

    unsigned int GetCurrentStringIndex( void ) const                // Get the index of the current string
        { return m_StringList.GetCurrentIndex(); };

    unsigned int GetNumStrings( void ) const                        // Get the number of strings in our config item
        { return m_StringList.GetNumItems(); };

    void UpdateItem( WCHAR* pwszName,                               // Allow the user to update all values, except the string value, at once
                     WCHAR* pwszHelpText,
                     WCHAR* pwszType,
                     long lDefault,
                     long lMinimum,
                     long lMaximum );

private:
    long m_lDefault;    // Default Value
    long m_lMinimum;    // Minimum Value
    long m_lMaximum;    // Maximum Value

    // BUGBUG: This linked list class uses "delete", not "delete[]" to clear the data items.
    // BUGBUG: Since we are creating a WCHAR* (new []), this is a bug!!
    CLinkedList< WCHAR* > m_StringList;  // String list -- 1st item is default
};

#endif // _CONFIGITEMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\flashutils.cpp ===
/*****************************************************
*** flashutils.cpp
***
*** CPP file for our Flash utilities library
*** These functions will allow the kernel of the
*** Xbox to be Flashed.
***
*** by James N. Helm
*** January 21st, 2002
***
*****************************************************/

#include "stdafx.h"
#include "flashutils.h"

//
// Mapped virtual address of ROM region
//

PVOID KernelRomBase;

SIZE_T FlashSizeMap[] = {
    0,
    512 * 1024,     // SST 49LF040 Firmware Hub
    1024 * 1024     // Generic 29F080
};

FlashStatus
FlashGetStatus(
    IN FlashDeviceID ID,
    IN ULONG_PTR Address OPTIONAL,
    IN BYTE Data
    )
/*++

Routine Description:

    This routine checks status of flash chip using data# polling method.
    The data# polling bit, DQ7, indicates whether the Embeded Algorithm
    is in progress or completed.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    Address - Physical address of flash ROM to be checked

    Data - Expected data at specified address

Return Value:

    Status of flash chip, see the definition of FlashStatus above.

--*/
{
    UCHAR retry=1, d, t;

    if ( !ARGUMENT_PRESENT(Address) ) {
        Address = FlashBaseAddress( ID );
    }

    if ( ID == FlashSST49LF040 ) {

        //
        // SST doesn't support Exceeded Timing Limits, DQ5
        //

        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;
        } else {
            return FlashStatusBusy;
        }

    } else {

again:
        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;        // data matches
        } else if ( d & 0x20 ) {            // Timeout?
            d = FlashReadByte(Address) & 0x80;
            if ( t == d ) {
                return FlashStatusReady;    // data matches
            }
            if ( retry-- ) {
                goto again;                 // may have been write completion
            }
            return FlashStatusTimeout;
        }

        if ( retry-- ) {
            goto again;                     // may have been write completion
        } else {
            return FlashStatusError;
        }
    }
}


VOID
FlashResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine resets flash ROM back to read mode if device is in ID command
    mode or during a program or erase operation

Arguments:

    None

Return Value:

    None

--*/
{
    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0xF0 );
    KeStallExecutionProcessor( 150000 );
}


FlashDeviceID
FlashDetectDevice(
    VOID
    )
/*++

Routine Description:

    This routine detects the device and manufacturer id of flash device on
    the system.  The device on Xbus will be detected first and if no device
    detected, LPC bus will be next.

Arguments:

    None

Return Value:

    Type of flash id installed in the system or FlashUnknownDevice

--*/
{
    BYTE byte;
    BYTE id1=0, id2=0;
    BOOL FirstTime = TRUE;
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;

detect:

    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0x90 );

    KeStallExecutionProcessor( 1 );

    id1 = FlashReadByte( 0xFFFF0000 );
    id2 = FlashReadByte( 0xFFFF0001 );

    FlashResetDevice();

    if ( id1 == SST_ID && id2 == SST_49LF040 ) {
        return FlashSST49LF040;
    }

    if ( (id1 == AMD_ID || id1 == HYUNDAI_ID || id1 == FUJITSU_ID) && \
         id2 == GENERIC_29F080 ) {
        return FlashGeneric29F080;
    }

    if ( id1 == ST_ID && id2 == M29F080A ) {
        return FlashGeneric29F080;
    }

    if ( FirstTime == TRUE ) {

        //
        // We are here because we couldn't find any flash ROM on Xbus.
        // Next thing is to see if this is a EVT board and enable ROM
        // write bus cycle to LPC interface.  By default the write cycle
        // to ROM will drop.
        //

        FirstTime = FALSE;

        //
        // Looking for PCI-to-LPC bridge
        //

        for ( byte=0x00; byte<=0xff; byte++ ) {
            PCISlotNumber.u.AsULONG = byte;
            HalReadPCISpace( 0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration) );
            if ( Configuration.BaseClass == 6 && Configuration.SubClass == 1 ) {
                break;
            }
        }

        //
        // If it is Nvidia PCI-to-LPC bridge, enable LPC ROM write
        //

        if ( Configuration.VendorID == 0x10DE && Configuration.DeviceID == 0x01B2 ) {
            byte = 0x01;
            HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
            goto detect;
        }

    } else {

        //
        // If we still couldn't find any flash ROM on LPC bus, disable LPC
        // ROM write
        //

        byte = 0x00;
        HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
    }

    return FlashUnknownDevice;
}


BOOL
FlashEraseChip(
    FlashDeviceID ID
    )
/*++

Routine Description:

    This routine erase the content of entire flash ROM to 0xFF.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    ULONG_PTR FlashPtr;
    BOOL fBlank = FALSE;
    SIZE_T Count, Retries=5;

    while ( Retries-- ) {

        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x80 );
        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x10 );

        FlashPtr = ~0L;

        //
        // Wait until flash chip is ready and completely erased.
        //

        Count = 0x100000;
        while ( FlashGetStatus(ID, FlashPtr, 0xFF) != FlashStatusReady && Count ) {
            Count--;
        }

        //
        // For some reasons in the FIB DVT, even the flash status is
        // ready but the actual data is not written to the chip.
        // We just have to poll the actual data and spin for a while
        // if it didn't get through.
        //

        Count = 0x100000;
        while ( FlashReadByte(FlashPtr) != 0xFF && Count ) {
            KeStallExecutionProcessor( 150000 );
            Count--;
        }

        //
        // Perform a blank check by compare all the content with 0xFF
        //

        Count = FlashSize( ID );
        FlashResetDevice();
        FlashPtr = FlashBaseAddress( ID );

        ASSERTMSG( "Size of flash ROM must be power of two", (Count & (Count-1)) == 0 );

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != 0xFFFF ) {
                DbgPrint( "FLASH: blank check failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fBlank = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fBlank;
}


BOOL
FlashProgramImage(
    IN FlashDeviceID ID,
    IN PVOID ImageBuffer
    )
/*++

Routine Description:

    This routine programs the content of flash ROM with new image.  The flash
    ROM has to be blank first before programming.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    ImageBuffer - Buffer contains the content to be programmed

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    BYTE b;
    PBYTE pb;
    PWORD pw;
    ULONG TimeOut;
    ULONG_PTR FlashPtr;
    BYTE TrueData, CurrData;
    BOOL Loop, fSuccess = FALSE;
    SIZE_T Count, Retries = 5;
    SIZE_T Again;

    while ( Retries-- ) {

        Count = FlashSize( ID );
        pb = (PBYTE)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );

        while ( Count-- ) {

            b = *pb++;

            if ( b != 0xFF ) {
                FlashWriteByte( 0xFFFF5555, 0xAA );
                FlashWriteByte( 0xFFFF2AAA, 0x55 );
                FlashWriteByte( 0xFFFF5555, 0xA0 );
                FlashWriteByte( FlashPtr, b );

                //
                // Wait until flash chip is ready for next command
                //

                Again = 0x100000;
                while ( FlashGetStatus(ID, FlashPtr, b) != FlashStatusReady && Again ) {
                    Again--;
                }

                //
                // For some reasons in the FIB DVT, even the flash status is
                // ready but the actual data is not written to the chip.
                // We just have to poll the actual data and spin for a while
                // if it didn't get through.
                //

                Again = 0x100000;
                while ( FlashReadByte(FlashPtr) != b && Again ) {
                    Again--;
                }
            }

            FlashPtr++;
        }

        //
        // Verify the content that just has been programmed
        //

        Count = FlashSize( ID );
        pw = (PWORD)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );
        FlashResetDevice();

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != *pw++ ) {
                DbgPrint( "FLASH: verification failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fSuccess = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fSuccess;
}


UINT64
FASTCALL
FlashReadMSR(
    IN ULONG Address
    )
/*++

Routine Description:

    This routine reads Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

Return Value:

    64-bit value of specified MSR

--*/
{
    __asm {
        rdmsr
    }
}

VOID
FASTCALL
FlashWriteMSR(
    IN ULONG Address,
    IN UINT64 Value
    )
/*++

Routine Description:

    This routine writes Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

    Value - 64-bit value to be written

Return Value:

    None

--*/
{
    __asm {
        mov     eax, DWORD PTR [Value]
        mov     edx, DWORD PTR [Value+4]
        wrmsr
    }
}


VOID
FlashChangeRomCaching(
    BOOL EnableCache
    )
/*++

Routine Description:

    This routine searches for ROM cache setting in MTRR and disable it.  It is
    necessary to disable and flash cache before changing MTRR.  The following
    steps are recommended by Intel in order to change MTRR settings. Save CR4,
    disable and flush processor cache, flush TLB, disable MTRR, change MTRR
    settings, flush cache and TLB, enable MTRR and restore CR4

Arguments:

    EnableCache - TRUE to enable caching, FALSE to disable

Return Value:

    None

--*/
{
    ULONG MTRR;
    UINT64 v, MTRRdeftype;
    ULONG Base, Type;


    __asm {
        push    ecx
        push    edx

        _emit   0fh                 ; mov  eax, cr4
        _emit   20h
        _emit   0e0h

        push    eax                 ; save content of cr4

        mov     eax, cr0            ; disable and flush cache
        push    eax                 ; save content of cr0
        or      eax, 060000000H
        mov     cr0, eax
        wbinvd

        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Save the content of MTRR deftype and disable MTRR
    //

    MTRRdeftype = FlashReadMSR( 0x2FF );
    FlashWriteMSR( 0x2FF, 0 );

    for ( MTRR=0x200; MTRR<0x20F; MTRR+=2 ) {
        v = FlashReadMSR( MTRR );
        Base = (ULONG)((v >> 12) & 0xFFFFFF);
        Type = (BYTE)v;

        //
        // Set or reset valid bit according to cache enable flag
        //

        if ( Base >= (FLASH_BASE_ADDRESS >> 12) && Type != 0 ) {
            v = FlashReadMSR( MTRR+1 );
            v = EnableCache ? (v | 0x800) : (v & (~0x800));
            FlashWriteMSR( MTRR+1, v );
        }
    }

    __asm {
        wbinvd                      ; flush cache
        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Restore content of MTRR deftype, MTRR should be re-enabled
    //

    FlashWriteMSR( 0x2FF, MTRRdeftype );

    __asm {
        pop     eax                 ; restore cr0
        mov     cr0, eax

        pop     eax                 ; restore cr4

        _emit   0fh                 ; mov  cr4, eax
        _emit   22h
        _emit   0e0h

        pop     edx
        pop     ecx
    }
}


HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    )
{
#ifdef FLASH_TIME
    UINT64 ClockTick;
#endif

    FlashDeviceID ID;
    HRESULT hr = S_OK;

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC();
#endif

    if ( IsBadReadPtr(ImageBuffer, ImageSize) || \
         IsBadWritePtr(szResp, cchResp) ) {
        return HRESULT_FROM_WIN32( ERROR_NOACCESS );
    }

    //
    // Map top 1MB of physical memory of ROM region (FFF00000-FFFFFFFF)
    //

    KernelRomBase = MmMapIoSpace( FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                  PAGE_READWRITE | PAGE_NOCACHE );

    if ( !KernelRomBase ) {
        _snprintf( szResp, cchResp, "unable to map i/o space" );
        return E_FAIL;
    }

    __asm cli

    DebugPrint( "HVS -- FLASH: interrupts are now disabled\n" );

    //
    // Disable ROM caching
    //

    FlashChangeRomCaching( FALSE );

    ID = FlashDetectDevice();

    if ( ID == FlashUnknownDevice ) {
        _snprintf( szResp, cchResp, "Unknown flash device id" );
        hr = E_FAIL;
        goto cleanup;
    }

    if ( FlashSize(ID) != ImageSize ) {
        _snprintf( szResp, cchResp, "Invalid image size" );
        hr = E_FAIL;
        goto cleanup;
    }

    DebugPrint( "HVS -- FLASH: erasing and blank checking...\n" );

    if ( !FlashEraseChip(ID) ) {
        _snprintf( szResp, cchResp, "Failed to erase flash chip" );
        hr = E_FAIL;
        goto cleanup;
    }

    DebugPrint( "HVS -- FLASH: programming...\n" );

    if ( !FlashProgramImage(ID, ImageBuffer) ) {
        _snprintf( szResp, cchResp, "Failed to program kernel image (verify failed)" );
        hr = E_FAIL;
        goto cleanup;
    }

    DebugPrint( "HVS -- FLASH: done\n" );

    if ( SUCCEEDED(hr) ) {
        _snprintf( szResp, cchResp, "Done, new image flashed" );
    }

    hr = S_OK;

cleanup:

    __asm sti

    DebugPrint( "HVS -- FLASH: interrupts are now enabled\n" );

    MmUnmapIoSpace( KernelRomBase, FLASH_REGION_SIZE );

    //
    // Re-enable ROM caching as needed
    //

    FlashChangeRomCaching( TRUE );

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC() - ClockTick;
    DbgPrint( "FLASH: elapsed time %I64u seconds\n", ClockTick / 733000000UI64 );
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\helpmenu.cpp ===
/*****************************************************
*** helpmenu.cpp
***
*** Header file for our Help Menu class.
*** This menu will display help for whatever menu
*** specifies it
***
*** by James N. Helm
*** December 18th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "helpmenu.h"

// Constructors and Destructor
CHelpMenu::CHelpMenu( void )
{
}

CHelpMenu::~CHelpMenu( void )
{
}


// Initialize the Menu
HRESULT CHelpMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CHelpMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Help Menu" );

    // Add screen items here
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status Bar Column 1
    AddTextItem( GetButtonFont(), L"B",     gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Back", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    return hr;
}


// Render the menu items properly on our menu
void CHelpMenu::RenderMenuItems( CUDTexture* pTexture )
{
    // Don't render anything if we don't have any menu items
    if( 0 == GetNumMenuItems() )
        return;

    m_MenuItems.MoveTo( GetTopItemIndex() );    // Start at menu item that needs to be displayed
    for( unsigned int x = GetTopItemIndex(); x <= GetBottomItemIndex(); x++ )
    {
        // Determine where on the screen the menu item should be
        float fXPos = m_fLeftMenuAreaBoundary + m_fLeftMenuAreaBorder;
        float fYPos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * ( x - GetTopItemIndex() ) );

        // Distinguish between enabled and disabled items
        DWORD dwFGColor, dwBGColor;
        if( m_MenuItems.GetCurrentNode()->m_bEnabled )
        {
            // Check to see if it's highlighted
            if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
            {
                dwFGColor = m_dwMenuItemHighlightedFGColor;
                dwBGColor = m_dwMenuItemHighlightedBGColor;
            }
            else
            {
                dwFGColor = m_dwMenuItemEnabledFGColor;
                dwBGColor = m_dwMenuItemEnabledBGColor;
            }
        }
        else
        {
            dwFGColor = m_dwMenuItemDisabledFGColor;
            dwBGColor = m_dwMenuItemDisabledBGColor;
        }

        // Check to see if the value is a main value, or an indented info item
        if( 0 != wcsncmp( m_MenuItems.GetCurrentNode()->m_pwszItemName, L"*-*", 3 ) )
        {
            // Draw the item text to the screen (left justified)
            pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwFGColor, dwBGColor, L"%ls", m_MenuItems.GetCurrentNode()->m_pwszItemName );
        }
        else
        {
            pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, gc_dwCOLOR_TEXT_YELLOW, dwBGColor, L"     %ls", m_MenuItems.GetCurrentNode()->m_pwszItemName + 3 );
        }

        m_MenuItems.MoveNext();
    }
}


// Handle any requests for the joystick (thumb-pad)
void CHelpMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_RIGHT:
        {
            // Y
            if( nThumbY < 0 )  // Move the right joystick down
            {
                // Process the default button delay
                if( !HandleInputDelay( bFirstYPress ) )
                    return;

                // Only act if we have any items on our screen
                if( GetNumMenuItems() > 0 )
                {
                    UpdateTexture();

                    // Check to see if the menu wouldn't fill the screen
                    int iNewTopIndex = GetTopItemIndex() + GetNumMenuItemsToDisplay();

                    if( ( iNewTopIndex + GetNumMenuItemsToDisplay() ) > GetNumMenuItems() )
                    {
                        iNewTopIndex = GetNumMenuItems() - GetNumMenuItemsToDisplay();

                        if( iNewTopIndex < 0 )
                            iNewTopIndex = 0;

                        SetTopItemIndex( iNewTopIndex );
                    }
                    else
                    {
                        SetTopItemIndex( iNewTopIndex );
                    }
                }
                break;
            }
            else if( nThumbY > 0 ) // Move right joystick up
            {
                // Process the default button delay
                if( !HandleInputDelay( bFirstYPress ) )
                    return;

                // Only act if we have any items on our screen
                if( GetNumMenuItems() > 0 )
                {
                    if( GetTopItemIndex() > 0 )
                    {
                        UpdateTexture();

                        int iNewTopIndex = GetTopItemIndex() - GetNumMenuItemsToDisplay();
                        if( iNewTopIndex < 0 )
                            iNewTopIndex = 0;

                        SetTopItemIndex( iNewTopIndex );
                    }
                }
                break;
            }

            // X
            if( nThumbX < 0 )       // Move the right joystick left
            {
                CMenuScreen::HandleInput( joystick, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
            }
            else if( nThumbX > 0 )  // Move the right joystick right
            {
                CMenuScreen::HandleInput( joystick, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
            }
            break;
        }
    default:
        {
            CMenuScreen::HandleInput( joystick, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
            break;
        }
    }
}


// Handles input (of the BUTTONS) for the current menu
void CHelpMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_B:
        {
            GoBack();

            break;
        }
    }
}


// Handle control input for a single list menu
void CHelpMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() > 0 )
            {
                if( GetTopItemIndex() > 0 )
                {
                    UpdateTexture();

                    SetTopItemIndex( GetTopItemIndex() - 1 );
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() > 0 )
            {
                UpdateTexture();

                // Check to see if the menu wouldn't fill the screen
                int iNewTopIndex = GetTopItemIndex() + 1;

                if( ( iNewTopIndex + GetNumMenuItemsToDisplay() ) > GetNumMenuItems() )
                {
                    iNewTopIndex = GetNumMenuItems() - GetNumMenuItemsToDisplay();

                    if( iNewTopIndex < 0 )
                        iNewTopIndex = 0;

                    SetTopItemIndex( iNewTopIndex );
                }
                else
                {
                    SetTopItemIndex( iNewTopIndex );
                }
            }
            break;
        }
	}
}



// Add a help item to our menu class
void CHelpMenu::AddHelpItem( XFONT* pItemFont, WCHAR* pwszHelpItem, XFONT* pValueFont, WCHAR* pwszHelpValue )
{
    if( NULL == pItemFont || NULL == pwszHelpItem || NULL == pValueFont || NULL == pwszHelpValue )
    {
        DebugPrint( "CHelpMenu::AddHelpItem():Invalid argument(s) passed in!!\n" );

        return;
    }

    // DebugPrint( "Main Item - %ls\n", pwszHelpItem );

    // Add the item to our menu
    AddMenuItem( pItemFont, pwszHelpItem, FALSE, TRUE, 0 );

    // Parse the Help Value and determine if there should be wrapping, etc
    WCHAR pwszTempBuffer[1024];
    pwszTempBuffer[1023] = L'\0';

    // Don't add a 'value' if the user didn't pass one in
    if( 0 == wcslen( pwszHelpValue ) )
        return;

    WCHAR* pwszParser2 = wcsstr( pwszHelpValue, L"\\n" );
    if( NULL == pwszParser2 )
    {
        // Copy the indent character in to our temp variable
        wcscpy( pwszTempBuffer, L"*-*" );
        wcsncat( pwszTempBuffer, pwszHelpValue, 1021 );
        // DebugPrint( "Value (no parse) - %ls\n", pwszTempBuffer );
        AddMenuItem( pValueFont, pwszTempBuffer, FALSE, TRUE, 0 );
    }
    else
    {
        WCHAR* pwszParser = pwszHelpValue;
        do
        {
            // Copy the indent character in to our temp variable
            wcscpy( pwszTempBuffer, L"*-*" );

            // Append the first string to our temp variable
            unsigned int uiCatAmount = pwszParser2 - pwszParser;
            if( uiCatAmount > 1021 )
                uiCatAmount = 1021;
            wcsncat( pwszTempBuffer, pwszParser, uiCatAmount );

            // DebugPrint( "Value1 (parse) - %ls\n", pwszTempBuffer );

            // Add the menu item to our List
            AddMenuItem( pValueFont, pwszTempBuffer, FALSE, TRUE, 0 );

            // Update our string pointer to point at the beginning of our new string
            pwszParser = pwszParser2 + 2;

            // Find the next \n (if any) in our string
            pwszParser2 = wcsstr( pwszParser, L"\\n" );
        } while( NULL != pwszParser2 );

        // Check to see if there is a string left to add
        if( L'\0' != pwszParser )
        {
            // Copy the indent character in to our temp variable
            wcscpy( pwszTempBuffer, L"*-*" );

            // Append the first string to our temp variable
            wcsncat( pwszTempBuffer, pwszParser, 1021 );

            // DebugPrint( "Value2 (parse) - %ls\n", pwszTempBuffer );

            // Add the menu item to our List
            AddMenuItem( pValueFont, pwszTempBuffer, FALSE, TRUE, 0 );
        }
    }
}


// Clear all the help items from our screen
void CHelpMenu::ClearHelpItems( void )
{
    ClearMenuItems();
}


// This should be called whenever the menu is entered or activated
void CHelpMenu::Enter( void )
{
    CMenuScreen::Enter();

    SetTopItemIndex( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\flashutils.h ===
/*****************************************************
*** flashutils.h
***
*** Header file for our Flash utilities library
*** These functions will allow the kernel of the
*** Xbox to be Flashed.
***
*** by James N. Helm
*** January 21st, 2002
***
*****************************************************/

#ifndef _FLASHUTILS_H_
#define _FLASHUTILS_H_

#include <mm.h>
#include <pci.h>

//
// Manufacturer and chip identifiers
//

#define SST_ID                  0xBF
#define SST_49LF040             0x53

#define AMD_ID                  0x01
#define FUJITSU_ID              0x04
#define HYUNDAI_ID              0xAD
#define GENERIC_29F080          0xD5

#define ST_ID                   0x20
#define M29F080A                0xF1


typedef enum {
    FlashUnknownDevice = 0,
    FlashSST49LF040,
    FlashGeneric29F080
} FlashDeviceID;

typedef enum {
    FlashStatusReady,
    FlashStatusBusy,
    FlashStatusEraseSuspended,
    FlashStatusTimeout,
    FlashStatusError
} FlashStatus;

// SIZE_T
// FlashSize(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro returns size of flash ROM specified by device identifier id
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Size of flash ROM for specified device
//
// --

#define FlashSize( ID )         FlashSizeMap[(ID)]

// ULONG_PTR
// FlashBaseAddress(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro calculates the base address of flash ROM specified by ID,
//     based on the size of the chip
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Base address of flash ROM from top 4GB
//
// --

#define FlashBaseAddress( ID )  ((ULONG_PTR)(0xFFFFFFFF-FlashSize(ID)+1))

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)


////////////
// Macros
////////////

// BYTE
// FlashReadByte(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads one byte from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     A read byte from specified address
//
// --

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteByte(
//     IN ULONG_PTR Physical,
//     IN BYTE Byte
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes one byte to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Byte - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteByte(a, d) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

// WORD
// FlashReadWord(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads two bytes from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     Two byte from specified address
//
// --

#define FlashReadWord(a) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))


////////////
// Functions
////////////
FlashStatus FlashGetStatus( IN FlashDeviceID ID,       // This routine checks status of flash chip using data# polling method.
                            IN ULONG_PTR Address OPTIONAL,
                            IN BYTE Data );
VOID FlashResetDevice( VOID );                          // This routine resets flash ROM back to read mode if device is in ID
                                                        //   command mode or during a program or erase operation
FlashDeviceID FlashDetectDevice( VOID );                // Detects the device and manufacturer id of flash device on the system
BOOL FlashEraseChip( FlashDeviceID ID );                // This routine erase the content of entire flash ROM to 0xFF.
BOOL FlashProgramImage( IN FlashDeviceID ID,            // This routine programs the content of flash ROM with new image.
                        IN PVOID ImageBuffer );
UINT64 FASTCALL FlashReadMSR( IN ULONG Address );       // Reads Pentium III Model-Specific Register (MSR) specified by Address
VOID FASTCALL FlashWriteMSR( IN ULONG Address,          // Writes Pentium III Model-Specific Register (MSR) specified by Address
                             IN UINT64 Value );
VOID FlashChangeRomCaching( BOOL EnableCache );         // Adjusts caching to support ROM flashing
HRESULT FlashKernelImage( IN  PVOID  ImageBuffer,       // Flash the kernel image to the Xbox
                          IN  SIZE_T ImageSize,
                          OUT LPSTR  szResp,
                          IN  DWORD  cchResp );


#endif // _FLASHUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\helpmenu.h ===
/*****************************************************
*** helpmenu.h
***
*** Header file for our Help Menu class.
*** This menu will display help for whatever menu
*** specifies it
***
*** by James N. Helm
*** December 18th, 2001
***
*****************************************************/

#ifndef _HELPMENU_H_
#define _HELPMENU_H_

#include "menuscreen.h"

class CHelpMenu : public CMenuScreen
{
public:
    // Constructors and Destructor
    CHelpMenu( void );
    ~CHelpMenu( void );

    // Public Methods
    void RenderMenuItems( CUDTexture* pTexture );                   // Render the menu items properly on our menu
    void RenderSelector( CUDTexture* pTexture ) {};                 // Render the selector for our menu
    void Enter( void );                                             // This should be called whenever the menu is entered or activated
    HRESULT Init( XFONT* pMenuItemFont,                             // Initialize the Menu
                  XFONT* pMenuTitleFont );
    void HandleInput( enum JOYSTICK joystick,                       // Handle any requests for the joystick (thumb-pad)
                      int nThumbY,
                      int nThumbX,
                      BOOL bFirstYPress,
                      BOOL bFirstXPress );
    void HandleInput( enum BUTTONS buttonPressed,                   // Handles input (of the BUTTONS) for the current menu
                      BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed,                 // Handles input (of the CONTROLS) for the current menu
                      BOOL bFirstPress );
    void AddHelpItem( XFONT* pItemFont,                             // Add a help item to our menu class
                      WCHAR* pwszHelpItem,
                      XFONT* pValueFont,
                      WCHAR* pwszHelpValue );

    void ClearHelpItems( void );                                    // Clear all the help items from our screen
protected:
private:
};

#endif // _HELPMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\key.cpp ===
#include "stdafx.h"
#include "key.h"

// Key Class by Victor Blanco
CKey::CKey( void )
:
m_iXOrigin( 0 ),
m_iYOrigin( 0 ),
m_iWidth( 0 ),
m_iHeight( 0 ),		
m_dwSelectColor( 0x00000000 ),
m_fRender( TRUE ),
m_pwszResultChar( NULL )
{
}

CKey::~CKey( void )
{
    if( m_pwszResultChar )
    {
        delete[] m_pwszResultChar;
        m_pwszResultChar = NULL;
    }
}

void CKey::define( int iX, int iY, int iW, int iH, DWORD dwColor )
{
	m_iXOrigin = iX;
	m_iYOrigin = iY;
	m_iWidth = iW;
	m_iHeight = iH;		
	m_dwSelectColor = dwColor;	
}

void CKey::defineText( WCHAR* pwszResult )
{
    if( !pwszResult )
    {
        return;
    }

    // Make sure we don't cause a memory leak
    if( m_pwszResultChar )
    {
        delete[] m_pwszResultChar;
        m_pwszResultChar = NULL;
    }

    m_pwszResultChar = _wcsdup( pwszResult );
}

void CKey::setRender( BOOL fValue )
{
	m_fRender = fValue;
}

BOOL CKey::getRender( void )
{
	return m_fRender;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\hvslFunctions.h ===
#ifndef _HVSLFUNCTIONS_H_
#define _HVSLFUNCTIONS_H_

#include <xfont.h>
#include "xitem.h"
#include "helpmenu.h"
#include "messagemenu.h"
#include "keypadmenu.h"
#include "keyboardmenu.h"
#include "choosesavemenu.h"
#include "memareaselectmenu.h"
#include "yesnomenu.h"
#include "memoryunit.h"
#include "xbeinfo.h"

const unsigned int g_cuiFILE_LINE_SIZE =        4096;       // Size of the buffer to read info from our file
const unsigned int g_cuiCONFIG_ITEM_SIZE =      1024;       // Size of out standard Config Item size

// Memory Unit BitMasks used for detection
static const DWORD gc_dwMUBitMask[] = { XDEVICE_PORT0_TOP_MASK,
                                        XDEVICE_PORT0_BOTTOM_MASK,
                                        XDEVICE_PORT1_TOP_MASK,
                                        XDEVICE_PORT1_BOTTOM_MASK,
                                        XDEVICE_PORT2_TOP_MASK,
                                        XDEVICE_PORT2_BOTTOM_MASK,
                                        XDEVICE_PORT3_TOP_MASK,
                                        XDEVICE_PORT3_BOTTOM_MASK };

void InitializeMenus( void );                           // Initialize our Menus
CHelpMenu* GetHelpMenuPtr( void );                      // Return a pointer to the Help Menu
CKeypadMenu* GetKeypadPtr( void );                      // Return a pointer to the Virtual Keypad
CKeyboardMenu* GetKeyboardPtr( void );                  // Return a pointer to the Virtual Keyboard
CChooseSaveMenu* GetChooseSavePtr( void );              // Return a pointer to the Choose Saved Game Menu
CMemAreaSelectMenu* GetMemAreaSelectPtr( void );        // Return a pointer to the Memory Area Select Menu
CMessageMenu* GetMessagePtr( void );                    // Return a pointer to the Message Menu
CYesNoMenu* GetYesNoPtr( void );                        // Return a pointer to the YES / NO Menu
                                                        
/////////                                               
// Fonts                                                
/////////                                               
void InitializeFonts( void );                           // Initialize our fonts
void CleanupFonts( void );                              // Close and clean up our fonts
XFONT* GetHeaderFont( void );                           // Return a pointer to our Header Font
XFONT* GetBodyFont( void );                             // Return a pointer to our Body Font
XFONT* GetButtonFont( void );                           // Return a pointer to our Button Font

/////////                                               
// Menus                                                
/////////             
CXItem* GetCurrentMenu( void );                         // Return a pointer to the current menu
void SetCurrentMenu( CXItem* pMenuPtr );                // Set the current Menu
CXItem* GetPreviousMenu( void );                        // Return a pointer to the previous Menu
void SetPreviousMenu( CXItem* pMenuPtr );               // Set the previous Menu
                                                        
////////////////////////                                
// Memory Units / Areas                                 
////////////////////////                                
void InitializeMUs( void );                             // Initialize our MUs and mount any that need mounting
BOOL GetMUsChanged( void );                             // Can be used to determine if there have been any changes to our Memory Units
void ProcessMUs( void );                                // Check to see if an MU has been inserted or removed, and properly Mounts, or Dismounts the MUs
CMemoryUnit* GetMUPtr( unsigned int uiIndex );          // Get a pointer to a memory unit based on index

////////////////////////////
// Configuration management
////////////////////////////
HRESULT LoadXBEConfigs( CXBEInfo* pXBEInfo,             // Load an XBE configuration from a file .DAT file
                        const char* pszLoadPath );      
                                                        
HRESULT SaveXBEConfigs( CXBEInfo* pXBEInfo,             // Save the current XBE configuration to a .DAT file
                        const char* pszSavePath );

/////////
// Other
/////////                                           
BOOL DeleteDirectory( const char* pszPath );            // Delete a directory and all files within
BOOL FileExists( const char* pszFileName );             // Will return TRUE if a file exists, otherise FALSE
long ThumbStickScale( int iStickValue,                  // Will return a scaled number
                      long lMinValue,
                      long lMaxValue );
HRESULT ProcessConfigFile( CXBEInfo* pXBEInfo );        // Process a configuration file for a specific XBE
CXBEInfo* GetLauncherXBEInfo( void );                   // Return a pointer to our HVS Launcher XBE Info object
void InitLauncherXBEInfo( void );                       // Initialize the HVS Launcher Config if one exists

#endif // _HVSLFUNCTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\IndTests.h ===
/*****************************************************
*** indtests.h
***
*** Header file for our Individual Tests Menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** November 26th, 2001
***
*****************************************************/

#ifndef _INDTESTS_H_
#define _INDTESTS_H_

#include "menuscreen.h"
#include "xbelist.h"
#include "testconfigmenu.h"
#include "resultsmenu.h"
#include "rommenu.h"

enum INDTESTS_ACTIONS
{
    ENUM_INDTESTSMENU_NOACTION,
    ENUM_INDTESTSMENU_SAVECONFIG_NAME,
    ENUM_INDTESTSMENU_SAVECONFIG_MA_SELECT,
    ENUM_INDTESTSMENU_LOADCONFIG_MA_SELECT,
    ENUM_INDTESTSMENU_LOADCONFIG2_SG_SELECT,
    ENUM_INDTESTSMENU_RESETCONFIG_DATA
};

const WCHAR  gc_pwszINDTESTS_NO_TEST_MESSAGE[] =    L"No tests were found.";
const float  gc_fINDTESTS_NO_TEST_TEXT_YPOS =       125.0f;

class CIndTests : public CMenuScreen
{
public:
    // Constructors and Destructor
    CIndTests( void );
    ~CIndTests( void );

    // Public Methods
    void Action( CUDTexture* pTexture );                        // Renders to the texture and calls any per-frame processing
    HRESULT Init( XFONT* pMenuItemFont,                         // Initialize the Menu
                  XFONT* pMenuTitleFont );                      
    void HandleInput( enum BUTTONS buttonPressed,               // Handles input (of the BUTTONS) for the current menu
                      BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed,             // Handles input from the controls
                      BOOL bFirstPress );
    void Enter( void );                                         // This should be called whenever the menu is entered or activated
    HRESULT LaunchSuiteFromSave( const char* pszPath,           // Launch a test suite from a path and a Saved Game Name
                                 const WCHAR* pwszSaveName );

    WCHAR* GetConfigName( void ) { return m_pwszConfigName; };  // Get the name of the current configuration
    void SetConfigNameInfo( WCHAR* pwszConfigName );            // Set the config name info

private:                                                        
    CXBEList              m_XBEList;                            // List of XBEs (tests) that this menu will deal with
    enum INDTESTS_ACTIONS m_eCurrentAction;                     // Used to track the current action of the user
    WCHAR*                m_pwszConfigName;                     // Used to hold the name of the current configuration loaded

    unsigned short        m_usILoopCount;                       // Used to track the inner loop test number
    unsigned short        m_usILoopMax;                         // Used to track how many total inner loop tests there are
    unsigned short        m_usCurrentDefConfig;                 // Used to track the currently running default config (outer loop number)
    unsigned short        m_usTotalDefConfigs;                  // Used to determine how many total global test configs there are (outer loop total)
                                                            
    // Sub-Menus                                            
    CTestConfigMenu m_TestConfigMenu;
    CResultsMenu m_ResultsMenu;
    CROMMenu m_ROMMenu;
                               
    // Methods
    void RenderMenuItems( CUDTexture* pTexture );               // Render the menu items properly on our menu
    HRESULT LoadSuiteConfiguration( const char* pszDirectory ); // Load a configuration suite specified by the user
    HRESULT SaveSuiteConfiguration( void );                     // Save a configuration suite specified by the user
    void ProcessMenuActions( void );                            // If the user is performing an action, this will handle it
    void ProcessRunningTests( void );                           // Handle it if the launcher is running a set of tests
    void SelectAllOrNone( void );                               // Will select all of the tests, or none of the tests, depending upon current select status

    HRESULT GenerateTestRunInfoFile( char* pszCurrentTest );    // Create the Test Run Info file for the current test run
    HRESULT ReadTestRunInfoFile( char* pszCurrentTest,          // Read the Test Run Info file for the current test run
                                 char* pszNextTest,
                                 WCHAR* pwszConfigName );
    HRESULT StoreRunningTestConfig( void );                     // Write the configurations of the tests the user is running to the T:\ drive
    HRESULT StoreLatestResults( char* pszTestName,              // Write the previously run test info to the results file
                                unsigned __int64 uiPassed,      
                                unsigned __int64 uiFailed,
                                char* pszTestNotes );    
    void LaunchTest( char* pszTestName,                         // Launch the correct test passing the write config information
                     unsigned int uiConfigNumber );
    void LaunchTestSuite( void );                               // Launch the test suite that is currently loaded
    BOOL ItemsHighlighted( void );                              // Will return TRUE if any item in our list is highlighted
    void GoToHelp( void );                                      // Sets up and goes to the help menu
    int ProcessConfigItemForLaunch( CConfigItem* pConfigItem,   // Process a config item to be passed to the test we are launching
                                    char* pszBuffer );
	void DisplayLeftMenu( void );                               // Display the menu items for the 'left' dpad button
	void DisplayRightMenu( void );								// Display the menu items for the 'right' dpad button
    void ClearAllConfigData( void );                            // Reset the program to it's initial state (nothing loaded, no configs)
    void ClearConfigNameInfo( void );                           // Clear the config name and path info
    unsigned short GetTotalNumberTestsToRun( void );            // Calculate the total number of tests to run
    unsigned short GetTotalNumberTestsToRunMinusGlobal( void ); // Calculate the total number of tests to run without factoring in the global config data


    // Menu commands
    void RunTests( void );
    void EditConfig( void );
    void ToggleTestSelect( void );
    void ToggleTestSelectON( void );
    void DisplayResults( void );
    void SaveSuite( void );
    void LoadSuite( void );
};

#endif // _INDTESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\indtests.cpp ===
/*****************************************************
*** indtests.cpp
***
*** CPP file for our Individual Tests Menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** November 26th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "indtests.h"

// Constructors and Destructor
CIndTests::CIndTests( void ) :
m_eCurrentAction( ENUM_INDTESTSMENU_NOACTION ),
m_pwszConfigName( NULL ),
m_usILoopCount( 0 ),
m_usILoopMax( 0 ),
m_usCurrentDefConfig( 0 ),
m_usTotalDefConfigs( 0 )
{
}

CIndTests::~CIndTests( void )
{
    ClearConfigNameInfo();
}

// Renders to the texture and calls any per-frame processing
void CIndTests::Action( CUDTexture* pTexture )
{
    // Make sure we handle any user initiated actions
    ProcessMenuActions();

    if( m_eCurrentAction != ENUM_INDTESTSMENU_NOACTION )
        return;

    // Call the base class function
    CMenuScreen::Action( pTexture );
}

// Render the menu items properly on our menu
void CIndTests::RenderMenuItems( CUDTexture* pTexture )
{
    if( 0 == GetNumMenuItems() )
    {
        // Display Message Here
        float fXPos = gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), gc_pwszINDTESTS_NO_TEST_MESSAGE ) / 2 );
        float fYPos = gc_fINDTESTS_NO_TEST_TEXT_YPOS;

        pTexture->DrawText( GetBodyFont(), fXPos, fYPos, m_dwMenuItemEnabledFGColor, m_dwMenuItemEnabledBGColor, L"%ls", gc_pwszINDTESTS_NO_TEST_MESSAGE );
    }
    else
    {
        //
        // Render the total number of tests that will be run
        //
        WCHAR pwszNumTests[MAX_PATH+1];
        pwszNumTests[MAX_PATH] = L'\0';

        _snwprintf( pwszNumTests, MAX_PATH, L"[%hu test(s)]", GetTotalNumberTestsToRun() );

        float fXPos = ( m_fRightMenuAreaBoundary - m_fRightMenuAreaBorder ) - GetStringPixelWidth( GetBodyFont(), pwszNumTests );
        float fYPos = 30;

        pTexture->DrawText( GetBodyFont(), fXPos, fYPos, m_dwMenuItemHighlightedFGColor, m_dwMenuItemHighlightedBGColor, L"%ls", pwszNumTests );

        //
        // Render the name of the current configuration (if there is one)
        //
        if( NULL != GetConfigName() )
        {
            int iLen = GetStringPixelWidth( GetBodyFont(), L"[]" );
            fXPos = ( m_fRightMenuAreaBoundary - m_fRightMenuAreaBorder ) - GetStringPixelWidth( GetBodyFont(), GetConfigName() ) - iLen;
            fYPos = 60;

            pTexture->DrawText( GetBodyFont(), fXPos, fYPos, m_dwMenuItemHighlightedFGColor, m_dwMenuItemHighlightedBGColor, L"[%ls]", GetConfigName() );
        }

        CMenuScreen::RenderMenuItems( pTexture );
    }
}

// Initialize the Menu
HRESULT CIndTests::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CIndTests::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Test List" );

    /////////////////////////
    // Add screen items here
    /////////////////////////
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    DisplayLeftMenu();

    ///////////////////////
	// Add menu items here
    ///////////////////////

    // Find each test .XBE
    m_XBEList.Init( "d:\\tests", "XBE" );

    // Add each XBE to a structure, and create a menu item for that XBE
    for( unsigned int x = 0; x < m_XBEList.GetNumItems(); x++ )
        AddMenuItem( pMenuItemFont, m_XBEList.GetXBETitle( x ), FALSE, TRUE, x );

    // Initialize sub-menus
    m_TestConfigMenu.Init( pMenuItemFont, pMenuTitleFont );
    m_TestConfigMenu.SetBackPtr( this );

    m_ResultsMenu.Init( pMenuItemFont, pMenuTitleFont );
    m_ResultsMenu.SetBackPtr( this );

    m_ROMMenu.Init( pMenuItemFont, pMenuTitleFont );
    m_ROMMenu.SetBackPtr( this );

    return hr;
}


// Handles input (of the CONTROLS) for the current menu
void CIndTests::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( CONTROL_START != controlPressed && 
		CONTROL_BACK != controlPressed &&
		CONTROL_DPAD_LEFT != controlPressed &&
		CONTROL_DPAD_RIGHT != controlPressed &&
        CONTROL_LEFT_THUMB != controlPressed &&
        CONTROL_RIGHT_THUMB != controlPressed )
    {
        CMenuScreen::HandleInput( controlPressed, bFirstPress );

        return;
    }

    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( controlPressed )
    {
    case CONTROL_BACK:
        {
            GoToHelp();

            break;
        }
    case CONTROL_START:
        {
            RunTests();

            break;
        }
	case CONTROL_DPAD_LEFT:
		{
			UpdateTexture();

			DisplayLeftMenu();

			break;
		}
	case CONTROL_DPAD_RIGHT:
		{
			UpdateTexture();

			DisplayRightMenu();

			break;
		}
    case CONTROL_LEFT_THUMB:
        {
            SelectAllOrNone();

            break;
        }
    case CONTROL_RIGHT_THUMB:
        {
            // Don't do anything if there aren't any menu items
            if( 0 == GetNumMenuItems() )
                return;

            // Ask the user if they really want to clear all data
            m_eCurrentAction = ENUM_INDTESTSMENU_RESETCONFIG_DATA;

            GetYesNoPtr()->SetBackPtr( this );
            GetYesNoPtr()->SetMenuTitle( GetBodyFont(), L"Clear Test Configurations" );
            GetYesNoPtr()->SetText( L"Are you sure that you wish to clear\nALL configuration data for ALL tests?" );

            Leave( GetYesNoPtr() );

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CIndTests::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            ToggleTestSelectON();
            EditConfig();

            break;
        }
    case BUTTON_B:
        {
            GoBack();

            break;
        }
    case BUTTON_X:
        {
            SaveSuite();

            break;
        }
    case BUTTON_Y:
        {
            LoadSuite();

            break;
        }
    case BUTTON_BLACK:
        {
            ToggleTestSelect();

            break;
        }
    case BUTTON_WHITE:
        {
            DisplayResults();            

            break;
        }
    case BUTTON_RIGHT_TRIGGER:
        {
			m_TestConfigMenu.SetMenuTitle( GetHeaderFont(), L"Test Run Globals" );
            m_TestConfigMenu.SetMultiConfigs( TRUE );
            m_TestConfigMenu.SetXBEInfoPtr( GetLauncherXBEInfo() );

            Leave( &m_TestConfigMenu );

            break;
        }
    case BUTTON_LEFT_TRIGGER:
        {
            Leave( &m_ROMMenu );

            break;
        }
    }
}


// Will return TRUE if any item in our list is highlighted
BOOL CIndTests::ItemsHighlighted( void )
{
    // Check to see if there is anything highlighted
    BOOL bFoundItem = FALSE;

    unsigned int uiCurrentIndex = m_MenuItems.GetCurrentIndex();
    m_MenuItems.MoveFirst();
    do
    {
        if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
            bFoundItem = TRUE;
    } while( m_MenuItems.MoveNext() );

    m_MenuItems.MoveTo( uiCurrentIndex );

    return bFoundItem;
}


// Save a configuration suite specified by the user
HRESULT CIndTests::SaveSuiteConfiguration( void )
{
    // Create the Saved Game used to store this configuration
    char pszGamePath[MAX_PATH + 1];
    pszGamePath[MAX_PATH] = '\0';

    char pszDrivePath[4];
    pszDrivePath[3] = '\0';

    if( 8 == GetMemAreaSelectPtr()->GetSelectedItemValue() ) // Xbox Hard Disk
        strcpy( pszDrivePath, "U:\\" );
    else
        strcpy( pszDrivePath, GetMUPtr( GetMemAreaSelectPtr()->GetSelectedItemValue() )->GetDrivePath() );
    WCHAR* pwszGameName = GetKeyboardPtr()->GetValue();

    DebugPrint( "pszDrivePath - '%hs', pwszGameName - '%ls'\n", pszDrivePath, pwszGameName );
    if( ERROR_SUCCESS != XCreateSaveGame( pszDrivePath,
                                          pwszGameName,
                                          CREATE_NEW, // OPEN_ALWAYS,
                                          0,
                                          pszGamePath,
                                          MAX_PATH ) )
    {
        // Delete the game (it might exist) and try again
        if( ERROR_SUCCESS != XDeleteSaveGame( pszDrivePath, pwszGameName ) )
        {
            DebugPrint( "CIndTests::SaveSuiteConfiguration():Failed to delete the existing Saved Game!! - '%hs%ls'\n", pszDrivePath, pwszGameName );

            return E_FAIL;
        }
        else if( ERROR_SUCCESS != XCreateSaveGame( pszDrivePath,
                                                   pwszGameName,
                                                   CREATE_NEW, // OPEN_ALWAYS,
                                                   0,
                                                   pszGamePath,
                                                   MAX_PATH ) )
        {
            DebugPrint( "CIndTests::SaveSuiteConfiguration():Failed to create the Saved Game!! - '%hs%ls'\n", pszDrivePath, pwszGameName );

            return E_FAIL;
        }
    }

    BOOL bConfigFound = FALSE;      // Used to determine if there are any configurations to save

    // For every Highlighted Menu Item, Save the configuration
    m_MenuItems.MoveFirst();
    m_XBEList.MoveFirst();
    do
    {
        if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
        {
            bConfigFound = TRUE;

            // Save the configuration
            if( FAILED( SaveXBEConfigs( m_XBEList.GetCurrentXBEInfoPtr(), pszGamePath ) ) )
                DebugPrint( "CIndTests::SaveSuiteConfiguration():Failed to save the test configuration for - '%ls.xbe'", m_XBEList.GetCurrentXBEInfoPtr()->GetFilename() );
        }

        m_XBEList.MoveNext();
    } while( m_MenuItems.MoveNext() );

    if( 0 != GetLauncherXBEInfo()->GetNumTestConfigs() )
    {
        // Save the overall test run information (comments) entered by the user
        if( FAILED( SaveXBEConfigs( GetLauncherXBEInfo(), pszGamePath ) ) )
            DebugPrint( "CIndTests::SaveSuiteConfiguration():Failed to save the test configuration for - '%ls.xbe'", GetLauncherXBEInfo()->GetFilename() );
    }

    // Check if we found any configs to write
    // If not, delete the saved game we created
    if( !bConfigFound )
    {
        DebugPrint( "SaveXBEConfigs():Nothing to save -- Deleting Save\n" );
        if( ERROR_SUCCESS != XDeleteSaveGame( pszDrivePath, pwszGameName ) )
        {
            DebugPrint( "CIndTests::SaveSuiteConfiguration():Failed to delete the existing Saved Game!! - '%hs%ls'\n", pszDrivePath, pwszGameName );

            return E_FAIL;
        }
    }
    else
    {
        SetConfigNameInfo( pwszGameName );

        //DebugPrint( "Config Name: '%ls'\n", GetConfigName() );
        //DebugPrint( "Config Path: '%hs'\n", GetConfigPath() );
    }

    return S_OK;
}

// Load a configuration suite specified by the user
HRESULT CIndTests::LoadSuiteConfiguration( const char* pszDirectory )
{
    if( NULL == pszDirectory )
    {
        DebugPrint( "CIndTests::LoadSuiteConfiguration():Invalid argument(s) passed in!!\n" );

        return E_INVALIDARG;
    }

    // Clear any loaded configuration that currently exists
    ClearAllConfigData();

    // For every .DAT found in the Save Game, load the config for the .XBE (in order)
    char pszConfigPath[MAX_PATH+1];
    pszConfigPath[MAX_PATH] = '\0';

    int iCount = 0;
    m_XBEList.MoveFirst();
    m_MenuItems.MoveFirst();
    do
    {
        // Check to see if any configs exists for this XBE
        if( pszDirectory[strlen(pszDirectory) - 1] != '\\' )
            _snprintf( pszConfigPath, MAX_PATH, "%hs\\%hs_0.dat", pszDirectory, m_XBEList.GetCurrentXBEInfoPtr()->GetFilename() );
        else
            _snprintf( pszConfigPath, MAX_PATH, "%hs%hs_0.dat", pszDirectory, m_XBEList.GetCurrentXBEInfoPtr()->GetFilename() );

        // If the file exists, load it, otherwise move on
        if( FileExists( pszConfigPath ) )
        {
            // Load the XBE's configs
            if( FAILED( LoadXBEConfigs( m_XBEList.GetCurrentXBEInfoPtr(), pszDirectory ) ) )
            {
                DebugPrint( "CIndTests::LoadSuiteConfiguration():Failed to load the test configuration for - '%ls.xbe'\n", m_XBEList.GetCurrentXBEInfoPtr()->GetFilename() );
            }
            else    // Highlight the menu option
            {
                m_XBEList.GetCurrentXBEInfoPtr()->SetLoaded( TRUE );
                UpdateMenuItem( iCount, m_MenuItems.GetCurrentNode()->m_pwszItemName, TRUE, m_MenuItems.GetCurrentNode()->m_bEnabled );
            }
        }

        iCount++;
        m_MenuItems.MoveNext();
    } while( m_XBEList.MoveNext() );

    // Check to see if we have an overall Test Run Info file.  If so, load it
    if( pszDirectory[strlen(pszDirectory) - 1] != '\\' )
        _snprintf( pszConfigPath, MAX_PATH, "%hs\\%hs_0.dat", pszDirectory, GetLauncherXBEInfo()->GetFilename() );
    else
        _snprintf( pszConfigPath, MAX_PATH, "%hs%hs_0.dat", pszDirectory, GetLauncherXBEInfo()->GetFilename() );

    // If the file exists, load it, otherwise move on
    if( FileExists( pszConfigPath ) )
    {
        // Load the HVS Launcher XBE's configs
        if( FAILED( LoadXBEConfigs( GetLauncherXBEInfo(), pszDirectory ) ) )
            DebugPrint( "CIndTests::LoadSuiteConfiguration():Failed to load the test configuration for - '%ls.xbe'\n", GetLauncherXBEInfo()->GetFilename() );
        else    // Highlight the menu option
            GetLauncherXBEInfo()->SetLoaded( TRUE );
    }

    return S_OK;
}


// If the user is performing an action, this will handle it
void CIndTests::ProcessMenuActions( void )
{
    switch( m_eCurrentAction )
    {
    case ENUM_INDTESTSMENU_SAVECONFIG_NAME:
        {
            if( !GetKeyboardPtr()->GetCancelled() )
            {
                // Get the Configuration Name
                m_eCurrentAction = ENUM_INDTESTSMENU_SAVECONFIG_MA_SELECT;

                GetMemAreaSelectPtr()->SetBackPtr( this );

                Leave( GetMemAreaSelectPtr() );
            }
            else
                m_eCurrentAction = ENUM_INDTESTSMENU_NOACTION;  // Make sure we set this to no action

            break;
        }
    case ENUM_INDTESTSMENU_SAVECONFIG_MA_SELECT:
        {
            // Make sure we set this to no action
            m_eCurrentAction = ENUM_INDTESTSMENU_NOACTION;
            
            if( !GetMemAreaSelectPtr()->GetCancelled() )
                if( FAILED( SaveSuiteConfiguration() ) )
                    DebugPrint( "CIndTests::ProcessMenuActions():SaveSuiteConfiguration() Failed!!\n" );

            break;
        }
    case ENUM_INDTESTSMENU_LOADCONFIG_MA_SELECT:
        {
            if( !GetMemAreaSelectPtr()->GetCancelled() )
            {
                m_eCurrentAction = ENUM_INDTESTSMENU_LOADCONFIG2_SG_SELECT;

                GetChooseSavePtr()->SetBackPtr( this );
                if( 8 == GetMemAreaSelectPtr()->GetSelectedItemValue() ) // Xbox Hard Disk
                    GetChooseSavePtr()->SetInfo( "U:\\" );
                else
                    GetChooseSavePtr()->SetInfo( GetMUPtr( GetMemAreaSelectPtr()->GetSelectedItemValue() )->GetDrivePath() );

                Leave( GetChooseSavePtr() );
            }
            else    // User cancelled
                m_eCurrentAction = ENUM_INDTESTSMENU_NOACTION;  // Make sure we set this to no action

            break;
        }
    case ENUM_INDTESTSMENU_LOADCONFIG2_SG_SELECT:
        {
            // Make sure we set this to no action
            m_eCurrentAction = ENUM_INDTESTSMENU_NOACTION;

            if( !GetChooseSavePtr()->GetCancelled() )
            {
                if( FAILED( LoadSuiteConfiguration( GetChooseSavePtr()->GetCurrentSaveDirectory() ) ) )
                    DebugPrint( "CIndTests::ProcessMenuActions():LoadSuiteConfiguration() Failed!!\n" );
                else // Store the info of the loaded config
                {
                    SetConfigNameInfo( GetChooseSavePtr()->GetCurrentSaveName() );

                    //DebugPrint( "Config Name: '%ls'\n", GetConfigName() );
                    //DebugPrint( "Config Path: '%hs'\n", GetConfigPath() );
                }
            }
            else // User selected back from the Choose Save Menu
            {
                // Get the Saved Game the user wishes to process
                m_eCurrentAction = ENUM_INDTESTSMENU_LOADCONFIG_MA_SELECT;
                GetMemAreaSelectPtr()->SetBackPtr( this );
                Leave( GetMemAreaSelectPtr() );
            }

            break;
        }
    case ENUM_INDTESTSMENU_RESETCONFIG_DATA:
        {
            // Make sure we set this to no action
            m_eCurrentAction = ENUM_INDTESTSMENU_NOACTION;

            // If they didn't cancel, delete all config data
            if( !GetYesNoPtr()->GetCancelled() )
            {
                ClearAllConfigData();
            }

            break;
        }
    }
}


// Write the configurations of the tests the user is running to the T:\ drive
HRESULT CIndTests::StoreRunningTestConfig( void )
{
    // Create the Directory used to store this configuration
    
    if( !CreateDirectory( gc_pszRunningTestsPath, NULL ) )
    {
        // Attempt to delete the directory
        if( !DeleteDirectory( gc_pszRunningTestsPath ) )
        {
            DebugPrint( "CIndTests::StoreRunningTestConfig():Failed to delete the directory!! - '%hs'\n", gc_pszRunningTestsPath );

            return E_FAIL;
        }
        else
        {
            // Create the directory again
            if( !CreateDirectory( gc_pszRunningTestsPath, NULL ) )
            {
                DebugPrint( "CIndTests::StoreRunningTestConfig():Failed to create the directory!! - '%hs'\n", gc_pszRunningTestsPath );

                return E_FAIL;
            }
        }
    }

    BOOL bConfigFound = FALSE;      // Used to determine if there are any configurations to save

    // For every Highlighted Menu Item, Save the configuration
    m_MenuItems.MoveFirst();
    m_XBEList.MoveFirst();
    do
    {
        if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
        {
            bConfigFound = TRUE;

            // Save the configuration
            if( FAILED( SaveXBEConfigs( m_XBEList.GetCurrentXBEInfoPtr(), (char*)gc_pszRunningTestsPath ) ) )
                DebugPrint( "CIndTests::StoreRunningTestConfig():Failed to save the test configuration for - '%ls.xbe'", m_XBEList.GetCurrentXBEInfoPtr()->GetFilename() );
        }

        m_XBEList.MoveNext();
    } while( m_MenuItems.MoveNext() );

    if( 0 != GetLauncherXBEInfo()->GetNumTestConfigs() )
    {
        // Save the overall test run information (comments) entered by the user
        if( FAILED( SaveXBEConfigs( GetLauncherXBEInfo(), (char*)gc_pszRunningTestsPath ) ) )
            DebugPrint( "CIndTests::StoreRunningTestConfig():Failed to save the test configuration for - '%ls.xbe'", GetLauncherXBEInfo()->GetFilename() );
    }

    // Check if we found any configs to write
    // If not, delete the saved game we created
    if( !bConfigFound )
    {
        DebugPrint( "StoreRunningTestConfig():Nothing to run -- Deleting Running Tests Directory\n" );
        if( !DeleteDirectory( gc_pszRunningTestsPath ) )
        {
            DebugPrint( "CIndTests::StoreRunningTestConfig():Failed to delete the directory!! - '%hs'\n", gc_pszRunningTestsPath );

            return E_FAIL;
        }

        return E_ABORT;
    }

    return S_OK;
}


// Read the Test Run Info file for the current test run
HRESULT CIndTests::ReadTestRunInfoFile( char* pszCurrentTest, char* pszNextTest, WCHAR* pwszConfigName )
{
    if( NULL == pszCurrentTest || NULL == pszNextTest || NULL == pwszConfigName )
    {
        DebugPrint( "CIndTests::ReadTestRunInfoFile():Invalid argument(s) passed in!!\n" );
        return E_INVALIDARG;
    }

    FILE* pfCurrentTestInfo = fopen( gc_pszCurrentTestInfoFile, "rt" );
    if( NULL == pfCurrentTestInfo )
    {
        DebugPrint( "CIndTests::ReadTestRunInfoFile():Unable to open the file!! - '%hs'\n", gc_pszCurrentTestInfoFile );
        return E_FAIL;
    }

    // Suite Name
    if( 1 != fscanf( pfCurrentTestInfo, "\"%l255[^\"]\"\n", pwszConfigName ) ) DebugPrint( "CIndTests::ReadTestRunInfoFile():Failed to scan Config Name!!\n" );
    
    // Current inner loop test number
    if( 1 != fscanf( pfCurrentTestInfo, "%hu\n", &m_usILoopCount ) ) DebugPrint( "CIndTests::ReadTestRunInfoFile():Failed to scan Current Inner Loop Tests Info!!\n" );

    // Total inner loop test number
    if( 1 != fscanf( pfCurrentTestInfo, "%hu\n", &m_usILoopMax ) ) DebugPrint( "CIndTests::ReadTestRunInfoFile():Failed to scan Current Inner Loop Total Tests!!\n" );

    // Current Global Default Test Config Number
    if( 1 != fscanf( pfCurrentTestInfo, "%hu\n", &m_usCurrentDefConfig ) ) DebugPrint( "CIndTests::ReadTestRunInfoFile():Failed to scan Current Default Config Number!!\n" );

    // Total Global Default Test Configs
    if( 1 != fscanf( pfCurrentTestInfo, "%hu\n", &m_usTotalDefConfigs ) ) DebugPrint( "CIndTests::ReadTestRunInfoFile():Failed to scan Total Default Config Number!!\n" );
    
    // Current Test Name
    if( 1 != fscanf( pfCurrentTestInfo, "%hs\n", pszCurrentTest ) ) DebugPrint( "CIndTests::ReadTestRunInfoFile():Failed to read the current test file name!!\n" );

    // Test List
    if( ( ( m_usCurrentDefConfig * m_usILoopMax ) + m_usILoopCount + 1 ) == ( m_usTotalDefConfigs * m_usILoopMax ) )
    {
        // If there are no more tests to run, simply return an empty string
        pszNextTest[0] = '\0';
    }
    else // There is a test to run, get the file name
    {
        char pszFirstTestInList[MAX_PATH+1];
        pszFirstTestInList[MAX_PATH] = '\0';

        for( unsigned int x = 0; x < m_usILoopMax; x++ )
        {
            // Read the test filename
            if( 1 != fscanf( pfCurrentTestInfo, "%hs\n", pszNextTest ) ) DebugPrint( "CIndTests::ReadTestRunInfoFile():Failed to read the test file name!!\n" );

            if( x == ( m_usILoopCount + 1 ) )
                break;

            // Store the very first test in our list in case we need to use that test as our 'next' test
            if( 0 == x )
                strncpy( pszFirstTestInList, pszNextTest, MAX_PATH );
        }

        // Check to see if we need to use the first test in our list
        if( x == m_usILoopMax )
            strcpy( pszNextTest, pszFirstTestInList );
    }

    fclose( pfCurrentTestInfo );
    pfCurrentTestInfo = NULL;

    return S_OK;
}


// Create the Test Run Info file for the current test run
HRESULT CIndTests::GenerateTestRunInfoFile( char* pszCurrentTest )
{
    if( NULL == pszCurrentTest )
    {
        DebugPrint( "CIndTests::GenerateTestRunInfoFile():Invalid argument(s) passed in!!\n" );
        return E_INVALIDARG;
    }

    FILE* pfCurrentTestInfo = fopen( gc_pszCurrentTestInfoFile, "wt" );
    if( NULL == pfCurrentTestInfo )
    {
        DebugPrint( "CIndTests::GenerateTestRunInfoFile():Unable to create the file!! - '%hs'\n", gc_pszCurrentTestInfoFile );
        return E_FAIL;
    }

    // Suite Name
    fprintf( pfCurrentTestInfo, "\"%ls\"\n", GetConfigName() );

    // Current inner loop test number
    fprintf( pfCurrentTestInfo, "%hu\n", m_usILoopCount );

    // Total inner loop test number
    fprintf( pfCurrentTestInfo, "%hu\n", m_usILoopMax );

    // Current Global Default Test Config Number
    fprintf( pfCurrentTestInfo, "%hu\n", m_usCurrentDefConfig );

    // Total Number of Global Default Test Configs
    fprintf( pfCurrentTestInfo, "%hu\n", m_usTotalDefConfigs );

    // Current Test File Name
    fprintf( pfCurrentTestInfo, "%hs\n", pszCurrentTest );

    unsigned int uiMenuIndex = m_MenuItems.GetCurrentIndex();
    unsigned int uiXBEListIndex = m_XBEList.GetCurrentIndex();

    // Test List
    m_MenuItems.MoveFirst();
    m_XBEList.MoveFirst();
    do
    {
        if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
        {
            for( unsigned int x = 0; x < m_XBEList.GetCurrentXBEInfoPtr()->GetNumTestConfigs(); x++ )
                fprintf( pfCurrentTestInfo, "%hs_%u.dat\n", m_XBEList.GetCurrentXBEInfoPtr()->GetFilename(), x );
        }

        m_XBEList.MoveNext();
    } while( m_MenuItems.MoveNext() );

    fclose( pfCurrentTestInfo );
    pfCurrentTestInfo = NULL;

    // Restore our indexes
    m_MenuItems.MoveTo( uiMenuIndex );
    m_XBEList.MoveTo( uiXBEListIndex );

    return S_OK;
}


// Launch the correct test passing the right config information
void CIndTests::LaunchTest( char* pszTestName, unsigned int uiConfigNumber )
{
    if( NULL == pszTestName )
    {
        DebugPrint( "CIndTests::LaunchTest():Invalid argument(s) passed in!!\n" );

        return;
    }

    // Find the test in our list
    BOOL bTestFound = FALSE;
    m_XBEList.MoveFirst();
    do
    {
        if( 0 == _stricmp( pszTestName, m_XBEList.GetCurrentXBEInfoPtr()->GetFilename() ) )
        {
            bTestFound = TRUE;
            break;
        }
    } while( m_XBEList.MoveNext() );

    if( !bTestFound )
    {
        DebugPrint( "CIndTests::LaunchTest():Could not find test - '%hs'\n", pszTestName );
        return;
    }

    // Check to make sure the configuration passed in exists
    if( uiConfigNumber >= m_XBEList.GetCurrentXBEInfoPtr()->GetNumTestConfigs() )
    {
        DebugPrint( "CIndTests::LaunchTest():Invalid configuration '%u' passed in for '%hs'!!\n", uiConfigNumber, pszTestName );
        return;
    }

    char pszConfigData[3072];
    ZeroMemory( pszConfigData, 3072 );

    char* pCurrentPos = pszConfigData;
    int iNumBytes = 0;

    // Check to make sure the global configuration passed in exists
    if( m_usCurrentDefConfig >= GetLauncherXBEInfo()->GetNumTestConfigs() )
    {
        DebugPrint( "CIndTests::LaunchTest():Invalid configuration '%hu' specified for the global configs!!\n", m_usCurrentDefConfig );
        return;
    }

    // Process the default config items for the HVS Launcher
    GetLauncherXBEInfo()->MoveToTestConfig( m_usCurrentDefConfig );
    GetLauncherXBEInfo()->GetCurrentTestConfig()->MoveFirstConfigItem();
    do
    {
        iNumBytes = ProcessConfigItemForLaunch( GetLauncherXBEInfo()->GetCurrentTestConfig()->GetCurrentConfigItem(), pCurrentPos );

        pCurrentPos += iNumBytes;
    } while( GetLauncherXBEInfo()->GetCurrentTestConfig()->MoveNextConfigItem() );

    // Process the config items for the current test being launched
    CTestConfig* pTestConfig = m_XBEList.GetCurrentXBEInfoPtr()->GetTestConfig( uiConfigNumber );
    pTestConfig->MoveFirstConfigItem();
    do
    {
        iNumBytes = ProcessConfigItemForLaunch( pTestConfig->GetCurrentConfigItem(), pCurrentPos );

        pCurrentPos += iNumBytes;
    } while( pTestConfig->MoveNextConfigItem() );

    // Construct the path of the XBE to launch
    char pszXBEPath[MAX_PATH + 1];
    ZeroMemory( pszXBEPath, MAX_PATH + 1 );

    _snprintf( pszXBEPath, MAX_PATH, "d:%hs\\%hs.%hs", m_XBEList.GetCurrentXBEInfoPtr()->GetDirectory(),
                                                       m_XBEList.GetCurrentXBEInfoPtr()->GetFilename(),
                                                       m_XBEList.GetCurrentXBEInfoPtr()->GetFileExtension() );

    // Construct the structure to pass to the test
    int nSize = sizeof( ToTestData ) + strlen( pszConfigData ) + 1;
    struct ToTestData* pTestData = (ToTestData*)new char[sizeof(LAUNCH_DATA)];
    ZeroMemory( pTestData, nSize );

    pTestData->titleID = HVSLAUNCHERID;
    pTestData->testNumber = ( m_usCurrentDefConfig * m_usILoopMax ) + m_usILoopCount + 1;
    pTestData->totalTests = m_usTotalDefConfigs * m_usILoopMax;
    strcpy( pTestData->configSettings, pszConfigData );

    // DebugPrint( "CIndTests::LaunchTest():pszTestName - '%hs'\n", pszTestName );
    // DebugPrint( "CIndTests::LaunchTest():pszXBEPath  - '%hs'\n", pszXBEPath );

    LaunchImage( pszXBEPath, (LAUNCH_DATA*)pTestData );
}


// Process a config item to be passed to the test we are launching
int CIndTests::ProcessConfigItemForLaunch( CConfigItem* pConfigItem, char* pszBuffer )
{
    int iReturnVal = 0;

    if( 0 == _wcsicmp( pConfigItem->GetType(), L"number" ) )
    {
        CConfigNumber* pConfigNumber = (CConfigNumber*)pConfigItem;

        // Append each config item to the buffer
        iReturnVal = sprintf( pszBuffer, "%ls=%ld\n", 
            pConfigNumber->GetFieldName(),
            pConfigNumber->GetDefault() );
    }
    else if( 0 == _wcsicmp( pConfigItem->GetType(), L"range" ) )
    {
        CConfigRange* pConfigRange = (CConfigRange*)pConfigItem;

        // Append each config item to the buffer
        iReturnVal = sprintf( pszBuffer, "%ls=%ld-%ld\n", 
            pConfigRange->GetFieldName(),
            pConfigRange->GetDefault1(),
            pConfigRange->GetDefault2() );
    }
    else if( 0 == _wcsicmp( pConfigItem->GetType(), L"string" ) )
    {
        CConfigString* pConfigString = (CConfigString*)pConfigItem;

        // Append each config item to the buffer
        iReturnVal = sprintf( pszBuffer, "%ls=%ls\n", 
            pConfigString->GetFieldName(),
            pConfigString->GetCurrentString() );
    }
    else if( 0 == _wcsicmp( pConfigItem->GetType(), L"string2" ) )
    {
        CConfigString2* pConfigString2 = (CConfigString2*)pConfigItem;

        // Append each config item to the buffer
        iReturnVal = sprintf( pszBuffer, "%ls=%ls\n", 
            pConfigString2->GetFieldName(),
            pConfigString2->GetString() );
    }
    else if( 0 == _wcsicmp( pConfigItem->GetType(), L"numberstring" ) )
    {
        CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pConfigItem;

        // Append each config item to the buffer
        iReturnVal = sprintf( pszBuffer, "%ls=%ld %ls\n", 
            pConfigNumberString->GetFieldName(),
            pConfigNumberString->GetDefault(),
            pConfigNumberString->GetCurrentString() );
    }

    return iReturnVal;
}


// Write the previously run test info to the results file
HRESULT CIndTests::StoreLatestResults( char* pszTestName, unsigned __int64 uiPassed, unsigned __int64 uiFailed, char* pszTestNotes )
{
    if( NULL == pszTestName )
    {
        DebugPrint( "CIndTests::StoreLatestResults():Invalid argument(s) passed in!!\n" );
        return E_FAIL;
    }

    FILE* pfResults = fopen( gc_pszResultsFile, "at" );
    if( NULL == pfResults )
    {
        DebugPrint( "CIndTests::StoreLatestResults():Unable to create the file!! - '%hs'\n", gc_pszResultsFile );
        return E_FAIL;
    }

    // Remove any trailing "\n" from the notes
    if( '\n' == pszTestNotes[strlen(pszTestNotes) - 1] )
        pszTestNotes[strlen(pszTestNotes) - 1] = '\0';

    // Get the test .XBE file name, and get the current config index
    char pszFileName[MAX_PATH+1];
    pszFileName[MAX_PATH] = '\0';
    unsigned int uiConfigNumber = 0;

    char* pszDOTString = strstr( pszTestName, "_" );
    strncpy( pszFileName, pszTestName, pszDOTString - pszTestName );
    pszFileName[pszDOTString - pszTestName] = '\0';

    pszDOTString += 1;
    if( 1 != sscanf( pszDOTString, "%u", &uiConfigNumber ) )
        DebugPrint( "CIndTests::StoreLatestResults():Unabled to determine config number!!\n" );

    CXBEInfo* pXBEInfo = m_XBEList.GetXBEInfoPtr( m_XBEList.GetIndexOfXBE( pszFileName ) );

    // DebugPrint( "%ls (Config %u), %I64u, %I64u\n", pXBEInfo->GetTitleName(), uiConfigNumber, uiPassed, uiFailed );

    fprintf( pfResults, "%ls (Config %u), %I64u, %I64u, \"%hs\"\n", pXBEInfo->GetTitleName(), uiConfigNumber + 1, uiPassed, uiFailed, pszTestNotes );

    fclose( pfResults );
    pfResults = NULL;

    return S_OK;
}


// Handle it if the launcher is running a set of tests
void CIndTests::ProcessRunningTests( void )
{
    // Check to see if we have any data and get the launch data if found
    DWORD dwLaunchDataType = 0l;
    LAUNCH_DATA oLaunchData;
    ZeroMemory( &oLaunchData, sizeof( oLaunchData ) );

    // Check to see if there is any data from a previous test
    if( ERROR_SUCCESS != XGetLaunchInfo( &dwLaunchDataType, &oLaunchData ) )
        return;
    else
    {
        // Check to make sure it's from one of our tests
        if( LDT_TITLE != dwLaunchDataType )
        {
            DebugPrint( "CIndTests::ProcessRunningTests():Data not from one of our tests!!\n" );
            return;
        }
    }

    // We got data, let's process it
    struct ToLauncherData* pLauncherData = (struct ToLauncherData*)&oLaunchData;

    /*
    DebugPrint( "Title ID = 0x%0.8X\n", pLauncherData->titleID );
    DebugPrint( "Passed   = %u\n", pLauncherData->numPass );
    DebugPrint( "Failed   = %u\n", pLauncherData->numFail );
    DebugPrint( "Notes    = '%hs'\n", pLauncherData->notes );
    */

    // Get the information from the previous test

    // If this was our last config for a test, let's delete it's data information
    WCHAR pwszConfigName[MAX_PATH+1];
    char pszCurrentTest[MAX_PATH+1];
    char pszNextTest[MAX_PATH+1];
    ZeroMemory( pwszConfigName, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
    pszCurrentTest[MAX_PATH] = '\0';
    pszNextTest[MAX_PATH] = '\0';

    if( FAILED( ReadTestRunInfoFile( pszCurrentTest, pszNextTest, pwszConfigName ) ) )
    {
        DebugPrint( "CIndTests::ProcessRunningTests():Failed to read the test run info file!!\n" );
        return;
    }

    /*
    DebugPrint( "Current I    - '%hu'\n", m_usILoopCount );
    DebugPrint( "Total I      - '%hu'\n", m_usILoopMax );
    DebugPrint( "Current O    - '%hu'\n", m_usCurrentDefConfig );
    DebugPrint( "Total O      - '%hu'\n", m_usTotalDefConfigs );
    DebugPrint( "Current Test - '%hs'\n", pszCurrentTest );
    DebugPrint( "Next Test    - '%hs'\n", pszNextTest );
    */

    // Update the Results file with the latest data
    StoreLatestResults( pszCurrentTest, (unsigned __int64)pLauncherData->numPass, (unsigned __int64)pLauncherData->numFail, pLauncherData->notes );

    // Load Configs from Running Test Directory
    LoadSuiteConfiguration( (char*)gc_pszRunningTestsPath );

    // Set our configuration name if necessary
    if( 0 != wcscmp( L"(null)", pwszConfigName ) )
        SetConfigNameInfo( pwszConfigName );

    // Increment our current test to run number and inner loop counter
    m_usILoopCount++;

    if( m_usILoopCount == m_usILoopMax )
    {
        m_usILoopCount = 0;
        m_usCurrentDefConfig++;
    }


    // Check to see if we are done running tests
    if( m_usCurrentDefConfig == m_usTotalDefConfigs )
    {
        // We're done, let's clean up
        DebugPrint( "CIndTests::ProcessRunningTests():No more tests, cleaning up...\n" );

        if( !DeleteDirectory( gc_pszRunningTestsPath ) )
            DebugPrint( "Unable to delete directory - '%hs'\n", gc_pszRunningTestsPath );

        if( !DeleteFile( gc_pszCurrentTestInfoFile ) )
            DebugPrint( "Unable to delete the running test file - '%hs'\n", gc_pszCurrentTestInfoFile );

        // Clear out test number counters
        m_usILoopCount = 0;
        m_usILoopMax = 0;
        m_usCurrentDefConfig = 0;
        m_usTotalDefConfigs = 0;

        // Display the results
        Leave( &m_ResultsMenu );
    }
    else
    {
        // Generate an updated Test Info File
        GenerateTestRunInfoFile( pszNextTest );

        //
        // Launch the next test
        //

        // Get the test name and config number
        char pszFileName[MAX_PATH+1];
        pszFileName[MAX_PATH] = '\0';
        unsigned int uiConfigNumber = 0;

        char* pszDOTString = strstr( pszNextTest, "_" );
        strncpy( pszFileName, pszNextTest, pszDOTString - pszNextTest );
        pszFileName[pszDOTString - pszNextTest] = '\0';

        pszDOTString += 1;
        if( 1 != sscanf( pszDOTString, "%u", &uiConfigNumber ) )
            DebugPrint( "CIndTests::StoreLatestResults():Unabled to determine config number!!\n" );

        LaunchTest( pszFileName, uiConfigNumber );
    }
}


// This should be called whenever the menu is entered or activated
void CIndTests::Enter( void )
{
    // Call the base class enter
    CMenuScreen::Enter();

    // Check to see if we are running tests
    static BOOL bProcessed = FALSE;
    if( !bProcessed )
    {
        bProcessed = TRUE;
        ProcessRunningTests();
    }
}


// Launch a test suite from a path and a Saved Game Name
HRESULT CIndTests::LaunchSuiteFromSave( const char* pszPath, const WCHAR* pwszSaveName )
{
    // Open the Saved Game and verify it exists
    char pszGamePath[MAX_PATH+1];
    pszGamePath[MAX_PATH] = '\0';
    DWORD dwResult = XCreateSaveGame( pszPath,
                                      pwszSaveName,
                                      OPEN_EXISTING,
                                      0,
                                      pszGamePath,
                                      MAX_PATH );

    if( ERROR_SUCCESS != dwResult )
    {
        DebugPrint( "CIndTests::LaunchSuiteFromSave():Failed to open the Saved Game!! Path - '%hs', Name - '%ls'\n", pszPath, pwszSaveName );

        return E_FAIL;
    }

    // Load Configs from Test Directory
    LoadSuiteConfiguration( pszGamePath );

    // Set the name of our Saved Config
    SetConfigNameInfo( (WCHAR*)pwszSaveName );

    // Launch the tests
    RunTests();

    return S_OK;
}


// Launch the test suite that is currently loaded
void CIndTests::LaunchTestSuite( void )
{
    if( E_ABORT == StoreRunningTestConfig() )
    {
        GetMessagePtr()->SetText( L"At least one test must be selected\nin order to launch the test suite." );
        GetMessagePtr()->SetBackPtr( this );
        Leave( GetMessagePtr() );

        return;
    }

    // Find out how many total tests there are to run
    m_usILoopCount = 0;
    m_usILoopMax = GetTotalNumberTestsToRunMinusGlobal();

    m_usCurrentDefConfig = 0;
    m_usTotalDefConfigs = (unsigned short)GetLauncherXBEInfo()->GetNumTestConfigs();

    // Delete the Results File from last run
    DeleteFile( gc_pszResultsFile );

    // Find the first highlighted test and launch it
    m_MenuItems.MoveFirst();
    m_XBEList.MoveFirst();
    do
    {
        if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
        {
            // Create our Test Run Information File
            char pszFileName[MAX_PATH+1];
            pszFileName[MAX_PATH] = '\0';

            _snprintf( pszFileName, MAX_PATH, "%hs_0.dat", m_XBEList.GetCurrentXBEInfoPtr()->GetFilename() );

            GenerateTestRunInfoFile( pszFileName );

            LaunchTest( m_XBEList.GetCurrentXBEInfoPtr()->GetFilename(), 0 );
        }

        m_XBEList.MoveNext();
    } while( m_MenuItems.MoveNext() );
}

// Calculate the total number of tests to run without factoring in the global config data
unsigned short CIndTests::GetTotalNumberTestsToRunMinusGlobal( void )
{
    unsigned short usReturnVal = 0;

    // Find out how many total tests there are to run
    m_MenuItems.MoveFirst();
    m_XBEList.MoveFirst();
    do
    {
        if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
        {
            usReturnVal += (unsigned short) m_XBEList.GetCurrentXBEInfoPtr()->GetNumTestConfigs();
        }
        m_XBEList.MoveNext();
    } while( m_MenuItems.MoveNext() );

    return usReturnVal;
}

// Calculate the total number of tests to run
unsigned short CIndTests::GetTotalNumberTestsToRun( void )
{
    return GetTotalNumberTestsToRunMinusGlobal() * (unsigned short)GetLauncherXBEInfo()->GetNumTestConfigs();
}


// Set the config name and path info
void CIndTests::SetConfigNameInfo( WCHAR* pwszConfigName )
{
    if( NULL == pwszConfigName )
    {
        DebugPrint( "CIndTests::SetConfigNameInfo():Invalid argument(s) passed in!!\n" );
        return;
    }

    // Clean up any memory that may already be in use
    ClearConfigNameInfo();

    m_pwszConfigName = new WCHAR[wcslen( pwszConfigName ) + 1];
    if( NULL == m_pwszConfigName )
    {
        DebugPrint( "CIndTests::SetConfigNameInfo():Unable to allocate memory for Config Name!!\n" );
        return;
    }

    // Copy the name to our member variable
    wcscpy( m_pwszConfigName, pwszConfigName );
}

void CIndTests::RunTests( void )
{
    // Don't do anything if there aren't any menu items
    if( 0 == GetNumMenuItems() )
        return;

    LaunchTestSuite();  // Launch the currently loaded Suite Configuration
}

void CIndTests::EditConfig( void )
{
    ////////////////////////////////////
    // Edit the currently selected test
    ////////////////////////////////////

    // Don't do anything if there aren't any menu items
    if( 0 == GetNumMenuItems() )
        return;

	m_TestConfigMenu.SetMenuTitle( GetHeaderFont(), m_XBEList.GetXBEInfoPtr( GetSelectedItem() )->GetTitleName() );
    m_TestConfigMenu.SetMultiConfigs( TRUE );
    m_TestConfigMenu.SetXBEInfoPtr( m_XBEList.GetXBEInfoPtr( GetSelectedItem() ) );
    Leave( &m_TestConfigMenu );
}

void CIndTests::ToggleTestSelect( void )
{
    //////////////////////////////////////
    // Toggle the currently selected item
    //////////////////////////////////////

    // Don't do anything if there aren't any menu items
    if( 0 == GetNumMenuItems() )
        return;

    UpdateMenuItem( GetSelectedItem(), m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName, !m_MenuItems.GetNode( GetSelectedItem() )->m_bHighlighted, m_MenuItems.GetNode( GetSelectedItem() )->m_bEnabled );
}


void CIndTests::ToggleTestSelectON( void )
{
    ////////////////////////////////////////
    // Select the currently highlighted item
    ////////////////////////////////////////

    // Don't do anything if there aren't any menu items
    if( 0 == GetNumMenuItems() )
        return;

    UpdateMenuItem( GetSelectedItem(), m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName, TRUE, m_MenuItems.GetNode( GetSelectedItem() )->m_bEnabled );
}


void CIndTests::DisplayResults( void )
{
    // Display the results
    Leave( &m_ResultsMenu );
}

void CIndTests::SaveSuite( void )
{
    //////////////////////////////////////////////////
    // Save Current Suite Configuration to Saved Game
    //////////////////////////////////////////////////

    // Don't do anything if there aren't any menu items
    if( 0 == GetNumMenuItems() )
        return;

    if( !ItemsHighlighted() )
    {
        GetMessagePtr()->SetText( L"At least one test must be selected\nin order to save the test suite." );
        GetMessagePtr()->SetBackPtr( this );
        Leave( GetMessagePtr() );
    }
    else
    {
        // Get the Configuration Name
        m_eCurrentAction = ENUM_INDTESTSMENU_SAVECONFIG_NAME;

        GetKeyboardPtr()->SetBackPtr( this );
        GetKeyboardPtr()->SetInfo( L"Enter the name of the Suite Config File", 40, GetConfigName() );

        Leave( GetKeyboardPtr() );
    }
}

void CIndTests::LoadSuite( void )
{
    //////////////////////////////////////
    // Load Configuration from Saved Game
    //////////////////////////////////////

    // Don't do anything if there aren't any menu items
    if( 0 == GetNumMenuItems() )
        return;

    // Get the Saved Game the user wishes to process
    m_eCurrentAction = ENUM_INDTESTSMENU_LOADCONFIG_MA_SELECT;
    GetMemAreaSelectPtr()->SetBackPtr( this );
    Leave( GetMemAreaSelectPtr() );
}


// Sets up and goes to the help menu
void CIndTests::GoToHelp( void )
{
    // Set the menu title
    WCHAR pwszTitle[50];
    pwszTitle[49] = L'\0';

    _snwprintf( pwszTitle, 49, L"%ls Info", m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName );
    GetHelpMenuPtr()->SetMenuTitle( GetHeaderFont(), pwszTitle );

    // Set the back pointer for the help menu
    GetHelpMenuPtr()->SetBackPtr( this );

    // Clear the current help
    GetHelpMenuPtr()->ClearHelpItems();

    // Populate the help menu with the text file info (if it exists)
    char pszFilePath[MAX_PATH+1];
    pszFilePath[MAX_PATH] = '\0';

    _snprintf( pszFilePath, MAX_PATH, "d:%hs\\%hs.txt", m_XBEList.GetXBEInfoPtr( GetSelectedItem() )->GetDirectory(), m_XBEList.GetXBEInfoPtr( GetSelectedItem() )->GetFilename() );

    if( FileExists( pszFilePath ) )
    {
        // Open the file
        FILE* pfInputFile = fopen( pszFilePath, "rt" );
        if( NULL == pfInputFile )
        {
            DebugPrint( "CIndTests::GoToHelp():Failed to open the input file!! - %hs\n", pszFilePath );

            return;
        }

        WCHAR pwszFileLine[MAX_PATH+1];
        pwszFileLine[MAX_PATH] = L'\0';

        while( NULL != fgetws( pwszFileLine, MAX_PATH, pfInputFile ) )
        {
            if( L'\n' == pwszFileLine[wcslen(pwszFileLine) - 1] )
                pwszFileLine[wcslen(pwszFileLine) - 1] = L'\0';

            GetHelpMenuPtr()->AddHelpItem( GetBodyFont(),
                                           pwszFileLine,
                                           GetBodyFont(),
                                           L"" );
        }

        fclose( pfInputFile );
        pfInputFile = NULL;

        // navigate to the menu
        Leave( GetHelpMenuPtr() );
    }

    /*
    m_pXBEInfo->GetCurrentTestConfig()->MoveFirstConfigItem();
    do
    {
        GetHelpMenuPtr()->AddHelpItem( GetBodyFont(),
                                       m_pXBEInfo->GetCurrentTestConfig()->GetCurrentConfigItem()->GetFieldName(),
                                       GetBodyFont(),
                                       m_pXBEInfo->GetCurrentTestConfig()->GetCurrentConfigItem()->GetHelpText() );
    } while( m_pXBEInfo->GetCurrentTestConfig()->MoveNextConfigItem() );
    */
}

// Display the menu items for the 'left' dpad button
void CIndTests::DisplayLeftMenu( void )
{
    // Clear out all screen items except the background bitmap
    unsigned int uiNumItems = m_ScreenItems.GetNumItems();
    for( unsigned int x = 1; x < uiNumItems; x++ )
    {
        m_ScreenItems.DelNode( 1 );
    }

    // Add the Right Arrow to the menu
    AddBitmapAlphaItem( "d:\\media\\images\\rightarrowbig.bmp",
                        "d:\\media\\images\\rightarrowbig_alpha.bmp",
                        (int)( m_fRightMenuAreaBoundary - m_fRightMenuAreaBorder - 19 ),
                        (int)gc_fSTATUS_TEXT_ROW1_YPOS - 7 );


	// Status Bar Column 1
	AddTextItem( GetButtonFont(), L"C",             gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_X_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Save Suite",   gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetButtonFont(), L"D",             gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_Y_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Load Suite",   gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

	// Status Bar Column 2
	AddTextItem( GetButtonFont(), L"A",             gc_fSTATUS_TEXT_COL2_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Edit Test",    gc_fSTATUS_TEXT_COL2_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"I",             gc_fSTATUS_TEXT_COL2_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_BLACK_BUTTON,   gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Select Test",  gc_fSTATUS_TEXT_COL2_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

	// Status Bar Column 3
	AddTextItem( GetButtonFont(), L"H",             gc_fSTATUS_TEXT_COL3_XPOS - 5,                       gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_BACK_BUTTON,    gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Test Info",    gc_fSTATUS_TEXT_COL3_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetButtonFont(), L"G",             gc_fSTATUS_TEXT_COL3_XPOS - 5,                       gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_START_BUTTON,   gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Run Test(s)",  gc_fSTATUS_TEXT_COL3_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
}


// Display the menu items for the 'right' dpad button
void CIndTests::DisplayRightMenu( void )
{
    // Clear out all screen items except the background bitmap
    unsigned int uiNumItems = m_ScreenItems.GetNumItems();
    for( unsigned int x = 1; x < uiNumItems; x++ )
    {
        m_ScreenItems.DelNode( 1 );
    }
	
    // Add the Left Arrow to the menu
    AddBitmapAlphaItem( "d:\\media\\images\\leftarrowbig.bmp",
                        "d:\\media\\images\\leftarrowbig_alpha.bmp",
                        (int)gc_fSTATUS_TEXT_COL1_XPOS,
                        (int)gc_fSTATUS_TEXT_ROW1_YPOS - 7 );

    // Status Bar Column 1
	AddTextItem( GetButtonFont(), L"E",                     gc_fSTATUS_TEXT_COL1_XPOS + 27,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_L_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Flash ROM",            gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST + 27, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetButtonFont(), L"F",                     gc_fSTATUS_TEXT_COL1_XPOS + 27,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_R_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Test Run Globals",     gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST + 27, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

	// Status Bar Column 2
	AddTextItem( GetButtonFont(), L"J",                     gc_fSTATUS_TEXT_COL2_XPOS + 27,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_WHITE_BUTTON,   gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Last Results",         gc_fSTATUS_TEXT_COL2_XPOS + gc_fBUTTON_WIDTH_ADJUST + 27, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
}


// Will select all of the tests, or none of the tests, depending upon current select status
void CIndTests::SelectAllOrNone( void )
{
    BOOL bAllSelected = TRUE;

    m_MenuItems.MoveFirst();
    do
    {
        if( !m_MenuItems.GetCurrentNode()->m_bHighlighted )
        {
            bAllSelected = FALSE;
            break;
        }
    } while( m_MenuItems.MoveNext() );

    // Toggle the select status
    m_MenuItems.MoveFirst();
    do
    {
        UpdateMenuItem( m_MenuItems.GetCurrentIndex(), m_MenuItems.GetCurrentNode()->m_pwszItemName, !bAllSelected, m_MenuItems.GetCurrentNode()->m_bEnabled );
    } while( m_MenuItems.MoveNext() );
}


// Reset the program to it's initial state (nothing loaded, no configs)
void CIndTests::ClearAllConfigData( void )
{
    //
    // Clear global test data (default parameters, etc)
    //

    // Clear out any existing test configurations
    GetLauncherXBEInfo()->ClearTestConfigs();

    // Add 1 global configuration based off of the default config
    CTestConfig* pTestConfig = new CTestConfig;
    if( NULL == pTestConfig )
    {
        DebugPrint( "CIndTests::ClearAllConfigData()):Failed to allocate memory!!\n");
    }
    else
    {
        *pTestConfig = *( GetLauncherXBEInfo()->GetDefaultTestConfig() );

        // Add the new test config to our current XBE
        GetLauncherXBEInfo()->AddTestConfig( pTestConfig );
    }

    // Don't do anything if there aren't any menu items
    if( 0 == GetNumMenuItems() )
        return;

    // De-Select all tests
    m_MenuItems.MoveFirst();
    do
    {
        UpdateMenuItem( m_MenuItems.GetCurrentIndex(), m_MenuItems.GetCurrentNode()->m_pwszItemName, FALSE, m_MenuItems.GetCurrentNode()->m_bEnabled );
    } while( m_MenuItems.MoveNext() );

    // Delete all configs for each test and set config 1 to the default configuration
    m_XBEList.MoveFirst();
    do
    {
        // Clear out any existing test configurations
        m_XBEList.GetCurrentXBEInfoPtr()->ClearTestConfigs();

        // Add 1 configuration based off of the default config for the test
        pTestConfig = new CTestConfig;
        if( NULL == pTestConfig )
        {
            DebugPrint( "CIndTests::ClearAllConfigData()):Failed to allocate memory!!\n");
            continue;
        }

        *pTestConfig = *( m_XBEList.GetCurrentXBEInfoPtr()->GetDefaultTestConfig() );

        // Add the new test config to our current XBE
        m_XBEList.GetCurrentXBEInfoPtr()->AddTestConfig( pTestConfig );
    } while( m_XBEList.MoveNext() );

    // Remove any loaded save name info
    if( NULL != m_pwszConfigName )
    {
        delete[] m_pwszConfigName;
        m_pwszConfigName = NULL;
    }
}

// Clear the config name and path info
void CIndTests::ClearConfigNameInfo( void )
{
    if( NULL != m_pwszConfigName )
    {
        delete[] m_pwszConfigName;
        m_pwszConfigName = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\hvslFunctions.cpp ===
#include "stdafx.h"
#include "hvslFunctions.h"

static XFONT*               g_pHeaderFont = NULL;       // Header font used by all menus
static XFONT*               g_pBodyFont = NULL;         // Body font used by all menus
static XFONT*               g_pButtonFont = NULL;       // Button font used by all menus

static CHelpMenu            g_HelpMenu;                 // Help menu (will display help for each menu)
static CKeypadMenu          g_KeypadMenu;               // Virtual Keypad (Can be used by any Menu)                            
static CKeyboardMenu        g_KeyboardMenu;             // Virtual Keyboard (Can be used by any Menu)
static CChooseSaveMenu      g_ChooseSaveMenu;           // Allows the user to select a Saved Game
static CMemAreaSelectMenu   g_MemAreaSelectMenu;        // Allows the user to select a Saved Game
static CMessageMenu         g_MessageMenu;              // Present a message to the user
static CYesNoMenu           g_YesNoMenu;                // Ask the user a YES / NO question

static CXItem*              g_pCurrentScreen = NULL;    // Pointer to the current menu object
static CXItem*              g_pPrevScreen = NULL;	    // Pointer to the previous menu object
                            
static CMemoryUnit          g_MemoryUnits[8];           // Memory Units that can be inserted, removed, etc
static DWORD                g_dwInsertedMUs;            // Tracks which MUs are inserted or removed
static BOOL                 g_bMUsChanged = TRUE;       // Tracks whether MU's have been inserted or removed

static CXBEInfo             g_LauncherXBEInfo;          // XBE Information for our test launcher


// Initialize our Menus
void InitializeMenus( void )
{
    g_HelpMenu.Init( GetBodyFont(), GetHeaderFont() );
    g_KeypadMenu.Init( GetBodyFont(), GetHeaderFont() );
    g_KeyboardMenu.Init( GetBodyFont(), GetHeaderFont() );
    g_ChooseSaveMenu.Init( GetBodyFont(), GetHeaderFont() );
    g_MemAreaSelectMenu.Init( GetBodyFont(), GetHeaderFont() );
    g_MessageMenu.Init( GetBodyFont(), GetHeaderFont() );
    g_YesNoMenu.Init( GetBodyFont(), GetHeaderFont() );
}


// Return a pointer to the YES / NO Menu
CYesNoMenu* GetYesNoPtr( void )
{
    return &g_YesNoMenu;
}


// Return a pointer to the Help Menu
CHelpMenu* GetHelpMenuPtr( void )
{
    return &g_HelpMenu;
}


// Return a pointer to the Message Menu
CMessageMenu* GetMessagePtr( void )
{
    return &g_MessageMenu;
}


// Return a pointer to the Memory Area Select Menu
CMemAreaSelectMenu* GetMemAreaSelectPtr( void )
{
    return &g_MemAreaSelectMenu;
}

// Return a pointer to the Choose Saved Game Menu
CChooseSaveMenu* GetChooseSavePtr( void )
{
	return &g_ChooseSaveMenu;
}

// Return a pointer to the Virtual Keypad
CKeypadMenu* GetKeypadPtr( void )
{
	return &g_KeypadMenu;
}

// Return a pointer to the Virtual Keyboard
CKeyboardMenu* GetKeyboardPtr( void )
{
	return &g_KeyboardMenu;
}

// Initialize our fonts
void InitializeFonts( void )
{
    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    if( FAILED( OpenTTFontFile( g_pHeaderFont, gc_pwszFONT_HEADER_FILENAME ) ) )
        DebugPrint( "Init():Failed to open the header font!! - '%ls'\n", gc_pwszFONT_HEADER_FILENAME );

    if( FAILED( OpenTTFontFile( g_pBodyFont, gc_pwszFONT_BODY_FILENAME ) ) )
        DebugPrint( "Init():Failed to open the body font!! - '%ls'\n", gc_pwszFONT_BODY_FILENAME );

    if( FAILED( OpenTTFontFile( g_pButtonFont, gc_pwszFONT_BUTTON_FILENAME ) ) )
        DebugPrint( "Init():Failed to open the button font!! - '%ls'\n", gc_pwszFONT_BODY_FILENAME );
}

// Close and clean up our fonts
void CleanupFonts( void )
{
    if( FAILED( CloseTTFont( g_pHeaderFont ) ) )
        DebugPrint( "CleanUp():Failed to close the Header Font!!\n" );

    if( FAILED( CloseTTFont( g_pBodyFont ) ) )
        DebugPrint( "CleanUp():Failed to close the Body Font!!\n" );

    if( FAILED( CloseTTFont( g_pButtonFont ) ) )
        DebugPrint( "CleanUp():Failed to close the Button Font!!\n" );
}

// Return a pointer to our Header Font
XFONT* GetHeaderFont( void )
{
    return g_pHeaderFont;
}

// Return a pointer to our Body Font
XFONT* GetBodyFont( void )
{
    return g_pBodyFont;
}

// Return a pointer to our Button Font
XFONT* GetButtonFont( void )
{
    return g_pButtonFont;
}

// Return a pointer to the current menu
CXItem* GetCurrentMenu( void )
{
    return g_pCurrentScreen;
}

// Set the current Menu
void SetCurrentMenu( CXItem* pMenuPtr )
{
    g_pCurrentScreen = pMenuPtr;

    // Make sure we call the enter function of our new menu
    GetCurrentMenu()->Enter();
}

// Return a pointer to the previous Menu
CXItem* GetPreviousMenu( void )
{
    return g_pPrevScreen;
}

// Set the previous Menu
void SetPreviousMenu( CXItem* pMenuPtr )
{
    g_pPrevScreen = pMenuPtr;
}

//////////////////////////////
// Memory Units / Areas
//////////////////////////////

// Can be used to determine if there have been any changes to our Memory Units
BOOL GetMUsChanged( void )
{
    return g_bMUsChanged;
}

// Initialize our MUs and mount any that need mounting
void InitializeMUs( void )
{
    // Initialize our Memory Units
    g_MemoryUnits[0].SetPortSlot( XDEVICE_PORT0, XDEVICE_TOP_SLOT );
    g_MemoryUnits[1].SetPortSlot( XDEVICE_PORT0, XDEVICE_BOTTOM_SLOT );
    g_MemoryUnits[2].SetPortSlot( XDEVICE_PORT1, XDEVICE_TOP_SLOT );
    g_MemoryUnits[3].SetPortSlot( XDEVICE_PORT1, XDEVICE_BOTTOM_SLOT );
    g_MemoryUnits[4].SetPortSlot( XDEVICE_PORT2, XDEVICE_TOP_SLOT );
    g_MemoryUnits[5].SetPortSlot( XDEVICE_PORT2, XDEVICE_BOTTOM_SLOT );
    g_MemoryUnits[6].SetPortSlot( XDEVICE_PORT3, XDEVICE_TOP_SLOT );
    g_MemoryUnits[7].SetPortSlot( XDEVICE_PORT3, XDEVICE_BOTTOM_SLOT );

    // Mount any MU that is inserted
    g_dwInsertedMUs = XGetDevices( XDEVICE_TYPE_MEMORY_UNIT );
    for( unsigned int x = 0; x < 8; ++x )
    {
        if( g_dwInsertedMUs & gc_dwMUBitMask[x] )
        {
            DebugPrint( "Mounting... %d\n", x );
            g_MemoryUnits[x].Mount();
        }
    }
}

// Check to see if an MU has been inserted or removed, and properly Mounts, or Dismounts the MUs
void ProcessMUs( void )
{
    DWORD dwMUInsertions;
    DWORD dwMURemovals;

    // If the state has changed, update our texture and our previous mask
    g_bMUsChanged = XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwMUInsertions, &dwMURemovals );
    if( g_bMUsChanged )
    {
        // Mount or Unmount our MU's
        for( unsigned int x = 0; x < 8; ++x )
        {
            // Check to see if the MU was removed
            if( dwMURemovals & gc_dwMUBitMask[x] )
            {
                // Remove the MU from our Mask
                g_dwInsertedMUs = g_dwInsertedMUs & ( ~ gc_dwMUBitMask[x] );

                // Unmount the MU
                g_MemoryUnits[x].Unmount();

            }

            // Check to see if the MU is inserted
            if( dwMUInsertions & gc_dwMUBitMask[x] )
            {
                // Add the MU to our Mask
                g_dwInsertedMUs = g_dwInsertedMUs | gc_dwMUBitMask[x];

                // Mount the MU
                g_MemoryUnits[x].Mount();
            }
        }
    }
}

// Get a pointer to a memory unit based on index
CMemoryUnit* GetMUPtr( unsigned int uiIndex )
{
    if( uiIndex > 8 )
        return NULL;

    return &g_MemoryUnits[uiIndex];
}

// Load configuration from a file
HRESULT LoadXBEConfigs( CXBEInfo* pXBEInfo, const char* pszLoadPath )
{
    if( NULL == pszLoadPath || NULL == pXBEInfo )
    {
        DebugPrint( "LoadXBEConfigs():Invalid argument(s) passed in!!\n" );

        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;  // Return code

    // Clear out all configurations for this XBE
    pXBEInfo->ClearTestConfigs();

    char pszFilePath[MAX_PATH+1];
    WCHAR pwszFileLine[MAX_PATH+1];
    char pszValue[MAX_PATH+1];
    WCHAR pwszVariable[64];
    WCHAR* pwszEnd = NULL;
    

    // Load each .DAT file in order (very important)
    // Must start with _0 and count up.  If there are missing numbers, it will miss them
    for( unsigned int uiConfNum = 0; uiConfNum < 1000; uiConfNum++ )
    {
        pszFilePath[MAX_PATH] = '\0';
        pwszFileLine[MAX_PATH] = L'\0';
        pszValue[MAX_PATH] = '\0';
        pwszVariable[63] = L'\0';

        // Process each config file for the specified test
        if( pszLoadPath[strlen( pszLoadPath ) - 1] != '\\' )
            sprintf( pszFilePath, "%hs\\%hs_%u.dat", pszLoadPath, pXBEInfo->GetFilename(), uiConfNum );
        else
            sprintf( pszFilePath, "%hs%hs_%u.dat", pszLoadPath, pXBEInfo->GetFilename(), uiConfNum );

        if( !FileExists( pszFilePath ) )
            break;

        // Process the file

        // Create a new test config (based on defaults) to work with
        CTestConfig* pTestConfig = new CTestConfig( *(pXBEInfo->GetDefaultTestConfig()) );
        if( NULL == pTestConfig )
        {
            DebugPrint( "LoadXBEConfigs():Unable to allocate memory!!\n" );
            hr = E_OUTOFMEMORY;

            break;
        }

        FILE* pfConfigFile = fopen( pszFilePath, "rt" );
        if( NULL == pfConfigFile )
        {
            DebugPrint( "LoadXBEConfigs():Failed to open the config file!! - '%hs'\n", pszFilePath );
            hr = E_FAIL;

            delete pTestConfig;
            pTestConfig = NULL;

            break;
        }

        /*
        // Check the version in the file
        fgetws( pwszFileLine, MAX_PATH, pfConfigFile );

        // Remove the new-line
        pwszEnd = wcschr( pwszFileLine, '\n' );
        if( pwszEnd ) *pwszEnd = L'\0';

        // Read and process the version line
        if( swscanf( pwszFileLine, L"%l63[^=]= %h255[^\0]", pwszVariable, pszValue ) != 2 )
        {
            DebugPrint( "Version was not processed!! Should be first line in the file!!\n" );

            delete pTestConfig;
            pTestConfig = NULL;

            fclose( pfConfigFile );
            pfConfigFile = NULL;

            continue;
        }
        else
        {
            if( ( 0 != _wcsicmp( pwszVariable, L"version" ) ) ||
                ( pTestConfig->GetConfigVersion() != atol( pszValue ) ) )
            {
                DebugPrint( "Version was not processed!! Should be first line in the file!!\n" );

                delete pTestConfig;
                pTestConfig = NULL;

                fclose( pfConfigFile );
                pfConfigFile = NULL;

                continue;
            }
        }
        */

        // Process each line of the file, storing the new value
        while( NULL != fgetws( pwszFileLine, MAX_PATH, pfConfigFile ) )
        {
            // DebugPrint( "pwszFileLine - '%ls'\n", pwszFileLine );

            // Remove the new-line
            pwszEnd = wcschr( pwszFileLine, '\n' );
            if( pwszEnd ) *pwszEnd = L'\0';

            // Make sure we have a vaild data line
            if( !( ( pwszFileLine[0] > L'0' && pwszFileLine[0] < L'9' ) ||
                   ( pwszFileLine[0] > L'A' && pwszFileLine[0] < L'Z' ) ||
                   ( pwszFileLine[0] > L'a' && pwszFileLine[0] < L'z' ) ) )
                continue;

            // Remove any comments that might be in the line
            WCHAR* pwszC = wcschr( pwszFileLine, ';' );
            if( NULL != pwszC ) *pwszC = L'\0';
            pwszC = wcschr( pwszFileLine, L'[' );
            if( NULL != pwszC ) *pwszC = L'\0';

            RightTrim( pwszFileLine );

            // Process the file line
            pwszVariable[0] = L'\0';
            pszValue[0] = '\0';
            if( swscanf( pwszFileLine, L"%l63[^=]= %h255[^\0]", pwszVariable, pszValue ) == 0 )
            {
                DebugPrint( "Unable to process the current file line!! - '%ls'\n", pwszFileLine );

                continue;
            }

            RightTrim( pwszVariable );

            // DebugPrint( "pwszVariable - '%ls' = '%hs'\n", pwszVariable, pszValue );
            
            // Check our current values
            pTestConfig->MoveFirstConfigItem();
            do
            {
                // Check to see if we've already processed this item.  If so, skip it
                if( pTestConfig->GetCurrentConfigItem()->GetProcessed() )
                    continue;

                // If we find the item, process it
                if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetFieldName(), pwszVariable ) )
                {
                    if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"number" ) )
                    {
                        CConfigNumber* pConfigNumber = (CConfigNumber*)pTestConfig->GetCurrentConfigItem();

                        pConfigNumber->ProcessValue( pszValue );
                    }
                    else if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"range" ) )
                    {
                        CConfigRange* pConfigRange = (CConfigRange*)pTestConfig->GetCurrentConfigItem();

                        pConfigRange->ProcessValue( pszValue );
                    }
                    else if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"string" ) )
                    {
                        CConfigString* pConfigString = (CConfigString*)pTestConfig->GetCurrentConfigItem();

                        pConfigString->ProcessValue( pszValue );
                    }
                    else if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"string2" ) )
                    {
                        CConfigString2* pConfigString2 = (CConfigString2*)pTestConfig->GetCurrentConfigItem();

                        pConfigString2->ProcessValue( pszValue );
                    }
                    else if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"numberstring" ) )
                    {
                        CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pTestConfig->GetCurrentConfigItem();

                        pConfigNumberString->ProcessValue( pszValue );
                    }

                    break;
                }
            } while( pTestConfig->MoveNextConfigItem() );
        }

        // Close our file
        fclose( pfConfigFile );
        pfConfigFile = NULL;

        // Add our test config to our XBE
        pXBEInfo->AddTestConfig( pTestConfig );
    }

    // Check to see if we have added any configs.  If not, add a default
    if( uiConfNum == 0 )
    {
        // Create a New Test Config with the defaults to store in our XBE Object
        CTestConfig* pTestConfig = new CTestConfig( *(pXBEInfo->GetDefaultTestConfig()) );
        if( NULL == pTestConfig )
        {
            DebugPrint( "LoadXBEConfigs():Unable to allocate memory!!\n" );

            return E_OUTOFMEMORY;
        }
        
        pXBEInfo->AddTestConfig( pTestConfig );
    }

    return hr;
}


// Save the current XBE configuration to a .DAT file
HRESULT SaveXBEConfigs( CXBEInfo* pXBEInfo, const char* pszSavePath )
{
    if( NULL == pXBEInfo || NULL == pszSavePath )
    {
        DebugPrint( "SaveXBEConfigs():Invalid argument(s) passed in!!\n" );

        return E_INVALIDARG;
    }

    char pszFilePath[MAX_PATH+1];
    pszFilePath[MAX_PATH] = '\0';

    // DebugPrint( "SaveXBEConfigs():pXBEInfo->pszFilename - '%hs'\n", pXBEInfo->pszFilename );

    // For each configuration, create a separate file
    for( unsigned int x = 0; x < pXBEInfo->GetNumTestConfigs(); x++ )
    {
        // Dump Save Configuration
        if( pszSavePath[strlen(pszSavePath) - 1] != '\\' )
            sprintf( pszFilePath, "%s\\%s_%u.dat", pszSavePath, pXBEInfo->GetFilename(), x );
        else
            sprintf( pszFilePath, "%s%s_%u.dat", pszSavePath, pXBEInfo->GetFilename(), x );

        FILE* pfConfigFile = fopen( pszFilePath, "wt" );
        if( NULL == pfConfigFile )
        {
            DebugPrint( "SaveXBEConfigs():Failed to create the config file!! - '%hs'\n", pszFilePath );

            continue;
        }

        // Write the version
        if( fprintf( pfConfigFile, ";Version=%ld\n", pXBEInfo->GetDefaultTestConfig()->GetConfigVersion() ) < 0 )
            DebugPrint( "SaveXBEConfigs():Failed to write the version!! Version - '%ld'\n", pXBEInfo->GetDefaultTestConfig()->GetConfigVersion() );

        // For each Test Config, write it out to the file
        pXBEInfo->MoveToTestConfig( x );
        CTestConfig* pTestConfig = pXBEInfo->GetCurrentTestConfig();
        pTestConfig->MoveFirstConfigItem();
        do
        {
            if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"number" ) )
            {
                CConfigNumber* pConfigNumber = (CConfigNumber*)pTestConfig->GetCurrentConfigItem();

                if( fprintf( pfConfigFile, "%ls=%ld\t\t;%ls\n", pConfigNumber->GetFieldName(),
                                                                pConfigNumber->GetDefault(),
                                                                pConfigNumber->GetHelpText() ) < 0 )
                    DebugPrint( "SaveXBEConfigs():Failed to write the number!!\n" );
            }
            else if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"range" ) )
            {
                CConfigRange* pConfigRange = (CConfigRange*)pTestConfig->GetCurrentConfigItem();

                if( fprintf( pfConfigFile, "%ls=%ld-%ld\t\t;%ls\n", pConfigRange->GetFieldName(),
                                                                    pConfigRange->GetDefault1(),
                                                                    pConfigRange->GetDefault2(),
                                                                    pConfigRange->GetHelpText() ) < 0 )
                    DebugPrint( "SaveXBEConfigs():Failed to write the range!!\n" );
            }
            else if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"string" ) )
            {
                CConfigString* pConfigString = (CConfigString*)pTestConfig->GetCurrentConfigItem();

                if( fprintf( pfConfigFile, "%ls=%ls\t\t;%ls\n", pConfigString->GetFieldName(),
                                                                pConfigString->GetCurrentString(),
                                                                pConfigString->GetHelpText() ) < 0 )
                    DebugPrint( "SaveXBEConfigs():Failed to write the string!!\n" );
            }
            else if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"string2" ) )
            {
                CConfigString2* pConfigString2 = (CConfigString2*)pTestConfig->GetCurrentConfigItem();

                if( fprintf( pfConfigFile, "%ls=%ls\t\t;%ls\n", pConfigString2->GetFieldName(),
                                                                pConfigString2->GetString(),
                                                                pConfigString2->GetHelpText() ) < 0 )
                    DebugPrint( "SaveXBEConfigs():Failed to write the string2!!\n" );
            }
            else if( 0 == _wcsicmp( pTestConfig->GetCurrentConfigItem()->GetType(), L"numberstring" ) )
            {
                CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pTestConfig->GetCurrentConfigItem();

                if( fprintf( pfConfigFile, "%ls=%ld %ls\t\t;%ls\n", pConfigNumberString->GetFieldName(),
                                                                    pConfigNumberString->GetDefault(),
                                                                    pConfigNumberString->GetCurrentString(),
                                                                    pConfigNumberString->GetHelpText() ) < 0 )
                    DebugPrint( "SaveXBEConfigs():Failed to write the numberstring!!\n" );
            }
        } while( pTestConfig->MoveNextConfigItem() );

        fclose( pfConfigFile );
        pfConfigFile = NULL;
    }

    return S_OK;
}


// Will return TRUE if a file exists, otherise FALSE
BOOL FileExists( const char* pszFileName )
{
    if( NULL == pszFileName )
    {
        DebugPrint( "CMemoryArea::FileExists():Invalid parameter passed in!!\n" );

        return FALSE;
    }

    BOOL bReturn = FALSE;

    // Attempt to open the file to see if the file exists
    HANDLE hFile = CreateFile( pszFileName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL );

    if( INVALID_HANDLE_VALUE == hFile )
    {
        if( ( ERROR_FILE_NOT_FOUND != GetLastError() ) && ( ERROR_NOT_READY != GetLastError() ) && ( ERROR_PATH_NOT_FOUND != GetLastError() ) )
            DebugPrint( "CMemoryArea::FileExists():CreateFile failed!! - '%s', '0x%.8X (%d)'", pszFileName, GetLastError(), GetLastError() );
    }
    else
    {
        bReturn = TRUE;

        CloseHandle( hFile );
        hFile = NULL;
    }

    return bReturn;
}


// Delete a directory and all files within
BOOL DeleteDirectory( const char* pszPath )
{
    // DO NOT use a trailing slash

    char pszBuf[MAX_PATH+1];
    ZeroMemory( pszBuf, MAX_PATH+1 );

    sprintf( pszBuf, "%s\\*.*", pszPath );

    WIN32_FIND_DATA fd;
    HANDLE h = FindFirstFile( pszBuf, &fd );
    if ( h != INVALID_HANDLE_VALUE )
    //
    // Valid handle value -- There must be files or sub-directories
    //
    {
        do
        {
            // Skip over "." and ".." directories
            // BUGBUG: Skip over Dash directories on the TDATA drive
            // BUGBUG: We should NOT skip these while we are in the launcher -- We can allow ALL data to be nuked
            // if ( ( fd.cFileName[0] == '.' ) ||
            //      ( ( strcmp( fd.cFileName, FILE_DATA_XDASH_TITLEID  ) == 0 ) && ( FILE_DATA_TDATA_DRIVE_LETTER_A == pszPath[0] ) ) )

            if( fd.cFileName[0] == '.' )
                continue;

            _snprintf( pszBuf, MAX_PATH, "%s\\%s", pszPath, fd.cFileName );

            if ( ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
                if ( !DeleteDirectory( pszBuf ) )
                    return FALSE;
            }
            else
            {
                if ( !DeleteFile( pszBuf ) )
                    return FALSE;
            }
        }
        while ( FindNextFile( h, &fd ) );

        FindClose( h );
        h = NULL;
    }
    else
    //
    // Invalid handle value -- FindFirstFile failed!
    //
    {
        // If we didn't find a file, the directory is already deleted!
        if( ERROR_FILE_NOT_FOUND != GetLastError() )
            DebugPrint( "DeleteDirectory():FindFirstFile Failed - '%s', Error - '0x%.8X (%d)'", pszBuf, GetLastError(), GetLastError() );
    }

    BOOL fReturn;

    // Check to see if we are dealing with a rool level directory
    if( ( strlen( pszPath ) == 2 ) && ( pszPath[1] == ':' ) )
        fReturn = TRUE; // Yes we are dealing with a root level directory, keep the directory
    else
        fReturn = RemoveDirectory( pszPath ) != FALSE;  // No we are not dealing with a root level directory, remove the directory

    return fReturn;
}


// Will return a scaled number
long ThumbStickScale( int iStickValue,
                      long lMinValue,
                      long lMaxValue )
{
    // Sub dead-zone
	if( iStickValue > 0 )
        iStickValue -= gc_nJOYSTICK_DEADZONE;
	else
        iStickValue += gc_nJOYSTICK_DEADZONE;

    if( abs( iStickValue ) <= lMinValue )
        return( 1 );

    if( iStickValue > 0 )
        iStickValue -= lMinValue;
    else
        iStickValue += lMinValue;

    // Divide by ( Max - Dead Zone )
    double fValue = (double)iStickValue / (double)( 32768 - gc_nJOYSTICK_DEADZONE - lMinValue );

    // Multiply by Itself
    fValue = fValue * fValue * fValue * fValue * fValue * fValue * fValue * fValue;

    // Multiply by Top end scale value
    long lReturn = (long)( fValue * (double)( lMaxValue - 1 ) ) + 1;

    return lReturn;
}


// Process a configuration file for a specific XBE
HRESULT ProcessConfigFile( CXBEInfo* pXBEInfo )
{
    if( NULL == pXBEInfo )
    {
        DebugPrint( "ProcessConfigFile():Invalid Argument passed in!!\n" );
        return E_INVALIDARG;
    }

    // Pointers to our buffers which will need clean up
    WCHAR* pwszFieldName = NULL;
    WCHAR* pwszHelpText = NULL;
    WCHAR* pwszFieldType = NULL;
    WCHAR* pwszNewValue = NULL;
    WCHAR* pwszFileLine = NULL;
    WCHAR* pwszNewString = NULL;
    FILE* pfConfigFile = NULL;

    // Open the configuration file
    
    char pszConfigFileName[MAX_PATH + 1];
    ZeroMemory( pszConfigFileName, MAX_PATH + 1 );

    _snprintf( pszConfigFileName, MAX_PATH, "d:%s\\%s.cfg", pXBEInfo->GetDirectory(), pXBEInfo->GetFilename() );
    
    pfConfigFile = fopen( pszConfigFileName, "rt" );
    if( NULL == pfConfigFile )
    {
        DebugPrint( "ProcessConfigFile():Failed to open the configuration file!! - '%s'\n", pszConfigFileName );
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    // Allocate memory to hold information from our file
    pwszFileLine = new WCHAR[g_cuiFILE_LINE_SIZE];
    if( NULL == pwszFileLine )
    {
        DebugPrint( "ProcessConfigFile():Failed to allocate memory!!\n" );
        hr = E_OUTOFMEMORY;

        goto cleanup;
    }

    CTestConfig* pDefaultConfig = pXBEInfo->GetDefaultTestConfig(); // Store a handy pointer to our defalut test config

    // Get the config version
    if( NULL == fgetws( pwszFileLine, g_cuiFILE_LINE_SIZE, pfConfigFile ) )
    {
        DebugPrint( "ProcessConfigFile():Failed to read the version file line!!\n" );
        hr = E_FAIL;

        goto cleanup;
    }
    else    // Get the version number
    {
        long lConfigVersion = 0l;

        if( swscanf( pwszFileLine, L"%ld", &lConfigVersion ) != 1 )
        {
            DebugPrint( "ProcessConfigFile():Failed to get the version!! - '%s'\n", pwszFileLine );
            hr = E_FAIL;

            goto cleanup;
        }
        pDefaultConfig->SetConfigVersion( lConfigVersion );
    }

    pwszFieldName = new WCHAR[g_cuiCONFIG_ITEM_SIZE];
    pwszHelpText = new WCHAR[g_cuiCONFIG_ITEM_SIZE];
    pwszFieldType = new WCHAR[g_cuiCONFIG_ITEM_SIZE];
    pwszNewValue = new WCHAR[g_cuiCONFIG_ITEM_SIZE];

    if( ( NULL == pwszFieldName ) || ( NULL == pwszHelpText ) || ( NULL == pwszFieldType ) || ( NULL == pwszNewValue ) )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    while( NULL != fgetws( pwszFileLine, g_cuiFILE_LINE_SIZE, pfConfigFile ) )
    {
        // Make sure we have a vaild data line
        if( !( ( pwszFileLine[0] > L'0' && pwszFileLine[0] < L'9' ) ||
               ( pwszFileLine[0] > L'A' && pwszFileLine[0] < L'Z' ) ||
               ( pwszFileLine[0] > L'a' && pwszFileLine[0] < L'z' ) ) )
            continue;

        // Remove any comments that might be in the line
        WCHAR* wc = wcschr( pwszFileLine, ';' );
        if( NULL != wc ) *wc = L'\0';
        wc = wcschr( pwszFileLine, L'[' );
        if( NULL != wc ) *wc = L'\0';

        RightTrim( pwszFileLine );

        // If we fail to parse the line, return an error
        if( swscanf( pwszFileLine, L"%[^,], \"%[^\"]\", %[^,]", pwszFieldName, pwszHelpText, pwszFieldType ) != 3 )
        {
            DebugPrint( "ProcessConfigFile():Failed to properly parse line!! - '%ls'\n", pwszFileLine );
            hr = E_FAIL;
            break;
        }

        // DebugPrint( "Name - '%ls', Help - '%ls', Type - '%ls'\n", pwszFieldName, pwszHelpText, pwszFieldType );

        // Determine what type of field we are dealing with
        if( 0 == _wcsicmp( pwszFieldType, L"number" ) )
        {
            long lDef1, lMin1, lMax1;

            if( swscanf( pwszFileLine, L"%[^,], \"%[^\"]\", %[^,], %ld, %ld, %ld", pwszFieldName, pwszHelpText, pwszFieldType, &lDef1, &lMin1, &lMax1 ) != 6 )
            {
                DebugPrint( "ProcessConfigFile():NUMBER: Failed to properly parse line!! - '%ls'\n", pwszFileLine );

                hr = E_FAIL;
                break;
            }

            CConfigNumber* pConfigNumber = new CConfigNumber;
            if( NULL == pConfigNumber )
            {
                DebugPrint( "ProcessConfigFile():NUMBER:Failed to allocate memory!!\n" );
                hr = E_OUTOFMEMORY;
                break;
            }

            pConfigNumber->UpdateItem( pwszFieldName, pwszHelpText, pwszFieldType, lDef1, lMin1, lMax1 );

            // Add this item to our list
            pDefaultConfig->AddConfigItem( (CConfigItem*)pConfigNumber );

            /*
            DebugPrint( "NUMBER: '%ls', '%ls', '%ls', DEF:'%ld', MIN:'%ld', MAX:'%ld'\n",
                pConfigNumber->GetFieldName(),
                pConfigNumber->GetHelpText(),
                pConfigNumber->GetType(),
                pConfigNumber->GetDefault(),
                pConfigNumber->GetMinimum(),
                pConfigNumber->GetMaximum() );
            */
        }
        else if( 0 == _wcsicmp( pwszFieldType, L"range" ) )
        {
            long lDef1, lDef2, lMin1, lMin2, lMax1, lMax2;

            if( swscanf( pwszFileLine, L"%[^,], \"%[^\"]\", %[^,], %ld, %ld, %ld, %ld, %ld, %ld", pwszFieldName, pwszHelpText, pwszFieldType, &lDef1, &lMin1, &lMax1, &lDef2, &lMin2, &lMax2 ) != 9 )
            {
                DebugPrint( "ProcessConfigFile():RANGE: Failed to properly parse line!! - '%ls'\n", pwszFileLine );

                hr = E_FAIL;
                break;
            }

            CConfigRange* pConfigRange = new CConfigRange;
            if( NULL == pConfigRange )
            {
                DebugPrint( "ProcessConfigFile():RANGE:Failed to allocate memory!!\n" );
                hr = E_OUTOFMEMORY;
                break;
            }

            pConfigRange->UpdateItem( pwszFieldName, pwszHelpText, pwszFieldType, lDef1, lMin1, lMax1, lDef2, lMin2, lMax2 );

            // Add this item to our list
            pDefaultConfig->AddConfigItem( (CConfigItem*)pConfigRange );

            /*
            DebugPrint( "RANGE: '%ls', '%ls', '%ls', DEF1:'%ld', MIN1:'%ld', MAX1:'%ld', DEF2:'%ld', MIN2:'%ld', MAX2:'%ld'\n",
                pConfigRange->GetFieldName(),
                pConfigRange->GetHelpText(),
                pConfigRange->GetType(),
                pConfigRange->GetDefault1(),
                pConfigRange->GetMinimum1(),
                pConfigRange->GetMaximum1(),
                pConfigRange->GetDefault2(),
                pConfigRange->GetMinimum2(),
                pConfigRange->GetMaximum2() );
            */
        }
        else if( 0 == _wcsicmp( pwszFieldType, L"string" ) )
        {
            CConfigString* pConfigString = new CConfigString;
            if( NULL == pConfigString )
            {
                DebugPrint( "ProcessConfigFile():STRING:Failed to allocate memory!!\n" );
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            // Set our field name and help text
            pConfigString->UpdateItem( pwszFieldName, pwszHelpText, pwszFieldType );
            
            // Process each string
            WCHAR* pwszCurrString = pwszFileLine + wcslen( pwszFieldName ) + wcslen( pwszHelpText ) + wcslen( pwszFieldType ) + 8;
            WCHAR* pwszSubString = NULL;
            ZeroMemory( pwszNewValue, sizeof( WCHAR ) * g_cuiCONFIG_ITEM_SIZE );
            while( pwszSubString = wcsstr( pwszCurrString, L"," ) )
            {
                lstrcpyn( pwszNewValue, pwszCurrString, pwszSubString - pwszCurrString + 1 );
                pConfigString->AddString( pwszNewValue );

                // Make sure we don't crash on bad data by checking to see if we have 2 chars to advance accross
                if( wcslen( pwszSubString ) < 2 )
                {
                    DebugPrint( "ProcessConfigFile():Improperly configured string!! - '%ls'\n", pwszSubString );

                    hr = E_FAIL;
                    goto cleanup;
                }
                
                pwszCurrString = pwszSubString + 2;
            }

            // Add the last string
            // TODO: Should we add checking here, to make sure we have a valid string?
            pConfigString->AddString( pwszCurrString );

            // Add this item to our list
            pConfigString->MoveFirstString();

            // Add the config item to our default configuration
            pDefaultConfig->AddConfigItem( (CConfigItem*)pConfigString );

            /*
            DebugPrint( "STRING: '%ls', '%ls', '%ls'",
                pConfigString->GetFieldName(),
                pConfigString->GetHelpText(),
                pConfigString->GetType() );
            
            for( unsigned int x = 0; x < pConfigString->GetNumStrings(); x++ )
            {
                DebugPrint( ", '%ls'", pConfigString->GetString( x ) );
            }
            
            DebugPrint( "\n" );
            */
        }
        else if( 0 == _wcsicmp( pwszFieldType, L"string2" ) )
        {
            pwszNewString = new WCHAR[g_cuiCONFIG_ITEM_SIZE];
            if( NULL == pwszNewString )
            {
                DebugPrint( "ProcessConfigFile():STRING2:Failed to allocate memory!!\n" );
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            int iScanFields = swscanf( pwszFileLine, L"%[^,], \"%[^\"]\", %[^,], \"%[^\"]\"", pwszFieldName, pwszHelpText, pwszFieldType, pwszNewString );

            // If it only scanned 3 fields, the last string must be empty, or not there (default to nothing)
            if( 3 == iScanFields )
            {
                pwszNewString[0] = L'\0';
            }
            else if( 4 != iScanFields ) // Make sure that if it didn't scan three fields, it scanned 4
            {
                DebugPrint( "ProcessConfigFile():STRING2: Failed to properly parse line!! - '%ls'\n", pwszFileLine );
                hr = E_FAIL;
                goto cleanup;
            }

            CConfigString2* pConfigString2 = new CConfigString2;
            if( NULL == pConfigString2 )
            {
                DebugPrint( "ProcessConfigFile():STRING2:Failed to allocate memory!!\n" );
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            // Set our field name and help text
            // TODO: Should we add checking here, to make sure we have a valid string?
            pConfigString2->UpdateItem( pwszFieldName, pwszHelpText, pwszFieldType, pwszNewString );

            // Add this item to our list
            pDefaultConfig->AddConfigItem( (CConfigItem*)pConfigString2 );

            /*
            DebugPrint( "STRING2: '%ls', '%ls', '%ls', '%ls'\n",
                pConfigString2->GetFieldName(),
                pConfigString2->GetHelpText(),
                pConfigString2->GetType(),
                pConfigString2->GetString() );
            */
        }
        else if( 0 == _wcsicmp( pwszFieldType, L"numberstring" ) )
        {
            long lDef1, lMin1, lMax1;

            if( swscanf( pwszFileLine, L"%[^,], \"%[^\"]\", %[^,], %ld, %ld, %ld", pwszFieldName, pwszHelpText, pwszFieldType, &lDef1, &lMin1, &lMax1 ) != 6 )
            {
                DebugPrint( "ProcessConfigFile():NUMBERSTRING: Failed to properly parse line!! - '%ls'\n", pwszFileLine );
                hr = E_FAIL;
                break;
            }

            CConfigNumberString* pConfigNumberString = new CConfigNumberString;
            if( NULL == pConfigNumberString )
            {
                DebugPrint( "ProcessConfigFile():NUMBERSTRING:Failed to allocate memory!!\n" );
                hr = E_OUTOFMEMORY;
                break;
            }

            // Set our field name, help text, type, and number values
            pConfigNumberString->UpdateItem( pwszFieldName, pwszHelpText, pwszFieldType, lDef1, lMin1, lMax1  );
            
            // Process each string
            WCHAR* pwszSubString = NULL;
            WCHAR* pwszCurrString = pwszFileLine +              // This will point at the first number after our identifiers
                                    wcslen( pwszFieldName ) +
                                    wcslen( pwszHelpText ) + 
                                    wcslen( pwszFieldType ) +
                                    8;

            // Find the position in the string that is after all of the numbers
            for( unsigned int x = 0; x < 3; x++ )
                pwszCurrString = wcsstr( pwszCurrString, L"," ) + 1;

            // Move the pointer ahead to so we can skip the first space after the numbers
            pwszCurrString++;

            // Process each string that is left in the line
            ZeroMemory( pwszNewValue, sizeof( WCHAR ) * g_cuiCONFIG_ITEM_SIZE );
            while( pwszSubString = wcsstr( pwszCurrString, L"," ) )
            {
                lstrcpyn( pwszNewValue, pwszCurrString, pwszSubString - pwszCurrString + 1 );
                pConfigNumberString->AddString( pwszNewValue );

                // Make sure we don't crash on bad data by checking to see if we have 2 chars to advance accross
                if( wcslen( pwszSubString ) < 2 )
                {
                    DebugPrint( "ProcessConfigFile():Improperly configured string!! - '%ls'\n", pwszSubString );
                    hr = E_FAIL;
                    goto cleanup;
                }
                
                pwszCurrString = pwszSubString + 2;
            }

            // Add the last string
            // TODO: Should we add checking here, to make sure we have a valid string?
            pConfigNumberString->AddString( pwszCurrString );

             // Add this item to our list
            pConfigNumberString->MoveFirstString();

            // Add the configuration item to our default version
            pDefaultConfig->AddConfigItem( (CConfigItem*)pConfigNumberString );

            /*
            DebugPrint( "NUMBERSTRING: '%ls', '%ls', '%ls', '%ld', '%ld', '%ld'",
                pConfigNumberString->GetFieldName(),
                pConfigNumberString->GetHelpText(),
                pConfigNumberString->GetType(),
                pConfigNumberString->GetDefault(),
                pConfigNumberString->GetMinimum(), 
                pConfigNumberString->GetMaximum() );
            
            for( unsigned int x = 0; x < pConfigNumberString->GetNumStrings(); x++ )
            {
                DebugPrint( ", '%ls'", pConfigNumberString->GetString( x ) );
            }
            
            DebugPrint( "\n" );
            */
        }
    }

cleanup:
    // Clean up our allocated memory and close our file
    if( NULL != pwszFileLine ) delete[] pwszFileLine;
    if( NULL != pwszFieldName ) delete[] pwszFieldName;
    if( NULL != pwszHelpText ) delete[] pwszHelpText;
    if( NULL != pwszFieldType ) delete[] pwszFieldType;
    if( NULL != pwszNewValue ) delete[] pwszNewValue;
    if( NULL != pwszNewString ) delete[] pwszNewString;
    if( NULL != pfConfigFile ) fclose( pfConfigFile );

    // Set all our pointers to NULL
    pwszFileLine = NULL;
    pwszFieldName = NULL;
    pwszHelpText = NULL;
    pwszFieldType = NULL;
    pwszNewValue = NULL;
    pwszNewString = NULL;
    pfConfigFile = NULL;

    return hr;
}


// Return a pointer to our HVS Launcher XBE Info object
CXBEInfo* GetLauncherXBEInfo( void )
{
    return &g_LauncherXBEInfo;
}


// Initialize the HVS Launcher Config if one exists
void InitLauncherXBEInfo( void )
{
    g_LauncherXBEInfo.SetDirectory( "" );
    g_LauncherXBEInfo.SetFilename( "default" );
    g_LauncherXBEInfo.SetFileExtension( "xbe" );
    g_LauncherXBEInfo.SetLoaded( FALSE );
    g_LauncherXBEInfo.SetTitleName( L"HVS Launcher" );

    if( FAILED( ProcessConfigFile( &g_LauncherXBEInfo ) ) )
    {
        DebugPrint( "InitLauncherXBEInfo():Failed to ProcessConfigFile()!!\n");
        g_LauncherXBEInfo.ClearTestConfigs();

        // Create a bogus Test Config so we don't crash
        CTestConfig* pTestConfig = new CTestConfig;
        if( NULL == pTestConfig )
        {
            DebugPrint( "InitLauncherXBEInfo():Failed to allocate memory!!\n");                
            return;
        }

        CConfigString2* pConfigString2 = new CConfigString2;
        if( NULL == pConfigString2 )
        {
            DebugPrint( "InitLauncherXBEInfo():Failed to allocate memory!!\n");
            delete pTestConfig;
            pTestConfig = NULL;
            return;
        }

        // Update our string and add it to our test config
        pConfigString2->UpdateItem( L"DefaultString", L"Error or no Default Config File Found", L"string2", L"This config was auto-generated" );
        pTestConfig->AddConfigItem( (CConfigItem*)pConfigString2 );

        // Add the new test config to our XBE Info for the Launcher
        g_LauncherXBEInfo.AddTestConfig( pTestConfig );
    }
    else
    {
        // Add a new test configuration based off of the default configuration for the HVS Launcher
        CTestConfig* pTestConfig = new CTestConfig;
        if( NULL == pTestConfig )
        {
            DebugPrint( "InitLauncherXBEInfo():Failed to allocate memory!!\n");                
            return;
        }

        *pTestConfig = *(g_LauncherXBEInfo.GetDefaultTestConfig());

        // Add the new test config to our XBE Info for the Launcher
        g_LauncherXBEInfo.AddTestConfig( pTestConfig );
    }

    // DebugPrint( "Num Launcher Configs - '%u'\n", g_LauncherXBEInfo.GetNumTestConfigs() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\hvslauncher.cpp ===
#include "stdafx.h"
#include "polyobject.h"
#include "udtexture.h"
#include "indtests.h"
#include "keyboardmenu.h"
#include "choosesavemenu.h"

// Forward declarations
HRESULT Init( CPolyObject* poMainRenderSurface, CUDTexture* poMainTexture );
HRESULT InitD3D( UINT uiWidth, UINT uiHeight, DWORD dwFlags );
BOOL LaunchFromSave( char* pszPath, WCHAR* pwszSaveName );
// HRESULT InitDSound( void );
HRESULT ProcessInput( USBManager* pUSBManager );
HRESULT ProcessGlobalKeySequences( USBManager* pUSBManager );
HRESULT CleanUp( void );
void DisplaySystemInfo( void );   // Sets up and goes to the help menu

// BOOL GammaFade(int startTime);
// unsigned int GetScreenWidth( void );      // Get the Width of the screen
// unsigned int GetScreenHeight( void );     // Get the Height of the screen
// void AlphaTexture( IDirect3DTexture8* pTexture, DWORD dwColor );

// Other globals
IDirect3DDevice8*      g_pD3DDevice     = NULL;         // Pointer to our Direct3D Device Object
// LPDIRECTSOUND          g_pDSound        = NULL;         // Pointer to our DirectSound Object
CXItem*                g_pRootMenu      = NULL;         // Global Pointer to our 'ROOT' menu

void _cdecl main()
{
    USBManager  oUSBManager;                // Handles all input devices for the Xbox
    CPolyObject oMainRenderSurface;         // Poly that will be used as our main render surface
    CUDTexture  oMainTexture;               // Main Texture for our menu data that all screens will render to

    if( FAILED( Init( &oMainRenderSurface, &oMainTexture ) ) )
    {
        DebugPrint( "Failed to Initialize Program!!\n" );

        return; // This is invalid on the Xbox, but if we can't init, we might as well break
    }

    // Menu's
    CIndTests oMenuIndTests;

    // Initialize Root-Menu
    oMenuIndTests.Init( GetBodyFont(), GetHeaderFont() );
    SetCurrentMenu( &oMenuIndTests );
    g_pRootMenu = &oMenuIndTests;

    // Check to see if we should launch a test
    WCHAR pwszSaveName[MAX_PATH+1];
    char pszPath[4];
    
    pszPath[3] = '\0';
    pwszSaveName[MAX_PATH] = L'\0';

    if( LaunchFromSave( pszPath, pwszSaveName ) )
    {
        // Check to see if the Suite is on an MU.  If so, try for a while before giving up
        DWORD dwGetTickCount = GetTickCount();

        while( ( GetTickCount() - dwGetTickCount ) < 2500 ) // 2.5 seconds
        {
            // Attempt to Launch the Game
            if( FAILED( oMenuIndTests.LaunchSuiteFromSave( pszPath, pwszSaveName ) ) )
                DebugPrint( "main():Failed to LaunchSuiteFromSave!! Path - '%hs', Save Name - '%ls'\n", pszPath, pwszSaveName );

            // Don't wait if it's the Hard Drive
            if( 0 == _stricmp( pszPath, "u:\\" ) )
                break;

            // Make sure we are looking for the MU's
            ProcessMUs();

            Sleep( 500 ); // 1/2 second
        }
        WCHAR pszMessage[MAX_PATH+1];
        pszMessage[MAX_PATH] = L'\0';

        _snwprintf( pszMessage, MAX_PATH, L"Unable to launch the specified configuration.\nPath = '%hs'\nConfig Name = '%ls'", pszPath, pwszSaveName );
        GetMessagePtr()->SetBackPtr( GetCurrentMenu() );
        GetMessagePtr()->SetText( pszMessage );

        SetCurrentMenu( GetMessagePtr() );
    }

    // Render Loop
	do
    {
        // Handle any global key sequences
        ProcessGlobalKeySequences( &oUSBManager );

        // Deal with our MUs (any changes)
        ProcessMUs();

        GetCurrentMenu()->Action( &oMainTexture );

		g_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, gc_dwCOLOR_BLACK, 1.0f, 0 );
		g_pD3DDevice->BeginScene();

        g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

        g_pD3DDevice->SetTexture( 0, oMainTexture.GetTexture() );
        oMainRenderSurface.Render( g_pD3DDevice );
		g_pD3DDevice->SetTexture( 0, NULL );

        g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
        g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

        g_pD3DDevice->EndScene();
		g_pD3DDevice->Present( NULL, NULL, NULL, NULL );

        // Handle any input from the user
        ProcessInput( &oUSBManager );
    } while( true );

    CleanUp();

    DebugPrint( "***** main()\n" );
}


/*
// Initialize DSound
HRESULT InitDSound( void )
{
	HRESULT hr = S_OK;

    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDSound, NULL)))
	{
        DebugPrint( "DirectSoundCreate FAILED!! Error - '0x%.08X'\n", hr );

        return hr;
	}

    return hr;
}
*/

// Initialize Direct3D
HRESULT InitD3D( UINT uiWidth, UINT uiHeight, DWORD dwFlags )
{
    // Check to see if we are already initialized, and if so, release
    // the previous object
    if( NULL != g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

    IDirect3D8* pD3D;
    HRESULT hr = S_OK;

    // Create our Direct3D Object
    if( NULL == ( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
    {
        DebugPrint( "InitD3D():Failed to create our D3D Object!!\n" );

        return E_FAIL;
    }

    // Always do interlaced output on an HDTV.
    if( XGetAVPack() == XC_AV_PACK_HDTV )
    {
        dwFlags |= D3DPRESENTFLAG_INTERLACED;
    }

	// Create our D3D Device Object
	D3DPRESENT_PARAMETERS d3dpp;
	ZeroMemory( &d3dpp, sizeof( d3dpp ) );
	
	d3dpp.BackBufferWidth                 = uiWidth;    // SCREEN_WIDTH;
	d3dpp.BackBufferHeight                = uiHeight;   // SCREEN_HEIGHT;
	d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    if( uiWidth <= 1280 )
    {
        d3dpp.MultiSampleType             = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN; // D3DMULTISAMPLE_NONE; // D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR; // D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN; 
    }
	d3dpp.BackBufferCount                 = 1;
    d3dpp.Flags                           |= dwFlags;
	
    d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
    d3dpp.Windowed                        = FALSE;                   // Must be FALSE for Xbox
	d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.EnableAutoDepthStencil          = FALSE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE; // D3DPRESENT_INTERVAL_DEFAULT;
    
  	if ( FAILED ( hr = pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                           D3DDEVTYPE_HAL,
                                           NULL,
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                           &d3dpp,
                                           &g_pD3DDevice ) ) )
	{
		DebugPrint( "InitD3D():Failed to create our D3D Device Object!!\n" );
	}

    D3DDevice_SetSoftDisplayFilter(TRUE);

    // Release the D3D Object
    // It's ok to simply release this object, as we know we cannot be here if the D3D Object failed creation
    pD3D->Release();
    pD3D = NULL;


    // Create our ViewPort
    D3DVIEWPORT8 D3DViewport;

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = uiWidth;   // SCREEN_WIDTH;
    D3DViewport.Height = uiHeight;  // SCREEN_HEIGHT; 
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( hr = g_pD3DDevice->SetViewport( &D3DViewport ) ) )
    {
        DebugPrint( "InitD3D():Failed to set the D3D Viewport!!\n" );
    }

	g_pD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    g_pD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    g_pD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
	g_pD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    // g_pD3DDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS , FALSE ); // Must do this to enable Edge Antialiasing
    g_pD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    g_pD3DDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);
    // g_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );
    if( uiWidth <= 1280 )
    {
        g_pD3DDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS , TRUE );
    }

	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_ANISOTROPIC );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_ANISOTROPIC );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	g_pD3DDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    return hr;
}

// Initialize our application - video, sound, etc
HRESULT Init( CPolyObject* poMainRenderSurface, CUDTexture* poMainTexture )
{
    ////////////////////////////
    // Set the File System Cache
    ////////////////////////////
    XSetFileCacheSize( gc_uiCACHE_SIZE );

    /////////////////
    // Initialize D3D
    /////////////////
    if( FAILED( InitD3D( gc_uiSCREEN_WIDTH, gc_uiSCREEN_HEIGHT, 0 ) ) )
    {
        DebugPrint( "Init():Failed to Initialize D3D!!\n" );

        _asm { int 3 };
    }

    // Initialize our Main Render Surface Polygon
    poMainRenderSurface->Initialize( g_pD3DDevice, (float)gc_uiSCREEN_WIDTH, (float)gc_uiSCREEN_HEIGHT );

    // Initial our main texture
    poMainTexture->Initialize( g_pD3DDevice, NULL, 1024, 1024 );

    ////////////////////////////////////////
    // Setup and Initialize our Default FONT
    ////////////////////////////////////////
    InitializeFonts();

    ////////////////////
    // Memory Units
    ////////////////////
    InitializeMUs();

    /*
    ////////////////////
    // Initialize DSound
    ////////////////////
    if( FAILED( InitDSound() ) )
    {
        DebugPrint( "Init():Failed to Initialize DSound!!\n" );
    }
    
    ////////////////////////
    // Initialize our Sounds
    ////////////////////////
    if( FAILED( g_Sounds.Init( g_pDSound ) ) )
    {
        DebugPrint( "Init():Failed to Initialize our Sounds!!\n" );
    }
    */

    ////////////////////////
    // Setup Menus and Items
    ////////////////////////
    InitializeMenus();

    ///////////////////////////////////////
    // Initialize our HVS Launcher XBE Info
    ///////////////////////////////////////
    InitLauncherXBEInfo();

    return S_OK;
}

// Clean up our application (close drivers, etc)
HRESULT CleanUp( void )
{
    // Clean up D3D
    if( NULL != g_pD3DDevice )
    {
        g_pD3DDevice->Release();
        g_pD3DDevice = NULL;
    }

	/*
    // Clean up DSound
    if( NULL != g_pDSound )
    {
        g_pDSound->Release();
        g_pDSound = NULL;
    }
    */

    // Clean up the Fonts
    CleanupFonts();
    
    return S_OK;
}

// Process any global key sequences
HRESULT ProcessGlobalKeySequences( USBManager* pUSBManager )
{
    if( pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER, gc_nBUTTON_THRESHOLD ) &&
        pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_RIGHT_TRIGGER, gc_nBUTTON_THRESHOLD ) &&
        pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_BLACK, gc_nBUTTON_THRESHOLD ) )
    {
        // Reboot to the XDK Launcher
        XLaunchNewImage( NULL, NULL );
    }
    else if( pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER, gc_nBUTTON_THRESHOLD ) &&
             pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_RIGHT_TRIGGER, gc_nBUTTON_THRESHOLD ) &&
             pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_WHITE, gc_nBUTTON_THRESHOLD ) )
    {
        // Display System Information
        DisplaySystemInfo();

    }

    return S_OK;
}

// Handle input from the user
HRESULT ProcessInput( USBManager* pUSBManager )
{
    BOOL bFirstPress;                   // Used to determine if one button has been pressed for the first time
    BOOL bFirstPress2;                  // Used to handle Two Buttons
    BOOL bFirstXPress;                  // Used to determine if the X Axis has been pressed for the first time
    BOOL bFirstYPress;                  // Used to determine if the Y Axis has been pressed for the first time
    BOOL bRemoteButtonPressed = FALSE;  // Used to deal with the multiple controls mappings (A/OK/START, B/BACK)
    BOOL bControlPressed = FALSE;       // Used to deal with the multiple controls mappings (A/OK/START, B/BACK)
    BOOL bButtonPressed = FALSE;        // Used to deal with the multiple controls mappings (A/OK/START, B/BACK)
    int  nThumbY = 0;
    int  nThumbX = 0;

    // Update the state of all controllers
    pUSBManager->ProcessInput();

    // START Button
    if( pUSBManager->IsControlPressed( PORT_ANY, CONTROL_START, &bFirstPress ) )
        GetCurrentMenu()->HandleInput( CONTROL_START, bFirstPress );

    // BACK Button
    if( bControlPressed = pUSBManager->IsControlPressed( PORT_ANY, CONTROL_BACK, &bFirstPress ) )
        GetCurrentMenu()->HandleInput( CONTROL_BACK, bFirstPress );

    // A BUTTON
    bButtonPressed       = pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_A, gc_nBUTTON_THRESHOLD, &bFirstPress );
    bRemoteButtonPressed = pUSBManager->IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_OK, &bFirstPress2 );
    if( bButtonPressed || bRemoteButtonPressed )
    {
        // Check to see if one of the buttons is a 'repeat' press.  If so, report FALSE for first press
        if( bButtonPressed && ( !bFirstPress ) )
            bFirstPress = FALSE;
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
            bFirstPress = FALSE;
        else
            bFirstPress = TRUE;

        GetCurrentMenu()->HandleInput( BUTTON_A, bFirstPress );
    }

    // B BUTTON
    bButtonPressed = pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_B, gc_nBUTTON_THRESHOLD, &bFirstPress );
    bRemoteButtonPressed = pUSBManager->IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_REPLAY, &bFirstPress2 );
    if( bButtonPressed || bRemoteButtonPressed )
    {
        // Check to see if one of the buttons is a 'repeat' press.  If so, report FALSE for first press
        if( bButtonPressed && ( !bFirstPress ) )
            bFirstPress = FALSE;
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
            bFirstPress = FALSE;
        else
            bFirstPress = TRUE;

        GetCurrentMenu()->HandleInput( BUTTON_B, bFirstPress );
    }

    // X MENU BUTTON
    bButtonPressed = pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_X, gc_nBUTTON_THRESHOLD, &bFirstPress );
    bRemoteButtonPressed = pUSBManager->IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_MENU, &bFirstPress2 );
    if( bButtonPressed || bRemoteButtonPressed )
    {
        if( bButtonPressed && ( !bFirstPress ) )
            bFirstPress = FALSE;
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
            bFirstPress = FALSE;
        else
            bFirstPress = TRUE;

        GetCurrentMenu()->HandleInput( BUTTON_X, bFirstPress );
    }

    // Y BUTTON
    if( pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_Y, gc_nBUTTON_THRESHOLD, &bFirstPress ) )
        GetCurrentMenu()->HandleInput( BUTTON_Y, bFirstPress );

    // BLACK BUTTON
    if( pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_BLACK, gc_nBUTTON_THRESHOLD, &bFirstPress ) )
        GetCurrentMenu()->HandleInput( BUTTON_BLACK, bFirstPress );

    // WHITE BUTTON
    if( pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_WHITE, gc_nBUTTON_THRESHOLD, &bFirstPress ) )
        GetCurrentMenu()->HandleInput( BUTTON_WHITE, bFirstPress );


    // UP DPAD
    bControlPressed = pUSBManager->IsControlPressed( PORT_ANY, CONTROL_DPAD_UP, &bFirstPress );
    bRemoteButtonPressed = pUSBManager->IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_UP, &bFirstPress2 );
    if( bControlPressed || bRemoteButtonPressed )
    {
        if( bControlPressed && ( !bFirstPress ) )
            bFirstPress = FALSE;
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
            bFirstPress = FALSE;
        else
            bFirstPress = TRUE;

        GetCurrentMenu()->HandleInput( CONTROL_DPAD_UP, bFirstPress );
    }

    // DOWN DPAD / REMOTE DOWN
    bControlPressed = pUSBManager->IsControlPressed( PORT_ANY, CONTROL_DPAD_DOWN, &bFirstPress );
    bRemoteButtonPressed = pUSBManager->IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_DOWN, &bFirstPress2 );
    if( bControlPressed || bRemoteButtonPressed )
    {
        if( bControlPressed && ( !bFirstPress ) )
            bFirstPress = FALSE;
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
            bFirstPress = FALSE;
        else
            bFirstPress = TRUE;

        GetCurrentMenu()->HandleInput( CONTROL_DPAD_DOWN, bFirstPress );
    }

    // LEFT DPAD
    bControlPressed = pUSBManager->IsControlPressed( PORT_ANY, CONTROL_DPAD_LEFT, &bFirstPress );
    bRemoteButtonPressed = pUSBManager->IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_LEFT, &bFirstPress2 );
    if( bControlPressed || bRemoteButtonPressed )
    {
        if( bControlPressed && ( !bFirstPress ) )
            bFirstPress = FALSE;
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
            bFirstPress = FALSE;
        else
            bFirstPress = TRUE;

        GetCurrentMenu()->HandleInput( CONTROL_DPAD_LEFT, bFirstPress );
    }

    // RIGHT DPAD
    bControlPressed = pUSBManager->IsControlPressed( PORT_ANY, CONTROL_DPAD_RIGHT, &bFirstPress );
    bRemoteButtonPressed = pUSBManager->IsRemoteButtonPressed( PORT_ANY, REMOTE_BUTTON_RIGHT, &bFirstPress2 );
    if( bControlPressed || bRemoteButtonPressed )
    {
        if( bControlPressed && ( !bFirstPress ) )
            bFirstPress = FALSE;
        else if( bRemoteButtonPressed && ( !bFirstPress2 ) )
            bFirstPress = FALSE;
        else
            bFirstPress = TRUE;

        GetCurrentMenu()->HandleInput( CONTROL_DPAD_RIGHT, bFirstPress );
    }

    // LEFT THUMB BUTTON
    bControlPressed = pUSBManager->IsControlPressed( PORT_ANY, CONTROL_LEFT_THUMB, &bFirstPress );
    if( bControlPressed )
        GetCurrentMenu()->HandleInput( CONTROL_LEFT_THUMB, bFirstPress );

    // RIGHT THUMB BUTTON
    bControlPressed = pUSBManager->IsControlPressed( PORT_ANY, CONTROL_RIGHT_THUMB, &bFirstPress );
    if( bControlPressed )
        GetCurrentMenu()->HandleInput( CONTROL_RIGHT_THUMB, bFirstPress );

    // LEFT TRIGGER BUTTON
    if( pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_LEFT_TRIGGER, gc_nBUTTON_THRESHOLD, &bFirstPress ) )
        GetCurrentMenu()->HandleInput( BUTTON_LEFT_TRIGGER, bFirstPress );

    // Right Trigger Button
    if( pUSBManager->IsButtonPressed( PORT_ANY, BUTTON_RIGHT_TRIGGER, gc_nBUTTON_THRESHOLD, &bFirstPress ) )
        GetCurrentMenu()->HandleInput( BUTTON_RIGHT_TRIGGER, bFirstPress );


    // LEFT THUMB STICK
    nThumbY = pUSBManager->GetJoystickY( PORT_ANY, JOYSTICK_LEFT, gc_nJOYSTICK_DEADZONE, &bFirstYPress );
    nThumbX = pUSBManager->GetJoystickX( PORT_ANY, JOYSTICK_LEFT, gc_nJOYSTICK_DEADZONE, &bFirstXPress );
    if( ( nThumbY != 0 ) || ( nThumbX != 0 ) )
        GetCurrentMenu()->HandleInput( JOYSTICK_LEFT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );
    
    // RIGHT THUMB STICK
    nThumbY = pUSBManager->GetJoystickY( PORT_ANY, JOYSTICK_RIGHT, gc_nJOYSTICK_DEADZONE, &bFirstYPress );
    nThumbX = pUSBManager->GetJoystickX( PORT_ANY, JOYSTICK_RIGHT, gc_nJOYSTICK_DEADZONE, &bFirstXPress );
    if( ( nThumbY != 0 ) || ( nThumbX != 0 ) )
        GetCurrentMenu()->HandleInput( JOYSTICK_RIGHT, nThumbY, nThumbX, bFirstYPress, bFirstXPress );

    return S_OK;
}


/*
void AlphaTexture( IDirect3DTexture8* pTexture, DWORD dwColor )
{
    D3DXCOLOR newColor = D3DXCOLOR(dwColor);

	HRESULT          hr;
	D3DSURFACE_DESC  desc;
	
	pTexture->GetLevelDesc(0, &desc);
	D3DFORMAT format = desc.Format;

    if(format == D3DFMT_LIN_A8R8G8B8)
	{	
		pTexture->GetLevelDesc(0, &desc);
		int width        = desc.Width;
		int height       = desc.Height;

		D3DLOCKED_RECT textureInfo;
		hr = pTexture->LockRect(0, &textureInfo, NULL, 0);
		if( FAILED( hr ))
		{
            DebugPrint( "AlphaTexture():Failed to lock the texture!!\n" );
		}
		
		DWORD *p = (DWORD*)textureInfo.pBits;
		DWORD counter = 0;

		D3DXCOLOR pixelColor;

		// for(int j = 0; j < (width * height); j++)
        for(int j = 0; j < (width * 22); j++)
		{
			pixelColor = D3DCOLOR(p[j]);
			pixelColor.a = pixelColor.r;  // assuming pixels are white, set alpha
			pixelColor.r = newColor.r;
			pixelColor.g = newColor.g;
			pixelColor.b = newColor.b;
			p[j] = pixelColor;
		}

		pTexture->UnlockRect(0);
		D3DXFilterTexture(pTexture, NULL, 0, D3DX_FILTER_LINEAR);
	}
	else
	{
        DebugPrint( "AlphaTexture():Invalid Texture Format!!\n" );
	}

}

// Get the current Width of the screen
unsigned int GetScreenWidth( void )
{
    D3DDISPLAYMODE  d3dDisplayMode;
    ZeroMemory( &d3dDisplayMode, sizeof( d3dDisplayMode ) );

    HRESULT hr = g_pD3DDevice->GetDisplayMode( &d3dDisplayMode );
    if( FAILED( hr ) )
    {
        DebugPrint( "GetScreenWidth():Failed to get the Display Mode!! Error - '0x%.8X (%d)'\n", hr, hr );

        return 0;
    }

    return d3dDisplayMode.Width;
}


// Get the current Height of the screen
unsigned int GetScreenHeight( void )
{
    D3DDISPLAYMODE  d3dDisplayMode;
    ZeroMemory( &d3dDisplayMode, sizeof( d3dDisplayMode ) );

    HRESULT hr = g_pD3DDevice->GetDisplayMode( &d3dDisplayMode );
    if( FAILED( hr ) )
    {
        DebugPrint( "GetScreenHeight():Failed to get the Display Mode!! Error - '0x%.8X (%d)'\n", hr, hr );

        return 0;
    }

    return d3dDisplayMode.Height;
}


#define FADE_LENGTH 5000

void SetRamp(int coefficient)
{
    int i, value;
    D3DGAMMARAMP ramp;

    for (i = 0; i < 256; i++) {
        value = i * coefficient / FADE_LENGTH;
        ramp.red[i] = (BYTE)value;
        ramp.green[i] = (BYTE)value;
        ramp.blue[i] = (BYTE)value;
    }

    IDirect3DDevice8_SetGammaRamp(g_pD3DDevice,
            D3DSGR_NO_CALIBRATION | D3DSGR_IMMEDIATE,
            &ramp);
}

BOOL GammaFade(int startTime)
{
    int delta;

    delta = GetTickCount() - startTime;

    if (delta >= FADE_LENGTH) {
        SetRamp(FADE_LENGTH);
        return FALSE;
    } else {
        SetRamp(delta);
        return TRUE;
    }
}
*/

// Launch a Test Suite from a Saved Game
BOOL LaunchFromSave( char* pszPath, WCHAR* pwszSaveName )
{
    if( NULL == pszPath || NULL == pwszSaveName )
    {
        DebugPrint( "LaunchFromSave():Invalid argument(s) passed in!!\n" );

        return FALSE;
    }

    BOOL bReturn = FALSE;

    // Check to see if we should launch a specific config
    if( FileExists( gc_pszAutoRunFile ) )
    {
        FILE* fAutoFile = fopen( gc_pszAutoRunFile, "rt" );
        if( NULL == fAutoFile )
            DebugPrint( "LaunchFromSave():Failed to open the AutoRun file!! - '%hs'\n", gc_pszAutoRunFile );
        else
        {
            if( fscanf( fAutoFile, "%3[^,], \"%l[^\"]\"", pszPath, pwszSaveName ) != 2 )
                DebugPrint( "LaunchFromSave():Failed to process the AutoRun file properly!! - '%hs'\n", gc_pszAutoRunFile );
            else
                bReturn = TRUE;
            
            fclose( fAutoFile );
            fAutoFile = NULL;

            DebugPrint( "LaunchFromSave():pszPath = '%hs', pszSaveName - '%ls'\n", pszPath, pwszSaveName );
        }

        // Delete the file to make sure we don't run the same config again
        if( !DeleteFile( gc_pszAutoRunFile ) )
        {
            DebugPrint( "LaunchFromSave():Failed to delete the AutoRun file!! - '%hs'\n", gc_pszAutoRunFile );

            bReturn = FALSE;
        }
    } 
    
    return bReturn;
}

// Sets up and goes to the help menu
void DisplaySystemInfo( void )
{
    // Set the menu title
    GetHelpMenuPtr()->SetMenuTitle( GetHeaderFont(), L"Xbox System Info" );

    // Set the back pointer for the help menu
    GetHelpMenuPtr()->SetBackPtr( g_pRootMenu );

    // Clear the current help
    GetHelpMenuPtr()->ClearHelpItems();

    // Populate the help menu with our items
    char* pszBoxInfo = NULL;
    pszBoxInfo = GetBoxInformation();

    char* pszCurrentLoc = pszBoxInfo;
    char* pszNewLinePtr = NULL;

    if( NULL != pszBoxInfo )
    {
        /*
        WCHAR pwszTempStr[MAX_PATH+1];
        pwszTempStr[MAX_PATH] = L'\0';
        */

        WCHAR pwszItemName[MAX_PATH+1];
        WCHAR pwszItemValue[MAX_PATH+1];
        pwszItemName[MAX_PATH] = L'\0';
        pwszItemValue[MAX_PATH] = L'\0';

        while( pszNewLinePtr = strstr( pszCurrentLoc, "\n" ) )
        {
            *pszNewLinePtr = '\0';
            // _snwprintf( pwszTempStr, MAX_PATH, L"%hs", pszCurrentLoc );
            
            if( sscanf( pszCurrentLoc, "%l255[^=] = %l255[^\0]", pwszItemName, pwszItemValue ) == 2 )
            {
                // Wrap on each comma/space
                WCHAR* pszCommaPtr = pwszItemValue;
                WCHAR* pwszSplit = NULL;
                WCHAR pwszWrapString[3];

                // Determine if we are dealing with Peripherals.  If so, wrap on a semi-colon
                if( 0 == _wcsicmp( pwszItemName, L"Peripherals " ) )
                    wcscpy( pwszWrapString, L"; " );
                else
                    wcscpy( pwszWrapString, L", " );

                while( pwszSplit = wcsstr( pszCommaPtr, pwszWrapString ) )
                {
                    *pwszSplit = L'\\';
                    *(pwszSplit+1) = L'n';

                    // Skip over our newly created "\n"
                    pszCommaPtr += 2;
                }

                GetHelpMenuPtr()->AddHelpItem( GetBodyFont(),
                                               pwszItemName,
                                               GetBodyFont(),
                                               pwszItemValue );
            }

            // Skip over the '\0' char we created
            pszCurrentLoc = pszNewLinePtr + 1;
        }

        delete[] pszBoxInfo;
        pszBoxInfo = NULL;
    }

    // navigate to the menu
    GetCurrentMenu()->Leave( GetHelpMenuPtr() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\key.h ===
#ifndef _KEY_H
#define _KEY_H

class CKey
{
public:
	int m_iXOrigin, m_iYOrigin;		// x,y coordinate of the key's upper left pixel
	int m_iWidth, m_iHeight;		// width and height of the key
	DWORD m_dwSelectColor;			// color to hilight the key with upon selection
	WCHAR* m_pwszResultChar;        // value attached to the key
	BOOL m_fRender;				    // should the key be rendered?

	// Constructors and Destructors
	CKey( void );
	~CKey( void );

	void define( int iX, int iY, int iW, int iH, DWORD dwColor );
	void defineText( WCHAR* pwszResult );
	void setRender( BOOL fValue );
	BOOL getRender( void );
};

#endif // _KEY_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\keyboardmenu.cpp ===
/*****************************************************
*** keyboardmenu.cpp
***
*** CPP file for our Keyboard Menu class.
***
*** by James N. Helm
*** December 6th, 2000
***
*****************************************************/

#include "stdafx.h"
#include "keyboardmenu.h"

// Constructors
CKeyboardMenu::CKeyboardMenu( void ) :
m_pwszTextString( NULL ),
m_uiLength( 0 ),
m_bCancelled( FALSE ),
m_xKeypos( gc_uiKEYBOARD_NUM_COLS - 1 ),
m_yKeypos( 0 ),
m_ucState( 0 ),
m_bShift( FALSE ),
m_bFirstPress( TRUE )
{
    ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );

    GenerateKeypad();
}


// Destructor
CKeyboardMenu::~CKeyboardMenu( void )
{
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }
}


// Initialize the Menu
HRESULT CKeyboardMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CKeyboardMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Keyboard" );

    /////////////////////////
    // Add screen items here
    /////////////////////////
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status Bar Column 1
    AddTextItem( GetButtonFont(), L"A",       gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Select", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"B",       gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Cancel", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    // Status Bar Column 2
    AddTextItem( GetButtonFont(), L"C",             gc_fSTATUS_TEXT_COL2_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_X_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Change State", gc_fSTATUS_TEXT_COL2_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

	
    return hr;
}


// Draws a menu on to the screen
void CKeyboardMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    // Lock our texture and set it as the render target
    pTexture->Lock();

	// Draw our keypad
	renderKeypad( pTexture );

	// Draw our User defined Text
    pTexture->DrawText( GetBodyFont(), (float)gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), m_pwszTextString ) / 2 ), (float)gc_uiKEYBOARD_TEXTSTRING_Y1, m_dwMenuItemEnabledFGColor, m_dwMenuItemEnabledBGColor, L"%ls", m_pwszTextString );

    // Draw the current value on to the screen
    pTexture->DrawText( GetBodyFont(), (float)gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), m_pwszValueBuffer ) / 2 ), (float)gc_uiKEYBOARD_VALUE_Y1, m_dwMenuItemHighlightedFGColor, m_dwMenuItemHighlightedBGColor, L"%ls", m_pwszValueBuffer );

    // Unlock our texture
    pTexture->Unlock();
}


// Handles input (of the CONTROLS) for the current menu
void CKeyboardMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Wrap the cursor
            if( 0 == m_yKeypos )
                m_yKeypos = gc_uiKEYBOARD_NUM_ROWS - 1;
            else // m_yKeypos > 0
                m_yKeypos--;

            for( int x = m_yKeypos; x >= 0; x-- )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( 0 != wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) ) )
                {
                    UpdateTexture();
                    m_yKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Wrap the cursor
            if( ( gc_uiKEYBOARD_NUM_ROWS - 1 ) == m_yKeypos )
                m_yKeypos = 0;
            else // m_yKeypos < ( gc_uiKEYBOARD_NUM_ROWS - 1 )
                m_yKeypos++;
            
            for( unsigned int x = m_yKeypos; x < gc_uiKEYBOARD_NUM_ROWS; x++ )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();
                    m_yKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            // Wrap the cursor
            if( 0 == m_xKeypos )
                m_xKeypos = gc_uiKEYBOARD_NUM_COLS - 1;
            else // m_xKeypos > 0
                m_xKeypos--;
            
            for( int x = m_xKeypos; x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();
                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Wrap the cursor
            if( ( gc_uiKEYBOARD_NUM_COLS - 1 ) == m_xKeypos )
                m_xKeypos = 0;
            else // m_xKeypos < ( gc_uiKEYBOARD_NUM_COLS - 1 )
                m_xKeypos++;

            for( unsigned int x = m_xKeypos; x < gc_uiKEYBOARD_NUM_COLS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();
                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_LEFT_THUMB:    // Shift
        {
            UpdateTexture();

            m_bShift = !m_bShift;

            GenerateKeypad();

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CKeyboardMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"" ) )              //backspace
			{
                m_bFirstPress = FALSE;

				int len = wcslen( m_pwszValueBuffer );
				
				if( len > 0 )
				{
                    UpdateTexture();

					m_pwszValueBuffer[len - 1] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"ok" ) )        //ok
			{
                GoBack();
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"cancel" ) )    //cancel
			{
                m_bCancelled = TRUE;

                GoBack();
			}
			else
			{
                // Ensure we don't exceed the limit of our buffer
                if( wcslen( m_pwszValueBuffer ) < m_uiLength )
                {
                    UpdateTexture();

                    if( m_bFirstPress )
                    {
                        m_bFirstPress = FALSE;
                        ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
                    }

                    if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"space" ) )    //space bar
                        wcscat( m_pwszValueBuffer, L" " );  // Space bar
                    else    // Normal character
                    {
    				    wcscat( m_pwszValueBuffer, m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar );

                        // Fix our shift state if necessary
                        if( m_bShift )
                        {
                            m_bShift = FALSE;
                            GenerateKeypad();
                        }
                    }
                }
			}

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            GoBack();

            break;
        }
    case BUTTON_X:    // State Change
        {
            UpdateTexture();

            m_ucState++;
            if( m_ucState >= ENUM_KEYBOARDSTATE_NUM_STATES )
                m_ucState = ENUM_KEYBOARDSTATE_FIRST_STATE;

            GenerateKeypad();

            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
            m_bFirstPress = FALSE;
			int len = wcslen( m_pwszValueBuffer );
			
			if( len > 0 )
			{
                UpdateTexture();

				m_pwszValueBuffer[len - 1] = L'\0';
			}

            break;
        }
    case BUTTON_BLACK:  // Space
        {
            if( m_bFirstPress )
            {
                m_bFirstPress = FALSE;
                ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
            }

            // Ensure we don't exceed the limit of an IP Address
            if( wcslen( m_pwszValueBuffer ) < m_uiLength )
            {
                UpdateTexture();
                wcscat( m_pwszValueBuffer, L" " );  // Space bar
            }

            break;
        }
    }
}


// Generate the kepad we will be using
void CKeyboardMenu::GenerateKeypad(void) 
{
	
	// First create numberpad
	int xgrid  = gc_uiKEYBOARD_NUM_COLS - 1;
	int ygrid  = gc_uiKEYBOARD_NUM_ROWS;
	int xstart = gc_uiKEYBOARD_TOPROW_X1;
	int ystart = gc_uiKEYBOARD_TOPROW_Y1;
	int width  = 32;
	int height = 32;
	int spacer = 2;
	int currentx = xstart;
	int currenty = ystart;

	WCHAR buffer[3];
    ZeroMemory( buffer, sizeof( WCHAR ) * 3 );

    unsigned short alpha = 48;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, m_dwMenuItemEnabledFGColor );
			currentx += width + spacer;
			buffer[0] = alpha;
			m_keyPad[x][y].defineText(buffer);
			alpha++;
			
            if( ENUM_KEYBOARDSTATE_SYMBOLS == m_ucState )
            {
                if( 65 == alpha )
                    alpha = 33;
                if( 48 == alpha )
                    alpha = 91;
                if( 97 == alpha )
                    alpha = 123;
            }
            else if( ENUM_KEYBOARDSTATE_UPPER_ALPHA == m_ucState )
            {
                if( 58 == alpha )
                {
                    if( m_bShift )
                        alpha = 97;
                    else
                        alpha = 65;
                }
            }
            else if( ENUM_KEYBOARDSTATE_LOWER_ALPHA == m_ucState )
            {
                if( 58 == alpha )
                {
                    if( m_bShift )
                        alpha = 65;
                    else
                        alpha = 97;
                }
            }
		}
		currentx = xstart;
		currenty += height + spacer;
	}


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = gc_uiKEYBOARD_NUM_ROWS;
	xstart = gc_uiKEYBOARD_TOPROW_X1 + 313;
	ystart = gc_uiKEYBOARD_TOPROW_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	currentx = xstart;
	currenty = ystart;

	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, m_dwMenuItemEnabledFGColor );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}
	
	m_keyPad[9][0].defineText(L"ok");
	m_keyPad[9][1].defineText(L"cancel");
	m_keyPad[9][2].defineText(L"space");
	m_keyPad[9][3].defineText(L"");

}


// Draw our keypad
BOOL CKeyboardMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for( unsigned int x = 0; x < gc_uiKEYBOARD_NUM_COLS; x++ )
	{
		for( unsigned int y = 0; y < gc_uiKEYBOARD_NUM_ROWS; y++ )
		{
			if( m_keyPad[x][y].getRender() && ( wcscmp( m_keyPad[x][y].m_pwszResultChar, L"place" ) != 0 ) )
			{
                // Lock our texture so that we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, m_dwMenuItemSelectorColor );
                    
                    dwCharColor = m_dwSelectedItemFGColor;
                }
                else
                {
                    dwCharColor = m_dwMenuItemEnabledFGColor;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, gc_fKEYBOARD_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( GetBodyFont(), &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( GetBodyFont(), m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				
                pTexture->DrawText( GetBodyFont(), textX, textY, dwCharColor, m_dwMenuItemEnabledBGColor, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// This will be called whenever this menu is entered / activated
void CKeyboardMenu::Enter( void )
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Default the focus to the OK Button
	m_xKeypos = gc_uiKEYBOARD_NUM_COLS - 1;
    m_yKeypos = 0;

    // Make sure our cancelled option is set to FALSE
    m_bCancelled = FALSE;

    // Put the keyboard in it's original state
    m_bFirstPress = TRUE;
    m_bShift = FALSE;
    m_ucState = ENUM_KEYBOARDSTATE_FIRST_STATE;
    GenerateKeypad();
}


// This should be called before the Keyboard is invoked
HRESULT CKeyboardMenu::SetInfo( WCHAR* pwszTextString, unsigned int uiLength, WCHAR* pwszValueDefault/*=NULL*/ )
{
    if( NULL == pwszTextString )
    {
        DebugPrint( "CKeyboardMenu::SetInfo():Invalid argument passed in!!\n" );

        return E_INVALIDARG;
    }

    if( NULL != m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }

    m_pwszTextString = new WCHAR[wcslen(pwszTextString)+1];
    wcscpy( m_pwszTextString, pwszTextString );

    // Set the length of the string
    // TODO: Check to make sure it will fit in the buffer!!
    m_uiLength = uiLength;

    // Copy the default value (if any) in to our value buffer
    if( NULL != pwszValueDefault )
        wcsncpy( m_pwszValueBuffer, pwszValueDefault, MAX_PATH );
    else
        m_pwszValueBuffer[0] = L'\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\memareaselectmenu.cpp ===
/*****************************************************
*** memareaselectmenu.cpp
***
*** CPP file for our Memory Area Select Menu class.
*** This menu will allow the user to select from one
*** of the 9 available Memory Areas
***
*** by James N. Helm
*** November 30th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "memareaselectmenu.h"

// Constructors and Destructor
CMemAreaSelectMenu::CMemAreaSelectMenu( void ) :
m_bCancelled( FALSE )
{
}

CMemAreaSelectMenu::~CMemAreaSelectMenu( void )
{
}

// Initialize the Menu
HRESULT CMemAreaSelectMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CMemAreaSelectMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Select Memory Area" );

    // Add screen items here
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status Bar Column 1
    AddTextItem( GetButtonFont(), L"A",              gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Select",        gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"B",              gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Back / Cancel", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
	
    return hr;
}

// Draws a menu on to the screen
void CMemAreaSelectMenu::Action( CUDTexture* pTexture )
{
    if( GetMUsChanged() )
        UpdateMenuItems();

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );
}

// Handles input (of the BUTTONS) for the current menu
void CMemAreaSelectMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            GoBack();

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            GoBack();

            break;
        }
    }
}


// This should be called whenever the menu is entered or activated
void CMemAreaSelectMenu::Enter( void )
{
    // Base class Enter
    CMenuScreen::Enter();

    // Make sure our cancelled state is set correctly
    m_bCancelled = FALSE;

    // Update our menu items
    UpdateMenuItems();
}


// Update the menu items on our screen
void CMemAreaSelectMenu::UpdateMenuItems( void )
{
    ClearMenuItems();

    // Add the menu items (Memory Areas) to our Menu
    AddMenuItem( GetBodyFont(), L"Xbox Hard Disk", FALSE, TRUE, 8 );

    for( unsigned int x = 0; x < 8; x++ )
    {
        if( GetMUPtr( x )->IsMounted() )
            AddMenuItem( GetBodyFont(), GetMUPtr( x )->GetDefaultName(), FALSE, TRUE, x );
    }

    UpdateTexture();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\keypadmenu.h ===
/*****************************************************
*** keypadmenu.h
***
*** Header file for our Kaypad Menu class.
***
*** by James N. Helm
*** December 18th, 2001
***
*****************************************************/

#ifndef _KEYPADMENU_H_
#define _KEYPADMENU_H_

const unsigned int gc_uiKEYPAD_NUM_ROWS =         4;
const unsigned int gc_uiKEYPAD_NUM_COLS =         4;

const unsigned int gc_uiKEYPAD_TOPROW_Y1 =        200;
const unsigned int gc_uiKEYPAD_TOPROW_X1 =        205;

const unsigned int gc_uiKEYPAD_TEXTSTRING_Y1 =    140;
const unsigned int gc_uiKEYPAD_VALUE_Y1 =         165;

const float gc_fKEYPAD_LINE_WIDTH =               1.0f;

#include "menuscreen.h"  // Base menu type
#include "key.h"

class CKeypadMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CKeypadMenu( void );
    virtual ~CKeypadMenu( void );

    // Process drawing and input for a menu screen
    virtual void Enter( void );   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

    virtual HRESULT Init( XFONT* pMenuItemFont,             // Initialize the Menu
                          XFONT* pMenuTitleFont );

    HRESULT SetInfo( WCHAR* pwszTextString,                 // This should be called before the Keyboard is invoked
                     unsigned int uiLength,
                     WCHAR* pwszValueDefault = NULL );

    BOOL GetCancelled( void ) { return m_bCancelled; };     // Used to determine if the user cancelled the keyboard
    WCHAR* GetValue( void ) { return m_pwszValueBuffer; };  // Return a pointer to the user entered value

protected:
    // Properties
    WCHAR*          m_pwszTextString;                                       // The string that will be displayed to the user
    WCHAR           m_pwszValueBuffer[MAX_PATH+1];                          // Will hold the information that is collected
    unsigned int    m_uiLength;                                             // Maximum size of the string to collect
    BOOL            m_bCancelled;                                           // Used to determine if the user cancelled the keyboard
	int             m_xKeypos;                                              // Current X position on the Keyboard
    int             m_yKeypos;                                              // Current Y position on the Keyboard
	CKey            m_keyPad[gc_uiKEYPAD_NUM_COLS][gc_uiKEYPAD_NUM_ROWS];   // Each Key displayed on the Keyboard
    BOOL            m_bFirstPress;                                          // Used to determine if the user has pressed a key before
	
    // Private Methods
	virtual void GenerateKeypad(void);                  // Create the keypad that will be used
	virtual BOOL renderKeypad( CUDTexture* pTexture );  // Draw the keypad on to the our texture

};

#endif // _MACHINENAMEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\memareaselectmenu.h ===
/*****************************************************
*** memareaselectmenu.h
***
*** Header file for our Memory Area Select Menu class.
*** This menu will allow the user to select from one
*** of the 9 available Memory Areas
***
*** by James N. Helm
*** November 30th, 2001
***
*****************************************************/

#ifndef _MEMAREASELECTMENU_H_
#define _MEMAREASELECTMENU_H_

#include "menuscreen.h"

class CMemAreaSelectMenu : public CMenuScreen
{
public:
    // Constructors and Destructor
    CMemAreaSelectMenu( void );
    ~CMemAreaSelectMenu( void );

    // Public Methods
    void Action( CUDTexture* pTexture );            // Draws a menu on to the screen
    HRESULT Init( XFONT* pMenuItemFont,             // Initialize the Menu
                  XFONT* pMenuTitleFont );
    void HandleInput( enum BUTTONS buttonPressed,   // Handles input (of the BUTTONS) for the current menu
                      BOOL bFirstPress );

    void Enter( void );                             // This should be called whenever the menu is entered or activated

    BOOL GetCancelled( void )                       // Will return TRUE if the user cancelled the selection
        { return m_bCancelled; };
    int GetSelectedAreaIndex( void )                // Return the index of the selected memory area (8 is Xbox Hard Disk, 0 through 7 are MUs)
        { return GetSelectedItemValue(); };
private:
    BOOL m_bCancelled;                              // Used to determine if the user cancelled the selection

    void UpdateMenuItems( void );                   // Update the menu items on our screen
};

#endif // _MEMAREASELECTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\keypadmenu.cpp ===
/*****************************************************
*** keypadmenu.cpp
***
*** CPP file for our Kaypad Menu class.
***
*** by James N. Helm
*** December 18th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "keypadmenu.h"

// Constructors
CKeypadMenu::CKeypadMenu( void ) :
m_pwszTextString( NULL ),
m_uiLength( 0 ),
m_bCancelled( FALSE ),
m_xKeypos( gc_uiKEYPAD_NUM_COLS - 1 ),
m_yKeypos( 0 ),
m_bFirstPress( TRUE )
{
    ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );

    GenerateKeypad();
}


// Destructor
CKeypadMenu::~CKeypadMenu( void )
{
    if( m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }
}


// Initialize the Menu
HRESULT CKeypadMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CKeypadMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Keypad" );

    /////////////////////////
    // Add screen items here
    /////////////////////////
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status Bar Column 1
    AddTextItem( GetButtonFont(), L"A",       gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Select", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"B",       gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Cancel", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
	
    return hr;
}


// Draws a menu on to the screen
void CKeypadMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    // Lock our texture and set it as the render target
    pTexture->Lock();

	// Draw our keypad
	renderKeypad( pTexture );

	// Draw our User defined Text
    pTexture->DrawText( GetBodyFont(), (float)gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), m_pwszTextString ) / 2 ), (float)gc_uiKEYPAD_TEXTSTRING_Y1, m_dwMenuItemEnabledFGColor, m_dwMenuItemEnabledBGColor, L"%ls", m_pwszTextString );

    // Draw the current value on to the screen
    pTexture->DrawText( GetBodyFont(), (float)gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), m_pwszValueBuffer ) / 2 ), (float)gc_uiKEYPAD_VALUE_Y1, m_dwMenuItemHighlightedFGColor, m_dwMenuItemHighlightedBGColor, L"%ls", m_pwszValueBuffer );

    // Unlock our texture
    pTexture->Unlock();
}


// Handles input (of the CONTROLS) for the current menu
void CKeypadMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Wrap the cursor
            if( 0 == m_yKeypos )
                m_yKeypos = gc_uiKEYPAD_NUM_ROWS - 1;
            else // m_yKeypos > 0
                m_yKeypos--;

            for( int x = m_yKeypos; x >= 0; x-- )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( 0 != wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) ) )
                {
                    UpdateTexture();
                    m_yKeypos = x;

                    break;
                }
                else if( 0 == x )
                {
                    x = gc_uiKEYPAD_NUM_ROWS;
                }
            }

            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Wrap the cursor
            if( ( gc_uiKEYPAD_NUM_ROWS - 1 ) == m_yKeypos )
                m_yKeypos = 0;
            else // m_yKeypos < ( gc_uiKEYPAD_NUM_ROWS - 1 )
                m_yKeypos++;
            
            for( unsigned int x = m_yKeypos; x < gc_uiKEYPAD_NUM_ROWS; x++ )
            {
                if( m_keyPad[m_xKeypos][x].getRender() && ( wcscmp( m_keyPad[m_xKeypos][x].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();
                    m_yKeypos = x;

                    break;
                }
                else if( ( gc_uiKEYPAD_NUM_ROWS - 1 ) == x )
                {
                    x = -1;
                }
            }

            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            // Wrap the cursor
            if( 0 == m_xKeypos )
                m_xKeypos = gc_uiKEYPAD_NUM_COLS - 1;
            else // m_xKeypos > 0
                m_xKeypos--;
            
            for( int x = m_xKeypos; x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();
                    m_xKeypos = x;

                    break;
                }
                else if( 0 == x )
                {
                    x = gc_uiKEYPAD_NUM_COLS;
                }
            }

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Wrap the cursor
            if( ( gc_uiKEYPAD_NUM_COLS - 1 ) == m_xKeypos )
                m_xKeypos = 0;
            else // m_xKeypos < ( gc_uiKEYPAD_NUM_COLS - 1 )
                m_xKeypos++;

            for( unsigned int x = m_xKeypos; x < gc_uiKEYPAD_NUM_COLS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();
                    m_xKeypos = x;

                    break;
                }
                else if( ( gc_uiKEYPAD_NUM_COLS - 1 ) == x )
                {
                    x = -1;
                }
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CKeypadMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
			// Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"" ) )              //backspace
			{
                m_bFirstPress = FALSE;
				int len = wcslen( m_pwszValueBuffer );
				
				if( len > 0 )
				{
                    UpdateTexture();

					m_pwszValueBuffer[len - 1] = L'\0';
				}
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"ok" ) )        //ok
			{
                GoBack();
			}
			else if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"cancel" ) )    //cancel
			{
                m_bCancelled = TRUE;

                GoBack();
			}
			else
			{
                // Ensure we don't exceed the limit of our buffer
                if( wcslen( m_pwszValueBuffer ) < m_uiLength )
                {
                    UpdateTexture();

                    // If it's the first press, clear the text value
                    if( m_bFirstPress )
                    {
                        m_bFirstPress = FALSE;
                        ZeroMemory( m_pwszValueBuffer, sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
                    }

                    if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"space" ) )    //space bar
                        wcscat( m_pwszValueBuffer, L" " );  // Space bar
                    else    // Normal character
                    {
    				    wcscat( m_pwszValueBuffer, m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar );
                    }
                }
			}

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;

            GoBack();

            break;
        }
    case BUTTON_WHITE:  // Backspace
        {
            m_bFirstPress = FALSE;
			int len = wcslen( m_pwszValueBuffer );
			
			if( len > 0 )
			{
                UpdateTexture();

				m_pwszValueBuffer[len - 1] = L'\0';
			}

            break;
        }
    /*
    case BUTTON_BLACK:  // Space
        {
            // Ensure we don't exceed the limit of an IP Address
            if( wcslen( m_pwszValueBuffer ) < m_uiLength )
            {
                UpdateTexture();
                wcscat( m_pwszValueBuffer, L" " );  // Space bar
            }

            break;
        }
    */
    }
}


// Generate the kepad we will be using
void CKeypadMenu::GenerateKeypad(void) 
{
	
	// First create numberpad
	int xgrid  = gc_uiKEYPAD_NUM_COLS - 1;
	int ygrid  = gc_uiKEYPAD_NUM_ROWS;
	int xstart = gc_uiKEYPAD_TOPROW_X1;
	int ystart = gc_uiKEYPAD_TOPROW_Y1;
	int width  = 32;
	int height = 32;
	int spacer = 2;
	int currentx = xstart;
	int currenty = ystart;

	WCHAR buffer[3];
    ZeroMemory( buffer, sizeof( WCHAR ) * 3 );

    unsigned short alpha = 49;

	for(int y = 0; y < ygrid; y++)
	{
		for(int x = 0; x < xgrid; x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, m_dwMenuItemEnabledFGColor );
			currentx += width + spacer;
			buffer[0] = alpha;
			m_keyPad[x][y].defineText(buffer);
			alpha++;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    m_keyPad[0][3].defineText(L"place");
    m_keyPad[1][3].defineText(L"0");
    m_keyPad[2][3].defineText(L"place");


	// Second generate larger buttons
	int xbase  = xgrid;
	xgrid  = 1;
	ygrid  = gc_uiKEYPAD_NUM_ROWS;
	xstart = gc_uiKEYPAD_TOPROW_X1 + 125;
	ystart = gc_uiKEYPAD_TOPROW_Y1;
	width  = 103;
	height = 32;
	spacer = 2;
	currentx = xstart;
	currenty = ystart;

	for(y = 0; y < ygrid; y++)
	{
		for(int x = xbase; x < (xbase + xgrid); x++)
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, m_dwMenuItemEnabledFGColor );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}
	
	m_keyPad[gc_uiKEYPAD_NUM_COLS - 1][0].defineText(L"ok");
	m_keyPad[gc_uiKEYPAD_NUM_COLS - 1][1].defineText(L"cancel");
	m_keyPad[gc_uiKEYPAD_NUM_COLS - 1][2].defineText(L"place");
	m_keyPad[gc_uiKEYPAD_NUM_COLS - 1][3].defineText(L"");

}


// Draw our keypad
BOOL CKeypadMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for( unsigned int x = 0; x < gc_uiKEYPAD_NUM_COLS; x++ )
	{
		for( unsigned int y = 0; y < gc_uiKEYPAD_NUM_ROWS; y++ )
		{
			if( m_keyPad[x][y].getRender() && ( wcscmp( m_keyPad[x][y].m_pwszResultChar, L"place" ) != 0 ) )
			{
                // Lock our texture so that we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, m_dwMenuItemSelectorColor );
                    
                    dwCharColor = m_dwSelectedItemFGColor;
                }
                else
                {
                    dwCharColor = m_dwMenuItemEnabledFGColor;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, gc_fKEYPAD_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( GetBodyFont(), &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( GetBodyFont(), m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				
                pTexture->DrawText( GetBodyFont(), textX, textY, dwCharColor, m_dwMenuItemEnabledBGColor, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// This will be called whenever this menu is entered / activated
void CKeypadMenu::Enter( void )
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Default the focus to the OK Button
	m_xKeypos = gc_uiKEYPAD_NUM_COLS - 1;
    m_yKeypos = 0;

    // Make sure our cancelled option is set to FALSE
    m_bCancelled = FALSE;

    // Set the first keypress back to true
    m_bFirstPress = TRUE;
}


// This should be called before the Keyboard is invoked
HRESULT CKeypadMenu::SetInfo( WCHAR* pwszTextString, unsigned int uiLength, WCHAR* pwszValueDefault/*=NULL*/ )
{
    if( NULL == pwszTextString )
    {
        DebugPrint( "CKeypadMenu::SetInfo():Invalid argument passed in!!\n" );

        return E_INVALIDARG;
    }

    if( NULL != m_pwszTextString )
    {
        delete[] m_pwszTextString;
        m_pwszTextString = NULL;
    }

    m_pwszTextString = new WCHAR[wcslen(pwszTextString)+1];
    wcscpy( m_pwszTextString, pwszTextString );

    // Set the length of the string
    // TODO: Check to make sure it will fit in the buffer!!
    m_uiLength = uiLength;

    // Copy the default value (if any) in to our value buffer
    if( NULL != pwszValueDefault )
        wcsncpy( m_pwszValueBuffer, pwszValueDefault, MAX_PATH );
    else
        m_pwszValueBuffer[0] = L'\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\memoryunit.cpp ===
/*****************************************************
*** memoryunit.cpp
***
*** CPP file for our Memory Unit class.
*** This class will contain functions and information
*** pertaining to an Xbox Memory Unit
***
*** by James N. Helm
*** March 28th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "memoryunit.h"

// Contructors and Destructor
CMemoryUnit::CMemoryUnit( void ) :
m_cDriveLetter( '\0' ),
m_pwszDefaultName( NULL ),
m_pwszMUName( NULL ),
m_bMounted( FALSE ),
m_bFormatted( FALSE ),
m_dwPort( 0l ),
m_dwSlot( 0l )
{
    m_pszDrivePath[3] = '\0';
}


CMemoryUnit::~CMemoryUnit( void )
{
    if( NULL == m_pwszDefaultName )
    {
        delete[] m_pwszDefaultName;
        m_pwszDefaultName = NULL;
    }

    if( NULL == m_pwszMUName )
    {
        delete[] m_pwszMUName;
        m_pwszMUName = NULL;
    }
}


// Mount the Memory Unit
HRESULT CMemoryUnit::Mount( void )
{
    // If the MU is already mounted, unmount it
    if( IsMounted() )
    {
        if( FAILED( Unmount() ) )
        {
            DebugPrint( "CMemoryUnit::Mount():Failed to Unmount the MU!!\n" );

            return E_FAIL;
        }
    }

    // Mount the MU
    DWORD dwReturnVal = XMountMU( m_dwPort, m_dwSlot, &m_cDriveLetter );
    if( ERROR_SUCCESS != dwReturnVal )
    //
    // There was a problem mounting the MU
    //
    {
        // Check to see if the failure was the result of an unformatted MU
        // If so, mark this MU as Unformatted
        if( ERROR_UNRECOGNIZED_VOLUME == dwReturnVal )
        //
        // Yes, the MU was unformatted, which caused the Mount Failure
        //
        {
            DebugPrint( "CMemoryUnit::Mount():Failed to Mount the MU, it was unformatted!! - '0x%0.8X (%d)'\n", dwReturnVal, dwReturnVal );

            m_bFormatted = FALSE;
        }
        else
        //
        // There was an error trying to mount, other than "not formatted"
        //
        {
            DebugPrint( "CMemoryUnit::Mount():Failed to Mount the MU!! - '0x%0.8X (%d)'\n", dwReturnVal, dwReturnVal );
        }


        return E_FAIL;
    }
    else
    //
    // The MU was mounted successfully
    //
    {
        m_bMounted = TRUE;
        m_bFormatted = TRUE;
    }

    HRESULT hr = ProcessMountedMU();

    return hr;
}


// Unmount the Memory Unit
HRESULT CMemoryUnit::Unmount( void )
{
    // Verify the MU was mounted, if not, bail
    if( !IsMounted() )
    {
        return E_ABORT;
    }

    // Unmount the MU
    DWORD dwReturnVal = XUnmountMU( m_dwPort, m_dwSlot );
    if( ERROR_SUCCESS != dwReturnVal )
    //
    // There was a problem unmounting the MU
    //
    {
        DebugPrint( "CMemoryUnit::Unmount():Failed to Unmount the MU!! - '%X'\n", dwReturnVal );

        return E_FAIL;
    }
    else
    //
    // The MU was unmounted successfully
    {
        m_bMounted = FALSE;
        m_bFormatted = FALSE;
    }

    // Clear out the MU Name
    if( m_pwszMUName )
    {
        delete[] m_pwszMUName;
        m_pwszMUName = NULL;
    }

    // Reset the MU Drive Letter
    m_cDriveLetter = '\0';

    return S_OK;
}


// Get the total number of blocks on the Memory Area
DWORD CMemoryUnit::GetTotalBlocks( void )
{
    // Check to see if the MU is mounted, if not, return 0
    if( !IsMounted() )
    {
        DebugPrint( "CMemoryUnit::GetTotalBlocks():The MU was not mounted -- Cannot retrieve space information!!\n" );

        return 0;
    }

    DWORD dwTotalBlocks, dwFreeBlocks;

    if( FAILED( CalcSpace( &dwTotalBlocks, &dwFreeBlocks ) ) )
    {
        DebugPrint( "CMemoryUnit::GetTotalBlocks():CalcSpace failed!!\n" );
    }

    return dwTotalBlocks;
}


// Get the number of blocks that are free on the Memory Area
DWORD CMemoryUnit::GetFreeBlocks( void )
{
    // Check to see if the MU is mounted, if not, return 0
    if( !IsMounted() )
    {
        DebugPrint( "CMemoryUnit::GetFreeBlocks():The MU was not mounted -- Cannot retrieve space information!!\n" );

        return 0;
    }

    DWORD dwTotalBlocks, dwFreeBlocks;

    if( FAILED( CalcSpace( &dwTotalBlocks, &dwFreeBlocks ) ) )
    {
        DebugPrint( "CMemoryUnit::GetFreeBlocks():CalcSpace failed!!\n" );
    }

    return dwFreeBlocks;
}


// Retreives block information for the current MU
HRESULT CMemoryUnit::CalcSpace( DWORD* pdwTotalBlocks, DWORD* pdwFreeBlocks )
{
    *pdwTotalBlocks = 0;
    *pdwFreeBlocks = 0;

    ULARGE_INTEGER uliFreeBytesAvailable, uliTotalNumBytes, uliTotalNumFreeBytes;

    // Get the disk space information for the MU -- If there was a problem, return 0
    if( !GetDiskFreeSpaceEx( m_pszDrivePath, &uliFreeBytesAvailable, &uliTotalNumBytes, &uliTotalNumFreeBytes ) )
    {
        DebugPrint( "CMemoryUnit::CalcSpace():Failed to 'GetDiskFreeSpaceEx'!! - '%hs', '0x%.8X (%d)'\n", m_pszDrivePath, GetLastError(), GetLastError() );

        return E_FAIL;
    }

    // Calculate the block sizes, and store the values in our parameters
    *pdwTotalBlocks = (DWORD)( uliTotalNumBytes.QuadPart / gc_dwMEMORY_AREA_BLOCK_SIZE_IN_BYTES );
    *pdwFreeBlocks  = (DWORD)( uliTotalNumFreeBytes.QuadPart / gc_dwMEMORY_AREA_BLOCK_SIZE_IN_BYTES );

    return S_OK;
}


// Set the port and the slot this MU will be on
HRESULT CMemoryUnit::SetPortSlot( DWORD dwPort, DWORD dwSlot )
{
    // Check to make sure the parameters are withing the valid range
    if( ( dwPort < XDEVICE_PORT0 ) ||
        ( dwPort > XDEVICE_PORT3 ) ||
        ( ( dwSlot != XDEVICE_TOP_SLOT ) && ( dwSlot != XDEVICE_BOTTOM_SLOT ) ) )
    {
        DebugPrint( "CMemoryUnit::SetPortSlot():Invalid parameter!!\n" );

        return E_INVALIDARG;
    }

    // Set the default name
    if( NULL != m_pwszDefaultName )
    {
        delete[] m_pwszDefaultName;
        m_pwszDefaultName = NULL;
    }

    // We add 4 characters to fit the space, number/letter combo, and the NULL
    unsigned int uiStrLen = wcslen( gc_pwszMEMORY_UNIT_NAME_PATTERN ) + 4;
    m_pwszDefaultName = new WCHAR[uiStrLen];
    if( NULL == m_pwszDefaultName )
        DebugPrint( "Failed to set the Default Name of the MU!!\n" );
    else
        swprintf( m_pwszDefaultName, L"%ls %c%c", gc_pwszMEMORY_UNIT_NAME_PATTERN, ( dwPort + 1 ) + '0', XDEVICE_TOP_SLOT == dwSlot ? 'A' : 'B' );
    
    // DebugPrint( "CMemoryUnit::SetPortSlot():Default Name - '%ls'\n", m_pwszDefaultName );

    m_dwPort = dwPort;
    m_dwSlot = dwSlot;

    return S_OK;
}

// Used to determine if the MU is named
BOOL CMemoryUnit::IsNamed( void )
{
    if( ( NULL != m_pwszMUName ) && ( L'\0' != m_pwszMUName[0] ) )
    {
        return TRUE;
    }

    return FALSE;
}


// Get the Index of the current MU
unsigned int CMemoryUnit::GetIndex( void )
{
    return ( ( m_dwPort * 2 ) + ( m_dwSlot ) );
}


// Process a mounted MU (Get the name, etc)
HRESULT CMemoryUnit::ProcessMountedMU( void )
{
    // Create our drive path from the drive letter
    sprintf( m_pszDrivePath, "%c:\\", m_cDriveLetter );

    // Get the name of the MU
    WCHAR pwszMUName[MAX_MUNAME + 1];
    ZeroMemory( pwszMUName, sizeof( WCHAR) * MAX_MUNAME + 1 );

    DWORD dwReturnVal = XMUNameFromDriveLetter( m_cDriveLetter, pwszMUName, MAX_MUNAME );
    if( ERROR_SUCCESS != dwReturnVal )
        DebugPrint( "CMemoryUnit::ProcessMountedMU():Failed to Get the MU Name!! - '0x%.8X (%d)'\n", dwReturnVal, dwReturnVal );
    else
    //
    // We got the MU Name, let's copy it to our own memory
    //
    {
        if( NULL != m_pwszMUName )
        {
            delete[] m_pwszMUName;
            m_pwszMUName = NULL;
        }

        unsigned int uiStrLen = wcslen( pwszMUName );
        m_pwszMUName = new WCHAR[uiStrLen + 1];
        if( NULL == m_pwszMUName )
        {
            DebugPrint( "CMemoryUnit::ProcessMountedMU():Failed to Allocate Memory!!\n" );

            return E_FAIL;
        }

        wcscpy( m_pwszMUName, pwszMUName );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\keyboardmenu.h ===
/*****************************************************
*** keyboardmenu.h
***
*** Header file for our Keyboard Menu class.
*** This is a base menu type
***
*** by James N. Helm
*** December 6th, 2000
***
*****************************************************/

#ifndef _KEYBOARDMENU_H_
#define _KEYBOARDMENU_H_

const unsigned int gc_uiKEYBOARD_NUM_ROWS =         4;
const unsigned int gc_uiKEYBOARD_NUM_COLS =         10;

const unsigned int gc_uiKEYBOARD_TOPROW_Y1 =        200;
const unsigned int gc_uiKEYBOARD_TOPROW_X1 =        110;

const unsigned int gc_uiKEYBOARD_TEXTSTRING_Y1 =    140;
const unsigned int gc_uiKEYBOARD_VALUE_Y1 =         165;

const float gc_fKEYBOARD_LINE_WIDTH =               1.0f;

#include "menuscreen.h"  // Base menu type
#include "key.h"

enum KeyboardStates
{
    ENUM_KEYBOARDSTATE_FIRST_STATE = 0,

    ENUM_KEYBOARDSTATE_LOWER_ALPHA = 0,
    ENUM_KEYBOARDSTATE_UPPER_ALPHA,
    ENUM_KEYBOARDSTATE_SYMBOLS,
    
    ENUM_KEYBOARDSTATE_NUM_STATES
};

class CKeyboardMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CKeyboardMenu( void );
    virtual ~CKeyboardMenu( void );

    // Process drawing and input for a menu screen
    virtual void Enter( void );   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

    virtual HRESULT Init( XFONT* pMenuItemFont,             // Initialize the Menu
                          XFONT* pMenuTitleFont );

    HRESULT SetInfo( WCHAR* pwszTextString,                 // This should be called before the Keyboard is invoked
                     unsigned int uiLength,
                     WCHAR* pwszValueDefault = NULL );

    BOOL GetCancelled( void ) { return m_bCancelled; };     // Used to determine if the user cancelled the keyboard
    WCHAR* GetValue( void ) { return m_pwszValueBuffer; };  // Return a pointer to the user entered value

protected:
    // Properties
    WCHAR*          m_pwszTextString;                                           // The string that will be displayed to the user
    WCHAR           m_pwszValueBuffer[MAX_PATH+1];                              // Will hold the information that is collected
    unsigned int    m_uiLength;                                                 // Maximum size of the string to collect
    BOOL            m_bCancelled;                                               // Used to determine if the user cancelled the keyboard
	int             m_xKeypos;                                                  // Current X position on the Keyboard
    int             m_yKeypos;                                                  // Current Y position on the Keyboard
    unsigned char   m_ucState;                                                  // Used to determine which keys are displayed to the user
    BOOL            m_bShift;                                                   // Used to determine if the user has "shifted" the keyboard
	CKey            m_keyPad[gc_uiKEYBOARD_NUM_COLS][gc_uiKEYBOARD_NUM_ROWS];   // Each Key displayed on the Keyboard
    BOOL            m_bFirstPress;                                              // Used to determine if the user has pressed a key before
	
    // Private Methods
	virtual void GenerateKeypad(void);                  // Create the keypad that will be used
	virtual BOOL renderKeypad( CUDTexture* pTexture );  // Draw the keypad on to the our texture

};

#endif // _MACHINENAMEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\menuscreen.cpp ===
/*****************************************************
*** menuscreen.cpp
***
*** CPP file for our XShell Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
*** 
*** by James N. Helm
*** December 1st, 2000
*** 
*****************************************************/

#include "stdafx.h"
#include "menuscreen.h"

// Constructor
CMenuScreen::CMenuScreen( void )
: m_pwszMenuTitle( NULL ),
m_uiSelectedItem( 0 ),
m_uiTopItemIndex( 0 ),
m_bUpdateTexture( TRUE ),
m_bSingleList( TRUE ),
m_BackPtr( NULL ),
m_dwKeyPressDelayTimer( GetTickCount() ),
m_dwKeyPressDelayInterval( 0l ),
m_dwKeyPressInitialDelay( 0l ),
m_dwKeyPressRepeatDelay( 0l ),
m_fLeftMenuAreaBoundary( 0.0f ),
m_fTopMenuAreaBoundary( 0.0f ),
m_fRightMenuAreaBoundary( 0.0f ),
m_fBottomMenuAreaBoundary( 0.0f ),
m_fLeftMenuAreaBorder( 0.0f ),
m_fTopMenuAreaBorder( 0.0f ),
m_fRightMenuAreaBorder( 0.0f ),
m_fBottomMenuAreaBorder( 0.0f ),
m_fMenuItemVertSpace( 0.0f ),
m_fMenuItemHorizSpace( 0.0f ),
m_iUpArrowXPos( 0 ),
m_iUpArrowYPos( 0 ),
m_iDownArrowXPos( 0 ),
m_iDownArrowYPos( 0 ),
m_uiMenuItemFontHeight( 0 ),
m_uiMenuItemFontAliasLevel( 0 ),
m_fMenuItemSelectorBorder( 0.0f ),
m_dwMenuItemEnabledFGColor( 0l ),
m_dwMenuItemEnabledBGColor( 0l ),
m_dwMenuItemDisabledFGColor( 0l ),
m_dwMenuItemDisabledBGColor( 0l ),
m_dwMenuItemHighlightedFGColor( 0l ),
m_dwMenuItemHighlightedBGColor( 0l ),
m_dwSelectedItemFGColor( 0l ),
m_dwSelectedItemBGColor( 0l ),
m_dwSelectedItemHLFGColor( 0l ),
m_dwSelectedItemHLBGColor( 0l )
{
    m_ScreenItems.SetDeleteDataItem( TRUE );
    m_MenuItems.SetDeleteDataItem( TRUE );

    // Set our menu properties to the defaults
    SetMenuAreaBoundaries();
    SetMenuAreaBorders();
    SetMenuItemVertSpace();
    SetMenuItemFontProperties();
    SetMenuItemColors();
    SetMenuItemSelectedColors();
    SetMenuItemSelectorProperties();
    SetDelayIntervals();
    SetArrowPositions();

	m_UpArrow.UpdateItem( "d:\\media\\images\\uparrowsm.bmp", "d:\\media\\images\\uparrowsm_alpha.bmp", m_iUpArrowXPos, m_iUpArrowYPos );
	m_DownArrow.UpdateItem( "d:\\media\\images\\downarrowsm.bmp", "d:\\media\\images\\downarrowsm_alpha.bmp", m_iDownArrowXPos, m_iDownArrowYPos );
}


// Destructor
CMenuScreen::~CMenuScreen( void )
{
    if( NULL != m_pwszMenuTitle )
    {
        delete[] m_pwszMenuTitle;
        m_pwszMenuTitle = NULL;
    }

    // Clear out our linked lists
    ClearScreenItems();
    ClearMenuItems();
}


// Draws a menu on to the screen
void CMenuScreen::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;
    else
        m_bUpdateTexture = FALSE;

    pTexture->Lock();

    // Draw the screen items
    RenderScreenItems( pTexture );

    // Draw the screen title
    RenderMenuTitle( pTexture );

    // Render the highlighter (selector)
    RenderSelector( pTexture );
   
    // Render the Menu Items
    RenderMenuItems( pTexture );

    // Draw the display arrows
    RenderDisplayArrows( pTexture );

    pTexture->Unlock();
}


// Render the display arrows which will indicate more info off screen
void CMenuScreen::RenderDisplayArrows( CUDTexture* pTexture )
{
    // Don't render anything if we don't have any menu items
    if( 0 == GetNumMenuItems() )
        return;

    if( 0 != GetTopItemIndex() )
		m_UpArrow.Render( pTexture );

    if( GetBottomItemIndex() < ( GetNumMenuItems() - 1 ) )
		m_DownArrow.Render( pTexture );

	// Render the line if necessary
	if( ( 0 != GetTopItemIndex() ) || ( GetBottomItemIndex() < ( GetNumMenuItems() - 1 ) ) )
		pTexture->DrawLine( (float)m_iUpArrowXPos - 3, (float)m_iUpArrowYPos, (float)m_iUpArrowXPos - 3, (float)m_iDownArrowYPos + m_DownArrow.GetBitmapHeight(), 1, m_dwMenuItemEnabledFGColor );
}


// Render the menu title on to the menu
void CMenuScreen::RenderMenuTitle( CUDTexture* pTexture )
{
    // TODO: Should this be in a different place?
    // Render the App Title here
    XFONT_SetTextHeight( GetHeaderFont(), 25 );
    pTexture->DrawText( GetHeaderFont(), gc_fLEFT_MENU_AREA_BORDER, 30, gc_dwCOLOR_TEXT_YELLOW, gc_dwCOLOR_DARK_GREY, L"HVS Launcher" );
    XFONT_SetTextHeight( GetHeaderFont(), gc_uiDEFAULT_FONT_HEIGHT );

    pTexture->DrawText( GetHeaderFont(), gc_fLEFT_MENU_AREA_BORDER, 60, gc_dwCOLOR_TEXT_GREEN, gc_dwCOLOR_DARK_GREY, m_pwszMenuTitle );
}


// Render the screen items properly on our menu
void CMenuScreen::RenderScreenItems( CUDTexture* pTexture )
{
    // Don't render anything if we don't have any screen items
    if( 0 == GetNumScreenItems() )
        return;

    m_ScreenItems.MoveFirst(); // Start at the 1st Item
    for( unsigned int x = 0; x < GetNumScreenItems(); ++x )
    {
        m_ScreenItems.GetCurrentNode()->Render( pTexture );
        m_ScreenItems.MoveNext();
    }
}


// Render the menu items properly on our menu
void CMenuScreen::RenderMenuItems( CUDTexture* pTexture )
{
    // Don't render anything if we don't have any menu items
    if( 0 == GetNumMenuItems() )
        return;

    if( IsSingleListMenu() )
    //
    // Render the menu items for a single list menu
    //
    {
        m_MenuItems.MoveTo( GetTopItemIndex() );    // Start at menu item that needs to be displayed
        for( unsigned int x = GetTopItemIndex(); x <= GetBottomItemIndex(); ++x )
        {
            // Determine where on the screen the menu item should be
            float fXPos = m_fLeftMenuAreaBoundary + m_fLeftMenuAreaBorder;
            float fYPos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * ( x - GetTopItemIndex() ) );

            // Distinguish between enabled and disabled items
            DWORD dwFGColor, dwBGColor;
            if( m_MenuItems.GetCurrentNode()->m_bEnabled )
            {
                // Check to see if it's highlighted
                if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
                {
                    // Check to see if it's the currently selected item
                    if( x == GetSelectedItem() )
                    {
                        dwFGColor = m_dwSelectedItemHLFGColor;
                        dwBGColor = m_dwSelectedItemHLBGColor;
                    }
                    else
                    {
                        dwFGColor = m_dwMenuItemHighlightedFGColor;
                        dwBGColor = m_dwMenuItemHighlightedBGColor;
                    }

                }
                else
                {
                    // Check to see if it's our currently selected item
                    if( x == GetSelectedItem() )
                    {
                        dwFGColor = m_dwSelectedItemFGColor;
                        dwBGColor = m_dwSelectedItemBGColor;
                    }
                    else
                    {
                        dwFGColor = m_dwMenuItemEnabledFGColor;
                        dwBGColor = m_dwMenuItemEnabledBGColor;
                    }
                }
            }
            else
            {
                dwFGColor = m_dwMenuItemDisabledFGColor;
                dwBGColor = m_dwMenuItemDisabledBGColor;
            }

            // Draw the item text to the screen (left justified)
            if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
            {
                int iPixelWidth = GetStringPixelWidth( GetBodyFont(), L"\x221A" ) + 4;
                pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos - iPixelWidth, fYPos, dwFGColor, dwBGColor, L"%c", L'\x221A' );
                pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwFGColor, dwBGColor, L"%ls", m_MenuItems.GetCurrentNode()->m_pwszItemName );
                // pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwFGColor, dwBGColor, L"\x221A %ls", m_MenuItems.GetCurrentNode()->m_pwszItemName );
            }
            else
            {
                pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwFGColor, dwBGColor, L"%ls", m_MenuItems.GetCurrentNode()->m_pwszItemName );
            }

            // Draw the value right justified, if needed
            if( ( NULL != m_MenuItems.GetCurrentNode()->m_pValueFont ) && ( NULL != m_MenuItems.GetCurrentNode()->m_pwszItemValue ) )
            {
                fXPos = m_fRightMenuAreaBoundary - GetStringPixelWidth( m_MenuItems.GetCurrentNode()->m_pValueFont, m_MenuItems.GetCurrentNode()->m_pwszItemValue ) - m_fRightMenuAreaBorder;
                pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pValueFont, fXPos, fYPos, gc_dwCOLOR_TEXT_YELLOW, dwBGColor, m_MenuItems.GetCurrentNode()->m_pwszItemValue );
            }
        
            m_MenuItems.MoveNext();
        }
    }
    else
    //
    // Render the menu items for a multi list menu
    //
    {
        // Draw a separator line in the middle of the menu
        pTexture->DrawLine( gc_fMENU_AREA_HORIZ_CENTER, gc_fTOP_MENU_AREA_BOUNDARY, gc_fMENU_AREA_HORIZ_CENTER, gc_fBOTTOM_MENU_AREA_BOUNDARY, 2, gc_dwCOLOR_BLACK );

        unsigned int uiRowNum = 0;

        m_MenuItems.MoveTo( GetTopItemIndex() );    // Start at menu item that needs to be displayed
        for( unsigned int x = GetTopItemIndex(); x <= GetBottomItemIndex(); ++x )
        {
            float fXPos = 0.0f;
            float fYPos = 0.0f;

            if( 0 == ( x % 2 ) )
            //
            // Left Side Menu Item
            //
            {
                fXPos = m_fLeftMenuAreaBoundary + m_fLeftMenuAreaBorder;
                fYPos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * uiRowNum );
            }
            else
            //
            // Right Side Menu Item
            //
            {
                fXPos = gc_fMENU_AREA_HORIZ_CENTER + 6;
                fYPos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * uiRowNum );

                uiRowNum++; // Increase our row number for the next loop
            }


            // Distinguish between enabled and disabled items
            if( m_MenuItems.GetCurrentNode()->m_bEnabled )
            {
                // Check to see if it's highlighted
                if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
                    pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, m_dwMenuItemHighlightedFGColor, m_dwMenuItemHighlightedBGColor, m_MenuItems.GetCurrentNode()->m_pwszItemName );
                else
                    pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, m_dwMenuItemEnabledFGColor, m_dwMenuItemEnabledBGColor, m_MenuItems.GetCurrentNode()->m_pwszItemName );
            }
            else
                pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, m_dwMenuItemDisabledFGColor, m_dwMenuItemDisabledBGColor, m_MenuItems.GetCurrentNode()->m_pwszItemName );
        
            m_MenuItems.MoveNext();
        }
    }
}

// Render the selector for our menu
void CMenuScreen::RenderSelector( CUDTexture* pTexture )
{
    // If we don't have any menu items, we can't have anything selected
    if( 0 == GetNumMenuItems() )
        return;

    float fX1Pos = 0.0f;
    float fY1Pos = 0.0f;
    float fX2Pos = 0.0f;
    float fY2Pos = 0.0f;

    if( IsSingleListMenu() )
    {
        // Render the Selector Bar for the selected Menu Item
        fX1Pos = m_fLeftMenuAreaBoundary + m_fLeftMenuAreaBorder - m_fMenuItemSelectorBorder;
        fY1Pos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * GetSelectorPosition() ) - m_fMenuItemSelectorBorder;
        fX2Pos = m_fRightMenuAreaBoundary - m_fRightMenuAreaBorder + m_fMenuItemSelectorBorder;
        fY2Pos = fY1Pos + m_uiMenuItemFontHeight + ( 2 * m_fMenuItemSelectorBorder );
    }
    else    // Calculate selector for Multi List
    {
        if( 0 == ( GetSelectedItem() % 2 ) )
        //
        // Left Side Menu Item
        //
        {
            fX1Pos = m_fLeftMenuAreaBoundary + m_fLeftMenuAreaBorder - m_fMenuItemSelectorBorder;
            fY1Pos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * ( GetSelectorPosition() / 2 ) ) - m_fMenuItemSelectorBorder;
            fX2Pos = gc_fMENU_AREA_HORIZ_CENTER - 6 + m_fMenuItemSelectorBorder;
            fY2Pos = fY1Pos + m_uiMenuItemFontHeight + ( 2 * m_fMenuItemSelectorBorder );
        }
        else
        //
        // Right Side Menu Item
        //
        {
            fX1Pos = gc_fMENU_AREA_HORIZ_CENTER + 6 - m_fMenuItemSelectorBorder;
            fY1Pos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * ( GetSelectorPosition() / 2 ) ) - m_fMenuItemSelectorBorder;
            fX2Pos = m_fRightMenuAreaBoundary - m_fRightMenuAreaBorder + m_fMenuItemSelectorBorder;
            fY2Pos = fY1Pos + m_uiMenuItemFontHeight + ( 2 * m_fMenuItemSelectorBorder );
        }
    }

    pTexture->DrawBox( fX1Pos, fY1Pos, fX2Pos, fY2Pos, m_dwMenuItemSelectorColor );
}

// Initialize the Menu
HRESULT CMenuScreen::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    return S_OK;
}


// Add a text item to our current screen from a file
HRESULT CMenuScreen::AddTextItem( XFONT* pFont, WCHAR* pwszText, float fXPos, float fYPos, DWORD dwFGColor, DWORD dwBGColor )
{
    CTextItem* pTextItem = new CTextItem;
    if( !pTextItem )
    {
        DebugPrint( "CMenuScreen::AddTextItem():Out of memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Update the item with the information that we pulled from the file
    pTextItem->UpdateItem( pFont, pwszText, fXPos, fYPos, dwFGColor, dwBGColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pTextItem );
    
    return S_OK;
}


// Add a panel item to our current screen
HRESULT CMenuScreen::AddPanelItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, DWORD dwColor )
{
    CPanelItem* pPanelItem = new CPanelItem;
    if( !pPanelItem )
    {
        DebugPrint( "CMenuScreen::AddPanelItem():Out of memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Update the item with the information that we pulled from the file
    pPanelItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pPanelItem );

    return S_OK;
}


// Add a line to our current screen
HRESULT CMenuScreen::AddLineItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor )
{
    CLineItem* pLineItem = new CLineItem;
    if( !pLineItem )
    {
        DebugPrint( "CMenuScreen::AddLineItem():Out of memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Update the item with the information that we pulled from the file
    pLineItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pLineItem );

    return S_OK;
}


// Add a line to our current screen
HRESULT CMenuScreen::AddOutlineItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor )
{
    COutlineItem* pOutlineItem = new COutlineItem;
    if( !pOutlineItem )
    {
        DebugPrint( "CMenuScreen::AddOutlineItem():Out of memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Update the item with the information that we pulled from the file
    pOutlineItem->UpdateItem( fX1Pos, fY1Pos, fX2Pos, fY2Pos, fWidth, dwColor );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pOutlineItem );

    return S_OK;
}


// Add a Bitmap Item to our Screen from a file
HRESULT CMenuScreen::AddBitmapItem( char* pszFilename, int nXPos, int nYPos )
{
    CBitmapItem* pBitmapItem = new CBitmapItem;
    if( !pBitmapItem )
    {
        DebugPrint( "CMenuScreen::AddBitmapItem():Out of memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Update the item with the information that we pulled from the file
    pBitmapItem->UpdateItem( pszFilename, nXPos, nYPos );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pBitmapItem );

    return S_OK;
}


// Add a Bitmap Item to our Screen from a file
HRESULT CMenuScreen::AddBitmapAlphaItem( char* pszFilename, char* pszAlphaFilename, int nXPos, int nYPos )
{
    CBitmapAlphaItem* pBitmapAlphaItem = new CBitmapAlphaItem;
    if( NULL == pBitmapAlphaItem )
    {
        DebugPrint( "CMenuScreen::AddBitmapAlphaItem():Out of memory!!\n" );

        return E_OUTOFMEMORY;
    }

    // Update the item with the information that we pulled from the file
    pBitmapAlphaItem->UpdateItem( pszFilename, pszAlphaFilename, nXPos, nYPos );

    // Add the item to our list of Screen Items
    m_ScreenItems.AddNode( pBitmapAlphaItem );

    return S_OK;
}


// Update an existing menu item
HRESULT CMenuScreen::UpdateMenuItem( unsigned int uiIndex, WCHAR* pwszItemName, BOOL bHighlighted, BOOL bEnabled, WCHAR* pwszItemValue/*=NULL*/ )
{
    if( NULL == pwszItemName || uiIndex >= GetNumMenuItems() )
    {
        DebugPrint( "CMenuScreen::AddMenuItem():Invalid argument(s) passed in!!\n" );

        return E_INVALIDARG;
    }

    UpdateTexture();

    wcsncpy( m_MenuItems[uiIndex]->m_pwszItemName, pwszItemName, 255 );
    m_MenuItems[uiIndex]->m_bHighlighted = bHighlighted;
    m_MenuItems[uiIndex]->m_bEnabled = bEnabled;

    if( NULL != pwszItemValue )
        wcsncpy( m_MenuItems[uiIndex]->m_pwszItemValue, pwszItemValue, 255 );

    return S_OK;
}

// Used to add Menu Items to the current Menu
HRESULT CMenuScreen::AddMenuItem( XFONT* pFont, WCHAR* pwszItemName, BOOL bHighlighted, BOOL bEnabled, int nItemValue, XFONT* pValueFont/*=NULL*/, WCHAR* pwszItemValue/*=NULL*/ )
{
    if( NULL == pwszItemName || NULL == pFont )
    {
        DebugPrint( "CMenuScreen::AddMenuItem():Invalid argument(s) passed in!!\n" );

        return E_INVALIDARG;
    }

    CMenuItem* pMenuItem = new CMenuItem;
    if( NULL == pMenuItem )
    {
        DebugPrint( "CMenuScreen::AddMenuItem():Ran out of memory!!\n" );

        return E_OUTOFMEMORY;
    }
    
    wcsncpy( pMenuItem->m_pwszItemName, pwszItemName, 255 );

    pMenuItem->m_pFont = pFont;
    pMenuItem->m_bHighlighted = bHighlighted;
    pMenuItem->m_bEnabled = bEnabled;
    pMenuItem->m_nItemValue = nItemValue;

    // Deal with the menu item value (if necessary)
    if( ( NULL != pValueFont ) && ( NULL != pwszItemValue ) )
    {
        wcsncpy( pMenuItem->m_pwszItemValue, pwszItemValue, 255 );
        pMenuItem->m_pValueFont = pValueFont;
    }

    m_MenuItems.AddNode( pMenuItem );

    // If this is our first menu item, select it
    if( 1 == m_MenuItems.GetNumItems() )
    {
        SetSelectedItem( 0 );
    }

	// Adjust our right border if we have enough menu items to display 'arrows'
	// BUGBUG: This is overriding our user defined values!!  That is bad
	if( m_MenuItems.GetNumItems() > GetNumMenuItemsToDisplay() )
		m_fRightMenuAreaBorder = gc_fRIGHT_MENU_AREA_BORDER + 37;
	else
		m_fRightMenuAreaBorder = gc_fRIGHT_MENU_AREA_BORDER;

    return S_OK;
}


// Returns the number of items that should appear on the menu
unsigned int CMenuScreen::GetNumMenuItemsToDisplay( void )
{
    float fPanelHeight = m_fBottomMenuAreaBoundary - m_fTopMenuAreaBoundary;
    unsigned int uiReturnVal = (unsigned int)( ( fPanelHeight - m_fTopMenuAreaBorder ) / ( m_uiMenuItemFontHeight + m_fMenuItemVertSpace ) );

    // Double the number of items on the menu if it's a multi list menu
    if( !IsSingleListMenu() )
        uiReturnVal *= 2;
    
    return uiReturnVal;
}


// Get the index of the top menu item that should be displayed
HRESULT CMenuScreen::SetTopItemIndex( unsigned int uiIndex )
{
    if( IsSingleListMenu() )
    {
        // Make sure the passed in index is either 0, or within the realm of display
        if( ( ( uiIndex + GetNumMenuItemsToDisplay() - 1 ) < GetNumMenuItems() ) || ( 0 == uiIndex ) )
        {
            m_uiTopItemIndex = uiIndex;
        }
        else
        {
            DebugPrint( "CMenuScreen::SetTopItemIndex():Invalid index passed!! - '%d'\n", uiIndex );

            return E_INVALIDARG;
        }
    }
    else
    {
        // Make sure the passed in index is either 0, or within the realm of display
        if( ( ( uiIndex + GetNumMenuItemsToDisplay() - 1 ) < ( GetNumMenuItems() + 1 ) ) || ( 0 == uiIndex ) )
        {
            m_uiTopItemIndex = uiIndex;
        }
        else
        {
            DebugPrint( "CMenuScreen::SetTopItemIndex():Invalid index passed!! - '%d'\n", uiIndex );

            return E_INVALIDARG;
        }
    }

    return S_OK;
}


// Get the index of the bottom menu item that should be displayed
unsigned int CMenuScreen::GetBottomItemIndex( void )
{
    unsigned int uiReturnVal = GetTopItemIndex() + GetNumMenuItemsToDisplay() - 1;
    
    if( uiReturnVal > ( GetNumMenuItems() - 1 ) )
        uiReturnVal = GetNumMenuItems() - 1;

    return uiReturnVal;
}


// Set the boundaries of the menu area (where the menu items will live)
void CMenuScreen::SetMenuAreaBoundaries( float fX1/*=gc_fLEFT_MENU_AREA_BOUNDARY*/,
                                         float fY1/*=gc_fTOP_MENU_AREA_BOUNDARY*/,
                                         float fX2/*=gc_fRIGHT_MENU_AREA_BOUNDARY*/,
                                         float fY2/*=gc_fBOTTOM_MENU_AREA_BOUNDARY*/ )
{
    m_fLeftMenuAreaBoundary = fX1;        // Left boundary of where the menu items will appear
    m_fTopMenuAreaBoundary = fY1;         // Top boundary of where the menu items will appear
    m_fRightMenuAreaBoundary = fX2;       // Right boundary of where the menu items will appear
    m_fBottomMenuAreaBoundary = fY2;      // Bottom boundary of where the menu items will appear
}


// Set the borders of the menu area (where the menu items will live)
void CMenuScreen::SetMenuAreaBorders( float fLeftBorder/*=gc_fLEFT_MENU_AREA_BORDER*/,
                                      float fTopBorder/*=gc_fTOP_MENU_AREA_BORDER*/,
                                      float fRightBorder/*=gc_fRIGHT_MENU_AREA_BORDER*/,
                                      float fBottomBorder/*=gc_fBOTTOM_MENU_AREA_BORDER*/ )
{
    m_fLeftMenuAreaBorder = fLeftBorder;        // Left border of where the menu items will appear
    m_fTopMenuAreaBorder = fTopBorder;          // Top border of where the menu items will appear
    m_fRightMenuAreaBorder = fRightBorder;      // Right border of where the menu items will appear
    m_fBottomMenuAreaBorder = fBottomBorder;    // Bottom border of where the menu items will appear
}


// Set the amount of time a button should delay before repeating
void CMenuScreen::SetDelayIntervals( DWORD dwInitialDelay/*=gc_dwMENU_BUTTONPRESS_INITIAL_DELAY*/,
                                     DWORD dwRepeatDelay/*=gc_dwMENU_BUTTONPRESS_REPEAT_DELAY*/ )
{
    m_dwKeyPressInitialDelay = dwInitialDelay;
    m_dwKeyPressRepeatDelay = dwRepeatDelay;
}


void CMenuScreen::SetMenuItemVertSpace( float fVertSpace/*=gc_fMENU_ITEM_VERT_SPACE*/,
                                        float fHorizSpace/*=gc_fMENU_ITEM_HORIZ_SPACE*/ )
{
    m_fMenuItemVertSpace = fVertSpace;
    m_fMenuItemHorizSpace = fHorizSpace;
}

// Set the font height of the menu items
void CMenuScreen::SetMenuItemFontProperties( unsigned int uiFontHeight/*=gc_uiDEFAULT_FONT_HEIGHT*/,
                                             unsigned int uiFontAliasLevel/*=gc_uiDEFAULT_FONT_ALIAS_LEVEL*/ )
{
    m_uiMenuItemFontHeight = uiFontHeight;          // Font height of a menu item
    m_uiMenuItemFontAliasLevel = uiFontAliasLevel;  // Alias level of a menu item
}

// Set the menu item selector properties
void CMenuScreen::SetMenuItemSelectorProperties( float fBorder/*=gc_fMENU_SELECTOR_BORDER*/,
                                                 DWORD dwColor/*=gc_dwMENU_SELECTOR_COLOR*/ )
{
    m_fMenuItemSelectorBorder = fBorder;
    m_dwMenuItemSelectorColor = dwColor;
}

// Set the colors of the menu items
void CMenuScreen::SetMenuItemColors( DWORD dwEnabledItemFGColor/*=gc_fMENU_ITEM_ENABLED_FG_COLOR*/,
                                     DWORD dwEnabledItemBGColor/*=gc_fMENU_ITEM_ENABLED_BG_COLOR*/,
                                     DWORD dwDisabledItemFGColor/*=gc_fMENU_ITEM_DISABLED_FG_COLOR*/,
                                     DWORD dwDisabledItemBGColor/*=gc_fMENU_ITEM_DISABLED_BG_COLOR*/,
                                     DWORD dwHighlightedItemFGColor/*=gc_fMENU_ITEM_HIGHLIGHTED_FG_COLOR*/,
                                     DWORD dwHighlightedItemBGColor/*=gc_fMENU_ITEM_HIGHLIGHTED_BG_COLOR*/ )
{
    m_dwMenuItemEnabledFGColor = dwEnabledItemFGColor;          // Foreground color for an enabled menu item
    m_dwMenuItemEnabledBGColor = dwEnabledItemBGColor;          // Background color for an enabled menu item
    m_dwMenuItemDisabledFGColor = dwDisabledItemFGColor;        // Foreground color for a disabled menu item
    m_dwMenuItemDisabledBGColor = dwDisabledItemBGColor;        // Background color for a disabled menu item
    m_dwMenuItemHighlightedFGColor = dwHighlightedItemFGColor;  // Foreground color for a highlighted menu item
    m_dwMenuItemHighlightedBGColor = dwHighlightedItemBGColor;  // Background color for a highlighted menu item
}


// Set the colors of the menu items
void CMenuScreen::SetMenuItemSelectedColors( DWORD dwSelectedItemFGColor/*=gc_fMENU_ITEM_SELECTED_FG_COLOR*/,
                                             DWORD dwSelectedItemBGColor/*=gc_fMENU_ITEM_SELECTED_BG_COLOR*/,
                                             DWORD dwSelectedHLItemFGColor/*=gc_fMENU_ITEM_SELECTED_HL_FG_COLOR*/,
                                             DWORD dwSelectedHLItemBGColor/*=gc_fMENU_ITEM_SELECTED_HL_BG_COLOR*/ )
{
    m_dwSelectedItemFGColor = dwSelectedItemFGColor;
    m_dwSelectedItemBGColor = dwSelectedItemBGColor;
    m_dwSelectedItemHLFGColor = dwSelectedHLItemFGColor;
    m_dwSelectedItemHLBGColor = dwSelectedHLItemBGColor;
}

// Set the positions of the arrows on our menu
void CMenuScreen::SetArrowPositions( int iUpArrowXPos/*=gc_iUPARROWXPOS*/,
                                     int iUpArrowYPos/*=gc_iUPARROWYPOS*/,
                                     int iDownArrowXPos/*=gc_iDOWNARROWXPOS*/,
                                     int iDownArrowYPos/*=gc_iDOWNARROWYPOS*/ )
{
    m_iUpArrowXPos = iUpArrowXPos;
    m_iUpArrowYPos = iUpArrowYPos;
    m_iDownArrowXPos = iDownArrowXPos;
    m_iDownArrowYPos = iDownArrowYPos;
}

// Return a pointer to the menu title
HRESULT CMenuScreen::SetMenuTitle( XFONT* pMenuTitleFont, WCHAR* pwszMenuTitle )
{
    if( NULL == pwszMenuTitle || NULL == pMenuTitleFont )
    {
        DebugPrint( "CMenuScreen::SetMenuTitle():Invalid argument(s) passed in!!\n" );
        
        return E_INVALIDARG;
    }

    if( NULL != m_pwszMenuTitle )
    {
        delete[] m_pwszMenuTitle;
        m_pwszMenuTitle = NULL;
    }

    unsigned long ulStrLen = wcslen( pwszMenuTitle ) + 1;
    m_pwszMenuTitle = new WCHAR[ulStrLen];
    if( NULL == m_pwszMenuTitle )
    {
        DebugPrint( "CMenuScreen::SetMenuTitle():Out of Memory!!\n" );

        return E_OUTOFMEMORY;
    }
    
    ZeroMemory( m_pwszMenuTitle, sizeof( WCHAR ) * ulStrLen );

    wcscpy( m_pwszMenuTitle, pwszMenuTitle );

    return S_OK;
}


// Handles input from the buttons
void CMenuScreen::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( buttonPressed )
    {
    case BUTTON_B:
        {
            GoBack();

            break;
        }
    }
}


// Handles input (of the CONTROLS) for the current menu
void CMenuScreen::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( IsSingleListMenu() )
        HandleControlInputSingleList( controlPressed, bFirstPress );
    else
        HandleControlInputMultiList( controlPressed, bFirstPress );
}


// Handle control input for a single list menu
void CMenuScreen::HandleControlInputSingleList( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() > 0 )
            {
                if( GetSelectedItem() > 0 )
                {
                    UpdateTexture();
                    SetSelectedItem( GetSelectedItem() - 1 );

                    // Adjust the screen appropriately
                    if( GetSelectedItem() < GetTopItemIndex() )
                        SetTopItemIndex( GetTopItemIndex() - 1 );
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() != 0 )
            {
                if( GetSelectedItem() < ( GetNumMenuItems() - 1 ) )
                {
                    UpdateTexture();
                    SetSelectedItem( GetSelectedItem() + 1 );

                    // Adjust the screen appropriately
                    if( GetSelectedItem() > GetBottomItemIndex() )
                        SetTopItemIndex( GetTopItemIndex() + 1 );
                }
            }
            break;
        }
	}
}

// Handle control input for a multi list menu
void CMenuScreen::HandleControlInputMultiList( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() > 0 )
            {
                if( GetSelectedItem() >= 2 )
                {
                    UpdateTexture();
                    SetSelectedItem( GetSelectedItem() - 2 );

                    // TODO: Fix this when we need multi-list menus
                    /*
                    // Adjust the screen appropriately
                    if( GetSelectorPosition() > 1 )
                        SetSelectorPosition( GetSelectorPosition() - 2 );
                    else
                        SetTopItemIndex( GetTopItemIndex() - 2 );
                    */
                }
            }
            break;
        }
    case CONTROL_DPAD_DOWN:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() != 0 )
            {
                if( ( GetSelectedItem() + 2 ) < GetNumMenuItems() )
                {
                    UpdateTexture();
                    SetSelectedItem( GetSelectedItem() + 2 );

                    // TODO: Fix this when we need multi-list menus
                    /*
                    // Adjust the screen appropriately
                    if( GetSelectorPosition() < ( GetNumMenuItemsToDisplay() - 2 ) )
                        SetSelectorPosition( GetSelectorPosition() + 2 );
                    else
                        SetTopItemIndex( GetTopItemIndex() + 2 );
                    */
                }
            }
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() > 0 )
            {
                if( ( 0 == ( GetSelectorPosition() % 2 ) ) && ( ( GetSelectedItem() + 1 ) < GetNumMenuItems() ) )
                {
                    UpdateTexture();
                    SetSelectedItem( GetSelectedItem() + 1 );

                    // TODO: Fix this when we need multi-list menus
                    /*
                    // Adjust the screen appropriately
                    SetSelectorPosition( GetSelectorPosition() + 1 );
                    */
                }
            }
            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() > 0 )
            {
                if( ( 0 != ( GetSelectorPosition() % 2 ) ) && ( ( (int)GetSelectedItem() - 1 ) >= 0 ) )
                {
                    UpdateTexture();
                    SetSelectedItem( GetSelectedItem() - 1 );

                    // TODO: Fix this when we need multi-list menus
                    /*
                    // Adjust the screen appropriately
                    SetSelectorPosition( GetSelectorPosition() - 1 );
                    */
                }
            }
            break;
        }
	}
}


// Handle any requests for the joystick (thumb-pad)
void CMenuScreen::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            // Yxc
            if( nThumbY < 0 )  // Move the left joystick down
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_DOWN, bFirstYPress );
            }
            else if( nThumbY > 0 ) // Move left joystick up
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_UP, bFirstYPress );
            }

            // X
            if( nThumbX < 0 )       // Move the left joystick left
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
            }
            else if( nThumbX > 0 )  // Move the left joystick right
            {
                // Hand off this to the "DPad" handler
                HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
            }
            break;
        }
    }
}


// Handle the default delay before for Input
BOOL CMenuScreen::HandleInputDelay( BOOL bFirstPress )
{
    // If this is a repeat button press, let's delay a bit
    if( bFirstPress )
    {
        m_dwKeyPressDelayTimer = GetTickCount();
        m_dwKeyPressDelayInterval = m_dwKeyPressInitialDelay;
    }
    else // Check to see if the repeat press is within our timer, otherwise bail
    {
        // If the interval is too small, bail
        if( ( GetTickCount() - m_dwKeyPressDelayTimer ) < m_dwKeyPressDelayInterval )
        {
            return FALSE;
        }
        m_dwKeyPressDelayTimer = GetTickCount();
        m_dwKeyPressDelayInterval = m_dwKeyPressRepeatDelay;
    }

    return TRUE;
}


// Sets the currently selected item on our screen
HRESULT CMenuScreen::SetSelectedItem( unsigned int uiItemNumber )
{
    if( uiItemNumber > GetNumMenuItems() )
    {
        DebugPrint( "CMenuScreen::SetSelectedItem():Tried to select item out of range! - '%d', MAX - '%d'\n", uiItemNumber, GetNumMenuItems() - 1 );

        return E_INVALIDARG;
    }

    m_uiSelectedItem = uiItemNumber;

    return S_OK;
}


// Allows user to set a single, or multi list menu
void CMenuScreen::SetSingleListMenu( BOOL bMenuType )
{
    m_bSingleList = bMenuType;  // TRUE for Single List, FALSE for Multi List
}


// Should be called whenever a user enters or activates this menu
void CMenuScreen::Enter( void )
{
    UpdateTexture();

    m_dwKeyPressDelayTimer = GetTickCount();
    m_dwKeyPressDelayInterval = m_dwKeyPressInitialDelay;
}


// Should be called whenever a user leaves the menu
void CMenuScreen::Leave( CXItem* pItem )
{
    SetPreviousMenu( this );
    SetCurrentMenu( pItem );
}

// Go back to the previous menu
void CMenuScreen::GoBack( void )
{
    if( NULL != m_BackPtr )
        Leave( m_BackPtr );
}


// Clear all menu items from the list
void CMenuScreen::ClearMenuItems( void )
{ 
    SetSelectedItem( 0 );
    SetTopItemIndex( 0 );

    m_MenuItems.EmptyList();
};


// Get the position of the selector on the menu
unsigned int CMenuScreen::GetSelectorPosition( void )
{
    return GetSelectedItem() - GetTopItemIndex();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\memoryunit.h ===
/*****************************************************
*** memoryunit.h
***
*** Header file for our Memory Unit class.
*** This class will contain functions and information
*** pertaining to an Xbox Memory Unit
***
*** by James N. Helm
*** March 28th, 2001
***
*** Modified
*** 11/30/2001  by James N. Helm -- Removed 'special'
***             code, only working with MU as if I
***             were a game now
***
*****************************************************/

#ifndef _MEMORYUNIT_H_
#define _MEMORYUNIT_H_

const WCHAR gc_pwszMEMORY_UNIT_NAME_PATTERN[] =         L"Memory Unit";
const DWORD gc_dwMEMORY_AREA_BLOCK_SIZE_IN_BYTES =      16384;

class CMemoryUnit
{
public:
    // Contructor and Destructors
    CMemoryUnit( void );
    ~CMemoryUnit( void );

    // Public Methods
    HRESULT Mount( void );                                  // Mount the Memory Unit
    HRESULT Unmount( void );                                // Unmount the Memory Unit
    char* GetDrivePath( void )                              // Get the pointer to the drive path (i.e. "u:\")
        { return m_pszDrivePath; };                         // Get the pointer to our default name
    WCHAR* GetDefaultName( void )
        { return m_pwszDefaultName; };
    WCHAR* GetName( void ) { return m_pwszMUName; };        // Get the name of the MU
    DWORD GetFreeBlocks( void );                            // Get the number of blocks that are free on the MU
    DWORD GetTotalBlocks( void );                           // Get the total number of blocks on the MU
    BOOL IsFormatted( void ) { return m_bFormatted; };      // Returns the format state of the MU
    BOOL IsMounted( void ) { return m_bMounted; };          // Returns the mount state of the MU
    BOOL IsNamed( void );                                   // Used to determine if the MU is named
    HRESULT SetPortSlot( DWORD dwPort,                      // Set the port and the slot this MU will be on
                         DWORD dwSlot );                    
    unsigned int GetIndex( void );                          // Get the Index of the current MU
                                                            
private:                                                    
    char    m_cDriveLetter;                                 // The drive letter the MU is mounted on
    char    m_pszDrivePath[4];                              // The path of the current MU (i.e. "u:\", "f:\")
    WCHAR*  m_pwszDefaultName;                              // The default name of the MU
    WCHAR*  m_pwszMUName;                                   // The name of the MU
    BOOL    m_bMounted;                                     // When the MU is mounted, this is set to TRUE
    BOOL    m_bFormatted;                                   // Used to determine if the MU is formatted
    DWORD   m_dwPort;                                       // The port the MU is on (XDEVICE_PORT0 through XDEVICE_PORT3)
    DWORD   m_dwSlot;                                       // The slot of the Controller the MU is in (XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT)

    // Private Methods
    HRESULT ProcessMountedMU( void );                       // Process a mounted MU (Get the name, etc)
    HRESULT CalcSpace( DWORD* pdwTotalBlocks,               // Retreives block information for the current MU
                       DWORD* pdwFreeBlocks );
};

#endif // _MEMORYUNIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\messagemenu.cpp ===
/*****************************************************
*** messagemenu.h
***
*** CPP file for our Message Menu class.
*** This menu will present a message to the user, and
*** simply allow them to navigate back from where they
*** came.
***
*** by James N. Helm
*** December 11th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "messagemenu.h"

// Constructors and Destructor
CMessageMenu::CMessageMenu( void )
{
    // Zero out our buffers
    for( unsigned int x = 0; x < gc_uiMESS_MENU_NUM_TEXT_LINES; x++ )
        ZeroMemory( m_apwszTextMessage[x], sizeof( WCHAR ) * ( MAX_PATH + 1 ) );
}

CMessageMenu::~CMessageMenu( void )
{
}

// Initialize the Menu
HRESULT CMessageMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CMessageMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Message" );

    /////////////////////////
    // Add screen items here
    /////////////////////////
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );
	
    // Status Bar Column 1
    // AddBitmapAlphaItem( "d:\\media\\images\\Abutton.bmp", "d:\\media\\images\\buttonalpha.bmp",     (int)gc_fSTATUS_TEXT_COL1_XPOS, (int)gc_fSTATUS_TEXT_ROW1_YPOS );
    // AddBitmapAlphaItem( "d:\\media\\images\\Bbutton.bmp", "d:\\media\\images\\buttonalpha.bmp",     (int)gc_fSTATUS_TEXT_COL1_XPOS, (int)gc_fSTATUS_TEXT_ROW1_YPOS );
    // AddBitmapItem( "d:\\media\\images\\Bbutton.bmp", (int)gc_fSTATUS_TEXT_COL1_XPOS, (int)gc_fSTATUS_TEXT_ROW1_YPOS );
    // AddBitmapItem( "d:\\media\\images\\Abutton.bmp", (int)gc_fSTATUS_TEXT_COL1_XPOS, (int)gc_fSTATUS_TEXT_ROW1_YPOS );
    AddTextItem( GetButtonFont(), L"A",        gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Select",  gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"B",        gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Back",    gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    ///////////////////////
	// Add menu items here
    ///////////////////////

    return hr;
}


// Render the menu items properly on our menu
void CMessageMenu::RenderMenuItems( CUDTexture* pTexture )
{
    float fXPos = 0.0f;
    float fYPos = 0.0f;

    // Render the text message
    for( unsigned int x = 0; x < gc_uiMESS_MENU_NUM_TEXT_LINES; x++ )
    {
		WCHAR* pwszMessagePtr = m_apwszTextMessage[x];
		DWORD dwFGColor = m_dwMenuItemEnabledFGColor;
		DWORD dwBGColor = m_dwMenuItemEnabledBGColor;

		// Determine if the user wants to display this line of text in a different color
		if( 0 == wcsncmp( m_apwszTextMessage[x], L"/c", 2 ) )
		{
			pwszMessagePtr += 2;	// Skip the initial "/c"

			// Read the DWORD FG color out of the line
			WCHAR* pwszStopString = NULL;
			dwFGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwFGColor )
				DebugPrint( "CMessageMenu::RenderMenuItems():Possible error in conversion of the FG color (DWORD)\n" );

			// Skip over the FG color and the space
			pwszMessagePtr = pwszStopString + 1;

			// Read the DWORD BG color out of the line
			dwBGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwBGColor )
				DebugPrint( "CMessageMenu::RenderMenuItems():Possible error in conversion of the BG color (DWORD)\n" );

			// Skip over the BG color and the space
			pwszMessagePtr = pwszStopString + 1;
		}

		fXPos = gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), pwszMessagePtr ) / 2 );
        fYPos = gc_fMESSAGE_TEXT_YPOS + ( x * ( m_uiMenuItemFontHeight + m_fMenuItemVertSpace ) );

        pTexture->DrawText( GetBodyFont(), fXPos, fYPos, dwFGColor, dwBGColor, L"%ls", pwszMessagePtr );
    }

    // Render the OK Button
    int iTextWidth = GetStringPixelWidth( GetBodyFont(), L"Ok" ) / 2;
    fXPos = gc_fMENU_AREA_HORIZ_CENTER - iTextWidth;
    fYPos = gc_fOK_BUTTON_YPOS;

    // Draw the box and highlight
    pTexture->DrawBox( fXPos - gc_fOK_BUTTON_BORDER,
                       fYPos - gc_fOK_BUTTON_BORDER,
                       fXPos + ( iTextWidth * 2 ) + gc_fOK_BUTTON_BORDER,
                       fYPos + m_uiMenuItemFontHeight + gc_fOK_BUTTON_BORDER,
                       gc_dwCOLOR_SELECTOR_BLACK );

    pTexture->DrawOutline( fXPos - gc_fOK_BUTTON_BORDER,
                           fYPos - gc_fOK_BUTTON_BORDER,
                           fXPos + ( iTextWidth * 2 ) + gc_fOK_BUTTON_BORDER,
                           fYPos + m_uiMenuItemFontHeight + gc_fOK_BUTTON_BORDER,
                           2,
                           m_dwMenuItemEnabledFGColor );

    // Draw the text on the button
    pTexture->DrawText( GetBodyFont(), fXPos, fYPos, m_dwSelectedItemFGColor, m_dwSelectedItemBGColor, L"Ok" );

}


// Handles input (of the BUTTONS) for the current menu
void CMessageMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
    case BUTTON_B:
        {
            GoBack();

            break;
        }
    }
}


// Used to set the text message that will be displayed to the user
void CMessageMenu::SetText( WCHAR* pwszMessage )
{
    if( NULL == pwszMessage )
    {
        DebugPrint( "CMessageMenu::SetText():Invalid argument(s) passed in!!\n" );

        return;
    }

    for( unsigned int x = 0; x < gc_uiMESS_MENU_NUM_TEXT_LINES; x++ )
    {
        unsigned int uiCount = 0;
        while( ( *pwszMessage != L'\n' ) && ( *pwszMessage != L'\0' ) )
        {
            m_apwszTextMessage[x][uiCount] = *pwszMessage;
            uiCount++;
            pwszMessage++;

            // Exit when we find the end of the current string
            if( uiCount == MAX_PATH + 1 )
                break;
        }
        m_apwszTextMessage[x][uiCount] = L'\0';

        // Exit early if we are at the end of the message
        if( *pwszMessage == L'\0' )
            break;

        uiCount++;
        pwszMessage++;
    }

    /*
    for( x = 0; x < gc_uiMESS_MENU_NUM_TEXT_LINES; x++ )
    {
        DebugPrint("m_apwszTextMessage[x] - '%ls'\n", m_apwszTextMessage[x] );
        DebugPrint( "Length - '%d'\n", wcslen( m_apwszTextMessage[x] ) );
    }
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\menuscreen.h ===
/*****************************************************
*** menuscreen.h
***
*** Header file for our XShell Generic menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** December 1st , 2000
***
*****************************************************/

#ifndef _MENUSCREEN_H_
#define _MENUSCREEN_H_

#include "xitem.h"
#include "screenitems.h"

// Menu Area Boundaries                                             
const float         gc_fLEFT_MENU_AREA_BOUNDARY =                   0.0f;
const float         gc_fTOP_MENU_AREA_BOUNDARY =                    101.0f;
const float         gc_fRIGHT_MENU_AREA_BOUNDARY =                  639.0f;
const float         gc_fBOTTOM_MENU_AREA_BOUNDARY =                 375.0f;
const float         gc_fMENU_AREA_HORIZ_CENTER =                    ( gc_fRIGHT_MENU_AREA_BOUNDARY - gc_fLEFT_MENU_AREA_BOUNDARY ) / 2.0f;
const float         gc_fMENU_AREA_VERT_CENTER =                     ( gc_fBOTTOM_MENU_AREA_BOUNDARY - gc_fTOP_MENU_AREA_BOUNDARY ) / 2.0f;
                                                                    
// Menu Area Borders                                                
const float         gc_fLEFT_MENU_AREA_BORDER =                     40.0f;
const float         gc_fTOP_MENU_AREA_BORDER =                      10.0f;
const float         gc_fRIGHT_MENU_AREA_BORDER =                    40.0f;
const float         gc_fBOTTOM_MENU_AREA_BORDER =                   10.0f;

// Menu Area spacing                                                
const float         gc_fMENU_ITEM_VERT_SPACE =                      5.0f;
const float         gc_fMENU_ITEM_HORIZ_SPACE =                     5.0f;

// Menu Area Colors
const DWORD         gc_fMENU_ITEM_ENABLED_FG_COLOR =                gc_dwCOLOR_TEXT_GREEN;  // gc_dwCOLOR_DIM_YELLOW;
const DWORD         gc_fMENU_ITEM_ENABLED_BG_COLOR =                gc_dwCOLOR_BLACK;
const DWORD         gc_fMENU_ITEM_DISABLED_FG_COLOR =               gc_dwCOLOR_BLACK;
const DWORD         gc_fMENU_ITEM_DISABLED_BG_COLOR =               gc_dwCOLOR_BLACK;
const DWORD         gc_fMENU_ITEM_HIGHLIGHTED_FG_COLOR =            gc_dwCOLOR_TEXT_YELLOW; // gc_dwCOLOR_WHITE;
const DWORD         gc_fMENU_ITEM_HIGHLIGHTED_BG_COLOR =            gc_dwCOLOR_BLACK;

// Menu Select Bar Properties
const float         gc_fMENU_SELECTOR_BORDER =                      2.0f;
const DWORD         gc_dwMENU_SELECTOR_COLOR =                      gc_dwCOLOR_SELECTOR_BLACK; // gc_dwCOLOR_DARK_GREEN;

// Selected Item Colors
const DWORD         gc_fMENU_ITEM_SELECTED_FG_COLOR =               gc_dwCOLOR_WHITE;
const DWORD         gc_fMENU_ITEM_SELECTED_BG_COLOR =               gc_dwMENU_SELECTOR_COLOR;
const DWORD         gc_fMENU_ITEM_SELECTED_HL_FG_COLOR =            gc_dwCOLOR_WHITE;
const DWORD         gc_fMENU_ITEM_SELECTED_HL_BG_COLOR =            gc_dwMENU_SELECTOR_COLOR;

// Delay Interval Defaults
const DWORD         gc_dwMENU_BUTTONPRESS_INITIAL_DELAY =           400;    // milliseconds
const DWORD         gc_dwMENU_BUTTONPRESS_REPEAT_DELAY =            50;     // milliseconds

// Status Bar Text Position & Color Info
const float         gc_fSTATUS_TEXT_COL1_XPOS =                     gc_fLEFT_MENU_AREA_BOUNDARY + gc_fLEFT_MENU_AREA_BORDER;
const float         gc_fSTATUS_TEXT_COL2_XPOS =                     gc_fLEFT_MENU_AREA_BOUNDARY + gc_fLEFT_MENU_AREA_BORDER + 200; // gc_fSTATUS_TEXT_COL1_XPOS + 200.0f;
const float         gc_fSTATUS_TEXT_COL3_XPOS =                     gc_fLEFT_MENU_AREA_BOUNDARY + gc_fLEFT_MENU_AREA_BORDER + 400; // gc_fSTATUS_TEXT_COL2_XPOS + 200.0f;
const float         gc_fSTATUS_TEXT_ROW1_YPOS =                     gc_fBOTTOM_MENU_AREA_BOUNDARY + 15.0f;
const float         gc_fSTATUS_TEXT_ROW2_YPOS =                     gc_fBOTTOM_MENU_AREA_BOUNDARY + gc_uiDEFAULT_FONT_HEIGHT + 19.0f; // gc_fSTATUS_TEXT_ROW1_YPOS + gc_uiDEFAULT_FONT_HEIGHT + 4;

const DWORD         gc_dwSTATUS_TEXT_FG_COLOR =                     gc_fMENU_ITEM_ENABLED_FG_COLOR;
const DWORD         gc_dwSTATUS_TEXT_BG_COLOR =                     gc_fMENU_ITEM_ENABLED_BG_COLOR;

// Default Arrow Positions
const int           gc_iUPARROWXPOS =                               575;
const int           gc_iUPARROWYPOS =                               105;
const int           gc_iDOWNARROWXPOS =                             gc_iUPARROWXPOS;
const int           gc_iDOWNARROWYPOS =                             330;

class CMenuScreen : public CXItem
{
public:
    // Constructors and Destructors
    CMenuScreen( void );
    virtual ~CMenuScreen( void );

    // Public Methods
    virtual void Action( CUDTexture* pTexture );                // Renders to the texture and calls any per-frame processing
    
    virtual void HandleInput( enum BUTTONS buttonPressed,       // Handles input from the buttons
                              BOOL bFirstPress );
    
    virtual void HandleInput( enum CONTROLS controlPressed,     // Handles input from the controls
                              BOOL bFirstPress );
    
    virtual void HandleInput( enum JOYSTICK joystick,           // Handles input from the joysticks
                              int nThumbY,
                              int nThumbX,
                              BOOL bFirstYPress,
                              BOOL bFirstXPress );
    virtual void Enter( void );                                 // This should be called whenever the menu is entered or activated

    virtual void         ClearMenuItems( void );                                        // Clear all menu items from the list
    virtual void         ClearScreenItems( void ) { m_ScreenItems.EmptyList(); };       // Clear all screen items from the list
    virtual HRESULT      Init( XFONT* pMenuItemFont,                                    // Initialize the Menu
                               XFONT* pMenuTitleFont );
    virtual void         SetBackPtr( CXItem* pBackPtr ) { m_BackPtr = pBackPtr; };      // Set the back-pointer to specficy where navigating back should send the user
    virtual void         GoBack( void );                                                // Go back to the previous menu
    virtual unsigned int GetNumMenuItems( void )                                        // Return the number of menu items on our current menu
        { return m_MenuItems.GetNumItems(); };
    virtual unsigned int GetNumScreenItems( void )                                      // Return the number of Screen items on our current menu
        { return m_ScreenItems.GetNumItems(); };
    virtual unsigned int GetSelectedItem( void ) const                                  // Get the index of the currently selected item on the screen
        { return m_uiSelectedItem; };
    virtual int GetSelectedItemValue( void )                                            // Get the value of the currently selected item on the screen
        { return m_MenuItems[GetSelectedItem()]->m_nItemValue; };
    virtual HRESULT      SetSelectedItem( unsigned int uiItemNumber );                  // Set the currently selected item on the screen
    virtual WCHAR*       GetMenuTitle( void ) { return m_pwszMenuTitle; };              // Return a pointer to the menu title
    virtual HRESULT      SetMenuTitle( XFONT* pMenuTitleFont,                           // Return a pointer to the menu title
                                       WCHAR* pwszMenuTitle );
    virtual unsigned int GetSelectorPosition( void );                                   // Get the position of the selector on the menu
    virtual void         SetSingleListMenu( BOOL bMenuType );                           // Allows user to set a single, or multi list menu
    virtual BOOL         IsSingleListMenu( void ) { return m_bSingleList; };            // Used to determine if we are using a single or multi list menu

    virtual void         UpdateTexture( void ) { m_bUpdateTexture = TRUE; };            // Call this when the texture should be updated

    
    // Set the boundaries of the menu area (where the menu items will live)
    virtual void         SetMenuAreaBoundaries( float fX1 = gc_fLEFT_MENU_AREA_BOUNDARY,
                                                float fY1 = gc_fTOP_MENU_AREA_BOUNDARY,
                                                float fX2 = gc_fRIGHT_MENU_AREA_BOUNDARY,
                                                float fY2 = gc_fBOTTOM_MENU_AREA_BOUNDARY );

    // Set the borders of the menu area (where the menu items will live)
    virtual void         SetMenuAreaBorders( float fLeftBorder   = gc_fLEFT_MENU_AREA_BORDER,
                                             float fTopBorder    = gc_fTOP_MENU_AREA_BORDER,
                                             float fRightBorder  = gc_fRIGHT_MENU_AREA_BORDER,
                                             float fBottomBorder = gc_fBOTTOM_MENU_AREA_BORDER );

    // Set the vertical spacing between the menu items
    virtual void        SetMenuItemVertSpace( float fVertSpace = gc_fMENU_ITEM_VERT_SPACE,
                                              float fHorizSpace = gc_fMENU_ITEM_HORIZ_SPACE );

    // Set the font height of the menu items
    virtual void        SetMenuItemFontProperties( unsigned int uiFontHeight = gc_uiDEFAULT_FONT_HEIGHT,
                                                   unsigned int uiFontAliasLevel = gc_uiDEFAULT_FONT_ALIAS_LEVEL );
    // Set the menu item selector properties
    virtual void        SetMenuItemSelectorProperties( float fBorder = gc_fMENU_SELECTOR_BORDER,
                                                       DWORD dwColor = gc_dwMENU_SELECTOR_COLOR );

    // Set the amount of time a button should delay before repeating
    virtual void        SetDelayIntervals( DWORD dwInitialDelay = gc_dwMENU_BUTTONPRESS_INITIAL_DELAY,
                                           DWORD dwRepeatDelay = gc_dwMENU_BUTTONPRESS_REPEAT_DELAY );

    // Set the colors of the menu items
    virtual void        SetMenuItemColors( DWORD dwEnabledItemFGColor = gc_fMENU_ITEM_ENABLED_FG_COLOR,
                                           DWORD dwEnabledItemBGColor = gc_fMENU_ITEM_ENABLED_BG_COLOR,
                                           DWORD dwDisabledItemFGColor = gc_fMENU_ITEM_DISABLED_FG_COLOR,
                                           DWORD dwDisabledItemBGColor = gc_fMENU_ITEM_DISABLED_BG_COLOR,
                                           DWORD dwHighlightedItemFGColor = gc_fMENU_ITEM_HIGHLIGHTED_FG_COLOR,
                                           DWORD dwHighlightedItemBGColor = gc_fMENU_ITEM_HIGHLIGHTED_BG_COLOR );

    // Set the colors of the menu items
    virtual void        SetMenuItemSelectedColors( DWORD dwSelectedItemFGColor = gc_fMENU_ITEM_SELECTED_FG_COLOR,
                                                   DWORD dwSelectedItemBGColor = gc_fMENU_ITEM_SELECTED_BG_COLOR,
                                                   DWORD dwSelectedHLItemFGColor = gc_fMENU_ITEM_SELECTED_HL_FG_COLOR,
                                                   DWORD dwSelectedHLItemBGColor = gc_fMENU_ITEM_SELECTED_HL_BG_COLOR );

    // Set the positions of the arrows on our menu
    virtual void        SetArrowPositions( int iUpArrowXPos = gc_iUPARROWXPOS,
                                           int iUpArrowYPos = gc_iUPARROWYPOS,
                                           int iDownArrowXPos = gc_iDOWNARROWXPOS,
                                           int iDownArrowYPos = gc_iDOWNARROWYPOS );


    // Deal with a scrolling menu
    virtual unsigned int GetNumMenuItemsToDisplay( void );                  // Returns the number of items that should appear on the menu
    virtual unsigned int GetTopItemIndex( void )                            // Get the index of the top menu item that should be displayed
        { return m_uiTopItemIndex; };
    virtual unsigned int GetBottomItemIndex( void );                        // Get the index of the bottom menu item that should be displayed
    virtual HRESULT      SetTopItemIndex( unsigned int uiIndex );           // Set the index of the top menu item that should be displayed

protected:
    CLinkedList< CScreenItem* > m_ScreenItems;                  // List of pointers to screen items that will be rendered
    CLinkedList< CMenuItem* >   m_MenuItems;                    // List of pointers to our menu items that will be rendered
    WCHAR*                      m_pwszMenuTitle;                // Title of the current menu
    XFONT*                      m_pMenuTitleFont;               // Font used to render the menu title
    unsigned int                m_uiSelectedItem;               // The currently selected item in the list (-1 if nothing is selected)
    unsigned int                m_uiTopItemIndex;               // Index of the top item that is to be displayed
    BOOL                        m_bUpdateTexture;               // Used to determine when the texture should be updated
    BOOL                        m_bSingleList;                  // Used to determine if our menu is a single, or double list menu
    CXItem*                     m_BackPtr;                      // Used to determine where the user should go if they press "Back"
    CBitmapAlphaItem            m_UpArrow;                      // The up arrow displayed when more info is off the top of the screen
    CBitmapAlphaItem            m_DownArrow;                    // The up down displayed when more info is off the bottom of the screen
	/*
    CBitmapItem					m_UpArrow;                      // The up arrow displayed when more info is off the top of the screen
    CBitmapItem					m_DownArrow;                    // The up down displayed when more info is off the bottom of the screen
	*/

    // Menu Repeat-Rate Timers
    DWORD                       m_dwKeyPressDelayTimer;         // Used to track how much time has passed
    DWORD                       m_dwKeyPressDelayInterval;      // Used to track our current interval
    DWORD                       m_dwKeyPressInitialDelay;       // Amount of time to delay after an initial button press  
    DWORD                       m_dwKeyPressRepeatDelay;        // Amount of time to delay after a button is held down

    // Menu area Boundaries
    float                       m_fLeftMenuAreaBoundary;        // Left boundary of where the menu items will appear
    float                       m_fTopMenuAreaBoundary;         // Top boundary of where the menu items will appear
    float                       m_fRightMenuAreaBoundary;       // Right boundary of where the menu items will appear
    float                       m_fBottomMenuAreaBoundary;      // Bottom boundary of where the menu items will appear

    // Menu area Borders
    float                       m_fLeftMenuAreaBorder;          // Left border of where the menu items will appear
    float                       m_fTopMenuAreaBorder;           // Top border of where the menu items will appear
    float                       m_fRightMenuAreaBorder;         // Right border of where the menu items will appear
    float                       m_fBottomMenuAreaBorder;        // Bottom border of where the menu items will appear

    float                       m_fMenuItemVertSpace;           // Set the vertial space between each menu item
    float                       m_fMenuItemHorizSpace;          // Set the vertial space between each menu item

    // Arrow positions
    int                         m_iUpArrowXPos;                 // X Position of our up arrow
    int                         m_iUpArrowYPos;                 // Y Position of our up arrow
    int                         m_iDownArrowXPos;               // X Position of our down arrow
    int                         m_iDownArrowYPos;               // Y Position of our down arrow

    // Menu Item Font info
    unsigned int                m_uiMenuItemFontHeight;         // Font height of a menu item
    unsigned int                m_uiMenuItemFontAliasLevel;     // Alias level of a menu item

    // Menu Selector border
    float                       m_fMenuItemSelectorBorder;      // Border surrounding the selected item
    DWORD                       m_dwMenuItemSelectorColor;      // Color of the selector bar

    // Menu Item Colors
    DWORD                       m_dwMenuItemEnabledFGColor;     // Foreground color for an enabled menu item
    DWORD                       m_dwMenuItemEnabledBGColor;     // Background color for an enabled menu item
    DWORD                       m_dwMenuItemDisabledFGColor;    // Foreground color for a disabled menu item
    DWORD                       m_dwMenuItemDisabledBGColor;    // Background color for a disabled menu item
    DWORD                       m_dwMenuItemHighlightedFGColor; // Foreground color for a highlighted menu item
    DWORD                       m_dwMenuItemHighlightedBGColor; // Background color for a highlighted menu item

    // Selected Item Colors
    DWORD                       m_dwSelectedItemFGColor;        // Selected Item foreground color
    DWORD                       m_dwSelectedItemBGColor;        // Selected Item background color
    DWORD                       m_dwSelectedItemHLFGColor;      // Selected/Highlighted Item foreground color
    DWORD                       m_dwSelectedItemHLBGColor;      // Selected/Highlighted Item background color

    // Methods
    virtual void HandleControlInputSingleList( enum CONTROLS controlPressed,    // Handle control input for a single list menu
                                               BOOL bFirstPress );

    virtual void HandleControlInputMultiList( enum CONTROLS controlPressed,     // Handle control input for a double list menu
                                              BOOL bFirstPress );

    virtual BOOL HandleInputDelay( BOOL bFirstPress );          // Handle the default delay before for Input - TRUE if button should be processed

    virtual void RenderMenuItems( CUDTexture* pTexture );       // Render the menu items properly on our menu
    virtual void RenderSelector( CUDTexture* pTexture );        // Render the selector for our menu
    virtual void RenderScreenItems( CUDTexture* pTexture );     // Render the screen items properly on our menu
    virtual void RenderMenuTitle( CUDTexture* pTexture );       // Render the menu title on to the menu
    virtual void RenderDisplayArrows( CUDTexture* pTexture );   // Render the display arrows which will indicate more info off screen


    virtual void Leave( CXItem* pItem );                // Should be called whenever user is leaving the menu

    virtual HRESULT UpdateMenuItem( unsigned int uiIndex,   // Update an existing menu item
                                    WCHAR* pwszItemName,
                                    BOOL bHighlighted,
                                    BOOL bEnabled,
                                    WCHAR* pwszItemValue=NULL );

    virtual HRESULT AddMenuItem( XFONT* pFont,          // Used to add Menu Items to the current Menu
                                 WCHAR* pwszItemName,
                                 BOOL bHighlighted,
                                 BOOL bEnabled,
                                 int nItemValue,
                                 XFONT* pValueFont=NULL,
                                 WCHAR* pwszItemValue=NULL );

    virtual HRESULT AddTextItem( XFONT* pFont,          // Add a Text Item to our Screen object list
                                 WCHAR* pwszText,
                                 float fXPos,
                                 float fYPos,
                                 DWORD dwFGColor,
                                 DWORD dwBGColor );

    virtual HRESULT AddPanelItem( float fX1Pos,         // Add a PanelItem to our Screen object list
                                  float fY1Pos,
                                  float fX2Pos,
                                  float fY2Pos,
                                  DWORD dwColor );

    virtual HRESULT AddLineItem( float fX1Pos,          // Add a Line Item to our Screen object list
                                 float fY1Pos,
                                 float fX2Pos,
                                 float fY2Pos,
                                 float fWidth,
                                 DWORD dwColor );

    virtual HRESULT AddOutlineItem( float fX1Pos,       // Add a Outline Item to our Screen object list
                                    float fY1Pos,
                                    float fX2Pos,
                                    float fY2Pos,
                                    float fWidth,
                                    DWORD dwColor );

    virtual HRESULT AddBitmapItem( char* pszFilename,   // Add a Bitmap Item to our Screen object list
                                   int nXPos,
                                   int nYPos );

    virtual HRESULT AddBitmapAlphaItem( char* pszFilename,   // Add a Bitmap Item (with Alpha) to our Screen object list
                                        char* pszAlphaFilename,
                                        int nXPos,
                                        int nYPos );
};

#endif // _MENUSCREEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\PolyObject.h ===
/******************************************************
** polyobject.h
** 
** A basic polygon object capable of rendering itself
**
** 03/09/2001
** by James N. Helm
******************************************************/

#ifndef _POLYOBJECT_H_
#define _POLYOBJECT_H_

class CPolyObject
{
public:
    // Constructors and Destructors
    CPolyObject( void );
    ~CPolyObject( void );

    // Public Properties
    
    // Public Methods
    void Initialize( const IDirect3DDevice8* pD3DDevice,    // Setup our Vertex Buffer and Poly Points
                     const float fScreenWidth,
                     const float fScreenHeight );
    
    void Render( const IDirect3DDevice8* pD3DDevice );      // Render the poly to the backbuffer

private:
    // Private Properties
    IDirect3DVertexBuffer8* m_pVertexBuffer;                // Vertex buffer for our Polygon

    // Private Methods
    void CleanUp( void );                                         // Clean up any memory we have allocated
};

#endif // _POLYOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\messagemenu.h ===
/*****************************************************
*** messagemenu.h
***
*** Header file for our Message Menu class.
*** This menu will present a message to the user, and
*** simply allow them to navigate back from where they
*** came.
***
*** by James N. Helm
*** December 11th, 2001
***
*****************************************************/

#ifndef _MESSAGEMENU_H_
#define _MESSAGEMENU_H_

#include "menuscreen.h"

const float gc_fMESSAGE_TEXT_YPOS =                 125.0f;
const float gc_fOK_BUTTON_YPOS =                    315.0f;
const float gc_fOK_BUTTON_BORDER =                  10.0f;

const unsigned int gc_uiMESS_MENU_NUM_TEXT_LINES =  5;

class CMessageMenu : public CMenuScreen
{
public:
    // Constructors and Destructor
    CMessageMenu( void );
    ~CMessageMenu( void );

    // Public Methods
    HRESULT Init( XFONT* pMenuItemFont,             // Initialize the Menu
                  XFONT* pMenuTitleFont );
    void HandleInput( enum BUTTONS buttonPressed,   // Handles input (of the BUTTONS) for the current menu
                      BOOL bFirstPress );
    void SetText( WCHAR* pwszMessage );             // Used to set the text message that will be displayed to the user
protected:
    void RenderMenuItems( CUDTexture* pTexture );   // Render the menu items properly on our menu

private:
    WCHAR m_apwszTextMessage[gc_uiMESS_MENU_NUM_TEXT_LINES][MAX_PATH+1];	// Used to hold the text message
};

#endif // _MESSAGEMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\PolyObject.cpp ===
#include "stdafx.h"
#include "polyobject.h"

// Contstructor
CPolyObject::CPolyObject( void )
: m_pVertexBuffer( NULL )
{
}

// Destructor
CPolyObject::~CPolyObject( void )
{
    // Destroy any memory, etc, that we have allocated
    CleanUp();
}


// Clean up any memory allocated, etc.
void CPolyObject::CleanUp( void )
{
    // Clean up our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }
}


// Initialize our data, including our vertext buffer
void CPolyObject::Initialize( const IDirect3DDevice8* pD3DDevice, const float fScreenWidth, const float fScreenHeight )
{
    // Clean up anything that was previously allocated
    CleanUp();

    // Setup our vertices
    MYTEXVERTEX* pb = NULL;

    // Create our vertex buffer
    pD3DDevice->CreateVertexBuffer( sizeof( MYTEXVERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = 0.0f;         pb[0].v.y = 0.0f;          pb[0].v.z = 0.1f; pb[0].fRHW = 0.9f; pb[0].diffuse = gc_dwCOLOR_WHITE; pb[0].tu = 0.0f;         pb[0].tv = 0.0f;
    pb[1].v.x = fScreenWidth; pb[1].v.y = 0.0f;          pb[1].v.z = 0.1f; pb[1].fRHW = 0.9f; pb[1].diffuse = gc_dwCOLOR_WHITE; pb[1].tu = fScreenWidth; pb[1].tv = 0.0f;
    pb[2].v.x = fScreenWidth; pb[2].v.y = fScreenHeight; pb[2].v.z = 0.1f; pb[2].fRHW = 0.9f; pb[2].diffuse = gc_dwCOLOR_WHITE; pb[2].tu = fScreenWidth; pb[2].tv = fScreenHeight;
    pb[3].v.x = 0.0f;         pb[3].v.y = fScreenHeight; pb[3].v.z = 0.1f; pb[3].fRHW = 0.9f; pb[3].diffuse = gc_dwCOLOR_WHITE; pb[3].tu = 0.0f;         pb[3].tv = fScreenHeight;

    m_pVertexBuffer->Unlock();
}


// Render the Poly to the screen
void CPolyObject::Render( const IDirect3DDevice8* pD3DDevice )
{
    pD3DDevice->SetVertexShader( D3DFVF_MYTEXVERTEX );
    pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( MYTEXVERTEX ) );
    pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\resultsmenu.h ===
/*****************************************************
*** resultsmenu.h
***
*** Header file for our Results Menu class.
*** This class will parse the results file and
*** display the data to the user
***
*** by James N. Helm
*** December 7th, 2001
***
*****************************************************/

#ifndef _RESULTSMENU_H_
#define _RESULTSMENU_H_

class CTestResult;

#include "menuscreen.h"

const WCHAR  gc_pwszRESULTS_NO_RESULTS_MESSAGE[] =      L"No test results were found.";
const float  gc_fRESULTS_NO_RESULTS_TEXT_YPOS =         175.0f;
const unsigned int g_cuiRESULTSFILE_LINE_SIZE =         4096;       // Size of the buffer to read info from our file
const unsigned int g_cuiRESULTS_TEST_NOTES_SIZE =       3072;       // Size of the buffer for our test notes
const unsigned int g_cuiRESULTS_TEST_NAME_SIZE =        MAX_PATH;   // Size of the buffer for our test name

class CResultsMenu : public CMenuScreen
{
public:
    // Constructors and Destructor
    CResultsMenu( void );
    ~CResultsMenu( void );

    // Public Methods
    HRESULT Init( XFONT* pMenuItemFont,             // Initialize the Menu
                  XFONT* pMenuTitleFont );

    void HandleInput( enum CONTROLS controlPressed, // Handles input from the controls
                      BOOL bFirstPress );

    void RenderMenuItems( CUDTexture* pTexture );   // Used to render the menu items on the screen

    void Enter( void );                             // This should be called whenever the menu is entered or activated

private:
    // Properties
    CLinkedList< CTestResult* > m_TestResults;      // List of test results
    BOOL m_bFileProcessed;                          // Used to determine if the results file was already processed

    // Methods
    HRESULT ProcessResultsFile( void );             // Parse the results file and create the list of Passed / Fail info
    void GoToHelp( void );                          // Sets up and goes to the help menu
    void UpdateScreenItems( void );                 // Updates the screen items depending upon screen dimensions
};


////////////////////////////////////////
////////////////////////////////////////
//// CTestResult Class
////////////////////////////////////////
////////////////////////////////////////
class CTestResult
{
public:
    CTestResult( void );
    ~CTestResult( void );

    WCHAR* GetTestName( void )                              // Get the name of the test
        { return m_pwszTestName; };
    unsigned __int64 GetPassed( void )                      // Get the number of passes for this test
        { return m_ui64Passed; };
    unsigned __int64 GetFailed( void )                      // Get the number of failures for this test
        { return m_ui64Failed; };
    char* GetTestNotes( void )                              // Get the notes for the test
        { return m_pszTestNotes; };

    void SetTestName( WCHAR* pszTestName );                 // Set the name of the test
    void SetPassed( unsigned __int64 ui64Passed )           // Set the number of passes for this test
        { m_ui64Passed = ui64Passed; };
    void SetFailed( unsigned __int64 ui64Failed )           // Set the number of fails for this test
        { m_ui64Failed = ui64Failed; };
    void SetTestNotes( char* pszTestNotes );                // Store the test notes
    void Update( WCHAR* pwszTestName,                       // Update all fields at once
                 unsigned __int64 ui64Passed,               
                 unsigned __int64 ui64Failed,
                 char* pszTestNotes );

    // Operators
    BOOL operator>( const CTestResult& item );
    BOOL operator<( const CTestResult& item );
    BOOL operator==( const CTestResult& item );

private:
    WCHAR* m_pwszTestName;
    unsigned __int64 m_ui64Passed;
    unsigned __int64 m_ui64Failed;
    char* m_pszTestNotes;
};

#endif // _RESULTSMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\resultsmenu.cpp ===
/*****************************************************
*** resultsmenu.cpp
***
*** CPP file for our Results Menu class.
*** This class will parse the results file and
*** display the data to the user
***
*** by James N. Helm
*** December 7th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "resultsmenu.h"

// Constructors and Destructor
CResultsMenu::CResultsMenu( void ) :
m_bFileProcessed( FALSE )
{
    m_TestResults.SetDeleteDataItem( TRUE );
}

CResultsMenu::~CResultsMenu( void )
{
    m_TestResults.EmptyList();
}

// Initialize the Menu
HRESULT CResultsMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CResultsMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

    SetMenuAreaBoundaries( gc_fLEFT_MENU_AREA_BOUNDARY,
                           gc_fTOP_MENU_AREA_BOUNDARY + m_uiMenuItemFontHeight + m_fMenuItemVertSpace,
                           gc_fRIGHT_MENU_AREA_BOUNDARY,
                           gc_fBOTTOM_MENU_AREA_BOUNDARY );


	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Test Results" );

    /////////////////////////
    // Add screen items here
    /////////////////////////
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status bar column 1
    AddTextItem( GetButtonFont(), L"B",             gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetBodyFont(),   L" Back",         gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetButtonFont(), L"H",             gc_fSTATUS_TEXT_COL1_XPOS - 5,                       gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_BACK_BUTTON,    gc_dwSTATUS_TEXT_BG_COLOR );
	AddTextItem( GetBodyFont(),   L" Test Notes",   gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    return hr;
}


// Updates the screen items depending upon screen dimensions
void CResultsMenu::UpdateScreenItems( void )
{
    // Header text for results columns
    AddTextItem( GetBodyFont(), L"Test Name", gc_fLEFT_MENU_AREA_BOUNDARY + gc_fLEFT_MENU_AREA_BORDER,                                                       gc_fTOP_MENU_AREA_BOUNDARY + m_fTopMenuAreaBorder, gc_dwCOLOR_TEXT_YELLOW, gc_dwCOLOR_DARK_GREY );
    AddTextItem( GetBodyFont(), L"Passed",    ( m_fRightMenuAreaBoundary - 100 ) - GetStringPixelWidth( GetBodyFont(), L"Passed" ) - m_fRightMenuAreaBorder, gc_fTOP_MENU_AREA_BOUNDARY + m_fTopMenuAreaBorder, gc_dwCOLOR_TEXT_YELLOW, gc_dwCOLOR_DARK_GREY );
    AddTextItem( GetBodyFont(), L"Failed",    m_fRightMenuAreaBoundary - GetStringPixelWidth( GetBodyFont(), L"Failed" ) - m_fRightMenuAreaBorder,           gc_fTOP_MENU_AREA_BOUNDARY + m_fTopMenuAreaBorder, gc_dwCOLOR_TEXT_YELLOW, gc_dwCOLOR_DARK_GREY );
}


// Handles input (of the CONTROLS) for the current menu
void CResultsMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    if( CONTROL_BACK != controlPressed )
    {
        CMenuScreen::HandleInput( controlPressed, bFirstPress );

        return;
    }

    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( controlPressed )
    {
    case CONTROL_BACK:
        {
            GoToHelp();

            break;
        }
	}
}


// Render the menu items properly on our menu
void CResultsMenu::RenderMenuItems( CUDTexture* pTexture )
{
    // Don't render anything if we don't have any menu items
    if( 0 == GetNumMenuItems() )
    {
        // Display Message Here
        float fXPos = gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), gc_pwszRESULTS_NO_RESULTS_MESSAGE ) / 2 );
        float fYPos = gc_fRESULTS_NO_RESULTS_TEXT_YPOS;

        pTexture->DrawText( GetBodyFont(), fXPos, fYPos, m_dwMenuItemEnabledFGColor, m_dwMenuItemEnabledBGColor, L"%ls", gc_pwszRESULTS_NO_RESULTS_MESSAGE );
        return;
    }

    m_MenuItems.MoveTo( GetTopItemIndex() );    // Start at menu item that needs to be displayed
    m_TestResults.MoveTo( GetTopItemIndex() );
    for( unsigned int x = GetTopItemIndex(); x <= GetBottomItemIndex(); ++x )
    {
        // Determine where on the screen the menu item should be
        float fXPos = m_fLeftMenuAreaBoundary + m_fLeftMenuAreaBorder;
        float fYPos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * ( x - GetTopItemIndex() ) );

        // Determine the color of the item
        DWORD dwItemColorFG, dwItemColorBG;

        // Distinguish between enabled and disabled items
        if( m_MenuItems.GetCurrentNode()->m_bEnabled )
        {
            // Check to see if it's highlighted
            if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
            {
                if( x == GetSelectedItem() )
                {
                    dwItemColorFG = m_dwSelectedItemHLFGColor;
                    dwItemColorBG = m_dwSelectedItemHLBGColor;
                }
                else
                {
                    dwItemColorFG = m_dwMenuItemHighlightedFGColor;
                    dwItemColorBG = m_dwMenuItemHighlightedBGColor;
                }
            }
            else
            {
                if( x == GetSelectedItem() )
                {
                    dwItemColorFG = m_dwSelectedItemFGColor;
                    dwItemColorBG = m_dwSelectedItemBGColor;
                }
                else
                {
                    dwItemColorFG = m_dwMenuItemEnabledFGColor;
                    dwItemColorBG = m_dwMenuItemEnabledBGColor;
                }
            }
        }
        else
        {
            dwItemColorFG = m_dwMenuItemDisabledFGColor;
            dwItemColorBG = m_dwMenuItemDisabledBGColor;
        }

        pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwItemColorFG, dwItemColorBG, m_MenuItems.GetCurrentNode()->m_pwszItemName );

        WCHAR pwszMenuValue[MAX_PATH+1];
        pwszMenuValue[MAX_PATH] = L'\0';

        // Draw the PASSED values
        _snwprintf( pwszMenuValue, MAX_PATH, L"%u", m_TestResults.GetCurrentNode()->GetPassed() );

        // Draw the value right justified
        fXPos = ( m_fRightMenuAreaBoundary - 100 ) - GetStringPixelWidth( m_MenuItems.GetCurrentNode()->m_pFont, pwszMenuValue ) - m_fRightMenuAreaBorder;
        pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwItemColorFG, dwItemColorBG, pwszMenuValue );

        // Draw the FAILED values
        _snwprintf( pwszMenuValue, MAX_PATH, L"%u", m_TestResults.GetCurrentNode()->GetFailed() );

        // Draw the value right justified
        fXPos = m_fRightMenuAreaBoundary - GetStringPixelWidth( m_MenuItems.GetCurrentNode()->m_pFont, pwszMenuValue ) - m_fRightMenuAreaBorder;
        pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwItemColorFG, dwItemColorBG, pwszMenuValue );

        m_MenuItems.MoveNext();
        m_TestResults.MoveNext();
    }
}


// This should be called whenever the menu is entered or activated
void CResultsMenu::Enter( void )
{
    CMenuScreen::Enter();

    if( !m_bFileProcessed )
    {
        m_bFileProcessed = TRUE;

        // Empty our menu items
        ClearMenuItems();

        // Process the results file and create our menu items
        ProcessResultsFile();

        // Update our screen items
        UpdateScreenItems();
    }
}


// Parse the results file and create the list of Passed / Fail info
HRESULT CResultsMenu::ProcessResultsFile( void )
{
    // Clear our current Test Results
    m_TestResults.EmptyList();

    // Open the results file
    FILE* pfRes = fopen( gc_pszResultsFile, "rt" );
    if( NULL == pfRes )
    {
        DebugPrint( "CResultsMenu::ProcessResultsFile():Failed to open the results file!! - '%hs'\n", gc_pszResultsFile );
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    unsigned int uiCount = 0;
    unsigned __int64 ui64Pass, ui64Fail;
    WCHAR* pwszTestName = new WCHAR[g_cuiRESULTS_TEST_NAME_SIZE];
    char* pszTestNotes = new char[g_cuiRESULTS_TEST_NOTES_SIZE];
    WCHAR* pwszFileLine = new WCHAR[g_cuiRESULTSFILE_LINE_SIZE];
    
    if( ( NULL == pwszFileLine ) || ( NULL == pszTestNotes ) || ( NULL == pwszTestName ) )
    {
        DebugPrint( "CResultsMenu::ProcessResultsFile():Failed to allocate memory!!\n" );
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    while( NULL != fgetws( pwszFileLine, g_cuiRESULTSFILE_LINE_SIZE, pfRes ) )
    {
        // Make sure we have a vaild data line
        if( !( ( pwszFileLine[0] > L'0' && pwszFileLine[0] < L'9' ) ||
               ( pwszFileLine[0] > L'A' && pwszFileLine[0] < L'Z' ) ||
               ( pwszFileLine[0] > L'a' && pwszFileLine[0] < L'z' ) ) )
            continue;

        // Remove any comments that might be in the line
        WCHAR* wc = wcschr( pwszFileLine, ';' );
        if( NULL != wc ) *wc = L'\0';
        wc = wcschr( pwszFileLine, L'[' );
        if( NULL != wc ) *wc = L'\0';

        RightTrim( pwszFileLine );

        // If we fail to parse the line, return an error
        int iResult = swscanf( pwszFileLine, L"%[^,], %I64u, %I64u, \"%h[^\"]", pwszTestName, &ui64Pass, &ui64Fail, pszTestNotes );
        if(  iResult != 4 )
        {
            if( 3 == iResult )
            {
                pszTestNotes[0] = '\0';
            }
            else
            {
                DebugPrint( "CResultsMenu::ProcessResultsFile():Failed to properly parse line!! - '%ls'\n", pwszFileLine );

                hr = E_FAIL;
                break;
            }
        }

        // Create a new Result object
        CTestResult* pTestResult = new CTestResult;
        if( NULL == pTestResult )
        {
            DebugPrint( "CResultsMenu::ProcessResultsFile():Unable to allocate memory!!\n" );

            hr = E_OUTOFMEMORY;
            break;
        }

        // Store the values in our Test Result
        pTestResult->Update( pwszTestName, ui64Pass, ui64Fail, pszTestNotes );

        // Store the Test Result in our list
        m_TestResults.AddNode( pTestResult );

        // Add a menu item with the test name
        AddMenuItem( GetBodyFont(), pwszTestName, FALSE, TRUE, uiCount++ );
    }

cleanup:
    // Clean up our allocated memory and close our files
    if( NULL != pwszFileLine ) delete[] pwszFileLine;
    if( NULL != pszTestNotes ) delete[] pszTestNotes;
    if( NULL != pwszTestName ) delete[] pwszTestName;
    if( NULL != pfRes ) fclose( pfRes );

    // Set our pointers to NULL
    pwszFileLine = NULL;
    pszTestNotes = NULL;
    pwszTestName = NULL;
    pfRes = NULL;

    return hr;
}


// Sets up and goes to the help menu
void CResultsMenu::GoToHelp( void )
{
    // Check to see if there are any test notes.  If not, simply bail
    if( '\0' == m_TestResults.GetNode( GetSelectedItem() )->GetTestNotes()[0] )
        return;

    // Set the menu title
    WCHAR pwszTitle[50];
    pwszTitle[49] = L'\0';

    _snwprintf( pwszTitle, 49, L"%ls Test Notes", m_TestResults.GetNode( GetSelectedItem() )->GetTestName() );
    GetHelpMenuPtr()->SetMenuTitle( GetHeaderFont(), pwszTitle );

    // Set the back pointer for the help menu
    GetHelpMenuPtr()->SetBackPtr( this );

    // Clear the current help
    GetHelpMenuPtr()->ClearHelpItems();

    // Populate the help menu with info in the test notes
    WCHAR pwszTempStr[MAX_PATH+1];
    char pszLine[MAX_PATH+1];

    pwszTempStr[MAX_PATH] = L'\0';
    pszLine[MAX_PATH] = '\0';

    char* pszTestNotes = m_TestResults.GetNode( GetSelectedItem() )->GetTestNotes();
    char* pszTestNotesPtr = pszTestNotes;
    char* pszNewLinePtr;

    // Determine if there are any "\n's" in the string
    while( NULL != ( pszNewLinePtr = strstr( pszTestNotesPtr, "\\n" ) ) )
    {
        // Copy the string segment to a temp char string
        strncpy( pszLine, pszTestNotesPtr, pszNewLinePtr - pszTestNotesPtr );
        pszLine[pszNewLinePtr - pszTestNotesPtr] = '\0';

        // Copy the line of text to a WCHAR string and add it to our help
        _snwprintf( pwszTempStr, MAX_PATH, L"%hs", pszLine );

        GetHelpMenuPtr()->AddHelpItem( GetBodyFont(),
                                       pwszTempStr,
                                       GetBodyFont(),
                                       L"" );

        // Skip the remaining portion of the \n
        pszTestNotesPtr = pszNewLinePtr + 2;
    }

    // Copy the last string (that won't have a \n)
    _snwprintf( pwszTempStr, MAX_PATH, L"%hs", pszTestNotesPtr );
    
    GetHelpMenuPtr()->AddHelpItem( GetBodyFont(),
                                   pwszTempStr,
                                   GetBodyFont(),
                                   L"" );

    // navigate to the menu
    Leave( GetHelpMenuPtr() );
}


////////////////////////////////////////
////////////////////////////////////////
//// CTestResult Class
////////////////////////////////////////
////////////////////////////////////////

// Constructor
CTestResult::CTestResult( void ) :
m_pwszTestName( NULL ),
m_ui64Passed( 0 ),
m_ui64Failed( 0 ),
m_pszTestNotes( NULL )
{
}

// Destructor
CTestResult::~CTestResult( void )
{
    if( NULL != m_pszTestNotes )
    {
        delete[] m_pszTestNotes;
        m_pszTestNotes = NULL;
    }

    if( NULL != m_pwszTestName )
    {
        delete[] m_pwszTestName;
        m_pwszTestName = NULL;
    }
}


// Operators
BOOL CTestResult::operator>( const CTestResult& item )
{
    if( _wcsicmp( m_pwszTestName, item.m_pwszTestName ) > 0 )
        return TRUE;

    return FALSE;
}

BOOL CTestResult::operator<( const CTestResult& item )
{
    if( _wcsicmp( m_pwszTestName, item.m_pwszTestName ) < 0 )
        return TRUE;

    return FALSE;
}

BOOL CTestResult::operator==( const CTestResult& item )
{
    if( _wcsicmp( m_pwszTestName, item.m_pwszTestName ) == 0 )
        return TRUE;

    return FALSE;
}


// Set the name of the test
void CTestResult::SetTestName( WCHAR* pwszTestName )
{
    if( NULL == pwszTestName )
        return;

    if( NULL != m_pwszTestName )
    {
        delete[] m_pwszTestName;
        m_pwszTestName = NULL;
    }

    m_pwszTestName = new WCHAR[wcslen( pwszTestName ) + 1];
    if( NULL == m_pwszTestName )
    {
        DebugPrint( "CTestResult::SetTestName():Failed to allocate memory!!\n" );
        return;
    }

    // Copy the test name in to our newly allocated memory
    wcscpy( m_pwszTestName, pwszTestName );
}


// Store the test notes
void CTestResult::SetTestNotes( char* pszTestNotes )
{
    if( NULL == pszTestNotes )
        return;

    if( NULL != m_pszTestNotes )
    {
        delete[] m_pszTestNotes;
        m_pszTestNotes = NULL;
    }

    m_pszTestNotes = new char[strlen( pszTestNotes )+1];
    if( NULL == m_pszTestNotes )
    {
        DebugPrint( "CTestResult::SetTestNotes():Unable to allocate memory!!\n" );

        return;
    }

    strcpy( m_pszTestNotes, pszTestNotes );
}


// Update all fields at once
void CTestResult::Update( WCHAR* pwszTestName, unsigned __int64 ui64Passed, unsigned __int64 ui64Failed, char* pszTestNotes )
{
    if( NULL == pwszTestName )
        return;

    SetTestName( pwszTestName );
    SetPassed( ui64Passed );
    SetFailed( ui64Failed );
    SetTestNotes( pszTestNotes );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\screenitem.h ===
/*****************************************************
*** screenitem.h
***
*** Header file for our abstract base class for a
*** generic screen item.
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#ifndef _SCREENITEM_H_
#define _SCREENITEM_H_

#include "udtexture.h"

class CScreenItem
{
public:
    // Constructors and Destructors
    CScreenItem( void );
    virtual ~CScreenItem( void );

    // Every screen item should know how to render itself
    virtual void Render( CUDTexture* pTexture ) = 0;

    virtual BOOL operator < ( const CScreenItem& item ) { return FALSE; };
    virtual BOOL operator > ( const CScreenItem& item ) { return FALSE; };
    virtual BOOL operator == ( const CScreenItem& item ) { return FALSE; };

protected:
};

#endif // _SCREENITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\screenitem.cpp ===
/*****************************************************
*** screenitem.cpp
***
*** CPP file for our abstract base class for a
*** generic screen item.
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#include "stdafx.h"
#include "screenitem.h"

// Constructor
CScreenItem::CScreenItem( void )
{
};

// Destructor
CScreenItem::~CScreenItem( void )
{ 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\rommenu.cpp ===
/*****************************************************
*** rommenu.cpp
***
*** CPP file for our ROM Menu class.
*** This menu will allow the user to select a ROM and
*** flash it to their Xbox.
***
*** by James N. Helm
*** January 21st, 2002
***
*****************************************************/

#include "stdafx.h"
#include "rommenu.h"

extern PVOID KernelRomBase;

// Constructors and Destructor
CROMMenu::CROMMenu( void ) :
m_eCurrentAction( ENUM_ROMMENU_NOACTION ),
m_pucROMImage( NULL )
{
}

CROMMenu::~CROMMenu( void )
{
    if( NULL != m_pucROMImage )
    {
        LocalFree( m_pucROMImage );
        m_pucROMImage = NULL;
    }
}

// Initialize the Menu
HRESULT CROMMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CROMMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"ROM Flash Menu" );

    // Add screen items here
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status Bar Column 1
    AddTextItem( GetButtonFont(), L"A",             gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Flash ROM",    gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"B",             gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Back",         gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

	
	// Add menu items here -- Find all the roms and list them
    WIN32_FIND_DATA wfd;
    ZeroMemory( &wfd, sizeof( wfd ) );

    HANDLE hRomFiles = FindFirstFile( "d:\\roms\\*.bin", &wfd );
    if( INVALID_HANDLE_VALUE != hRomFiles )
    {
        WCHAR pwszFileName[MAX_PATH+1];
        pwszFileName[MAX_PATH] = L'\0';

        do
        {
            // Add the file name to our menu
            swprintf( pwszFileName, L"%hs", wfd.cFileName );

            AddMenuItem( pMenuItemFont, pwszFileName, FALSE, TRUE, 0 );
        } while( FindNextFile( hRomFiles, &wfd ) );

        FindClose( hRomFiles );
        hRomFiles = INVALID_HANDLE_VALUE;
    }

    return hr;
}

// Renders to the texture and calls any per-frame processing
void CROMMenu::Action( CUDTexture* pTexture )
{
    // Make sure we handle any user initiated actions
    ProcessMenuActions();

    if( ( m_eCurrentAction != ENUM_ROMMENU_NOACTION ) && ( m_eCurrentAction != ENUM_ROMMENU_FLASHINGROM_MESSAGE ) )
        return;

    // Call the base class function
    CMenuScreen::Action( pTexture );
}

// Render the selector for our menu
void CROMMenu::RenderSelector( CUDTexture* pTexture )
{
    if( ENUM_ROMMENU_FLASHINGROM_MESSAGE == m_eCurrentAction )
        return;
    else
        CMenuScreen::RenderSelector( pTexture );
}

// Render the menu items properly on our menu
void CROMMenu::RenderMenuItems( CUDTexture* pTexture )
{
    if( 0 == GetNumMenuItems() )
    {
        // Display Message Here
        float fXPos = gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), gc_pwszROMMENU_NO_ROMS_MESSAGE ) / 2 );
        float fYPos = gc_fROMMENU_TEXT_YPOS;

        pTexture->DrawText( GetBodyFont(), fXPos, fYPos, m_dwMenuItemEnabledFGColor, m_dwMenuItemEnabledBGColor, L"%ls", gc_pwszROMMENU_NO_ROMS_MESSAGE );
    }
    else if( ENUM_ROMMENU_FLASHINGROM_MESSAGE == m_eCurrentAction )
    {
        // Display Message Here
        float fXPos = 0.0f;
        float fYPos = gc_fROMMENU_TEXT_YPOS;

        for( unsigned int i = 0; i < ARRAYSIZE(gc_pwszROMMENU_FLASHING_ROM_MESSAGE); i++ )
        {
            fXPos = gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), (WCHAR*)gc_pwszROMMENU_FLASHING_ROM_MESSAGE[i] ) / 2 );
            fYPos = gc_fROMMENU_TEXT_YPOS + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * i );

            pTexture->DrawText( GetBodyFont(), fXPos, fYPos, m_dwMenuItemEnabledFGColor, m_dwMenuItemEnabledBGColor, L"%ls", gc_pwszROMMENU_FLASHING_ROM_MESSAGE[i] );
        }
    }
    else
    {
        CMenuScreen::RenderMenuItems( pTexture );
    }
}

// Handles input (of the BUTTONS) for the current menu
void CROMMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // If it's a repeat press, let's bail
    if( !bFirstPress )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            WCHAR pwszMessage[MAX_PATH+1];  // Used to display various messages to the user
            pwszMessage[MAX_PATH] = L'\0';

            // Load the ROM image in to memory
            char pszROMFileName[MAX_PATH+1];
            pszROMFileName[MAX_PATH] = '\0';

            _snprintf( pszROMFileName, MAX_PATH, "d:\\roms\\%ls", m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName );

            if( FAILED( LoadROMImage( pszROMFileName ) ) )
            {
                DebugPrint( "CROMMenu::HandleInput():Unable to load the ROM image!! - '%hs'\n", pszROMFileName );

                // Display a failure Message to the user
                _snwprintf( pwszMessage, MAX_PATH, L"ROM load was unsuccessful!!\n\nThe ROM that was attempted:\n%ls", m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName );

				GetMessagePtr()->SetBackPtr( this );
                GetMessagePtr()->SetText( pwszMessage );
                Leave( GetMessagePtr() );
            }
            else
            {
                // Check the ROM Version so that we can display the proper message
				BYTE byImageVer, byXboxROMVer;
                if( !CheckROMVersion( &byImageVer, &byXboxROMVer ) )
                    _snwprintf( pwszMessage, MAX_PATH, L"Image ROM version (0x%02X)  Xbox ROM version (0x%02X)\n/c%ld %ld VERSIONS DO NOT MATCH!!\n\nAre you sure you wish to flash the ROM with\n/c%ld %ld %ls?", byImageVer, byXboxROMVer, gc_dwCOLOR_TVSAFE_RED, m_dwMenuItemEnabledBGColor, gc_dwCOLOR_TEXT_YELLOW, m_dwMenuItemEnabledBGColor, m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName );
                else
                    _snwprintf( pwszMessage, MAX_PATH, L"Image ROM version (0x%02X)  Xbox ROM version (0x%02X)\nVersions Match\n\nAre you sure you wish to flash the ROM with\n/c%ld %ld %ls?", byImageVer, byXboxROMVer, gc_dwCOLOR_TEXT_YELLOW, m_dwMenuItemEnabledBGColor, m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName );

                // Go get the users permission (YES / NO menu)
                m_eCurrentAction = ENUM_ROMMENU_FLASHCONFIG_YESNO;

                GetYesNoPtr()->SetBackPtr( this );
                GetYesNoPtr()->SetMenuTitle( GetBodyFont(), L"ROM Flash" );

                GetYesNoPtr()->SetText( pwszMessage );

                Leave( GetYesNoPtr() );
            }

            break;
        }
    case BUTTON_B:
        {
            GoBack();

            break;
        }
    }
}


// If the user is performing an action, this will handle it
void CROMMenu::ProcessMenuActions( void )
{
    switch( m_eCurrentAction )
    {
    case ENUM_ROMMENU_FLASHCONFIG_YESNO:
        {
            if( !GetYesNoPtr()->GetCancelled() )
            {
                // Get the Configuration Name
                m_eCurrentAction = ENUM_ROMMENU_FLASHINGROM_MESSAGE;

            }
            else
            {
                m_eCurrentAction = ENUM_ROMMENU_NOACTION;  // Make sure we set this to no action

                // Unload the loaded ROM Image
                if( NULL != m_pucROMImage )
                {
                    LocalFree( m_pucROMImage );
                    m_pucROMImage = NULL;
                }
            }

            break;
        }
    case ENUM_ROMMENU_FLASHINGROM_MESSAGE:
        {
            // Make sure we set this to our program action
            m_eCurrentAction = ENUM_ROMMENU_FLASHINGROM_PROGRAM;
            UpdateTexture();
            
            break;
        }
    case ENUM_ROMMENU_FLASHINGROM_PROGRAM:
        {
            // Make sure we set this to no action
            m_eCurrentAction = ENUM_ROMMENU_NOACTION;

            // Flash the ROM
            HRESULT hFlashResult = FlashROMImage();

            // Unload the loaded ROM Image
            if( NULL != m_pucROMImage )
            {
                LocalFree( m_pucROMImage );
                m_pucROMImage = NULL;
            }

            GetMessagePtr()->SetBackPtr( this );

            WCHAR pwszMessage[MAX_PATH+1];
            pwszMessage[MAX_PATH] = L'\0';
            
            if( FAILED( hFlashResult ) )
                _snwprintf( pwszMessage, MAX_PATH, L"ROM flash was unsuccessful!!\nThe ROM that was attempted:\n%ls", m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName );
            else
                _snwprintf( pwszMessage, MAX_PATH, L"ROM flashed successfully!!\nThe ROM that was flashed:\n%ls\nYou should cold reboot for the ROM to take affect.", m_MenuItems.GetNode( GetSelectedItem() )->m_pwszItemName );

            GetMessagePtr()->SetText( pwszMessage );
            Leave( GetMessagePtr() );

            break;
        }
    }
}


// Load the ROM image in to memory
HRESULT CROMMenu::LoadROMImage( char* pszROMFileName )
{
    //
    // Load the ROM image
    //

    if( NULL != m_pucROMImage )
    {
        LocalFree( m_pucROMImage );
        m_pucROMImage = NULL;
    }

    m_pucROMImage = (PUCHAR) LocalAlloc( LMEM_FIXED, ROM_SIZE );
    if( NULL == m_pucROMImage )
    {
        DebugPrint( "CROMMenu::LoadROMImage():Could not allocate ROM image memory!!\n" );

        return E_OUTOFMEMORY;
    }

    //
    // Open the ROM Image file
    //
    HANDLE hROMFileHandle = CreateFile( pszROMFileName,
                                        GENERIC_READ,
                                        0,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL );

    if( INVALID_HANDLE_VALUE == hROMFileHandle )
    {
        DebugPrint( "CROMMenu::LoadROMImage():Could not open the ROM file!! - '%hs'\n", pszROMFileName );

        LocalFree( m_pucROMImage );
        m_pucROMImage = NULL;

        return E_FAIL;
    }

    //
    // Read in the ROM
    //

    ULONG ulSizeOfDataReturned = 0;
    PUCHAR pucROMData = m_pucROMImage;
    while( ReadFile( hROMFileHandle, pucROMData, ROM_SIZE - ( pucROMData - m_pucROMImage ), &ulSizeOfDataReturned, NULL)
           && ( 0 != ulSizeOfDataReturned ) )
    {
        pucROMData += ulSizeOfDataReturned;
    }
    
    CloseHandle( hROMFileHandle );
    hROMFileHandle = INVALID_HANDLE_VALUE;

    if( ROM_SIZE != ( pucROMData - m_pucROMImage ) )
    {
        DebugPrint( "CROMMenu::LoadROMImage():Could not read ROM image file, read %d out of %d bytes!!\n", ( pucROMData - m_pucROMImage ), ROM_SIZE );

        LocalFree( m_pucROMImage );
        m_pucROMImage = NULL;

        return E_FAIL;
    }

    return S_OK;
}


// Flash the ROM image to the Xbox
HRESULT CROMMenu::FlashROMImage( void )
{
    // Check to make sure we have loaded a ROM image before attempting the flash
    if( NULL == m_pucROMImage )
    {
        DebugPrint( "CROMMenu::FlashROMImage():You need to load a ROM image first!!\n" );
        
        return E_FAIL;
    }

    //
    // Flash the ROM
    //
    DebugPrint( "CROMMenu::FlashROMImage():Starting ROM Flash...\n" );

    HRESULT hrFlash = S_OK;

    for( unsigned int i = 0; i < ROM_FLASH_RETRIES; i++ )
    {
        CHAR szResp[128];
        hrFlash = FlashKernelImage( m_pucROMImage,
                                    ROM_SIZE,
                                    szResp,
                                    ARRAYSIZE( szResp ) );

        DebugPrint( "CROMMenu::FlashROMImage():Flash Status (%d): hr=0x%08x (%hs)\n", i, hrFlash, szResp );

        if( SUCCEEDED( hrFlash ) )
            break;
    }

    if( ROM_FLASH_RETRIES == i )
    {
        DebugPrint( "CROMMenu::FlashROMImage():Could not flash ROM, hr=0x%08x\n", hrFlash );

        return hrFlash;
    }


    return S_OK;
}


// Check to make sure the version of the ROM matches the Xbox
BOOL CROMMenu::CheckROMVersion( BYTE* pbyImageVer/*=NULL*/, BYTE* pbyXboxROMVer/*=NULL*/ )
{
    // Check to make sure we have loaded a ROM image before attempting to check the version
    if( NULL == m_pucROMImage )
    {
        DebugPrint( "CROMMenu::CheckROMVersion():You need to load a ROM image first!!\n" );

        return FALSE;
    }

    //
    // Map top 1MB of physical memory of ROM region (FFF00000-FFFFFFFF)
    //

    KernelRomBase = MmMapIoSpace( FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                  PAGE_READWRITE | PAGE_NOCACHE );

    if ( NULL == KernelRomBase )
    {
        DebugPrint( "CROMMenu::CheckROMVersion():Unable to map i/o space!!\n" );

        return FALSE;
    }

    BYTE byXboxROMVersion = FlashReadByte( FLASH_BASE_ADDRESS + ROM_VERSION_BYTE_OFFSET );
    BYTE byImageVersion = ((PBYTE)m_pucROMImage)[ROM_VERSION_BYTE_OFFSET];

    DebugPrint( "CheckROMVersion():XBOX ROM Ver: 0x%02X, Image ROM Ver 0x%02X\n", byXboxROMVersion, byImageVersion );

    // Unmap I/O Space
    MmUnmapIoSpace( KernelRomBase, FLASH_REGION_SIZE );
    KernelRomBase = NULL;

	//
	// Pass back the proper values if the user wants them
	//
	if( NULL != pbyImageVer )
		*pbyImageVer = byImageVersion;

	if( NULL != pbyXboxROMVer )
		*pbyXboxROMVer = byXboxROMVersion;

	//
	// Return whether the versions match (TRUE), or do not match (FALSE)
	//
    if( byXboxROMVersion != byImageVersion )
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\rommenu.h ===
/*****************************************************
*** rommenu.h
***
*** Header file for our ROM Menu class.
*** This menu will allow the user to select a ROM and
*** flash it to their Xbox.
***
*** by James N. Helm
*** January 21st, 2002
***
*****************************************************/

#ifndef _ROMMENU_H_
#define _ROMMENU_H_

#include "flashutils.h"
#include "menuscreen.h"

const WCHAR  gc_pwszROMMENU_NO_ROMS_MESSAGE[] =                 L"No ROMs were found.";
static const WCHAR*  gc_pwszROMMENU_FLASHING_ROM_MESSAGE[] =
{
    L"Please wait.  Updating the ROM...",
    L"(Do not reboot or power off!)"
};
const float  gc_fROMMENU_TEXT_YPOS =                            125.0f;

#define ROM_SIZE                                                (1024 * 1024)
#define ROM_FLASH_RETRIES                                       25
#define ROM_VERSION_BYTE_OFFSET                                 0x78
#define ARRAYSIZE(a)                                            (sizeof(a) / sizeof(a[0]))

enum ROMMENU_ACTIONS
{
    ENUM_ROMMENU_NOACTION,
    ENUM_ROMMENU_FLASHCONFIG_YESNO,
    ENUM_ROMMENU_FLASHINGROM_MESSAGE,
    ENUM_ROMMENU_FLASHINGROM_PROGRAM
};

class CROMMenu : public CMenuScreen
{
public:
    // Constructors and Destructor
    CROMMenu( void );
    ~CROMMenu( void );

    // Public Methods
    HRESULT Init( XFONT* pMenuItemFont,                     // Initialize the Menu
                  XFONT* pMenuTitleFont );
    void Action( CUDTexture* pTexture );                    // Renders to the texture and calls any per-frame processing
    void RenderSelector( CUDTexture* pTexture );            // Render the selector for our menu
    void RenderMenuItems( CUDTexture* pTexture );           // Render the menu items properly on our menu
    void HandleInput( enum BUTTONS buttonPressed,           // Handles input (of the BUTTONS) for the current menu
                      BOOL bFirstPress );                   
                                                            
private:                                                    
    // Properties
    PUCHAR m_pucROMImage;                                   // Pointer to our ROM image that will be flashed
    enum ROMMENU_ACTIONS m_eCurrentAction;                  // Used to track the current action of the user
    
    // Methods
    void ProcessMenuActions( void );                        // If the user is performing an action, this will handle it
    HRESULT LoadROMImage( char* pszROMFileName );           // Load the ROM image in to memory
    HRESULT FlashROMImage( void );                          // Flash the ROM image on to the Xbox
    BOOL CheckROMVersion( BYTE* pbyImageVer = NULL,			// Check to make sure the version of the ROM matches the Xbox
						  BYTE* pbyXboxROMVer = NULL );
};

#endif // _ROMMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\testconfig.h ===
/*****************************************************
*** testconfig.h
***
*** Header file for our Test Config info class.
*** This class will hold information on a
*** configuration for a test.
*** 
*** by James N. Helm
*** December 5th, 2001
*** 
*****************************************************/

#ifndef _TESTCONFIG_H_
#define _TESTCONFIG_H_

#include "configitems.h"

class CTestConfig
{
public:
    CTestConfig( void );
    CTestConfig( const CTestConfig& TestConfig );
    ~CTestConfig( void );

    // Operators
    CTestConfig& operator=( const CTestConfig& TestConfig );

    long m_lConfigVersion;                                      // Used to determine which config version we should use
    CLinkedList< CConfigItem* > m_ConfigItems;                  
                                                                
    // Methods                                                  
    void AddConfigItem( CConfigItem* pConfigItem )              // Add a config item to our list
        { m_ConfigItems.AddNode( pConfigItem ); };              
                                                                
    unsigned int GetNumConfigItems( void ) const;               // Returns the number of config items this configuration contains
    void SetConfigVersion( long lVersion )                      // Set the configuration version
        { m_lConfigVersion = lVersion; };
    long GetConfigVersion( void ) const                         // Return the current configuration version
        { return m_lConfigVersion; };
    void ClearConfigItems( void )                               // Clear out the config items
        { m_ConfigItems.EmptyList(); };

	BOOL MoveNextConfigItem( void );                            // Move to the next config item in the list
	BOOL MovePrevConfigItem( void );                            // Move to the prev config item in the list
	BOOL MoveFirstConfigItem( void );                           // Move to the first config item in the list
	BOOL MoveLastConfigItem( void );                            // Move to the last config item in the list
	CConfigItem* GetCurrentConfigItem( void ) const;            // Get the config item that is currently being pointed to
	CConfigItem* GetConfigItem( unsigned int uiIndex ) const;   // Get the config item at the specified index

    // Operators
    BOOL operator>( const CTestConfig& item );
    BOOL operator<( const CTestConfig& item );
    BOOL operator==( const CTestConfig& item );
};

#endif // _TESTCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\screenitems.cpp ===
/*****************************************************
*** screenitems.cpp
***
*** CPP file for our screen item classes.
*** This file will contain the definition for all
*** types of screen items
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#include "stdafx.h"
#include "screenitems.h"

extern IDirect3DDevice8* g_pD3DDevice;  // Pointer to our Direct3D Device Object


/*****************************************************
/* CTextItem( void )
/****************************************************/

// Constructor
CTextItem::CTextItem( void ) :
CScreenItem(),
m_pFont( NULL ),
m_pwszText( NULL ),
m_fXPos( 0.0f ),
m_fYPos( 0.0f ),
m_dwFGColor( 0L ),
m_dwBGColor( 0L )
{
}

// Destructor
CTextItem::~CTextItem( void )
{
    // Clean up our allocated memory
    if( m_pwszText )
    {
        delete[] m_pwszText;
        m_pwszText = NULL;
    }
}

// Allows the user to update the information for the Text Item
void CTextItem::UpdateItem( XFONT* pFont, WCHAR* pwszText, float fXPos, float fYPos, DWORD dwFGColor, DWORD dwBGColor )
{
    // Ensure we were passed a valid pointer
    if( NULL == pwszText || NULL == pFont )
    {
        DebugPrint( "CTextItem()::UpdateItem():pwszText was invalid!!\n" );

        return;
    }

    // If we have already set a text item, lets clear the memory so we can allocate new memory
    if( m_pwszText )
    {
        delete[] m_pwszText;
        m_pwszText = NULL;
    }

    // Create new memory and copy the string that was passed in by the user
    int iStrLen = wcslen( pwszText );
    m_pwszText = new WCHAR[iStrLen + 1];
    if( !m_pwszText )
    {
        // Check to see if we could allocate memory -- If not, assert!!
        DebugPrint( "CTextItem()::UpdateItem():Couldn't allocate memory!!\n" );
    }
    else
    {
        ZeroMemory( m_pwszText, sizeof( WCHAR ) * (iStrLen + 1) );
        wcscpy( m_pwszText, pwszText );
    }
   
    // Set our other parameters
    m_pFont = pFont;
    m_fXPos = fXPos;
    m_fYPos = fYPos;
    m_dwFGColor = dwFGColor;
    m_dwBGColor = dwBGColor;
}


// Used to render itself to the screen
void CTextItem::Render( CUDTexture* pTexture )
{
    pTexture->DrawText( m_pFont, m_fXPos, m_fYPos, m_dwFGColor, m_dwBGColor, L"%s", m_pwszText );
}

/*****************************************************
/* CPanelItem( void )
/****************************************************/

// Constructor
CPanelItem::CPanelItem( void ) :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
CPanelItem::~CPanelItem( void )
{
}

// Allows the user to update the information for the Panel Item
void CPanelItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void CPanelItem::Render( CUDTexture* pTexture )
{
    pTexture->DrawBox( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_dwColor );
}


/*****************************************************
/* CLineItem( void )
/****************************************************/
// Constructor
CLineItem::CLineItem( void ) :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_fWidth( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
CLineItem::~CLineItem( void )
{
}

// Allows the user to update the information for the Outline Item
void CLineItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_fWidth = fWidth;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void CLineItem::Render( CUDTexture* pTexture )
{
    pTexture->DrawLine( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_fWidth, m_dwColor );
}


/*****************************************************
/* COutlineItem( void )
/****************************************************/
// Constructor
COutlineItem::COutlineItem( void ) :
CScreenItem(),
m_fX1Pos( 0.0f ),
m_fY1Pos( 0.0f ),
m_fX2Pos( 0.0f ),
m_fY2Pos( 0.0f ),
m_fWidth( 0.0f ),
m_dwColor( 0L )
{
}

// Destructor
COutlineItem::~COutlineItem( void )
{
}

// Allows the user to update the information for the Outline Item
void COutlineItem::UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor )
{
    m_fX1Pos = fX1Pos;
    m_fY1Pos = fY1Pos;
    m_fX2Pos = fX2Pos;
    m_fY2Pos = fY2Pos;
    m_fWidth = fWidth;
    m_dwColor = dwColor;
}

// Used to render itself to the screen
void COutlineItem::Render( CUDTexture* pTexture )
{
    pTexture->DrawOutline( m_fX1Pos, m_fY1Pos, m_fX2Pos, m_fY2Pos, m_fWidth, m_dwColor );
}


/*****************************************************
/* CBitmapItem( void )
/****************************************************/
// Constructor
CBitmapItem::CBitmapItem( void ) :
CScreenItem(),
m_pszFilename( NULL ),
m_nXPos( 0 ),
m_nYPos( 0 )
{
}

// Destructor
CBitmapItem::~CBitmapItem( void )
{
    // Clean up our memory
    if( m_pszFilename )
    {
        delete[] m_pszFilename;
        m_pszFilename = NULL;
    }
}

// Allows the user to update the information for the Outline Item
void CBitmapItem::UpdateItem( char* pszFilename, int nXPos, int nYPos )
{
    // Ensure we were passed a valid pointer
    if( !pszFilename )
    {
        DebugPrint( "CBitmapItem()::UpdateItem():pszFilename was invalid!!\n" );

        return;
    }

    // If we have already set a text item, lets clear the memory so we can allocate new memory
    if( m_pszFilename )
    {
        delete[] m_pszFilename;
        m_pszFilename = NULL;
    }

    // Create new memory and copy the string that was passed in by the user
    int iStrLen = strlen( pszFilename );
    m_pszFilename = new char[iStrLen + 1];
    if( !m_pszFilename )
    {
        // Check to see if we could allocate memory -- If not, assert!!
        DebugPrint( "CBitmapItem()::UpdateItem():Couldn't allocate memory!!\n" );

        return;
    }
    else
    {
        ZeroMemory( m_pszFilename, iStrLen + 1 );
        strcpy( m_pszFilename, pszFilename );
    }

    m_nXPos = nXPos;
    m_nYPos = nYPos;

    m_Bitmap.read( m_nXPos, m_nYPos, m_pszFilename );
}

// Used to render itself to the screen
void CBitmapItem::Render( CUDTexture* pTexture )
{
    m_Bitmap.render( g_pD3DDevice, pTexture->GetTextureSurface() );
}


/*****************************************************
/* CBitmapAlphaItem( void )
/****************************************************/
// Constructor
CBitmapAlphaItem::CBitmapAlphaItem( void ) :
m_pszFilename( NULL ),
m_pszAlphaFilename( NULL ),
m_nXPos( 0 ),
m_nYPos( 0 )
{
}

// Destructor
CBitmapAlphaItem::~CBitmapAlphaItem( void )
{
    // Clean up our memory
    if( NULL != m_pszFilename )
    {
        delete[] m_pszFilename;
        m_pszFilename = NULL;
    }

    if( NULL != m_pszAlphaFilename )
    {
        delete[] m_pszAlphaFilename;
        m_pszAlphaFilename = NULL;
    }
}

// Allows the user to update the information for the Outline Item
void CBitmapAlphaItem::UpdateItem( char* pszFilename, char* pszAlphaFilename, int nXPos, int nYPos )
{
    // Ensure we were passed a valid pointer
    if( NULL == pszFilename || NULL == pszAlphaFilename )
    {
        DebugPrint( "CBitmapItem()::UpdateItem():pszFilename was invalid!!\n" );

        return;
    }

    // If we have already set a text item, lets clear the memory so we can allocate new memory
    if( NULL != m_pszFilename )
    {
        delete[] m_pszFilename;
        m_pszFilename = NULL;
    }

    if( NULL != m_pszAlphaFilename )
    {
        delete[] m_pszAlphaFilename;
        m_pszAlphaFilename = NULL;
    }

    // Create new memory and copy the string that was passed in by the user
    m_pszFilename = new char[strlen( pszFilename ) + 1];
    if( !m_pszFilename )
    {
        // Check to see if we could allocate memory -- If not, assert!!
        DebugPrint( "CBitmapItem()::UpdateItem():Couldn't allocate memory!!\n" );

        return;
    }
    else
    {
        strcpy( m_pszFilename, pszFilename );
    }

    m_pszAlphaFilename = new char[strlen( pszAlphaFilename ) + 1];
    if( NULL == m_pszAlphaFilename )
    {
        // Check to see if we could allocate memory -- If not, assert!!
        DebugPrint( "CBitmapItem()::UpdateItem():Couldn't allocate memory!!\n" );

        return;
    }
    else
    {
        strcpy( m_pszAlphaFilename, pszAlphaFilename );
    }

    m_nXPos = nXPos;
    m_nYPos = nYPos;

    m_Bitmap.readWithAlpha( m_nXPos, m_nYPos, m_pszFilename, m_pszAlphaFilename );
}

// Used to render itself to the screen
void CBitmapAlphaItem::Render( CUDTexture* pTexture )
{
    m_Bitmap.render( g_pD3DDevice, pTexture->GetTextureSurface() );
}


/******************************
*** Menu Item Class
******************************/
CMenuItem::CMenuItem( void )
: m_pFont( NULL ),
m_pValueFont( NULL ),
m_bHighlighted( FALSE ),
m_bEnabled( TRUE ),
m_nItemValue( 0 )
{
    ZeroMemory( m_pwszItemName, sizeof( WCHAR ) * 256 );
    ZeroMemory( m_pwszItemValue, sizeof( WCHAR ) * 256 );
};

CMenuItem::~CMenuItem( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\screenitems.h ===
/*****************************************************
*** screenitems.h
***
*** Header file for our screen item classes.
*** This file will contain the definition for all
*** types of screen items
*** 
*** by James N. Helm
*** January 13th, 2001
*** 
*****************************************************/

#ifndef _SCREENITEMS_H_
#define _SCREENITEMS_H_

#include "screenitem.h"
#include "bitmapfile.h"

/*****************************************************
/* CTextItem( void )
/****************************************************/
class CTextItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CTextItem( void );
    ~CTextItem( void );

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( XFONT* pFont, WCHAR* pwszText, float fXPos, float fYPos, DWORD dwFGColor, DWORD dwBGColor );

private:
    XFONT* m_pFont;
    WCHAR* m_pwszText;
    float m_fXPos;
    float m_fYPos;
    DWORD m_dwFGColor;
    DWORD m_dwBGColor;
};


/*****************************************************
/* CPanelItem( void )
/****************************************************/
class CPanelItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CPanelItem( void );
    ~CPanelItem( void );

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        DWORD m_dwColor;
};


/*****************************************************
/* CLineItem( void )
/****************************************************/
class CLineItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CLineItem( void );
    ~CLineItem( void );

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        float m_fWidth;
        DWORD m_dwColor;
};


/*****************************************************
/* COutlineItem( void )
/****************************************************/
class COutlineItem : public CScreenItem
{
public:
    // Constructors and Destructors
    COutlineItem( void );
    ~COutlineItem( void );

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( float fX1Pos, float fY1Pos, float fX2Pos, float fY2Pos, float fWidth, DWORD dwColor );

private:
        float m_fX1Pos;
        float m_fY1Pos;
        float m_fX2Pos;
        float m_fY2Pos;
        float m_fWidth;
        DWORD m_dwColor;
};


/*****************************************************
/* CBitmapItem( void )
/****************************************************/
class CBitmapItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CBitmapItem( void );
    ~CBitmapItem( void );

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( char* pszFilename, int nXPos, int nYPos );
	int GetBitmapHeight( void ) { return m_Bitmap.GetHeight(); };
	int GetBitmapWidth( void ) { return m_Bitmap.GetWidth(); };

private:
    BitmapFile m_Bitmap;

    char* m_pszFilename;
    int m_nXPos;
    int m_nYPos;
};


/*****************************************************
/* CBitmapAlphaItem( void )
/****************************************************/
class CBitmapAlphaItem : public CScreenItem
{
public:
    // Constructors and Destructors
    CBitmapAlphaItem( void );
    ~CBitmapAlphaItem( void );

    // Must create this for all CScreenItem classes
    void Render( CUDTexture* pTexture );

    // Allow the user to update the item
    void UpdateItem( char* pszFilename, char* pszAlphaFilename, int nXPos, int nYPos );
	int GetBitmapHeight( void ) { return m_Bitmap.GetHeight(); };
	int GetBitmapWidth( void ) { return m_Bitmap.GetWidth(); };

private:
    BitmapFile m_Bitmap;

    char* m_pszFilename;
    char* m_pszAlphaFilename;
    int m_nXPos;
    int m_nYPos;
};


/*****************************************************
/* CMenuItem( void )
/****************************************************/
class CMenuItem
{
public:
    // Constructors and Destructors
    CMenuItem( void );
    ~CMenuItem( void );

    XFONT* m_pFont;             // The font that will be used to render this menu item
    WCHAR m_pwszItemName[256];  // The text representation of the current menu item
    XFONT* m_pValueFont;        // The font that will be used to render the item value
    WCHAR m_pwszItemValue[256]; // The text representation of the current menu item value (can be NULL)
    BOOL m_bHighlighted;        // Used to determine if the current menu item is highlighted
    BOOL m_bEnabled;            // Used to determine if the current menu item is enabled
    int m_nItemValue;           // Used to determine which item is selected (Should be unique for items within the same menu)

    // Operators
    BOOL operator < ( const CMenuItem& item ) { return FALSE; };
    BOOL operator > ( const CMenuItem& item ) { return FALSE; };
    BOOL operator == ( const CMenuItem& item ) { return FALSE; };

private:
};

#endif //_SCREENITEMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\testconfig.cpp ===
/*****************************************************
*** testconfig.cpp
***
*** CPP file for our Test Config info class.
*** This class will hold information on a
*** configuration for a test.
*** 
*** by James N. Helm
*** December 5th, 2001
*** 
*****************************************************/

#include "stdafx.h"
#include "testconfig.h"

// Constructors
CTestConfig::CTestConfig( void ) :
m_lConfigVersion( 0l )
{
    m_ConfigItems.SetDeleteDataItem( TRUE );
}

// Copy Constructor
CTestConfig::CTestConfig( const CTestConfig& TestConfig )
{
    *this = TestConfig;
}

// Destructor
CTestConfig::~CTestConfig( void )
{
    ClearConfigItems();
}

// Assignment Operator
CTestConfig& CTestConfig::operator=( const CTestConfig& TestConfig )
{
    if( &TestConfig == this )
        return *this;

    // Clear out any data that was already here
    ClearConfigItems();

    SetConfigVersion( TestConfig.GetConfigVersion() );

    // Copy all of the config items
    for( unsigned int x = 0; x < TestConfig.GetNumConfigItems(); x++ )
    {
        CConfigItem* pConfigItem = TestConfig.GetConfigItem( x );
        CConfigItem* pNewConfigItem = NULL;

        // Determine which type of config item it is
        if( 0 == _wcsicmp( pConfigItem->GetType(), L"number" ) )
        {
            pNewConfigItem = (CConfigItem*)new CConfigNumber;
            if( NULL == pNewConfigItem )
            {
                DebugPrint( "CTestConfig::operator=():Unable to allocate memory!!\n" );

                break;
            }

            *((CConfigNumber*)pNewConfigItem) = *((CConfigNumber*)pConfigItem);
        }
        else if( 0 == _wcsicmp( pConfigItem->GetType(), L"range" ) )
        {
            pNewConfigItem = (CConfigItem*)new CConfigRange;
            if( NULL == pNewConfigItem )
            {
                DebugPrint( "CTestConfig::operator=():Unable to allocate memory!!\n" );

                break;
            }
            
            *((CConfigRange*)pNewConfigItem) = *((CConfigRange*)pConfigItem);
        }
        else if( 0 == _wcsicmp( pConfigItem->GetType(), L"string" ) )
        {
            pNewConfigItem = (CConfigItem*)new CConfigString;
            if( NULL == pNewConfigItem )
            {
                DebugPrint( "CTestConfig::operator=():Unable to allocate memory!!\n" );

                break;
            }
            
            *((CConfigString*)pNewConfigItem) = *((CConfigString*)pConfigItem);
        }
        else if( 0 == _wcsicmp( pConfigItem->GetType(), L"string2" ) )
        {
            pNewConfigItem = (CConfigItem*)new CConfigString2;
            if( NULL == pNewConfigItem )
            {
                DebugPrint( "CTestConfig::operator=():Unable to allocate memory!!\n" );

                break;
            }
            
            *((CConfigString2*)pNewConfigItem) = *((CConfigString2*)pConfigItem);
        }
        else if( 0 == _wcsicmp( pConfigItem->GetType(), L"numberstring" ) )
        {
            pNewConfigItem = (CConfigItem*)new CConfigNumberString;
            if( NULL == pNewConfigItem )
            {
                DebugPrint( "CTestConfig::operator=():Unable to allocate memory!!\n" );

                break;
            }
            
            *((CConfigNumberString*)pNewConfigItem) = *((CConfigNumberString*)pConfigItem);
        }

        AddConfigItem( pNewConfigItem );
    }

    return *this;
}

// Returns the number of config items this configuration contains
unsigned int CTestConfig::GetNumConfigItems( void ) const
{
    return m_ConfigItems.GetNumItems();
}


// Move the next config item in the list
BOOL CTestConfig::MoveNextConfigItem( void )
{
    return m_ConfigItems.MoveNext();
}


// Move the prev config item in the list
BOOL CTestConfig::MovePrevConfigItem( void )
{
    return m_ConfigItems.MovePrev();
}


// Move the first config item in the list
BOOL CTestConfig::MoveFirstConfigItem( void )
{
    return m_ConfigItems.MoveFirst();
}


// Move the last config item in the list
BOOL CTestConfig::MoveLastConfigItem( void )
{
    return m_ConfigItems.MoveLast();
}


// Get the config item that is currently being pointed to
CConfigItem* CTestConfig::GetCurrentConfigItem( void ) const
{
    return m_ConfigItems.GetCurrentNode();
}


// Get the config item at the specified index
CConfigItem* CTestConfig::GetConfigItem( unsigned int uiIndex ) const
{
    return m_ConfigItems.GetNode( uiIndex );
}

// Operators
BOOL CTestConfig::operator>( const CTestConfig& item )
{
    return FALSE;
}

BOOL CTestConfig::operator<( const CTestConfig& item )
{
    return FALSE;
}

BOOL CTestConfig::operator==( const CTestConfig& item )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\udtexture.cpp ===
/*****************************************************
*** udtexture.cpp
***
*** CPP file for our udtexture class.  This class
*** will hold a texture and allow the user to perform
*** certain actions on this texture, like writing
*** text, etc
*** 
*** by James N. Helm
*** January 24th, 2001
***
*** Modified
*** 03/09/2001 - James N. Helm
*** 11/20/2001 - James N. Helm
*****************************************************/
#include "stdafx.h"
#include "udtexture.h"

// Constructor
CUDTexture::CUDTexture( void ) :
m_pD3DDevice( NULL ),
m_pTexture( NULL ),
m_pTextureSurface( NULL ),
m_pCurrentRenderTarget( NULL ),
m_pVertexBuffer( NULL ),
m_pCurrentVBuffer( NULL ),
m_uiCurrentStride( 0 ),
m_iTextureWidth( 0 ),
m_iTextureHeight( 0 ),
m_uiTextureLockedRef( 0 )
{
}


// Destructor
CUDTexture::~CUDTexture( void )
{
    // CleanUp any memory we have allocated
    CleanUp();
}

// Clean up any memory we have allocated
void CUDTexture::CleanUp( void )
{
    // Release our surface if needed
    if( NULL != m_pTextureSurface )
    {
        m_pTextureSurface->Release();
        m_pTextureSurface = NULL;
    }

    // Release our Vertex Buffer
    if( m_pVertexBuffer )
    {
        m_pVertexBuffer->Release();
        m_pVertexBuffer = NULL;
    }

    // Release our texture if needed
    if( NULL != m_pTexture )
    {
        m_pTexture->Release();
        m_pTexture = NULL;
    }

    // Release our D3D Device
    if( NULL != m_pD3DDevice )
    {
        m_pD3DDevice->Release();
        m_pD3DDevice = NULL;
    }
}


// Clear the texture
void CUDTexture::Clear( DWORD dwColor )
{
    // Clear the texture here
    m_pD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET, dwColor, 1.0f, 0 );
}


// Draw a box on to the texture
void CUDTexture::DrawBox( float fX1, float fY1, float fX2, float fY2, DWORD dwColor )
{
    UDTEXTURE_VERTEX* pb = NULL;

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

	pb[0].v.x = fX1; pb[0].v.y = fY1; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = dwColor;
	pb[1].v.x = fX2; pb[1].v.y = fY1; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = dwColor;
	pb[2].v.x = fX2; pb[2].v.y = fY2; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = dwColor;
	pb[3].v.x = fX1; pb[3].v.y = fY2; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = dwColor;

    m_pVertexBuffer->Unlock();

    // Make sure that edge antialiasing is off for this call!
    DWORD dwEdgeCurrentState = 0;

    m_pD3DDevice->GetRenderState( D3DRS_EDGEANTIALIAS, &dwEdgeCurrentState );
    m_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );

    // Draw the box
    m_pD3DDevice->DrawPrimitive( D3DPT_TRIANGLEFAN, 0, 2 );

    // Restore the Edge Antialiasing state
    m_pD3DDevice->SetRenderState( D3DRS_EDGEANTIALIAS, dwEdgeCurrentState );
}


// Draw a clear rectangle to the texture
void CUDTexture::DrawClearRect( float fX1, float fY1, float fX2, float fY2, DWORD dwColor )
{
	D3DRECT rect;

    rect.x1 = (long)fX1; 
	rect.x2 = (long)fX2 + 1;

    rect.y1 = (long)fY1;
	rect.y2 = (long)fY2 + 1;

    m_pD3DDevice->Clear( 1, &rect, D3DCLEAR_TARGET, dwColor, 0, 0 );
}


// Draw a line to the texture
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
void CUDTexture::DrawLine( float fX1, float fY1, float fX2, float fY2, float fLineWidth, DWORD dwColor )
{
    // Set the line width
    m_pD3DDevice->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth );

    UDTEXTURE_VERTEX* pb = NULL;

    m_pVertexBuffer->Lock( 0, 0, (BYTE**)&pb, 0 );

    pb[0].v.x = fX1;  pb[0].v.y = fY1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = dwColor;
	pb[1].v.x = fX2;  pb[1].v.y = fY2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = dwColor;

    m_pVertexBuffer->Unlock();

    m_pD3DDevice->DrawPrimitive( D3DPT_LINELIST, 0, 1 );
}


// Draw an outline to the texture
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CUDTexture::DrawOutline( float fX1, float fY1, float fX2, float fY2, float fLineWidth, DWORD dwColor )
{
    // Draw the box on the Texture
    DrawLine( fX1, fY1, fX1, fY2, fLineWidth, dwColor );     // Left Line
    DrawLine( fX1, fY2, fX2, fY2, fLineWidth, dwColor );     // Bottom Line
    DrawLine( fX2, fY2, fX2, fY1, fLineWidth, dwColor );     // Right Line
    DrawLine( fX2, fY1, fX1, fY1, fLineWidth, dwColor );     // Top Line
}


// Prints formatted text using the default font to the texture
void CUDTexture::DrawText( XFONT* pFont, float fX1, float fY1, DWORD dwFGColor, DWORD dwBGColor, const WCHAR* pwszFormat, ... )
{
	va_list ArgList;        // Argument List
    WCHAR wpszStr[256];     // Honkin Buffer

    va_start( ArgList, pwszFormat );

    // Create the formated string to place on to the surface
    int i = wvsprintfW( wpszStr, pwszFormat, ArgList );

    XFONT_SetTextColor( pFont, 0xFF000000 );
    XFONT_SetBkColor( pFont, 0xFF000000 );

    // Shadow
    XFONT_TextOut( pFont, m_pTextureSurface, wpszStr, i, (long)fX1+2, (long)fY1+2 );

    XFONT_SetTextColor( pFont, dwFGColor );
    XFONT_SetBkColor( pFont, dwBGColor );

    // Text
    XFONT_TextOut( pFont, m_pTextureSurface, wpszStr, i, (long)fX1, (long)fY1 );

	va_end( ArgList );
}


// Lock the texture surface so that we can render on to it
void CUDTexture::Lock( void )
{
    ++m_uiTextureLockedRef; // Increment our Reference count
    if( m_uiTextureLockedRef > 1 )
    {
        // Return if we've been previously locked
        return;
    }

    // Get the current render target so that we can replace it
    // after we render to our texture
    m_pD3DDevice->GetRenderTarget( &m_pCurrentRenderTarget );

    // Get the current stream source and stride so that we can replace it
    // after we finish rendering to our texture
    m_pD3DDevice->GetStreamSource( 0, &m_pCurrentVBuffer, &m_uiCurrentStride );

    if( m_pTextureSurface )
    {
        // Set our Texture surface to be our render target for all our primitive calls
        m_pD3DDevice->SetRenderTarget( m_pTextureSurface, NULL );

        // Set our stream source to be from our Vertex Buffer
        m_pD3DDevice->SetStreamSource( 0, m_pVertexBuffer, sizeof( UDTEXTURE_VERTEX ) );

        m_pD3DDevice->SetVertexShader( D3DFVF_UDTEXTURE_VERTEX );
    }
}


// Unlock the texture surface after we have rendered to it
void CUDTexture::Unlock( void )
{
    if( m_uiTextureLockedRef > 0 )
    {
        --m_uiTextureLockedRef; // Decrement our Reference count

        // If we are not at 0, we should return, otherwise clean up
        if( m_uiTextureLockedRef > 0 )
        {
            return;
        }
    }
    else // We must not have been locked, so simply return
    {
        return;
    }

    // Restore the original render target
    if( m_pCurrentRenderTarget )
    {
        m_pD3DDevice->SetRenderTarget( m_pCurrentRenderTarget, NULL );
        
        m_pCurrentRenderTarget->Release();
        m_pCurrentRenderTarget = NULL;
    }

    // Restore the original stream source
    if( m_pCurrentVBuffer )
    {
        m_pD3DDevice->SetStreamSource( 0, m_pCurrentVBuffer, m_uiCurrentStride );

        m_pCurrentVBuffer->Release();
        m_pCurrentVBuffer = NULL;
    }
}


// Initialize D3D for this screen
void CUDTexture::Initialize( IDirect3DDevice8* pD3DDevice, char* pszFileName=NULL, int iTextureWidth=512, int iTextureHeight=512 )
{
    // Make sure we don't leak
    CleanUp();

    pD3DDevice->AddRef();
    m_pD3DDevice = pD3DDevice;
    m_iTextureWidth = iTextureWidth;
    m_iTextureHeight = iTextureHeight;

    /////////////////////
    // Create our texture
    /////////////////////
    if( NULL != pszFileName )
    {
        D3DXCreateTextureFromFileExA( m_pD3DDevice, 
                                      pszFileName,
                                      D3DX_DEFAULT,    // width
                                      D3DX_DEFAULT,    // height
                                      D3DX_DEFAULT,    // mips number
                                      0,
                                      D3DFMT_A8R8G8B8,
                                      D3DPOOL_MANAGED,
                                      D3DX_FILTER_LINEAR,
                                      D3DX_FILTER_LINEAR,
                                      0,
                                      NULL,
                                      NULL,
                                        &m_pTexture );
    }
    else
    {
        m_pD3DDevice->CreateTexture( m_iTextureWidth,
                                     m_iTextureHeight,
                                     0,
                                     D3DUSAGE_RENDERTARGET,
                                     D3DFMT_LIN_A8R8G8B8, //D3DFMT_LIN_X8R8G8B8,
                                     0,
                                     &m_pTexture );
    }

    ///////////////////////////////
    // Get our surface from texture
    ///////////////////////////////
    m_pTexture->MoveResourceMemory( D3DMEM_VIDEO );
    m_pTexture->GetSurfaceLevel( 0, &m_pTextureSurface );

    ///////////////////////////////
    // Create a Vertex Buffer for
    // our Primitive Calls
    ///////////////////////////////
    m_pD3DDevice->CreateVertexBuffer( sizeof( UDTEXTURE_VERTEX ) * 4, 0, 0, 0, &m_pVertexBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\testconfigmenu.cpp ===
/****************************************************
*** testconfigmenu.cpp
***
*** CPP file for our Test Config Menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** November 27th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "testconfigmenu.h"

// Constructors and Destructor
CTestConfigMenu::CTestConfigMenu( void ) :
m_pXBEInfo( NULL ),
m_eCurrentAction( ENUM_TESTCONFMENU_NOACTION ),
m_uiSelectedConfigItem( 0 ),
m_lNum1Val( 0l ),
m_bMultiConfigs( TRUE )
{
}

CTestConfigMenu::~CTestConfigMenu( void )
{
}

// Initialize the Menu
HRESULT CTestConfigMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CTestConfigMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Test Config Menu (Config 1 of 1)" );

    // Adjust our on-screen menu items
    ClearScreenItems();

    /////////////////////////
    // Add screen items here
    /////////////////////////
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status Bar Column 1
    AddTextItem( GetButtonFont(), L"A",       gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Select", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"B",       gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Back",   gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    // Status Bar Column 2
    AddTextItem( GetButtonFont(), L"C",              gc_fSTATUS_TEXT_COL2_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_X_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Delete Config", gc_fSTATUS_TEXT_COL2_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"D",              gc_fSTATUS_TEXT_COL2_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_Y_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Create Config", gc_fSTATUS_TEXT_COL2_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    // Status Bar Column 3
    AddTextItem( GetButtonFont(), L"E",                gc_fSTATUS_TEXT_COL3_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_L_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Previous Config", gc_fSTATUS_TEXT_COL3_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"F",                gc_fSTATUS_TEXT_COL3_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_R_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Next Config",     gc_fSTATUS_TEXT_COL3_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );

    return hr;
}


// Renders to the texture and calls any per-frame processing
void CTestConfigMenu::Action( CUDTexture* pTexture )
{
    // Make sure we handle any user initiated actions
    ProcessMenuActions();

    if( ENUM_TESTCONFMENU_NOACTION != m_eCurrentAction )
        return;

    // Call the base class function
    CMenuScreen::Action( pTexture );
}


// Render the screen items properly on our menu
void CTestConfigMenu::RenderScreenItems( CUDTexture* pTexture )
{
    // Don't render anything if we don't have any screen items
    if( 0 == GetNumScreenItems() )
        return;

    m_ScreenItems.MoveFirst(); // Start at the 1st Item
    for( unsigned int x = 0; x < GetNumScreenItems(); ++x )
    {
        m_ScreenItems.GetCurrentNode()->Render( pTexture );
        m_ScreenItems.MoveNext();


        // If we don't support multiple configs, only render our first two buttons
        if( ( !m_bMultiConfigs ) && ( x == 4 ) )
            break;
    }
}


// Render the menu title on to the menu
void CTestConfigMenu::RenderMenuTitle( CUDTexture* pTexture )
{
    // Render the App Title here
    XFONT_SetTextHeight( GetHeaderFont(), 25 );
    pTexture->DrawText( GetHeaderFont(), gc_fLEFT_MENU_AREA_BORDER, 30, gc_dwCOLOR_TEXT_YELLOW, gc_dwCOLOR_DARK_GREY, L"HVS Launcher" );
    XFONT_SetTextHeight( GetHeaderFont(), gc_uiDEFAULT_FONT_HEIGHT );

	if( m_bMultiConfigs )
		pTexture->DrawText( GetHeaderFont(), gc_fLEFT_MENU_AREA_BORDER, 60, gc_dwCOLOR_TEXT_GREEN, gc_dwCOLOR_DARK_GREY, L"%ls (Config %u of %u)", GetMenuTitle(), m_pXBEInfo->GetCurrentTestConfigIndex() + 1, m_pXBEInfo->GetNumTestConfigs() );
	else
		pTexture->DrawText( GetHeaderFont(), gc_fLEFT_MENU_AREA_BORDER, 60, gc_dwCOLOR_TEXT_GREEN, gc_dwCOLOR_DARK_GREY, L"%ls", GetMenuTitle() );
}


// Render the menu items properly on our menu
void CTestConfigMenu::RenderMenuItems( CUDTexture* pTexture )
{
    // Don't render anything if we don't have any menu items
    if( 0 == GetNumMenuItems() )
        return;

    m_MenuItems.MoveTo( GetTopItemIndex() );    // Start at menu item that needs to be displayed
    for( unsigned int x = GetTopItemIndex(); x <= GetBottomItemIndex(); ++x )
    {
        // Determine where on the screen the menu item should be
        float fXPos = m_fLeftMenuAreaBoundary + m_fLeftMenuAreaBorder;
        float fYPos = m_fTopMenuAreaBoundary + m_fTopMenuAreaBorder + ( ( m_fMenuItemVertSpace + m_uiMenuItemFontHeight ) * ( x - GetTopItemIndex() ) );

        // Determine the color of the item
        DWORD dwItemColorFG, dwItemColorBG;

        // Distinguish between enabled and disabled items
        if( m_MenuItems.GetCurrentNode()->m_bEnabled )
        {
            // Check to see if it's highlighted
            if( m_MenuItems.GetCurrentNode()->m_bHighlighted )
            {
                if( x == GetSelectedItem() )
                {
                    dwItemColorFG = m_dwSelectedItemHLFGColor;
                    dwItemColorBG = m_dwSelectedItemHLBGColor;
                }
                else
                {
                    dwItemColorFG = m_dwMenuItemHighlightedFGColor;
                    dwItemColorBG = m_dwMenuItemHighlightedBGColor;
                }
            }
            else
            {
                if( x == GetSelectedItem() )
                {
                    dwItemColorFG = m_dwSelectedItemFGColor;
                    dwItemColorBG = m_dwSelectedItemBGColor;
                }
                else
                {
                    dwItemColorFG = m_dwMenuItemEnabledFGColor;
                    dwItemColorBG = m_dwMenuItemEnabledBGColor;
                }
            }
        }
        else
        {
            dwItemColorFG = m_dwMenuItemDisabledFGColor;
            dwItemColorBG = m_dwMenuItemDisabledBGColor;
        }

        pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwItemColorFG, dwItemColorBG, m_MenuItems.GetCurrentNode()->m_pwszItemName );

        WCHAR pwszMenuValue[MAX_PATH+1];
        pwszMenuValue[MAX_PATH] = L'\0';

        CTestConfig* pTestConfig = m_pXBEInfo->GetCurrentTestConfig();  // Store our current test config in a handy pointer

        if( 0 == _wcsicmp( pTestConfig->GetConfigItem( x )->GetType(), L"number" ) )
        {
            CConfigNumber* pConfigNumber = (CConfigNumber*)pTestConfig->GetConfigItem( x );

            _snwprintf( pwszMenuValue, MAX_PATH, L"%ld", pConfigNumber->GetDefault() );
        }
        else if( 0 == _wcsicmp( pTestConfig->GetConfigItem( x )->GetType(), L"range" ) )
        {
            CConfigRange* pConfigRange = (CConfigRange*)pTestConfig->GetConfigItem( x );

            _snwprintf( pwszMenuValue, MAX_PATH, L"%ld to %ld", pConfigRange->GetDefault1(), pConfigRange->GetDefault2() );
        }
        else if( 0 == _wcsicmp( pTestConfig->GetConfigItem( x )->GetType(), L"string" ) )
        {
            CConfigString* pConfigString = (CConfigString*)pTestConfig->GetConfigItem( x );

            _snwprintf( pwszMenuValue, MAX_PATH, L"%ls", pConfigString->GetCurrentString() );
        }
        else if( 0 == _wcsicmp( pTestConfig->GetConfigItem( x )->GetType(), L"string2" ) )
        {
            CConfigString2* pConfigString2 = (CConfigString2*)pTestConfig->GetConfigItem( x );

            _snwprintf( pwszMenuValue, MAX_PATH, L"%ls", pConfigString2->GetString() );
        }
        else if( 0 == _wcsicmp( pTestConfig->GetConfigItem( x )->GetType(), L"numberstring" ) )
        {
            CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pTestConfig->GetConfigItem( x );

            _snwprintf( pwszMenuValue, MAX_PATH, L"%ld %ls", pConfigNumberString->GetDefault(), pConfigNumberString->GetCurrentString() );
        }

        // Draw the value right justified
        fXPos = m_fRightMenuAreaBoundary - GetStringPixelWidth( m_MenuItems.GetCurrentNode()->m_pFont, pwszMenuValue ) - m_fRightMenuAreaBorder;
        pTexture->DrawText( m_MenuItems.GetCurrentNode()->m_pFont, fXPos, fYPos, dwItemColorFG, dwItemColorBG, pwszMenuValue );
        
        m_MenuItems.MoveNext();
    }
}


// Handles input from the buttons
void CTestConfigMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            CConfigItem* pConfigItem = m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

            // Check to see if our value is a string2.  If so, launch the keyboard
            if( 0 == wcscmp( pConfigItem->GetType(), L"string2" ) )
            {
                CConfigString2* pConfigString2 = (CConfigString2*)pConfigItem;
                m_uiSelectedConfigItem = GetSelectedItem();

                m_eCurrentAction = ENUM_TESTCONFMENU_EDITSTRING2;

                WCHAR pwszText[MAX_PATH+1];
                pwszText[MAX_PATH] = '\0';

                _snwprintf( pwszText, MAX_PATH, L"Enter the value for '%ls'", pConfigString2->GetFieldName() );

                GetKeyboardPtr()->SetBackPtr( this );
                GetKeyboardPtr()->SetInfo( pwszText, 40, pConfigString2->GetString() );

                Leave( GetKeyboardPtr() );
            }
            else if( 0 == wcscmp( pConfigItem->GetType(), L"numberstring" ) )
            {
                CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pConfigItem;
                m_uiSelectedConfigItem = GetSelectedItem();

                m_eCurrentAction = ENUM_TESTCONFMENU_EDIT_NUMBERSTRING;

                WCHAR pwszText[MAX_PATH+1];
                WCHAR pwszValText[MAX_PATH+1];
                pwszText[MAX_PATH] = '\0';
                pwszValText[MAX_PATH] = L'\0';

                _snwprintf( pwszText, MAX_PATH, L"Enter a number between %ld and %ld.", pConfigNumberString->GetMinimum(), pConfigNumberString->GetMaximum() );
                _snwprintf( pwszValText, MAX_PATH, L"%ld", pConfigNumberString->GetDefault() );

                GetKeypadPtr()->SetBackPtr( this );
                GetKeypadPtr()->SetInfo( pwszText, 15, pwszValText );

                Leave( GetKeypadPtr() );
            }
            else if( 0 == wcscmp( pConfigItem->GetType(), L"number" ) )
            {
                CConfigNumber* pConfigNumber = (CConfigNumber*)pConfigItem;
                m_uiSelectedConfigItem = GetSelectedItem();

                m_eCurrentAction = ENUM_TESTCONFMENU_EDIT_NUMBER;

                WCHAR pwszText[MAX_PATH+1];
                WCHAR pwszValText[MAX_PATH+1];
                pwszText[MAX_PATH] = '\0';
                pwszValText[MAX_PATH] = L'\0';

                _snwprintf( pwszText, MAX_PATH, L"Enter a number between %ld and %ld.", pConfigNumber->GetMinimum(), pConfigNumber->GetMaximum() );
                _snwprintf( pwszValText, MAX_PATH, L"%ld", pConfigNumber->GetDefault() );

                GetKeypadPtr()->SetBackPtr( this );
                GetKeypadPtr()->SetInfo( pwszText, 15, pwszValText );

                Leave( GetKeypadPtr() );
            }
            else if( 0 == wcscmp( pConfigItem->GetType(), L"range" ) )
            {
                CConfigRange* pConfigRange = (CConfigRange*)pConfigItem;
                m_uiSelectedConfigItem = GetSelectedItem();

                m_eCurrentAction = ENUM_TESTCONFMENU_EDIT_RANGE1;

                WCHAR pwszText[MAX_PATH+1];
                WCHAR pwszValText[MAX_PATH+1];
                pwszText[MAX_PATH] = L'\0';
                pwszValText[MAX_PATH] = L'\0';

                _snwprintf( pwszText, MAX_PATH, L"Enter #1 (between %ld and %ld)", pConfigRange->GetMinimum1(), pConfigRange->GetMaximum1() );
                _snwprintf( pwszValText, MAX_PATH, L"%ld", pConfigRange->GetDefault1() );

                GetKeypadPtr()->SetBackPtr( this );
                GetKeypadPtr()->SetInfo( pwszText, 15, pwszValText );

                Leave( GetKeypadPtr() );
            }
            break;
        }
    case BUTTON_X:
        {
            if( !m_bMultiConfigs )
                break;

            UpdateTexture();

            // Delete configuration
            m_pXBEInfo->DeleteCurrentTestConfig();

            break;
        }
    case BUTTON_Y:
        {
            if( !m_bMultiConfigs )
                break;

            UpdateTexture();

            // Create New Configuration
            m_pXBEInfo->AddNewTestConfig();

            break;
        }
    case BUTTON_B:
        {
            GoBack();

            break;
        }
    case BUTTON_RIGHT_TRIGGER:
        {
            if( !m_bMultiConfigs )
                break;

            UpdateTexture();
            
            // Move to the next test configuration
            m_pXBEInfo->MoveNextTestConfig();

            break;
        }
    case BUTTON_LEFT_TRIGGER:
        {
            if( !m_bMultiConfigs )
                break;

            UpdateTexture();

            // Move to the previous test configuration
            m_pXBEInfo->MovePrevTestConfig();

            break;
        }
    }
}

// Handle any requests for the joystick (thumb-pad)
void CTestConfigMenu::HandleInput( enum JOYSTICK joystick, int nThumbY, int nThumbX, BOOL bFirstYPress, BOOL bFirstXPress )
{
    switch( joystick )
    {
    // This is the LEFT Thumb Joystick on the controller
    case JOYSTICK_LEFT:
        {
            CMenuScreen::HandleInput( joystick, nThumbY, nThumbX, bFirstYPress, bFirstXPress );

            break;
        }
    case JOYSTICK_RIGHT:
        {
            // Yxc
            if( nThumbY < 0 )  // Move the right joystick down
            {

                // Process the default button delay
                if( !HandleInputDelay( bFirstYPress ) )
                    return;
                
                CConfigItem* pConfigItem = m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                // Check to see what type of item we are dealing with
                if( 0 == _wcsicmp( pConfigItem->GetType(), L"range" ) )
                {
                    UpdateTexture();

                    CConfigRange* pConfigRange = (CConfigRange*)pConfigItem;

                    // Process the second part of a range
                    long lScaler = ThumbStickScale( nThumbY,
                                                    gc_lTESTCONFIG_NUMBER_BUFZONE,
                                                    pConfigRange->GetMaximum2() / gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR );

                    if( ( pConfigRange->GetDefault2() - lScaler ) < pConfigRange->GetMinimum2() )
                        pConfigRange->SetDefault2( pConfigRange->GetMaximum2() );
                    else
                        pConfigRange->SetDefault2( pConfigRange->GetDefault2() - lScaler );
                }
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"numberstring" ) )
                {
                    UpdateTexture();

                    CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pConfigItem;

                    // Process the string part of a number string
                    if( !pConfigNumberString->MovePrevString() )
                        pConfigNumberString->MoveLastString();
                }
            }
            else if( nThumbY > 0 ) // Move right joystick up
            {
                // Process the default button delay
                if( !HandleInputDelay( bFirstYPress ) )
                    return;

                CConfigItem* pConfigItem = m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                // Check to see what type of item we are dealing with
                if( 0 == _wcsicmp( pConfigItem->GetType(), L"range" ) )
                {
                    UpdateTexture();

                    CConfigRange* pConfigRange = (CConfigRange*)pConfigItem;

                    // Process the second part of a range
                    long lScaler = ThumbStickScale( nThumbY,
                                                    gc_lTESTCONFIG_NUMBER_BUFZONE,
                                                    pConfigRange->GetMaximum2() / gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR );

                    if( ( pConfigRange->GetDefault2() + lScaler ) > pConfigRange->GetMaximum2() )
                        pConfigRange->SetDefault2( pConfigRange->GetMinimum2() );
                    else
                        pConfigRange->SetDefault2( pConfigRange->GetDefault2() + lScaler );
                }
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"numberstring" ) )
                {
                    UpdateTexture();

                    CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pConfigItem;

                    // Process the string part of a number string
                    if( !pConfigNumberString->MoveNextString() )
                        pConfigNumberString->MoveFirstString();
                }
            }

            // X
            if( nThumbX < 0 )       // Move the right joystick left
            {
                CConfigItem* pConfigItem = m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                if( 0 == _wcsicmp( pConfigItem->GetType(), L"range" ) )
                {
                    // Process the default button delay
                    if( !HandleInputDelay( bFirstXPress ) )
                        return;
                
                    UpdateTexture();

                    CConfigRange* pConfigRange = (CConfigRange*)pConfigItem;

                    // Process the first part of a range
                    long lScaler = ThumbStickScale( nThumbX,
                                                    gc_lTESTCONFIG_NUMBER_BUFZONE,
                                                    pConfigRange->GetMaximum1() / gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR );

                    if( ( pConfigRange->GetDefault1() - lScaler ) < pConfigRange->GetMinimum1() )
                        pConfigRange->SetDefault1( pConfigRange->GetMaximum1() );
                    else
                        pConfigRange->SetDefault1( pConfigRange->GetDefault1() - lScaler );

                }
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"number" ) )
                {
                    // Process the default button delay
                    if( !HandleInputDelay( bFirstXPress ) )
                        return;
                
                    UpdateTexture();
                    
                    CConfigNumber* pConfigNumber = (CConfigNumber*)pConfigItem;

                    long lScaler = ThumbStickScale( nThumbX,
                                                    gc_lTESTCONFIG_NUMBER_BUFZONE,
                                                    pConfigNumber->GetMaximum() / gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR ); // gc_lTESTCONFIG_NUMBER_MAXSCALE );

                    if( ( pConfigNumber->GetDefault() - lScaler ) < pConfigNumber->GetMinimum() )
                        pConfigNumber->SetDefault( pConfigNumber->GetMaximum() );
                    else
                        pConfigNumber->SetDefault( pConfigNumber->GetDefault() - lScaler );
                }
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"numberstring" ) )
                {
                    // Process the default button delay
                    if( !HandleInputDelay( bFirstXPress ) )
                        return;
                
                    UpdateTexture();
                    
                    CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pConfigItem;

                    long lScaler = ThumbStickScale( nThumbX,
                                                    gc_lTESTCONFIG_NUMBER_BUFZONE,
                                                    pConfigNumberString->GetMaximum() / gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR ); // gc_lTESTCONFIG_NUMBER_MAXSCALE );

                    // Handle the number part of our number string
                    if( ( pConfigNumberString->GetDefault() - lScaler ) < pConfigNumberString->GetMinimum() )
                        pConfigNumberString->SetDefault( pConfigNumberString->GetMaximum() );
                    else
                      pConfigNumberString->SetDefault( pConfigNumberString->GetDefault() - lScaler );
                }
                else // Hand off this to the "DPad" handler
                {
                    HandleInput( CONTROL_DPAD_LEFT, bFirstXPress );
                }
            }
            else if( nThumbX > 0 )  // Move the right joystick right
            {
                CConfigItem* pConfigItem = m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                if( 0 == _wcsicmp( pConfigItem->GetType(), L"range" ) )
                {
                    // Process the default button delay
                    if( !HandleInputDelay( bFirstXPress ) )
                        return;

                    UpdateTexture();

                    CConfigRange* pConfigRange = (CConfigRange*)pConfigItem;

                    // Process the first part of a range
                    long lScaler = ThumbStickScale( nThumbX,
                                                    gc_lTESTCONFIG_NUMBER_BUFZONE,
                                                    pConfigRange->GetMaximum1() / gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR );

                    if( ( pConfigRange->GetDefault1() + lScaler ) > pConfigRange->GetMaximum1() )
                        pConfigRange->SetDefault1( pConfigRange->GetMinimum1() );
                    else
                        pConfigRange->SetDefault1( pConfigRange->GetDefault1() + lScaler );

                }
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"number" ) )
                {
                    // Process the default button delay
                    if( !HandleInputDelay( bFirstXPress ) )
                        return;

                    UpdateTexture();

                    CConfigNumber* pConfigNumber = (CConfigNumber*)pConfigItem;

                    // Process the first part of a range
                    long lScaler = ThumbStickScale( nThumbX,
                                                    gc_lTESTCONFIG_NUMBER_BUFZONE,
                                                    pConfigNumber->GetMaximum() / gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR );

                    if( ( pConfigNumber->GetDefault() + lScaler ) > pConfigNumber->GetMaximum() )
                        pConfigNumber->SetDefault( pConfigNumber->GetMinimum() );
                    else
                        pConfigNumber->SetDefault( pConfigNumber->GetDefault() + lScaler );
                }
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"numberstring" ) )
                {
                    // Process the default button delay
                    if( !HandleInputDelay( bFirstXPress ) )
                        return;

                    UpdateTexture();

                    CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pConfigItem;

                    // Process the first part of a range
                    long lScaler = ThumbStickScale( nThumbX,
                                                    gc_lTESTCONFIG_NUMBER_BUFZONE,
                                                    pConfigNumberString->GetMaximum() / gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR );

                    if( ( pConfigNumberString->GetDefault() + lScaler ) > pConfigNumberString->GetMaximum() )
                        pConfigNumberString->SetDefault( pConfigNumberString->GetMinimum() );
                    else
                      pConfigNumberString->SetDefault( pConfigNumberString->GetDefault() + lScaler );
                }
                else // Hand off this to the "DPad" handler
                {
                    HandleInput( CONTROL_DPAD_RIGHT, bFirstXPress );
                }
            }
            break;
        }
    }
}


// Handle control input for a single list menu
void CTestConfigMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Pass off UP/DOWN navigation to our base class
    switch( controlPressed )
    {
    case CONTROL_DPAD_UP:
    case CONTROL_DPAD_DOWN:
        {
            CMenuScreen::HandleInput( controlPressed, bFirstPress );
            break;
        }
    }

    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Controls being pressed
    switch( controlPressed )
    {
    case CONTROL_BACK:
        {
            GoToHelp();

            break;
        }
    case CONTROL_DPAD_LEFT:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() > 0 )
            {
                UpdateTexture();

                CConfigItem* pConfigItem = m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                // Determine what type of item we are dealing with
                /*
                if( 0 == _wcsicmp( pConfigItem->GetType(), L"number" ) )
                {
                    CConfigNumber* pConfigNumber = (CConfigNumber*)pConfigItem;

                    if( pConfigNumber->GetDefault() == pConfigNumber->GetMinimum() )
                        pConfigNumber->SetDefault( pConfigNumber->GetMaximum() );
                    else
                      pConfigNumber->SetDefault( pConfigNumber->GetDefault() - 1 );
                }
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"range" ) )
                {
                    CConfigRange* pConfigRange = (CConfigRange*)pConfigItem;

                    // Process the first part of a range
                    if( pConfigRange->GetDefault1() == pConfigRange->GetMinimum1() )
                        pConfigRange->SetDefault1( pConfigRange->GetMaximum1() );
                    else
                        pConfigRange->SetDefault1( pConfigRange->GetDefault1() - 1 );
                }
                */
                if( 0 == _wcsicmp( pConfigItem->GetType(), L"string" ) )
                {
                    CConfigString* pConfigString = (CConfigString*)pConfigItem;

                    if( !pConfigString->MovePrevString() )
                        pConfigString->MoveLastString();
                }
                /*
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"numberstring" ) )
                {
                    // Handle the number part of our number string

                    CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pConfigItem;

                    if( pConfigNumberString->GetDefault() == pConfigNumberString->GetMinimum() )
                        pConfigNumberString->SetDefault( pConfigNumberString->GetMaximum() );
                    else
                      pConfigNumberString->SetDefault( pConfigNumberString->GetDefault() - 1 );
                }
                */
            }
            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Only act if we have any items on our screen
            if( GetNumMenuItems() != 0 )
            {
                UpdateTexture();

                CConfigItem* pConfigItem = m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                // Determine what type of item we are dealing with
                /*
                if( 0 == _wcsicmp( pConfigItem->GetType(), L"number" ) )
                {
                    CConfigNumber* pConfigNumber = (CConfigNumber*)pConfigItem;

                    if( pConfigNumber->GetDefault() == pConfigNumber->GetMaximum() )
                        pConfigNumber->SetDefault( pConfigNumber->GetMinimum() );
                    else
                      pConfigNumber->SetDefault( pConfigNumber->GetDefault() + 1 );
                }
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"range" ) )
                {
                    CConfigRange* pConfigRange = (CConfigRange*)pConfigItem;

                    // Process the first part of a range
                    if( pConfigRange->GetDefault1() == pConfigRange->GetMaximum1() )
                        pConfigRange->SetDefault1( pConfigRange->GetMinimum1() );
                    else
                        pConfigRange->SetDefault1( pConfigRange->GetDefault1() + 1 );
                }
                */
                if( 0 == _wcsicmp( pConfigItem->GetType(), L"string" ) )
                {
                    CConfigString* pConfigString = (CConfigString*)pConfigItem;

                    if( !pConfigString->MoveNextString() )
                        pConfigString->MoveFirstString();
                }
                /*
                else if( 0 == _wcsicmp( pConfigItem->GetType(), L"numberstring" ) )
                {
                    CConfigNumberString* pConfigNumberString = (CConfigNumberString*)pConfigItem;

                    if( pConfigNumberString->GetDefault() == pConfigNumberString->GetMaximum() )
                        pConfigNumberString->SetDefault( pConfigNumberString->GetMinimum() );
                    else
                      pConfigNumberString->SetDefault( pConfigNumberString->GetDefault() + 1 );
                }
                */
            }
            break;
        }
	}
}


// This should be called whenever the menu is entered or activated
void CTestConfigMenu::Enter( void )
{
    CMenuScreen::Enter();

    if( NULL == m_pXBEInfo )
    {
        DebugPrint( "Enter():Invalid XBE Pointer set!!\n" );

        GoBack();
    }

    CTestConfig* pTestConfig = m_pXBEInfo->GetCurrentTestConfig();  // Store our config item in a handy pointer
    // CTestConfig* pTestConfig = m_pXBEInfo->GetDefaultTestConfig();  // Store our config item in a handy pointer

    pTestConfig->MoveFirstConfigItem();
    unsigned int uiCount = 0;
    
    do
    {
        AddMenuItem( GetBodyFont(), pTestConfig->GetCurrentConfigItem()->GetFieldName(), FALSE, TRUE, uiCount );
        uiCount++;
    } while( pTestConfig->MoveNextConfigItem() );

    // Adjust our selected item if necessary
    // Set our Selected Item back to the proper config setting
    SetSelectedItem( m_uiSelectedConfigItem );
    m_uiSelectedConfigItem = 0;

    if( GetSelectedItem() < GetNumMenuItemsToDisplay() )
        SetTopItemIndex( 0 );
    else if( ( GetSelectedItem() + GetNumMenuItemsToDisplay() ) >= GetNumMenuItems() )
        SetTopItemIndex( GetNumMenuItems() - GetNumMenuItemsToDisplay() );
    else // It can be our top item
        SetTopItemIndex( GetSelectedItem() );

    /*
    DebugPrint( "TopItemIndex    - '%d'\n", GetTopItemIndex() );
    DebugPrint( "BottomItemIndex - '%d'\n", GetBottomItemIndex() );
    DebugPrint( "SelectedItem    - '%u'\n", GetSelectedItem() );
    DebugPrint( "SelectorPos     - '%u'\n", GetSelectorPosition() );
    */
}


// Should be called whenever user is leaving the menu
void CTestConfigMenu::Leave( CXItem* pItem )
{
    ClearMenuItems();
    
    CMenuScreen::Leave( pItem );
};


// If the user is performing an action, this will handle it
void CTestConfigMenu::ProcessMenuActions( void )
{
    switch( m_eCurrentAction )
    {
    case ENUM_TESTCONFMENU_EDITSTRING2:
        {
            // Make sure we set this to no action
            m_eCurrentAction = ENUM_TESTCONFMENU_NOACTION;

            // Check to see if the user cancelled the operation.  If not, store the new value
            if( !GetKeyboardPtr()->GetCancelled() )
            {
                CConfigString2* pConfigString2 = (CConfigString2*)m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );

                pConfigString2->SetString( GetKeyboardPtr()->GetValue() );
            }

            break;
        }
    case ENUM_TESTCONFMENU_EDIT_RANGE1:
        {
            if( !GetKeypadPtr()->GetCancelled() )
            {
                CConfigRange* pConfigRange = (CConfigRange*)m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer
                m_uiSelectedConfigItem = GetSelectedItem();

                m_eCurrentAction = ENUM_TESTCONFMENU_EDIT_RANGE2;

                // Store the first number the user entered
                WCHAR* pwszStopString = NULL;
                m_lNum1Val = wcstol( GetKeypadPtr()->GetValue(), &pwszStopString, 10 );

                WCHAR pwszText[MAX_PATH+1];
                WCHAR pwszValText[MAX_PATH+1];
                pwszText[MAX_PATH] = L'\0';
                pwszValText[MAX_PATH] = L'\0';

                _snwprintf( pwszText, MAX_PATH, L"Enter #2 (between %ld and %ld)", pConfigRange->GetMinimum2(), pConfigRange->GetMaximum2() );
                _snwprintf( pwszValText, MAX_PATH, L"%ld", pConfigRange->GetDefault2() );

                DebugPrint( "pwszValText - '%ls'\n", pwszValText );

                GetKeypadPtr()->SetBackPtr( this );
                GetKeypadPtr()->SetInfo( pwszText, 15, pwszValText );

                Leave( GetKeypadPtr() );
            }
            else    // User cancelled
                m_eCurrentAction = ENUM_TESTCONFMENU_NOACTION;  // Make sure we set this to no action

            break;
        }
    case ENUM_TESTCONFMENU_EDIT_RANGE2:
        {
            m_eCurrentAction = ENUM_TESTCONFMENU_NOACTION;  // Make sure we set this to no action

            if( !GetKeypadPtr()->GetCancelled() )
            {
                CConfigRange* pConfigRange = (CConfigRange*)m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                // Get the second number the user entered
                WCHAR* pwszStopString = NULL;
                long lVal2 = wcstol( GetKeypadPtr()->GetValue(), &pwszStopString, 10 );

                // Set our range values
                pConfigRange->SetDefault1( m_lNum1Val );
                pConfigRange->SetDefault2( lVal2 );

                m_lNum1Val = 0l;                
            }

            break;
        }
    case ENUM_TESTCONFMENU_EDIT_NUMBERSTRING:
        {
            m_eCurrentAction = ENUM_TESTCONFMENU_NOACTION;  // Make sure we set this to no action

            if( !GetKeypadPtr()->GetCancelled() )
            {
                CConfigNumberString* pConfigNumberString = (CConfigNumberString*)m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                // Get the second number the user entered
                WCHAR* pwszStopString = NULL;
                long lVal1 = wcstol( GetKeypadPtr()->GetValue(), &pwszStopString, 10 );

                // Set our range values
                pConfigNumberString->SetDefault( lVal1 );
            }

            break;
        }
    case ENUM_TESTCONFMENU_EDIT_NUMBER:
        {
            m_eCurrentAction = ENUM_TESTCONFMENU_NOACTION;  // Make sure we set this to no action

            if( !GetKeypadPtr()->GetCancelled() )
            {
                CConfigNumber* pConfigNumber = (CConfigNumber*)m_pXBEInfo->GetCurrentTestConfig()->GetConfigItem( GetSelectedItem() );  // Store our config item in a handy pointer

                // Get the second number the user entered
                WCHAR* pwszStopString = NULL;
                long lVal1 = wcstol( GetKeypadPtr()->GetValue(), &pwszStopString, 10 );

                // Set our range values
                pConfigNumber->SetDefault( lVal1 );
            }

            break;
        }
    }
}


// Set the PTR to our active XBEInfo object
void CTestConfigMenu::SetXBEInfoPtr( CXBEInfo* pXBEInfo )
{
    m_pXBEInfo = pXBEInfo;
};


// Sets up and goes to the help menu
void CTestConfigMenu::GoToHelp( void )
{
    // Set the menu title
    WCHAR pwszTitle[50];
    pwszTitle[49] = L'\0';

    _snwprintf( pwszTitle, 49, L"%ls Help", m_pXBEInfo->GetTitleName() );
    GetHelpMenuPtr()->SetMenuTitle( GetHeaderFont(), pwszTitle );

    // Set the back pointer for the help menu
    GetHelpMenuPtr()->SetBackPtr( this );

    // Clear the current help
    GetHelpMenuPtr()->ClearHelpItems();

    // Populate the help menu with our items
    m_pXBEInfo->GetCurrentTestConfig()->MoveFirstConfigItem();
    do
    {
        GetHelpMenuPtr()->AddHelpItem( GetBodyFont(),
                                       m_pXBEInfo->GetCurrentTestConfig()->GetCurrentConfigItem()->GetFieldName(),
                                       GetBodyFont(),
                                       m_pXBEInfo->GetCurrentTestConfig()->GetCurrentConfigItem()->GetHelpText() );
    } while( m_pXBEInfo->GetCurrentTestConfig()->MoveNextConfigItem() );
    
    // navigate to the menu
    Leave( GetHelpMenuPtr() );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\testconfigmenu.h ===
/*****************************************************
*** testconfigmenu.h
***
*** Header file for our Test Config Menu class.
*** This is a standard menu contains a list of menu
*** items to be selected.
***
*** by James N. Helm
*** November 27th, 2001
***
*****************************************************/

#ifndef _TESTCONFIGMENU_H_
#define _TESTCONFIGMENU_H_

#include "menuscreen.h"
#include "xbeinfo.h"

const long gc_lTESTCONFIG_NUMBER_BUFZONE =              3500;
const long gc_lTESTCONFIG_NUMBER_MAXSCALE =             100000;
const long gc_lTESTCONFIG_NUMBER_MAXSCALE_DIVISOR =     15;

enum TESTCONFMENU_ACTIONS
{
    ENUM_TESTCONFMENU_NOACTION,
    ENUM_TESTCONFMENU_EDITSTRING2,
    ENUM_TESTCONFMENU_EDIT_NUMBERSTRING,
    ENUM_TESTCONFMENU_EDIT_NUMBER,
    ENUM_TESTCONFMENU_EDIT_RANGE1,
    ENUM_TESTCONFMENU_EDIT_RANGE2
};

class CTestConfigMenu : public CMenuScreen
{
public:
    // Constructors and Destructor
    CTestConfigMenu( void );
    ~CTestConfigMenu( void );

    // Public Methods
    HRESULT Init( XFONT* pMenuItemFont,             // Initialize the Menu
                  XFONT* pMenuTitleFont );
    // Draws a menu on to the screen
    void Action( CUDTexture* pTexture );            // Renders to the texture and calls any per-frame processing
    void RenderScreenItems( CUDTexture* pTexture ); // Render the screen items properly on our menu
	void RenderMenuTitle( CUDTexture* pTexture );	// Render the menu title on to the menu
    void RenderMenuItems( CUDTexture* pTexture );   // Used to render the menu items on the screen
    void HandleInput( enum BUTTONS buttonPressed,   // Handles input from the buttons
                      BOOL bFirstPress );
    void HandleInput( enum CONTROLS controlPressed, // Handle input (of the CONTROLS) for the current menu
                      BOOL bFirstPress );
    void HandleInput( enum JOYSTICK joystick,       // Handle any requests for the joystick (thumb-pad)
                      int nThumbY,
                      int nThumbX,
                      BOOL bFirstYPress,
                      BOOL bFirstXPress );

    void Enter( void );                             // This should be called whenever the menu is entered or activated

    void SetXBEInfoPtr( CXBEInfo* pXBEInfo );       // Set the PTR to our active XBEInfo object
    void SetMultiConfigs( BOOL bConfigs )           // Set whether or not the XBE supports multiple configs
        { m_bMultiConfigs = bConfigs; };

private:
    CXBEInfo* m_pXBEInfo;
    enum TESTCONFMENU_ACTIONS m_eCurrentAction;     // Used to track the current action of the user
    unsigned int m_uiSelectedConfigItem;            // Used to track which config item is selected when using multiple menus
    long m_lNum1Val;                                // Used to store numbers if user is in manual edit mode
    BOOL m_bMultiConfigs;                           // Used to determine if the XBE supports multiple configs

    void Leave( CXItem* pItem );                    // Should be called whenever user is leaving the menu
    void ProcessMenuActions( void );                // If the user is performing an action, this will handle it
    void GoToHelp( void );                          // Sets up and goes to the help menu
};

#endif // _TESTCONFIGMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define XFONT_TRUETYPE
#define APP_TITLE_NAME                                  "HVSLauncher"

/////////////////////////////////
// Includes
/////////////////////////////////
#include <ntos.h>
#include <xtl.h>
#include <xfontfuncs.h>
// #include <xdbg.h>
#include <stdio.h>
#include <hvsUtils.h>

// UI Libs / Tools
#include <linkedlist.h>
#include <usbmanager.h>

///////////////////////////
// Constants and Structures
///////////////////////////

// Colors
const DWORD         gc_dwCOLOR_WHITE =                              0xFFFFFFFF;
const DWORD         gc_dwCOLOR_BLACK =                              0xFF000000;
const DWORD         gc_dwCOLOR_RED =                                0xFFFF0000;
const DWORD         gc_dwCOLOR_GREEN =                              0xFF00FF00;
const DWORD         gc_dwCOLOR_DARK_GREEN =                         0xFF276F07;
const DWORD         gc_dwCOLOR_BLUE =                               0xFF0000FF;
const DWORD         gc_dwCOLOR_DARK_GREY =                          0xFF808080;
const DWORD         gc_dwCOLOR_LIGHT_GREY =                         0xFFC0C0C0;
const DWORD         gc_dwCOLOR_DIM_GREY =                           0xFF272727;
const DWORD         gc_dwCOLOR_DIM_YELLOW =                         0xFFC0BF5A;
const DWORD         gc_dwCOLOR_BRIGHT_YELLOW =                      0xFFC0BF5A;

const DWORD         gc_dwCOLOR_TVSAFE_GREEN =                       0xFF2CDF2C;
const DWORD         gc_dwCOLOR_TVSAFE_RED =                         0xFF8D3232;
const DWORD         gc_dwCOLOR_TVSAFE_BLUE =                        0xFF20209F;
const DWORD         gc_dwCOLOR_TVSAFE_YELLOW =                      0xFFF0F02F;

const DWORD         gc_dwCOLOR_TEXT_GREEN =                         0xFF34DD07;
const DWORD         gc_dwCOLOR_TEXT_YELLOW =                        0xFFFFF200;
const DWORD         gc_dwCOLOR_SELECTOR_BLACK =                     0x66000000;

// Button Colors
const DWORD         gc_dwCOLOR_A_BUTTON =                           gc_dwCOLOR_TVSAFE_GREEN;
const DWORD         gc_dwCOLOR_B_BUTTON =                           gc_dwCOLOR_TVSAFE_RED;
const DWORD         gc_dwCOLOR_X_BUTTON =                           gc_dwCOLOR_TVSAFE_BLUE;
const DWORD         gc_dwCOLOR_Y_BUTTON =                           gc_dwCOLOR_TVSAFE_YELLOW;
const DWORD         gc_dwCOLOR_L_BUTTON =                           gc_dwCOLOR_DARK_GREY;
const DWORD         gc_dwCOLOR_R_BUTTON =                           gc_dwCOLOR_DARK_GREY;
const DWORD         gc_dwCOLOR_WHITE_BUTTON =                       gc_dwCOLOR_WHITE;
const DWORD         gc_dwCOLOR_BLACK_BUTTON =                       gc_dwCOLOR_DIM_GREY;
const DWORD         gc_dwCOLOR_START_BUTTON =                       gc_dwCOLOR_DARK_GREY;
const DWORD         gc_dwCOLOR_BACK_BUTTON =                        gc_dwCOLOR_DARK_GREY;

const float         gc_fBUTTON_WIDTH_ADJUST =                       22;

// Program information
const unsigned int  gc_uiCACHE_SIZE =                               (1024 * 1024 * 8);	// Eight Megs
const WCHAR         gc_pwszFONT_HEADER_FILENAME[] =                 L"d:\\media\\fonts\\xbox.ttf";
const WCHAR         gc_pwszFONT_BODY_FILENAME[] =                   L"d:\\media\\fonts\\xbox_rg.ttf";
const WCHAR         gc_pwszFONT_BUTTON_FILENAME[] =                 L"d:\\media\\fonts\\xboxdings.ttf";
const unsigned int  gc_uiDEFAULT_FONT_HEIGHT =                      20;
const unsigned int  gc_uiDEFAULT_FONT_ALIAS_LEVEL =                 0;
const unsigned int  gc_uiSCREEN_HEIGHT =                            480;
const unsigned int  gc_uiSCREEN_WIDTH =                             640;
const char          gc_pszAutoRunFile[] =                           "T:\\AUTORUN.TXT";
const char          gc_pszResultsFile[] =                           "T:\\RESULTS.TXT";
const char          gc_pszCurrentTestInfoFile[] =                   "T:\\RUNNINGTEST.TXT";
const char          gc_pszRunningTestsPath[] =                      "T:\\RUNNINGTESTS";
                                                                    
// Input constants
const int           gc_nBUTTON_THRESHOLD =                          50;    // 0 to 255
const int           gc_nJOYSTICK_DEADZONE =                         20000; // 0 to 32768

// Default Texture Vertex Type
struct MYTEXVERTEX
{
    D3DXVECTOR3 v;
    float       fRHW;
    D3DCOLOR    diffuse;
    float       tu, tv;    // The texture coordinates
};

#define D3DFVF_MYTEXVERTEX  ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

///////////////////////////////////
// HVS Launcher dependent includes
///////////////////////////////////
#include "hvslfunctions.h"

// Libs

// Menus and Commands


#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\udtexture.h ===
/*****************************************************
*** udtexture.h
***
*** Header file for our udtexture class.  This class
*** will hold a texture and allow the user to perform
*** certain actions on this texture, like writing
*** text, etc
*** 
*** by James N. Helm
*** January 24th, 2001
*** 
*** Modified
*** 03/09/2001 - James N. Helm
*** 11/20/2001 - James N. Helm
*****************************************************/

#ifndef _UDTEXTURE_H_
#define _UDTEXTURE_H_

#include "xfont.h"

typedef struct _UDTEXTURE_VERTEX
{
	D3DXVECTOR3 v;
	float       fRHW;
	D3DCOLOR    cDiffuse;
} UDTEXTURE_VERTEX;

#define D3DFVF_UDTEXTURE_VERTEX     ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE )

class CUDTexture
{
public:
    // Constructors and Destructors
    CUDTexture( void );
    ~CUDTexture( void );

    // Public Properties

    // Public Methods
    void Initialize( IDirect3DDevice8* pDevice,             // Initialize our texture and create our surface 
                     char* pszFileName,
                     int iTextureWidth,
                     int iTextureHeight );

    void CleanUp( void );                                   // Clean up any memory we have allocated
    
    void Clear( DWORD dwColor );                            // Clear the current Texture, setting the background to specified color
    
    void DrawBox( float fX1,                                // Draw a box on the screen
                  float fY1,
                  float fX2,
                  float fY2,
                  DWORD dwColor );

    void DrawClearRect( float fX1,                          // Draw a clear rectangle to the screen
                        float fY1,
                        float fX2,
                        float fY2,
                        DWORD dwColor );

    void DrawLine( float fX1,                               // Draw a line on the screen
                   float fY1,
                   float fX2,
                   float fY2,
                   float fLineWidth,
                   DWORD dwColor );

    void DrawOutline( float fX1,                            // Draw an outline at the current location with a specific border size
                      float fY1,
                      float fX2,
                      float fY2,
                      float fLineWidth,
                      DWORD dwColor );

    void DrawText( XFONT* pFont,                            // Prints formatted text, using the default font size
                   float fX1,
                   float fY1,
                   DWORD dwFGColor,
                   DWORD dwBGColor,
                   const WCHAR* pwszFormat,
                   ... );

    void Lock( void );                                      // Lock the texture surface so that we can render on to it
    void Unlock( void );                                    // Unlock the texture surface after we have rendered on to it

    IDirect3DTexture8* GetTexture( void )                   // Get the address of the texture
        { return m_pTexture; };
    IDirect3DSurface8* GetTextureSurface( void )            // Get the address of the texture surface
        { return m_pTextureSurface; };

private:
    // Private Properties
    IDirect3DDevice8*       m_pD3DDevice;               // Direct 3D Device Pointer
    IDirect3DTexture8*      m_pTexture;                 // Actual texture being worked on
    IDirect3DSurface8*      m_pTextureSurface;          // Surface of the texture -- can render to this
    IDirect3DSurface8*      m_pCurrentRenderTarget;     // Used to store the render target that is set outside the texture
    IDirect3DVertexBuffer8* m_pVertexBuffer;            // Vertex Buffer used for our Primitive calls
    IDirect3DVertexBuffer8* m_pCurrentVBuffer;          // Used to store Vertex Buffer that is set outside the texture
    UINT                    m_uiCurrentStride;          // Used to store the stride of the VB that is set outside the texture
    D3DLOCKED_RECT          m_d3dlr;                    // Rect structure used in our "lock"
    int                     m_iTextureWidth;            // Width of the Texture
    int                     m_iTextureHeight;           // Height of the Texture
    unsigned int            m_uiTextureLockedRef;       // Used to determine if our texture is locked
    
    // Private Methods
};

#endif // _UDTEXTURE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\xbeinfo.cpp ===
/*****************************************************
*** xbeinfo.cpp
***
*** CPP file for our XBE info class.
*** This file will contain the implementation an XBE
*** info object.
*** 
*** by James N. Helm
*** November 27th, 2001
*** 
*****************************************************/

#include "stdafx.h"
#include "xbeinfo.h"

CXBEInfo::CXBEInfo( void ) :
m_bLoaded( FALSE )
{
    ZeroMemory( m_pszDirectory, MAX_PATH + 1 );
    ZeroMemory( m_pszFilename, MAX_PATH + 1 );
    ZeroMemory( m_pszFileExtension, 4 );
    ZeroMemory( m_pwszTitleName, sizeof( WCHAR ) * ( XBEIMAGE_TITLE_NAME_LENGTH + 1 ) );

    m_TestConfigurations.SetDeleteDataItem( TRUE );
}

CXBEInfo::~CXBEInfo( void )
{
    m_TestConfigurations.EmptyList();
}


// Operators
BOOL CXBEInfo::operator>( const CXBEInfo& item )
{
    if( _wcsicmp( m_pwszTitleName, item.m_pwszTitleName ) > 0 )
        return TRUE;

    return FALSE;
}

BOOL CXBEInfo::operator<( const CXBEInfo& item )
{
    if( _wcsicmp( m_pwszTitleName, item.m_pwszTitleName ) < 0 )
        return TRUE;

    return FALSE;
}

BOOL CXBEInfo::operator==( const CXBEInfo& item )
{
    if( _wcsicmp( m_pwszTitleName, item.m_pwszTitleName ) == 0 )
        return TRUE;

    return FALSE;
}


// Add a test configuration based on the Default Config
void CXBEInfo::AddNewTestConfig( void )
{
    CTestConfig* pTestConfig = new CTestConfig;
    if( NULL == pTestConfig )
    {
        DebugPrint( "CXBEInfo::AddNewTestConfig():Could not allocate memory!!\n" );

        return;
    }

    *pTestConfig = *GetDefaultTestConfig();

    // Add the configuration to our list
    AddTestConfig( pTestConfig );

    // Set the current config to the last configuration (our newest)
    MoveLastTestConfig();
}


// Returns the number of test configs associated with this XBE
unsigned int CXBEInfo::GetNumTestConfigs( void )
{
    return m_TestConfigurations.GetNumItems();
}


// Move to the specified test configuration
void CXBEInfo::MoveToTestConfig( unsigned int uiIndex )
{
    m_TestConfigurations.MoveTo( uiIndex );
}


// Move to the next test config in the list
BOOL CXBEInfo::MoveNextTestConfig( void )
{
    return m_TestConfigurations.MoveNext();
}


// Move to the prev test config in the list
BOOL CXBEInfo::MovePrevTestConfig( void )
{
    return m_TestConfigurations.MovePrev();
}


// Move to the first test config in the list
BOOL CXBEInfo::MoveFirstTestConfig( void )
{
    return m_TestConfigurations.MoveFirst();
}


// Move to the last test config in the list
BOOL CXBEInfo::MoveLastTestConfig( void )
{
    return m_TestConfigurations.MoveLast();
}


// Get the default test config for our XBE
CTestConfig* CXBEInfo::GetDefaultTestConfig( void )
{
    return &m_DefaultTestConfig;
}


// Get the test config that is currently being pointed to
CTestConfig* CXBEInfo::GetCurrentTestConfig( void )
{
    return m_TestConfigurations.GetCurrentNode();
}


// Get the test config at the specified index
CTestConfig* CXBEInfo::GetTestConfig( unsigned int uiIndex )
{
    return m_TestConfigurations.GetNode( uiIndex );
}


// Delete the test config at the specified index
HRESULT CXBEInfo::DeleteTestConfig( unsigned int uiIndex )
{
    return m_TestConfigurations.DelNode( uiIndex );
}


// Delete the test config at current index
HRESULT CXBEInfo::DeleteCurrentTestConfig( void )
{
    HRESULT hr = E_ABORT;

    if( GetNumTestConfigs() > 1 )
        hr = m_TestConfigurations.DelCurrentNode();
    
    return hr;
}


// Set the directory of the XBE
void CXBEInfo::SetDirectory( char* pszDirectory )
{
    if( NULL == pszDirectory )
        return;

    strncpy( m_pszDirectory, pszDirectory, MAX_PATH );
}


// Set the filename of the XBE
void CXBEInfo::SetFilename( char* pszFilename )
{
    if( NULL == pszFilename )
        return;

    strncpy( m_pszFilename, pszFilename, MAX_PATH );
}


// Set the file extension of the XBE
void CXBEInfo::SetFileExtension( char* pszFileExtension )
{
    if( NULL == pszFileExtension )
        return;

    strncpy( m_pszFileExtension, pszFileExtension, 3 );
}


// Set the Title Name of the XBE
void CXBEInfo::SetTitleName( WCHAR* pwszTitleName )
{
    if( NULL == pwszTitleName )
        return;

    wcsncpy( m_pwszTitleName, pwszTitleName, XBEIMAGE_TITLE_NAME_LENGTH );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\xbeinfo.h ===
/*****************************************************
*** xbeinfo.h
***
*** Header file for our XBE info class.
*** This file will contain the definition an XBE
*** info object.
*** 
*** by James N. Helm
*** November 27th, 2001
*** 
*****************************************************/

#ifndef _XBEINFO_H_
#define _XBEINFO_H_

#include <xbeimage.h>
#include "testconfig.h"

class CXBEInfo
{
public:
    CXBEInfo( void );
    ~CXBEInfo( void );

    // Methods
    void AddNewTestConfig( void );                                  // Add a test configuration based on the Default Config
    void AddTestConfig( CTestConfig* pTestConfig )                  // Add a test config to our XBE
        { m_TestConfigurations.AddNode( pTestConfig ); };           
                                                                    
    unsigned int GetNumTestConfigs( void );                         // Returns the number of test configs associated with this XBE
    
    void MoveToTestConfig( unsigned int uiIndex );                  // Move to the specified test configuration
	BOOL MoveNextTestConfig( void );                                // Move to the next test config in the list
	BOOL MovePrevTestConfig( void );                                // Move to the prev test config in the list
	BOOL MoveFirstTestConfig( void );                               // Move to the first test config in the list
	BOOL MoveLastTestConfig( void );                                // Move to the last test config in the list
    char* GetDirectory( void ) { return m_pszDirectory; };          // Get the directory of the XBE
    char* GetFilename( void ) { return m_pszFilename; };            // Get the filename of the XBE
    char* GetFileExtension( void ) { return m_pszFileExtension; };  // Get the file extension of the XBE
    WCHAR* GetTitleName( void ) { return m_pwszTitleName; };        // Get the Title Name of the XBE
    CTestConfig* GetDefaultTestConfig( void );                      // Get the default test config for our XBE
	CTestConfig* GetCurrentTestConfig( void );                      // Get the test config that is currently being pointed to
    unsigned int GetCurrentTestConfigIndex( void )                  // Get the index of the test config that is currently being pointed to
        { return m_TestConfigurations.GetCurrentIndex(); };
    BOOL GetLoaded( void ) { return m_bLoaded; };                   // Get if the XBE info was loaded from disk

	CTestConfig* GetTestConfig( unsigned int uiIndex );	            // Get the test config at the specified index
    HRESULT DeleteTestConfig( unsigned int uiIndex );	            // Delete the test config at the specified index
    HRESULT DeleteCurrentTestConfig( void );                        // Delete the test config at current index
    void ClearTestConfigs( void )                                   // Clear out all test configs for this XBE
        { m_TestConfigurations.EmptyList(); };

    void SetDirectory( char* pszDirectory );                        // Set the directory of the XBE
    void SetFilename( char* pszFilename );                          // Set the filename of the XBE
    void SetFileExtension( char* pszFileExtension );                // Set the file extension of the XBE
    void SetTitleName( WCHAR* pwszTitleName );                      // Set the Title Name of the XBE
    void SetLoaded( BOOL bLoad ) { m_bLoaded = bLoad; };            // Set that the XBE info was loaded from disk

    // Operators
    BOOL operator>( const CXBEInfo& item );
    BOOL operator<( const CXBEInfo& item );
    BOOL operator==( const CXBEInfo& item );

private:
    // Properties
    char m_pszDirectory[MAX_PATH + 1];
    char m_pszFilename[MAX_PATH + 1];
    char m_pszFileExtension[4];
    WCHAR m_pwszTitleName[XBEIMAGE_TITLE_NAME_LENGTH + 1];
    BOOL m_bLoaded;     // Used to determine if the XBE had it's config's loaded from the Hard Drive

    CTestConfig m_DefaultTestConfig;                    // Default Test Configuration for our XBE
    CLinkedList< CTestConfig* > m_TestConfigurations;   // Test Configurations for this XBE
};

#endif // _XBEINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\xfontfuncs.cpp ===
#include "stdafx.h"
#include "xfontfuncs.h"

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int GetStringPixelWidth( XFONT* pFont, IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    if( NULL == string || NULL == pFont )
    {
        DebugPrint( "GetStringPixelWidth( WCHAR* ):Invalid argument(s) passed in!\n" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( pFont, string, length, &outlen );
	
    return outlen;
}


// Get the width of the char*
int GetStringPixelWidth( XFONT* pFont, IN char* string, IN int length /*=-1*/ ) 
{
    if( NULL == string || NULL == pFont )
    {
        DebugPrint( "GetStringPixelWidth( char* ):Invalid argument(s) passed in!\n" );

        return -1;
    }

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( pFont, newWStr, length );
}


// Get the size of the current font
void GetFontSize( XFONT* pFont, unsigned int* pheight, unsigned int* pdecent )
{
    // Verify the parameters that were passed in are corred
    if( NULL == pheight || NULL == pdecent || NULL == pFont )
    {
        DebugPrint( "GetFontSize():Invalid argument(s) passed!!\n" );

        return;
    }

    XFONT_GetFontMetrics( pFont, pheight, pdecent );
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( XFONT* pFont, char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( NULL == pString ) || ( 0 > ( x2 - x1 ) ) || ( NULL == pFont ) )
    {
        DebugPrint( "CXboxVideo::TruncateStringToFit():Invalid argument(s)!! x1 - '%f', x2 - '%f'\n", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pFont, pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( XFONT* pFont, WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( NULL == pString ) || ( 0 > ( x2 - x1 ) ) || ( NULL == pFont ) )
    {
        DebugPrint( "CXboxVideo::TruncateStringToFit():Invalid argument(s)!! x1 - '%f', x2 - '%f'\n", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pFont, pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Open the font file specified and use the font pointer passed in
HRESULT OpenTTFontFile( XFONT*& pFont, const WCHAR* pwszFontFilename )
{
    if( NULL != pFont || NULL == pwszFontFilename )
    {
        DebugPrint( "OpenFontFile():Invalid argument(s) passed in!!\n" );

        return E_INVALIDARG;
    }

    XFONT_OpenTrueTypeFont( pwszFontFilename, 4096, &pFont );

	if( NULL == pFont )
    {
        DebugPrint( "OpenFontFile():Failed to Open the True Type Font!!\n" );

        return E_FAIL;
    }

    XFONT_SetTextColor( pFont, gc_dwCOLOR_WHITE );
    XFONT_SetBkColor( pFont, gc_dwCOLOR_BLACK );
    XFONT_SetTextHeight( pFont, gc_uiDEFAULT_FONT_HEIGHT );
    XFONT_SetTextAntialiasLevel( pFont, gc_uiDEFAULT_FONT_ALIAS_LEVEL );
    XFONT_SetTextStyle( pFont, XFONT_NORMAL );

    return S_OK;
}


// Close an opened font
HRESULT CloseTTFont( XFONT*& pFont )
{
    if( NULL == pFont )
    {
        DebugPrint( "CloseTTFont():Invalid argument passed in!!\n" );

        return E_INVALIDARG;
    }

    XFONT_Release( pFont );
    pFont = NULL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\xbelist.h ===
/*****************************************************
*** xbelist.h
***
*** Header file for our XBE List class.
*** This class will hold a linked list of XBE's that
*** will be populated from a directory.
***
*** by James N. Helm
*** December 2nd , 2000
***
*****************************************************/

#ifndef _XBELIST_H_
#define _XBELIST_H_

#include <xbeimage.h>
#include "xbeinfo.h"
#include "configitems.h"

#define XBE_INITIAL_HEADER_SIZE     4096

class CXBEList
{
public:
    // Constructors and Destructors
    CXBEList( void );
    ~CXBEList( void );

    // Methods
    HRESULT Init( char* dirname, char* fileExt );               // Initialize the list from a directory, loading files of a certain type
    unsigned int GetNumItems( void )                            // Get the number of items currently in our list
        { return m_XBEItems.GetNumItems(); };
    char* GetXBEName( unsigned int index )                      // Get the name of an XBE by index
        { return m_XBEItems[index]->GetFilename(); };
    char* GetXBEDir( unsigned int index )                       // Get the directory of an XBE by index
        { return m_XBEItems[index]->GetDirectory(); };
    char* GetXBEExt( unsigned int index )                       // Get the extension of an XBE by index
        { return m_XBEItems[index]->GetFileExtension(); };
    WCHAR* GetXBETitle( unsigned int index )                    // The title name of the XBE as in the XBE CERT Information
        { return m_XBEItems[index]->GetTitleName(); };
    CXBEInfo* GetXBEInfoPtr( unsigned int uiIndex )             // Return a pointer to our CXBEInfo item
        { return m_XBEItems[uiIndex]; };

    BOOL MoveFirst( void ) { return m_XBEItems.MoveFirst(); };  // Move to the first XBE in our list
    BOOL MovePrev( void ) { return m_XBEItems.MovePrev(); };    // Move to the next XBE in our list
    BOOL MoveNext( void ) { return m_XBEItems.MoveNext(); };    // Move to the next XBE in our list
    BOOL MoveLast( void ) { return m_XBEItems.MoveLast(); };    // Move to the last XBE in our list
    HRESULT MoveTo( unsigned int uiIndex)                       // Move to the XBE specified by the index
        { return m_XBEItems.MoveTo( uiIndex ); };
    unsigned int GetCurrentIndex( void )                        // Get the index of the current item
        { return m_XBEItems.GetCurrentIndex(); };
    CXBEInfo* GetCurrentXBEInfoPtr( void )                      // Return a pointer to our CXBEInfo item
        { return m_XBEItems.GetCurrentNode(); };
    unsigned int GetIndexOfXBE( char* pszFilename );            // Find the index of an XBE by filename

private:
    // Private Properties
    CLinkedList< CXBEInfo* > m_XBEItems;                    // XBE Item list
    BOOL m_bInitialized;                                    // Determines if we've already populated

    // Private Methods
    HRESULT LoadXBEs( char* pszDirname,                     // Load the XBEs in to our Linked List
                      char* pszFileExt );
    HRESULT GetInfoFromXBE( CXBEInfo* currentXBE,           // Will parse an XBE file and return the Title Name and Publisher Name
                            BOOL& bValidXBE,
                            char* pszDrive );
    HRESULT ProcessFile( char* pszFileName,                 // Process a file and add it to our list if it is valid
                         char* pszDrive,
                         char* pszDirectory,
                         char* pszExtension );
};

#endif // _XBELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\xitem.cpp ===
/*****************************************************
*** xitem.cpp
***
*** CPP file for our abstract base class for a
*** generic screen of our XDash Config program.
*** 
*** by James N. Helm
*** November 2nd, 2000
***
*** Modified
*** 12/03/2000 - by James N. Helm for XShell
*** 03/09/2001 - by James N. Helm for MU Config
*** 06/22/2001 - by James N. Helm for MU Config
***              Added Set/Get Title functions and
***              property
*****************************************************/

#include "stdafx.h"
#include "xitem.h"

// Constructor
CXItem::CXItem( void )
{
}

// Destructor
CXItem::~CXItem( void )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\XFontFuncs.h ===
#ifndef _XFONTFUNCS_H_
#define _XFONTFUNCS_H_

#include <xfont.h>

// Get the pixel width of a string
int GetStringPixelWidth( XFONT* pFont,
                         IN LPCWSTR string,
                         IN int length = -1 );

// Get the pixel width of a char*
int GetStringPixelWidth( XFONT* pFont,
                         IN char* string,
                         IN int length = -1 );

// Get the size of the currently selected font
void GetFontSize( XFONT* pFont,
                  unsigned int* pheight,
                  unsigned int* pdecent );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( XFONT* pFont,
                             char* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Truncate a string to fit within a certain screen size
HRESULT TruncateStringToFit( XFONT* pFont,
                             WCHAR* pString,
                             unsigned int nStrSize,
                             float x1,
                             float x2 );

// Open the font file specified and use the font pointer passed in
HRESULT OpenTTFontFile( XFONT*& pFont,
                        const WCHAR* pwszFontFilename );

// Close an opened font
HRESULT CloseTTFont( XFONT*& pFont );

#endif // _XFONTFUNCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\xbelist.cpp ===
/*****************************************************
*** xbelist.cpp
***
*** CPP file for our XBE List class.
*** This class will hold a linked list of XBE's that
*** will be populated from a directory.
***
*** by James N. Helm
*** December 2nd , 2000
***
*****************************************************/

#include "stdafx.h"
#include "xbelist.h"

// Constructor
CXBEList::CXBEList( void )
: m_bInitialized( FALSE )
{
    m_XBEItems.SetDeleteDataItem( TRUE );
    m_XBEItems.SetSortedList( TRUE );
}

// Destructor
CXBEList::~CXBEList( void )
{
}


// Will parse an XBE file and return the Title Name and Publisher Name
// If the XBE is valid, bValidXBE will be TRUE, otherwise FALSE
HRESULT CXBEList::GetInfoFromXBE( CXBEInfo* currentXBE, BOOL& bValidXBE, char* pszDrive )
{
    if( ( NULL == currentXBE ) || ( NULL == pszDrive ) )
    {
        DebugPrint( "CXBEList::GetInfoFromXBE():Invalid arg passed in!!\n" );

        return E_INVALIDARG;
    }

    bValidXBE = FALSE;                      // Set the initial return BOOLean to 'FALSE' -- only set it to TRUE if we end up with a valid XBE
    DWORD dwCertLocationOffset = 0;         // Offset in the file where the CERT information lives
    int numRead = 0;                        // Number of 'pages' read using fread
    HRESULT hr = S_OK;                      // Return Code
    FILE* pXBEFile = NULL;                  // Used to open the XBE file
    char pszfileNameBuffer[MAX_PATH + 1];   // Used to hold the file name
    XBEIMAGE_HEADER InitialXBEHeader;       // Will hold the initial header of our XBE file

    // Clear our buffers
    ZeroMemory( pszfileNameBuffer, MAX_PATH + 1 );

    _snprintf( pszfileNameBuffer, MAX_PATH, "%s%s\\%s.%s", pszDrive, currentXBE->GetDirectory(), currentXBE->GetFilename(), currentXBE->GetFileExtension() );

    pXBEFile = fopen( pszfileNameBuffer, "rbR" );
    if( NULL == pXBEFile )
    {
        // Couldn't open the XBE file, return "FALSE" as to the XBE validity
        DebugPrint( "CXBEList::GetInfoFromXBE():Failed to open the file!! - '%s'\n", pszfileNameBuffer );

        hr = S_OK;
        goto cleanup;
    }

    numRead = fread( &InitialXBEHeader, sizeof( XBEIMAGE_HEADER ), 1, pXBEFile );
    if( 1 != numRead )
    {
        // Header wasn't big enough to be a valid XBE file, return "FALSE" as to the XBE validity
        DebugPrint( "CXBEList::GetInfoFromXBE():Header wasn't big enough - expected 1, got - '%d'\n", numRead );

        // Clean up and return
        hr = S_OK;
        goto cleanup;
    }

    if( InitialXBEHeader.Signature != XBEIMAGE_SIGNATURE )
    {
        // Signature didn't match, return "false" as to the XBE validity
        DebugPrint( "CXBEList::GetInfoFromXBE():Invalid XBE signature\n" );

        // Clean up and return
        hr = S_OK;
        goto cleanup;
    }

    // Calculate the offset in the file where the CERT size is located
    dwCertLocationOffset = (ULONG)InitialXBEHeader.Certificate - (ULONG)InitialXBEHeader.BaseAddress;

    // Seek to that location in the file and read in the XBOX CERT
    if( 0 != fseek( pXBEFile, dwCertLocationOffset, SEEK_SET ) )
    {
        // Return FALSE
        DebugPrint( "CXBEList::GetInfoFromXBE():Could not fseek to proper file location!! Tried - '%d'\n", dwCertLocationOffset );

        goto cleanup;
    }

    // Read in the information in to our XCERT
    XBEIMAGE_CERTIFICATE XBECert;
    numRead = fread( &XBECert, sizeof( XBEIMAGE_CERTIFICATE ), 1, pXBEFile );
    if( 1 != numRead )
    {
        // Return FALSE
        DebugPrint( "CXBEList::GetInfoFromXBE():Could not read the CERT from the file!! - expected 1, got - '%d'\n", numRead );

        goto cleanup;
    }

    _snwprintf( currentXBE->GetTitleName(), XBEIMAGE_TITLE_NAME_LENGTH, L"%s", XBECert.TitleName );

    bValidXBE = TRUE;

cleanup:

    if( NULL != pXBEFile )
        fclose( pXBEFile );

    return hr;
}


// Initialize our list
//
// dirname - the name of the directory to parse
// fileExt - the extension of the file to use
HRESULT CXBEList::Init( char* pszDirname, char* pszFileExt )
{
    HRESULT hr = S_OK;

    if( m_bInitialized )
        hr = m_XBEItems.EmptyList();    // Ensure our list is empty

    if( SUCCEEDED( hr ) )
    {
        m_bInitialized = FALSE;
        hr = LoadXBEs( pszDirname, pszFileExt );

        if( SUCCEEDED( hr ) )
            m_bInitialized = TRUE;
        else // Clean up our list if we are in a bad way
            m_XBEItems.EmptyList();
    }

    return hr;
}


// Load the XBEs in to our Linked List
HRESULT CXBEList::LoadXBEs( char* pszDirname, char* pszFileExt )
{
    // Ensure we were passed valid parameters
    if( ( NULL == pszDirname ) || ( NULL == pszFileExt ) )
    {
        DebugPrint( "CXBEList::LoadXBEs():Invalid arguments passed in!!\n" );

        return E_INVALIDARG;
    }

    char pszSearchPath[MAX_PATH];
    _snprintf( pszSearchPath, MAX_PATH, "%s\\*.%s", pszDirname, pszFileExt );

    WIN32_FIND_DATA wfd;
    HANDLE hFind;

    // Find the first file in the directory
    hFind = FindFirstFile( pszSearchPath, &wfd );

    // If FindFirstFile failed with an error, return E_FAIL
    if( INVALID_HANDLE_VALUE == hFind )
        return E_FAIL;

    // Parse the directories looking for the correct file types
    do
    {
        // Skip over files that we are not interested in
		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM )
			continue;

		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )
			continue;

		if ( wfd.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY )
			continue;

        if( wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            continue;

		if ( '.' == wfd.cFileName[0] )
			continue;

        HRESULT hrFileStatus = ProcessFile( wfd.cFileName, "d:", pszDirname, pszFileExt );
        if( FAILED( hrFileStatus ) )
            DebugPrint( "CXBEList::LoadXBEs():Failed to process the file!! File - '%hs', Dir - '%hs', Error - '0x%.8X (%d)'\n", wfd.cFileName, pszDirname, hrFileStatus, hrFileStatus );

    } while( FindNextFile( hFind, &wfd ) );

// cleanup:
    if( !FindClose( hFind ) )
        DebugPrint( "CXBEList::LoadXBEs():FindClose failed!! - (%d)\n", GetLastError() );

    return S_OK;
}


// Process the file and add it to our XBE list if it's valid
HRESULT CXBEList::ProcessFile( char* pszFileName, char* pszDrive, char* pszDirectory, char* pszExtension )
{
    if( ( NULL == pszFileName ) || ( NULL == pszDirectory ) || ( NULL == pszExtension ) || ( NULL == pszDrive ) )
    {
        DebugPrint( "CXBEList::ProcessFile():Invalid parameter passed in!!\n" );

        return E_INVALIDARG;
    }

    // Process files that only END in .XBE
    char* pszLocExtention = pszFileName + ( strlen( pszFileName ) - 3 );

    // Match the extension using the upcased version of the file name
    if( 0 == _stricmp( pszLocExtention, pszExtension ) )
    {
        CXBEInfo* pXBEInfo = new CXBEInfo;
        if( NULL == pXBEInfo )
        {
            DebugPrint( "CXBEList::ProcessFile():Failed to allocate memory!!\n" );

            return E_OUTOFMEMORY;
        }

        pXBEInfo->SetDirectory( pszDirectory + 2 );

        unsigned int uiStrLen = strlen( pszFileName ) - strlen( pszExtension ) - 1;
        char* pszNewFileName = new char[uiStrLen + 1];
        if( NULL == pszNewFileName )
        {
            DebugPrint( "CXBEList::ProcessFile():Unable to allocate memory!!\n" );

            delete pXBEInfo;
            pXBEInfo = NULL;

            return E_OUTOFMEMORY;
        }
        pszNewFileName[uiStrLen] = '\0';
        strncpy( pszNewFileName, pszFileName, uiStrLen );
        pXBEInfo->SetFilename( pszNewFileName );

        delete[] pszNewFileName;
        pszNewFileName = NULL;

        pXBEInfo->SetFileExtension( pszLocExtention );

        // DebugPrint( "CXBEList::ProcessFile():Dir - '%hs', File - '%hs'\n", pXBEInfo->GetDirectory(), pXBEInfo->GetFilename() );

        // Determine if it's a valid XBE, get the title and publisher info
        BOOL bValidXBE;
        if( FAILED( GetInfoFromXBE( pXBEInfo, bValidXBE, pszDrive ) ) )
        {
            DebugPrint( "CXBEList::ProcessFile(): Get Info Failed!!\n" );

            delete pXBEInfo;
            pXBEInfo = NULL;
        }
        else if( !bValidXBE )
        {
            DebugPrint( "CXBEList::ProcessFile():Invalid XBE!!\n" );

            delete pXBEInfo;
            pXBEInfo = NULL;
        }
        else
		{
			// Process Configuration File
            if( FAILED( ProcessConfigFile( pXBEInfo ) ) )
            {
                DebugPrint( "CXBEList::ProcessFile():ProcessConfigFile failed!!\n" );

                delete pXBEInfo;
                pXBEInfo = NULL;
            }
            else
            {
                // Add a configuration based off of the default configuration
                CTestConfig* pTestConfig = new CTestConfig;
                if( NULL == pTestConfig )
                {
                    DebugPrint( "CXBEList::ProcessFile():Failed to allocate memory!!\n");

                    delete pXBEInfo;
                    pXBEInfo = NULL;
                    
                    return E_FAIL;
                }

                *pTestConfig = *(pXBEInfo->GetDefaultTestConfig());

                // Add the new test config to our XBE
                pXBEInfo->AddTestConfig( pTestConfig );

                // Add the XBE to our list
                m_XBEItems.AddNode( pXBEInfo );
            }
		}
    }

    return S_OK;
}


// Find the index of an XBE by filename
unsigned int CXBEList::GetIndexOfXBE( char* pszFilename )
{
    if( NULL == pszFilename )
    {
        DebugPrint( "CXBEList::GetIndexOfXBE():Invalid argument(s) passed in!!\n" );

        return 9999;
    }

    BOOL bFound = FALSE;
    unsigned int uiReturnIndex = 0;
    MoveFirst();
    do
    {
        if( 0 == _stricmp( pszFilename, GetCurrentXBEInfoPtr()->GetFilename() ) )
        {
            bFound = TRUE;

            break;
        }

        uiReturnIndex++;
    } while( MoveNext() );

    if( !bFound )
        uiReturnIndex = 9999;

    return uiReturnIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\xitem.h ===
/*****************************************************
*** xitem.h
***
*** Header file for our abstract base class for a
*** generic screen of our XDash Config program.
***
*** by James N. Helm
*** November 2nd, 2000
***
*** Modified
*** 12/03/2000 - by James N. Helm for XShell
*** 03/09/2001 - by James N. Helm for MU Config
*** 06/22/2001 - by James N. Helm for MU Config
***              Added Set/Get Title functions and
***              property
*** 11/21/2001 - by James N. Helm for HVS
                 Removed everything but action and
                 control functions
*****************************************************/

#ifndef _XDCITEM_H_
#define _XDCITEM_H_

#include "udtexture.h"

class CXItem
{
public:
    // Constructors and Destructors
    CXItem( void );
    virtual ~CXItem( void );

    // Functions that MUST be overridden
    virtual void Action( CUDTexture* pTexture ) = 0;
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress ) = 0;
    virtual void HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress ) = 0;
    virtual void HandleInput( enum JOYSTICK joystick, int nThumbLY, int nThumbLX, BOOL bFirstYPress, BOOL bFirstXPress ) = 0;
    
    virtual void Enter( void ) = 0;                     // Should be called whenever the menu becomes active
    virtual void Leave( CXItem* pItem ) = 0;            // Should be called whenever user is leaving the menu
protected:

private:
};

#endif // _XDCITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\memCheck\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\yesnomenu.cpp ===
/*****************************************************
*** yesnomenu.h
***
*** CPP file for our Yes/No Menu class.
*** This will allow the user to select Yes or No
***
*** by James N. Helm
*** December 13th, 2001
***
*****************************************************/

#include "stdafx.h"
#include "yesnomenu.h"

// Constructors
CYesNoMenu::CYesNoMenu( void ) :
m_bCancelled( FALSE ),
m_xKeypos( 0 ),
m_yKeypos( 0 )
{
    // Zero out our buffers
    for( unsigned int x = 0; x < gc_uiNUM_TEXT_LINES; x++ )
        ZeroMemory( m_apwszTextMessage[x], sizeof( WCHAR ) * ( MAX_PATH + 1 ) );

    GenerateKeypad();
}


// Destructor
CYesNoMenu::~CYesNoMenu( void )
{
}


// Initialize the Menu
HRESULT CYesNoMenu::Init( XFONT* pMenuItemFont, XFONT* pMenuTitleFont )
{
    HRESULT hr = CMenuScreen::Init( pMenuItemFont, pMenuTitleFont );
    if( FAILED( hr ) )
    {
        DebugPrint( "CYesNoMenu::Init():Failed to initialize base class!!\n" );

        return hr;
    }

	// Set the menu title
	SetMenuTitle( pMenuTitleFont, L"Yes / No" );

    /////////////////////////
    // Add screen items here
    /////////////////////////
    AddBitmapItem( "d:\\media\\images\\background.bmp", 0, 0 );

    // Status Bar Column 1
    AddTextItem( GetButtonFont(), L"A",       gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwCOLOR_A_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Select", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW1_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( GetButtonFont(), L"B",       gc_fSTATUS_TEXT_COL1_XPOS,                           gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwCOLOR_B_BUTTON,       gc_dwSTATUS_TEXT_BG_COLOR );
    AddTextItem( pMenuItemFont,   L" Cancel", gc_fSTATUS_TEXT_COL1_XPOS + gc_fBUTTON_WIDTH_ADJUST, gc_fSTATUS_TEXT_ROW2_YPOS, gc_dwSTATUS_TEXT_FG_COLOR, gc_dwSTATUS_TEXT_BG_COLOR );
	
    return hr;
}


// Draws a menu on to the screen
void CYesNoMenu::Action( CUDTexture* pTexture )
{
    // Check to see if we should update our texture.  If not, bail
    if( !m_bUpdateTexture )
        return;

    // Let our base menu draw the items from the data file
    CMenuScreen::Action( pTexture );

    // Lock our texture and set it as the render target
    pTexture->Lock();

	// Draw our keypad
	renderKeypad( pTexture );

    // Render the text message
    for( unsigned int x = 0; x < gc_uiNUM_TEXT_LINES; x++ )
    {
		WCHAR* pwszMessagePtr = m_apwszTextMessage[x];
		DWORD dwFGColor = m_dwMenuItemEnabledFGColor;
		DWORD dwBGColor = m_dwMenuItemEnabledBGColor;

		// Determine if the user wants to display this line of text in a different color
		if( 0 == wcsncmp( m_apwszTextMessage[x], L"/c", 2 ) )
		{
			pwszMessagePtr += 2;	// Skip the initial "/c"

			// Read the DWORD FG color out of the line
			WCHAR* pwszStopString = NULL;
			dwFGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwFGColor )
				DebugPrint( "CMessageMenu::RenderMenuItems():Possible error in conversion of the FG color (DWORD)\n" );

			// Skip over the FG color and the space
			pwszMessagePtr = pwszStopString + 1;

			// Read the DWORD BG color out of the line
			dwBGColor = wcstol( pwszMessagePtr, &pwszStopString, 10 );
			if( 0 == dwBGColor )
				DebugPrint( "CMessageMenu::RenderMenuItems():Possible error in conversion of the BG color (DWORD)\n" );

			// Skip over the BG color and the space
			pwszMessagePtr = pwszStopString + 1;
		}

        float fXPos = gc_fMENU_AREA_HORIZ_CENTER - ( GetStringPixelWidth( GetBodyFont(), pwszMessagePtr ) / 2 );
        float fYPos = gc_fYESNO_TEXT_YPOS + ( x * ( m_uiMenuItemFontHeight + m_fMenuItemVertSpace ) );

        pTexture->DrawText( GetBodyFont(), fXPos, fYPos, dwFGColor, dwBGColor, L"%ls", pwszMessagePtr );
    }

    // Unlock our texture
    pTexture->Unlock();
}


// Handles input (of the CONTROLS) for the current menu
void CYesNoMenu::HandleInput( enum CONTROLS controlPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( controlPressed )
    {
    case CONTROL_DPAD_LEFT:
        {
            // Wrap the cursor
            if( 0 == m_xKeypos )
                m_xKeypos = gc_uiYESNO_NUM_COLS - 1;
            else // m_xKeypos > 0
                m_xKeypos--;
            
            for( int x = m_xKeypos; x >= 0; x-- )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();
                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
    case CONTROL_DPAD_RIGHT:
        {
            // Wrap the cursor
            if( ( gc_uiYESNO_NUM_COLS - 1 ) == m_xKeypos )
                m_xKeypos = 0;
            else // m_xKeypos < ( gc_uiYESNO_NUM_COLS - 1 )
                m_xKeypos++;

            for( unsigned int x = m_xKeypos; x < gc_uiYESNO_NUM_COLS; x++ )
            {
                if( m_keyPad[x][m_yKeypos].getRender() && ( wcscmp( m_keyPad[x][m_yKeypos].m_pwszResultChar, L"place" ) != 0 ) )
                {
                    UpdateTexture();
                    m_xKeypos = x;

                    break;
                }
            }

            break;
        }
	}
}


// Handles input (of the BUTTONS) for the current menu
void CYesNoMenu::HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress )
{
    // Process the default button delay
    if( !HandleInputDelay( bFirstPress ) )
        return;

    // Handle Buttons being pressed
    switch( buttonPressed )
    {
    case BUTTON_A:
        {
            // Deal with keyboard input
			if( 0 == wcscmp( m_keyPad[m_xKeypos][m_yKeypos].m_pwszResultChar, L"No" ) )    // No
                m_bCancelled = TRUE;

            GoBack();

            break;
        }
    case BUTTON_B:
        {
            m_bCancelled = TRUE;
            
            GoBack();

            break;
        }
    }
}


// Generate the kepad we will be using
void CYesNoMenu::GenerateKeypad(void) 
{
	
	// Create the buttons
	int xstart = gc_uiYESNO_TOPROW_X1;
	int ystart = gc_uiYESNO_TOPROW_Y1;
	int width  = gc_uiYESNO_BUTTON_WIDTH;
	int height = gc_uiYESNO_BUTTON_HEIGHT;
	int spacer = gc_uiYESNO_BUTTON_SPACER;
	int currentx = xstart;
	int currenty = ystart;

    for(unsigned int y = 0; y < gc_uiYESNO_NUM_ROWS; y++ )
	{
		for( unsigned int x = 0; x < gc_uiYESNO_NUM_COLS; x++ )
		{
			m_keyPad[x][y].define( currentx, currenty, width, height, m_dwMenuItemEnabledFGColor );
			currentx += width + spacer;
		}
		currentx = xstart;
		currenty += height + spacer;
	}

    m_keyPad[0][0].defineText( L"Yes" );
    m_keyPad[1][0].defineText( L"No" );
}


// Draw our keypad
BOOL CYesNoMenu::renderKeypad( CUDTexture* pTexture )
{
	
	// Render outlines of keys	
	float x1, x2;
	float y1, y2;
	for( unsigned int x = 0; x < gc_uiYESNO_NUM_COLS; x++ )
	{
		for( unsigned int y = 0; y < gc_uiYESNO_NUM_ROWS; y++ )
		{
			if( m_keyPad[x][y].getRender() && ( wcscmp( m_keyPad[x][y].m_pwszResultChar, L"place" ) != 0 ) )
			{
                // Lock our texture so that we can render to it
                pTexture->Lock();

				x1 = (float)m_keyPad[x][y].m_iXOrigin;
				x2 = (float)(m_keyPad[x][y].m_iXOrigin + m_keyPad[x][y].m_iWidth);
				
				y1 = (float)m_keyPad[x][y].m_iYOrigin;
				y2 = (float)(m_keyPad[x][y].m_iYOrigin + m_keyPad[x][y].m_iHeight);
	
				// hilight key if currently selected
                DWORD dwCharColor;
				if((m_xKeypos == x) && (m_yKeypos == y))
                {
					pTexture->DrawBox( x1, y1, x2, y2, m_dwMenuItemSelectorColor );
                    
                    dwCharColor = m_dwSelectedItemFGColor;
                }
                else
                {
                    dwCharColor = m_dwMenuItemEnabledFGColor;
                }

                pTexture->DrawOutline( x1, y1, x2, y2, gc_fYESNO_LINE_WIDTH, m_keyPad[x][y].m_dwSelectColor );
				
				unsigned int decent;
				unsigned int fontHeight;
				GetFontSize( GetBodyFont(), &fontHeight, &decent );
				
				float textX = (float)((m_keyPad[x][y].m_iWidth / 2) + m_keyPad[x][y].m_iXOrigin) - GetStringPixelWidth( GetBodyFont(), m_keyPad[x][y].m_pwszResultChar ) / 2;
				float textY = (float)((m_keyPad[x][y].m_iHeight / 2) + m_keyPad[x][y].m_iYOrigin) - (fontHeight / 2);
				
                pTexture->DrawText( GetBodyFont(), textX, textY, dwCharColor, m_dwMenuItemEnabledBGColor, L"%s", m_keyPad[x][y].m_pwszResultChar);

                // Unlock our texture
                pTexture->Unlock();
			}
		}
	}
	
	return TRUE;
}


// This will be called whenever this menu is entered / activated
void CYesNoMenu::Enter( void )
{
    // Call the base-class enter
    CMenuScreen::Enter();

    // Default the focus to the NO Button
	m_xKeypos = 1;
    m_yKeypos = 0;

    // Make sure our cancelled option is set to FALSE
    m_bCancelled = FALSE;
}


// Used to set the text message that will be displayed to the user
void CYesNoMenu::SetText( WCHAR* pwszMessage )
{
    if( NULL == pwszMessage )
    {
        DebugPrint( "CYesNoMenu::SetText():Invalid argument(s) passed in!!\n" );

        return;
    }

    for( unsigned int x = 0; x < gc_uiNUM_TEXT_LINES; x++ )
    {
        unsigned int uiCount = 0;
        while( ( *pwszMessage != L'\n' ) && ( *pwszMessage != L'\0' ) )
        {
            m_apwszTextMessage[x][uiCount] = *pwszMessage;
            uiCount++;
            pwszMessage++;

            // Exit when we find the end of the current string
            if( uiCount == MAX_PATH + 1 )
                break;
        }
        m_apwszTextMessage[x][uiCount] = L'\0';

        // Exit early if we are at the end of the message
        if( *pwszMessage == L'\0' )
            break;

        uiCount++;
        pwszMessage++;
    }

    /*
    for( x = 0; x < gc_uiNUM_TEXT_LINES; x++ )
    {
        DebugPrint("m_apwszTextMessage[x] - '%ls'\n", m_apwszTextMessage[x] );
        DebugPrint( "Length - '%d'\n", wcslen( m_apwszTextMessage[x] ) );
    }
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\launcher\yesnomenu.h ===
/*****************************************************
*** yesnomenu.h
***
*** Header file for our Yes/No Menu class.
*** This will allow the user to select Yes or No
***
*** by James N. Helm
*** December 13th, 2001
***
*****************************************************/

#ifndef _YESNOMENU_H_
#define _YESNOMENU_H_

const unsigned int gc_uiYESNO_NUM_ROWS =        1;     
const unsigned int gc_uiYESNO_NUM_COLS =        2;     
                                                
const unsigned int gc_uiYESNO_BUTTON_SPACER =   35;     
const unsigned int gc_uiYESNO_BUTTON_HEIGHT =   40;     
const unsigned int gc_uiYESNO_BUTTON_WIDTH =    100;     
                                                
const unsigned int gc_uiYESNO_TOPROW_Y1 =       285;     
const unsigned int gc_uiYESNO_TOPROW_X1 =       ( 640 / 2 ) - ( gc_uiYESNO_BUTTON_SPACER / 2 ) - gc_uiYESNO_BUTTON_WIDTH;
                                                
const float gc_fYESNO_TEXT_YPOS =               125.0f     ;
                                                
const float gc_fYESNO_LINE_WIDTH =              1.0f;     

const unsigned int gc_uiNUM_TEXT_LINES =        5;

#include "menuscreen.h"  // Base menu type
#include "key.h"

class CYesNoMenu : public CMenuScreen
{
public:
    // Constructors and Destructors
    CYesNoMenu( void );
    virtual ~CYesNoMenu( void );

    // Process drawing and input for a menu screen
    virtual void Enter( void );   // This will be called whenever this menu is entered / activated
    virtual void Action( CUDTexture* pTexture );
    virtual void HandleInput( enum BUTTONS buttonPressed, BOOL bFirstPress );
    virtual void HandleInput( enum CONTROLS buttonPressed, BOOL bFirstPress );

    virtual HRESULT Init( XFONT* pMenuItemFont,             // Initialize the Menu
                          XFONT* pMenuTitleFont );

    void SetText( WCHAR* pwszMessage );                     // Used to set the text message that will be displayed to the user

    BOOL GetCancelled( void ) { return m_bCancelled; };     // Used to determine if the user cancelled the keyboard

protected:
    // Properties
    WCHAR   m_apwszTextMessage[gc_uiNUM_TEXT_LINES][MAX_PATH+1];	// Used to hold the text message
    BOOL    m_bCancelled;                                           // Used to determine if the user cancelled the menu
	int     m_xKeypos;                                              // Current X position on the Keyboard
    int     m_yKeypos;                                              // Current Y position on the Keyboard
	CKey    m_keyPad[gc_uiYESNO_NUM_COLS][gc_uiYESNO_NUM_ROWS];     // Each Key displayed on the Keyboard
	
    // Private Methods
	virtual void GenerateKeypad(void);                  // Create the keypad that will be used
	virtual BOOL renderKeypad( CUDTexture* pTexture );  // Draw the keypad on to the our texture

};

#endif // _YESNOMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\memCheck\gui.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    gui.cpp

Abstract:

    Low level disk test scanner.

Notes:

*****************************************************************************/
#include "memCheck.h"

IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText	= NULL;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;

#define STICK_DEAD_ZONE         6400
#define BUTTON_PRESS_VALUE      100
#define BUTTON_SPEEP_VALUE      150         // in ms

#define COLUMN_1_OFFSET         25
#define COLUMN_2_OFFSET         165

int ThumbStickScale(int stick, int max)
    {
    if(stick > 0) stick -= STICK_DEAD_ZONE;
    else stick += STICK_DEAD_ZONE;

    return (stick*max)/(32768-STICK_DEAD_ZONE);
    }


void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale)
    {
    // UP
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
        {
        ++value;
        if(value > max) value = max;
        }
    if(input.Gamepad.sThumbLY > STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value > max) value = max;
        }

    // DOWN
    if(input.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
        {
        --value;
        if(value < min) value = min;
        if(value > max) value = min;
        }
    if(input.Gamepad.sThumbLY < -STICK_DEAD_ZONE)
        {
        value += ThumbStickScale(input.Gamepad.sThumbLY, maxThumbStickScale);
        if(value < min) value = min;
        if(value > max) value = min;
        }
    }

DWORD buttonXColor, buttonYColor, buttonAColor, buttonBColor, buttonBlkColor, buttonWhtColor;
DWORD currentSelection = 0;

void GUI(void)
{
    bool exit = false;
    DWORD addDevice, removeDevice;
    XINPUT_STATE state;

    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
        for(unsigned port=0; port<XGetPortCount(); port++)
        {
            if(hDuke[port])
            {
                XInputGetState(hDuke[port], &state);
                if(state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) exit = true;
            }
        }

        UpdateGraphics( DISPLAYMODE_CONFIG_READONLY );

        Sleep(BUTTON_SPEEP_VALUE);
}

    // sleep past any residual user input presses
    Sleep(BUTTON_SPEEP_VALUE);
    buttonXColor = buttonYColor = buttonAColor = buttonBColor = buttonBlkColor = buttonWhtColor = 0xFFFFFFFF;
    }


void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...)
    {
    char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, x, (line+1)*10, 0, color, 0);
    }


void UpdateGraphics(unsigned mode /*=DISPLAYMODE_RUN_TIME*/)
{
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // run time status mode
    //
    if( mode == DISPLAYMODE_RUN_TIME || mode == DISPLAYMODE_PAUSE )
    {
	    GraphicPrint( pd3ds, COLUMN_1_OFFSET, 1, 0xFF4444FF, "Memory Type: %ls", g_pwszMemType );
	    GraphicPrint( pd3ds, COLUMN_1_OFFSET, 2, 0xFF4444FF, "Total Memory: %u MB", g_dwTotalMemory );

        unsigned line = 4;
        GraphicPrint( pd3ds, COLUMN_1_OFFSET, line, 0xFFFFFFFF, "Starting Pos: %u", globalSettings.dwStartBlock );
        GraphicPrint( pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, "Ending Pos: %u", globalSettings.dwEndBlock );
        
        GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Block Size: %u", globalSettings.dwBlockSize );

        // Calculate Block Amount
        DWORD dwTotalBlocks = ( globalSettings.dwEndBlock - globalSettings.dwStartBlock ) / globalSettings.dwBlockSize;
        if( ( ( globalSettings.dwEndBlock - globalSettings.dwStartBlock ) % globalSettings.dwBlockSize ) != 0 )
            dwTotalBlocks++;

        GraphicPrint( pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, "Total Blocks: %u", dwTotalBlocks );

        GraphicPrint( pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Blocks Read: %I64u", ui64NumBlocksRead);
        
        unsigned __int64 ui64ClockTick = ReadTSC() - ui64Time;
        GraphicPrint( pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, "Run Time: %I64u sec", ui64ClockTick / 733000000UI64 );

        GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Test Pass #%u", dwTestPassNumber );

        if( globalSettings.stopAfter.type == STOPAFTER_ITERATIONS )
            GraphicPrint( pd3ds, COLUMN_2_OFFSET,  line, 0xFFFFFFFF, "Duration: %u iteration(s)", globalSettings.stopAfter.duration );
        else if( globalSettings.stopAfter.type == STOPAFTER_MINUTES )
            GraphicPrint( pd3ds, COLUMN_2_OFFSET,  line, 0xFFFFFFFF, "Duration: %u minute(s)", globalSettings.stopAfter.duration );
        else if( globalSettings.stopAfter.type == STOPAFTER_HOURS )
            GraphicPrint( pd3ds, COLUMN_2_OFFSET,  line, 0xFFFFFFFF, "Duration: %u hour(s)", globalSettings.stopAfter.duration );

        line++;

        GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFF00FF00, "Pass %u", dwNumPass );
        GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFF0000, "Fail %u", dwNumFail );

        line+=2;

        // Check to see if interrupts are disabled
        if( !globalSettings.dwDisableInterrupts )
        {
            GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFF0000, "Interrupts enabled; Failures Possible!!" );
        }

        // Check to see if XBDM is enabled.  If so, display a warning
        if( DmGetCurrentDmi() != NULL )
        {
            GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFF0000, "XBDM enabled; Failures Possible!!" );
        }

        // Check to see if USB is enabled.  If so, display a warning
        if( globalSettings.dwEnableUSB )
        {
            GraphicPrint( pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFF0000, "USB enabled; Failures Possible!!" );

            if( mode == DISPLAYMODE_RUN_TIME )
            {
	            GraphicPrint( pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Press START to view the current settings" );
	            GraphicPrint( pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press Left Trigger + Right Trigger + Black to reboot" );
            }
            else if( mode == DISPLAYMODE_PAUSE )
            {
	            GraphicPrint( pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFF00,  "PAUSED" );
	            GraphicPrint( pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFF00,  "Press BACK to continue" );
            }
        }
        else
        {
            if( mode == DISPLAYMODE_RUN_TIME )
                GraphicPrint( pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "USB Disabled.  Test must complete before test can be halted" );
        }
    }

    //
    // config setup gui
    //
    else if(mode == DISPLAYMODE_CONFIG_READONLY)
    {
        DWORD color;
        if(mode == 2) color = 0xFF777777;
        else color = 0xFFFFFFFF;

        if(mode == DISPLAYMODE_CONFIG_INTERACTIVE) // interactive
        {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Use the DPAD or Left Thumbstick UP/DOWN to change the values");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press START to continue");
        }
        else // non interactive
        {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press BACK to continue");
        }
    }

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
}



bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                {
                LogPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    // check for exit file
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile("T:\\testexit.txt", &FindFileData);
    FindClose(hFind);
    if(hFind != INVALID_HANDLE_VALUE)
        {
        LogPrint("\r\n\r\nFound Exit File (testexit.txt) - rebooting\r\n");
        return true;
        }

    return false;
    }


bool InputCheckButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE)
                {
                return true;
                }
            }
        }

    return false;
    }


bool InputCheckDigitalButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.wButtons & button)
                {
                return true;
                }
            }
        }

    return false;
    }


void Pause(void)
    {
    DWORD addDevice, removeDevice;
    OutputDebugStringA("*****************************************************************************\n");
    OutputDebugStringA("* Entered Paused State. Hit the BACK button to resume...\n");
    OutputDebugStringA("*****************************************************************************\n");
    while(!InputCheckDigitalButton(XINPUT_GAMEPAD_BACK))
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        UpdateGraphics(DISPLAYMODE_PAUSE);

        Sleep(BUTTON_SPEEP_VALUE);
        }
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            //LogPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }


void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned i=0; i<XGetPortCount()*2; i++)
        {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[i]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[i]), XMUSlotFromDriveLetter((char)hSlot[i]));
            hSlot[i] = NULL;
            }
        if(add & USBSlotMasks[i])
            {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
                {
                hSlot[i] = (HANDLE)drive;
                //LogPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[i])+1, XMUSlotFromDriveLetter((char)hSlot[i])+1);
                }
            }
        }
    }


/*

Routine Description:

	De-initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT DeInitGraphics(void)
{
    g_pDevice->Release();
    g_pDevice = NULL;

    g_pd3dtText->Release();
    g_pd3dtText = NULL;

    return S_OK;
}

/*

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT InitGraphics(void)
{
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;

    // Release D3D Object
    g_d3d->Release();
    g_d3d = NULL;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

    // Clear our persisted memory
    g_pDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00000000, 1.0f, 0 );
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\memCheck\memCheck.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    memCheck.h

Abstract:

    Memory validator / scanner

Notes:

*****************************************************************************/

#ifndef _MEMCHECK_H_
#define _MEMCHECK_H_

#ifdef _VC
//#define DEVICE_TYPE ULONG
#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500
#endif

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <ntos.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>

#include <dm.h>
#include <xtl.h>
#include <stdio.h>

#include "../utils/hvsUtils.h"
#include "bitfont.h"

//
// utility functions
//
void DebugPrint(char* format, ...);
long GetNumber(char *string);

//
// Initialization calls
//
void Initialize(void);
HRESULT DeInitGraphics(void);
HRESULT InitGraphics(void);

//
// User input
// 
void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);
bool InputCheckButton(int button);
bool InputCheckDigitalButton(int button);
void Pause(void);
int ThumbStickScale(int stick, int max);
void AdjustValue(DWORD &value, DWORD min, DWORD max, XINPUT_STATE &input, DWORD maxThumbStickScale);


//
// Graphics / GUI methods
//
enum DISPLAY_MODE
    {
    DISPLAYMODE_PAUSE,
    DISPLAYMODE_RUN_TIME,
    DISPLAYMODE_CONFIG_READONLY,
    DISPLAYMODE_CONFIG_INTERACTIVE
    };
void UpdateGraphics(unsigned mode = DISPLAYMODE_RUN_TIME);
void GUI(void);
void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...);


//
// Utility functions
//
void HexDump(const unsigned char * buffer, DWORD length);
WCHAR* Ansi2UnicodeHack(char *str);
BOOL CompareBuff( unsigned char *buff1, unsigned char *buff2, unsigned length );


//
// User input
//
extern HANDLE hDuke[XGetPortCount()];
extern HANDLE hSlot[XGetPortCount()*2];
static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };

//
// config settings
//
struct ConfigSettings : public CoreConfigSettings
{
    DWORD dwBlockSize;
    DWORD dwStartBlock;
    DWORD dwEndBlock;
    DWORD dwReadMode;
    DWORD dwPauseOnExit;
    DWORD dwEnableGraphics;
    DWORD dwGraphicsUpdateInterval;
    DWORD dwEnableUSB;
    DWORD dwEnableNetwork;
    DWORD dwDisableInterrupts;

    ConfigSettings()
    {
        dwBlockSize = 0;
        dwStartBlock = 0;
        dwEndBlock = 0;
        dwReadMode = 0;
        dwPauseOnExit = 0;
        dwEnableGraphics = 0;
        dwGraphicsUpdateInterval = 0;
        dwEnableUSB = 0;
        dwEnableNetwork = 0;
        dwDisableInterrupts = 0;
    }
};

extern ConfigSettings globalSettings;

//
// stats
//
extern DWORD dwNumPass;
extern DWORD dwNumFail;
extern DWORD dwNumBuffMisMatch;
extern unsigned __int64 ui64NumBlocksRead;
extern unsigned __int64 ui64Time;
extern DWORD dwNumTimesThrough;
extern DWORD dwTestPassNumber;
extern WCHAR g_pwszMemType[50];
extern DWORD g_dwTotalMemory;

//
// graphics
//
extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;

FORCEINLINE
void * __cdecl MEMMOVE (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

#if     defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
        {
        extern void RtlMoveMemory( void *, const void *, size_t count );

        RtlMoveMemory( dst, src, count );
        }
#else
        if (dst <= src || (char *)dst >= ((char *)src + count)) {
                /*
                 * Non-Overlapping Buffers
                 * copy from lower addresses to higher addresses
                 */
                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst + 1;
                        src = (char *)src + 1;
                }
        }
        else {
                /*
                 * Overlapping Buffers
                 * copy from higher addresses to lower addresses
                 */
                dst = (char *)dst + count - 1;
                src = (char *)src + count - 1;

                while (count--) {
                        *(char *)dst = *(char *)src;
                        dst = (char *)dst - 1;
                        src = (char *)src - 1;
                }
        }
#endif

        return(ret);
}

FORCEINLINE
UINT64
ReadTSC(
    VOID
    )
/*++

Routine Description:

    This routine reads processor's time-stamp counter.  The time-stamp counter
    is contained in a 64-bit MSR.  The high-order of 32 bits MSR are loaded
    into the EDX register, and the low-order 32 bits are loaded into the EAX
    register.  The processor increments the time-stamp counter MSR every
    clock cycle and resets it to 0 whenever the processor reset.

Arguments:

    None

Return Value:

    64-bit MSR of time-stamp counter

--*/
{
    __asm {
        rdtsc
    }
}

#endif //_MEMCHECK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\readFile\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\memCheck\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\memCheck\memCheck.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    memCheck.cpp

Abstract:

    Memory validator / scanner

Notes:

*****************************************************************************/

#include "memCheck.h"
#include <xbeimage.h>
#include <mm.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

#pragma intrinsic( memcpy )


HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[XGetPortCount()*2] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

//
// config settings
//
ConfigSettings globalSettings;

//
// stats
//
DWORD dwNumTimesThrough = 0;
DWORD dwTestPassNumber = 1;
DWORD dwNumPass = 0;
DWORD dwNumFail = 0;
DWORD dwNumBuffMisMatch = 0;
unsigned __int64 ui64NumBlocksRead = 0;
unsigned __int64 ui64Time = ReadTSC();

//
// Info
//
WCHAR g_pwszMemType[50];
DWORD g_dwTotalMemory = 0;

void ParseTestConfig(char *variable, char *value, void *userParam)
{
    ConfigSettings* pSettings = (ConfigSettings*)userParam;

    if(strstr(variable, "blocksize") != NULL) pSettings->dwBlockSize = GetNumber(value);
    else if(strstr(variable, "startblock") != NULL) pSettings->dwStartBlock = GetNumber(value);
    else if(strstr(variable, "endblock") != NULL) pSettings->dwEndBlock = atol(value);
    else if(strstr(variable, "readmode") != NULL) pSettings->dwReadMode = GetNumber(value);
    else if(strstr(variable, "pauseonexit") != NULL) pSettings->dwPauseOnExit = GetNumber(value);
    else if(strstr(variable, "enablegraphics") != NULL) pSettings->dwEnableGraphics = GetNumber(value);
    else if(strstr(variable, "graphicsupdateinterval") != NULL) pSettings->dwGraphicsUpdateInterval = GetNumber(value);
    else if(strstr(variable, "enableusb") != NULL) pSettings->dwEnableUSB = GetNumber(value);
    else if(strstr(variable, "enablenetwork") != NULL) pSettings->dwEnableNetwork = GetNumber(value);
    else if(strstr(variable, "disableinterrupts") != NULL) pSettings->dwDisableInterrupts = GetNumber(value);

    // DebugPrint( "var - '%hs' = '%hs'\r\n", variable, value );
}

void _cdecl main(void)
{
    //
    // Get the launch data (if any)
    //
    DWORD dwDataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    XGetLaunchInfo( &dwDataType, &launchInfo );
    ToTestData* pInitialParams = (ToTestData*)&launchInfo;

    //
    // cleanup old files
    //
    DeleteFile("T:\\testexit.txt");

    DWORD dwAddDevice, dwRemoveDevice;

    char *iniConfig = NULL;

    //
    // Grab the startup parameters
    //
    if( pInitialParams->titleID == HVSLAUNCHERID )
    {
        iniConfig = new char[strlen(pInitialParams->configSettings)+1];
        strcpy(iniConfig, pInitialParams->configSettings);
        ParseConfigSettings( pInitialParams->configSettings, &globalSettings, ParseTestConfig, &globalSettings );
    }
    else
    {
        FILE* pFile = fopen("D:\\memCheck.ini", "rb");
        if( NULL != pFile )
        {
            DWORD dwFilesize = _filelength( _fileno( pFile ) );
            iniConfig = new char[dwFilesize+1];
            if( 1 != fread( iniConfig, dwFilesize, 1, pFile ) ) DebugPrint( "Failed to read the starup params!!\r\n" );
            iniConfig[dwFilesize] = '\0';

            ParseConfigSettings( iniConfig, &globalSettings, ParseTestConfig, &globalSettings );
            if( 0 != fseek( pFile, 0, SEEK_SET ) ) DebugPrint( "Failed to seek properly!!\r\n" );
            if( 1 != fread( iniConfig, dwFilesize, 1, pFile ) ) DebugPrint( "Failed to read the starup params!!\r\n" );
            iniConfig[dwFilesize] = '\0';
            fclose( pFile );
        }
    }

    // Call SetSaveName BEFORE calling LogPrint or LogFlush
    SetSaveName( globalSettings.saveName, "memCheck.log" );
    LogFlush();

    Initialize();

    if( pInitialParams->titleID == HVSLAUNCHERID )
        LogPrint( "Launched from HVS\n  Test %u of %u\n\n", pInitialParams->testNumber, pInitialParams->totalTests );
    else
        LogPrint( "Running in stand a lone mode\n\n" );

    LogPrint("Memory Check (Built on " __DATE__ " at " __TIME__ ")\n");
    LogPrint("Copyright (C) Microsoft Corporation.  All rights reserved.\n\n");


    //
    // allocate buffer space
    //
    unsigned char *buff1 = (unsigned char*) VirtualAlloc( NULL,
                                                          globalSettings.dwBlockSize,
                                                          MEM_COMMIT,
                                                          PAGE_READWRITE );

    unsigned char *buff2 = (unsigned char*) VirtualAlloc( NULL,
                                                          globalSettings.dwBlockSize,
                                                          MEM_COMMIT,
                                                          PAGE_READWRITE );

    DebugPrint( "Buffer 1 Address: %0.8X - %0.8X\n", buff1, buff1 + globalSettings.dwBlockSize );
    DebugPrint( "Buffer 2 Address: %0.8X - %0.8X\n\n", buff2, buff2 + globalSettings.dwBlockSize );

    if( !buff1 || !buff2 )
    {
        DebugPrint("\n\n\nUnable to allocate enough buffer space (%u)\n", globalSettings.dwBlockSize * 2);
        DebugPrint("Rebooting...\n\n\n");
        if(pInitialParams->titleID == HVSLAUNCHERID)
        {
            ToLauncherData* outParams = (ToLauncherData*)&launchInfo;
            outParams->titleID = XeImageHeader()->Certificate->TitleID;
            outParams->numPass = 0;
            outParams->numFail = 0;
            sprintf(outParams->notes, "Unable to allocate enough space (%u).\n", globalSettings.dwBlockSize * 2);

            LaunchImage("D:\\default.xbe", &launchInfo);
        }
        else
        {
            XLaunchNewImage(NULL, NULL);
        }
        
        return;
    }

    //
    // Allocate the needed memory
    //
    UCHAR* pucAllMemory = NULL;
    MEMORYSTATUS memStatus;
    ZeroMemory( &memStatus, sizeof( memStatus ) );

    GlobalMemoryStatus( &memStatus );

    DebugPrint( "Length              - '%d'\r\n", memStatus.dwLength );
    DebugPrint( "Memory Load         - '%d'\r\n", memStatus.dwMemoryLoad );
    DebugPrint( "Total Physical      - '%d'\r\n", memStatus.dwTotalPhys );
    DebugPrint( "Available Physical  - '%d'\r\n", memStatus.dwAvailPhys );
    DebugPrint( "Total Page File     - '%d'\r\n", memStatus.dwTotalPageFile );
    DebugPrint( "Available Page File - '%d'\r\n", memStatus.dwAvailPageFile );
    DebugPrint( "Total Virtual       - '%d'\r\n", memStatus.dwTotalVirtual );
    DebugPrint( "Available Virtual   - '%d'\r\n", memStatus.dwAvailVirtual );

    pucAllMemory = (UCHAR*)MmMapIoSpace( 0, memStatus.dwTotalPhys, PAGE_READWRITE | PAGE_NOCACHE );
    if( NULL == pucAllMemory )
    {
        DebugPrint("\n\n\nUnable to allocate '%d' bytes of memory!!\n", memStatus.dwAvailPhys );
        DebugPrint("Rebooting...\n\n\n");

        if( pInitialParams->titleID == HVSLAUNCHERID )
        {
            ToLauncherData* outParams = (ToLauncherData*)&launchInfo;
            outParams->titleID = XeImageHeader()->Certificate->TitleID;
            outParams->numPass = 0;
            outParams->numFail = 0;
            outParams->notes[0] = '\0';
            sprintf(outParams->notes, "Unable to allocate '%d' bytes of memory\n", memStatus.dwAvailPhys );

            LaunchImage("D:\\default.xbe", &launchInfo);
        }
        else
        {
            XLaunchNewImage(NULL, NULL);
        }
    }

    DebugPrint( "\n\n\nAllocated (%u) bytes of memory\n", memStatus.dwTotalPhys );

    //
    // Check to see if the user wants to test all memory, or if they specified to much memory
    //
    if( ( 0 == globalSettings.dwEndBlock ) || ( globalSettings.dwEndBlock > memStatus.dwTotalPhys ) )
        globalSettings.dwEndBlock = memStatus.dwTotalPhys;

    //
    // run the test
    //
    unsigned int uiCurrentMemAddress = globalSettings.dwStartBlock;
    UCHAR* pucCurrentLocation = pucAllMemory + globalSettings.dwStartBlock;

    // LogPrint("    (uiCurrentMemAddress) -- %08X\n", &uiCurrentMemAddress );

    DebugPrint( "Pass Number: %u\n", dwTestPassNumber );

    BOOL bSkipBuff1 = FALSE;
    BOOL bSkipBuff2 = FALSE;
    BOOL bUpdateGraphics = TRUE;
    DWORD dwAdjustedBlockSize = 0;
    while( TRUE )
    {
        if( globalSettings.dwEnableUSB )
        {
            XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwAddDevice, &dwRemoveDevice );
            InputDukeInsertions( dwAddDevice, dwRemoveDevice );
            XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwAddDevice, &dwRemoveDevice );
            InputMUInsertions( dwAddDevice, dwRemoveDevice );
        }

        // Check to see if we should stop
        if( globalSettings.stopAfter.duration )
        {
            unsigned __int64 ui64ClockTick = ReadTSC() - ui64Time;

            if( ( globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && dwNumTimesThrough >= globalSettings.stopAfter.duration ) ||
                ( globalSettings.stopAfter.type == STOPAFTER_MINUTES    && ( ( ui64ClockTick / 733000000UI64 ) / 60 ) >= globalSettings.stopAfter.duration ) ||
                ( globalSettings.stopAfter.type == STOPAFTER_HOURS      && ( ( ( ui64ClockTick / 733000000UI64 ) / 60 ) / 60 ) >= globalSettings.stopAfter.duration ) )
            {
                break;
            }
        }

        // Update our graphics every n seconds
        unsigned __int64 ui64ClockTick = ReadTSC() - ui64Time;
        if( ( 0 == ( ui64ClockTick / 733000000UI64 ) % globalSettings.dwGraphicsUpdateInterval ) && globalSettings.dwEnableGraphics )
        {
            if( bUpdateGraphics )
            {
                bUpdateGraphics = FALSE;
                InitGraphics();
                UpdateGraphics( DISPLAYMODE_RUN_TIME );
                g_pDevice->PersistDisplay();
                DeInitGraphics();
            }
        }
        else
        {
            bUpdateGraphics = TRUE;
        }

        if( globalSettings.dwEnableUSB )
        {
            if( InputCheckDigitalButton(XINPUT_GAMEPAD_START) ) GUI();

            if( InputCheckExitCombo() )
            {
                break;
            }
        }

        // Check to see if we have read all the memory specified
        if( uiCurrentMemAddress >= globalSettings.dwEndBlock )
        {
            dwNumTimesThrough++;
            dwTestPassNumber++;
            if( globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && dwNumTimesThrough >= globalSettings.stopAfter.duration )
                dwTestPassNumber--;

            DebugPrint( "Pass Number: %u\n", dwTestPassNumber );

            //
            // Reset all of the parameters to start another loop
            //
            uiCurrentMemAddress = globalSettings.dwStartBlock;
            pucCurrentLocation = pucAllMemory + globalSettings.dwStartBlock;

            continue;
        }

        memset( buff1, 0, globalSettings.dwBlockSize );
        memset( buff2, 0, globalSettings.dwBlockSize );

        dwAdjustedBlockSize = globalSettings.dwBlockSize;

        //
        // Check to see if the memory read would read in to my buffers
        //
        if( ( ( pucCurrentLocation + dwAdjustedBlockSize ) >= buff1 ) &&
            ( ( pucCurrentLocation + dwAdjustedBlockSize ) < ( buff1 + dwAdjustedBlockSize ) ) )
        {
            bSkipBuff1 = TRUE;
            dwAdjustedBlockSize = buff1 - pucCurrentLocation;
        }
        else if( ( ( pucCurrentLocation + dwAdjustedBlockSize ) >= buff2 ) &&
                 ( ( pucCurrentLocation + dwAdjustedBlockSize ) < ( buff2 + dwAdjustedBlockSize ) ) )
        {
            bSkipBuff2 = TRUE;
            dwAdjustedBlockSize = buff2 - pucCurrentLocation;
        }

        //
        // Check to see if our memory read would extend past the end of our memory range
        //
        if( ( pucCurrentLocation + dwAdjustedBlockSize ) > ( pucAllMemory + globalSettings.dwEndBlock ) )
        {
            dwAdjustedBlockSize = ( pucAllMemory + globalSettings.dwEndBlock ) - pucCurrentLocation;
            DebugPrint( "Adjusted Block Size = %u\n", dwAdjustedBlockSize );
        }

        // Disable interrupts if necessary
        if( globalSettings.dwDisableInterrupts )
            __asm cli

        //
        // read from memory
        //
        memcpy( buff1, pucCurrentLocation, dwAdjustedBlockSize );
        memcpy( buff2, pucCurrentLocation, dwAdjustedBlockSize );

        /*
        // This will introduce errors so that we can verify the test is working as expected
        unsigned __int64 ui64ClockTick = ReadTSC() - ui64Time;
        if( 0 == ( ui64ClockTick / 733000000UI64 ) % 15 )
            buff2[418] = ~buff1[418];
        */

        //
        // Compare the buffers to make sure they match
        //
        if( !CompareBuff( buff1, buff2, dwAdjustedBlockSize ) )
        {
            LogPrint("    (Read) Mem Location -- %08X\n", pucCurrentLocation );
            // _asm { int 3 }
            // DebugPrint( "\n\nBuffers did not match!!\r\n" );
            // HexDump( buff1, dwAdjustedBlockSize );
            // HexDump( buff2, dwAdjustedBlockSize );
            dwNumFail++;
        }
        else
        {
            //
            // Check to see if the user wants to test writing
            //
            if( globalSettings.dwReadMode == 1 ) // 1 = read only, so we should log a pass
            {
                dwNumPass++;
            }
            else
            {
                //
                // Write back to the same memory
                //
                memcpy( pucCurrentLocation, buff1, dwAdjustedBlockSize );

                //
                // Re-read from the newly written memory
                //
                memcpy( buff1, pucCurrentLocation, dwAdjustedBlockSize );

                //
                // Compare the buffers again
                //
                if( !CompareBuff( buff1, buff2, dwAdjustedBlockSize ) )
                {
                    LogPrint("    (Write) Mem Location -- %08X\n", pucCurrentLocation );
                    // DebugPrint( "\n\nBuffers did not match!!\r\n" );
                    // HexDump( buff1, dwAdjustedBlockSize );
                    // HexDump( buff2, dwAdjustedBlockSize );
                    dwNumFail++;
                }
                else
                {
                    dwNumPass++;
                }
            }
        }

        // Enable interrupts if necessary
        if( globalSettings.dwDisableInterrupts )
            __asm sti


        // DebugPrint( "Current Loc - '0x%0.8X'\r\n", pucCurrentLocation );
        
        ui64NumBlocksRead++;
        if( ( bSkipBuff1 ) || ( bSkipBuff2 ) )
        {
            bSkipBuff1 = FALSE;
            bSkipBuff2 = FALSE;
            
            pucCurrentLocation += dwAdjustedBlockSize + globalSettings.dwBlockSize;
            uiCurrentMemAddress += dwAdjustedBlockSize + globalSettings.dwBlockSize;
        }
        else
        {
            pucCurrentLocation += dwAdjustedBlockSize;
            uiCurrentMemAddress += dwAdjustedBlockSize;
        }
    } // While

    if( globalSettings.dwEnableGraphics )
    {
        InitGraphics();
        UpdateGraphics( DISPLAYMODE_RUN_TIME );
        g_pDevice->PersistDisplay();
    }

    LogPrint( "\nNumber of failures - '%u'\n", dwNumFail );
    LogPrint( "Number of passes   - '%u'\n", dwNumPass );

    //
    // Post results if necessary
    //
    if( ( globalSettings.dwEnableNetwork ) && ( strncmp(globalSettings.resultsServer, "http://", 7) == 0 ) )
    {
        //
        // Initialize the Network
        //
        XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
        XNetStartup(&xnsp);

        //
        // Initialize USB if it hasn't been already
        //
        if( !globalSettings.dwEnableUSB )
            XInitDevices(0, NULL);


        WSADATA wsaData;
        DBDATA results;
        unsigned short version = MAKEWORD(2, 2);
        WSAStartup( version, &wsaData );

        results.deviceType = "Memory";
        char pszMemType[MAX_PATH+1];
        pszMemType[MAX_PATH] = '\0';
        _snprintf( pszMemType, MAX_PATH, "%ls", g_pwszMemType );
        results.manufacturer = RightTrim( pszMemType );
        results.firmwareVersion = "";
        results.hardwareVersion = "";
        results.serialNumber = "";
        results.testName = "Memory Check";

        char variation[256];
        results.boxInformation = GetBoxInformation();
        results.configSettings = iniConfig;
        results.variation = variation;

        sprintf( variation, "Block Size: %u, Read Mode: %u, Start Block: %u, End Block: %u", globalSettings.dwBlockSize, globalSettings.dwReadMode, globalSettings.dwStartBlock, globalSettings.dwEndBlock );

        // TODO: Different results for READ & READ/WRITE tests
        // failures (read/write errors)
        results.status = 0;
        results.numOperations = dwNumFail;
        results.notes = "Read/Write Errors";
        if( results.numOperations )
            PostResults( globalSettings.resultsServer, &results );

        // passes
        results.status = 1;
        results.numOperations = dwNumPass;
        results.notes = "Successful Reads/Writes";
        if( results.numOperations )
            PostResults( globalSettings.resultsServer, &results );

        // cleanup
        delete[] results.boxInformation;
    }

    // Cleanup
    if( iniConfig != NULL ) delete[] iniConfig;
    if( buff1 != NULL ) VirtualFree( buff1, 0, MEM_RELEASE);
    if( buff2 != NULL ) VirtualFree( buff2, 0, MEM_RELEASE);
    if( pucAllMemory != NULL ) MmUnmapIoSpace( pucAllMemory, memStatus.dwTotalPhys );

    if( globalSettings.dwEnableGraphics )
    {
        if( globalSettings.dwPauseOnExit )
            Pause();
        else
            g_pDevice->PersistDisplay();            // persist the display across the reboot
    }

    //
    // test done, reboot
    //
    if( pInitialParams->titleID == HVSLAUNCHERID )
    {
        ToLauncherData* outParams = (ToLauncherData*)&launchInfo;
        outParams->titleID = XeImageHeader()->Certificate->TitleID;
        outParams->numPass = dwNumPass;
        outParams->numFail = dwNumFail;
        outParams->notes[0] = '\0';

        LaunchImage("D:\\default.xbe", &launchInfo);
    }
    else
        XLaunchNewImage(NULL, NULL);
}

FORCEINLINE ULONG
REG_RD32(VOID* Ptr, ULONG Addr)
{
    return *((volatile DWORD*)((BYTE*)(Ptr) + (Addr)));
}

void Initialize( void )
{
    //
    // USB
    //
    if( globalSettings.dwEnableUSB )
        XInitDevices(0, NULL);

    //
    // Network
    //
    /*
    if( globalSettings.dwEnableNetwork )
    {
        XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
        XNetStartup(&xnsp);
    }
    */

    //
    // Graphics
    //
    /*
    if( globalSettings.dwEnableGraphics )
        InitGraphics();
    */

    //
    // Memory Type
    //
    #define NV_PEXTDEV_BOOT_0                   0x00101000 // private\windows\directx\dxg\d3d8\se\nv_ref_2a.h
    #define XPCICFG_GPU_MEMORY_REGISTER_BASE_0  0xFD000000 // private\ntos\inc\xpcicfg.h

    // Get the total amount of memory available
    MEMORYSTATUS memStatus;

    ZeroMemory( &memStatus, sizeof( memStatus ) );
    ZeroMemory( g_pwszMemType, sizeof( WCHAR ) * 50 );

    GlobalMemoryStatus( &memStatus );

    g_dwTotalMemory = memStatus.dwTotalPhys / ( 1024 * 1024 );  // In Megabytes

    if( ( REG_RD32( (void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PEXTDEV_BOOT_0 ) & 0x0000C0000 ) == 0 )
        _snwprintf( g_pwszMemType, 49, L"Micron" );
    else
        _snwprintf( g_pwszMemType, 49, L"Samsung" );

    // Update Log with possible failure info
    // Check to see if interrupts are disabled
    if( !globalSettings.dwDisableInterrupts )
        LogPrint( "Interrupts are enabled; failures are possible!!\n" );

    if( DmGetCurrentDmi() != NULL )
        LogPrint( "XBDM is enabled; failures are possible!!\n" );

    if( globalSettings.dwEnableUSB)
        LogPrint( "USB is enabled; failures are possible!!\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\readFile\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\memCheck\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    Helper functions

Notes:

*****************************************************************************/

#include "memCheck.h"

BOOL CompareBuff( unsigned char *buff1, unsigned char *buff2, unsigned length )
{
    BOOL bReturn = TRUE;

    for(unsigned i=0; i<length; i++)
    {
        if(buff1[i] != buff2[i])
        {
            // LogPrint("    %u: %02X %02X\n", i, buff1[i], buff2[i] );
            bReturn = FALSE;
            break;
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\readFile\readFile.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    readFile.h

Abstract:

    File System disk scanner.

*****************************************************************************/

#ifndef _READFILE_H_
#define _READFILE_H_

#ifdef _VC
//#define DEVICE_TYPE ULONG
#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500
#endif

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>

#include <xtl.h>
#include <stdio.h>

#include "../utils/hvsUtils.h"
#include "bitfont.h"

#define CLEARFLAG(var, flag)    (var &= ~(flag))
#define SETFLAG(var, flag)      (var |=  (flag))

//
// Initialization calls
//
void Initialize(void);
HRESULT InitGraphics(void);

//
// User input
// 
void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);
bool InputCheckButton(int button);
bool InputCheckDigitalButton(int button);
void Pause(void);


//
// Graphics / GUI methods
//
enum DISPLAY_MODE
    {
    DISPLAYMODE_PAUSE,
    DISPLAYMODE_RUN_TIME,
    DISPLAYMODE_CONFIG_READONLY,
    DISPLAYMODE_CONFIG_INTERACTIVE
    };
void UpdateGraphics(unsigned mode = DISPLAYMODE_RUN_TIME);
void GUI(void);
void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...);


//
// Utility functions
//
void CompareBuff(unsigned char *buff1, unsigned char *buff2, unsigned char *buff3, unsigned length);
DWORD MapDrive( char cDriveLetter, char* pszPartition );
DWORD UnMapDrive( char cDriveLetter );


typedef bool (*PARSE_FUNC)(char *path, WIN32_FIND_DATA &data);
bool ParseFiles(char *path, PARSE_FUNC funct);



//
// User input
//
extern HANDLE hDuke[XGetPortCount()];
extern HANDLE hSlot[XGetPortCount()*2];
static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };

enum MEDIA_TYPES
	{
	MEDIA_UNKNOWN,
	MEDIA_CDDA,
	MEDIA_CDROM,
	MEDIA_DVD_5_RO,
	MEDIA_DVD_5_RW,
	MEDIA_DVD_9_RO,
	MEDIA_DVD_9_RW,
	MEDIA_HD,
    MEDIA_MU
	};

static const char *mediaTypeNames[] = 
    {
    "Unknown",
    "CD DA",
    "CD ROM",
    "DVD 5 RO",
    "DVD 5 RW",
    "DVD 9 RO",
    "DVD 9 RW",
    "Hard Disk",
    "MU"
    };

//
// config settings
//
struct ConfigSettings : public CoreConfigSettings
    {
    char drive[128];
    DWORD compareBuffers;
    DWORD numberOfReads;
    DWORD pauseOnMismatch;
    DWORD pauseOnExit;
    DWORD readSize;
    DWORD dir;

    ConfigSettings()
        {
        strcpy(drive, "A:");
        compareBuffers = 0;
        numberOfReads = 2;
        pauseOnMismatch = 0;
        pauseOnExit = 0;
        readSize = 1024;
        dir = 0;

        stopAfter.type = STOPAFTER_ITERATIONS;
        stopAfter.duration = 1;
        }
    };

extern ConfigSettings globalSettings;


//
// stats
//
extern DWORD numFail;
extern DWORD numPass;
extern DWORD numBuffMisMatch;
extern DWORD numTimesThrough;
extern unsigned __int64 numFiles;
extern unsigned __int64 numFilesRead;
extern DWORD time;
extern char model[64], serial[64], firmware[64];
extern WIN32_FIND_DATA findData;
extern double percentDone;
extern DWORD mediaType;
extern DWORD addDevice, removeDevice;


//
// graphics
//
extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;


void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
DWORD GetDiskType(HANDLE hDevice);


//
// Low level IOCTL stuff
//
/*
#define CTL_CODE(DeviceType, Function, Method, Access) ( \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) )

#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_CONTROLLER          0x00000004

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

#define FILE_ANY_ACCESS                 0

#define IOCTL_DVD_BASE                  FILE_DEVICE_DVD
#define IOCTL_DVD_START_SESSION         CTL_CODE(IOCTL_DVD_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_READ_KEY              CTL_CODE(IOCTL_DVD_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY              CTL_CODE(IOCTL_DVD_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_END_SESSION           CTL_CODE(IOCTL_DVD_BASE, 0x0403, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SET_READ_AHEAD        CTL_CODE(IOCTL_DVD_BASE, 0x0404, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_GET_REGION            CTL_CODE(IOCTL_DVD_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY2             CTL_CODE(IOCTL_DVD_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DVD_READ_STRUCTURE        CTL_CODE(IOCTL_DVD_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_BASE                FILE_DEVICE_CD_ROM
#define IOCTL_CDROM_GET_DRIVE_GEOMETRY  CTL_CODE(IOCTL_CDROM_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SET_SPINDLE_SPEED   CTL_CODE(IOCTL_CDROM_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_CHECK_VERIFY        CTL_CODE(IOCTL_CDROM_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
//#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define CDAUDIO_BYTES_PER_FRAME         2352
#define CDAUDIO_BYTES_PER_SECOND        176400
#define CDAUDIO_BYTES_PER_MINUTE        10584000
#define CDAUDIO_FRAMES_PER_SECOND       75
#define CDAUDIO_FRAMES_PER_MINUTE       4500
#define CDAUDIO_SECTOR_OFFSET           150

// from private\ntos\idex\idex.h:
#define IDE_ATAPI_RAW_CD_SECTOR_SIZE            2352
#define IDE_ATAPI_CD_SECTOR_SHIFT               11
*/


#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#endif //_READFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\readFile\diskUtils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    diskUtils.cpp

Abstract:

    Functions that talk to the DVD drive

Notes:
    dvd player code:
        "\xboxsrc\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp"
    filesystem retry code:
        "\xboxsrc\private\ntos\idex\cdrom.c" (IdexCdRomFinishRequestSense)
    sense data format:
        "\xboxsrc\public\ddk\inc\scsi.h"


    DVD-X2 Supported Error Sense Codes
        Sense   Sense   Sense   Description
        Key	    Code    Code Qu
        ----------------------------------------------------------------------
        0x00	0x00	0x00	No Additional Sense information (= no error)
        0x01	0x80	0x00	Cache fill error, speed reduction requested
        0x02	0x04	0x00	Logical Unit not ready, cause not reported
        0x02	0x04	0x01	Logical Unit is in process of becoming ready
        0x02	0x30	0x00	Incompatible medium installed
        0x02	0x3A	0x00	Medium not present
        0x03	0x57	0x00	Unable to recover Table of Contents
        0x03	0x80	0x00	Read Error
        0x04	0x00	0x00	Hardware error
        0x04	0x08	0x03	Logical Unit Communication CRC Error - UDMA33
        0x05	0x21	0x00	Logical Block Address Out of Range
        0x05	0x55	0x00	System Resource Failure
        0x05	0x64	0x00	Illegal mode for this track
        0x05	0x6F	0x00	Authentication Failure - CSS
        0x05	0x80	0x00	Authentication Failure - Xbox
        0x05	0x81	0x00	Command error
        0x06	0x29	0x00	Power On, Reset or Bus Device Reset occurred
        0x06	0x2A	0x01	Mode Parameters changed
        0x06	0x2E	0x00	Insufficient time for operation

    Win32 Error code mapping:
        1/80:   ERROR_CRC                   23
        2/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        2/other ERROR_NOT_READY             21
        3/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        3/other ERROR_CRC                   23
        5/21:   ERROR_SECTOR_NOT_FOUND      27
        5/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        5/6F:   ERROR_TOO_MANY_SECRETS      1381
        5/80:   ERROR_TOO_MANY_SECRETS      1381
        other:  ERROR_IO_DEVICE             1117

    IOCTL_CDROM_SET_SPINDLE_SPEED
        speed 2     ~3000rpm      2x -    5x
        speed 1     ~2000rpm    4/3x - 10/3x
        speed 0     ~1000rpm    2/3x -  5/3x

*****************************************************************************/

#include "readFile.h"

/*
APIs in this file:

    void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
    bool CDTestReady(HANDLE hDevice);
    DWORD GetDiskType(HANDLE hDevice);

*/







void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware)
    {
    unsigned i;
    DWORD returned;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;
    bool closeHandle = false;

    if(hDevice == NULL)
        {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        if(cdrom)
            RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        else
            RtlInitObjectString(&VolumeString, "\\Device\\Harddisk0\\Partition0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
        }

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(cdrom) atapt->IdeReg.bCommandReg = 0xA1;
    else atapt->IdeReg.bCommandReg = 0xEC;

    DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH, atapt, sizeof(ATA_PASS_THROUGH), atapt, sizeof(ATA_PASS_THROUGH), &returned, FALSE);
    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for(i=0; i<sizeof(IdData->ModelNumber); i+=2)
        {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
        }
    model[i] = 0;

    for(i=0; i<sizeof(IdData->SerialNumber); i+=2)
        {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
        }
    serial[i] = 0;

    for(i=0; i<sizeof(IdData->FirmwareRevision); i+=2)
        {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
        }
    firmware[i] = 0;

    if(closeHandle) NtClose(hDevice);
    }


bool CDTestReady(HANDLE hDevice)
    {
    DWORD cbReturned;

    BOOL fReturn = DeviceIoControl(hDevice, IOCTL_CDROM_CHECK_VERIFY, NULL, 0, NULL, 0, &cbReturned, NULL);

    if(fReturn || (GetLastError() == ERROR_UNRECOGNIZED_MEDIA))
        {
        return false;
        }
    
    return true;
    }


DWORD GetDiskType(HANDLE hDevice)
    {
    DVD_READ_STRUCTURE readStruct;
    UCHAR readStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) + sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];

    bool closeHandle = false;

    if(hDevice == NULL)
        {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
        }

    memset(&readStruct, 0, sizeof(DVD_READ_STRUCTURE));
    memset(readStructureOutput, 0, sizeof(readStructureOutput));

    // try DVD Read Structure
    readStruct.Format = DvdPhysicalDescriptor;

    DWORD returned = 0;
    BOOL result = DeviceIoControl(hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(DVD_READ_STRUCTURE), readStructureOutput, sizeof(readStructureOutput), &returned, NULL);
    if(result)
        {
        if(closeHandle) NtClose(hDevice);
        DVD_LAYER_DESCRIPTOR *layerDescr = (DVD_LAYER_DESCRIPTOR *)(&readStructureOutput[sizeof(DVD_DESCRIPTOR_HEADER)]);
        BYTE layerType = (layerDescr->BookType) | (layerDescr->BookVersion << 4);
        if(layerDescr->LayerType == 1)
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RO;
            else return MEDIA_DVD_9_RO;
            }
        else
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RW;
            else return MEDIA_DVD_9_RW;
            }
        }

    // not a DVD disk...
    else
        {
	    CDROM_TOC toc;
        memset(&toc, 0, sizeof(CDROM_TOC));
		result = DeviceIoControl( hDevice, IOCTL_CDROM_READ_TOC, &toc, sizeof(CDROM_TOC), &toc, sizeof(CDROM_TOC), &returned, NULL);
        if(closeHandle) NtClose(hDevice);
        if(result)
            {
            if(toc.FirstTrack == toc.LastTrack) return MEDIA_CDROM;
            return MEDIA_CDDA;
            }
        else
            {
            return MEDIA_CDROM;
            }
        }

    return MEDIA_UNKNOWN;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\readFile\readFile.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    readFile.cpp

Abstract:

    File System disk scanner.

Notes:

  
*****************************************************************************/

#include "readFile.h"
#include <xbeimage.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[XGetPortCount()*2] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
DWORD addDevice, removeDevice;

bool GetNumFiles(char *path, WIN32_FIND_DATA &data);
bool ReadFiles(char *path, WIN32_FIND_DATA &data);


//
// config settings
//
ConfigSettings globalSettings;

//
// stats
//
DWORD numFail = 0;
DWORD numPass = 0;
DWORD numBuffMisMatch = 0;
DWORD numTimesThrough = 1;
unsigned __int64 numFiles = 0;
unsigned __int64 numFilesRead = 0;
DWORD time = 0;
char model[64], serial[64], firmware[64];
WIN32_FIND_DATA findData;
double percentDone = 0; // read % of a single file
DWORD mediaType = MEDIA_UNKNOWN;

unsigned char *buff1;
unsigned char *buff2;
unsigned char *buff3;



void ParseTestConfig(char *variable, char *value, void *userParam)
    {
    ConfigSettings *settings = (ConfigSettings*)userParam;

    if(strstr(variable, "drive") != NULL) strcpy(settings->drive, value);
    else if(strstr(variable, "readsize") != NULL) settings->readSize = GetNumber(value);
    else if(strstr(variable, "comparebuffers") != NULL) settings->compareBuffers = atol(value);
    else if(strstr(variable, "pauseonexit") != NULL) settings->pauseOnExit = GetNumber(value);
    else if(strstr(variable, "numberofreads") != NULL) settings->numberOfReads = GetNumber(value);
    else if(strstr(variable, "pauseonmismatch") != NULL) settings->pauseOnMismatch = atol(value);
    else if(strstr(variable, "dir") != NULL) settings->dir = atol(value);
    }

#pragma warning(disable : 4326) // return type of 'main' should be 'int or void' instead of 'ShutDown'
struct ShutDown
    {
    ShutDown(LAUNCH_DATA &launchInfo, unsigned __int64 pass, unsigned __int64 fail, char *format, ...)
        {
        ToLauncherData* outParams = (ToLauncherData*)&launchInfo;
        ToTestData* initialParams = (ToTestData*)&launchInfo;

        if(initialParams->titleID == HVSLAUNCHERID)
            {
            outParams->titleID = XeImageHeader()->Certificate->TitleID;
            outParams->numPass = pass;
            outParams->numFail = fail;
            va_list args;
            va_start(args, format);
            vsprintf(outParams->notes, format, args);
            va_end(args);

            LaunchImage("D:\\default.xbe", &launchInfo);
            }
        else
            XLaunchNewImage(NULL, NULL);
        }
    };


ShutDown _cdecl main(void)
    {
    bool exit = false;
    DBDATA results;

    //
    // Get the launch data (if any)
    //
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    XGetLaunchInfo(&dataType, &launchInfo);
    ToTestData* initialParams = (ToTestData*)&launchInfo;

    Initialize();

    //
    // cleanup old files
    //
    DeleteFile("T:\\testexit.txt");

    char *iniConfig = NULL;



    //
    // Grab the startup parameters
    //
    if(initialParams->titleID == HVSLAUNCHERID)
        {
        iniConfig = new char[strlen(initialParams->configSettings)+1];
        strcpy(iniConfig, initialParams->configSettings);
        ParseConfigSettings(initialParams->configSettings, &globalSettings, ParseTestConfig, &globalSettings);
        }
    else
        {
        FILE *file = fopen("D:\\readFile.ini", "rb");
        if(file)
            {
            DWORD filesize = _filelength(_fileno(file));
            iniConfig = new char[filesize+1];
            unsigned bytesRead = fread(iniConfig, 1, filesize, file);
            iniConfig[bytesRead] = '\0';

            ParseConfigSettings(iniConfig, &globalSettings, ParseTestConfig, &globalSettings);
            if(fseek(file, 0, SEEK_SET) == 0)
                {
                bytesRead = fread(iniConfig, 1, filesize, file);
                iniConfig[bytesRead] = '\0';
                }
            fclose(file);
            }
        }


    // Call SetSaveName BEFORE calling LogPrint or LogFlush
    SetSaveName(globalSettings.saveName, "readFile.log");
    LogFlush();

    if(initialParams->titleID == HVSLAUNCHERID)
        LogPrint("Launched from HVS\n  Test %u of %u\n\n", initialParams->testNumber, initialParams->totalTests);
    else
        LogPrint("Running in stand a lone mode\n\n");

    LogPrint("Read File (Built on " __DATE__ " at " __TIME__ ")\n");
    LogPrint("Copyright (C) Microsoft Corporation.  All rights reserved.\n\n");


    memset(model, 0, 64);
    memset(serial, 0, 64);
    memset(firmware, 0, 64);

    char driveLetter = CLEARFLAG(globalSettings.drive[0], 0x20); // make it caps

    if(driveLetter == 'D') // can be either DVD or HD
        {
        ULARGE_INTEGER avail, total, free;
        GetDiskFreeSpaceEx("D:\\", &avail, &total, &free);
        if(free.QuadPart != 0) driveLetter = 'C'; // D points to hard disk
        }
    else if(driveLetter == 'A') // DVD
        driveLetter = 'D';

    if(driveLetter >= 'F' && driveLetter <= 'M') // MU
        {
        Sleep(2000); // let the mus get mounted

        strcpy(model, "MU");
        results.deviceType = "MU";
        mediaType = MEDIA_MU;
        }
    else if(driveLetter == 'D') // CD/DVD
        {
        results.deviceType = "DVD";
        GetDriveID(NULL, true, model, serial, firmware);
        mediaType = GetDiskType(NULL);
        }

    // hard disk
    else if(driveLetter == 'C')
        {
        results.deviceType = "Hard Drive";
        GetDriveID(NULL, false, model, serial, firmware);
        mediaType = MEDIA_HD;
        MapDrive('C', "\\Device\\Harddisk0\\Partition1");
        }
    else if(driveLetter == 'Y')
        {
        results.deviceType = "Hard Drive";
        GetDriveID(NULL, false, model, serial, firmware);
        mediaType = MEDIA_HD;
        MapDrive('Y', "\\Device\\Harddisk0\\Partition2");
        }
    else
        {
        results.deviceType = "Hard Drive";
        GetDriveID(NULL, false, model, serial, firmware);
        mediaType = MEDIA_HD;
        }


    //
    // print out the drive info and config settings
    //
	LogPrint("DRIVE: Model:             %s\n", model);
	LogPrint("DRIVE: Serial:            %s\n", serial);
	LogPrint("DRIVE: Firmware:          %s\n", firmware);
    LogPrint("MEDIA: Type:              %s\n", mediaTypeNames[mediaType]);

    LogPrint("Config Settings:\n");
    LogPrint("  ResultsServer:    %s\n", globalSettings.resultsServer);
    LogPrint("  SaveName:         %s\n", globalSettings.saveName);
    LogPrint("  StopAfter:        %u %s\n", globalSettings.stopAfter.duration, globalSettings.stopAfter.type==STOPAFTER_MINUTES?"min":(globalSettings.stopAfter.type==STOPAFTER_HOURS?"hours":"iterations"));
	LogPrint("\n");
    LogPrint("  Drive:            %s\n", globalSettings.drive);
    LogPrint("  ReadSize:         %u\n", globalSettings.readSize);
    LogPrint("  CompareBuffers:   %u\n", globalSettings.compareBuffers);
    LogPrint("  PauseOnExit:      %u\n", globalSettings.pauseOnExit);
    LogPrint("  PauseOnMismatch:  %u\n", globalSettings.pauseOnMismatch);
    LogPrint("  NumberOfReads:    %u\n", globalSettings.numberOfReads);
    LogPrint("  Dir:              %u\n", globalSettings.dir);
    LogPrint("\n");

    buff1 = new unsigned char[globalSettings.readSize];
    buff2 = new unsigned char[globalSettings.readSize];
    buff3 = new unsigned char[globalSettings.readSize];
    char *path = new char[MEGABYTE];
    if(!buff1 || !buff2 || !buff3 || !path)
        {
        LogPrint("Unable to allocate enough space (%u)\n", (globalSettings.readSize * 3) + MEGABYTE);
        DebugPrint("\n\n\nUnable to allocate enough space (%u)\n", (globalSettings.readSize * 3) + MEGABYTE);
        DebugPrint("Try lowering readSize\n");
        DebugPrint("Rebooting...\n\n\n");
        return ShutDown(launchInfo, 0, 0, "Unable to allocate enough space (%u).\\nTry lowering readSize", (globalSettings.readSize * 3) + MEGABYTE);
        }

    strcpy(path, globalSettings.drive);

    // Get the total number of files
    ParseFiles(path, GetNumFiles);
    LogPrint("Total Number of Files: %I64u\n", numFiles);
    if(numFiles == 0) exit = true;


    time = GetTickCount();
    // Run the test
    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
        UpdateGraphics(DISPLAYMODE_RUN_TIME);

        exit = ParseFiles(path, ReadFiles);

        ++numTimesThrough;

        if(globalSettings.stopAfter.type == STOPAFTER_ITERATIONS)
            if(numTimesThrough > globalSettings.stopAfter.duration) exit = true;
        }

    //
    // dump the stats
    //
    DWORD finalTime = (GetTickCount() - time)/1000;
    DWORD totalErrors = numFail + numBuffMisMatch;

    LogPrint("****Program Stats:\n");
    LogPrint("*** %9u sec run time\n", finalTime);
    LogPrint("*** %9I64u Total files read\n", numFilesRead);
    LogPrint("****\n");
    if(globalSettings.compareBuffers == 1)
        LogPrint("*** %9u Buffer mismatches\n", numBuffMisMatch);
    LogPrint("*** %9u Failures\n", numFail);
    LogPrint("*** %9u Total Reported Errors\n", totalErrors);
    LogPrint("****\n");
    LogPrint("*** %9u errors / file\n", numFilesRead? totalErrors / numFilesRead : 0);
    LogPrint("*** %9u errors / sec\n", finalTime? totalErrors / finalTime : 0);

    //
    // Post results if necessary
    //
    if(strncmp(globalSettings.resultsServer, "http://", 7) == 0)
        {
        WSADATA wsaData;
        unsigned short version = MAKEWORD(2, 2);
        WSAStartup(version, &wsaData);

        results.manufacturer = RightTrim(model);
        results.firmwareVersion = RightTrim(firmware);
        results.hardwareVersion = "";
        results.serialNumber = RightTrim(serial);
        results.testName = "Read File";

        char variation[256];
        char *v = variation;
        sprintf(variation, "Drive %s", globalSettings.drive);
        results.variation = variation;
        results.boxInformation = GetBoxInformation();
        results.configSettings = iniConfig;

        // passes
        results.status = 1;
        results.numOperations = numPass;
        results.notes = "Successful Reads";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // failures (read errors)
        results.status = 0;
        results.numOperations = numFail;
        results.notes = "Read Errors";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // failures (buffer mismatches)
        results.status = 0;
        results.numOperations = numBuffMisMatch;
        results.notes = "Buffer Mismatches";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // cleanup
        delete[] results.boxInformation;
        }

    delete[] iniConfig;
    delete[] path;
    delete[] buff1;
    delete[] buff2;
    delete[] buff3;

    if(driveLetter == 'C')
        UnMapDrive('C');
    else if(driveLetter == 'Y')
        UnMapDrive('Y');

    if(globalSettings.pauseOnExit)
        {
        Pause();
        }
    else
        {
        // persist the display across the reboot
        g_pDevice->PersistDisplay();
        }

    //
    // test done, reboot
    //
    return ShutDown(launchInfo, numPass, totalErrors, "\0");
    }


bool GetNumFiles(char *path, WIN32_FIND_DATA &data)
    {
    if(globalSettings.dir) LogPrint("%8u %s\n", data.nFileSizeLow, path);
    ++numFiles;

    return false;
    }


bool ReadFiles(char *path, WIN32_FIND_DATA &data)
    {
    //LogPrint("%s\n", path);
    bool exit = false;

    FILE *file = fopen(path, "rb");
    if(!file)
        {
        LogPrint("Open Error %u: %s\n", GetLastError(), path);
        ++numFail;
        return false;
        }

    DWORD chunkSize = globalSettings.readSize;
    //DWORD fileLen = _filelength(_fileno(file));
    DWORD fileLen = data.nFileSizeLow;
    DWORD offset = 0;

    if(chunkSize > fileLen) chunkSize = fileLen;


    while(!exit)
        {
        percentDone = fileLen ? (double)offset / (double)fileLen * 100.00 : 100.00;
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
        UpdateGraphics(DISPLAYMODE_RUN_TIME);

        //fseek(file, offset, SEEK_SET);
        if(fread(buff1, 1, chunkSize, file) != chunkSize)
            {
            LogPrint("Read Error %u: %s\n", GetLastError(), path);
            ++numFail;
            break;
            }

        if(globalSettings.numberOfReads == 2)
            {
            if(fseek(file, offset, SEEK_SET) != 0) LogPrint("Warning Seek Failed (ec %u) %s\n", GetLastError(), path);
            if(fread(buff2, 1, chunkSize, file) != chunkSize)
                {
                LogPrint("Read Error %u: %s\n", GetLastError(), path);
                ++numFail;
                break;
                }
            if(memcmp(buff1, buff2, chunkSize) != 0)
                {
                LogPrint("Read Error Buff Mismatch: %s\n", path);
                ++numBuffMisMatch;

                if(globalSettings.compareBuffers)
                    {
                    int retry = 3;
                    do {
                        // do another read for reference
                        if(fseek(file, offset, SEEK_SET) != 0) LogPrint("Warning Seek Failed (ec %u) %s\n", GetLastError(), path);
                        if(fread(buff3, 1, chunkSize, file) == chunkSize) break;
                        retry--;
                        } while(retry >= 0);
                    CompareBuff(buff1, buff2, buff3, chunkSize);
                    }

                break;
                }
            }

        offset += chunkSize;
        if(offset >= fileLen)
            {
            ++numPass;
            break; // done reading the file
            }

        if(offset + chunkSize >= fileLen)
            chunkSize = fileLen - offset;

        if(InputCheckDigitalButton(XINPUT_GAMEPAD_START)) GUI();
        if(InputCheckExitCombo())
            {
            exit = true;
            break;
            }
        if(globalSettings.stopAfter.duration)
            {
            if((globalSettings.stopAfter.type == STOPAFTER_MINUTES && TICK2MIN(GetTickCount() - time) >= globalSettings.stopAfter.duration) ||
                (globalSettings.stopAfter.type == STOPAFTER_HOURS && TICK2HOUR(GetTickCount() - time) >= globalSettings.stopAfter.duration) )
                {
                exit = true;
                break;
                }
            }
        }

    percentDone = 0.0;
    ++numFilesRead;
    fclose(file);

    return exit;
    }


void Initialize(void)
    {
    //
    // USB
    //
    XInitDevices(0, NULL);

    //
    // Network
    //
    XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    XNetStartup(&xnsp);

    //
    //
    //
    InitGraphics();
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\reboot\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct TVertex
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
    float u, v;         // Texture coordinates
};

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\readFile\gui.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    gui.cpp

Abstract:

    File System disk scanner.

Notes:

*****************************************************************************/
#include "readFile.h"

IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText	= NULL;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;

#define STICK_DEAD_ZONE         6400
#define BUTTON_PRESS_VALUE      100
#define BUTTON_SPEEP_VALUE      150         // in ms

#define COLUMN_1_OFFSET         25
#define COLUMN_2_OFFSET         165

void GUI(void)
    {
    bool exit = false;
    XINPUT_STATE state;

    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        for(unsigned port=0; port<XGetPortCount(); port++)
            {
            if(hDuke[port])
                {
                XInputGetState(hDuke[port], &state);
                if(state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) exit = true;
                }
            }

        UpdateGraphics(DISPLAYMODE_CONFIG_READONLY);

        Sleep(BUTTON_SPEEP_VALUE);
        }

    // sleep past any residual user input presses
    Sleep(BUTTON_SPEEP_VALUE);
    }

void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...)
    {
    char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, x, (line+1)*10, 0, color, 0);
    }


void UpdateGraphics(unsigned mode /*=DISPLAYMODE_RUN_TIME*/)
    {
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // run time status mode
    //
    if(mode == DISPLAYMODE_RUN_TIME || mode == DISPLAYMODE_PAUSE)
        {
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 1, 0xFF4444FF, "FILE READ");
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 2, 0xFF4444FF, "Model: %s", model);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 3, 0xFF4444FF, "Serial: %s", serial);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 4, 0xFF4444FF, "Firmware: %s", firmware);
        
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 5, 0xFF4444FF, "Media: %s", mediaTypeNames[mediaType]);

        unsigned line = 6;
        GraphicPrint(pd3ds, COLUMN_1_OFFSET, line, 0xFFFFFFFF, "Files Read: %I64u (%I64u on disk)", numFilesRead, numFiles);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, " Run Time: %u sec", (GetTickCount() - time)/1000);

        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Current File: %s", findData.cFileName);
        if(findData.nFileSizeLow >= 30000)
            GraphicPrint(pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, " (%.02lf %%)", percentDone);

        if(globalSettings.stopAfter.duration != 0 && globalSettings.stopAfter.type == STOPAFTER_ITERATIONS)
            GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u of %u", numTimesThrough, globalSettings.stopAfter.duration);
        else
            GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Pass %u", numTimesThrough);


        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Buffer Mismatches: %u", numBuffMisMatch);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET,   line, 0xFFFFFFFF, " Failures: %u", numFail);


        if(mode == DISPLAYMODE_RUN_TIME)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFFFF,  "Press START to view the current settings");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press Left Trigger + Right Trigger + Black to reboot");
            }
        else if(mode == DISPLAYMODE_PAUSE)
            {
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  19, 0xFFFFFF00,  "PAUSED");
	        GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFF00,  "Press BACK to continue");
            }
        }

    //
    // config setup gui
    //
    else if(mode == DISPLAYMODE_CONFIG_READONLY)
        {
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 1, 0xFF777777,  "Drive: %s", globalSettings.drive);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 2, 0xFF777777,  "Read Size: %u bytes", globalSettings.readSize);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 1, 0xFF777777,  " Number of Reads: %u", globalSettings.numberOfReads);
	    GraphicPrint(pd3ds, COLUMN_2_OFFSET, 2, 0xFF777777,  " Compare Buffers: %u", globalSettings.compareBuffers);

	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press BACK to continue");
        }

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    }



bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                {
                LogPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    // check for exit file
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile("T:\\testexit.txt", &FindFileData);
    FindClose(hFind);
    if(hFind != INVALID_HANDLE_VALUE)
        {
        LogPrint("\r\n\r\nFound Exit File (testexit.txt) - rebooting\r\n");
        return true;
        }

    return false;
    }


bool InputCheckButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE)
                {
                return true;
                }
            }
        }

    return false;
    }


bool InputCheckDigitalButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.wButtons & button)
                {
                return true;
                }
            }
        }

    return false;
    }


void Pause(void)
    {
    OutputDebugStringA("*****************************************************************************\n");
    OutputDebugStringA("* Entered Paused State. Hit the BACK button to resume...\n");
    OutputDebugStringA("*****************************************************************************\n");
    while(!InputCheckDigitalButton(XINPUT_GAMEPAD_BACK))
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        UpdateGraphics(DISPLAYMODE_PAUSE);

        Sleep(BUTTON_SPEEP_VALUE);
        }
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            //LogPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }


void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned i=0; i<XGetPortCount()*2; i++)
        {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[i]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[i]), XMUSlotFromDriveLetter((char)hSlot[i]));
            hSlot[i] = NULL;
            }
        if(add & USBSlotMasks[i])
            {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
                {
                hSlot[i] = (HANDLE)drive;
                //LogPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[i])+1, XMUSlotFromDriveLetter((char)hSlot[i])+1);
                }
            }
        }
    }


/*

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT InitGraphics(void)
    {
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\reboot\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\readFile\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    Helper functions

Notes:

*****************************************************************************/

#include "readFile.h"

void CompareBuff(unsigned char *buff1, unsigned char *buff2, unsigned char *buff3, unsigned length)
    {
    for(unsigned i=0; i<length; i++)
        {
        if(buff1[i] != buff2[i])
            {
            LogPrint("    %08X: %02X %02X %02X\n", i, buff1[i], buff2[i], buff3[i]);
            }
        }
    }


bool ParseFiles(char *path, PARSE_FUNC funct)
    {
    bool exit = false;
    HANDLE h;
    DWORD err;
    char *pathEnd;
    
    pathEnd = path + strlen(path);
    strcpy(pathEnd, "\\*.*");

    h = FindFirstFile(path, &findData);
    if(h == INVALID_HANDLE_VALUE)
        {
        err = GetLastError();
        if(err != ERROR_NO_MORE_FILES && err != ERROR_FILE_NOT_FOUND && err!=0)
            {
            LogPrint("Find Error %u: %s\n", err, path);
            ++numFail;
            }
        *pathEnd = '\0';

        if(InputCheckExitCombo())
            {
            exit = true;
            }
        if(globalSettings.stopAfter.duration)
            {
            if((globalSettings.stopAfter.type == STOPAFTER_MINUTES && TICK2MIN(GetTickCount() - time) >= globalSettings.stopAfter.duration) ||
                (globalSettings.stopAfter.type == STOPAFTER_HOURS && TICK2HOUR(GetTickCount() - time) >= globalSettings.stopAfter.duration) )
                {
                exit = true;
                }
            }

        return exit;
        }

    do
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);
        UpdateGraphics(DISPLAYMODE_RUN_TIME);

        strcpy(pathEnd+1, findData.cFileName);
        if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
            exit = ParseFiles(path, funct);
            if(exit == true)
                {
                SetLastError(0);
                break;
                }
            }
        else
            {
            exit = funct(path, findData);
            if(exit == true)
                {
                SetLastError(0);
                break;
                }
            }

        if(InputCheckDigitalButton(XINPUT_GAMEPAD_START)) GUI();
        if(InputCheckExitCombo())
            {
            exit = true;
            SetLastError(0);
            break;
            }
        if(globalSettings.stopAfter.duration)
            {
            if((globalSettings.stopAfter.type == STOPAFTER_MINUTES && TICK2MIN(GetTickCount() - time) >= globalSettings.stopAfter.duration) ||
                (globalSettings.stopAfter.type == STOPAFTER_HOURS && TICK2HOUR(GetTickCount() - time) >= globalSettings.stopAfter.duration) )
                {
                exit = true;
                SetLastError(0);
                break;
                }
            }
        } while(FindNextFile(h, &findData));

    err = GetLastError();
    if(err != ERROR_NO_MORE_FILES && err != ERROR_FILE_NOT_FOUND && err!=0)
        {
        LogPrint("Find Error %u: %s\n", err, path);
        ++numFail;
        }

    FindClose(h);
    *pathEnd = '\0';
    return exit;
    }


extern "C"
    {
	NTSYSCALLAPI
	NTSTATUS
	NTAPI
	IoCreateSymbolicLink(
		IN POBJECT_STRING SymbolicLinkName,
		IN POBJECT_STRING DeviceName
		);

	NTSYSCALLAPI
	NTSTATUS
	NTAPI
	IoDeleteSymbolicLink(
		IN POBJECT_STRING SymbolicLinkName
		);
    }


DWORD MapDrive( char cDriveLetter, char* pszPartition )
    {
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );

    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );

    ANSI_STRING ostDrive, ostPath;

    RtlInitObjectString( &ostDrive, pszDrive );
    RtlInitObjectString( &ostPath, pszPartition );
    NTSTATUS status = IoCreateSymbolicLink( &ostDrive, &ostPath );

    return RtlNtStatusToDosError( status );
    }

DWORD UnMapDrive( char cDriveLetter )
    {
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );

    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );

    ANSI_STRING ostDrive;

    RtlInitObjectString( &ostDrive, pszDrive );
    NTSTATUS status = IoDeleteSymbolicLink(&ostDrive);

    return RtlNtStatusToDosError( status );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\reboot\reboot.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    reboot.cpp

Abstract:

    File System disk scanner.

Notes:

  xbsetcfg /D xc:\reboot.xbe
*****************************************************************************/

#include "reboot.h"
#include <xbeimage.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[XGetPortCount()*2] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
DWORD addDevice, removeDevice;


//
// config settings
//
ConfigSettings globalSettings;

//
// stats
//
Stats stats;
char model[64], serial[64], firmware[64];
DWORD mediaType = MEDIA_UNKNOWN;

#define SCREEN_WAIT_TIME 2000

void ParseTestConfig(char *variable, char *value, void *userParam)
    {
    ConfigSettings *settings = (ConfigSettings*)userParam;

    if(strstr(variable, "seed") != NULL) settings->seed = GetNumber(value);
    else if(strstr(variable, "reboottype") != NULL) settings->rebootType = GetNumber(value);
    }

extern "C" POBJECT_STRING XeImageFileName;

void _cdecl main(void)
    {
    bool firstRun = false;
    bool exit = false;
    DBDATA results;
    DWORD totalReboots;

    //
    // Get the launch data (if any)
    //
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    XGetLaunchInfo(&dataType, &launchInfo);
    ToTestData* initialParams = (ToTestData*)&launchInfo;

    Initialize();


    // mount c:
    MapDrive('C', "\\Device\\Harddisk0\\Partition1");
    if(!FileExists("c:\\dashboard_backup.xbx"))
        {
        firstRun = true;
        }

    if(firstRun) 
        {
        // save the original D path so we know where the launcher is located
        GetMapDrive('D', stats.driveD);
        //DebugPrint("************Drive D: %s\n", stats.driveD);
        }
    else
        {
        // when run via the dashboard.xbx file, D is not mapped to the 
        // location of the xbe, so we map it ourselves
        UnMapDrive('D');
        MapDrive('D', "\\Device\\Harddisk0\\Partition1");
        }

    //
    // cleanup old files
    //
    DeleteFile("T:\\testexit.txt");

    //
    // Grab the startup parameters
    //
    char *iniConfig = NULL;
    if(initialParams->titleID == HVSLAUNCHERID)
        {
        FILE *f = fopen("C:\\reboot.ini", "w+");
        if(f)
            {
            fprintf(f, "%s", initialParams->configSettings);
            fclose(f);
            }
        else
            {
            LogPrint("Unable to write to C:\\reboot.ini (ec: %u), test will run with default parameters.\n", GetLastError());
            }
        iniConfig = new char[strlen(initialParams->configSettings)+1];
        strcpy(iniConfig, initialParams->configSettings);
        ParseConfigSettings(initialParams->configSettings, &globalSettings, ParseTestConfig, &globalSettings);
        }
    else
        {
        FILE *file = fopen("D:\\reboot.ini", "rb");
        if(file)
            {
            DWORD filesize = _filelength(_fileno(file));
            iniConfig = new char[filesize+1];
            unsigned bytesRead = fread(iniConfig, 1, filesize, file);
            iniConfig[bytesRead] = '\0';

            ParseConfigSettings(iniConfig, &globalSettings, ParseTestConfig, &globalSettings);
            if(fseek(file, 0, SEEK_SET) == 0)
                {
                bytesRead = fread(iniConfig, 1, filesize, file);
                iniConfig[bytesRead] = '\0';
                }
            fclose(file);
            }
        }

    //
    // seed random number generator
    //
    srand(globalSettings.seed);

    // if random mode, set the reboot mode to an actual setting
    if(globalSettings.rebootType == REBOOT_RANDOM)
        globalSettings.rebootType = rand() % REBOOT_RANDOM;


    SetSaveName(globalSettings.saveName, "reboot.log");

    //
    // configure our test to run on reboots
    //
    if(firstRun)
        {
        char rebootLoc[128];

        // Call SetSaveName BEFORE calling LogPrint or LogFlush
        LogFlush();

        DeleteFile("T:\\stats.dat");

        // figure out where this xbe is located so we can copy it
        // eg: \Device\Harddisk0\Partition1\devkit\hvs\tests\reboot.xbe
        strncpy(rebootLoc, XeImageFileName->Buffer, XeImageFileName->Length);
        rebootLoc[XeImageFileName->Length] = '\0';
        char *temp = strrchr(rebootLoc, '\\');
        if(temp) *temp = '\0';
        MapDrive('Q', rebootLoc);
        if(CopyFile("Q:\\reboot.xbe", "C:\\reboot.xbe", FALSE) == 0) // just in case reboot.xbe is on a DVD
            {
            UnMapDrive('Q');
            LogPrint("Unable to copy %s\\reboot.xbe (ec: %u)\n", rebootLoc, GetLastError());
            goto systemCleanup;
            }
        SetFileAttributes("Q:\\reboot.xbe", FILE_ATTRIBUTE_NORMAL);
        UnMapDrive('Q');
        if(CopyFile("C:\\dashboard.xbx", "C:\\dashboard_backup.xbx", FALSE) == 0)
            {
            LogPrint("Unable to backup C:\\dashboard.xbx (ec: %u)\n", GetLastError());
            goto systemCleanup;
            }

        // copy ini file (or create ini) to c:
        if(iniConfig)
            {
            CopyFile("D:\\reboot.ini", "C:\\reboot.ini", FALSE);
            }

        // edit dashboard.xbx to load reboot.xbe on bootup
        FILE *f = fopen("C:\\dashboard.xbx", "wb+");
        if(f)
            {
            char metaImage[360];
            memset(metaImage, 0, 360);
            strcpy(metaImage, "\\Device\\Harddisk0\\Partition1;reboot.xbe");
            fwrite(metaImage, sizeof(metaImage), 1, f);
            fclose(f);
            }
        else
            {
            LogPrint("Unable to write to C:\\dashboard.xbx (ec: %u)\n", GetLastError());
            }
        }




    memset(model, 0, 64);
    memset(serial, 0, 64);
    memset(firmware, 0, 64);

    results.deviceType = "DVD";
    GetDriveID(NULL, true, model, serial, firmware);
    mediaType = GetDiskType(NULL);

    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    GetDiskFreeSpaceEx("A:\\", &FreeBytesAvailable, &TotalNumberOfBytes, &TotalNumberOfFreeBytes);

    if(firstRun)
        {
        LogPrint("Reboot (Built on " __DATE__ " at " __TIME__ ")\n");
        LogPrint("Copyright (C) Microsoft Corporation.  All rights reserved.\n\n");

        if(initialParams->titleID == HVSLAUNCHERID)
            LogPrint("Launched from HVS\n  Test %u of %u\n\n", initialParams->testNumber, initialParams->totalTests);
        else
            LogPrint("Running in stand a lone mode\n\n");

        //
        // print out the drive info and config settings
        //
	    LogPrint("DRIVE: Model:             %s\n", model);
	    LogPrint("DRIVE: Serial:            %s\n", serial);
	    LogPrint("DRIVE: Firmware:          %s\n", firmware);
        LogPrint("MEDIA: Type:              %s\n", mediaTypeNames[mediaType]);

        LogPrint("Config Settings:\n");
        LogPrint("  ResultsServer:    %s\n", globalSettings.resultsServer);
        LogPrint("  SaveName:         %s\n", globalSettings.saveName);
        LogPrint("  StopAfter:        %u %s\n", globalSettings.stopAfter.duration, globalSettings.stopAfter.type==STOPAFTER_MINUTES?"min":(globalSettings.stopAfter.type==STOPAFTER_HOURS?"hours":"iterations"));
	    LogPrint("\n");
        LogPrint("  RebootType:       %u\n", globalSettings.rebootType);
        LogPrint("  Seed:             %u\n", globalSettings.seed);
        LogPrint("\n");
        }

    // Open and read the stats file
    FILE *f = fopen("T:\\stats.dat", "rb+");
    if(!f) f = fopen("T:\\stats.dat", "wb+");
    if(!f)
        {
        LogPrint("Error: unable to open the stats file (ec: %u)\n", GetLastError());
        }
    if(!firstRun) 
        {
        if(fread(&stats, sizeof(stats), 1, f) != 1)
            {
            LogPrint("Error: unable to read the stats file (ec: %u)\n", GetLastError());
            }
        }

    // initialize stats if necessary
    if(firstRun)
        {
        if(initialParams->titleID == HVSLAUNCHERID) stats.launchedFromHVS = true;
        }
    if(stats.mediaType == MEDIA_UNKNOWN) stats.mediaType = mediaType;
    if(stats.mediaSize == 0) stats.mediaSize = TotalNumberOfBytes.QuadPart;

    totalReboots = stats.numSoftReboots + stats.numHardReboots + stats.numQuickReboots + stats.numSMCReboots + stats.failures + 1;

    // update stats
    if(mediaType == MEDIA_UNKNOWN)
        {
        ++stats.failures;
        LogPrint("Error on reboot %u: no media detected\n", totalReboots);
        }
    else if(mediaType != stats.mediaType)
        {
        ++stats.failures;
        LogPrint("Error on reboot %u: Current media (%s) does not match previous media (%s)\n", totalReboots, mediaTypeNames[mediaType], mediaTypeNames[stats.mediaType]);
        }
    else if(stats.mediaSize < TotalNumberOfBytes.QuadPart)
        {
        stats.mediaSize = TotalNumberOfBytes.QuadPart;
        ++stats.failures;
        LogPrint("Error on reboot %u: Detected wrong media size\n", totalReboots);
        }
    else if(stats.mediaSize < TotalNumberOfBytes.QuadPart)
        {
        ++stats.failures;
        LogPrint("Error on reboot %u: Detected wrong media size\n", totalReboots);
        }
    else // media detected successfully
        {
        if(globalSettings.rebootType == REBOOT_SOFT) ++stats.numSoftReboots;
        else if(globalSettings.rebootType == REBOOT_HARD) ++stats.numHardReboots;
        else if(globalSettings.rebootType == REBOOT_QUICK) ++stats.numQuickReboots;
        else if(globalSettings.rebootType == REBOOT_SMC) ++stats.numSMCReboots;
        }
    stats.runTime += GetTickCount() + SCREEN_WAIT_TIME;

    // write the stats
    if(fseek(f, 0, SEEK_SET) == 0)
        {
        fwrite(&stats, sizeof(stats), 1, f);
        }
    fclose(f);


    UpdateGraphics(DISPLAYMODE_RUN_TIME);

    // give USB time to enum devices, and the user time to see the screen
    for(unsigned time=0; time<SCREEN_WAIT_TIME; time+=200)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);

        // check stopAfter
        if(globalSettings.stopAfter.type == STOPAFTER_ITERATIONS && totalReboots >= globalSettings.stopAfter.duration) exit = true;
        else if(globalSettings.stopAfter.type == STOPAFTER_MINUTES && TICK2MIN(stats.runTime) >= globalSettings.stopAfter.duration) exit = true;
        else if(globalSettings.stopAfter.type == STOPAFTER_HOURS && TICK2HOUR(stats.runTime) >= globalSettings.stopAfter.duration) exit = true;

        // check for usb exit
        if(InputCheckExitCombo()) exit = true;

        if(exit) break;

        Sleep(200);
        }


    if(!exit)
        {
        UnMapDrive('C');

        // persist the display across the reboot
        g_pDevice->PersistDisplay();

        LogPrint("Rebooting (#%u) (type=%u)...\n", totalReboots+1, globalSettings.rebootType);

        // let IO complete - may be unneccessary, better safe than blowing a test run
        Sleep(200);

        //
        // reboot
        //
        if(globalSettings.rebootType == REBOOT_SOFT)
            HalReturnToFirmware(HalRebootRoutine);
        else if(globalSettings.rebootType == REBOOT_HARD)
            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET, SMC_RESET_ASSERT_POWERCYCLE);
        else if(globalSettings.rebootType == REBOOT_QUICK)
            XLaunchNewImage("D:\\reboot.xbe", NULL);
        else if(globalSettings.rebootType == REBOOT_SMC)
            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET, SMC_RESET_ASSERT_RESET);

        // If the reboot is successful, we will never get here

        // sleep for 10 sec
        Sleep(10000);

        // if reboot hasnt happened yet, end the run and cleanup
        LogPrint("Reboot didnt happen after 10 sec. Ending Run.\n");
        LogPrint("   You might not have a new SMC.\n");
        MapDrive('C', "\\Device\\Harddisk0\\Partition1"); // gotta remount C
        }



    /////////////////////////////////////////////////////////////////////////
    //
    // test is done if we get here, cleanup and reboot back to the real world
    //
    /////////////////////////////////////////////////////////////////////////


systemCleanup:

    //
    // system cleanup
    //
    CopyFile("C:\\dashboard_backup.xbx", "C:\\dashboard.xbx", FALSE);
    DeleteFile("C:\\dashboard_backup.xbx");
    DeleteFile("C:\\reboot.xbe");
    DeleteFile("C:\\reboot.ini");
    DeleteFile("T:\\stats.dat");


    //
    // dump the stats
    //
    DWORD finalTime = stats.runTime/1000;
    DWORD totalErrors = stats.failures;

    LogPrint("****Program Stats:\n");
    LogPrint("*** %9u sec run time\n", finalTime);
    LogPrint("*** %9u Total Reboots\n", totalReboots);
    LogPrint("****\n");
    LogPrint("*** %9u Total Reported Errors\n", totalErrors);
    LogPrint("****\n");
    LogPrint("*** %9u errors / reboot\n", totalReboots? totalErrors / totalReboots : 0);
    LogPrint("*** %9u errors / sec\n", finalTime? totalErrors / finalTime : 0);


    //
    // Post results if necessary
    //
    if(strncmp(globalSettings.resultsServer, "http://", 7) == 0)
        {
        WSADATA wsaData;
        unsigned short version = MAKEWORD(2, 2);
        WSAStartup(version, &wsaData);

        results.manufacturer = RightTrim(model);
        results.firmwareVersion = RightTrim(firmware);
        results.hardwareVersion = "";
        results.serialNumber = RightTrim(serial);
        results.testName = "Reboot";

        char variation[256];
        char *v = variation;
        sprintf(variation, "Reboot Mode: %u", globalSettings.rebootType);
        results.variation = variation;
        results.boxInformation = GetBoxInformation();
        results.configSettings = iniConfig;

        // passes
        results.status = 1;
        results.numOperations = stats.numSoftReboots;
        results.notes = "Successful Soft Reboots";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // passes
        results.status = 1;
        results.numOperations = stats.numHardReboots;
        results.notes = "Successful Hard Reboots";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // passes
        results.status = 1;
        results.numOperations = stats.numQuickReboots;
        results.notes = "Successful Quick Reboots";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // passes
        results.status = 1;
        results.numOperations = stats.numSMCReboots;
        results.notes = "Successful SMC Reboots";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // failures
        results.status = 0;
        results.numOperations = stats.failures;
        results.notes = "Media Detection Failures";
        if(results.numOperations)
            PostResults(globalSettings.resultsServer, &results);

        // cleanup
        delete[] results.boxInformation;
        }

    delete[] iniConfig;
    UnMapDrive('C');
    if(!firstRun) UnMapDrive('D');

    // persist the display across the reboot
    g_pDevice->PersistDisplay();

    //
    // test done, reboot back to the real world
    //
    if(stats.launchedFromHVS)
        {
        UnMapDrive('D');
        MapDrive('D', stats.driveD);

        ToLauncherData* outParams = (ToLauncherData*)&launchInfo;
        outParams->titleID = XeImageHeader()->Certificate->TitleID;
        outParams->numPass = totalReboots - totalErrors;
        outParams->numFail = totalErrors;
        outParams->notes[0] = '\0';

        LaunchImage("D:\\default.xbe", &launchInfo);
        }
    else
        XLaunchNewImage(NULL, NULL);
    }


void Initialize(void)
    {
    //
    // USB
    //
    XInitDevices(0, NULL);

    //
    // Network
    //
    XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    XNetStartup(&xnsp);

    //
    // D3D
    //
    InitGraphics();
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\reboot\gui.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    gui.cpp

Abstract:

    File System disk scanner.

Notes:

*****************************************************************************/
#include "reboot.h"

IDirect3D8*		    g_d3d		= NULL;
IDirect3DDevice8*	g_pDevice	= NULL;
BitFont				g_font;
IDirect3DTexture8*	g_pd3dtText	= NULL;
TVertex				g_prText[4];
D3DLOCKED_RECT		g_d3dlr;

#define STICK_DEAD_ZONE         6400
#define BUTTON_PRESS_VALUE      100
#define BUTTON_SPEEP_VALUE      150         // in ms

#define COLUMN_1_OFFSET         25
#define COLUMN_2_OFFSET         165

void GUI(void)
    {
    bool exit = false;
    XINPUT_STATE state;

    while(!exit)
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        for(unsigned port=0; port<XGetPortCount(); port++)
            {
            if(hDuke[port])
                {
                XInputGetState(hDuke[port], &state);
                if(state.Gamepad.wButtons & XINPUT_GAMEPAD_BACK) exit = true;
                }
            }

        UpdateGraphics(DISPLAYMODE_CONFIG_READONLY);

        Sleep(BUTTON_SPEEP_VALUE);
        }

    // sleep past any residual user input presses
    Sleep(BUTTON_SPEEP_VALUE);
    }

void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...)
    {
    char szBuffer[256];

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);

    WCHAR *ptr = Ansi2UnicodeHack(szBuffer);

    g_font.DrawText(pd3ds, ptr, x, (line+1)*10, 0, color, 0);
    }


void UpdateGraphics(unsigned mode /*=DISPLAYMODE_RUN_TIME*/)
    {
    IDirect3DSurface8*	pd3ds;

    // Clear the device
    g_pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Clear the texture
    g_pd3dtText->LockRect(0, &g_d3dlr, NULL, 0);
    for(unsigned i=0; i<240; i++)
        memset((LPBYTE)g_d3dlr.pBits + i * g_d3dlr.Pitch, 0, 320 * 4);
    g_pd3dtText->UnlockRect(0);

    // Get the surface to draw the text to
    g_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // run time status mode
    //
    if(mode == DISPLAYMODE_RUN_TIME || mode == DISPLAYMODE_PAUSE)
        {
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 1, 0xFF4444FF, "REBOOT");
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 2, 0xFF4444FF, "Model: %s", model);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 3, 0xFF4444FF, "Serial: %s", serial);
	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 4, 0xFF4444FF, "Firmware: %s", firmware);

	    GraphicPrint(pd3ds, COLUMN_1_OFFSET, 5, 0xFF4444FF, "Media: %s", mediaTypeNames[mediaType]);
        unsigned line = 6;

        if(globalSettings.stopAfter.duration != 0 && globalSettings.stopAfter.type == STOPAFTER_ITERATIONS)
            GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Reboot %u of %u", stats.numSoftReboots + stats.numQuickReboots + stats.numHardReboots + stats.numSMCReboots + stats.failures, globalSettings.stopAfter.duration);
        else
            GraphicPrint(pd3ds, COLUMN_1_OFFSET,  ++line, 0xFFFFFFFF, "Reboot %u", stats.numSoftReboots + stats.numQuickReboots + stats.numHardReboots + stats.numSMCReboots + stats.failures);
        GraphicPrint(pd3ds, COLUMN_2_OFFSET, line, 0xFFFFFFFF, " Run Time: %u sec", stats.runTime/1000);

        GraphicPrint(pd3ds, COLUMN_1_OFFSET, ++line, 0xFFFFFFFF, "Detection Failures: %u", stats.failures);

	    GraphicPrint(pd3ds, COLUMN_1_OFFSET,  20, 0xFFFFFFFF,  "Press Left Trigger + Right Trigger + Black to reboot");
        }

    // Release the surface
    pd3ds->Release();

    // Draw the textured primitive (with the text)
    g_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, g_prText, sizeof(TVertex));

    // End the scene and present it
    g_pDevice->EndScene();
    g_pDevice->Present(NULL, NULL, NULL, NULL);
    }



bool InputCheckExitCombo(void)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > BUTTON_PRESS_VALUE &&
                state.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > BUTTON_PRESS_VALUE)
                {
                LogPrint("\r\n\r\nFound Exit Combo on gamepad %u - rebooting\r\n", port+1);
                return true;
                }
            }
        }

    // check for exit file
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind = FindFirstFile("T:\\testexit.txt", &FindFileData);
    FindClose(hFind);
    if(hFind != INVALID_HANDLE_VALUE)
        {
        LogPrint("\r\n\r\nFound Exit File (testexit.txt) - rebooting\r\n");
        return true;
        }

    return false;
    }


bool InputCheckButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.bAnalogButtons[button] > BUTTON_PRESS_VALUE)
                {
                return true;
                }
            }
        }

    return false;
    }


bool InputCheckDigitalButton(int button)
    {
    XINPUT_STATE state;

    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port])
            {
            XInputGetState(hDuke[port], &state);
            if(state.Gamepad.wButtons & button)
                {
                return true;
                }
            }
        }

    return false;
    }


void Pause(void)
    {
    OutputDebugStringA("*****************************************************************************\n");
    OutputDebugStringA("* Entered Paused State. Hit the BACK button to resume...\n");
    OutputDebugStringA("*****************************************************************************\n");
    while(!InputCheckDigitalButton(XINPUT_GAMEPAD_BACK))
        {
        XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDevice, &removeDevice);
        InputDukeInsertions(addDevice, removeDevice);
        XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &addDevice, &removeDevice);
        InputMUInsertions(addDevice, removeDevice);

        UpdateGraphics(DISPLAYMODE_PAUSE);

        Sleep(BUTTON_SPEEP_VALUE);
        }
    }


void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & USBPortMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & USBPortMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            //LogPrint("Adding Duke in Port %u\n", port+1);
            }
        }
    }


void InputMUInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned i=0; i<XGetPortCount()*2; i++)
        {
        DWORD port = i/2;
        DWORD slot = i%2==0?XDEVICE_BOTTOM_SLOT:XDEVICE_TOP_SLOT;
        if(remove & USBSlotMasks[i])
            {
            if(hSlot[i]) XUnmountMU(XMUPortFromDriveLetter((char)hSlot[i]), XMUSlotFromDriveLetter((char)hSlot[i]));
            hSlot[i] = NULL;
            }
        if(add & USBSlotMasks[i])
            {
            char drive;
            if(XMountMU(port, slot, &drive) == ERROR_SUCCESS)
                {
                hSlot[i] = (HANDLE)drive;
                //LogPrint("Adding MU in Port %u, Slot %u\n", XMUPortFromDriveLetter((char)hSlot[i])+1, XMUSlotFromDriveLetter((char)hSlot[i])+1);
                }
            }
        }
    }


/*

Routine Description:

	Initializes the graphics

Arguments:

	None

Return Value:

	None

*/
HRESULT InitGraphics(void)
    {
    HRESULT	hr;
    D3DPRESENT_PARAMETERS d3dpp;
    int i;
    
    // Create an instance of a Direct3D8 object 
    g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
    if(g_d3d == NULL)
        return E_FAIL;
    
    // Setup the present parameters: 640x480x24
    ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= 640;
    d3dpp.BackBufferHeight					= 480;
    d3dpp.BackBufferFormat					= D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount					= 1;
    d3dpp.Flags								= 0;
    d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
    d3dpp.Flags								= 0;
    d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;
    
    // Create the device
    hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, &g_pDevice);
    if(FAILED(hr))
        return hr;
    
    // Create a buffer for the text
    hr = g_pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &g_pd3dtText);
    if(FAILED(hr))
        return hr;
    
    // Text plane
    g_prText[0].x = 0.0f;
    g_prText[0].y = 480.0f;
    g_prText[0].u = 0.0f;
    g_prText[0].v = 240.0f;
    g_prText[1].x = 0.0f;
    g_prText[1].y = 0.0f;
    g_prText[1].u = 0.0f;
    g_prText[1].v = 0.0f;
    g_prText[2].x = 640.0f;
    g_prText[2].y = 0.0f;
    g_prText[2].u = 320.0f;
    g_prText[2].v = 0.0f;
    g_prText[3].x = 640.0f;
    g_prText[3].y = 480.0f;
    g_prText[3].u = 320.0f;
    g_prText[3].v = 240.0f;
    
    for(i=0; i<4; i++) 
        {
        g_prText[i].z	= 0.0f;
        g_prText[i].rhw	= 1.0f;
        }
    
    // Setup stuff
    g_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
    g_pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    g_pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    g_pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pDevice->SetTexture(0, g_pd3dtText);
    g_pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\reboot\reboot.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    reboot.h

Abstract:

    File System disk scanner.

*****************************************************************************/

#ifndef _REBOOT_H_
#define _REBOOT_H_

#ifdef _VC
//#define DEVICE_TYPE ULONG
#define NTLEANANDMEAN
#define _X86_
#define _WIN32_WINNT 0x0500
#endif

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <smcdef.h>

#include <xtl.h>
#include <stdio.h>

#include "../utils/hvsUtils.h"
#include "bitfont.h"

#define CLEARFLAG(var, flag)    (var &= ~(flag))
#define SETFLAG(var, flag)      (var |=  (flag))

//
// Initialization calls
//
void Initialize(void);
HRESULT InitGraphics(void);

//
// User input
// 
void InputDukeInsertions(DWORD add, DWORD remove=0);
void InputMUInsertions(DWORD add, DWORD remove=0);
bool InputCheckExitCombo(void);
bool InputCheckButton(int button);
bool InputCheckDigitalButton(int button);
void Pause(void);


//
// Graphics / GUI methods
//
enum DISPLAY_MODE
    {
    DISPLAYMODE_PAUSE,
    DISPLAYMODE_RUN_TIME,
    DISPLAYMODE_CONFIG_READONLY,
    DISPLAYMODE_CONFIG_INTERACTIVE
    };
void UpdateGraphics(unsigned mode = DISPLAYMODE_RUN_TIME);
void GUI(void);
void GraphicPrint(IDirect3DSurface8* pd3ds, unsigned x, unsigned line, DWORD color, char* format, ...);


//
// Utility functions
//

//
// User input
//
extern HANDLE hDuke[XGetPortCount()];
extern HANDLE hSlot[XGetPortCount()*2];
static const DWORD USBPortMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
static const DWORD USBSlotMasks[] = {
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_BOTTOM_MASK,
    XDEVICE_PORT3_TOP_MASK
    };

enum MEDIA_TYPES
	{
	MEDIA_UNKNOWN,
	MEDIA_CDDA,
	MEDIA_CDROM,
	MEDIA_DVD_5_RO,
	MEDIA_DVD_5_RW,
	MEDIA_DVD_9_RO,
	MEDIA_DVD_9_RW,
	MEDIA_HD,
    MEDIA_MU
	};

static const char *mediaTypeNames[] = 
    {
    "Unknown",
    "CD DA",
    "CD ROM",
    "DVD 5 RO",
    "DVD 5 RW",
    "DVD 9 RO",
    "DVD 9 RW",
    "Hard Disk",
    "MU"
    };

struct Stats
    {
    bool launchedFromHVS;
    DWORD numSoftReboots;
    DWORD numHardReboots;
    DWORD numQuickReboots;
    DWORD numSMCReboots;
    DWORD failures;
    DWORD runTime;
    DWORD mediaType;
    unsigned __int64 mediaSize;
    char driveD[MAX_PATH];

    Stats()
        {
        launchedFromHVS = false;
        numSoftReboots = 0;
        numHardReboots = 0;
        numQuickReboots = 0;
        numSMCReboots = 0;
        failures = 0;
        runTime = 0;
        mediaType = MEDIA_UNKNOWN;
        mediaSize = 0;
        memset(driveD, 0, MAX_PATH);
        }
    };

enum REBOOT_TYPES
    {
    REBOOT_SOFT,
    REBOOT_HARD,
    REBOOT_QUICK,
    REBOOT_SMC,
    REBOOT_RANDOM
    };

//
// config settings
//
struct ConfigSettings : public CoreConfigSettings
    {
    DWORD rebootType;
    DWORD seed;

    ConfigSettings()
        {
        seed = 0;
        rebootType = REBOOT_QUICK;

        stopAfter.type = STOPAFTER_ITERATIONS;
        stopAfter.duration = 5;
        }
    };

extern ConfigSettings globalSettings;


//
// stats
//
extern Stats stats;
extern char model[64], serial[64], firmware[64];
extern DWORD mediaType;
extern DWORD addDevice, removeDevice;


//
// graphics
//
extern IDirect3D8*		    g_d3d;
extern IDirect3DDevice8*	g_pDevice;
extern BitFont				g_font;
extern IDirect3DTexture8*	g_pd3dtText;
extern TVertex				g_prText[4];
extern D3DLOCKED_RECT		g_d3dlr;


void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
DWORD GetDiskType(HANDLE hDevice);
DWORD MapDrive(char cDriveLetter, char* pszPartition);
DWORD UnMapDrive(char cDriveLetter);
DWORD GetMapDrive(char cDriveLetter, char *partition);
bool FileExists(const char *filename);



#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#endif //_REBOOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\reboot\diskUtils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    diskUtils.cpp

Abstract:

    Functions that talk to the DVD drive

Notes:
    dvd player code:
        "\xboxsrc\private\ui\dvd\library\hardware\drives\specific\xboxdvddrive.cpp"
    filesystem retry code:
        "\xboxsrc\private\ntos\idex\cdrom.c" (IdexCdRomFinishRequestSense)
    sense data format:
        "\xboxsrc\public\ddk\inc\scsi.h"


    DVD-X2 Supported Error Sense Codes
        Sense   Sense   Sense   Description
        Key	    Code    Code Qu
        ----------------------------------------------------------------------
        0x00	0x00	0x00	No Additional Sense information (= no error)
        0x01	0x80	0x00	Cache fill error, speed reduction requested
        0x02	0x04	0x00	Logical Unit not ready, cause not reported
        0x02	0x04	0x01	Logical Unit is in process of becoming ready
        0x02	0x30	0x00	Incompatible medium installed
        0x02	0x3A	0x00	Medium not present
        0x03	0x57	0x00	Unable to recover Table of Contents
        0x03	0x80	0x00	Read Error
        0x04	0x00	0x00	Hardware error
        0x04	0x08	0x03	Logical Unit Communication CRC Error - UDMA33
        0x05	0x21	0x00	Logical Block Address Out of Range
        0x05	0x55	0x00	System Resource Failure
        0x05	0x64	0x00	Illegal mode for this track
        0x05	0x6F	0x00	Authentication Failure - CSS
        0x05	0x80	0x00	Authentication Failure - Xbox
        0x05	0x81	0x00	Command error
        0x06	0x29	0x00	Power On, Reset or Bus Device Reset occurred
        0x06	0x2A	0x01	Mode Parameters changed
        0x06	0x2E	0x00	Insufficient time for operation

    Win32 Error code mapping:
        1/80:   ERROR_CRC                   23
        2/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        2/other ERROR_NOT_READY             21
        3/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        3/other ERROR_CRC                   23
        5/21:   ERROR_SECTOR_NOT_FOUND      27
        5/30:   ERROR_UNRECOGNIZED_MEDIA    1785
        5/6F:   ERROR_TOO_MANY_SECRETS      1381
        5/80:   ERROR_TOO_MANY_SECRETS      1381
        other:  ERROR_IO_DEVICE             1117

    IOCTL_CDROM_SET_SPINDLE_SPEED
        speed 2     ~3000rpm      2x -    5x
        speed 1     ~2000rpm    4/3x - 10/3x
        speed 0     ~1000rpm    2/3x -  5/3x

*****************************************************************************/

#include "reboot.h"

/*
APIs in this file:

    void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware);
    bool CDTestReady(HANDLE hDevice);
    DWORD GetDiskType(HANDLE hDevice);

*/







void GetDriveID(HANDLE hDevice, bool cdrom, char* model, char* serial, char* firmware)
    {
    unsigned i;
    DWORD returned;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;
    bool closeHandle = false;

    if(hDevice == NULL)
        {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        if(cdrom)
            RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        else
            RtlInitObjectString(&VolumeString, "\\Device\\Harddisk0\\Partition0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
        }

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(cdrom) atapt->IdeReg.bCommandReg = 0xA1;
    else atapt->IdeReg.bCommandReg = 0xEC;

    DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH, atapt, sizeof(ATA_PASS_THROUGH), atapt, sizeof(ATA_PASS_THROUGH), &returned, FALSE);
    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for(i=0; i<sizeof(IdData->ModelNumber); i+=2)
        {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
        }
    model[i] = 0;

    for(i=0; i<sizeof(IdData->SerialNumber); i+=2)
        {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
        }
    serial[i] = 0;

    for(i=0; i<sizeof(IdData->FirmwareRevision); i+=2)
        {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
        }
    firmware[i] = 0;

    if(closeHandle) NtClose(hDevice);
    }


bool CDTestReady(HANDLE hDevice)
    {
    DWORD cbReturned;

    BOOL fReturn = DeviceIoControl(hDevice, IOCTL_CDROM_CHECK_VERIFY, NULL, 0, NULL, 0, &cbReturned, NULL);

    if(fReturn || (GetLastError() == ERROR_UNRECOGNIZED_MEDIA))
        {
        return false;
        }
    
    return true;
    }


DWORD GetDiskType(HANDLE hDevice)
    {
    DVD_READ_STRUCTURE readStruct;
    UCHAR readStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) + sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];

    bool closeHandle = false;

    if(hDevice == NULL)
        {
        OBJECT_ATTRIBUTES ObjA;
        OBJECT_STRING VolumeString;
        IO_STATUS_BLOCK IoStatusBlock;
        RtlInitObjectString(&VolumeString, "\\Device\\cdrom0");
        InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
        NtCreateFile(&hDevice, SYNCHRONIZE|GENERIC_READ, &ObjA, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NO_INTERMEDIATE_BUFFERING);
        closeHandle = true;
        }

    memset(&readStruct, 0, sizeof(DVD_READ_STRUCTURE));
    memset(readStructureOutput, 0, sizeof(readStructureOutput));

    // try DVD Read Structure
    readStruct.Format = DvdPhysicalDescriptor;

    DWORD returned = 0;
    BOOL result = DeviceIoControl(hDevice, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(DVD_READ_STRUCTURE), readStructureOutput, sizeof(readStructureOutput), &returned, NULL);
    if(result)
        {
        if(closeHandle) NtClose(hDevice);
        DVD_LAYER_DESCRIPTOR *layerDescr = (DVD_LAYER_DESCRIPTOR *)(&readStructureOutput[sizeof(DVD_DESCRIPTOR_HEADER)]);
        BYTE layerType = (layerDescr->BookType) | (layerDescr->BookVersion << 4);
        if(layerDescr->LayerType == 1)
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RO;
            else return MEDIA_DVD_9_RO;
            }
        else
            {
            if(layerDescr->NumberOfLayers == 0)
                return MEDIA_DVD_5_RW;
            else return MEDIA_DVD_9_RW;
            }
        }

    // not a DVD disk...
    else
        {
	    CDROM_TOC toc;
        memset(&toc, 0, sizeof(CDROM_TOC));
		result = DeviceIoControl( hDevice, IOCTL_CDROM_READ_TOC, &toc, sizeof(CDROM_TOC), &toc, sizeof(CDROM_TOC), &returned, NULL);
        if(closeHandle) NtClose(hDevice);
        if(result)
            {
            if(toc.FirstTrack == toc.LastTrack) return MEDIA_CDROM;
            return MEDIA_CDDA;
            }
        else
            {
            return MEDIA_CDROM;
            }
        }

    return MEDIA_UNKNOWN;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\reboot\utils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    Helper functions

Notes:

*****************************************************************************/

#include "reboot.h"

DWORD MapDrive(char cDriveLetter, char* pszPartition)
    {
    char pszDrive[20];
    ZeroMemory(pszDrive, 20);
 
    sprintf(pszDrive, "\\??\\%c:", cDriveLetter);
 
    ANSI_STRING ostDrive, ostPath;
 
    RtlInitObjectString(&ostDrive, pszDrive);
    RtlInitObjectString(&ostPath, pszPartition);
    NTSTATUS status = IoCreateSymbolicLink(&ostDrive, &ostPath);
 
    return RtlNtStatusToDosError(status);
    }

DWORD UnMapDrive(char cDriveLetter)
    {
    char pszDrive[20];
    ZeroMemory(pszDrive, 20);
 
    sprintf(pszDrive, "\\??\\%c:", cDriveLetter);
 
    ANSI_STRING ostDrive;
 
    RtlInitObjectString(&ostDrive, pszDrive);
    NTSTATUS status = IoDeleteSymbolicLink(&ostDrive);
 
    return RtlNtStatusToDosError(status);
    }

DWORD GetMapDrive(char cDriveLetter, char *partition)
    {
    OBJECT_STRING ObjectName;
    ULONG TargetLength = MAX_PATH;
    OBJECT_STRING ObjectTarget;
    char pszDrive[20];
    HANDLE handle;

    ZeroMemory(pszDrive, 20);
    sprintf(pszDrive, "\\??\\%c:", cDriveLetter);

    OBJECT_ATTRIBUTES ObjectAttributes;
    RtlInitObjectString(&ObjectName, pszDrive);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NTSTATUS status = NtOpenSymbolicLinkObject(&handle, &ObjectAttributes);
    if(!NT_SUCCESS(status))
        {
        return RtlNtStatusToDosError(status);
        }

    ObjectTarget.Buffer = partition;
    ObjectTarget.MaximumLength = MAX_PATH;

    status = NtQuerySymbolicLinkObject(handle, &ObjectTarget, &TargetLength);

    NtClose(handle);

    strncpy(partition, ObjectTarget.Buffer, ObjectTarget.Length);
    partition[ObjectTarget.Length] = '\0';

    return RtlNtStatusToDosError(status);
    }


/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    char *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
bool FileExists(const char *filename)
    {
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    bool retval = false;

    hFind = FindFirstFile(filename, &FindFileData);

    if(hFind != INVALID_HANDLE_VALUE)
        {
        retval = true;
        }
    FindClose(hFind);

    return retval;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\sampleTest\sampleTest.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    sampleTest.cpp

Abstract:

    Sample code for integrating with the HVS Launcher

Notes:
    
    * Custom ini file settings are stored in the ConfigSettings struct
    * Ini file settings are parsed out in the ParseTestConfig function


*****************************************************************************/

#include <xtl.h>
#include <stdio.h>
#include <xbeimage.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

#include "../utils/hvsUtils.h"

HANDLE hDuke[XGetPortCount()] = { NULL, NULL, NULL, NULL };
HANDLE hSlot[XGetPortCount()*2] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

static void Initialize(void);

struct ConfigSettings : public CoreConfigSettings
    {
    DWORD customParam1;
    char customParam2[64];

    ConfigSettings()
        {
        customParam1 = 123;
        customParam2[0] = '\0';
        }
    } globalSettings;


void ParseTestConfig(char *variable, char *value, void *userParam)
    {
    ConfigSettings *settings = (ConfigSettings*)userParam;

    if(strstr(variable, "customparam1") != NULL) settings->customParam1 = GetNumber(value);
    else if(strstr(variable, "customparam2") != NULL) strcpy(settings->customParam2, value);
    }

void _cdecl main(void)
    {
    //
    // Get the launch data (if any)
    //
    DWORD dataType = 0xCDCDCDCD;
    LAUNCH_DATA launchInfo;
    XGetLaunchInfo(&dataType, &launchInfo);
    ToTestData* initialParams = (ToTestData*)&launchInfo;
    char *iniConfig = NULL;

    Initialize();

    //
    // Grab the startup parameters
    //
    if(initialParams->titleID == HVSLAUNCHERID)
        {
        // parameters are coming from HVS
        iniConfig = new char[strlen(initialParams->configSettings)+1];
        strcpy(iniConfig, initialParams->configSettings);
        ParseConfigSettings(initialParams->configSettings, &globalSettings, ParseTestConfig, &globalSettings);
        }
    else
        {
        // not launched from HVS, run in standAlone mode
        FILE *file = fopen("D:\\sampleTest.ini", "rb");
        if(file)
            {
            DWORD filesize = _filelength(_fileno(file));
            iniConfig = new char[filesize+1];
            unsigned bytesRead = fread(iniConfig, 1, filesize, file);
            iniConfig[bytesRead] = '\0';

            ParseConfigSettings(iniConfig, &globalSettings, ParseTestConfig, &globalSettings);

            // read the file again, cause ParseConfigSettings will modify the buffer
            if(fseek(file, 0, SEEK_SET) == 0)
                {
                bytesRead = fread(iniConfig, 1, filesize, file);
                iniConfig[bytesRead] = '\0';
                }
            fclose(file);
            }
        }

    // Call SetSaveName BEFORE calling LogPrint or LogFlush
    SetSaveName(globalSettings.saveName, "sampleTest.log");
    LogFlush();

    if(initialParams->titleID == HVSLAUNCHERID)
        LogPrint("Launched from HVS\n  Test %u of %u\n\n", initialParams->testNumber, initialParams->totalTests);
    else
        LogPrint("Running in stand a lone mode\n\n");


    // Log out important INI file settings for reference
    LogPrint("Config Settings:\n");
    LogPrint("  ResultsServer: %s\n", globalSettings.resultsServer);
    LogPrint("  SaveName:      %s\n", globalSettings.saveName);
    LogPrint("  StopAfter:     %u %s\n", globalSettings.stopAfter.duration, globalSettings.stopAfter.type==STOPAFTER_MINUTES?"min":(globalSettings.stopAfter.type==STOPAFTER_HOURS?"hours":"iterations"));

    LogPrint("  CustomParam1:  %u\n", globalSettings.customParam1);
    LogPrint("  CustomParam2:  %s\n", globalSettings.customParam2);



    //
    // TODO run the test here
    //


    //
    // Sends test results + hardware information to the database
    //
    if(strncmp(globalSettings.resultsServer, "http://", 7) == 0)
        {
        DBDATA data;
        data.deviceType = "deviceType";
        data.manufacturer = "manufacturer";
        data.firmwareVersion = "firmwareVersion";
        data.hardwareVersion = "hardwareVersion";
        data.serialNumber = "serialNumber";
        data.testName = "Sample Test";
        data.variation = "Test 1";
        data.status = 1; // 1=pass, 0=fail
        data.numOperations = 100;
        data.boxInformation = GetBoxInformation();
        data.configSettings = iniConfig;
        data.notes = "notes";

        PostResults(globalSettings.resultsServer, &data);

        // if we had any failures, we would call PostResults again 
        // with data.status=0, and numOperations = to the number of
        // failures

        LogPrint("\nBox Information:\n");
        LogPrint("%s\n\n", data.boxInformation);
        delete[] data.boxInformation;
        }
    delete[] iniConfig;


    //
    // Get the percentage of acceptable failres for this test
    //
    if(strncmp(globalSettings.resultsServer, "http://", 7) == 0)
        {
        double criteria = GetAcceptanceCriteria(globalSettings.resultsServer, "Sample Test");
        LogPrint("Criteria for 'test' = %lf\n", criteria);
        }


    //
    // test done, reboot
    //
    if(initialParams->titleID == HVSLAUNCHERID)
        {
        ToLauncherData* outParams = (ToLauncherData*)&launchInfo;
        outParams->titleID = XeImageHeader()->Certificate->TitleID;
        outParams->numPass = 100;
        outParams->numFail = 0;
        outParams->notes[0] = '\0';

        LaunchImage("D:\\default.xbe", &launchInfo);
        }
    else
        XLaunchNewImage(NULL, NULL);
    }


static void Initialize(void)
    {
    DWORD error;

    //
    // USB
    //
    XInitDevices(0, NULL);

    //
    // Network
    //
    WSADATA wsaData;
    unsigned short version = MAKEWORD(2, 2);
    XNetStartupParams xnsp = { sizeof(XNetStartupParams), XNET_STARTUP_BYPASS_SECURITY };
    error = XNetStartup(&xnsp);
    if(error != NO_ERROR)
        {
        }
    Sleep(5000); // needed cause XNetStartup isnt fully started when call exits
    WSAStartup(version, &wsaData);

    //
    //
    //
    //InitGraphics();
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\sampleTest\sampleTest.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    sampleTest.h

Abstract:

    

*****************************************************************************/

#ifndef _SAMPLETEST_H_
#define _SAMPLETEST_H_



#endif //_SAMPLETEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\utils\hvsUtils.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    hvsUtils.cpp

Abstract:

    HVS Test Helper functions

Notes:

*****************************************************************************/

#include <stdio.h>
#include <xtl.h>
#include <crtdbg.h>
#include <malloc.h>

#include "hvsUtils.h"



/*****************************************************************************

Routine Description:

    DebugPrint

    Writes data to the debugger.

Arguments:

    char *format,
    ...

Return Value:

    none

*****************************************************************************/
void DebugPrint(char* format, ...)
    {
    if(!format) return;

    char *szBuffer;
    try
        {
        // alloca can throw if no mem on stack
        szBuffer = (char*)_alloca(4*1024*sizeof(char));

        va_list args;
        va_start(args, format);

        vsprintf(szBuffer, format, args);
        OutputDebugStringA(szBuffer);

        va_end(args);
        }
    catch(...)
        {
        OutputDebugStringA(format); // just write out as much as we can
        }
    }

/*****************************************************************************

Routine Description:

    DebugPrint

    Writes data to the debugger.

Arguments:

    WCHAR *format,
    ...

Return Value:

    none

*****************************************************************************/
void DebugPrint(WCHAR* format, ...)
    {
    if(!format) return;

    WCHAR *wszBuffer;
    try
        {
        // alloca can throw if no mem on stack
        wszBuffer = (WCHAR*)_alloca(4*1024*sizeof(WCHAR));

        va_list args;
        va_start(args, format);

        vswprintf(wszBuffer, format, args);
        OutputDebugStringW(wszBuffer);

        va_end(args);
        }
    catch(...)
        {
        OutputDebugStringW(format); // just write out as much as we can
        }
    }


/*****************************************************************************

Routine Description:

    HexDump

    Writes binary data as a hex dump using LogPrint

Arguments:

    unsigned char * buffer
    DWORD length

Return Value:

    none

*****************************************************************************/
void HexDump(const unsigned char * buffer, DWORD length)
    {
    DWORD i, count, index;
    char digits[]="0123456789ABCDEF";
    char line[100];
    unsigned cbLine;

    for(index = 0; length; length -= count, buffer += count, index += count)
        {
        count = (length > 16) ? 16:length;

        cbLine = sprintf(line, "%08X  ", index);

        for(i=0;i<count;i++)
            {
            line[cbLine++] = digits[buffer[i] >> 4];
            line[cbLine++] = digits[buffer[i] & 0x0f];
            if(i == 7)
                {
                line[cbLine++] = ' ';
                line[cbLine++] = '|';
                line[cbLine++] = ' ';
                }
            else
                {
                line[cbLine++] = ' ';
                }
            }
        for(; i < 16; i++)
            {
            line[cbLine++] = ' ';
            line[cbLine++] = ' ';
            line[cbLine++] = ' ';
            }

        line[cbLine++] = ' ';

        for(i = 0; i < count; i++)
            {
            if(buffer[i] < 32 || buffer[i] > 126)
                {
                line[cbLine++] = '.';
                }
            else
                {
                line[cbLine++] = buffer[i];
                }
            }

        line[cbLine++] = 0;
        LogPrint("%s\n", line);
        }
    }

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    WCHAR* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a WCHAR string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
WCHAR* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((DWORD)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (WCHAR*)str;
    }


/*****************************************************************************

Routine Description:

    GetNumber

    Parses a number from a string that is either base 10 or 16 (must be 
    prefixed by "0x")

Arguments:

    IN char* string - string representation of the number

Return Value:

    long

*****************************************************************************/
long GetNumber(char *string)
    {
    char *tmp;
    if((tmp = strchr(string, 'x')) != NULL)
        {
        long a=0;
        if(sscanf(tmp+1, "%X", &a) != 1) return 0;
        return a;
        }

    return atol(string);
    }

char* RightTrim(char *string)
    {
    char *white = " \n\r\t";
    unsigned len = strlen(string);
    while(--len)
        {
        if(strchr(white, string[len]) != NULL)
            string[len] = '\0';
        else break;
        }

    return string;
    }

WCHAR* RightTrim(WCHAR *string)
    {
    WCHAR *white = L" \n\r\t";
    unsigned len = wcslen(string);
    while(--len)
        {
        if(wcschr(white, string[len]) != NULL)
            string[len] = L'\0';
        else break;
        }

    return string;
    }

/*****************************************************************************

Routine Description:

    ParseConfigSettings

    Parses config settings from a buffer (new line delimited) and adds them
    to a CoreConfigSettings struct.

Arguments:

    char *config - config settings to parse
    CoreConfigSettings *output - where to stick the settings
    USERSETTING_FUNC LocalTestConfigs - user supplied function for parsing 
        custom settings
    void *userParam - user supplied pointer thats passed to LocalTestConfigs

Return Value:

    none

*****************************************************************************/
void ParseConfigSettings(char *config, CoreConfigSettings *output, USERSETTING_FUNC LocalTestConfigs, void *userParam)
    {
    char value[256];
    char variable[64];
    char *end;

    do
        {
        end = strchr(config, '\n');
        if(end) *end = '\0';

        char *c = strchr(config, ';');
        if(c) *c = '\0';
        c = strchr(config, '[');
        if(c) *c = '\0';
        RightTrim(config);

        if(sscanf(config, "%63[^=]= %255[^\0]", variable, value) == 2)
            {
            _strlwr(variable);

            // core settings
            if(strstr(variable, "resultsserver") != NULL) strcpy(output->resultsServer, value);
            else if(strstr(variable, "savename") != NULL) strcpy(output->saveName, value);
            else if(strstr(variable, "stopafter") != NULL)
                {
                output->stopAfter.duration = GetNumber(value);
                if(strstr(value, "min")) output->stopAfter.type = STOPAFTER_MINUTES;
                else if(strstr(value, "hour")) output->stopAfter.type = STOPAFTER_HOURS;
                else if(strstr(value, "iter")) output->stopAfter.type = STOPAFTER_ITERATIONS;
                }

            // test settings
            else LocalTestConfigs(variable, value, userParam);
            }

        if(end) config = end+1;
        } while(end);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\utils\hvsUtils.h ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    hvsUtils.h

Abstract:

    HVS Test Helper functions

Notes:

*****************************************************************************/

#ifndef _HVSUTILS_H_
#define _HVSUTILS_H_

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

// define filelength instead of including io.h because it will 
// collide with ntos\inc\io.h
extern "C"
    {
    long __cdecl _filelength(int);
    }

#ifndef KILOBYTE
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE * KILOBYTE)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#endif

#define TICK2MIN(val)       ((val)/1000/60)
#define TICK2HOUR(val)      ((val)/1000/60/60)

#define HVSLAUNCHERID 0x48570000

struct ToTestData
    {
    DWORD titleID; // always == 48570000
    unsigned short testNumber; // test # out of totalTests
    unsigned short totalTests;
    char configSettings[0];
    };

struct ToLauncherData
    {
    DWORD titleID;
    unsigned __int64 numPass;
    unsigned __int64 numFail;
    char notes[0];
    };

struct DBDATA
    {
    char *deviceType;
    char *manufacturer;
    char *firmwareVersion;
    char *hardwareVersion;
    char *serialNumber;
    char *testName;
    char *variation;
    unsigned int status;
    unsigned __int64 numOperations;
    char *boxInformation;
    char *configSettings;
    char *notes;
    };

enum STOPAFTER_TYPES
    {
    STOPAFTER_MINUTES,
    STOPAFTER_HOURS,
    STOPAFTER_ITERATIONS,
    STOPAFTER_NEVER
    };

struct StopAfterSetting
    {
    unsigned duration;
    int type;           // STOPAFTER_TYPES

    // default values
    StopAfterSetting()
        {
        duration = 0;
        type = STOPAFTER_NEVER;
        }
    };

struct CoreConfigSettings
    {
    char resultsServer[128];
    char saveName[64];
    StopAfterSetting stopAfter;

    // default values
    CoreConfigSettings()
        {
        resultsServer[0] = '\0';
        strcpy(saveName, "Test Results");
        }
    };

// Save Game logging
void SetSaveName(char *saveName, char *fileName);
void LogPrint(char* format, ...);
void LogFlush(void);

// Sends the test entries to the web
DWORD PostResults(const char *url, const DBDATA *results);

// Retrieves the percentage of acceptable failres from the network
double GetAcceptanceCriteria(const char *url, const char* testName);

// Gathers various information about the system and software
char *GetBoxInformation(void);

// XLaunchNewImage wrapper (avoids restriction on matching title IDs)
void LaunchImage(char *xbe, LAUNCH_DATA *launchInfo);

// Misc Utilities
void DebugPrint(char* format, ...);
void DebugPrint(WCHAR* format, ...);
WCHAR* Ansi2UnicodeHack(char *str);
void HexDump(const unsigned char * buffer, DWORD length);
long GetNumber(char *string);
char* RightTrim(char *string);
WCHAR* RightTrim(WCHAR *string);

typedef void (*USERSETTING_FUNC)(char *variable, char *value, void *userParam);
void ParseConfigSettings(char *config, CoreConfigSettings *output, USERSETTING_FUNC LocalTestConfigs, void *userParam);

#endif // _HVSUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\utils\boxInfo.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    hvsUtils.cpp

Abstract:

    HVS Test Helper functions

Notes:

*****************************************************************************/

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <xbeimage.h>
extern "C"
    {
    #include <init.h>
    }
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

#include <xtl.h>
#include <stdio.h>

#include "hvsUtils.h"

extern "C"
    {
    DECLSPEC_IMPORT
    void
    WINAPI
    HalReadWritePCISpace(
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG RegisterNumber,
        IN PVOID Buffer,
        IN ULONG Length,
        IN BOOLEAN WritePCISpace
        );
    #define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
        HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );

    void*
    WINAPI
    MmMapIoSpace(
        IN ULONG_PTR PhysicalAddress,
        IN SIZE_T NumberOfBytes,
        IN ULONG Protect
        );

    void
    WINAPI
    MmUnmapIoSpace(
        IN PVOID BaseAddress,
        IN SIZE_T NumberOfBytes
        );
    }

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

FORCEINLINE ULONG REG_RD32(VOID* Ptr, ULONG Addr)
    {
    return *((volatile DWORD*)((BYTE*)(Ptr) + (Addr)));
    }

static DWORD WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

static DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }

static const char * const vmodes[] =
    {
    "SDTV SCART Analog/Digital",
    "HDTV",
    "VGA",
    "RFU",
    "SDTV Analog/Digital",
    "Power Off",
    "SDTV Analog",
    "No Pack",
    "SMC Error"
    };

static const char * const hwversions[] =
    {
    "Unknown",                  // 0
    "DVT3 (old metal)",         // 1
    "DVT3 (new metal)",         // 2
    "DVT4, DVT5, XDK2 (FAB F)", // 3
    "DVT6, XDK2 (FAB G/H)",     // 4
    "QT"                        // 5
    };

static const char * const lang[] = 
    {
    "Unknown",
    "English",
    "Japanese",
    "German",
    "French",
    "Spanish",
    "Italian"
    };

static const char * const videostd[] =
    {
    "Unknown",
    "NTSC_M",
    "NTSC_J",
    "PAL_I"
    };

enum MEDIA_TYPES
	{
	MEDIA_UNKNOWN,
	MEDIA_CDDA,
	MEDIA_CDROM,
	MEDIA_DVD_5_RO,
	MEDIA_DVD_5_RW,
	MEDIA_DVD_9_RO,
	MEDIA_DVD_9_RW,
	MEDIA_HD
	};

static const char *mediaTypeNames[] = 
    {
    "Unknown",
    "CD DA",
    "CD ROM",
    "DVD 5 RO",
    "DVD 5 RW",
    "DVD 9 RO",
    "DVD 9 RW",
    "Hard Disk"
    };

static char* GetHWVersion(unsigned char &hwver);
static void DumpClocks(char *buffer, unsigned hwver);
static void GetPeripheral(char *buffer);
static void GetDriveID(char* device, char* model, char* serial, char* firmware);
static DWORD GetDiskType(void);


/*****************************************************************************

Routine Description:

    GetBoxInformation

    Retrieves detailed information on the current box (hw and sw versions 
    etc.)

Arguments:

    none

Return Value:

    char* - newly allocated string

Notes:

    Caller MUST delete[] the returned pointer !!!

*****************************************************************************/
char *GetBoxInformation(void)
    {
    DWORD buffLen;
    bool multiple;
    char *info;
    char *boxInfo = new char[8*KILOBYTE];
    if(!boxInfo) return NULL;
    info = boxInfo;

    char *tempBuff = new char[KILOBYTE];
    if(!tempBuff)
        {
        delete[] boxInfo;
        return NULL;
        }

    // hw version
    unsigned char baseInitTable = 0;
    info += sprintf(info, "HW Ver = %s %s\n", GetHWVersion(baseInitTable), (XboxHardwareInfo->Flags&XBOX_HW_FLAG_DEVKIT_KERNEL)?"DEVKIT":"RETAIL");
    info += sprintf(info, "GPU Ver = %02X\n", XboxHardwareInfo->GpuRevision);
    info += sprintf(info, "MCP Ver = %02X\n", XboxHardwareInfo->McpRevision);

    // get SMC version
    tempBuff[0] = (char)ReadSMC(0x01);
    tempBuff[1] = (char)ReadSMC(0x01);
    tempBuff[2] = (char)ReadSMC(0x01);
    tempBuff[3] = '\0';
    info += sprintf(info, "SMC Ver = %s\n", tempBuff);

    // get clock speeds
    DumpClocks(tempBuff, baseInitTable);
    info += sprintf(info, "Clock Speeds = %s\n", tempBuff);

    // get memory information
    DWORD memTest = ReadSMC(0x14);
    #define NV_PEXTDEV_BOOT_0                                0x00101000 // private\windows\directx\dxg\d3d8\se\nv_ref_2a.h
    #define XPCICFG_GPU_MEMORY_REGISTER_BASE_0               0xFD000000 // private\ntos\inc\xpcicfg.h
    if((REG_RD32((void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PEXTDEV_BOOT_0) & 0x0000C0000) == 0)
        info += sprintf(info, "Memory Type = Micron\n");
    else
        info += sprintf(info, "Memory Type = Samsung\n");
    info += sprintf(info, "Memory Size = %s\n", ReadSMC(0x15)==1 ? "4 Meg chips" : "2 Meg chips");
    info += sprintf(info, "Memory Test = 0x%08X (%s)\n", memTest, memTest?"FAIL":"PASS");

    // get hard disk manufacturer
    memset(tempBuff, 0, KILOBYTE);
    GetDriveID("\\Device\\Harddisk0\\Partition0", tempBuff, tempBuff+384, tempBuff+768);
    info += sprintf(info, "HDD Info = %s, %s, %s\n", tempBuff, tempBuff+384, tempBuff+768);

    // get dvd drive information
    memset(tempBuff, 0, KILOBYTE);
    GetDriveID("\\Device\\CdRom0", tempBuff, tempBuff+384, tempBuff+768);
    info += sprintf(info, "DVD Info = %s, %s, %s\n", tempBuff, tempBuff+384, tempBuff+768);
    info += sprintf(info, "Media Type = %s\n", mediaTypeNames[GetDiskType()]);

    // hw flags "private/ntos/inc/init.h"
    tempBuff[0] = '\0';
    multiple=false;
    if(XboxHardwareInfo->Flags & XBOX_HW_FLAG_INTERNAL_USB_HUB)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "USB HUB");
        }
    if(XboxHardwareInfo->Flags & XBOX_480P_MACROVISION_ENABLED)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "480p");
        }
    info += sprintf(info, "HW Flags = %s\n", tempBuff);

    // language
    DWORD language = XGetLanguage();
    if(language >= ARRAYSIZE(lang)) language = 0;
    info += sprintf(info, "Language = %s\n", lang[language]);

    // game region
    DWORD region = XGetLanguage();
    if(region == XC_GAME_REGION_NA)
        info += sprintf(info, "Game Region = North America\n");
    else if(region == XC_GAME_REGION_JAPAN)
        info += sprintf(info, "Game Region = Japan\n");
    else if(region == XC_GAME_REGION_RESTOFWORLD)
        info += sprintf(info, "Game Region = Europe, etc.\n");
    else
        info += sprintf(info, "Game Region = Unknown\n");

    // av pack
    DWORD avpack = ReadSMC(0x04);
    if(avpack > 8) avpack = 8; // ReadSMC() can return 0xCCCCCCCC on error
    info += sprintf(info, "AV Pack = %s\n", vmodes[avpack]);

    // video standard
    DWORD vidStd = XGetVideoStandard();
    if(vidStd >= ARRAYSIZE(videostd)) vidStd = 0;
    info += sprintf(info, "Video Standard = %s\n", videostd[vidStd]);

    // get video flags
    DWORD vidFlags = XGetVideoFlags();
    multiple=false;
    tempBuff[0] = '\0';
    strcat(tempBuff, "(");
    if(vidFlags & XC_VIDEO_FLAGS_WIDESCREEN)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "WIDE");
        }
    if(vidFlags & XC_VIDEO_FLAGS_HDTV_720p)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "720p");
        }
    if(vidFlags & XC_VIDEO_FLAGS_HDTV_1080i)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "1080i");
        }
    if(vidFlags & XC_VIDEO_FLAGS_LETTERBOX)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "LETTERBOX");
        }
    if(vidFlags & XC_VIDEO_FLAGS_PAL_60Hz)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "PAL60Hz");
        }
    strcat(tempBuff, ")");
    info += sprintf(info, "Video Flags = %s\n", tempBuff);

    // get audio flags
    DWORD audioFlags = XGetAudioFlags();
    multiple=false;
    tempBuff[0] = '\0';
    if(audioFlags & XC_AUDIO_FLAGS_SURROUND)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "SURROUND");
        }
    if(audioFlags & XC_AUDIO_FLAGS_STEREO)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "STEREO");
        }
    if(audioFlags & XC_AUDIO_FLAGS_MONO)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "MONO");
        }
    if(audioFlags & XC_AUDIO_FLAGS_ENABLE_AC3)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "AC3");
        }
    if(audioFlags & XC_AUDIO_FLAGS_ENABLE_DTS)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "DTS");
        }
    info += sprintf(info, "Audio Flags = %s\n", tempBuff);

    // USB Devices
    tempBuff[0] = '\0';
    GetPeripheral(tempBuff);
    info += sprintf(info, "Peripherals = %s\n", tempBuff);

    // Kernel and library version
    info += sprintf(info, "ROM Version = %u %s\n", XboxKrnlVersion->Build, (!!(0x8000 & XboxKrnlVersion->Qfe))?"checked":"free");
    info += sprintf(info, "XTL Version = %u %s\n", XeImageHeader()->XapiLibraryVersion->BuildVersion, XeImageHeader()->XapiLibraryVersion->DebugBuild?"checked":"free");

    // SMC info
    info += sprintf(info, "CPU Temp = %d\n", ReadSMC(0x09));
    info += sprintf(info, "AIR Temp = %d\n", ReadSMC(0x0A));
    info += sprintf(info, "Fan = %d\n", ReadSMC(0x10));
    info += sprintf(info, "SMC Error = %d\n", ReadSMC(0x0F));


    delete[] tempBuff;
    return boxInfo;
    }






static DWORD GetDiskType(void)
    {
    DWORD type = MEDIA_UNKNOWN;
    #define ALIGN_DOWN(length, type)    ((ULONG)(length) & ~(sizeof(type) - 1))
    #define ALIGN_UP(length, type)      (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

    DWORD returned;
    NTSTATUS status;
    HANDLE handle;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitObjectString(&VolumeString, "\\Device\\CdRom0");
    InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(&handle,
                            SYNCHRONIZE|GENERIC_READ,
                            &ObjA,
                            &IoStatusBlock,
                            0,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_NONALERT);


    DVD_READ_STRUCTURE readStruct;
    UCHAR readStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) + sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];

    memset(&readStruct, 0, sizeof(DVD_READ_STRUCTURE));
    memset(readStructureOutput, 0, sizeof(readStructureOutput));

    // try DVD Read Structure
    readStruct.Format = DvdPhysicalDescriptor;

    returned = 0;
    BOOL result = DeviceIoControl(handle, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(DVD_READ_STRUCTURE), readStructureOutput, sizeof(readStructureOutput), &returned, NULL);

    NtClose(handle);

    if(result)
        {
        DVD_LAYER_DESCRIPTOR *layerDescr = (DVD_LAYER_DESCRIPTOR *)(&readStructureOutput[sizeof(DVD_DESCRIPTOR_HEADER)]);
        BYTE layerType = (layerDescr->BookType) | (layerDescr->BookVersion << 4);
        if(layerDescr->LayerType == 1)
            {
            if(layerDescr->NumberOfLayers == 0)
                type = MEDIA_DVD_5_RO;
            else type = MEDIA_DVD_9_RO;
            }
        else
            {
            if(layerDescr->NumberOfLayers == 0)
                type = MEDIA_DVD_5_RW;
            else type = MEDIA_DVD_9_RW;
            }
        }

    // not a DVD disk...
    else
        {
	    CDROM_TOC toc;
        memset(&toc, 0, sizeof(CDROM_TOC));
		result = DeviceIoControl( handle, IOCTL_CDROM_READ_TOC, &toc, sizeof(CDROM_TOC), &toc, sizeof(CDROM_TOC), &returned, NULL);
        if(result)
            {
            if(toc.FirstTrack == toc.LastTrack) type = MEDIA_CDROM;
            type = MEDIA_CDDA;
            }
        else
            {
            type = MEDIA_UNKNOWN;
            }
        }

    NtClose(handle);
    return type;
    }



static void DumpClocks(char *buffer, unsigned hwver)
    {
    #define NV_PRAMDAC_NVPLL_COEFF 0x00680500 /* RW-4R */
    const float F_XTAL_135 = 13.5f;
    const float F_XTAL_166 = 16.6667f;

    PCI_SLOT_NUMBER SlotNumber;
    DWORD MPLLCoeff;
    DWORD m;
    DWORD n;
    DWORD p;
    DWORD fsbspeed;
    DWORD vcofreq;
    DWORD nvclk;
    DWORD nvpll;
    DWORD fsb_pdiv;
    DWORD mem_pdiv;
    DWORD mclk;
    DWORD cpuspeed;
    float XTAL;

    if(hwver >= 0x46) 
        {
        XTAL = F_XTAL_166;
        }
    else
        {
        XTAL = F_XTAL_135;
        }

    //
    // Read CR_CPU_MPLL_COEFF 
    //
    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = 0;
    SlotNumber.u.bits.FunctionNumber = 3;
    HalReadPCISpace(0, SlotNumber.u.AsULONG, 0x6C, &MPLLCoeff, sizeof(MPLLCoeff));

    m = MPLLCoeff & 0xFF;
    n = (MPLLCoeff >> 8) & 0xFF;

    if(m != 0)
        {
        //
        // Calculate cpu frequency
        //
        fsbspeed = (DWORD)((XTAL / m) * n);

        cpuspeed = (DWORD)((XTAL / m) * n * 11 / 2);
    
        //
        // Calculate nvclk
        //
        nvpll = REG_RD32((void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PRAMDAC_NVPLL_COEFF);
        m = nvpll & 0xFF;
        n = (nvpll >> 8)  & 0xFF;
        p = (nvpll >> 16) & 0xFF;
    
        nvclk = (m != 0) ? (DWORD)((n * XTAL / (1 << p) / m)) : 0;
    
        //
        // Calculate vco
        //
        m = MPLLCoeff & 0xFF;
        n = (MPLLCoeff >> 8) & 0xFF;
        fsb_pdiv = (MPLLCoeff >> 16) & 0xF;
        
        vcofreq = (DWORD)((XTAL / m) * (fsb_pdiv * 2 * n));
    
        //
        // Calculate mclk
        //
        mem_pdiv = (MPLLCoeff >> 20) & 0xF;
        mclk = (DWORD)(vcofreq / (2 * mem_pdiv));

        sprintf(buffer, "Crystal=%s, FSB=%d, CPU=%d, NVCLK=%d, VCO=%d, MCLK=%d",
            (hwver >= 0x46) ? "16.6" : "13.5", fsbspeed, cpuspeed, nvclk, vcofreq, mclk);
        }
    else
        {
        sprintf(buffer, "unknown");
        }
    }

static char* GetHWVersion(unsigned char &hwver)
    {
    #define PAGE_SIZE                   4096
    #define ROM_SIZE                    (1024 * 1024)
    #define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
    #define ROM_VERSION_BYTE_OFFSET     0x78
    #define FLASH_BASE_ADDRESS          0xFFF00000
    #define FLASH_REGION_SIZE           (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

    LPBYTE RomBase = (LPBYTE)MmMapIoSpace(FLASH_BASE_ADDRESS, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE);

    if(RomBase == NULL) return (char*)hwversions[0];

    hwver = (unsigned char)(RomBase[ROM_VERSION_BYTE_OFFSET] & 0xFF);

    MmUnmapIoSpace(RomBase, PAGE_SIZE);

    //
    // Init table version < 0x40: Old DVT 3 Boxes with NV2A A02 old metal 7 (NVCLK 155, CPU 665)
    // Init table version = 0x40: New DVT 3 Boxes with NV2A A02 new metal 7 (Faster)
    // Init table version = 0x46: DVT4, DVT5, XDK2 (FAB F)
    // Init table version = 0x60: DVT6+, XDK2 (FAB G/H)
    // Init table version = 0x70: QT (MCP C03)
    // (private\ntos\recovery\recovery.cpp)
    //
    //DebugPrint("hwver: 0x%X\n", hwver);

    if(hwver <  0x40) return (char*)hwversions[1];
    if(hwver == 0x40) return (char*)hwversions[2];
    if(hwver == 0x46) return (char*)hwversions[3];
    if(hwver == 0x60) return (char*)hwversions[4];
    if(hwver == 0x70) return (char*)hwversions[5];
    return (char*)hwversions[0];
    }

static void GetPeripheral(char *buffer)
    {
    DWORD XIDMasks[] = {
        XDEVICE_PORT0_MASK,
        XDEVICE_PORT1_MASK,
        XDEVICE_PORT2_MASK,
        XDEVICE_PORT3_MASK
        };
    DWORD XMUMasks[] = {
        XDEVICE_PORT0_TOP_MASK,
        XDEVICE_PORT1_TOP_MASK,
        XDEVICE_PORT2_TOP_MASK,
        XDEVICE_PORT3_TOP_MASK,
        XDEVICE_PORT0_BOTTOM_MASK,
        XDEVICE_PORT1_BOTTOM_MASK,
        XDEVICE_PORT2_BOTTOM_MASK,
        XDEVICE_PORT3_BOTTOM_MASK
        };
    DWORD insertions, insertions2;
    unsigned i;
    unsigned port, slot;

    buffer[0] = '\0';

    bool dukeMask[4] = { false, false, false, false }; // Duke zeros bug

    // look for dukes
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "Duke(%d); ", port);
            dukeMask[port] = true;
            }
        }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            buffer+=sprintf(buffer, "MU(%d, %d); ", port, slot);
            }
        }

    /*
    // check for hawks
    insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    //insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            buffer+=sprintf(buffer, "Hawk(%d, %d); ", port, slot);
            }
        }
        */

    // look for dvd dongle
    /* 
    insertions = XGetDevices(XDEVICE_TYPE_IR_REMOTE);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i % XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "DVD(%d); ", port);
            }
        }
    */

    // look for keyboard
    #ifdef DEBUG_KEYBOARD
    insertions = XGetDevices(XDEVICE_TYPE_DEBUG_KEYBOARD);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i % XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "Keyboard(%d); ", port);
            }
        }
    #endif // DEBUG_KEYBOARD

    }


static void GetDriveID(char* device, char* model, char* serial, char* firmware)
    {
    char *temp;
    unsigned i;
    DWORD returned;
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;


    RtlInitObjectString(&VolumeString, device);
    InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    status = NtCreateFile(&fileHandle,
                            SYNCHRONIZE|GENERIC_READ,
                            &ObjA,
                            &IoStatusBlock,
                            0,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_NONALERT);

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(strstr(device, "CdRom") != NULL) atapt->IdeReg.bCommandReg = 0xa1;
    else atapt->IdeReg.bCommandReg = 0xec;

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             FALSE);
    NtClose(fileHandle);

    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for ( i=0; i<sizeof(IdData->ModelNumber); i+=2 ) {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
    }
    model[i] = '\0';
    temp = strstr(model, "  ");
    if(temp) *temp = '\0';

    for ( i=0; i<sizeof(IdData->SerialNumber); i+=2 ) {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
    }
    serial[i] = '\0';
    temp = strstr(serial, "  ");
    if(temp) *temp = '\0';

    for ( i=0; i<sizeof(IdData->FirmwareRevision); i+=2 ) {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
    }
    firmware[i] = '\0';
    temp = strstr(firmware, "  ");
    if(temp) *temp = '\0';
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\utils\launch.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    launch.cpp

Abstract:

    HVS Test Helper functions

Notes:

*****************************************************************************/

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xbeimage.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

#include <xtl.h>
#include <stdio.h>
#include "hvsUtils.h"


/*****************************************************************************

Routine Description:

    LaunchImage

    Wrapper for XLaunchNewImage, which allows us to pass LAUNCH_DATA to an
    xbe that does not have the same title ID as the caller's ID.

Arguments:

    char *xbe       - full path to the new xbe
    LAUNCH_DATA     - info to pass

Return Value:

    none - this function will NOT RETURN

*****************************************************************************/
void LaunchImage(char *xbe, LAUNCH_DATA *launchInfo)
    {
    if(xbe)
        {
        FILE *f = fopen(xbe, "rb");
        if(f)
            {
            // read the title ID from the destination XBE
            unsigned char image[512];
            _XBEIMAGE_HEADER *h = (_XBEIMAGE_HEADER*)image;
            if(fread(image, 1, 512, f) != 512)
                {
                OutputDebugStringA("Reading of target image failed...\n");
                }

            // XLaunchNewImage looks at our images' title ID.
            // So we spoof it to make it look like we are the destination
            XeImageHeader()->Certificate->TitleID = *(DWORD*)&image[0x180];

            fclose(f);
            }
        }

    // Now we can pass LAUNCH_DATA to the XBE with a different title ID
    XLaunchNewImage(xbe, launchInfo);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\datamask.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  datamask.h

Abstract:

  This module contains the definitions for datamask.lib

Author:

  Steven Kehrli (steveke) 4-Jan-2002

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/



#ifndef _DATAMASK_H
#define _DATAMASK_H



#ifdef _XBOX
#include <xtl.h>
#else  // XBOX
#include <windows.h>
#endif // XBOX



#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus



VOID
WINAPI
DataMask(
    BYTE  *pBuffer,
    UINT  nBufferSize
);



#ifdef __cplusplus
}
#endif // __cplusplus



#endif // _DATAMASK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\covermon.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    covermon.h

Abstract:

    This module contains routine to poll coverage data logging

Environment:

    Xbox

Revision History:

--*/

#ifndef __COVERMON_H__
#define __COVERMON_H__


#ifdef __cplusplus
extern "C" {
#endif


//
// These are exported from covermon.dll
//

DWORD
WINAPI
CovMonInternalCloseLogFileAllBinaries(
    VOID
    );


DWORD
WINAPI
CovMonInternalPollLoggingAllBinaries(
    LPCSTR TestName
    );


BOOL
WINAPI
CovMonRegisterNoImportCoverageBinary(
    HANDLE ImageBase
    );


BOOL
WINAPI
CovMonRegisterAllNoImportCoverageBinaries(
    VOID
    );


#ifdef __cplusplus
}
#endif


#endif // __COVERMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\utils\logging.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    logging.cpp

Abstract:

    HVS Test Helper functions

Notes:

*****************************************************************************/

#include <stdio.h>
#include <xtl.h>
#include <crtdbg.h>

#include "hvsUtils.h"

// private kernel API
extern "C" void FlushDiskCache(void);

static void FindSaveGame(void);


/*****************************************************************************

Routine Description:

    SetSaveName

    Sets the filename and Save Game Name for the log file. This function 
    MUST be called prior to calling LogPrint or LogFlush.

Arguments:

    char *format,
    ...

Return Value:

    none

*****************************************************************************/
static char *logFilename = NULL;
static XGAME_FIND_DATA saveGameData;
static WCHAR saveGameName[MAX_GAMENAME];
static char saveFileName[128];
static bool saveNameSet = false;
void SetSaveName(char *saveName, char *fileName)
    {
    saveNameSet = true;

    strcpy((char*)saveGameName, saveName);
    Ansi2UnicodeHack((char*)saveGameName);

    strcpy(saveFileName, fileName);
    }


/*****************************************************************************

Routine Description:

    LogPrint

    Writes data to the debugger and a log file save game using printf style
    symantics.

Arguments:

    char *format,
    ...

Return Value:

    none

*****************************************************************************/
void LogPrint(char* format, ...)
    {
    if(!format) return;

    if(saveNameSet == false)
        {
        _ASSERT(0 && "Must call SetSaveName() prior to calling LogPrint()");
        }

    char *szBuffer = new char[1024*1024];
    DWORD err = GetLastError(); // we dont want LogPrint to tromp on the last error

    va_list args;
    va_start(args, format);

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    if(!logFilename)
        {
        FindSaveGame();
        }

    FILE *f = fopen(logFilename, "a+");
    if(f)
        {
        fprintf(f, "%s", szBuffer);
        fclose(f);
        FlushDiskCache();
        }

    va_end(args);

    delete[] szBuffer;
    SetLastError(err);
    }

/*****************************************************************************

Routine Description:

    LogFlush

    Deletes the log file

Arguments:

    none

Return Value:

    none

*****************************************************************************/
void LogFlush(void)
    {
    if(saveNameSet == false)
        {
        _ASSERT(0 && "Must call SetSaveName() prior to calling LogFlush()");
        }

    if(!logFilename)
        {
        FindSaveGame();
        }

    // remove old copy of file
    DeleteFile(logFilename);
    FlushDiskCache();
    }


/*****************************************************************************

Routine Description:

    FindSaveGame

    Private API

*****************************************************************************/
static void FindSaveGame(void)
    {
    HANDLE h = XFindFirstSaveGame("U:\\", &saveGameData);
    while(h != INVALID_HANDLE_VALUE)
        {
        if(wcscmp(saveGameData.szSaveGameName, saveGameName) == 0)
            {
            logFilename = saveGameData.szSaveGameDirectory;
            strcat(logFilename, saveFileName);
            XFindClose(h);
            return;
            }

        if(!XFindNextSaveGame(h, &saveGameData)) break;
        }

    if(h != INVALID_HANDLE_VALUE) XFindClose(h);

    // create a new save game
    logFilename = saveGameData.szSaveGameDirectory;
    XCreateSaveGame("U:\\", saveGameName, OPEN_ALWAYS, 0, logFilename, MAX_PATH);
    strcat(logFilename, saveFileName);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\debug.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2002 by Microsoft Corporation.

Module Name:

  debug.h

Abstract:

  This header contains useful debug macros and other aids.  Adapted from xn.h.

Author:

  David Hefner (2-7-2002)

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#pragma once

#ifdef _XBOX

#ifndef __cplusplus
#error "debug.h must only be included by a C++ file"
#endif

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define INLINE __forceinline

#if DBG
#define IFDBG(x)    x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)   x
#endif

// ---------------------------------------------------------------------------------------
// Asserts
// ---------------------------------------------------------------------------------------

INLINE void DbgBreak()
{
    _asm int 3;
}

#ifdef XNET_FEATURE_ASSERT
#ifdef _XBOX
#define DbgAssert(expr,file,line,msg) RtlAssert((PVOID)((msg)?(msg):(expr)),file,line,NULL)
#else
int DbgAssertPop(const char * pszExpr, const char * pszFile, int iLine, const char * pszMsg);
#define DbgAssert(expr,file,line,msg) do { if (DbgAssertPop(expr,file,line,msg)) { DbgBreak(); } } while (0)
#endif
char * __cdecl DbgAssertFmt(char const * pszFmt, ...);
#define ASSERT_BEG(x)   do { if (!(x)) { char * __pch__ = DbgAssertFmt(
#define ASSERT_END(x)   ); DbgAssert(#x,__FILE__,__LINE__,__pch__); } } while (0)
#define Assert(x) \
        do { if (!(x)) { DbgAssert(#x,__FILE__,__LINE__,NULL); } } while (0)
#define AssertSz(x,sz) \
        ASSERT_BEG(x) sz ASSERT_END(x)
#define AssertSz1(x,sz,a1) \
        ASSERT_BEG(x) sz,a1 ASSERT_END(x)
#define AssertSz2(x,sz,a1,a2) \
        ASSERT_BEG(x) sz,a1,a2 ASSERT_END(x)
#define AssertSz3(x,sz,a1,a2,a3) \
        ASSERT_BEG(x) sz,a1,a2,a3 ASSERT_END(x)
#define AssertSz4(x,sz,a1,a2,a3,a4) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4 ASSERT_END(x)
#define AssertSz5(x,sz,a1,a2,a3,a4,a5) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5 ASSERT_END(x)
#define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6 ASSERT_END(x)
#define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7 ASSERT_END(x)
#define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8 ASSERT_END(x)
#define AssertSz9(x,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 ASSERT_END(x)
#define AssertList(ple) \
        do { const char * __psz__ = DbgVerifyList(ple,NULL); \
        if (__psz__) { DbgAssert("AssertList("#ple")",__FILE__,__LINE__,__psz__); } } while (0)
#define AssertListEntry(ple,pleReq) \
        do { const char * __psz__ = DbgVerifyList(ple,pleReq); \
        if (__psz__) { DbgAssert("AssertListEntry("#ple","#pleReq")",__FILE__,__LINE__,__psz__); } } while (0)
#else
#define Assert(x)
#define AssertSz(x,sz)
#define AssertSz1(x,sz,a1)
#define AssertSz2(x,sz,a1,a2)
#define AssertSz3(x,sz,a1,a2,a3)
#define AssertSz4(x,sz,a1,a2,a3,a4)
#define AssertSz5(x,sz,a1,a2,a3,a4,a5)
#define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6)
#define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7)
#define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8)
#define AssertSz9(x,sz, a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define AssertList(ple)
#define AssertListEntry(ple,pleReq)
#endif

#undef  ASSERT
#define ASSERT(x)   Assert(x)

// ---------------------------------------------------------------------------------------
// Traces
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE
void __cdecl DbgTrace(const char * szTag, const char * szFmt, ...);
#ifdef XNET_FEATURE_XBDM_SERVER
#define Tag(t)  m_##t
#else
#define Tag(t)  t_##t
#endif
#if defined(_XBOX) || !defined(__cplusplus)
#define TAGINIT(t)
#else
class CTagInit { public: CTagInit(int * pi, const char * pszTag); int i; };
#define TAGINIT(t)          ; CTagInit __init__##t(&Tag(t),#t)
#endif
#define TAG_ENABLE      1
#define TAG_BREAK       2
#define DefineTag(t,i)      int Tag(t) = i TAGINIT(t)
#define ExternTag(t)        extern int Tag(t)
#define TRACE_BEG(t)        do { if (Tag(t) > 0) { DbgTrace(#t,
#define TRACE_END(t)        ); if (Tag(t) > 1) DbgBreak(); } } while (0)
#define TraceSz(t,sz) \
        TRACE_BEG(t) sz TRACE_END(t)
#define TraceSz1(t,sz,a1) \
        TRACE_BEG(t) sz,a1 TRACE_END(t)
#define TraceSz2(t,sz,a1,a2) \
        TRACE_BEG(t) sz,a1,a2 TRACE_END(t)
#define TraceSz3(t,sz,a1,a2,a3) \
        TRACE_BEG(t) sz,a1,a2,a3 TRACE_END(t)
#define TraceSz4(t,sz,a1,a2,a3,a4) \
        TRACE_BEG(t) sz,a1,a2,a3,a4 TRACE_END(t)
#define TraceSz5(t,sz,a1,a2,a3,a4,a5) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5 TRACE_END(t)
#define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6 TRACE_END(t)
#define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7 TRACE_END(t)
#define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8 TRACE_END(t)
#define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 TRACE_END(t)
#define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 TRACE_END(t)
#define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11 TRACE_END(t)
#define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12 TRACE_END(t)
#define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13 TRACE_END(t)
#define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14 TRACE_END(t)
#define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15 TRACE_END(t)
#define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 TRACE_END(t)
#else
#define DefineTag(t,i)
#define ExternTag(t)
#define TraceSz(t,sz)
#define TraceSz1(t,sz,a1)
#define TraceSz2(t,sz,a1,a2)
#define TraceSz3(t,sz,a1,a2,a3)
#define TraceSz4(t,sz,a1,a2,a3,a4)
#define TraceSz5(t,sz,a1,a2,a3,a4,a5)
#define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6)
#define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7)
#define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8)
#define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
#define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
#define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)
#define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)
#define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)
#define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
#define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)
#endif

ExternTag(Warning);
ExternTag(Verbose);

// ---------------------------------------------------------------------------------------
// Rip
// ---------------------------------------------------------------------------------------

#ifdef _XBOX
#define Rip(sz) RIP(sz)
#elif defined(XNET_FEATURE_ASSERT)
#define Rip(sz) AssertSz1(0, "RIP: %s", sz)
#else
#define Rip(sz) { DbgPrint("%s", sz); DbgBreak(); }
#endif


// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

char * HexStr(const void * pv, size_t cb);

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

#define CBDHG1 96
extern "C" const BYTE g_abOakleyGroup1Mod[CBDHG1];
extern "C" const BYTE g_abOakleyGroup1Base[CBDHG1];



#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\dxconio.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    dxconio.h

*******************************************************************************/

#ifndef __DXCONIO_H__
#define __DXCONIO_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#define DXCIOAPI __cdecl

#ifndef _XBOX

#if !defined(_DXCONIO_EXPORT_)
#define DXCONIOAPI __declspec(dllimport)
#else
#define DXCONIOAPI __declspec(dllexport)
#endif

#else

#define DXCONIOAPI

#endif // XBOX

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define MAX_TCHAR_OUTPUT        4096

#define CHAR_ASPECT             1.875f

#define XSCROLL_LINEUP          0x0001
#define XSCROLL_LINELEFT        0x0002
#define XSCROLL_LINEDOWN        0x0004
#define XSCROLL_LINERIGHT       0x0008
#define XSCROLL_PAGEUP          0x0010
#define XSCROLL_PAGELEFT        0x0020
#define XSCROLL_PAGEDOWN        0x0040
#define XSCROLL_PAGERIGHT       0x0080
#define XSCROLL_TOP             0x0100
#define XSCROLL_LEFT            0x0200
#define XSCROLL_BOTTOM          0x0400
#define XSCROLL_RIGHT           0x0800
#define XSCROLL_HORZ            0x1000
#define XSCROLL_VERT            0x2000

#define RGBA_XCOLOR(r, g, b, a) ((XCOLOR)(((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

//******************************************************************************
// Data types
//******************************************************************************

typedef DWORD                   XCOLOR;

//******************************************************************************
// stdio functions
//******************************************************************************

// xprintf, xwprintf, and xtprintf

DXCONIOAPI
int
DXCIOAPI
xprintf(
    const char *, 
    ...
);
DXCONIOAPI
int
DXCIOAPI
xwprintf(
    const wchar_t *,
    ...
);
#ifndef UNICODE
#define xtprintf            xprintf
#else
#define xtprintf            xwprintf
#endif // UNICODE

// xvprintf, xvwprintf, and xvtprintf

DXCONIOAPI
int
DXCIOAPI
xvprintf(
    const char *,
    va_list
);
DXCONIOAPI
int
DXCIOAPI
xvwprintf(
    const wchar_t *,
    va_list
);
#ifndef UNICODE
#define xvtprintf           xvprintf
#else
#define xvtprintf           xvwprintf
#endif // UNICODE

// xputchar, xputwchar, and xputtchar

DXCONIOAPI
int
DXCIOAPI
xputchar(
    int
);
DXCONIOAPI
wint_t
DXCIOAPI
xputwchar(
    wint_t
);
#ifndef UNICODE
#define xputtchar           xputchar
#else
#define xputtchar           xputwchar
#endif // UNICODE

// xputs, xputws, and xputts

DXCONIOAPI
int
DXCIOAPI
xputs(
    const char *
);
DXCONIOAPI
int
DXCIOAPI
xputws(
    const wchar_t *
);
#ifndef UNICODE
#define xputts              xputs
#else
#define xputts              xputws
#endif // UNICODE

//******************************************************************************
// Console management functions
//******************************************************************************

// xCreateConsole

DXCONIOAPI
BOOL
DXCIOAPI
xCreateConsole(
    LPVOID pvDevice
);

// xReleaseConsole

DXCONIOAPI
void
DXCIOAPI
xReleaseConsole(
    void
);

// xClearScreen

DXCONIOAPI
void
DXCIOAPI
xClearScreen(
    void
);

// xSetFontA, xSetFontW, and xSetFont

DXCONIOAPI
void
DXCIOAPI
xSetFontA(
    float  fWidth,
    float  fHeight,
    LPCSTR pszFace
);
DXCONIOAPI
void
DXCIOAPI
xSetFontW(
    float   fWidth,
    float   fHeight,
    LPCWSTR pszFace
);
#ifndef UNICODE
#define xSetFont xSetFontA
#else
#define xSetFont xSetFontW
#endif // UNICODE

// xSetTextColor

DXCONIOAPI
XCOLOR
DXCIOAPI
xSetTextColor(
    BYTE red, 
    BYTE green, 
    BYTE blue, 
    BYTE alpha
);

// xSetBackgroundColor

DXCONIOAPI
XCOLOR
DXCIOAPI
xSetBackgroundColor(
    BYTE red,
    BYTE green,
    BYTE blue,
    BYTE alpha
);

// xSetBackgroundImageA, xSetBackgroundImageW, and xSetBackgroundImage

DXCONIOAPI
BOOL
DXCIOAPI
xSetBackgroundImageA(
    LPCSTR pszImage
);
DXCONIOAPI
BOOL
DXCIOAPI
xSetBackgroundImageW(
    LPCWSTR pszImage
);
#ifndef UNICODE
#define xSetBackgroundImage xSetBackgroundImageA
#else
#define xSetBackgroundImage xSetBackgroundImageW
#endif // UNICODE

// xScrollConsoleX

DXCONIOAPI
void
DXCIOAPI
xScrollConsole(
    DWORD  dwScroll,
    float* pfHorz,
    float* pfVert
);

// xSetOutputBufferSize

DXCONIOAPI
BOOL
DXCIOAPI
xSetOutputBufferSize(
    UINT uBytes
);

// xSetDisplayWidth

DXCONIOAPI
BOOL
DXCIOAPI
xSetDisplayWidth(
    UINT uWidth
);

// xDisplayConsole

DXCONIOAPI
void
DXCIOAPI
xDisplayConsole(
    void
);

// xResetConsole

DXCONIOAPI
BOOL
DXCIOAPI
xResetConsole(
    void
);

// xTextOutA, xTextOutW, and xTextOut

DXCONIOAPI
BOOL
DXCIOAPI
xTextOutA(
    float   fXStart,
    float   fYStart,
    float   fCWidth,
    float   fCHeight,
    XCOLOR  xcColor,
    LPCSTR  pszString,
    UINT    uCount
);
DXCONIOAPI
BOOL
DXCIOAPI
xTextOutW(
    float   fXStart,
    float   fYStart,
    float   fCWidth,
    float   fCHeight,
    XCOLOR  xcColor,
    LPCWSTR pszString,
    UINT    uCount
);
#ifndef UNICODE
#define xTextOut            xTextOutA
#else
#define xTextOut            xTextOutW
#endif // UNICODE

// xDebugStringA, xDebugStringW, and xDebugString

DXCONIOAPI
void
DXCIOAPI
xDebugStringA(
    LPCSTR pszFormat,
    ...
);
DXCONIOAPI
void
DXCIOAPI
xDebugStringW(
    LPCWSTR pszFormat, 
    ...
);
#ifndef UNICODE
#define xDebugString        xDebugStringA
#else
#define xDebugString        xDebugStringW
#endif // UNICODE

//******************************************************************************
// stdio overrides
//******************************************************************************

#ifdef  printf
#undef  printf
#endif // printf
#define printf                  xprintf

#ifdef  wprintf
#undef  wprintf
#endif // wprintf
#define wprintf                 xwprintf

#ifdef  _tprintf
#undef  _tprintf
#endif // _tprintf
#define _tprintf                xtprintf

#ifdef  vprintf
#undef  vprintf
#endif // vprintf
#define vprintf                 xvprintf

#ifdef  vwprintf
#undef  vwprintf
#endif // vwprintf
#define vwprintf                xvwprintf

#ifdef  _vtprintf
#undef  _vtprintf
#endif // _vtprintf
#define _vtprintf               xvtprintf

#ifdef  putchar
#undef  putchar
#endif // putchar
#define putchar                 xputchar

#ifdef  putwchar
#undef  putwchar
#endif // putwchar
#define putwchar                xputwchar

#ifdef  _puttchar
#undef  _puttchar
#endif // _puttchar
#define _puttchar               xputtchar

#ifdef  puts
#undef  puts
#endif // puts
#define puts                    xputs

#ifdef  _putws
#undef  _putws
#endif // _putws
#define _putws                  xputws

#ifdef  _putts
#undef  _putts
#endif // _puttchar
#define _putts                  xputts

//******************************************************************************
// Debug output overrides
//******************************************************************************

#ifndef DXCONIO_NO_OVERRIDES

#undef  OutputDebugString
#define OutputDebugString(x)    xDebugString(TEXT("%s"), x)

#endif // !DXCONIO_NO_OVERRIDES

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DXCONIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hvs\utils\posts.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    posts.cpp

Abstract:

    HVS Test Helper functions

Notes:

*****************************************************************************/

#include <stdio.h>
#include <xtl.h>
#include <xbeimage.h>
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

#include "hvsUtils.h"

static int POSTEncode(char *dest, const char *source);
static DWORD POST(const char *server, char *post, DWORD &dataLen, DWORD maxRecvSize);



/*****************************************************************************

Routine Description:

    PostResults

    Sends the DBDATA information as an HTTP POST to a web server where it
    will get entered into a database.

Arguments:

    char *url
    const DBDATA *results

Return Value:

    DWORD - error code

*****************************************************************************/
DWORD PostResults(const char *url, const DBDATA *results)
    {
    if(!url || !results) return 0;

    char *postData = new char[128*KILOBYTE];
    if(!postData) return 0;

    char fullURL[256];
    sprintf(fullURL, "%sxbox/postResults.asp", url);

    char *post = postData;

    XNADDR xnaddr;
    UINT iTimeout = 500;    // Five seconds maximum just in case
    memset(&xnaddr, 0, sizeof(xnaddr));
    while (XNetGetTitleXnAddr(&xnaddr) == 0 && iTimeout-- > 0) Sleep(10);

    post += sprintf(post, "macAddr=%02X-%02X-%02X-%02X-%02X-%02X", xnaddr.abEnet[0], xnaddr.abEnet[1], xnaddr.abEnet[2], xnaddr.abEnet[3], xnaddr.abEnet[4], xnaddr.abEnet[5]);

    post += sprintf(post, "&devType=");
    post += POSTEncode(post, results->deviceType);

    post += sprintf(post, "&mfg=");
    post += POSTEncode(post, results->manufacturer);

    post += sprintf(post, "&fw=");
    post += POSTEncode(post, results->firmwareVersion);

    post += sprintf(post, "&hw=");
    post += POSTEncode(post, results->hardwareVersion);

    post += sprintf(post, "&sn=");
    post += POSTEncode(post, results->serialNumber);

    post += sprintf(post, "&test=");
    post += POSTEncode(post, results->testName);

    post += sprintf(post, "&variation=");
    post += POSTEncode(post, results->variation);

    post += sprintf(post, "&status=%u", results->status);
    post += sprintf(post, "&numOps=%I64u", results->numOperations);

    post += sprintf(post, "&boxInfo=");
    post += POSTEncode(post, results->boxInformation);

    post += sprintf(post, "&testConfig=");
    post += POSTEncode(post, results->configSettings);

    post += sprintf(post, "&notes=");
    post += POSTEncode(post, results->notes);

    DWORD postLen = post-postData;

    DWORD err = POST(fullURL, postData, postLen, 128*KILOBYTE);
    //LogPrint("%s\n", postData);
    //LogPrint("****************************************************************************\n");
    //LogPrint("****************************************************************************\n");
    //LogPrint("****************************************************************************\n");
    //LogPrint("****************************************************************************\n");

    delete[] postData;
    return 0;
    }



/*****************************************************************************

Routine Description:

    GetAcceptanceCriteria

    Retrieves the percentage of acceptable failres for the given test

Arguments:

    char* testName

Return Value:

    double

*****************************************************************************/
double GetAcceptanceCriteria(const char *url, const char* testName)
    {
    if(!url || !testName) return 0.0;

    double result = 0.0;
    char *postData = new char[4*KILOBYTE];
    char *post = postData;

    char fullURL[256];
    sprintf(fullURL, "%sxbox/getCriteria.asp", url);

    post += sprintf(post, "test=");
    post += POSTEncode(post, testName);

    DWORD postLen = post-postData;
    DWORD err = POST(url, postData, postLen, 4*KILOBYTE);

    char *criteria = strstr(postData, "Criteria:");
    if(criteria)
        {
        criteria += 9;
        result = atof(criteria);
        }

    delete[] postData;
    return result;
    }


/*****************************************************************************

Routine Description:

    POSTEncode

    PRIVATE API

    Removes special characters and replaces them with HTTP escape codes

Arguments:

    char* dest
    char* source

Return Value:

    int

*****************************************************************************/
static int POSTEncode(char *dest, const char *source)
    {
    if(dest == source) return 0;
    if(!dest || !source) return 0;

    // NOTE: the restricted characters are defined in the URI RFC 
    //       (current ver: 2396) in section 2.

    char *restricted = ";/?:@&=+$,\"#%%<>\\~\r\n\t";
    char buff[10];

    int i;

    for(i=0; *source; source++, i++)
        {
        if(strchr(restricted, *source) != NULL)
            {
            sprintf(buff, "%02X", (unsigned)(*source));
            dest[i] = (char)'%%';    ++i;
            dest[i] = buff[0]; ++i;
            dest[i] = buff[1]; 
            }
        else if(*source == ' ')
            {
            dest[i] = '+';
            }
        else
            {
            dest[i] = *source;
            }
        }

    dest[i] = '\0';
    return i;
    }


/*****************************************************************************

Routine Description:

    POST

    PRIVATE API

    Sends an HTTP POST to a web server

Arguments:

    char* server - "http://ipaddr/url" (ipaddr must be an IP address)
    char* post - post data
    DWORD dataLen - length of the postData, on return will contain the length 
        of any data received.
    DWORD maxRecvSize maximum size of the post buffer, if 0 no data will
        be returned from the server.

Return Value:

    DWORD

*****************************************************************************/
static DWORD POST(const char *server, char *post, DWORD &dataLen, DWORD maxRecvSize)
    {
    //DebugPrint("POST(%s, data, %u, %u)\n", server, dataLen, maxRecvSize);

    if(strncmp(server, "http://", 7) != 0)
        return 0;

    char *data = new char[dataLen+512];
    if(!data)
        return 0;

    // parse out the ip address and the path/filename
    char serverIP[25];
    const char *url = strchr(server+8, '/');
    strncpy(serverIP, server+7, url - (server+7));
    serverIP[url - (server+7)] = '\0';

    // intiailize the socket
    SOCKET sock = socket(PF_INET, SOCK_STREAM, 0);
    SOCKADDR_IN dest;
    dest.sin_family = PF_INET;
    dest.sin_port = htons(80);
    dest.sin_addr.s_addr = inet_addr(serverIP);

    if(connect(sock, (SOCKADDR*)&dest, sizeof(SOCKADDR)) == SOCKET_ERROR)
        {
        DebugPrint("HVS: connect error: (ec: %u)\n", GetLastError());
        dataLen = 0;
        }
    else
        {
        unsigned postLen;

        // turn off the time wait delay after closing the socket
        linger noTimeWait = { true, 0 };
        setsockopt(sock, SOL_SOCKET, SO_LINGER, (char*)&noTimeWait, sizeof(noTimeWait));

        postLen = sprintf(data,
                        "POST %s HTTP/1.1\r\n"
                        "Host: %s\r\n"
                        "Accept: */*\r\n"
                        "User-Agent: HVS Test\r\n"
                        "TitleID: 0x%08X\r\n"
                        "Connection: Close\r\n"
                        "Content-Length: %u\r\n"
                        "Content-Type: application/x-www-form-urlencoded\r\n"
                        "\r\n"
                        "%s",
                        url,
                        serverIP,
                        XeImageHeader()->Certificate->TitleID,
                        dataLen,
                        post);

        //
        // send the post
        //
        //LogPrint("****************************************************************************\n");
        //LogPrint("****************************************************************************\n");
        //LogPrint("****************************************************************************\n");
        //LogPrint("****************************************************************************\n");
        //LogPrint("%s", data);
        DWORD err = send(sock, data, postLen, 0);

        //
        // try to receive data (if necessary)
        //
        if(maxRecvSize)
            {
            dataLen = recv(sock, post, maxRecvSize, 0);
            post[dataLen] = '\0';
            if(strstr(post, "100 Continue"))
                {
                dataLen = recv(sock, post, maxRecvSize, 0);
                post[dataLen] = '\0';
                }
            }
        else
            {
            // caller doesnt want any data from the server
            dataLen = 0;
            }

        shutdown(sock, SD_BOTH);
        }

    delete[] data;
    closesocket(sock);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\guidgen.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  guidgen.h

Abstract:

  This module contains the definitions for guidgen.dll

Author:

  Steven Kehrli (steveke) 30-Nov-2000

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#ifndef _GUIDGEN_H
#define _GUIDGEN_H

#include <xtl.h>



#ifdef __cplusplus
extern "C" {
#endif



// Function Prototypes

HRESULT
xCreateGUID(
    OUT GUID  *Guid
);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\harnessapi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    harnessapi.h

Abstract:

    This module contains definition of APIs exported from test harness

--*/


#ifndef __HARNESSAPI_H__
#define __HARNESSAPI_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL
WINAPI
RunTestA(
    SOCKET  socket,
    LPCSTR  TestName
    );

BOOL
WINAPI
RunTestW(
    SOCKET  socket,
    LPCWSTR TestName
    );

BOOL
WINAPI
Shutdown(
    SOCKET socket,
    ULONG  Reserved
    );

#if defined(UNICODE) || defined(_UNICODE)
#define RunTest RunTestW
#else
#define RunTest RunTestA
#endif

#ifdef __cplusplus
}
#endif

#endif // __HARNESSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\launcher.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    launcher.h

Abstract:

    Public launcher header

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    07-31-2000  Created

*/
#ifndef _LAUNCHER_H_
#define _LAUNCHER_H_

#include <winsockx.h>


/*

Routine Description:

    SockPrint

    Formatted print function that sends the output through a connected SOCKET.

Arguments:

    SOCKET sock - connected socket
    char* format - printf style format specifier
    ... - arguments specified by the format specifier

Return Value:

    int - number of bytes sent out

Notes:

*/
extern int SockPrint(SOCKET sock, char* format, ...);

#endif //_LAUNCHER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\medialoader.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	medialoader.h

Abstract:

	copies media files from a server to the xbox

Author:

	Jeff Sullivan (jeffsul) 24-Jul-2001

Revision History:

	24-Jul-2001 jeffsul
		Initial Version

//------------------------------------------------------------------------------
//	Regular Expressions for finding files:
//
//	*	find 0 or more matches
//	+	find 1 or more matches
//	?	find 0 or 1 matches
//
//	()	grouping operator
//
//	\w  is the same as [a-z A-Z 0-9]	(alphanumeric)
//	\d	is the same as [0-9]			(numeric)
//	\s	is the same as [ \f\t\r\n]		(white space)
//
//	Example:
//	==> media_directory/file(\d*)(\w?).(/w/w/w)
//	would find any files in media_directory that begin with "file" followed by any number
//	of digits, then one or more alphanumeric characters, and finally a file extension of 
//	three alphanumeric characters (i.e., file112b.wav, file.txt, file336.1b3, etc. )
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//	Getting a certain number of files:
//	
//	%X	where X is the number of files to find
//
//	Example:
//	==> media_directory/(\w*).wav%3
//	would find 3 files that match the search criteria, in this case, 3 wav files in
//	the media_directory directory
//------------------------------------------------------------------------------


--*/

#ifndef __MEDIALOADER_H__
#define __MEDIALOADER_H__

#ifndef _X86_
#define _X86_
#endif

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <xbox.h>

#define MLCOPY_ALWAYS		0x0000
#define MLCOPY_IFNEWER		0x0001
#define MLCOPY_IFNOTEXIST	0x0002
#define MLCOPY_MAXVALUE		0x0002

typedef struct _MEDIAFILEDESC				// a structure describing which files to copy from
{											// a remote server and how to copy them...
	LPSTR	lpszFromPath;					// file to search for on remote server (can use wildcards)
	LPSTR	lpszToPath;						// directory where to store the remote file on xbox
	DWORD	dwFlags;						// flags describing how to copy the file
} MEDIAFILEDESC, *PMEDIAFILEDESC;


/*++

Routine Description:

	Grabs media files from a server to the xbox

Arguments:

	IN MEDIAFILEDESC MediaFileDesc[]	-	array of structures describing what files to copy to xbox

Return Value:

	S_OK on succes
	E_XX on failure

--*/
extern HRESULT _stdcall
LoadMedia( 
	IN MEDIAFILEDESC MediaFileDesc[]		// array of structures describing what files to copy to xbox
);


/*++

Routine Description:

	Gets media file descriptions from an .ini file and passes them to LoadMedia

Arguments:

	IN LPCSTR	lpszIniFile	-	path to an initialization file that describes which media files to load

Return Value:

	S_OK on succes
	E_XX on failure

--*/
#if 0
extern HRESULT _stdcall
LoadMediaFromIni( 
	IN LPCSTR	lpszIniFile					// path to an initialization file that describes which media files to load
);
#endif 0


/*++

Routine Description:

	sets the error level for media loader, any errors at or below this level will be output
	the default is set to 5 to output all information
	5  general info about what the medialoader is doing
	4  notifications about file states (already exists, up to date, overwriting, etc)
	3  warnings that are produced when media loader is given bad input (couldnt find as many files as requested, file missing from .ini, etc)
	2  warnings when media loader couldnt do what it was instructed to do for whatever reason
	1  errors generally having to do with file io (usually problems like file names that are too long), usually recoverable but doesnt guarantee that you get the results that you wanted
	0  hopefully youll never see these, if you do, it means I probably messed something up with my code or the network is down, not very recoverable


Arguments:

	IN INT nErrorLevel - level of errors to be displayed ( 0-1 = errors, 2-3 = warnings, 4-5 = info )

Return Value:

	None

--*/
extern VOID _stdcall
MLSetErrorLevel( 
	IN INT nErrorLevel 
);

#if 0
/*++

Routine Description:

	gets an integer value from an .ini file

Arguments:

	IN LPCSTR	lpAppName	-	section name
	IN LPCSTR	lpKeyName	-	key name
	IN INT		nDefault	-	return value if key name not found
	IN LPCSTR	lpFileName	-	initialization file name

Return Value:

	The value found in the .ini on success
	nDefault on failure

--*/
extern INT _stdcall
GetIniInt( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN INT		nDefault,					// return value if key name not found
	IN LPCSTR	lpFileName					// initialization file name
);


/*++

Routine Description:

	gets a floating point value from an .ini file

Arguments:

	IN LPCSTR	lpAppName	-	section name
	IN LPCSTR	lpKeyName	-	key name
	IN FLOAT	fDefault	-	return value if key name not found
	IN LPCSTR	lpFileName	-	initialization file name

Return Value:

	The value found in the .ini on success
	fDefault on failure

--*/
extern FLOAT _stdcall
GetIniFloat( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN FLOAT	fDefault,					// return value if key name not found
	IN LPCSTR	lpFileName					// initialization file name
);


/*++

Routine Description:

	gets a string from an .ini file and copies it into lpReturnedString

Arguments:

	IN LPCSTR	lpAppName			-	section name
	IN LPCSTR	lpKeyName,			-	key name
	IN LPCSTR	lpDefault,			-	return value if key name not found
	OUT LPSTR	lpReturnedString,	-	holds the returned string
	IN DWORD	nSize,				-	max size of returned string
	IN LPCSTR	lpFileName			-	initialization file name

Return Value:

	The string found in the .ini on success
	lpDefault on failure

--*/
extern INT _stdcall
GetIniString( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN LPCSTR	lpDefault,					// return value if key name not found
	OUT LPSTR	lpReturnedString,			// holds the returned string
	IN DWORD	nSize,						// max size of returned string
	IN LPCSTR	lpFileName					// initialization file name
);


/*++

Routine Description:

	gets a pre-defined constant value from an .ini file

Arguments:

	IN LPCSTR	lpAppName	-	section name
	IN LPCSTR	lpKeyName	-	key name
	IN DWORD	dwDefault	-	return value if key name not found
	IN LPCSTR	lpFileName	-	initialization file name

Return Value:

	The vlaue of the constant found in the .ini on success
	dwDefault on failure

--*/
extern DWORD _stdcall
GetIniConst( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN DWORD	dwDefault,					// return value if key name not found
	IN LPCSTR	lpFileName					// initialization file name
);


/*++

Routine Description:

	gets a constant or enumerated value from its string equivalent

Arguments:

	IN CONST CHAR*	szStr	-	constant's name
	IN INT			cchStr	-	length of szStr
	OUT PDWORD		pval	-	pointer to DWORd to store value

Return Value:

	returns TRUE if the constant is found, FALSE otherwise

--*/
extern BOOL _stdcall
GetConst(
	IN CONST CHAR*	szStr, 
	IN INT			cchStr, 
	OUT PDWORD		pval
);
#endif 0
	
#endif // #ifndef __MEDIALOADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\regsuite.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	regsuite.h

Abstract:

	Exported header file for regression suite library (regsuite.lib)

Author:

	Jeff Sullivan (jeffsul) 11-Feb-2002

[Notes:]

	Known Issues

		RSBeginTest() returns XLL_FAIL at this point for error.  It should return XLL_ABORT or XLL_SKIP when those values are defined.

		If g_D3D_PresentFlag is not set to one of the following values, the variable will not be set correctly:
		D3DPRESENTFLAG_WIDESCREEN
		D3DPRESENTFLAG_INTERLACED            
		D3DPRESENTFLAG_PROGRESSIVE
		D3DPRESENTFLAG_FIELD

		If g_D3D_MultiSampleType is not set to one of the following values, the variable will not be set correctly:
		D3DMULTISAMPLE_NONE                                    
		D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR            
		D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX          
		D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR 
		D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR   
		D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR            
		D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN          
		D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR            
		D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN          
		D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN          
		D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN


Revision History:

	11-Feb-2002 jeffsul
		Initial Version

--*/

#ifndef _REGRESSIONSUITE_H_
#define _REGRESSIONSUITE_H_

#include <xtl.h>
#include "..\..\hvs\utils\hvsUtils.h"
#include <xlog.h>
//#include <medialoader.h>
#include <macros.h>
#include <xtestlib.h>

#define RS_DONTALLOCMEMORY	0x00000001L
#define RS_DONTALLOCVOICES	0x00000002L
#define RS_DONTSETMLDEBUG	0x00000004L

typedef VOID (_stdcall *RSINIT_FUNC) ( LPCSTR szKey, LPCSTR szValue, LPVOID lpUserParam );

typedef struct
{
	// D3D
	UINT                D3D_uiBackBufferWidth;
    UINT                D3D_uiBackBufferHeight;
    D3DFORMAT           D3D_BackBufferFormat;
    UINT                D3D_uiBackBufferCount;
    D3DMULTISAMPLE_TYPE D3D_MultiSampleType;
    D3DSWAPEFFECT       D3D_SwapEffect;
	BOOL                D3D_bEnableAutoDepthStencil;
    D3DFORMAT           D3D_AutoDepthStencilFormat;
    DWORD               D3D_dwFlags;								// Display mode flag, Widescreen mode flag, 1:1.1 aspect ratio flag
    UINT                D3D_uiFullScreen_RefreshRateInHz; 
    UINT                D3D_uiFullScreen_PresentationInterval;
	BOOL				D3D_bSingleStepPusher;
	BOOL				D3D_bD3dParser;
	BOOL				D3D_bNullHardware;

	// DMusic
	BOOL				DM_bDoWorkLocally;							// Test will call DirectMusicDoWork itself, number, 0, 0, 1
	DWORD				DM_dwDoWorkFrequency;						// Times per second test will call DirectMusicDoWork, number, 60, 0, 100000 
	DWORD				DM_dwDebugLevel;							// DirectMusic debug level, number, 1, 0, 10
	DWORD				DM_dwRIPLevel;								// DirectMusic RIP level, number, 0, 0, 10
	DWORD				DM_dwTestDebugLevel;						// DirectMusic tests debug level, number, 2, 0, 10
	DWORD				DM_dwVoiceCount;							// Max # of HW 2D voices DMusic can use, number, 180, 0, 192
	CHAR				DM_szDMHeap[MAX_PATH];						// Type of heap to use for DirectMusic, string, (DMDDEFAULT), DMDEFAULT, DMFIXED, USER, USERFIXED
	DWORD				DM_dwHeapSizeNorm;							// Sized of DMs normal heap (if fixed size), number, 16777216, 0, 134217728
	DWORD				DM_dwHeapSizePhys;							// Sized of DMs physical heap (if fixed size), number, 16777216, 0, 134217728

	// DSound
	BOOL				DS_bEnableHeadphones;						// Use EnableHeadphones(), 0, 0, 1
	CHAR				DS_szFXImage[MAX_PATH];						// Path of DSP code on server, string
	CHAR				DS_szHRTF[MAX_PATH];						// HRTF to use,  string, (FULL), FULL, LIGHT, PAN3D

	// other 
	CHAR				RS_szTestRun[MAX_PATH];						// An optional unique name to help identify your test run, string2 
	CHAR				RS_szHttpServer[MAX_PATH];					// =string2 (172.26.172.13)
	CHAR				RS_szConfigPage[MAX_PATH];					// =string2 (/dxregression/submit/sysConfig.asp)
	CHAR				RS_szStatePage[MAX_PATH];					// =string2, optional
	CHAR				RS_szLogPage[MAX_PATH];						// =string2 (/dxregression/submit/log.asp)
	CHAR				RS_szPostFileName[MAX_PATH];				// =string2 (t:\webpost.log)
	BOOL				RS_bLogResults;								// Store test results in a database, number, 0, 0, 1 
	DWORD				RS_dwDecreaseMemory;						// Memory to preallocate before tests are run (bytes), number, 0, 0, 134217728
	UINT				RS_dwDSUsedVoices2D;						// 2DVoices to burn before tests run, number, 0, 0, 192
	UINT				RS_dwDSUsedVoices3D;						// 3DVoices to burn before tests run, number, 0, 0, 64
	DWORD				RS_dwMLErrorLevel;							// Media Loader debug level, number, dwJeffsCall, 0, 10

	// test specific data passed directly through callback

} RSTESTPARAMS;

/*++

Routine Description:

	Parses launch data for test initialization.  
	If the test is launched from HVS Launcher, the data comes from the launch data.  Otherwise (test is stand alone), 
		the data comes from <XBENAME>.ini file in the same directory as the .xbe.
	The routine generates a .repro file (in the same directory as the .xbe) that will only be removed if RSEndTest() 
		is called with 0 passed as uiFail.
	The routine also allocates memory and voices as specified by launch parameters.  To override this, use the flags parameter.
	The routine will set medialoader debug level based on input.

Arguments:

	IN DWORD			dwFlags			-	0 for default behaviour, use RS_DONTALLOCXXX to avoid unwanted allocations
	OUT RSTESTPARAMS*	pTestParams		-	pointer to a struct to be filled in with launch data
	IN RSINIT_FUNC		LocalTestInit	-	pointer to function to parse remaining test-specific init values
	IN LPVOID			lpUserParam		-	pointer to a user defined variable that is passed to LocalTestInit when called

Return Value:

	XLL_PASS	-	if success
	XLL_FAIL	-	never returned
	XLL_INFO	-	?
	XLL_ABORT	-	if function fails
	XLL_SKIP	-	if current configuration is not supported

--*/
extern DWORD _stdcall
RSBeginTest( 
	IN DWORD			dwFlags,
	OUT RSTESTPARAMS*	pTestParams,
	IN RSINIT_FUNC		LocalTestInit,
	IN LPVOID			lpUserParam
);


/*++

Routine Description:

	Called at the end of a test app to give control back to the HVS launcher or reboot the box.
	If uiFail is 0, this routine deletes the .repro file created by RSInitializeTest().
	Also cleans up any memory/voices allocated by RSBeginTest().

Arguments:

	UINT64		uiPass		-	the number of tests passed
	UINT64		uiFail		-	the number of tests failed
	LPCSTR		lpszNotes	-	optional string of notes to pass back to the launcher

Return Value:

	None

--*/
extern VOID _stdcall
RSEndTest( 
	UINT64				uiPass,
	UINT64				uiFail,
	LPCSTR				lpszNotes 
);


/*++

Routine Description:

	gets a constant or enumerated value from its string equivalent

Arguments:

	IN CONST CHAR*	szStr	-	constant's name
	IN INT			cchStr	-	length of szStr
	OUT PDWORD		pval	-	pointer to DWORd to store value

Return Value:

	returns TRUE if the constant is found, FALSE otherwise

--*/
extern BOOL _stdcall
GetConst(
	IN CONST CHAR*	szStr, 
	IN INT			cchStr, 
	OUT PDWORD		pval
);

#endif // #ifndef _REGRESSIONSUITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\teststat.h ===
/***************************************

This is the header file for the statistics package

***************************************/

#if (defined (NTNAT) || defined (OS2SS))
#define FAR
#define PASCAL
#define far
#define double ULONG	     /* this needs to be changed when flt support
                               becomes available under NT */
#define BOOL BOOLEAN
#endif

#if (defined (WIN16) || defined (WIN32) || defined (MIPS) || defined (DOS))
    #define SHORT short
    #define ULONG DWORD
    #define USHORT WORD
    #define PSHORT short *
    #define PSZ	  LPSTR
    #define PUSHORT USHORT far *
    #define PULONG ULONG far *
    #define FAR far
#endif

#if (defined (WIN16))
    #define PLONG LPSTR
#endif

#ifdef OS2386
    #define far
#endif

#define STAT_ERROR_ILLEGAL_MIN_ITER   1
#define STAT_ERROR_ILLEGAL_MAX_ITER   2
#define STAT_ERROR_ALLOC_FAILED       3
#define STAT_ERROR_ILLEGAL_BOUNDS     4

#define DEFAULT_OUTLIER_FACTOR        4

USHORT FAR PASCAL TestStatOpen     (USHORT, USHORT);
VOID   FAR PASCAL TestStatInit     (VOID);
BOOL   FAR PASCAL TestStatConverge (ULONG);
VOID   FAR PASCAL TestStatValues   (PSZ, USHORT, PULONG far *, PUSHORT, 
                                       PUSHORT); 
VOID   FAR PASCAL TestStatClose    (VOID);
ULONG  FAR PASCAL TestStatRand     (ULONG, ULONG);
double FAR PASCAL TestStatUniRand  (VOID);
USHORT  FAR PASCAL TestStatShortRand  (VOID);
LONG   FAR PASCAL TestStatNormDist (ULONG, USHORT);
LONG   FAR PASCAL TestStatOldDist (ULONG, USHORT);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\timing.h ===
/* Header file for timer.dll.  Use with timer.c for making the
   dll 
*/

typedef enum {
    KILOSECONDS,
    SECONDS,
    MILLISECONDS,
    MICROSECONDS,
    TENTHMICROSECS,
    NANOSECONDS,
    TIMER_FREE
} _TimerUnits;

#if (defined (WIN16) || defined (WIN32) || defined (NTWIN))
    #define SHORT short
    #define ULONG DWORD
    #define USHORT WORD
    #define PSHORT short *
    #define PSZ	  LPSTR
#endif

#if (defined (WIN16))
    #define PLONG LPSTR
    typedef struct _QWORD {	       
	ULONG	ulLo;
	ULONG	ulHi;
    } QWORD;

    typedef QWORD FAR *PQWORD;
#endif

#if (defined (WIN32) || defined (NTWIN))
#ifdef W32S
    typedef struct _QWORD {
	ULONG	ulLo;
	ULONG	ulHi;
    } QWORD;
#define PQWORD QWORD *
#else
#define PQWORD PLARGE_INTEGER
#endif
#endif

#if (!defined (WIN32) && !defined (NTWIN))
#define OPTIONAL
#endif

#if (defined (OS2SS) || defined (NTNAT) || defined (WIN32) || defined (NTWIN))
#define far
#if (!defined (WIN32) && !defined (NTWIN))
#define FAR
#endif
#endif

#ifdef NTNAT
#define BOOL BOOLEAN
#endif

#ifdef OS2386
#define far
#endif

SHORT FAR PASCAL TimerOpen (SHORT far *, _TimerUnits);
SHORT FAR PASCAL TimerInit (SHORT);
ULONG FAR PASCAL TimerRead (SHORT);
SHORT FAR PASCAL TimerClose (SHORT);
BOOL  FAR PASCAL TimerReport (PSZ, SHORT);
VOID  FAR PASCAL TimerQueryPerformanceCounter (PQWORD, PQWORD);
ULONG FAR PASCAL TimerConvertTicsToUSec (ULONG, ULONG);

#define TIMERERR_NOT_AVAILABLE 1
#define TIMERERR_NO_MORE_HANDLES 2
#define TIMERERR_INVALID_UNITS 3
#define TIMERERR_INVALID_HANDLE 4
#define TIMERERR_OVERFLOW 0xffffffff

typedef struct {
    ULONG ulLo;
    ULONG ulHi;
    _TimerUnits TUnits;
} Timer;

#ifdef WIN16
    #define MAX_TIMERS 500
#else                              
    #define MAX_TIMERS 5000
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\tsc.h ===
#ifndef __tsc_h__
#define __tsc_h__

#if XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif //def __cplusplus

#define _i __declspec(dllexport) __forceinline

	//*****************************************************************************
	//* Function:	TscInit
	//* Purpose:	Initialize the tsc routines, set the processor speed variables
	//* Params:		mhz --- the processor speed, in megahertz. 
	//*					If it is 0, 733 is used as the default
	//* Return:		TRUE
	//*****************************************************************************
BOOL TscInit(int mhz);

	//*****************************************************************************
	//* Function:	TscGetStamp
	//* Purpose:	return the current time-stamp count
	//* Params:		none
    //* Return:     an INT64 containing the number of clock cycles since reboot
	//* Note:		on a 733mhz, it will loop around in about 797 years...
	//*****************************************************************************
_i INT64 TscGetStamp();

	//*****************************************************************************
	//* Function:	TscGetDStamp
	//* Purpose:	return the current time-stamp count
	//* Params:		none
    //* Return:     an INT64 containing the number of clock cycles since reboot
	//*	Note:		This will loop every 5.8 seconds. For longer measurements, use
	//*					TscGetStamp.
	//*****************************************************************************
_i DWORD TscGetDStamp();

	//*****************************************************************************
    //****   INT64 functions                              ************************
	//**** (slower, but are accurate for 800 years or so)  ************************
	//*****************************************************************************


	//*****************************************************************************
	//* Function:	TscBegin
	//* Purpose:	start measuring time...
	//* Params:		none
    //* Return:     a INT64 that holds the clock time at start
	//* Note:		Pass the return value to TscEnd or TscCurrentTime
	//*****************************************************************************
_i INT64 TscBegin();

	//*****************************************************************************
	//* Function:	TscEnd
	//* Purpose:	stop counting time
	//* Params:		start is the time when you started measuring time
    //* Return:     a INT64 that holds the number of clock cycles since TscBegin
	//*****************************************************************************
_i INT64 TscEnd(INT64 start);

	//*****************************************************************************
	//* Function:	TscCurrentTime
	//* Purpose:	get the ellapsed time since the corresponding TscBegin
	//* Params:		start is the time when you started measuring time
    //* Return:     a INT64 that holds the number of clock cycles since TscBegin
	//*****************************************************************************
_i INT64 TscCurrentTime(INT64 start);


	//*****************************************************************************
	//****   DWORD functions                               ************************
	//**** (faster, but are only accurate for 5.8 seconds  ************************
	//*****************************************************************************


	//*****************************************************************************
	//* Function:	TscDBegin
	//* Purpose:	start measuring time...
	//* Params:		none
	//* Return:		a DWORD that holds the clock time at start
	//* Note:		Pass the return value to TscEnd or TscCurrentTime
	//*****************************************************************************
_i DWORD TscDBegin();

	//*****************************************************************************
	//* Function:	TscDEnd
	//* Purpose:	stop counting time
	//* Params:		start is the time when you started measuring time
	//* Return:		a DWORD that holds the number of clock cycles since TscBegin
	//*****************************************************************************
_i DWORD TscDEnd(DWORD start);

	//*****************************************************************************
	//* Function:	TscDCurrentTime
	//* Purpose:	get the ellapsed time since the corresponding TscBegin
	//* Params:		start is the time when you started measuring time
	//* Return:		a DWORD that holds the number of clock cycles since TscBegin
	//*****************************************************************************
_i DWORD TscDCurrentTime(DWORD start);

	//*****************************************************************************
	//* Function:   TscGetCpuidLen()
	//* Purpose:    If you're really nit-picky, this tells you how long it takes to
	//*               do a cpuid and a rdtsc, in clock-ticks. It shouldn't matter.
	//* Return:		a DWORD that holds the number of CCs it takes to cpuid & rdtsc
	//*****************************************************************************
_i DWORD TscGetCpuidLen();


	//*****************************************************************************
	//****   conversion functions                          ************************
	//****   clock-ticks (I64) to seconds, etc             ************************
	//*****************************************************************************
_i FLOAT TscTicksToFSeconds (INT64 ticks);
_i FLOAT TscTicksToFMSeconds(INT64 ticks);
_i FLOAT TscTicksToFUSeconds(INT64 ticks);

_i DWORD TscTicksToDSeconds (INT64 ticks);
_i DWORD TscTicksToDMSeconds(INT64 ticks);
_i DWORD TscTicksToDUSeconds(INT64 ticks);

_i INT64 TscTicksToSeconds (INT64 ticks);
_i INT64 TscTicksToMSeconds(INT64 ticks);
_i INT64 TscTicksToUSeconds(INT64 ticks);

_i INT64 TscFSecondsToTicks (FLOAT seconds );
_i INT64 TscFMSecondsToTicks(FLOAT mseconds);
_i INT64 TscFUSecondsToTicks(FLOAT useconds);

_i INT64 TscDSecondsToTicks (DWORD seconds );
_i INT64 TscDMSecondsToTicks(DWORD mseconds);
_i INT64 TscDUSecondsToTicks(DWORD useconds);


	//*****************************************************************************
	//****   conversion functions                          ************************
	//****   clock-ticks (DWORD) to seconds, etc           ************************
	//*****************************************************************************
_i FLOAT TscDTicksToFSeconds (DWORD ticks);
_i FLOAT TscDTicksToFMSeconds(DWORD ticks);
_i FLOAT TscDTicksToFUSeconds(DWORD ticks);

_i DWORD TscDTicksToDSeconds (DWORD ticks);
_i DWORD TscDTicksToDMSeconds(DWORD ticks);
_i DWORD TscDTicksToDUSeconds(DWORD ticks);

_i DWORD TscFSecondsToDTicks (FLOAT seconds );
_i DWORD TscFMSecondsToDTicks(FLOAT mseconds);
_i DWORD TscFUSecondsToDTicks(FLOAT useconds);

_i DWORD TscDSecondsToDTicks (DWORD seconds );
_i DWORD TscDMSecondsToDTicks(DWORD mseconds);
_i DWORD TscDUSecondsToDTicks(DWORD useconds);


#ifdef __cplusplus
}	//extern "C" {
#endif //def __cplusplus


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\profilep.h ===
/************************************************************************
*                                                                       *
*   profilep.h -- INI file APIs pulled from winbase, used by tests      *
*                                                                       *
*   Copyright (c) 1990-1998, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/
#ifndef _PROFILEP_
#define _PROFILEP_


//
// Define API decoration for direct importing of DLL references.
//

#ifndef WINBASEAPI
#define WINBASEAPI
#endif  // ! WINBASEAPI

#ifdef __cplusplus
extern "C" {
#endif

WINBASEAPI
UINT
WINAPI
GetProfileIntA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN INT nDefault
    );
WINBASEAPI
UINT
WINAPI
GetProfileIntW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpKeyName,
    IN INT nDefault
    );
#ifdef UNICODE
#define GetProfileInt  GetProfileIntW
#else
#define GetProfileInt  GetProfileIntA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetProfileStringA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN LPCSTR lpDefault,
    OUT LPSTR lpReturnedString,
    IN DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetProfileStringW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpKeyName,
    IN LPCWSTR lpDefault,
    OUT LPWSTR lpReturnedString,
    IN DWORD nSize
    );
#ifdef UNICODE
#define GetProfileString  GetProfileStringW
#else
#define GetProfileString  GetProfileStringA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteProfileStringA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN LPCSTR lpString
    );
WINBASEAPI
BOOL
WINAPI
WriteProfileStringW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpKeyName,
    IN LPCWSTR lpString
    );
#ifdef UNICODE
#define WriteProfileString  WriteProfileStringW
#else
#define WriteProfileString  WriteProfileStringA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetProfileSectionA(
    IN LPCSTR lpAppName,
    OUT LPSTR lpReturnedString,
    IN DWORD nSize
    );
WINBASEAPI
DWORD
WINAPI
GetProfileSectionW(
    IN LPCWSTR lpAppName,
    OUT LPWSTR lpReturnedString,
    IN DWORD nSize
    );
#ifdef UNICODE
#define GetProfileSection  GetProfileSectionW
#else
#define GetProfileSection  GetProfileSectionA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WriteProfileSectionA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpString
    );
WINBASEAPI
BOOL
WINAPI
WriteProfileSectionW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpString
    );
#ifdef UNICODE
#define WriteProfileSection  WriteProfileSectionW
#else
#define WriteProfileSection  WriteProfileSectionA
#endif // !UNICODE

WINBASEAPI
UINT
WINAPI
GetPrivateProfileIntA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN INT nDefault,
    IN LPCSTR lpFileName
    );
WINBASEAPI
UINT
WINAPI
GetPrivateProfileIntW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpKeyName,
    IN INT nDefault,
    IN LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileInt  GetPrivateProfileIntW
#else
#define GetPrivateProfileInt  GetPrivateProfileIntA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetPrivateProfileStringA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN LPCSTR lpDefault,
    OUT LPSTR lpReturnedString,
    IN DWORD nSize,
    IN LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileStringW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpKeyName,
    IN LPCWSTR lpDefault,
    OUT LPWSTR lpReturnedString,
    IN DWORD nSize,
    IN LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileString  GetPrivateProfileStringW
#else
#define GetPrivateProfileString  GetPrivateProfileStringA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStringA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN LPCSTR lpString,
    IN LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStringW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpKeyName,
    IN LPCWSTR lpString,
    IN LPCWSTR lpFileName
    );
#ifdef UNICODE
#define WritePrivateProfileString  WritePrivateProfileStringW
#else
#define WritePrivateProfileString  WritePrivateProfileStringA
#endif // !UNICODE

WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionA(
    IN LPCSTR lpAppName,
    OUT LPSTR lpReturnedString,
    IN DWORD nSize,
    IN LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionW(
    IN LPCWSTR lpAppName,
    OUT LPWSTR lpReturnedString,
    IN DWORD nSize,
    IN LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileSection  GetPrivateProfileSectionW
#else
#define GetPrivateProfileSection  GetPrivateProfileSectionA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileSectionA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpString,
    IN LPCSTR lpFileName
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileSectionW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpString,
    IN LPCWSTR lpFileName
    );
#ifdef UNICODE
#define WritePrivateProfileSection  WritePrivateProfileSectionW
#else
#define WritePrivateProfileSection  WritePrivateProfileSectionA
#endif // !UNICODE


WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionNamesA(
    OUT LPSTR lpszReturnBuffer,
    IN DWORD nSize,
    IN LPCSTR lpFileName
    );
WINBASEAPI
DWORD
WINAPI
GetPrivateProfileSectionNamesW(
    OUT LPWSTR lpszReturnBuffer,
    IN DWORD nSize,
    IN LPCWSTR lpFileName
    );
#ifdef UNICODE
#define GetPrivateProfileSectionNames  GetPrivateProfileSectionNamesW
#else
#define GetPrivateProfileSectionNames  GetPrivateProfileSectionNamesA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
GetPrivateProfileStructA(
    IN LPCSTR lpszSection,
    IN LPCSTR lpszKey,
    OUT LPVOID   lpStruct,
    IN UINT     uSizeStruct,
    IN LPCSTR szFile
    );
WINBASEAPI
BOOL
WINAPI
GetPrivateProfileStructW(
    IN LPCWSTR lpszSection,
    IN LPCWSTR lpszKey,
    OUT LPVOID   lpStruct,
    IN UINT     uSizeStruct,
    IN LPCWSTR szFile
    );
#ifdef UNICODE
#define GetPrivateProfileStruct  GetPrivateProfileStructW
#else
#define GetPrivateProfileStruct  GetPrivateProfileStructA
#endif // !UNICODE

WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStructA(
    IN LPCSTR lpszSection,
    IN LPCSTR lpszKey,
    IN LPVOID   lpStruct,
    IN UINT     uSizeStruct,
    IN LPCSTR szFile
    );
WINBASEAPI
BOOL
WINAPI
WritePrivateProfileStructW(
    IN LPCWSTR lpszSection,
    IN LPCWSTR lpszKey,
    IN LPVOID   lpStruct,
    IN UINT     uSizeStruct,
    IN LPCWSTR szFile
    );
#ifdef UNICODE
#define WritePrivateProfileStruct  WritePrivateProfileStructW
#else
#define WritePrivateProfileStruct  WritePrivateProfileStructA
#endif // !UNICODE


#ifdef __cplusplus
}
#endif


#endif // _PROFILEP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\xlog.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  xlog.h

Abstract:

  This module contains the definitions for XLL_ logging levels and XLO_ logging options

Author:

  Steven Kehrli (steveke) 13-Mar-2000
  
------------------------------------------------------------------------------*/

#pragma once



#ifdef _XBOX

#include <winsockx.h>

#else

#include <winsock2.h>

#endif



#ifdef __cplusplus
extern "C" {
#endif



// XLL_ logging levels

#define XLL_LOGNONE               0x00000000L  // Disables all logging
#define XLL_LOGDEFAULT            0x000001FFL  // Enables logging at all levels except XLL_VARIATION_TIME
#define XLL_LOGALL                0xFFFFFFFFL  // Enables logging at all levels

#define XLL_EXCEPTION             0x00000001L  // Enables logging of exception events
#define XLL_BREAK                 0x00000002L  // Enables logging to break into the debugger
#define XLL_FAIL                  0x00000004L  // Enables logging of failure events
#define XLL_WARN                  0x00000008L  // Enables logging of warning events
#define XLL_BLOCK                 0x00000010L  // Enables logging of blocking events
#define XLL_PASS                  0x00000020L  // Enables logging of pass events
#define XLL_INFO                  0x00000040L  // Enables logging of informational events
#define XLL_VARIATION_END         0x00000080L  // Enables logging of variation end events
#define XLL_VARIATION_START       0x00000100L  // Enables logging of variation start events
#define XLL_VARIATION             (XLL_VARIATION_START | XLL_VARIATION_END)  // Enables logging of variation start and end events
#define XLL_VARIATION_TIME        0x00000200L  // Enables logging of variation time events



// XLO_ logging options

#define XLO_DEBUG                 0x00000001L  // Log output is echoed to the debugger
#define XLO_CONFIG                0x00000002L  // Enables logging of system configuration when the log object is created
#define XLO_STATE                 0x00000004L  // Enables logging of system resource status when the log object is created and again when the log object is closed
#define XLO_REFRESH               0x00000008L  // Creates a new log file.  If the log file already exists, overwrites the file and clears the existing attributes.



// Global definitions

#define OWNER_ALIAS_LENGTH        16           // Maximum length of an owner alias, in characters
#define COMPONENT_NAME_LENGTH     32           // Maximum length of a component name, in characters
#define SUBCOMPONENT_NAME_LENGTH  32           // Maximum length of a subcomponent name, in characters
#define FUNCTION_NAME_LENGTH      32           // Maximum length of a function name, in characters
#define VARIATION_NAME_LENGTH     32           // Maximum length of a variation name, in characters
#define LOG_STRING_LENGTH         255          // Maximum length of the string in a line of log output, in characters



// Global structures

typedef struct _WEB_SERVER_INFO_A {
    LPSTR  lpszHttpServer;                     // Pointer to a null-terminated string (ANSI) that specifies the http server to which the web posts will be directed.  This member is NULL if no web posts will be made.
    LPSTR  lpszConfigPage;                     // Pointer to a null-terminated string (ANSI) that specifies the web page to which the system configuration will be web posted.  This member is NULL if no web posts will be made.
    LPSTR  lpszStatePage;                      // Pointer to a null-terminated string (ANSI) that specifies the web page to which the system state will be web posted.  This member is NULL if no web posts will be made.
    LPSTR  lpszLogPage;                        // Pointer to a null-terminated string (ANSI) that specifies the web page to which the log output will be web posted.  This member is NULL if no web posts will be made.
    LPSTR  lpszWebPostFileName;                // Pointer to a null-terminated string (ANSI) that specifies the file to which the web posts will be cached.  This member is NULL to use the default file name.
} WEB_SERVER_INFO_A, *PWEB_SERVER_INFO_A;

typedef struct _WEB_SERVER_INFO_W {
    LPWSTR  lpszHttpServer;                    // Pointer to a null-terminated string (UNICODE) that specifies the http server to which the web posts will be directed.  This member is NULL if no web posts will be made.
    LPWSTR  lpszConfigPage;                    // Pointer to a null-terminated string (UNICODE) that specifies the web page to which the system configuration will be web posted.  This member is NULL if no web posts will be made.
    LPWSTR  lpszStatePage;                     // Pointer to a null-terminated string (UNICODE) that specifies the web page to which the system state will be web posted.  This member is NULL if no web posts will be made.
    LPWSTR  lpszLogPage;                       // Pointer to a null-terminated string (UNICODE) that specifies the web page to which the log output will be web posted.  This member is NULL if no web posts will be made.
    LPWSTR  lpszWebPostFileName;               // Pointer to a null-terminated string (UNICODE) that specifies the file to which the web posts will be cached.  This member is NULL to use the default file name.
} WEB_SERVER_INFO_W, *PWEB_SERVER_INFO_W;

#ifdef UNICODE
#define WEB_SERVER_INFO  WEB_SERVER_INFO_W
#define PWEB_SERVER_INFO  PWEB_SERVER_INFO_W
#else
#define WEB_SERVER_INFO  WEB_SERVER_INFO_A
#define PWEB_SERVER_INFO  PWEB_SERVER_INFO_A
#endif



// Function prototypes

HANDLE
WINAPI
xCreateLog_A(
    IN  LPSTR               lpszLogFileName_A,
    IN  PWEB_SERVER_INFO_A  pWebServerInfo_A,
    IN  SOCKET              sConsoleSocket,
    IN  DWORD               dwLogLevel,
    IN  DWORD               dwLogOptions
);

HANDLE
WINAPI
xCreateLog_W(
    IN  LPWSTR              lpszLogFileName_W,
    IN  PWEB_SERVER_INFO_W  pWebServerInfo_W,
    IN  SOCKET              sConsoleSocket,
    IN  DWORD               dwLogLevel,
    IN  DWORD               dwLogOptions
);

#ifdef UNICODE
#define xCreateLog  xCreateLog_W
#else
#define xCreateLog  xCreateLog_A
#endif

HANDLE
WINAPI
xSetLogSocket(
    IN  HANDLE  hLog,
    IN  SOCKET  sConsoleSocket
);

BOOL
WINAPI
xCloseLog(
    IN  HANDLE  hLog
);

BOOL
WINAPI
xSetOwnerAlias(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszOwnerAlias_A
);

BOOL
WINAPI
xSetComponent(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszComponentName_A,
    IN  LPSTR   lpszSubcomponentName_A
);

BOOL
WINAPI
xSetFunctionName(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszFunctionName_A
);

BOOL
WINAPI
xStartVariationEx(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszVariationName_A,
    IN  int     nVariationTime
);

BOOL
WINAPI
xStartVariation(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszVariationName_A
);

DWORD
WINAPI
xEndVariation(
    IN  HANDLE  hLog
);

BOOL
WINAPI
xLog_va(
    IN  HANDLE   hLog,
    IN  DWORD    dwLogLevel,
    IN  LPSTR    lpszFormatString_A,
    IN  va_list  varg_ptr
);

BOOL
WINAPI
xLog(
    IN  HANDLE  hLog,
    IN  DWORD   dwLogLevel,
    IN  LPSTR   lpszFormatString_A,
    IN  ...
);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\netsync.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

  netsync.h

Abstract:

  This module contains the definitions for netsync.dll

Author:

  Steven Kehrli (steveke) 21-Jul-2000

------------------------------------------------------------------------------*/

#pragma once



#ifdef _XBOX

#include <winsockx.h>

#else

#include <winsock2.h>
#include <wsockntp.h>

#endif



#ifdef __cplusplus
extern "C" {
#endif



// NETSYNC_MESSAGE_SIZE is the size limit, in bytes, of a netsync message
#define NETSYNC_MESSAGE_SIZE          1024



// Function Pointer Prototypes

// PNETSYNC_THREAD_FUNCTION is the main function prototype of a thread session
// NetsyncThreadFunction should return when the session is complete
typedef VOID (WINAPI *PNETSYNC_THREAD_FUNCTION) (
    IN HANDLE   hNetsyncObject,       // Handle to the netsync object for the session
    IN BYTE     byClientCount,        // Specifies the number of clients in the session
    IN u_long   *ClientInAddr,        // Pointer to the array of client ip addresses
    IN XNADDR   *ClientXnAddr,        // Pointer to the array of client xnet addresses
    IN u_short  LowPort,              // Specifies the low port number allocated for the session
    IN u_short  HighPort              // Specifies the high port number allocated for the session
);



// PNETSYNC_START_FUNCTION is the start function prototype
// NetsyncStartFunction is called once when the callback session starts and before NetsyncCallbackFunction
// NetsyncStartFunction should return LPVOID, a pointer to a context structure to be used by NetsyncCallbackFunction
typedef LPVOID (WINAPI *PNETSYNC_START_FUNCTION) (
    IN HANDLE   hSessionObject,       // Handle to the session object
    IN HANDLE   hNetsyncObject,       // Handle to the netsync object for the session
    IN BYTE     byClientCount,        // Specifies the number of clients in the session
    IN u_long   *ClientInAddr,        // Pointer to the array of client ip addresses
    IN XNADDR   *ClientXnAddr,        // Pointer to the array of client xnet addresses
    IN u_short  LowPort,              // Specifies the low port number allocated for the session
    IN u_short  HighPort              // Specifies the high port number allocated for the session
);

// PNETSYNC_CALLBACK_FUNCTION is the main function prototype of a callback session
// NetsyncCallbackFunction should return FALSE when the session is complete or TRUE to continue processing messages
typedef BOOL (WINAPI *PNETSYNC_CALLBACK_FUNCTION) (
    IN HANDLE   hSessionObject,       // Handle to the session object
    IN HANDLE   hNetsyncObject,       // Handle to the netsync object for the session
    IN u_long   FromInAddr,           // Specifies the sender ip address of the message
    IN XNADDR   *FromXnAddr,          // Pointer to the sender xnet address of the message
    IN DWORD    dwMessageType,        // Specifies the message type, either server (NETSYNC_MSGTYPE_SERVER) or client (NETSYNC_MSGTYPE_CLIENT)
    IN DWORD    dwMessageSize,        // Specifies the size of the message, in bytes
    IN char     *pMessage,            // Pointer to the message buffer
    IN LPVOID   lpContext             // Pointer to the context structure returned from NetsyncStartFunction
);

// PNETSYNC_STOP_FUNCTION is the stop function prototype
// NetsyncStopFunction is called once when the callback session ends and after NetsyncCallbackFunction
// NetsyncStopFunction should return when all session resources are freed, including the context structure
typedef VOID (WINAPI *PNETSYNC_STOP_FUNCTION) (
    IN HANDLE   hSessionObject,       // Handle to the session object
    IN HANDLE   hNetsyncObject,       // Handle to the netsync object for the session
    IN LPVOID   lpContext             // Pointer to the context structure returned from NetsyncStartFunction
);



// Session Types

// NETSYNC_SESSION_THREAD is a netsync session that runs in its own thread
#define NETSYNC_SESSION_THREAD        1
// NETSYNC_SESSION_CALLBACK is a netsync session that uses a message callback function
#define NETSYNC_SESSION_CALLBACK      2

typedef struct _NETSYNC_TYPE_THREAD {
    BYTE     byClientCount;           // Specifies the client count for a session
    u_short  nMinPortCount;           // Specifies the minimum port count for a session
    LPWSTR   lpszDllName_W;           // Pointer to a null-terminated string (UNICODE) that specifies the dll name for the netsync session
    LPSTR    lpszMainFunction_A;      // Pointer to a null-terminated string (ANSI) that specifies the main function name
} NETSYNC_TYPE_THREAD, *PNETSYNC_TYPE_THREAD;

typedef struct _NETSYNC_TYPE_CALLBACK {
    BYTE     byMinClientCount;        // Specifies the minimum client count for a session
    BYTE     byMaxClientCount;        // Specifies the maximum client count for a session
    u_short  nMinPortCount;           // Specifies the minimum port count for a session
    LPWSTR   lpszDllName_W;           // Pointer to a null-terminated string (UNICODE) that specifies the dll name for the netsync session
    LPSTR    lpszMainFunction_A;      // Pointer to a null-terminated string (ANSI) that specifies the main function name
    LPSTR    lpszStartFunction_A;     // Pointer to a null-terminated string (ANSI) that specifies the start function name
    LPSTR    lpszStopFunction_A;      // Pointer to a null-terminated string (ANSI) that specifies the stop function name
} NETSYNC_TYPE_CALLBACK, *PNETSYNC_TYPE_CALLBACK;



// Message Types

// NETSYNC_MSGTYPE_SERVER indicates a server message
#define NETSYNC_MSGTYPE_SERVER        0x01
// NETSYNC_MSGTYPE_CLIENT indicates a client message
#define NETSYNC_MSGTYPE_CLIENT        0x02

// NETSYNC_MSG_STOPSESSION is the message id to indicate the session has ended
#define NETSYNC_MSG_STOPSESSION       0x0F1
// NETSYNC_MSG_ADDCLIENT is the message id to indicate a client joined the session
#define NETSYNC_MSG_ADDCLIENT         0x0F2
// NETSYNC_MSG_DELETECLIENT is the message id to indicate a client left the session
#define NETSYNC_MSG_DELETECLIENT      0x0F3
// NETSYNC_MSG_DUPLICATECLIENT is the message id to indicate a client rejoined the session without first leaving the session
#define NETSYNC_MSG_DUPLICATECLIENT   0x0F4

// NETSYNC_MSG_USER is the base message id for user messages
#define NETSYNC_MSG_USER              0x800

typedef struct _NETSYNC_GENERIC_MESSAGE {
    DWORD  dwMessageId;  // Specifies the message id
} NETSYNC_GENERIC_MESSAGE, *PNETSYNC_GENERIC_MESSAGE;



// Function Prototypes

BOOL
WINAPI
NetsyncCreateServer(
);

VOID
WINAPI
NetsyncCloseServer(
);

VOID
WINAPI
NetsyncRemoveClientFromSession(
    IN HANDLE  hSessionObject,
    IN HANDLE  hNetsyncObject,
    IN u_long  ClientAddr
);

HANDLE
WINAPI
NetsyncCreateClient(
    IN  u_long   RemoteInAddr,
    IN  DWORD    dwSessionType,
    IN  LPVOID   pSessionType,
    OUT u_long   *ServerInAddr,
    OUT XNADDR   *ServerXnAddr,
    OUT u_short  *LowPort,
    OUT u_short  *HighPort
);

VOID
WINAPI
NetsyncCloseClient(
    IN HANDLE  hNetsyncObject
);

DWORD
WINAPI
NetsyncSendClientMessage(
    IN HANDLE  hNetsyncObject,
    IN u_long  ToAddr,
    IN DWORD   dwMessageSize,
    IN char    *pMessage
);

DWORD
WINAPI
NetsyncReceiveServerMessage(
    IN  HANDLE  hNetsyncObject,
    IN  DWORD   dwTimeout,
    OUT u_long  *FromInAddr,
    OUT XNADDR  *FromXnAddr,
    OUT DWORD   *dwMessageSize,
    OUT char *  *pMessage
);

DWORD
WINAPI
NetsyncReceiveClientMessage(
    IN  HANDLE  hNetsyncObject,
    IN  DWORD   dwTimeout,
    OUT u_long  *FromInAddr,
    OUT XNADDR  *FromXnAddr,
    OUT DWORD   *dwMessageSize,
    OUT char *  *pMessage
);

DWORD
WINAPI
NetsyncReceiveMessage(
    IN  HANDLE  hNetsyncObject,
    IN  DWORD   dwTimeout,
    OUT DWORD   *dwMessageType,
    OUT u_long  *FromInAddr,
    OUT XNADDR  *FromXnAddr,
    OUT DWORD   *dwMessageSize,
    OUT char *  *pMessage
);

BOOL
WINAPI
NetsyncFreeMessage(
    IN  char *  pMessage
);



// Export Table Definitions

#ifdef _XBOX

typedef struct _NETSYNC_EXPORT_TABLE_ENTRY  {
    LPSTR    lpszFunction_A;  // Pointer to a null-terminated string (ANSI) that specifies the function name
    FARPROC  pFunction;       // Pointer to the function address
} NETSYNC_EXPORT_TABLE_ENTRY, *PNETSYNC_EXPORT_TABLE_ENTRY;

typedef struct _NETSYNC_EXPORT_TABLE_DIRECTORY {
    LPWSTR                       lpszModuleName;  // Pointer to a null-terminated string (UNICODE) that specifies the dll name
    PNETSYNC_EXPORT_TABLE_ENTRY  pTableEntry;     // Pointer to the list of table entries for this dll
} NETSYNC_EXPORT_TABLE_DIRECTORY, *PNETSYNC_EXPORT_TABLE_DIRECTORY;

#ifdef __cplusplus
#define __EXTERN_C extern "C"
#else
#define __EXTERN_C
#endif

#define NETSYNC_EXPORT_SECTION_NAME ".SYNCEXP$N"

#define BEGIN_NETSYNC_EXPORT_TABLE(ModuleName) \
    __EXTERN_C NETSYNC_EXPORT_TABLE_ENTRY  ModuleName##_NetsyncExportTableEntry[] = {

#define NETSYNC_EXPORT_TABLE_ENTRY(FunctionName, Function) \
        { FunctionName, (FARPROC) Function },

#define END_NETSYNC_EXPORT_TABLE(ModuleName) \
        { NULL, NULL } \
    };

#define DECLARE_NETSYNC_EXPORT_DIRECTORY(ModuleName) \
    extern NETSYNC_EXPORT_TABLE_ENTRY          ModuleName##_NetsyncExportTableEntry[]; \
    __EXTERN_C NETSYNC_EXPORT_TABLE_DIRECTORY  ModuleName##_NetsyncExportTableDirectory = { \
        L#ModuleName, \
        ModuleName##_NetsyncExportTableEntry \
    };

#endif // XBOX



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\xnetref.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xnetref.h

Abstract:

  This module contains the definitions for xnetref.lib

Author:

  Steven Kehrli (steveke) 24-May-2001

------------------------------------------------------------------------------*/



#pragma once


#ifdef _XBOX



#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus



ULONG
WINAPI
XNetAddRefLocal(
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
);

#define XNetAddRef() XNetAddRefLocal(__FILE__, __LINE__)



ULONG
WINAPI
XNetReleaseLocal(
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
);

#define XNetRelease() XNetReleaseLocal(__FILE__, __LINE__)



#ifdef __cplusplus
}
#endif // __cplusplus



#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\xlogconio.h ===
//
// Overload xLog() to also call xDebugString
//
#include <dxconio.h>

extern gbConsoleOut;

BOOL
WINAPI
xLog(
	IN BOOL	bConsoleOut,
    IN HANDLE  hLog,
    IN DWORD   dwLogLevel,
    IN LPSTR   lpszFormatString_A,
    IN ...
);

//
// Overload xStarVariation() to also call xDebugString
//
BOOL
WINAPI
xStartVariation(
	IN BOOL	bConsoleOut,
    IN HANDLE  hLog,
    IN LPSTR   lpszVariationName_A
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\xnetrefp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xnetrefp.h

Abstract:

  This module contains additional definitions for xnetref.lib

Author:

  Steven Kehrli (steveke) 24-May-2001

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/



#ifdef _XBOX



#ifndef _XNETREFP_H
#define _XNETREFP_H



#include <xtl.h>
#include <winsockp.h>



#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus



ULONG
WINAPI
XNetRefGetParams(
    XNetStartupParams  *pXNetRefStartupParams,
    XNetConfigParams   *pXNetRefConfigParams
);



#ifdef __cplusplus
}
#endif // __cplusplus



#endif // _XNETREFP_H



#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\xonlineref.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xonlineref.h

Abstract:

  This module contains the definitions for xonlineref.lib

Author:

  Steven Kehrli (steveke) 21-Jan-2002

------------------------------------------------------------------------------*/



#pragma once


#ifdef _XBOX



#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus



ULONG
WINAPI
XOnlineAddRef();



ULONG
WINAPI
XOnlineRelease();



#ifdef __cplusplus
}
#endif // __cplusplus



#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\xmem.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  xmem.h

Abstract:

  This module contains the definitions for xmem.dll

Author:

  Steven Kehrli (steveke) 1-Nov-2001

------------------------------------------------------------------------------*/

#pragma once



#ifdef __cplusplus
extern "C" {
#endif



HANDLE
WINAPI
xMemCreateLocal(
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
);

LPVOID
WINAPI
xMemAllocLocal(
    IN  HANDLE  hMemObject,
    IN  SIZE_T  dwBytes,
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
);

LPVOID
WINAPI
xMemReAllocLocal(
    IN  HANDLE  hMemObject,
    IN  LPVOID  lpMem,
    IN  SIZE_T  dwBytes,
    IN  LPSTR   lpszFile,
    IN  DWORD   dwLine
);

BOOL
WINAPI
xMemFree(
    IN  HANDLE  hMemObject,
    IN  LPVOID  lpMem
);

BOOL
WINAPI
xMemClose(
    IN  HANDLE  hMemObject
);

#define xMemCreate() xMemCreateLocal(__FILE__, __LINE__)
#define xMemAlloc(hMemObject, dwBytes) xMemAllocLocal(hMemObject, dwBytes, __FILE__, __LINE__)
#define xMemReAlloc(hMemObject, lpMem, dwBytes) xMemReAllocLocal(hMemObject, lpMem, dwBytes, __FILE__, __LINE__)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\ccl.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cl.h

Abstract:

    function declarations and type definitions for cll.cpp

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __cl_h_
#define __cl_h_

//#include "cpx.h"

typedef VOID (*ControlFunc)(DWORD context, BOOL repeat, BYTE slot);

typedef union {
	struct{
		DWORD Db   : 16;
		DWORD Ab0  : 1;				//16
		DWORD Ab1  : 1;				//17
		DWORD Ab2  : 1;				//18
		DWORD Ab3  : 1;				//19
		DWORD Ab4  : 1;				//20
		DWORD Ab5  : 1;				//21
		DWORD Ab6  : 1;				//22
		DWORD Ab7  : 1;				//23
		DWORD LtUp : 1;				//24
		DWORD LtDn : 1;				//25
		DWORD LtLt : 1;				//26
		DWORD LtRt : 1;				//27
		DWORD RtUp : 1;				//28
		DWORD RtDn : 1;				//29
		DWORD RtLt : 1;				//30
		DWORD RtRt : 1;				//31
		DWORD DpUp : 1;				//32
		DWORD DpDn : 1;				//33
		DWORD DpLt : 1;				//34
		DWORD DpRt : 1;				//35
		DWORD R    : 28;			//36-64
	};
	UINT64 all;
} BUTTONS;

//this big mess here should map exactly to the structure above, and can be used in the elmement "all".
#define bDB0_PRESSED				0x00000001
#define bDB1_PRESSED				0x00000002
#define bDB2_PRESSED				0x00000004
#define bDB3_PRESSED				0x00000008
#define bDB4_PRESSED				0x00000010
#define bDB5_PRESSED				0x00000020
#define bDB6_PRESSED				0x00000040
#define bDB7_PRESSED				0x00000080
#define bDB8_PRESSED				0x00000100
#define bDB9_PRESSED				0x00000200
#define bDB10_PRESSED				0x00000400
#define bDB11_PRESSED				0x00000800
#define bDB12_PRESSED				0x00001000
#define bDB13_PRESSED				0x00002000
#define bDB14_PRESSED				0x00004000
//#define bDB15_PRESSED				0x00008000
#define bAB0_PRESSED				0x00010000
#define bAB1_PRESSED				0x00020000
#define bAB2_PRESSED				0x00040000
#define bAB3_PRESSED				0x00080000
#define bAB4_PRESSED				0x00100000
#define bAB5_PRESSED				0x00200000
#define bAB6_PRESSED				0x00400000
#define bAB7_PRESSED				0x00800000
#define bLTS_UP_PRESSED				0x01000000
#define bLTS_DN_PRESSED				0x02000000
#define bLTS_LT_PRESSED				0x04000000
#define bLTS_RT_PRESSED				0x08000000
#define bRTS_UP_PRESSED				0x10000000
#define bRTS_DN_PRESSED				0x20000000
#define bRTS_LT_PRESSED				0x40000000
#define bRTS_RT_PRESSED				0x80000000

#define bANY						0x00008000
#define bALL						0x00000000

#define bANYBUTTON					0x00ffffff
#define bANYTHING					0xffffffff

#define bDPD_UP_PRESSED				bDB0_PRESSED
#define bDPD_DN_PRESSED				bDB1_PRESSED
#define bDPD_LT_PRESSED				bDB2_PRESSED
#define bDPD_RT_PRESSED				bDB3_PRESSED
#define bSTART_PRESSED				bDB4_PRESSED
#define bBACK_PRESSED				bDB5_PRESSED
#define bLT_PRESSED					bDB6_PRESSED
#define bRT_PRESSED					bDB7_PRESSED

//#define bSELECT_PRESSED bBACK_PRESSED //hackhack

typedef struct _CF{
	BUTTONS but;
	ControlFunc func;
	struct _CF * next;
	DWORD context;
	BOOL repeat;
}CF, *pCF;

class CL{
private:
	CF head;
	int num;
public:
	CL();
	~CL();
	DWORD RegisterControl(BUTTONS but, ControlFunc func, DWORD context);
	DWORD CheckControls();
};

extern BYTE gDontRead;				//the index of a controller to not read commands from

BUTTONS GetButtons(DWORD slot);

BOOL cclCheckButtons(int slot, UINT64 b);	//use slot==-1 to check all.


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\mmu.h ===
#ifndef __mmu_h_
#define __mmu_h_

BOOL muInit();
BOOL muDeinit();
void muGetDeviceMessages();
CHAR muGetDriveFromPortSlot(int port, int slot);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\log.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    log.h

Abstract:

    function declarations for log.cpp

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __log_h_
#define __log_h_

// #define _LogToDebug_ //define this to send all logged stuff to the debugger also
// #define _UseCreateFile_	//uncomment this to use CreateFile instead of fopen. *NOT RECOMMENDED, since fopen sometimes has bugs!*

#ifndef _Use_fopen_
	#define _UseCreateFile_
#endif

//#include "cpx.h"

UINT logInit(CHAR * file);
VOID logDeinit();


//logLog: used to log an event. It does formatted printing. 
//It automatically displays date & time, unless you place 
//']' at the beginning of str. 
//(']' won't be displayed if you do use it though.)
UINT logLog(const CHAR * str, ...); 
UINT logLogAndDump(const CHAR * str, ...);
void logDumpToDebug();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\modes.h ===
#ifndef __modes_h_
#define __modes_h_

#define STATUS_BOOT     (-1)    //program is starting
#define STATUS_ENTER	1		//switch to this mode
#define STATUS_NORMAL	0		//normal...
#define STATUS_LEAVE    2		//leaving a mode
#define STATUS_QUIT		(-2)	//program is quitting, so clean up.
typedef VOID (*ModeFunc)(DWORD status, INT param);			//the mode functions...

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\num.h ===
#ifndef __num_h_
#define __num_h_

//first 2 bits determine alignment
#define numALIGN_LEFT		0x00000000
#define numALIGN_RIGHT		0x00000001
#define numALIGN_CENTER		0x00000002
#define numDRAW_VERCIAL		0x00000003

//sinwave rippling
#define numRIPPLE			0x00000004

void numDrawNumbers(int num, float x, float y, float sizex, float sizey, DWORD col, DWORD flags);
void numRipple();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\draw.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    draw.h

Abstract:

    function declarations for draw.cpp

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __draw_h_
#define __draw_h_

#define _UseD3d_ //d3d works now...
// #define _UseDxConio_ //define this to use dxconio

//#include "cpx.h"

#define SCALEX(n) ((n)*(8/7))
#define SCALEY(n) ((n)*(3/2))

void drInit(int width = 640, int height = 480);
void drDeinit();
void drBox(float x1, float y1, float x2, float y2, DWORD col);
void drLine(float x1, float y1, float x2, float y2, DWORD col);
void drSetSize(float width = 7, float height = 15, DWORD col = 0xffffffff, DWORD bkcol = 0);
int drPrintf(float x1, float y1, WCHAR* format, ...);
void drGetSize(float*pwidth, float*pheight, DWORD*pcolor, DWORD*pbkcolor);
void drShowScreen();
void drBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const BYTE* pData );
void drCls();
void drQuad(float x1, float y1, DWORD c1, float x2, float y2, DWORD c2, float x3, float y3, DWORD c3, float x4, float y4, DWORD c4);
DWORD drScaledFloatToRgba(float r, float g, float b, float a);	 //floats from 0=>1
DWORD drUnscaledFloatToRgba(float r, float g, float b, float a);//floats from 0=>255
DWORD drHslToRgb(float h, float s, float l, float al);
int drGetStrSize(LPCWSTR str, int len);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\xtestlib.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    xtestlib.h

Abstract:

    This module contains the forward declaration of common routines
    in xtestlib

Author:

    Sakphong Chanbai (schanbai) 13-Mar-2000

Revision History:

--*/

#ifndef __XTESTLIB_H__
#define __XTESTLIB_H__

#ifdef __cplusplus
extern "C" {
#endif


VOID
NTAPI
FlushDiskCache(
    VOID
    );


VOID
NTAPI
RebootSystem(
    VOID
    );


BOOLEAN
NTAPI
IniRemoveStringCommentA(
    IN OUT PSTR String
    );


BOOLEAN
NTAPI
IniRemoveStringCommentW(
    IN OUT PWSTR String
    );

INT
NTAPI
GetIniInt( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN INT		nDefault,					// return value if key name not found
	IN LPCSTR	lpFileName					// initialization file name
);

FLOAT
NTAPI
GetIniFloat( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN FLOAT	fDefault,					// return value if key name not found
	IN LPCSTR	lpFileName					// initialization file name
);

INT
NTAPI
GetIniString( 
	IN LPCSTR	lpAppName,					// section name
	IN LPCSTR	lpKeyName,					// key name
	IN LPCSTR	lpDefault,					// return value if key name not found
	OUT LPSTR	lpReturnedString,			// holds the returned string
	IN DWORD	nSize,						// max size of returned string
	IN LPCSTR	lpFileName					// initialization file name
);


LPWSTR *
WINAPI
CommandLineToArgvW(
    IN LPCWSTR lpCmdLine,
    OUT int * pNumArgs
    );


LPSTR *
WINAPI
CommandLineToArgvA(
    IN LPCSTR lpCmdLine,
    OUT int * pNumArgs
    );


CHAR
WINAPI
XTestLibGetTestNameSpace(
    VOID
    );


CHAR
WINAPI
XTestLibGetTempNameSpace(
    VOID
    );


BOOL
WINAPI
XTestLibIsStressTesting(
    VOID
    );


BOOL
XTestLibIsRunningInDevkit(
    VOID
    );


ULONG
WINAPI
SetAllocationTrackingOptions(
    ULONG Flags
    );


BOOL
WINAPI
EnableAllocationTracking(
    HMODULE XeModuleHandle
    );


typedef struct _PRIVATE_HEAP_RECORD {

    HANDLE HeapHandle;
    ULONG  OwnerModuleIndex;

} PRIVATE_HEAP_RECORD, *PPRIVATE_HEAP_RECORD;


#define MAX_HEAP_HANDLE_TRACKING 1024


CONST PCHAR
WINAPI
XeModuleNameFromModuleIndex(
    ULONG ModuleIndex
    );


CONST PCHAR
WINAPI
XeModuleNameFromModuleHeader(
    PVOID ModuleHeader
    );


ULONG
WINAPI
XeModuleIndexFromAddress(
    ULONG_PTR Address
    );


CONST PVOID
WINAPI
XeModuleHeaderFromModuleIndex(
    ULONG ModuleIndex
    );


CONST PVOID
WINAPI
XeModuleHeaderFromModuleName(
    LPCSTR ModuleName
    );


PVOID
WINAPI
XTestLibLocateXImageHeader(
    VOID
    );


BOOL
WINAPI
GetHeapTrackingDatabase(
    PPRIVATE_HEAP_RECORD HeapRecordPtr,
    SIZE_T BufferSize
    );


VOID
QueryCpuTimesInformation(
    PLARGE_INTEGER KernelTime,
    PLARGE_INTEGER IdleTime,
    PLARGE_INTEGER DpcTime OPTIONAL,
    PLARGE_INTEGER InterruptTime OPTIONAL,
    PLARGE_INTEGER UserTime OPTIONAL
    );


LPSTR
WINAPI
NtStatusSymbolicName(
    IN  LONG  Status
);

LPSTR
WINAPI
WinErrorSymbolicName(
    IN  DWORD  LastError
);

#if defined( UNICODE ) || defined( _UNICODE )

#define IniRemoveStringComment     IniRemoveStringCommentW
#define CommandLineToArgv          CommandLineToArgvW

#else // UNICODE

#define IniRemoveStringComment     IniRemoveStringCommentA
#define CommandLineToArgv          CommandLineToArgvA

#endif // UNICODE


#include <profilep.h>


//
// Export table entry
//
typedef struct _EXP_TABLE_ENTRY {
    PCHAR pProcName;
    PROC pfnProc;
} EXP_TABLE_ENTRY, *PEXP_TABLE_ENTRY;


//
// Export table directory
//
typedef struct _EXP_TABLE_DIRECTORY {
    PCHAR ModuleName;
    PEXP_TABLE_ENTRY TableEntry;
} EXP_TABLE_DIRECTORY, *PEXP_TABLE_DIRECTORY;


//
// Useful macros to export functions table
//
#ifdef __cplusplus
#define __EXTRN_C extern "C"
#else
#define __EXTRN_C
#endif


#define EXPORT_SECTION_NAME ".EXP$U"


//
// Macro to define export table entry
//
#define BEGIN_EXPORT_TABLE( ModuleName ) \
    __EXTRN_C EXP_TABLE_ENTRY ModuleName##_ExportTableEntry[] = {

#define EXPORT_TABLE_ENTRY( ProcName, Proc ) \
        { ProcName, (PROC)Proc },


#define END_EXPORT_TABLE( ModuleName ) \
        { NULL, NULL } \
    };

#define DECLARE_EXPORT_DIRECTORY( ModuleName ) \
    extern EXP_TABLE_ENTRY ModuleName##_ExportTableEntry[]; \
    __EXTRN_C EXP_TABLE_DIRECTORY ModuleName##_ExportTableDirectory = { \
        #ModuleName, \
        ModuleName##_ExportTableEntry \
    };


#ifdef __cplusplus
}
#endif

#endif // __XTESTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\device.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    device.h

Abstract:

    function declarations for device.cpp

Author:

    Jason Gould (a-jasgou)   May 2000

Revision History:

--*/
#ifndef __device_h_
#define __device_h_

//#include "xbox.h"      //we do need this to access the input format data.

//#define _LogStuff_	//define this to enable logging of control pads

//#include "cpx.h"
// #define HUMAN_READABLE_LOG //uncomment this to produce a "pretty" log file

#define AGE(slot) ((TscTicksToUSeconds(TscCurrentTime(gTimeStart)) - gLastUpdate[slot]))	//get the age of the last update of a slot

#define XINPUT_GAMEPAD_DPAD_UP          0x00000001
#define XINPUT_GAMEPAD_DPAD_DOWN        0x00000002
#define XINPUT_GAMEPAD_DPAD_LEFT        0x00000004
#define XINPUT_GAMEPAD_DPAD_RIGHT       0x00000008
#define XINPUT_GAMEPAD_START            0x00000010
#define XINPUT_GAMEPAD_BACK             0x00000020
#define XINPUT_GAMEPAD_LEFT_THUMB       0x00000040
#define XINPUT_GAMEPAD_RIGHT_THUMB      0x00000080

typedef struct gpGAMEPAD{
    WORD    wButtons;
    BYTE    bAnalogButtons[8];
    SHORT   sThumbLX;
    SHORT   sThumbLY;
    SHORT   sThumbRX;
    SHORT   sThumbRY;
} gpGAMEPAD, *gpPGAMEPAD;

typedef void (*gpLOGFUNC)(UINT64 lastupdate, int slot, gpGAMEPAD * data, DWORD packet);

#define GPA                0
#define GPB                1
#define GPX                2
#define GPY                3
#define GPK                4
#define GPW                5
#define GPL                6
#define GPR                7


/*void BulkStorDeviceChangeProc(
	IN PCBULKSTOR_DEVICE_INFORMATION pdi,
	IN BOOL fAdd, 
	IN BOOL fEnum, 
	IN PVOID pvContext);
*/

INT64 gpTSecondAge(int slot);
void gpPoll();
void gpUpdateDeviceStateInfo();
DWORD gpInputSetState(int slot, IN OUT PXINPUT_FEEDBACK Feedback);
DWORD gpInit(BOOL DoMapping);
VOID gpDeinit();
_declspec(dllexport) BOOL __inline gpDeviceExists(int slot);
BOOL gpSetLogFunction(gpLOGFUNC func);
_declspec(dllexport) gpPGAMEPAD __inline gpGetState(int slot);
_declspec(dllexport) int __inline gpMaxSlots();

//*******************GLOBAL DUKE DATA*************************************************
//extern DWORD gDeviceHandle[MAX_SLOTS];				//array of deivce handles
//extern gpGAMEPAD gInputFormat[MAX_SLOTS];		//holds the 26 bytes of button states, etc.
//extern DWORD gPacket[MAX_SLOTS];                    //packet #
//extern UINT64 gLastUpdate[MAX_SLOTS];				//the last update of each slot
//extern UINT64 gTimeStart;							//beginning of time for this program
	
//*******************GLOBAL MU DATA***************************************************
//extern BULKSTOR_DEVICE_INFORMATION gMui[MAX_MUS];	//array of memory unit info
//extern DWORD gMuHandle[MAX_MUS];					//array of memory unit handles
//extern BYTE gMuID[MAX_MUS];						//IDs of the enumerated memory units


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\xpong.h ===
#ifndef __xpong_h_
#define __xpong_h_

#define _UseXpong_		//uncomment this to enable xpong

VOID XPong(DWORD context, INT param);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\inc\cpx\xsound.h ===
#pragma once

class IXsound {
public:
	static bool InitSound( CHAR** sounds, IXsound** ixsound);
	~IXsound();
	bool XPlaySound(UINT number);
};

//bool InitSound( TCHAR** sounds, XSOUNDS* );
//bool KillSound( void );
//bool XPlaySound( PONG_SOUND pong_sound );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\crypto\cryptotest.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    cryptotest.cpp

Abstract:

    test the kernel crypto stuff

Author:

    XBox online dev

Environment:

    Xbox

Revision History:

    7-2-2001 - apoulos  - Added 'xEndVariation' for all variations, replaced _alloca with 
                          HeapAlloc/HeapFree so that we don't have to increase the default
                          stack size. 

    6-7-2001 - johndaly - copied and made into 'test code' for harness

--*/

extern "C" {
    #include <ntos.h>
    #include <init.h>
    #include <hal.h>
    #include <nturtl.h>
    #include <xtl.h>
    #include <xboxp.h>
    #include <xdbg.h>
    #include <phy.h>
    #include <xbeimage.h>
    #include <ldr.h>
};
#include <des.h>
#include <sha.h>
#include <rc4.h>
#include <rsa.h>
#include <tripldes.h>
#include <modes.h>
#include "xcrypt.h"
#include <winsockx.h>
#include <xtestlib.h>
#include <xnetref.h>
#include <xlog.h>
#include <malloc.h>


LONG CryptoThreadID = 0;
#define FILE_DATA_SIZE 0x4000
#define REPEAT_LOOP 10
PVOID FileDataBuffer;
HANDLE HeapHandle;

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

// If #defined, this runs Known-Answer tests on our SHA, DES and TripleDES implementations.
#define RUN_KNOWN_ANSWER_TESTS 1


//#define AESTEST 1

#ifdef AESTEST
#include "aes.h"
#endif



// SHA Test defines ...
#define SHA_TEST_LENGTH 64
#define SHA_REPEAT_LOOP 50000

#ifdef RUN_KNOWN_ANSWER_TESTS
	#define SHA_KA_LENGTH1 3
	#define SHA_KA_LENGTH2 56
	#define SHA_KA_DIG_LEN 20
#endif



BOOL 
shatest(
    void
    )
/*++

Routine Description:

    SHA1 test for testing ROM API: XcSHAInit, XcSHAUpdate, XcSHAFinal

Arguments:

    None

Return Value:

    TRUE if test successful

--*/
{
	BYTE text[SHA_TEST_LENGTH];
	BYTE digest[A_SHA_DIGEST_LEN];
	BYTE shaDigest[XC_SERVICE_DIGEST_SIZE];
	A_SHA_CTX ctxt;
	BYTE shaCtxt[XC_SERVICE_SHA_CONTEXT_SIZE];
	DWORD dwStart,dwEnd,i;

	#ifdef RUN_KNOWN_ANSWER_TESTS
		// Known-answer test-related variables ...
		UCHAR ka_txt1[SHA_KA_LENGTH1] = {'a', 'b', 'c'};
		BYTE ka_digest1[SHA_KA_DIG_LEN] = {0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E, 0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D};
		UCHAR ka_txt2[SHA_KA_LENGTH2] = {'a', 'b', 'c', 'd', 'b', 'c', 'd', 'e', 'c', 'd', 'e', 'f', 'd', 'e', 'f', 'g', 'e', 'f', 'g', 'h', 
			'f', 'g', 'h', 'i', 'g', 'h', 'i', 'j', 'h', 'i', 'j', 'k', 'i', 'j', 'k', 'l', 'j', 'k', 'l', 'm', 'k', 'l', 'm', 'n', 'l', 'm', 'n', 'o', 'm', 'n', 'o', 'p', 'n', 'o', 'p', 'q'};
		BYTE ka_digest2[SHA_KA_DIG_LEN] = {0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE, 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1};
	#endif

    ASSERT( sizeof(ctxt) == XC_SERVICE_SHA_CONTEXT_SIZE );
    ASSERT( A_SHA_DIGEST_LEN == XC_SERVICE_DIGEST_SIZE );
    
	#ifdef RUN_KNOWN_ANSWER_TESTS
		ASSERT( SHA_KA_DIG_LEN == XC_SERVICE_DIGEST_SIZE );
	#endif

	XNetRandom( text, SHA_TEST_LENGTH );
	RtlZeroMemory( &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE );
	RtlZeroMemory( shaCtxt, XC_SERVICE_SHA_CONTEXT_SIZE );

    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        A_SHAInit( &ctxt );
        XcSHAInit( shaCtxt );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAInit", "%d times took %d ms", SHA_REPEAT_LOOP * 2, dwEnd );
    
    if (memcmp( shaCtxt, &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAInit result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        XcSHAUpdate( shaCtxt, text, SHA_TEST_LENGTH );
        A_SHAUpdate( &ctxt, text, SHA_TEST_LENGTH );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAUpdate", "%d bytes took %d ms", SHA_REPEAT_LOOP * 2 * SHA_TEST_LENGTH, dwEnd );
    
    if (memcmp( shaCtxt, &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAUpdate result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        XcSHAFinal( shaCtxt, shaDigest );
        A_SHAFinal( &ctxt, digest );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAFinal", "%d times took %d ms", SHA_REPEAT_LOOP * 2, dwEnd );
    
    if (memcmp( shaDigest, digest, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAFinal result compare failed!");
        return FALSE;
    }

	#ifdef RUN_KNOWN_ANSWER_TESTS
		// Our first known-answer test ...
		XcSHAInit( shaCtxt );
		XcSHAUpdate( shaCtxt, ka_txt1, SHA_KA_LENGTH1 );
		XcSHAFinal( shaCtxt, shaDigest );
		if (memcmp( shaDigest, ka_digest1, XC_SERVICE_DIGEST_SIZE ) != 0)
		{
			XDBGWRN("Crypto Test", " SHA known answer test 1 compare failed!");
			return FALSE;
		}

		// Our second known-answer test ...
		XcSHAInit( shaCtxt );
		XcSHAUpdate( shaCtxt, ka_txt2, SHA_KA_LENGTH2 );
		XcSHAFinal( shaCtxt, shaDigest );
		if (memcmp( shaDigest, ka_digest2, XC_SERVICE_DIGEST_SIZE ) != 0)
		{
			XDBGWRN("Crypto Test", " SHA known answer test 2 compare failed!");
			return FALSE;
		}
	#endif
			
    return TRUE;
}

#define RC4_KEY_TEST_LENGTH 16

#define RC4_TEST_LENGTH 64

#define RC4_REPEAT_LOOP 50000

BOOL 
rc4test(
    void
    )
/*++

Routine Description:

    RC4 test for testing ROM API: XcRC4Key, XcRC4Crypt 

Arguments:

    None

Return Value:

    TRUE if test successful

--*/
{
	BYTE key[RC4_KEY_TEST_LENGTH];
	BYTE text[RC4_TEST_LENGTH];
	BYTE text2[RC4_TEST_LENGTH];
	RC4_KEYSTRUCT keyStruct;
	BYTE pbkeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
	DWORD dwStart,dwEnd,i;
    
    ASSERT( sizeof(keyStruct) == XC_SERVICE_RC4_KEYSTRUCT_SIZE );
    
	XNetRandom( key, RC4_KEY_TEST_LENGTH );
	XNetRandom( text, RC4_TEST_LENGTH );
    memcpy( text2, text, RC4_TEST_LENGTH );
    
    dwStart = GetTickCount();
    for(i=0; i<RC4_REPEAT_LOOP; ++i)
    {
        rc4_key( &keyStruct, RC4_KEY_TEST_LENGTH, key );
        XcRC4Key( pbkeyStruct, RC4_KEY_TEST_LENGTH, key );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcRC4Key", "%d times for %d byte key took %d ms", RC4_REPEAT_LOOP * 2, RC4_KEY_TEST_LENGTH, dwEnd );
    
    if (memcmp( pbkeyStruct, &keyStruct, XC_SERVICE_RC4_KEYSTRUCT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Key result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<RC4_REPEAT_LOOP; ++i)
    {
        XcRC4Crypt( pbkeyStruct, RC4_TEST_LENGTH, text );
        rc4( &keyStruct, RC4_TEST_LENGTH, text2 );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcRC4Crypt", "%d bytes took %d ms", RC4_REPEAT_LOOP * 2 * RC4_TEST_LENGTH, dwEnd );
    
    if (memcmp( text, text2, RC4_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Crypt result compare failed!");
        return FALSE;
    }
    
    if (memcmp( pbkeyStruct, &keyStruct, XC_SERVICE_RC4_KEYSTRUCT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Crypt key struct result compare failed!");
        return FALSE;
    }
    
    return TRUE;
}

BYTE PrivateKeyData[] = 
    {
           0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0xA7,0xC1,0xB4,0xFE,
           0x8C,0x26,0x9A,0xCF,0xEC,0xDB,0x9F,0xAA,
           0xF0,0xCF,0x82,0xB8,0xCE,0x0E,0xD8,0x22,
           0x6D,0xDA,0x49,0xD6,0x8A,0x1C,0xFD,0x5E,
           0xAD,0xB4,0xA0,0x3E,0xA6,0xEA,0xB6,0x20,
           0xF0,0xB9,0x2C,0xC3,0x48,0x48,0x1E,0xD2,
           0x2B,0x22,0xA0,0xAF,0xA8,0x3E,0x41,0x95,
           0xB8,0x3D,0x04,0xBF,0x9E,0x58,0x3D,0x7C,
           0xF5,0x92,0x2E,0x0C,0xFD,0x85,0x67,0xC3,
           0xB2,0xE7,0x33,0x7F,0x7E,0x46,0xFC,0x2A,
           0x10,0x77,0xB4,0xB6,0x7B,0x2B,0x7C,0x70,
           0x70,0x33,0x94,0x51,0x0F,0x64,0x9E,0x1A,
           0x37,0x4D,0x5C,0x49,0xB9,0x7E,0xCE,0x1D,
           0x47,0xC7,0x72,0x90,0x61,0xC4,0xEE,0xEF,
           0xF6,0x2C,0x47,0x36,0xCD,0x4B,0x23,0x96,
           0xB2,0x24,0x2C,0xC5,0x6D,0x62,0x08,0x43,
           0x3E,0x16,0xB8,0x86,0x32,0xF3,0x12,0x91,
           0xA2,0xF4,0x42,0x19,0xCC,0xC5,0x5E,0x9C,
           0x75,0x25,0x9C,0x84,0x5A,0xBC,0xE0,0xCE,
           0x15,0x62,0xD5,0xCE,0x3E,0x30,0x1C,0x48,
           0xFA,0x1E,0x67,0xE9,0x06,0xA5,0x9E,0x9C,
           0xAB,0xEE,0x16,0xAA,0x44,0x9D,0x56,0x35,
           0xCA,0xD9,0x5A,0xC4,0xFB,0xA4,0x9A,0x39,
           0xE4,0xFD,0x8B,0x58,0xF1,0xE8,0x0C,0x45,
           0x76,0x80,0x7E,0xBB,0x57,0x68,0x32,0xC9,
           0x9C,0x3E,0x67,0x55,0x28,0xBD,0xB9,0xB4,
           0x6D,0x64,0xF1,0xB6,0x11,0x6B,0x0D,0xE9,
           0xF2,0x04,0x08,0xDB,0x2B,0x42,0x9C,0xC5,
           0x17,0x0D,0x86,0xE9,0x40,0x32,0x75,0x6E,
           0x51,0x7D,0xF6,0x4C,0x7E,0xA8,0x97,0x3A,
           0x95,0x31,0x20,0x7A,0x66,0xBF,0xE2,0x79,
           0xCF,0xC5,0x4A,0xA1,0xDF,0x9A,0x1E,0x52,
           0x8C,0x2B,0xF9,0xAB,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x49,0xFB,0xD0,0x56,
           0x36,0x69,0xEF,0x00,0x98,0x35,0x83,0x42,
           0x42,0xF9,0x14,0x52,0x81,0xF7,0xA9,0x8E,
           0x57,0x95,0xE9,0xA8,0xD6,0x01,0x8B,0x84,
           0x55,0xE9,0xEF,0x2E,0xCC,0x94,0x50,0x11,
           0x97,0x10,0x9E,0xF3,0x18,0xC3,0xAB,0x6E,
           0x04,0x08,0x90,0xD8,0x9D,0x97,0x04,0x37,
           0xB3,0x7E,0x57,0x1C,0xA3,0x97,0xE5,0x5B,
           0x85,0x18,0x8C,0xD2,0xAC,0xE8,0x97,0xF3,
           0x7A,0x19,0xCC,0x93,0xC1,0xCC,0xAE,0x53,
           0x6E,0xCE,0xFC,0x18,0xE3,0xAA,0xB3,0x26,
           0x72,0xA2,0x48,0x52,0xD0,0xCE,0xB2,0xC9,
           0x61,0x8D,0x15,0xB3,0xF7,0xF4,0x9A,0x7B,
           0xF6,0x85,0x93,0xF6,0xCF,0xDD,0x04,0xCA,
           0xC8,0x9A,0xCA,0x40,0xDA,0x9F,0x5D,0x9C,
           0x49,0x43,0x41,0x89,0xB8,0x4C,0xB6,0x0C,
           0x3D,0xE3,0x8F,0xDA,0x00,0x00,0x00,0x00,
           0x6F,0x65,0x54,0xDB,0x9B,0x37,0x53,0xF2,
           0x5C,0xEF,0x3F,0x49,0x5F,0xAC,0x41,0xA9,
           0xAB,0xE4,0x9F,0x49,0xA3,0x1E,0x84,0xEB,
           0x4A,0x8D,0xED,0xBB,0x12,0x0D,0xA4,0xF9,
           0x72,0x3E,0xE3,0x28,0x92,0x44,0xE4,0x1C,
           0x18,0xFF,0xC3,0xCB,0xCE,0xBD,0x78,0x96,
           0x54,0x0B,0x93,0xCF,0x52,0x47,0x0A,0x5C,
           0xD6,0xC6,0x38,0xA1,0xBE,0x22,0x48,0x8A,
           0x36,0xCD,0x79,0x1B,0x4C,0xB2,0xB2,0x84,
           0x7E,0x35,0x22,0x2D,0x3C,0xB6,0xF1,0x10,
           0x73,0x06,0x72,0x0C,0xD8,0x40,0xC6,0xE2,
           0x82,0xD5,0x47,0xF8,0x45,0x02,0xC9,0xA0,
           0x91,0xF6,0x21,0x34,0x52,0x6B,0xEB,0x73,
           0x42,0x11,0xA4,0x1E,0x08,0x6B,0xD2,0x8A,
           0x76,0xE3,0xFA,0x85,0xA8,0x7F,0x89,0xDF,
           0xEB,0xE8,0x4F,0x51,0xB0,0x54,0x6E,0xC9,
           0x00,0x00,0x00,0x00,0xF1,0x60,0x2C,0x21,
           0xB9,0xEE,0x5A,0x12,0x18,0xED,0x07,0x9E,
           0x0D,0x10,0xFC,0x3C,0x72,0xCD,0x5B,0x10,
           0xE2,0xC2,0x11,0x94,0x94,0x3C,0x6A,0xCE,
           0x7C,0xD0,0x52,0x07,0x32,0x6B,0xEF,0xAA,
           0x7A,0x4B,0xD6,0x3A,0x18,0x35,0xE8,0x2B,
           0xFE,0xE9,0x0D,0xF5,0x11,0x01,0xD1,0x4C,
           0x24,0x0B,0xC4,0xC7,0x6A,0xF3,0x26,0xB8,
           0x6E,0x17,0x4F,0xA0,0x61,0x54,0x85,0x4B,
           0x84,0x6C,0xDD,0x94,0xAC,0x60,0x07,0xD8,
           0x78,0xCD,0xFD,0x78,0x33,0xC7,0xB2,0xD1,
           0xF1,0x7A,0xBE,0x5F,0xA9,0x99,0x0F,0xE9,
           0x1B,0xF9,0x95,0x17,0xBB,0xF7,0x41,0x8A,
           0x84,0xA5,0x3B,0xA0,0xC3,0xBD,0x62,0xC4,
           0x16,0xC3,0x56,0x5C,0xCE,0xDE,0x86,0xD9,
           0xB3,0xB3,0x10,0xB5,0x10,0xEE,0x5A,0xE1,
           0xB6,0x95,0xF4,0x1F,0x00,0x00,0x00,0x00,
           0xF9,0x91,0xAE,0xCD,0x61,0xA5,0x8B,0xD4,
           0xDA,0x1F,0xC2,0x97,0x91,0x72,0x22,0x55,
           0xF7,0x4F,0xAF,0x79,0x53,0x1D,0x28,0xF6,
           0x01,0xE0,0xD1,0x96,0x0F,0x0E,0x3C,0xD4,
           0x20,0x9E,0x43,0x96,0x01,0x4D,0x42,0x8C,
           0x78,0x5E,0xCC,0xE3,0xA5,0x65,0xAF,0x4A,
           0xD9,0xE4,0xBD,0x13,0x80,0xF8,0x7F,0x4B,
           0xE5,0x74,0x5C,0x51,0x0F,0xB0,0x50,0x93,
           0x8D,0xA9,0xA8,0xD2,0xEC,0x59,0x56,0x12,
           0xD9,0x18,0xC1,0x0E,0x4C,0x85,0x59,0xFE,
           0x8E,0x9B,0x0F,0x00,0x58,0xF4,0xFE,0x84,
           0x36,0x90,0x27,0x92,0xB0,0xDD,0x0F,0xB8,
           0x23,0x87,0x16,0xC8,0xD2,0x21,0x39,0x84,
           0x17,0x24,0x8F,0xB3,0x7C,0x39,0x33,0xD0,
           0xD7,0xBD,0x76,0xF2,0x8A,0xBA,0xCE,0x66,
           0xDE,0x98,0xE8,0x6A,0x2B,0x7C,0x38,0x41,
           0x00,0x00,0x00,0x00,0xE1,0x34,0x07,0x45,
           0x19,0x30,0xC0,0xC3,0xEC,0x82,0x88,0x6E,
           0x8C,0x39,0xC0,0xBA,0xAC,0x0B,0x34,0x2A,
           0x00,0xB5,0x32,0xED,0xAE,0xA0,0xAB,0x79,
           0x92,0xE7,0x61,0x67,0xA3,0xC4,0x35,0x3A,
           0x55,0x38,0x0C,0x37,0x06,0xE9,0xE1,0x34,
           0x12,0x41,0xEA,0xB2,0x62,0x31,0xA5,0x26,
           0x8A,0x04,0xB2,0x46,0x95,0xCB,0x48,0xCC,
           0xE4,0x81,0x7C,0x15,0x66,0x23,0x2D,0x30,
           0xD5,0xA0,0xEE,0x6D,0x2F,0x0B,0x18,0x9B,
           0xBE,0x98,0xC5,0x2A,0xDA,0x24,0x5F,0xF8,
           0xA5,0xEC,0xFB,0x83,0x76,0x2F,0x8C,0x16,
           0x21,0x4E,0xEA,0x72,0xED,0x81,0xBA,0xC0,
           0x7D,0x19,0x22,0x9A,0x01,0xF3,0x67,0x3B,
           0x01,0xB3,0x2F,0xE1,0xDB,0x4F,0xCA,0xC7,
           0x14,0x8C,0x55,0x3C,0x0B,0x0C,0xB0,0x7C,
           0x97,0xC5,0x02,0x8E,0x00,0x00,0x00,0x00,
           0x91,0x24,0x79,0x59,0x78,0x0B,0x98,0x3B,
           0x2C,0xC3,0xA5,0x1F,0x1D,0x07,0xC7,0xD6,
           0x03,0xF4,0xC6,0x2B,0x2A,0x27,0xB2,0xCB,
           0xB9,0xE8,0xDB,0xE8,0x36,0x04,0x67,0x6A,
           0xCF,0x46,0x50,0x50,0xD7,0xD3,0x24,0x98,
           0x9C,0x20,0xE1,0x26,0xE7,0x22,0x2A,0xD6,
           0x61,0xBD,0xA9,0xD2,0x86,0x81,0x44,0xAE,
           0x12,0x31,0xDB,0xEF,0xC3,0x02,0xCA,0xC1,
           0xB0,0x2F,0x8E,0x2E,0x4B,0x66,0x9A,0x8E,
           0xD9,0x93,0x43,0xF7,0x51,0x69,0x5A,0x5E,
           0x74,0x22,0xEE,0x6B,0x20,0x03,0x61,0xDD,
           0xDE,0xFD,0x72,0x8C,0xA1,0xA4,0xDC,0xAD,
           0x6F,0x99,0x62,0x8B,0xD4,0x4E,0x4C,0xAD,
           0xD8,0x89,0x72,0xD9,0xCF,0x3C,0xC4,0x19,
           0x05,0xBC,0x6A,0x8B,0x15,0x10,0x56,0x6B,
           0x5D,0x5D,0x4F,0x8F,0x26,0xDC,0x1C,0x42,
           0x62,0x16,0x66,0x0B,0x81,0xB2,0x47,0x0F,
           0xDA,0x56,0xD9,0xA5,0x96,0x1B,0x0D,0x82,
           0xEF,0x52,0x10,0x4B,0xD9,0x0A,0x67,0x28,
           0xBC,0x1F,0x8D,0x4B,0xF1,0xB2,0x87,0x00,
           0xC1,0x6E,0x0F,0x08,0xB9,0x1C,0x83,0xBA,
           0x01,0xF4,0x22,0x73,0x16,0x18,0x8B,0x1D,
           0x63,0x00,0xCC,0x78,0x6C,0xF8,0xE5,0x3B,
           0x11,0x45,0xE9,0x66,0x03,0x88,0x7A,0x51,
           0x3D,0x63,0x2A,0x49,0x9A,0xF8,0xF6,0x3D,
           0xE1,0xCB,0x8F,0x40,0x47,0x54,0x5B,0x94,
           0x86,0x2C,0x8B,0xB9,0x86,0xCA,0x0D,0x66,
           0x02,0x95,0x54,0xFD,0x76,0x55,0x32,0x20,
           0xFB,0x76,0xD2,0x36,0x39,0xAF,0x0C,0x82,
           0xDE,0x59,0x88,0xD9,0x1F,0xD2,0x68,0x20,
           0x67,0xDE,0x5A,0xC2,0x56,0x40,0x52,0xF4,
           0x9C,0x36,0xDB,0xE1,0xA7,0x9F,0x0E,0x52,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

BYTE PublicKeyData[] = 
    {
           0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0xA7,0xC1,0xB4,0xFE,
           0x8C,0x26,0x9A,0xCF,0xEC,0xDB,0x9F,0xAA,
           0xF0,0xCF,0x82,0xB8,0xCE,0x0E,0xD8,0x22,
           0x6D,0xDA,0x49,0xD6,0x8A,0x1C,0xFD,0x5E,
           0xAD,0xB4,0xA0,0x3E,0xA6,0xEA,0xB6,0x20,
           0xF0,0xB9,0x2C,0xC3,0x48,0x48,0x1E,0xD2,
           0x2B,0x22,0xA0,0xAF,0xA8,0x3E,0x41,0x95,
           0xB8,0x3D,0x04,0xBF,0x9E,0x58,0x3D,0x7C,
           0xF5,0x92,0x2E,0x0C,0xFD,0x85,0x67,0xC3,
           0xB2,0xE7,0x33,0x7F,0x7E,0x46,0xFC,0x2A,
           0x10,0x77,0xB4,0xB6,0x7B,0x2B,0x7C,0x70,
           0x70,0x33,0x94,0x51,0x0F,0x64,0x9E,0x1A,
           0x37,0x4D,0x5C,0x49,0xB9,0x7E,0xCE,0x1D,
           0x47,0xC7,0x72,0x90,0x61,0xC4,0xEE,0xEF,
           0xF6,0x2C,0x47,0x36,0xCD,0x4B,0x23,0x96,
           0xB2,0x24,0x2C,0xC5,0x6D,0x62,0x08,0x43,
           0x3E,0x16,0xB8,0x86,0x32,0xF3,0x12,0x91,
           0xA2,0xF4,0x42,0x19,0xCC,0xC5,0x5E,0x9C,
           0x75,0x25,0x9C,0x84,0x5A,0xBC,0xE0,0xCE,
           0x15,0x62,0xD5,0xCE,0x3E,0x30,0x1C,0x48,
           0xFA,0x1E,0x67,0xE9,0x06,0xA5,0x9E,0x9C,
           0xAB,0xEE,0x16,0xAA,0x44,0x9D,0x56,0x35,
           0xCA,0xD9,0x5A,0xC4,0xFB,0xA4,0x9A,0x39,
           0xE4,0xFD,0x8B,0x58,0xF1,0xE8,0x0C,0x45,
           0x76,0x80,0x7E,0xBB,0x57,0x68,0x32,0xC9,
           0x9C,0x3E,0x67,0x55,0x28,0xBD,0xB9,0xB4,
           0x6D,0x64,0xF1,0xB6,0x11,0x6B,0x0D,0xE9,
           0xF2,0x04,0x08,0xDB,0x2B,0x42,0x9C,0xC5,
           0x17,0x0D,0x86,0xE9,0x40,0x32,0x75,0x6E,
           0x51,0x7D,0xF6,0x4C,0x7E,0xA8,0x97,0x3A,
           0x95,0x31,0x20,0x7A,0x66,0xBF,0xE2,0x79,
           0xCF,0xC5,0x4A,0xA1,0xDF,0x9A,0x1E,0x52,
           0x8C,0x2B,0xF9,0xAB,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

#define PK_KEY_TEST_BIT_LENGTH 2048

#define PK_REPEAT_LOOP 5

BOOL 
pktest(
    void
    )
/*++

Routine Description:

    pktest

Arguments:

    None

Return Value:

    TRUE if test successful

--*/
{
	BYTE* text1;
	BYTE* text2;
	BYTE* text3;
	BYTE* temp1;
	BYTE* temp2;
	BYTE* prvKey;
	BYTE* pubKey;
	DWORD pubKeySize, prvKeySize;
	DWORD bits;
	DWORD dwStart,dwEnd,i;
	DWORD keyLength,dataLength;
	DWORD result1,result2;
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)PublicKeyData;
    BOOL bRetVal = TRUE;
    
    bits = PK_KEY_TEST_BIT_LENGTH;
	result1 = BSafeComputeKeySizes( &pubKeySize, &prvKeySize, &bits );
    ASSERT( result1 );

    ASSERT( pubKeySize == sizeof(PublicKeyData) );
    ASSERT( prvKeySize == sizeof(PrivateKeyData) );

    keyLength = XcPKGetKeyLen( PublicKeyData );
    if (keyLength != pPubKey->keylen)
    {
        XDBGWRN("Crypto Test", " XcPKGetKeyLen return bad length %d!", keyLength);
        return FALSE;
    }

    dataLength = pPubKey->datalen;
    
    XDBGTRC("Crypto Test", "XcPKEncPublic Keylen = %d, datalen = %d", keyLength, dataLength);

	//  (apoulos) - Replaced use of _alloca with HeapAlloc.
	/*
	text1 = (BYTE*)_alloca( keyLength );
	text2 = (BYTE*)_alloca( keyLength );
	text3 = (BYTE*)_alloca( keyLength );
	temp1 = (BYTE*)_alloca( keyLength );
	temp2 = (BYTE*)_alloca( keyLength );
	*/ 
	
	text1 = (BYTE *) HeapAlloc (HeapHandle, 0L, keyLength);
	text2 = (BYTE *) HeapAlloc (HeapHandle, 0L, keyLength);
	text3 = (BYTE *) HeapAlloc (HeapHandle, 0L, keyLength);
	temp1 = (BYTE *) HeapAlloc (HeapHandle, 0L, keyLength);
	temp2 = (BYTE *) HeapAlloc (HeapHandle, 0L, keyLength);

    if (NULL == text1 ||
        NULL == text2 ||
        NULL == text3 ||
        NULL == temp1 ||
        NULL == temp2) {
        bRetVal = FALSE;
        goto cleanup;
    }

    RtlZeroMemory( text1, keyLength );
	XNetRandom( text1, dataLength );
	memcpy( text2, text1, keyLength );
	memcpy( text3, text1, keyLength );

    dwStart = GetTickCount();
    for(i=0; i<PK_REPEAT_LOOP; ++i)
    {
        result1 = XcPKEncPublic( PublicKeyData, text1, temp1 );
        result2 = BSafeEncPublic((LPBSAFE_PUB_KEY)PublicKeyData, text2, temp2);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcPKEncPublic", "%d times for %d byte key took %d ms", PK_REPEAT_LOOP * 2, dataLength, dwEnd );
    
    if (!result1 || !result2)
    {
        XDBGWRN("Crypto Test", " XcPKEncPublic failed %d %d!", result1, result2);
        bRetVal = FALSE;
        goto cleanup;
    }
    
    if (memcmp( temp1, temp2, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKEncPublic result compare failed!");
        bRetVal = FALSE;
        goto cleanup;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<PK_REPEAT_LOOP; ++i)
    {
        result1 = XcPKDecPrivate( PrivateKeyData, temp1, text1 );
        result2 = BSafeDecPrivate((LPBSAFE_PRV_KEY)PrivateKeyData, temp2, text2 );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcPKDecPrivate", "%d times for %d byte key took %d ms", PK_REPEAT_LOOP * 2, dataLength, dwEnd );
    
    if (!result1 || !result2)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate failed %d %d!", result1, result2);
        bRetVal = FALSE;
        goto cleanup;
    }
    
    if (memcmp( text1, text2, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate result compare failed!");
        bRetVal = FALSE;
        goto cleanup;
    }
    
    if (memcmp( text1, text3, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate result compare failed!");
        bRetVal = FALSE;
        goto cleanup;
    }
	
    cleanup:
	// Free heap-allocated resources ...
	if (NULL != text1)
	{
		HeapFree (HeapHandle, 0L, text1);
		text1 = NULL;
	}	

	if (NULL != text2)
	{
		HeapFree (HeapHandle, 0L, text2);
		text2 = NULL;
	}	

	if (NULL != text3)
	{
		HeapFree (HeapHandle, 0L, text3);
		text3 = NULL;
	}	

	if (NULL != temp1)
	{
		HeapFree (HeapHandle, 0L, temp1);
		temp1 = NULL;
	}	

	if (NULL != temp2)
	{
		HeapFree (HeapHandle, 0L, temp2);
		temp2 = NULL;
	}	
	
    return bRetVal;
}

#define DES_TEST_LENGTH 512

#define DES_REPEAT_LOOP 1000

#ifdef RUN_KNOWN_ANSWER_TESTS
	#define DES_NUM_KA_VECTORS 19
#endif


BOOL 
destest(
    void
    )
/*++

Routine Description:

     Single DES test for testing ROM API: XcDESKeyParity, XcDESKey, XcBlockCryptCBC 

Arguments:

    None

Return Value:

    TRUE if test successful

--*/
{
	BYTE text[DES_TEST_LENGTH];
	BYTE saveText[DES_TEST_LENGTH];
	BYTE saveCText[DES_TEST_LENGTH];
	BYTE key[XC_SERVICE_DES_KEYSIZE];
	BYTE saveKey[XC_SERVICE_DES_KEYSIZE];
	BYTE iv[XC_SERVICE_DES_BLOCKLEN];
	BYTE fb[XC_SERVICE_DES_BLOCKLEN];
	DESTable desTable;
	BYTE XCDESTable[XC_SERVICE_DES_TABLESIZE];
	DWORD dwStart,dwEnd,i,j;
  

	// Known-answer test-related vars ...
	#ifdef RUN_KNOWN_ANSWER_TESTS
		BYTE ka_keys[DES_NUM_KA_VECTORS][XC_SERVICE_DES_KEYSIZE] = 
			{{0x7C, 0xA1, 0x10, 0x45, 0x4A, 0x1A, 0x6E, 0x57}, 
			 {0x01, 0x31, 0xD9, 0x61, 0x9D, 0xC1, 0x37, 0x6E}, 
			 {0x07, 0xA1, 0x13, 0x3E, 0x4A, 0x0B, 0x26, 0x86}, 
			 {0x38, 0x49, 0x67, 0x4C, 0x26, 0x02, 0x31, 0x9E}, 
			 {0x04, 0xB9, 0x15, 0xBA, 0x43, 0xFE, 0xB5, 0xB6}, 
			 {0x01, 0x13, 0xB9, 0x70, 0xFD, 0x34, 0xF2, 0xCE}, 
			 {0x01, 0x70, 0xF1, 0x75, 0x46, 0x8F, 0xB5, 0xE6}, 
			 {0x43, 0x29, 0x7F, 0xAD, 0x38, 0xE3, 0x73, 0xFE}, 
			 {0x07, 0xA7, 0x13, 0x70, 0x45, 0xDA, 0x2A, 0x16}, 
			 {0x04, 0x68, 0x91, 0x04, 0xC2, 0xFD, 0x3B, 0x2F}, 
			 {0x37, 0xD0, 0x6B, 0xB5, 0x16, 0xCB, 0x75, 0x46}, 
			 {0x1F, 0x08, 0x26, 0x0D, 0x1A, 0xC2, 0x46, 0x5E}, 
			 {0x58, 0x40, 0x23, 0x64, 0x1A, 0xBA, 0x61, 0x76}, 
			 {0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xB0, 0x07}, 
			 {0x49, 0x79, 0x3E, 0xBC, 0x79, 0xB3, 0x25, 0x8F}, 
			 {0x4F, 0xB0, 0x5E, 0x15, 0x15, 0xAB, 0x73, 0xA7}, 
			 {0x49, 0xE9, 0x5D, 0x6D, 0x4C, 0xA2, 0x29, 0xBF}, 
			 {0x01, 0x83, 0x10, 0xDC, 0x40, 0x9B, 0x26, 0xD6}, 
			 {0x1C, 0x58, 0x7F, 0x1C, 0x13, 0x92, 0x4F, 0xEF}} ;

		BYTE ka_pts[DES_NUM_KA_VECTORS][8] = 
			{{0x01, 0xA1, 0xD6, 0xD0, 0x39, 0x77, 0x67, 0x42}, 
			 {0x5C, 0xD5, 0x4C, 0xA8, 0x3D, 0xEF, 0x57, 0xDA}, 
			 {0x02, 0x48, 0xD4, 0x38, 0x06, 0xF6, 0x71, 0x72}, 
			 {0x51, 0x45, 0x4B, 0x58, 0x2D, 0xDF, 0x44, 0x0A}, 
			 {0x42, 0xFD, 0x44, 0x30, 0x59, 0x57, 0x7F, 0xA2}, 
			 {0x05, 0x9B, 0x5E, 0x08, 0x51, 0xCF, 0x14, 0x3A}, 
			 {0x07, 0x56, 0xD8, 0xE0, 0x77, 0x47, 0x61, 0xD2}, 
			 {0x76, 0x25, 0x14, 0xB8, 0x29, 0xBF, 0x48, 0x6A}, 
			 {0x3B, 0xDD, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02}, 
			 {0x26, 0x95, 0x5F, 0x68, 0x35, 0xAF, 0x60, 0x9A}, 
			 {0x16, 0x4D, 0x5E, 0x40, 0x4F, 0x27, 0x52, 0x32}, 
			 {0x6B, 0x05, 0x6E, 0x18, 0x75, 0x9F, 0x5C, 0xCA}, 
			 {0x00, 0x4B, 0xD6, 0xEF, 0x09, 0x17, 0x60, 0x62}, 
			 {0x48, 0x0D, 0x39, 0x00, 0x6E, 0xE7, 0x62, 0xF2}, 
			 {0x43, 0x75, 0x40, 0xC8, 0x69, 0x8F, 0x3C, 0xFA}, 
			 {0x07, 0x2D, 0x43, 0xA0, 0x77, 0x07, 0x52, 0x92}, 
			 {0x02, 0xFE, 0x55, 0x77, 0x81, 0x17, 0xF1, 0x2A}, 
			 {0x1D, 0x9D, 0x5C, 0x50, 0x18, 0xF7, 0x28, 0xC2}, 
			 {0x30, 0x55, 0x32, 0x28, 0x6D, 0x6F, 0x29, 0x5A}} ;

		BYTE ka_cts[DES_NUM_KA_VECTORS][8] = 
			{{0x69, 0x0F, 0x5B, 0x0D, 0x9A, 0x26, 0x93, 0x9B},
			 {0x7A, 0x38, 0x9D, 0x10, 0x35, 0x4B, 0xD2, 0x71},
			 {0x86, 0x8E, 0xBB, 0x51, 0xCA, 0xB4, 0x59, 0x9A},
			 {0x71, 0x78, 0x87, 0x6E, 0x01, 0xF1, 0x9B, 0x2A},
			 {0xAF, 0x37, 0xFB, 0x42, 0x1F, 0x8C, 0x40, 0x95},
			 {0x86, 0xA5, 0x60, 0xF1, 0x0E, 0xC6, 0xD8, 0x5B},
			 {0x0C, 0xD3, 0xDA, 0x02, 0x00, 0x21, 0xDC, 0x09},
			 {0xEA, 0x67, 0x6B, 0x2C, 0xB7, 0xDB, 0x2B, 0x7A},
			 {0xDF, 0xD6, 0x4A, 0x81, 0x5C, 0xAF, 0x1A, 0x0F},
			 {0x5C, 0x51, 0x3C, 0x9C, 0x48, 0x86, 0xC0, 0x88},
			 {0x0A, 0x2A, 0xEE, 0xAE, 0x3F, 0xF4, 0xAB, 0x77},
			 {0xEF, 0x1B, 0xF0, 0x3E, 0x5D, 0xFA, 0x57, 0x5A},
			 {0x88, 0xBF, 0x0D, 0xB6, 0xD7, 0x0D, 0xEE, 0x56},
			 {0xA1, 0xF9, 0x91, 0x55, 0x41, 0x02, 0x0B, 0x56},
			 {0x6F, 0xBF, 0x1C, 0xAF, 0xCF, 0xFD, 0x05, 0x56},
			 {0x2F, 0x22, 0xE4, 0x9B, 0xAB, 0x7C, 0xA1, 0xAC},
			 {0x5A, 0x6B, 0x61, 0x2C, 0xC2, 0x6C, 0xCE, 0x4A},
			 {0x5F, 0x4C, 0x03, 0x8E, 0xD1, 0x2B, 0x2E, 0x41},
			 {0x63, 0xFA, 0xC0, 0xD0, 0x34, 0xD9, 0xF7, 0x93}} ;

		BYTE zeroes[] = {0, 0, 0, 0, 0, 0, 0, 0};	
	#endif

    ASSERT( sizeof(desTable) == XC_SERVICE_DES_TABLESIZE );
    
	XNetRandom( text, DES_TEST_LENGTH );
	XNetRandom( key, XC_SERVICE_DES_KEYSIZE );
	XNetRandom( iv, XC_SERVICE_DES_BLOCKLEN );

	memcpy(saveKey, key, XC_SERVICE_DES_KEYSIZE);
    XcDESKeyParity(key, XC_SERVICE_DES_KEYSIZE);

    desparityonkey(saveKey, XC_SERVICE_DES_KEYSIZE);
    if (memcmp( key, saveKey, XC_SERVICE_DES_KEYSIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " desparityonkey result compare failed!");
        return FALSE;
    }

    XcKeyTable(XC_SERVICE_DES_CIPHER, XCDESTable, key);

    deskey(&desTable, saveKey);
    if (memcmp( (BYTE*)&desTable, XCDESTable, XC_SERVICE_DES_TABLESIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " deskey result compare failed!");
        return FALSE;
    }

	memcpy(saveText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, DES_TEST_LENGTH, text, text, XCDESTable, XC_SERVICE_ENCRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(des, 8, text+j, text+j, &desTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("RSA DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(des, 8, text+j, text+j, &desTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
    XDBGENT("RSA DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveCText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, DES_TEST_LENGTH, text, text, XCDESTable, XC_SERVICE_DECRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }


	// Run all of the Known-answer tests ...
	#ifdef RUN_KNOWN_ANSWER_TESTS
		for (i=0; i<DES_NUM_KA_VECTORS; i++) 
		{
			memcpy (key, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
			memcpy (fb,zeroes,8);
			memcpy (text, ka_pts[i], 8);

			XcDESKeyParity (key, XC_SERVICE_DES_KEYSIZE);
			XcKeyTable (XC_SERVICE_DES_CIPHER, XCDESTable, key);

			XcBlockCryptCBC (XC_SERVICE_DES_CIPHER, 8, text, text, XCDESTable, XC_SERVICE_ENCRYPT, fb);
			if (memcmp (ka_cts[i], text, 8 ) != 0)
			{
				XDBGWRN ("Crypto Test", " Known Answer DES encryption compare failed!");
				return FALSE;
			}

			memcpy (fb,zeroes,8);
			XcBlockCryptCBC (XC_SERVICE_DES_CIPHER, 8, text, text, XCDESTable, XC_SERVICE_DECRYPT, fb);
			if (memcmp (ka_pts[i], text, 8 ) != 0)
			{
				XDBGWRN ("Crypto Test", " Known Answer DES decryption compare failed!");
				return FALSE;
			}
		}
	#endif

    return TRUE;
}


#ifdef RUN_KNOWN_ANSWER_TESTS
	#define DES3_NUM_KA_VECTORS 19
	#define DES3_NUM_KA_IVS 3
#endif




BOOL 
des3test(
    void
    )
/*++

Routine Description:

     Triple DES test for testing ROM API: XcDESKeyParity, XcDESKey, XcBlockCryptCBC 

Arguments:

    None

Return Value:

    TRUE if test successful

--*/
{
	BYTE text[DES_TEST_LENGTH];
	BYTE saveText[DES_TEST_LENGTH];
	BYTE saveCText[DES_TEST_LENGTH];
	BYTE key[XC_SERVICE_DES3_KEYSIZE];
	BYTE saveKey[XC_SERVICE_DES3_KEYSIZE];
	BYTE iv[XC_SERVICE_DES_BLOCKLEN];
	BYTE fb[XC_SERVICE_DES_BLOCKLEN];
	DES3TABLE desTable;
	BYTE XCDES3Table[XC_SERVICE_DES3_TABLESIZE];
	DWORD dwStart,dwEnd,i,j;

	#ifdef RUN_KNOWN_ANSWER_TESTS
		BYTE ka_keys[DES3_NUM_KA_VECTORS][XC_SERVICE_DES3_KEYSIZE] = 
			{{0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57},
			 {0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e},
			 {0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86},
			 {0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e},
			 {0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6},
			 {0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce},
			 {0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6},
			 {0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe},
			 {0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16},
			 {0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f},
			 {0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46},
			 {0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e},
			 {0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76},
			 {0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07},
			 {0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f},
			 {0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7},
			 {0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf},
			 {0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6},
			 {0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef}};

		BYTE ka_pts[DES3_NUM_KA_VECTORS][8] = 
			{{0x01, 0xa1, 0xd6, 0xd0, 0x39, 0x77, 0x67, 0x42}, 
			 {0x5c, 0xd5, 0x4c, 0xa8, 0x3d, 0xef, 0x57, 0xda}, 
			 {0x02, 0x48, 0xd4, 0x38, 0x06, 0xf6, 0x71, 0x72}, 
			 {0x51, 0x45, 0x4b, 0x58, 0x2d, 0xdf, 0x44, 0x0a}, 
			 {0x42, 0xfd, 0x44, 0x30, 0x59, 0x57, 0x7f, 0xa2}, 
			 {0x05, 0x9b, 0x5e, 0x08, 0x51, 0xcf, 0x14, 0x3a}, 
			 {0x07, 0x56, 0xd8, 0xe0, 0x77, 0x47, 0x61, 0xd2}, 
			 {0x76, 0x25, 0x14, 0xb8, 0x29, 0xbf, 0x48, 0x6a}, 
			 {0x3b, 0xdd, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02}, 
			 {0x26, 0x95, 0x5f, 0x68, 0x35, 0xaf, 0x60, 0x9a}, 
			 {0x16, 0x4d, 0x5e, 0x40, 0x4f, 0x27, 0x52, 0x32}, 
			 {0x6b, 0x05, 0x6e, 0x18, 0x75, 0x9f, 0x5c, 0xca}, 
			 {0x00, 0x4b, 0xd6, 0xef, 0x09, 0x17, 0x60, 0x62}, 
			 {0x48, 0x0d, 0x39, 0x00, 0x6e, 0xe7, 0x62, 0xf2}, 
			 {0x43, 0x75, 0x40, 0xc8, 0x69, 0x8f, 0x3c, 0xfa}, 
			 {0x07, 0x2d, 0x43, 0xa0, 0x77, 0x07, 0x52, 0x92}, 
			 {0x02, 0xfe, 0x55, 0x77, 0x81, 0x17, 0xf1, 0x2a}, 
			 {0x1d, 0x9d, 0x5c, 0x50, 0x18, 0xf7, 0x28, 0xc2}, 
			 {0x30, 0x55, 0x32, 0x28, 0x6d, 0x6f, 0x29, 0x5a}};

		BYTE ka_cts[DES3_NUM_KA_IVS][DES3_NUM_KA_VECTORS][8] = 
			{
			{{0x69, 0x0f, 0x5b, 0x0d, 0x9a, 0x26, 0x93, 0x9b}, 
			 {0x7a, 0x38, 0x9d, 0x10, 0x35, 0x4b, 0xd2, 0x71}, 
			 {0x86, 0x8e, 0xbb, 0x51, 0xca, 0xb4, 0x59, 0x9a}, 
			 {0x71, 0x78, 0x87, 0x6e, 0x01, 0xf1, 0x9b, 0x2a}, 
			 {0xaf, 0x37, 0xfb, 0x42, 0x1f, 0x8c, 0x40, 0x95}, 
			 {0x86, 0xa5, 0x60, 0xf1, 0x0e, 0xc6, 0xd8, 0x5b}, 
			 {0x0c, 0xd3, 0xda, 0x02, 0x00, 0x21, 0xdc, 0x09}, 
			 {0xea, 0x67, 0x6b, 0x2c, 0xb7, 0xdb, 0x2b, 0x7a}, 
			 {0xdf, 0xd6, 0x4a, 0x81, 0x5c, 0xaf, 0x1a, 0x0f}, 
			 {0x5c, 0x51, 0x3c, 0x9c, 0x48, 0x86, 0xc0, 0x88}, 
			 {0x0a, 0x2a, 0xee, 0xae, 0x3f, 0xf4, 0xab, 0x77}, 
			 {0xef, 0x1b, 0xf0, 0x3e, 0x5d, 0xfa, 0x57, 0x5a}, 
			 {0x88, 0xbf, 0x0d, 0xb6, 0xd7, 0x0d, 0xee, 0x56}, 
			 {0xa1, 0xf9, 0x91, 0x55, 0x41, 0x02, 0x0b, 0x56}, 
			 {0x6f, 0xbf, 0x1c, 0xaf, 0xcf, 0xfd, 0x05, 0x56}, 
			 {0x2f, 0x22, 0xe4, 0x9b, 0xab, 0x7c, 0xa1, 0xac}, 
			 {0x5a, 0x6b, 0x61, 0x2c, 0xc2, 0x6c, 0xce, 0x4a}, 
			 {0x5f, 0x4c, 0x03, 0x8e, 0xd1, 0x2b, 0x2e, 0x41}, 
			 {0x63, 0xfa, 0xc0, 0xd0, 0x34, 0xd9, 0xf7, 0x93}},

			{{0x89, 0x20, 0x2f, 0x22, 0x4f, 0x1f, 0x22, 0x61}, 
			 {0x6d, 0xda, 0x0d, 0xe9, 0x9d, 0x3c, 0x86, 0xb9}, 
			 {0x82, 0x00, 0x61, 0x6c, 0x58, 0x9b, 0xc7, 0xaa}, 
			 {0x64, 0x75, 0x72, 0x92, 0xfe, 0xbc, 0xca, 0xd1}, 
			 {0x20, 0x4f, 0xc6, 0x12, 0x39, 0x92, 0xd4, 0xe9}, 
			 {0x1f, 0xa8, 0x6f, 0x6f, 0x73, 0x56, 0x03, 0xa3}, 
			 {0x65, 0xe0, 0x5d, 0x62, 0xb3, 0x5a, 0xa3, 0x65}, 
			 {0x95, 0xc0, 0xf9, 0xe5, 0x95, 0xae, 0xc2, 0xff}, 
			 {0x12, 0x73, 0x59, 0xc2, 0x0e, 0x10, 0xe2, 0x5a}, 
			 {0xb0, 0x89, 0xd9, 0x0f, 0x84, 0xef, 0x0c, 0x4c}, 
			 {0x32, 0xbb, 0xdd, 0x67, 0xd4, 0xe6, 0x6d, 0xd6}, 
			 {0xb4, 0x87, 0x30, 0x81, 0xfd, 0xeb, 0xc8, 0x1d}, 
			 {0x98, 0x8f, 0xe2, 0xe8, 0xe1, 0x75, 0x5e, 0x78}, 
			 {0xee, 0x6c, 0x0f, 0xeb, 0xb2, 0x12, 0xb2, 0x18}, 
			 {0xc0, 0x3a, 0xdc, 0x2b, 0x6a, 0xa8, 0x5b, 0x5b}, 
			 {0x09, 0x6a, 0x41, 0x36, 0xe0, 0xf6, 0x5f, 0x76}, 
			 {0xbf, 0x4d, 0xa6, 0xaa, 0x59, 0xed, 0x57, 0x51}, 
			 {0xaa, 0xb9, 0x33, 0x90, 0xe1, 0x3d, 0x3b, 0xb3}, 
			 {0xdb, 0x3c, 0x41, 0x06, 0xc5, 0xdb, 0x56, 0x48}},

			{{0x58, 0x5a, 0x1e, 0x8d, 0x89, 0x70, 0x5d, 0x10},
			 {0x99, 0x98, 0x5b, 0x67, 0xb5, 0x98, 0xbd, 0x25},
			 {0xd2, 0xff, 0x67, 0x46, 0x13, 0x77, 0xfb, 0xb5},
			 {0x93, 0xbd, 0x8b, 0xee, 0xea, 0x23, 0x10, 0xfc},
			 {0x6b, 0xfb, 0x4d, 0xf0, 0x56, 0x9c, 0xeb, 0xce},
			 {0x0b, 0xe3, 0x55, 0x87, 0x38, 0xc6, 0xd7, 0xc3},
			 {0x3b, 0xfc, 0x9a, 0x3f, 0x03, 0x4d, 0xa2, 0x92},
			 {0xea, 0x9a, 0xb3, 0x58, 0x5f, 0x16, 0x65, 0x86},
			 {0x95, 0x3a, 0x36, 0xff, 0x13, 0xa0, 0x89, 0x06},
			 {0x08, 0xbd, 0x60, 0xf6, 0xf8, 0x0d, 0x6f, 0xad},
			 {0x83, 0xa3, 0x06, 0x06, 0xfc, 0x78, 0xd7, 0x40},
			 {0x64, 0x45, 0x79, 0x9c, 0x9b, 0x70, 0x16, 0x94},
			 {0x1e, 0x1f, 0xdd, 0x86, 0x60, 0xa7, 0x5b, 0xb5},
			 {0x60, 0xba, 0xe5, 0x9c, 0x51, 0x76, 0x73, 0x94},
			 {0x82, 0x6e, 0xc7, 0xe0, 0x2f, 0x48, 0x68, 0x85},
			 {0x9e, 0x30, 0x37, 0x7b, 0x7a, 0x39, 0xd5, 0xd3},
			 {0x64, 0xb7, 0x73, 0x06, 0x32, 0x1a, 0x93, 0x2c},
			 {0x3b, 0x17, 0xda, 0xff, 0x73, 0x3f, 0xcf, 0xb0},
			 {0x7f, 0x38, 0x21, 0x5d, 0x73, 0xb0, 0xee, 0x62}}};

		BYTE ka_ivs[DES3_NUM_KA_IVS][8] = 
			{{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			 {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55},
			 {0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}};
	#endif

    ASSERT( sizeof(desTable) == XC_SERVICE_DES3_TABLESIZE );
    
	XNetRandom( text, DES_TEST_LENGTH );
	XNetRandom( key, XC_SERVICE_DES3_KEYSIZE );
	XNetRandom( iv, XC_SERVICE_DES_BLOCKLEN );

	memcpy(saveKey, key, XC_SERVICE_DES3_KEYSIZE);
    XcDESKeyParity(key, XC_SERVICE_DES3_KEYSIZE);

    desparityonkey(saveKey, XC_SERVICE_DES3_KEYSIZE);
    if (memcmp( key, saveKey, XC_SERVICE_DES3_KEYSIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " desparityonkey result compare failed!");
        return FALSE;
    }

    XcKeyTable(XC_SERVICE_DES3_CIPHER, XCDES3Table, key);

    tripledes3key(&desTable, saveKey);
    if (memcmp( (BYTE*)&desTable, XCDES3Table, XC_SERVICE_DES3_TABLESIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " tripledes3key result compare failed!");
        return FALSE;
    }

	memcpy(saveText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, DES_TEST_LENGTH, text, text, XCDES3Table, XC_SERVICE_ENCRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM 3DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(tripledes, 8, text+j, text+j, &desTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("RSA 3DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(tripledes, 8, text+j, text+j, &desTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
    XDBGENT("RSA 3DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveCText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, DES_TEST_LENGTH, text, text, XCDES3Table, XC_SERVICE_DECRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM 3DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

	// Run all the known answer tests for triple des...
	#ifdef RUN_KNOWN_ANSWER_TESTS
		for (i=0; i<DES3_NUM_KA_VECTORS; i++) {
			for (j=0; j<DES3_NUM_KA_IVS; j++) {
				memcpy (key, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
				memcpy (key + XC_SERVICE_DES_KEYSIZE, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
				memcpy (key + 2 * XC_SERVICE_DES_KEYSIZE, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
				memcpy(fb,ka_ivs[j],8);
				memcpy(text, ka_pts[i], 8);

				XcDESKeyParity(key, XC_SERVICE_DES3_KEYSIZE);
				XcKeyTable(XC_SERVICE_DES3_CIPHER, XCDES3Table, key);

				XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, 8, text, text, XCDES3Table, XC_SERVICE_ENCRYPT, fb);
				if (memcmp( ka_cts[j][i], text, 8 ) != 0)
				{
					XDBGWRN("Crypto Test", " Known Answer tripleDES encryption compare failed!");
					return FALSE;
				}

				memcpy(fb,ka_ivs[j],8);
				XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, 8, text, text, XCDES3Table, XC_SERVICE_DECRYPT, fb);
				if (memcmp( ka_pts[i], text, 8 ) != 0)
				{
					XDBGWRN("Crypto Test", " Known Answer tripleDES decryption compare failed!");
					return FALSE;
				}
			}
		}
	#endif

    return TRUE;
}

#define USE_GROUP1 1

#ifdef USE_GROUP1

#define DH_KEY_LENGTH 96

static unsigned char g_def_p[DH_KEY_LENGTH] =
    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
      0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
      0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
      0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
      0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
      0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
      0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
      0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
      0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
      0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };

static unsigned char g_def_g[DH_KEY_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
    };

#else

#define DH_KEY_LENGTH 128

static unsigned char g_def_p[DH_KEY_LENGTH] =
     { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
       0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
       0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
       0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
       0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
       0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
       0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
       0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
       0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
       0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
       0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b,
       0x0b, 0xff, 0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed,
       0xee, 0x38, 0x6b, 0xfb, 0x5a, 0x89, 0x9f, 0xa5,
       0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b, 0x1f, 0xe6,
       0x49, 0x28, 0x66, 0x51, 0xec, 0xe6, 0x53, 0x81,
       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
     };

static unsigned char g_def_g[DH_KEY_LENGTH] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
     };

#endif

#define DH_REPEAT_LOOP 10

BOOL 
dhtest(
    void
    )
/*++

Routine Description:

     Diffie Hellman test for testing ROM API: XcModExp

Arguments:

    None

Return Value:

    TRUE if test successful

--*/
{
	DWORD dwStart,dwEnd,i,j;
	BYTE x[DH_KEY_LENGTH];
	BYTE gx[DH_KEY_LENGTH];
	BYTE y[DH_KEY_LENGTH];
	BYTE gy[DH_KEY_LENGTH];
	BYTE gxy[DH_KEY_LENGTH];
	BYTE gyx[DH_KEY_LENGTH];
	BYTE *p;
	BOOL fOK;
	
    XNetRandom( x, DH_KEY_LENGTH );
    XNetRandom( y, DH_KEY_LENGTH );    
    
    dwStart = GetTickCount();
    for(i=0; i<DH_REPEAT_LOOP; ++i)
    {
        RtlZeroMemory( gx, DH_KEY_LENGTH );
        RtlZeroMemory( gy, DH_KEY_LENGTH );
        RtlZeroMemory( gxy, DH_KEY_LENGTH );
        RtlZeroMemory( gyx, DH_KEY_LENGTH );
        
        fOK = XcModExp( (DWORD*)gx, (DWORD*)g_def_g, (DWORD*)x, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gy, (DWORD*)g_def_g, (DWORD*)y, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gxy, (DWORD*)gx, (DWORD*)y, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gyx, (DWORD*)gy, (DWORD*)x, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcModExp", "%d times took %d ms", DH_REPEAT_LOOP*4, dwEnd );

    for (i=0,p = x; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("x  ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = y; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("y  ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gx; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gx ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gy; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gy ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gxy; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gxy", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }

    return (RtlEqualMemory(gxy, gyx, DH_KEY_LENGTH));
}

#ifdef AESTEST

#define AES_TEST_LENGTH 512

#define AES_KEY_LENGTH 16

#define AES_REPEAT_LOOP 1000

BOOL 
aestest(
    void
    )
/*++

Routine Description:

     aestest

Arguments:

    None

Return Value:

    TRUE if test successful

--*/
{
	BYTE text[AES_TEST_LENGTH];
	BYTE saveText[AES_TEST_LENGTH];
	BYTE saveCText[AES_TEST_LENGTH];
	BYTE key[AES_KEY_LENGTH];
	BYTE iv[AES_KEY_LENGTH];
	BYTE fb[AES_KEY_LENGTH];
	AESTable aesTable;
	DWORD dwStart,dwEnd,i,j;
    
	XNetRandom( text, AES_TEST_LENGTH );
	XNetRandom( key, AES_KEY_LENGTH );
	XNetRandom( iv, AES_KEY_LENGTH );

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        aeskey(&aesTable, key, CRYPT_AES128_ROUNDS);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes key", "%d times took %d ms", AES_REPEAT_LOOP, dwEnd );

	memcpy(saveText, text, AES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,AES_KEY_LENGTH);
    	memcpy(text, saveText, AES_TEST_LENGTH);
        for (j=0; j<AES_TEST_LENGTH; j+= AES_KEY_LENGTH)
        {
        	CBC(aes, AES_KEY_LENGTH, text+j, text+j, &aesTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes Enc", "%d bytes took %d ms", AES_REPEAT_LOOP * AES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, AES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,AES_KEY_LENGTH);
    	memcpy(text, saveCText, AES_TEST_LENGTH);
        for (j=0; j<AES_TEST_LENGTH; j+= AES_KEY_LENGTH)
        {
        	CBC(aes, AES_KEY_LENGTH, text+j, text+j, &aesTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes Dec", "%d bytes took %d ms", AES_REPEAT_LOOP * AES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, AES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " AES result compare failed!");
        return FALSE;
    }

    return TRUE;
}

#endif //AESTEST


//
// Crypto updata test
//

DWORD g_updateTestResult;

//
// support functions
//

void
TestXcSHAInit(
    IN PUCHAR pbSHAContext
    )
{
    g_updateTestResult = *pbSHAContext;
}
   
void
TestXcSHAUpdate(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    )
{
    g_updateTestResult = *pbSHAContext * (*pbInput << 1) * (dwInputLength << 2);
}
   
void
TestXcSHAFinal(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbDigest
    )
{
    g_updateTestResult = *pbSHAContext * (*pbDigest << 1);
}
   
void
TestXcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    g_updateTestResult = *pbKeyStruct * (dwKeyLength << 1) * (*pbKey << 2);
}
   
void
TestXcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    g_updateTestResult = *pbKeyStruct * (dwInputLength << 1) * (*pbInput << 2);
}
   
void
TestXcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE pbDigest
    )
{
    g_updateTestResult = *pbKeyMaterial * (cbKeyMaterial << 1) * (*pbData << 2) * (cbData << 3) * (*pbData2 << 4) * (cbData2 << 5) * (*pbDigest << 6);
}

ULONG
TestXcPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return *pbPubKey * (*pbInput << 1) * (*pbOutput << 2);
}
   
ULONG
TestXcPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return *pbPrvKey * (*pbInput << 1) * (*pbOutput << 2);
}

ULONG
TestXcPKGetKeyLen(
    IN PUCHAR pbPubKey
    )
{
    return *pbPubKey;
}

BOOLEAN
TestXcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    )
{
    return (BOOLEAN) ((g_updateTestResult = *pbSig * (*pbPubKey << 1) * (*pbDigest << 2)) & 1) != 0;
}
   
ULONG
TestXcModExp(
    IN LPDWORD pA,
    IN LPDWORD pB,
    IN LPDWORD pC,
    IN LPDWORD pD,
    IN ULONG dwN
    )
{
    return *(BYTE*)pA * (*(BYTE*)pB << 1) * (*(BYTE*)pC << 2) * (*(BYTE*)pD << 3) * (dwN << 4);
}
   
void
TestXcDESKeyParity(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength
    )
{
    g_updateTestResult = *pbKey * (dwKeyLength << 1);
}
   
void
TestXcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    )
{
    g_updateTestResult = dwCipher * (*pbKeyTable << 1) * (*pbKey << 2);
}
   
void
TestXcBlockCrypt(
    IN ULONG dwCipher,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    )
{
    g_updateTestResult = dwCipher * (*pbOutput << 1) * (*pbInput << 2) * (*pbKeyTable << 3) * (dwOp << 4);
}
   
void
TestXcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    )
{
    g_updateTestResult = dwCipher * (dwInputLength << 1) * (*pbOutput << 2) * (*pbInput << 3) * (*pbKeyTable << 4) * (dwOp << 5) * (*pbFeedback << 6);
}

ULONG
TestXcCryptService(
    IN ULONG dwOp,
    IN void* pArgs
    )
{
    return dwOp * (*((BYTE*)pArgs) << 1);
}

CRYPTO_VECTOR newCryptoVector =
{
    TestXcSHAInit,
    TestXcSHAUpdate,
    TestXcSHAFinal,
    TestXcRC4Key,
    TestXcRC4Crypt,
    TestXcHMAC,
    TestXcPKEncPublic,
    TestXcPKDecPrivate,
    TestXcPKGetKeyLen,
    TestXcVerifyPKCS1Signature,
    TestXcModExp,
    TestXcDESKeyParity,
    TestXcKeyTable,
    TestXcBlockCrypt,
    TestXcBlockCryptCBC,
    TestXcCryptService
};

CRYPTO_VECTOR oldCryptoVector;

#define UPDATE_REPEAT_LOOP 1

BOOL 
updatetest(
    void
    )
/*++

Routine Description:

     updatetest

Arguments:

    None

Return Value:

    TRUE if test successful

--*/

{
    BYTE buf[1024], *p1, *p2;
    int i;
    DWORD result;
    
    KIRQL _irql;

    XNetRandom( buf, sizeof(buf) );
    p1 = p2 = buf;
        
    _irql = KeRaiseIrqlToDpcLevel();

    XcUpdateCrypto( &newCryptoVector, &oldCryptoVector );

    for (i = 0; i < UPDATE_REPEAT_LOOP; ++i)
    {
        XcSHAInit( p1++ );
        if ( g_updateTestResult != *p2++ ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcSHAUpdate( p1++, p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcSHAFinal( p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcRC4Key( p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcRC4Crypt( p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcHMAC( p1++, *p1++, p1++, *p1++, p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) * (*p2++ << 5) * (*p2++ << 6) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKEncPublic( p1++, p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKDecPrivate( p1++, p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKGetKeyLen( p1++ );
        if ( result != *p2++ ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcVerifyPKCS1Signature( p1++, p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        if ( result != ((g_updateTestResult & 1) != 0) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcModExp( (DWORD*)p1++, (DWORD*)p1++, (DWORD*)p1++ , (DWORD*)p1++, *p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcDESKeyParity( p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcKeyTable( *p1++, p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
        
        XcBlockCrypt( *p1++, p1++, p1++, p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcBlockCryptCBC( *p1++, *p1++, p1++, p1++, p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) * (*p2++ << 5) * (*p2++ << 6) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
        
        result = XcCryptService( *p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
    }
    
    XcUpdateCrypto( &oldCryptoVector, &newCryptoVector );

    KeLowerIrql(_irql);

    if (i < UPDATE_REPEAT_LOOP)
    {
        return FALSE;
    }
    
    if (shatest())
    {
        XDBGTRC("Crypto Test", "SHA1 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "SHA1 failed!");
    }

    if (rc4test())
    {
        XDBGTRC("Crypto Test", "RC4 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "RC4 failed!");
    }

    if (destest())
    {
        XDBGTRC("Crypto Test", "DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "DES failed!");
    }

    if (des3test())
    {
        XDBGTRC("Crypto Test", "Triple DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Triple DES failed!");
    }

    if (dhtest())
    {
        XDBGTRC("Crypto Test", "Diffie Hellman succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Diffie Hellman failed!");
    }

    if (pktest())
    {
        XDBGTRC("Crypto Test", "PK succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "PK failed!");
    }

    return TRUE;
}

VOID
WINAPI
CryptoStartTest(
    HANDLE LogHandle
    )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/
{
    LONG ID;
    DWORD x;
    char *tmpPtr;
    unsigned y = 0;

    //OutputDebugString( TEXT("crypto: StartTest is called\n") );

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement( &CryptoThreadID );

    //
    // get parameters
    // MaxFiles - maximum number of files to create
    // -1 means creat until failure - this takes too long for BVT's
    //

    //MaxFiles = GetPrivateProfileIntA("crypto",
    //                                 "Files",
    //                                 1000,
    //                                 "testini.ini");
    
    xSetComponent( LogHandle, "kernel", "crypto" );

    //
    // seed random number generator
    // may want to conside saving the seed sometime
    //

    srand( (unsigned)GetTickCount() );

    //
    // create our test data buffer
    //

    FileDataBuffer = HeapAlloc(HeapHandle, 0, FILE_DATA_SIZE);
    if (NULL == FileDataBuffer) {
        OutputDebugString(L"Out of memory!");
        return;
    }
    tmpPtr = (char *)FileDataBuffer;
    for (x = 1; x < FILE_DATA_SIZE; x++) {
        *tmpPtr = (char)(x % 16);
        ++tmpPtr;
    }

    //
    // call the tests
    //
    //_asm int 3;

    XNetAddRef();
    
    xSetFunctionName(LogHandle, "shatest" );
    xStartVariation( LogHandle, "shatest" );
    if (shatest())
    {
        xLog(LogHandle, XLL_PASS, "SHA1 succeeded");
    }
    else
    {
        xLog(LogHandle, XLL_FAIL, "SHA1 failed");
    }
    xEndVariation( LogHandle );


    xSetFunctionName(LogHandle, "rc4test" );
    xStartVariation( LogHandle, "rc4test" );
    if (rc4test())
    {
        xLog(LogHandle, XLL_PASS, "RC4 succeeded");
    }
    else
    {
        xLog(LogHandle, XLL_FAIL, "RC4 failed");
    }
    xEndVariation( LogHandle );

    xSetFunctionName(LogHandle, "destest" );
    xStartVariation( LogHandle, "destest" );
    if (destest())
    {
        xLog(LogHandle, XLL_PASS, "DES succeeded");
    }
    else
    {
        xLog(LogHandle, XLL_FAIL, "DES failed");
    }
    xEndVariation( LogHandle );

    xSetFunctionName(LogHandle, "des3test" );
    xStartVariation( LogHandle, "des3test" );
    if (des3test())
    {
        xLog(LogHandle, XLL_PASS, "Triple DES succeeded");
    }
    else
    {
        xLog(LogHandle, XLL_FAIL, "Triple DES failed");
    }
    xEndVariation( LogHandle );

    xSetFunctionName(LogHandle, "dhtest" );
    xStartVariation( LogHandle, "dhtest" );
    if (dhtest())
    {
        xLog(LogHandle, XLL_PASS, "Diffie Hellman succeeded");
    }
    else
    {
        xLog(LogHandle, XLL_FAIL, "Diffie Hellman failed");
    }
    xEndVariation( LogHandle );

    xSetFunctionName(LogHandle, "pktest" );
    xStartVariation( LogHandle, "pktest" );
    if (pktest())
    {
        xLog(LogHandle, XLL_PASS, "PK succeeded");
    }
    else
    {
        xLog(LogHandle, XLL_FAIL, "PK failed");
    }
    xEndVariation( LogHandle );

#ifdef AESTEST
    xSetFunctionName(LogHandle, "aestest" );
    xStartVariation( LogHandle, "aestest" );
    if (aestest())
    {
        xLog(LogHandle, XLL_PASS, "AES succeeded");
    }
    else
    {
        xLog(LogHandle, XLL_FAIL, "AES failed");
    }
    xEndVariation( LogHandle );
#endif

    xSetFunctionName(LogHandle, "updatetest" );
    xStartVariation( LogHandle, "updatetest" );
    if (updatetest())
    {
        xLog(LogHandle, XLL_PASS, "Crypto Update succeeded");
    }
    else
    {
        xLog(LogHandle, XLL_FAIL, "Crypto Update failed");
    }
    xEndVariation( LogHandle );
    
    XNetRelease();

    //
    // clean up the mess on the last drive
    //
	HeapFree(HeapHandle, 0, FileDataBuffer);
	
    return;
}

VOID
WINAPI
CryptoEndTest(
    VOID
    )
/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/
{
    CryptoThreadID = 0;
    //OutputDebugString( TEXT("Crypto: EndTest is called\n") );
}

BOOL
WINAPI
CryptoDllMain(
    HINSTANCE   hInstance,
    DWORD       fdwReason,
    LPVOID      lpReserved
    )
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( lpReserved );

    if ( fdwReason == DLL_PROCESS_ATTACH ) {

		// Start with a 32K growable heap  ...
        HeapHandle = HeapCreate( 0, 0x8000, 0 );

        if ( !HeapHandle ) {
            OutputDebugString( TEXT("crypto: Unable to create heap\n") );
            return FALSE;
        }

    } else if ( fdwReason == DLL_PROCESS_DETACH ) {

        if ( HeapHandle ) {
            HeapDestroy( HeapHandle );
        }
    }

    return TRUE;
}



//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( cryptotest )
#pragma data_seg()

BEGIN_EXPORT_TABLE( cryptotest )
    EXPORT_TABLE_ENTRY( "StartTest", CryptoStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", CryptoEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", CryptoDllMain )
END_EXPORT_TABLE( cryptotest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\except\fpexcept.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

        fpexcept.c

Abstract:

        test floating point exceptions

Author:

        johndaly

Environment:

        x86-only - used to test emulators (16 and 32 bit)

Notes:

        This is for x86 only, it is an instruction-level test designed to make
        sure SEH works correctly with 486 emulators.  All test output to stdout.

Revision History:

        10/9/95 - creation
        9/25/2000 - use in xbox (wow, 5 yeras later...! add more tests.)

--*/

/* global pragmas */
#pragma optimize ("", off)

/* includes */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <xlog.h>
#include <xtestlib.h>

#if 0
int _fltused = 1;
#endif

/* function declarations */
void __cdecl fpexcept_main(void);
void InvOp(void);
void ZeroDiv(void);
void DenormalOp(void);
void NumOverflow(void);
void NumUnderflow(void);
void StackEx(void);
void Inexact(void);
LONG FPExceptionFilter(EXCEPTION_POINTERS *);

/* global data */
WORD wControlWord = 0;      /* used by ResetEnableExcept macro */
HANDLE FpExceptLogHandle;   /* logging handle */

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The 
// default is only one thread.
//

LONG FPExceptThreadID = 0;

/* macros */
/* reset the fpu and enable the indicated exceptions */
#define ResetEnableExcept(ExceptionMask)    \
   _asm   fninit                            \
   _asm   FSTCW  wControlWord               \
   _asm   xor wControlWord,##ExceptionMask  \
   _asm   fldcw wControlWord

/*****************************************************************************
 *
 * Name        : fpexcept_main
 *
 * Purpose     : run all the sub-functional tests
 *
 * Args        : none
 *
 * Returns     : nothing
 *
 * Mod Globals :
 *
 * Notes       :
 *
  *****************************************************************************/
void __cdecl fpexcept_main(void)   {

   __try {
      /* create exceptions */
      InvOp();
      ZeroDiv();
      DenormalOp();
      NumOverflow();
      NumUnderflow();
      StackEx();
      Inexact();
      }
   __except(FPExceptionFilter(GetExceptionInformation())){}

}

/*****************************************************************************
 *
 * Name        : InvOp
 *
 * Purpose     : create invalid-operation exceptions
 *
 * Args        : none
 *
 * Returns     : none
 *
 * Mod Globals : none
 *
 * Notes       :
 *
  *****************************************************************************/
#pragma warning(disable: 4409)
void InvOp(void)  {
   /* locals */
   float a = (float)1.22e1;
   float b = (float)0.0;
   double e = 1.25e40;
   double f = 0.0;
   int c = 0;
   int d = 1;
   long g = 0;
   long h = 1;
   double trash;
   char FakeTenbyteBCD[] = {'1','2','3','4','5','6','7','8','9','0','1','2','3','4','5','6','7','8','9'};

   xSetFunctionName( FpExceptLogHandle, "fpexcept:invop" );
   xStartVariation( FpExceptLogHandle, "InvOp" );

   /* enable invalid-operation exceptions */
   /* stack errors - overflow */
   /* log action */

   xLog( FpExceptLogHandle, XLL_INFO, "testing invalid operation exceptions - overflow the stack");
   ResetEnableExcept(0x00000001)
   _asm  {
      // fld1
      fld1
      fld1
      fld1
      fld1
      fld1
      fld1
      fld1
      fld1
      fld1
      fwait

      // fbld
      fbld FakeTenbyteBCD
      fwait

      fnop
      }

   /* enable invalid-operation exceptions */
   /* invalid ops */
   /* log action */
   xLog( FpExceptLogHandle, XLL_INFO, "testing invalid operation exceptions - operations with invalid operands");
   ResetEnableExcept(0x00000001)
   xLog( FpExceptLogHandle, XLL_INFO, "f2xm1");
   _asm  {
      f2xm1
      fwait
      }

   xLog( FpExceptLogHandle, XLL_INFO, "fabs");
   _asm  {
      fabs
      fwait

      fadd a
      fwait

      fadd e
      fwait
      }

   xLog( FpExceptLogHandle, XLL_INFO, "fadd");
   _asm  {
      fadd st,st(1)
      fwait

      fadd st(1),st
      fwait

      fadd st,st(7)
      fwait

      fadd st(7),st
      fwait

      faddp st(1),st
      fwait

      faddp st(7),st
      fwait

      fadd
      fwait

      fiadd d
      fwait

      fiadd h
      fwait
      }

   xLog( FpExceptLogHandle, XLL_INFO, "fbstp");
   _asm  {
      fbstp FakeTenbyteBCD
      fwait
      }

   xLog( FpExceptLogHandle, XLL_INFO, "fchs");
   _asm  {
      fchs
      fwait
      }

   xLog( FpExceptLogHandle, XLL_INFO, "fcom");
   _asm  {
      fcom a
      fwait

      fcom e
      fwait

      fcom st(1)
      fwait

      fcom st(7)
      fwait

      fcom
      fwait

      fcomp a
      fwait

      fcomp e
      fwait

      fcomp st(1)
      fwait

      fcomp st(7)
      fwait

      fcomp
      fwait

      fcompp
      fwait

      fnop
      }

   ResetEnableExcept(0x00000001)
   xLog( FpExceptLogHandle, XLL_INFO, "fprem");
   _asm  {
    fldz
    fld1
    fprem
    fwait
    }

   ResetEnableExcept(0x00000001)
   xLog( FpExceptLogHandle, XLL_INFO, "fly2x");
   _asm  {
    fldz
    fldz
    fyl2x
    fwait

    fldz
    fchs
    fldz
    fyl2x
    fwait

    fldz
    fldz
    fchs
    fyl2x
    fwait

    fldz
    fchs
    fldz
    fchs
    fyl2x
    fwait
    }

   xEndVariation( FpExceptLogHandle );
}
#pragma warning(default: 4409)

/*****************************************************************************
 *
 * Name        : ZeroDiv
 *
 * Purpose     : create divide by 0 exceptions
 *
 * Args        : none
 *
 * Returns     : none
 *
 * Mod Globals : none
 *
 * Notes       :
 *
  *****************************************************************************/
void ZeroDiv(void)  {

   /* locals */
   float a = (float)1.22e1;
   float b = (float)0.0;
   double e = 1.25e40;
   double f = 0.0;
   int c = 0;
   int d = 1;
   long g = 0;
   long h = 1;
   double trash;

   /* create exceptions */
   /* remember to follow all exceptions with fwait */
   /* which will cause the processor to check */
   
   xSetFunctionName( FpExceptLogHandle, "fpexcept:zerodiv" );
   xStartVariation( FpExceptLogHandle, "ZeroDiv" );

   /* enable divide by 0 exceptions */
   /* log action */
   xLog( FpExceptLogHandle, XLL_INFO, "testing divide-by-0 exceptions - fdiv variations");
   /* divide by 0 using division */
   ResetEnableExcept(0x00000004)
   _asm  {
      fld a
      fdiv b
      fwait

      fld e
      fdiv f
      fwait

      fldz
      fld e
      fdiv st, st(1)
      fwait

      fld e
      fldz
      fdiv st(1), st
      fwait

      fstp trash
      fstp trash
      fstp trash
      fstp trash

      fld e
      fldz
      fdivp st(1), st
      fwait

      fld e
      fldz
      fdiv
      fwait

      fild d
      fidiv c
      fwait

      fidiv g
      fwait
      fnop
      }

   /* enable divide by 0 exceptions */
   /* divide by 0 using reverse division */
   /* log action */
   xLog( FpExceptLogHandle, XLL_INFO, "testing divide-by-0 exceptions - fdivr variations");
   ResetEnableExcept(0x00000004)
   _asm  {
      fld b
      fdivr a
      fwait

      fld f
      fdivr e
      fwait

      fld e
      fldz
      fdivr st, st(1)
      fwait

      fldz
      fld e
      fdivr st(1), st
      fwait

      fstp trash
      fstp trash
      fstp trash
      fstp trash

      fldz
      fld e
      fdivrp st(1), st
      fwait

      fldz
      fld e
      fdivr
      fwait

      fild c
      fidivr d
      fwait

      fild g
      fidivr h
      fwait
      fnop
      }

   /* enable divide by 0 exceptions */
   /* divide by 0 fxtract division */
   /* log action */
   xLog( FpExceptLogHandle, XLL_INFO, "testing divide-by-0 exceptions - fxtract variations");
   ResetEnableExcept(0x00000004)
   _asm  {
      fldz
      fxtract
      fwait
      fnop
      }

   /* enable divide by 0 exceptions */
   /* divide by 0 fyl2x division */
   /* log action */
   xLog( FpExceptLogHandle, XLL_INFO, "testing divide-by-0 exceptions - fyl2x variations");
   ResetEnableExcept(0x00000004)
   _asm  {
      fld1
      fldz
      fyl2x
      fwait
      fnop
      }

   xEndVariation( FpExceptLogHandle );
return;

}

/*****************************************************************************
 *
 * Name        : DenormalOp
 *
 * Purpose     : create denormal operand exceptions
 *
 * Args        : none
 *
 * Returns     : none
 *
 * Mod Globals : none
 *
 * Notes       :
 *
  *****************************************************************************/
void DenormalOp(void)  {
   /* locals */

}

/*****************************************************************************
 *
 * Name        : NumOverflow
 *
 * Purpose     : create numeric overflow exceptions
 *
 * Args        : none
 *
 * Returns     : none
 *
 * Mod Globals : none
 *
 * Notes       :
 *
  *****************************************************************************/
void NumOverflow(void)  {
   /* locals */

}

/*****************************************************************************
 *
 * Name        : NumUnderflow
 *
 * Purpose     : create numeric overflow exceptions
 *
 * Args        : none
 *
 * Returns     : none
 *
 * Mod Globals : none
 *
 * Notes       :
 *
  *****************************************************************************/
void NumUnderflow(void)  {
   /* locals */

}

/*****************************************************************************
 *
 * Name        : StackEx
 *
 * Purpose     : create numeric stack exceptions
 *
 * Args        : none
 *
 * Returns     : none
 *
 * Mod Globals : none
 *
 * Notes       :
 *
  *****************************************************************************/
void StackEx(void)  {
   /* locals */

}

/*****************************************************************************
 *
 * Name        : Inexact
 *
 * Purpose     : create inexact exceptions
 *
 * Args        : none
 *
 * Returns     : none
 *
 * Mod Globals : none
 *
 * Notes       :
 *
  *****************************************************************************/
void Inexact(void)  {
   /* locals */

}

/*****************************************************************************
 *
 * Name        : LONG FPExceptionFilter(LPEXCEPTION_RECORD lpER)
 *
 * Purpose     : filter for exception handler, writess exception information to stdout
 *
 * Args        : LPEXCEPTION_RECORD lpER - pointer to an exception record
 *
 * Returns     : LONG - exception filter code
 *
 * Mod Globals : none
 *
 * Notes       : patterned on Advanced Windows pg. 735
 *               there is some pretty nasty register manipulation in here
 *
  *****************************************************************************/
LONG FPExceptionFilter(EXCEPTION_POINTERS *lpER) {

   /* locals */
   char szBuff[300], *p;
   DWORD dwExceptionCode = lpER->ExceptionRecord->ExceptionCode;

   sprintf(szBuff, "Code = %x, Address = %x", dwExceptionCode, lpER->ExceptionRecord->ExceptionAddress);

   /* point to end of string */
   p = strchr(szBuff, 0);

   switch(dwExceptionCode){
      case EXCEPTION_FLT_INVALID_OPERATION:
         sprintf(p, "EXCEPTION_FLT_INVALID_OPERATION ");
         /* munge context record */
         lpER->ContextRecord->FloatSave.StatusWord &= 0xFF7E;
         break;

      case EXCEPTION_FLT_DENORMAL_OPERAND:
         sprintf(p, "EXCEPTION_FLT_DENORMAL_OPERAND ");
         /* munge context record */
         lpER->ContextRecord->FloatSave.StatusWord &= 0xFF7D;
         break;

      case EXCEPTION_FLT_DIVIDE_BY_ZERO:
         sprintf(p, "EXCEPTION_FLT_DIVIDE_BY_ZERO ");
         /* munge context record */
         lpER->ContextRecord->FloatSave.StatusWord &= 0xFF7B;
         break;

      case EXCEPTION_FLT_OVERFLOW:
         sprintf(p, "EXCEPTION_FLT_OVERFLOW ");
         /* munge context record */
         lpER->ContextRecord->FloatSave.StatusWord &= 0xFF77;
         break;

      case EXCEPTION_FLT_UNDERFLOW:
         sprintf(p, "EXCEPTION_FLT_UNDERFLOW ");
         /* munge context record */
         lpER->ContextRecord->FloatSave.StatusWord &= 0xFF6F;
         break;

      case EXCEPTION_FLT_INEXACT_RESULT:
         sprintf(p, "EXCEPTION_FLT_INEXACT_RESULT ");
         /* munge context record */
         lpER->ContextRecord->FloatSave.StatusWord &= 0xFF5F;
         break;

      case EXCEPTION_FLT_STACK_CHECK:
         sprintf(p, "EXCEPTION_FLT_STACK_CHECK ");
         /* munge context record */
         lpER->ContextRecord->FloatSave.StatusWord &= 0xFF3E;
         break;

      default:
         sprintf(p, "Unhandled Exception! Continue search...\n");
         xLog(FpExceptLogHandle, XLL_FAIL, "%s", szBuff);
         return(EXCEPTION_CONTINUE_SEARCH);
      }

   xLog(FpExceptLogHandle, XLL_PASS, "%s", szBuff);
   return(EXCEPTION_CONTINUE_EXECUTION);
}

VOID
WINAPI
FPExceptStartTest(
    HANDLE xLogHandle
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    FpExceptLogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    LONG ID;
    FpExceptLogHandle = xLogHandle;

    OutputDebugString( TEXT("fpexcept: StartTest is called\n") );

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample.dll]. Everytime
    // the harness calls StartTest, FPExceptThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    // 

    ID = InterlockedIncrement( &FPExceptThreadID );

    xSetComponent( FpExceptLogHandle, "kernel", "fpexcept" );

    //
    // call the tests
    //

    fpexcept_main();

    return;

}

VOID
WINAPI
FPExceptEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    FPExceptThreadID = 0;
    OutputDebugString( TEXT("timetest: EndTest is called\n") );
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( fpexcept )
#pragma data_seg()

BEGIN_EXPORT_TABLE( fpexcept )
    EXPORT_TABLE_ENTRY( "StartTest", FPExceptStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", FPExceptEndTest )
END_EXPORT_TABLE( fpexcept )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\crypto\aes.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aes.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the low-level AES encryption routines


Author:

    Scott Field (SField) 09-October-2000

Revision History:

--*/


#ifndef __AES_H__
#define __AES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif


#define AES_MAXROUNDS   (14)

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_MAXROUNDS+1][4][4];
    unsigned char   keytabdec[AES_MAXROUNDS+1][4][4];
} AESTable;

#define CRYPT_AES128_ROUNDS             10
#define CRYPT_AES192_ROUNDS             12
#define CRYPT_AES256_ROUNDS             14

#define AES_TABLESIZE   (sizeof(AESTable))
#define AES_BLOCKLEN    (16)
#define AES_KEYSIZE     (32)


void
RSA32API
aes(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );

void
RSA32API
aeskey(
    AESTable    *KeyTable,
    BYTE        *Key,
    int         rounds
    );



#ifdef __cplusplus
}
#endif

#endif // __AES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\except\intxcpt.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

        intxcpt.c

Abstract:

        test integer exceptions

Author:

        johndaly

Environment:

        x86-only - used to test emulators (16 and 32 bit)

Notes:

        This is for x86 only, it is an instruction-level test designed to make
        sure SEH works correctly with 486 emulators.  All test output to stdout.

Revision History:

        7/15/96 - creation

--*/

/* global pragmas */
#pragma optimize ("", off)

/* includes */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>


/* function declarations */
void __cdecl main(void);
void InvOp(void);
LONG ExceptionFilter(EXCEPTION_POINTERS *);

/* global data */
WORD wControlWord = 0;  /* used by ResetEnableExcept macro */

/* macro */
/* 1 arg ie "inc ax" */
#define TryInstruction(instruction)                         \
    puts(#instruction);                                    \
    __try {                                                 \
        _asm {                                              \
            instruction                                     \
        }                                                   \
    }                                                       \
   __except(FPExceptionFilter(GetExceptionInformation())){}

/* 2 args ie "add ax, bx" */
#define TryInstruction1(instruction, instruction1)           \
    puts(#instruction"," #instruction1);                      \
    __try {                                                 \
        _asm {                                              \
            instruction, instruction1                       \
        }                                                   \
    }                                                       \
   __except(FPExceptionFilter(GetExceptionInformation())){}


/*****************************************************************************
 *
 * Name        : main
 *
 * Purpose     : run all the sub-functional tests
 *
 * Args        : none
 *
 * Returns     : nothing
 *
 * Mod Globals :
 *
 * Notes       :
 *
  *****************************************************************************/
void __cdecl main(void)   {

    InvOp();

}

/*****************************************************************************
 *
 * Name        : InvOp
 *
 * Purpose     : create invalid-operation exceptions
 *
 * Args        : none
 *
 * Returns     : none
 *
 * Mod Globals : none
 *
 * Notes       :
 *
  *****************************************************************************/
void InvOp(void)  {
    /* locals */
    unsigned long    Dead;
    void *DeadPtr;
    DeadPtr = &Dead;

    TryInstruction(cli)
    TryInstruction(clts)
    TryInstruction(hlt)
    TryInstruction1(in  al, 0000h)
    TryInstruction(insb)
    TryInstruction(insw)
    TryInstruction(insd)
    TryInstruction(invd)
    TryInstruction(invlpg  DeadPtr)
    TryInstruction(lgdt    DeadPtr)
    TryInstruction(lidt    DeadPtr)
    TryInstruction(lldt    DeadPtr)
    TryInstruction(lmsw    DeadPtr)
    TryInstruction(ltr     DeadPtr)
    TryInstruction1(mov     CR0, eax)
    TryInstruction1(mov     eax, CR0)
    TryInstruction1(mov     eax, CR2)
    TryInstruction1(mov     eax, CR3)
    TryInstruction1(mov     CR2, eax)
    TryInstruction1(mov     CR3, eax)
    TryInstruction1(mov     eax, DR0)
    TryInstruction1(mov     eax, DR1)
    TryInstruction1(mov     eax, DR2)
    TryInstruction1(mov     eax, DR3)
    TryInstruction1(mov     DR6, eax)
    TryInstruction1(mov     DR7, eax)
    TryInstruction1(mov     DR0, eax)
    TryInstruction1(mov     DR1, eax)
    TryInstruction1(mov     DR2, eax)
    TryInstruction1(mov     DR3, eax)
    TryInstruction1(mov     DR6, eax)
    TryInstruction1(mov     DR7, eax)
    TryInstruction1(mov     TR4, eax)
    TryInstruction1(mov     TR5, eax)
    TryInstruction1(mov     TR6, eax)
    TryInstruction1(mov     TR7, eax)
    TryInstruction1(mov     eax, TR4)
    TryInstruction1(mov     eax, TR5)
    TryInstruction1(mov     eax, TR6)
    TryInstruction1(mov     eax, TR7)
    TryInstruction1(mov     eax, TR3)
    TryInstruction1(mov     TR3, eax)
    TryInstruction1(out     0, eax)
    TryInstruction(outsb)
    TryInstruction(outsw)
    TryInstruction(outsd)
    TryInstruction(sgdt    fword ptr DeadPtr)
    TryInstruction(sidt    fword ptr DeadPtr)

    // might be OK on x86
    TryInstruction(sldt    DeadPtr)
    TryInstruction(sti)

    // might be OK on x86
    TryInstruction(str     DeadPtr)
    TryInstruction(wbinvd)

}

/*****************************************************************************
 *
 * Name        : LONG ExceptionFilter(LPEXCEPTION_RECORD lpER)
 *
 * Purpose     : filter for exception handler, writess exception information to stdout
 *
 * Args        : LPEXCEPTION_RECORD lpER - pointer to an exception record
 *
 * Returns     : LONG - exception filter code
 *
 * Mod Globals : none
 *
 * Notes       : patterned on Advanced Windows pg. 735
 *               there is some pretty nasty register manipulation in here
 *
  *****************************************************************************/
LONG FPExceptionFilter(EXCEPTION_POINTERS *lpER) {

   /* locals */
   char szBuff[300], *p;
   DWORD dwExceptionCode = lpER->ExceptionRecord->ExceptionCode;

   sprintf(szBuff, "Code = %x, Address = %x\n", dwExceptionCode, lpER->ExceptionRecord->ExceptionAddress);

   /* point to end of string */
   p = strchr(szBuff, 0);

   switch(dwExceptionCode){
      case EXCEPTION_FLT_INVALID_OPERATION:
         sprintf(p, "EXCEPTION_FLT_INVALID_OPERATION\n");
         break;

      case EXCEPTION_FLT_DIVIDE_BY_ZERO:
         sprintf(p, "EXCEPTION_FLT_DIVIDE_BY_ZERO\n");
         break;

      case STATUS_ACCESS_VIOLATION:
         sprintf(p, "STATUS_ACCESS_VIOLATION\n");
         break;

      case STATUS_PRIVILEGED_INSTRUCTION:
         sprintf(p, "STATUS_PRIVILEGED_INSTRUCTION\n");
         break;

      case STATUS_ILLEGAL_INSTRUCTION:
         sprintf(p, "STATUS_ILLEGAL_INSTRUCTION\n");
         break;

      case STATUS_INVALID_LOCK_SEQUENCE:
         sprintf(p, "STATUS_INVALID_LOCK_SEQUENCE\n");
         break;

      default:
         sprintf(p, "Unhandled Exception! Continue search...\n");
         printf("%s\n",szBuff);
         return(EXCEPTION_CONTINUE_SEARCH);
         break;
      }

   printf("%s\n",szBuff);
   return(EXCEPTION_EXECUTE_HANDLER);
}



=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\formatz\formatz.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    formatz.c

Abstract:

    test out the XFormatUtilityDrive() API

Author:

    John Daly (johndaly) 23-jan-2002

Environment:

    X-Box

Notes:

Revision History:

    23-jan-2002     johndaly
    created

Current Status:


--*/

//
// includes
//

#include "formatz.h"

void 
__cdecl 
main(
    void
    )
/*++

Routine Description:

    main
    
Arguments:

    None

Return Value:

    None

--*/
{
    
    //
    // call the tests
    //

    test_XFormatUtilityDriveNoFile();
    test_XFormatUtilityDriveOneFile();

    return;

}

VOID
WINAPI
test_XFormatUtilityDriveNoFile(
    void
    )
/*++

Routine Description:

    run iterations of XFormatUtilityDrive with no open files

Arguments:

    HANDLE LogHandle

Return Value:

    None

--*/
{
    DWORD x;

    for (x = 0; x < 10000; x++) {
        if(FALSE == XFormatUtilityDrive()) {
            OutputDebugStringA("ERROR: XFormatUtilityDrive failed - no files open scenario\r\n");
        } else {
            //OutputDebugStringA("XFormatUtilityDrive succeeded - no files open scenario\r\n");
        }
    }
    return;
}

VOID
WINAPI
test_XFormatUtilityDriveOneFile(
    void
    )
/*++

Routine Description:

    run iterations of XFormatUtilityDrive with an open file

Arguments:

    HANDLE LogHandle

Return Value:

    None

--*/
{
    DWORD x,y;
    char FileDataBuffer[] = {"abcdefghijklmnopqrstuvwxyz0123456789"};
    char dataname[MAX_PATH] = {0};
    DWORD FileCount = 1;
    HANDLE hFile;
    DWORD dwBytesWritten;

    for (y = 0; y < 10000; y++) {
        
        //
        // open a file(s)
        //

        for (x = 0; x < FileCount; x++) {

            sprintf(dataname, "Z:\\data%4.4x.dat", x);

            hFile = CreateFile(dataname,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (INVALID_HANDLE_VALUE == hFile) {
                OutputDebugStringA("ERROR: CreateFile failed while saving data (title)\r\n");
                continue;
            }

            //
            // write some easily understood pattern of data to the file
            //

            if (0 == WriteFile(hFile,
                               FileDataBuffer,
                               sizeof(FileDataBuffer),
                               &dwBytesWritten,
                               NULL)) {
                OutputDebugStringA("ERROR: WriteFile failed while saving data (title)\r\n");
                break;
            }
        }

        if (FALSE == XFormatUtilityDrive()) {
            OutputDebugStringA("ERROR: XFormatUtilityDrive failed - no files open scenario\r\n");
        } else {
            //OutputDebugStringA("XFormatUtilityDrive succeeded - no files open scenario\r\n");
        }
        
        CloseHandle(hFile);
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\formatz\formatz.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    formatz.h

Abstract:

    test out the XFormatUtilityDrive() API
    
Author:

    John Daly (johndaly) 23-jan-2002

Revision History:

--*/

#ifndef _FORMATZ_
#define _FORMATZ_

//
// includes
//

#include <stdio.h>
#include <xapip.h>
#include <xboxp.h>
#include <xlog.h>
#include <xtestlib.h>

//
// function declarations
//

VOID
WINAPI
test_XFormatUtilityDriveNoFile(
    void
    );

VOID
WINAPI
test_XFormatUtilityDriveOneFile(
    void
    );

void 
__cdecl 
main(
    void
    );

#endif // _FORMATZ_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\loader\loader.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>



void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }

void main(void)
    {
    DWORD dataType = 0xCCCCCCCC;
    LAUNCH_DATA launchInfo;

    memset(&launchInfo, 0xCC, sizeof(LAUNCH_DATA));

    XGetLaunchInfo(&dataType, &launchInfo);

    DebugPrint("LOADER TEST APP: In the Game.\n");
    DebugPrint("    Launch Type: 0x%X\n", dataType);
    DebugPrint("    Sleeping forever...\n");

    while(1)
        {
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\io\devctl\devctl.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    devctl.c

Abstract:

    This program is designed to call as many of the native NT API's as
    possible. The program is written to crash drivers as its primary function.

Author:

    Neill Clift (neillc) 23-Oct-1997

Environment:

    Xbox

Revision History:

    2-May-2000    schanbai

        Ported to Xbox

--*/


#pragma warning( disable : 4201 4057 )

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <xtl.h>
#include "time.h"
#include "xtestlib.h"
#include "xlog.h"


#define MAX_DEVICES                 4096
#define SLOP_SENTINAL               0xA5

#define SLOP                        100
#define BIGBUF_SIZE                 0x10000
#define RAND_REP                    1000
#define MAX_IOCTL_TAILOR            100
#define INITIAL_IOCTL_TAILOR_SIZE   200

typedef struct _DEVMAP {
    OBJECT_NAME_INFORMATION *name;
    FILE_NAME_INFORMATION   *filename;
    HANDLE                  handle;
    DEVICE_TYPE             devtype;
    ACCESS_MASK             access;
} DEVMAP, *PDEVMAP;

//
// Define a structure to keep a track of issued IOCTL's. We do this to try and make a
// guess at what IOCTL's/FSCTL's a driver is actualy processing.
//
typedef struct _IOCTLINFO {
   NTSTATUS status;
   ULONG ioctl;
   ULONG count;
} IOCTLINFO, *PIOCTLINFO;

typedef struct _IOCTLREC {
   ULONG total, count;
   IOCTLINFO ioctl[1];
} IOCTLREC, *PIOCTLREC;

DEVMAP      g_devmap[MAX_DEVICES];
UCHAR       *bigbuf;
HANDLE      randthread, alertthread, mainthread;
ULONG       ioctl_min_function=0;
ULONG       ioctl_max_function=200 /*0xFFF*/;
ULONG       ioctl_min_devtype=0;
ULONG       ioctl_max_devtype=200;
ULONG       max_random_calls   = 100000;
ULONG       max_tailured_calls = 10000;
ULONG       progress_counter=0;
ULONG       alerted=0;
HANDLE      DevCtlLogHandle;
ULONG       MAX_RET;
HANDLE      DevCtlHeapHandle;
PCHAR       DevCtlBigBuffer = NULL;

volatile BOOL ExitFromThread;


/*
   Hack to get a 32 bit random value from a 15 bit source
*/
ULONG
rand32(
    void
    )
{
    return(rand() << 17) + rand() + rand();
}


/*
   Allocate a buffer with slop and fill the slop with a know value
*/
PVOID
reallocslop(
    PVOID  p,
    ULONG  len
    )
{
    progress_counter++;
    if ( !p ) {
        p = HeapAlloc( DevCtlHeapHandle, HEAP_ZERO_MEMORY, len + SLOP );
    } else {
        p = HeapReAlloc( DevCtlHeapHandle, 0, p, len + SLOP );
    }
    memset(p, SLOP_SENTINAL, len + SLOP);
    return p;
}


/*
   Check to see if the driver wrote too far by checking the slop values
*/
VOID
testslop(
    PVOID p,
    ULONG len,
    PCHAR what,
    PCHAR subwhat
)
{
    UCHAR *pc;
    ULONG i;

    pc = p;
    pc += len;

    for (i = 0; i < SLOP; i++, pc++) {
        if (*pc != SLOP_SENTINAL) {
            DbgPrint(
                "DEVCTL: Driver wrote beyond end during %s %s for length %d!\n",
                what,
                subwhat,
                len
                );
            break;
        }
    }
}

/*
   Do volume queries of different lengths
*/
VOID
do_query_volume(
    HANDLE                  handle,
    FS_INFORMATION_CLASS    InfoType,
    ULONG                   bufl,
    PCHAR                   what
)
{
    ULONG                   l, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status;

    ret = 0;
    buf = NULL;
    do {
       l = bufl + 1024;

       do {
           buf = reallocslop(buf, l);
           status = NtQueryVolumeInformationFile(handle, &iosb, buf, l, InfoType);
           testslop(buf, l, "NtQueryVolumeInformationFile", what);

           if (status == STATUS_NOT_IMPLEMENTED ||
               status == STATUS_INVALID_INFO_CLASS ||
               status == STATUS_INVALID_DEVICE_REQUEST ||
               status == STATUS_INVALID_PARAMETER ||
               status == STATUS_ACCESS_DENIED) {

                //break;
           }
       } while (l-- != 0);

       status = NtQueryVolumeInformationFile(
                    handle,
                    &iosb,
                    (PVOID)-1024,
                    0,
                    InfoType
                    );

    } while (++ret < MAX_RET);

    HeapFree( DevCtlHeapHandle, 0, buf );
}

/*
   Do file queries
*/
VOID
do_query_file(
    HANDLE                  handle,
    FILE_INFORMATION_CLASS  InfoType,
    ULONG                   bufl,
    PCHAR                   what
    )
{
    ULONG                   l, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status;

    ret = 0;
    buf = NULL;
    do {

       l = bufl + 1024;

       do {
           buf = reallocslop(buf, l);
           status = NtQueryInformationFile(handle, &iosb, buf, l, InfoType);
           testslop(buf, l, "NtQueryInformationFile", what);

           if (status == STATUS_NOT_IMPLEMENTED ||
               status == STATUS_INVALID_INFO_CLASS ||
               status == STATUS_INVALID_DEVICE_REQUEST ||
               status == STATUS_INVALID_PARAMETER ||
               status == STATUS_ACCESS_DENIED) {

                //break;
           }

       } while (l-- != 0);

       status = NtQueryInformationFile(
                    handle,
                    &iosb,
                    (PVOID)-1024,
                    0,
                    InfoType
                    );

    } while (++ret < MAX_RET);

    HeapFree( DevCtlHeapHandle, 0, buf );
}


/*
   Do file sets
*/
VOID
do_set_file(
    HANDLE                  handle,
    FILE_INFORMATION_CLASS  InfoType,
    ULONG                   bufl
    )
{
    ULONG                   l, i, ret;
    IO_STATUS_BLOCK         iosb;
    PVOID                   buf;
    NTSTATUS                status;

    ret = 0;
    buf = NULL;
    do {

       l = bufl + 1024;
       buf = HeapAlloc( DevCtlHeapHandle, HEAP_ZERO_MEMORY, l );
       if ( buf ) {
           do {
               for (i = 0; i < l; i++) {
                  ((PCHAR)buf)[i] = (CHAR) rand ();
               }
               progress_counter++;
               status = NtSetInformationFile(
                            handle,
                            &iosb,
                            buf,
                            l,
                            InfoType
                            );

               if (status == STATUS_NOT_IMPLEMENTED ||
                   status == STATUS_INVALID_INFO_CLASS ||
                   status == STATUS_INVALID_DEVICE_REQUEST ||
                   status == STATUS_INVALID_PARAMETER ||
                   status == STATUS_ACCESS_DENIED) {

                    //break;
               }

           } while (l-- != 0);

           status = NtSetInformationFile(
                        handle,
                        &iosb,
                        (PVOID)-1024,
                        0,
                        InfoType
                        );

           HeapFree( DevCtlHeapHandle, 0, buf );
       }
    } while (++ret < MAX_RET);
}

NTSTATUS
query_object(
    HANDLE  handle,
    PDEVMAP devmap
    )
{
    OBJECT_NAME_INFORMATION *on = NULL;
    FILE_NAME_INFORMATION   *fn = NULL;
    ULONG                   sfn, son;
    FILE_FS_DEVICE_INFORMATION devinfo;
    NTSTATUS                status;
    static IO_STATUS_BLOCK  iosb;

    sfn = sizeof (*fn) + 1024;
    son = sizeof (*on) + 1024;
    fn = reallocslop(NULL, sfn);
    on = reallocslop(NULL, son);

    if (devmap) {
       devmap->filename = fn;
       devmap->name = on;
    }

    if (fn == NULL || on == NULL) {
        KdPrint(( "DEVCTL: Memory allocation failure in query_object!\n" ));
        return STATUS_NO_MEMORY;
    }

    status = NtQueryInformationFile(
                handle,
                &iosb,
                fn,
                sfn,
                FileNameInformation
                );

    testslop(fn, sfn, "NtQueryInformationFile", "FileNameInformation");

    if (NT_SUCCESS(status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        fn->FileNameLength = 0;
    }

    if (!devmap) {
       HeapFree( DevCtlHeapHandle, 0, fn );
       HeapFree( DevCtlHeapHandle, 0, on );
    }

    status = NtQueryVolumeInformationFile(handle,
                                          &iosb,
                                          &devinfo,
                                          sizeof (devinfo),
                                          FileFsDeviceInformation);

    if (NT_SUCCESS(status)) {
        status = iosb.Status;
    }

    if (!NT_SUCCESS(status)) {
        if (devmap) {
           devmap->devtype = 0;
        }
    } else {
        if (devmap) {
           devmap->devtype = devinfo.DeviceType;
        }
//        KdPrint(( "Got the device number for a device!" ));
    }

    //
    // Do loads of different queries with different buffer lengths.
    //
    do_query_file(handle, FileBasicInformation, sizeof(FILE_BASIC_INFORMATION), "FileBasicInformation");
    do_query_file(handle, FileStandardInformation, sizeof(FILE_STANDARD_INFORMATION), "FileStandardInformation");
    do_query_file(handle, FileInternalInformation, sizeof(FILE_INTERNAL_INFORMATION), "FileInternalInformation");
    do_query_file(handle, FileEaInformation, sizeof(FILE_EA_INFORMATION), "FileEaInformation");
    do_query_file(handle, FileAccessInformation, sizeof(FILE_ACCESS_INFORMATION), "FileAccessInformation");
    do_query_file(handle, FileNameInformation, sizeof(FILE_NAME_INFORMATION) + 1024, "FileNameInformation");
    do_query_file(handle, FileModeInformation, sizeof(FILE_MODE_INFORMATION), "FileModeInformation");
    do_query_file(handle, FileAlignmentInformation, sizeof(FILE_ALIGNMENT_INFORMATION), "FileAlignmentInformation");
    do_query_file(handle, FileAllInformation, sizeof(FILE_ALL_INFORMATION), "FileAllInformation");
    do_query_file(handle, FileStreamInformation, sizeof(FILE_STREAM_INFORMATION), "FileStreamInformation");
    do_query_file(handle, FilePipeInformation, sizeof(FILE_PIPE_INFORMATION), "FilePipeInformation");
    do_query_file(handle, FilePipeLocalInformation, sizeof (FILE_PIPE_LOCAL_INFORMATION), "FilePipeLocalInformation");
    do_query_file(handle, FilePipeRemoteInformation, sizeof(FILE_PIPE_REMOTE_INFORMATION), "FilePipeRemoteInformation");
    do_query_file(handle, FileCompressionInformation, sizeof(FILE_COMPRESSION_INFORMATION), "FileCompressionInformation");
    do_query_file(handle, FileNetworkOpenInformation, sizeof(FILE_NETWORK_OPEN_INFORMATION), "FileNetworkOpenInformation");
    do_query_file(handle, FileAttributeTagInformation, sizeof(FILE_ATTRIBUTE_TAG_INFORMATION), "FileAttributeTagInformation");

    do_set_file(handle, FileBasicInformation, sizeof(FILE_BASIC_INFORMATION));
    do_set_file(handle, FileLinkInformation, sizeof(FILE_LINK_INFORMATION));
    do_set_file(handle, FileDispositionInformation, sizeof(FILE_DISPOSITION_INFORMATION));
    do_set_file(handle, FilePositionInformation, sizeof(FILE_POSITION_INFORMATION));
    do_set_file(handle, FileAllocationInformation, sizeof(FILE_ALLOCATION_INFORMATION));
    do_set_file(handle, FileEndOfFileInformation, sizeof(FILE_END_OF_FILE_INFORMATION));
    do_set_file(handle, FileMoveClusterInformation, sizeof(FILE_MOVE_CLUSTER_INFORMATION));

    do_query_volume(handle, FileFsVolumeInformation, sizeof(FILE_FS_VOLUME_INFORMATION) + 1024, "FileFsVolumeInformation");
    do_query_volume(handle, FileFsSizeInformation, sizeof(FILE_FS_SIZE_INFORMATION), "FileFsSizeInformation" );
    do_query_volume(handle, FileFsDeviceInformation, sizeof(FILE_FS_DEVICE_INFORMATION) + 1024, "FileFsDeviceInformation");
    do_query_volume(handle, FileFsAttributeInformation, sizeof(FILE_FS_ATTRIBUTE_INFORMATION), "FileFsAttributeInformation");
    do_query_volume(handle, FileFsControlInformation, sizeof(FILE_FS_CONTROL_INFORMATION), "FileFsControlInformation");
    do_query_volume(handle, FileFsFullSizeInformation, sizeof(FILE_FS_SIZE_INFORMATION), "FileFsFullSizeInformation");
    do_query_volume(handle, FileFsObjectIdInformation, sizeof(FILE_FS_OBJECTID_INFORMATION) + 1024, "FileFsObjectIdInformation");

    return status;
}

/*
   Do the fast queries on the open path
*/
NTSTATUS
try_fast_query_delete_etc(
    POBJECT_ATTRIBUTES poa
    )
{
    PVOID fi = NULL;
    NTSTATUS status;
    ULONG ret;

    status = STATUS_SUCCESS;

    ret = 0;
    do {
        fi = reallocslop(fi, sizeof (FILE_NETWORK_OPEN_INFORMATION));
        status = NtQueryFullAttributesFile(poa, fi);
        testslop(fi, sizeof (FILE_NETWORK_OPEN_INFORMATION), "NtQueryFullAttributesFile", "");
    } while (++ret < MAX_RET);

    ret = 0;
    do {
        status = NtDeleteFile(poa);
    } while (++ret < MAX_RET);

    HeapFree( DevCtlHeapHandle, 0, fi );
    return status;
}

/*
   Do a whole bunch of random things
*/
NTSTATUS misc_functions(
    HANDLE handle,
    ULONG sync
    )
{
    IO_STATUS_BLOCK iosb;
    NTSTATUS status = STATUS_SUCCESS;
    PVOID buf;
    ULONG bufl;
    LONG i;
    LARGE_INTEGER bo;
    ULONG ret;

    buf = HeapAlloc( DevCtlHeapHandle, HEAP_ZERO_MEMORY, bufl = 1024 );
    if (buf == 0) {
       KdPrint(( "DEVCTL: Failed to allocate buffer!\n" ));
       return STATUS_NO_MEMORY;
    }

    i = bufl;

    if (!sync) {
         ret = 0;
         do {
            progress_counter++;
            bo.QuadPart = 0;
            status = NtReadFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                 &bo, NULL);
            if (NT_SUCCESS (status))
               status = iosb.Status;
            progress_counter++;
            bo.QuadPart = 0x7FFFFFFFFFFFFFFF - i + 1;
            status = NtReadFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                 &bo, NULL);
            if (NT_SUCCESS (status))
               status = iosb.Status;
         } while (++ret < MAX_RET);

          ret = 0;
          do {
             progress_counter++;
             bo.QuadPart = 0;
             NtWriteFile (handle, NULL, NULL, NULL, &iosb, buf, i, &bo, NULL);

             //
             // Wrap to negative call
             //
             progress_counter++;
             bo.QuadPart = 0x7FFFFFFFFFFFFFFF - i + 1;
             NtWriteFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                   &bo, NULL);
             //
             // Do an append call.
             //
             progress_counter++;
             bo.QuadPart = -1;
             NtWriteFile (handle, NULL, NULL, NULL, &iosb, buf, i, &bo, NULL);
          } while (++ret < MAX_RET);
    }

       ret = 0;
       do {
          progress_counter++;
          NtFlushBuffersFile (handle, &iosb);
       } while (++ret < MAX_RET);

       {
       ULONG_PTR first = 1, j, datalen, l;
       CHAR bufn[1024];
       PFILE_NAMES_INFORMATION tfni;

       ret = 0;
       do {
          progress_counter++;
          status = NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                         FileNamesInformation, FALSE, NULL, TRUE);
          if ( NT_SUCCESS(status) && first && status != STATUS_PENDING ) {
             first = 0;
             datalen = iosb.Information;
             for (j = 0; j < datalen; j += tfni->NextEntryOffset) {
                tfni = (PFILE_NAMES_INFORMATION)((PCHAR)buf + j);
                memset (bufn, 0, sizeof (bufn));
                l = tfni->FileNameLength / sizeof (WCHAR);
                if (l >= sizeof (bufn) / sizeof (bufn[0]))
                   l = sizeof (bufn) / sizeof (bufn[0]) - 1;
                strncpy (bufn, tfni->FileName, l);
                KdPrint(( "DEVCTL: -> %s\n", bufn ));
                if (tfni->NextEntryOffset == 0)
                   break;
             }
          }
       } while (++ret < MAX_RET);
        }

       ret = 0;
       do {
          progress_counter++;
          NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                         FileDirectoryInformation, FALSE, NULL, TRUE);
       } while (++ret < MAX_RET);

       ret = 0;
       do {
          progress_counter++;
          NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                         FileFullDirectoryInformation, FALSE, NULL, TRUE);
       } while (++ret < MAX_RET);

       ret = 0;
       do {
          progress_counter++;
          NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                         FileBothDirectoryInformation, FALSE, NULL, TRUE);
       } while (++ret < MAX_RET);

       ret = 0;
       do {
          progress_counter++;
          NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                         FileObjectIdInformation, FALSE, NULL, TRUE);
       } while (++ret < MAX_RET);

       ret = 0;
       do {
          progress_counter++;
          NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                         FileQuotaInformation, FALSE, NULL, TRUE);
       } while (++ret < MAX_RET);

       ret = 0;
       do {
          progress_counter++;
          NtQueryDirectoryFile (handle, NULL, NULL, NULL, &iosb, buf, i,
                                         FileReparsePointInformation, FALSE, NULL, TRUE);
       } while (++ret < MAX_RET);

       ret = 0;

    HeapFree( DevCtlHeapHandle, 0, buf );
    return status;
}

//
// Do a load of opens etc relative from the current handle
//
NTSTATUS
do_sub_open_etc(
    HANDLE handle,
    PCHAR s
)
{
    OBJECT_ATTRIBUTES oa;
    OBJECT_STRING name;
    NTSTATUS status;
    IO_STATUS_BLOCK iosb;
    PCHAR as;

    if (strlen (s) > 30) {
       as = "Big...";
    } else {
       as = s;
    }

    RtlInitObjectString (&name, s);
    InitializeObjectAttributes(&oa,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               handle,
                               NULL);
    status = NtCreateFile(&handle,
                          MAXIMUM_ALLOWED,
                          &oa,
                          &iosb,
                          NULL,
                          0,
                          0,
                          FILE_OPEN,
                          0,
                          NULL,
                          0);

    if (NT_SUCCESS (status)) {
       status = iosb.Status;
    }

    if (NT_SUCCESS (status)) {
       query_object(handle, NULL);
       misc_functions (handle, 0);
       status = NtClose(handle);
       if (!NT_SUCCESS (status)) {
          KdPrint(( "DEVCTL: NtClose failed %s\n", NtStatusSymbolicName(status) ));
       }
    }

    try_fast_query_delete_etc (&oa);
    return status;
}
//
// Try a few opens relative to the device its self.
//
NTSTATUS
try_funny_opens(
    HANDLE handle
)
{
    ULONG ret, i;
    static ULONG bigl;

    if (DevCtlBigBuffer == NULL) {
       DevCtlBigBuffer = HeapAlloc( DevCtlHeapHandle, HEAP_ZERO_MEMORY, bigl = 0x10000 );
       if (DevCtlBigBuffer == NULL) {
          KdPrint(( "DEVCTL: Memory allocation failure in try_funny_opens!\n" ));
          return STATUS_NO_MEMORY;
       }
       bigl /= sizeof (DevCtlBigBuffer[0]);

       for (i = 0; i < bigl; i++)
          DevCtlBigBuffer[i] = 'A';
       DevCtlBigBuffer[bigl - 3] = '\0';
    }
    ret = 0;
    do {
       do_sub_open_etc (handle, "");
       do_sub_open_etc (handle, " ");
       do_sub_open_etc (handle, "\\");
       do_sub_open_etc (handle, "\\\\\\\\\\\\");
       do_sub_open_etc (handle, DevCtlBigBuffer);
       do_sub_open_etc (handle, ":");
       do_sub_open_etc (handle, " :");
       do_sub_open_etc (handle, ": ");
       do_sub_open_etc (handle, ": ");
       do_sub_open_etc (handle, "::");
       do_sub_open_etc (handle, ": :");
       do_sub_open_etc (handle, "::$UNUSED");
       do_sub_open_etc (handle, "::$STANDARD_INFORMATION");
       do_sub_open_etc (handle, "::$ATTRIBUTE_LIST");
       do_sub_open_etc (handle, "::$FILE_NAME");
       do_sub_open_etc (handle, "::$OBJECT_ID");
       do_sub_open_etc (handle, "::$SECURITY_DESCRIPTOR");
       do_sub_open_etc (handle, "::$VOLUME_NAME");
       do_sub_open_etc (handle, "::$VOLUME_INFORMATION");
       do_sub_open_etc (handle, "::$DATA");
       do_sub_open_etc (handle, "::$INDEX_ROOT");
       do_sub_open_etc (handle, "::$INDEX_ALLOCATION");
       do_sub_open_etc (handle, "::$BITMAP");
       do_sub_open_etc (handle, "::$REPARSE_POINT");
       do_sub_open_etc (handle, "::$EA_INFORMATION");
       do_sub_open_etc (handle, "::$PROPERTY_SET");
       do_sub_open_etc (handle, "::$FIRST_USER_DEFINED_ATTRIBUTE");
       do_sub_open_etc (handle, "::$END");
    } while (++ret < MAX_RET);
    return 0;
}

VOID
randomize_buf(
    PVOID buf,
    ULONG bufl
)
{
   ULONG i;
   PUCHAR pc = buf;

   for (i = 0; i < bufl; i++) {
      *pc++ = (UCHAR)(rand() & 0xff);
   }
}

/*

   Thread used to randomize buffers
*/
VOID
WINAPI
randomize(
    PVOID buf
)
{
   ULONG i;
   PUCHAR pc;

   while ( ExitFromThread == FALSE ) {
      pc = buf;
      try {
          for (i = 0; i < BIGBUF_SIZE; i++) {
              *pc++ = (UCHAR)(rand() & 0xff);
          }
      } except (EXCEPTION_EXECUTE_HANDLER) {
      }
      SleepEx (0, TRUE);
   }
}


VOID
WINAPI
AlerterThread(
    HANDLE MainThreadHandle
)

/*++

Routine Description:

    Thread used to keep the main thread moving if it gets stuck in a synchronouse I/O

Arguments:

    MainThreadHandle - thread handle of main thread

Return Value:

    None

--*/

{
    NTSTATUS Status;
    ULONG last = progress_counter;

    while ( ExitFromThread == FALSE ) {

        last = progress_counter;
        SleepEx( 5000, TRUE );
        if ( progress_counter == 0 || progress_counter != last ) {
            continue;
        }

        Status = NtAlertThreadEx ( MainThreadHandle, UserMode );
        if ( !NT_SUCCESS(Status) ) {
            KdPrint(( "DEVCTL: NtAlertThreadEx failed %s\n", NtStatusSymbolicName(Status) ));
        }

        alerted++;
    }
}

void record_ioctl (PIOCTLREC *piorec, ULONG ioctl, NTSTATUS status)
{
   PIOCTLREC iorec = *piorec;
   ULONG i, j;

   if (!iorec) {
      iorec = HeapAlloc( DevCtlHeapHandle, HEAP_ZERO_MEMORY, sizeof (*iorec) + \
                      INITIAL_IOCTL_TAILOR_SIZE * sizeof (iorec->ioctl[0]) );
      if (!iorec) {
         return;
      }
      *piorec = iorec;
      iorec->total = INITIAL_IOCTL_TAILOR_SIZE;
      iorec->count = 0;
   }
   for (i = 0; i < iorec->count; i++) {
      if (iorec->ioctl[i].ioctl == ioctl && iorec->ioctl[i].status == status) {
         return;
      }
      if (iorec->ioctl[i].status == status) {
         if (iorec->ioctl[i].count > MAX_IOCTL_TAILOR) {
            return; // too many seen of this one
         }
         if (++iorec->ioctl[i].count > MAX_IOCTL_TAILOR) {
            for (j = i + 1; j < iorec->count; j++) {
               if (iorec->ioctl[j].status == status) {
                  iorec->ioctl[j] = iorec->ioctl[--iorec->count];
                  j--;
               }
            }
            return;
         }
         break;
      }
   }
   if (iorec->total == iorec->count) {
      iorec = HeapReAlloc( DevCtlHeapHandle, 0, iorec, sizeof (*iorec) + \
                       iorec->total * 2 * sizeof (iorec->ioctl[0]) );
      if (!iorec) {
         return;
      }
      *piorec = iorec;
      iorec->total *= 2;
   }
   i = iorec->count;
   iorec->ioctl[i].status = status;
   iorec->ioctl[i].ioctl = ioctl;
   iorec->ioctl[i].count = 0;
   iorec->count = i + 1;
}

void do_tailored_ioctl (PDEVMAP                 devmap,
                        PIOCTLREC               iorec,
                        ULONG fsctl)
{
   ULONG                   method, ioctl_val;
   PVOID                   inbuf, outbuf;
   ULONG                   inlen, outlen;
   static IO_STATUS_BLOCK  static_iosb;
   ULONG                   ret;
   ULONG                   i, j, k;
   NTSTATUS                status;

   if (!iorec) {
      return;
   }

   for (i = 0; i < iorec->count; i++) {
      if (iorec->ioctl[i].count >= MAX_IOCTL_TAILOR)
         continue;
      ioctl_val = iorec->ioctl[i].ioctl;
      method = ioctl_val&0x3;
      alerted = 0;
      for (j = 0; j < max_tailured_calls; j += RAND_REP) {
         ret = 0;
         do {
            for (k = 0; k < RAND_REP; k++) {
               switch(method) {
                  case METHOD_BUFFERED :

                     inlen = rand()&(BIGBUF_SIZE - 1);
                     outlen = rand()&(BIGBUF_SIZE - 1);

                     inbuf = bigbuf;
                     outbuf = bigbuf;

                     randomize_buf (inbuf, inlen);
                     break;

                  case METHOD_IN_DIRECT :
                  case METHOD_OUT_DIRECT :

                     inlen = rand()&(BIGBUF_SIZE - 1);
                     outlen = rand()&(BIGBUF_SIZE - 1);

                     inbuf = bigbuf;
                     outbuf = &bigbuf[BIGBUF_SIZE - outlen];
                     randomize_buf (inbuf, inlen);
                     randomize_buf (outbuf, outlen);

                     break;

                  case METHOD_NEITHER :
                  default :

                     inlen = rand32();
                     outlen = rand32();

                     inbuf = (PVOID)rand32();
                     outbuf = (PVOID)rand32();

                     break;
               }

               progress_counter++;
               if (!fsctl) {
                  status = NtDeviceIoControlFile(devmap->handle,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 &static_iosb,
                                                 ioctl_val,
                                                 inbuf,
                                                 inlen,
                                                 outbuf,
                                                 outlen);
               } else {
                  status = NtFsControlFile(devmap->handle,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &static_iosb,
                                           ioctl_val,
                                           inbuf,
                                           inlen,
                                           outbuf,
                                           outlen);
               }
            }
            if (alerted > 5) {
               break;
            }
         } while (++ret < MAX_RET);
         if (alerted > 5)
            break;

      }
   }
}

NTSTATUS
do_ioctl(
    PDEVMAP                 devmap
)
{
    ULONG                   function, method=0, access, i, j, ioctl_val=0;
    static IO_STATUS_BLOCK  static_iosb;
    PVOID                   inbuf, outbuf;
    ULONG                   inlen, outlen;
    ULONG                   tmp;
    NTSTATUS                status;
    ULONG                   devtype;
    ULONG                   ret;
    BOOL                    hit_leak;
    PIOCTLREC               iorec = NULL, fsrec = NULL;

    //
    // do I/O calls with no buffer
    //
    for (function = ioctl_min_function; function <= ioctl_max_function; function++) {
      for (devtype = ioctl_min_devtype; devtype <= ioctl_max_devtype; devtype++) {
          ret = 0;
          do {
             hit_leak = FALSE;
             for (access = FILE_ANY_ACCESS;
                  access <= (devmap->access&(FILE_READ_ACCESS|FILE_WRITE_ACCESS));
                  access++) {
                 for (method = 0; method < 4; method++) {
                     ioctl_val = CTL_CODE(devtype, function, method, access);

                     progress_counter++;
                    status = NtDeviceIoControlFile(devmap->handle,
                                                   NULL, NULL, NULL,
                                                   &static_iosb,
                                                   ioctl_val,
                                                   (PVOID)bigbuf,
                                                   0,
                                                   (PVOID)bigbuf,
                                                   0);
                    record_ioctl (&iorec, ioctl_val, status);

                    status = NtFsControlFile(devmap->handle, NULL, NULL, NULL,
                                             &static_iosb,
                                             ioctl_val,
                                             (PVOID)bigbuf,
                                             0,
                                             (PVOID)bigbuf,
                                             0);
                    record_ioctl (&fsrec, ioctl_val, status);

                    Sleep (0);
                 }
             }
         } while (++ret < MAX_RET);
      }
    }


   status = NtResumeThread (randthread, &tmp);
   if (!NT_SUCCESS (status)) {
      KdPrint(( "DEVCTL: NtResumeThread failed %s\n", NtStatusSymbolicName(status) ));
   }
   for (i = 0; i < max_random_calls; i += RAND_REP) {
       if (ioctl_min_function >= ioctl_max_function)
          function = ioctl_min_function;
       else
          function = ioctl_min_function +
                     (rand() % (ioctl_max_function - ioctl_min_function));
       ret = 0;
       do {
          for (j = 0; j < RAND_REP; j++) {
             if (ioctl_min_devtype >= ioctl_max_devtype)
                devtype = ioctl_min_devtype;
             else
                devtype = ioctl_min_devtype +
                           (rand() % (ioctl_max_devtype - ioctl_min_devtype));
             method = rand() & 0x3;

             access = rand() & devmap->access&(FILE_READ_ACCESS|FILE_WRITE_ACCESS);

             ioctl_val = CTL_CODE(devtype,
                                  function,
                                  method,
                                  access);

             switch(method) {
                 case METHOD_BUFFERED :

                     inlen = rand()&(BIGBUF_SIZE - 1);
                     outlen = rand()&(BIGBUF_SIZE - 1);

                     inbuf = bigbuf;
                     outbuf = bigbuf;

                     break;

                 case METHOD_IN_DIRECT :
                 case METHOD_OUT_DIRECT :

                     inlen = rand()&(BIGBUF_SIZE - 1);
                     outlen = rand()&(BIGBUF_SIZE - 1);

                     inbuf = bigbuf;
                     outbuf = &bigbuf[BIGBUF_SIZE - outlen];
//                       KdPrint(( "%p %d %p %d", inbuf, inlen, outbuf, outlen ));

                     break;

                 case METHOD_NEITHER :
                 default :

                     inlen = rand32();
                     outlen = rand32();

                     inbuf = (PVOID)rand32();
                     outbuf = (PVOID)rand32();

                     break;
             }

             progress_counter++;
                NtDeviceIoControlFile(devmap->handle,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &static_iosb,
                                      ioctl_val,
                                      inbuf,
                                      inlen,
                                      outbuf,
                                      outlen);
                record_ioctl (&iorec, ioctl_val, status);

                NtFsControlFile(devmap->handle,
                                NULL,
                                NULL,
                                NULL,
                                &static_iosb,
                                ioctl_val,
                                inbuf,
                                inlen,
                                outbuf,
                                outlen);
                record_ioctl (&fsrec, ioctl_val, status);
         }

      } while (++ret < MAX_RET);
   }

   status = NtSuspendThread (randthread, &tmp);
   if (!NT_SUCCESS (status)) {
      KdPrint(( "DEVCTL: NtSuspendThread failed %s\n", NtStatusSymbolicName(status) ));
   }

   do_tailored_ioctl (devmap, iorec, 0);
   do_tailored_ioctl (devmap, fsrec, 1);

    if (iorec) {
       HeapFree( DevCtlHeapHandle, 0, iorec );
    }
    if (fsrec) {
       HeapFree( DevCtlHeapHandle, 0, fsrec );
    }
    return 0;
}

/*
   Open device with various options
*/
NTSTATUS
open_device(
    HANDLE                  parent,
    POBJECT_STRING          name,
    PDEVMAP                 devmap,
    BOOL                    synch,        // Do a synchronous open
    BOOL                    direct        // Do a direct open
)
{
    NTSTATUS                  status;
    IO_STATUS_BLOCK           iosb;
    ULONG                     l, lw;
    CHAR                      dn[1024];
    OBJECT_STRING             dnu;
    ULONG                     options;
    OBJECT_ATTRIBUTES         oa;
    ACCESS_MASK               am;
    ULONG                     share=0;

    l = name->Length;
    if (l >= sizeof (dn))
       l = sizeof (dn) - 1;
    lw = l / sizeof (dn[0]);
    strncpy (dn, name->Buffer, lw);
    dn[lw] = '\0';
    RtlInitObjectString (&dnu, dn);
    dn[min(dnu.Length, sizeof (dn) - sizeof (dn[0]))/sizeof(dn[0])] = 0;

    InitializeObjectAttributes(&oa,
                               name,
                               OBJ_CASE_INSENSITIVE,
                               parent,
                               NULL);

    devmap->handle = NULL;

    if (direct) {
        options = 0;
        am = SYNCHRONIZE|FILE_READ_ATTRIBUTES|READ_CONTROL|WRITE_OWNER|WRITE_DAC;
    } else if (synch) {
        options = FILE_SYNCHRONOUS_IO_ALERT;
        am = MAXIMUM_ALLOWED|SYNCHRONIZE;
    } else {
        options = 0;
        am = MAXIMUM_ALLOWED;
    }

    do {
        status = NtCreateFile(
                    &devmap->handle,
                    am,
                    &oa,
                    &iosb,
                    NULL,
                    0,
                    share,
                    FILE_OPEN,
                    options,
                    NULL,
                    0
                    );

        if (status == STATUS_SHARING_VIOLATION) {
            if (share&FILE_SHARE_READ) {
                share &= ~FILE_SHARE_READ;
                if (share&FILE_SHARE_WRITE) {
                   share &= ~FILE_SHARE_WRITE;
                   if (share&FILE_SHARE_DELETE) {
                      break;
                   } else {
                      share |= FILE_SHARE_DELETE;
                   }
                } else {
                   share |= FILE_SHARE_WRITE;
                }
             } else {
                share |= FILE_SHARE_READ;
             }
          } else if (status == STATUS_ACCESS_DENIED) {
             if (am&MAXIMUM_ALLOWED) {
                am &= ~MAXIMUM_ALLOWED;
                am |= FILE_READ_DATA|FILE_WRITE_DATA|SYNCHRONIZE|FILE_READ_ATTRIBUTES|
                      READ_CONTROL|FILE_APPEND_DATA;
             } else if (am&FILE_WRITE_DATA) {
                am &= ~FILE_WRITE_DATA;
             } else if (am&FILE_APPEND_DATA) {
                am &= ~FILE_APPEND_DATA;
             } else if (am&FILE_READ_DATA) {
                am &= ~FILE_READ_DATA;
             } else if (am&WRITE_OWNER) {
                am &= ~WRITE_OWNER;
             } else if (am&WRITE_DAC) {
                am &= ~WRITE_DAC;
             } else if (am&WRITE_DAC) {
                am &= ~WRITE_DAC;
             } else if (am&READ_CONTROL) {
                am &= ~READ_CONTROL;
             } else if (am&FILE_READ_ATTRIBUTES) {
                am &= ~FILE_READ_ATTRIBUTES;
             } else {
                break;
             }
          }
    } while (status == STATUS_SHARING_VIOLATION || status == STATUS_ACCESS_DENIED);

    if (NT_SUCCESS(status)) {
        query_object(devmap->handle, devmap);
        misc_functions (devmap->handle, synch);
    } else {
        if (status != STATUS_INVALID_DEVICE_REQUEST &&
            status != STATUS_ACCESS_DENIED) {
            KdPrint(( "DEVCTL: NtCreateFile failed %s\n", NtStatusSymbolicName(status) ));
        }
    }

    if ( (direct && synch) || (!synch && !direct) ) {
        // Only do this twice
        try_fast_query_delete_etc (&oa);
    }

    return status;
}


NTSTATUS
do_device_opens(
    HANDLE handle,
    POBJECT_STRING name,
    PDEVMAP devmap,
    PULONG  devscount
    )

/*++

Routine Description:

   Do all the various different opens looking for handles

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;

    Status = open_device(
                handle,
                name,
                &devmap[*devscount],
                TRUE,   /* Synchronous           */
                FALSE   /* No direct device open */
                );

    if ( NT_SUCCESS(Status) ) {
        try_funny_opens( devmap[*devscount].handle );
        do_ioctl( &devmap[*devscount] );
        *devscount = *devscount + 1;
        if ( *devscount == MAX_DEVICES ) {
            return Status;
        }
    } else {
        KdPrint((
            "DEVCTL: failed to open device %Z (sync, indirect, %s)\n",
            name,
            NtStatusSymbolicName(Status)
            ));
    }

    Status = open_device(
                handle,
                name,
                &devmap[*devscount],
                FALSE,  /* Synchronous             */
                FALSE   /* No direct device access */
                );

    if ( NT_SUCCESS(Status) ) {
        try_funny_opens( devmap[*devscount].handle );
        do_ioctl( &devmap[*devscount] );
        *devscount = *devscount + 1;
    } else {
        KdPrint((
            "DEVCTL: failed to opened device %Z (async, indirect, %s)\n",
            name,
            NtStatusSymbolicName(Status)
            ));
    }

    Status = open_device(
                handle,
                name,
                &devmap[*devscount],
                TRUE,  /* Synchronous          */
                TRUE   /* Direct device access */
                );

    if ( NT_SUCCESS(Status) ) {
        try_funny_opens( devmap[*devscount].handle );
        do_ioctl( &devmap[*devscount] );
        *devscount = *devscount + 1;
    } else {
        KdPrint((
            "DEVCTL: failed to opened device %Z (sync, direct, %s)\n",
            name,
            NtStatusSymbolicName(Status)
            ));
    }

    return Status;
}


NTSTATUS
recurse(
    HANDLE           handle,
    POBJECT_STRING   name,
    PDEVMAP          devmap,
    PULONG           devscount,
    PCHAR            path
    )

/*++

Routine Description:

    Traverse the object tree looking for devices

Arguments:

Return Value:

--*/

{
    HANDLE nhandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    OBJECT_DIRECTORY_INFORMATION *od;
    PVOID buffer;
    ULONG bufferlen;
    ULONG retlen, Context=0;
    PCHAR npath = NULL;

    bufferlen = 0x2000;
    buffer = HeapAlloc( DevCtlHeapHandle, HEAP_ZERO_MEMORY, bufferlen );

    if ( !buffer ) {
        return STATUS_NO_MEMORY;
    }

    InitializeObjectAttributes(
        &oa,
        name,
        OBJ_CASE_INSENSITIVE,
        handle,
        NULL
        );

    Status = NtOpenDirectoryObject( &nhandle, &oa );

    if ( NT_SUCCESS(Status) ) {
        do {
            //
            // Under Xbox, NtQueryDirectoryObject returns single entry at a time
            //
            Status = NtQueryDirectoryObject(
                        nhandle,
                        buffer,
                        bufferlen,
                        FALSE,
                        &Context,
                        &retlen
                        );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                PVOID pv = HeapReAlloc(
                                DevCtlHeapHandle,
                                HEAP_ZERO_MEMORY,
                                buffer,
                                bufferlen + 0x1000
                                );
                KdPrint(( "DEVCTL: buffer too small, trying %lu\n", bufferlen + 0x1000 ));
                if ( pv ) {
                    bufferlen += 0x1000;
                    buffer = pv;
                    continue;
                }
            }

            if ( NT_SUCCESS(Status) ) {
                od = (POBJECT_DIRECTORY_INFORMATION)buffer;
                if ( od->Name.Length ) {
                    size_t len = strlen(path);
                    npath = HeapAlloc( DevCtlHeapHandle, 0, len + 1 + od->Name.Length + 1);

                    if (!npath) {
                       KdPrint(( "DEVCTL: memory allocation failed for path buffer! "));
                       Status = STATUS_NO_MEMORY;
                       break;
                    }

                    strcpy (npath, path);
                    if ( len == 0 || (len && path[len-1] != '\\') ) {
                        strcat(npath, "\\");
                    }

                    memcpy( npath+len, od->Name.Buffer, od->Name.Length );
                    *(npath+len+od->Name.Length) = 0;

                    if (od->Type == 'eriD') {

                        recurse(nhandle,
                                &od->Name,
                                devmap,
                                devscount,
                                npath
                                );

                    } else if ( od->Type == 'iveD' ) {
                        Status = do_device_opens (nhandle,
                                                  &od->Name,
                                                  devmap,
                                                  devscount
                                                  );
                    }
                }
            } else if ( !NT_SUCCESS(Status) && Status != STATUS_NO_MORE_ENTRIES ) {
                KdPrint(( "DEVCTL: NtQueryDirectoryObject failed (%s)\n", NtStatusSymbolicName(Status) ));
            }

        } while ( NT_SUCCESS(Status) );

        HeapFree( DevCtlHeapHandle, 0, buffer );
        NtClose(nhandle);
    } else {
        KdPrint((
            "DEVCTL: NtOpenDirectoryObject failed %Z (%s)\n",
            name,
            NtStatusSymbolicName(Status)
            ));
    }

    HeapFree( DevCtlHeapHandle, 0, npath );
    return Status;
}


VOID
AlertExitThread(
    HANDLE ThreadHandle
    )
{
    ULONG PreviousSuspendCount;
    NTSTATUS Status;

    do {
        Status = NtResumeThread( ThreadHandle, &PreviousSuspendCount );
    } while ( NT_SUCCESS(Status) && PreviousSuspendCount );

    QueueUserAPC((PAPCFUNC)ExitThread, ThreadHandle, 0 );
    NtAlertThreadEx( ThreadHandle, UserMode );
    SetThreadPriority( ThreadHandle, THREAD_PRIORITY_HIGHEST );

    while ( WaitForSingleObject(ThreadHandle, 5000) == WAIT_TIMEOUT ) {
        KdPrint(( "DEVCTL: timeout while waiting for thread to be terminated\n" ));
#if DBG
        __asm int 3;
#endif
    }

    CloseHandle( ThreadHandle );
}


VOID
WINAPI
DevCtlStartTest(
    HANDLE hLog
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    DevCtlLogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    ULONG i, devscount;
    OBJECT_STRING ObjS;
    NTSTATUS Status;

    KdPrint(( "DEVCTL: StartTest\n" ));
    ASSERT( DevCtlLogHandle != INVALID_HANDLE_VALUE );
    DevCtlLogHandle = hLog;

    MAX_RET = GetProfileIntA( "devctl", "maxretry", 500 );

    xSetComponent( DevCtlLogHandle, "Kernel", "Io" );
    xSetFunctionName( DevCtlLogHandle, "stress" );
    xStartVariation( DevCtlLogHandle, "I/O stress" );

    srand( (unsigned)time(NULL) );

    __try {

        bigbuf = NULL;
        randthread = NULL;
        alertthread = NULL;
        mainthread = NULL;
        ExitFromThread = FALSE;

        bigbuf = VirtualAlloc( NULL, BIGBUF_SIZE+SLOP, MEM_COMMIT, PAGE_READWRITE );
        if ( !bigbuf ) {
            KdPrint(( "DEVCTL: unable to allocate memory\n" ));
            __leave;
        }

        randthread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)randomize, bigbuf, 0, NULL );
        if ( !randthread ) {
            __leave;
        }

        Status = NtDuplicateObject( NtCurrentThread(), &mainthread, DUPLICATE_SAME_ACCESS );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(( "DEVCTL: NtDuplicateObject failed %s\n", NtStatusSymbolicName(Status) ));
            __leave;
        }

        alertthread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)AlerterThread, mainthread, 0, NULL );
        if ( !alertthread ) {
            KdPrint(( "DEVCTL: failed to create alerting thread %s\n", WinErrorSymbolicName(GetLastError()) ));
            __leave;
        }

        Status = NtSuspendThread( randthread, NULL );
        if ( !NT_SUCCESS(Status) ) {
            KdPrint(( "DEVCTL: NtSuspendThread failed %s\n", NtStatusSymbolicName(Status) ));
        }

        devscount = 0;
        RtlInitObjectString( &ObjS, OTEXT("\\") );
        recurse( 0, &ObjS, g_devmap, &devscount, "" );

        for ( i=0; i<devscount; i++ ) {
            HeapFree( DevCtlHeapHandle, 0, g_devmap[i].name );
            g_devmap[i].name = NULL;
            HeapFree( DevCtlHeapHandle, 0, g_devmap[i].filename );
            g_devmap[i].filename = NULL;
            NtClose(g_devmap[i].handle);
        }

        devscount = 0;

        InterlockedExchange( (LPLONG)&ExitFromThread, TRUE );

    } __finally {

        if ( randthread ) {
            AlertExitThread( randthread );
        }

        if ( alertthread ) {
            AlertExitThread( alertthread );
        }

        if ( mainthread ) {
            NtClose( mainthread );
        }

        if ( bigbuf ) {
            VirtualFree( bigbuf, 0, MEM_RELEASE );
        }
    }

    xEndVariation( DevCtlLogHandle );
}


VOID
WINAPI
DevCtlEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    KdPrint(( "DEVCTL: EndTest\n" ));
}


BOOL
WINAPI
DevCtlDllMain(
    HINSTANCE   hInstance,
    DWORD       fdwReason,
    LPVOID      lpReserved
    )
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( lpReserved );

    if ( fdwReason == DLL_PROCESS_ATTACH ) {
        DevCtlHeapHandle = HeapCreate( 0, 0, 0 );
    } else if ( fdwReason == DLL_PROCESS_DETACH ) {
        DevCtlBigBuffer = NULL;
        HeapDestroy( DevCtlHeapHandle );
    }

    return DevCtlHeapHandle != NULL;
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( devctl )
#pragma data_seg()

BEGIN_EXPORT_TABLE( devctl )
    EXPORT_TABLE_ENTRY( "StartTest", DevCtlStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DevCtlEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", DevCtlDllMain )
END_EXPORT_TABLE( devctl )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\mm\abuseval\abuseval.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    abuseval.c

Abstract:

    This module contains routines for page attributes testing.  Page with
    PAGE_READONLY, PAGE_READWRITE, PAGE_GUARD, PAGE_NOACCESS will be tested.

--*/

#include <ntos.h>
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <xtestlib.h>
#include <xlog.h>

VOID
PageAttributeTestWorker(
    IN HANDLE LogHandle,
    IN PCSTR PageAttributeString,
    IN DWORD PageAttribute,
    IN PVOID lpBuffer,
    IN BOOL  fAllowWrite,
    IN BOOL  fAllowRead
    )
{
    CHAR Buffer[256];
    BOOL b;
    DWORD dwOldProtect;

    sprintf( Buffer, "Write to %s", PageAttributeString );
    xStartVariation( LogHandle, Buffer );

    __try {

        b = VirtualProtect( lpBuffer, PAGE_SIZE, PageAttribute, &dwOldProtect );

        if ( !b ) {
            xLog( LogHandle, XLL_BLOCK,
                  "Failed to change page attributes to %s (%s)",
                  PageAttributeString, WinErrorSymbolicName(GetLastError()) );
            __leave;
        }

        *(volatile CHAR *)lpBuffer = 0;

        xLog( LogHandle, fAllowWrite ? XLL_PASS : XLL_FAIL,
            "No exception raised" );

        sprintf( Buffer, "Write to %s", PageAttributeString );
        xStartVariation( LogHandle, Buffer );

        __try {
            *(volatile CHAR *)lpBuffer;
            xLog( LogHandle, fAllowRead ? XLL_PASS : XLL_FAIL,
                "No exception raised" );
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            xLog( LogHandle, fAllowRead ? XLL_FAIL : XLL_PASS, "Exception raised" );
        }

        xEndVariation( LogHandle );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        xLog( LogHandle, fAllowWrite ? XLL_FAIL : XLL_PASS, "Exception raised" );
    }

    xEndVariation( LogHandle );
}

VOID
PageAttributesTest(
    HANDLE LogHandle,
    LPVOID lpBuffer
    )
/*++

Routine Description:

    This routine will check that the region pointed to by lpBuffer is of
    PAGE_GUARD

Arguments:

    LogHandle - Handle for xLog

    lpBuffer - buffer pointing to the virtualalloc'd region

    dwBufferSize - size of the buffer

Return:

    None

--*/
{
    BOOL b;
    DWORD dwOldProtect;

    //
    // PAGE_GUARD
    //
    // We read the same page twice, first time we expect an exception
    // second time we don't
    //

    xStartVariation( LogHandle, "Read from PAGE_GUARD (1st read)" );

    __try {

        b = VirtualProtect( lpBuffer, PAGE_SIZE, PAGE_READWRITE | PAGE_GUARD,
                            &dwOldProtect );
        if ( !b ) {
            xLog( LogHandle, XLL_BLOCK,
                  "Failed to change page attributes to "
                  "PAGE_READWRITE | PAGE_GUARD (%s)",
                  WinErrorSymbolicName(GetLastError()) );
            __leave;
        }

        *(volatile CHAR *)lpBuffer;
        xLog( LogHandle, XLL_FAIL, "No exception raised" );

        xStartVariation( LogHandle, "Read from PAGE_GUARD (2nd read)" );

        __try {
            *(volatile CHAR *)lpBuffer;
            xLog( LogHandle, XLL_PASS, "No exception raised" );
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            xLog( LogHandle, XLL_FAIL, "Exception raised unexpectedly" );
        }

        xEndVariation( LogHandle );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        xLog( LogHandle, XLL_PASS, "Exception raised" );
    }

    xEndVariation( LogHandle );

    //
    // Test various page attributes
    //

    PageAttributeTestWorker( LogHandle, "PAGE_READONLY", PAGE_READONLY,
                             lpBuffer, FALSE, TRUE );

    PageAttributeTestWorker( LogHandle, "PAGE_READWRITE", PAGE_READWRITE,
                             lpBuffer, TRUE, TRUE );

    PageAttributeTestWorker( LogHandle, "PAGE_NOACCESS", PAGE_NOACCESS,
                             lpBuffer, FALSE, FALSE );
}


VOID
WINAPI
PageAttributesStartTest(
    HANDLE LogHandle
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    LPVOID lpBuffer;

    xSetComponent( LogHandle, "Kernel", "Mm" );
    xSetFunctionName( LogHandle, "VirtualAlloc" );

    lpBuffer = VirtualAlloc( NULL, PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE );

    if ( !lpBuffer ) {
        xStartVariation( LogHandle, "Allocation" );
        xLog( LogHandle, XLL_BLOCK, "VirtualAlloc failed (%s)",
              WinErrorSymbolicName(GetLastError()) );
        xEndVariation( LogHandle );
        return;
    }

    PageAttributesTest( LogHandle, lpBuffer );
    VirtualFree( lpBuffer, 0, MEM_RELEASE );
}

VOID
WINAPI
PageAttributesEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( abuseval )
#pragma data_seg()

BEGIN_EXPORT_TABLE( abuseval )
    EXPORT_TABLE_ENTRY( "StartTest", PageAttributesStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", PageAttributesEndTest )
END_EXPORT_TABLE( abuseval )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\mm\perf\memcpy\nt\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    This module contains routines to measure memory performace under NT

Environment:

    User mode

Revision History:

--*/


#include <windows.h>
#include <stdio.h>


VOID
WINAPI
MemPerfStartTest(
    HANDLE
    );


int
_cdecl
main( void )
{
    MemPerfStartTest( NULL );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\mm\perf\memcpy\memperf.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    memperf.cpp

Abstract:

    This module contains routines to measure memory performace under Xbox

Environment:

    Xbox

Revision History:

--*/


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#if XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif

#include <xlog.h>
#include <xtestlib.h>
#include <stdio.h>
#include <testutil.h>
#include <tsc.h>


#define NUMBER_OF_LOOP  1500
#define MEGABYTE   (1024*1024)


VOID
MemoryBandwidthTest(
    HANDLE LogHandle,
    LPSTR  FunctionName,
    DWORD  AdditionalProtecionFlags,
    BOOL   BlockInterrupt,
    DWORD  numBytes
    )
{
    ULONG i;

    xSetFunctionName( LogHandle, FunctionName );

    BEGIN_VARIATION( "Memory Bandwidth" )
    {
        PBYTE Destination = NULL;
        PBYTE Source = NULL;
        INT64 BestTime = 0x7FFFFFFFFFFFFFFFI64;

        #ifndef _UNDER_NT
        if ( XTestLibIsStressTesting() ) {
            LOG_MSG_BLOCK( "This test only runs in serial mode" );
            goto EndVariation;
        }
        #else
        UNREFERENCED_PARAMETER( BlockInterrupt );
        #endif

        Source = (PBYTE)VirtualAlloc(
                                0,
                                numBytes,
                                MEM_COMMIT,
                                PAGE_READWRITE | AdditionalProtecionFlags
                                );
        if ( !Source ) {
            LOG_MSG_BLOCK( "not enough memory" );
            goto EndVariation;
        }

        Destination = (PBYTE)VirtualAlloc(
                                0,
                                numBytes,
                                MEM_COMMIT,
                                PAGE_READWRITE | AdditionalProtecionFlags
                                );
        if ( !Destination ) {
            LOG_MSG_BLOCK( "not enough memory" );
            VirtualFree( Source, 0, MEM_RELEASE );
            goto EndVariation;
        }

        if ( Destination ) {

            CHAR Buffer[256];
            int ThreadPriority = GetThreadPriority( GetCurrentThread() );
            if ( ThreadPriority != THREAD_PRIORITY_ERROR_RETURN ) {
                SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL );
            }

            for ( i=0; i<NUMBER_OF_LOOP; i++ ) {
#ifndef _UNDER_NT
                if ( BlockInterrupt ) {
                    __asm cli;
                }
#endif
                INT64 StartTime = TscBegin();
                memcpy( Destination, Source, numBytes );
                INT64 TotalTime = TscEnd( StartTime );

#ifndef _UNDER_NT
                if ( BlockInterrupt ) {
                    __asm sti
                }
#endif
                if ( TotalTime < BestTime ) {
                    BestTime = TotalTime;
                }
            }

            if ( ThreadPriority != THREAD_PRIORITY_ERROR_RETURN ) {
                SetThreadPriority( GetCurrentThread(), ThreadPriority );
            }

            sprintf(
                Buffer,
                "MEMPERF: %f MB/sec",
                (float)(numBytes/TscTicksToFUSeconds(BestTime))
                );

            KdPrint(( "%s\n", Buffer ));
            LOG_MSG_PASS( Buffer );

            VirtualFree( Source, 0, MEM_RELEASE );
            VirtualFree( Destination, 0, MEM_RELEASE );
        }

EndVariation:
        NOTHING;
    }
    END_VARIATION();
}


VOID
WINAPI
MemPerfStartTest(
    HANDLE LogHandle
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    KdPrint(( "MEMPERF: StartTest\n" ));
    xSetComponent( LogHandle, "Mm", "Perf" );

    TscInit( 0 );
    MemoryBandwidthTest( LogHandle, "Cache (1 meg)", 0, FALSE, MEGABYTE );
    MemoryBandwidthTest( LogHandle, "No Cache (1 meg)", PAGE_NOCACHE, FALSE, MEGABYTE );
    MemoryBandwidthTest( LogHandle, "No Cache (4 meg)", PAGE_NOCACHE, FALSE, 4*MEGABYTE );
#ifndef _UNDER_NT
    MemoryBandwidthTest( LogHandle, "Cache (1 meg) (block interrupt)", 0, TRUE, MEGABYTE );
    MemoryBandwidthTest( LogHandle, "No Cache (1 meg) (block interrupt)", PAGE_NOCACHE, TRUE, MEGABYTE );
#endif
}


VOID
WINAPI
MemPerfEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    KdPrint(( "MEMPERF: EndTest\n" ));
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( memperf )
#pragma data_seg()

BEGIN_EXPORT_TABLE( memperf )
    EXPORT_TABLE_ENTRY( "StartTest", MemPerfStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MemPerfEndTest )
END_EXPORT_TABLE( memperf )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\mm\vmstress\vmstress.cpp ===
//
// `VmStress' - stress test for virtual space manager 
// Copyright (c) 1991  Microsoft Corporation
// 
// Module Name:
// 
//     vmstress.c
// 
// Abstract:
// 
//     Test stress program for virtual memory.
// 
// Author:
// 
//     Lou Perazzoli (LouP) 26-Jul-91
// 
// Revision History:
// 
//     S. Somasegar (Somase) Jul 18, 1991 
// 
//         - Ported to a Win32 application
// 
//     G. Bailey (GBailey) Oct 7, 1995 
//  
//         - added logging for HCT purposes
// 
//     P. Lunia (PankajL) Dec 7, 1995 
// 
//         - fixed access violation related to not
//           existing when cannot
//         
//         -  allocated memory for startva0 in main.
// 
//     S.Calinoiu (SilviuC) Apr 4, 1997
// 
//         - added code to dump information to aid debug stress failures
// 
//         - added some useful comments and error checking code
//
//         - fixed bug 80814 that caused AV under special stress conditions
//
//
//     J. Sirimarco ( Digital Equipment Corporation ), 18-May-1998
//
//         - Ported to Win64 

//


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#pragma warning(disable:4201)
#include <xtl.h>
#include <string.h>
#include <malloc.h>
#include <time.h>
#include <xtestlib.h>

//
// MY_RAND
//

#define MY_RAND()       ((random()<<16) + (random()<<1) + (random()&1))


//
// Start of definition additions made by Gbailey
// to improve test logging for better HCT support
//

#define MAX_ALLOCS      5
#define START           1
#define FAIL            0

int fCreateLog = FALSE;

HANDLE VmStressLogHandle;

void myPrintf (LPSTR lpStr, ...);
void GetPageFileInfo( char *szRet, int GetPageFile );
void LogDateTime( char *szTmp );
void PrintStatus( BOOL Type );
void PrintMemoryStat( char *szTmp );
void ValidateMemoryRegion (PVOID Address, SIZE_T Size);

struct _PAGE_FILE 
{
    CHAR  szPageFilePath[35];
    CHAR  szDriveLetter[5];
    DWORD iTotalSpace;
    DWORD iFreeSpace;
    struct _PAGE_FILE * Next;
} *stPageFileInfo;

//
// end of Gbailey definition additions
//

//
// INIT_ARG struct
//
// Va: start of virtual space region to be tested
// Size: size of the virtual space region to be tested
//

//
// J. Sirimarco ( DEC ), 14-May-1998
//
// Changed the _INIT_ARG structure for 64-bit NT porting.  The Size 
// variable was changed from type DWORD to type SIZE_T.  
//
// Original: 
//
//   typedef struct _INIT_ARG {
//        PDWORD Va;
//        SIZE_T Size;
//   } INIT_ARG, *PINITARG;
//

typedef struct _INIT_ARG {
    PDWORD Va;
    SIZE_T Size;
} INIT_ARG, *PINITARG;


//
// GlobalDebugInformation
//
// Global variable used to keep the information that should be dumped
// when the test fails.
//

//
// J. Sirimarco ( DEC ), 14-May-1998
//
// Changed the DebugInformation structure for 64-bit NT porting.  
// The data type of RegionSize was changed from DWORD to SIZE_T. 
// The data type of CurrentSize was changed from DWORD to SIZE_T.   
//
// Original: 
//
//   struct DebugInformation
//   {
//       PVOID   RegionStart [2];
//
//       DWORD   RegionSize [2]; 
//
//       PVOID   NextAddressAccessed [2];
//       BOOL    NextAccessIsWrite [2];
//       int     CurrentIValue [2];
//       int     CurrentJValue [2];
//
//       DWORD   CurrentIteration;
//       PVOID   CurrentStart;
//
//       DWORD   CurrentSize; 
//
//       DWORD   WaitResult;
//
//       HANDLE TestThread [2];
//       BOOL ThreadActive [2];
//
//   } GlobalDebugInformation;
//

//

struct DebugInformation
{
    PVOID   RegionStart [2];

    SIZE_T  RegionSize [2]; 

    PVOID   NextAddressAccessed [2];
    BOOL    NextAccessIsWrite [2];
    int     CurrentIValue [2];
    int     CurrentJValue [2];

    DWORD   CurrentIteration;
    PVOID   CurrentStart;

    SIZE_T  CurrentSize; 

    DWORD   WaitResult;

    HANDLE TestThread [2];
    BOOL ThreadActive [2];

} GlobalDebugInformation;


//
// GenerateRandomExceptions
//
// Used for debugging purposes. If it is set to true the program will
// generate randomly access violations. It is set to true if the
// program is launched with `-generate-random-exceptions'.
//

BOOL GenerateRandomExceptions = TRUE;


//
// FailSecondThreadCreation
//
// Used for debugging purposes. If it is set to true the creation of the second
// thread will fail. This is used to reveal a bug that was present in the 
// test (bug #80814). Set to true if `-fail-second-thread-creation' is specified
// in the command line.
//

BOOL FailSecondThreadCreation = FALSE;


//
// VerboseOutput
//
// If false the program will be completely quiet. It will not print anything
// into kernel debugger, except if a fatal failure occurs. Set to true by
// `-verbose' command line option.
//

BOOL VerboseOutput = FALSE;


//
// ProgramVersion
//

char ProgramVersion[] = "VmStress 0.01 - Apr 30, 1997";

//
// DebugPrint
//

void DebugPrint (char *format, ...)
{
    va_list params;
    //char szTemp [2048];

    va_start (params, format);
    //vsprintf (szTemp, format, params);
    //OutputDebugStringA(szTemp);
    // printf ("VmDebug: %s", szTemp);
    va_end (params);
}


ULONG Seed = GetTickCount();

int
random(
    void
    )
{
    return RtlRandom( &Seed );
}


//
// DumpDebugInformation
//

void DumpDebugInformation ()
{
    DebugPrint ("-------------------------------------------------------\n");

    DebugPrint ("vmstress: current iteration: %u\n", 
        GlobalDebugInformation.CurrentIteration);
    DebugPrint ("vmstress: address: %0p, size: %0p\n",
        GlobalDebugInformation.CurrentStart,
        GlobalDebugInformation.CurrentSize);
    DebugPrint ("vmstress: threads: %0p, %0p\n",
        GlobalDebugInformation.TestThread[0],
        GlobalDebugInformation.TestThread[1]);
    DebugPrint ("vmstress: wait result: %08X\n", 
        GlobalDebugInformation.WaitResult);
    DebugPrint ("\n");


    DebugPrint ("Thread 0: address: %0p, size: %0p\n",
        GlobalDebugInformation.RegionStart[0],
        GlobalDebugInformation.RegionSize[0]);
    DebugPrint ("Thread 0: active: %s\n",
        GlobalDebugInformation.ThreadActive[0] ? "true" : "false");
    DebugPrint ("          next access: %0p, operation: %s\n",
        GlobalDebugInformation.NextAddressAccessed[0],
        GlobalDebugInformation.NextAccessIsWrite[0] ? "write" : "read");
    DebugPrint ("          iteration: i: %d, j: %d\n",
        GlobalDebugInformation.CurrentIValue[0],
        GlobalDebugInformation.CurrentJValue[0]);
    DebugPrint ("\n");


    DebugPrint ("Thread 1: address: %0p, size: %0p\n",
        GlobalDebugInformation.RegionStart[1],
        GlobalDebugInformation.RegionSize[1]);
    DebugPrint ("Thread 1: active: %s\n",
        GlobalDebugInformation.ThreadActive[1] ? "true" : "false");
    DebugPrint ("          next access: %0p, operation: %s\n",
        GlobalDebugInformation.NextAddressAccessed[1],
        GlobalDebugInformation.NextAccessIsWrite[1] ? "write" : "read");
    DebugPrint ("          iteration: i: %d, j: %d\n",
        GlobalDebugInformation.CurrentIValue[1],
        GlobalDebugInformation.CurrentJValue[1]);
    DebugPrint ("\n");

    DebugPrint ("----------------------------------------- VmStress ---\n");

    ValidateMemoryRegion (
        GlobalDebugInformation.RegionStart[0],
        GlobalDebugInformation.RegionSize[0]);

    DebugPrint ("----------------------------------------- VmStress ---\n");
}


//
// BreakIntoDebugger ()
//

void BreakIntoDebugger ()
{
    DumpDebugInformation ();
    DebugBreak ();
}


//
// ExceptionFilter
//
// For any exception we will print all debug information and then we will
// break into debugger.
//

DWORD ExceptionFilter ()
{
    DebugPrint ("vmstress: exception caught ...\n");
    DumpDebugInformation ();
    //DebugBreak ();

    return EXCEPTION_EXECUTE_HANDLER;
}


//
// VmRandom1 (parameter)
//
// The function of the first thread that tests the virtual memory manager.
// `parameter' is actually a pointer to an `INIT_ARG' structure specifying
// the virtual space region to be tested.
//

VOID
VmRandom1 (
    LPVOID ThreadParameter
    )
{

    PINITARG InitialArg;
    DWORD Seed = 8373833;

    SIZE_T  size; 

    PDWORD startva0;
    PDWORD Va;
    DWORD i,j;

    //
    // Break into debugger if we get a null thread parameter. This should be
    // a pointer to a structure and it shouldn't be null.
    //

    if (ThreadParameter == NULL)
      {
        DebugPrint ("Thread 0: thread parameter: %0p (null!)\n", ThreadParameter);
        BreakIntoDebugger ();
      }

    //
    // Write debug information.
    //

    GlobalDebugInformation.RegionStart [0] = ((PINITARG)ThreadParameter)->Va;
    GlobalDebugInformation.RegionSize [0] = ((PINITARG)ThreadParameter)->Size;
    GlobalDebugInformation.ThreadActive [0] = TRUE;

    //
    // Capture virtual space region characteristics
    //

    InitialArg = (PINITARG)ThreadParameter;

    startva0 = InitialArg->Va;
    size = InitialArg->Size;

    //
    // Perform `10 * 2500' memory operations (r/w).
    //

    for (j = 1; j < 10; j++) 
      {
        for (i = 1 ; i < 2500; i++) 
          {
             Seed = MY_RAND();
             Va = startva0 + (Seed % (size / sizeof(DWORD)));

             // if (i % 1000 == 0)
             //     printf ("Sample address: %08X\n", Va);

             GlobalDebugInformation.NextAddressAccessed[0] = Va;
             GlobalDebugInformation.NextAccessIsWrite[0] = FALSE;
             GlobalDebugInformation.CurrentIValue[0] = i;
             GlobalDebugInformation.CurrentJValue[0] = j;
             
             __try 
               {
                 if (*Va == ((PtrToUlong(Va) + 1))) 
                   {
                     GlobalDebugInformation.NextAccessIsWrite[0] = FALSE;
                     
                     //
                     // Force an access violation randomly. This is
                     // used for debugging of the test.
                     //

  
                     if (GenerateRandomExceptions && ((random () & 0xFFF) == 0xABC))
                         *((BYTE *)0) = (BYTE)0xAB;
                 

                     *Va = PtrToUlong(Va);
                   } 
                 else 
                   {
                     if (*Va != PtrToUlong(Va)) 
                       {
                         DebugPrint ("Thread 0: wrong value at address %0p\n", Va);
                         DebugPrint ("Thread 0: expected: %0p, found: %08X\n", 
                                     Va, *Va);
                         BreakIntoDebugger ();

                         if( fCreateLog )
                             myPrintf("Bad random value in cell %0p was %lx\n", 
                                      Va, *Va);
                       }
                   }
               }
             __except (ExceptionFilter ())
               {
               }
          }

        //
        // Sleep 150 msecs after every 2500 iterations
        //

        Sleep (150);
      }

    GlobalDebugInformation.ThreadActive [0] = FALSE;
}


//
// VmRandom2 (parameter)
//
// The function of the second thread that tests the virtual memory manager.
// `parameter' is actually a pointer to an 'INIT_ARG' structure specifying
// the virtual space region to be tested.
//

VOID
VmRandom2 (
    LPVOID ThreadParameter
    )
{

    PINITARG InitialArg;
    DWORD Seed = 8373839;

    SIZE_T size;

    PDWORD startva0;
    PDWORD Va;
    DWORD i,j;


    //
    // Break into debugger if we get a null thread parameter. This should be
    // a pointer to a structure and it shouldn't be null.
    //

    if (ThreadParameter == NULL)
      {
        DebugPrint ("Thread 1: thread parameter: %0p (null!)\n", ThreadParameter);
        BreakIntoDebugger ();
      }

    //
    // Write debug information.
    //

    GlobalDebugInformation.RegionStart [1] = ((PINITARG)ThreadParameter)->Va;
    GlobalDebugInformation.RegionSize [1] = ((PINITARG)ThreadParameter)->Size;
    GlobalDebugInformation.ThreadActive [1] = TRUE;

    //
    // Capture virtual space region characteristics
    //

    InitialArg = (PINITARG)ThreadParameter;

    startva0 = InitialArg->Va;
    size = InitialArg->Size;


    //
    // Perform `10 * 2500' memory operations (r/w).
    //

    for (j = 1; j < 10; j++) 
      {
        for (i = 1 ; i < 2500; i++) 
          {
             Seed = MY_RAND();
             Va = startva0 + (Seed % (size / sizeof(DWORD)));

             GlobalDebugInformation.NextAddressAccessed[1] = Va;
             GlobalDebugInformation.NextAccessIsWrite[1] = FALSE;
             GlobalDebugInformation.CurrentIValue[1] = i;
             GlobalDebugInformation.CurrentJValue[1] = j;

             __try
               {
//

                 if (*Va == ((PtrToUlong(Va) + 1))) 
                   {
                     GlobalDebugInformation.NextAccessIsWrite[1] = FALSE;
                     
                     //
                     // Force an access violation randomly. This is
                     // used for debugging of the test.
                     //
                     
                     if (GenerateRandomExceptions && ((random () & 0xFFF) == 0xABC))
                         *((BYTE *)0) = (BYTE)0xAB;
                 
                     *Va = PtrToUlong(Va);
                   } 
                 else 
                   {
                     if (*Va != PtrToUlong(Va) ) 
                       {
                         DebugPrint ("Thread 1: wrong value at address %0p\n", Va);
                         DebugPrint ("Thread 1: expected: %0p, found: %08X\n", 
                                     Va, *Va);
                         BreakIntoDebugger ();

                         if( fCreateLog )
                             myPrintf("Bad random value in cell %0p was %lx\n", 
                                      Va, *Va);
                       }
                   }
               }
             __except (ExceptionFilter ())
               {
               }
          }

        //
        // Sleep 150 msecs after every 2500 iterations
        //
        
        Sleep (150);
      }
        
    GlobalDebugInformation.ThreadActive [1] = FALSE;
}


//
// main
//

int  __cdecl main_function (
    int argc,
    char *argv[],
    char *envp[]
    )
{
    HANDLE Objects[2];
    MEMORYSTATUS MemStatus = {0};
    INIT_ARG InitialArg;
    PDWORD Va;
    PDWORD EndVa;

    SIZE_T size;

    LPVOID startva0;
    BOOL   bstatus;
    DWORD ThreadId1, ThreadId2;
    DWORD count = 0;
    DWORD VallocCnt = 1;
    DWORD dError;
//    DWORD CurrentIteration = 0;           // Not referenced.  
    DWORD WaitResult;

    if (argc == 2 && strcmp (argv[1], "-version") == 0)
      {
        myPrintf ("VmStress - stress program for virtual memory manager   \n");
        myPrintf ("Copyright (c) Microsoft Corporation, 1997              \n");
        myPrintf ("                                                       \n");
        myPrintf ("Author:  Lou Perazzoli                                 \n");
        myPrintf ("Owner:   Silviu Calinoiu                               \n");
        myPrintf ("Version: 0.0.1                                         \n");
        myPrintf ("Updated: Jun 05, 1997                                  \n");

        return 1;
      }

    if (argc > 1) 
      {
        if ( *(argv[1]+1) == 'h' || *(argv[1]+1) == 'H')
            fCreateLog = TRUE;
      }

    if (argc == 2 && strcmp (argv[1], "-generate-random-exceptions") == 0)
      {
        GenerateRandomExceptions = TRUE;
        VerboseOutput = TRUE;
      }

    if (argc == 2 && strcmp (argv[1], "-fail-second-thread-creation") == 0)
      {
        FailSecondThreadCreation = TRUE;
        VerboseOutput = TRUE;
      }

    if (argc == 2 && strcmp (argv[1], "-verbose") == 0)
      {
        VerboseOutput = TRUE;
      }

    myPrintf("Starting Virtual Memory Stress Test\n");

    if( fCreateLog )
        PrintStatus( START );

    GlobalDebugInformation.CurrentIteration = 0;
    GlobalDebugInformation.CurrentStart = 0;
    GlobalDebugInformation.CurrentSize = 0;
    GlobalDebugInformation.TestThread[0] = 0;
    GlobalDebugInformation.TestThread[1] = 0;
    GlobalDebugInformation.WaitResult = 0;

    GlobalDebugInformation.RegionStart[0] = 0;
    GlobalDebugInformation.RegionSize[0] = 0;
    GlobalDebugInformation.NextAddressAccessed[0] = 0;
    GlobalDebugInformation.NextAccessIsWrite[0] = ( BOOL ) 0;

    GlobalDebugInformation.CurrentIValue[0] = 0;
    GlobalDebugInformation.CurrentJValue[0] = 0;

    GlobalDebugInformation.RegionStart[1] = 0;
    GlobalDebugInformation.RegionSize[1] = 0;
    GlobalDebugInformation.NextAddressAccessed[1] = 0;
    GlobalDebugInformation.NextAccessIsWrite[1] = 0;
    GlobalDebugInformation.CurrentIValue[1] = 0;
    GlobalDebugInformation.CurrentJValue[1] = 0;

    GlobalDebugInformation.ThreadActive [0] = FALSE;
    GlobalDebugInformation.ThreadActive [1] = FALSE;

    for (;;) 
      {
        GlobalDebugInformation.CurrentIteration++;

        //GlobalMemoryStatus(&MemStatus);
        
        size = MemStatus.dwAvailPhys + (4096*10);
        startva0 = NULL;

        //
        // Create a region of private memory based on the number of
        // available pages on this system.
        //

        //GlobalMemoryStatus(&MemStatus);

        size = MemStatus.dwAvailPhys;
        if (size == 0) 
          {
            size = 4096;
        }
        
        if (size > 64000) 
          {

            if ( size > 0x180000 ) // 1024 * 1024 * 1.5
                size = ( SIZE_T ) 0x180000;
            else
                size -= 4*4096;
          }

        startva0 = VirtualAlloc(
            NULL,
            size,
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE);

        GlobalDebugInformation.CurrentStart = startva0;
        GlobalDebugInformation.CurrentSize =  size;

        if (startva0 == NULL) 
          {
            dError = GetLastError();

            DebugPrint ("vmstress: allocating %0p failed (error: %u), "
                        "even if %0p available\n",
                         size, dError, MemStatus.dwAvailPhys);

            myPrintf ("#%d)Error(%d) in virtual allocation of size %ldMB when "
                      "available phys. memory is %ldMB \n",
                      VallocCnt, dError, size / (1024 * 1024),
                      MemStatus.dwAvailPhys / (1024 * 1024));

            if(fCreateLog) 
              { // If being run with HCT System Stress
                myPrintf ("(%d)Error(%d) in virtual allocation of size %ldMB "
                          "when available phys. memory is %ldMB \n",
                          VallocCnt,
                          dError,
                          size/ (1024*1024),
                          MemStatus.dwAvailPhys/ (1024*1024));

                // commented out code for VallocCnt checking to avoid NULL cast 
                // and de-reference
                // of startva0 later. (PankajL)

                if( VallocCnt == MAX_ALLOCS ) 
                  {
                    DebugPrint ("vmstress: exiting ...\n");
                    PrintStatus(FAIL);
                    return dError;
                  }
                else 
                  {
                    VallocCnt++;
                    continue;
                  }
              }
            else
              {
                DebugPrint ("vmstress: exiting ...\n");
                return dError;
              }
          }

        if (VerboseOutput)
          {
            DebugPrint ("vmstress: region: %0p, size: %0p\n", startva0, size);
          }

        myPrintf("Created region address: %0p, size: %0p\n", startva0, size);

        if( fCreateLog && VallocCnt > 1 ) 
          {
            VallocCnt = 1;
          }

        InitialArg.Va = (PULONG)startva0;
        InitialArg.Size = size;

        //
        // Set all memory to known values (not zeroes).
        //

        myPrintf("Initializing Memory\n");

        EndVa = (PDWORD)startva0 + (size/sizeof(DWORD));

        Va = (PULONG)startva0;

        while (Va < EndVa) {
            *Va = PtrToUlong(Va) + 1;
            Va += 1;
        }

        //
        // Validate the memory region just to make sure we are starting
        // with correct data.
        //

        ValidateMemoryRegion (InitialArg.Va, InitialArg.Size);

        //
        // Create the two worker threads
        //

        Objects[0] = CreateThread(
            NULL,
            0L,
            (LPTHREAD_START_ROUTINE)VmRandom1,
            (LPVOID)&InitialArg,
            0,
            &ThreadId1);

        //assert (Objects[0]);

        if (FailSecondThreadCreation)
          {
            Objects[1] = NULL;
          }
        else
          {
            Objects[1] = CreateThread(
                NULL,
                0L,
                (LPTHREAD_START_ROUTINE)VmRandom2,
                (LPVOID)&InitialArg,
                0,
                &ThreadId2);

            //assert (Objects[1]);
          }

        //
        // We will not print any message about thread creation failure because
        // under stress this might happen often and we will spend all our time
        // printing messages into debugger.
        //

        GlobalDebugInformation.TestThread[0] = Objects[0];
        GlobalDebugInformation.TestThread[1] = Objects[1];

        if (Objects[0] && Objects[1])
          {
            if (VerboseOutput)
                DebugPrint ("vmstress: two threads created\n");
        
            WaitResult = WaitForMultipleObjects (
                2,
                Objects,
                TRUE,
                INFINITE );
          }
        else if(Objects [0])
          {
            if (VerboseOutput)
                DebugPrint ("vmstress: thread 0 created\n");
            WaitResult = WaitForSingleObject (Objects[0], INFINITE);
          }
        else if(Objects [1])
          {
            if (VerboseOutput)
                DebugPrint ("vmstress: thread 1 created\n");
            WaitResult = WaitForSingleObject (Objects[1], INFINITE);
          }
        else
          {
            WaitResult = 0;
          }

        //
        // We will not break into debugger if the wait operation fails
        // because this is might indeed happen under stress conditions.
        //

        GlobalDebugInformation.WaitResult = WaitResult;
        
        if (WaitResult == WAIT_FAILED)
            if (VerboseOutput)
                DebugPrint ("vmstress: wait operation failed\n");

        //
        // Validate the memory region after both threads have finished.
        //

        ValidateMemoryRegion (InitialArg.Va, InitialArg.Size);

        count += 1;
        myPrintf("Stress test pass number %ld complete\n",count);

        CloseHandle (Objects[0]);
        CloseHandle (Objects[1]);

        if (GlobalDebugInformation.ThreadActive[0] 
            || GlobalDebugInformation.ThreadActive[1])
          {
            DebugPrint ("vmstress: test bug - freeing memory still used\n");
            BreakIntoDebugger ();
          }

        bstatus = VirtualFree (
            startva0,
            0,               // free the whole chunk
            MEM_RELEASE);

        if (! bstatus) 
          {
            DebugPrint ("vmstress: error %u when freeing memory at address %0p\n",
                GetLastError(), startva0);

            myPrintf ("Error in freeing virtual memory \n");
            dError = GetLastError();
            if(fCreateLog) 
              { // If being run with HCT System Stress
                myPrintf("Error(%d) in freeing virtual memory of size "
                         "%0p\nVMStress test result = FAIL\n", 
                         dError, size);
              }

            DebugPrint ("vmstress: exiting ...\n");
            return dError;
          }

        //
        // Mark memory region as freed.
        //

        GlobalDebugInformation.CurrentStart = ( PVOID ) ( ( INT_PTR ) 0xFFFFFFFF );
        
        //
        // Sleep 5 secs after each stress cycle.
        //

        Sleep (5000);

        if ( !XTestLibIsStressTesting() && count > 10 ) {
            break;
        }
      }
    
    argc;
    argv;
    envp;               // to shut the compiler up

    return 0;
}


void PrintStatus( BOOL Type )
{

    CHAR szBuf[1024];
    CHAR szTmp[512];

    memset(szTmp, '\0',sizeof(szTmp) );
    memset(szBuf, '\0',sizeof(szBuf) );


    if( Type == START )
        sprintf(szBuf,"\n***** Virtual Memory Test Start *****\n");

    if(Type == FAIL)
        sprintf(szBuf,
                "\n*****************\nVMStress test result = FAIL\nMemory Values at Failure Below\n*****************\n");

    LogDateTime( ( char * ) &szTmp );
    strcat(szBuf,szTmp);
    memset(szTmp, '\0',sizeof(szTmp) );

    PrintMemoryStat( ( char * )&szTmp );
    strcat(szBuf,szTmp);
    memset(szTmp, '\0',sizeof(szTmp) );

    // write report to log file
    myPrintf(szBuf);

}

//
// PrintMemoryStat will call GlobalMemoryStatus and format string with
// all relevant memory information.  Only called when -h parm is used.
//
void
PrintMemoryStat(
    char *szTmp
    )
{

   MEMORYSTATUS MemStatus = {0};
   char szMemoryStatusStr[512];
   char szbuf[128];


   sprintf(szMemoryStatusStr,"\n\t*************Memory Information in MB**************\n");
   strcat (szMemoryStatusStr,"\tPhysical\tVirtual\t\tPageFile\n");
   strcat (szMemoryStatusStr,"\tTotal\tAvail.\tTotal\tAvail.\tTotal\tAvail.\n");
   strcat (szMemoryStatusStr,"\t=======\t=======\t=======\t=======\t=======\t=======\n");

   GlobalMemoryStatus(&MemStatus);
   sprintf(szbuf,"\t%ld\t%ld\t%ld\t%ld\t%ld\t%ld\n",
                 MemStatus.dwTotalPhys/ (1024*1024),
                 MemStatus.dwAvailPhys/ (1024*1024),
                 MemStatus.dwTotalVirtual/ (1024*1024),
                 MemStatus.dwAvailVirtual/ (1024*1024),
                 MemStatus.dwTotalPageFile/ (1024*1024),
                 MemStatus.dwAvailPageFile/ (1024*1024) );
   strcat(szMemoryStatusStr,szbuf);

   strcpy(szTmp,szMemoryStatusStr);

}

void
LogDateTime
   (
   char *szTmp
   )
{
    SYSTEMTIME   SystemTime;

    GetSystemTime (&SystemTime);
    sprintf(
        szTmp,
        "Date and Time: %lu-%lu-%lu at %lu:%02lu \n",
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wYear,
        SystemTime.wHour,
        SystemTime.wMinute
        );
}

void myPrintf (LPSTR lpStr,
               ...)
{
    va_list marker;
    //char    szBuffer[512];
    //FILE *  fpLogFile;


    va_start (marker, lpStr);
    //vsprintf (szBuffer, lpStr, marker);
    va_end(marker);
    //OutputDebugStringA( szBuffer );

    //fpLogFile = fopen("c:\\vmstress.log","a");
    //fprintf(fpLogFile, szBuffer);
    //fclose(fpLogFile);
}

//
// Function:
//
//     ValidateMemoryRegion
//
// Description:
//
//     This function traverses a memory region and
//     makes sure that all values stored are address or
//     address + 1. It dumps all regions that are not right.
//

void
ValidateMemoryRegion (

    PVOID Address,
    SIZE_T Size)
{
    BOOL FoundProblem = FALSE;
    PDWORD Current = (PDWORD) Address;
    PDWORD End = Current + Size/sizeof(DWORD);

    for ( ; Current < End; Current += 0x1000)

        if ((*Current != PtrToUlong( Current ) ) && 
            (*Current != (PtrToUlong(Current) + 1)))
          {
            DebugPrint ("Invalid contents: %0p\n", Current);
            FoundProblem = TRUE;
          }

    if (FoundProblem == FALSE)
        myPrintf ("Memory region check: ok\n");
}


VOID
WINAPI
VmStressStartTest(
    HANDLE hLog
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    VmStressLogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    MEMORYSTATUS stat;
    GlobalMemoryStatus( &stat );

    if(stat.dwTotalPhys >= 100*1024*1024)
        {
        KdPrint(( "VMSTRESS: StartTest\n" ));
        VmStressLogHandle = hLog;
        main_function( 0, NULL, NULL );
        }
    else
        {
        KdPrint(( "VMSTRESS: Exiting - not enough memory\n" ));
        }
}


VOID
WINAPI
VmStressEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    KdPrint(( "VMSTRESS: EndTest\n" ));
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( vmstress )
#pragma data_seg()

BEGIN_EXPORT_TABLE( vmstress )
    EXPORT_TABLE_ENTRY( "StartTest", VmStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", VmStressEndTest )
END_EXPORT_TABLE( vmstress )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ob\dirlog\precomp.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This program contains pre-compile headers.

Author:

    Sakphong Chanbai (schanbai) 03-May-2000

Environment:

    Xbox

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\mm\XMmAPI\dll.h ===
/*++

  Copyright (c) 2000 Microsoft Corporation

  Module Name:

	dll.h

  Abstract:

	TBD

  Author:

	Toby Dziubala (a-tobydz) 25-April-2000

  Revision History:

--*/
#ifndef __DLL_H__
#define __DLL_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MEMDLL_API
#define MEMDLL_API
#endif

#define TRUE 1
#define FALSE 0


/// Function Prototypes ///
MEMDLL_API void XMmApiStartTest( HANDLE LogHandle );
MEMDLL_API void XMmApiEndTest( void );


#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\mm\XMmAPI\dllmain.cpp ===
/*++

  Copyright (c) 2000 Microsoft Corporation

  Module Name:

	dllmain.cpp

  Abstract:

	TBD

  Author:

	Toby Dziubala (a-tobydz) 22-May-2000

  Enviornment:

	Windows 2000

  Revision History:
	
	  - First Version:	20-April-2000
	  - XBox Version:	22-May-2000

--*/

#include <xtl.h>
#include "dll.h"
#include "prototypes.h"
#include "xtestlib.h"


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xmmapi )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xmmapi )
    EXPORT_TABLE_ENTRY( "StartTest", XMmApiStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XMmApiEndTest )
END_EXPORT_TABLE( xmmapi )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\mm\XMmAPI\mmTest.cpp ===
/*++

  Copyright (c) 2000 Microsoft Corporation

  Module Name:

	mmTest.cpp

  Abstract:

	XBox memory management API tests.

  Author:

	Toby Dziubala (a-tobydz) 01-May-2000

  Enviornment:

	Windows 2000

  Revision History:

--*/
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include "dll.h"
#include "prototypes.h"
#include "xlog.h"




/*********************************************************************************************/
//Function:	StartTest()			Author: Toby Dziubala				Date: 4 / 25 / 00
//
//Purpose: Calls other test dll functions.
//		   
//
//Parameters:		
//				
/********************************************************************************************/


// XBox logging handle
HANDLE XMmApiLogHandle = INVALID_HANDLE_VALUE;


/*++

Routine Description:
              
    Calls subsequent test cases.
    
Arguments:

	- NONE -
    
Return:
    
    None

--*/
void XMmApiStartTest( HANDLE XMmApiLogHandle )
{	
	
	// Setup XBox logging
	ASSERT( XMmApiLogHandle != INVALID_HANDLE_VALUE );
		
	KdPrint(( "XMmAPI:StartTest\n" ));
	
	// Run the Test cases //
	TestCase1( XMmApiLogHandle );	
	TestCase2( XMmApiLogHandle );
	TestCase3( XMmApiLogHandle );
	TestCase4( XMmApiLogHandle );
	TestCase5( XMmApiLogHandle );
	TestCase6( XMmApiLogHandle );
	TestCase7( XMmApiLogHandle );
	TestCase8( XMmApiLogHandle );
	TestCase9( XMmApiLogHandle );
	TestCase10( XMmApiLogHandle );
	TestCase11( XMmApiLogHandle );
	TestCase12( XMmApiLogHandle );
	TestCase13( XMmApiLogHandle );
	TestCase14( XMmApiLogHandle );
	TestCase15( XMmApiLogHandle );
	TestCase16( XMmApiLogHandle );
	TestCase17( XMmApiLogHandle );

}



/*++

Routine Description:
              
    Dll exit point.
    
Arguments:

	- NONE -
    
Return:
    
    None

--*/
void XMmApiEndTest( void )
{
	KdPrint(( "XMmAPI:EndTest\n" ));
}




/*++

	=== TEST CASE 1 ===

Routine Description:
              
    Test to verify you can reserve virtual memory then free it.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

--*/
void TestCase1( HANDLE XMmApiLogHandle )
{
	LPVOID	lpStartAddress	=	NULL;		// Returned starting memory location
	BOOL	fFail;							// Failure flag
	char	cBuffer[128];					// Logging text buffer

	
	// Log location with the Kernel Debugger
	KdPrint(( "XMmAPI: ==TestCase 1==\n" ));

	// Reset the fFail flag
	fFail = FALSE;
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( 0L, 32768, MEM_RESERVE, PAGE_READWRITE )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 1== Test to verify you can reserve virtual memory then free it." );

	// Reserve 32 megs of virtual memory
	lpStartAddress = VirtualAlloc( 0L, 32768, MEM_RESERVE, PAGE_READWRITE );
	
	// Make sure we got a valid address
	if ( 0L == lpStartAddress )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "VirtualAlloc Failed to Allocate 32 megs of memory."
			  );
		KdPrint(( "VirtualAlloc( ) Failed!\n" ));

		fFail = TRUE;
	}
		
	// Free the committed memory
	if ( FALSE == fFail )
	{
		fFail = VirtualFree( lpStartAddress, 0, MEM_RELEASE );

		if ( FALSE == fFail )	// VirtualFree() returns FALSE if an error occurs (inverse)
		{
			xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "VirtualFree() Failed!"
				  );
			
			KdPrint(( "VirtualFree() Failed!\n" ));

			fFail = TRUE;		// Reset the fail flag to indicate an error
		}
		else
		{
			lpStartAddress = 0L;
			fFail = FALSE;		// Reset the fail flag
		}	
	}
	
	// LogEndCase
	if ( FALSE == fFail || ( FALSE == fFail && 0L == lpStartAddress) )
	{
		// TestCase passed
		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "TestCase 1: PASS"
			  );
		
		KdPrint(( ">>>TestCase 1 PASSED<<<\n" ));
	}
	else
	{	
		// TestCase failed
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "TestCase 1: FAILED!"
			  );
		
		KdPrint(( ">>>TestCase 1 FAILED<<<\n" ));
	}
}



/*++

	=== TEST CASE 2 ===

Routine Description:
              
    Test to verify you can reserve, commit, and free virtual memory.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

--*/
void TestCase2( HANDLE XMmApiLogHandle )
{
	LPVOID	lpStartAddress	=	NULL;		// Returned starting memory location
	BOOL	fFail;							// Failure flag

	
	// Log location with the Kernel Debugger
	KdPrint(( "XMmAPI: ==TestCase 2==\n" ));

	// Reset the fFail flag
	fFail = FALSE;
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( 0L, 32768, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 2== Test to verify you can reserve, commit, and free virtual memory." );

	// Reserve 32 megs of virtual memory
	lpStartAddress = VirtualAlloc( 0L, 32768, MEM_RESERVE, PAGE_READWRITE );
	
	// Make sure we got a valid address
	if ( 0L == lpStartAddress )
	{
		xLog( XMmApiLogHandle, 
			  XLL_FAIL,
			  "Failed to allocate 32768 megz!" 
			);
		
		KdPrint(( "VirtualAlloc() Failed!\n" ));

		fFail = TRUE;
	}
	else
		fFail = FALSE;
	
	// Commit the memory
	if ( FALSE == fFail )
	{
		lpStartAddress = VirtualAlloc( 0L, 32768, MEM_COMMIT, PAGE_READWRITE );

		if ( 0L == lpStartAddress )
		{
			xLog( XMmApiLogHandle, 
				  XLL_FAIL,
				  "Failed to commit memory!" 
				);
			
			KdPrint(( "VirtualAlloc( MEM_COMMIT ) Failed!\n" ));
			
			fFail = TRUE;
		}
	}
	
		
	// Free the committed memory
	if ( FALSE == fFail )
	{
		fFail = VirtualFree( lpStartAddress, 32768, MEM_DECOMMIT );

		if ( FALSE == fFail )	// VirtualFree() returns FALSE if an error occurs (inverse)
		{
			xLog( XMmApiLogHandle, 
			  XLL_FAIL,
			  "VirtualFree() Failed!" 
			);

			KdPrint(( "VirtualFree() Failed!\n" ));

			fFail = TRUE;		// Reset the fail flag to indicate an error
		}
		else
		{
			lpStartAddress = 0L;
			fFail = FALSE;		// Reset the fail flag
		}
	}
	
	// LogEndCase
	if ( FALSE == fFail || ( FALSE == fFail && 0L == lpStartAddress) )
	{
		xLog( XMmApiLogHandle, 
			  XLL_PASS,
			  "TestCase 2: PASSED" 
			);

		KdPrint(( ">>>TestCase 2 PASSED<<<\n" ));
	}
	else
	{
		xLog( XMmApiLogHandle,
			  XLL_INFO,
			  "TestCase 2: FAILED"
			);

		KdPrint(( ">>>TestCase 2 FAILED<<<\n" ));
	}
}




/*++

	=== TEST CASE 3 ===

Routine Description:
              
    Test to verify you can touch allocated virtual memory.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

--*/

void TestCase3( HANDLE XMmApiLogHandle )
{
	LPVOID	lpStartAddress = NULL;		// Returned starting memory location
	BOOL	fFail;						// Failure flag

	// Log location with the Kernel Debugger
	KdPrint(( "XMmAPI: ==TestCase 3==\n" ));

	// Reset the fFail flag
	fFail = FALSE;
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( 0L, 32768, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 3== Test to verify you can touch allocated virtual memory." );

	// Reserve 32 megs of virtual memory
	lpStartAddress = VirtualAlloc( 0L, 32768, MEM_RESERVE, PAGE_READWRITE );
	
	// Make sure we got a valid address
	if ( 0L == lpStartAddress )
	{
		xLog( XMmApiLogHandle,
		  XLL_FAIL,
		  "Failed to allocate 32768 megz!" );

		KdPrint(( "VirtualAlloc( ) Failed!\n" ));
		
		goto END;
	}
	
	
	// Commit the memory
	lpStartAddress = VirtualAlloc( 0L, 32768, MEM_COMMIT, PAGE_READWRITE );

	if ( 0L == lpStartAddress )
	{
		xLog( XMmApiLogHandle,
		  XLL_FAIL,
		  "Failed to commit memory!" );
		fFail = TRUE;
		
		KdPrint(( "VirtualAlloc( MEM_COMMIT ) Failed!\n" ));

	}
		
	
	// Touch the committed memory
	if ( FALSE == fFail )
	{
		ZeroMemory( lpStartAddress, 32768 );
	}
	
	
	
	// Free the committed memory
	if ( FALSE == fFail )
	{
		fFail = VirtualFree( lpStartAddress, 32768, MEM_DECOMMIT );

		if ( FALSE == fFail )	// VirtualFree() returns FALSE if an error occurs (inverse)
		{
			xLog( XMmApiLogHandle,
				  XLL_INFO,
				  "Couldn't free memory!" );
			fFail = TRUE;		// Reset the fail flag to indicate an error

			KdPrint(( "VirtualFree() Failed!\n" ));
		}
		else
		{
			lpStartAddress = 0L;
			fFail = FALSE;		// Reset the fail flag
		}
	}
	
	// LogEndCase
	if ( FALSE == fFail || ( FALSE == fFail && 0L == lpStartAddress) )
	{
		xLog( XMmApiLogHandle,
		  XLL_PASS,
		  "TestCase 3: PASS" );

		KdPrint(( ">>>TestCase 3 PASS<<<\n" ));
	}
	else
	{
		xLog( XMmApiLogHandle,
		  XLL_FAIL,
		  "TestCase 3: FAIL" );

		KdPrint(( ">>>TestCase 3 FAIL<<<\n" ));
	}

END: ;

}




/*++

	=== TEST CASE 4 ===

Routine Description:
              
    Test to verify you can reserve, commit, and free virtual memory using various protection flags.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

--*/
void TestCase4( HANDLE XMmApiLogHandle )
{
	LPVOID	lpMemory[8];		// Returned starting memory location
	BOOL	fFail;				// Failure flag
	INT		i = 0;				// Counter for memory blocks
	
	// Log location with the Kernel Debugger
	KdPrint(( "XMmAPI: ==TestCase 4==\n" ));

	// Reset the fFail flag
	fFail = FALSE;
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( 0L, 32768, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 4== Test to verify you can reserve, commit, and free virtual memory using various protection flags." );

	for ( i = 0; i < 8; i++ )
	{
		switch ( i )
			{

			case 0:
				{
					xStartVariation( XMmApiLogHandle, "PAGE_READWRITE" );

					// Reserve 32 megs of virtual memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_READWRITE );
					
					// Make sure we got a valid address
					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "PAGE_READWRITE Failed!" );
						xEndVariation( XMmApiLogHandle );
						break;
					}
					
					
					// Commit the memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_READWRITE );

					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "Couldn't commit PAGE_READWRITE!" );
						fFail = TRUE;
						xEndVariation( XMmApiLogHandle );
						break;
					}
					else
					{
						xEndVariation( XMmApiLogHandle );
						break;
					}
				} // end case 0
				
			case 1:
				{
					xStartVariation( XMmApiLogHandle, "PAGE_READONLY" );

					// Reserve 32 megs of virtual memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_READONLY );
					
					// Make sure we got a valid address
					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "PAGE_READONLY Failed!" );
						xEndVariation( XMmApiLogHandle );
						break;
					}
					
					// Commit the memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_READONLY );

					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "Couldn't commit PAGE_READWRITE!" );
						fFail = TRUE;
						xEndVariation( XMmApiLogHandle );
						break;
					}
					else
					{
						xEndVariation( XMmApiLogHandle );
						break;
					}
				} // end case 1
			
			case 2:
				{
					xStartVariation( XMmApiLogHandle, "PAGE_EXECUTE" );

					// Reserve 32 megs of virtual memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_EXECUTE );
					
					// Make sure we got a valid address
					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "PAGE_EXECUTE Failed!" );
						xEndVariation( XMmApiLogHandle );
						break;
					}
					
					// Commit the memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_EXECUTE );

					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "Couldn't commit PAGE_EXECUTE!" );
						fFail = TRUE;
						xEndVariation( XMmApiLogHandle );
						break;
					}
					else
					{
						xEndVariation( XMmApiLogHandle );
						break;
					}
				} // end case 2

			case 3:
				{
					xStartVariation( XMmApiLogHandle, "PAGE_EXECUTE_READ" );

					// Reserve 32 megs of virtual memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_EXECUTE_READ );
					
					// Make sure we got a valid address
					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "PAGE_EXECUTE_READ Failed!" );
						xEndVariation( XMmApiLogHandle );
						break;
					}
					
					// Commit the memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_EXECUTE_READ );

					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "Couldn't commit PAGE_EXECUTE_READ!" );
						fFail = TRUE;
						xEndVariation( XMmApiLogHandle );
						break;
					}
					else
					{
						xEndVariation( XMmApiLogHandle );
						break;
					}
				} // end case 3

			case 4:
				{
					xStartVariation( XMmApiLogHandle, "PAGE_EXECUTE_READWRITE" );

					// Reserve 32 megs of virtual memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_EXECUTE_READWRITE );
					
					// Make sure we got a valid address
					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "PAGE_EXECUTE_READWRITE Failed!" );
						xEndVariation( XMmApiLogHandle );
						break;
					}
					
					// Commit the memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE );

					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "Couldn't commit PAGE_EXECUTE_READWRITE!" );
						fFail = TRUE;
						xEndVariation( XMmApiLogHandle );
						break;
					}
					else
					{
						xEndVariation( XMmApiLogHandle );
						break;
					}
				} // end case 4

			case 5:
				{
					xStartVariation( XMmApiLogHandle, "PAGE_GUARD" );

					// Reserve 32 megs of virtual memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_GUARD );
					
					// Make sure we got a valid address
					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "PAGE_GUARD Failed!" );
						xEndVariation( XMmApiLogHandle );
						break;
					}
					
					// Commit the memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_GUARD );

					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "Couldn't commit PAGE_GUARD!" );
						fFail = TRUE;
						xEndVariation( XMmApiLogHandle );
						break;
					}
					else
					{
						xEndVariation( XMmApiLogHandle );
						break;
					}
				} // end case 5

			case 6:
				{
					xStartVariation( XMmApiLogHandle, "PAGE_NOACCESS" );

					// Reserve 32 megs of virtual memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_NOACCESS );
					
					// Make sure we got a valid address
					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "PAGE_NOACCESS Failed!" );
						xEndVariation( XMmApiLogHandle );
						break;
					}
					
					// Commit the memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_NOACCESS );

					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "Couldn't commit PAGE_NOACCESS!" );
						fFail = TRUE;
						xEndVariation( XMmApiLogHandle );
						break;
					}
					else
					{
						xEndVariation( XMmApiLogHandle );
						break;
					}
				} // end case 6

			case 7:
				{	
					xStartVariation( XMmApiLogHandle, "PAGE_NOCACHE" );

					// Reserve 32 megs of virtual memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_NOCACHE );
					
					// Make sure we got a valid address
					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "PAGE_NOCACHE Failed!" );
						xEndVariation( XMmApiLogHandle );
						break;
					}
					
					// Commit the memory
					lpMemory[i] = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_NOCACHE );

					if ( 0L == lpMemory[i] )
					{
						xLog( XMmApiLogHandle,
							  XLL_INFO,
							  "Couldn't commit PAGE_NOCACHE!" );
						fFail = TRUE;
						xEndVariation( XMmApiLogHandle );
						break;
					}
					else
					{
						xEndVariation( XMmApiLogHandle );
						break;
					}
				} // end case 7
			} // end switch
		} // end for

		
	
	// Free the committed memory
	if ( FALSE == fFail )
	{
	 	xStartVariation( XMmApiLogHandle, "Freeing memory" );

		
		// Free memory in array
		for ( i = 0; i < 8; i++ )
			fFail = VirtualFree( lpMemory[i], 0, MEM_DECOMMIT );

		if ( FALSE == fFail )	// VirtualFree() returns FALSE if an error occurs (inverse)
		{
			xLog( XMmApiLogHandle,
				  XLL_INFO,
				  "Couldn't free memory!" );

			KdPrint(( "VirtualFree() Failed!\n" ));

			fFail = TRUE;		// Reset the fail flag to indicate an error
		}
		else
			fFail = FALSE;		// Reset the fail flag
		
		xEndVariation( XMmApiLogHandle );
	}
	
	// LogEndCase
	if ( FALSE == fFail )
	{
		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "TestCase 4: PASS" );

		KdPrint(( ">>>TestCase 4 PASS<<<\n" ));
	}
	else
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "TestCase 4: FAIL" );

		KdPrint(( ">>>TestCase 4 FAILED<<<\n" ));
	}


}	// end TestCase 4




/*++

	=== TEST CASE 5 ===

Routine Description:
              
    Test to verify you can reserve / commit the minimum page size of memory (4096 bytes).
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

--*/

void TestCase5( HANDLE XMmApiLogHandle )
{
	LPVOID	lpStartAddress = NULL;		// Returned starting memory location
	BOOL	fFail;						// Failure flag

		// Log location with the Kernel Debugger
	KdPrint(( "XMmAPI: ==TestCase 5==\n" ));

	// Reset the fFail flag
	fFail = FALSE;
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( 0L, 4096, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 5== Test to verify you can reserve / commit the minimum page size of memory (4096 bytes)." );

	// Reserve 32 megs of virtual memory
	lpStartAddress = VirtualAlloc( 0L, 4096, MEM_RESERVE, PAGE_READWRITE );

	// Make sure we got a valid address
	if ( 0L == lpStartAddress )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "VirtualAlloc() failed to allocate 4096 bytes" );
		
		KdPrint(( "VirtualAlloc() Failed!\n" ));

		fFail = TRUE;
	}

	// Commit the memory
	// Reserve 32 megs of virtual memory
	lpStartAddress = VirtualAlloc( 0L, 4096, MEM_COMMIT, PAGE_READWRITE );
	
	// Make sure we got a valid address
	if ( 0L == lpStartAddress )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "VirtualAlloc() failed to commit 4096 bytes" );

		KdPrint(( "VirtualAlloc( MEM_COMMIT ) Failed!\n" ));

		fFail = TRUE;
	}
	else
	{
		ZeroMemory( lpStartAddress, 4096 );
	}
	
	// Free the committed memory
	if ( FALSE == fFail )
	{
		xStartVariation( XMmApiLogHandle, "VirtualFree()" );
		
		fFail = VirtualFree( lpStartAddress, 0, MEM_DECOMMIT );

		if ( FALSE == fFail )	// VirtualFree() returns FALSE if an error occurs (inverse)
		{
			xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "VirtualFree() failed!" );
			
			KdPrint(( "VirtualFree() Failed!\n" ));

			fFail = TRUE;		// Reset the fail flag to indicate an error
		}
		else
		{
			lpStartAddress = 0L;
			fFail = FALSE;		// Reset the fail flag
		}
	}
	
		xEndVariation( XMmApiLogHandle );

	// LogEndCase
	if ( FALSE == fFail || ( FALSE == fFail && 0L == lpStartAddress) )
	{
		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "TestCase 5: PASS" );

		KdPrint(( ">>>TestCase 5 PASSED<<<\n" ));
	}
	else
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "TestCase 5: FAIL" );

		KdPrint(( ">>>TestCase 3 FAILED<<<\n" ));

	}
} // end TestCase 5



/*++

	=== TEST CASE 6 ===

Routine Description:
              
    Test to verify you can reserve / commit all available memory.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	This function will eat up to 256 megs of RAM.

--*/
void TestCase6( HANDLE XMmApiLogHandle )
{
	LPVOID	lpmMemoryArray[16];				// Returned starting memory location
	LPVOID  lpmMemTemp = NULL;				// Temporary address location
	BOOL	fFail;							// Failure flag
	INT		i = 0;							// Counter / reference
	DWORD	size = 0;						// Size of memmory chunk to allocate
	DWORD	dwTotalSize = 0;				// Total amount of memory allocated

	// Log location with the Kernel Debugger
	KdPrint(( "XMmAPI: ==TestCase 6==\n" ));

	// Reset the fFail flag
	fFail = FALSE;

	// Set the size variable
	size = 16384;		// 1 meg RAM or 4 pages (4096 bytes per page)
	dwTotalSize = 0;
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 6== Test to verify you can reserve / commit all available memory." );
	
	
	// Keep allocating memory until the size has been reduced to zero.
	// For each VirtualAlloc() that fails, we reduce the size by 1/2.
	
	// TODO: Are pages the same size on the XBox
	while( i < 16 && size > 0 )
	{
		lpmMemTemp = VirtualAlloc( 0L, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE );
		
		// If the call to VirtualAlloc didn't fail...
		if( lpmMemTemp != 0L )
		{
			// Place the new address into our array
			lpmMemoryArray[i] = lpmMemTemp;

			// Try touching the allocated memory
			_try {

				ZeroMemory( lpmMemoryArray[i], size );

			} _except( EXCEPTION_EXECUTE_HANDLER ) {
				xLog( XMmApiLogHandle,
					  XLL_INFO,
					  "ZeroMemory raised an exception at address 0x%p",
					  lpmMemoryArray[i] );
				
				// An error occured
				fFail = TRUE;
				KdPrint(( "Exception touching all reserved Memory!\n" ));
				_asm int 3; // Pause for personal reflection...
			}

			i++;
			dwTotalSize += size;
		}
		else
		{
			// If VirtualAlloc failed, try cutting the allocation size in half (prob won't be necessary)
			size /= 2;
		}
	}
	
	// Log total allocation size
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "Allocated %d bytes of memory in %d allocations .",
		  dwTotalSize,
		  i
		  );

	// Log some status with the Kernel Debugger
	KdPrint(( "Memory Eaten.\n" ));
	
	_asm int 3;

	KdPrint(( "Freeing Memory.\n" ));

	_asm int 3;

	// Free all the memory blocks we have allocated
	for( i ; i > 0; i-- )
	{
		KdPrint(( "Entering loop...\n" ));
		
		_asm int 3;
		_try {
			
			// Free up our memory
			
			KdPrint(( "Freeing Memory..." ));

			VirtualFree( lpmMemoryArray[i], 0, MEM_DECOMMIT );
			
			} _except( EXCEPTION_EXECUTE_HANDLER ) {
				xLog( XMmApiLogHandle, 
					  XLL_INFO,
					  "VirtualFree raised and exception at address 0x%p",
					  lpmMemoryArray[i] );
				
				// An error occured
				fFail = TRUE;

				KdPrint(( "VirtualFree() threw an exception." ));
				
				_asm int 3; // More personal reflection (in hex of course)
			
			}

			// Set the array location to 0L
			lpmMemoryArray[i] = 0L;
		
	} // end for

	// Make sure all the memory was deallocated by checking the value of i
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "%d blocks not free'd.",
		  i
		  );

	// LogEndCase
	if ( FALSE == fFail )
	{
		KdPrint(( "Memory free'd\n" ));
		KdPrint(( ">>>TestCase 6 PASSED<<<\n" ));

		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "TestCase 6: PASS" );
	}
	else
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "TestCase 6: FAIL" );

		KdPrint(( ">>>TestCase 6 FAILED<<<\n" ));
	}
} // end TestCase 6



/*++

	=== TEST CASE 7 ===

Routine Description:
              
    Test to verify accessing read-only memory raises and exception.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase7( HANDLE XMmApiLogHandle )
{
	
	LPVOID lpmMemory = NULL;	// Block of allocated memory
	BOOL   fFail;				// General-purpose flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 7== Test to verify accessing read-only memory raises and exception." );


	// PAGE_READONLY: Attempt to ZeroMemory read-only memory
	lpmMemory = VirtualAlloc( 0L, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_READONLY );

	// Verify the memory was allocated
	if ( 0L == lpmMemory )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "Couldn't allocate read-only memory"
			);
		
		KdPrint(( "VirtualAlloc() Failed!\n" ));

		KdPrint(( ">>>TestCase 7 FAILED<<<\n" ));
		
		goto OTHER_END;

	} 
	
		
		// Now try writing to the memory
		_try {
			
			ZeroMemory( lpmMemory, 16384 );
		
		} _except( EXCEPTION_EXECUTE_HANDLER ) {

			xLog( XMmApiLogHandle,
				  XLL_PASS,
				  "Expected exception occured at address: 0x%p",
				  lpmMemory
				);
			KdPrint(( "Expected exception occured..." ));
			KdPrint(( ">>>TestCase 7 PASSED<<<\n" ));
			
			goto END;
		}
		
		// The system did not throw an exception
		fFail = TRUE;		
		xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "An exception did not occur.",
				  lpmMemory
				);
			
		KdPrint(( "An expected exception did not occur...\n" ));

		KdPrint(( ">>>TestCase 7 FAILED<<<\n" ));
		
		
		// END
END:
		// Free the memory
		fFail = VirtualFree( lpmMemory, 0, MEM_DECOMMIT );

		// Make sure it worked
		if ( FALSE == fFail )
			xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "Couldn't free memory!"
				);

OTHER_END: ;

} // end TestCase7()


/*++

	=== TEST CASE 8 ===

Routine Description:
              
    Test to verify accessing protected memory raises and exception.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase8( HANDLE XMmApiLogHandle )
{
	
	LPVOID lpmMemory = NULL;	// Block of allocated memory
	BOOL   fFail;				// General-purpose flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 8== Test to verify accessing protected (execute only) memory raises and exception." );


	// PAGE_READONLY: Attempt to ZeroMemory read-only memory
	lpmMemory = VirtualAlloc( 0L, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE );

	// Verify the memory was allocated
	if ( 0L == lpmMemory )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "Couldn't allocate execute only memory"
			);
		
		KdPrint(( ">>>TestCase 8 FAILED<<<\n" ));

		goto OTHER_END;

	} 
	
		
		// Now try writing to the memory
		_try {
			
			ZeroMemory( lpmMemory, 16384 );
		
		} _except( EXCEPTION_EXECUTE_HANDLER ) {

			xLog( XMmApiLogHandle,
				  XLL_PASS,
				  "Expected exception occured at address: 0x%p",
				  lpmMemory
				);
			KdPrint(( "Expected exception occured..." ));
			KdPrint(( ">>>TestCase 8 PASS<<<" ));
			
			goto END;
		}
		
		// The system did not throw an exception
		xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "An exception did not occur.",
				  lpmMemory
				);	
		KdPrint(( ">>>TestCase 8 FAIL<<<" ));
		
		
		// END
END:
		// Free the memory
		fFail = VirtualFree( lpmMemory, 0, MEM_DECOMMIT );

		// Make sure it worked
		if ( FALSE == fFail )
			xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "Couldn't free memory!"
				);

OTHER_END: ;

} // end TestCase8()




/*++

	=== Test Case 9 ===

Routine Description:
              
    Test to verify accessing EXECUTE_READ memory raises and exception.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase9( HANDLE XMmApiLogHandle )
{
	
	LPVOID lpmMemory = NULL;	// Block of allocated memory
	BOOL   fFail;				// General-purpose flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 9== Test to verify accessing protected (EXECUTE_READ) memory raises and exception." );


	// PAGE_READONLY: Attempt to ZeroMemory read-only memory
	lpmMemory = VirtualAlloc( 0L, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READ );

	// Verify the memory was allocated
	if ( 0L == lpmMemory )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "Couldn't allocate execute only memory"
			);
		
		KdPrint(( ">>>TestCase 9 FAILED<<<\n" ));
			
		goto OTHER_END;

	} 
	
		// Now try writing to the memory
		_try {
			
			ZeroMemory( lpmMemory, 16384 );
		
		} _except( EXCEPTION_EXECUTE_HANDLER ) {

			xLog( XMmApiLogHandle,
				  XLL_PASS,
				  "Expected exception occured at address: 0x%p",
				  lpmMemory
				);
			
			goto END;
		}
		
		// The system did not throw an exception
		xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "An exception did not occur.",
				  lpmMemory
				);	
		
		
		// END
END:
		// Free the memory
		fFail = VirtualFree( lpmMemory, 0, MEM_DECOMMIT );

		// Make sure it worked
		if ( FALSE == fFail )
			xLog( XMmApiLogHandle,
				  XLL_INFO,
				  "Couldn't free memory!"
				);

OTHER_END: ;

} // end TestCase9()



/*++

	=== Test Case 10 ===

Routine Description:
              
    Test to verify accessing PAGE_GUARD memory raises and exception.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase10( HANDLE XMmApiLogHandle )
{
	
	LPVOID lpmMemory = NULL;	// Block of allocated memory
	BOOL   fFail;				// General-purpose flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 10== Test to verify accessing protected (PAGE_GUARD) memory raises and exception." );


	// PAGE_READONLY: Attempt to ZeroMemory read-only memory
	lpmMemory = VirtualAlloc( 0L, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_GUARD );

	// Verify the memory was allocated
	if ( 0L == lpmMemory )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "Couldn't allocate execute only memory"
			);

		KdPrint(( ">>>TestCase 10 FAILED<<<\n" ));

		goto OTHER_END;
	} 
	
		// Now try writing to the memory
		_try {
			
			ZeroMemory( lpmMemory, 16384 );
		
		} _except( EXCEPTION_EXECUTE_HANDLER ) {

			xLog( XMmApiLogHandle,
				  XLL_PASS,
				  "Expected exception occured at address: 0x%p",
				  lpmMemory
				);
			
			goto END;
		}
		
		// The system did not throw an exception
		xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "An exception did not occur.",
				  lpmMemory
				);	
		
		
		// END
END:
		// Free the memory
		fFail = VirtualFree( lpmMemory, 0, MEM_DECOMMIT );

		// Make sure it worked
		if ( FALSE == fFail )
			xLog( XMmApiLogHandle,
				  XLL_INFO,
				  "Couldn't free memory!"
				);

OTHER_END: ;


} // end TestCase10()


/*++

	=== TEST CASE 11 ===

Routine Description:
              
    Test to verify accessing freed memory raises an exception.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase11( HANDLE XMmApiLogHandle )
{
	LPVOID lpmMemory = NULL;	// Block of allocated memory
	BOOL   fFail;				// General-purpose flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 11== Test to verify accessing freed memory raises an exception." );

	// Allocate memory
	lpmMemory = VirtualAlloc( 0L, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE );

	// Make sure we got our memory
	if ( 0L == lpmMemory )
	{
		xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "Couldn't allocate memory!"
			);

		KdPrint(( ">>>TestCase 11 FAILED<<<\n" ));

		goto END;
	}

	// Free the memory
	fFail = VirtualFree( lpmMemory, 0, MEM_DECOMMIT );

	if ( FALSE == fFail )
	{
		xLog( XMmApiLogHandle,
			  XLL_INFO,
			  "Couldn't free memory!"
			);
	}

	// Touch the freed address
	// Now try writing to the memory
		_try {
			
			ZeroMemory( lpmMemory, 16384 );
		
		} _except( EXCEPTION_EXECUTE_HANDLER ) {

			xLog( XMmApiLogHandle,
				  XLL_PASS,
				  "Expected exception occured at address: 0x%p",
				  lpmMemory
				);

			KdPrint(( "Expected exception occured\n" ));
			KdPrint(( ">>>TestCase 11 PASSED<<<\n" ));
			
			goto END;
		}
		
		// The system did not throw an exception
		xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "An exception did not occur.",
				  lpmMemory
			 );
		
		KdPrint(( "An expected exception did not occur\n" ));

		KdPrint(( ">>>TestCase 11 FAILED<<<\n" ));
		
		
		// END
END: ;

}// End TestCase11()



/*++

	=== TEST CASE 12 ===

Routine Description:
              
    Test to verify allocating memory in a protected region fails.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/

void TestCase12( HANDLE XMmApiLogHandle )
{
	
	LPVOID lpmMemory = NULL;	// Block of allocated memory
	BOOL   fFail;				// General-purpose flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualAlloc( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 12== Test to verify allocating memory in a protected region fails." );

	// Allocate memory
	lpmMemory = VirtualAlloc( (LPVOID)0x1000, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE );

	// Check for 0L
	if ( 0L == lpmMemory )
	{
		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "VirtualAlloc() failed to allocate memory in a protected region."
			);
	}
	else
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "VirtualAlloc() reserved memory in a protected region."
			);
	} 
}// End TestCase12



/*++

	=== TEST CASE 13 ===

Routine Description:
              
    Test to verify VirutalProtect will change memory protection.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase13( HANDLE XMmApiLogHandle )
{
	
	LPVOID						lpmMemory = NULL;		// Pointer to allocated memory
	MEMORY_BASIC_INFORMATION	lpMemInfo;				// Pointer to the memory info structure
	PDWORD						lpflOldProtect = 0L;	// Pointer to store old protection type
	BOOL						fFail;					// Fail flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "VirtualProtect( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 13== Test to verify VirutalProtect will change memory protection." );
	
	// Allocate 1 meg of memory
	lpmMemory = VirtualAlloc( 0L, 16384, MEM_RESERVE | MEM_COMMIT, PAGE_READONLY );

	
	// Make sure the memory was allocated
	if ( 0L == lpmMemory )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "Failed to allocate memory!"
			);

		KdPrint(( "VirtualAlloc() Failed!\n" ));
	}
	
	// Now change the protection attributes
	fFail = VirtualProtect( lpmMemory, 16 * 1024, PAGE_EXECUTE_READWRITE, lpflOldProtect );

	
	// Check the return value
	if ( FALSE == fFail )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "VirtualProtect Failed!"
			);

		KdPrint(( "VirutalProtect() Failed!\n" ));
	}
	else
	{
		// Fill another memory info structure element for comparison
		VirtualQuery( lpmMemory, &lpMemInfo, sizeof( lpMemInfo ) );

		// Check the protection attributes
		if ( lpMemInfo.Protect == PAGE_EXECUTE_READWRITE )
		{
			xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "AllocationProtect: %d Expected: %d\n",
			  lpMemInfo.Protect,
			  PAGE_EXECUTE_READWRITE
			);
			
			KdPrint(( ">>>TestCase 13 PASSED<<<\n" ));

		}
		else
		{
			xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "AllocationProtect: %d Expected: %d\n",
			  lpMemInfo.Protect,
			  PAGE_EXECUTE_READWRITE
			);

			KdPrint(( ">>>TestCase 13 FAILED<<<\n" ));

		}
	}


} // end TestCase13()



/*++

	=== TEST CASE 14 ===

Routine Description:
              
    Test to verify GetProcessHeap() returns a vaild handle to the default heap.
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase14 ( HANDLE XMmApiLogHandle )
{
	HANDLE	hHeapHandle = NULL;			// Heap handle
		
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "GetProcessHeap( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 14= Test to verify GetProcessHeap() returns a vaild handle to the default heap." );

	// Attempt to get a handle to the default heap
	_try {
		
		hHeapHandle = GetProcessHeap();
	} _except( EXCEPTION_EXECUTE_HANDLER ) {

		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GetProcessHeap() Failed!"
			);

		KdPrint(( "GetProcessHeap() Failed!\n" ));
	}

	// Verify the handle is not 0L
	if ( 0L == hHeapHandle )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GetProcessHeap() returned a 0L handle!"
			);
		
		KdPrint(( "GetProcessHeap returned NULL...\n" ));

		KdPrint(( ">>>TestCase 14 FAILED<<<\n" ));
	}
	else
	{
		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "GetProcessHeap() returned a valid handle."
			);

		KdPrint(( ">>>TestCase 14 PASSED<<<\n" ));

	}
}// end TestCase14




/*++

	=== TEST CASE 15 ===

Routine Description:
              
    Test functionality of Global memory APIs
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase15( HANDLE XMmApiLogHandle )
{
	
	HGLOBAL	hGlobal			= NULL;		// Handle to a global memory object
	HGLOBAL hGlobalBak		= NULL;		// Backup handle used to free memory
	HGLOBAL hGlobalObj		= NULL;		// Handle returned from 'GlobalHandle()'
	DWORD	dwSize			= 0;		// Size of global memory object
	DWORD	dwError;					// Used for calls to GetLastError()
	LPVOID	lpGlobalPtr		= NULL;		// Pointer to global memory (first byte in block)
	BOOL	fFail;						// Generic fail flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "GlobalAlloc( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 15= Test functionality of Global memory APIs" );

	// Variation: GlobalAlloc()
	xStartVariation( XMmApiLogHandle, "GlobalAlloc()" );

	// Allocate a 32 meg moveable block of memory
	hGlobal = GlobalAlloc( GMEM_MOVEABLE, 32768 );

	// Check for a 0L return
	if ( 0L == hGlobal )
	{
		// xLog failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GlobalAlloc() Failed to allocate memory!"
			);

		KdPrint(( "GlobalAlloc() Failed!\n" ));

		xEndVariation( XMmApiLogHandle );

		goto END;
	}
	else
	{
		// End Variation: GlobalAlloc()
		xEndVariation( XMmApiLogHandle );

		// Start Variation: GlobalSize()
		xStartVariation( XMmApiLogHandle, "GlobalSize()" );
		
		// Make sure it allocated the right size
		dwSize = GlobalSize( hGlobal );

		if ( dwSize != 32768 )
		{
			// xLog failure
			xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GlobalAlloc() allocated only %d bytes!",
			  dwSize
			);

			KdPrint(( "GlobalAlloc() allocated insufficient memory!\n" ));

		}

		// End Variation: GlobalSize()
		xEndVariation( XMmApiLogHandle );

		// Save the handle
		hGlobalBak = hGlobal;
	}
	
	// Start Variation: GlobalLock()
	xStartVariation( XMmApiLogHandle, "GlobalLock()" );

	// Lock the memory object and get a pointer to the first byte of the memory block
	lpGlobalPtr = GlobalLock( hGlobal );

	// Check for 0L
	if ( 0L == lpGlobalPtr )
	{
		// xLog Failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GlobalLock() Failed!", dwSize
			);

		KdPrint(( "GlobalLock() Failed!\n" ));
	}
	
	// End Variation: GlobalLock()
	xEndVariation( XMmApiLogHandle );

	// Start Variation: GlobalHandle()
	xStartVariation( XMmApiLogHandle, "GlobalHandle()" );

	hGlobalObj = GlobalHandle( lpGlobalPtr );

	// Check for NULL
	if ( 0L == hGlobalObj )
	{
		// xLog failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GlobalHandle() returned 0L!"
			);

		KdPrint(( "GlobalHandle() returned NULL\n" ));
	}
	
	// End Variation: GlobalHandle()
	xEndVariation( XMmApiLogHandle );

	// Start Variation: GlobalUnlock()
	xStartVariation( XMmApiLogHandle, "GlobalUnlock()" );

	// Unlock the memory
	fFail = GlobalUnlock( hGlobal );

	// Check the return value ( 0 is failure, but not always, so call GetLastError() to be sure )
	if ( FALSE == fFail )
	{
		dwError = GetLastError();

		if ( NO_ERROR != dwError )
		{
			xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GlobalUnlock() Failed!"
			);

			KdPrint(( "GlobalUnlock() Failed!\n" ));

		}
	}

	// End Variation: GlobalUnlock()
	xEndVariation( XMmApiLogHandle );

	// Start Variation: GlobalReAlloc()
	xStartVariation( XMmApiLogHandle, "GlobalReAlloc()" );

	// Reallocate the memory to 64 megs
	hGlobal = GlobalReAlloc( hGlobal, 65536, GMEM_MOVEABLE );

	// Check for 0L
	if ( 0L == hGlobal )
	{
		// xLog Failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GlobalReAlloc() Failed!"
			);
		
		KdPrint(( "GlobalReAlloc() Failed!\n" ));

		// Reset the handle
		hGlobal = hGlobalBak;
	}
	else
	{
		// Make sure it allocated the right size
		dwSize = GlobalSize( hGlobal );
		
		if ( dwSize != 65536 )
		{
			xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GlobalReAlloc() failed to allocate specified amount of memory!"
			);

			KdPrint(( "GlobalReAlloc() failed to allocate specified amount of memory! \n" ));
		}
	}
	
	// End Variation: GlobalReAlloc()
	xEndVariation( XMmApiLogHandle );

	// Start Variation: GlobalFree()
	xStartVariation( XMmApiLogHandle, "GlobalFree()" );

	// Free the memory
	hGlobal = GlobalFree( hGlobal );

	if ( hGlobal == 0L )
	{
		// xLog Pass
		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "===Test Case 15=== PASSED"
			);

		KdPrint(( ">>>TestCase 15 PASSED<<<\n" ));
	}
	else
	{
		// xLog Failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "GlobalFree() Failed!"
			);

		KdPrint(( ">>>TestCase 15 FAILED<<<\n" ));
	}

	// End Variation: GlobalFree()
	xEndVariation( XMmApiLogHandle );

END: ;

} //end TestCase15()





/*++

	=== TEST CASE 16 ===

Routine Description:
              
    Test functionality of Local memory APIs
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase16( HANDLE XMmApiLogHandle )
{
	
	HLOCAL	hLocal		= NULL;		// Handle to a global memory object
	HLOCAL	hLocalBak	= NULL;		// Backup handle
	HLOCAL  hLocalObj	= NULL;		// Handle returned from 'LocalHandle()'
	DWORD	dwSize;					// Size of global memory object
	DWORD	dwError;				// Used for calls to GetLastError()
	LPVOID	lpLocalPtr;				// Pointer to global memory (first byte in block)
	BOOL	fFail;					// Generic fail flag
	
	
	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "GetProcessHeap( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 16= Test functionality of Local memory APIs" );

	// Variation: LocalAlloc()
	xStartVariation( XMmApiLogHandle, "LocalAlloc()" );

	// Allocate a 32 meg moveable block of memory
	hLocal = LocalAlloc( LMEM_MOVEABLE, 32768 );

	// Check for a 0L return
	if ( 0L == hLocal )
	{
		// xLog failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "LocalAlloc() Failed to allocate memory!"
			);

		KdPrint(( "LocalAlloc() Failed to allocate memory!\n" ));

	}
	else
	{
		// Backup the handle
		hLocalBak = hLocal;

		// End Variation: LocalAlloc()
		xEndVariation( XMmApiLogHandle );

		// Start Variation: LocalSize()
		xStartVariation( XMmApiLogHandle, "LocalSize()" );
		
		// Make sure it allocated the right size
		dwSize = LocalSize( hLocal );

		if ( dwSize != 32768 )
		{
			// xLog failure
			xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "LocalAlloc() allocated only %d bytes!",
			  dwSize
			);

			KdPrint(( "LocalAlloc() allocated insufficient memory!\n" ));
		}

		// End Variation: LocalSize()
		xEndVariation( XMmApiLogHandle );
	}
	
	// Start Variation: LocalLock()
	xStartVariation( XMmApiLogHandle, "LocalLock()" );

	// Lock the memory object and get a pointer to the first byte of the memory block
	lpLocalPtr = LocalLock( hLocal );

	// Check for 0L
	if ( 0L == lpLocalPtr )
	{
		// xLog Failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "LocalLock() Failed!", dwSize
			);

		KdPrint(( "LocalLock() Failed!\n" ));
	}
	
	// End Variation: LocalLock()
	xEndVariation( XMmApiLogHandle );

	// Start Variation: LocalHandle()
	xStartVariation( XMmApiLogHandle, "LocalHandle()" );

	hLocalObj = LocalHandle( lpLocalPtr );

	// Check for 0L
	if ( 0L == hLocalObj )
	{
		// xLog failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "LocalHandle() returned NULL!"
			);
		
		KdPrint(( "LocalHandle() returned NULL\n" ));

	}
	
	// End Variation: LocalHandle()
	xEndVariation( XMmApiLogHandle );

	// Start Variation: LocalUnlock()
	xStartVariation( XMmApiLogHandle, "LocalUnlock()" );

	// Unlock the memory
	fFail = LocalUnlock( hLocal );

	// Check the return value ( 0 is failure, but not always, so call GetLastError() to be sure )
	if ( FALSE == fFail )
	{
		dwError = GetLastError();

		if ( NO_ERROR != dwError )
		{
			xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "LocalUnlock() Failed!"
				);

			KdPrint(( "LocalUnlock Failed!\n" ));
		}
	}

	// End Variation: LocalUnlock()
	xEndVariation( XMmApiLogHandle );

	// Start Variation: LocalReAlloc()
	xStartVariation( XMmApiLogHandle, "LocalReAlloc()" );

	// Reallocate the memory to 64 megs
	hLocal = LocalReAlloc( hLocal, 65536, LMEM_MOVEABLE );

	// Check for 0L
	if ( 0L == hLocal )
	{
		// xLog Failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "LocalReAlloc() Failed!"
			);
		
		KdPrint(( "LocalReAlloc() Failed!\n" ));

		// Reset the handle
		hLocal = hLocalBak;
	}
	else
	{
		// Make sure it allocated the right size
		dwSize = LocalSize( hLocal );
		
		if ( dwSize != 65536 )
		{
			xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "LocalReAlloc() failed to allocate specified amount of memory!"
				);
			
			KdPrint(( "LocalReAlloc() failed to allocate the specified amount of memory!\n" ));

		}
	}
	
	// End Variation: LocalReAlloc()
	xEndVariation( XMmApiLogHandle );

	// Start Variation: LocalFree()
	xStartVariation( XMmApiLogHandle, "LocalFree()" );

	// Free the memory
	hLocal = LocalFree( hLocal );

	if ( hLocal == 0L )
	{
		// xLog Pass
		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "===Test Case 16=== PASSED"
			);

		KdPrint(( ">>>TestCase 16 PASSED<<<\n" ));
	}
	else
	{
		// xLog Failure
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "LocalFree() Failed!"
			);

		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "===Test Case 16=== FAILED"
			);

		KdPrint(( ">>>TestCase 16 FAILED<<<\n" ));
	}

	// End Variation: LocalFree()
	xEndVariation( XMmApiLogHandle );

} //end TestCase16()


/*++

	=== TEST CASE 17 ===

Routine Description:
              
    Test functionality of Heap memory APIs
    
Arguments:

	- HANDLE	XMmApiLogHandle		// Handle to the XBox Logging Object
    
Return:
    
    None

Comments:
	
	
--*/
void TestCase17( HANDLE XMmApiLogHandle )
{
	HANDLE	hHeap		= NULL;		// Handle to the heap
	HANDLE	hHeapBak	= NULL;		// Backup heap handle
	LPVOID	lpHeapMem	= NULL;		// Pointer to the heap
	DWORD	dwSize;					// Size of the heap
	BOOL	fFail;					// Generic fail flag


	// LogBeginCase
	xSetComponent( XMmApiLogHandle, "Kernel", "Mm" );
	xSetFunctionName( XMmApiLogHandle, "Heap*( )" );
	
	xLog( XMmApiLogHandle,
		  XLL_INFO,
		  "==TestCase 17= Test functionality of Heap memory APIs" );

	xStartVariation( XMmApiLogHandle, "HeapCreate()" );

	_try {
		
		hHeap = HeapCreate( HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE, 32768, 131072 ); 
		
		} _except( EXCEPTION_EXECUTE_HANDLER ) {

		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "HeapCreate() threw an exception!"
			);
		
		KdPrint(( "HeapCreate() threw an exception\n" ));

		KdPrint(( ">>>TestCase 17 FAILED<<<\n" ));

		goto END;
	}

	// Backup the handle
	hHeapBak = hHeap;

	xEndVariation( XMmApiLogHandle );

	xStartVariation( XMmApiLogHandle, "HeapAlloc()" );
	
	// Allocate 32 megs of the heaps memory and zero it
	_try {

		lpHeapMem = HeapAlloc( hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_ZERO_MEMORY, 100000 );
	} _except( EXCEPTION_EXECUTE_HANDLER ) {

		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "HeapAlloc() threw an exception!"
			);

		KdPrint(( "HeapAlloc() threw an exception!\n" ));

		goto END;
	}

	xEndVariation( XMmApiLogHandle );

	xStartVariation( XMmApiLogHandle, "HeapSize()" );

	// Get the size of the allocated block for verification
	dwSize = HeapSize( hHeap, 0L, lpHeapMem );

	if ( dwSize != 100000 )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "Heap is only %d bytes!",
			  dwSize
			);
		
		KdPrint(( "HeapAlloc() allocated insufficient memory!\n" ));
	}

	xEndVariation( XMmApiLogHandle );

	xStartVariation( XMmApiLogHandle, "HeapReAlloc()" );

	// Resize the allocation block to incorporate the entire heap
	_try {
		
		lpHeapMem = HeapReAlloc( hHeap, HEAP_GENERATE_EXCEPTIONS | HEAP_REALLOC_IN_PLACE_ONLY | HEAP_ZERO_MEMORY, lpHeapMem, 65536 );
	} _except( EXCEPTION_EXECUTE_HANDLER ) {

		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "HeapReAlloc() threw an exception!",
			  dwSize
			);

		KdPrint(( "HeapReAlloc() failed!\n" ));

		// Free the allocated heap memory
		fFail = HeapFree( hHeap, 0L, lpHeapMem );

		// Check for failure ( 0 indicates a failure [inverse] )
		if ( FALSE == fFail )
		{
			xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "HeapFree() failed!"
				);
		}

		// Destroy the heap
		fFail = HeapDestroy( hHeap );

		// Check for 0
		if ( fFail == FALSE )
		{
			xLog( XMmApiLogHandle,
				  XLL_FAIL,
				  "HeapDestroy() Failed!"
				);
		}
			goto END;
		}
	

	xStartVariation( XMmApiLogHandle, "HeapSize()" );

	// Get the size of the allocated block for verification
	dwSize = HeapSize( hHeap, 0L, lpHeapMem );

	if ( dwSize != 65536 )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "Heap is only %d bytes!",
			  dwSize
			);

	KdPrint(( "HeapReAlloc() allocated insufficient memory!\n" ));

	}

	xEndVariation( XMmApiLogHandle );

	xStartVariation( XMmApiLogHandle, "HeapFree()" );

	// Free the allocated heap memory
	fFail = HeapFree( hHeap, 0L, lpHeapMem );

	// Check for failure ( 0 indicates a failure [inverse] )
	if ( FALSE == fFail )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "HeapFree() failed!"
			);

		KdPrint(( "HeapFree() failed!\n" ));
	}

	xEndVariation( XMmApiLogHandle );

	xStartVariation( XMmApiLogHandle, "HeapDestroy()" );

	// Destroy the heap
	fFail = HeapDestroy( hHeap );

	// Check for 0
	if ( fFail == FALSE )
	{
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "HeapDestroy() Failed!"
			);
		
		xLog( XMmApiLogHandle,
			  XLL_FAIL,
			  "===Test Case 17=== FAILED"
			);

		KdPrint(( "HeapDestroy() Failed!\n" ));

		KdPrint(( ">>>TestCase17 FAILED\n" ));
	}
	else
	{
		xLog( XMmApiLogHandle,
			  XLL_PASS,
			  "===TestCase 17=== PASSED"
			);

		KdPrint(( ">>>TestCase 17<<< PASSED" ));
	}


END: ;



} //end TestCase17()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ob\dirlog\dirlog.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    dirlog.c

Abstract:

    This program contains routines to log all objects in Xbox directory.

Author:

    Sakphong Chanbai (schanbai) 03-May-2000

Environment:

    Xbox

Revision History:

--*/


#include "precomp.h"
#include "testutil.h"


HANDLE HeapHandle;


int __cdecl
UnicodeCompare(
    const void *arg1,
    const void *arg2
    )
{
    POBJECT_DIRECTORY_INFORMATION s1, s2;
    ULONG i, j;

    s1 = (POBJECT_DIRECTORY_INFORMATION)arg1;
    s2 = (POBJECT_DIRECTORY_INFORMATION)arg2;

    for ( i=0, j=0; (i < s1->Name.Length / sizeof(WCHAR)) && \
        (j < s2->Name.Length / sizeof(WCHAR)); \
        i++, j++) {
        if ( s1->Name.Buffer[i] < s2->Name.Buffer[j] ) {
            return -1;
        } else if ( s1->Name.Buffer[i] > s2->Name.Buffer[j] ) {
            return +1;
        }
    }

    if (i > j) {
        return -1;
    } else if (i < j) {
        return +1;
    } else {
        return 0;
    }
}


HANDLE
HandleSymbolicLink(
    IN  HANDLE LogHandle,
    IN  HANDLE DirectoryHandle,
    IN  PWSTR Link
    )
{
    NTSTATUS Status;
    HANDLE LinkHandle = NULL;
    OBJECT_ATTRIBUTES ObjA;
    UNICODE_STRING String, Result;
    CHAR AnsiBuffer[1024]; 
    WCHAR ResultBuffer[1024];

    RtlInitUnicodeString( &String, Link );

    InitializeObjectAttributes(
        &ObjA,
        &String,
        OBJ_CASE_INSENSITIVE,
        DirectoryHandle,
        NULL
        );

    xSetFunctionName( LogHandle, "NtOpenSymbolicLinkObject" );
    sprintf( AnsiBuffer, "%ws", Link );
    xStartVariation( LogHandle, AnsiBuffer );

    Status = NtOpenSymbolicLinkObject(
                &LinkHandle,
                SYMBOLIC_LINK_QUERY,
                &ObjA
                );

    if ( !NT_SUCCESS(Status) ) {
        xLog( LogHandle, XLL_FAIL, "%ws, status = 0x%x", Link, Status );
        xEndVariation( LogHandle );
        return NULL;
    } else {
        xLog( LogHandle, XLL_PASS, "pass" );
        xEndVariation( LogHandle );
    }

    xSetFunctionName( LogHandle, "NtQuerySymbolicLinkObject" );
    xStartVariation( LogHandle, AnsiBuffer );

    Result.Buffer = ResultBuffer;
    Result.Length = 0;
    Result.MaximumLength = sizeof(ResultBuffer);

    Status = NtQuerySymbolicLinkObject(
                LinkHandle,
                &Result,
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        xLog( LogHandle, XLL_FAIL, "%ws, status = 0x%x", Link, Status );
        xEndVariation( LogHandle );
    } else {
        Result.Buffer[ Result.Length/sizeof(WCHAR) ] = 0;
        xLog( LogHandle, XLL_PASS, "%ws", Result.Buffer );
        xEndVariation( LogHandle );
    }

    return LinkHandle;
}


HANDLE
OpenObject(
    IN  HANDLE LogHandle,
    IN  HANDLE DirectoryHandle,
    IN  PWSTR  ObjectName,
    IN  POBJECT_DIRECTORY_INFORMATION ObjDirPtr
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    UNICODE_STRING String;
    CHAR AnsiBuffer[1024];
    HANDLE ObjectHandle;

    RtlInitUnicodeString( &String, ObjectName );

    InitializeObjectAttributes(
        &ObjA,
        &String,
        OBJ_CASE_INSENSITIVE,
        DirectoryHandle,
        NULL
        );

    if ( wcsncmp(
            ObjDirPtr->TypeName.Buffer,
            L"Timer",
            ObjDirPtr->TypeName.Length/sizeof(WCHAR)) == 0 ) {
        xSetFunctionName( LogHandle, "NtOpenTimer" );
        Status = NtOpenTimer(
                    &ObjectHandle,
                    MAXIMUM_ALLOWED,
                    &ObjA
                    );
    } else if ( wcsncmp(
                    ObjDirPtr->TypeName.Buffer,
                    L"Event",
                    ObjDirPtr->TypeName.Length/sizeof(WCHAR)) == 0 ) {
        xSetFunctionName( LogHandle, "NtOpenEvent" );
        Status = NtOpenEvent(
                    &ObjectHandle,
                    MAXIMUM_ALLOWED,
                    &ObjA
                    );
    } else if ( wcsncmp(
                    ObjDirPtr->TypeName.Buffer,
                    L"Mutant",
                    ObjDirPtr->TypeName.Length/sizeof(WCHAR)) == 0 ) {
        xSetFunctionName( LogHandle, "NtOpenMutant" );
        Status = NtOpenMutant(
                    &ObjectHandle,
                    MAXIMUM_ALLOWED,
                    &ObjA
                    );
    } else if ( wcsncmp(
                    ObjDirPtr->TypeName.Buffer,
                    L"Section",
                    ObjDirPtr->TypeName.Length/sizeof(WCHAR)) == 0 ) {
        xSetFunctionName( LogHandle, "NtOpenSection" );
        Status = NtOpenSection(
                    &ObjectHandle,
                    MAXIMUM_ALLOWED,
                    &ObjA
                    );
    } else if ( wcsncmp(
                    ObjDirPtr->TypeName.Buffer,
                    L"Semaphore",
                    ObjDirPtr->TypeName.Length/sizeof(WCHAR)) == 0 ) {
        xSetFunctionName( LogHandle, "NtOpenSemaphore" );
        Status = NtOpenSemaphore(
                    &ObjectHandle,
                    MAXIMUM_ALLOWED,
                    &ObjA
                    );
    } else {
        xSetFunctionName( LogHandle, "NtQueryDirectoryObject" );
        sprintf( AnsiBuffer, "%wZ", &ObjDirPtr->Name );
        xStartVariation( LogHandle, AnsiBuffer );
        xLog( LogHandle, XLL_PASS, "Type = %wZ", &ObjDirPtr->TypeName );
        xEndVariation( LogHandle );
        return NULL;
    }

    sprintf( AnsiBuffer, "%ws", ObjectName );
    xStartVariation( LogHandle, AnsiBuffer );

    if ( NT_SUCCESS(Status) ) {
        xLog( LogHandle, XLL_PASS, "handle = %p", ObjectHandle );
    } else {
        xLog( LogHandle, XLL_FAIL, "Status = 0x%X", Status );
        ObjectHandle = NULL;
    }


    xEndVariation( LogHandle );
    return ObjectHandle;
}


VOID
QueryObject(
    IN  HANDLE LogHandle,
    IN  HANDLE ObjectHandle,
    IN  PWSTR  Path,
    IN  PWSTR  ObjectName
    )
{
#define LARGE_BUFFER_SIZE (32*1024)
    NTSTATUS Status;
    CHAR VariationBuffer[1024];
    PUCHAR LargeBuffer = _alloca(LARGE_BUFFER_SIZE);
    POBJECT_BASIC_INFORMATION pObjBasicInfo;
    POBJECT_NAME_INFORMATION pObjNameInfo;
    POBJECT_TYPE_INFORMATION pObjTypeInfo;
    POBJECT_TYPES_INFORMATION pObjTypesInfo;
    POBJECT_HANDLE_FLAG_INFORMATION pObjHandleFlagInfo;

    xSetFunctionName( LogHandle, "NtQueryObject (ObjectBasicInformation)" );
    sprintf( VariationBuffer, "%ws\\%ws", Path, ObjectName );
    xStartVariation( LogHandle, VariationBuffer );
    pObjBasicInfo = (POBJECT_BASIC_INFORMATION)LargeBuffer;
    
    Status = NtQueryObject(
                ObjectHandle,
                ObjectBasicInformation,
                pObjBasicInfo,
                sizeof(OBJECT_BASIC_INFORMATION),
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        xLog(
            LogHandle,
            XLL_PASS,
            "HandleCount=%d PointerCount=%d",
            pObjBasicInfo->HandleCount,
            pObjBasicInfo->PointerCount
            );
    } else {
        xLog(
            LogHandle,
            Status == STATUS_INFO_LENGTH_MISMATCH ? XLL_BLOCK : XLL_FAIL,
            "Status = 0x%X",
            Status
            );
    }

    xEndVariation( LogHandle );

    xSetFunctionName( LogHandle, "NtQueryObject (ObjectNameInformation)" );
    xStartVariation( LogHandle, VariationBuffer );
    pObjNameInfo = (POBJECT_NAME_INFORMATION)LargeBuffer;

    Status = NtQueryObject(
                ObjectHandle,
                ObjectNameInformation,
                pObjNameInfo,
                LARGE_BUFFER_SIZE,
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        xLog(
            LogHandle,
            XLL_PASS,
            "%ws",
            pObjNameInfo->Name.Buffer ? pObjNameInfo->Name.Buffer : L"<noname>"
            );
    } else {
        xLog(
            LogHandle,
            Status == STATUS_INFO_LENGTH_MISMATCH ? XLL_BLOCK : XLL_FAIL,
            "Status = 0x%X",
            Status
            );
    }

    xEndVariation( LogHandle );

    xSetFunctionName( LogHandle, "NtQueryObject (ObjectTypeInformation)" );
    xStartVariation( LogHandle, VariationBuffer );
    pObjTypeInfo = (POBJECT_TYPE_INFORMATION)LargeBuffer;

    Status = NtQueryObject(
                ObjectHandle,
                ObjectTypeInformation,
                pObjTypeInfo,
                LARGE_BUFFER_SIZE,
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        xLog(
            LogHandle,
            XLL_PASS,
            "%ws",
            pObjTypeInfo->TypeName.Buffer
            );
    } else {
        xLog(
            LogHandle,
            Status == STATUS_INFO_LENGTH_MISMATCH ? XLL_BLOCK : XLL_FAIL,
            "Status = 0x%X",
            Status
            );
    }
    xEndVariation( LogHandle );

    xSetFunctionName( LogHandle, "NtQueryObject (ObjectTypesInformation)" );
    xStartVariation( LogHandle, VariationBuffer );
    pObjTypesInfo =  (POBJECT_TYPES_INFORMATION)LargeBuffer;

    Status = NtQueryObject(
                ObjectHandle,
                ObjectTypesInformation,
                pObjTypesInfo,
                LARGE_BUFFER_SIZE,
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        xLog(
            LogHandle,
            XLL_PASS,
            "number of types = %d",
            pObjTypesInfo->NumberOfTypes
            );
    } else {
        xLog(
            LogHandle,
            Status == STATUS_INFO_LENGTH_MISMATCH ? XLL_BLOCK : XLL_FAIL,
            "Status = 0x%X",
            Status
            );
    }

    xEndVariation( LogHandle );

    xSetFunctionName( LogHandle, "NtQueryObject (ObjectHandleFlagInformation)" );
    xStartVariation( LogHandle, VariationBuffer );
    pObjHandleFlagInfo = (POBJECT_HANDLE_FLAG_INFORMATION)LargeBuffer;

    Status = NtQueryObject(
                ObjectHandle,
                ObjectHandleFlagInformation,
                pObjHandleFlagInfo,
                sizeof(OBJECT_HANDLE_FLAG_INFORMATION),
                NULL
                );

    if ( NT_SUCCESS(Status) ) {
        xLog(
            LogHandle,
            XLL_PASS,
            "Inherit=%d ProtectFromClose=%d",
            pObjHandleFlagInfo->Inherit,
            pObjHandleFlagInfo->ProtectFromClose
            );
    } else {
        xLog(
            LogHandle,
            Status == STATUS_INFO_LENGTH_MISMATCH ? XLL_BLOCK : XLL_FAIL,
            "Status = 0x%X",
            Status
            );
    }

    xEndVariation( LogHandle );
}


NTSTATUS
ListObjectsInDirectory(
    HANDLE                  LogHandle,
    HANDLE                  Handle,
    PUNICODE_STRING         Dir,
    PWCHAR                  Path
)
{
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    HANDLE NewHandle;
    PWCHAR NewPath = NULL;
    WCHAR devbuf[256];
    ULONG Context;
    ULONG c, RetLen;
    ULONG BufferLen;
    PVOID Buffer;
    OBJECT_DIRECTORY_INFORMATION *ObjDirPtr;
    PCHAR AnsiBuffer;

    AnsiBuffer = HeapAlloc( HeapHandle, HEAP_ZERO_MEMORY, 1024 );
    if ( !AnsiBuffer ) {
        return STATUS_NO_MEMORY;
    }

    InitializeObjectAttributes(
        &ObjA,
        Dir,
        OBJ_CASE_INSENSITIVE,
        Handle,
        NULL
        );

    wcsncpy( devbuf, Dir->Buffer, sizeof(devbuf) / sizeof(devbuf[0]) );
    devbuf[sizeof(devbuf) - 1] = L'\0';

    xSetFunctionName( LogHandle, "NtOpenDirectoryObject" );
    sprintf( AnsiBuffer, "%ws", devbuf );
    xStartVariation( LogHandle, AnsiBuffer );
    Status = NtOpenDirectoryObject( &NewHandle, MAXIMUM_ALLOWED, &ObjA );

    if ( !NT_SUCCESS(Status) ) {
        DbgPrint(
            "DIRLOG: NtOpenDirectoryObject failed 0x%x for directory %ws\n",
            Status,
            devbuf
            );

        xLog(
            LogHandle,
            XLL_BLOCK,
            "NtOpenDirectoryObject failed 0x%x for directory %ws",
            Status,
            devbuf
            );
        xEndVariation( LogHandle );
        HeapFree( HeapHandle, 0, AnsiBuffer );
        return Status;
    } else {
        xLog( LogHandle, XLL_PASS, "%ws", devbuf );
        xEndVariation( LogHandle );
    }

    xSetFunctionName( LogHandle, "NtQueryDirectoryObject" );

    Context = 0;
    BufferLen = 0x10000;
    Buffer = HeapAlloc( HeapHandle, HEAP_ZERO_MEMORY, BufferLen );

    if ( !Buffer ) {
        DbgPrint( "DIRLOG: unable to allocate memory\n" );
        xStartVariation( LogHandle, "memory allocation" );
        xLog( LogHandle, XLL_BLOCK, "unable to allocate memory" );
        xEndVariation( LogHandle );
        HeapFree( HeapHandle, 0, AnsiBuffer );
        return STATUS_NO_MEMORY;
    }

    xStartVariation( LogHandle, AnsiBuffer );
    Status = NtQueryDirectoryObject(
                NewHandle,
                Buffer,
                BufferLen,
                FALSE,
                TRUE,
                &Context,
                &RetLen
                );

    if ( !NT_SUCCESS(Status) && Status != STATUS_NO_MORE_ENTRIES ) {
        DbgPrint(
            "DIRLOG: NtQueryDirectoryObject failed 0x%x for directory %ws\n",
            Status,
            devbuf
            );

        xLog(
            LogHandle,
            XLL_BLOCK,
            "NtQueryDirectoryObject failed 0x%x for directory %ws",
            Status,
            devbuf
            );
        xEndVariation( LogHandle );
    }

    if ( NT_SUCCESS(Status) ) {

        xLog( LogHandle, XLL_PASS, "%ws", devbuf );
        xEndVariation( LogHandle );

        for ( ObjDirPtr=(POBJECT_DIRECTORY_INFORMATION)Buffer, c=0; \
              ObjDirPtr->Name.Length || ObjDirPtr->TypeName.Length; \
              c++, ObjDirPtr++ ) {
           ;
        }

        qsort( Buffer, c, sizeof(*ObjDirPtr), UnicodeCompare );

        for ( ObjDirPtr=(POBJECT_DIRECTORY_INFORMATION)Buffer; \
              ObjDirPtr->Name.Length || ObjDirPtr->TypeName.Length; \
              ObjDirPtr++ ) {

            wcsncpy( devbuf, ObjDirPtr->Name.Buffer, sizeof(devbuf)/sizeof(devbuf[0]) );
            devbuf[sizeof(devbuf)/sizeof(devbuf[0]) - 1] = L'\0';

            NewPath = HeapAlloc(
                        HeapHandle,
                        HEAP_ZERO_MEMORY, 
                        (wcslen(Path) + 1 + wcslen(devbuf) + 1) * sizeof(WCHAR)
                        );

            if ( !NewPath ) {
                DbgPrint( "DIRLOG: Memory allocation failed for path buffer!\n" );
                xStartVariation( LogHandle, "memory allocation" );
                xLog( LogHandle, XLL_BLOCK, "Memory allocation failed for path buffer!" );
                xEndVariation( LogHandle );
                break;
            }

            wcscpy ( NewPath, Path );
            if ( Path[wcslen(Path)-1] != '\\' && devbuf[wcslen(devbuf)-1] != '\\') {
                wcscat( NewPath, L"\\" );
            }
            wcscat( NewPath, devbuf );

            if ( wcsncmp(
                    ObjDirPtr->TypeName.Buffer,
                    L"Directory",
                    ObjDirPtr->TypeName.Length/sizeof(WCHAR)) == 0 ) {

                ListObjectsInDirectory(
                    LogHandle,
                    NewHandle,
                    &ObjDirPtr->Name,
                    NewPath
                    );
            } else {

                UNICODE_STRING String;
                WCHAR StringBuffer[1024];
                HANDLE ObjHandle = NULL;

                String.Buffer = StringBuffer;
                String.Length = 0;
                String.MaximumLength = sizeof(StringBuffer);

                if ( wcsncmp(
                        ObjDirPtr->TypeName.Buffer,
                        L"SymbolicLink",
                        ObjDirPtr->TypeName.Length/sizeof(WCHAR)) == 0 ) {

                    ObjHandle = HandleSymbolicLink( LogHandle, NewHandle, devbuf );
                } else {
                    ObjHandle = OpenObject(
                                    LogHandle,
                                    NewHandle,
                                    devbuf,
                                    ObjDirPtr
                                    );
                }
                    
                if ( ObjHandle ) {
                    QueryObject( LogHandle, ObjHandle, Path, devbuf );
                    NtClose( ObjHandle );
                }
            }

            HeapFree( HeapHandle, 0, NewPath );
        }
    }

    HeapFree( HeapHandle, 0, AnsiBuffer );
    HeapFree( HeapHandle, 0, Buffer );
    NtClose( NewHandle );
    return Status;
}


BOOL
WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       fdwReason,
    LPVOID      lpReserved
    )
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( lpReserved );

    if ( fdwReason == DLL_PROCESS_ATTACH ) {
        HeapHandle = HeapCreate( 0, 0, 0 );
        ASSERT( HeapHandle );
    } else if ( fdwReason == DLL_PROCESS_DETACH ) {
        HeapDestroy( HeapHandle );
    }

    return HeapHandle != NULL;
}


#ifdef _UNDER_NT
VOID
_cdecl
main(
    HANDLE LogHandle
    )
#else
VOID
WINAPI
StartTest(
    HANDLE LogHandle
    )
#endif

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    UNICODE_STRING RootDir;

    xSetComponent( LogHandle, "Kernel", "Ob" );
    KdPrint(( "DIRLOG: StartTest\n" ));

    //
    // Start enumerating from root
    //
    RtlInitUnicodeString( &RootDir, L"\\" );
    ListObjectsInDirectory( LogHandle, NULL, &RootDir, L"" );
}


VOID
WINAPI
EndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    KdPrint(( "DIRLOG: EndTest\n" ));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\mm\XMmAPI\prototypes.h ===
/*++

  Copyright (c) 2000 Microsoft Corporation

  Module Name:

	dll.h

  Abstract:

	TBD

  Author:

	Toby Dziubala (a-tobydz) 25-April-2000

  Revision History:

--*/



/// Function Prototypes ///


/// TestCase Prototypes ///
void TestCase1( HANDLE LogHandle );			// Test to verify you can reserve virtual memory then free it.
void TestCase2( HANDLE LogHandle );			// Test to verify you can reserve, commit, and free virtual memory.
void TestCase3( HANDLE LogHandle );			// Test to verify you can touch allocated virtual memory.
void TestCase4( HANDLE LogHandle );			// Test to verify you can reserve, commit, and free virtual memory 
											// using various protection flags.				
void TestCase5( HANDLE LogHandle );			// Test to verify you can reserve / commit the minimum page size 
											// of memory (4096 bytes).
void TestCase6( HANDLE LogHandle );			// Test to verify you can reserve / commit all available memory.
void TestCase7( HANDLE LogHandle );			// Test to verify accessing read-only memory raises and exception.
void TestCase8( HANDLE LogHandle );			// Test to verify accessing protected memory raises and exception.
void TestCase9( HANDLE LogHandle );			// Test to verify accessing EXECUTE_READ memory raises and exception.
void TestCase10( HANDLE LogHandle );		// Test to verify accessing PAGE_GUARD memory raises and exception.
void TestCase11( HANDLE LogHandle );		// Test to verify accessing freed memory raises an exception.
void TestCase12( HANDLE LogHandle );		// Test to verify allocating memory in a protected region fails.
void TestCase13( HANDLE LogHandle );		// Test to verify VirutalProtect will change memory protection.
void TestCase14( HANDLE LogHandle );		// Test to verify GetProcessHeap() returns a vaild handle to the default heap.
void TestCase15( HANDLE LogHandle );		// Test functionality of Global memory APIs.
void TestCase16( HANDLE LogHandle );		// Test functionality of Local memory APIs.
void TestCase17( HANDLE LogHandle );		// Test functionality of Heap memory APIs.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ob\obstress\pch.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This program contains routines to stress object manager

Author:

    Silviu Calinoiu (silviuc) 18-Mar-1997

Environment:

    Xbox

Revision History:

    04-May-2000     schanbai

        Ported to Xbox

--*/

#ifndef __HTSTRESS_PCH_HXX__
#define __HTSTRESS_PCH_HXX__

extern "C" {
#include <nt.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <tchar.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>

#define DbgMessage _DbgMessage

#endif // __HTSTRESS_PCH_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ob\obstress\stress.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    stress.h

Abstract:

    This program contains routines to stress object manager

Author:

    Silviu Calinoiu (silviuc) 18-Mar-1997

Environment:

    Xbox

Revision History:

    04-May-2000     schanbai

        Ported to Xbox

--*/


#ifndef __STRESS_HXX_INCLUDED__
#define __STRESS_HXX_INCLUDED__


#define THREADS_NUMBER              10
#define MAX_OBJECTS_PER_THREAD      50000

extern HANDLE *aHandles[ THREADS_NUMBER ];
extern UINT auHandlesNo[ THREADS_NUMBER ];


DWORD
WINAPI 
StressHandleTableThread( 
	LPVOID lpParam
    );


DWORD
WINAPI
CleanHandleTableThread( 
    LPVOID lpParam
    );


#endif // __STRESS_HXX_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ob\obstress\main.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    This program contains routines to stress object manager

Author:

    Silviu Calinoiu (silviuc) 18-Mar-1997

Environment:

    Xbox

Revision History:

    04-May-2000     schanbai

        Ported to Xbox

--*/


#include "pch.h"
#include "utils.h"
#include "stress.h"
#include "xlog.h"
#include "xtestlib.h"


HANDLE ObStressHeapHandle;


BOOL
AllocateMemory(
    VOID
    )
{
    ULONG i;

    for ( i=0; i<THREADS_NUMBER; i++ ) {
        aHandles[i] = (HANDLE *)\
            HeapAlloc( ObStressHeapHandle, HEAP_ZERO_MEMORY, sizeof(HANDLE) * MAX_OBJECTS_PER_THREAD );

        if ( !aHandles[i] ) {
            return FALSE;
        }
    }

    return TRUE;
}


VOID
FreeMemory(
    VOID
    )
{
    ULONG i;

    for ( i=0; i<THREADS_NUMBER; i++ ) {
        if ( aHandles[i] ) {
            HeapFree( ObStressHeapHandle, HEAP_ZERO_MEMORY, aHandles[i] );
        }
    }
}


BOOL
WINAPI
ObStressDllMain(
    HINSTANCE   hInstance,
    DWORD       fdwReason,
    LPVOID      lpReserved
    )
{
    UNREFERENCED_PARAMETER( lpReserved );

    if ( fdwReason == DLL_PROCESS_ATTACH ) {
        ObStressHeapHandle = HeapCreate( 0, 0, 0 );
    } else if ( fdwReason == DLL_PROCESS_DETACH ) {
        ASSERT( ObStressHeapHandle );
        HeapDestroy( ObStressHeapHandle );
    }

    return ObStressHeapHandle != NULL;
}


VOID
WINAPI
ObStressStartTest(
    HANDLE LogHandle
    )

/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
    HANDLE ahThreads[ THREADS_NUMBER ];
    UINT uThreadIndex;
    UINT uStressThreadsNo;
    UINT uCleanupThreadsNo;
    UINT uCrtHandle;
    DWORD dwThreadId;
    DWORD dwWaitResult;
    DWORD dwSleepTime;
    BOOL StressMode;
    ULONG LastTickCount = 0;
    ULONG Seed = GetTickCount();

    if ( AllocateMemory() ) {

        xSetComponent( LogHandle, "Kernel", "Ob" );
        xSetFunctionName( LogHandle, "stress" );
        xStartVariation( LogHandle, "stress" );

        KdPrint(( "OBSTRESS: StartTest\n" ));

        ASSERT( THREADS_NUMBER <= MAXIMUM_WAIT_OBJECTS );

        StressMode = XTestLibIsStressTesting();
        KdPrint(( "OBSTRESS: running in stress mode = %d\n", StressMode ));

        LastTickCount = GetTickCount();

        //
        // loop forever if in stress mode
        //

        for (;;) {
            PS_STATISTICS ProcessStatistics;
            ULONG HandleCount;

            ProcessStatistics.Length = sizeof(PS_STATISTICS);
            PsQueryStatistics(&ProcessStatistics);
            HandleCount = ProcessStatistics.HandleCount;

            DbgMessage( "\nStarting new execution cycle, handle count = %ld\n", HandleCount );

            //
            // launch the stress threads
            //

            for ( uThreadIndex = 0; uThreadIndex < THREADS_NUMBER; uThreadIndex++ ) {

                //
                // no handles yet
                //

                auHandlesNo[ uThreadIndex ] = 0;

                //
                // create a new stress thread
                //

                ahThreads[ uThreadIndex ] = CreateThread(
                                                NULL,
                                                0,
                                                StressHandleTableThread,
                                                UlongToPtr( uThreadIndex ),
                                                0,
                                                &dwThreadId
                                                );

                if ( ahThreads[ uThreadIndex ] == NULL ) {
                    DbgMessage( "Cannot create thread %u, error %u\n", uThreadIndex );
                    break;
                }
            }
        
            uStressThreadsNo = uThreadIndex;

            if ( uStressThreadsNo == 0 ) {
                DbgMessage( "Could not create any thread.\n" );
            } else {
                DbgMessage( "Number of stress threads launched %u\n", uStressThreadsNo );

                //
                // wait for the stress threads to end
                //

                dwWaitResult = WaitForMultipleObjects(
                                    uStressThreadsNo,
                                    ahThreads,
                                    TRUE,
                                    INFINITE
                                    );

                ASSERT( ( dwWaitResult >= WAIT_OBJECT_0 ) && 
                        ( dwWaitResult <= ( WAIT_OBJECT_0 + uStressThreadsNo ) ) );

                //
                // close the thread handles
                //

                for ( uThreadIndex = 0; uThreadIndex < uStressThreadsNo; uThreadIndex++ ) {
                    CloseHandle( ahThreads[ uThreadIndex ] );
                }

                //
                // launch the clean-up threads
                //

                DbgMessage( "Starting clean-up threads\n" );

                for ( uThreadIndex = 0; uThreadIndex < uStressThreadsNo; uThreadIndex++ ) {
                    ahThreads[ uThreadIndex ] = CreateThread( 
                                                    NULL,
                                                    0,
                                                    CleanHandleTableThread,
                                                    UlongToPtr( uThreadIndex ),
                                                    0,
                                                    &dwThreadId
                                                    );

                    if ( ahThreads[ uThreadIndex ] == NULL ) {
                        DbgMessage( "Cannot create clean-up thread %u, error %u\n", uThreadIndex );
                        break;
                    }
                }

                uCleanupThreadsNo = uThreadIndex;
                DbgMessage( "Number of cleanup threads launched %u\n", uCleanupThreadsNo );

                //
                // wait for the clean-up threads to end
                //

                if ( uCleanupThreadsNo > 0 ) {
                    dwWaitResult = WaitForMultipleObjects(
                                        uCleanupThreadsNo,
                                        ahThreads,
                                        TRUE,
                                        INFINITE
                                        );


                    ASSERT( ( dwWaitResult >= WAIT_OBJECT_0 ) && 
                            ( dwWaitResult <= ( WAIT_OBJECT_0 + uCleanupThreadsNo ) ) );

                    //
                    // close the thread handles
                    //

                    for ( uThreadIndex = 0; uThreadIndex < uCleanupThreadsNo; uThreadIndex++ ) {
                        CloseHandle( ahThreads[ uThreadIndex ] );
                    }
                }

                //
                // if we couldn't create enough cleanup threads then clean-up the rest of the handles here
                //

                for ( uThreadIndex = uCleanupThreadsNo; uThreadIndex < uStressThreadsNo; uThreadIndex++ ) {
                    for( uCrtHandle = 0; uCrtHandle < auHandlesNo[ uThreadIndex ]; uCrtHandle++ ) {
                        CloseHandle( aHandles[ uThreadIndex ][ uCrtHandle ] );
                    }
                }
            }

            //
            // sleep for some time
            //

            dwSleepTime = abs(RtlRandom(&Seed)) % 5000;

            DbgMessage( "Main thread - sleeping...\n" );

            Sleep( dwSleepTime );

            ProcessStatistics.Length = sizeof(PS_STATISTICS);
            PsQueryStatistics(&ProcessStatistics);

            if ( HandleCount != ProcessStatistics.HandleCount ) {
                DbgMessage(
                    "Warning: handle leak, previous handle count is %ld, now is %ld\n",
                    HandleCount,
                    ProcessStatistics.HandleCount
                    );
            }

            if ( !StressMode && (GetTickCount()-LastTickCount) > 60000 ) {
                break;
            }
        }

        xEndVariation( LogHandle );
    }

    FreeMemory();        
}


VOID
WINAPI
ObStressEndTest(
    VOID
    )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/

{
    KdPrint(( "OBSTRESS: EndTest\n" ));
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( obstress )
#pragma data_seg()

BEGIN_EXPORT_TABLE( obstress )
    EXPORT_TABLE_ENTRY( "StartTest", ObStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", ObStressEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", ObStressDllMain )
END_EXPORT_TABLE( obstress )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ob\obstress\utils.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This program contains routines to stress object manager

Author:

    Silviu Calinoiu (silviuc) 18-Mar-1997

Environment:

    Xbox

Revision History:

    04-May-2000     schanbai

        Ported to Xbox

--*/

#ifndef __HTSTRESS_UTILS_HXX_INCLUDED__
#define __HTSTRESS_UTILS_HXX_INCLUDED__


#define ARRAY_LENGTH( array )   ( sizeof(array)/sizeof(array[0]) )


VOID
__cdecl 
_DbgMessage (
    LPCSTR Format,
    ...
    );


#endif // __HTSTRESS_UTILS_HXX_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\commontest.h ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         "Z"
#define TITLE_DRIVE         "T"
#define USER_DRIVE          "U"
#define BASE_DRIVE          CACHE_DRIVE

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    xStartVariation(hLog, variant);
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    xStartVariation(hLog, aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ob\obstress\utils.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This program contains routines to stress object manager

Author:

    Silviu Calinoiu (silviuc) 18-Mar-1997

Environment:

    Xbox

Revision History:

    04-May-2000     schanbai

        Ported to Xbox

--*/


#include "pch.h"


VOID
__cdecl 
_DbgMessage(
    LPCSTR Format,
    ...
    )
{
    va_list Params;
    //CHAR Buffer [4096];

    va_start (Params, Format);
    //sprintf (Buffer, TEXT("OBSTRESS: "));
    //vsprintf (Buffer + _tcslen(Buffer), Format, Params);
    va_end(Params);
    //OutputDebugStringA( Buffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\sections.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    sections.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xlog.h>
#include "sections.h"
#include "commontest.h"
#include "utils.h"
#include "xtestlib.h"

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

static ULONG ThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE XESECTIONSHeapHandle;


BOOL WINAPI XESECTIONSDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        XESECTIONSHeapHandle = HeapCreate(0, 0, 0);

        if(!XESECTIONSHeapHandle)
            {
            OutputDebugString(L"XESECTIONS: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(XESECTIONSHeapHandle)
            {
            HeapDestroy(XESECTIONSHeapHandle);
            }
        }

    return TRUE;
    }

static bool wcistrstr(WCHAR *string, WCHAR *substr, size_t len=0)
    {
    if(!string || ! substr) return false;
    if(!*string) return false;
    if(!len) len = wcslen(substr);
    if(_wcsnicmp(string, substr, len) == 0) return true;

    return wcistrstr(string+1, substr, len);
    }


/*

Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    DWORD threadNumber - sequential number of the thread
    DWORD loops - # of times to run test
    WCHAR* testname - specific name of a test to run

Return Value:

    DWORD

*/
namespace XESECTIONS {

DWORD stressMode = 0;


static DWORD RunAll(HANDLE hLog, DWORD threadNumber, DWORD loops, WCHAR *testname)
    {
    Sleep(threadNumber*200); // stagger the thread's execution a bit

    struct APIFUNCT
        {
        APITEST_FUNC f;
        WCHAR *name;
        };
    #define BUILTAPISTRUCT(n) { n , L#n }

    // Define all the API tests
    APIFUNCT testlist[] =
        {
        /*
        */
        BUILTAPISTRUCT(XESECTIONS::XLoadSection_Test),
        /*
        */
        };

    bool runAll = _wcsicmp(testname, L"(all)") == 0 ? true : false;

    // Run the suite of tests
    for(DWORD i=0; i<loops; i++)
        {
        // run each test
        for(unsigned j=0; j<ARRAYSIZE(testlist); j++)
            {
            if(runAll || wcistrstr(testlist[j].name, testname))
                {
                xLog(hLog, XLL_INFO, "%ws() ******************************************", testlist[j].name);
                LogResourceStatus(hLog, false);
                DebugPrint("XESECTIONS(%d): Entering %ws()\n", threadNumber, testlist[j].name);
                testlist[j].f(hLog, threadNumber);
                }
            }
        }

    return 0;
    }
    } // namespace XESECTIONS

/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XESECTIONSStartTest(HANDLE hLog)
    {
    DWORD ID = 0;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &ThreadID);


    // test settings
    const int buffLen = 1024;
    WCHAR testname[buffLen];
    DWORD loops;


    // Pull out internal INI file settings
    GetProfileString(L"sections", L"testname", L"(all)", testname, buffLen);
    loops = GetProfileInt(L"sections", L"loops", 1);
    XESECTIONS::stressMode = GetProfileInt(L"GeneralSettings", L"StressTestMode", 0);


    xSetOwnerAlias(hLog, "jpoley");
    xSetComponent(hLog, "XAPI", "Loader");
    DebugPrint("XESECTIONS(%d): **************************************************************\n", ID);
    DebugPrint("XESECTIONS(%d): Entering StartTest()\n", ID);
    DebugPrint("XESECTIONS(%d): Internal INI Settings:\n", ID);
    DebugPrint("  loops=%lu\n", loops);
    DebugPrint("  testname=%ws\n", testname);


    switch(ID)
        {
        case 0:
        case 1:
        default:
            XESECTIONS::RunAll(hLog, ID, loops, testname);
            break;
        }


    DebugPrint("XESECTIONS(%d): Leaving StartTest()\n", ID);
    DebugPrint("FILEIO(%d): **************************************************************\n", ID);
    xSetOwnerAlias(hLog, NULL);
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XESECTIONSEndTest(void)
    {
    ThreadID = 0;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( sections )
#pragma data_seg()

BEGIN_EXPORT_TABLE( sections )
    EXPORT_TABLE_ENTRY( "StartTest", XESECTIONSStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XESECTIONSEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", XESECTIONSDllMain )
END_EXPORT_TABLE( sections )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ob\obstress\stress.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    stress.cpp

Abstract:

    This program contains routines to stress object manager

Author:

    Silviu Calinoiu (silviuc) 18-Mar-1997

Environment:

    Xbox

Revision History:

    04-May-2000     schanbai

        Ported to Xbox

--*/


#include "pch.h"
#include "utils.h"
#include "stress.h"

//
// constant definitions
//

#define MAX_OBJECTS_PER_LOOP    1000
#define LOOPS_NO_PER_THREAD     1000

enum {
    StressCreateUnnamedEvents       = 0,
    StressCreateNamedEvents         = 1,
    StressCreateUnnamedSemaphores   = 2,
    StressCreateNamedSemaphores     = 3,
    StressCreateUnnamedMutexes      = 4,
    StressCreateNamedMutexes        = 5,
    StressDuplicateHandles          = 6,
    StressCloseHandles              = 7,
    StressOperationsNo              = 8
};


//
// global data
//

HANDLE *aHandles[ THREADS_NUMBER ];
UINT auHandlesNo[ THREADS_NUMBER ];

    
BOOL
CreateObjects( 
    UINT uThreadIndex,
    UINT uObjectType
    )
{
    UINT uObjectsToCreate;
    UINT uObjectsAlreadyCreated;
    UINT uCrtObject;
    int nResult;
    OCHAR szName[ 128 ];
    ULONG Seed = GetTickCount();

    /*
    DbgMessage(
        "CreateObjects( %u ) - begin - %u handles already\n",
        uThreadIndex,
        auHandlesNo[ uThreadIndex ]
        );
    */

    //
    // how many objects to create this time
    //

    uObjectsToCreate = abs( RtlRandom(&Seed) ) % MAX_OBJECTS_PER_LOOP;
    uObjectsAlreadyCreated = auHandlesNo[ uThreadIndex ];

    if ( uObjectsAlreadyCreated + uObjectsToCreate > MAX_OBJECTS_PER_THREAD ) {
        uObjectsToCreate = MAX_OBJECTS_PER_THREAD - uObjectsAlreadyCreated;
    }

    //
    // create the objects
    //

    switch ( uObjectType ) {

    case StressCreateUnnamedEvents:
        for ( uCrtObject = 0; uCrtObject < uObjectsToCreate; uCrtObject++ ) {

            aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] = \
                CreateEvent( NULL, FALSE, FALSE, NULL );
            
            if ( aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] == NULL ) {
                DbgMessage(
                    "Thread %u, CreateEvent failed, error %u.\n",
                    uThreadIndex, 
                    GetLastError()
                    );
            } else {
                uObjectsAlreadyCreated++;
            }
        }
        break;

    case StressCreateNamedEvents:
        for ( uCrtObject = 0; uCrtObject < uObjectsToCreate; uCrtObject++ ) {
            //
            // the name of the object - we might have duplicates
            //

            nResult = soprintf(
                            szName,
                            OTEXT( "Event%u" ),
                            uCrtObject
                            );

            if ( nResult < 0 ) {
                DbgMessage( "_sntprintf buffer too small.\n" );
                continue;
            }

            aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] = \
                CreateEvent( NULL, FALSE, TRUE, szName );
            
            if ( aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] == NULL ) {
                DbgMessage(
                    "Thread %u, CreateEvent failed, error %u.\n",
                    uThreadIndex, 
                    GetLastError()
                    );
            } else {
                uObjectsAlreadyCreated++;
            }
        }
        break;

    case StressCreateUnnamedSemaphores:
        for ( uCrtObject = 0; uCrtObject < uObjectsToCreate; uCrtObject++ ) {
            aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] = \
                CreateSemaphore( NULL, 1, 1, NULL );
            
            if ( aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] == NULL ) {
                DbgMessage(
                    "Thread %u, CreateSemaphore failed, error %u.\n",
                    uThreadIndex, 
                    GetLastError()
                    );
            } else {
                uObjectsAlreadyCreated++;
            }
        }
        break;

    case StressCreateNamedSemaphores:
        for ( uCrtObject = 0; uCrtObject < uObjectsToCreate; uCrtObject++ ) {
            //
            // the name of the object - we might have duplicates
            //

            nResult = soprintf( 
                            szName,
                            OTEXT( "Semaphore%u" ),
                            uCrtObject
                            );

            if ( nResult < 0 ) {
                DbgMessage( "_sntprintf buffer too small.\n" );
                continue;
            }

            aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] = \
                CreateSemaphore( NULL, 0, 1, szName );
            
            if ( aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] == NULL ) {
                DbgMessage(
                    "Thread %u, CreateSemaphore failed, error %u.\n",
                    uThreadIndex, 
                    GetLastError()
                    );
            } else {
                uObjectsAlreadyCreated++;
            }
        }
        break;

    case StressCreateUnnamedMutexes:
        for ( uCrtObject = 0; uCrtObject < uObjectsToCreate; uCrtObject++ ) {
            aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] = \
                CreateMutex( NULL, FALSE, NULL );
            
            if ( aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] == NULL ) {
                DbgMessage(
                    "Thread %u, CreateMutex failed, error %u.\n",
                    uThreadIndex, 
                    GetLastError()
                    );
            } else {
                uObjectsAlreadyCreated++;
            }
        }
        break;

    case StressCreateNamedMutexes:
        for ( uCrtObject = 0; uCrtObject < uObjectsToCreate; uCrtObject++ ) {
            //
            // the name of the object - we might have duplicates
            //

            nResult = soprintf( 
                            szName,
                            OTEXT( "Mutex%u" ),
                            uCrtObject
                            );

            if ( nResult < 0 ) {
                DbgMessage( "_sntprintf buffer too small.\n" );
                continue;
            }

            aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] = \
                CreateMutex( NULL, TRUE, szName );
            
            if ( aHandles[ uThreadIndex ][ uObjectsAlreadyCreated ] == NULL ) {
                DbgMessage(
                    "Thread %u, CreateMutex failed, error %u.\n",
                    uThreadIndex, 
                    GetLastError()
                    );
            } else {
                uObjectsAlreadyCreated++;
            }
        }
        break;

    default:
        ASSERT( FALSE );
    }

    ASSERT( uObjectsAlreadyCreated <= MAX_OBJECTS_PER_THREAD );

    auHandlesNo[ uThreadIndex ] = uObjectsAlreadyCreated;

    /*
    DbgMessage(
        "CreateObjects( %u ) - end - %u handles now\n",
        uThreadIndex,
        auHandlesNo[ uThreadIndex ]
        );
    */

    if ( uObjectsAlreadyCreated >= MAX_OBJECTS_PER_THREAD ) {
        //
        // the table is full
        //
        return FALSE;
    } else {
        //
        // still have space for some handles
        //
        return TRUE;
    }
}


void
CloseHandles( 
    UINT uThreadIndex
    )
{
    UINT uIndexStart;
    UINT uHandlesToClose;
    UINT uIndexEnd;
    UINT uCrtHandle;
    ULONG Seed = GetTickCount();

    /*
    DbgMessage(
        "CloseHandles( %u ) - begin - %u handles for now\n",
        uThreadIndex,
        auHandlesNo[ uThreadIndex ]
        );
    */

    if ( auHandlesNo[ uThreadIndex ] == 0 ) {
        //
        // nothing to close
        //
        return;
    }

    //
    // start closing from this index
    //

    uIndexStart = abs( RtlRandom(&Seed) ) % auHandlesNo[ uThreadIndex ];
    
    //
    // how many handles to close
    //

    uHandlesToClose = abs( RtlRandom(&Seed) ) % MAX_OBJECTS_PER_LOOP;

    if ( uIndexStart + uHandlesToClose > auHandlesNo[ uThreadIndex ] ) {
        uHandlesToClose = auHandlesNo[ uThreadIndex ] - uIndexStart;
    }

    if ( uHandlesToClose == 0 ) {
        //
        // nothing to do
        //
        return;
    }

    //
    // close the handles
    //

    uIndexEnd = uIndexStart + uHandlesToClose;

    ASSERT( uIndexEnd <= auHandlesNo[ uThreadIndex ] );

    /*
    DbgMessage(
        "CloseHandles: total %u, start %u, end %u, will close %u\n",
        auHandlesNo[ uThreadIndex ],
        uIndexStart,
        uIndexEnd,
        uHandlesToClose
        );
    */

    for ( uCrtHandle = uIndexStart; uCrtHandle < uIndexEnd; uCrtHandle++ ) {
        CloseHandle( aHandles[ uThreadIndex ][ uCrtHandle ] );
    }

    if ( uIndexEnd < auHandlesNo[ uThreadIndex ] ) {
        //
        // keep the end of the buffer
        //

        MoveMemory(
            &aHandles[ uThreadIndex ][ uIndexStart ],
            &aHandles[ uThreadIndex ][ uIndexEnd ],
            ( auHandlesNo[ uThreadIndex ] - uIndexEnd ) * sizeof( aHandles[ uThreadIndex ][ uIndexEnd ] )
            );
    }

    ASSERT( auHandlesNo[ uThreadIndex ] >= uHandlesToClose );

    auHandlesNo[ uThreadIndex ] -= uHandlesToClose;

    /*
    DbgMessage(
        "CloseHandles( %u ) - end - %u handles now\n",
        uThreadIndex,
        auHandlesNo[ uThreadIndex ]
        );
    */
}


void
DuplicateHandles( 
    UINT uThreadIndex
    )
{
    UINT uIndexStart;
    UINT uIndexEnd;
    UINT uCrtHandle;
    UINT uHandlesToDup;
    UINT uCrtHandleNumber;
    BOOL bResult;
    HANDLE hCurrentProcess;
    ULONG Seed = GetTickCount();

    if ( auHandlesNo[ uThreadIndex ] == 0 ) {
        //
        // nothing to duplicate
        //
        return;
    }

    hCurrentProcess = NtCurrentProcess();

    //
    // start duplicating from this index
    //

    uIndexStart = abs( RtlRandom(&Seed) ) % auHandlesNo[ uThreadIndex ];
    
    //
    // how many handles to duplicate
    //

    uHandlesToDup = abs( RtlRandom(&Seed) ) % MAX_OBJECTS_PER_LOOP;

    if ( uIndexStart + uHandlesToDup > auHandlesNo[ uThreadIndex ] ) {
        uHandlesToDup = auHandlesNo[ uThreadIndex ] - uIndexStart;
    }

    if ( auHandlesNo[ uThreadIndex ] + uHandlesToDup > MAX_OBJECTS_PER_THREAD ) {
        uHandlesToDup = MAX_OBJECTS_PER_THREAD - auHandlesNo[ uThreadIndex ];
    }

    if ( uHandlesToDup == 0 ) {
        //
        // nothing to do
        //
        return;
    }

    //
    // duplicate the handles
    //

    uIndexEnd = uIndexStart + uHandlesToDup;

    ASSERT( uIndexEnd <= auHandlesNo[ uThreadIndex ] );
    ASSERT( auHandlesNo[ uThreadIndex ] + uHandlesToDup <= MAX_OBJECTS_PER_THREAD );

    uCrtHandleNumber = auHandlesNo[ uThreadIndex ];

    for ( uCrtHandle = uIndexStart; uCrtHandle < uIndexEnd; uCrtHandle++ ) {
        bResult = DuplicateHandle( 
                        hCurrentProcess,
                        aHandles[ uThreadIndex ][ uCrtHandle ],
                        hCurrentProcess,
                        &aHandles[ uThreadIndex ][ uCrtHandleNumber ],
                        DUPLICATE_SAME_ACCESS,
                        FALSE,
                        0
                        );
        
        if ( bResult == FALSE ) {
            DbgMessage(
                "Thread %u: DuplicateHandles: cannot duplicate handle %p\n",
                uThreadIndex,
                aHandles[ uThreadIndex ][ uCrtHandle ]
                );
        } else {
            uCrtHandleNumber++;
        }
    }

    auHandlesNo[ uThreadIndex ] = uCrtHandleNumber;
}


DWORD
WINAPI 
StressHandleTableThread( 
	LPVOID lpParam
    )
{
    UINT uStressThreadIndex;
    UINT uCrtLoop;
    UINT uOperationType;
    BOOL bContinue;
    DWORD dwSleepTime;
    ULONG Seed = GetTickCount();

    uStressThreadIndex = PtrToUlong( lpParam );

    //
    // loop
    //

    for ( uCrtLoop = 0; uCrtLoop < LOOPS_NO_PER_THREAD; uCrtLoop++ ) {
        //
        // choose an action to take
        //

        uOperationType = abs( RtlRandom(&Seed) ) % StressOperationsNo;

        switch ( uOperationType ) {
        case StressCloseHandles:
            //
            // close some of our handles
            //
            CloseHandles( uStressThreadIndex );
            break;

        case StressDuplicateHandles:
            //
            // duplicate some of our handles
            //
            DuplicateHandles( uStressThreadIndex );
            break;

        default:
            //
            // create new objects
            //

            bContinue = CreateObjects( uStressThreadIndex, uOperationType );

            if ( bContinue == FALSE ) {
                //
                // our internal handle table is full
                //
                DbgMessage(
                    "Stress thread %u, returning...\n", 
                    uStressThreadIndex
                    );

                return 0;
            }
        }

        //
        // sleep for some time
        //

        if ( ( uCrtLoop % 100 ) == 0 ) {
            dwSleepTime = abs( RtlRandom(&Seed) ) % 5000;

            DbgMessage(
                "Stress thread %u, sleeping...\n", 
                uStressThreadIndex
                );

            Sleep( dwSleepTime );
        }
    }

    return 0;
}


DWORD
WINAPI
CleanHandleTableThread( 
    LPVOID lpParam
    )
{
    UINT uCrtHandle;
    UINT uThreadIndex;
    ULONG Seed = GetTickCount();

    uThreadIndex = PtrToUlong( lpParam );

    /*
    DbgMessage(
        "CleanHandleTableThread( %u ) - begin - %u handles for now\n",
        uThreadIndex,
        auHandlesNo[ uThreadIndex ]
        );
    */

    //
    // close the handles corresponding to this thread
    //

    if ( ( abs( RtlRandom(&Seed) ) % 2 ) == 0 ) {
        for ( uCrtHandle = 0; uCrtHandle < auHandlesNo[ uThreadIndex ]; uCrtHandle++ ) {
            CloseHandle( aHandles[ uThreadIndex ][ uCrtHandle ] );
        }
    } else {
        for ( uCrtHandle = auHandlesNo[ uThreadIndex ]; uCrtHandle > 0 ; uCrtHandle-- ) {
            CloseHandle( aHandles[ uThreadIndex ][ uCrtHandle - 1 ] );
        }
    }

    auHandlesNo[ uThreadIndex ] = 0;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\sections.h ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    sections.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/

typedef DWORD (*APITEST_FUNC)(HANDLE hLog, DWORD ThreadID);

namespace XESECTIONS
    {
    //
    //  Loader Tests
    //
    extern DWORD XLoadSection_Test(HANDLE hLog, DWORD ThreadID);
    } // namespace XESECTIONS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

/*
#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif
*/



// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>



#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
{
ULONG DebugPrint(PCHAR Format, ...);
}


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\segments.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    segments.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "sections.h"

#define MAKE_SEGMENT_BODY(name, size) \
    char seg_sz##name[] = #name; \
    int seg_i##name; \
    char seg_c##name[size+1] = {0};

#pragma data_seg("seg00000")
MAKE_SEGMENT_BODY( Segment00000, 0 )

#pragma data_seg("seg00001")
MAKE_SEGMENT_BODY( Segment00001, 1 )

#pragma data_seg("seg00002")
MAKE_SEGMENT_BODY( Segment00002, 2 )

#pragma data_seg("seg00003")
MAKE_SEGMENT_BODY( Segment00003, 3 )

#pragma data_seg("seg00004")
MAKE_SEGMENT_BODY( Segment00004, 4 )

#pragma data_seg("seg00005")
MAKE_SEGMENT_BODY( Segment00005, 5 )

#pragma data_seg("seg00006")
MAKE_SEGMENT_BODY( Segment00006, 6 )

#pragma data_seg("seg00007")
MAKE_SEGMENT_BODY( Segment00007, 7 )

#pragma data_seg("seg00008")
MAKE_SEGMENT_BODY( Segment00008, 8 )

#pragma data_seg("seg00009")
MAKE_SEGMENT_BODY( Segment00009, 9 )

#pragma data_seg("seg00010")
MAKE_SEGMENT_BODY( Segment00010, 10 )

#pragma data_seg("seg00011")
MAKE_SEGMENT_BODY( Segment00011, 11 )

#pragma data_seg("seg00012")
MAKE_SEGMENT_BODY( Segment00012, 12 )

#pragma data_seg("seg00013")
MAKE_SEGMENT_BODY( Segment00013, 13 )

#pragma data_seg("seg00014")
MAKE_SEGMENT_BODY( Segment00014, 14 )

#pragma data_seg("seg00015")
MAKE_SEGMENT_BODY( Segment00015, 15 )

#pragma data_seg("seg00016")
MAKE_SEGMENT_BODY( Segment00016, 16 )

#pragma data_seg("seg00017")
MAKE_SEGMENT_BODY( Segment00017, 17 )

#pragma data_seg("seg00018")
MAKE_SEGMENT_BODY( Segment00018, 18 )

#pragma data_seg("seg00019")
MAKE_SEGMENT_BODY( Segment00019, 19 )

#pragma data_seg("seg00020")
MAKE_SEGMENT_BODY( Segment00020, 20 )

#pragma data_seg("seg00021")
MAKE_SEGMENT_BODY( Segment00021, 21 )

#pragma data_seg("seg00022")
MAKE_SEGMENT_BODY( Segment00022, 22 )

#pragma data_seg("seg00023")
MAKE_SEGMENT_BODY( Segment00023, 23 )

#pragma data_seg("seg00024")
MAKE_SEGMENT_BODY( Segment00024, 24 )

#pragma data_seg("seg00025")
MAKE_SEGMENT_BODY( Segment00025, 25 )

#pragma data_seg("seg00026")
MAKE_SEGMENT_BODY( Segment00026, 26 )

#pragma data_seg("seg00027")
MAKE_SEGMENT_BODY( Segment00027, 27 )

#pragma data_seg("seg00028")
MAKE_SEGMENT_BODY( Segment00028, 28 )

#pragma data_seg("seg00029")
MAKE_SEGMENT_BODY( Segment00029, 29 )

#pragma data_seg("seg00030")
MAKE_SEGMENT_BODY( Segment00030, 30 )

#pragma data_seg("seg00031")
MAKE_SEGMENT_BODY( Segment00031, 31 )

#pragma data_seg("seg00032")
MAKE_SEGMENT_BODY( Segment00032, 32 )

#pragma data_seg("seg00033")
MAKE_SEGMENT_BODY( Segment00033, 33 )

#pragma data_seg("seg00034")
MAKE_SEGMENT_BODY( Segment00034, 34 )

#pragma data_seg("seg00035")
MAKE_SEGMENT_BODY( Segment00035, 35 )

#pragma data_seg("seg00036")
MAKE_SEGMENT_BODY( Segment00036, 36 )

#pragma data_seg("seg00037")
MAKE_SEGMENT_BODY( Segment00037, 37 )

#pragma data_seg("seg00038")
MAKE_SEGMENT_BODY( Segment00038, 38 )

#pragma data_seg("seg00039")
MAKE_SEGMENT_BODY( Segment00039, 39 )

#pragma data_seg("seg00040")
MAKE_SEGMENT_BODY( Segment00040, 40 )

#pragma data_seg("seg00041")
MAKE_SEGMENT_BODY( Segment00041, 41 )

#pragma data_seg("seg00042")
MAKE_SEGMENT_BODY( Segment00042, 42 )

#pragma data_seg("seg00043")
MAKE_SEGMENT_BODY( Segment00043, 43 )

#pragma data_seg("seg00044")
MAKE_SEGMENT_BODY( Segment00044, 44 )

#pragma data_seg("seg00045")
MAKE_SEGMENT_BODY( Segment00045, 45 )

#pragma data_seg("seg00046")
MAKE_SEGMENT_BODY( Segment00046, 46 )

#pragma data_seg("seg00047")
MAKE_SEGMENT_BODY( Segment00047, 47 )

#pragma data_seg("seg00048")
MAKE_SEGMENT_BODY( Segment00048, 48 )

#pragma data_seg("seg00049")
MAKE_SEGMENT_BODY( Segment00049, 49 )

#pragma data_seg("seg00050")
MAKE_SEGMENT_BODY( Segment00050, 50 )

#pragma data_seg("seg00051")
MAKE_SEGMENT_BODY( Segment00051, 51 )

#pragma data_seg("seg00052")
MAKE_SEGMENT_BODY( Segment00052, 52 )

#pragma data_seg("seg00053")
MAKE_SEGMENT_BODY( Segment00053, 53 )

#pragma data_seg("seg00054")
MAKE_SEGMENT_BODY( Segment00054, 54 )

#pragma data_seg("seg00055")
MAKE_SEGMENT_BODY( Segment00055, 55 )

#pragma data_seg("seg00056")
MAKE_SEGMENT_BODY( Segment00056, 56 )

#pragma data_seg("seg00057")
MAKE_SEGMENT_BODY( Segment00057, 57 )

#pragma data_seg("seg00058")
MAKE_SEGMENT_BODY( Segment00058, 58 )

#pragma data_seg("seg00059")
MAKE_SEGMENT_BODY( Segment00059, 59 )

#pragma data_seg("seg00060")
MAKE_SEGMENT_BODY( Segment00060, 60 )

#pragma data_seg("seg00061")
MAKE_SEGMENT_BODY( Segment00061, 61 )

#pragma data_seg("seg00062")
MAKE_SEGMENT_BODY( Segment00062, 62 )

#pragma data_seg("seg00063")
MAKE_SEGMENT_BODY( Segment00063, 63 )

#pragma data_seg("seg00064")
MAKE_SEGMENT_BODY( Segment00064, 64 )

#pragma data_seg("seg00065")
MAKE_SEGMENT_BODY( Segment00065, 65 )

#pragma data_seg("seg00066")
MAKE_SEGMENT_BODY( Segment00066, 66 )

#pragma data_seg("seg00067")
MAKE_SEGMENT_BODY( Segment00067, 67 )

#pragma data_seg("seg00068")
MAKE_SEGMENT_BODY( Segment00068, 68 )

#pragma data_seg("seg00069")
MAKE_SEGMENT_BODY( Segment00069, 69 )

#pragma data_seg("seg00070")
MAKE_SEGMENT_BODY( Segment00070, 70 )

#pragma data_seg("seg00071")
MAKE_SEGMENT_BODY( Segment00071, 71 )

#pragma data_seg("seg00072")
MAKE_SEGMENT_BODY( Segment00072, 72 )

#pragma data_seg("seg00073")
MAKE_SEGMENT_BODY( Segment00073, 73 )

#pragma data_seg("seg00074")
MAKE_SEGMENT_BODY( Segment00074, 74 )

#pragma data_seg("seg00075")
MAKE_SEGMENT_BODY( Segment00075, 75 )

#pragma data_seg("seg00076")
MAKE_SEGMENT_BODY( Segment00076, 76 )

#pragma data_seg("seg00077")
MAKE_SEGMENT_BODY( Segment00077, 77 )

#pragma data_seg("seg00078")
MAKE_SEGMENT_BODY( Segment00078, 78 )

#pragma data_seg("seg00079")
MAKE_SEGMENT_BODY( Segment00079, 79 )

#pragma data_seg("seg00080")
MAKE_SEGMENT_BODY( Segment00080, 80 )

#pragma data_seg("seg00081")
MAKE_SEGMENT_BODY( Segment00081, 81 )

#pragma data_seg("seg00082")
MAKE_SEGMENT_BODY( Segment00082, 82 )

#pragma data_seg("seg00083")
MAKE_SEGMENT_BODY( Segment00083, 83 )

#pragma data_seg("seg00084")
MAKE_SEGMENT_BODY( Segment00084, 84 )

#pragma data_seg("seg00085")
MAKE_SEGMENT_BODY( Segment00085, 85 )

#pragma data_seg("seg00086")
MAKE_SEGMENT_BODY( Segment00086, 86 )

#pragma data_seg("seg00087")
MAKE_SEGMENT_BODY( Segment00087, 87 )

#pragma data_seg("seg00088")
MAKE_SEGMENT_BODY( Segment00088, 88 )

#pragma data_seg("seg00089")
MAKE_SEGMENT_BODY( Segment00089, 89 )

#pragma data_seg("seg00090")
MAKE_SEGMENT_BODY( Segment00090, 90 )

#pragma data_seg("seg00091")
MAKE_SEGMENT_BODY( Segment00091, 91 )

#pragma data_seg("seg00092")
MAKE_SEGMENT_BODY( Segment00092, 92 )

#pragma data_seg("seg00093")
MAKE_SEGMENT_BODY( Segment00093, 93 )

#pragma data_seg("seg00094")
MAKE_SEGMENT_BODY( Segment00094, 94 )

#pragma data_seg("seg00095")
MAKE_SEGMENT_BODY( Segment00095, 95 )

#pragma data_seg("seg00096")
MAKE_SEGMENT_BODY( Segment00096, 96 )

#pragma data_seg("seg00097")
MAKE_SEGMENT_BODY( Segment00097, 97 )

#pragma data_seg("seg00098")
MAKE_SEGMENT_BODY( Segment00098, 98 )

#pragma data_seg("seg00099")
MAKE_SEGMENT_BODY( Segment00099, 99 )

#pragma data_seg("seg00100")
MAKE_SEGMENT_BODY( Segment00100, 100 )

#pragma data_seg("seg00101")
MAKE_SEGMENT_BODY( Segment00101, 101 )

#pragma data_seg("seg00102")
MAKE_SEGMENT_BODY( Segment00102, 102 )

#pragma data_seg("seg00103")
MAKE_SEGMENT_BODY( Segment00103, 103 )

#pragma data_seg("seg00104")
MAKE_SEGMENT_BODY( Segment00104, 104 )

#pragma data_seg("seg00105")
MAKE_SEGMENT_BODY( Segment00105, 105 )

#pragma data_seg("seg00106")
MAKE_SEGMENT_BODY( Segment00106, 106 )

#pragma data_seg("seg00107")
MAKE_SEGMENT_BODY( Segment00107, 107 )

#pragma data_seg("seg00108")
MAKE_SEGMENT_BODY( Segment00108, 108 )

#pragma data_seg("seg00109")
MAKE_SEGMENT_BODY( Segment00109, 109 )

#pragma data_seg("seg00110")
MAKE_SEGMENT_BODY( Segment00110, 110 )

#pragma data_seg("seg00111")
MAKE_SEGMENT_BODY( Segment00111, 111 )

#pragma data_seg("seg00112")
MAKE_SEGMENT_BODY( Segment00112, 112 )

#pragma data_seg("seg00113")
MAKE_SEGMENT_BODY( Segment00113, 113 )

#pragma data_seg("seg00114")
MAKE_SEGMENT_BODY( Segment00114, 114 )

#pragma data_seg("seg00115")
MAKE_SEGMENT_BODY( Segment00115, 115 )

#pragma data_seg("seg00116")
MAKE_SEGMENT_BODY( Segment00116, 116 )

#pragma data_seg("seg00117")
MAKE_SEGMENT_BODY( Segment00117, 117 )

#pragma data_seg("seg00118")
MAKE_SEGMENT_BODY( Segment00118, 118 )

#pragma data_seg("seg00119")
MAKE_SEGMENT_BODY( Segment00119, 119 )

#pragma data_seg("seg00120")
MAKE_SEGMENT_BODY( Segment00120, 120 )

#pragma data_seg("seg00121")
MAKE_SEGMENT_BODY( Segment00121, 121 )

#pragma data_seg("seg00122")
MAKE_SEGMENT_BODY( Segment00122, 122 )

#pragma data_seg("seg00123")
MAKE_SEGMENT_BODY( Segment00123, 123 )

#pragma data_seg("seg00124")
MAKE_SEGMENT_BODY( Segment00124, 124 )

#pragma data_seg("seg00125")
MAKE_SEGMENT_BODY( Segment00125, 125 )

#pragma data_seg("seg00126")
MAKE_SEGMENT_BODY( Segment00126, 126 )

#pragma data_seg("seg00127")
MAKE_SEGMENT_BODY( Segment00127, 127 )

#pragma data_seg("seg00128")
MAKE_SEGMENT_BODY( Segment00128, 128 )

#pragma data_seg("seg00129")
MAKE_SEGMENT_BODY( Segment00129, 129 )

#pragma data_seg("seg00130")
MAKE_SEGMENT_BODY( Segment00130, 130 )

#pragma data_seg("seg00131")
MAKE_SEGMENT_BODY( Segment00131, 131 )

#pragma data_seg("seg00132")
MAKE_SEGMENT_BODY( Segment00132, 132 )

#pragma data_seg("seg00133")
MAKE_SEGMENT_BODY( Segment00133, 133 )

#pragma data_seg("seg00134")
MAKE_SEGMENT_BODY( Segment00134, 134 )

#pragma data_seg("seg00135")
MAKE_SEGMENT_BODY( Segment00135, 135 )

#pragma data_seg("seg00136")
MAKE_SEGMENT_BODY( Segment00136, 136 )

#pragma data_seg("seg00137")
MAKE_SEGMENT_BODY( Segment00137, 137 )

#pragma data_seg("seg00138")
MAKE_SEGMENT_BODY( Segment00138, 138 )

#pragma data_seg("seg00139")
MAKE_SEGMENT_BODY( Segment00139, 139 )

#pragma data_seg("seg00140")
MAKE_SEGMENT_BODY( Segment00140, 140 )

#pragma data_seg("seg00141")
MAKE_SEGMENT_BODY( Segment00141, 141 )

#pragma data_seg("seg00142")
MAKE_SEGMENT_BODY( Segment00142, 142 )

#pragma data_seg("seg00143")
MAKE_SEGMENT_BODY( Segment00143, 143 )

#pragma data_seg("seg00144")
MAKE_SEGMENT_BODY( Segment00144, 144 )

#pragma data_seg("seg00145")
MAKE_SEGMENT_BODY( Segment00145, 145 )

#pragma data_seg("seg00146")
MAKE_SEGMENT_BODY( Segment00146, 146 )

#pragma data_seg("seg00147")
MAKE_SEGMENT_BODY( Segment00147, 147 )

#pragma data_seg("seg00148")
MAKE_SEGMENT_BODY( Segment00148, 148 )

#pragma data_seg("seg00149")
MAKE_SEGMENT_BODY( Segment00149, 149 )

#pragma data_seg("seg00150")
MAKE_SEGMENT_BODY( Segment00150, 150 )

#pragma data_seg("seg00151")
MAKE_SEGMENT_BODY( Segment00151, 151 )

#pragma data_seg("seg00152")
MAKE_SEGMENT_BODY( Segment00152, 152 )

#pragma data_seg("seg00153")
MAKE_SEGMENT_BODY( Segment00153, 153 )

#pragma data_seg("seg00154")
MAKE_SEGMENT_BODY( Segment00154, 154 )

#pragma data_seg("seg00155")
MAKE_SEGMENT_BODY( Segment00155, 155 )

#pragma data_seg("seg00156")
MAKE_SEGMENT_BODY( Segment00156, 156 )

#pragma data_seg("seg00157")
MAKE_SEGMENT_BODY( Segment00157, 157 )

#pragma data_seg("seg00158")
MAKE_SEGMENT_BODY( Segment00158, 158 )

#pragma data_seg("seg00159")
MAKE_SEGMENT_BODY( Segment00159, 159 )

#pragma data_seg("seg00160")
MAKE_SEGMENT_BODY( Segment00160, 160 )

#pragma data_seg("seg00161")
MAKE_SEGMENT_BODY( Segment00161, 161 )

#pragma data_seg("seg00162")
MAKE_SEGMENT_BODY( Segment00162, 162 )

#pragma data_seg("seg00163")
MAKE_SEGMENT_BODY( Segment00163, 163 )

#pragma data_seg("seg00164")
MAKE_SEGMENT_BODY( Segment00164, 164 )

#pragma data_seg("seg00165")
MAKE_SEGMENT_BODY( Segment00165, 165 )

#pragma data_seg("seg00166")
MAKE_SEGMENT_BODY( Segment00166, 166 )

#pragma data_seg("seg00167")
MAKE_SEGMENT_BODY( Segment00167, 167 )

#pragma data_seg("seg00168")
MAKE_SEGMENT_BODY( Segment00168, 168 )

#pragma data_seg("seg00169")
MAKE_SEGMENT_BODY( Segment00169, 169 )

#pragma data_seg("seg00170")
MAKE_SEGMENT_BODY( Segment00170, 170 )

#pragma data_seg("seg00171")
MAKE_SEGMENT_BODY( Segment00171, 171 )

#pragma data_seg("seg00172")
MAKE_SEGMENT_BODY( Segment00172, 172 )

#pragma data_seg("seg00173")
MAKE_SEGMENT_BODY( Segment00173, 173 )

#pragma data_seg("seg00174")
MAKE_SEGMENT_BODY( Segment00174, 174 )

#pragma data_seg("seg00175")
MAKE_SEGMENT_BODY( Segment00175, 175 )

#pragma data_seg("seg00176")
MAKE_SEGMENT_BODY( Segment00176, 176 )

#pragma data_seg("seg00177")
MAKE_SEGMENT_BODY( Segment00177, 177 )

#pragma data_seg("seg00178")
MAKE_SEGMENT_BODY( Segment00178, 178 )

#pragma data_seg("seg00179")
MAKE_SEGMENT_BODY( Segment00179, 179 )

#pragma data_seg("seg00180")
MAKE_SEGMENT_BODY( Segment00180, 180 )

#pragma data_seg("seg00181")
MAKE_SEGMENT_BODY( Segment00181, 181 )

#pragma data_seg("seg00182")
MAKE_SEGMENT_BODY( Segment00182, 182 )

#pragma data_seg("seg00183")
MAKE_SEGMENT_BODY( Segment00183, 183 )

#pragma data_seg("seg00184")
MAKE_SEGMENT_BODY( Segment00184, 184 )

#pragma data_seg("seg00185")
MAKE_SEGMENT_BODY( Segment00185, 185 )

#pragma data_seg("seg00186")
MAKE_SEGMENT_BODY( Segment00186, 186 )

#pragma data_seg("seg00187")
MAKE_SEGMENT_BODY( Segment00187, 187 )

#pragma data_seg("seg00188")
MAKE_SEGMENT_BODY( Segment00188, 188 )

#pragma data_seg("seg00189")
MAKE_SEGMENT_BODY( Segment00189, 189 )

#pragma data_seg("seg00190")
MAKE_SEGMENT_BODY( Segment00190, 190 )

#pragma data_seg("seg00191")
MAKE_SEGMENT_BODY( Segment00191, 191 )

#pragma data_seg("seg00192")
MAKE_SEGMENT_BODY( Segment00192, 192 )

#pragma data_seg("seg00193")
MAKE_SEGMENT_BODY( Segment00193, 193 )

#pragma data_seg("seg00194")
MAKE_SEGMENT_BODY( Segment00194, 194 )

#pragma data_seg("seg00195")
MAKE_SEGMENT_BODY( Segment00195, 195 )

#pragma data_seg("seg00196")
MAKE_SEGMENT_BODY( Segment00196, 196 )

#pragma data_seg("seg00197")
MAKE_SEGMENT_BODY( Segment00197, 197 )

#pragma data_seg("seg00198")
MAKE_SEGMENT_BODY( Segment00198, 198 )

#pragma data_seg("seg00199")
MAKE_SEGMENT_BODY( Segment00199, 199 )

#pragma data_seg("seg00200")
MAKE_SEGMENT_BODY( Segment00200, 200 )

#pragma data_seg("seg00201")
MAKE_SEGMENT_BODY( Segment00201, 201 )

#pragma data_seg("seg00202")
MAKE_SEGMENT_BODY( Segment00202, 202 )

#pragma data_seg("seg00203")
MAKE_SEGMENT_BODY( Segment00203, 203 )

#pragma data_seg("seg00204")
MAKE_SEGMENT_BODY( Segment00204, 204 )

#pragma data_seg("seg00205")
MAKE_SEGMENT_BODY( Segment00205, 205 )

#pragma data_seg("seg00206")
MAKE_SEGMENT_BODY( Segment00206, 206 )

#pragma data_seg("seg00207")
MAKE_SEGMENT_BODY( Segment00207, 207 )

#pragma data_seg("seg00208")
MAKE_SEGMENT_BODY( Segment00208, 208 )

#pragma data_seg("seg00209")
MAKE_SEGMENT_BODY( Segment00209, 209 )

#pragma data_seg("seg00210")
MAKE_SEGMENT_BODY( Segment00210, 210 )

#pragma data_seg("seg00211")
MAKE_SEGMENT_BODY( Segment00211, 211 )

#pragma data_seg("seg00212")
MAKE_SEGMENT_BODY( Segment00212, 212 )

#pragma data_seg("seg00213")
MAKE_SEGMENT_BODY( Segment00213, 213 )

#pragma data_seg("seg00214")
MAKE_SEGMENT_BODY( Segment00214, 214 )

#pragma data_seg("seg00215")
MAKE_SEGMENT_BODY( Segment00215, 215 )

#pragma data_seg("seg00216")
MAKE_SEGMENT_BODY( Segment00216, 216 )

#pragma data_seg("seg00217")
MAKE_SEGMENT_BODY( Segment00217, 217 )

#pragma data_seg("seg00218")
MAKE_SEGMENT_BODY( Segment00218, 218 )

#pragma data_seg("seg00219")
MAKE_SEGMENT_BODY( Segment00219, 219 )

#pragma data_seg("seg00220")
MAKE_SEGMENT_BODY( Segment00220, 220 )

#pragma data_seg("seg00221")
MAKE_SEGMENT_BODY( Segment00221, 221 )

#pragma data_seg("seg00222")
MAKE_SEGMENT_BODY( Segment00222, 222 )

#pragma data_seg("seg00223")
MAKE_SEGMENT_BODY( Segment00223, 223 )

#pragma data_seg("seg00224")
MAKE_SEGMENT_BODY( Segment00224, 224 )

#pragma data_seg("seg00225")
MAKE_SEGMENT_BODY( Segment00225, 225 )

#pragma data_seg("seg00226")
MAKE_SEGMENT_BODY( Segment00226, 226 )

#pragma data_seg("seg00227")
MAKE_SEGMENT_BODY( Segment00227, 227 )

#pragma data_seg("seg00228")
MAKE_SEGMENT_BODY( Segment00228, 228 )

#pragma data_seg("seg00229")
MAKE_SEGMENT_BODY( Segment00229, 229 )

#pragma data_seg("seg00230")
MAKE_SEGMENT_BODY( Segment00230, 230 )

#pragma data_seg("seg00231")
MAKE_SEGMENT_BODY( Segment00231, 231 )

#pragma data_seg("seg00232")
MAKE_SEGMENT_BODY( Segment00232, 232 )

#pragma data_seg("seg00233")
MAKE_SEGMENT_BODY( Segment00233, 233 )

#pragma data_seg("seg00234")
MAKE_SEGMENT_BODY( Segment00234, 234 )

#pragma data_seg("seg00235")
MAKE_SEGMENT_BODY( Segment00235, 235 )

#pragma data_seg("seg00236")
MAKE_SEGMENT_BODY( Segment00236, 236 )

#pragma data_seg("seg00237")
MAKE_SEGMENT_BODY( Segment00237, 237 )

#pragma data_seg("seg00238")
MAKE_SEGMENT_BODY( Segment00238, 238 )

#pragma data_seg("seg00239")
MAKE_SEGMENT_BODY( Segment00239, 239 )

#pragma data_seg("seg00240")
MAKE_SEGMENT_BODY( Segment00240, 240 )

#pragma data_seg("seg00241")
MAKE_SEGMENT_BODY( Segment00241, 241 )

#pragma data_seg("seg00242")
MAKE_SEGMENT_BODY( Segment00242, 242 )

#pragma data_seg("seg00243")
MAKE_SEGMENT_BODY( Segment00243, 243 )

#pragma data_seg("seg00244")
MAKE_SEGMENT_BODY( Segment00244, 244 )

#pragma data_seg("seg00245")
MAKE_SEGMENT_BODY( Segment00245, 245 )

#pragma data_seg("seg00246")
MAKE_SEGMENT_BODY( Segment00246, 246 )

#pragma data_seg("seg00247")
MAKE_SEGMENT_BODY( Segment00247, 247 )

#pragma data_seg("seg00248")
MAKE_SEGMENT_BODY( Segment00248, 248 )

#pragma data_seg("seg00249")
MAKE_SEGMENT_BODY( Segment00249, 249 )

#pragma data_seg("seg00250")
MAKE_SEGMENT_BODY( Segment00250, 250 )

#pragma data_seg("seg00251")
MAKE_SEGMENT_BODY( Segment00251, 251 )

#pragma data_seg("seg00252")
MAKE_SEGMENT_BODY( Segment00252, 252 )

#pragma data_seg("seg00253")
MAKE_SEGMENT_BODY( Segment00253, 253 )

#pragma data_seg("seg00254")
MAKE_SEGMENT_BODY( Segment00254, 254 )

#pragma data_seg("seg00255")
MAKE_SEGMENT_BODY( Segment00255, 255 )

#pragma data_seg("seg00256")
MAKE_SEGMENT_BODY( Segment00256, 256 )

#pragma data_seg("seg00257")
MAKE_SEGMENT_BODY( Segment00257, 257 )

#pragma data_seg("seg00258")
MAKE_SEGMENT_BODY( Segment00258, 258 )

#pragma data_seg("seg00259")
MAKE_SEGMENT_BODY( Segment00259, 259 )

#pragma data_seg("seg00260")
MAKE_SEGMENT_BODY( Segment00260, 260 )

#pragma data_seg("seg00261")
MAKE_SEGMENT_BODY( Segment00261, 261 )

#pragma data_seg("seg00262")
MAKE_SEGMENT_BODY( Segment00262, 262 )

#pragma data_seg("seg00263")
MAKE_SEGMENT_BODY( Segment00263, 263 )

#pragma data_seg("seg00264")
MAKE_SEGMENT_BODY( Segment00264, 264 )

#pragma data_seg("seg00265")
MAKE_SEGMENT_BODY( Segment00265, 265 )

#pragma data_seg("seg00266")
MAKE_SEGMENT_BODY( Segment00266, 266 )

#pragma data_seg("seg00267")
MAKE_SEGMENT_BODY( Segment00267, 267 )

#pragma data_seg("seg00268")
MAKE_SEGMENT_BODY( Segment00268, 268 )

#pragma data_seg("seg00269")
MAKE_SEGMENT_BODY( Segment00269, 269 )

#pragma data_seg("seg00270")
MAKE_SEGMENT_BODY( Segment00270, 270 )

#pragma data_seg("seg00271")
MAKE_SEGMENT_BODY( Segment00271, 271 )

#pragma data_seg("seg00272")
MAKE_SEGMENT_BODY( Segment00272, 272 )

#pragma data_seg("seg00273")
MAKE_SEGMENT_BODY( Segment00273, 273 )

#pragma data_seg("seg00274")
MAKE_SEGMENT_BODY( Segment00274, 274 )

#pragma data_seg("seg00275")
MAKE_SEGMENT_BODY( Segment00275, 275 )

#pragma data_seg("seg00276")
MAKE_SEGMENT_BODY( Segment00276, 276 )

#pragma data_seg("seg00277")
MAKE_SEGMENT_BODY( Segment00277, 277 )

#pragma data_seg("seg00278")
MAKE_SEGMENT_BODY( Segment00278, 278 )

#pragma data_seg("seg00279")
MAKE_SEGMENT_BODY( Segment00279, 279 )

#pragma data_seg("seg00280")
MAKE_SEGMENT_BODY( Segment00280, 280 )

#pragma data_seg("seg00281")
MAKE_SEGMENT_BODY( Segment00281, 281 )

#pragma data_seg("seg00282")
MAKE_SEGMENT_BODY( Segment00282, 282 )

#pragma data_seg("seg00283")
MAKE_SEGMENT_BODY( Segment00283, 283 )

#pragma data_seg("seg00284")
MAKE_SEGMENT_BODY( Segment00284, 284 )

#pragma data_seg("seg00285")
MAKE_SEGMENT_BODY( Segment00285, 285 )

#pragma data_seg("seg00286")
MAKE_SEGMENT_BODY( Segment00286, 286 )

#pragma data_seg("seg00287")
MAKE_SEGMENT_BODY( Segment00287, 287 )

#pragma data_seg("seg00288")
MAKE_SEGMENT_BODY( Segment00288, 288 )

#pragma data_seg("seg00289")
MAKE_SEGMENT_BODY( Segment00289, 289 )

#pragma data_seg("seg00290")
MAKE_SEGMENT_BODY( Segment00290, 290 )

#pragma data_seg("seg00291")
MAKE_SEGMENT_BODY( Segment00291, 291 )

#pragma data_seg("seg00292")
MAKE_SEGMENT_BODY( Segment00292, 292 )

#pragma data_seg("seg00293")
MAKE_SEGMENT_BODY( Segment00293, 293 )

#pragma data_seg("seg00294")
MAKE_SEGMENT_BODY( Segment00294, 294 )

#pragma data_seg("seg00295")
MAKE_SEGMENT_BODY( Segment00295, 295 )

#pragma data_seg("seg00296")
MAKE_SEGMENT_BODY( Segment00296, 296 )

#pragma data_seg("seg00297")
MAKE_SEGMENT_BODY( Segment00297, 297 )

#pragma data_seg("seg00298")
MAKE_SEGMENT_BODY( Segment00298, 298 )

#pragma data_seg("seg00299")
MAKE_SEGMENT_BODY( Segment00299, 299 )

#pragma data_seg("seg00300")
MAKE_SEGMENT_BODY( Segment00300, 300 )

#pragma data_seg("seg00301")
MAKE_SEGMENT_BODY( Segment00301, 301 )

#pragma data_seg("seg00302")
MAKE_SEGMENT_BODY( Segment00302, 302 )

#pragma data_seg("seg00303")
MAKE_SEGMENT_BODY( Segment00303, 303 )

#pragma data_seg("seg00304")
MAKE_SEGMENT_BODY( Segment00304, 304 )

#pragma data_seg("seg00305")
MAKE_SEGMENT_BODY( Segment00305, 305 )

#pragma data_seg("seg00306")
MAKE_SEGMENT_BODY( Segment00306, 306 )

#pragma data_seg("seg00307")
MAKE_SEGMENT_BODY( Segment00307, 307 )

#pragma data_seg("seg00308")
MAKE_SEGMENT_BODY( Segment00308, 308 )

#pragma data_seg("seg00309")
MAKE_SEGMENT_BODY( Segment00309, 309 )

#pragma data_seg("seg00310")
MAKE_SEGMENT_BODY( Segment00310, 310 )

#pragma data_seg("seg00311")
MAKE_SEGMENT_BODY( Segment00311, 311 )

#pragma data_seg("seg00312")
MAKE_SEGMENT_BODY( Segment00312, 312 )

#pragma data_seg("seg00313")
MAKE_SEGMENT_BODY( Segment00313, 313 )

#pragma data_seg("seg00314")
MAKE_SEGMENT_BODY( Segment00314, 314 )

#pragma data_seg("seg00315")
MAKE_SEGMENT_BODY( Segment00315, 315 )

#pragma data_seg("seg00316")
MAKE_SEGMENT_BODY( Segment00316, 316 )

#pragma data_seg("seg00317")
MAKE_SEGMENT_BODY( Segment00317, 317 )

#pragma data_seg("seg00318")
MAKE_SEGMENT_BODY( Segment00318, 318 )

#pragma data_seg("seg00319")
MAKE_SEGMENT_BODY( Segment00319, 319 )

#pragma data_seg("seg00320")
MAKE_SEGMENT_BODY( Segment00320, 320 )

#pragma data_seg("seg00321")
MAKE_SEGMENT_BODY( Segment00321, 321 )

#pragma data_seg("seg00322")
MAKE_SEGMENT_BODY( Segment00322, 322 )

#pragma data_seg("seg00323")
MAKE_SEGMENT_BODY( Segment00323, 323 )

#pragma data_seg("seg00324")
MAKE_SEGMENT_BODY( Segment00324, 324 )

#pragma data_seg("seg00325")
MAKE_SEGMENT_BODY( Segment00325, 325 )

#pragma data_seg("seg00326")
MAKE_SEGMENT_BODY( Segment00326, 326 )

#pragma data_seg("seg00327")
MAKE_SEGMENT_BODY( Segment00327, 327 )

#pragma data_seg("seg00328")
MAKE_SEGMENT_BODY( Segment00328, 328 )

#pragma data_seg("seg00329")
MAKE_SEGMENT_BODY( Segment00329, 329 )

#pragma data_seg("seg00330")
MAKE_SEGMENT_BODY( Segment00330, 330 )

#pragma data_seg("seg00331")
MAKE_SEGMENT_BODY( Segment00331, 331 )

#pragma data_seg("seg00332")
MAKE_SEGMENT_BODY( Segment00332, 332 )

#pragma data_seg("seg00333")
MAKE_SEGMENT_BODY( Segment00333, 333 )

#pragma data_seg("seg00334")
MAKE_SEGMENT_BODY( Segment00334, 334 )

#pragma data_seg("seg00335")
MAKE_SEGMENT_BODY( Segment00335, 335 )

#pragma data_seg("seg00336")
MAKE_SEGMENT_BODY( Segment00336, 336 )

#pragma data_seg("seg00337")
MAKE_SEGMENT_BODY( Segment00337, 337 )

#pragma data_seg("seg00338")
MAKE_SEGMENT_BODY( Segment00338, 338 )

#pragma data_seg("seg00339")
MAKE_SEGMENT_BODY( Segment00339, 339 )

#pragma data_seg("seg00340")
MAKE_SEGMENT_BODY( Segment00340, 340 )

#pragma data_seg("seg00341")
MAKE_SEGMENT_BODY( Segment00341, 341 )

#pragma data_seg("seg00342")
MAKE_SEGMENT_BODY( Segment00342, 342 )

#pragma data_seg("seg00343")
MAKE_SEGMENT_BODY( Segment00343, 343 )

#pragma data_seg("seg00344")
MAKE_SEGMENT_BODY( Segment00344, 344 )

#pragma data_seg("seg00345")
MAKE_SEGMENT_BODY( Segment00345, 345 )

#pragma data_seg("seg00346")
MAKE_SEGMENT_BODY( Segment00346, 346 )

#pragma data_seg("seg00347")
MAKE_SEGMENT_BODY( Segment00347, 347 )

#pragma data_seg("seg00348")
MAKE_SEGMENT_BODY( Segment00348, 348 )

#pragma data_seg("seg00349")
MAKE_SEGMENT_BODY( Segment00349, 349 )

#pragma data_seg("seg00350")
MAKE_SEGMENT_BODY( Segment00350, 350 )

#pragma data_seg("seg00351")
MAKE_SEGMENT_BODY( Segment00351, 351 )

#pragma data_seg("seg00352")
MAKE_SEGMENT_BODY( Segment00352, 352 )

#pragma data_seg("seg00353")
MAKE_SEGMENT_BODY( Segment00353, 353 )

#pragma data_seg("seg00354")
MAKE_SEGMENT_BODY( Segment00354, 354 )

#pragma data_seg("seg00355")
MAKE_SEGMENT_BODY( Segment00355, 355 )

#pragma data_seg("seg00356")
MAKE_SEGMENT_BODY( Segment00356, 356 )

#pragma data_seg("seg00357")
MAKE_SEGMENT_BODY( Segment00357, 357 )

#pragma data_seg("seg00358")
MAKE_SEGMENT_BODY( Segment00358, 358 )

#pragma data_seg("seg00359")
MAKE_SEGMENT_BODY( Segment00359, 359 )

#pragma data_seg("seg00360")
MAKE_SEGMENT_BODY( Segment00360, 360 )

#pragma data_seg("seg00361")
MAKE_SEGMENT_BODY( Segment00361, 361 )

#pragma data_seg("seg00362")
MAKE_SEGMENT_BODY( Segment00362, 362 )

#pragma data_seg("seg00363")
MAKE_SEGMENT_BODY( Segment00363, 363 )

#pragma data_seg("seg00364")
MAKE_SEGMENT_BODY( Segment00364, 364 )

#pragma data_seg("seg00365")
MAKE_SEGMENT_BODY( Segment00365, 365 )

#pragma data_seg("seg00366")
MAKE_SEGMENT_BODY( Segment00366, 366 )

#pragma data_seg("seg00367")
MAKE_SEGMENT_BODY( Segment00367, 367 )

#pragma data_seg("seg00368")
MAKE_SEGMENT_BODY( Segment00368, 368 )

#pragma data_seg("seg00369")
MAKE_SEGMENT_BODY( Segment00369, 369 )

#pragma data_seg("seg00370")
MAKE_SEGMENT_BODY( Segment00370, 370 )

#pragma data_seg("seg00371")
MAKE_SEGMENT_BODY( Segment00371, 371 )

#pragma data_seg("seg00372")
MAKE_SEGMENT_BODY( Segment00372, 372 )

#pragma data_seg("seg00373")
MAKE_SEGMENT_BODY( Segment00373, 373 )

#pragma data_seg("seg00374")
MAKE_SEGMENT_BODY( Segment00374, 374 )

#pragma data_seg("seg00375")
MAKE_SEGMENT_BODY( Segment00375, 375 )

#pragma data_seg("seg00376")
MAKE_SEGMENT_BODY( Segment00376, 376 )

#pragma data_seg("seg00377")
MAKE_SEGMENT_BODY( Segment00377, 377 )

#pragma data_seg("seg00378")
MAKE_SEGMENT_BODY( Segment00378, 378 )

#pragma data_seg("seg00379")
MAKE_SEGMENT_BODY( Segment00379, 379 )

#pragma data_seg("seg00380")
MAKE_SEGMENT_BODY( Segment00380, 380 )

#pragma data_seg("seg00381")
MAKE_SEGMENT_BODY( Segment00381, 381 )

#pragma data_seg("seg00382")
MAKE_SEGMENT_BODY( Segment00382, 382 )

#pragma data_seg("seg00383")
MAKE_SEGMENT_BODY( Segment00383, 383 )

#pragma data_seg("seg00384")
MAKE_SEGMENT_BODY( Segment00384, 384 )

#pragma data_seg("seg00385")
MAKE_SEGMENT_BODY( Segment00385, 385 )

#pragma data_seg("seg00386")
MAKE_SEGMENT_BODY( Segment00386, 386 )

#pragma data_seg("seg00387")
MAKE_SEGMENT_BODY( Segment00387, 387 )

#pragma data_seg("seg00388")
MAKE_SEGMENT_BODY( Segment00388, 388 )

#pragma data_seg("seg00389")
MAKE_SEGMENT_BODY( Segment00389, 389 )

#pragma data_seg("seg00390")
MAKE_SEGMENT_BODY( Segment00390, 390 )

#pragma data_seg("seg00391")
MAKE_SEGMENT_BODY( Segment00391, 391 )

#pragma data_seg("seg00392")
MAKE_SEGMENT_BODY( Segment00392, 392 )

#pragma data_seg("seg00393")
MAKE_SEGMENT_BODY( Segment00393, 393 )

#pragma data_seg("seg00394")
MAKE_SEGMENT_BODY( Segment00394, 394 )

#pragma data_seg("seg00395")
MAKE_SEGMENT_BODY( Segment00395, 395 )

#pragma data_seg("seg00396")
MAKE_SEGMENT_BODY( Segment00396, 396 )

#pragma data_seg("seg00397")
MAKE_SEGMENT_BODY( Segment00397, 397 )

#pragma data_seg("seg00398")
MAKE_SEGMENT_BODY( Segment00398, 398 )

#pragma data_seg("seg00399")
MAKE_SEGMENT_BODY( Segment00399, 399 )

#pragma data_seg("seg00400")
MAKE_SEGMENT_BODY( Segment00400, 400 )

#pragma data_seg("seg00401")
MAKE_SEGMENT_BODY( Segment00401, 401 )

#pragma data_seg("seg00402")
MAKE_SEGMENT_BODY( Segment00402, 402 )

#pragma data_seg("seg00403")
MAKE_SEGMENT_BODY( Segment00403, 403 )

#pragma data_seg("seg00404")
MAKE_SEGMENT_BODY( Segment00404, 404 )

#pragma data_seg("seg00405")
MAKE_SEGMENT_BODY( Segment00405, 405 )

#pragma data_seg("seg00406")
MAKE_SEGMENT_BODY( Segment00406, 406 )

#pragma data_seg("seg00407")
MAKE_SEGMENT_BODY( Segment00407, 407 )

#pragma data_seg("seg00408")
MAKE_SEGMENT_BODY( Segment00408, 408 )

#pragma data_seg("seg00409")
MAKE_SEGMENT_BODY( Segment00409, 409 )

#pragma data_seg("seg00410")
MAKE_SEGMENT_BODY( Segment00410, 410 )

#pragma data_seg("seg00411")
MAKE_SEGMENT_BODY( Segment00411, 411 )

#pragma data_seg("seg00412")
MAKE_SEGMENT_BODY( Segment00412, 412 )

#pragma data_seg("seg00413")
MAKE_SEGMENT_BODY( Segment00413, 413 )

#pragma data_seg("seg00414")
MAKE_SEGMENT_BODY( Segment00414, 414 )

#pragma data_seg("seg00415")
MAKE_SEGMENT_BODY( Segment00415, 415 )

#pragma data_seg("seg00416")
MAKE_SEGMENT_BODY( Segment00416, 416 )

#pragma data_seg("seg00417")
MAKE_SEGMENT_BODY( Segment00417, 417 )

#pragma data_seg("seg00418")
MAKE_SEGMENT_BODY( Segment00418, 418 )

#pragma data_seg("seg00419")
MAKE_SEGMENT_BODY( Segment00419, 419 )

#pragma data_seg("seg00420")
MAKE_SEGMENT_BODY( Segment00420, 420 )

#pragma data_seg("seg00421")
MAKE_SEGMENT_BODY( Segment00421, 421 )

#pragma data_seg("seg00422")
MAKE_SEGMENT_BODY( Segment00422, 422 )

#pragma data_seg("seg00423")
MAKE_SEGMENT_BODY( Segment00423, 423 )

#pragma data_seg("seg00424")
MAKE_SEGMENT_BODY( Segment00424, 424 )

#pragma data_seg("seg00425")
MAKE_SEGMENT_BODY( Segment00425, 425 )

#pragma data_seg("seg00426")
MAKE_SEGMENT_BODY( Segment00426, 426 )

#pragma data_seg("seg00427")
MAKE_SEGMENT_BODY( Segment00427, 427 )

#pragma data_seg("seg00428")
MAKE_SEGMENT_BODY( Segment00428, 428 )

#pragma data_seg("seg00429")
MAKE_SEGMENT_BODY( Segment00429, 429 )

#pragma data_seg("seg00430")
MAKE_SEGMENT_BODY( Segment00430, 430 )

#pragma data_seg("seg00431")
MAKE_SEGMENT_BODY( Segment00431, 431 )

#pragma data_seg("seg00432")
MAKE_SEGMENT_BODY( Segment00432, 432 )

#pragma data_seg("seg00433")
MAKE_SEGMENT_BODY( Segment00433, 433 )

#pragma data_seg("seg00434")
MAKE_SEGMENT_BODY( Segment00434, 434 )

#pragma data_seg("seg00435")
MAKE_SEGMENT_BODY( Segment00435, 435 )

#pragma data_seg("seg00436")
MAKE_SEGMENT_BODY( Segment00436, 436 )

#pragma data_seg("seg00437")
MAKE_SEGMENT_BODY( Segment00437, 437 )

#pragma data_seg("seg00438")
MAKE_SEGMENT_BODY( Segment00438, 438 )

#pragma data_seg("seg00439")
MAKE_SEGMENT_BODY( Segment00439, 439 )

#pragma data_seg("seg00440")
MAKE_SEGMENT_BODY( Segment00440, 440 )

#pragma data_seg("seg00441")
MAKE_SEGMENT_BODY( Segment00441, 441 )

#pragma data_seg("seg00442")
MAKE_SEGMENT_BODY( Segment00442, 442 )

#pragma data_seg("seg00443")
MAKE_SEGMENT_BODY( Segment00443, 443 )

#pragma data_seg("seg00444")
MAKE_SEGMENT_BODY( Segment00444, 444 )

#pragma data_seg("seg00445")
MAKE_SEGMENT_BODY( Segment00445, 445 )

#pragma data_seg("seg00446")
MAKE_SEGMENT_BODY( Segment00446, 446 )

#pragma data_seg("seg00447")
MAKE_SEGMENT_BODY( Segment00447, 447 )

#pragma data_seg("seg00448")
MAKE_SEGMENT_BODY( Segment00448, 448 )

#pragma data_seg("seg00449")
MAKE_SEGMENT_BODY( Segment00449, 449 )

#pragma data_seg("seg00450")
MAKE_SEGMENT_BODY( Segment00450, 450 )

#pragma data_seg("seg00451")
MAKE_SEGMENT_BODY( Segment00451, 451 )

#pragma data_seg("seg00452")
MAKE_SEGMENT_BODY( Segment00452, 452 )

#pragma data_seg("seg00453")
MAKE_SEGMENT_BODY( Segment00453, 453 )

#pragma data_seg("seg00454")
MAKE_SEGMENT_BODY( Segment00454, 454 )

#pragma data_seg("seg00455")
MAKE_SEGMENT_BODY( Segment00455, 455 )

#pragma data_seg("seg00456")
MAKE_SEGMENT_BODY( Segment00456, 456 )

#pragma data_seg("seg00457")
MAKE_SEGMENT_BODY( Segment00457, 457 )

#pragma data_seg("seg00458")
MAKE_SEGMENT_BODY( Segment00458, 458 )

#pragma data_seg("seg00459")
MAKE_SEGMENT_BODY( Segment00459, 459 )

#pragma data_seg("seg00460")
MAKE_SEGMENT_BODY( Segment00460, 460 )

#pragma data_seg("seg00461")
MAKE_SEGMENT_BODY( Segment00461, 461 )

#pragma data_seg("seg00462")
MAKE_SEGMENT_BODY( Segment00462, 462 )

#pragma data_seg("seg00463")
MAKE_SEGMENT_BODY( Segment00463, 463 )

#pragma data_seg("seg00464")
MAKE_SEGMENT_BODY( Segment00464, 464 )

#pragma data_seg("seg00465")
MAKE_SEGMENT_BODY( Segment00465, 465 )

#pragma data_seg("seg00466")
MAKE_SEGMENT_BODY( Segment00466, 466 )

#pragma data_seg("seg00467")
MAKE_SEGMENT_BODY( Segment00467, 467 )

#pragma data_seg("seg00468")
MAKE_SEGMENT_BODY( Segment00468, 468 )

#pragma data_seg("seg00469")
MAKE_SEGMENT_BODY( Segment00469, 469 )

#pragma data_seg("seg00470")
MAKE_SEGMENT_BODY( Segment00470, 470 )

#pragma data_seg("seg00471")
MAKE_SEGMENT_BODY( Segment00471, 471 )

#pragma data_seg("seg00472")
MAKE_SEGMENT_BODY( Segment00472, 472 )

#pragma data_seg("seg00473")
MAKE_SEGMENT_BODY( Segment00473, 473 )

#pragma data_seg("seg00474")
MAKE_SEGMENT_BODY( Segment00474, 474 )

#pragma data_seg("seg00475")
MAKE_SEGMENT_BODY( Segment00475, 475 )

#pragma data_seg("seg00476")
MAKE_SEGMENT_BODY( Segment00476, 476 )

#pragma data_seg("seg00477")
MAKE_SEGMENT_BODY( Segment00477, 477 )

#pragma data_seg("seg00478")
MAKE_SEGMENT_BODY( Segment00478, 478 )

#pragma data_seg("seg00479")
MAKE_SEGMENT_BODY( Segment00479, 479 )

#pragma data_seg("seg00480")
MAKE_SEGMENT_BODY( Segment00480, 480 )

#pragma data_seg("seg00481")
MAKE_SEGMENT_BODY( Segment00481, 481 )

#pragma data_seg("seg00482")
MAKE_SEGMENT_BODY( Segment00482, 482 )

#pragma data_seg("seg00483")
MAKE_SEGMENT_BODY( Segment00483, 483 )

#pragma data_seg("seg00484")
MAKE_SEGMENT_BODY( Segment00484, 484 )

#pragma data_seg("seg00485")
MAKE_SEGMENT_BODY( Segment00485, 485 )

#pragma data_seg("seg00486")
MAKE_SEGMENT_BODY( Segment00486, 486 )

#pragma data_seg("seg00487")
MAKE_SEGMENT_BODY( Segment00487, 487 )

#pragma data_seg("seg00488")
MAKE_SEGMENT_BODY( Segment00488, 488 )

#pragma data_seg("seg00489")
MAKE_SEGMENT_BODY( Segment00489, 489 )

#pragma data_seg("seg00490")
MAKE_SEGMENT_BODY( Segment00490, 490 )

#pragma data_seg("seg00491")
MAKE_SEGMENT_BODY( Segment00491, 491 )

#pragma data_seg("seg00492")
MAKE_SEGMENT_BODY( Segment00492, 492 )

#pragma data_seg("seg00493")
MAKE_SEGMENT_BODY( Segment00493, 493 )

#pragma data_seg("seg00494")
MAKE_SEGMENT_BODY( Segment00494, 494 )

#pragma data_seg("seg00495")
MAKE_SEGMENT_BODY( Segment00495, 495 )

#pragma data_seg("seg00496")
MAKE_SEGMENT_BODY( Segment00496, 496 )

#pragma data_seg("seg00497")
MAKE_SEGMENT_BODY( Segment00497, 497 )

#pragma data_seg("seg00498")
MAKE_SEGMENT_BODY( Segment00498, 498 )

#pragma data_seg("seg00499")
MAKE_SEGMENT_BODY( Segment00499, 499 )

#pragma data_seg("seg00500")
MAKE_SEGMENT_BODY( Segment00500, 500 )

#pragma data_seg("seg00501")
MAKE_SEGMENT_BODY( Segment00501, 501 )

#pragma data_seg("seg00502")
MAKE_SEGMENT_BODY( Segment00502, 502 )

#pragma data_seg("seg00503")
MAKE_SEGMENT_BODY( Segment00503, 503 )

#pragma data_seg("seg00504")
MAKE_SEGMENT_BODY( Segment00504, 504 )

#pragma data_seg("seg00505")
MAKE_SEGMENT_BODY( Segment00505, 505 )

#pragma data_seg("seg00506")
MAKE_SEGMENT_BODY( Segment00506, 506 )

#pragma data_seg("seg00507")
MAKE_SEGMENT_BODY( Segment00507, 507 )

#pragma data_seg("seg00508")
MAKE_SEGMENT_BODY( Segment00508, 508 )

#pragma data_seg("seg00509")
MAKE_SEGMENT_BODY( Segment00509, 509 )

#pragma data_seg("seg00510")
MAKE_SEGMENT_BODY( Segment00510, 510 )

#pragma data_seg("seg00511")
MAKE_SEGMENT_BODY( Segment00511, 511 )

#pragma data_seg("seg00512")
MAKE_SEGMENT_BODY( Segment00512, 512 )

#pragma data_seg("seg00513")
MAKE_SEGMENT_BODY( Segment00513, 513 )

#pragma data_seg("seg00514")
MAKE_SEGMENT_BODY( Segment00514, 514 )

#pragma data_seg("seg00515")
MAKE_SEGMENT_BODY( Segment00515, 515 )

#pragma data_seg("seg00516")
MAKE_SEGMENT_BODY( Segment00516, 516 )

#pragma data_seg("seg00517")
MAKE_SEGMENT_BODY( Segment00517, 517 )

#pragma data_seg("seg00518")
MAKE_SEGMENT_BODY( Segment00518, 518 )

#pragma data_seg("seg00519")
MAKE_SEGMENT_BODY( Segment00519, 519 )

#pragma data_seg("seg00520")
MAKE_SEGMENT_BODY( Segment00520, 520 )

#pragma data_seg("seg00521")
MAKE_SEGMENT_BODY( Segment00521, 521 )

#pragma data_seg("seg00522")
MAKE_SEGMENT_BODY( Segment00522, 522 )

#pragma data_seg("seg00523")
MAKE_SEGMENT_BODY( Segment00523, 523 )

#pragma data_seg("seg00524")
MAKE_SEGMENT_BODY( Segment00524, 524 )

#pragma data_seg("seg00525")
MAKE_SEGMENT_BODY( Segment00525, 525 )

#pragma data_seg("seg00526")
MAKE_SEGMENT_BODY( Segment00526, 526 )

#pragma data_seg("seg00527")
MAKE_SEGMENT_BODY( Segment00527, 527 )

#pragma data_seg("seg00528")
MAKE_SEGMENT_BODY( Segment00528, 528 )

#pragma data_seg("seg00529")
MAKE_SEGMENT_BODY( Segment00529, 529 )

#pragma data_seg("seg00530")
MAKE_SEGMENT_BODY( Segment00530, 530 )

#pragma data_seg("seg00531")
MAKE_SEGMENT_BODY( Segment00531, 531 )

#pragma data_seg("seg00532")
MAKE_SEGMENT_BODY( Segment00532, 532 )

#pragma data_seg("seg00533")
MAKE_SEGMENT_BODY( Segment00533, 533 )

#pragma data_seg("seg00534")
MAKE_SEGMENT_BODY( Segment00534, 534 )

#pragma data_seg("seg00535")
MAKE_SEGMENT_BODY( Segment00535, 535 )

#pragma data_seg("seg00536")
MAKE_SEGMENT_BODY( Segment00536, 536 )

#pragma data_seg("seg00537")
MAKE_SEGMENT_BODY( Segment00537, 537 )

#pragma data_seg("seg00538")
MAKE_SEGMENT_BODY( Segment00538, 538 )

#pragma data_seg("seg00539")
MAKE_SEGMENT_BODY( Segment00539, 539 )

#pragma data_seg("seg00540")
MAKE_SEGMENT_BODY( Segment00540, 540 )

#pragma data_seg("seg00541")
MAKE_SEGMENT_BODY( Segment00541, 541 )

#pragma data_seg("seg00542")
MAKE_SEGMENT_BODY( Segment00542, 542 )

#pragma data_seg("seg00543")
MAKE_SEGMENT_BODY( Segment00543, 543 )

#pragma data_seg("seg00544")
MAKE_SEGMENT_BODY( Segment00544, 544 )

#pragma data_seg("seg00545")
MAKE_SEGMENT_BODY( Segment00545, 545 )

#pragma data_seg("seg00546")
MAKE_SEGMENT_BODY( Segment00546, 546 )

#pragma data_seg("seg00547")
MAKE_SEGMENT_BODY( Segment00547, 547 )

#pragma data_seg("seg00548")
MAKE_SEGMENT_BODY( Segment00548, 548 )

#pragma data_seg("seg00549")
MAKE_SEGMENT_BODY( Segment00549, 549 )

#pragma data_seg("seg00550")
MAKE_SEGMENT_BODY( Segment00550, 550 )

#pragma data_seg("seg00551")
MAKE_SEGMENT_BODY( Segment00551, 551 )

#pragma data_seg("seg00552")
MAKE_SEGMENT_BODY( Segment00552, 552 )

#pragma data_seg("seg00553")
MAKE_SEGMENT_BODY( Segment00553, 553 )

#pragma data_seg("seg00554")
MAKE_SEGMENT_BODY( Segment00554, 554 )

#pragma data_seg("seg00555")
MAKE_SEGMENT_BODY( Segment00555, 555 )

#pragma data_seg("seg00556")
MAKE_SEGMENT_BODY( Segment00556, 556 )

#pragma data_seg("seg00557")
MAKE_SEGMENT_BODY( Segment00557, 557 )

#pragma data_seg("seg00558")
MAKE_SEGMENT_BODY( Segment00558, 558 )

#pragma data_seg("seg00559")
MAKE_SEGMENT_BODY( Segment00559, 559 )

#pragma data_seg("seg00560")
MAKE_SEGMENT_BODY( Segment00560, 560 )

#pragma data_seg("seg00561")
MAKE_SEGMENT_BODY( Segment00561, 561 )

#pragma data_seg("seg00562")
MAKE_SEGMENT_BODY( Segment00562, 562 )

#pragma data_seg("seg00563")
MAKE_SEGMENT_BODY( Segment00563, 563 )

#pragma data_seg("seg00564")
MAKE_SEGMENT_BODY( Segment00564, 564 )

#pragma data_seg("seg00565")
MAKE_SEGMENT_BODY( Segment00565, 565 )

#pragma data_seg("seg00566")
MAKE_SEGMENT_BODY( Segment00566, 566 )

#pragma data_seg("seg00567")
MAKE_SEGMENT_BODY( Segment00567, 567 )

#pragma data_seg("seg00568")
MAKE_SEGMENT_BODY( Segment00568, 568 )

#pragma data_seg("seg00569")
MAKE_SEGMENT_BODY( Segment00569, 569 )

#pragma data_seg("seg00570")
MAKE_SEGMENT_BODY( Segment00570, 570 )

#pragma data_seg("seg00571")
MAKE_SEGMENT_BODY( Segment00571, 571 )

#pragma data_seg("seg00572")
MAKE_SEGMENT_BODY( Segment00572, 572 )

#pragma data_seg("seg00573")
MAKE_SEGMENT_BODY( Segment00573, 573 )

#pragma data_seg("seg00574")
MAKE_SEGMENT_BODY( Segment00574, 574 )

#pragma data_seg("seg00575")
MAKE_SEGMENT_BODY( Segment00575, 575 )

#pragma data_seg("seg00576")
MAKE_SEGMENT_BODY( Segment00576, 576 )

#pragma data_seg("seg00577")
MAKE_SEGMENT_BODY( Segment00577, 577 )

#pragma data_seg("seg00578")
MAKE_SEGMENT_BODY( Segment00578, 578 )

#pragma data_seg("seg00579")
MAKE_SEGMENT_BODY( Segment00579, 579 )

#pragma data_seg("seg00580")
MAKE_SEGMENT_BODY( Segment00580, 580 )

#pragma data_seg("seg00581")
MAKE_SEGMENT_BODY( Segment00581, 581 )

#pragma data_seg("seg00582")
MAKE_SEGMENT_BODY( Segment00582, 582 )

#pragma data_seg("seg00583")
MAKE_SEGMENT_BODY( Segment00583, 583 )

#pragma data_seg("seg00584")
MAKE_SEGMENT_BODY( Segment00584, 584 )

#pragma data_seg("seg00585")
MAKE_SEGMENT_BODY( Segment00585, 585 )

#pragma data_seg("seg00586")
MAKE_SEGMENT_BODY( Segment00586, 586 )

#pragma data_seg("seg00587")
MAKE_SEGMENT_BODY( Segment00587, 587 )

#pragma data_seg("seg00588")
MAKE_SEGMENT_BODY( Segment00588, 588 )

#pragma data_seg("seg00589")
MAKE_SEGMENT_BODY( Segment00589, 589 )

#pragma data_seg("seg00590")
MAKE_SEGMENT_BODY( Segment00590, 590 )

#pragma data_seg("seg00591")
MAKE_SEGMENT_BODY( Segment00591, 591 )

#pragma data_seg("seg00592")
MAKE_SEGMENT_BODY( Segment00592, 592 )

#pragma data_seg("seg00593")
MAKE_SEGMENT_BODY( Segment00593, 593 )

#pragma data_seg("seg00594")
MAKE_SEGMENT_BODY( Segment00594, 594 )

#pragma data_seg("seg00595")
MAKE_SEGMENT_BODY( Segment00595, 595 )

#pragma data_seg("seg00596")
MAKE_SEGMENT_BODY( Segment00596, 596 )

#pragma data_seg("seg00597")
MAKE_SEGMENT_BODY( Segment00597, 597 )

#pragma data_seg("seg00598")
MAKE_SEGMENT_BODY( Segment00598, 598 )

#pragma data_seg("seg00599")
MAKE_SEGMENT_BODY( Segment00599, 599 )

#pragma data_seg("seg00600")
MAKE_SEGMENT_BODY( Segment00600, 600 )

#pragma data_seg("seg00601")
MAKE_SEGMENT_BODY( Segment00601, 601 )

#pragma data_seg("seg00602")
MAKE_SEGMENT_BODY( Segment00602, 602 )

#pragma data_seg("seg00603")
MAKE_SEGMENT_BODY( Segment00603, 603 )

#pragma data_seg("seg00604")
MAKE_SEGMENT_BODY( Segment00604, 604 )

#pragma data_seg("seg00605")
MAKE_SEGMENT_BODY( Segment00605, 605 )

#pragma data_seg("seg00606")
MAKE_SEGMENT_BODY( Segment00606, 606 )

#pragma data_seg("seg00607")
MAKE_SEGMENT_BODY( Segment00607, 607 )

#pragma data_seg("seg00608")
MAKE_SEGMENT_BODY( Segment00608, 608 )

#pragma data_seg("seg00609")
MAKE_SEGMENT_BODY( Segment00609, 609 )

#pragma data_seg("seg00610")
MAKE_SEGMENT_BODY( Segment00610, 610 )

#pragma data_seg("seg00611")
MAKE_SEGMENT_BODY( Segment00611, 611 )

#pragma data_seg("seg00612")
MAKE_SEGMENT_BODY( Segment00612, 612 )

#pragma data_seg("seg00613")
MAKE_SEGMENT_BODY( Segment00613, 613 )

#pragma data_seg("seg00614")
MAKE_SEGMENT_BODY( Segment00614, 614 )

#pragma data_seg("seg00615")
MAKE_SEGMENT_BODY( Segment00615, 615 )

#pragma data_seg("seg00616")
MAKE_SEGMENT_BODY( Segment00616, 616 )

#pragma data_seg("seg00617")
MAKE_SEGMENT_BODY( Segment00617, 617 )

#pragma data_seg("seg00618")
MAKE_SEGMENT_BODY( Segment00618, 618 )

#pragma data_seg("seg00619")
MAKE_SEGMENT_BODY( Segment00619, 619 )

#pragma data_seg("seg00620")
MAKE_SEGMENT_BODY( Segment00620, 620 )

#pragma data_seg("seg00621")
MAKE_SEGMENT_BODY( Segment00621, 621 )

#pragma data_seg("seg00622")
MAKE_SEGMENT_BODY( Segment00622, 622 )

#pragma data_seg("seg00623")
MAKE_SEGMENT_BODY( Segment00623, 623 )

#pragma data_seg("seg00624")
MAKE_SEGMENT_BODY( Segment00624, 624 )

#pragma data_seg("seg00625")
MAKE_SEGMENT_BODY( Segment00625, 625 )

#pragma data_seg("seg00626")
MAKE_SEGMENT_BODY( Segment00626, 626 )

#pragma data_seg("seg00627")
MAKE_SEGMENT_BODY( Segment00627, 627 )

#pragma data_seg("seg00628")
MAKE_SEGMENT_BODY( Segment00628, 628 )

#pragma data_seg("seg00629")
MAKE_SEGMENT_BODY( Segment00629, 629 )

#pragma data_seg("seg00630")
MAKE_SEGMENT_BODY( Segment00630, 630 )

#pragma data_seg("seg00631")
MAKE_SEGMENT_BODY( Segment00631, 631 )
char seg_cSegment00631bonus[1024*1024] = {0};

#pragma data_seg("seg00632")
MAKE_SEGMENT_BODY( Segment00632, 632 )

#pragma data_seg("seg00633")
MAKE_SEGMENT_BODY( Segment00633, 633 )

#pragma data_seg("seg00634")
MAKE_SEGMENT_BODY( Segment00634, 634 )

#pragma data_seg("seg00635")
MAKE_SEGMENT_BODY( Segment00635, 635 )

#pragma data_seg("seg00636")
MAKE_SEGMENT_BODY( Segment00636, 636 )

#pragma data_seg("seg00637")
MAKE_SEGMENT_BODY( Segment00637, 637 )

#pragma data_seg("seg00638")
MAKE_SEGMENT_BODY( Segment00638, 638 )

#pragma data_seg("seg00639")
MAKE_SEGMENT_BODY( Segment00639, 639 )

#pragma data_seg("seg00640")
MAKE_SEGMENT_BODY( Segment00640, 640 )

#pragma data_seg("seg00641")
MAKE_SEGMENT_BODY( Segment00641, 641 )

#pragma data_seg("seg00642")
MAKE_SEGMENT_BODY( Segment00642, 642 )

#pragma data_seg("seg00643")
MAKE_SEGMENT_BODY( Segment00643, 643 )

#pragma data_seg("seg00644")
MAKE_SEGMENT_BODY( Segment00644, 644 )

#pragma data_seg("seg00645")
MAKE_SEGMENT_BODY( Segment00645, 645 )

#pragma data_seg("seg00646")
MAKE_SEGMENT_BODY( Segment00646, 646 )

#pragma data_seg("seg00647")
MAKE_SEGMENT_BODY( Segment00647, 647 )

#pragma data_seg("seg00648")
MAKE_SEGMENT_BODY( Segment00648, 648 )

#pragma data_seg("seg00649")
MAKE_SEGMENT_BODY( Segment00649, 649 )

#pragma data_seg("seg00650")
MAKE_SEGMENT_BODY( Segment00650, 650 )

#pragma data_seg("seg00651")
MAKE_SEGMENT_BODY( Segment00651, 651 )

#pragma data_seg("seg00652")
MAKE_SEGMENT_BODY( Segment00652, 652 )

#pragma data_seg("seg00653")
MAKE_SEGMENT_BODY( Segment00653, 653 )

#pragma data_seg("seg00654")
MAKE_SEGMENT_BODY( Segment00654, 654 )

#pragma data_seg("seg00655")
MAKE_SEGMENT_BODY( Segment00655, 655 )

#pragma data_seg("seg00656")
MAKE_SEGMENT_BODY( Segment00656, 656 )

#pragma data_seg("seg00657")
MAKE_SEGMENT_BODY( Segment00657, 657 )

#pragma data_seg("seg00658")
MAKE_SEGMENT_BODY( Segment00658, 658 )

#pragma data_seg("seg00659")
MAKE_SEGMENT_BODY( Segment00659, 659 )

#pragma data_seg("seg00660")
MAKE_SEGMENT_BODY( Segment00660, 660 )

#pragma data_seg("seg00661")
MAKE_SEGMENT_BODY( Segment00661, 661 )

#pragma data_seg("seg00662")
MAKE_SEGMENT_BODY( Segment00662, 662 )

#pragma data_seg("seg00663")
MAKE_SEGMENT_BODY( Segment00663, 663 )

#pragma data_seg("seg00664")
MAKE_SEGMENT_BODY( Segment00664, 664 )

#pragma data_seg("seg00665")
MAKE_SEGMENT_BODY( Segment00665, 665 )

#pragma data_seg("seg00666")
MAKE_SEGMENT_BODY( Segment00666, 666 )

#pragma data_seg("seg00667")
MAKE_SEGMENT_BODY( Segment00667, 667 )

#pragma data_seg("seg00668")
MAKE_SEGMENT_BODY( Segment00668, 668 )

#pragma data_seg("seg00669")
MAKE_SEGMENT_BODY( Segment00669, 669 )

#pragma data_seg("seg00670")
MAKE_SEGMENT_BODY( Segment00670, 670 )

#pragma data_seg("seg00671")
MAKE_SEGMENT_BODY( Segment00671, 671 )

#pragma data_seg("seg00672")
MAKE_SEGMENT_BODY( Segment00672, 672 )

#pragma data_seg("seg00673")
MAKE_SEGMENT_BODY( Segment00673, 673 )

#pragma data_seg("seg00674")
MAKE_SEGMENT_BODY( Segment00674, 674 )

#pragma data_seg("seg00675")
MAKE_SEGMENT_BODY( Segment00675, 675 )

#pragma data_seg("seg00676")
MAKE_SEGMENT_BODY( Segment00676, 676 )

#pragma data_seg("seg00677")
MAKE_SEGMENT_BODY( Segment00677, 677 )

#pragma data_seg("seg00678")
MAKE_SEGMENT_BODY( Segment00678, 678 )

#pragma data_seg("seg00679")
MAKE_SEGMENT_BODY( Segment00679, 679 )

#pragma data_seg("seg00680")
MAKE_SEGMENT_BODY( Segment00680, 680 )

#pragma data_seg("seg00681")
MAKE_SEGMENT_BODY( Segment00681, 681 )

#pragma data_seg("seg00682")
MAKE_SEGMENT_BODY( Segment00682, 682 )

#pragma data_seg("seg00683")
MAKE_SEGMENT_BODY( Segment00683, 683 )

#pragma data_seg("seg00684")
MAKE_SEGMENT_BODY( Segment00684, 684 )

#pragma data_seg("seg00685")
MAKE_SEGMENT_BODY( Segment00685, 685 )

#pragma data_seg("seg00686")
MAKE_SEGMENT_BODY( Segment00686, 686 )

#pragma data_seg("seg00687")
MAKE_SEGMENT_BODY( Segment00687, 687 )

#pragma data_seg("seg00688")
MAKE_SEGMENT_BODY( Segment00688, 688 )

#pragma data_seg("seg00689")
MAKE_SEGMENT_BODY( Segment00689, 689 )

#pragma data_seg("seg00690")
MAKE_SEGMENT_BODY( Segment00690, 690 )

#pragma data_seg("seg00691")
MAKE_SEGMENT_BODY( Segment00691, 691 )

#pragma data_seg("seg00692")
MAKE_SEGMENT_BODY( Segment00692, 692 )

#pragma data_seg("seg00693")
MAKE_SEGMENT_BODY( Segment00693, 693 )

#pragma data_seg("seg00694")
MAKE_SEGMENT_BODY( Segment00694, 694 )

#pragma data_seg("seg00695")
MAKE_SEGMENT_BODY( Segment00695, 695 )

#pragma data_seg("seg00696")
MAKE_SEGMENT_BODY( Segment00696, 696 )

#pragma data_seg("seg00697")
MAKE_SEGMENT_BODY( Segment00697, 697 )

#pragma data_seg("seg00698")
MAKE_SEGMENT_BODY( Segment00698, 698 )

#pragma data_seg("seg00699")
MAKE_SEGMENT_BODY( Segment00699, 699 )

#pragma data_seg("seg00700")
MAKE_SEGMENT_BODY( Segment00700, 700 )

#pragma data_seg("seg00701")
MAKE_SEGMENT_BODY( Segment00701, 701 )

#pragma data_seg("seg00702")
MAKE_SEGMENT_BODY( Segment00702, 702 )

#pragma data_seg("seg00703")
MAKE_SEGMENT_BODY( Segment00703, 703 )

#pragma data_seg("seg00704")
MAKE_SEGMENT_BODY( Segment00704, 704 )

#pragma data_seg("seg00705")
MAKE_SEGMENT_BODY( Segment00705, 705 )

#pragma data_seg("seg00706")
MAKE_SEGMENT_BODY( Segment00706, 706 )

#pragma data_seg("seg00707")
MAKE_SEGMENT_BODY( Segment00707, 707 )

#pragma data_seg("seg00708")
MAKE_SEGMENT_BODY( Segment00708, 708 )

#pragma data_seg("seg00709")
MAKE_SEGMENT_BODY( Segment00709, 709 )

#pragma data_seg("seg00710")
MAKE_SEGMENT_BODY( Segment00710, 710 )

#pragma data_seg("seg00711")
MAKE_SEGMENT_BODY( Segment00711, 711 )

#pragma data_seg("seg00712")
MAKE_SEGMENT_BODY( Segment00712, 712 )

#pragma data_seg("seg00713")
MAKE_SEGMENT_BODY( Segment00713, 713 )

#pragma data_seg("seg00714")
MAKE_SEGMENT_BODY( Segment00714, 714 )

#pragma data_seg("seg00715")
MAKE_SEGMENT_BODY( Segment00715, 715 )

#pragma data_seg("seg00716")
MAKE_SEGMENT_BODY( Segment00716, 716 )

#pragma data_seg("seg00717")
MAKE_SEGMENT_BODY( Segment00717, 717 )

#pragma data_seg("seg00718")
MAKE_SEGMENT_BODY( Segment00718, 718 )

#pragma data_seg("seg00719")
MAKE_SEGMENT_BODY( Segment00719, 719 )

#pragma data_seg("seg00720")
MAKE_SEGMENT_BODY( Segment00720, 720 )

#pragma data_seg("seg00721")
MAKE_SEGMENT_BODY( Segment00721, 721 )

#pragma data_seg("seg00722")
MAKE_SEGMENT_BODY( Segment00722, 722 )

#pragma data_seg("seg00723")
MAKE_SEGMENT_BODY( Segment00723, 723 )

#pragma data_seg("seg00724")
MAKE_SEGMENT_BODY( Segment00724, 724 )

#pragma data_seg("seg00725")
MAKE_SEGMENT_BODY( Segment00725, 725 )

#pragma data_seg("seg00726")
MAKE_SEGMENT_BODY( Segment00726, 726 )

#pragma data_seg("seg00727")
MAKE_SEGMENT_BODY( Segment00727, 727 )

#pragma data_seg("seg00728")
MAKE_SEGMENT_BODY( Segment00728, 728 )

#pragma data_seg("seg00729")
MAKE_SEGMENT_BODY( Segment00729, 729 )

#pragma data_seg("seg00730")
MAKE_SEGMENT_BODY( Segment00730, 730 )

#pragma data_seg("seg00731")
MAKE_SEGMENT_BODY( Segment00731, 731 )

#pragma data_seg("seg00732")
MAKE_SEGMENT_BODY( Segment00732, 732 )

#pragma data_seg("seg00733")
MAKE_SEGMENT_BODY( Segment00733, 733 )

#pragma data_seg("seg00734")
MAKE_SEGMENT_BODY( Segment00734, 734 )

#pragma data_seg("seg00735")
MAKE_SEGMENT_BODY( Segment00735, 735 )

#pragma data_seg("seg00736")
MAKE_SEGMENT_BODY( Segment00736, 736 )

#pragma data_seg("seg00737")
MAKE_SEGMENT_BODY( Segment00737, 737 )

#pragma data_seg("seg00738")
MAKE_SEGMENT_BODY( Segment00738, 738 )

#pragma data_seg("seg00739")
MAKE_SEGMENT_BODY( Segment00739, 739 )

#pragma data_seg("seg00740")
MAKE_SEGMENT_BODY( Segment00740, 740 )

#pragma data_seg("seg00741")
MAKE_SEGMENT_BODY( Segment00741, 741 )

#pragma data_seg("seg00742")
MAKE_SEGMENT_BODY( Segment00742, 742 )

#pragma data_seg("seg00743")
MAKE_SEGMENT_BODY( Segment00743, 743 )

#pragma data_seg("seg00744")
MAKE_SEGMENT_BODY( Segment00744, 744 )

#pragma data_seg("seg00745")
MAKE_SEGMENT_BODY( Segment00745, 745 )

#pragma data_seg("seg00746")
MAKE_SEGMENT_BODY( Segment00746, 746 )

#pragma data_seg("seg00747")
MAKE_SEGMENT_BODY( Segment00747, 747 )

#pragma data_seg("seg00748")
MAKE_SEGMENT_BODY( Segment00748, 748 )

#pragma data_seg("seg00749")
MAKE_SEGMENT_BODY( Segment00749, 749 )

#pragma data_seg("seg00750")
MAKE_SEGMENT_BODY( Segment00750, 750 )

#pragma data_seg("seg00751")
MAKE_SEGMENT_BODY( Segment00751, 751 )

#pragma data_seg("seg00752")
MAKE_SEGMENT_BODY( Segment00752, 752 )

#pragma data_seg("seg00753")
MAKE_SEGMENT_BODY( Segment00753, 753 )

#pragma data_seg("seg00754")
MAKE_SEGMENT_BODY( Segment00754, 754 )

#pragma data_seg("seg00755")
MAKE_SEGMENT_BODY( Segment00755, 755 )

#pragma data_seg("seg00756")
MAKE_SEGMENT_BODY( Segment00756, 756 )

#pragma data_seg("seg00757")
MAKE_SEGMENT_BODY( Segment00757, 757 )

#pragma data_seg("seg00758")
MAKE_SEGMENT_BODY( Segment00758, 758 )

#pragma data_seg("seg00759")
MAKE_SEGMENT_BODY( Segment00759, 759 )

#pragma data_seg("seg00760")
MAKE_SEGMENT_BODY( Segment00760, 760 )

#pragma data_seg("seg00761")
MAKE_SEGMENT_BODY( Segment00761, 761 )

#pragma data_seg("seg00762")
MAKE_SEGMENT_BODY( Segment00762, 762 )

#pragma data_seg("seg00763")
MAKE_SEGMENT_BODY( Segment00763, 763 )

#pragma data_seg("seg00764")
MAKE_SEGMENT_BODY( Segment00764, 764 )

#pragma data_seg("seg00765")
MAKE_SEGMENT_BODY( Segment00765, 765 )

#pragma data_seg("seg00766")
MAKE_SEGMENT_BODY( Segment00766, 766 )

#pragma data_seg("seg00767")
MAKE_SEGMENT_BODY( Segment00767, 767 )

#pragma data_seg("seg00768")
MAKE_SEGMENT_BODY( Segment00768, 768 )

#pragma data_seg("seg00769")
MAKE_SEGMENT_BODY( Segment00769, 769 )

#pragma data_seg("seg00770")
MAKE_SEGMENT_BODY( Segment00770, 770 )

#pragma data_seg("seg00771")
MAKE_SEGMENT_BODY( Segment00771, 771 )

#pragma data_seg("seg00772")
MAKE_SEGMENT_BODY( Segment00772, 772 )

#pragma data_seg("seg00773")
MAKE_SEGMENT_BODY( Segment00773, 773 )

#pragma data_seg("seg00774")
MAKE_SEGMENT_BODY( Segment00774, 774 )

#pragma data_seg("seg00775")
MAKE_SEGMENT_BODY( Segment00775, 775 )

#pragma data_seg("seg00776")
MAKE_SEGMENT_BODY( Segment00776, 776 )

#pragma data_seg("seg00777")
MAKE_SEGMENT_BODY( Segment00777, 777 )

#pragma data_seg("seg00778")
MAKE_SEGMENT_BODY( Segment00778, 778 )

#pragma data_seg("seg00779")
MAKE_SEGMENT_BODY( Segment00779, 779 )

#pragma data_seg("seg00780")
MAKE_SEGMENT_BODY( Segment00780, 780 )

#pragma data_seg("seg00781")
MAKE_SEGMENT_BODY( Segment00781, 781 )

#pragma data_seg("seg00782")
MAKE_SEGMENT_BODY( Segment00782, 782 )

#pragma data_seg("seg00783")
MAKE_SEGMENT_BODY( Segment00783, 783 )

#pragma data_seg("seg00784")
MAKE_SEGMENT_BODY( Segment00784, 784 )

#pragma data_seg("seg00785")
MAKE_SEGMENT_BODY( Segment00785, 785 )

#pragma data_seg("seg00786")
MAKE_SEGMENT_BODY( Segment00786, 786 )

#pragma data_seg("seg00787")
MAKE_SEGMENT_BODY( Segment00787, 787 )

#pragma data_seg("seg00788")
MAKE_SEGMENT_BODY( Segment00788, 788 )

#pragma data_seg("seg00789")
MAKE_SEGMENT_BODY( Segment00789, 789 )

#pragma data_seg("seg00790")
MAKE_SEGMENT_BODY( Segment00790, 790 )

#pragma data_seg("seg00791")
MAKE_SEGMENT_BODY( Segment00791, 791 )

#pragma data_seg("seg00792")
MAKE_SEGMENT_BODY( Segment00792, 792 )

#pragma data_seg("seg00793")
MAKE_SEGMENT_BODY( Segment00793, 793 )

#pragma data_seg("seg00794")
MAKE_SEGMENT_BODY( Segment00794, 794 )

#pragma data_seg("seg00795")
MAKE_SEGMENT_BODY( Segment00795, 795 )

#pragma data_seg("seg00796")
MAKE_SEGMENT_BODY( Segment00796, 796 )

#pragma data_seg("seg00797")
MAKE_SEGMENT_BODY( Segment00797, 797 )

#pragma data_seg("seg00798")
MAKE_SEGMENT_BODY( Segment00798, 798 )

#pragma data_seg("seg00799")
MAKE_SEGMENT_BODY( Segment00799, 799 )

#pragma data_seg("seg00800")
MAKE_SEGMENT_BODY( Segment00800, 800 )

#pragma data_seg("seg00801")
MAKE_SEGMENT_BODY( Segment00801, 801 )

#pragma data_seg("seg00802")
MAKE_SEGMENT_BODY( Segment00802, 802 )

#pragma data_seg("seg00803")
MAKE_SEGMENT_BODY( Segment00803, 803 )

#pragma data_seg("seg00804")
MAKE_SEGMENT_BODY( Segment00804, 804 )

#pragma data_seg("seg00805")
MAKE_SEGMENT_BODY( Segment00805, 805 )

#pragma data_seg("seg00806")
MAKE_SEGMENT_BODY( Segment00806, 806 )

#pragma data_seg("seg00807")
MAKE_SEGMENT_BODY( Segment00807, 807 )

#pragma data_seg("seg00808")
MAKE_SEGMENT_BODY( Segment00808, 808 )

#pragma data_seg("seg00809")
MAKE_SEGMENT_BODY( Segment00809, 809 )

#pragma data_seg("seg00810")
MAKE_SEGMENT_BODY( Segment00810, 810 )

#pragma data_seg("seg00811")
MAKE_SEGMENT_BODY( Segment00811, 811 )

#pragma data_seg("seg00812")
MAKE_SEGMENT_BODY( Segment00812, 812 )

#pragma data_seg("seg00813")
MAKE_SEGMENT_BODY( Segment00813, 813 )

#pragma data_seg("seg00814")
MAKE_SEGMENT_BODY( Segment00814, 814 )

#pragma data_seg("seg00815")
MAKE_SEGMENT_BODY( Segment00815, 815 )

#pragma data_seg("seg00816")
MAKE_SEGMENT_BODY( Segment00816, 816 )

#pragma data_seg("seg00817")
MAKE_SEGMENT_BODY( Segment00817, 817 )

#pragma data_seg("seg00818")
MAKE_SEGMENT_BODY( Segment00818, 818 )

#pragma data_seg("seg00819")
MAKE_SEGMENT_BODY( Segment00819, 819 )

#pragma data_seg("seg00820")
MAKE_SEGMENT_BODY( Segment00820, 820 )

#pragma data_seg("seg00821")
MAKE_SEGMENT_BODY( Segment00821, 821 )

#pragma data_seg("seg00822")
MAKE_SEGMENT_BODY( Segment00822, 822 )

#pragma data_seg("seg00823")
MAKE_SEGMENT_BODY( Segment00823, 823 )

#pragma data_seg("seg00824")
MAKE_SEGMENT_BODY( Segment00824, 824 )

#pragma data_seg("seg00825")
MAKE_SEGMENT_BODY( Segment00825, 825 )

#pragma data_seg("seg00826")
MAKE_SEGMENT_BODY( Segment00826, 826 )

#pragma data_seg("seg00827")
MAKE_SEGMENT_BODY( Segment00827, 827 )

#pragma data_seg("seg00828")
MAKE_SEGMENT_BODY( Segment00828, 828 )

#pragma data_seg("seg00829")
MAKE_SEGMENT_BODY( Segment00829, 829 )

#pragma data_seg("seg00830")
MAKE_SEGMENT_BODY( Segment00830, 830 )

#pragma data_seg("seg00831")
MAKE_SEGMENT_BODY( Segment00831, 831 )

#pragma data_seg("seg00832")
MAKE_SEGMENT_BODY( Segment00832, 832 )

#pragma data_seg("seg00833")
MAKE_SEGMENT_BODY( Segment00833, 833 )

#pragma data_seg("seg00834")
MAKE_SEGMENT_BODY( Segment00834, 834 )

#pragma data_seg("seg00835")
MAKE_SEGMENT_BODY( Segment00835, 835 )

#pragma data_seg("seg00836")
MAKE_SEGMENT_BODY( Segment00836, 836 )

#pragma data_seg("seg00837")
MAKE_SEGMENT_BODY( Segment00837, 837 )

#pragma data_seg("seg00838")
MAKE_SEGMENT_BODY( Segment00838, 838 )

#pragma data_seg("seg00839")
MAKE_SEGMENT_BODY( Segment00839, 839 )

#pragma data_seg("seg00840")
MAKE_SEGMENT_BODY( Segment00840, 840 )

#pragma data_seg("seg00841")
MAKE_SEGMENT_BODY( Segment00841, 841 )

#pragma data_seg("seg00842")
MAKE_SEGMENT_BODY( Segment00842, 842 )

#pragma data_seg("seg00843")
MAKE_SEGMENT_BODY( Segment00843, 843 )

#pragma data_seg("seg00844")
MAKE_SEGMENT_BODY( Segment00844, 844 )

#pragma data_seg("seg00845")
MAKE_SEGMENT_BODY( Segment00845, 845 )

#pragma data_seg("seg00846")
MAKE_SEGMENT_BODY( Segment00846, 846 )

#pragma data_seg("seg00847")
MAKE_SEGMENT_BODY( Segment00847, 847 )

#pragma data_seg("seg00848")
MAKE_SEGMENT_BODY( Segment00848, 848 )

#pragma data_seg("seg00849")
MAKE_SEGMENT_BODY( Segment00849, 849 )

#pragma data_seg("seg00850")
MAKE_SEGMENT_BODY( Segment00850, 850 )

#pragma data_seg("seg00851")
MAKE_SEGMENT_BODY( Segment00851, 851 )

#pragma data_seg("seg00852")
MAKE_SEGMENT_BODY( Segment00852, 852 )

#pragma data_seg("seg00853")
MAKE_SEGMENT_BODY( Segment00853, 853 )

#pragma data_seg("seg00854")
MAKE_SEGMENT_BODY( Segment00854, 854 )

#pragma data_seg("seg00855")
MAKE_SEGMENT_BODY( Segment00855, 855 )

#pragma data_seg("seg00856")
MAKE_SEGMENT_BODY( Segment00856, 856 )

#pragma data_seg("seg00857")
MAKE_SEGMENT_BODY( Segment00857, 857 )

#pragma data_seg("seg00858")
MAKE_SEGMENT_BODY( Segment00858, 858 )

#pragma data_seg("seg00859")
MAKE_SEGMENT_BODY( Segment00859, 859 )

#pragma data_seg("seg00860")
MAKE_SEGMENT_BODY( Segment00860, 860 )

#pragma data_seg("seg00861")
MAKE_SEGMENT_BODY( Segment00861, 861 )

#pragma data_seg("seg00862")
MAKE_SEGMENT_BODY( Segment00862, 862 )

#pragma data_seg("seg00863")
MAKE_SEGMENT_BODY( Segment00863, 863 )

#pragma data_seg("seg00864")
MAKE_SEGMENT_BODY( Segment00864, 864 )

#pragma data_seg("seg00865")
MAKE_SEGMENT_BODY( Segment00865, 865 )

#pragma data_seg("seg00866")
MAKE_SEGMENT_BODY( Segment00866, 866 )

#pragma data_seg("seg00867")
MAKE_SEGMENT_BODY( Segment00867, 867 )

#pragma data_seg("seg00868")
MAKE_SEGMENT_BODY( Segment00868, 868 )

#pragma data_seg("seg00869")
MAKE_SEGMENT_BODY( Segment00869, 869 )

#pragma data_seg("seg00870")
MAKE_SEGMENT_BODY( Segment00870, 870 )

#pragma data_seg("seg00871")
MAKE_SEGMENT_BODY( Segment00871, 871 )

#pragma data_seg("seg00872")
MAKE_SEGMENT_BODY( Segment00872, 872 )

#pragma data_seg("seg00873")
MAKE_SEGMENT_BODY( Segment00873, 873 )

#pragma data_seg("seg00874")
MAKE_SEGMENT_BODY( Segment00874, 874 )

#pragma data_seg("seg00875")
MAKE_SEGMENT_BODY( Segment00875, 875 )

#pragma data_seg("seg00876")
MAKE_SEGMENT_BODY( Segment00876, 876 )

#pragma data_seg("seg00877")
MAKE_SEGMENT_BODY( Segment00877, 877 )

#pragma data_seg("seg00878")
MAKE_SEGMENT_BODY( Segment00878, 878 )

#pragma data_seg("seg00879")
MAKE_SEGMENT_BODY( Segment00879, 879 )

#pragma data_seg("seg00880")
MAKE_SEGMENT_BODY( Segment00880, 880 )

#pragma data_seg("seg00881")
MAKE_SEGMENT_BODY( Segment00881, 881 )

#pragma data_seg("seg00882")
MAKE_SEGMENT_BODY( Segment00882, 882 )

#pragma data_seg("seg00883")
MAKE_SEGMENT_BODY( Segment00883, 883 )

#pragma data_seg("seg00884")
MAKE_SEGMENT_BODY( Segment00884, 884 )

#pragma data_seg("seg00885")
MAKE_SEGMENT_BODY( Segment00885, 885 )

#pragma data_seg("seg00886")
MAKE_SEGMENT_BODY( Segment00886, 886 )

#pragma data_seg("seg00887")
MAKE_SEGMENT_BODY( Segment00887, 887 )

#pragma data_seg("seg00888")
MAKE_SEGMENT_BODY( Segment00888, 888 )

#pragma data_seg("seg00889")
MAKE_SEGMENT_BODY( Segment00889, 889 )

#pragma data_seg("seg00890")
MAKE_SEGMENT_BODY( Segment00890, 890 )

#pragma data_seg("seg00891")
MAKE_SEGMENT_BODY( Segment00891, 891 )

#pragma data_seg("seg00892")
MAKE_SEGMENT_BODY( Segment00892, 892 )

#pragma data_seg("seg00893")
MAKE_SEGMENT_BODY( Segment00893, 893 )

#pragma data_seg("seg00894")
MAKE_SEGMENT_BODY( Segment00894, 894 )

#pragma data_seg("seg00895")
MAKE_SEGMENT_BODY( Segment00895, 895 )

#pragma data_seg("seg00896")
MAKE_SEGMENT_BODY( Segment00896, 896 )

#pragma data_seg("seg00897")
MAKE_SEGMENT_BODY( Segment00897, 897 )

#pragma data_seg("seg00898")
MAKE_SEGMENT_BODY( Segment00898, 898 )

#pragma data_seg("seg00899")
MAKE_SEGMENT_BODY( Segment00899, 899 )

#pragma data_seg("seg00900")
MAKE_SEGMENT_BODY( Segment00900, 900 )

#pragma data_seg("seg00901")
MAKE_SEGMENT_BODY( Segment00901, 901 )

#pragma data_seg("seg00902")
MAKE_SEGMENT_BODY( Segment00902, 902 )

#pragma data_seg("seg00903")
MAKE_SEGMENT_BODY( Segment00903, 903 )

#pragma data_seg("seg00904")
MAKE_SEGMENT_BODY( Segment00904, 904 )

#pragma data_seg("seg00905")
MAKE_SEGMENT_BODY( Segment00905, 905 )

#pragma data_seg("seg00906")
MAKE_SEGMENT_BODY( Segment00906, 906 )

#pragma data_seg("seg00907")
MAKE_SEGMENT_BODY( Segment00907, 907 )

#pragma data_seg("seg00908")
MAKE_SEGMENT_BODY( Segment00908, 908 )

#pragma data_seg("seg00909")
MAKE_SEGMENT_BODY( Segment00909, 909 )

#pragma data_seg("seg00910")
MAKE_SEGMENT_BODY( Segment00910, 910 )

#pragma data_seg("seg00911")
MAKE_SEGMENT_BODY( Segment00911, 911 )

#pragma data_seg("seg00912")
MAKE_SEGMENT_BODY( Segment00912, 912 )

#pragma data_seg("seg00913")
MAKE_SEGMENT_BODY( Segment00913, 913 )

#pragma data_seg("seg00914")
MAKE_SEGMENT_BODY( Segment00914, 914 )

#pragma data_seg("seg00915")
MAKE_SEGMENT_BODY( Segment00915, 915 )

#pragma data_seg("seg00916")
MAKE_SEGMENT_BODY( Segment00916, 916 )

#pragma data_seg("seg00917")
MAKE_SEGMENT_BODY( Segment00917, 917 )

#pragma data_seg("seg00918")
MAKE_SEGMENT_BODY( Segment00918, 918 )

#pragma data_seg("seg00919")
MAKE_SEGMENT_BODY( Segment00919, 919 )

#pragma data_seg("seg00920")
MAKE_SEGMENT_BODY( Segment00920, 920 )

#pragma data_seg("seg00921")
MAKE_SEGMENT_BODY( Segment00921, 921 )

#pragma data_seg("seg00922")
MAKE_SEGMENT_BODY( Segment00922, 922 )

#pragma data_seg("seg00923")
MAKE_SEGMENT_BODY( Segment00923, 923 )

#pragma data_seg("seg00924")
MAKE_SEGMENT_BODY( Segment00924, 924 )

#pragma data_seg("seg00925")
MAKE_SEGMENT_BODY( Segment00925, 925 )

#pragma data_seg("seg00926")
MAKE_SEGMENT_BODY( Segment00926, 926 )

#pragma data_seg("seg00927")
MAKE_SEGMENT_BODY( Segment00927, 927 )

#pragma data_seg("seg00928")
MAKE_SEGMENT_BODY( Segment00928, 928 )

#pragma data_seg("seg00929")
MAKE_SEGMENT_BODY( Segment00929, 929 )

#pragma data_seg("seg00930")
MAKE_SEGMENT_BODY( Segment00930, 930 )

#pragma data_seg("seg00931")
MAKE_SEGMENT_BODY( Segment00931, 931 )

#pragma data_seg("seg00932")
MAKE_SEGMENT_BODY( Segment00932, 932 )

#pragma data_seg("seg00933")
MAKE_SEGMENT_BODY( Segment00933, 933 )

#pragma data_seg("seg00934")
MAKE_SEGMENT_BODY( Segment00934, 934 )

#pragma data_seg("seg00935")
MAKE_SEGMENT_BODY( Segment00935, 935 )

#pragma data_seg("seg00936")
MAKE_SEGMENT_BODY( Segment00936, 936 )

#pragma data_seg("seg00937")
MAKE_SEGMENT_BODY( Segment00937, 937 )

#pragma data_seg("seg00938")
MAKE_SEGMENT_BODY( Segment00938, 938 )

#pragma data_seg("seg00939")
MAKE_SEGMENT_BODY( Segment00939, 939 )

#pragma data_seg("seg00940")
MAKE_SEGMENT_BODY( Segment00940, 940 )

#pragma data_seg("seg00941")
MAKE_SEGMENT_BODY( Segment00941, 941 )

#pragma data_seg("seg00942")
MAKE_SEGMENT_BODY( Segment00942, 942 )

#pragma data_seg("seg00943")
MAKE_SEGMENT_BODY( Segment00943, 943 )

#pragma data_seg("seg00944")
MAKE_SEGMENT_BODY( Segment00944, 944 )

#pragma data_seg("seg00945")
MAKE_SEGMENT_BODY( Segment00945, 945 )

#pragma data_seg("seg00946")
MAKE_SEGMENT_BODY( Segment00946, 946 )

#pragma data_seg("seg00947")
MAKE_SEGMENT_BODY( Segment00947, 947 )

#pragma data_seg("seg00948")
MAKE_SEGMENT_BODY( Segment00948, 948 )

#pragma data_seg("seg00949")
MAKE_SEGMENT_BODY( Segment00949, 949 )

#pragma data_seg("seg00950")
MAKE_SEGMENT_BODY( Segment00950, 950 )

#pragma data_seg("seg00951")
MAKE_SEGMENT_BODY( Segment00951, 951 )

#pragma data_seg("seg00952")
MAKE_SEGMENT_BODY( Segment00952, 952 )

#pragma data_seg("seg00953")
MAKE_SEGMENT_BODY( Segment00953, 953 )

#pragma data_seg("seg00954")
MAKE_SEGMENT_BODY( Segment00954, 954 )

#pragma data_seg("seg00955")
MAKE_SEGMENT_BODY( Segment00955, 955 )

#pragma data_seg("seg00956")
MAKE_SEGMENT_BODY( Segment00956, 956 )

#pragma data_seg("seg00957")
MAKE_SEGMENT_BODY( Segment00957, 957 )

#pragma data_seg("seg00958")
MAKE_SEGMENT_BODY( Segment00958, 958 )

#pragma data_seg("seg00959")
MAKE_SEGMENT_BODY( Segment00959, 959 )

#pragma data_seg("seg00960")
MAKE_SEGMENT_BODY( Segment00960, 960 )

#pragma data_seg("seg00961")
MAKE_SEGMENT_BODY( Segment00961, 961 )

#pragma data_seg("seg00962")
MAKE_SEGMENT_BODY( Segment00962, 962 )

#pragma data_seg("seg00963")
MAKE_SEGMENT_BODY( Segment00963, 963 )

#pragma data_seg("seg00964")
MAKE_SEGMENT_BODY( Segment00964, 964 )

#pragma data_seg("seg00965")
MAKE_SEGMENT_BODY( Segment00965, 965 )

#pragma data_seg("seg00966")
MAKE_SEGMENT_BODY( Segment00966, 966 )

#pragma data_seg("seg00967")
MAKE_SEGMENT_BODY( Segment00967, 967 )

#pragma data_seg("seg00968")
MAKE_SEGMENT_BODY( Segment00968, 968 )

#pragma data_seg("seg00969")
MAKE_SEGMENT_BODY( Segment00969, 969 )

#pragma data_seg("seg00970")
MAKE_SEGMENT_BODY( Segment00970, 970 )

#pragma data_seg("seg00971")
MAKE_SEGMENT_BODY( Segment00971, 971 )

#pragma data_seg("seg00972")
MAKE_SEGMENT_BODY( Segment00972, 972 )

#pragma data_seg("seg00973")
MAKE_SEGMENT_BODY( Segment00973, 973 )

#pragma data_seg("seg00974")
MAKE_SEGMENT_BODY( Segment00974, 974 )

#pragma data_seg("seg00975")
MAKE_SEGMENT_BODY( Segment00975, 975 )

#pragma data_seg("seg00976")
MAKE_SEGMENT_BODY( Segment00976, 976 )

#pragma data_seg("seg00977")
MAKE_SEGMENT_BODY( Segment00977, 977 )

#pragma data_seg("seg00978")
MAKE_SEGMENT_BODY( Segment00978, 978 )

#pragma data_seg("seg00979")
MAKE_SEGMENT_BODY( Segment00979, 979 )

#pragma data_seg("seg00980")
MAKE_SEGMENT_BODY( Segment00980, 980 )

#pragma data_seg("seg00981")
MAKE_SEGMENT_BODY( Segment00981, 981 )

#pragma data_seg("seg00982")
MAKE_SEGMENT_BODY( Segment00982, 982 )

#pragma data_seg("seg00983")
MAKE_SEGMENT_BODY( Segment00983, 983 )

#pragma data_seg("seg00984")
MAKE_SEGMENT_BODY( Segment00984, 984 )

#pragma data_seg("seg00985")
MAKE_SEGMENT_BODY( Segment00985, 985 )

#pragma data_seg("seg00986")
MAKE_SEGMENT_BODY( Segment00986, 986 )

#pragma data_seg("seg00987")
MAKE_SEGMENT_BODY( Segment00987, 987 )

#pragma data_seg("seg00988")
MAKE_SEGMENT_BODY( Segment00988, 988 )

#pragma data_seg("seg00989")
MAKE_SEGMENT_BODY( Segment00989, 989 )

#pragma data_seg("seg00990")
MAKE_SEGMENT_BODY( Segment00990, 990 )

#pragma data_seg("seg00991")
MAKE_SEGMENT_BODY( Segment00991, 991 )

#pragma data_seg("seg00992")
MAKE_SEGMENT_BODY( Segment00992, 992 )

#pragma data_seg("seg00993")
MAKE_SEGMENT_BODY( Segment00993, 993 )

#pragma data_seg("seg00994")
MAKE_SEGMENT_BODY( Segment00994, 994 )

#pragma data_seg("seg00995")
MAKE_SEGMENT_BODY( Segment00995, 995 )

#pragma data_seg("seg00996")
MAKE_SEGMENT_BODY( Segment00996, 996 )

#pragma data_seg("seg00997")
MAKE_SEGMENT_BODY( Segment00997, 997 )

#pragma data_seg("seg00998")
MAKE_SEGMENT_BODY( Segment00998, 998 )

#pragma data_seg("seg00999")
MAKE_SEGMENT_BODY( Segment00999, 999 )

#pragma data_seg("seg01000")
MAKE_SEGMENT_BODY( Segment01000, 1000 )

#pragma data_seg("seg01001")
MAKE_SEGMENT_BODY( Segment01001, 1001 )

#pragma data_seg("seg01002")
MAKE_SEGMENT_BODY( Segment01002, 1002 )

#pragma data_seg("seg01003")
MAKE_SEGMENT_BODY( Segment01003, 1003 )

#pragma data_seg("seg01004")
MAKE_SEGMENT_BODY( Segment01004, 1004 )

#pragma data_seg("seg01005")
MAKE_SEGMENT_BODY( Segment01005, 1005 )

#pragma data_seg("seg01006")
MAKE_SEGMENT_BODY( Segment01006, 1006 )

#pragma data_seg("seg01007")
MAKE_SEGMENT_BODY( Segment01007, 1007 )

#pragma data_seg("seg01008")
MAKE_SEGMENT_BODY( Segment01008, 1008 )

#pragma data_seg("seg01009")
MAKE_SEGMENT_BODY( Segment01009, 1009 )

#pragma data_seg("seg01010")
MAKE_SEGMENT_BODY( Segment01010, 1010 )

#pragma data_seg("seg01011")
MAKE_SEGMENT_BODY( Segment01011, 1011 )

#pragma data_seg("seg01012")
MAKE_SEGMENT_BODY( Segment01012, 1012 )

#pragma data_seg("seg01013")
MAKE_SEGMENT_BODY( Segment01013, 1013 )

#pragma data_seg("seg01014")
MAKE_SEGMENT_BODY( Segment01014, 1014 )

#pragma data_seg("seg01015")
MAKE_SEGMENT_BODY( Segment01015, 1015 )

#pragma data_seg("seg01016")
MAKE_SEGMENT_BODY( Segment01016, 1016 )

#pragma data_seg("seg01017")
MAKE_SEGMENT_BODY( Segment01017, 1017 )

#pragma data_seg("seg01018")
MAKE_SEGMENT_BODY( Segment01018, 1018 )

#pragma data_seg("seg01019")
MAKE_SEGMENT_BODY( Segment01019, 1019 )

#pragma data_seg("seg01020")
MAKE_SEGMENT_BODY( Segment01020, 1020 )

#pragma data_seg("seg01021")
MAKE_SEGMENT_BODY( Segment01021, 1021 )

#pragma data_seg("seg01022")
MAKE_SEGMENT_BODY( Segment01022, 1022 )

#pragma data_seg("seg01023")
MAKE_SEGMENT_BODY( Segment01023, 1023 )

#pragma data_seg("seg01024")
MAKE_SEGMENT_BODY( Segment01024, 1024 )

#pragma data_seg("seg01025")
MAKE_SEGMENT_BODY( Segment01025, 1025 )

#pragma data_seg("seg01026")
MAKE_SEGMENT_BODY( Segment01026, 1026 )

#pragma data_seg("seg01027")
MAKE_SEGMENT_BODY( Segment01027, 1027 )

#pragma data_seg("seg01028")
MAKE_SEGMENT_BODY( Segment01028, 1028 )

#pragma data_seg("seg01029")
MAKE_SEGMENT_BODY( Segment01029, 1029 )

#pragma data_seg("seg01030")
MAKE_SEGMENT_BODY( Segment01030, 1030 )

#pragma data_seg("seg01031")
MAKE_SEGMENT_BODY( Segment01031, 1031 )

#pragma data_seg("seg01032")
MAKE_SEGMENT_BODY( Segment01032, 1032 )

#pragma data_seg("seg01033")
MAKE_SEGMENT_BODY( Segment01033, 1033 )

#pragma data_seg("seg01034")
MAKE_SEGMENT_BODY( Segment01034, 1034 )

#pragma data_seg("seg01035")
MAKE_SEGMENT_BODY( Segment01035, 1035 )

#pragma data_seg("seg01036")
MAKE_SEGMENT_BODY( Segment01036, 1036 )

#pragma data_seg("seg01037")
MAKE_SEGMENT_BODY( Segment01037, 1037 )

#pragma data_seg("seg01038")
MAKE_SEGMENT_BODY( Segment01038, 1038 )

#pragma data_seg("seg01039")
MAKE_SEGMENT_BODY( Segment01039, 1039 )

#pragma data_seg("seg01040")
MAKE_SEGMENT_BODY( Segment01040, 1040 )

#pragma data_seg("seg01041")
MAKE_SEGMENT_BODY( Segment01041, 1041 )

#pragma data_seg("seg01042")
MAKE_SEGMENT_BODY( Segment01042, 1042 )

#pragma data_seg("seg01043")
MAKE_SEGMENT_BODY( Segment01043, 1043 )

#pragma data_seg("seg01044")
MAKE_SEGMENT_BODY( Segment01044, 1044 )

#pragma data_seg("seg01045")
MAKE_SEGMENT_BODY( Segment01045, 1045 )

#pragma data_seg("seg01046")
MAKE_SEGMENT_BODY( Segment01046, 1046 )

#pragma data_seg("seg01047")
MAKE_SEGMENT_BODY( Segment01047, 1047 )

#pragma data_seg("seg01048")
MAKE_SEGMENT_BODY( Segment01048, 1048 )

#pragma data_seg("seg01049")
MAKE_SEGMENT_BODY( Segment01049, 1049 )

#pragma data_seg("seg01050")
MAKE_SEGMENT_BODY( Segment01050, 1050 )

#pragma data_seg("seg01051")
MAKE_SEGMENT_BODY( Segment01051, 1051 )

#pragma data_seg("seg01052")
MAKE_SEGMENT_BODY( Segment01052, 1052 )

#pragma data_seg("seg01053")
MAKE_SEGMENT_BODY( Segment01053, 1053 )

#pragma data_seg("seg01054")
MAKE_SEGMENT_BODY( Segment01054, 1054 )

#pragma data_seg("seg01055")
MAKE_SEGMENT_BODY( Segment01055, 1055 )

#pragma data_seg("seg01056")
MAKE_SEGMENT_BODY( Segment01056, 1056 )

#pragma data_seg("seg01057")
MAKE_SEGMENT_BODY( Segment01057, 1057 )

#pragma data_seg("seg01058")
MAKE_SEGMENT_BODY( Segment01058, 1058 )

#pragma data_seg("seg01059")
MAKE_SEGMENT_BODY( Segment01059, 1059 )

#pragma data_seg("seg01060")
MAKE_SEGMENT_BODY( Segment01060, 1060 )

#pragma data_seg("seg01061")
MAKE_SEGMENT_BODY( Segment01061, 1061 )

#pragma data_seg("seg01062")
MAKE_SEGMENT_BODY( Segment01062, 1062 )

#pragma data_seg("seg01063")
MAKE_SEGMENT_BODY( Segment01063, 1063 )

#pragma data_seg("seg01064")
MAKE_SEGMENT_BODY( Segment01064, 1064 )

#pragma data_seg("seg01065")
MAKE_SEGMENT_BODY( Segment01065, 1065 )

#pragma data_seg("seg01066")
MAKE_SEGMENT_BODY( Segment01066, 1066 )

#pragma data_seg("seg01067")
MAKE_SEGMENT_BODY( Segment01067, 1067 )

#pragma data_seg("seg01068")
MAKE_SEGMENT_BODY( Segment01068, 1068 )

#pragma data_seg("seg01069")
MAKE_SEGMENT_BODY( Segment01069, 1069 )

#pragma data_seg("seg01070")
MAKE_SEGMENT_BODY( Segment01070, 1070 )

#pragma data_seg("seg01071")
MAKE_SEGMENT_BODY( Segment01071, 1071 )

#pragma data_seg("seg01072")
MAKE_SEGMENT_BODY( Segment01072, 1072 )

#pragma data_seg("seg01073")
MAKE_SEGMENT_BODY( Segment01073, 1073 )

#pragma data_seg("seg01074")
MAKE_SEGMENT_BODY( Segment01074, 1074 )

#pragma data_seg("seg01075")
MAKE_SEGMENT_BODY( Segment01075, 1075 )

#pragma data_seg("seg01076")
MAKE_SEGMENT_BODY( Segment01076, 1076 )

#pragma data_seg("seg01077")
MAKE_SEGMENT_BODY( Segment01077, 1077 )

#pragma data_seg("seg01078")
MAKE_SEGMENT_BODY( Segment01078, 1078 )

#pragma data_seg("seg01079")
MAKE_SEGMENT_BODY( Segment01079, 1079 )

#pragma data_seg("seg01080")
MAKE_SEGMENT_BODY( Segment01080, 1080 )

#pragma data_seg("seg01081")
MAKE_SEGMENT_BODY( Segment01081, 1081 )

#pragma data_seg("seg01082")
MAKE_SEGMENT_BODY( Segment01082, 1082 )

#pragma data_seg("seg01083")
MAKE_SEGMENT_BODY( Segment01083, 1083 )

#pragma data_seg("seg01084")
MAKE_SEGMENT_BODY( Segment01084, 1084 )

#pragma data_seg("seg01085")
MAKE_SEGMENT_BODY( Segment01085, 1085 )

#pragma data_seg("seg01086")
MAKE_SEGMENT_BODY( Segment01086, 1086 )

#pragma data_seg("seg01087")
MAKE_SEGMENT_BODY( Segment01087, 1087 )

#pragma data_seg("seg01088")
MAKE_SEGMENT_BODY( Segment01088, 1088 )

#pragma data_seg("seg01089")
MAKE_SEGMENT_BODY( Segment01089, 1089 )

#pragma data_seg("seg01090")
MAKE_SEGMENT_BODY( Segment01090, 1090 )

#pragma data_seg("seg01091")
MAKE_SEGMENT_BODY( Segment01091, 1091 )

#pragma data_seg("seg01092")
MAKE_SEGMENT_BODY( Segment01092, 1092 )

#pragma data_seg("seg01093")
MAKE_SEGMENT_BODY( Segment01093, 1093 )

#pragma data_seg("seg01094")
MAKE_SEGMENT_BODY( Segment01094, 1094 )

#pragma data_seg("seg01095")
MAKE_SEGMENT_BODY( Segment01095, 1095 )

#pragma data_seg("seg01096")
MAKE_SEGMENT_BODY( Segment01096, 1096 )

#pragma data_seg("seg01097")
MAKE_SEGMENT_BODY( Segment01097, 1097 )

#pragma data_seg("seg01098")
MAKE_SEGMENT_BODY( Segment01098, 1098 )

#pragma data_seg("seg01099")
MAKE_SEGMENT_BODY( Segment01099, 1099 )

#pragma data_seg("seg01100")
MAKE_SEGMENT_BODY( Segment01100, 1100 )

#pragma data_seg("seg01101")
MAKE_SEGMENT_BODY( Segment01101, 1101 )

#pragma data_seg("seg01102")
MAKE_SEGMENT_BODY( Segment01102, 1102 )

#pragma data_seg("seg01103")
MAKE_SEGMENT_BODY( Segment01103, 1103 )

#pragma data_seg("seg01104")
MAKE_SEGMENT_BODY( Segment01104, 1104 )

#pragma data_seg("seg01105")
MAKE_SEGMENT_BODY( Segment01105, 1105 )

#pragma data_seg("seg01106")
MAKE_SEGMENT_BODY( Segment01106, 1106 )

#pragma data_seg("seg01107")
MAKE_SEGMENT_BODY( Segment01107, 1107 )

#pragma data_seg("seg01108")
MAKE_SEGMENT_BODY( Segment01108, 1108 )

#pragma data_seg("seg01109")
MAKE_SEGMENT_BODY( Segment01109, 1109 )

#pragma data_seg("seg01110")
MAKE_SEGMENT_BODY( Segment01110, 1110 )

#pragma data_seg("seg01111")
MAKE_SEGMENT_BODY( Segment01111, 1111 )

#pragma data_seg("seg01112")
MAKE_SEGMENT_BODY( Segment01112, 1112 )

#pragma data_seg("seg01113")
MAKE_SEGMENT_BODY( Segment01113, 1113 )

#pragma data_seg("seg01114")
MAKE_SEGMENT_BODY( Segment01114, 1114 )

#pragma data_seg("seg01115")
MAKE_SEGMENT_BODY( Segment01115, 1115 )

#pragma data_seg("seg01116")
MAKE_SEGMENT_BODY( Segment01116, 1116 )

#pragma data_seg("seg01117")
MAKE_SEGMENT_BODY( Segment01117, 1117 )

#pragma data_seg("seg01118")
MAKE_SEGMENT_BODY( Segment01118, 1118 )

#pragma data_seg("seg01119")
MAKE_SEGMENT_BODY( Segment01119, 1119 )

#pragma data_seg("seg01120")
MAKE_SEGMENT_BODY( Segment01120, 1120 )

#pragma data_seg("seg01121")
MAKE_SEGMENT_BODY( Segment01121, 1121 )

#pragma data_seg("seg01122")
MAKE_SEGMENT_BODY( Segment01122, 1122 )

#pragma data_seg("seg01123")
MAKE_SEGMENT_BODY( Segment01123, 1123 )

#pragma data_seg("seg01124")
MAKE_SEGMENT_BODY( Segment01124, 1124 )

#pragma data_seg("seg01125")
MAKE_SEGMENT_BODY( Segment01125, 1125 )

#pragma data_seg("seg01126")
MAKE_SEGMENT_BODY( Segment01126, 1126 )

#pragma data_seg("seg01127")
MAKE_SEGMENT_BODY( Segment01127, 1127 )

#pragma data_seg("seg01128")
MAKE_SEGMENT_BODY( Segment01128, 1128 )

#pragma data_seg("seg01129")
MAKE_SEGMENT_BODY( Segment01129, 1129 )

#pragma data_seg("seg01130")
MAKE_SEGMENT_BODY( Segment01130, 1130 )

#pragma data_seg("seg01131")
MAKE_SEGMENT_BODY( Segment01131, 1131 )

#pragma data_seg("seg01132")
MAKE_SEGMENT_BODY( Segment01132, 1132 )

#pragma data_seg("seg01133")
MAKE_SEGMENT_BODY( Segment01133, 1133 )

#pragma data_seg("seg01134")
MAKE_SEGMENT_BODY( Segment01134, 1134 )

#pragma data_seg("seg01135")
MAKE_SEGMENT_BODY( Segment01135, 1135 )

#pragma data_seg("seg01136")
MAKE_SEGMENT_BODY( Segment01136, 1136 )

#pragma data_seg("seg01137")
MAKE_SEGMENT_BODY( Segment01137, 1137 )

#pragma data_seg("seg01138")
MAKE_SEGMENT_BODY( Segment01138, 1138 )

#pragma data_seg("seg01139")
MAKE_SEGMENT_BODY( Segment01139, 1139 )

#pragma data_seg("seg01140")
MAKE_SEGMENT_BODY( Segment01140, 1140 )

#pragma data_seg("seg01141")
MAKE_SEGMENT_BODY( Segment01141, 1141 )

#pragma data_seg("seg01142")
MAKE_SEGMENT_BODY( Segment01142, 1142 )

#pragma data_seg("seg01143")
MAKE_SEGMENT_BODY( Segment01143, 1143 )

#pragma data_seg("seg01144")
MAKE_SEGMENT_BODY( Segment01144, 1144 )

#pragma data_seg("seg01145")
MAKE_SEGMENT_BODY( Segment01145, 1145 )

#pragma data_seg("seg01146")
MAKE_SEGMENT_BODY( Segment01146, 1146 )

#pragma data_seg("seg01147")
MAKE_SEGMENT_BODY( Segment01147, 1147 )

#pragma data_seg("seg01148")
MAKE_SEGMENT_BODY( Segment01148, 1148 )

#pragma data_seg("seg01149")
MAKE_SEGMENT_BODY( Segment01149, 1149 )

#pragma data_seg("seg01150")
MAKE_SEGMENT_BODY( Segment01150, 1150 )

#pragma data_seg("seg01151")
MAKE_SEGMENT_BODY( Segment01151, 1151 )

#pragma data_seg("seg01152")
MAKE_SEGMENT_BODY( Segment01152, 1152 )

#pragma data_seg("seg01153")
MAKE_SEGMENT_BODY( Segment01153, 1153 )

#pragma data_seg("seg01154")
MAKE_SEGMENT_BODY( Segment01154, 1154 )

#pragma data_seg("seg01155")
MAKE_SEGMENT_BODY( Segment01155, 1155 )

#pragma data_seg("seg01156")
MAKE_SEGMENT_BODY( Segment01156, 1156 )

#pragma data_seg("seg01157")
MAKE_SEGMENT_BODY( Segment01157, 1157 )

#pragma data_seg("seg01158")
MAKE_SEGMENT_BODY( Segment01158, 1158 )

#pragma data_seg("seg01159")
MAKE_SEGMENT_BODY( Segment01159, 1159 )

#pragma data_seg("seg01160")
MAKE_SEGMENT_BODY( Segment01160, 1160 )

#pragma data_seg("seg01161")
MAKE_SEGMENT_BODY( Segment01161, 1161 )

#pragma data_seg("seg01162")
MAKE_SEGMENT_BODY( Segment01162, 1162 )

#pragma data_seg("seg01163")
MAKE_SEGMENT_BODY( Segment01163, 1163 )

#pragma data_seg("seg01164")
MAKE_SEGMENT_BODY( Segment01164, 1164 )

#pragma data_seg("seg01165")
MAKE_SEGMENT_BODY( Segment01165, 1165 )

#pragma data_seg("seg01166")
MAKE_SEGMENT_BODY( Segment01166, 1166 )

#pragma data_seg("seg01167")
MAKE_SEGMENT_BODY( Segment01167, 1167 )

#pragma data_seg("seg01168")
MAKE_SEGMENT_BODY( Segment01168, 1168 )

#pragma data_seg("seg01169")
MAKE_SEGMENT_BODY( Segment01169, 1169 )

#pragma data_seg("seg01170")
MAKE_SEGMENT_BODY( Segment01170, 1170 )

#pragma data_seg("seg01171")
MAKE_SEGMENT_BODY( Segment01171, 1171 )

#pragma data_seg("seg01172")
MAKE_SEGMENT_BODY( Segment01172, 1172 )

#pragma data_seg("seg01173")
MAKE_SEGMENT_BODY( Segment01173, 1173 )

#pragma data_seg("seg01174")
MAKE_SEGMENT_BODY( Segment01174, 1174 )

#pragma data_seg("seg01175")
MAKE_SEGMENT_BODY( Segment01175, 1175 )

#pragma data_seg("seg01176")
MAKE_SEGMENT_BODY( Segment01176, 1176 )

#pragma data_seg("seg01177")
MAKE_SEGMENT_BODY( Segment01177, 1177 )

#pragma data_seg("seg01178")
MAKE_SEGMENT_BODY( Segment01178, 1178 )

#pragma data_seg("seg01179")
MAKE_SEGMENT_BODY( Segment01179, 1179 )

#pragma data_seg("seg01180")
MAKE_SEGMENT_BODY( Segment01180, 1180 )

#pragma data_seg("seg01181")
MAKE_SEGMENT_BODY( Segment01181, 1181 )

#pragma data_seg("seg01182")
MAKE_SEGMENT_BODY( Segment01182, 1182 )

#pragma data_seg("seg01183")
MAKE_SEGMENT_BODY( Segment01183, 1183 )

#pragma data_seg("seg01184")
MAKE_SEGMENT_BODY( Segment01184, 1184 )

#pragma data_seg("seg01185")
MAKE_SEGMENT_BODY( Segment01185, 1185 )

#pragma data_seg("seg01186")
MAKE_SEGMENT_BODY( Segment01186, 1186 )

#pragma data_seg("seg01187")
MAKE_SEGMENT_BODY( Segment01187, 1187 )

#pragma data_seg("seg01188")
MAKE_SEGMENT_BODY( Segment01188, 1188 )

#pragma data_seg("seg01189")
MAKE_SEGMENT_BODY( Segment01189, 1189 )

#pragma data_seg("seg01190")
MAKE_SEGMENT_BODY( Segment01190, 1190 )

#pragma data_seg("seg01191")
MAKE_SEGMENT_BODY( Segment01191, 1191 )

#pragma data_seg("seg01192")
MAKE_SEGMENT_BODY( Segment01192, 1192 )

#pragma data_seg("seg01193")
MAKE_SEGMENT_BODY( Segment01193, 1193 )

#pragma data_seg("seg01194")
MAKE_SEGMENT_BODY( Segment01194, 1194 )

#pragma data_seg("seg01195")
MAKE_SEGMENT_BODY( Segment01195, 1195 )

#pragma data_seg("seg01196")
MAKE_SEGMENT_BODY( Segment01196, 1196 )

#pragma data_seg("seg01197")
MAKE_SEGMENT_BODY( Segment01197, 1197 )

#pragma data_seg("seg01198")
MAKE_SEGMENT_BODY( Segment01198, 1198 )

#pragma data_seg("seg01199")
MAKE_SEGMENT_BODY( Segment01199, 1199 )

#pragma data_seg("seg01200")
MAKE_SEGMENT_BODY( Segment01200, 1200 )

#pragma data_seg("seg01201")
MAKE_SEGMENT_BODY( Segment01201, 1201 )

#pragma data_seg("seg01202")
MAKE_SEGMENT_BODY( Segment01202, 1202 )

#pragma data_seg("seg01203")
MAKE_SEGMENT_BODY( Segment01203, 1203 )

#pragma data_seg("seg01204")
MAKE_SEGMENT_BODY( Segment01204, 1204 )

#pragma data_seg("seg01205")
MAKE_SEGMENT_BODY( Segment01205, 1205 )

#pragma data_seg("seg01206")
MAKE_SEGMENT_BODY( Segment01206, 1206 )

#pragma data_seg("seg01207")
MAKE_SEGMENT_BODY( Segment01207, 1207 )

#pragma data_seg("seg01208")
MAKE_SEGMENT_BODY( Segment01208, 1208 )

#pragma data_seg("seg01209")
MAKE_SEGMENT_BODY( Segment01209, 1209 )

#pragma data_seg("seg01210")
MAKE_SEGMENT_BODY( Segment01210, 1210 )

#pragma data_seg("seg01211")
MAKE_SEGMENT_BODY( Segment01211, 1211 )

#pragma data_seg("seg01212")
MAKE_SEGMENT_BODY( Segment01212, 1212 )

#pragma data_seg("seg01213")
MAKE_SEGMENT_BODY( Segment01213, 1213 )

#pragma data_seg("seg01214")
MAKE_SEGMENT_BODY( Segment01214, 1214 )

#pragma data_seg("seg01215")
MAKE_SEGMENT_BODY( Segment01215, 1215 )

#pragma data_seg("seg01216")
MAKE_SEGMENT_BODY( Segment01216, 1216 )

#pragma data_seg("seg01217")
MAKE_SEGMENT_BODY( Segment01217, 1217 )

#pragma data_seg("seg01218")
MAKE_SEGMENT_BODY( Segment01218, 1218 )

#pragma data_seg("seg01219")
MAKE_SEGMENT_BODY( Segment01219, 1219 )

#pragma data_seg("seg01220")
MAKE_SEGMENT_BODY( Segment01220, 1220 )

#pragma data_seg("seg01221")
MAKE_SEGMENT_BODY( Segment01221, 1221 )

#pragma data_seg("seg01222")
MAKE_SEGMENT_BODY( Segment01222, 1222 )

#pragma data_seg("seg01223")
MAKE_SEGMENT_BODY( Segment01223, 1223 )

#pragma data_seg("seg01224")
MAKE_SEGMENT_BODY( Segment01224, 1224 )

#pragma data_seg("seg01225")
MAKE_SEGMENT_BODY( Segment01225, 1225 )

#pragma data_seg("seg01226")
MAKE_SEGMENT_BODY( Segment01226, 1226 )

#pragma data_seg("seg01227")
MAKE_SEGMENT_BODY( Segment01227, 1227 )

#pragma data_seg("seg01228")
MAKE_SEGMENT_BODY( Segment01228, 1228 )

#pragma data_seg("seg01229")
MAKE_SEGMENT_BODY( Segment01229, 1229 )

#pragma data_seg("seg01230")
MAKE_SEGMENT_BODY( Segment01230, 1230 )

#pragma data_seg("seg01231")
MAKE_SEGMENT_BODY( Segment01231, 1231 )

#pragma data_seg("seg01232")
MAKE_SEGMENT_BODY( Segment01232, 1232 )

#pragma data_seg("seg01233")
MAKE_SEGMENT_BODY( Segment01233, 1233 )

#pragma data_seg("seg01234")
MAKE_SEGMENT_BODY( Segment01234, 1234 )

#pragma data_seg("seg01235")
MAKE_SEGMENT_BODY( Segment01235, 1235 )

#pragma data_seg("seg01236")
MAKE_SEGMENT_BODY( Segment01236, 1236 )

#pragma data_seg("seg01237")
MAKE_SEGMENT_BODY( Segment01237, 1237 )

#pragma data_seg("seg01238")
MAKE_SEGMENT_BODY( Segment01238, 1238 )

#pragma data_seg("seg01239")
MAKE_SEGMENT_BODY( Segment01239, 1239 )

#pragma data_seg("seg01240")
MAKE_SEGMENT_BODY( Segment01240, 1240 )

#pragma data_seg("seg01241")
MAKE_SEGMENT_BODY( Segment01241, 1241 )

#pragma data_seg("seg01242")
MAKE_SEGMENT_BODY( Segment01242, 1242 )

#pragma data_seg("seg01243")
MAKE_SEGMENT_BODY( Segment01243, 1243 )

#pragma data_seg("seg01244")
MAKE_SEGMENT_BODY( Segment01244, 1244 )

#pragma data_seg("seg01245")
MAKE_SEGMENT_BODY( Segment01245, 1245 )

#pragma data_seg("seg01246")
MAKE_SEGMENT_BODY( Segment01246, 1246 )

#pragma data_seg("seg01247")
MAKE_SEGMENT_BODY( Segment01247, 1247 )

#pragma data_seg("seg01248")
MAKE_SEGMENT_BODY( Segment01248, 1248 )

#pragma data_seg("seg01249")
MAKE_SEGMENT_BODY( Segment01249, 1249 )

#pragma data_seg("seg01250")
MAKE_SEGMENT_BODY( Segment01250, 1250 )

#pragma data_seg("seg01251")
MAKE_SEGMENT_BODY( Segment01251, 1251 )

#pragma data_seg("seg01252")
MAKE_SEGMENT_BODY( Segment01252, 1252 )

#pragma data_seg("seg01253")
MAKE_SEGMENT_BODY( Segment01253, 1253 )

#pragma data_seg("seg01254")
MAKE_SEGMENT_BODY( Segment01254, 1254 )

#pragma data_seg("seg01255")
MAKE_SEGMENT_BODY( Segment01255, 1255 )

#pragma data_seg("seg01256")
MAKE_SEGMENT_BODY( Segment01256, 1256 )

#pragma data_seg("seg01257")
MAKE_SEGMENT_BODY( Segment01257, 1257 )

#pragma data_seg("seg01258")
MAKE_SEGMENT_BODY( Segment01258, 1258 )

#pragma data_seg("seg01259")
MAKE_SEGMENT_BODY( Segment01259, 1259 )

#pragma data_seg("seg01260")
MAKE_SEGMENT_BODY( Segment01260, 1260 )

#pragma data_seg("seg01261")
MAKE_SEGMENT_BODY( Segment01261, 1261 )

#pragma data_seg("seg01262")
MAKE_SEGMENT_BODY( Segment01262, 1262 )

#pragma data_seg("seg01263")
MAKE_SEGMENT_BODY( Segment01263, 1263 )

#pragma data_seg("seg01264")
MAKE_SEGMENT_BODY( Segment01264, 1264 )

#pragma data_seg("seg01265")
MAKE_SEGMENT_BODY( Segment01265, 1265 )

#pragma data_seg("seg01266")
MAKE_SEGMENT_BODY( Segment01266, 1266 )

#pragma data_seg("seg01267")
MAKE_SEGMENT_BODY( Segment01267, 1267 )

#pragma data_seg("seg01268")
MAKE_SEGMENT_BODY( Segment01268, 1268 )

#pragma data_seg("seg01269")
MAKE_SEGMENT_BODY( Segment01269, 1269 )

#pragma data_seg("seg01270")
MAKE_SEGMENT_BODY( Segment01270, 1270 )

#pragma data_seg("seg01271")
MAKE_SEGMENT_BODY( Segment01271, 1271 )

#pragma data_seg("seg01272")
MAKE_SEGMENT_BODY( Segment01272, 1272 )

#pragma data_seg("seg01273")
MAKE_SEGMENT_BODY( Segment01273, 1273 )

#pragma data_seg("seg01274")
MAKE_SEGMENT_BODY( Segment01274, 1274 )

#pragma data_seg("seg01275")
MAKE_SEGMENT_BODY( Segment01275, 1275 )

#pragma data_seg("seg01276")
MAKE_SEGMENT_BODY( Segment01276, 1276 )

#pragma data_seg("seg01277")
MAKE_SEGMENT_BODY( Segment01277, 1277 )

#pragma data_seg("seg01278")
MAKE_SEGMENT_BODY( Segment01278, 1278 )

#pragma data_seg("seg01279")
MAKE_SEGMENT_BODY( Segment01279, 1279 )

#pragma data_seg("seg01280")
MAKE_SEGMENT_BODY( Segment01280, 1280 )

#pragma data_seg("seg01281")
MAKE_SEGMENT_BODY( Segment01281, 1281 )

#pragma data_seg("seg01282")
MAKE_SEGMENT_BODY( Segment01282, 1282 )

#pragma data_seg("seg01283")
MAKE_SEGMENT_BODY( Segment01283, 1283 )

#pragma data_seg("seg01284")
MAKE_SEGMENT_BODY( Segment01284, 1284 )

#pragma data_seg("seg01285")
MAKE_SEGMENT_BODY( Segment01285, 1285 )

#pragma data_seg("seg01286")
MAKE_SEGMENT_BODY( Segment01286, 1286 )

#pragma data_seg("seg01287")
MAKE_SEGMENT_BODY( Segment01287, 1287 )

#pragma data_seg("seg01288")
MAKE_SEGMENT_BODY( Segment01288, 1288 )

#pragma data_seg("seg01289")
MAKE_SEGMENT_BODY( Segment01289, 1289 )

#pragma data_seg("seg01290")
MAKE_SEGMENT_BODY( Segment01290, 1290 )

#pragma data_seg("seg01291")
MAKE_SEGMENT_BODY( Segment01291, 1291 )

#pragma data_seg("seg01292")
MAKE_SEGMENT_BODY( Segment01292, 1292 )

#pragma data_seg("seg01293")
MAKE_SEGMENT_BODY( Segment01293, 1293 )

#pragma data_seg("seg01294")
MAKE_SEGMENT_BODY( Segment01294, 1294 )

#pragma data_seg("seg01295")
MAKE_SEGMENT_BODY( Segment01295, 1295 )

#pragma data_seg("seg01296")
MAKE_SEGMENT_BODY( Segment01296, 1296 )

#pragma data_seg("seg01297")
MAKE_SEGMENT_BODY( Segment01297, 1297 )

#pragma data_seg("seg01298")
MAKE_SEGMENT_BODY( Segment01298, 1298 )

#pragma data_seg("seg01299")
MAKE_SEGMENT_BODY( Segment01299, 1299 )

#pragma data_seg("seg01300")
MAKE_SEGMENT_BODY( Segment01300, 1300 )

#pragma data_seg("seg01301")
MAKE_SEGMENT_BODY( Segment01301, 1301 )

#pragma data_seg("seg01302")
MAKE_SEGMENT_BODY( Segment01302, 1302 )

#pragma data_seg("seg01303")
MAKE_SEGMENT_BODY( Segment01303, 1303 )

#pragma data_seg("seg01304")
MAKE_SEGMENT_BODY( Segment01304, 1304 )

#pragma data_seg("seg01305")
MAKE_SEGMENT_BODY( Segment01305, 1305 )

#pragma data_seg("seg01306")
MAKE_SEGMENT_BODY( Segment01306, 1306 )

#pragma data_seg("seg01307")
MAKE_SEGMENT_BODY( Segment01307, 1307 )

#pragma data_seg("seg01308")
MAKE_SEGMENT_BODY( Segment01308, 1308 )

#pragma data_seg("seg01309")
MAKE_SEGMENT_BODY( Segment01309, 1309 )

#pragma data_seg("seg01310")
MAKE_SEGMENT_BODY( Segment01310, 1310 )

#pragma data_seg("seg01311")
MAKE_SEGMENT_BODY( Segment01311, 1311 )

#pragma data_seg("seg01312")
MAKE_SEGMENT_BODY( Segment01312, 1312 )

#pragma data_seg("seg01313")
MAKE_SEGMENT_BODY( Segment01313, 1313 )

#pragma data_seg("seg01314")
MAKE_SEGMENT_BODY( Segment01314, 1314 )

#pragma data_seg("seg01315")
MAKE_SEGMENT_BODY( Segment01315, 1315 )

#pragma data_seg("seg01316")
MAKE_SEGMENT_BODY( Segment01316, 1316 )

#pragma data_seg("seg01317")
MAKE_SEGMENT_BODY( Segment01317, 1317 )

#pragma data_seg("seg01318")
MAKE_SEGMENT_BODY( Segment01318, 1318 )

#pragma data_seg("seg01319")
MAKE_SEGMENT_BODY( Segment01319, 1319 )

#pragma data_seg("seg01320")
MAKE_SEGMENT_BODY( Segment01320, 1320 )

#pragma data_seg("seg01321")
MAKE_SEGMENT_BODY( Segment01321, 1321 )

#pragma data_seg("seg01322")
MAKE_SEGMENT_BODY( Segment01322, 1322 )

#pragma data_seg("seg01323")
MAKE_SEGMENT_BODY( Segment01323, 1323 )

#pragma data_seg("seg01324")
MAKE_SEGMENT_BODY( Segment01324, 1324 )

#pragma data_seg("seg01325")
MAKE_SEGMENT_BODY( Segment01325, 1325 )

#pragma data_seg("seg01326")
MAKE_SEGMENT_BODY( Segment01326, 1326 )

#pragma data_seg("seg01327")
MAKE_SEGMENT_BODY( Segment01327, 1327 )

#pragma data_seg("seg01328")
MAKE_SEGMENT_BODY( Segment01328, 1328 )

#pragma data_seg("seg01329")
MAKE_SEGMENT_BODY( Segment01329, 1329 )

#pragma data_seg("seg01330")
MAKE_SEGMENT_BODY( Segment01330, 1330 )

#pragma data_seg("seg01331")
MAKE_SEGMENT_BODY( Segment01331, 1331 )

#pragma data_seg("seg01332")
MAKE_SEGMENT_BODY( Segment01332, 1332 )

#pragma data_seg("seg01333")
MAKE_SEGMENT_BODY( Segment01333, 1333 )

#pragma data_seg("seg01334")
MAKE_SEGMENT_BODY( Segment01334, 1334 )

#pragma data_seg("seg01335")
MAKE_SEGMENT_BODY( Segment01335, 1335 )

#pragma data_seg("seg01336")
MAKE_SEGMENT_BODY( Segment01336, 1336 )

#pragma data_seg("seg01337")
MAKE_SEGMENT_BODY( Segment01337, 1337 )

#pragma data_seg("seg01338")
MAKE_SEGMENT_BODY( Segment01338, 1338 )

#pragma data_seg("seg01339")
MAKE_SEGMENT_BODY( Segment01339, 1339 )

#pragma data_seg("seg01340")
MAKE_SEGMENT_BODY( Segment01340, 1340 )

#pragma data_seg("seg01341")
MAKE_SEGMENT_BODY( Segment01341, 1341 )

#pragma data_seg("seg01342")
MAKE_SEGMENT_BODY( Segment01342, 1342 )

#pragma data_seg("seg01343")
MAKE_SEGMENT_BODY( Segment01343, 1343 )

#pragma data_seg("seg01344")
MAKE_SEGMENT_BODY( Segment01344, 1344 )

#pragma data_seg("seg01345")
MAKE_SEGMENT_BODY( Segment01345, 1345 )

#pragma data_seg("seg01346")
MAKE_SEGMENT_BODY( Segment01346, 1346 )

#pragma data_seg("seg01347")
MAKE_SEGMENT_BODY( Segment01347, 1347 )

#pragma data_seg("seg01348")
MAKE_SEGMENT_BODY( Segment01348, 1348 )

#pragma data_seg("seg01349")
MAKE_SEGMENT_BODY( Segment01349, 1349 )

#pragma data_seg("seg01350")
MAKE_SEGMENT_BODY( Segment01350, 1350 )

#pragma data_seg("seg01351")
MAKE_SEGMENT_BODY( Segment01351, 1351 )

#pragma data_seg("seg01352")
MAKE_SEGMENT_BODY( Segment01352, 1352 )

#pragma data_seg("seg01353")
MAKE_SEGMENT_BODY( Segment01353, 1353 )

#pragma data_seg("seg01354")
MAKE_SEGMENT_BODY( Segment01354, 1354 )

#pragma data_seg("seg01355")
MAKE_SEGMENT_BODY( Segment01355, 1355 )

#pragma data_seg("seg01356")
MAKE_SEGMENT_BODY( Segment01356, 1356 )

#pragma data_seg("seg01357")
MAKE_SEGMENT_BODY( Segment01357, 1357 )

#pragma data_seg("seg01358")
MAKE_SEGMENT_BODY( Segment01358, 1358 )

#pragma data_seg("seg01359")
MAKE_SEGMENT_BODY( Segment01359, 1359 )

#pragma data_seg("seg01360")
MAKE_SEGMENT_BODY( Segment01360, 1360 )

#pragma data_seg("seg01361")
MAKE_SEGMENT_BODY( Segment01361, 1361 )

#pragma data_seg("seg01362")
MAKE_SEGMENT_BODY( Segment01362, 1362 )

#pragma data_seg("seg01363")
MAKE_SEGMENT_BODY( Segment01363, 1363 )

#pragma data_seg("seg01364")
MAKE_SEGMENT_BODY( Segment01364, 1364 )

#pragma data_seg("seg01365")
MAKE_SEGMENT_BODY( Segment01365, 1365 )

#pragma data_seg("seg01366")
MAKE_SEGMENT_BODY( Segment01366, 1366 )

#pragma data_seg("seg01367")
MAKE_SEGMENT_BODY( Segment01367, 1367 )

#pragma data_seg("seg01368")
MAKE_SEGMENT_BODY( Segment01368, 1368 )

#pragma data_seg("seg01369")
MAKE_SEGMENT_BODY( Segment01369, 1369 )

#pragma data_seg("seg01370")
MAKE_SEGMENT_BODY( Segment01370, 1370 )

#pragma data_seg("seg01371")
MAKE_SEGMENT_BODY( Segment01371, 1371 )

#pragma data_seg("seg01372")
MAKE_SEGMENT_BODY( Segment01372, 1372 )

#pragma data_seg("seg01373")
MAKE_SEGMENT_BODY( Segment01373, 1373 )

#pragma data_seg("seg01374")
MAKE_SEGMENT_BODY( Segment01374, 1374 )

#pragma data_seg("seg01375")
MAKE_SEGMENT_BODY( Segment01375, 1375 )

#pragma data_seg("seg01376")
MAKE_SEGMENT_BODY( Segment01376, 1376 )

#pragma data_seg("seg01377")
MAKE_SEGMENT_BODY( Segment01377, 1377 )

#pragma data_seg("seg01378")
MAKE_SEGMENT_BODY( Segment01378, 1378 )

#pragma data_seg("seg01379")
MAKE_SEGMENT_BODY( Segment01379, 1379 )

#pragma data_seg("seg01380")
MAKE_SEGMENT_BODY( Segment01380, 1380 )

#pragma data_seg("seg01381")
MAKE_SEGMENT_BODY( Segment01381, 1381 )

#pragma data_seg("seg01382")
MAKE_SEGMENT_BODY( Segment01382, 1382 )

#pragma data_seg("seg01383")
MAKE_SEGMENT_BODY( Segment01383, 1383 )

#pragma data_seg("seg01384")
MAKE_SEGMENT_BODY( Segment01384, 1384 )

#pragma data_seg("seg01385")
MAKE_SEGMENT_BODY( Segment01385, 1385 )

#pragma data_seg("seg01386")
MAKE_SEGMENT_BODY( Segment01386, 1386 )

#pragma data_seg("seg01387")
MAKE_SEGMENT_BODY( Segment01387, 1387 )

#pragma data_seg("seg01388")
MAKE_SEGMENT_BODY( Segment01388, 1388 )

#pragma data_seg("seg01389")
MAKE_SEGMENT_BODY( Segment01389, 1389 )

#pragma data_seg("seg01390")
MAKE_SEGMENT_BODY( Segment01390, 1390 )

#pragma data_seg("seg01391")
MAKE_SEGMENT_BODY( Segment01391, 1391 )

#pragma data_seg("seg01392")
MAKE_SEGMENT_BODY( Segment01392, 1392 )

#pragma data_seg("seg01393")
MAKE_SEGMENT_BODY( Segment01393, 1393 )

#pragma data_seg("seg01394")
MAKE_SEGMENT_BODY( Segment01394, 1394 )

#pragma data_seg("seg01395")
MAKE_SEGMENT_BODY( Segment01395, 1395 )

#pragma data_seg("seg01396")
MAKE_SEGMENT_BODY( Segment01396, 1396 )

#pragma data_seg("seg01397")
MAKE_SEGMENT_BODY( Segment01397, 1397 )

#pragma data_seg("seg01398")
MAKE_SEGMENT_BODY( Segment01398, 1398 )

#pragma data_seg("seg01399")
MAKE_SEGMENT_BODY( Segment01399, 1399 )

#pragma data_seg("seg01400")
MAKE_SEGMENT_BODY( Segment01400, 1400 )

#pragma data_seg("seg01401")
MAKE_SEGMENT_BODY( Segment01401, 1401 )

#pragma data_seg("seg01402")
MAKE_SEGMENT_BODY( Segment01402, 1402 )

#pragma data_seg("seg01403")
MAKE_SEGMENT_BODY( Segment01403, 1403 )

#pragma data_seg("seg01404")
MAKE_SEGMENT_BODY( Segment01404, 1404 )

#pragma data_seg("seg01405")
MAKE_SEGMENT_BODY( Segment01405, 1405 )

#pragma data_seg("seg01406")
MAKE_SEGMENT_BODY( Segment01406, 1406 )

#pragma data_seg("seg01407")
MAKE_SEGMENT_BODY( Segment01407, 1407 )

#pragma data_seg("seg01408")
MAKE_SEGMENT_BODY( Segment01408, 1408 )

#pragma data_seg("seg01409")
MAKE_SEGMENT_BODY( Segment01409, 1409 )

#pragma data_seg("seg01410")
MAKE_SEGMENT_BODY( Segment01410, 1410 )

#pragma data_seg("seg01411")
MAKE_SEGMENT_BODY( Segment01411, 1411 )

#pragma data_seg("seg01412")
MAKE_SEGMENT_BODY( Segment01412, 1412 )

#pragma data_seg("seg01413")
MAKE_SEGMENT_BODY( Segment01413, 1413 )

#pragma data_seg("seg01414")
MAKE_SEGMENT_BODY( Segment01414, 1414 )

#pragma data_seg("seg01415")
MAKE_SEGMENT_BODY( Segment01415, 1415 )

#pragma data_seg("seg01416")
MAKE_SEGMENT_BODY( Segment01416, 1416 )

#pragma data_seg("seg01417")
MAKE_SEGMENT_BODY( Segment01417, 1417 )

#pragma data_seg("seg01418")
MAKE_SEGMENT_BODY( Segment01418, 1418 )

#pragma data_seg("seg01419")
MAKE_SEGMENT_BODY( Segment01419, 1419 )

#pragma data_seg("seg01420")
MAKE_SEGMENT_BODY( Segment01420, 1420 )

#pragma data_seg("seg01421")
MAKE_SEGMENT_BODY( Segment01421, 1421 )

#pragma data_seg("seg01422")
MAKE_SEGMENT_BODY( Segment01422, 1422 )

#pragma data_seg("seg01423")
MAKE_SEGMENT_BODY( Segment01423, 1423 )

#pragma data_seg("seg01424")
MAKE_SEGMENT_BODY( Segment01424, 1424 )

#pragma data_seg("seg01425")
MAKE_SEGMENT_BODY( Segment01425, 1425 )

#pragma data_seg("seg01426")
MAKE_SEGMENT_BODY( Segment01426, 1426 )

#pragma data_seg("seg01427")
MAKE_SEGMENT_BODY( Segment01427, 1427 )

#pragma data_seg("seg01428")
MAKE_SEGMENT_BODY( Segment01428, 1428 )

#pragma data_seg("seg01429")
MAKE_SEGMENT_BODY( Segment01429, 1429 )

#pragma data_seg("seg01430")
MAKE_SEGMENT_BODY( Segment01430, 1430 )

#pragma data_seg("seg01431")
MAKE_SEGMENT_BODY( Segment01431, 1431 )

#pragma data_seg("seg01432")
MAKE_SEGMENT_BODY( Segment01432, 1432 )

#pragma data_seg("seg01433")
MAKE_SEGMENT_BODY( Segment01433, 1433 )

#pragma data_seg("seg01434")
MAKE_SEGMENT_BODY( Segment01434, 1434 )

#pragma data_seg("seg01435")
MAKE_SEGMENT_BODY( Segment01435, 1435 )

#pragma data_seg("seg01436")
MAKE_SEGMENT_BODY( Segment01436, 1436 )

#pragma data_seg("seg01437")
MAKE_SEGMENT_BODY( Segment01437, 1437 )

#pragma data_seg("seg01438")
MAKE_SEGMENT_BODY( Segment01438, 1438 )

#pragma data_seg("seg01439")
MAKE_SEGMENT_BODY( Segment01439, 1439 )

#pragma data_seg("seg01440")
MAKE_SEGMENT_BODY( Segment01440, 1440 )

#pragma data_seg("seg01441")
MAKE_SEGMENT_BODY( Segment01441, 1441 )

#pragma data_seg("seg01442")
MAKE_SEGMENT_BODY( Segment01442, 1442 )

#pragma data_seg("seg01443")
MAKE_SEGMENT_BODY( Segment01443, 1443 )

#pragma data_seg("seg01444")
MAKE_SEGMENT_BODY( Segment01444, 1444 )

#pragma data_seg("seg01445")
MAKE_SEGMENT_BODY( Segment01445, 1445 )

#pragma data_seg("seg01446")
MAKE_SEGMENT_BODY( Segment01446, 1446 )

#pragma data_seg("seg01447")
MAKE_SEGMENT_BODY( Segment01447, 1447 )

#pragma data_seg("seg01448")
MAKE_SEGMENT_BODY( Segment01448, 1448 )

#pragma data_seg("seg01449")
MAKE_SEGMENT_BODY( Segment01449, 1449 )

#pragma data_seg("seg01450")
MAKE_SEGMENT_BODY( Segment01450, 1450 )

#pragma data_seg("seg01451")
MAKE_SEGMENT_BODY( Segment01451, 1451 )

#pragma data_seg("seg01452")
MAKE_SEGMENT_BODY( Segment01452, 1452 )

#pragma data_seg("seg01453")
MAKE_SEGMENT_BODY( Segment01453, 1453 )

#pragma data_seg("seg01454")
MAKE_SEGMENT_BODY( Segment01454, 1454 )

#pragma data_seg("seg01455")
MAKE_SEGMENT_BODY( Segment01455, 1455 )

#pragma data_seg("seg01456")
MAKE_SEGMENT_BODY( Segment01456, 1456 )

#pragma data_seg("seg01457")
MAKE_SEGMENT_BODY( Segment01457, 1457 )

#pragma data_seg("seg01458")
MAKE_SEGMENT_BODY( Segment01458, 1458 )

#pragma data_seg("seg01459")
MAKE_SEGMENT_BODY( Segment01459, 1459 )

#pragma data_seg("seg01460")
MAKE_SEGMENT_BODY( Segment01460, 1460 )

#pragma data_seg("seg01461")
MAKE_SEGMENT_BODY( Segment01461, 1461 )

#pragma data_seg("seg01462")
MAKE_SEGMENT_BODY( Segment01462, 1462 )

#pragma data_seg("seg01463")
MAKE_SEGMENT_BODY( Segment01463, 1463 )

#pragma data_seg("seg01464")
MAKE_SEGMENT_BODY( Segment01464, 1464 )

#pragma data_seg("seg01465")
MAKE_SEGMENT_BODY( Segment01465, 1465 )

#pragma data_seg("seg01466")
MAKE_SEGMENT_BODY( Segment01466, 1466 )

#pragma data_seg("seg01467")
MAKE_SEGMENT_BODY( Segment01467, 1467 )

#pragma data_seg("seg01468")
MAKE_SEGMENT_BODY( Segment01468, 1468 )

#pragma data_seg("seg01469")
MAKE_SEGMENT_BODY( Segment01469, 1469 )

#pragma data_seg("seg01470")
MAKE_SEGMENT_BODY( Segment01470, 1470 )

#pragma data_seg("seg01471")
MAKE_SEGMENT_BODY( Segment01471, 1471 )

#pragma data_seg("seg01472")
MAKE_SEGMENT_BODY( Segment01472, 1472 )

#pragma data_seg("seg01473")
MAKE_SEGMENT_BODY( Segment01473, 1473 )

#pragma data_seg("seg01474")
MAKE_SEGMENT_BODY( Segment01474, 1474 )

#pragma data_seg("seg01475")
MAKE_SEGMENT_BODY( Segment01475, 1475 )

#pragma data_seg("seg01476")
MAKE_SEGMENT_BODY( Segment01476, 1476 )

#pragma data_seg("seg01477")
MAKE_SEGMENT_BODY( Segment01477, 1477 )

#pragma data_seg("seg01478")
MAKE_SEGMENT_BODY( Segment01478, 1478 )

#pragma data_seg("seg01479")
MAKE_SEGMENT_BODY( Segment01479, 1479 )

#pragma data_seg("seg01480")
MAKE_SEGMENT_BODY( Segment01480, 1480 )

#pragma data_seg("seg01481")
MAKE_SEGMENT_BODY( Segment01481, 1481 )

#pragma data_seg("seg01482")
MAKE_SEGMENT_BODY( Segment01482, 1482 )

#pragma data_seg("seg01483")
MAKE_SEGMENT_BODY( Segment01483, 1483 )

#pragma data_seg("seg01484")
MAKE_SEGMENT_BODY( Segment01484, 1484 )

#pragma data_seg("seg01485")
MAKE_SEGMENT_BODY( Segment01485, 1485 )

#pragma data_seg("seg01486")
MAKE_SEGMENT_BODY( Segment01486, 1486 )

#pragma data_seg("seg01487")
MAKE_SEGMENT_BODY( Segment01487, 1487 )

#pragma data_seg("seg01488")
MAKE_SEGMENT_BODY( Segment01488, 1488 )

#pragma data_seg("seg01489")
MAKE_SEGMENT_BODY( Segment01489, 1489 )

#pragma data_seg("seg01490")
MAKE_SEGMENT_BODY( Segment01490, 1490 )

#pragma data_seg("seg01491")
MAKE_SEGMENT_BODY( Segment01491, 1491 )

#pragma data_seg("seg01492")
MAKE_SEGMENT_BODY( Segment01492, 1492 )

#pragma data_seg("seg01493")
MAKE_SEGMENT_BODY( Segment01493, 1493 )

#pragma data_seg("seg01494")
MAKE_SEGMENT_BODY( Segment01494, 1494 )

#pragma data_seg("seg01495")
MAKE_SEGMENT_BODY( Segment01495, 1495 )

#pragma data_seg("seg01496")
MAKE_SEGMENT_BODY( Segment01496, 1496 )

#pragma data_seg("seg01497")
MAKE_SEGMENT_BODY( Segment01497, 1497 )

#pragma data_seg("seg01498")
MAKE_SEGMENT_BODY( Segment01498, 1498 )

#pragma data_seg("seg01499")
MAKE_SEGMENT_BODY( Segment01499, 1499 )

#pragma data_seg("seg01500")
MAKE_SEGMENT_BODY( Segment01500, 1500 )

#pragma data_seg("seg01501")
MAKE_SEGMENT_BODY( Segment01501, 1501 )

#pragma data_seg("seg01502")
MAKE_SEGMENT_BODY( Segment01502, 1502 )

#pragma data_seg("seg01503")
MAKE_SEGMENT_BODY( Segment01503, 1503 )

#pragma data_seg("seg01504")
MAKE_SEGMENT_BODY( Segment01504, 1504 )

#pragma data_seg("seg01505")
MAKE_SEGMENT_BODY( Segment01505, 1505 )

#pragma data_seg("seg01506")
MAKE_SEGMENT_BODY( Segment01506, 1506 )

#pragma data_seg("seg01507")
MAKE_SEGMENT_BODY( Segment01507, 1507 )

#pragma data_seg("seg01508")
MAKE_SEGMENT_BODY( Segment01508, 1508 )

#pragma data_seg("seg01509")
MAKE_SEGMENT_BODY( Segment01509, 1509 )

#pragma data_seg("seg01510")
MAKE_SEGMENT_BODY( Segment01510, 1510 )

#pragma data_seg("seg01511")
MAKE_SEGMENT_BODY( Segment01511, 1511 )

#pragma data_seg("seg01512")
MAKE_SEGMENT_BODY( Segment01512, 1512 )

#pragma data_seg("seg01513")
MAKE_SEGMENT_BODY( Segment01513, 1513 )

#pragma data_seg("seg01514")
MAKE_SEGMENT_BODY( Segment01514, 1514 )

#pragma data_seg("seg01515")
MAKE_SEGMENT_BODY( Segment01515, 1515 )

#pragma data_seg("seg01516")
MAKE_SEGMENT_BODY( Segment01516, 1516 )

#pragma data_seg("seg01517")
MAKE_SEGMENT_BODY( Segment01517, 1517 )

#pragma data_seg("seg01518")
MAKE_SEGMENT_BODY( Segment01518, 1518 )

#pragma data_seg("seg01519")
MAKE_SEGMENT_BODY( Segment01519, 1519 )

#pragma data_seg("seg01520")
MAKE_SEGMENT_BODY( Segment01520, 1520 )

#pragma data_seg("seg01521")
MAKE_SEGMENT_BODY( Segment01521, 1521 )

#pragma data_seg("seg01522")
MAKE_SEGMENT_BODY( Segment01522, 1522 )

#pragma data_seg("seg01523")
MAKE_SEGMENT_BODY( Segment01523, 1523 )

#pragma data_seg("seg01524")
MAKE_SEGMENT_BODY( Segment01524, 1524 )

#pragma data_seg("seg01525")
MAKE_SEGMENT_BODY( Segment01525, 1525 )

#pragma data_seg("seg01526")
MAKE_SEGMENT_BODY( Segment01526, 1526 )

#pragma data_seg("seg01527")
MAKE_SEGMENT_BODY( Segment01527, 1527 )

#pragma data_seg("seg01528")
MAKE_SEGMENT_BODY( Segment01528, 1528 )

#pragma data_seg("seg01529")
MAKE_SEGMENT_BODY( Segment01529, 1529 )

#pragma data_seg("seg01530")
MAKE_SEGMENT_BODY( Segment01530, 1530 )

#pragma data_seg("seg01531")
MAKE_SEGMENT_BODY( Segment01531, 1531 )

#pragma data_seg("seg01532")
MAKE_SEGMENT_BODY( Segment01532, 1532 )

#pragma data_seg("seg01533")
MAKE_SEGMENT_BODY( Segment01533, 1533 )

#pragma data_seg("seg01534")
MAKE_SEGMENT_BODY( Segment01534, 1534 )

#pragma data_seg("seg01535")
MAKE_SEGMENT_BODY( Segment01535, 1535 )

#pragma data_seg("seg01536")
MAKE_SEGMENT_BODY( Segment01536, 1536 )

#pragma data_seg("seg01537")
MAKE_SEGMENT_BODY( Segment01537, 1537 )

#pragma data_seg("seg01538")
MAKE_SEGMENT_BODY( Segment01538, 1538 )

#pragma data_seg("seg01539")
MAKE_SEGMENT_BODY( Segment01539, 1539 )

#pragma data_seg("seg01540")
MAKE_SEGMENT_BODY( Segment01540, 1540 )

#pragma data_seg("seg01541")
MAKE_SEGMENT_BODY( Segment01541, 1541 )

#pragma data_seg("seg01542")
MAKE_SEGMENT_BODY( Segment01542, 1542 )

#pragma data_seg("seg01543")
MAKE_SEGMENT_BODY( Segment01543, 1543 )

#pragma data_seg("seg01544")
MAKE_SEGMENT_BODY( Segment01544, 1544 )

#pragma data_seg("seg01545")
MAKE_SEGMENT_BODY( Segment01545, 1545 )

#pragma data_seg("seg01546")
MAKE_SEGMENT_BODY( Segment01546, 1546 )

#pragma data_seg("seg01547")
MAKE_SEGMENT_BODY( Segment01547, 1547 )

#pragma data_seg("seg01548")
MAKE_SEGMENT_BODY( Segment01548, 1548 )

#pragma data_seg("seg01549")
MAKE_SEGMENT_BODY( Segment01549, 1549 )

#pragma data_seg("seg01550")
MAKE_SEGMENT_BODY( Segment01550, 1550 )

#pragma data_seg("seg01551")
MAKE_SEGMENT_BODY( Segment01551, 1551 )

#pragma data_seg("seg01552")
MAKE_SEGMENT_BODY( Segment01552, 1552 )

#pragma data_seg("seg01553")
MAKE_SEGMENT_BODY( Segment01553, 1553 )

#pragma data_seg("seg01554")
MAKE_SEGMENT_BODY( Segment01554, 1554 )

#pragma data_seg("seg01555")
MAKE_SEGMENT_BODY( Segment01555, 1555 )

#pragma data_seg("seg01556")
MAKE_SEGMENT_BODY( Segment01556, 1556 )

#pragma data_seg("seg01557")
MAKE_SEGMENT_BODY( Segment01557, 1557 )

#pragma data_seg("seg01558")
MAKE_SEGMENT_BODY( Segment01558, 1558 )

#pragma data_seg("seg01559")
MAKE_SEGMENT_BODY( Segment01559, 1559 )

#pragma data_seg("seg01560")
MAKE_SEGMENT_BODY( Segment01560, 1560 )

#pragma data_seg("seg01561")
MAKE_SEGMENT_BODY( Segment01561, 1561 )

#pragma data_seg("seg01562")
MAKE_SEGMENT_BODY( Segment01562, 1562 )

#pragma data_seg("seg01563")
MAKE_SEGMENT_BODY( Segment01563, 1563 )

#pragma data_seg("seg01564")
MAKE_SEGMENT_BODY( Segment01564, 1564 )

#pragma data_seg("seg01565")
MAKE_SEGMENT_BODY( Segment01565, 1565 )

#pragma data_seg("seg01566")
MAKE_SEGMENT_BODY( Segment01566, 1566 )

#pragma data_seg("seg01567")
MAKE_SEGMENT_BODY( Segment01567, 1567 )

#pragma data_seg("seg01568")
MAKE_SEGMENT_BODY( Segment01568, 1568 )

#pragma data_seg("seg01569")
MAKE_SEGMENT_BODY( Segment01569, 1569 )

#pragma data_seg("seg01570")
MAKE_SEGMENT_BODY( Segment01570, 1570 )

#pragma data_seg("seg01571")
MAKE_SEGMENT_BODY( Segment01571, 1571 )

#pragma data_seg("seg01572")
MAKE_SEGMENT_BODY( Segment01572, 1572 )

#pragma data_seg("seg01573")
MAKE_SEGMENT_BODY( Segment01573, 1573 )

#pragma data_seg("seg01574")
MAKE_SEGMENT_BODY( Segment01574, 1574 )

#pragma data_seg("seg01575")
MAKE_SEGMENT_BODY( Segment01575, 1575 )

#pragma data_seg("seg01576")
MAKE_SEGMENT_BODY( Segment01576, 1576 )

#pragma data_seg("seg01577")
MAKE_SEGMENT_BODY( Segment01577, 1577 )

#pragma data_seg("seg01578")
MAKE_SEGMENT_BODY( Segment01578, 1578 )

#pragma data_seg("seg01579")
MAKE_SEGMENT_BODY( Segment01579, 1579 )

#pragma data_seg("seg01580")
MAKE_SEGMENT_BODY( Segment01580, 1580 )

#pragma data_seg("seg01581")
MAKE_SEGMENT_BODY( Segment01581, 1581 )

#pragma data_seg("seg01582")
MAKE_SEGMENT_BODY( Segment01582, 1582 )

#pragma data_seg("seg01583")
MAKE_SEGMENT_BODY( Segment01583, 1583 )

#pragma data_seg("seg01584")
MAKE_SEGMENT_BODY( Segment01584, 1584 )

#pragma data_seg("seg01585")
MAKE_SEGMENT_BODY( Segment01585, 1585 )

#pragma data_seg("seg01586")
MAKE_SEGMENT_BODY( Segment01586, 1586 )

#pragma data_seg("seg01587")
MAKE_SEGMENT_BODY( Segment01587, 1587 )

#pragma data_seg("seg01588")
MAKE_SEGMENT_BODY( Segment01588, 1588 )

#pragma data_seg("seg01589")
MAKE_SEGMENT_BODY( Segment01589, 1589 )

#pragma data_seg("seg01590")
MAKE_SEGMENT_BODY( Segment01590, 1590 )

#pragma data_seg("seg01591")
MAKE_SEGMENT_BODY( Segment01591, 1591 )

#pragma data_seg("seg01592")
MAKE_SEGMENT_BODY( Segment01592, 1592 )

#pragma data_seg("seg01593")
MAKE_SEGMENT_BODY( Segment01593, 1593 )

#pragma data_seg("seg01594")
MAKE_SEGMENT_BODY( Segment01594, 1594 )

#pragma data_seg("seg01595")
MAKE_SEGMENT_BODY( Segment01595, 1595 )

#pragma data_seg("seg01596")
MAKE_SEGMENT_BODY( Segment01596, 1596 )

#pragma data_seg("seg01597")
MAKE_SEGMENT_BODY( Segment01597, 1597 )

#pragma data_seg("seg01598")
MAKE_SEGMENT_BODY( Segment01598, 1598 )

#pragma data_seg("seg01599")
MAKE_SEGMENT_BODY( Segment01599, 1599 )

#pragma data_seg("seg01600")
MAKE_SEGMENT_BODY( Segment01600, 1600 )

#pragma data_seg("seg01601")
MAKE_SEGMENT_BODY( Segment01601, 1601 )

#pragma data_seg("seg01602")
MAKE_SEGMENT_BODY( Segment01602, 1602 )

#pragma data_seg("seg01603")
MAKE_SEGMENT_BODY( Segment01603, 1603 )

#pragma data_seg("seg01604")
MAKE_SEGMENT_BODY( Segment01604, 1604 )

#pragma data_seg("seg01605")
MAKE_SEGMENT_BODY( Segment01605, 1605 )

#pragma data_seg("seg01606")
MAKE_SEGMENT_BODY( Segment01606, 1606 )

#pragma data_seg("seg01607")
MAKE_SEGMENT_BODY( Segment01607, 1607 )

#pragma data_seg("seg01608")
MAKE_SEGMENT_BODY( Segment01608, 1608 )

#pragma data_seg("seg01609")
MAKE_SEGMENT_BODY( Segment01609, 1609 )

#pragma data_seg("seg01610")
MAKE_SEGMENT_BODY( Segment01610, 1610 )

#pragma data_seg("seg01611")
MAKE_SEGMENT_BODY( Segment01611, 1611 )

#pragma data_seg("seg01612")
MAKE_SEGMENT_BODY( Segment01612, 1612 )

#pragma data_seg("seg01613")
MAKE_SEGMENT_BODY( Segment01613, 1613 )

#pragma data_seg("seg01614")
MAKE_SEGMENT_BODY( Segment01614, 1614 )

#pragma data_seg("seg01615")
MAKE_SEGMENT_BODY( Segment01615, 1615 )

#pragma data_seg("seg01616")
MAKE_SEGMENT_BODY( Segment01616, 1616 )

#pragma data_seg("seg01617")
MAKE_SEGMENT_BODY( Segment01617, 1617 )

#pragma data_seg("seg01618")
MAKE_SEGMENT_BODY( Segment01618, 1618 )

#pragma data_seg("seg01619")
MAKE_SEGMENT_BODY( Segment01619, 1619 )

#pragma data_seg("seg01620")
MAKE_SEGMENT_BODY( Segment01620, 1620 )

#pragma data_seg("seg01621")
MAKE_SEGMENT_BODY( Segment01621, 1621 )

#pragma data_seg("seg01622")
MAKE_SEGMENT_BODY( Segment01622, 1622 )

#pragma data_seg("seg01623")
MAKE_SEGMENT_BODY( Segment01623, 1623 )

#pragma data_seg("seg01624")
MAKE_SEGMENT_BODY( Segment01624, 1624 )

#pragma data_seg("seg01625")
MAKE_SEGMENT_BODY( Segment01625, 1625 )

#pragma data_seg("seg01626")
MAKE_SEGMENT_BODY( Segment01626, 1626 )

#pragma data_seg("seg01627")
MAKE_SEGMENT_BODY( Segment01627, 1627 )

#pragma data_seg("seg01628")
MAKE_SEGMENT_BODY( Segment01628, 1628 )

#pragma data_seg("seg01629")
MAKE_SEGMENT_BODY( Segment01629, 1629 )

#pragma data_seg("seg01630")
MAKE_SEGMENT_BODY( Segment01630, 1630 )

#pragma data_seg("seg01631")
MAKE_SEGMENT_BODY( Segment01631, 1631 )

#pragma data_seg("seg01632")
MAKE_SEGMENT_BODY( Segment01632, 1632 )

#pragma data_seg("seg01633")
MAKE_SEGMENT_BODY( Segment01633, 1633 )

#pragma data_seg("seg01634")
MAKE_SEGMENT_BODY( Segment01634, 1634 )

#pragma data_seg("seg01635")
MAKE_SEGMENT_BODY( Segment01635, 1635 )

#pragma data_seg("seg01636")
MAKE_SEGMENT_BODY( Segment01636, 1636 )

#pragma data_seg("seg01637")
MAKE_SEGMENT_BODY( Segment01637, 1637 )

#pragma data_seg("seg01638")
MAKE_SEGMENT_BODY( Segment01638, 1638 )

#pragma data_seg("seg01639")
MAKE_SEGMENT_BODY( Segment01639, 1639 )

#pragma data_seg("seg01640")
MAKE_SEGMENT_BODY( Segment01640, 1640 )

#pragma data_seg("seg01641")
MAKE_SEGMENT_BODY( Segment01641, 1641 )

#pragma data_seg("seg01642")
MAKE_SEGMENT_BODY( Segment01642, 1642 )

#pragma data_seg("seg01643")
MAKE_SEGMENT_BODY( Segment01643, 1643 )

#pragma data_seg("seg01644")
MAKE_SEGMENT_BODY( Segment01644, 1644 )

#pragma data_seg("seg01645")
MAKE_SEGMENT_BODY( Segment01645, 1645 )

#pragma data_seg("seg01646")
MAKE_SEGMENT_BODY( Segment01646, 1646 )

#pragma data_seg("seg01647")
MAKE_SEGMENT_BODY( Segment01647, 1647 )

#pragma data_seg("seg01648")
MAKE_SEGMENT_BODY( Segment01648, 1648 )

#pragma data_seg("seg01649")
MAKE_SEGMENT_BODY( Segment01649, 1649 )

#pragma data_seg("seg01650")
MAKE_SEGMENT_BODY( Segment01650, 1650 )

#pragma data_seg("seg01651")
MAKE_SEGMENT_BODY( Segment01651, 1651 )

#pragma data_seg("seg01652")
MAKE_SEGMENT_BODY( Segment01652, 1652 )

#pragma data_seg("seg01653")
MAKE_SEGMENT_BODY( Segment01653, 1653 )

#pragma data_seg("seg01654")
MAKE_SEGMENT_BODY( Segment01654, 1654 )

#pragma data_seg("seg01655")
MAKE_SEGMENT_BODY( Segment01655, 1655 )

#pragma data_seg("seg01656")
MAKE_SEGMENT_BODY( Segment01656, 1656 )

#pragma data_seg("seg01657")
MAKE_SEGMENT_BODY( Segment01657, 1657 )

#pragma data_seg("seg01658")
MAKE_SEGMENT_BODY( Segment01658, 1658 )

#pragma data_seg("seg01659")
MAKE_SEGMENT_BODY( Segment01659, 1659 )

#pragma data_seg("seg01660")
MAKE_SEGMENT_BODY( Segment01660, 1660 )

#pragma data_seg("seg01661")
MAKE_SEGMENT_BODY( Segment01661, 1661 )

#pragma data_seg("seg01662")
MAKE_SEGMENT_BODY( Segment01662, 1662 )

#pragma data_seg("seg01663")
MAKE_SEGMENT_BODY( Segment01663, 1663 )

#pragma data_seg("seg01664")
MAKE_SEGMENT_BODY( Segment01664, 1664 )

#pragma data_seg("seg01665")
MAKE_SEGMENT_BODY( Segment01665, 1665 )

#pragma data_seg("seg01666")
MAKE_SEGMENT_BODY( Segment01666, 1666 )

#pragma data_seg("seg01667")
MAKE_SEGMENT_BODY( Segment01667, 1667 )

#pragma data_seg("seg01668")
MAKE_SEGMENT_BODY( Segment01668, 1668 )

#pragma data_seg("seg01669")
MAKE_SEGMENT_BODY( Segment01669, 1669 )

#pragma data_seg("seg01670")
MAKE_SEGMENT_BODY( Segment01670, 1670 )

#pragma data_seg("seg01671")
MAKE_SEGMENT_BODY( Segment01671, 1671 )

#pragma data_seg("seg01672")
MAKE_SEGMENT_BODY( Segment01672, 1672 )

#pragma data_seg("seg01673")
MAKE_SEGMENT_BODY( Segment01673, 1673 )

#pragma data_seg("seg01674")
MAKE_SEGMENT_BODY( Segment01674, 1674 )

#pragma data_seg("seg01675")
MAKE_SEGMENT_BODY( Segment01675, 1675 )

#pragma data_seg("seg01676")
MAKE_SEGMENT_BODY( Segment01676, 1676 )

#pragma data_seg("seg01677")
MAKE_SEGMENT_BODY( Segment01677, 1677 )

#pragma data_seg("seg01678")
MAKE_SEGMENT_BODY( Segment01678, 1678 )

#pragma data_seg("seg01679")
MAKE_SEGMENT_BODY( Segment01679, 1679 )

#pragma data_seg("seg01680")
MAKE_SEGMENT_BODY( Segment01680, 1680 )

#pragma data_seg("seg01681")
MAKE_SEGMENT_BODY( Segment01681, 1681 )

#pragma data_seg("seg01682")
MAKE_SEGMENT_BODY( Segment01682, 1682 )

#pragma data_seg("seg01683")
MAKE_SEGMENT_BODY( Segment01683, 1683 )

#pragma data_seg("seg01684")
MAKE_SEGMENT_BODY( Segment01684, 1684 )

#pragma data_seg("seg01685")
MAKE_SEGMENT_BODY( Segment01685, 1685 )

#pragma data_seg("seg01686")
MAKE_SEGMENT_BODY( Segment01686, 1686 )

#pragma data_seg("seg01687")
MAKE_SEGMENT_BODY( Segment01687, 1687 )

#pragma data_seg("seg01688")
MAKE_SEGMENT_BODY( Segment01688, 1688 )

#pragma data_seg("seg01689")
MAKE_SEGMENT_BODY( Segment01689, 1689 )

#pragma data_seg("seg01690")
MAKE_SEGMENT_BODY( Segment01690, 1690 )

#pragma data_seg("seg01691")
MAKE_SEGMENT_BODY( Segment01691, 1691 )

#pragma data_seg("seg01692")
MAKE_SEGMENT_BODY( Segment01692, 1692 )

#pragma data_seg("seg01693")
MAKE_SEGMENT_BODY( Segment01693, 1693 )

#pragma data_seg("seg01694")
MAKE_SEGMENT_BODY( Segment01694, 1694 )

#pragma data_seg("seg01695")
MAKE_SEGMENT_BODY( Segment01695, 1695 )

#pragma data_seg("seg01696")
MAKE_SEGMENT_BODY( Segment01696, 1696 )

#pragma data_seg("seg01697")
MAKE_SEGMENT_BODY( Segment01697, 1697 )

#pragma data_seg("seg01698")
MAKE_SEGMENT_BODY( Segment01698, 1698 )

#pragma data_seg("seg01699")
MAKE_SEGMENT_BODY( Segment01699, 1699 )

#pragma data_seg("seg01700")
MAKE_SEGMENT_BODY( Segment01700, 1700 )

#pragma data_seg("seg01701")
MAKE_SEGMENT_BODY( Segment01701, 1701 )

#pragma data_seg("seg01702")
MAKE_SEGMENT_BODY( Segment01702, 1702 )

#pragma data_seg("seg01703")
MAKE_SEGMENT_BODY( Segment01703, 1703 )

#pragma data_seg("seg01704")
MAKE_SEGMENT_BODY( Segment01704, 1704 )

#pragma data_seg("seg01705")
MAKE_SEGMENT_BODY( Segment01705, 1705 )

#pragma data_seg("seg01706")
MAKE_SEGMENT_BODY( Segment01706, 1706 )

#pragma data_seg("seg01707")
MAKE_SEGMENT_BODY( Segment01707, 1707 )

#pragma data_seg("seg01708")
MAKE_SEGMENT_BODY( Segment01708, 1708 )

#pragma data_seg("seg01709")
MAKE_SEGMENT_BODY( Segment01709, 1709 )

#pragma data_seg("seg01710")
MAKE_SEGMENT_BODY( Segment01710, 1710 )

#pragma data_seg("seg01711")
MAKE_SEGMENT_BODY( Segment01711, 1711 )

#pragma data_seg("seg01712")
MAKE_SEGMENT_BODY( Segment01712, 1712 )

#pragma data_seg("seg01713")
MAKE_SEGMENT_BODY( Segment01713, 1713 )

#pragma data_seg("seg01714")
MAKE_SEGMENT_BODY( Segment01714, 1714 )

#pragma data_seg("seg01715")
MAKE_SEGMENT_BODY( Segment01715, 1715 )

#pragma data_seg("seg01716")
MAKE_SEGMENT_BODY( Segment01716, 1716 )

#pragma data_seg("seg01717")
MAKE_SEGMENT_BODY( Segment01717, 1717 )

#pragma data_seg("seg01718")
MAKE_SEGMENT_BODY( Segment01718, 1718 )

#pragma data_seg("seg01719")
MAKE_SEGMENT_BODY( Segment01719, 1719 )

#pragma data_seg("seg01720")
MAKE_SEGMENT_BODY( Segment01720, 1720 )

#pragma data_seg("seg01721")
MAKE_SEGMENT_BODY( Segment01721, 1721 )

#pragma data_seg("seg01722")
MAKE_SEGMENT_BODY( Segment01722, 1722 )

#pragma data_seg("seg01723")
MAKE_SEGMENT_BODY( Segment01723, 1723 )

#pragma data_seg("seg01724")
MAKE_SEGMENT_BODY( Segment01724, 1724 )

#pragma data_seg("seg01725")
MAKE_SEGMENT_BODY( Segment01725, 1725 )

#pragma data_seg("seg01726")
MAKE_SEGMENT_BODY( Segment01726, 1726 )

#pragma data_seg("seg01727")
MAKE_SEGMENT_BODY( Segment01727, 1727 )

#pragma data_seg("seg01728")
MAKE_SEGMENT_BODY( Segment01728, 1728 )

#pragma data_seg("seg01729")
MAKE_SEGMENT_BODY( Segment01729, 1729 )

#pragma data_seg("seg01730")
MAKE_SEGMENT_BODY( Segment01730, 1730 )

#pragma data_seg("seg01731")
MAKE_SEGMENT_BODY( Segment01731, 1731 )

#pragma data_seg("seg01732")
MAKE_SEGMENT_BODY( Segment01732, 1732 )

#pragma data_seg("seg01733")
MAKE_SEGMENT_BODY( Segment01733, 1733 )

#pragma data_seg("seg01734")
MAKE_SEGMENT_BODY( Segment01734, 1734 )

#pragma data_seg("seg01735")
MAKE_SEGMENT_BODY( Segment01735, 1735 )

#pragma data_seg("seg01736")
MAKE_SEGMENT_BODY( Segment01736, 1736 )

#pragma data_seg("seg01737")
MAKE_SEGMENT_BODY( Segment01737, 1737 )

#pragma data_seg("seg01738")
MAKE_SEGMENT_BODY( Segment01738, 1738 )

#pragma data_seg("seg01739")
MAKE_SEGMENT_BODY( Segment01739, 1739 )

#pragma data_seg("seg01740")
MAKE_SEGMENT_BODY( Segment01740, 1740 )

#pragma data_seg("seg01741")
MAKE_SEGMENT_BODY( Segment01741, 1741 )

#pragma data_seg("seg01742")
MAKE_SEGMENT_BODY( Segment01742, 1742 )

#pragma data_seg("seg01743")
MAKE_SEGMENT_BODY( Segment01743, 1743 )

#pragma data_seg("seg01744")
MAKE_SEGMENT_BODY( Segment01744, 1744 )

#pragma data_seg("seg01745")
MAKE_SEGMENT_BODY( Segment01745, 1745 )

#pragma data_seg("seg01746")
MAKE_SEGMENT_BODY( Segment01746, 1746 )

#pragma data_seg("seg01747")
MAKE_SEGMENT_BODY( Segment01747, 1747 )

#pragma data_seg("seg01748")
MAKE_SEGMENT_BODY( Segment01748, 1748 )

#pragma data_seg("seg01749")
MAKE_SEGMENT_BODY( Segment01749, 1749 )

#pragma data_seg("seg01750")
MAKE_SEGMENT_BODY( Segment01750, 1750 )

#pragma data_seg("seg01751")
MAKE_SEGMENT_BODY( Segment01751, 1751 )

#pragma data_seg("seg01752")
MAKE_SEGMENT_BODY( Segment01752, 1752 )

#pragma data_seg("seg01753")
MAKE_SEGMENT_BODY( Segment01753, 1753 )

#pragma data_seg("seg01754")
MAKE_SEGMENT_BODY( Segment01754, 1754 )

#pragma data_seg("seg01755")
MAKE_SEGMENT_BODY( Segment01755, 1755 )

#pragma data_seg("seg01756")
MAKE_SEGMENT_BODY( Segment01756, 1756 )

#pragma data_seg("seg01757")
MAKE_SEGMENT_BODY( Segment01757, 1757 )

#pragma data_seg("seg01758")
MAKE_SEGMENT_BODY( Segment01758, 1758 )

#pragma data_seg("seg01759")
MAKE_SEGMENT_BODY( Segment01759, 1759 )

#pragma data_seg("seg01760")
MAKE_SEGMENT_BODY( Segment01760, 1760 )

#pragma data_seg("seg01761")
MAKE_SEGMENT_BODY( Segment01761, 1761 )

#pragma data_seg("seg01762")
MAKE_SEGMENT_BODY( Segment01762, 1762 )

#pragma data_seg("seg01763")
MAKE_SEGMENT_BODY( Segment01763, 1763 )

#pragma data_seg("seg01764")
MAKE_SEGMENT_BODY( Segment01764, 1764 )

#pragma data_seg("seg01765")
MAKE_SEGMENT_BODY( Segment01765, 1765 )

#pragma data_seg("seg01766")
MAKE_SEGMENT_BODY( Segment01766, 1766 )

#pragma data_seg("seg01767")
MAKE_SEGMENT_BODY( Segment01767, 1767 )

#pragma data_seg("seg01768")
MAKE_SEGMENT_BODY( Segment01768, 1768 )

#pragma data_seg("seg01769")
MAKE_SEGMENT_BODY( Segment01769, 1769 )

#pragma data_seg("seg01770")
MAKE_SEGMENT_BODY( Segment01770, 1770 )

#pragma data_seg("seg01771")
MAKE_SEGMENT_BODY( Segment01771, 1771 )

#pragma data_seg("seg01772")
MAKE_SEGMENT_BODY( Segment01772, 1772 )

#pragma data_seg("seg01773")
MAKE_SEGMENT_BODY( Segment01773, 1773 )

#pragma data_seg("seg01774")
MAKE_SEGMENT_BODY( Segment01774, 1774 )

#pragma data_seg("seg01775")
MAKE_SEGMENT_BODY( Segment01775, 1775 )

#pragma data_seg("seg01776")
MAKE_SEGMENT_BODY( Segment01776, 1776 )

#pragma data_seg("seg01777")
MAKE_SEGMENT_BODY( Segment01777, 1777 )

#pragma data_seg("seg01778")
MAKE_SEGMENT_BODY( Segment01778, 1778 )

#pragma data_seg("seg01779")
MAKE_SEGMENT_BODY( Segment01779, 1779 )

#pragma data_seg("seg01780")
MAKE_SEGMENT_BODY( Segment01780, 1780 )

#pragma data_seg("seg01781")
MAKE_SEGMENT_BODY( Segment01781, 1781 )

#pragma data_seg("seg01782")
MAKE_SEGMENT_BODY( Segment01782, 1782 )

#pragma data_seg("seg01783")
MAKE_SEGMENT_BODY( Segment01783, 1783 )

#pragma data_seg("seg01784")
MAKE_SEGMENT_BODY( Segment01784, 1784 )

#pragma data_seg("seg01785")
MAKE_SEGMENT_BODY( Segment01785, 1785 )

#pragma data_seg("seg01786")
MAKE_SEGMENT_BODY( Segment01786, 1786 )

#pragma data_seg("seg01787")
MAKE_SEGMENT_BODY( Segment01787, 1787 )

#pragma data_seg("seg01788")
MAKE_SEGMENT_BODY( Segment01788, 1788 )

#pragma data_seg("seg01789")
MAKE_SEGMENT_BODY( Segment01789, 1789 )

#pragma data_seg("seg01790")
MAKE_SEGMENT_BODY( Segment01790, 1790 )

#pragma data_seg("seg01791")
MAKE_SEGMENT_BODY( Segment01791, 1791 )

#pragma data_seg("seg01792")
MAKE_SEGMENT_BODY( Segment01792, 1792 )

#pragma data_seg("seg01793")
MAKE_SEGMENT_BODY( Segment01793, 1793 )

#pragma data_seg("seg01794")
MAKE_SEGMENT_BODY( Segment01794, 1794 )

#pragma data_seg("seg01795")
MAKE_SEGMENT_BODY( Segment01795, 1795 )

#pragma data_seg("seg01796")
MAKE_SEGMENT_BODY( Segment01796, 1796 )

#pragma data_seg("seg01797")
MAKE_SEGMENT_BODY( Segment01797, 1797 )

#pragma data_seg("seg01798")
MAKE_SEGMENT_BODY( Segment01798, 1798 )

#pragma data_seg("seg01799")
MAKE_SEGMENT_BODY( Segment01799, 1799 )

#pragma data_seg("seg01800")
MAKE_SEGMENT_BODY( Segment01800, 1800 )

#pragma data_seg("seg01801")
MAKE_SEGMENT_BODY( Segment01801, 1801 )

#pragma data_seg("seg01802")
MAKE_SEGMENT_BODY( Segment01802, 1802 )

#pragma data_seg("seg01803")
MAKE_SEGMENT_BODY( Segment01803, 1803 )

#pragma data_seg("seg01804")
MAKE_SEGMENT_BODY( Segment01804, 1804 )

#pragma data_seg("seg01805")
MAKE_SEGMENT_BODY( Segment01805, 1805 )

#pragma data_seg("seg01806")
MAKE_SEGMENT_BODY( Segment01806, 1806 )

#pragma data_seg("seg01807")
MAKE_SEGMENT_BODY( Segment01807, 1807 )

#pragma data_seg("seg01808")
MAKE_SEGMENT_BODY( Segment01808, 1808 )

#pragma data_seg("seg01809")
MAKE_SEGMENT_BODY( Segment01809, 1809 )

#pragma data_seg("seg01810")
MAKE_SEGMENT_BODY( Segment01810, 1810 )

#pragma data_seg("seg01811")
MAKE_SEGMENT_BODY( Segment01811, 1811 )

#pragma data_seg("seg01812")
MAKE_SEGMENT_BODY( Segment01812, 1812 )

#pragma data_seg("seg01813")
MAKE_SEGMENT_BODY( Segment01813, 1813 )

#pragma data_seg("seg01814")
MAKE_SEGMENT_BODY( Segment01814, 1814 )

#pragma data_seg("seg01815")
MAKE_SEGMENT_BODY( Segment01815, 1815 )

#pragma data_seg("seg01816")
MAKE_SEGMENT_BODY( Segment01816, 1816 )

#pragma data_seg("seg01817")
MAKE_SEGMENT_BODY( Segment01817, 1817 )

#pragma data_seg("seg01818")
MAKE_SEGMENT_BODY( Segment01818, 1818 )

#pragma data_seg("seg01819")
MAKE_SEGMENT_BODY( Segment01819, 1819 )

#pragma data_seg("seg01820")
MAKE_SEGMENT_BODY( Segment01820, 1820 )

#pragma data_seg("seg01821")
MAKE_SEGMENT_BODY( Segment01821, 1821 )

#pragma data_seg("seg01822")
MAKE_SEGMENT_BODY( Segment01822, 1822 )

#pragma data_seg("seg01823")
MAKE_SEGMENT_BODY( Segment01823, 1823 )

#pragma data_seg("seg01824")
MAKE_SEGMENT_BODY( Segment01824, 1824 )

#pragma data_seg("seg01825")
MAKE_SEGMENT_BODY( Segment01825, 1825 )

#pragma data_seg("seg01826")
MAKE_SEGMENT_BODY( Segment01826, 1826 )

#pragma data_seg("seg01827")
MAKE_SEGMENT_BODY( Segment01827, 1827 )

#pragma data_seg("seg01828")
MAKE_SEGMENT_BODY( Segment01828, 1828 )

#pragma data_seg("seg01829")
MAKE_SEGMENT_BODY( Segment01829, 1829 )

#pragma data_seg("seg01830")
MAKE_SEGMENT_BODY( Segment01830, 1830 )

#pragma data_seg("seg01831")
MAKE_SEGMENT_BODY( Segment01831, 1831 )

#pragma data_seg("seg01832")
MAKE_SEGMENT_BODY( Segment01832, 1832 )

#pragma data_seg("seg01833")
MAKE_SEGMENT_BODY( Segment01833, 1833 )

#pragma data_seg("seg01834")
MAKE_SEGMENT_BODY( Segment01834, 1834 )

#pragma data_seg("seg01835")
MAKE_SEGMENT_BODY( Segment01835, 1835 )

#pragma data_seg("seg01836")
MAKE_SEGMENT_BODY( Segment01836, 1836 )

#pragma data_seg("seg01837")
MAKE_SEGMENT_BODY( Segment01837, 1837 )

#pragma data_seg("seg01838")
MAKE_SEGMENT_BODY( Segment01838, 1838 )

#pragma data_seg("seg01839")
MAKE_SEGMENT_BODY( Segment01839, 1839 )

#pragma data_seg("seg01840")
MAKE_SEGMENT_BODY( Segment01840, 1840 )

#pragma data_seg("seg01841")
MAKE_SEGMENT_BODY( Segment01841, 1841 )

#pragma data_seg("seg01842")
MAKE_SEGMENT_BODY( Segment01842, 1842 )

#pragma data_seg("seg01843")
MAKE_SEGMENT_BODY( Segment01843, 1843 )

#pragma data_seg("seg01844")
MAKE_SEGMENT_BODY( Segment01844, 1844 )

#pragma data_seg("seg01845")
MAKE_SEGMENT_BODY( Segment01845, 1845 )

#pragma data_seg("seg01846")
MAKE_SEGMENT_BODY( Segment01846, 1846 )

#pragma data_seg("seg01847")
MAKE_SEGMENT_BODY( Segment01847, 1847 )

#pragma data_seg("seg01848")
MAKE_SEGMENT_BODY( Segment01848, 1848 )

#pragma data_seg("seg01849")
MAKE_SEGMENT_BODY( Segment01849, 1849 )

#pragma data_seg("seg01850")
MAKE_SEGMENT_BODY( Segment01850, 1850 )

#pragma data_seg("seg01851")
MAKE_SEGMENT_BODY( Segment01851, 1851 )

#pragma data_seg("seg01852")
MAKE_SEGMENT_BODY( Segment01852, 1852 )

#pragma data_seg("seg01853")
MAKE_SEGMENT_BODY( Segment01853, 1853 )

#pragma data_seg("seg01854")
MAKE_SEGMENT_BODY( Segment01854, 1854 )

#pragma data_seg("seg01855")
MAKE_SEGMENT_BODY( Segment01855, 1855 )

#pragma data_seg("seg01856")
MAKE_SEGMENT_BODY( Segment01856, 1856 )

#pragma data_seg("seg01857")
MAKE_SEGMENT_BODY( Segment01857, 1857 )

#pragma data_seg("seg01858")
MAKE_SEGMENT_BODY( Segment01858, 1858 )

#pragma data_seg("seg01859")
MAKE_SEGMENT_BODY( Segment01859, 1859 )

#pragma data_seg("seg01860")
MAKE_SEGMENT_BODY( Segment01860, 1860 )

#pragma data_seg("seg01861")
MAKE_SEGMENT_BODY( Segment01861, 1861 )

#pragma data_seg("seg01862")
MAKE_SEGMENT_BODY( Segment01862, 1862 )

#pragma data_seg("seg01863")
MAKE_SEGMENT_BODY( Segment01863, 1863 )

#pragma data_seg("seg01864")
MAKE_SEGMENT_BODY( Segment01864, 1864 )

#pragma data_seg("seg01865")
MAKE_SEGMENT_BODY( Segment01865, 1865 )

#pragma data_seg("seg01866")
MAKE_SEGMENT_BODY( Segment01866, 1866 )

#pragma data_seg("seg01867")
MAKE_SEGMENT_BODY( Segment01867, 1867 )

#pragma data_seg("seg01868")
MAKE_SEGMENT_BODY( Segment01868, 1868 )

#pragma data_seg("seg01869")
MAKE_SEGMENT_BODY( Segment01869, 1869 )

#pragma data_seg("seg01870")
MAKE_SEGMENT_BODY( Segment01870, 1870 )

#pragma data_seg("seg01871")
MAKE_SEGMENT_BODY( Segment01871, 1871 )

#pragma data_seg("seg01872")
MAKE_SEGMENT_BODY( Segment01872, 1872 )

#pragma data_seg("seg01873")
MAKE_SEGMENT_BODY( Segment01873, 1873 )

#pragma data_seg("seg01874")
MAKE_SEGMENT_BODY( Segment01874, 1874 )

#pragma data_seg("seg01875")
MAKE_SEGMENT_BODY( Segment01875, 1875 )

#pragma data_seg("seg01876")
MAKE_SEGMENT_BODY( Segment01876, 1876 )

#pragma data_seg("seg01877")
MAKE_SEGMENT_BODY( Segment01877, 1877 )

#pragma data_seg("seg01878")
MAKE_SEGMENT_BODY( Segment01878, 1878 )

#pragma data_seg("seg01879")
MAKE_SEGMENT_BODY( Segment01879, 1879 )

#pragma data_seg("seg01880")
MAKE_SEGMENT_BODY( Segment01880, 1880 )

#pragma data_seg("seg01881")
MAKE_SEGMENT_BODY( Segment01881, 1881 )

#pragma data_seg("seg01882")
MAKE_SEGMENT_BODY( Segment01882, 1882 )

#pragma data_seg("seg01883")
MAKE_SEGMENT_BODY( Segment01883, 1883 )

#pragma data_seg("seg01884")
MAKE_SEGMENT_BODY( Segment01884, 1884 )

#pragma data_seg("seg01885")
MAKE_SEGMENT_BODY( Segment01885, 1885 )

#pragma data_seg("seg01886")
MAKE_SEGMENT_BODY( Segment01886, 1886 )

#pragma data_seg("seg01887")
MAKE_SEGMENT_BODY( Segment01887, 1887 )

#pragma data_seg("seg01888")
MAKE_SEGMENT_BODY( Segment01888, 1888 )

#pragma data_seg("seg01889")
MAKE_SEGMENT_BODY( Segment01889, 1889 )

#pragma data_seg("seg01890")
MAKE_SEGMENT_BODY( Segment01890, 1890 )

#pragma data_seg("seg01891")
MAKE_SEGMENT_BODY( Segment01891, 1891 )

#pragma data_seg("seg01892")
MAKE_SEGMENT_BODY( Segment01892, 1892 )

#pragma data_seg("seg01893")
MAKE_SEGMENT_BODY( Segment01893, 1893 )

#pragma data_seg("seg01894")
MAKE_SEGMENT_BODY( Segment01894, 1894 )

#pragma data_seg("seg01895")
MAKE_SEGMENT_BODY( Segment01895, 1895 )

#pragma data_seg("seg01896")
MAKE_SEGMENT_BODY( Segment01896, 1896 )

#pragma data_seg("seg01897")
MAKE_SEGMENT_BODY( Segment01897, 1897 )

#pragma data_seg("seg01898")
MAKE_SEGMENT_BODY( Segment01898, 1898 )

#pragma data_seg("seg01899")
MAKE_SEGMENT_BODY( Segment01899, 1899 )

#pragma data_seg("seg01900")
MAKE_SEGMENT_BODY( Segment01900, 1900 )

#pragma data_seg("seg01901")
MAKE_SEGMENT_BODY( Segment01901, 1901 )

#pragma data_seg("seg01902")
MAKE_SEGMENT_BODY( Segment01902, 1902 )

#pragma data_seg("seg01903")
MAKE_SEGMENT_BODY( Segment01903, 1903 )

#pragma data_seg("seg01904")
MAKE_SEGMENT_BODY( Segment01904, 1904 )

#pragma data_seg("seg01905")
MAKE_SEGMENT_BODY( Segment01905, 1905 )

#pragma data_seg("seg01906")
MAKE_SEGMENT_BODY( Segment01906, 1906 )

#pragma data_seg("seg01907")
MAKE_SEGMENT_BODY( Segment01907, 1907 )

#pragma data_seg("seg01908")
MAKE_SEGMENT_BODY( Segment01908, 1908 )

#pragma data_seg("seg01909")
MAKE_SEGMENT_BODY( Segment01909, 1909 )

#pragma data_seg("seg01910")
MAKE_SEGMENT_BODY( Segment01910, 1910 )

#pragma data_seg("seg01911")
MAKE_SEGMENT_BODY( Segment01911, 1911 )

#pragma data_seg("seg01912")
MAKE_SEGMENT_BODY( Segment01912, 1912 )

#pragma data_seg("seg01913")
MAKE_SEGMENT_BODY( Segment01913, 1913 )

#pragma data_seg("seg01914")
MAKE_SEGMENT_BODY( Segment01914, 1914 )

#pragma data_seg("seg01915")
MAKE_SEGMENT_BODY( Segment01915, 1915 )

#pragma data_seg("seg01916")
MAKE_SEGMENT_BODY( Segment01916, 1916 )

#pragma data_seg("seg01917")
MAKE_SEGMENT_BODY( Segment01917, 1917 )

#pragma data_seg("seg01918")
MAKE_SEGMENT_BODY( Segment01918, 1918 )

#pragma data_seg("seg01919")
MAKE_SEGMENT_BODY( Segment01919, 1919 )

#pragma data_seg("seg01920")
MAKE_SEGMENT_BODY( Segment01920, 1920 )

#pragma data_seg("seg01921")
MAKE_SEGMENT_BODY( Segment01921, 1921 )

#pragma data_seg("seg01922")
MAKE_SEGMENT_BODY( Segment01922, 1922 )

#pragma data_seg("seg01923")
MAKE_SEGMENT_BODY( Segment01923, 1923 )

#pragma data_seg("seg01924")
MAKE_SEGMENT_BODY( Segment01924, 1924 )

#pragma data_seg("seg01925")
MAKE_SEGMENT_BODY( Segment01925, 1925 )

#pragma data_seg("seg01926")
MAKE_SEGMENT_BODY( Segment01926, 1926 )

#pragma data_seg("seg01927")
MAKE_SEGMENT_BODY( Segment01927, 1927 )

#pragma data_seg("seg01928")
MAKE_SEGMENT_BODY( Segment01928, 1928 )

#pragma data_seg("seg01929")
MAKE_SEGMENT_BODY( Segment01929, 1929 )

#pragma data_seg("seg01930")
MAKE_SEGMENT_BODY( Segment01930, 1930 )

#pragma data_seg("seg01931")
MAKE_SEGMENT_BODY( Segment01931, 1931 )

#pragma data_seg("seg01932")
MAKE_SEGMENT_BODY( Segment01932, 1932 )

#pragma data_seg("seg01933")
MAKE_SEGMENT_BODY( Segment01933, 1933 )

#pragma data_seg("seg01934")
MAKE_SEGMENT_BODY( Segment01934, 1934 )

#pragma data_seg("seg01935")
MAKE_SEGMENT_BODY( Segment01935, 1935 )

#pragma data_seg("seg01936")
MAKE_SEGMENT_BODY( Segment01936, 1936 )

#pragma data_seg("seg01937")
MAKE_SEGMENT_BODY( Segment01937, 1937 )

#pragma data_seg("seg01938")
MAKE_SEGMENT_BODY( Segment01938, 1938 )

#pragma data_seg("seg01939")
MAKE_SEGMENT_BODY( Segment01939, 1939 )

#pragma data_seg("seg01940")
MAKE_SEGMENT_BODY( Segment01940, 1940 )

#pragma data_seg("seg01941")
MAKE_SEGMENT_BODY( Segment01941, 1941 )

#pragma data_seg("seg01942")
MAKE_SEGMENT_BODY( Segment01942, 1942 )

#pragma data_seg("seg01943")
MAKE_SEGMENT_BODY( Segment01943, 1943 )

#pragma data_seg("seg01944")
MAKE_SEGMENT_BODY( Segment01944, 1944 )
char seg_cSegment01944bonus[2048*1024] = {0};

#pragma data_seg("seg01945")
MAKE_SEGMENT_BODY( Segment01945, 1945 )

#pragma data_seg("seg01946")
MAKE_SEGMENT_BODY( Segment01946, 1946 )

#pragma data_seg("seg01947")
MAKE_SEGMENT_BODY( Segment01947, 1947 )

#pragma data_seg("seg01948")
MAKE_SEGMENT_BODY( Segment01948, 1948 )

#pragma data_seg("seg01949")
MAKE_SEGMENT_BODY( Segment01949, 1949 )

#pragma data_seg("seg01950")
MAKE_SEGMENT_BODY( Segment01950, 1950 )

#pragma data_seg("seg01951")
MAKE_SEGMENT_BODY( Segment01951, 1951 )

#pragma data_seg("seg01952")
MAKE_SEGMENT_BODY( Segment01952, 1952 )

#pragma data_seg("seg01953")
MAKE_SEGMENT_BODY( Segment01953, 1953 )

#pragma data_seg("seg01954")
MAKE_SEGMENT_BODY( Segment01954, 1954 )

#pragma data_seg("seg01955")
MAKE_SEGMENT_BODY( Segment01955, 1955 )

#pragma data_seg("seg01956")
MAKE_SEGMENT_BODY( Segment01956, 1956 )

#pragma data_seg("seg01957")
MAKE_SEGMENT_BODY( Segment01957, 1957 )

#pragma data_seg("seg01958")
MAKE_SEGMENT_BODY( Segment01958, 1958 )

#pragma data_seg("seg01959")
MAKE_SEGMENT_BODY( Segment01959, 1959 )

#pragma data_seg("seg01960")
MAKE_SEGMENT_BODY( Segment01960, 1960 )

#pragma data_seg("seg01961")
MAKE_SEGMENT_BODY( Segment01961, 1961 )

#pragma data_seg("seg01962")
MAKE_SEGMENT_BODY( Segment01962, 1962 )

#pragma data_seg("seg01963")
MAKE_SEGMENT_BODY( Segment01963, 1963 )

#pragma data_seg("seg01964")
MAKE_SEGMENT_BODY( Segment01964, 1964 )

#pragma data_seg("seg01965")
MAKE_SEGMENT_BODY( Segment01965, 1965 )

#pragma data_seg("seg01966")
MAKE_SEGMENT_BODY( Segment01966, 1966 )

#pragma data_seg("seg01967")
MAKE_SEGMENT_BODY( Segment01967, 1967 )

#pragma data_seg("seg01968")
MAKE_SEGMENT_BODY( Segment01968, 1968 )

#pragma data_seg("seg01969")
MAKE_SEGMENT_BODY( Segment01969, 1969 )

#pragma data_seg("seg01970")
MAKE_SEGMENT_BODY( Segment01970, 1970 )

#pragma data_seg("seg01971")
MAKE_SEGMENT_BODY( Segment01971, 1971 )

#pragma data_seg("seg01972")
MAKE_SEGMENT_BODY( Segment01972, 1972 )

#pragma data_seg("seg01973")
MAKE_SEGMENT_BODY( Segment01973, 1973 )

#pragma data_seg("seg01974")
MAKE_SEGMENT_BODY( Segment01974, 1974 )

#pragma data_seg("seg01975")
MAKE_SEGMENT_BODY( Segment01975, 1975 )

#pragma data_seg("seg01976")
MAKE_SEGMENT_BODY( Segment01976, 1976 )

#pragma data_seg("seg01977")
MAKE_SEGMENT_BODY( Segment01977, 1977 )

#pragma data_seg("seg01978")
MAKE_SEGMENT_BODY( Segment01978, 1978 )

#pragma data_seg("seg01979")
MAKE_SEGMENT_BODY( Segment01979, 1979 )

#pragma data_seg("seg01980")
MAKE_SEGMENT_BODY( Segment01980, 1980 )

#pragma data_seg("seg01981")
MAKE_SEGMENT_BODY( Segment01981, 1981 )

#pragma data_seg("seg01982")
MAKE_SEGMENT_BODY( Segment01982, 1982 )

#pragma data_seg("seg01983")
MAKE_SEGMENT_BODY( Segment01983, 1983 )

#pragma data_seg("seg01984")
MAKE_SEGMENT_BODY( Segment01984, 1984 )

#pragma data_seg("seg01985")
MAKE_SEGMENT_BODY( Segment01985, 1985 )

#pragma data_seg("seg01986")
MAKE_SEGMENT_BODY( Segment01986, 1986 )

#pragma data_seg("seg01987")
MAKE_SEGMENT_BODY( Segment01987, 1987 )

#pragma data_seg("seg01988")
MAKE_SEGMENT_BODY( Segment01988, 1988 )

#pragma data_seg("seg01989")
MAKE_SEGMENT_BODY( Segment01989, 1989 )

#pragma data_seg("seg01990")
MAKE_SEGMENT_BODY( Segment01990, 1990 )

#pragma data_seg("seg01991")
MAKE_SEGMENT_BODY( Segment01991, 1991 )

#pragma data_seg("seg01992")
MAKE_SEGMENT_BODY( Segment01992, 1992 )

#pragma data_seg("seg01993")
MAKE_SEGMENT_BODY( Segment01993, 1993 )

#pragma data_seg("seg01994")
MAKE_SEGMENT_BODY( Segment01994, 1994 )

#pragma data_seg("seg01995")
MAKE_SEGMENT_BODY( Segment01995, 1995 )

#pragma data_seg("seg01996")
MAKE_SEGMENT_BODY( Segment01996, 1996 )

#pragma data_seg("seg01997")
MAKE_SEGMENT_BODY( Segment01997, 1997 )

#pragma data_seg("seg01998")
MAKE_SEGMENT_BODY( Segment01998, 1998 )

#pragma data_seg("seg01999")
MAKE_SEGMENT_BODY( Segment01999, 1999 )

#pragma data_seg("seg02000")
MAKE_SEGMENT_BODY( Segment02000, 2000 )

#pragma data_seg("seg02001")
MAKE_SEGMENT_BODY( Segment02001, 2001 )

#pragma data_seg("seg02002")
MAKE_SEGMENT_BODY( Segment02002, 2002 )

#pragma data_seg("seg02003")
MAKE_SEGMENT_BODY( Segment02003, 2003 )

#pragma data_seg("seg02004")
MAKE_SEGMENT_BODY( Segment02004, 2004 )

#pragma data_seg("seg02005")
MAKE_SEGMENT_BODY( Segment02005, 2005 )

#pragma data_seg("seg02006")
MAKE_SEGMENT_BODY( Segment02006, 2006 )

#pragma data_seg("seg02007")
MAKE_SEGMENT_BODY( Segment02007, 2007 )

#pragma data_seg("seg02008")
MAKE_SEGMENT_BODY( Segment02008, 2008 )

#pragma data_seg("seg02009")
MAKE_SEGMENT_BODY( Segment02009, 2009 )

#pragma data_seg("seg02010")
MAKE_SEGMENT_BODY( Segment02010, 2010 )

#pragma data_seg("seg02011")
MAKE_SEGMENT_BODY( Segment02011, 2011 )

#pragma data_seg("seg02012")
MAKE_SEGMENT_BODY( Segment02012, 2012 )

#pragma data_seg("seg02013")
MAKE_SEGMENT_BODY( Segment02013, 2013 )

#pragma data_seg("seg02014")
MAKE_SEGMENT_BODY( Segment02014, 2014 )

#pragma data_seg("seg02015")
MAKE_SEGMENT_BODY( Segment02015, 2015 )

#pragma data_seg("seg02016")
MAKE_SEGMENT_BODY( Segment02016, 2016 )

#pragma data_seg("seg02017")
MAKE_SEGMENT_BODY( Segment02017, 2017 )

#pragma data_seg("seg02018")
MAKE_SEGMENT_BODY( Segment02018, 2018 )

#pragma data_seg("seg02019")
MAKE_SEGMENT_BODY( Segment02019, 2019 )

#pragma data_seg("seg02020")
MAKE_SEGMENT_BODY( Segment02020, 2020 )

#pragma data_seg("seg02021")
MAKE_SEGMENT_BODY( Segment02021, 2021 )

#pragma data_seg("seg02022")
MAKE_SEGMENT_BODY( Segment02022, 2022 )

#pragma data_seg("seg02023")
MAKE_SEGMENT_BODY( Segment02023, 2023 )

#pragma data_seg("seg02024")
MAKE_SEGMENT_BODY( Segment02024, 2024 )

#pragma data_seg("seg02025")
MAKE_SEGMENT_BODY( Segment02025, 2025 )

#pragma data_seg("seg02026")
MAKE_SEGMENT_BODY( Segment02026, 2026 )

#pragma data_seg("seg02027")
MAKE_SEGMENT_BODY( Segment02027, 2027 )

#pragma data_seg("seg02028")
MAKE_SEGMENT_BODY( Segment02028, 2028 )

#pragma data_seg("seg02029")
MAKE_SEGMENT_BODY( Segment02029, 2029 )

#pragma data_seg("seg02030")
MAKE_SEGMENT_BODY( Segment02030, 2030 )

#pragma data_seg("seg02031")
MAKE_SEGMENT_BODY( Segment02031, 2031 )

#pragma data_seg("seg02032")
MAKE_SEGMENT_BODY( Segment02032, 2032 )

#pragma data_seg("seg02033")
MAKE_SEGMENT_BODY( Segment02033, 2033 )

#pragma data_seg("seg02034")
MAKE_SEGMENT_BODY( Segment02034, 2034 )

#pragma data_seg("seg02035")
MAKE_SEGMENT_BODY( Segment02035, 2035 )

#pragma data_seg("seg02036")
MAKE_SEGMENT_BODY( Segment02036, 2036 )

#pragma data_seg("seg02037")
MAKE_SEGMENT_BODY( Segment02037, 2037 )

#pragma data_seg("seg02038")
MAKE_SEGMENT_BODY( Segment02038, 2038 )
char seg_cSegment02038bonus[10*1024*1024] = {0};

#pragma data_seg("seg02039")
MAKE_SEGMENT_BODY( Segment02039, 2039 )

#pragma data_seg("seg02040")
MAKE_SEGMENT_BODY( Segment02040, 2040 )

#pragma data_seg("seg02041")
MAKE_SEGMENT_BODY( Segment02041, 2041 )

#pragma data_seg("seg02042")
MAKE_SEGMENT_BODY( Segment02042, 2042 )

#pragma data_seg("seg02043")
MAKE_SEGMENT_BODY( Segment02043, 2043 )

#pragma data_seg("seg02044")
MAKE_SEGMENT_BODY( Segment02044, 2044 )

#pragma data_seg("seg02045")
MAKE_SEGMENT_BODY( Segment02045, 2045 )

#pragma data_seg("seg02046")
MAKE_SEGMENT_BODY( Segment02046, 2046 )

#pragma data_seg("seg02047")
MAKE_SEGMENT_BODY( Segment02047, 2047 )

#pragma  data_seg()


int *segmentValues[2048] =
    {
    &seg_iSegment00000,
    &seg_iSegment00001,
    &seg_iSegment00002,
    &seg_iSegment00003,
    &seg_iSegment00004,
    &seg_iSegment00005,
    &seg_iSegment00006,
    &seg_iSegment00007,
    &seg_iSegment00008,
    &seg_iSegment00009,
    &seg_iSegment00010,
    &seg_iSegment00011,
    &seg_iSegment00012,
    &seg_iSegment00013,
    &seg_iSegment00014,
    &seg_iSegment00015,
    &seg_iSegment00016,
    &seg_iSegment00017,
    &seg_iSegment00018,
    &seg_iSegment00019,
    &seg_iSegment00020,
    &seg_iSegment00021,
    &seg_iSegment00022,
    &seg_iSegment00023,
    &seg_iSegment00024,
    &seg_iSegment00025,
    &seg_iSegment00026,
    &seg_iSegment00027,
    &seg_iSegment00028,
    &seg_iSegment00029,
    &seg_iSegment00030,
    &seg_iSegment00031,
    &seg_iSegment00032,
    &seg_iSegment00033,
    &seg_iSegment00034,
    &seg_iSegment00035,
    &seg_iSegment00036,
    &seg_iSegment00037,
    &seg_iSegment00038,
    &seg_iSegment00039,
    &seg_iSegment00040,
    &seg_iSegment00041,
    &seg_iSegment00042,
    &seg_iSegment00043,
    &seg_iSegment00044,
    &seg_iSegment00045,
    &seg_iSegment00046,
    &seg_iSegment00047,
    &seg_iSegment00048,
    &seg_iSegment00049,
    &seg_iSegment00050,
    &seg_iSegment00051,
    &seg_iSegment00052,
    &seg_iSegment00053,
    &seg_iSegment00054,
    &seg_iSegment00055,
    &seg_iSegment00056,
    &seg_iSegment00057,
    &seg_iSegment00058,
    &seg_iSegment00059,
    &seg_iSegment00060,
    &seg_iSegment00061,
    &seg_iSegment00062,
    &seg_iSegment00063,
    &seg_iSegment00064,
    &seg_iSegment00065,
    &seg_iSegment00066,
    &seg_iSegment00067,
    &seg_iSegment00068,
    &seg_iSegment00069,
    &seg_iSegment00070,
    &seg_iSegment00071,
    &seg_iSegment00072,
    &seg_iSegment00073,
    &seg_iSegment00074,
    &seg_iSegment00075,
    &seg_iSegment00076,
    &seg_iSegment00077,
    &seg_iSegment00078,
    &seg_iSegment00079,
    &seg_iSegment00080,
    &seg_iSegment00081,
    &seg_iSegment00082,
    &seg_iSegment00083,
    &seg_iSegment00084,
    &seg_iSegment00085,
    &seg_iSegment00086,
    &seg_iSegment00087,
    &seg_iSegment00088,
    &seg_iSegment00089,
    &seg_iSegment00090,
    &seg_iSegment00091,
    &seg_iSegment00092,
    &seg_iSegment00093,
    &seg_iSegment00094,
    &seg_iSegment00095,
    &seg_iSegment00096,
    &seg_iSegment00097,
    &seg_iSegment00098,
    &seg_iSegment00099,
    &seg_iSegment00100,
    &seg_iSegment00101,
    &seg_iSegment00102,
    &seg_iSegment00103,
    &seg_iSegment00104,
    &seg_iSegment00105,
    &seg_iSegment00106,
    &seg_iSegment00107,
    &seg_iSegment00108,
    &seg_iSegment00109,
    &seg_iSegment00110,
    &seg_iSegment00111,
    &seg_iSegment00112,
    &seg_iSegment00113,
    &seg_iSegment00114,
    &seg_iSegment00115,
    &seg_iSegment00116,
    &seg_iSegment00117,
    &seg_iSegment00118,
    &seg_iSegment00119,
    &seg_iSegment00120,
    &seg_iSegment00121,
    &seg_iSegment00122,
    &seg_iSegment00123,
    &seg_iSegment00124,
    &seg_iSegment00125,
    &seg_iSegment00126,
    &seg_iSegment00127,
    &seg_iSegment00128,
    &seg_iSegment00129,
    &seg_iSegment00130,
    &seg_iSegment00131,
    &seg_iSegment00132,
    &seg_iSegment00133,
    &seg_iSegment00134,
    &seg_iSegment00135,
    &seg_iSegment00136,
    &seg_iSegment00137,
    &seg_iSegment00138,
    &seg_iSegment00139,
    &seg_iSegment00140,
    &seg_iSegment00141,
    &seg_iSegment00142,
    &seg_iSegment00143,
    &seg_iSegment00144,
    &seg_iSegment00145,
    &seg_iSegment00146,
    &seg_iSegment00147,
    &seg_iSegment00148,
    &seg_iSegment00149,
    &seg_iSegment00150,
    &seg_iSegment00151,
    &seg_iSegment00152,
    &seg_iSegment00153,
    &seg_iSegment00154,
    &seg_iSegment00155,
    &seg_iSegment00156,
    &seg_iSegment00157,
    &seg_iSegment00158,
    &seg_iSegment00159,
    &seg_iSegment00160,
    &seg_iSegment00161,
    &seg_iSegment00162,
    &seg_iSegment00163,
    &seg_iSegment00164,
    &seg_iSegment00165,
    &seg_iSegment00166,
    &seg_iSegment00167,
    &seg_iSegment00168,
    &seg_iSegment00169,
    &seg_iSegment00170,
    &seg_iSegment00171,
    &seg_iSegment00172,
    &seg_iSegment00173,
    &seg_iSegment00174,
    &seg_iSegment00175,
    &seg_iSegment00176,
    &seg_iSegment00177,
    &seg_iSegment00178,
    &seg_iSegment00179,
    &seg_iSegment00180,
    &seg_iSegment00181,
    &seg_iSegment00182,
    &seg_iSegment00183,
    &seg_iSegment00184,
    &seg_iSegment00185,
    &seg_iSegment00186,
    &seg_iSegment00187,
    &seg_iSegment00188,
    &seg_iSegment00189,
    &seg_iSegment00190,
    &seg_iSegment00191,
    &seg_iSegment00192,
    &seg_iSegment00193,
    &seg_iSegment00194,
    &seg_iSegment00195,
    &seg_iSegment00196,
    &seg_iSegment00197,
    &seg_iSegment00198,
    &seg_iSegment00199,
    &seg_iSegment00200,
    &seg_iSegment00201,
    &seg_iSegment00202,
    &seg_iSegment00203,
    &seg_iSegment00204,
    &seg_iSegment00205,
    &seg_iSegment00206,
    &seg_iSegment00207,
    &seg_iSegment00208,
    &seg_iSegment00209,
    &seg_iSegment00210,
    &seg_iSegment00211,
    &seg_iSegment00212,
    &seg_iSegment00213,
    &seg_iSegment00214,
    &seg_iSegment00215,
    &seg_iSegment00216,
    &seg_iSegment00217,
    &seg_iSegment00218,
    &seg_iSegment00219,
    &seg_iSegment00220,
    &seg_iSegment00221,
    &seg_iSegment00222,
    &seg_iSegment00223,
    &seg_iSegment00224,
    &seg_iSegment00225,
    &seg_iSegment00226,
    &seg_iSegment00227,
    &seg_iSegment00228,
    &seg_iSegment00229,
    &seg_iSegment00230,
    &seg_iSegment00231,
    &seg_iSegment00232,
    &seg_iSegment00233,
    &seg_iSegment00234,
    &seg_iSegment00235,
    &seg_iSegment00236,
    &seg_iSegment00237,
    &seg_iSegment00238,
    &seg_iSegment00239,
    &seg_iSegment00240,
    &seg_iSegment00241,
    &seg_iSegment00242,
    &seg_iSegment00243,
    &seg_iSegment00244,
    &seg_iSegment00245,
    &seg_iSegment00246,
    &seg_iSegment00247,
    &seg_iSegment00248,
    &seg_iSegment00249,
    &seg_iSegment00250,
    &seg_iSegment00251,
    &seg_iSegment00252,
    &seg_iSegment00253,
    &seg_iSegment00254,
    &seg_iSegment00255,
    &seg_iSegment00256,
    &seg_iSegment00257,
    &seg_iSegment00258,
    &seg_iSegment00259,
    &seg_iSegment00260,
    &seg_iSegment00261,
    &seg_iSegment00262,
    &seg_iSegment00263,
    &seg_iSegment00264,
    &seg_iSegment00265,
    &seg_iSegment00266,
    &seg_iSegment00267,
    &seg_iSegment00268,
    &seg_iSegment00269,
    &seg_iSegment00270,
    &seg_iSegment00271,
    &seg_iSegment00272,
    &seg_iSegment00273,
    &seg_iSegment00274,
    &seg_iSegment00275,
    &seg_iSegment00276,
    &seg_iSegment00277,
    &seg_iSegment00278,
    &seg_iSegment00279,
    &seg_iSegment00280,
    &seg_iSegment00281,
    &seg_iSegment00282,
    &seg_iSegment00283,
    &seg_iSegment00284,
    &seg_iSegment00285,
    &seg_iSegment00286,
    &seg_iSegment00287,
    &seg_iSegment00288,
    &seg_iSegment00289,
    &seg_iSegment00290,
    &seg_iSegment00291,
    &seg_iSegment00292,
    &seg_iSegment00293,
    &seg_iSegment00294,
    &seg_iSegment00295,
    &seg_iSegment00296,
    &seg_iSegment00297,
    &seg_iSegment00298,
    &seg_iSegment00299,
    &seg_iSegment00300,
    &seg_iSegment00301,
    &seg_iSegment00302,
    &seg_iSegment00303,
    &seg_iSegment00304,
    &seg_iSegment00305,
    &seg_iSegment00306,
    &seg_iSegment00307,
    &seg_iSegment00308,
    &seg_iSegment00309,
    &seg_iSegment00310,
    &seg_iSegment00311,
    &seg_iSegment00312,
    &seg_iSegment00313,
    &seg_iSegment00314,
    &seg_iSegment00315,
    &seg_iSegment00316,
    &seg_iSegment00317,
    &seg_iSegment00318,
    &seg_iSegment00319,
    &seg_iSegment00320,
    &seg_iSegment00321,
    &seg_iSegment00322,
    &seg_iSegment00323,
    &seg_iSegment00324,
    &seg_iSegment00325,
    &seg_iSegment00326,
    &seg_iSegment00327,
    &seg_iSegment00328,
    &seg_iSegment00329,
    &seg_iSegment00330,
    &seg_iSegment00331,
    &seg_iSegment00332,
    &seg_iSegment00333,
    &seg_iSegment00334,
    &seg_iSegment00335,
    &seg_iSegment00336,
    &seg_iSegment00337,
    &seg_iSegment00338,
    &seg_iSegment00339,
    &seg_iSegment00340,
    &seg_iSegment00341,
    &seg_iSegment00342,
    &seg_iSegment00343,
    &seg_iSegment00344,
    &seg_iSegment00345,
    &seg_iSegment00346,
    &seg_iSegment00347,
    &seg_iSegment00348,
    &seg_iSegment00349,
    &seg_iSegment00350,
    &seg_iSegment00351,
    &seg_iSegment00352,
    &seg_iSegment00353,
    &seg_iSegment00354,
    &seg_iSegment00355,
    &seg_iSegment00356,
    &seg_iSegment00357,
    &seg_iSegment00358,
    &seg_iSegment00359,
    &seg_iSegment00360,
    &seg_iSegment00361,
    &seg_iSegment00362,
    &seg_iSegment00363,
    &seg_iSegment00364,
    &seg_iSegment00365,
    &seg_iSegment00366,
    &seg_iSegment00367,
    &seg_iSegment00368,
    &seg_iSegment00369,
    &seg_iSegment00370,
    &seg_iSegment00371,
    &seg_iSegment00372,
    &seg_iSegment00373,
    &seg_iSegment00374,
    &seg_iSegment00375,
    &seg_iSegment00376,
    &seg_iSegment00377,
    &seg_iSegment00378,
    &seg_iSegment00379,
    &seg_iSegment00380,
    &seg_iSegment00381,
    &seg_iSegment00382,
    &seg_iSegment00383,
    &seg_iSegment00384,
    &seg_iSegment00385,
    &seg_iSegment00386,
    &seg_iSegment00387,
    &seg_iSegment00388,
    &seg_iSegment00389,
    &seg_iSegment00390,
    &seg_iSegment00391,
    &seg_iSegment00392,
    &seg_iSegment00393,
    &seg_iSegment00394,
    &seg_iSegment00395,
    &seg_iSegment00396,
    &seg_iSegment00397,
    &seg_iSegment00398,
    &seg_iSegment00399,
    &seg_iSegment00400,
    &seg_iSegment00401,
    &seg_iSegment00402,
    &seg_iSegment00403,
    &seg_iSegment00404,
    &seg_iSegment00405,
    &seg_iSegment00406,
    &seg_iSegment00407,
    &seg_iSegment00408,
    &seg_iSegment00409,
    &seg_iSegment00410,
    &seg_iSegment00411,
    &seg_iSegment00412,
    &seg_iSegment00413,
    &seg_iSegment00414,
    &seg_iSegment00415,
    &seg_iSegment00416,
    &seg_iSegment00417,
    &seg_iSegment00418,
    &seg_iSegment00419,
    &seg_iSegment00420,
    &seg_iSegment00421,
    &seg_iSegment00422,
    &seg_iSegment00423,
    &seg_iSegment00424,
    &seg_iSegment00425,
    &seg_iSegment00426,
    &seg_iSegment00427,
    &seg_iSegment00428,
    &seg_iSegment00429,
    &seg_iSegment00430,
    &seg_iSegment00431,
    &seg_iSegment00432,
    &seg_iSegment00433,
    &seg_iSegment00434,
    &seg_iSegment00435,
    &seg_iSegment00436,
    &seg_iSegment00437,
    &seg_iSegment00438,
    &seg_iSegment00439,
    &seg_iSegment00440,
    &seg_iSegment00441,
    &seg_iSegment00442,
    &seg_iSegment00443,
    &seg_iSegment00444,
    &seg_iSegment00445,
    &seg_iSegment00446,
    &seg_iSegment00447,
    &seg_iSegment00448,
    &seg_iSegment00449,
    &seg_iSegment00450,
    &seg_iSegment00451,
    &seg_iSegment00452,
    &seg_iSegment00453,
    &seg_iSegment00454,
    &seg_iSegment00455,
    &seg_iSegment00456,
    &seg_iSegment00457,
    &seg_iSegment00458,
    &seg_iSegment00459,
    &seg_iSegment00460,
    &seg_iSegment00461,
    &seg_iSegment00462,
    &seg_iSegment00463,
    &seg_iSegment00464,
    &seg_iSegment00465,
    &seg_iSegment00466,
    &seg_iSegment00467,
    &seg_iSegment00468,
    &seg_iSegment00469,
    &seg_iSegment00470,
    &seg_iSegment00471,
    &seg_iSegment00472,
    &seg_iSegment00473,
    &seg_iSegment00474,
    &seg_iSegment00475,
    &seg_iSegment00476,
    &seg_iSegment00477,
    &seg_iSegment00478,
    &seg_iSegment00479,
    &seg_iSegment00480,
    &seg_iSegment00481,
    &seg_iSegment00482,
    &seg_iSegment00483,
    &seg_iSegment00484,
    &seg_iSegment00485,
    &seg_iSegment00486,
    &seg_iSegment00487,
    &seg_iSegment00488,
    &seg_iSegment00489,
    &seg_iSegment00490,
    &seg_iSegment00491,
    &seg_iSegment00492,
    &seg_iSegment00493,
    &seg_iSegment00494,
    &seg_iSegment00495,
    &seg_iSegment00496,
    &seg_iSegment00497,
    &seg_iSegment00498,
    &seg_iSegment00499,
    &seg_iSegment00500,
    &seg_iSegment00501,
    &seg_iSegment00502,
    &seg_iSegment00503,
    &seg_iSegment00504,
    &seg_iSegment00505,
    &seg_iSegment00506,
    &seg_iSegment00507,
    &seg_iSegment00508,
    &seg_iSegment00509,
    &seg_iSegment00510,
    &seg_iSegment00511,
    &seg_iSegment00512,
    &seg_iSegment00513,
    &seg_iSegment00514,
    &seg_iSegment00515,
    &seg_iSegment00516,
    &seg_iSegment00517,
    &seg_iSegment00518,
    &seg_iSegment00519,
    &seg_iSegment00520,
    &seg_iSegment00521,
    &seg_iSegment00522,
    &seg_iSegment00523,
    &seg_iSegment00524,
    &seg_iSegment00525,
    &seg_iSegment00526,
    &seg_iSegment00527,
    &seg_iSegment00528,
    &seg_iSegment00529,
    &seg_iSegment00530,
    &seg_iSegment00531,
    &seg_iSegment00532,
    &seg_iSegment00533,
    &seg_iSegment00534,
    &seg_iSegment00535,
    &seg_iSegment00536,
    &seg_iSegment00537,
    &seg_iSegment00538,
    &seg_iSegment00539,
    &seg_iSegment00540,
    &seg_iSegment00541,
    &seg_iSegment00542,
    &seg_iSegment00543,
    &seg_iSegment00544,
    &seg_iSegment00545,
    &seg_iSegment00546,
    &seg_iSegment00547,
    &seg_iSegment00548,
    &seg_iSegment00549,
    &seg_iSegment00550,
    &seg_iSegment00551,
    &seg_iSegment00552,
    &seg_iSegment00553,
    &seg_iSegment00554,
    &seg_iSegment00555,
    &seg_iSegment00556,
    &seg_iSegment00557,
    &seg_iSegment00558,
    &seg_iSegment00559,
    &seg_iSegment00560,
    &seg_iSegment00561,
    &seg_iSegment00562,
    &seg_iSegment00563,
    &seg_iSegment00564,
    &seg_iSegment00565,
    &seg_iSegment00566,
    &seg_iSegment00567,
    &seg_iSegment00568,
    &seg_iSegment00569,
    &seg_iSegment00570,
    &seg_iSegment00571,
    &seg_iSegment00572,
    &seg_iSegment00573,
    &seg_iSegment00574,
    &seg_iSegment00575,
    &seg_iSegment00576,
    &seg_iSegment00577,
    &seg_iSegment00578,
    &seg_iSegment00579,
    &seg_iSegment00580,
    &seg_iSegment00581,
    &seg_iSegment00582,
    &seg_iSegment00583,
    &seg_iSegment00584,
    &seg_iSegment00585,
    &seg_iSegment00586,
    &seg_iSegment00587,
    &seg_iSegment00588,
    &seg_iSegment00589,
    &seg_iSegment00590,
    &seg_iSegment00591,
    &seg_iSegment00592,
    &seg_iSegment00593,
    &seg_iSegment00594,
    &seg_iSegment00595,
    &seg_iSegment00596,
    &seg_iSegment00597,
    &seg_iSegment00598,
    &seg_iSegment00599,
    &seg_iSegment00600,
    &seg_iSegment00601,
    &seg_iSegment00602,
    &seg_iSegment00603,
    &seg_iSegment00604,
    &seg_iSegment00605,
    &seg_iSegment00606,
    &seg_iSegment00607,
    &seg_iSegment00608,
    &seg_iSegment00609,
    &seg_iSegment00610,
    &seg_iSegment00611,
    &seg_iSegment00612,
    &seg_iSegment00613,
    &seg_iSegment00614,
    &seg_iSegment00615,
    &seg_iSegment00616,
    &seg_iSegment00617,
    &seg_iSegment00618,
    &seg_iSegment00619,
    &seg_iSegment00620,
    &seg_iSegment00621,
    &seg_iSegment00622,
    &seg_iSegment00623,
    &seg_iSegment00624,
    &seg_iSegment00625,
    &seg_iSegment00626,
    &seg_iSegment00627,
    &seg_iSegment00628,
    &seg_iSegment00629,
    &seg_iSegment00630,
    &seg_iSegment00631,
    &seg_iSegment00632,
    &seg_iSegment00633,
    &seg_iSegment00634,
    &seg_iSegment00635,
    &seg_iSegment00636,
    &seg_iSegment00637,
    &seg_iSegment00638,
    &seg_iSegment00639,
    &seg_iSegment00640,
    &seg_iSegment00641,
    &seg_iSegment00642,
    &seg_iSegment00643,
    &seg_iSegment00644,
    &seg_iSegment00645,
    &seg_iSegment00646,
    &seg_iSegment00647,
    &seg_iSegment00648,
    &seg_iSegment00649,
    &seg_iSegment00650,
    &seg_iSegment00651,
    &seg_iSegment00652,
    &seg_iSegment00653,
    &seg_iSegment00654,
    &seg_iSegment00655,
    &seg_iSegment00656,
    &seg_iSegment00657,
    &seg_iSegment00658,
    &seg_iSegment00659,
    &seg_iSegment00660,
    &seg_iSegment00661,
    &seg_iSegment00662,
    &seg_iSegment00663,
    &seg_iSegment00664,
    &seg_iSegment00665,
    &seg_iSegment00666,
    &seg_iSegment00667,
    &seg_iSegment00668,
    &seg_iSegment00669,
    &seg_iSegment00670,
    &seg_iSegment00671,
    &seg_iSegment00672,
    &seg_iSegment00673,
    &seg_iSegment00674,
    &seg_iSegment00675,
    &seg_iSegment00676,
    &seg_iSegment00677,
    &seg_iSegment00678,
    &seg_iSegment00679,
    &seg_iSegment00680,
    &seg_iSegment00681,
    &seg_iSegment00682,
    &seg_iSegment00683,
    &seg_iSegment00684,
    &seg_iSegment00685,
    &seg_iSegment00686,
    &seg_iSegment00687,
    &seg_iSegment00688,
    &seg_iSegment00689,
    &seg_iSegment00690,
    &seg_iSegment00691,
    &seg_iSegment00692,
    &seg_iSegment00693,
    &seg_iSegment00694,
    &seg_iSegment00695,
    &seg_iSegment00696,
    &seg_iSegment00697,
    &seg_iSegment00698,
    &seg_iSegment00699,
    &seg_iSegment00700,
    &seg_iSegment00701,
    &seg_iSegment00702,
    &seg_iSegment00703,
    &seg_iSegment00704,
    &seg_iSegment00705,
    &seg_iSegment00706,
    &seg_iSegment00707,
    &seg_iSegment00708,
    &seg_iSegment00709,
    &seg_iSegment00710,
    &seg_iSegment00711,
    &seg_iSegment00712,
    &seg_iSegment00713,
    &seg_iSegment00714,
    &seg_iSegment00715,
    &seg_iSegment00716,
    &seg_iSegment00717,
    &seg_iSegment00718,
    &seg_iSegment00719,
    &seg_iSegment00720,
    &seg_iSegment00721,
    &seg_iSegment00722,
    &seg_iSegment00723,
    &seg_iSegment00724,
    &seg_iSegment00725,
    &seg_iSegment00726,
    &seg_iSegment00727,
    &seg_iSegment00728,
    &seg_iSegment00729,
    &seg_iSegment00730,
    &seg_iSegment00731,
    &seg_iSegment00732,
    &seg_iSegment00733,
    &seg_iSegment00734,
    &seg_iSegment00735,
    &seg_iSegment00736,
    &seg_iSegment00737,
    &seg_iSegment00738,
    &seg_iSegment00739,
    &seg_iSegment00740,
    &seg_iSegment00741,
    &seg_iSegment00742,
    &seg_iSegment00743,
    &seg_iSegment00744,
    &seg_iSegment00745,
    &seg_iSegment00746,
    &seg_iSegment00747,
    &seg_iSegment00748,
    &seg_iSegment00749,
    &seg_iSegment00750,
    &seg_iSegment00751,
    &seg_iSegment00752,
    &seg_iSegment00753,
    &seg_iSegment00754,
    &seg_iSegment00755,
    &seg_iSegment00756,
    &seg_iSegment00757,
    &seg_iSegment00758,
    &seg_iSegment00759,
    &seg_iSegment00760,
    &seg_iSegment00761,
    &seg_iSegment00762,
    &seg_iSegment00763,
    &seg_iSegment00764,
    &seg_iSegment00765,
    &seg_iSegment00766,
    &seg_iSegment00767,
    &seg_iSegment00768,
    &seg_iSegment00769,
    &seg_iSegment00770,
    &seg_iSegment00771,
    &seg_iSegment00772,
    &seg_iSegment00773,
    &seg_iSegment00774,
    &seg_iSegment00775,
    &seg_iSegment00776,
    &seg_iSegment00777,
    &seg_iSegment00778,
    &seg_iSegment00779,
    &seg_iSegment00780,
    &seg_iSegment00781,
    &seg_iSegment00782,
    &seg_iSegment00783,
    &seg_iSegment00784,
    &seg_iSegment00785,
    &seg_iSegment00786,
    &seg_iSegment00787,
    &seg_iSegment00788,
    &seg_iSegment00789,
    &seg_iSegment00790,
    &seg_iSegment00791,
    &seg_iSegment00792,
    &seg_iSegment00793,
    &seg_iSegment00794,
    &seg_iSegment00795,
    &seg_iSegment00796,
    &seg_iSegment00797,
    &seg_iSegment00798,
    &seg_iSegment00799,
    &seg_iSegment00800,
    &seg_iSegment00801,
    &seg_iSegment00802,
    &seg_iSegment00803,
    &seg_iSegment00804,
    &seg_iSegment00805,
    &seg_iSegment00806,
    &seg_iSegment00807,
    &seg_iSegment00808,
    &seg_iSegment00809,
    &seg_iSegment00810,
    &seg_iSegment00811,
    &seg_iSegment00812,
    &seg_iSegment00813,
    &seg_iSegment00814,
    &seg_iSegment00815,
    &seg_iSegment00816,
    &seg_iSegment00817,
    &seg_iSegment00818,
    &seg_iSegment00819,
    &seg_iSegment00820,
    &seg_iSegment00821,
    &seg_iSegment00822,
    &seg_iSegment00823,
    &seg_iSegment00824,
    &seg_iSegment00825,
    &seg_iSegment00826,
    &seg_iSegment00827,
    &seg_iSegment00828,
    &seg_iSegment00829,
    &seg_iSegment00830,
    &seg_iSegment00831,
    &seg_iSegment00832,
    &seg_iSegment00833,
    &seg_iSegment00834,
    &seg_iSegment00835,
    &seg_iSegment00836,
    &seg_iSegment00837,
    &seg_iSegment00838,
    &seg_iSegment00839,
    &seg_iSegment00840,
    &seg_iSegment00841,
    &seg_iSegment00842,
    &seg_iSegment00843,
    &seg_iSegment00844,
    &seg_iSegment00845,
    &seg_iSegment00846,
    &seg_iSegment00847,
    &seg_iSegment00848,
    &seg_iSegment00849,
    &seg_iSegment00850,
    &seg_iSegment00851,
    &seg_iSegment00852,
    &seg_iSegment00853,
    &seg_iSegment00854,
    &seg_iSegment00855,
    &seg_iSegment00856,
    &seg_iSegment00857,
    &seg_iSegment00858,
    &seg_iSegment00859,
    &seg_iSegment00860,
    &seg_iSegment00861,
    &seg_iSegment00862,
    &seg_iSegment00863,
    &seg_iSegment00864,
    &seg_iSegment00865,
    &seg_iSegment00866,
    &seg_iSegment00867,
    &seg_iSegment00868,
    &seg_iSegment00869,
    &seg_iSegment00870,
    &seg_iSegment00871,
    &seg_iSegment00872,
    &seg_iSegment00873,
    &seg_iSegment00874,
    &seg_iSegment00875,
    &seg_iSegment00876,
    &seg_iSegment00877,
    &seg_iSegment00878,
    &seg_iSegment00879,
    &seg_iSegment00880,
    &seg_iSegment00881,
    &seg_iSegment00882,
    &seg_iSegment00883,
    &seg_iSegment00884,
    &seg_iSegment00885,
    &seg_iSegment00886,
    &seg_iSegment00887,
    &seg_iSegment00888,
    &seg_iSegment00889,
    &seg_iSegment00890,
    &seg_iSegment00891,
    &seg_iSegment00892,
    &seg_iSegment00893,
    &seg_iSegment00894,
    &seg_iSegment00895,
    &seg_iSegment00896,
    &seg_iSegment00897,
    &seg_iSegment00898,
    &seg_iSegment00899,
    &seg_iSegment00900,
    &seg_iSegment00901,
    &seg_iSegment00902,
    &seg_iSegment00903,
    &seg_iSegment00904,
    &seg_iSegment00905,
    &seg_iSegment00906,
    &seg_iSegment00907,
    &seg_iSegment00908,
    &seg_iSegment00909,
    &seg_iSegment00910,
    &seg_iSegment00911,
    &seg_iSegment00912,
    &seg_iSegment00913,
    &seg_iSegment00914,
    &seg_iSegment00915,
    &seg_iSegment00916,
    &seg_iSegment00917,
    &seg_iSegment00918,
    &seg_iSegment00919,
    &seg_iSegment00920,
    &seg_iSegment00921,
    &seg_iSegment00922,
    &seg_iSegment00923,
    &seg_iSegment00924,
    &seg_iSegment00925,
    &seg_iSegment00926,
    &seg_iSegment00927,
    &seg_iSegment00928,
    &seg_iSegment00929,
    &seg_iSegment00930,
    &seg_iSegment00931,
    &seg_iSegment00932,
    &seg_iSegment00933,
    &seg_iSegment00934,
    &seg_iSegment00935,
    &seg_iSegment00936,
    &seg_iSegment00937,
    &seg_iSegment00938,
    &seg_iSegment00939,
    &seg_iSegment00940,
    &seg_iSegment00941,
    &seg_iSegment00942,
    &seg_iSegment00943,
    &seg_iSegment00944,
    &seg_iSegment00945,
    &seg_iSegment00946,
    &seg_iSegment00947,
    &seg_iSegment00948,
    &seg_iSegment00949,
    &seg_iSegment00950,
    &seg_iSegment00951,
    &seg_iSegment00952,
    &seg_iSegment00953,
    &seg_iSegment00954,
    &seg_iSegment00955,
    &seg_iSegment00956,
    &seg_iSegment00957,
    &seg_iSegment00958,
    &seg_iSegment00959,
    &seg_iSegment00960,
    &seg_iSegment00961,
    &seg_iSegment00962,
    &seg_iSegment00963,
    &seg_iSegment00964,
    &seg_iSegment00965,
    &seg_iSegment00966,
    &seg_iSegment00967,
    &seg_iSegment00968,
    &seg_iSegment00969,
    &seg_iSegment00970,
    &seg_iSegment00971,
    &seg_iSegment00972,
    &seg_iSegment00973,
    &seg_iSegment00974,
    &seg_iSegment00975,
    &seg_iSegment00976,
    &seg_iSegment00977,
    &seg_iSegment00978,
    &seg_iSegment00979,
    &seg_iSegment00980,
    &seg_iSegment00981,
    &seg_iSegment00982,
    &seg_iSegment00983,
    &seg_iSegment00984,
    &seg_iSegment00985,
    &seg_iSegment00986,
    &seg_iSegment00987,
    &seg_iSegment00988,
    &seg_iSegment00989,
    &seg_iSegment00990,
    &seg_iSegment00991,
    &seg_iSegment00992,
    &seg_iSegment00993,
    &seg_iSegment00994,
    &seg_iSegment00995,
    &seg_iSegment00996,
    &seg_iSegment00997,
    &seg_iSegment00998,
    &seg_iSegment00999,
    &seg_iSegment01000,
    &seg_iSegment01001,
    &seg_iSegment01002,
    &seg_iSegment01003,
    &seg_iSegment01004,
    &seg_iSegment01005,
    &seg_iSegment01006,
    &seg_iSegment01007,
    &seg_iSegment01008,
    &seg_iSegment01009,
    &seg_iSegment01010,
    &seg_iSegment01011,
    &seg_iSegment01012,
    &seg_iSegment01013,
    &seg_iSegment01014,
    &seg_iSegment01015,
    &seg_iSegment01016,
    &seg_iSegment01017,
    &seg_iSegment01018,
    &seg_iSegment01019,
    &seg_iSegment01020,
    &seg_iSegment01021,
    &seg_iSegment01022,
    &seg_iSegment01023,
    &seg_iSegment01024,
    &seg_iSegment01025,
    &seg_iSegment01026,
    &seg_iSegment01027,
    &seg_iSegment01028,
    &seg_iSegment01029,
    &seg_iSegment01030,
    &seg_iSegment01031,
    &seg_iSegment01032,
    &seg_iSegment01033,
    &seg_iSegment01034,
    &seg_iSegment01035,
    &seg_iSegment01036,
    &seg_iSegment01037,
    &seg_iSegment01038,
    &seg_iSegment01039,
    &seg_iSegment01040,
    &seg_iSegment01041,
    &seg_iSegment01042,
    &seg_iSegment01043,
    &seg_iSegment01044,
    &seg_iSegment01045,
    &seg_iSegment01046,
    &seg_iSegment01047,
    &seg_iSegment01048,
    &seg_iSegment01049,
    &seg_iSegment01050,
    &seg_iSegment01051,
    &seg_iSegment01052,
    &seg_iSegment01053,
    &seg_iSegment01054,
    &seg_iSegment01055,
    &seg_iSegment01056,
    &seg_iSegment01057,
    &seg_iSegment01058,
    &seg_iSegment01059,
    &seg_iSegment01060,
    &seg_iSegment01061,
    &seg_iSegment01062,
    &seg_iSegment01063,
    &seg_iSegment01064,
    &seg_iSegment01065,
    &seg_iSegment01066,
    &seg_iSegment01067,
    &seg_iSegment01068,
    &seg_iSegment01069,
    &seg_iSegment01070,
    &seg_iSegment01071,
    &seg_iSegment01072,
    &seg_iSegment01073,
    &seg_iSegment01074,
    &seg_iSegment01075,
    &seg_iSegment01076,
    &seg_iSegment01077,
    &seg_iSegment01078,
    &seg_iSegment01079,
    &seg_iSegment01080,
    &seg_iSegment01081,
    &seg_iSegment01082,
    &seg_iSegment01083,
    &seg_iSegment01084,
    &seg_iSegment01085,
    &seg_iSegment01086,
    &seg_iSegment01087,
    &seg_iSegment01088,
    &seg_iSegment01089,
    &seg_iSegment01090,
    &seg_iSegment01091,
    &seg_iSegment01092,
    &seg_iSegment01093,
    &seg_iSegment01094,
    &seg_iSegment01095,
    &seg_iSegment01096,
    &seg_iSegment01097,
    &seg_iSegment01098,
    &seg_iSegment01099,
    &seg_iSegment01100,
    &seg_iSegment01101,
    &seg_iSegment01102,
    &seg_iSegment01103,
    &seg_iSegment01104,
    &seg_iSegment01105,
    &seg_iSegment01106,
    &seg_iSegment01107,
    &seg_iSegment01108,
    &seg_iSegment01109,
    &seg_iSegment01110,
    &seg_iSegment01111,
    &seg_iSegment01112,
    &seg_iSegment01113,
    &seg_iSegment01114,
    &seg_iSegment01115,
    &seg_iSegment01116,
    &seg_iSegment01117,
    &seg_iSegment01118,
    &seg_iSegment01119,
    &seg_iSegment01120,
    &seg_iSegment01121,
    &seg_iSegment01122,
    &seg_iSegment01123,
    &seg_iSegment01124,
    &seg_iSegment01125,
    &seg_iSegment01126,
    &seg_iSegment01127,
    &seg_iSegment01128,
    &seg_iSegment01129,
    &seg_iSegment01130,
    &seg_iSegment01131,
    &seg_iSegment01132,
    &seg_iSegment01133,
    &seg_iSegment01134,
    &seg_iSegment01135,
    &seg_iSegment01136,
    &seg_iSegment01137,
    &seg_iSegment01138,
    &seg_iSegment01139,
    &seg_iSegment01140,
    &seg_iSegment01141,
    &seg_iSegment01142,
    &seg_iSegment01143,
    &seg_iSegment01144,
    &seg_iSegment01145,
    &seg_iSegment01146,
    &seg_iSegment01147,
    &seg_iSegment01148,
    &seg_iSegment01149,
    &seg_iSegment01150,
    &seg_iSegment01151,
    &seg_iSegment01152,
    &seg_iSegment01153,
    &seg_iSegment01154,
    &seg_iSegment01155,
    &seg_iSegment01156,
    &seg_iSegment01157,
    &seg_iSegment01158,
    &seg_iSegment01159,
    &seg_iSegment01160,
    &seg_iSegment01161,
    &seg_iSegment01162,
    &seg_iSegment01163,
    &seg_iSegment01164,
    &seg_iSegment01165,
    &seg_iSegment01166,
    &seg_iSegment01167,
    &seg_iSegment01168,
    &seg_iSegment01169,
    &seg_iSegment01170,
    &seg_iSegment01171,
    &seg_iSegment01172,
    &seg_iSegment01173,
    &seg_iSegment01174,
    &seg_iSegment01175,
    &seg_iSegment01176,
    &seg_iSegment01177,
    &seg_iSegment01178,
    &seg_iSegment01179,
    &seg_iSegment01180,
    &seg_iSegment01181,
    &seg_iSegment01182,
    &seg_iSegment01183,
    &seg_iSegment01184,
    &seg_iSegment01185,
    &seg_iSegment01186,
    &seg_iSegment01187,
    &seg_iSegment01188,
    &seg_iSegment01189,
    &seg_iSegment01190,
    &seg_iSegment01191,
    &seg_iSegment01192,
    &seg_iSegment01193,
    &seg_iSegment01194,
    &seg_iSegment01195,
    &seg_iSegment01196,
    &seg_iSegment01197,
    &seg_iSegment01198,
    &seg_iSegment01199,
    &seg_iSegment01200,
    &seg_iSegment01201,
    &seg_iSegment01202,
    &seg_iSegment01203,
    &seg_iSegment01204,
    &seg_iSegment01205,
    &seg_iSegment01206,
    &seg_iSegment01207,
    &seg_iSegment01208,
    &seg_iSegment01209,
    &seg_iSegment01210,
    &seg_iSegment01211,
    &seg_iSegment01212,
    &seg_iSegment01213,
    &seg_iSegment01214,
    &seg_iSegment01215,
    &seg_iSegment01216,
    &seg_iSegment01217,
    &seg_iSegment01218,
    &seg_iSegment01219,
    &seg_iSegment01220,
    &seg_iSegment01221,
    &seg_iSegment01222,
    &seg_iSegment01223,
    &seg_iSegment01224,
    &seg_iSegment01225,
    &seg_iSegment01226,
    &seg_iSegment01227,
    &seg_iSegment01228,
    &seg_iSegment01229,
    &seg_iSegment01230,
    &seg_iSegment01231,
    &seg_iSegment01232,
    &seg_iSegment01233,
    &seg_iSegment01234,
    &seg_iSegment01235,
    &seg_iSegment01236,
    &seg_iSegment01237,
    &seg_iSegment01238,
    &seg_iSegment01239,
    &seg_iSegment01240,
    &seg_iSegment01241,
    &seg_iSegment01242,
    &seg_iSegment01243,
    &seg_iSegment01244,
    &seg_iSegment01245,
    &seg_iSegment01246,
    &seg_iSegment01247,
    &seg_iSegment01248,
    &seg_iSegment01249,
    &seg_iSegment01250,
    &seg_iSegment01251,
    &seg_iSegment01252,
    &seg_iSegment01253,
    &seg_iSegment01254,
    &seg_iSegment01255,
    &seg_iSegment01256,
    &seg_iSegment01257,
    &seg_iSegment01258,
    &seg_iSegment01259,
    &seg_iSegment01260,
    &seg_iSegment01261,
    &seg_iSegment01262,
    &seg_iSegment01263,
    &seg_iSegment01264,
    &seg_iSegment01265,
    &seg_iSegment01266,
    &seg_iSegment01267,
    &seg_iSegment01268,
    &seg_iSegment01269,
    &seg_iSegment01270,
    &seg_iSegment01271,
    &seg_iSegment01272,
    &seg_iSegment01273,
    &seg_iSegment01274,
    &seg_iSegment01275,
    &seg_iSegment01276,
    &seg_iSegment01277,
    &seg_iSegment01278,
    &seg_iSegment01279,
    &seg_iSegment01280,
    &seg_iSegment01281,
    &seg_iSegment01282,
    &seg_iSegment01283,
    &seg_iSegment01284,
    &seg_iSegment01285,
    &seg_iSegment01286,
    &seg_iSegment01287,
    &seg_iSegment01288,
    &seg_iSegment01289,
    &seg_iSegment01290,
    &seg_iSegment01291,
    &seg_iSegment01292,
    &seg_iSegment01293,
    &seg_iSegment01294,
    &seg_iSegment01295,
    &seg_iSegment01296,
    &seg_iSegment01297,
    &seg_iSegment01298,
    &seg_iSegment01299,
    &seg_iSegment01300,
    &seg_iSegment01301,
    &seg_iSegment01302,
    &seg_iSegment01303,
    &seg_iSegment01304,
    &seg_iSegment01305,
    &seg_iSegment01306,
    &seg_iSegment01307,
    &seg_iSegment01308,
    &seg_iSegment01309,
    &seg_iSegment01310,
    &seg_iSegment01311,
    &seg_iSegment01312,
    &seg_iSegment01313,
    &seg_iSegment01314,
    &seg_iSegment01315,
    &seg_iSegment01316,
    &seg_iSegment01317,
    &seg_iSegment01318,
    &seg_iSegment01319,
    &seg_iSegment01320,
    &seg_iSegment01321,
    &seg_iSegment01322,
    &seg_iSegment01323,
    &seg_iSegment01324,
    &seg_iSegment01325,
    &seg_iSegment01326,
    &seg_iSegment01327,
    &seg_iSegment01328,
    &seg_iSegment01329,
    &seg_iSegment01330,
    &seg_iSegment01331,
    &seg_iSegment01332,
    &seg_iSegment01333,
    &seg_iSegment01334,
    &seg_iSegment01335,
    &seg_iSegment01336,
    &seg_iSegment01337,
    &seg_iSegment01338,
    &seg_iSegment01339,
    &seg_iSegment01340,
    &seg_iSegment01341,
    &seg_iSegment01342,
    &seg_iSegment01343,
    &seg_iSegment01344,
    &seg_iSegment01345,
    &seg_iSegment01346,
    &seg_iSegment01347,
    &seg_iSegment01348,
    &seg_iSegment01349,
    &seg_iSegment01350,
    &seg_iSegment01351,
    &seg_iSegment01352,
    &seg_iSegment01353,
    &seg_iSegment01354,
    &seg_iSegment01355,
    &seg_iSegment01356,
    &seg_iSegment01357,
    &seg_iSegment01358,
    &seg_iSegment01359,
    &seg_iSegment01360,
    &seg_iSegment01361,
    &seg_iSegment01362,
    &seg_iSegment01363,
    &seg_iSegment01364,
    &seg_iSegment01365,
    &seg_iSegment01366,
    &seg_iSegment01367,
    &seg_iSegment01368,
    &seg_iSegment01369,
    &seg_iSegment01370,
    &seg_iSegment01371,
    &seg_iSegment01372,
    &seg_iSegment01373,
    &seg_iSegment01374,
    &seg_iSegment01375,
    &seg_iSegment01376,
    &seg_iSegment01377,
    &seg_iSegment01378,
    &seg_iSegment01379,
    &seg_iSegment01380,
    &seg_iSegment01381,
    &seg_iSegment01382,
    &seg_iSegment01383,
    &seg_iSegment01384,
    &seg_iSegment01385,
    &seg_iSegment01386,
    &seg_iSegment01387,
    &seg_iSegment01388,
    &seg_iSegment01389,
    &seg_iSegment01390,
    &seg_iSegment01391,
    &seg_iSegment01392,
    &seg_iSegment01393,
    &seg_iSegment01394,
    &seg_iSegment01395,
    &seg_iSegment01396,
    &seg_iSegment01397,
    &seg_iSegment01398,
    &seg_iSegment01399,
    &seg_iSegment01400,
    &seg_iSegment01401,
    &seg_iSegment01402,
    &seg_iSegment01403,
    &seg_iSegment01404,
    &seg_iSegment01405,
    &seg_iSegment01406,
    &seg_iSegment01407,
    &seg_iSegment01408,
    &seg_iSegment01409,
    &seg_iSegment01410,
    &seg_iSegment01411,
    &seg_iSegment01412,
    &seg_iSegment01413,
    &seg_iSegment01414,
    &seg_iSegment01415,
    &seg_iSegment01416,
    &seg_iSegment01417,
    &seg_iSegment01418,
    &seg_iSegment01419,
    &seg_iSegment01420,
    &seg_iSegment01421,
    &seg_iSegment01422,
    &seg_iSegment01423,
    &seg_iSegment01424,
    &seg_iSegment01425,
    &seg_iSegment01426,
    &seg_iSegment01427,
    &seg_iSegment01428,
    &seg_iSegment01429,
    &seg_iSegment01430,
    &seg_iSegment01431,
    &seg_iSegment01432,
    &seg_iSegment01433,
    &seg_iSegment01434,
    &seg_iSegment01435,
    &seg_iSegment01436,
    &seg_iSegment01437,
    &seg_iSegment01438,
    &seg_iSegment01439,
    &seg_iSegment01440,
    &seg_iSegment01441,
    &seg_iSegment01442,
    &seg_iSegment01443,
    &seg_iSegment01444,
    &seg_iSegment01445,
    &seg_iSegment01446,
    &seg_iSegment01447,
    &seg_iSegment01448,
    &seg_iSegment01449,
    &seg_iSegment01450,
    &seg_iSegment01451,
    &seg_iSegment01452,
    &seg_iSegment01453,
    &seg_iSegment01454,
    &seg_iSegment01455,
    &seg_iSegment01456,
    &seg_iSegment01457,
    &seg_iSegment01458,
    &seg_iSegment01459,
    &seg_iSegment01460,
    &seg_iSegment01461,
    &seg_iSegment01462,
    &seg_iSegment01463,
    &seg_iSegment01464,
    &seg_iSegment01465,
    &seg_iSegment01466,
    &seg_iSegment01467,
    &seg_iSegment01468,
    &seg_iSegment01469,
    &seg_iSegment01470,
    &seg_iSegment01471,
    &seg_iSegment01472,
    &seg_iSegment01473,
    &seg_iSegment01474,
    &seg_iSegment01475,
    &seg_iSegment01476,
    &seg_iSegment01477,
    &seg_iSegment01478,
    &seg_iSegment01479,
    &seg_iSegment01480,
    &seg_iSegment01481,
    &seg_iSegment01482,
    &seg_iSegment01483,
    &seg_iSegment01484,
    &seg_iSegment01485,
    &seg_iSegment01486,
    &seg_iSegment01487,
    &seg_iSegment01488,
    &seg_iSegment01489,
    &seg_iSegment01490,
    &seg_iSegment01491,
    &seg_iSegment01492,
    &seg_iSegment01493,
    &seg_iSegment01494,
    &seg_iSegment01495,
    &seg_iSegment01496,
    &seg_iSegment01497,
    &seg_iSegment01498,
    &seg_iSegment01499,
    &seg_iSegment01500,
    &seg_iSegment01501,
    &seg_iSegment01502,
    &seg_iSegment01503,
    &seg_iSegment01504,
    &seg_iSegment01505,
    &seg_iSegment01506,
    &seg_iSegment01507,
    &seg_iSegment01508,
    &seg_iSegment01509,
    &seg_iSegment01510,
    &seg_iSegment01511,
    &seg_iSegment01512,
    &seg_iSegment01513,
    &seg_iSegment01514,
    &seg_iSegment01515,
    &seg_iSegment01516,
    &seg_iSegment01517,
    &seg_iSegment01518,
    &seg_iSegment01519,
    &seg_iSegment01520,
    &seg_iSegment01521,
    &seg_iSegment01522,
    &seg_iSegment01523,
    &seg_iSegment01524,
    &seg_iSegment01525,
    &seg_iSegment01526,
    &seg_iSegment01527,
    &seg_iSegment01528,
    &seg_iSegment01529,
    &seg_iSegment01530,
    &seg_iSegment01531,
    &seg_iSegment01532,
    &seg_iSegment01533,
    &seg_iSegment01534,
    &seg_iSegment01535,
    &seg_iSegment01536,
    &seg_iSegment01537,
    &seg_iSegment01538,
    &seg_iSegment01539,
    &seg_iSegment01540,
    &seg_iSegment01541,
    &seg_iSegment01542,
    &seg_iSegment01543,
    &seg_iSegment01544,
    &seg_iSegment01545,
    &seg_iSegment01546,
    &seg_iSegment01547,
    &seg_iSegment01548,
    &seg_iSegment01549,
    &seg_iSegment01550,
    &seg_iSegment01551,
    &seg_iSegment01552,
    &seg_iSegment01553,
    &seg_iSegment01554,
    &seg_iSegment01555,
    &seg_iSegment01556,
    &seg_iSegment01557,
    &seg_iSegment01558,
    &seg_iSegment01559,
    &seg_iSegment01560,
    &seg_iSegment01561,
    &seg_iSegment01562,
    &seg_iSegment01563,
    &seg_iSegment01564,
    &seg_iSegment01565,
    &seg_iSegment01566,
    &seg_iSegment01567,
    &seg_iSegment01568,
    &seg_iSegment01569,
    &seg_iSegment01570,
    &seg_iSegment01571,
    &seg_iSegment01572,
    &seg_iSegment01573,
    &seg_iSegment01574,
    &seg_iSegment01575,
    &seg_iSegment01576,
    &seg_iSegment01577,
    &seg_iSegment01578,
    &seg_iSegment01579,
    &seg_iSegment01580,
    &seg_iSegment01581,
    &seg_iSegment01582,
    &seg_iSegment01583,
    &seg_iSegment01584,
    &seg_iSegment01585,
    &seg_iSegment01586,
    &seg_iSegment01587,
    &seg_iSegment01588,
    &seg_iSegment01589,
    &seg_iSegment01590,
    &seg_iSegment01591,
    &seg_iSegment01592,
    &seg_iSegment01593,
    &seg_iSegment01594,
    &seg_iSegment01595,
    &seg_iSegment01596,
    &seg_iSegment01597,
    &seg_iSegment01598,
    &seg_iSegment01599,
    &seg_iSegment01600,
    &seg_iSegment01601,
    &seg_iSegment01602,
    &seg_iSegment01603,
    &seg_iSegment01604,
    &seg_iSegment01605,
    &seg_iSegment01606,
    &seg_iSegment01607,
    &seg_iSegment01608,
    &seg_iSegment01609,
    &seg_iSegment01610,
    &seg_iSegment01611,
    &seg_iSegment01612,
    &seg_iSegment01613,
    &seg_iSegment01614,
    &seg_iSegment01615,
    &seg_iSegment01616,
    &seg_iSegment01617,
    &seg_iSegment01618,
    &seg_iSegment01619,
    &seg_iSegment01620,
    &seg_iSegment01621,
    &seg_iSegment01622,
    &seg_iSegment01623,
    &seg_iSegment01624,
    &seg_iSegment01625,
    &seg_iSegment01626,
    &seg_iSegment01627,
    &seg_iSegment01628,
    &seg_iSegment01629,
    &seg_iSegment01630,
    &seg_iSegment01631,
    &seg_iSegment01632,
    &seg_iSegment01633,
    &seg_iSegment01634,
    &seg_iSegment01635,
    &seg_iSegment01636,
    &seg_iSegment01637,
    &seg_iSegment01638,
    &seg_iSegment01639,
    &seg_iSegment01640,
    &seg_iSegment01641,
    &seg_iSegment01642,
    &seg_iSegment01643,
    &seg_iSegment01644,
    &seg_iSegment01645,
    &seg_iSegment01646,
    &seg_iSegment01647,
    &seg_iSegment01648,
    &seg_iSegment01649,
    &seg_iSegment01650,
    &seg_iSegment01651,
    &seg_iSegment01652,
    &seg_iSegment01653,
    &seg_iSegment01654,
    &seg_iSegment01655,
    &seg_iSegment01656,
    &seg_iSegment01657,
    &seg_iSegment01658,
    &seg_iSegment01659,
    &seg_iSegment01660,
    &seg_iSegment01661,
    &seg_iSegment01662,
    &seg_iSegment01663,
    &seg_iSegment01664,
    &seg_iSegment01665,
    &seg_iSegment01666,
    &seg_iSegment01667,
    &seg_iSegment01668,
    &seg_iSegment01669,
    &seg_iSegment01670,
    &seg_iSegment01671,
    &seg_iSegment01672,
    &seg_iSegment01673,
    &seg_iSegment01674,
    &seg_iSegment01675,
    &seg_iSegment01676,
    &seg_iSegment01677,
    &seg_iSegment01678,
    &seg_iSegment01679,
    &seg_iSegment01680,
    &seg_iSegment01681,
    &seg_iSegment01682,
    &seg_iSegment01683,
    &seg_iSegment01684,
    &seg_iSegment01685,
    &seg_iSegment01686,
    &seg_iSegment01687,
    &seg_iSegment01688,
    &seg_iSegment01689,
    &seg_iSegment01690,
    &seg_iSegment01691,
    &seg_iSegment01692,
    &seg_iSegment01693,
    &seg_iSegment01694,
    &seg_iSegment01695,
    &seg_iSegment01696,
    &seg_iSegment01697,
    &seg_iSegment01698,
    &seg_iSegment01699,
    &seg_iSegment01700,
    &seg_iSegment01701,
    &seg_iSegment01702,
    &seg_iSegment01703,
    &seg_iSegment01704,
    &seg_iSegment01705,
    &seg_iSegment01706,
    &seg_iSegment01707,
    &seg_iSegment01708,
    &seg_iSegment01709,
    &seg_iSegment01710,
    &seg_iSegment01711,
    &seg_iSegment01712,
    &seg_iSegment01713,
    &seg_iSegment01714,
    &seg_iSegment01715,
    &seg_iSegment01716,
    &seg_iSegment01717,
    &seg_iSegment01718,
    &seg_iSegment01719,
    &seg_iSegment01720,
    &seg_iSegment01721,
    &seg_iSegment01722,
    &seg_iSegment01723,
    &seg_iSegment01724,
    &seg_iSegment01725,
    &seg_iSegment01726,
    &seg_iSegment01727,
    &seg_iSegment01728,
    &seg_iSegment01729,
    &seg_iSegment01730,
    &seg_iSegment01731,
    &seg_iSegment01732,
    &seg_iSegment01733,
    &seg_iSegment01734,
    &seg_iSegment01735,
    &seg_iSegment01736,
    &seg_iSegment01737,
    &seg_iSegment01738,
    &seg_iSegment01739,
    &seg_iSegment01740,
    &seg_iSegment01741,
    &seg_iSegment01742,
    &seg_iSegment01743,
    &seg_iSegment01744,
    &seg_iSegment01745,
    &seg_iSegment01746,
    &seg_iSegment01747,
    &seg_iSegment01748,
    &seg_iSegment01749,
    &seg_iSegment01750,
    &seg_iSegment01751,
    &seg_iSegment01752,
    &seg_iSegment01753,
    &seg_iSegment01754,
    &seg_iSegment01755,
    &seg_iSegment01756,
    &seg_iSegment01757,
    &seg_iSegment01758,
    &seg_iSegment01759,
    &seg_iSegment01760,
    &seg_iSegment01761,
    &seg_iSegment01762,
    &seg_iSegment01763,
    &seg_iSegment01764,
    &seg_iSegment01765,
    &seg_iSegment01766,
    &seg_iSegment01767,
    &seg_iSegment01768,
    &seg_iSegment01769,
    &seg_iSegment01770,
    &seg_iSegment01771,
    &seg_iSegment01772,
    &seg_iSegment01773,
    &seg_iSegment01774,
    &seg_iSegment01775,
    &seg_iSegment01776,
    &seg_iSegment01777,
    &seg_iSegment01778,
    &seg_iSegment01779,
    &seg_iSegment01780,
    &seg_iSegment01781,
    &seg_iSegment01782,
    &seg_iSegment01783,
    &seg_iSegment01784,
    &seg_iSegment01785,
    &seg_iSegment01786,
    &seg_iSegment01787,
    &seg_iSegment01788,
    &seg_iSegment01789,
    &seg_iSegment01790,
    &seg_iSegment01791,
    &seg_iSegment01792,
    &seg_iSegment01793,
    &seg_iSegment01794,
    &seg_iSegment01795,
    &seg_iSegment01796,
    &seg_iSegment01797,
    &seg_iSegment01798,
    &seg_iSegment01799,
    &seg_iSegment01800,
    &seg_iSegment01801,
    &seg_iSegment01802,
    &seg_iSegment01803,
    &seg_iSegment01804,
    &seg_iSegment01805,
    &seg_iSegment01806,
    &seg_iSegment01807,
    &seg_iSegment01808,
    &seg_iSegment01809,
    &seg_iSegment01810,
    &seg_iSegment01811,
    &seg_iSegment01812,
    &seg_iSegment01813,
    &seg_iSegment01814,
    &seg_iSegment01815,
    &seg_iSegment01816,
    &seg_iSegment01817,
    &seg_iSegment01818,
    &seg_iSegment01819,
    &seg_iSegment01820,
    &seg_iSegment01821,
    &seg_iSegment01822,
    &seg_iSegment01823,
    &seg_iSegment01824,
    &seg_iSegment01825,
    &seg_iSegment01826,
    &seg_iSegment01827,
    &seg_iSegment01828,
    &seg_iSegment01829,
    &seg_iSegment01830,
    &seg_iSegment01831,
    &seg_iSegment01832,
    &seg_iSegment01833,
    &seg_iSegment01834,
    &seg_iSegment01835,
    &seg_iSegment01836,
    &seg_iSegment01837,
    &seg_iSegment01838,
    &seg_iSegment01839,
    &seg_iSegment01840,
    &seg_iSegment01841,
    &seg_iSegment01842,
    &seg_iSegment01843,
    &seg_iSegment01844,
    &seg_iSegment01845,
    &seg_iSegment01846,
    &seg_iSegment01847,
    &seg_iSegment01848,
    &seg_iSegment01849,
    &seg_iSegment01850,
    &seg_iSegment01851,
    &seg_iSegment01852,
    &seg_iSegment01853,
    &seg_iSegment01854,
    &seg_iSegment01855,
    &seg_iSegment01856,
    &seg_iSegment01857,
    &seg_iSegment01858,
    &seg_iSegment01859,
    &seg_iSegment01860,
    &seg_iSegment01861,
    &seg_iSegment01862,
    &seg_iSegment01863,
    &seg_iSegment01864,
    &seg_iSegment01865,
    &seg_iSegment01866,
    &seg_iSegment01867,
    &seg_iSegment01868,
    &seg_iSegment01869,
    &seg_iSegment01870,
    &seg_iSegment01871,
    &seg_iSegment01872,
    &seg_iSegment01873,
    &seg_iSegment01874,
    &seg_iSegment01875,
    &seg_iSegment01876,
    &seg_iSegment01877,
    &seg_iSegment01878,
    &seg_iSegment01879,
    &seg_iSegment01880,
    &seg_iSegment01881,
    &seg_iSegment01882,
    &seg_iSegment01883,
    &seg_iSegment01884,
    &seg_iSegment01885,
    &seg_iSegment01886,
    &seg_iSegment01887,
    &seg_iSegment01888,
    &seg_iSegment01889,
    &seg_iSegment01890,
    &seg_iSegment01891,
    &seg_iSegment01892,
    &seg_iSegment01893,
    &seg_iSegment01894,
    &seg_iSegment01895,
    &seg_iSegment01896,
    &seg_iSegment01897,
    &seg_iSegment01898,
    &seg_iSegment01899,
    &seg_iSegment01900,
    &seg_iSegment01901,
    &seg_iSegment01902,
    &seg_iSegment01903,
    &seg_iSegment01904,
    &seg_iSegment01905,
    &seg_iSegment01906,
    &seg_iSegment01907,
    &seg_iSegment01908,
    &seg_iSegment01909,
    &seg_iSegment01910,
    &seg_iSegment01911,
    &seg_iSegment01912,
    &seg_iSegment01913,
    &seg_iSegment01914,
    &seg_iSegment01915,
    &seg_iSegment01916,
    &seg_iSegment01917,
    &seg_iSegment01918,
    &seg_iSegment01919,
    &seg_iSegment01920,
    &seg_iSegment01921,
    &seg_iSegment01922,
    &seg_iSegment01923,
    &seg_iSegment01924,
    &seg_iSegment01925,
    &seg_iSegment01926,
    &seg_iSegment01927,
    &seg_iSegment01928,
    &seg_iSegment01929,
    &seg_iSegment01930,
    &seg_iSegment01931,
    &seg_iSegment01932,
    &seg_iSegment01933,
    &seg_iSegment01934,
    &seg_iSegment01935,
    &seg_iSegment01936,
    &seg_iSegment01937,
    &seg_iSegment01938,
    &seg_iSegment01939,
    &seg_iSegment01940,
    &seg_iSegment01941,
    &seg_iSegment01942,
    &seg_iSegment01943,
    &seg_iSegment01944,
    &seg_iSegment01945,
    &seg_iSegment01946,
    &seg_iSegment01947,
    &seg_iSegment01948,
    &seg_iSegment01949,
    &seg_iSegment01950,
    &seg_iSegment01951,
    &seg_iSegment01952,
    &seg_iSegment01953,
    &seg_iSegment01954,
    &seg_iSegment01955,
    &seg_iSegment01956,
    &seg_iSegment01957,
    &seg_iSegment01958,
    &seg_iSegment01959,
    &seg_iSegment01960,
    &seg_iSegment01961,
    &seg_iSegment01962,
    &seg_iSegment01963,
    &seg_iSegment01964,
    &seg_iSegment01965,
    &seg_iSegment01966,
    &seg_iSegment01967,
    &seg_iSegment01968,
    &seg_iSegment01969,
    &seg_iSegment01970,
    &seg_iSegment01971,
    &seg_iSegment01972,
    &seg_iSegment01973,
    &seg_iSegment01974,
    &seg_iSegment01975,
    &seg_iSegment01976,
    &seg_iSegment01977,
    &seg_iSegment01978,
    &seg_iSegment01979,
    &seg_iSegment01980,
    &seg_iSegment01981,
    &seg_iSegment01982,
    &seg_iSegment01983,
    &seg_iSegment01984,
    &seg_iSegment01985,
    &seg_iSegment01986,
    &seg_iSegment01987,
    &seg_iSegment01988,
    &seg_iSegment01989,
    &seg_iSegment01990,
    &seg_iSegment01991,
    &seg_iSegment01992,
    &seg_iSegment01993,
    &seg_iSegment01994,
    &seg_iSegment01995,
    &seg_iSegment01996,
    &seg_iSegment01997,
    &seg_iSegment01998,
    &seg_iSegment01999,
    &seg_iSegment02000,
    &seg_iSegment02001,
    &seg_iSegment02002,
    &seg_iSegment02003,
    &seg_iSegment02004,
    &seg_iSegment02005,
    &seg_iSegment02006,
    &seg_iSegment02007,
    &seg_iSegment02008,
    &seg_iSegment02009,
    &seg_iSegment02010,
    &seg_iSegment02011,
    &seg_iSegment02012,
    &seg_iSegment02013,
    &seg_iSegment02014,
    &seg_iSegment02015,
    &seg_iSegment02016,
    &seg_iSegment02017,
    &seg_iSegment02018,
    &seg_iSegment02019,
    &seg_iSegment02020,
    &seg_iSegment02021,
    &seg_iSegment02022,
    &seg_iSegment02023,
    &seg_iSegment02024,
    &seg_iSegment02025,
    &seg_iSegment02026,
    &seg_iSegment02027,
    &seg_iSegment02028,
    &seg_iSegment02029,
    &seg_iSegment02030,
    &seg_iSegment02031,
    &seg_iSegment02032,
    &seg_iSegment02033,
    &seg_iSegment02034,
    &seg_iSegment02035,
    &seg_iSegment02036,
    &seg_iSegment02037,
    &seg_iSegment02038,
    &seg_iSegment02039,
    &seg_iSegment02040,
    &seg_iSegment02041,
    &seg_iSegment02042,
    &seg_iSegment02043,
    &seg_iSegment02044,
    &seg_iSegment02045,
    &seg_iSegment02046,
    &seg_iSegment02047
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\utils.h ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

namespace XESECTIONS
    {
    extern bool FileExists(const char *filename);
    extern DWORD FillFile(HANDLE hFile, DWORD size);
    extern DWORD CreateFilledFile(const char *filename, DWORD size=16384);
    extern HANDLE FileOpen(const char *filename);
    extern HANDLE FileOpenRW(const char *filename);
    extern BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec);
    extern DWORD FillHDPartition(const char *drive, char *lpFile);
    extern void LogResourceStatus(HANDLE hLog, bool debugger);

    class iLARGE_INTEGER
        {
        public: 
            __int64 value;

        public:
            iLARGE_INTEGER() { value = 0; }
            iLARGE_INTEGER(int i) { value = i; }
            iLARGE_INTEGER(DWORD i) { value = i; }
            iLARGE_INTEGER(__int64 i) { value = i; }
            iLARGE_INTEGER(const LARGE_INTEGER &i) { value = i.QuadPart; }

            operator int() {  return (int)value; }
            operator DWORD() {  return (DWORD)value; }
            operator __int64() {  return value; }
            operator LARGE_INTEGER() {  LARGE_INTEGER a; a.QuadPart=value; return a; }
        };

    } // namespace XESECTIONS
#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\utils.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif

namespace XESECTIONS {

/*****************************************************************************

Routine Description:

    Ansi2UnicodeHack

    In-place Pseudo Ansi to Unicode (char to wide char) conversion.

Arguments:

    IN char* str - char string to convert to wide char string

Return Value:

    char* - pointer to Unicode string

Note:
    
    Because a bunch of Unicode functions expect a char string to be on an
    even boundry, the returned string may be moved 1 character over.

*****************************************************************************/
char* Ansi2UnicodeHack(char *str)
    {
    if(!str) return NULL;

    int align = 0;
    int len = strlen(str)+1;

    // put string on an even boundry because some freak put a bunch of ASSERTs
    // that check for even boundries in Unicode functions like 
    // RtlEqualUnicodeString()
    if(((ULONG_PTR)str & 1) != 0)
        {
        align = 1;
        }

    for(; len>=0; len--)
        {
        str[len*2+align] = str[len];
        str[len*2+align+1] = '\0';
        }

    str += align;

    return (char*)str;
    }


/*****************************************************************************

Routine Description:

    Unicode2AnsiHack

    In-place Pseudo Unicode to Ansi (wide char to char) conversion.

Arguments:

    IN unsigned short* str - wide char string to convert to char string

Return Value:

    char* - pointer to ANSI string

*****************************************************************************/
char* Unicode2AnsiHack(unsigned short *str)
    {
    if(!str) return NULL;
    char *str2 = (char*)str;

    size_t len = wcslen(str)+1;
    for(size_t i=0; i<len; i++)
        {
        str2[i] = str2[i*2];
        }

    return (char*)str;
    }

/*

Routine Description:

    Checks to see if a file or directory exists

Arguments:

    char *filename - the name of the file or dir to search for

Return Value:

    true if it exists, false if it doesnt

*/
bool FileExists(const char *filename)
    {
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    bool retval = false;

    hFind = FindFirstFile(filename, &FindFileData);

    if(hFind != INVALID_HANDLE_VALUE)
        {
        retval = true;
        }
    FindClose(hFind);

    return retval;
    }




/*

Routine Description:

    Creates a new file and fills it with x bytes of garbage

Arguments:

    char *filename - the name of the file to create
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD CreateFilledFile(const char *filename, DWORD size /*=16384*/)
    {
    HANDLE file = CreateFile(filename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    size = FillFile(file, size);

    CloseHandle(file);

    return size;
    return size;
    }




/*

Routine Description:

    Fills an opened file with x bytes of garbage

Arguments:

    HANDLE hFile - handle to opened file
    DWORD size - how big the file should be

Return Value:

    DWORD actual size of file

*/
DWORD FillFile(HANDLE hFile, DWORD size)
    {
    char *error = NULL;
    char w = 'X';
    DWORD wsize = sizeof(w);
    DWORD errCode = 0;

    do
        {
        if(hFile == INVALID_HANDLE_VALUE)
            {
            error = "unable to create/open file";
            errCode = GetLastError();
            break;
            }

        if(size == 0) break;

        if(SetFilePointer(hFile, size-1, NULL, FILE_BEGIN) != size-1)
            {
            error = "unable to size file";
            errCode = GetLastError();
            break;
            }

        if(WriteFile(hFile, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = "unable to write last byte";
            errCode = GetLastError();
            break;
            }
        } while(0);

    FlushFileBuffers(hFile);

    if(error)
        {
        DebugPrint("FILEIO: FillFile(%ld) - %s (ec: %d)\n", size, error, errCode);
        size = 0;
        }

    return size;
    }

/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpen(const char *filename)
    {
    return CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }



/*

Routine Description:

    Opens a file with Read Only access

Arguments:

    char *filename - name of the file to open

Return Value:

    BOOL - returns the result from CreateFile

*/
HANDLE FileOpenRW(const char *filename)
    {
    return CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }




/*

Routine Description:

    Generates a FILETIME structure from the date components by calling 
    SystemTimeToFileTime

Arguments:

    LPFILETIME fileTime - pointer to the FILETIME struct to populate with the date
    WORD year
    WORD month
    WORD day
    WORD hour
    WORD min
    WORD sec
    WORD msec

Return Value:

    BOOL - returns the result from SystemTimeToFileTime

*/
BOOL CreateFileTime(LPFILETIME fileTime, WORD year, WORD month, WORD day, WORD hour, WORD min, WORD sec, WORD msec)
    {
    SYSTEMTIME sysTime;

    sysTime.wYear = year;
    sysTime.wMonth = month;
    sysTime.wDay = day;
    sysTime.wHour = hour;
    sysTime.wMinute = min;
    sysTime.wSecond = sec;
    sysTime.wMilliseconds = msec;

    return SystemTimeToFileTime(&sysTime, fileTime);
    }

/*

Routine Description:


Arguments:

    drive - Drive to fill up, it should be in the form 
        C:\
        D:\
        etc.
    lpFile - This function will populate buffer with the name of the file created

Return Value:

    DWORD return code from GetLastError in the event of a problem

*/
DWORD FillHDPartition(const char *drive, char *lpFile)
    {
    if(!drive || !lpFile) return ERROR_INVALID_PARAMETER;

    DWORD error = 0;
    char w = 'X';
    DWORD wsize = sizeof(w);
    LARGE_INTEGER distance;
    LARGE_INTEGER size;
    ULARGE_INTEGER available;
    ULARGE_INTEGER total;
    ULARGE_INTEGER free;

    DebugPrint("FILEIO: Filling HD Partition: %s (this takes a long time)...\n", drive);

    sprintf(lpFile, "%sFHD.dmp", drive);

    HANDLE file = CreateFile(lpFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
    if(file == INVALID_HANDLE_VALUE)
        {
        return GetLastError();
        }

    // Get the disk space free
    GetDiskFreeSpaceEx(drive, &available, &total, &free);
    distance.QuadPart = (__int64)available.QuadPart - 256;
    size.QuadPart = 0;

    // Do a test write
    if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
        {
        error = GetLastError();
        CloseHandle(file);
        return error;
        }

    // write as big as a file as possible
    do
        {
        distance.QuadPart -= 256;
        if(distance.QuadPart < 0) break;

        if(SetFilePointerEx(file, distance, &size, FILE_BEGIN) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("SetFilePointerEx (ec: %lu)\n", error);
            }
        else if(size.QuadPart != distance.QuadPart)
            {
            error = 99;
            //DebugPrint("SetFilePointerEx size != dist\n");
            }
        else if(WriteFile(file, &w, wsize, &wsize, NULL) != TRUE)
            {
            error = GetLastError();
            //DebugPrint("WriteFile (ec: %lu)\n", error);
            }
        else
            {
            error = 0;
            }

        } while(error);

    // clean up
    if(FlushFileBuffers(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("FlushFileBuffers (ec: %lu)\n", error);
        }
    if(CloseHandle(file) != TRUE)
        {
        error = GetLastError();
        //DebugPrint("CloseHandle (ec: %lu)\n", error);
        }

    DebugPrint("FILEIO: Filled  HD Partition. %s(%I64d)\n", lpFile, size.QuadPart);

    return error;
    }

/*

Routine Description:

    Writes system resource usage information to the specified log file 
    and/or to the debugger.

    Be sure to include extern "C" { "ntos.h" } to use MmQueryStatistics

    MM_STATISTICS:
        ULONG TotalPhysicalPages;
        ULONG AvailablePages;
        ULONG VirtualMemoryBytesCommitted;
        ULONG VirtualMemoryBytesReserved;
        ULONG CachePagesCommitted;
        ULONG PoolPagesCommitted;
        ULONG StackPagesCommitted;
        ULONG ImagePagesCommitted;

Arguments:

    HANDLE hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs
    bool debugger - true sends memory data to the debugger

Return Value:

    None

*/
extern "C" void FlushDiskCache(void);

void LogResourceStatus(HANDLE hLog, bool debugger)
    {
    const DWORD pageSize = 4096;
    MM_STATISTICS mmStats;
    PS_STATISTICS psStats;

    // initialize the stat info
    memset(&mmStats, 0, sizeof(MM_STATISTICS));
    mmStats.Length = sizeof(MM_STATISTICS);
    memset(&psStats, 0, sizeof(PS_STATISTICS));
    psStats.Length = sizeof(PS_STATISTICS);

    FlushDiskCache();

    // gather all the data
    MmQueryStatistics(&mmStats);
    PsQueryStatistics(&psStats);

    // display/write the data
    if(hLog)
        {
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        xLog(hLog, XLL_INFO, "   Total:     %lu", mmStats.TotalPhysicalPages*pageSize);
        xLog(hLog, XLL_INFO, "   Available: %lu", mmStats.AvailablePages*pageSize);
        xLog(hLog, XLL_INFO, "   Cache:     %lu", mmStats.CachePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Pool:      %lu", mmStats.PoolPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Stack:     %lu", mmStats.StackPagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Image:     %lu", mmStats.ImagePagesCommitted*pageSize);
        xLog(hLog, XLL_INFO, "   Handles:   %lu", psStats.HandleCount);
        xLog(hLog, XLL_INFO, "Memory Status------------------------------------------");
        }
    if(debugger)
        {
        DebugPrint("MEM: Available=%lu, Cache=%lu, Pool=%lu, Stack=%lu, Image=%lu, Handles=%lu\n", mmStats.AvailablePages*pageSize, mmStats.CachePagesCommitted*pageSize, mmStats.PoolPagesCommitted*pageSize, mmStats.StackPagesCommitted*pageSize, mmStats.ImagePagesCommitted*pageSize, psStats.HandleCount);
        }
    }

void FlushVolume(char *volume)
    {
    HANDLE hFile = CreateFile(volume, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, 0, NULL);
    if(hFile == INVALID_HANDLE_VALUE)
        DebugPrint("MEM: FlushError: %lu, 0x%x\n", GetLastError(), GetLastError());
    FlushFileBuffers(hFile);
    CloseHandle(hFile);
    }

} // namespace XESECTIONS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\sections\XLoadSection.cpp ===
/*

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    XLoadSection.cpp

Abstract:

    Tests the section loading / unloading APIs

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "commontest.h"
#include "sections.h"
#include <xbeimage.h>

/*

Routine Description:

    Tests the section loading / unloading APIs

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    DWORD - 

*/
extern int seg_iSegment00001;
extern int *segmentValues[2048];

DWORD XESECTIONS::XLoadSection_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    */

    char segName[9];
    char testcase[32];
    HANDLE hSection;
    void *pSection1, *pSection2;
    DWORD size;
    PXBEIMAGE_SECTION oSection;
    unsigned refCount;


    //
    // This chunk is needed so that the linker doesnt throw out 
    // all of our sections
    //
    XLoadSection("seg00001");
    seg_iSegment00001 = 1;
    XFreeSection("seg00001");


    /*
        this test has 2048 sections in it, use for(i=0; i<2048, i++) for
        the full test.
    */
     for(unsigned i=0; i<512; i++)
        {
        sprintf(segName, "seg%05u", i);
        sprintf(testcase, "Modify seg%05u", i);

        xSetFunctionName(hLog, "XGetSectionHandle");
        TESTCASE(segName)
            {
            hSection = XGetSectionHandleA(segName);
            if(hSection != INVALID_HANDLE_VALUE) 
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());
            } ENDTESTCASE;

        if(hSection == INVALID_HANDLE_VALUE) continue;
        oSection = (PXBEIMAGE_SECTION)hSection;
        refCount = oSection->SectionReferenceCount;

        xSetFunctionName(hLog, "XLoadSection");
        TESTCASE(segName)
            {
            pSection1 = XLoadSection(segName);
            if(pSection1)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "ptr=%08X (ec: %ld)", pSection1, GetLastError());

            if(oSection->SectionReferenceCount == refCount+1)
                TESTPASS(hLog, "SectionReferenceCount==%u (ec: %ld)", oSection->SectionReferenceCount, GetLastError());
            else
                TESTFAIL(hLog, "SectionReferenceCount==%u (ec: %ld)", oSection->SectionReferenceCount, GetLastError());
            } ENDTESTCASE;
        TESTCASE(testcase)
            {
            *segmentValues[i] = i; // this will throw an exception if segment isnt loaded
            if(*segmentValues[i] == i)
                TESTPASS(hLog, "seg_iSegment%05u(%u) == %u", i, *segmentValues[i], i);
            else
                TESTFAIL(hLog, "seg_iSegment%05u(%u) != %u", i, *segmentValues[i], i);
            } ENDTESTCASE;

        xSetFunctionName(hLog, "XLoadSectionByHandle");
        TESTCASE(segName)
            {
            pSection2 = XLoadSectionByHandle(hSection);
            if(pSection2)
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "ptr=%08X (ec: %ld)", pSection2, GetLastError());

            if(oSection->SectionReferenceCount == refCount+2) 
                TESTPASS(hLog, "SectionReferenceCount==%u (ec: %ld)", oSection->SectionReferenceCount, GetLastError());
            else
                TESTFAIL(hLog, "SectionReferenceCount==%u (ec: %ld)", oSection->SectionReferenceCount, GetLastError());
            } ENDTESTCASE;

        xSetFunctionName(hLog, "XFreeSection");
        TESTCASE(segName)
            {
            if(XFreeSection(segName))
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());

            if(oSection->SectionReferenceCount == refCount+1) 
                TESTPASS(hLog, "SectionReferenceCount==%u (ec: %ld)", oSection->SectionReferenceCount, GetLastError());
            else
                TESTFAIL(hLog, "SectionReferenceCount==%u (ec: %ld)", oSection->SectionReferenceCount, GetLastError());
            } ENDTESTCASE;


        xSetFunctionName(hLog, "XGetSectionSize");
        TESTCASE(segName)
            {
            size = XGetSectionSize(hSection);
            if(size)
                TESTPASS(hLog, "Section Size: %u (ec: %ld)", size, GetLastError());
            else
                TESTFAIL(hLog, "Section Size: %u (ec: %ld)", size, GetLastError());
            } ENDTESTCASE;

        xSetFunctionName(hLog, "XFreeSectionByHandle");
        TESTCASE(segName)
            {
            if(XFreeSectionByHandle(hSection))
                TESTPASS(hLog, "(ec: %ld)", GetLastError());
            else
                TESTFAIL(hLog, "(ec: %ld)", GetLastError());

            if(oSection->SectionReferenceCount == refCount) 
                TESTPASS(hLog, "SectionReferenceCount==%u (ec: %ld)", oSection->SectionReferenceCount, GetLastError());
            else
                TESTFAIL(hLog, "SectionReferenceCount==%u (ec: %ld)", oSection->SectionReferenceCount, GetLastError());
            } ENDTESTCASE;
        }


    DWORD time = GetTickCount();




    //////////////////////////////////////////////////////////////////////////
    // NULL & ""
    //////////////////////////////////////////////////////////////////////////



    //////////////////////////////////////////////////////////////////////////
    // Straight line successes
    //////////////////////////////////////////////////////////////////////////


    //////////////////////////////////////////////////////////////////////////
    // Straight line failures
    //////////////////////////////////////////////////////////////////////////





    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    /*
    TESTCASE("Mini Stress")
        {
        DebugPrint("XESECTIONS(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 1000;
        unsigned failures = 0;
        unsigned i;
        for(i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }

            //if(XGetSoundtrackSongInfo(1, 0, &songID, &songLength, songname, 1024) != TRUE)
            //    ++failures;
            }
        if(failures)
            TESTFAIL(hLog, "Mini stress failures: %u", failures);
        else
            TESTPASS(hLog, "Mini stress failures: %u", failures);
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });
*/

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\create.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    create.cpp

Abstract:

    This program contains routines to stress and test threads
    and threading related APIs

--*/

#include "threading.h"

#define MAX_THREADS 10000

DWORD
WINAPI
StackSizeTestThreadProc(
    PTHREAD_PARAMETERS tpm
    )
{
    PVOID pv;

    if ( tpm ) {
        tpm->ExceptionCode = 0;
        __try {
            // Try to allocate space in stack
            pv = _alloca( tpm->StackSize );
        } __except( EXCEPTION_EXECUTE_HANDLER ) {
            tpm->ExceptionCode = GetExceptionCode();
        }
    }

    return 0;
}

DWORD
WINAPI
DoNothingThreadProc(
    DWORD ExitCode
    )
{
    return ExitCode;
}

DWORD
WINAPI
PollThreadProc(
    volatile LONG *ExitFlag
    )
{
    while ( *ExitFlag == 0 ) {
        Sleep( 1000 );
    }

    return InterlockedDecrement( (LPLONG)ExitFlag );
}

VOID
ThreadStackSizeTest(
    HANDLE LogHandle,
    ULONG Size
    )
{
    HANDLE ThreadHandle;
    CHAR Variation[64];
    THREAD_PARAMETERS tpm;

    if ( Size <= 1024*1024 ) {
        sprintf( Variation, "%dK stack size", Size/1024 );
    } else {
        sprintf( Variation, "%dM stack size", Size/(1024*1024) );
    }

    tpm.StackSize = Size;

    BEGIN_VARIATION( Variation )
    {
        ThreadHandle = CreateThread(
                            0,
                            4096 + Size,
                            (LPTHREAD_START_ROUTINE)StackSizeTestThreadProc,
                            (LPVOID)&tpm,
                            0,
                            NULL
                            );

        if ( !ThreadHandle ) {
            LOG_FAIL();
        } else {
            WaitForSingleObject( ThreadHandle, INFINITE );

            if ( tpm.ExceptionCode ) {
                xLog(
                    LogHandle,
                    XLL_EXCEPTION,
                    "BugID 7 - Exception=%s (0x%X)",
                    NtStatusSymbolicName( tpm.ExceptionCode ),
                    tpm.ExceptionCode
                    );
            } else {
                LOG_PASS();
            }

            CloseHandle( ThreadHandle );
        }
    }
    END_VARIATION();
}

VOID
SecurityAttributesTest(
    HANDLE LogHandle,
    LPSTR  Variation,
    LPSECURITY_ATTRIBUTES lpSA
    )
{
    HANDLE ThreadHandle;

    BEGIN_VARIATION( Variation )
    {
        ThreadHandle = CreateThread(
                            lpSA,
                            0,
                            (LPTHREAD_START_ROUTINE)StackSizeTestThreadProc,
                            0,
                            0,
                            NULL
                            );

        if ( !ThreadHandle ) {
            LOG_FAIL();
        } else {
            WaitForSingleObject( ThreadHandle, INFINITE );
            LOG_PASS();
            CloseHandle( ThreadHandle );
        }
    }
    END_VARIATION();
}

VOID
CreateThreadTest(
    HANDLE LogHandle
    )
{
    int i;
    HANDLE ThreadHandle;
    DWORD ExitCode, RealExitCode;
    volatile LONG ExitFlag;
    CHAR Buffer[256];
    ULONG Seed = GetTickCount();

    xSetFunctionName( LogHandle, "CreateThread" );

    ThreadStackSizeTest( LogHandle, 0 );
    ThreadStackSizeTest( LogHandle, 16*1024 );
    ThreadStackSizeTest( LogHandle, 128*1024 );
    ThreadStackSizeTest( LogHandle, 1*1024*1024 );
    ThreadStackSizeTest( LogHandle, 2*1024*1024 );
    ThreadStackSizeTest( LogHandle, 5*1024*1024 );
    ThreadStackSizeTest( LogHandle, 16*1024*1024 );

    SecurityAttributesTest(
        LogHandle,
        "lpsa = 0xdeadbeef",
        (LPSECURITY_ATTRIBUTES)0xdeadbeef
        );

    SecurityAttributesTest(
        LogHandle,
        "lpsa = NULL",
        NULL
        );

    BEGIN_VARIATION( "Create 10000 thread serially" )
    {
        for ( i=0; i<MAX_THREADS; i++ ) {
            ExitCode = RtlRandom( &Seed );
            ThreadHandle = CreateThread(
                                0,
                                16384 + (RtlRandom( &Seed) % 4096),
                                (LPTHREAD_START_ROUTINE)DoNothingThreadProc,
                                (LPVOID)ExitCode,
                                0,
                                NULL
                                );

            if ( !ThreadHandle ) {
                LOG_FAIL();
                break;
            } else {
                WaitForSingleObject( ThreadHandle, INFINITE );
                if ( !GetExitCodeThread( ThreadHandle, &RealExitCode ) ) {
                    CloseHandle( ThreadHandle );
                    LOG_MSG_BLOCK( "GetExitCodeThread failed" );
                    break;
                } else if ( ExitCode != RealExitCode ) {
                    CloseHandle( ThreadHandle );
                    LOG_FAIL();
                    break;
                } else {
                    CloseHandle( ThreadHandle );
                    if ( i == MAX_THREADS-1 ) {
                        LOG_PASS();
                    }
                }
            }
        }
    }
    END_VARIATION();

    if ( !XTestLibIsStressTesting() ) {

        int ThreadPriority = GetThreadPriority( GetCurrentThread() );

        if ( ThreadPriority != THREAD_PRIORITY_ERROR_RETURN ) {
            SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST );
        }

        BEGIN_VARIATION( "Create as many threads as possible" )
        {
            i = 0;
            ExitFlag = 0;

            do {
                ThreadHandle = CreateThread(
                                    0,
                                    16384 + (RtlRandom( &Seed ) % 16384),
                                    (LPTHREAD_START_ROUTINE)PollThreadProc,
                                    (LPVOID)&ExitFlag,
                                    0,
                                    NULL
                                    );

                if ( ThreadHandle ) {
                    i++;
                    SetThreadPriority( ThreadHandle, THREAD_PRIORITY_TIME_CRITICAL );
                    CloseHandle( ThreadHandle );
                }

            } while ( ThreadHandle );

            InterlockedExchange( (LPLONG)&ExitFlag, i );
            NtYieldExecution();

            while ( ExitFlag ) {
                Sleep( 1000 );
            }

            sprintf( Buffer, "%d threads created", i );
            LOG_MSG_PASS( Buffer );
        }
        END_VARIATION();

        if ( ThreadPriority != THREAD_PRIORITY_ERROR_RETURN ) {
            SetThreadPriority( GetCurrentThread(), ThreadPriority );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\notify.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    notify.cpp

Abstract:

    This program contains routines to stress and test threads
    and threading related APIs

Environment:

    Xbox

Revision History:

--*/


#include "threading.h"


LONG ThreadingCreateNotificationCounter;
LONG ThreadingDestroyNotificationCounter;


static
DWORD
WINAPI
NotificationTestThreadProc(
    PULONG
    )
{
    //
    // Does nothing, just returns immediately
    //
    return 0;
}


VOID
WINAPI
NotificationTestNotifyProc(
    BOOL fCreate
    )
{
    if ( fCreate ) {
        InterlockedIncrement( &ThreadingCreateNotificationCounter );
    } else {
        InterlockedIncrement( &ThreadingDestroyNotificationCounter );
    }
}


VOID
ThreadNotificationTest(
    HANDLE LogHandle
    )
{
    HANDLE ThreadHandle = NULL;
    XTHREAD_NOTIFICATION xtn;

    xSetFunctionName( LogHandle, "XRegisterThreadNotifyRoutine" );

    //
    // Reset counter so it will run correctly in stress mode
    //
    InterlockedExchange( &ThreadingCreateNotificationCounter, 0 );
    InterlockedExchange( &ThreadingDestroyNotificationCounter, 0 );

    xtn.pfnNotifyRoutine = (XTHREAD_NOTIFY_PROC)NotificationTestNotifyProc;
    XRegisterThreadNotifyRoutine( &xtn, TRUE );

    BEGIN_VARIATION( "create (registered)" )
    {
        ThreadHandle = CreateThread( 0, 0, (LPTHREAD_START_ROUTINE)NotificationTestThreadProc, NULL, 0, 0 );

        if ( !ThreadHandle ) {
            LOG_MSG_BLOCK( "unable to create thread" );
        } else {
            WaitForSingleObject( ThreadHandle, INFINITE );
            LOG_PASS_FAIL( ThreadingCreateNotificationCounter );
        }
    }
    END_VARIATION();

    BEGIN_VARIATION( "destroy (registered)" )
    {
        if ( ThreadHandle ) {
            LOG_PASS_FAIL( ThreadingDestroyNotificationCounter );
        } else {
            LOG_MSG_BLOCK( "unable to create thread" );
        }
    }
    END_VARIATION();

    XRegisterThreadNotifyRoutine( &xtn, FALSE );

    if ( ThreadHandle ) {
        CloseHandle( ThreadHandle );
        ThreadHandle = NULL;
    }

    //
    // Reset counter back to zero
    //
    InterlockedExchange( &ThreadingCreateNotificationCounter, 0 );
    InterlockedExchange( &ThreadingDestroyNotificationCounter, 0 );

    BEGIN_VARIATION( "create (unregistered)" )
    {
        ThreadHandle = CreateThread( 0, 0, (LPTHREAD_START_ROUTINE)NotificationTestThreadProc, NULL, 0, 0 );

        if ( !ThreadHandle ) {
            LOG_MSG_BLOCK( "unable to create thread" );
        } else {
            //
            // Counter should be zero because we already de-registered
            //
            WaitForSingleObject( ThreadHandle, INFINITE );
            LOG_PASS_FAIL( ThreadingCreateNotificationCounter == 0 );
        }
    }
    END_VARIATION();

    BEGIN_VARIATION( "destroy (unregistered)" )
    {
        if ( ThreadHandle ) {
            //
            // Counter should be zero because we already de-registered
            //
            LOG_PASS_FAIL( ThreadingDestroyNotificationCounter == 0);
        } else {
            LOG_MSG_BLOCK( "unable to create thread" );
        }
    }
    END_VARIATION();

    if ( ThreadHandle ) {
        CloseHandle( ThreadHandle );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\priority.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    priority.cpp

Abstract:

    This program contains routines to stress and test threads
    and threading related APIs

Author:

    Sakphong Chanbai (schanbai) 10-May-2000

Environment:

    Xbox

Revision History:

--*/


#include "threading.h"


static
DWORD
WINAPI
ThreadProc(
    PTHREAD_PARAMETERS tpm
    )
{
    return (DWORD)tpm;
}


VOID
GetThreadPriorityVariation(
    HANDLE LogHandle,
    LPSTR  Variation,
    HANDLE ThreadHandle,
    LPSTR  BlockMsg,
    BOOL   InvalidCase,
    BOOL   CleanupHandle
    )
{
    BOOL Success;

    BEGIN_VARIATION( Variation )
    {
        if ( !InvalidCase && !ThreadHandle ) {
            LOG_MSG_BLOCK( BlockMsg );
        } else {
            Success = ( THREAD_PRIORITY_ERROR_RETURN != GetThreadPriority(ThreadHandle) );
            LOG_PASS_FAIL( InvalidCase ? !Success : Success );
        }
    }
    END_VARIATION();

    if ( CleanupHandle ) {
        CloseHandle( ThreadHandle );
    }
}


VOID
GetThreadPriorityTest(
    HANDLE LogHandle
    )
{
    HANDLE Handle;

    xSetFunctionName( LogHandle, "GetThreadPriority" );

    GetThreadPriorityVariation(
        LogHandle,
        "normal thread",
        PrepareThread(ThreadProc, 0, 0),
        "CreateThread failed",
        FALSE,
        TRUE
        );

    GetThreadPriorityVariation(
        LogHandle,
        "current thread",
        GetCurrentThread(),
        "GetCurrentThread failed",
        FALSE,
        FALSE
        );

    GetThreadPriorityVariation(
        LogHandle,
        "suspended thread",
        Handle = PrepareThread( ThreadProc, 0, CREATE_SUSPENDED ),
        "CreateThread failed",
        FALSE,
        FALSE
        );
    ResumeThread( Handle );
    CloseHandle( Handle );

    GetThreadPriorityVariation(
        LogHandle,
        "handle=0xdeadbeef",
        (HANDLE)0xdeadbeef,
        0,
        TRUE,
        FALSE
        );

    GetThreadPriorityVariation(
        LogHandle,
        "handle=NULL",
        NULL,
        0,
        TRUE,
        FALSE
        );

    GetThreadPriorityVariation(
        LogHandle,
        "handle=INVALID_HANDLE_VALUE",
        INVALID_HANDLE_VALUE,
        0,
        TRUE,
        FALSE
        );

    GetThreadPriorityVariation(
        LogHandle,
        "event handle",
        CreateEvent(0, 0, 0, 0),
        "CreateEvent failed",
        TRUE,
        TRUE
        );

    GetThreadPriorityVariation(
        LogHandle,
        "semaphore handle",
        CreateSemaphore(0, 0, 1, 0),
        "CreateSemaphore failed",
        TRUE,
        TRUE
        );

    GetThreadPriorityVariation(
        LogHandle,
        "mutex handle",
        CreateMutex(0, 0, 0),
        "CreateMutex failed",
        TRUE,
        TRUE
        );

    GetThreadPriorityVariation(
        LogHandle,
        "waitable timer handle",
        CreateWaitableTimer(0, 0, 0),
        "CreateWaitableTimer failed",
        TRUE,
        TRUE
        );
}


VOID
SetThreadPriorityVariation(
    HANDLE LogHandle,
    LPSTR  Variation,
    HANDLE ThreadHandle,
    LPSTR  BlockMsg,
    BOOL   InvalidCase,
    BOOL   CleanupHandle
    )
{
    BOOL Success;
    static int ThreadPriorities[] = {
        THREAD_PRIORITY_ABOVE_NORMAL,
        THREAD_PRIORITY_BELOW_NORMAL,
        THREAD_PRIORITY_HIGHEST,
        THREAD_PRIORITY_IDLE,
        THREAD_PRIORITY_LOWEST,
        THREAD_PRIORITY_NORMAL,
        THREAD_PRIORITY_TIME_CRITICAL
    };
    const int ArraySize = sizeof(ThreadPriorities)/sizeof(ThreadPriorities[0]);
    int Priority, OriginalPriority = THREAD_PRIORITY_ERROR_RETURN;
    ULONG Seed = GetTickCount();

    BEGIN_VARIATION( Variation )
    {
        if ( !InvalidCase && !ThreadHandle ) {
            LOG_MSG_BLOCK( BlockMsg );
        } else {
            OriginalPriority = GetThreadPriority( ThreadHandle );
            Priority = ThreadPriorities[ RtlRandom( &Seed ) % ArraySize ];
            Success = SetThreadPriority( ThreadHandle, Priority );

            if ( InvalidCase ) {
                LOG_PASS_FAIL( !Success );
            } else if ( GetThreadPriority( ThreadHandle ) != Priority ) {
                LOG_MSG_FAIL( "mismatch thread priority" );
            } else {
                LOG_PASS();
            }
        }
    }
    END_VARIATION();

    //
    // Restore previous thread's priority
    //

    if ( !InvalidCase && ThreadHandle != NULL ) {
        if ( OriginalPriority == THREAD_PRIORITY_ERROR_RETURN ) {
            OriginalPriority = THREAD_PRIORITY_NORMAL;
        }
        SetThreadPriority( ThreadHandle, OriginalPriority );
    }

    if ( CleanupHandle ) {
        CloseHandle( ThreadHandle );
    }
}


VOID
SetThreadPriorityTest(
    HANDLE LogHandle
    )
{
    HANDLE Handle;

    xSetFunctionName( LogHandle, "SetThreadPriority" );

    SetThreadPriorityVariation(
        LogHandle,
        "normal thread",
        PrepareThread(ThreadProc, 0, 0),
        "CreateThread failed",
        FALSE,
        TRUE
        );

    SetThreadPriorityVariation(
        LogHandle,
        "current thread",
        GetCurrentThread(),
        "GetCurrentThread failed",
        FALSE,
        FALSE
        );

    SetThreadPriorityVariation(
        LogHandle,
        "suspended thread",
        Handle = PrepareThread( ThreadProc, 0, CREATE_SUSPENDED ),
        "CreateThread failed",
        FALSE,
        FALSE
        );
    ResumeThread( Handle );
    CloseHandle( Handle );

    SetThreadPriorityVariation(
        LogHandle,
        "handle=0xdeadbeef",
        (HANDLE)0xdeadbeef,
        0,
        TRUE,
        FALSE
        );

    SetThreadPriorityVariation(
        LogHandle,
        "handle=NULL",
        NULL,
        0,
        TRUE,
        FALSE
        );

    SetThreadPriorityVariation(
        LogHandle,
        "handle=INVALID_HANDLE_VALUE",
        INVALID_HANDLE_VALUE,
        0,
        TRUE,
        FALSE
        );

    SetThreadPriorityVariation(
        LogHandle,
        "event handle",
        CreateEvent(0, 0, 0, 0),
        "CreateEvent failed",
        TRUE,
        TRUE
        );

    SetThreadPriorityVariation(
        LogHandle,
        "semaphore handle",
        CreateSemaphore(0, 0, 1, 0),
        "CreateSemaphore failed",
        TRUE,
        TRUE
        );

    SetThreadPriorityVariation(
        LogHandle,
        "mutex handle",
        CreateMutex(0, 0, 0),
        "CreateMutex failed",
        TRUE,
        TRUE
        );

    SetThreadPriorityVariation(
        LogHandle,
        "waitable timer handle",
        CreateWaitableTimer(0, 0, 0),
        "CreateWaitableTimer failed",
        TRUE,
        TRUE
        );
}


VOID
ThreadPriorityTest(
    HANDLE LogHandle
    )
{
    GetThreadPriorityTest( LogHandle );
    SetThreadPriorityTest( LogHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\fiber.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    main.cpp

Abstract:

    This program contains routines to stress and test fiber and fiber
    related APIs

--*/

#include "threading.h"

VOID
WINAPI
FiberProc(
    PFIBER_PARAMETERS fpm
    )
{
    ASSERT( fpm );
    ASSERT( fpm->MainFiber );

    InterlockedIncrement( &fpm->Counter );
    SwitchToFiber( fpm->MainFiber );
}

VOID
FiberStackSizeTest(
    IN HANDLE LogHandle,
    IN SIZE_T Size
    )
{
    LPVOID Fiber;
    CHAR Variation[64];

    if ( Size <= 1024*1024 ) {
        sprintf( Variation, "%dK stack size", Size/1024 );
    } else {
        sprintf( Variation, "%dM stack size", Size/(1024*1024) );
    }

    BEGIN_VARIATION( Variation )
    {
        Fiber = CreateFiber( Size, 0, 0 );
        LOG_PASS_FAIL( Fiber != NULL );
        if ( Fiber ) {
            DeleteFiber( Fiber );
        }
    }
    END_VARIATION();
}

VOID
FiberTest(
    IN HANDLE LogHandle
    )
{
    LPVOID Fiber, MainFiber=NULL;
    SIZE_T f, NumberOfFibers;
    FIBER_PARAMETERS fpm;

    xSetFunctionName( LogHandle, "CreateFiber/DeleteFiber" );

    FiberStackSizeTest( LogHandle, 0 );
    FiberStackSizeTest( LogHandle, 4096 );
    FiberStackSizeTest( LogHandle, 16*1024 );
    FiberStackSizeTest( LogHandle, 128*1024 );

    //
    // Don't run the cases that consume lots of stack space in stress
    //

    if ( !XTestLibIsStressTesting() ) {
        FiberStackSizeTest( LogHandle, 1*1024*1024 );
        FiberStackSizeTest( LogHandle, 2*1024*1024 );
        FiberStackSizeTest( LogHandle, 5*1024*1024 );
        FiberStackSizeTest( LogHandle, 16*1024*1024 );
    }

    //
    // Create lots of fibers if we are not in stress
    //

    if ( !XTestLibIsStressTesting() ) {

        PVOID *Fibers = NULL;
        NumberOfFibers = 2000;

        BEGIN_VARIATION( "Create lots of fibers" )
        {
            Fibers = (PVOID *)LocalAlloc( LPTR, NumberOfFibers*sizeof(PVOID) );
            if ( !Fibers ) {
                LOG_MSG_BLOCK( "couldn't allocate buffer" );
            } else {
                for ( f=0; f<NumberOfFibers; f++ ) {
                    Fibers[f] = CreateFiber( 16384, 0, 0 );
                    if ( !Fibers[f] ) {
                        break;
                    }
                }
                LOG_PASS_FAIL( f == NumberOfFibers );
            }
        }
        END_VARIATION();

        if ( Fibers ) {
            for ( f=0; f<NumberOfFibers && Fibers[f]; f++ ) {
                DeleteFiber( Fibers[f] );
            }
            LocalFree( Fibers );
        }
    }

    xSetFunctionName( LogHandle, "ConvertThreadToFiber" );

    BEGIN_VARIATION( "Convert current thread to fiber" )
    {
        MainFiber = ConvertThreadToFiber( 0 );
        if ( MainFiber ) {
            LOG_PASS();
        } else {
            LOG_MSG_FAIL( "Cannot convert thread to fiber, test blocked" );
        }
    }
    END_VARIATION();

    //
    // Bail out if ConvertThreadToFiber fails, nothing else we could do now
    //

    if ( !MainFiber ) {
        return;
    }

    xSetFunctionName( LogHandle, "SwitchToFiber" );

    BEGIN_VARIATION( "Switch to lots of fiber" )
    {
        NumberOfFibers = 10000;
        fpm.Counter = 0;
        fpm.ExpectedCounter = NumberOfFibers;
        fpm.LogHandle = LogHandle;
        fpm.MainFiber = MainFiber;

        for ( f=0; f<NumberOfFibers; f++ ) {
            Fiber = CreateFiber( 16384, (LPFIBER_START_ROUTINE)FiberProc, &fpm );
            if ( !Fiber ) {
                LOG_MSG_BLOCK( "unable to create fiber" );
                break;
            }
            SwitchToFiber( Fiber );
            DeleteFiber( Fiber );
        }

        if ( f == NumberOfFibers ) {
            LOG_PASS_FAIL( NumberOfFibers == fpm.ExpectedCounter );
        }
    }
    END_VARIATION();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\exit.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exit.cpp

Abstract:

    This program contains routines to stress and test threads
    and threading related APIs

--*/

#include "threading.h"

VOID
WINAPI
ExitThreadTestThreadProc1(
    PTHREAD_PARAMETERS tpm
    )
{
    ExitThread( tpm->ExitCode );
}

DWORD
WINAPI
ExitThreadTestThreadProc2(
    PTHREAD_PARAMETERS tpm
    )
{
    return tpm->ExitCode;
}

DWORD
WINAPI
RunningThreadProc(
    PTHREAD_PARAMETERS tpm
    )
{
    volatile THREAD_PARAMETERS *p = tpm;

    while ( p->ExitCode ) {
        NOTHING;
    }

    return p->ExitCode;
}

VOID
ExitThreadVariation(
    HANDLE LogHandle,
    THREADPROC ThreadProc,
    LPSTR  Variation
    )
{
    HANDLE ThreadHandle;
    THREAD_PARAMETERS tpm;
    DWORD ExitCode;
    ULONG Seed = GetTickCount();

    BEGIN_VARIATION( Variation )
    {
        tpm.ExitCode = RtlRandom( &Seed );

        ThreadHandle = CreateThread(
                            0,
                            0,
                            (LPTHREAD_START_ROUTINE)ThreadProc,
                            (LPVOID)&tpm,
                            0,
                            NULL
                            );

        if ( !ThreadHandle ) {
            LOG_MSG_BLOCK( "CreateThread failed" );
        } else {
            WaitForSingleObject( ThreadHandle, INFINITE );

            if ( !GetExitCodeThread(ThreadHandle, &ExitCode) ) {
                LOG_MSG_BLOCK( "GetExitCodeThread failed" );
            } else if ( tpm.ExitCode == ExitCode ) {
                LOG_PASS();
            } else {
                LOG_MSG_FAIL( "mismatch exit code" );
            }

            CloseHandle( ThreadHandle );
        }
    }
    END_VARIATION();
}

VOID
GetExitCodeThreadVariation(
    HANDLE LogHandle,
    LPSTR  Variation,
    HANDLE Handle,
    PTHREAD_PARAMETERS tpm OPTIONAL,
    LPSTR  BlockMsg,
    BOOL   InvalidCase,
    BOOL   CleanupHandle
    )
{
    DWORD ExitCode;
    BOOL  Success;

    BEGIN_VARIATION( Variation )
    {
        if ( CleanupHandle && !Handle ) {
            LOG_MSG_BLOCK( BlockMsg );
        } else {
            Success = GetExitCodeThread( Handle, &ExitCode );

            if ( ARGUMENT_PRESENT(tpm) ) {
                LOG_PASS_FAIL( Success && tpm->ExitCode == ExitCode );
            } else {
                LOG_PASS_FAIL( InvalidCase ? !Success : Success );
            }
        }
    }
    END_VARIATION();

    if ( CleanupHandle && Handle && Handle != INVALID_HANDLE_VALUE ) {
        CloseHandle( Handle );
    }
}

VOID
ExitThreadTest(
    HANDLE LogHandle
    )
{
    HANDLE Handle;
    THREAD_PARAMETERS tpm;

    xSetFunctionName( LogHandle, "ExitThread" );

    ExitThreadVariation(
        LogHandle,
        (THREADPROC)ExitThreadTestThreadProc1,
        "exit code from ExitThread"
        );

    ExitThreadVariation(
        LogHandle,
        ExitThreadTestThreadProc2,
        "exit code from return value"
        );

    xSetFunctionName( LogHandle, "GetExitCodeThread" );

    GetExitCodeThreadVariation(
        LogHandle,
        "exit code from ExitThread",
        PrepareThread( (THREADPROC)ExitThreadTestThreadProc1, &tpm, 0 ),
        &tpm,
        "CreateThread failed",
        FALSE,
        TRUE
        );

    GetExitCodeThreadVariation(
        LogHandle,
        "exit code from return value",
        PrepareThread( ExitThreadTestThreadProc2, &tpm, 0 ),
        &tpm,
        "CreateThread failed",
        FALSE,
        TRUE
        );

    tpm.ExitCode = STILL_ACTIVE;
    GetExitCodeThreadVariation(
        LogHandle,
        "exit code from current thread",
        GetCurrentThread(),
        &tpm,
        "GetCurrentThread failed",
        FALSE,
        FALSE
        );

    GetExitCodeThreadVariation(
        LogHandle,
        "exit code from suspended thread",
        Handle = PrepareThread( (THREADPROC)ExitThreadTestThreadProc1, &tpm, CREATE_SUSPENDED, FALSE ),
        &tpm,
        "CreateThread failed",
        FALSE,
        FALSE
        );
    ResumeThread( Handle );
    CloseHandle( Handle );

    //
    // Invalid cases: calling GetExitCode thread by passing
    // various kinds of handle, event handle for example
    //
    GetExitCodeThreadVariation(
        LogHandle,
        "handle=0xdeadbeef",
        (HANDLE)0xdeadbeef,
        0,
        0,
        TRUE,
        FALSE
        );

    GetExitCodeThreadVariation(
        LogHandle,
        "handle=NULL",
        NULL,
        0,
        0,
        TRUE,
        FALSE
        );

    GetExitCodeThreadVariation(
        LogHandle,
        "handle=INVALID_HANDLE_VALUE",
        INVALID_HANDLE_VALUE,
        0,
        0,
        TRUE,
        FALSE
        );

    GetExitCodeThreadVariation(
        LogHandle,
        "handle=event handle",
        CreateEvent(0, 0, 0, 0),
        0,
        "CreateEvent failed",
        TRUE,
        TRUE
        );

    GetExitCodeThreadVariation(
        LogHandle,
        "handle=semaphore handle",
        CreateSemaphore(0, 0, 1, 0),
        0,
        "CreateSemaphore failed",
        TRUE,
        TRUE
        );

    GetExitCodeThreadVariation(
        LogHandle,
        "handle=mutex handle",
        CreateMutex(0, 0, 0),
        0,
        "CreateMutex failed",
        TRUE,
        TRUE
        );

    GetExitCodeThreadVariation(
        LogHandle,
        "handle=waitable timer handle",
        CreateWaitableTimer(0, 0, 0),
        0,
        "CreateWaitableTimer failed",
        TRUE,
        TRUE
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\main.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    main.cpp

Abstract:

    This program contains routines to stress and test threads
    and threading related APIs

--*/

#include "threading.h"

VOID
WINAPI
ThreadingStartTest(
    HANDLE LogHandle
    )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/
{
    xSetComponent( LogHandle, "Kernel", "Ps" );
    CreateThreadTest( LogHandle );
    ExitThreadTest( LogHandle );
    ThreadIDTest( LogHandle );
    ThreadPriorityTest( LogHandle );
    SuspendResumeTest( LogHandle );
    ThreadNotificationTest( LogHandle );
    ThreadLocalStorageTest( LogHandle );
    FiberTest( LogHandle );
}

VOID
WINAPI
ThreadingEndTest(
    VOID
    )
/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( threading )
#pragma data_seg()

BEGIN_EXPORT_TABLE( threading )
    EXPORT_TABLE_ENTRY( "StartTest", ThreadingStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", ThreadingEndTest )
END_EXPORT_TABLE( threading )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\threadid.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    threadid.cpp

Abstract:

    This program contains routines to stress and test threads
    and threading related APIs

Author:

    Sakphong Chanbai (schanbai) 10-May-2000

Environment:

    Xbox

Revision History:

--*/


#include "threading.h"


DWORD
WINAPI
ThreadIDTestThreadProc(
    PTHREAD_PARAMETERS tpm
    )
{
    tpm->ExpectedThreadID = GetCurrentThreadId();
    return 0;
}


VOID
ThreadIDVariation(
    HANDLE LogHandle,
    LPSTR  Variation
    )
{
    HANDLE ThreadHandle;
    THREAD_PARAMETERS tpm;

    BEGIN_VARIATION( Variation )
    {
        ThreadHandle = CreateThread(
                            0,
                            0,
                            (LPTHREAD_START_ROUTINE)ThreadIDTestThreadProc,
                            (LPVOID)&tpm,
                            0,
                            &tpm.ThreadID
                            );

        if ( !ThreadHandle ) {
            LOG_MSG_BLOCK( "CreateThread failed" );
        } else {
            WaitForSingleObject( ThreadHandle, INFINITE );

            if ( tpm.ExpectedThreadID == tpm.ThreadID ) {
                LOG_PASS();
            } else {
                LOG_MSG_FAIL( "mismatch thread id" );
            }

            CloseHandle( ThreadHandle );
        }
    }
    END_VARIATION();
}


VOID
ThreadIDTest(
    HANDLE LogHandle
    )
{
    xSetFunctionName( LogHandle, "GetCurrenThreadId" );
    ThreadIDVariation( LogHandle, "GetCurrentThreadId" );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\suspend.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    suspend.cpp

Abstract:

    This program contains routines to stress and test threads
    and threading related APIs

--*/

#include "threading.h"

VOID
SuspendResumeThreadVariation(
    HANDLE LogHandle,
    LPSTR  Variation,
    HANDLE ThreadHandle,
    LPSTR  BlockMsg,
    BOOL   InvalidCase,
    BOOL   CleanupHandle
    )
{
    DWORD Success;

    BEGIN_VARIATION( Variation )
    {
        if ( CleanupHandle && !ThreadHandle ) {
            LOG_MSG_BLOCK( BlockMsg );
        } else {
            Success = SuspendThread( ThreadHandle );

            if ( InvalidCase ) {
                LOG_PASS_FAIL( Success == ~0UL );
            } else {
                if ( Success == ~0UL ) {
                    LOG_MSG_FAIL( "SuspendThread failed" );
                } else {
                    Success = ResumeThread( ThreadHandle );
                    if ( Success == 0UL ) {
                        LOG_MSG_FAIL( "ResumeThread failed" );
                    } else {
                        LOG_PASS();
                    }
                }
            }
        }
    }
    END_VARIATION();

    if ( CleanupHandle && ThreadHandle && ThreadHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( ThreadHandle );
    }
}

VOID
SuspendResumeTest(
    HANDLE LogHandle
    )
{
    xSetFunctionName( LogHandle, "SuspendThread/ResumeThread" );

    SuspendResumeThreadVariation(
        LogHandle,
        "handle=0xdeadbeef",
        (HANDLE)0xdeadbeef,
        0,
        TRUE,
        FALSE
        );

    SuspendResumeThreadVariation(
        LogHandle,
        "handle=NULL",
        NULL,
        0,
        TRUE,
        FALSE
        );

    SuspendResumeThreadVariation(
        LogHandle,
        "handle=INVALID_HANDLE_VALUE",
        INVALID_HANDLE_VALUE,
        0,
        TRUE,
        FALSE
        );

    SuspendResumeThreadVariation(
        LogHandle,
        "handle=event handle",
        CreateEvent(0, 0, 0, 0),
        "CreateEvent failed",
        TRUE,
        TRUE
        );

    SuspendResumeThreadVariation(
        LogHandle,
        "handle=semaphore handle",
        CreateSemaphore(0, 0, 1, 0),
        "CreateSemaphore failed",
        TRUE,
        TRUE
        );

    SuspendResumeThreadVariation(
        LogHandle,
        "handle=mutex handle",
        CreateMutex(0, 0, 0),
        "CreateMutex failed",
        TRUE,
        TRUE
        );

    SuspendResumeThreadVariation(
        LogHandle,
        "handle=waitable timer handle",
        CreateWaitableTimer(0, 0, 0),
        "CreateWaitableTimer failed",
        TRUE,
        TRUE
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\threading.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    precomp.h

Abstract:

    This program contains routines to stress and test threads
    and threading related APIs

--*/

#include <ntos.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <windows.h>
#include <testutil.h>
#include <xlog.h>
#include <xtestlib.h>

typedef struct _THREAD_PARAMETERS {

    DWORD ExceptionCode;
    DWORD ExitCode;
    DWORD StackSize;
    DWORD ThreadID;
    DWORD ExpectedThreadID;
    HANDLE LogHandle;

} THREAD_PARAMETERS, *PTHREAD_PARAMETERS;

typedef DWORD (WINAPI *THREADPROC)(PTHREAD_PARAMETERS);

typedef struct _FIBER_PARAMETERS {

    PVOID MainFiber;
    LONG  Counter;
    ULONG ExpectedCounter;
    HANDLE LogHandle;

} FIBER_PARAMETERS, *PFIBER_PARAMETERS;

typedef VOID (WINAPI *FIBERPROC)(PFIBER_PARAMETERS);

VOID
CreateThreadTest(
    HANDLE LogHandle
    );

VOID
ExitThreadTest(
    HANDLE LogHandle
    );

VOID
ThreadIDTest(
    HANDLE LogHandle
    );

VOID
ThreadLocalStorageTest(
    HANDLE LogHandle
    );

VOID
ThreadPriorityTest(
    HANDLE LogHandle
    );

VOID
SuspendResumeTest(
    HANDLE LogHandle
    );

VOID
ThreadNotificationTest(
    HANDLE LogHandle
    );

VOID
FiberTest(
    HANDLE LogHandle
    );

__inline
HANDLE
PrepareThread(
    THREADPROC ThreadProc,
    PTHREAD_PARAMETERS tpm,
    DWORD CreationFlags,
    BOOL WaitUntilTerminate = TRUE
    )
{
    HANDLE Handle;
    ULONG Seed = GetTickCount();

    if ( tpm ) {
        tpm->ExitCode = CreationFlags == CREATE_SUSPENDED ? STILL_ACTIVE : RtlRandom( &Seed );
    }

    Handle = CreateThread(
                0,
                0,
                (LPTHREAD_START_ROUTINE)ThreadProc,
                (LPVOID)tpm,
                CreationFlags,
                0
                );

    if ( Handle && WaitUntilTerminate && CreationFlags != CREATE_SUSPENDED ) {
        WaitForSingleObject( Handle, INFINITE );
    }

    return Handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\xeldr\xetest\xetestp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xetest.h

Abstract:

    This program contains routines to test XE loader

Environment:

    Xbox

Revision History:

--*/

#include <ntos.h>
#include <ximage.h>
#include <xapip.h>
#include <xtl.h>
#include "sections.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\xeldr\xetest\i386\sections.asm ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved
;
; Module Name:
;
;    sections.asm
;
; Abstract:
;
;    This module contains code in separate sections
;    DONOT edit this file, it's automatically generated
;
;--

.386p
        .xlist
include callconv.inc
        .list

;
;
;
SECTN000 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section000 ,0

        db 4096 dup( 90h )

stdENDP _Section000

SECTN000 ends

;
;
;
SECTN001 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section001 ,0

        db 4096 dup( 90h )

stdENDP _Section001

SECTN001 ends

;
;
;
SECTN002 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section002 ,0

        db 4096 dup( 90h )

stdENDP _Section002

SECTN002 ends

;
;
;
SECTN003 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section003 ,0

        db 4096 dup( 90h )

stdENDP _Section003

SECTN003 ends

;
;
;
SECTN004 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section004 ,0

        db 4096 dup( 90h )

stdENDP _Section004

SECTN004 ends

;
;
;
SECTN005 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section005 ,0

        db 4096 dup( 90h )

stdENDP _Section005

SECTN005 ends

;
;
;
SECTN006 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section006 ,0

        db 4096 dup( 90h )

stdENDP _Section006

SECTN006 ends

;
;
;
SECTN007 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section007 ,0

        db 4096 dup( 90h )

stdENDP _Section007

SECTN007 ends

;
;
;
SECTN008 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section008 ,0

        db 4096 dup( 90h )

stdENDP _Section008

SECTN008 ends

;
;
;
SECTN009 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section009 ,0

        db 4096 dup( 90h )

stdENDP _Section009

SECTN009 ends

;
;
;
SECTN010 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section010 ,0

        db 4096 dup( 90h )

stdENDP _Section010

SECTN010 ends

;
;
;
SECTN011 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section011 ,0

        db 4096 dup( 90h )

stdENDP _Section011

SECTN011 ends

;
;
;
SECTN012 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section012 ,0

        db 4096 dup( 90h )

stdENDP _Section012

SECTN012 ends

;
;
;
SECTN013 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section013 ,0

        db 4096 dup( 90h )

stdENDP _Section013

SECTN013 ends

;
;
;
SECTN014 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section014 ,0

        db 4096 dup( 90h )

stdENDP _Section014

SECTN014 ends

;
;
;
SECTN015 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section015 ,0

        db 4096 dup( 90h )

stdENDP _Section015

SECTN015 ends

;
;
;
SECTN016 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section016 ,0

        db 4096 dup( 90h )

stdENDP _Section016

SECTN016 ends

;
;
;
SECTN017 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section017 ,0

        db 4096 dup( 90h )

stdENDP _Section017

SECTN017 ends

;
;
;
SECTN018 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section018 ,0

        db 4096 dup( 90h )

stdENDP _Section018

SECTN018 ends

;
;
;
SECTN019 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section019 ,0

        db 4096 dup( 90h )

stdENDP _Section019

SECTN019 ends

;
;
;
SECTN020 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section020 ,0

        db 4096 dup( 90h )

stdENDP _Section020

SECTN020 ends

;
;
;
SECTN021 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section021 ,0

        db 4096 dup( 90h )

stdENDP _Section021

SECTN021 ends

;
;
;
SECTN022 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section022 ,0

        db 4096 dup( 90h )

stdENDP _Section022

SECTN022 ends

;
;
;
SECTN023 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section023 ,0

        db 4096 dup( 90h )

stdENDP _Section023

SECTN023 ends

;
;
;
SECTN024 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section024 ,0

        db 4096 dup( 90h )

stdENDP _Section024

SECTN024 ends

;
;
;
SECTN025 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section025 ,0

        db 4096 dup( 90h )

stdENDP _Section025

SECTN025 ends

;
;
;
SECTN026 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section026 ,0

        db 4096 dup( 90h )

stdENDP _Section026

SECTN026 ends

;
;
;
SECTN027 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section027 ,0

        db 4096 dup( 90h )

stdENDP _Section027

SECTN027 ends

;
;
;
SECTN028 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section028 ,0

        db 4096 dup( 90h )

stdENDP _Section028

SECTN028 ends

;
;
;
SECTN029 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section029 ,0

        db 4096 dup( 90h )

stdENDP _Section029

SECTN029 ends

;
;
;
SECTN030 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section030 ,0

        db 4096 dup( 90h )

stdENDP _Section030

SECTN030 ends

;
;
;
SECTN031 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section031 ,0

        db 4096 dup( 90h )

stdENDP _Section031

SECTN031 ends

;
;
;
SECTN032 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section032 ,0

        db 4096 dup( 90h )

stdENDP _Section032

SECTN032 ends

;
;
;
SECTN033 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section033 ,0

        db 4096 dup( 90h )

stdENDP _Section033

SECTN033 ends

;
;
;
SECTN034 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section034 ,0

        db 4096 dup( 90h )

stdENDP _Section034

SECTN034 ends

;
;
;
SECTN035 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section035 ,0

        db 4096 dup( 90h )

stdENDP _Section035

SECTN035 ends

;
;
;
SECTN036 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section036 ,0

        db 4096 dup( 90h )

stdENDP _Section036

SECTN036 ends

;
;
;
SECTN037 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section037 ,0

        db 4096 dup( 90h )

stdENDP _Section037

SECTN037 ends

;
;
;
SECTN038 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section038 ,0

        db 4096 dup( 90h )

stdENDP _Section038

SECTN038 ends

;
;
;
SECTN039 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section039 ,0

        db 4096 dup( 90h )

stdENDP _Section039

SECTN039 ends

;
;
;
SECTN040 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section040 ,0

        db 4096 dup( 90h )

stdENDP _Section040

SECTN040 ends

;
;
;
SECTN041 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section041 ,0

        db 4096 dup( 90h )

stdENDP _Section041

SECTN041 ends

;
;
;
SECTN042 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section042 ,0

        db 4096 dup( 90h )

stdENDP _Section042

SECTN042 ends

;
;
;
SECTN043 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section043 ,0

        db 4096 dup( 90h )

stdENDP _Section043

SECTN043 ends

;
;
;
SECTN044 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section044 ,0

        db 4096 dup( 90h )

stdENDP _Section044

SECTN044 ends

;
;
;
SECTN045 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section045 ,0

        db 4096 dup( 90h )

stdENDP _Section045

SECTN045 ends

;
;
;
SECTN046 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section046 ,0

        db 4096 dup( 90h )

stdENDP _Section046

SECTN046 ends

;
;
;
SECTN047 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section047 ,0

        db 4096 dup( 90h )

stdENDP _Section047

SECTN047 ends

;
;
;
SECTN048 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section048 ,0

        db 4096 dup( 90h )

stdENDP _Section048

SECTN048 ends

;
;
;
SECTN049 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section049 ,0

        db 4096 dup( 90h )

stdENDP _Section049

SECTN049 ends

;
;
;
SECTN050 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section050 ,0

        db 4096 dup( 90h )

stdENDP _Section050

SECTN050 ends

;
;
;
SECTN051 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section051 ,0

        db 4096 dup( 90h )

stdENDP _Section051

SECTN051 ends

;
;
;
SECTN052 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section052 ,0

        db 4096 dup( 90h )

stdENDP _Section052

SECTN052 ends

;
;
;
SECTN053 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section053 ,0

        db 4096 dup( 90h )

stdENDP _Section053

SECTN053 ends

;
;
;
SECTN054 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section054 ,0

        db 4096 dup( 90h )

stdENDP _Section054

SECTN054 ends

;
;
;
SECTN055 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section055 ,0

        db 4096 dup( 90h )

stdENDP _Section055

SECTN055 ends

;
;
;
SECTN056 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section056 ,0

        db 4096 dup( 90h )

stdENDP _Section056

SECTN056 ends

;
;
;
SECTN057 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section057 ,0

        db 4096 dup( 90h )

stdENDP _Section057

SECTN057 ends

;
;
;
SECTN058 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section058 ,0

        db 4096 dup( 90h )

stdENDP _Section058

SECTN058 ends

;
;
;
SECTN059 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section059 ,0

        db 4096 dup( 90h )

stdENDP _Section059

SECTN059 ends

;
;
;
SECTN060 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section060 ,0

        db 4096 dup( 90h )

stdENDP _Section060

SECTN060 ends

;
;
;
SECTN061 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section061 ,0

        db 4096 dup( 90h )

stdENDP _Section061

SECTN061 ends

;
;
;
SECTN062 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section062 ,0

        db 4096 dup( 90h )

stdENDP _Section062

SECTN062 ends

;
;
;
SECTN063 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section063 ,0

        db 4096 dup( 90h )

stdENDP _Section063

SECTN063 ends

;
;
;
SECTN064 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section064 ,0

        db 4096 dup( 90h )

stdENDP _Section064

SECTN064 ends

;
;
;
SECTN065 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section065 ,0

        db 4096 dup( 90h )

stdENDP _Section065

SECTN065 ends

;
;
;
SECTN066 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section066 ,0

        db 4096 dup( 90h )

stdENDP _Section066

SECTN066 ends

;
;
;
SECTN067 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section067 ,0

        db 4096 dup( 90h )

stdENDP _Section067

SECTN067 ends

;
;
;
SECTN068 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section068 ,0

        db 4096 dup( 90h )

stdENDP _Section068

SECTN068 ends

;
;
;
SECTN069 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section069 ,0

        db 4096 dup( 90h )

stdENDP _Section069

SECTN069 ends

;
;
;
SECTN070 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section070 ,0

        db 4096 dup( 90h )

stdENDP _Section070

SECTN070 ends

;
;
;
SECTN071 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section071 ,0

        db 4096 dup( 90h )

stdENDP _Section071

SECTN071 ends

;
;
;
SECTN072 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section072 ,0

        db 4096 dup( 90h )

stdENDP _Section072

SECTN072 ends

;
;
;
SECTN073 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section073 ,0

        db 4096 dup( 90h )

stdENDP _Section073

SECTN073 ends

;
;
;
SECTN074 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section074 ,0

        db 4096 dup( 90h )

stdENDP _Section074

SECTN074 ends

;
;
;
SECTN075 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section075 ,0

        db 4096 dup( 90h )

stdENDP _Section075

SECTN075 ends

;
;
;
SECTN076 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section076 ,0

        db 4096 dup( 90h )

stdENDP _Section076

SECTN076 ends

;
;
;
SECTN077 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section077 ,0

        db 4096 dup( 90h )

stdENDP _Section077

SECTN077 ends

;
;
;
SECTN078 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section078 ,0

        db 4096 dup( 90h )

stdENDP _Section078

SECTN078 ends

;
;
;
SECTN079 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section079 ,0

        db 4096 dup( 90h )

stdENDP _Section079

SECTN079 ends

;
;
;
SECTN080 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section080 ,0

        db 4096 dup( 90h )

stdENDP _Section080

SECTN080 ends

;
;
;
SECTN081 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section081 ,0

        db 4096 dup( 90h )

stdENDP _Section081

SECTN081 ends

;
;
;
SECTN082 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section082 ,0

        db 4096 dup( 90h )

stdENDP _Section082

SECTN082 ends

;
;
;
SECTN083 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section083 ,0

        db 4096 dup( 90h )

stdENDP _Section083

SECTN083 ends

;
;
;
SECTN084 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section084 ,0

        db 4096 dup( 90h )

stdENDP _Section084

SECTN084 ends

;
;
;
SECTN085 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section085 ,0

        db 4096 dup( 90h )

stdENDP _Section085

SECTN085 ends

;
;
;
SECTN086 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section086 ,0

        db 4096 dup( 90h )

stdENDP _Section086

SECTN086 ends

;
;
;
SECTN087 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section087 ,0

        db 4096 dup( 90h )

stdENDP _Section087

SECTN087 ends

;
;
;
SECTN088 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section088 ,0

        db 4096 dup( 90h )

stdENDP _Section088

SECTN088 ends

;
;
;
SECTN089 SEGMENT PARA PUBLIC 'CODE'

cPublicProc _Section089 ,0

        db 4096 dup( 90h )

stdENDP _Section089

SECTN089 ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\xeldr\xetest\xetest.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xetest.cpp

Abstract:

    This program contains routines to test XE loader. Security test variations
    are available only under devkit as the image file needs to be modified
    during run-time.

--*/

#include "xetestp.h"

//
//
//
#define XIMG_LDR_IMAGE          (XapiGetCurrentProcess()->XeLdrImage)
#define XIMG_HEADER             (XapiGetCurrentProcess()->XeLdrImage->ImageHeader)
#define XIMG_VARHEADER          (XapiGetCurrentProcess()->XeLdrImage->VarImageHeader)
#define XIMG_NUM_SECTIONS       (XapiGetCurrentProcess()->XeLdrImage->ImageHeader-> \
                                    OptionalHeader.NumberOfSections)
#define XIMG_FIRST_SECTION      (XapiGetCurrentProcess()->XeLdrImage-> \
                                    FirstSectionHeader)

#define SECTION_ID_TO_NAME(id)  XeTestSectionName[id]
#define SECTION_ID_TO_INDEX(id) ((id) + XeTestSectionIdToSectionIndexBias)

CHAR XeTestSectionName[MAX_SECTIONS][9];
ULONG XeTestSectionIdToSectionIndexBias;

#pragma code_seg( "xetest1" )

PVOID
XeTestAllocateAllMemory(
    VOID
    )
/*++

Routine Description:

    Utility routine used to allocate all available memory returned by
    GlobalMemoryStatus. It puts system under low memory situation.

Arguments:

    None

Return Value:

    Pointer to allocated memory

--*/
{
    MEMORYSTATUS ms;
    PVOID BigChunk = NULL;
    LONG MemSize;

    GlobalMemoryStatus( &ms );
    MemSize = ms.dwAvailPhys;

    do {
        MemSize -= PAGE_SIZE;
        BigChunk = VirtualAlloc( 0, MemSize, MEM_COMMIT, PAGE_READWRITE );
    } while ( BigChunk == NULL && MemSize > 0 );

    ASSERT( BigChunk );

    return BigChunk;
}

#pragma code_seg( "xetest2" )

VOID
XeTestFreeAllMemory(
    IN PVOID P
    )
/*++

Routine Description:

    This routine free memory allocated by XeTestAllocateAllMemory

Arguments:

    P - Pointer returned from XeTestAllocateAllMemory

Return Value:

    None

--*/
{
    ASSERT( P );

    if ( P ) {
        VirtualFree( P, 0, MEM_RELEASE );
    }
}

#pragma code_seg( "xetest3" )

PXIMAGE_SECTION_HEADER
XeTestGetSectionHeader(
    ULONG SectionID
    )
/*++

Routine Description:

    This routine returns section header of ID specified by SectionID.

Arguments:

    SectionID - Zero-based section ID

Return Value:

    Pointer to section header

--*/
{
    ULONG SectionIndex = SECTION_ID_TO_INDEX(SectionID);

    ASSERT( SectionID < MAX_SECTIONS );
    ASSERT( SectionIndex < XIMG_NUM_SECTIONS );

    return XIMG_FIRST_SECTION + SectionIndex;
}

#pragma code_seg( "xetest4" )

BOOL
XeTestInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize section name cache (XeTestectionName) and section header cache
    (XeTestSectionHeader) for faster access

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    SIZE_T Section, SectionID;
    PXIMAGE_SECTION_HEADER SectionHeader;

    //
    // Look for index of section ID=0 (SECTN000)
    //

    SectionHeader = XIMG_FIRST_SECTION;
    for ( Section=0; Section<XIMG_NUM_SECTIONS; Section++ ) {
        if ( !strncmp(SECTION_NAME_PREFIX "000", (char*)SectionHeader->Name, \
                      XIMAGE_SECTION_NAME_MAXLEN) ) {
            XeTestSectionIdToSectionIndexBias = Section;
            break;
        }
        SectionHeader++;
    }

    if ( XeTestSectionIdToSectionIndexBias >= XIMG_NUM_SECTIONS ) {
        return FALSE;
    }

    for ( SectionID=0; SectionID<MAX_SECTIONS; SectionID++ ) {
        wsprintfA( XeTestSectionName[SectionID], "%s%03lu",
                   SECTION_NAME_PREFIX, SectionID );

        if ( (XeTestGetSectionHeader(SectionID)->SectionFlags & \
              XIMAGE_SECFLAG_IMPLICIT) != 0) {

            //
            // Verify that we have all required sections non-preloaded
            //

            DbgPrint( "XETEST: Section %.*s is not a non-preloaded\n",
                      XIMAGE_SECTION_NAME_MAXLEN,
                      XeTestSectionName[SectionID] );

            return FALSE;
        }
    }

    return TRUE;
}

#pragma code_seg( "xetest5" )

BOOL
VerifySectionRefCount(
    IN USHORT RefCountValue,
    IN ULONG SectionID
    )
/*++

Routine Description:

    This routine verifies referent count value of section specified by
    SectionID.

Arguments:

    RefCountValue - Value of referent cound to be verified

    SectionID - Zero-based section ID

Return Value:

    TRUE if referent count is correct, FALSE otherwise

--*/
{
    ULONG SectionIndex = SECTION_ID_TO_INDEX(SectionID);
    PUSHORT SectionRefCount;

    ASSERT( SectionID < MAX_SECTIONS );
    ASSERT( SectionIndex < XIMG_NUM_SECTIONS );

    SectionRefCount = (PUSHORT)(XapiGetCurrentProcess()-> \
                                XeLdrImage->LoadedSections + SectionIndex );

#if DBG
    if ( *SectionRefCount != RefCountValue ) {
        KdPrint(( "XETEST: %.*s%03u has refcount=%u, expected %u\n",
                  XIMAGE_SECTION_NAME_MAXLEN, *SectionRefCount,
                  RefCountValue ));
    }
#endif

    return *SectionRefCount == RefCountValue;
}

#pragma code_seg( "xetest6" )

BOOL
VerifyAllSectionsRefCount(
    IN USHORT RefCountValue
    )
/*++

Routine Description:

    This routine verifies referent count value of all section from ID=0 to
    ID=MAX_SECTIONS-1

Arguments:

    RefCountValue - Value of referent cound to be verified

Return Value:

    TRUE if all referent counts are correct, FALSE otherwise

--*/
{
    SIZE_T SectionID;

    for ( SectionID=0; SectionID<MAX_SECTIONS; SectionID++ ) {
        if ( !VerifySectionRefCount(RefCountValue, SectionID) ) {
            return FALSE;
        }
    }

    return TRUE;
}

#pragma code_seg( "xetest7" )

VOID
FileOffsetFromSectionID(
    IN  ULONG SectionID,
    OUT PULONG HeadFileOffset,
    OUT PULONG BodyFileOffset,
    OUT PULONG TailFileOffset
    )
/*++

Routine Description:

    This routine calculates file offset starting from beginning of the image
    file from SectionID.

Arguments:

    SectionID - Zero-based section ID

    HeadFileOffset - Output file offset of section head in image file

    BodyFileOffset - Output file offset of section body in image file

    TailFileOffset - Output file offset of section tail in image file

Return Value:

    None

--*/
{
    PXIMAGE_SECTION_HEADER SectionHeader;
    SIZE_T NumberOfBodyPages, HeadSize, PrevPageTailSize;

    SectionHeader = XeTestGetSectionHeader( SectionID );

    PrevPageTailSize = SectionHeader->VirtualAddress % LDR_PAGE_SIZE;

    //
    // Calculate offset in file for head page
    //

    *HeadFileOffset = (XIMG_HEADER->PagesInHeaders + SectionHeader->HeadPage) * \
        LDR_PAGE_SIZE + PrevPageTailSize;

    //
    // Calculate offset in file for body page if any
    //

    HeadSize = LDR_PAGE_SIZE - PrevPageTailSize;

    if ( SectionHeader->VirtualAddress <= HeadSize ) {
        NumberOfBodyPages = 0;
    } else {
        NumberOfBodyPages = (SectionHeader->VirtualSize - HeadSize) / LDR_PAGE_SIZE;
    }

    //
    // If there is no body page, offset of body page is offset of head page
    //

    if ( NumberOfBodyPages ) {
        *BodyFileOffset = (XIMG_HEADER->PagesInHeaders + SectionHeader->BodyPage) * \
            LDR_PAGE_SIZE + PrevPageTailSize;
    } else {
        *BodyFileOffset = *HeadFileOffset;
    }

    //
    // Calculate offset in file for tail page
    //

    if ( SectionHeader->TailPage != SectionHeader->HeadPage ) {
        *TailFileOffset = (XIMG_HEADER->PagesInHeaders + SectionHeader->TailPage) * \
            LDR_PAGE_SIZE + PrevPageTailSize;
    } else {
        *TailFileOffset = *BodyFileOffset;
    }
}

#pragma code_seg( "xetest8" )

NTSTATUS
XeTestReadImageFile(
    IN  SIZE_T FileOffset,
    OUT PVOID  Buffer,
    IN  SIZE_T BufferLength
    )
/*++

Routine Description:

    Utility routine to open image file and write data from specify Buffer to
    file starting from file offset specify in FileOffset

Arguments:

    FileOffset - Specify file offset to write from the begin of the file

    Buffer - Pointer to data buffer to write

    BufferLength - Number of bytes to write

Return Value:

    NT status code of the operation

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    LARGE_INTEGER ReadOffset;

    InitializeObjectAttributes( &ObjA, &XIMG_LDR_IMAGE->ImageFileName,
                                OBJ_CASE_INSENSITIVE, 0, 0 );

    Status = NtOpenFile( &FileHandle, FILE_GENERIC_READ, &ObjA, &IoStatusBlock,
                         FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT | \
                         FILE_RANDOM_ACCESS );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    ReadOffset.HighPart = 0;
    ReadOffset.LowPart = FileOffset;

    Status = NtReadFile( FileHandle, 0, 0, 0, &IoStatusBlock, Buffer,
                         BufferLength, &ReadOffset );

    NtClose( FileHandle );

    return Status;
}

#pragma code_seg( "xetest9" )

NTSTATUS
XeTestWriteImageFile(
    IN SIZE_T FileOffset,
    IN PVOID  Buffer,
    IN SIZE_T BufferLength
    )
/*++

Routine Description:

    Utility routine to open image file and write data from specify Buffer to
    file starting from file offset specify in FileOffset

Arguments:

    FileOffset - Specify file offset to write from the begin of the file

    Buffer - Pointer to data buffer to write

    BufferLength - Number of bytes to write

Return Value:

    NT status code of the operation

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    LARGE_INTEGER WriteOffset;

    InitializeObjectAttributes( &ObjA, &XIMG_LDR_IMAGE->ImageFileName,
                                OBJ_CASE_INSENSITIVE, 0, 0 );

    Status = NtOpenFile( &FileHandle, FILE_GENERIC_WRITE, &ObjA, &IoStatusBlock,
                         FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT | \
                         FILE_RANDOM_ACCESS );

    if ( !NT_SUCCESS(Status) ) {
        return Status;
    }

    WriteOffset.HighPart = 0;
    WriteOffset.LowPart = FileOffset;

    Status = NtWriteFile( FileHandle, 0, 0, 0, &IoStatusBlock, Buffer,
                          BufferLength, &WriteOffset );

    NtClose( FileHandle );

    return Status;
}

#pragma code_seg( "xetest10" )

BOOL
XeTestReadWriteSection(
    IN BOOL   ReadOperation,
    IN ULONG  SectionID,
    IN PVOID  Buffer,
    IN SIZE_T BufferLength
    )
/*++

Routine Description:

    Utility routine to read/write data to/from body page of section specified by
    SectionID

Arguments:

    ReadOperaion - Non-zero for read operation and vice versa

    SectionID - Id of the section

    Buffer - Pointer to data to write

    BufferLength - Size in bytes of the buffer

Return Value:

    TRUE if the operation success, otherwise FALSE

--*/
{
    NTSTATUS Status;
    ULONG HeadFileOffset, BodyFileOffset, TailFileOffset;

    FileOffsetFromSectionID( SectionID, &HeadFileOffset, &BodyFileOffset,
                             &TailFileOffset );

    if ( ReadOperation ) {
        Status = XeTestReadImageFile( BodyFileOffset, Buffer, BufferLength );
    } else {
        Status = XeTestWriteImageFile( BodyFileOffset, Buffer, BufferLength );
    }

    SetLastError( RtlNtStatusToDosError(Status) );

    return NT_SUCCESS( Status );
}

#pragma code_seg( "xetest11" )

VOID
BasicSectionLoadUnloadTest(
    VOID
    )
/*++

Routine Description:

    Test basic section loading/unloading under normal and low memory condition

Arguments:

    None

Return Value:

    None

--*/
{
    SIZE_T i;
    PVOID p;

    KdPrint(( "XETEST: basic load/unload under normal and low memory\n" ));

    //
    // All sections ref count should be zero
    //

    VerifyAllSectionsRefCount( 0 );

    //
    // Basic loading of non-preload section should work fine
    //

    for ( i=0; i<MAX_SECTIONS; i++ ) {
        if ( XLoadSection(SECTION_ID_TO_NAME(i)) == NULL ) {
            KdPrint(( "XETEST: XLoadSection[%lu] failed unexpectedly (0x%x)\n",
                      __LINE__, GetLastError() ));
        } else {
            XFreeSection( SECTION_ID_TO_NAME(i) );
        }
    }

    VerifyAllSectionsRefCount( 0 );

    //
    // Put the system into low memory situation and try to load sections
    //

    p = XeTestAllocateAllMemory();

    for ( i=0; i<MAX_SECTIONS; i++ ) {
        if ( XLoadSection(SECTION_ID_TO_NAME(i)) != NULL ) {
            KdPrint(( "XETEST: XLoadSection[%lu](%s) success unexpectly\n",
                      __LINE__, SECTION_ID_TO_NAME(i) ));
            XFreeSection( SECTION_ID_TO_NAME(i) );
        }
    }

    VerifyAllSectionsRefCount( 0 );

    //
    // Free back all the memory and try to load sections again
    //

    XeTestFreeAllMemory( p );

    for ( i=0; i<MAX_SECTIONS; i++ ) {
        if ( XLoadSection(SECTION_ID_TO_NAME(i)) == NULL ) {
            KdPrint(( "XETEST: XLoadSection[%lu] failed unexpectedly (0x%x)\n",
                      __LINE__, GetLastError() ));
        } else {
            XFreeSection( SECTION_ID_TO_NAME(i) );
        }
    }

    VerifyAllSectionsRefCount( 0 );
}

#pragma code_seg( "xetest12" )

VOID
TamperedSectionTest(
    VOID
    )
/*++

Routine Description

    This routine modifies image file on disk and tries to load/unload tampered
    section.

Arguments:

    None

Return Value:

    None

--*/
{
    PVOID SectionPtr;
    BYTE SaveByte;
    ULONG id;

    KdPrint(( "XETEST: tampered section loading\n" ));

    for ( id=0; id<MAX_SECTIONS; id++ ) {

        //
        // Verify reference count
        //

        VerifySectionRefCount( 0, id );

        //
        // Save the original content of the image
        //

        if ( !XeTestReadWriteSection(TRUE, id, &SaveByte, 1) ) {
            KdPrint(( "XETEST: unable to read section from file (0x%x)\n",
                      GetLastError() ));
            return;
        }

        //
        // Write new byte value to the body page
        //

        SaveByte = (BYTE)~SaveByte;

        if ( !XeTestReadWriteSection(FALSE, id, &SaveByte, 1) ) {
            KdPrint(( "XETEST: write image section failed (0x%x)\n", GetLastError() ));
            return;
        }

        //
        // Try to load the tampered section now
        //

        SectionPtr = XLoadSection( SECTION_ID_TO_NAME(id) );

        if ( SectionPtr ) {
            KdPrint(( "XETEST: tampered section was unexpectedly loaded!\n" ));
            XFreeSection( SECTION_ID_TO_NAME(id) );
        }

        //
        // Verify that there is no page actually loaded or allocated
        //

        if ( !IsBadCodePtr((PROC)SectionPtr) ) {
            KdPrint(( "XETEST: page unexpectedly allocated for tampered section" ));
        }

        //
        // Verify reference count of this section again
        //

        VerifySectionRefCount( 0, id );

        //
        // Restore original image content that we modified
        //

        SaveByte = (BYTE)~SaveByte;

        if ( !XeTestReadWriteSection(FALSE, id, &SaveByte, 1) ) {
            KdPrint(( "XETEST: restore image section failed (0x%x)\n", GetLastError() ));
        }
    }
}

#pragma code_seg( "xetest13" )

int __cdecl main( void )
{
    if ( !XeTestInitialize() ) {
        return FALSE;
    }

    BasicSectionLoadUnloadTest();
    TamperedSectionTest();

    KdPrint(( "XETEST: finish\n" ));
    Sleep( INFINITE );
    return TRUE;
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smc\smc.cpp ===
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>

extern "C"
    {
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

DWORD WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }

void DebugPrint(char* format, ...)
    {
    va_list args;
    va_start(args, format);

    char szBuffer[1024];

    vsprintf(szBuffer, format, args);
    OutputDebugStringA(szBuffer);

    va_end(args);
    }



void main(void)
    {
    DWORD dataType = 0xCCCCCCCC;
    LAUNCH_DATA launchInfo;

    memset(&launchInfo, 0xCC, sizeof(LAUNCH_DATA));
    XGetLaunchInfo(&dataType, &launchInfo);

    DWORD tValue = 0xCCCCCCCC;
    DWORD value;
    char ver[3];
    ver[0] = (char)ReadSMC(0x01);
    ver[1] = (char)ReadSMC(0x01);
    ver[2] = (char)ReadSMC(0x01);

    DebugPrint("SMC TEST APP.\n");
    //DebugPrint("    Launch Type: 0x%X\n", dataType);
    DebugPrint("    SMC Version: %c %c %c\n", ver[0], ver[1], ver[2]);

    WriteSMC(0x08, 0xF0); // set the led to red
    WriteSMC(0x07, 0x01); // set the led to red


    DebugPrint("Reading from SMC...\n");
    DebugPrint("  CPU Temp:  %d C\n", ReadSMC(0x09));
    DebugPrint("  Air Temp:  %d C\n", ReadSMC(0x0A));
    DebugPrint("  Fan Speed: %d\n",   ReadSMC(0x10));
    DebugPrint("  0xFF:      0x%X\n", ReadSMC(0xFF));
    DebugPrint("  0xFE:      0x%X\n", ReadSMC(0xFE));
    DebugPrint("  0x77:      0x%X\n", ReadSMC(0x77));
    DebugPrint("  0x21:      0x%X\n", ReadSMC(0x21));

    value = ReadSMC(0x03);
    DebugPrint("  DVD Tray:  %d %d %d\n", !!(value & 0x40), !!(value & 0x20), !!(value & 0x10));

    value = ReadSMC(0x04);
    DebugPrint("  AV Pack:   %d %d %d\n", !!(value & 0x04), !!(value & 0x02), !!(value & 0x01));

    //WriteSMC(0x02, 0x01); // reboot
    //WriteSMC(0x02, 0x80); // shutdown

    /*
    // Make sure Video mode is constant
    tValue = 0xCCCCCCCC;
    for(unsigned i=0; i<10000; i++)
        {
        value = ReadSMC(0x04);
        if(tValue != value)
            {
            DebugPrint("%d%d%d (0x%08X)\n", !!(value & 0x04), !!(value & 0x02), !!(value & 0x01), value);
            tValue = value;
            }
        Sleep(10); // without this we can starve out the SMC causing a shutdown ... :)
        }
        */
    

    /*
    // Read the DVD tray state
    DebugPrint("DVD Tray State:\n");
    tValue = 0xCCCCCCCC;
    while(1)
        {
        value = ReadSMC(0x03);
        if(tValue != value)
            {
            DebugPrint("%d%d%d %d (0x%08X)\n", !!(value & 0x40), !!(value & 0x20), !!(value & 0x10), value & 0x01, value);
            tValue = value;
            }
        Sleep(10); // without this we can starve out the SMC causing a shutdown ... :)
        }
    */

    DebugPrint("\nTest Done. Time to reboot\n");
    __asm int 3;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\commontest.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    commontest.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/


#include <xlog.h>
#include "utils.h"

#define CACHE_DRIVE         L"Z"
#define TITLE_DRIVE         L"T"
#define USER_DRIVE          L"U"
#define BASE_DRIVE          CACHE_DRIVE

static char* GetExceptionString(DWORD dwCode);
static void TESTPASS(HANDLE hLog, char *fmt, ...);
static void TESTFAIL(HANDLE hLog, char *fmt, ...);
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo);
static void StartTest(HANDLE hLog, WCHAR *variant);
static void StartTest(HANDLE hLog, char *variant);

#define TESTCASE(variant)   StartTest(hLog, variant); SetLastError(0); __try { do
#define ENDTESTCASE         while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } xEndVariation(hLog);
#define ENDTESTCASE_CLEAN(c)while(0); } __except(ExceptionHandler(hLog, GetExceptionInformation())) {  } c xEndVariation(hLog);
#define BLOCKED(bugid, msg) xLog(hLog, XLL_BLOCK, "BugID %d - %s", bugid, msg); break;
#define BUGGED(bugid, msg)  xLog(hLog, XLL_FAIL, "BugID %d - %s", bugid, msg); break;
#define BUGGEDPASS(bugid, msg)  xLog(hLog, XLL_PASS, "BugID %d - %s", bugid, msg); break;

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#define NEWSIZE(ptr)        ( ((unsigned int*)(ptr))[-4] )

static void TESTPASS(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_PASS, fmt, args);
    }
static void TESTFAIL(HANDLE hLog, char *fmt, ...)
    {
    va_list args;
    va_start(args, fmt);
    xLog_va(hLog, XLL_FAIL, fmt, args);
    }
static DWORD ExceptionHandler(HANDLE hLog, LPEXCEPTION_POINTERS exceptionInfo)
    {
    if(exceptionInfo->ExceptionRecord->ExceptionCode == 0xCAFEBEEF) return EXCEPTION_EXECUTE_HANDLER;

    xLog(hLog, XLL_EXCEPTION, "Code: 0x%08X %s (Exception Pointer: 0x%08X)", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    DebugPrint("  Exception Caught - Code: 0x%08X %s (Exception Pointer: 0x%08X)\n", exceptionInfo->ExceptionRecord->ExceptionCode, GetExceptionString(exceptionInfo->ExceptionRecord->ExceptionCode), exceptionInfo);
    return EXCEPTION_EXECUTE_HANDLER;
    }
static void StartTest(HANDLE hLog, char *variant)
    {
    xStartVariation(hLog, variant);
    }
static void StartTest(HANDLE hLog, WCHAR *variant)
    {
    // UNICODE to ANSI hack
    size_t len = wcslen(variant);
    char *aVar = new char[len+1];
    if(!aVar) return;
    for(size_t i=0; i<len+1; i++)
        {
        aVar[i] = (char)variant[i];
        }

    xStartVariation(hLog, aVar);

    delete[] aVar;
    }
static char* GetExceptionString(DWORD dwCode)
    {
    #define EXCEPTION( x ) case EXCEPTION_##x: return #x;

    static char szBuffer[512] = { 0 };

    switch(dwCode)
        {
        EXCEPTION( ACCESS_VIOLATION )
        EXCEPTION( DATATYPE_MISALIGNMENT )
        EXCEPTION( BREAKPOINT )
        EXCEPTION( SINGLE_STEP )
        EXCEPTION( ARRAY_BOUNDS_EXCEEDED )
        EXCEPTION( FLT_DENORMAL_OPERAND )
        EXCEPTION( FLT_DIVIDE_BY_ZERO )
        EXCEPTION( FLT_INEXACT_RESULT )
        EXCEPTION( FLT_INVALID_OPERATION )
        EXCEPTION( FLT_OVERFLOW )
        EXCEPTION( FLT_STACK_CHECK )
        EXCEPTION( FLT_UNDERFLOW )
        EXCEPTION( INT_DIVIDE_BY_ZERO )
        EXCEPTION( INT_OVERFLOW )
        EXCEPTION( PRIV_INSTRUCTION )
        EXCEPTION( IN_PAGE_ERROR )
        EXCEPTION( ILLEGAL_INSTRUCTION )
        EXCEPTION( NONCONTINUABLE_EXCEPTION )
        EXCEPTION( STACK_OVERFLOW )
        EXCEPTION( INVALID_DISPOSITION )
        EXCEPTION( GUARD_PAGE )
        EXCEPTION( INVALID_HANDLE )
        default:
            break;
        }

    sprintf(szBuffer, "Unknown Error");
    return szBuffer;
    }

#define ALLCHARS L"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f" \
    L"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff\x00"

// sizes
#define KILOBYTE 1024
#define MEGABYTE (KILOBYTE*KILOBYTE)
#define PAGESIZE (4*KILOBYTE)

// common numbers
static DWORD dwBogus = 0xF000BAAA;
static ULARGE_INTEGER ulBogus = { 0xF000BAAA, 0xF000BAAA };

// common HANDLE parameters
static HANDLE hNull = NULL;
static HANDLE hBogus = (void*)0xF000BAAA;

// common string parameters
static LPCTSTR lpNull = NULL;
static LPCTSTR lpEmpty = L"";
static LPCTSTR lpSpace = L" ";
static LPCTSTR lpBogus = (const unsigned short*)0xF000BAAA;


// different names
static WCHAR *crazyNames[] = {
    L")#+l+RI+Td<\x12>",
    L"~`!@#$%^&*)-=_+[{\\|';:\",./?>",
    L"*",
    L"?",
    L"abc?",
    L"abc>def",
    L"abc<def",
    L"abc|def",
    L"abc:def",
    L"abc\"def",
    L">",
    L"<",
    L":",
    L"|",
    L"\"",
    L"..\\abcdef",
    L".\\..\\abcdef",
    L"abc" BASE_DRIVE L":\\def",
    L"new\nline",
    L"newline\n",
    L"Carriage\rreturn",
    L"Carriagereturn\r",
    L"\ttab",
    L"tab\t",
    L"\abell",
    L"bell\a",
    L"::\\abc",
    L"abc",
    L".",
    L"..",
    };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	test.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\xeldr\gensrc\gensrc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    gensrc.c

Abstract:

    This program contains routines to generate include (.h) and
    assembly (.asm) file used by xetest

--*/

#include <stdio.h>
#include <stdlib.h>

char *h_header[] = {
    "/*++\n",
    "\n",
    "Copyright (c) Microsoft Corporation. All rights reserved.\n",
    "\n",
    "Module Name:\n",
    "\n",
    "    sections.h\n",
    "\n",
    "Abstract:\n",
    "\n",
    "    This program contains routines to test XE loader\n",
    "    DONOT edit this file, it's automatically generated\n",
    "\n",
    "--*/\n",
    "\n",
    "#ifndef _SECTIONS_INCLUDED\n",
    "#define _SECTIONS_INCLUDED\n",
    "\n",
    "#ifdef __cplusplus\n",
    "extern \"C\" {\n",
    "#endif\n",
    NULL
};

char *h_footer[] = {
    "\n",
    "#ifdef __cplusplus\n",
    "}\n",
    "#endif\n",
    "\n",
    "#endif // _SECTIONS_INCLUDED\n",
    NULL
};

char *asm_header[] = {
    ";++\n",
    ";\n",
    "; Copyright (c) Microsoft Corporation. All rights reserved\n",
    ";\n",
    "; Module Name:\n",
    ";\n",
    ";    sections.asm\n",
    ";\n",
    "; Abstract:\n",
    ";\n",
    ";    This module contains code in separate sections\n",
    ";    DONOT edit this file, it's automatically generated\n",
    ";\n",
    ";--\n",
    "\n",
    ".386p\n",
    "        .xlist\n",
    "include callconv.inc\n",
    "        .list\n",
    NULL
};

char *asm_footer[] = {
    "\n",
    "        end\n",
    NULL
};

void __cdecl main( int argc, char* argv[] )
{
    register i;
    FILE *h_fp, *asm_fp;
    unsigned short max_sections;

    if ( argc != 2 ) {
        printf( "Usage: gensrc <number of sections>\n" );
        return;
    }

    max_sections = (unsigned short)atoi( argv[1] );
    if ( !max_sections ) {
        printf( "Invalid parameter (number of section can't be zero)\n" );
        return;
    }

    h_fp = fopen( "sections.h", "wt" );
    if ( !h_fp ) {
        printf( "Unable to create sections.h\n" );
        return;
    }

    asm_fp = fopen( "i386\\sections.asm", "wt" );
    if ( !asm_fp ) {
        printf( "Unable to create i386\\sections.asm\n" );
        fclose( h_fp );
        return;
    }

    for ( i=0; h_header[i]; i++ ) {
        fputs( h_header[i], h_fp );
    }

    fprintf( h_fp, "\n#define MAX_SECTIONS %u\n", max_sections );
    fputs( "#define SECTION_NAME_PREFIX \"SECTN\"\n", h_fp );

    // Generate body
    for ( i=0; i<max_sections; i++ ) {
        fprintf( h_fp, "\nint\nWINAPI\nSection%03u(\n    VOID\n    );\n", i );
    }

    fputs( "\nCONST PROC Proc[] = {", h_fp );

    for ( i=0; i<max_sections; i++ ) {
        if ( (i%5) == 0 ) {
            fprintf( h_fp, "\n    " );
        }
        fprintf( h_fp, "Section%03u, ", i );
    }

    fputs( "\n};\n", h_fp );

    for ( i=0; h_footer[i]; i++ ) {
        fputs( h_footer[i], h_fp );
    }

    for ( i=0; asm_header[i]; i++ ) {
        fputs( asm_header[i], asm_fp );
    }

    // Generate body
    for ( i=0; i<max_sections; i++ ) {
        fprintf( asm_fp,
                 "\n;\n;\n;\nSECTN%03u SEGMENT PARA PUBLIC 'CODE'\n\n"
                 "cPublicProc _Section%03u ,0\n\n        db 4096 dup( 90h )\n\n"
                 "stdENDP _Section%03u\n\nSECTN%03u ends\n", i, i, i, i
               );
    }

    for ( i=0; asm_footer[i]; i++ ) {
        fputs( asm_footer[i], asm_fp );
    }

    fclose( h_fp );
    fclose( asm_fp );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\xeldr\xetest\sections.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sections.h

Abstract:

    This program contains routines to test XE loader
    DONOT edit this file, it's automatically generated

--*/

#ifndef _SECTIONS_INCLUDED
#define _SECTIONS_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_SECTIONS 90
#define SECTION_NAME_PREFIX "SECTN"

int
WINAPI
Section000(
    VOID
    );

int
WINAPI
Section001(
    VOID
    );

int
WINAPI
Section002(
    VOID
    );

int
WINAPI
Section003(
    VOID
    );

int
WINAPI
Section004(
    VOID
    );

int
WINAPI
Section005(
    VOID
    );

int
WINAPI
Section006(
    VOID
    );

int
WINAPI
Section007(
    VOID
    );

int
WINAPI
Section008(
    VOID
    );

int
WINAPI
Section009(
    VOID
    );

int
WINAPI
Section010(
    VOID
    );

int
WINAPI
Section011(
    VOID
    );

int
WINAPI
Section012(
    VOID
    );

int
WINAPI
Section013(
    VOID
    );

int
WINAPI
Section014(
    VOID
    );

int
WINAPI
Section015(
    VOID
    );

int
WINAPI
Section016(
    VOID
    );

int
WINAPI
Section017(
    VOID
    );

int
WINAPI
Section018(
    VOID
    );

int
WINAPI
Section019(
    VOID
    );

int
WINAPI
Section020(
    VOID
    );

int
WINAPI
Section021(
    VOID
    );

int
WINAPI
Section022(
    VOID
    );

int
WINAPI
Section023(
    VOID
    );

int
WINAPI
Section024(
    VOID
    );

int
WINAPI
Section025(
    VOID
    );

int
WINAPI
Section026(
    VOID
    );

int
WINAPI
Section027(
    VOID
    );

int
WINAPI
Section028(
    VOID
    );

int
WINAPI
Section029(
    VOID
    );

int
WINAPI
Section030(
    VOID
    );

int
WINAPI
Section031(
    VOID
    );

int
WINAPI
Section032(
    VOID
    );

int
WINAPI
Section033(
    VOID
    );

int
WINAPI
Section034(
    VOID
    );

int
WINAPI
Section035(
    VOID
    );

int
WINAPI
Section036(
    VOID
    );

int
WINAPI
Section037(
    VOID
    );

int
WINAPI
Section038(
    VOID
    );

int
WINAPI
Section039(
    VOID
    );

int
WINAPI
Section040(
    VOID
    );

int
WINAPI
Section041(
    VOID
    );

int
WINAPI
Section042(
    VOID
    );

int
WINAPI
Section043(
    VOID
    );

int
WINAPI
Section044(
    VOID
    );

int
WINAPI
Section045(
    VOID
    );

int
WINAPI
Section046(
    VOID
    );

int
WINAPI
Section047(
    VOID
    );

int
WINAPI
Section048(
    VOID
    );

int
WINAPI
Section049(
    VOID
    );

int
WINAPI
Section050(
    VOID
    );

int
WINAPI
Section051(
    VOID
    );

int
WINAPI
Section052(
    VOID
    );

int
WINAPI
Section053(
    VOID
    );

int
WINAPI
Section054(
    VOID
    );

int
WINAPI
Section055(
    VOID
    );

int
WINAPI
Section056(
    VOID
    );

int
WINAPI
Section057(
    VOID
    );

int
WINAPI
Section058(
    VOID
    );

int
WINAPI
Section059(
    VOID
    );

int
WINAPI
Section060(
    VOID
    );

int
WINAPI
Section061(
    VOID
    );

int
WINAPI
Section062(
    VOID
    );

int
WINAPI
Section063(
    VOID
    );

int
WINAPI
Section064(
    VOID
    );

int
WINAPI
Section065(
    VOID
    );

int
WINAPI
Section066(
    VOID
    );

int
WINAPI
Section067(
    VOID
    );

int
WINAPI
Section068(
    VOID
    );

int
WINAPI
Section069(
    VOID
    );

int
WINAPI
Section070(
    VOID
    );

int
WINAPI
Section071(
    VOID
    );

int
WINAPI
Section072(
    VOID
    );

int
WINAPI
Section073(
    VOID
    );

int
WINAPI
Section074(
    VOID
    );

int
WINAPI
Section075(
    VOID
    );

int
WINAPI
Section076(
    VOID
    );

int
WINAPI
Section077(
    VOID
    );

int
WINAPI
Section078(
    VOID
    );

int
WINAPI
Section079(
    VOID
    );

int
WINAPI
Section080(
    VOID
    );

int
WINAPI
Section081(
    VOID
    );

int
WINAPI
Section082(
    VOID
    );

int
WINAPI
Section083(
    VOID
    );

int
WINAPI
Section084(
    VOID
    );

int
WINAPI
Section085(
    VOID
    );

int
WINAPI
Section086(
    VOID
    );

int
WINAPI
Section087(
    VOID
    );

int
WINAPI
Section088(
    VOID
    );

int
WINAPI
Section089(
    VOID
    );

CONST PROC Proc[] = {
    Section000, Section001, Section002, Section003, Section004, 
    Section005, Section006, Section007, Section008, Section009, 
    Section010, Section011, Section012, Section013, Section014, 
    Section015, Section016, Section017, Section018, Section019, 
    Section020, Section021, Section022, Section023, Section024, 
    Section025, Section026, Section027, Section028, Section029, 
    Section030, Section031, Section032, Section033, Section034, 
    Section035, Section036, Section037, Section038, Section039, 
    Section040, Section041, Section042, Section043, Section044, 
    Section045, Section046, Section047, Section048, Section049, 
    Section050, Section051, Section052, Section053, Section054, 
    Section055, Section056, Section057, Section058, Section059, 
    Section060, Section061, Section062, Section063, Section064, 
    Section065, Section066, Section067, Section068, Section069, 
    Section070, Section071, Section072, Section073, Section074, 
    Section075, Section076, Section077, Section078, Section079, 
    Section080, Section081, Section082, Section083, Section084, 
    Section085, Section086, Section087, Section088, Section089, 
};

#ifdef __cplusplus
}
#endif

#endif // _SECTIONS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\ps\threading\tls.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    tls.cpp

Abstract:

    This program contains routines to stress and test Thread Local Storage

Author:

    John Daly

Environment:

    Xbox

Revision History:

--*/


#include "threading.h"

//
// static thread data in TLS
//

#define TLS_ARRAY_ELEMENTS 64
__declspec( thread ) DWORD tls_array[TLS_ARRAY_ELEMENTS] = {0};


DWORD
WINAPI
ThreadLocalStorageTestThreadProc(
    PTHREAD_PARAMETERS tpm
    )
{
    #define TOTAL_DYNAMIC_TLS_AVAILABLE (TLS_MINIMUM_AVAILABLE + TLS_EXPANSION_SLOTS)
    HANDLE LogHandle = tpm->LogHandle; // make log handle visible
    LPSTR Variation = {"TLS"};
    DWORD x;
    DWORD DynamicTLSSlots = 0;
    PVOID pTLS;
    BOOL ErrorFlag = FALSE;
    DWORD DynTlsArray[TOTAL_DYNAMIC_TLS_AVAILABLE + 1] = {0};   // + 1 to contain the end of the list
    
    //
    // since we are logging from the test thread, I have to cheat all over the place...
    //

    xSetComponent( LogHandle, "Kernel", "Ps" );
    xSetFunctionName( LogHandle, "ThreadLocalStorageTestThreadProc" );

    BEGIN_VARIATION( Variation ) {

        //
        // create dynamic TLS until failure
        // change, check, free dynamic TLS
        //
        
        ErrorFlag = FALSE;

        while ( ~0 != (DynTlsArray[DynamicTLSSlots] = TlsAlloc()) &&
                (DynamicTLSSlots <  TOTAL_DYNAMIC_TLS_AVAILABLE)) {
            ++DynamicTLSSlots;
        }

        for ( x = 0; x < DynamicTLSSlots; ++x ) {
            if ( 0 == TlsSetValue(DynTlsArray[x],&x) ) {
                LOG_MSG_FAIL("TlsSetValue failed!");
                ErrorFlag = TRUE;
            }
        }

        for ( x = 0; x < DynamicTLSSlots; ++x ) {
            pTLS = TlsGetValue(DynTlsArray[x]);
            if ( x != *(DWORD *)pTLS ) {
                LOG_MSG_FAIL("TlsGetValue failed!");
                ErrorFlag = TRUE;
            }
        }

        for ( x = 0; x < DynamicTLSSlots; ++x ) {
            if ( FALSE == TlsFree(DynTlsArray[x]) ) {
                LOG_MSG_FAIL("TlsFree failed!");
                ErrorFlag = TRUE;
            }
        }
        
        if ( ErrorFlag ) {
            LOG_MSG_FAIL("Tls Test failure detected!");
        } else {
            LOG_MSG_PASS("Tls Test succeeded in all cases");
        }

        //
        // change, check static TLS
        //

        for ( x = 0; x < TLS_ARRAY_ELEMENTS; x++ ) {
            tls_array[x] = x;
        }

        ErrorFlag = FALSE;
        for ( x = 0; x < TLS_ARRAY_ELEMENTS; x++ ) {
            if ( tls_array[x] != x ) {
                LOG_MSG_FAIL("tls_array access failed!");
                ErrorFlag = TRUE;
            }
        }

        if ( ErrorFlag ) {
            LOG_MSG_FAIL("tls_array access failure detected!");
        } else {
            LOG_MSG_PASS("tls_array access succeeded in all cases");
        }

    } END_VARIATION();

    return (0);
}

VOID
ThreadLocalStorageVariation(
    HANDLE LogHandle,
    LPSTR  Variation
    )
{
    HANDLE ThreadHandle;
    THREAD_PARAMETERS tpm;

    BEGIN_VARIATION( Variation )
    {
        tpm.LogHandle = LogHandle;
        ThreadHandle = CreateThread(
                            0,
                            4096 * 16,  // 64k
                            (LPTHREAD_START_ROUTINE)ThreadLocalStorageTestThreadProc,
                            (LPVOID)&tpm,
                            0,
                            &tpm.ThreadID
                            );

        if ( !ThreadHandle ) {
            LOG_MSG_BLOCK( "CreateThread failed" );
        } else {
            LOG_MSG_PASS("tls test ran");
            WaitForSingleObject( ThreadHandle, INFINITE );
            CloseHandle( ThreadHandle );
        }
    }
    END_VARIATION();
}


VOID
ThreadLocalStorageTest(
    HANDLE LogHandle
    )
{
    xSetFunctionName( LogHandle, "ThreadLocalStorageTest" );
    ThreadLocalStorageVariation( LogHandle, "ThreadLocalStorageTestRunner" );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\smcstress.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    smcstress.h

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

*/

typedef DWORD (*APITEST_FUNC)(HANDLE hLog, DWORD ThreadID);

namespace SMCStress
    {
    extern DWORD stressMode;

    //
    //  SMC Tests
    //
    extern DWORD HalReadSMBusValue_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD HalWriteSMBusValue_Test(HANDLE hLog, DWORD ThreadID);
    extern DWORD Message_Test(HANDLE hLog, DWORD ThreadID);
    } // namespace SMCStress
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
#define AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_

#if _MSC_VER > 1000
    #pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#ifndef UNICODE
    #define _UNICODE
    #define UNICODE
#endif


// Exclude rarely-used stuff from Windows headers
#define NTLEANANDMEAN
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_IA64_) && defined(_M_IX86)
#define _X86_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MRX000)
#define _MIPS_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_ALPHA)
#define _ALPHA_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_PPC)
#define _PPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_M68K)
#define _68K_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_X86_) && !defined(_IA64_) && !defined(_MIPS_) && defined(_M_MPPC)
#define _MPPC_
#endif
#if !defined(_68K_) && !defined(_MPPC_) && !defined(_PPC_) && !defined(_ALPHA_) && !defined(_MIPS_) && !defined(_X86_) && !defined(_M_IX86) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>



#include <stdio.h>
#include <xtl.h>
#include <profilep.h>

extern "C"
    {
    ULONG DebugPrint(PCHAR Format, ...);
    __declspec(dllimport) NTSTATUS NtDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes);
    }


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C5110465_9B32_48AE_884D_CB0151C70C0A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\utils.h ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#ifndef _UTILS_H_
#define _UTILS_H_

#include "stdafx.h"
#include <xlog.h>

namespace SMCStress
    {
    } // namespace SMCStress
#endif // _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\smcmessage.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    smcmessage.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/

#include "stdafx.h"
#include "xnetref.h"
#include "commontest.h"
#include "smcstress.h"

extern "C"
    {
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

static void WriteSMC(unsigned char addr, unsigned char value)
    {
    HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

static DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }

namespace SMCStress
    {
    extern char serverIP[32];
    extern char machineName[40];
    }

/*

Routine Description:

    Tests the HalWriteSMBusValue API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    DWORD - 

*/
DWORD SMCStress::Message_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );
    */
    xSetFunctionName(hLog, "HalWriteSMBusValue");
    DWORD time = GetTickCount();

    const unsigned buffLen = 2048;
    char post[256];
    char *data = new char[buffLen];
    
    if(!data)
        {
        return 0;
        }

    while(1)
        {
        bool state = false;
        SOCKET sock = socket(PF_INET, SOCK_STREAM, 0);
        SOCKADDR_IN dest;
        dest.sin_family = PF_INET;
        dest.sin_port = htons(80);
        dest.sin_addr.s_addr = inet_addr(serverIP);

        if(connect(sock, (SOCKADDR*)&dest, sizeof(SOCKADDR)) == SOCKET_ERROR)
            {
            DebugPrint("SMCSTRESS: connect error: (ec: %u)\n", GetLastError());
            }
        else
            {
            unsigned length, dataLen;

            length = sprintf(post, "machine=%s", machineName);
            dataLen = sprintf(data, 
                            "POST /smc/query.asp HTTP/1.1\r\n"
                            "Accept: */*\r\n"
                            "User-Agent: SMC\r\n"
                            "Connection: Close\r\n"
                            "Host: %s\r\n"
                            "Content-Length: %u\r\n"
                            "Content-Type: application/x-www-form-urlencoded\r\n"
                            "\r\n"
                            "%s",
                            serverIP,
                            length,
                            post);

            DWORD err = send(sock, data, dataLen, 0);

            err = recv(sock, data, buffLen, 0);
            data[err] = '\0';
            //OutputDebugStringA("\r\nHTTPA: ");
            //OutputDebugStringA(data);

            err = recv(sock, data, buffLen, 0);
            data[err] = '\0';
            //OutputDebugStringA("\r\nHTTPB: ");
            //OutputDebugStringA(data);

            if(strstr(data, "state=on"))
                {
                state = true;
                }
            else if(strstr(data, "stopstopstop"))
                {
                closesocket(sock);
                Sleep(INFINITE);
                break;
                }
            shutdown(sock, SD_BOTH);
            }
        closesocket(sock);

        if(state) WriteSMC(0x08, 0xF0);
        else  WriteSMC(0x08, 0x0F);

        WriteSMC(0x07, 0x01);
        Sleep(250);
        } // while(1)

    delete[] data;
    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\smcstress.cpp ===
/*

Copyright (c) 2000  Microsoft Corporation

Module Name:

    smcstress.cpp

Abstract:

    The DLL exports two of the mandatory APIs: StartTest and EndTest.
    TESTINI.INI must be modified correctly so that the
    harness will load and call StartTest/EndTest.

    Please see "x-box test harness.doc" for more information.

Author:

    jpoley

Environment:

    XBox

Revision History:

*/


#include "stdafx.h"
#include <xlog.h>
#include <xbdm.h>

#include "xnetref.h"
#include "smcstress.h"
#include "commontest.h"
#include "utils.h"
#include "xtestlib.h"

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The
// default is only one thread.
//

static ULONG ThreadID = 0;


//
// Heap handle from HeapCreate
//
HANDLE SMCStressHeapHandle;


BOOL WINAPI SMCStressDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        SMCStressHeapHandle = HeapCreate(0, 0, 0);

        if(!SMCStressHeapHandle)
            {
            OutputDebugString(L"SMCSTRESS: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(SMCStressHeapHandle)
            {
            HeapDestroy(SMCStressHeapHandle);
            }
        }

    return TRUE;
    }

static bool wcistrstr(WCHAR *string, WCHAR *substr, size_t len=0)
    {
    if(!string || ! substr) return false;
    if(!*string) return false;
    if(!len) len = wcslen(substr);
    if(_wcsnicmp(string, substr, len) == 0) return true;

    return wcistrstr(string+1, substr, len);
    }


/*

Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    DWORD threadNumber - sequential number of the thread
    DWORD loops - # of times to run test
    WCHAR* testname - specific name of a test to run

Return Value:

    DWORD

*/
namespace SMCStress {

DWORD stressMode = 0;
char serverIP[32];
char machineName[40];

static DWORD RunAll(HANDLE hLog, DWORD threadNumber, DWORD loops, WCHAR *testname)
    {
    Sleep(threadNumber*200); // stagger the thread's execution a bit

    struct APIFUNCT
        {
        APITEST_FUNC f;
        WCHAR *name;
        };
    #define BUILTAPISTRUCT(n) { n , L#n }

    /*
        The below code turns on the super secret special lab message board
        (e.g. spelling out messages using the LED on a bank of xboxes)
    */
    DWORD temp=40;
    ZeroMemory(SMCStress::machineName, 40);
    DmGetXboxName(SMCStress::machineName, &temp);
    if(strstr(SMCStress::machineName, "xlab"))
        {
        wcscpy(testname, L"Message");
        }
    else
        {
        wcscpy(testname, L"Hal");
        }


    // Define all the API tests
    APIFUNCT testlist[] =
        {
        /*
        */
        BUILTAPISTRUCT(SMCStress::HalReadSMBusValue_Test),
        BUILTAPISTRUCT(SMCStress::HalWriteSMBusValue_Test),
        //BUILTAPISTRUCT(SMCStress::Message_Test),
        /*
        */
        };

    bool runAll = _wcsicmp(testname, L"(all)") == 0 ? true : false;

    // Run the suite of tests
    for(DWORD i=0; i<loops; i++)
        {
        // run each test
        for(unsigned j=0; j<ARRAYSIZE(testlist); j++)
            {
            if(runAll || wcistrstr(testlist[j].name, testname))
                {
                xLog(hLog, XLL_INFO, "%ws() ******************************************", testlist[j].name);
                //LogResourceStatus(hLog, false);
                DebugPrint("SMCSTRESS(%d): Entering %ws()\n", threadNumber, testlist[j].name);
                testlist[j].f(hLog, threadNumber);
                }
            }
        }

    return 0;
    }
    } // namespace SMCStress


/*

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    hLog - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI SMCStressStartTest(HANDLE hLog)
    {
    DWORD ID = 0;

    //
    // One way to run multiple threads without creating threads is to
    // set NumberOfThreads=n under the section [sample]. Everytime
    // the harness calls StartTest, ThreadID will get increment by one
    // after InterlockedIncrement call below. If no NumberOfThreads
    // specified, only RunTest1 will be run
    //

    ID = InterlockedIncrement((LPLONG) &ThreadID);


    unsigned short version = MAKEWORD(2, 2);
    WSADATA wsaData;
    XNetAddRef();
    Sleep(5000); // Because XNetStartup isnt fully started up when the API returns
    WSAStartup(version, &wsaData);

    // pull server IP from testini.ini
    memset(SMCStress::serverIP, 0, 32);

    // test settings
    const int buffLen = 1024;
    WCHAR testname[buffLen];
    DWORD loops;


    // Pull out internal INI file settings
    GetProfileStringA("smcstress", "server", "157.56.11.181", SMCStress::serverIP, 32);
    GetProfileString(L"smcstress", L"testname", L"(all)", testname, buffLen);
    loops = GetProfileInt(L"smcstress", L"loops", 1);
    SMCStress::stressMode = GetProfileInt(L"GeneralSettings", L"StressTestMode", 0);


    xSetOwnerAlias(hLog, "jpoley");
    xSetComponent(hLog, "XAPI", "SMC");
    DebugPrint("SMCSTRESS(%d): **************************************************************\n", ID);
    DebugPrint("SMCSTRESS(%d): Entering StartTest()\n", ID);
    DebugPrint("SMCSTRESS(%d): Internal INI Settings:\n", ID);
    DebugPrint("  loops=%lu\n", loops);
    DebugPrint("  testname=%ws\n", testname);


    switch(ID)
        {
        case 0:
        case 1:
        default:
            SMCStress::RunAll(hLog, ID, loops, testname);
            break;
        }


    DebugPrint("SMCSTRESS(%d): Leaving StartTest()\n", ID);
    DebugPrint("SMCSTRESS(%d): **************************************************************\n", ID);
    xSetOwnerAlias(hLog, NULL);
    }


/*

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI SMCStressEndTest(void)
    {
    ThreadID = 0;
    }


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( smcstress )
#pragma data_seg()

BEGIN_EXPORT_TABLE( smcstress )
    EXPORT_TABLE_ENTRY( "StartTest", SMCStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SMCStressEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", SMCStressDllMain )
END_EXPORT_TABLE( smcstress )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\utils.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    This module contains the helper functions used by the API tests

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

*/
#include "stdafx.h"
#include "utils.h"

#ifdef  __cplusplus
    extern "C" {
    #include "ntos.h"
    }
#else
    #include "ntos.h"
#endif

namespace SMCStress {


} // namespace SMCStress
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\testgame\testgame.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    testgame.c

Abstract:

    test title, meant to be marked with a new number and run to simulate a game booting

Author:

    John Daly (johndaly) 9-Oct-2000

Environment:

    X-Box

Notes:

    totally ANSI

Revision History:

    9-Oct-2000  johndaly
    created

Current Status:

    need to globalize getting / setting config data to centralize the calls
    

--*/

#include "testgame.h"

void 
__cdecl 
main(
    void
    )
/*++

Routine Description:

    calls the main sets of functionality

Arguments:

    None

Return Value:

    None

--*/ 

{   
    ULONG TitleID;
    HANDLE hLogFile;
    TCHAR FileName[MAX_PATH] = {0};
    DWORD Error = 0;
    char *tmpPtr;
    int x;
    LARGE_INTEGER liDistanceToMove = {0};
    
    OutputDebugString(TEXT("********************************************************************************\r\nTestGame starting\r\n"));

    //
    // get our TitleID so we know which instance of this test we are
    //
    
    TitleID = GetTitleID();

    //
    // create a log file in a permanent place...
    // which will be the tdata\TitleID / title persistant data
    //

    _stprintf(FileName, TEXT("T:\\%8.8X.log"), TitleID);
    hLogFile = CreateFile((LPCSTR)FileName,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
    
    OutputDebugString(FileName);
    OutputDebugString(TEXT("\r\n"));

    if (INVALID_HANDLE_VALUE == hLogFile) {
        Error = GetLastError();
        OutputDebugString(TEXT("CreatFile Failed\n"));
        DebugBreak();
    }
    
    //
    // seek to EOF
    //
     
    SetFilePointerEx(hLogFile, liDistanceToMove, NULL, FILE_END);

    //
    // initialize data buffer for saved games / cache
    //
    
    FileDataBuffer = calloc(1, FILE_DATA_SIZE);
    
    if (NULL == FileDataBuffer) {
        OutputDebugString(TEXT("Out of memory!"));
        DebugBreak();
    }

    tmpPtr = (char *)FileDataBuffer;
    for (x = 1; x < FILE_DATA_SIZE; x++) {
        *tmpPtr = (char)(x % 16);
        ++tmpPtr;
    }

    //
    // check machine state and record it
    //
    
    CheckMachineStatePre(TitleID, hLogFile);

    //
    // check saved config data from hard disk (XSetValue / XGetValue)
    //
    
    CheckConfigData(TitleID, hLogFile);

    //
    // save some games
    //

    SaveSomeGames(TitleID, hLogFile);

    //
    // fill the cache with files marked with this TestID
    //
    
    FillCachePartition(TitleID, hLogFile);

    //
    // use some title persistant data
    //
    
    UseTitlePersistentData(TitleID, hLogFile);

    //
    // name / check MU name
    //
    
    NameMUs(TitleID, hLogFile);

    //
    // test out NickNames
    //
    
    UseNickNames(TitleID, hLogFile);

    //
    // test out Title Info
    //
    
    CheckTitleInfo(TitleID, hLogFile);

    //
    // check machine state and record it
    //
    
    CheckMachineStatePost(TitleID, hLogFile);
    
    //
    // run any tests that need to be run outside of the timed portion
    //
    
    AltTitleTest(TitleID, hLogFile);
    
    //
    // modify system to boot the next test variation
    //
    
    SetupNextRun(TitleID, hLogFile);
    
}

ULONG
GetTitleID(
    void
    )
/*++

Routine Description:

    get our TitleID so we know which instance of this test we are

Arguments:

    None

Return Value:

    ULONG - title ID number XUID
    0 if information not found

--*/ 
{
    PXBEIMAGE_HEADER ImageHeader;
    PXBEIMAGE_CERTIFICATE Certificate;

    ImageHeader = XeImageHeader();
    if (NULL == ImageHeader) {
        OutputDebugString(TEXT("NULL ImageHeader!\n"));
        DebugBreak();
    }

    if (ImageHeader) {
        Certificate = (PVOID)(ImageHeader->Certificate);
        if (NULL == Certificate) {
            OutputDebugString(TEXT("NULL Certificate!\n"));
            DebugBreak();
        }
    }
    if (Certificate && ImageHeader) {
        return ((Certificate)->TitleID);
    } else {
        return(0);
    }
}

void
CheckMachineStatePre(
    ULONG TitleID,
    HANDLE hLogFile
    )
/*++

Routine Description:

    check and log the state of the machine before we do any work

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None

--*/ 
{
    #define INIBUFFERSIZE 100
    TCHAR INIBuffer[INIBUFFERSIZE] = {0};
    DWORD RetVal;
    SYSTEMTIME SystemTime;
    DWORD LaunchDataType;
    LAUNCH_DATA LaunchData;
    DWORD dwRetval;
    int x = 0;
    
    //
    // look at the passed in data from the preceding title
    //
    
    dwRetval = XGetLaunchInfo(&LaunchDataType, &LaunchData);
    
    //
    // validate the data
    //

    if (ERROR_SUCCESS == dwRetval) {
        for (x = 0; x < MAX_LAUNCH_DATA_SIZE / sizeof(sizeof(TitleID)); x++) {
            if (*(ULONG *)&LaunchData.Data[x*(sizeof(TitleID))] != TitleID) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("launch data mismatch!\r\n"));
                break;
            }
        }
        if (x >= MAX_LAUNCH_DATA_SIZE / sizeof(TitleID)) {
            LogText(TitleID,
                    hLogFile,
                    TEXT("launch data OK!\r\n"));
        }
    } else {
        LogText(TitleID,
                hLogFile,
                TEXT("No launch data returned\r\n"));
    }
    
    //
    // set up the timer,
    // start timer so we can see how long this test takes
    //
    
    if ( FALSE == QueryPerformanceFrequency(&Frequency) ) {
        ;// log and exit
    }

    StartTimer();
    
    //
    // log the test ID
    //
    
    LogText(TitleID,hLogFile,TEXT("Test ID:%8.8X\r\n"),TitleID);

    //
    // what is the current time?
    // log it
    //

    GetSystemTime(&SystemTime);
    LogText(TitleID,
            hLogFile,
            TEXT("Time: Year:%d Month:%d DayOfWeek:%d Day:%d Hour:%d Minute:%d\r\n"),
            SystemTime.wYear, 
            SystemTime.wMonth, 
            SystemTime.wDayOfWeek, 
            SystemTime.wDay, 
            SystemTime.wHour, 
            SystemTime.wMinute);
    
    //
    // mount all plugged in MUs
    //

    MountMUs(TitleID, hLogFile);

    //
    // log the number of partitions, and the type / amount of space left on each
    //
    
    LogDiskStuff(TitleID, hLogFile);

    //
    // what else...
    //
}

void
SaveSomeGames(
    ULONG TitleID,
    HANDLE hLogFile
    )
/*++

Routine Description:

    save the number and size of games specified in the 
    INI file for this instance of the game

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None
    
Note: Need to handle saving to MUs as well

--*/ 
{
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    BOOL bRetVal;
    int FileCount, FileSize, x;
    WCHAR wgamename[13] = {0};
    char agamename[13] = {0};
    CHAR PathBuffer[MAX_PATH] = {0};
    DWORD dwBytesWritten;
    DWORD dwBytesToWrite;
    TCHAR SaveRoot[] = {TEXT("U:\\")};
    HANDLE hFile;
    int y = 0;
    int IterationC;

    //
    // need to save games based on iteration...
    //

    IterationC = GetPrivateProfileIntA("Iterations", 
                                       "current", 
                                       1, 
                                       "testgame.ini");
    
    //
    // get the number and size of the games to save from the INI file
    //

    FileCount = GetPrivateProfileIntA("SavedGame","count", 10, "testgame.ini");
    FileSize = GetPrivateProfileIntA("SavedGame","size", 1024, "testgame.ini");

    //
    // for each available savegame storage location (disk plus MUs)
    //

    while ( UDataDrives[y] ) {

        //
        // grab the next UData drive from the list
        //

        SaveRoot[0] = UDataDrives[y];
        
        //
        // is there savegame space available?
        // look in U:\
        //

        if ( FALSE == GetDiskFreeSpaceEx((LPCSTR)SaveRoot,
                                         &FreeBytesAvailable,
                                         &TotalNumberOfBytes,
                                         &TotalNumberOfFreeBytes) ) {
            OutputDebugString(TEXT("GetDiskFreeSpaceEx has failed! (U:\\)\n"));
            DebugBreak();
        }

        if ( FreeBytesAvailable.QuadPart < (FileCount * FileSize) ) {
            LogText(TitleID,
                    hLogFile,
                    TEXT("ERROR: out of savegame space\r\n"));
            ++y;
            continue;
        }

        //
        // save them
        //

        for ( x = 0; x < FileCount; x++ ) {

            swprintf(wgamename, L"game%4.4x%4.4x", IterationC, x);

            bRetVal = XCreateSaveGame((LPCSTR)SaveRoot,
                                      wgamename,
                                      OPEN_ALWAYS,
                                      0,
                                      PathBuffer,
                                      sizeof(PathBuffer));
            if (ERROR_SUCCESS != bRetVal) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR: XCreateSaveGame failed : winerror:%d\r\n"), bRetVal);
                continue;
            }

            sprintf(agamename, "game%4.4x%4.4x", IterationC, x);
            strcat(PathBuffer, agamename);
            strcat(PathBuffer, ".sav");

            hFile = CreateFile(PathBuffer,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if ( INVALID_HANDLE_VALUE == hFile ) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR: CreateFile failed while saving game\r\n"));
                continue;
            }

            //
            // write some easily understood pattern of data to the file
            //

            dwBytesToWrite = FileSize;
            while ( dwBytesToWrite ) {

                if ( 0 == WriteFile(hFile,
                                    FileDataBuffer,
                                    min(dwBytesToWrite, FILE_DATA_SIZE),
                                    &dwBytesWritten,
                                    NULL) ) {
                    LogText(TitleID,
                            hLogFile,
                            TEXT("ERROR: CreateFile failed while saving game\r\n"));
                    CloseHandle(hFile);
                    break;
                }

                if ( dwBytesToWrite >= dwBytesWritten ) {
                    dwBytesToWrite -= dwBytesWritten;
                } else {
                    dwBytesToWrite = 0;
                }
            }
            CloseHandle(hFile);
        }

        //
        // log the number that were successfully saved
        //

        LogText(TitleID,
                hLogFile,
                TEXT("Saved: %d game files to %c:\\ \r\n"),
                x,
                UDataDrives[y]);
        ++y;
    }
    
    return;
}

//
// stuff for following function
//

#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }
static const OBJECT_STRING g_DDosDevicePrefix =  CONSTANT_OBJECT_STRING(OTEXT("\\??\\Z:"));

void
FillCachePartition(
    ULONG TitleID,
    HANDLE hLogFile
    )
/*++

Routine Description:

    save the number and size of cache files specified in the 
    INI file for this instance of the game

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None
    
Notes:

    Yes, this function is full of duplicated cut and pasted code...so shoot me!

--*/ 
{
    #define TESTFILES 10
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    BOOL bRetVal;
    int FileCount, FileSize, x;
    char dataname[MAX_PATH] = {0};
    HANDLE hFile;
    DWORD dwBytesWritten;
    DWORD dwBytesToWrite;
    NTSTATUS Status;
    HANDLE LinkHandle = NULL;
    OBJECT_ATTRIBUTES Obja;
    OCHAR szLinkTarget[MAX_PATH];
    OBJECT_STRING LinkTarget;
    int IterationC;
    ULONG flags;
    HANDLE hFileArray[TESTFILES];
    DWORD dwLastError;

    //
    // need to save games based on iteration...
    //

    IterationC = GetPrivateProfileIntA("Iterations", 
                                       "current", 
                                       1, 
                                       "testgame.ini");

    //
    // look in Z:\
    // log cache partition information
    // first clean it up...
    //

    //
    // this code is needed if we build with /INITFLAGS:0
    // It will cause problems (always using the same cache partition) if used with other flags
    //

    flags = XeImageHeader()->InitFlags;

    LogText(TitleID,
            hLogFile,
            TEXT("detected: //INITFLAGS: %8.8d \r\n"),
            flags);

    if (0 == flags) {
        if (FALSE == XMountUtilityDrive(TRUE)) {
            LogText(TitleID,
                    hLogFile,
                    TEXT("XMountUtilityDrive(TRUE) returned failure (only relevant if //INITFLAGS:0). Code: %8.8d \r\n"),
                    GetLastError());
        }
    }

    InitializeObjectAttributes(&Obja,
                               (POBJECT_STRING) &g_DDosDevicePrefix,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenSymbolicLinkObject(&LinkHandle, &Obja);

    if ( NT_SUCCESS(Status) ) {
        LinkTarget.Buffer = szLinkTarget;
        LinkTarget.Length = 0;
        LinkTarget.MaximumLength = sizeof(szLinkTarget);

        Status = NtQuerySymbolicLinkObject(LinkHandle, &LinkTarget, NULL);
    
        if ( NT_SUCCESS(Status) ) {
            if ( LinkHandle )
                NtClose(LinkHandle);

            LogText(TitleID,
                    hLogFile,
                    TEXT("Cache Partition: %.*s\r\n"),
                    LinkTarget.Length,
                    LinkTarget.Buffer);

            //
            // any free space...
            //

            if ( FALSE == GetDiskFreeSpaceEx("Z:\\",
                                             &FreeBytesAvailable,
                                             &TotalNumberOfBytes,
                                             &TotalNumberOfFreeBytes) ) {
                OutputDebugString(TEXT("GetDiskFreeSpaceEx has failed! (Z:\\)\n"));
                DebugBreak();
            }

            //
            // get the number and size of the files to cache from the INI file
            //

            FileCount = GetPrivateProfileIntA("CacheFill","count", 10, "testgame.ini");
            FileSize = GetPrivateProfileIntA("CacheFill","size", 1024, "testgame.ini");

            if ( FreeBytesAvailable.QuadPart < (FileCount * FileSize) ) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR: out of Cache space\r\n"));
                LogText(TitleID,
                        hLogFile,
                        TEXT("space found : 0x%I64x\r\n"),
                        FreeBytesAvailable.QuadPart);
                return;
            }

            //
            // cache them
            //

            for ( x = 0; x < FileCount; x++ ) {

                sprintf(dataname, "Z:\\data%4.4x%4.4x.dat", IterationC, x);

                hFile = CreateFile(dataname,
                                   GENERIC_READ | GENERIC_WRITE,
                                   FILE_SHARE_READ,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

                if ( INVALID_HANDLE_VALUE == hFile ) {
                    LogText(TitleID,
                            hLogFile,
                            TEXT("ERROR: CreateFile failed while saving data (cache)\r\n"));
                    continue;
                }

                //
                // write some easily understood pattern of data to the file
                //

                dwBytesToWrite = FileSize;
                while ( dwBytesToWrite ) {

                    if ( 0 == WriteFile(hFile,
                                        FileDataBuffer,
                                        min(dwBytesToWrite, FILE_DATA_SIZE),
                                        &dwBytesWritten,
                                        NULL) ) {
                        LogText(TitleID,
                                hLogFile,
                                TEXT("ERROR: WriteFile failed while saving data (cache)\r\n"));
                        CloseHandle(hFile);
                        break;
                    }

                    if ( dwBytesToWrite >= dwBytesWritten ) {
                        dwBytesToWrite -= dwBytesWritten;
                    } else {
                        dwBytesToWrite = 0;
                    }
                }
                CloseHandle(hFile);
            }

            //
            // log the number that were successfully cached
            //

            LogText(TitleID,
                    hLogFile,
                    TEXT("Saved: %d data files\r\n"),
                    x);

        } else {
            OutputDebugString(TEXT("NtQuerySymbolicLinkObject has failed!\n"));
        //    DebugBreak();
        }

    } else {
        OutputDebugString(TEXT("NtOpenSymbolicLinkObject has failed! \n"));
        //DebugBreak();
    }

    //
    // new test for XFormatUtilityDrive()
    //
    
    //
    // case - drive mounted, no open files
    // assumes no files are open on z:\
    // double-check in debugger
    //

    if(FALSE == XFormatUtilityDrive()) {
        LogText(TitleID,
                hLogFile,
                TEXT("ERROR: XFormatUtilityDrive failed - no files open scenario\r\n"));
    } else {
        LogText(TitleID,
                hLogFile,
                TEXT("XFormatUtilityDrive succeeded - no files open scenario\r\n"));
    }

    if ( FALSE == GetDiskFreeSpaceEx("Z:\\",
                                     &FreeBytesAvailable,
                                     &TotalNumberOfBytes,
                                     &TotalNumberOfFreeBytes) ) {
        OutputDebugString(TEXT("GetDiskFreeSpaceEx has failed! (Z:\\)\n"));
        DebugBreak();
    }
    
    //
    // case - drive mounted, some open files
    //

    //
    // open some files
    //

    for ( x = 0; x < TESTFILES; x++ ) {

        sprintf(dataname, "Z:\\data%4.4x%4.4x.dat", IterationC, x);

        hFileArray[x] = CreateFile(dataname,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if ( INVALID_HANDLE_VALUE == hFileArray[x] ) {
            LogText(TitleID,
                    hLogFile,
                    TEXT("ERROR: CreateFile failed while saving data (cache)\r\n"));
            continue;
        }

        //
        // write some easily understood pattern of data to the file
        //

        dwBytesToWrite = FileSize;
        while ( dwBytesToWrite ) {

            if ( 0 == WriteFile(hFileArray[x],
                                FileDataBuffer,
                                min(dwBytesToWrite, FILE_DATA_SIZE),
                                &dwBytesWritten,
                                NULL) ) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR: CreateFile failed while saving data (cache)\r\n"));
                break;
            }

            if ( dwBytesToWrite >= dwBytesWritten ) {
                dwBytesToWrite -= dwBytesWritten;
            } else {
                dwBytesToWrite = 0;
            }
        }
    }

    if(FALSE == XFormatUtilityDrive()) {
        LogText(TitleID,
                hLogFile,
                TEXT("ERROR: XFormatUtilityDrive failed - files open scenario\r\n"));
    } else {
        LogText(TitleID,
                hLogFile,
                TEXT("XFormatUtilityDrive succeeded - files open scenario\r\n"));
    }

    //
    // Probe then close files
    // what should happen?
    //

    for ( x = 0; x < TESTFILES; x++ ) {
        
        //
        // try to do something with the file - how should it fail?
        // read and write...
        //
        
        dwBytesToWrite = FileSize;
        if ( 0 == WriteFile(hFileArray[x],
                            FileDataBuffer,
                            min(dwBytesToWrite, FILE_DATA_SIZE),
                            &dwBytesWritten,
                            NULL) ) {
            dwLastError = GetLastError();
            LogText(TitleID,
                    hLogFile,
                    TEXT("WriteFile failed as expected saving data\r\n"));
        } else {
            LogText(TitleID,
                    hLogFile,
                    TEXT("ERROR: WriteFile succeeded unexpectedly\r\n"));
        }

        if ( 0 == ReadFile(hFileArray[x],
                            FileDataBuffer,
                            min(dwBytesToWrite, FILE_DATA_SIZE),
                            &dwBytesWritten,
                            NULL) ) {
            dwLastError = GetLastError();
            LogText(TitleID,
                    hLogFile,
                    TEXT("ReadFile failed as expected saving data\r\n"));
        } else {
            LogText(TitleID,
                    hLogFile,
                    TEXT("ERROR: ReadFile succeeded unexpectedly\r\n"));
        }

        CloseHandle(hFileArray[x]);
    }

    //
    // make sure the new drive is accessable
    //

    for ( x = 0; x < FileCount; x++ ) {

        sprintf(dataname, "Z:\\data%4.4x%4.4x.dat", IterationC, x);

        hFile = CreateFile(dataname,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if ( INVALID_HANDLE_VALUE == hFile ) {
            LogText(TitleID,
                    hLogFile,
                    TEXT("ERROR: CreateFile failed while saving data (cache)\r\n"));
            continue;
        }

        //
        // write some easily understood pattern of data to the file
        //

        dwBytesToWrite = FileSize;
        while ( dwBytesToWrite ) {

            if ( 0 == WriteFile(hFile,
                                FileDataBuffer,
                                min(dwBytesToWrite, FILE_DATA_SIZE),
                                &dwBytesWritten,
                                NULL) ) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR: WriteFile failed while saving data (cache)\r\n"));
                CloseHandle(hFile);
                break;
            }

            if ( dwBytesToWrite >= dwBytesWritten ) {
                dwBytesToWrite -= dwBytesWritten;
            } else {
                dwBytesToWrite = 0;
            }
        }
        CloseHandle(hFile);
    }

    //
    // log the number that were successfully cached
    //

    LogText(TitleID,
            hLogFile,
            TEXT("Saved: %d data files\r\n"),
            x);

    return;
}

void
UseTitlePersistentData(
    ULONG TitleID,
    HANDLE hLogFile
    )
/*++

Routine Description:

    save the number and size of Title Persistent Data files specified in the 
    INI file for this instance of the game

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None

--*/ 
{
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    BOOL bRetVal;
    int FileCount, FileSize, x;
    char dataname[MAX_PATH] = {0};
    HANDLE hFile;
    DWORD dwBytesWritten;
    DWORD dwBytesToWrite;

    //
    // is there title persistant data space available?
    // look in T:\
    //
    
    if (FALSE == GetDiskFreeSpaceEx("T:\\",
                                   &FreeBytesAvailable,
                                   &TotalNumberOfBytes,
                                   &TotalNumberOfFreeBytes)) {
        OutputDebugString(TEXT("GetDiskFreeSpaceEx has failed! (T:\\)\n"));
        DebugBreak();
    }

    //
    // get the number and size of the files to cache from the INI file
    //

    FileSize = GetPrivateProfileIntA("TitleData","size", 1024, "testgame.ini");
    FileCount = GetPrivateProfileIntA("TitleData","count", 10, "testgame.ini");

    if (FreeBytesAvailable.QuadPart < (FileCount * FileSize)) {
        LogText(TitleID,
                hLogFile,
                TEXT("ERROR: out of Cache space\r\n"));
        return;
    }

    //
    // store them in the persistant area
    //
    
    for (x = 0; x < FileCount; x++) {
        
        sprintf(dataname, "T:\\data%4.4x.dat", x);

        hFile = CreateFile(dataname,
                           GENERIC_READ | GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (INVALID_HANDLE_VALUE == hFile) {
            LogText(TitleID,
                    hLogFile,
                    TEXT("ERROR: CreateFile failed while saving data (title)\r\n"));
            continue;
        }

        //
        // write some easily understood pattern of data to the file
        //

        dwBytesToWrite = FileSize;
        while (dwBytesToWrite) {

            if (0 == WriteFile(hFile,
                               FileDataBuffer,
                               min(dwBytesToWrite, FILE_DATA_SIZE),
                               &dwBytesWritten,
                               NULL)) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR: CreateFile failed while saving data (title)\r\n"));
                CloseHandle(hFile);
                break;
            }

            if (dwBytesToWrite >= dwBytesWritten) {
                dwBytesToWrite -= dwBytesWritten;
            } else {
                dwBytesToWrite = 0;
            }
        }
        CloseHandle(hFile);
    }
    
    //
    // log the number of files that were successfully cached
    //
    
    LogText(TitleID,
            hLogFile,
            TEXT("Saved: %d persistant files\r\n"),
            x);
    
    return;
}

void
CheckConfigData(
    ULONG TitleID,
    HANDLE hLogFile
    )
/*++

Routine Description:

    check saved config data from hard disk (XSetValue / XGetValue)

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None
    
Note:

    BUGBUG - do the right thing with the binary values

--*/ 
{
    #define QUERY_BUFF_LEN  300
    ULONG ulType;
    char pBuffer[QUERY_BUFF_LEN] = {0};
    VOID *pValue;
    ULONG cbResultLength;

    pValue = (VOID *)pBuffer;

    if (ERROR_SUCCESS == XQueryValue(XC_TIMEZONE_BIAS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_TIMEZONE_BIAS : 0x%8.8X\r\n"), 
                *(DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(_XC_TIMEZONE_BIAS,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_TZ_STD_NAME, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_TZ_STD_NAME : %s\r\n"), 
                (char *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_TZ_STD_NAME,,,) Failed\n"));
        DebugBreak();
    }

    //
    // find right way to interpret binary values
    //

    if (ERROR_SUCCESS == XQueryValue(XC_TZ_STD_DATE, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_TZ_STD_DATE : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_TZ_STD_DATE,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_TZ_STD_BIAS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_TZ_STD_BIAS : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_TZ_STD_BIAS,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_TZ_DLT_NAME, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_TZ_DLT_NAME : %s\r\n"), 
                (char *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_TZ_DLT_NAME,,,) Failed\n"));
        DebugBreak();
    }

    //
    // find right way to interpret binary values
    //

    if (ERROR_SUCCESS == XQueryValue(XC_TZ_DLT_DATE, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_TZ_DLT_DATE : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_TZ_DLT_DATE,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_TZ_DLT_BIAS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_TZ_DLT_BIAS : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_TZ_DLT_BIAS,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_LANGUAGE, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_LANGUAGE : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_LANGUAGE,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_VIDEO_FLAGS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_VIDEO_FLAGS : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_VIDEO_FLAGS,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_AUDIO_FLAGS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_AUDIO_FLAGS : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_AUDIO_FLAGS,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_PARENTAL_CONTROL_GAMES, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_PARENTAL_CONTROL_GAMES : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_PARENTAL_CONTROL_GAMES,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_PARENTAL_CONTROL_PASSWORD, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_PARENTAL_CONTROL_PASSWORD : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_PARENTAL_CONTROL_PASSWORD,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_PARENTAL_CONTROL_MOVIES, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_PARENTAL_CONTROL_MOVIES : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_PARENTAL_CONTROL_MOVIES,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_ONLINE_IP_ADDRESS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_ONLINE_IP_ADDRESS : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_ONLINE_IP_ADDRESS,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_ONLINE_DNS_ADDRESS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_ONLINE_DNS_ADDRESS : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_ONLINE_DNS_ADDRESS,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_ONLINE_DEFAULT_GATEWAY_ADDRESS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_ONLINE_DEFAULT_GATEWAY_ADDRESS : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_ONLINE_DEFAULT_GATEWAY_ADDRESS,,,) Failed\n"));
        DebugBreak();
    }

    if (ERROR_SUCCESS == XQueryValue(XC_ONLINE_SUBNET_ADDRESS, &ulType, pValue, QUERY_BUFF_LEN, &cbResultLength)){
        LogText(TitleID,
                hLogFile,
                TEXT("XQueryValue: XC_ONLINE_SUBNET_ADDRESS : 0x%8.8X\r\n"), 
                (DWORD *)pValue);
    } else {
        OutputDebugString(TEXT("XQueryValue(XC_ONLINE_SUBNET_ADDRESS,,,) Failed\n"));
        DebugBreak();
    }

}

void
CheckMachineStatePost(
    ULONG TitleID,
    HANDLE hLogFile
    )
/*++

Routine Description:

    check and log the state of the machine after we save games, etc

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None

--*/ 
{
    //
    // log the number of partitions, and the type / amount of space left on each
    //
    
    LogDiskStuff(TitleID, hLogFile);
    
    //
    // stop timer, log time
    //
    
    LogText(TitleID,
            hLogFile,
            TEXT("Run Time: %d milliseconds\r\n"), 
            EndTimer());

    //
    // what else...
    //
}

void
AltTitleTest(
    ULONG TitleID,
    HANDLE hLogFile
    )
/*++

Routine Description:

    test the alternate title ID functions
    XMountAlternateTitle()
    XUnmountAlternateTitle()

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None

Notes:
    
    assumes titles that have run before have mounted and put directories everywhere
    only 16 alt titles are allowed, so look for and check the last 16 titles
    
--*/
{
    TCHAR RootPath[] = {TEXT("U:\\")};
    char ListSequenceNumber[10] = {0};
    int x = 0;
    int y = 0;
    ULONG AlternateTitleID = 0;
    OCHAR chDrive = {0};
    NTSTATUS status;
    BOOL bRetVal;
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    TCHAR DeviceName[5];
    HANDLE hFind;
    int TitleCount = 0;
    int TotalFilesCounted = 0;
    int FileCount;
    int FilesCounted = 0;
    int IterationT;
    
    //
    // *** must be U:, or an MU drive ***
    // for each connected UData device...
    // for each game that has been run...
    // note - hiwords must match on IDs
    //

    FileCount = GetPrivateProfileIntA("SavedGame","count", 10, "testgame.ini");
    IterationT = GetPrivateProfileIntA("Iterations", "total", 1, "testgame.ini");
    FileCount *= IterationT;

    while ( UDataDrives[y] ) {
        
        //
        // initialize list sequence number index
        // 

        x = 0;

        //
        // grab the next UData drive from the list
        //

        RootPath[0] = UDataDrives[y];

        //
        // for all preceding titles, try mount/unmount
        //

        sprintf(ListSequenceNumber, "t%3.3d", x);

        //
        // figure out the alternate title...
        //

        while ( TitleCount < 16 &&
                TitleID != (AlternateTitleID =  (ULONG)GetPrivateProfileIntA("List", 
                                                        ListSequenceNumber, 
                                                        0, 
                                                        "testgame.ini")))
        {
            TitleCount++;
            FilesCounted = 0;

            //
            // returns a NT status, check it, this is the API test for this API...
            //

            status = XMountAlternateTitle((LPCSTR)RootPath,
                                          AlternateTitleID,
                                          &chDrive);

            if ( ERROR_SUCCESS != status ) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR! : XMountAlternateTitle failed: alt ID:0x%8.8x : Root:%s\r\n"), 
                        AlternateTitleID,
                        RootPath);
                break;
            } else {
                //LogText(TitleID,
                //        hLogFile,
                //        TEXT("XMountAlternateTitle succeeded: alt ID:0x%8.8x : Root:%s : drive:%c\r\n"),
                //        AlternateTitleID,
                //        RootPath,
                //        chDrive);

                //
                // Should be ready to look at Drive X: now...
                // just make sure we found the data files we expected...
                //

                hFind = XFindFirstSaveGame("X:\\",
                                           &FindGameData);

                if ( INVALID_HANDLE_VALUE == hFind ) {
                    LogText(TitleID,
                            hLogFile,
                            TEXT("ERROR! : XFindFirstSaveGame failed: X:\\\r\n"));
                } else {

                    do {
                        ++FilesCounted;
                        bRetVal = XFindNextSaveGame(hFind, &FindGameData);
                    }while ( bRetVal );

                    //
                    // add more checking here if needed, counting 
                    // saved games is probably enough
                    //

                    if ( FilesCounted != FileCount ) {
                        LogText(TitleID,
                                hLogFile,
                                TEXT("ERROR! : %d saved games counted of %d games expected \r\n"),
                                FilesCounted,
                                FileCount);
                    }

                    XFindClose(hFind);
                }

                status = XUnmountAlternateTitle(chDrive);

                if ( ERROR_SUCCESS != status ) {
                    LogText(TitleID,
                            hLogFile,
                            TEXT("ERROR! : XUnmountAlternateTitle failed\r\n"));
                } else {
                    //LogText(TitleID,
                    //        hLogFile,
                    //        TEXT("XUnmountAlternateTitle succeeded\r\n"));
                }
            }

            sprintf(ListSequenceNumber, "t%3.3d", ++x);

            TotalFilesCounted += FilesCounted;
        } 

        //
        // point to next UData...
        //

        ++y;
    }
    
    //
    // summary log
    //

    LogText(TitleID,
            hLogFile,
            TEXT("Alt UData count: %d drives, %d titles, %d savegames\r\n"),
            y,
            TitleCount,
            TotalFilesCounted);

    //
    // for each TData...
    //

    FileCount = GetPrivateProfileIntA("TitleData","count", 10, "testgame.ini");
    RootPath[0] = 'T';
    x = 0;
    TotalFilesCounted = 0;

    //
    // for all preceding titles, try mount/unmount
    //

    sprintf(ListSequenceNumber, "t%3.3d", x);

    while ( TitleID != (AlternateTitleID =  (ULONG)GetPrivateProfileIntA("List", 
                                                    ListSequenceNumber, 
                                                    0, 
                                                    "testgame.ini"))) 
    {
        FilesCounted = 0;

        //
        // returns a NT status, check it, this is the API test for this API...
        //

        status = XMountAlternateTitle((LPCSTR)RootPath,
                                      AlternateTitleID,
                                      &chDrive);

        if ( ERROR_SUCCESS != status ) {
            LogText(TitleID,
                    hLogFile,
                    TEXT("ERROR! : XMountAlternateTitle failed: alt ID:0x%8.8x : Root:%s\r\n"), 
                    AlternateTitleID,
                    RootPath);
            break;
        } else {
           // LogText(TitleID,
           //         hLogFile,
           //         TEXT("XMountAlternateTitle succeeded: alt ID:0x%8.8x : Root:%s : drive : %c\r\n"),
           //         AlternateTitleID,
           //         RootPath,
           //         chDrive);

            //
            // Should be ready to look at Drive X: now...
            // just make sure we found the data files we expected...
            //

            hFind = FindFirstFile("W:\\data*.dat",
                                  &FindData);

            if ( INVALID_HANDLE_VALUE == hFind ) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR! : FindFirstFile failed: X:\\data*.dat\r\n"));
            } else {

                do {
                    ++FilesCounted;
                    bRetVal = FindNextFile(hFind, &FindData);
                } while ( bRetVal );

                //
                // add more checking here if needed, counting 
                // saved games is probably enough
                //

                if ( FilesCounted != FileCount ) {
                    LogText(TitleID,
                            hLogFile,
                            TEXT("ERROR! : %d game data files counted of %d files expected \r\n"), 
                                 FilesCounted,
                                 FileCount);
                }
                FindClose(hFind);
            }

            status = XUnmountAlternateTitle(chDrive);

            if ( ERROR_SUCCESS != status ) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("XUnmountAlternateTitle failed\r\n"));
            } else {
                //LogText(TitleID,
                //        hLogFile,
                //        TEXT("XUnmountAlternateTitle succeeded\r\n"));
            }
        }

        sprintf(ListSequenceNumber, "t%3.3d", ++x);

        TotalFilesCounted += FilesCounted;
    }

    //
    // summary log
    //

    LogText(TitleID,
            hLogFile,
            TEXT("Alt TData count: %d titles\r\n"),
            TotalFilesCounted);
}

void
NameMUs(
    DWORD TitleID, 
    HANDLE hLogFile
    )
/*++

Routine Description:

    test the XMUNameFromDriveLetter()

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None

Notes:

    do this as simply as possible, I think the API may be in flux...
    use nice short data

--*/ 
{
    int y = 0;
    WCHAR buffer[100];
    DWORD RetVal;

    //
    // for each mounted MU...
    //

    while ( UDataDrives[y] ) {

        if ( (UDataDrives[y] == 'F') ||
             (UDataDrives[y] == 'G') ||
             (UDataDrives[y] == 'H') ||
             (UDataDrives[y] == 'I') ||
             (UDataDrives[y] == 'J') ||
             (UDataDrives[y] == 'K') ||
             (UDataDrives[y] == 'L') ||
             (UDataDrives[y] == 'M') ) {

            //
            // Read MU name, check to make sure it is what we had before
            //

            RetVal = XMUNameFromDriveLetter(UDataDrives[y],
                                            buffer,
                                            sizeof(buffer));

            if ( ERROR_SUCCESS != RetVal ) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR: XMUNameFromDriveLetter failed while getting MU name: MU: %c winerror:%d\r\n"), 
                        UDataDrives[y],
                        RetVal);
            } else {
                LogText(TitleID,
                        hLogFile,
                        TEXT("successfully retrieved MU Name: MU %c Name : %ls\r\n"), 
                        UDataDrives[y],
                        buffer);
            }

        }

        //
        // try next
        //

        ++y;
    }
}

void
UseNickNames(
    DWORD TitleID, 
    HANDLE hLogFile
    )
/*++

Routine Description:


Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None

Notes:



--*/ 
{
}

void
CheckTitleInfo(
    DWORD TitleID, 
    HANDLE hLogFile
    )
/*++

Routine Description:


Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None

Notes:

lookk at these 2 APIs
    DWORD XMUNameFromPortSlot(DWORD dwPort, DWORD dwSlot, LPWSTR lpName, DWORD cchName);

    The private API:
    DWORD XReadMUMetaData(DWORD dwPort, DWORD dwSlot, LPVOID lpBuffer, DWORD dwByteOffset, DWORD dwNumberOfBytesToRead);


--*/ 
{
    DWORD cchName = 128;
    WCHAR Name[128] = {0};
    DWORD insertions;
    unsigned port, slot, i;
    char Drive[10] = {10};
    LPVOID buffer;
    DWORD dwRetVal;

    buffer = calloc(PAGE_SIZE, 1);
    if (NULL == buffer) {
        LogText(TitleID,
                hLogFile,
                TEXT("Allocation failed in CheckTitleInfo()! s\r\n"));
        return;
    }
    
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    
    for(i=0; i<ARRAYSIZE(XMUMasks); i++){
        slot = i<XGetPortCount()?0:1;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i]){
            
            //
            // should already be mounted - stole this code from the mounting routien
            //XMountMU(port, slot, Drive);
            //

            dwRetVal = XMUNameFromPortSlot(port, slot, Name, cchName);
            if (ERROR_SUCCESS == dwRetVal) {
                LogText(TitleID,
                        hLogFile,
                        TEXT("successfully retrieved MU Name : %ls\r\n"), 
                        Name);
            } else {
                LogText(TitleID,
                        hLogFile,
                        TEXT("ERROR: XMUNameFromPortSlot failed while getting MU name: winerror:%d\r\n"), 
                        dwRetVal);
            }

            XReadMUMetaData(port, slot, buffer, 0, PAGE_SIZE);

            //
            // check the data (if there is any...)
            // not sure how to do this
            // 


        }
    }

    //
    // cleanup
    //

    free(buffer);
}

void
SetupNextRun(
    ULONG TitleID,
    HANDLE hLogFile
    )
/*++

Routine Description:

    modify the ini file as needed for the next test
    make any other adjustments needed before we terminate and reboot

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None

Notes:

    the test XBEs will be stored as their TestID.xbe
    there will be pre-made tdata\XXXXXXXX directories with the 
    same copy of testgame .ini


--*/ 
{
    char NewTitlePath[MAX_PATH] = {0};
    char ListSequenceNumber[10] = {0};
    TCHAR szIterationC[13] = {0};
    ULONG NextTitleID;
    int IterationC, IterationT;
    int x = 0;

    //
    // break if we have finished
    //
    
    if (0x0123fffe == TitleID) {
        OutputDebugString(TEXT("about to reboot after last test (ID == 0xfffffffe) has run"));
        DebugBreak();
    }
    
    //
    // figure out the next image...
    //
    
    IterationC = GetPrivateProfileIntA("Iterations", 
                                       "current", 
                                       1, 
                                       "testgame.ini");
    
    IterationT = GetPrivateProfileIntA("Iterations", 
                                       "total", 
                                       1, 
                                       "testgame.ini");
    LogText(TitleID,
            hLogFile,
            TEXT("This was iteration %d of %d \r\n"), 
            IterationC,
            IterationT);
    
    if (IterationC == IterationT) {
        
        //
        // reboot next game image
        //

        do {
            sprintf(ListSequenceNumber, "t%3.3d", x);
            x++;
        } while (TitleID != (ULONG)GetPrivateProfileIntA("List", 
                                                         ListSequenceNumber, 
                                                         0, 
                                                         "testgame.ini"));

        sprintf(ListSequenceNumber, "t%3.3d", x);
        NextTitleID = (ULONG)GetPrivateProfileIntA("List", 
                                                   ListSequenceNumber, 
                                                   0, 
                                                   "testgame.ini");
        
        //
        // reset counter for this game
        //
        
        _itot(1, szIterationC, 10);
        WritePrivateProfileString(TEXT("Iterations"), 
                                  TEXT("current"), 
                                  szIterationC,
                                  TEXT("testgame.ini"));


    } else {
        
        //
        // reboot current game image, increment iteration counter
        //

        ++IterationC;
        _itot(IterationC, szIterationC, 10);
        WritePrivateProfileString(TEXT("Iterations"), 
                                  TEXT("current"), 
                                  szIterationC,
                                  TEXT("testgame.ini"));
        NextTitleID = TitleID;

    }
    
    sprintf(NewTitlePath, 
            "%8.8x.xbe", 
            NextTitleID);
    
    LogText(TitleID,
            hLogFile,
            TEXT("Next Title: %s\r\n"), 
            NewTitlePath);
    
    //
    // pass some data to the next title
    // make the launch data a repeating sequence of the TitleID of the 
    // title to be launched
    //

    for (x = 0; x < (MAX_LAUNCH_DATA_SIZE / sizeof(NextTitleID)); x++) {
        *(ULONG *)&LaunchData.Data[x*(sizeof(NextTitleID))] = NextTitleID;
    }

    //
    // reboot to the next title
    //
    
    CloseHandle(hLogFile);
    OutputDebugString(TEXT("TestGame ending\n"));
    XWriteTitleInfoAndReboot(NewTitlePath, 
                             "\\device\\harddisk0\\partition2", 
                             LDT_TITLE, 
                             NextTitleID, 
                             &LaunchData);

}

void
LogText(
    ULONG TitleID,
    HANDLE hLogFile,
	TCHAR *format,
	...
    )
/*++

Routine Description:

    log formatted text

Arguments:

    HANDLE hLogFile
	char *string,
	char *format,
	...

Return Value:

    None
    
Notes

    limit input to 512 tchars
    if one is not careful bad things could happen...
    
--*/ 
{
    #define BUFFERLIMIT 512
    va_list arglist;
    DWORD NumberOfBytesWritten;
    PTCHAR buffer;
    DWORD NumberOfBytesToWrite;
    BOOL bRetval;

    //
    // format the log text, check to see if buffer length was exceded
    //

    buffer = calloc(BUFFERLIMIT, sizeof(TCHAR));
    if (NULL == buffer) {
        OutputDebugString(TEXT("Allocation failed!\n"));
        DebugBreak();
    }

    va_start(arglist, format);
    NumberOfBytesToWrite = _vsntprintf(buffer, BUFFERLIMIT, format, arglist);
    NumberOfBytesToWrite *= sizeof(TCHAR);
    
    if (BUFFERLIMIT - 1 < NumberOfBytesToWrite * sizeof(TCHAR)) {
        OutputDebugString(TEXT("buffer length exceeded, fix your code!\n"));
        DebugBreak();
    }
    
    //
    // append it to the file
    //

    bRetval = WriteFile(hLogFile,
                        buffer,
                        NumberOfBytesToWrite,
                        &NumberOfBytesWritten,
                        NULL);

    OutputDebugString(buffer);
    
    if (FALSE == bRetval) {
        OutputDebugString(TEXT("Writefile has failed!\n"));
        DebugBreak();
    }
    
    va_end(arglist);
    
    if (buffer) {
        free(buffer);
    }
}

void 
LogDiskStuff(
    DWORD TitleID, 
    HANDLE hLogFile
    )
/*++

Routine Description:

    log formatted text

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None
    
Notes

    limit input to 512 tchars
    if one is not careful bad things could happen...
    make this compile lists of devuces, such as legal savegame devices
    
--*/ 
{
    BOOL bRetVal;
    int x = 0;
    int DrivesIndex = 0;
    int UDataDrivesIndex = 0;

    LogText(TitleID,
            hLogFile,
            TEXT("device  type  installed             total           free           used\r\n"));

    for (x = 0; x < 26; x++) {
        _stprintf(TPO[x].DeviceName, TEXT("%c:\\"), DeviceLetters[x]);
        bRetVal = GetDiskFreeSpaceEx((LPCSTR)TPO[x].DeviceName,
                                     &TPO[x].FreeBytesAvailable,
                                     &TPO[x].TotalNumberOfBytes,
                                     &TPO[x].TotalNumberOfFreeBytes);

        if (bRetVal) {
            
            Drives[DrivesIndex] = DeviceLetters[x];

            //
            // take care of this in 1 place, rather than splitting it 
            // between here and some of the other functions that deal with drives
            //

            if ((DeviceLetters[x] == 'U') ||
                (DeviceLetters[x] == 'F') ||
                (DeviceLetters[x] == 'G') ||
                (DeviceLetters[x] == 'H') ||
                (DeviceLetters[x] == 'I') ||
                (DeviceLetters[x] == 'J') ||
                (DeviceLetters[x] == 'K') ||
                (DeviceLetters[x] == 'L') ||
                (DeviceLetters[x] == 'M')) {
                UDataDrives[UDataDrivesIndex++] = DeviceLetters[x];
            }
        }
        
        TPO[x].DriveType = 3; // GetDriveType(TPO[x].DeviceName);

        LogText(TitleID,
                hLogFile,
                TEXT("%s        %d         %s    %12I64d   %12I64d   %12I64d\r\n"), 
                TPO[x].DeviceName,
                TPO[x].DriveType,
                bRetVal ? TEXT("yes "): TEXT("no  "),
                TPO[x].TotalNumberOfBytes,
                TPO[x].TotalNumberOfFreeBytes,
                TPO[x].TotalNumberOfBytes.QuadPart - TPO[x].FreeBytesAvailable.QuadPart);

    }

}

void
MountMUs(
    DWORD TitleID, 
    HANDLE hLogFile
    )
/*++

Routine Description:

    log formatted text

Arguments:

    ULONG TestID
    HANDLE hLogFile

Return Value:

    None
    
Notes

    find and mount all MUs
    I believe the filesystem will now see them when they are present
    We will ignore unmounting them between titles 
    (unless this proves to be a bad thing to do)
    
--*/ 
{
    DWORD insertions;
    unsigned port, slot, i;
    char Drive[10] = {10};
    
    XInitDevices(sizeof(deviceTypes)/sizeof(XDEVICE_PREALLOC_TYPE), deviceTypes);

    Sleep(1000);    // time for things to init
    
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    
    for(i=0; i<ARRAYSIZE(XMUMasks); i++){
        slot = i<XGetPortCount()?0:1;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i]){
            XMountMU(port, slot, Drive);
        }
    }
}

VOID
WINAPI
StartTimer(
    VOID
    )
/*++

Routine Description:

    Start the test timer and returns 

Arguments:

    None

Return Value:

    None

Notes:

    this uses a global variable so the calling function does not have to 
    maintain state. this is to make this as convienient and easy as possible 
    to use and un-clutter the calling function

--*/ 
{
    QueryPerformanceCounter(&PerformanceCount);
}

DWORD
WINAPI
EndTimer(
    VOID
    )
/*++

Routine Description:

    Ends the test timer and returns the elapsed time in Milliseconds

Arguments:

    None

Return Value:

    elapsed time in Milliseconds

--*/ 
{
    LARGE_INTEGER PerformanceCountFinish;

    QueryPerformanceCounter(&PerformanceCountFinish);
    return(DWORD)((PerformanceCountFinish.QuadPart - PerformanceCount.QuadPart) / (Frequency.QuadPart / 1000));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\testgame\testgame.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    testgame.h

Abstract:

    support for testgame.c
    
Author:

    John Daly (johndaly) 30-Oct-2000

Revision History:

--*/

//
// includes
//

#undef _UNICODE
#undef UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <stdio.h>
#include <tchar.h>
#include "ntos.h"
#include <xbeimage.h>
#include <ldr.h>
#include <xcrypt.h>
#include <xtestlib.h>
#include <xboxp.h>
#include <xbox.h>
#include <xapip.h>
#include "xlaunch.h"

//
// global data
//

LARGE_INTEGER Frequency;
LARGE_INTEGER PerformanceCount;
PVOID FileDataBuffer;

//
// defines
//

#define FILE_DATA_SIZE 0x400000

//
// stolen from pathmisc.c
//

#define MU_FILENAME "muname.xbx"
#define MU_FILENAME_LENGTH (sizeof(MU_FILENAME) - 1)

typedef struct TEST_PARTITION_INFO {
    TCHAR DeviceName[5];
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    DWORD TotalNumberOfFiles;
    UINT DriveType;
} TestPartitionInfo, *pTestPartitionInfo;

TestPartitionInfo TPO[26] = {0};

XDEVICE_PREALLOC_TYPE deviceTypes[] = 
{
    {XDEVICE_TYPE_GAMEPAD,4},
    {XDEVICE_TYPE_MEMORY_UNIT,8},
    {XDEVICE_TYPE_VOICE_MICROPHONE,4},
    {XDEVICE_TYPE_VOICE_HEADPHONE,4}
};
    
LAUNCH_DATA LaunchData = {0};

DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };
DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
    };

//
// list of all found drives
//

TCHAR Drives[27] = {0};

//
// list of all UData drives / MUs (U + MUs)
//

TCHAR UDataDrives[27] = {0};

//
// allocate here instead of wasting stack space...
//

char FindPath[350] = {0};
WIN32_FIND_DATA FindData = {0};
XGAME_FIND_DATA FindGameData = {0};

//
// macro to return the number of elements in an array
//

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))

TCHAR DeviceLetters[] = {TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ")};
TCHAR MULetters[] = {TEXT("FGHIJKLM")};

//
// function declarations
//

void 
__cdecl 
main(
    void
    );

ULONG
GetTitleID(
    void
    );

void
CheckMachineStatePre(
    ULONG TestID,
    HANDLE hLogFile
    );

void
CheckMachineStatePost(
    ULONG TestID,
    HANDLE hLogFile
    );

void
SaveSomeGames(
    ULONG TestID,
    HANDLE hLogFile
    );

void
FillCachePartition(
    ULONG TestID,
    HANDLE hLogFile
    );

void
UseTitlePersistentData(
    ULONG TitleID,
    HANDLE hLogFile
    );

void
CheckConfigData(
    ULONG TitleID,
    HANDLE hLogFile
    );

void
SetupNextRun(
    ULONG TestID,
    HANDLE hLogFile
    );

void
LogText(
    ULONG TitleID,
    HANDLE hLogFile,
	TCHAR *format,
	...
    );

void 
LogDiskStuff(
    DWORD TitleID, 
    HANDLE hLogFile
    );

void 
AltTitleTest(
    DWORD TitleID, 
    HANDLE hLogFile
    );

void
MountMUs(
    DWORD TitleID, 
    HANDLE hLogFile
    );

void
NameMUs(
    DWORD TitleID, 
    HANDLE hLogFile
    );

void
UseNickNames(
    DWORD TitleID, 
    HANDLE hLogFile
    );

void
CheckTitleInfo(
    DWORD TitleID, 
    HANDLE hLogFile
    );

VOID
WINAPI
StartTimer(
    VOID
    );

DWORD
WINAPI
EndTimer(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\smcstress\tests.cpp ===
/*

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tests.cpp

Abstract:

    

Author:

    Josh Poley (jpoley)

Environment:

    XBox

Revision History:
    04-21-2000  Created

Notes:

    TRAYSTATE_RESET         B'01110000'	;0x70
    TRAYSTATE_MEDIADETECT   B'01100000'	;0x60
    TRAYSTATE_NOMEDIA       B'01000000'	;0x40
    TRAYSTATE_TRAYCLOSED    B'00000000'	;0x00
    TRAYSTATE_CLOSING       B'01010000'	;0x50
    TRAYSTATE_OPENING       B'00110000'	;0x30
    TRAYSTATE_UNLOADING     B'00100000'	;0x20
    TRAYSTATE_TRAYOPEN      B'00010000'	;0x10

*/

#include "stdafx.h"
#include "commontest.h"
#include "smcstress.h"

extern "C"
    {
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

static void WriteSMC(unsigned char addr, unsigned char value)
    {
    HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

static DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }

/*

Routine Description:

    Tests the HalReadSMBusValue API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    DWORD - 

*/
DWORD SMCStress::HalReadSMBusValue_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );
    */
    xSetFunctionName(hLog, "HalReadSMBusValue");
    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Version
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("CPU Temp")
        {
        char ver[3];
        ver[0] = (char)ReadSMC(0x01);
        ver[1] = (char)ReadSMC(0x01);
        ver[2] = (char)ReadSMC(0x01);

        TESTPASS(hLog, "Version %c %c %c", ver[0], ver[1], ver[2]);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // DVD tray and video state
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("DVD Tray State")
        {
        DWORD value = ReadSMC(0x03) & 0x70;
        if(value == 0x40 || value == 0x00) // closed (with or without media)
            {
            TESTPASS(hLog, "DVD Tray State 0x%X", value);
            }
        else
            {
            TESTFAIL(hLog, "DVD Tray State 0x%X", value);
            }
        } ENDTESTCASE;
    TESTCASE("AV Mode")
        {
        DWORD value = ReadSMC(0x04);
        if(value == 7) // NO AV pack
            {
            TESTFAIL(hLog, "AV Mode 0x%X", value);
            }
        else
            {
            TESTPASS(hLog, "AV Mode 0x%X", value);
            }
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Temperature
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("CPU Temp")
        {
        DWORD value = ReadSMC(0x09);
        if(value > 0 && value < 100)
            TESTPASS(hLog, "CPU temp: %lu C", value);
        else
            TESTFAIL(hLog, "CPU temp: %lu C", value);
        } ENDTESTCASE;
    TESTCASE("Air Temp")
        {
        DWORD value = ReadSMC(0x0A);
        if(value > 0 && value < 100)
            TESTPASS(hLog, "Air temp: %lu C", value);
        else
            TESTFAIL(hLog, "Air temp: %lu C", value);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // protocol failure test (bug 6225)
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Protocol Failure Test")
        {
        DWORD tValue = ReadSMC(0x04);
        DWORD value = 0xCCCCCCCC;
        for(unsigned i=0; i<10000; i++)
            {
            value = ReadSMC(0x04);
            if(value != tValue)
                {
                TESTFAIL(hLog, "Old VMODE (0x%X) != New VMODE (0x%X) after %u tries", tValue, value, i);
                //DebugPrint("%d%d%d (0x%08X)\n", !!(value & 0x04), !!(value & 0x02), !!(value & 0x01), value);
                break;
                }
            Sleep(5); // without this we can starve out the SMC causing a shutdown ... :)
            }

        if(tValue == value) TESTPASS(hLog, "no errors");
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Error Flag
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Error Code")
        {
        unsigned failures = 0;
        for(unsigned i=0; i<0xFF; i++)
            {
            WriteSMC(0x0E, (unsigned char)i);
            DWORD value = ReadSMC(0x0F);
            if(value != i)
                {
                ++failures;
                TESTFAIL(hLog, "Error Code (%u != %u)", value, i);
                }
            }

        if(!failures)
            TESTPASS(hLog, "Error Code");
        } ENDTESTCASE_CLEAN({WriteSMC(0x0E, 0x00);});

/*
    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("SMCSTRESS(%d): This test takes a long time to run...\n", ThreadID);
        const unsigned int maxStress = 10000;
        unsigned failures = 0;
        for(i=0; i<maxStress; i++)
            {
            if(i%(maxStress/10) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }

            swprintf(buffer, L"nic%u", i);
            if(XSetNickname(buffer, TRUE) != TRUE)
                {
                ++failures;
                }
            }
        if(failures)
            TESTFAIL(hLog, "Mini stress failures: %u", failures);
        else
            TESTPASS(hLog, "Mini stress failures: %u", failures);
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });

        */

    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////


    return 0;
    }


/*

Routine Description:

    Tests the HalWriteSMBusValue API

Arguments:

    HANDLE hLog - handle to an XLOG object
    DWORD ThreadID - unique id of the thread - used to keep tests from 
        corrupting the same file

Return Value:

    DWORD - 

*/
DWORD SMCStress::HalWriteSMBusValue_Test(HANDLE hLog, DWORD ThreadID)
    {
    /*
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );
    */
    xSetFunctionName(hLog, "HalWriteSMBusValue");
    DWORD time = GetTickCount();


    //////////////////////////////////////////////////////////////////////////
    // Mini Stress
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Mini Stress")
        {
        DebugPrint("SMCSTRESS(%d): This test takes a long time to run...\n", ThreadID);
        unsigned int maxStress;
        if(stressMode) maxStress = 10;
        else maxStress = 1;
        unsigned percentage = (maxStress/10 == 0) ? 1 : maxStress/10;
        unsigned i;
        for(i=0; i<maxStress; i++)
            {
            if(i%(percentage) == 0)
                {
                DebugPrint("   (%d) %02d%%\n", ThreadID, i*100/maxStress);
                //LogResourceStatus(NULL, true);
                }

            for(unsigned red=0; red<0xF; red++)
                {
                for(unsigned green=0; green<0xF; green++)
                    {
                    // set the LED color
                    WriteSMC(0x08, (red<<4) + green);
                    WriteSMC(0x07, 0x01);

                    // set no system error
                    WriteSMC(0x0E, 0x00);

                    // use default fan control
                    WriteSMC(0x05, 0x00);

                    Sleep(250);
                    }
                }
            }
        TESTPASS(hLog, "Mini stress");
        } ENDTESTCASE_CLEAN({ DebugPrint("   (%d) 100%%\n", ThreadID); });



    //////////////////////////////////////////////////////////////////////////
    // Performance
    //////////////////////////////////////////////////////////////////////////
    TESTCASE("Performance")
        {
        xLog(hLog, XLL_INFO, "Test took %lu milliseconds to run", GetTickCount()-time);
        } ENDTESTCASE;


    //////////////////////////////////////////////////////////////////////////
    // Cleanup
    //////////////////////////////////////////////////////////////////////////
    WriteSMC(0x08, 0x0F); // set led to green
    WriteSMC(0x07, 0x01);
    WriteSMC(0x07, 0x00); // set led to default behavior


    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\timetest\timetest.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    timetest.h

Abstract:

    support for timetest.c
    
Author:

    John Daly (johndaly) 12-May-2000

Revision History:

--*/

#ifndef _TIMETEST_
#define _TIMETEST_

//
// includes
//

#include <stdio.h>
#include <xapip.h>
#include <xboxp.h>
#include <xlog.h>
#include <xtestlib.h>

//
// macros
//

#define YEAR_TIME ((ULONGLONG)(10000000) * (ULONGLONG)(60 * 60 * 24 * 365))
// UTC 00:00.0000001, 100 microsseconds, .0000001 second
#define TIME_0001 ((ULONGLONG)(1))  
// UTC 12:00.0000000
#define TIME_1200 ((ULONGLONG)(10000000) * (ULONGLONG)(60 * 60 * 12))
// UTC 23:59.9999999
#define TIME_2359 (((ULONGLONG)(10000000) * (ULONGLONG)(60 * 60 * 24)) -1)

//
//  Macro used to dump the SYSTEM_TIME structure
//

#define  DumpSystemTime( SYS_TIME, DateName ){\
    swprintf(wbuffer,                                                               \
          L"%s wYear:%ld wMonth:%ld Hour:%ld Minute:%ld Second:%ld DayOfWeek:%ld wDay:%ld \n", \
          DateName,                                                                 \
          (long)SYS_TIME.wYear, (long) SYS_TIME.wMonth,                             \
          (long)SYS_TIME.wHour, (long) SYS_TIME.wMinute, (long)SYS_TIME.wSecond,    \
          SYS_TIME.wDayOfWeek, SYS_TIME.wDay);                                      \
    OutputDebugString(wbuffer);}

#define  DumpTimeZone( TIME_ZONE ){     \
        swprintf(wbuffer,               \
              L"Bias:%d STDname:%s\n",  \
              TIME_ZONE.Bias,           \
              TIME_ZONE.StandardName);  \
        OutputDebugString(wbuffer);     \
        DumpSystemTime( TIME_ZONE.StandardDate, TIME_ZONE.StandardName );   \
        swprintf(wbuffer,               \
              L"StandardBias:%d DaylightName:%s\n", \
              TIME_ZONE.StandardBias,   \
              TIME_ZONE.DaylightName);  \
        OutputDebugString(wbuffer);     \
        DumpSystemTime( TIME_ZONE.DaylightDate, TIME_ZONE.DaylightName );   \
        swprintf(wbuffer,               \
              L"DaylightBias:%d\n",     \
              TIME_ZONE.DaylightBias);  \
        OutputDebugString(wbuffer);}

//
// global data
//

//
// Thread ID in multiple-thread configuration (not a Win32 thread ID)
//
// You can specify how many threads you want to run your test by
// setting the key NumberOfThreads=n under your DLL section. The 
// default is only one thread.
// 

LONG ThreadID = 0;

//
// Heap handle from HeapCreate
//

HANDLE HeapHandle;

//
// defines
//
#define MAX_DWORD   0xffffffff        // maximum DWORD

//
// function declarations
//

VOID
WINAPI
test_CompareFileTime(
    HANDLE LogHandle
    );

VOID
WINAPI
test_FileTimeToLocalFileTime(
    HANDLE LogHandle
    );

VOID
WINAPI
test_GetTickCount(
    HANDLE LogHandle
    );

VOID
WINAPI
test_GetTimeZoneInformation(
    HANDLE LogHandle
    );

VOID
WINAPI
test_GetTimeZoneInformationSimpleCase(
    HANDLE LogHandle
    );

VOID
WINAPI
test_Sleep(
    HANDLE LogHandle
    );

VOID
WINAPI
test_SleepEx(
    HANDLE LogHandle
    );

VOID
WINAPI
StartTest(
    HANDLE LogHandle
    );

VOID
WINAPI
EndTest(
    VOID
    );

BOOL
WINAPI
DllMain(
    HINSTANCE   hInstance,
    DWORD       fdwReason,
    LPVOID      lpReserved
    );

DWORD
WINAPI
SleepTestThread(
    LPVOID lpParameter
    );

DWORD
WINAPI
SleepExTestThread(
    LPVOID lpParameter
    );

VOID 
CALLBACK 
TestAPCProc(
    ULONG_PTR dwParam
    );

VOID
CALLBACK 
TestFileIOCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );

BOOL
WINAPI
EqualTime(
    HANDLE LogHandle,
    LPSYSTEMTIME pst1, 
    LPSYSTEMTIME pst2
    );

#endif // _TIMETEST_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\kernel\utils\testutil.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    testutil.h

Abstract:

    This module contains common testing routine and xLog wrapper
    under NT environment

Author:

    Sakphong Chanbai (schanbai) 12-May-2000

Environment:

    Xbox

Revision History:

--*/


#ifndef _A8FD5CE7_2528_4795_90B4_4845082EDC3F_
#define _A8FD5CE7_2528_4795_90B4_4845082EDC3F_


#include <xlog.h>
#include <stdarg.h>


#ifdef _UNDER_NT

__inline
BOOL
xStartVariation(
    HANDLE LogHandle,
    PSTR   lpszVariationName
    )
{
    UNREFERENCED_PARAMETER( LogHandle );
    printf( "Variation: %s\n", lpszVariationName );
    return TRUE;
}

__inline
BOOL
xLog(
    IN HANDLE LogHandle,
    IN DWORD  dwLevel,
    IN LPSTR  lpFormat,
    ...
    )
{
    va_list argptr;

    printf( "Log: " );
    va_start( argptr, lpFormat );
    vprintf( lpFormat, argptr );
    va_end( argptr );
    printf( "\n" );

    UNREFERENCED_PARAMETER( LogHandle );
    UNREFERENCED_PARAMETER( dwLevel );

    return TRUE;
}

__inline
DWORD
xEndVariation(
    IN HANDLE LogHandle
    )
{
    UNREFERENCED_PARAMETER( LogHandle );
    return TRUE;
}

__inline
BOOL
xSetComponent(
    IN HANDLE LogHandle,
    IN LPSTR  lpCompName,
    IN LPSTR  lpSubCompName
    )
{
    UNREFERENCED_PARAMETER( LogHandle );
    printf( "\n*** %s, %s ***\n", lpCompName, lpSubCompName );
    return TRUE;
}

__inline
BOOL
xSetFunctionName(
    IN HANDLE LogHandle,
    IN LPSTR  lpFuncName
    )
{
    UNREFERENCED_PARAMETER( LogHandle );
    printf( "=== %s ===\n", lpFuncName );
    return TRUE;
}

__inline
LPSTR
WinErrorSymbolicName(
    DWORD /*ErrorCode*/
    )
{
    return "unknown";
}


_inline
LPSTR
NtStatusSymbolicName(
    NTSTATUS /*Status*/
    )
{
    return "unknown";
}


#define DbgPrint printf

#endif // _UNDER_NT


#define BEGIN_VARIATION( v ) \
        { \
            xStartVariation( LogHandle, v ); \
            SetLastError( 0 ); \
            __try

#define END_VARIATION() \
            __except ( EXCEPTION_EXECUTE_HANDLER ) { \
                xLog( \
                    LogHandle, \
                    GetExceptionCode() == DBG_RIPEXCEPTION ? XLL_PASS : XLL_EXCEPTION, \
                    "Exception=%s (0x%X)", \
                    NtStatusSymbolicName(GetExceptionCode()), GetExceptionCode() \
                    ); \
            } \
            xEndVariation( LogHandle ); \
        }

#define LOG_FAIL()          xLog( LogHandle, XLL_FAIL, "last error = %s (0x%X)", \
                                WinErrorSymbolicName(GetLastError()), GetLastError() )

#define LOG_MSG_FAIL( s )   xLog( LogHandle, XLL_FAIL, "%s;last error = %s (0x%X)", \
                                s, WinErrorSymbolicName(GetLastError()), GetLastError() )

#define LOG_BLOCK()         xLog( LogHandle, XLL_BLOCK, "last error = %s (0x%X)", \
                                WinErrorSymbolicName(GetLastError()), GetLastError() )

#define LOG_MSG_BLOCK( s )  xLog( LogHandle, XLL_BLOCK, "%s;last error = %s (0x%X)", \
                                s, WinErrorSymbolicName(GetLastError()), GetLastError() )

#define LOG_PASS()          xLog( LogHandle, XLL_PASS, "last error = %s (0x%X)", \
                                WinErrorSymbolicName(GetLastError()), GetLastError() )

#define LOG_MSG_PASS( s )   xLog( LogHandle, XLL_PASS, "%s;last error = %s (0x%X)", \
                                s, WinErrorSymbolicName(GetLastError()), GetLastError() )

#define LOG_PASS_FAIL( b )  xLog( LogHandle, (b) ? XLL_PASS : XLL_FAIL, "last error = %s (0x%X)", \
                                WinErrorSymbolicName(GetLastError()), GetLastError() )

#endif // _A8FD5CE7_2528_4795_90B4_4845082EDC3F_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\mcpx\DsoundDRT\DsoundDRT.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DsoundDRT.cpp
 *  Content:    DsoundDRT tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  04/20/01    danrose Created to test Xbox DsoundDRT
 *
 ****************************************************************************/

#include "DsoundDRT.h"
#include "medialoader.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;
extern "C" g_fDirectSoundDisableBusyWaitWarning;

/****************************************************************************
 *
 *  TestAc97XmoCallback
 *
 *  Description:
 *      Callback function for TestAc97Xmo.
 *
 *  Arguments:
 *      LPVOID [in]: stream context.
 *      LPVOID [in]: packet context.
 *      DWORD [in]: packet status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestAc97XmoCallback"

void CALLBACK
TestAc97XmoCallback
(
    LPVOID                  pvStreamContext,
    LPVOID                  pvPacketContext,
    DWORD                   dwStatus
)
{
    LPDWORD                 pdwSubmittedMask    = (LPDWORD)pvStreamContext;
    DWORD                   dwPacketIndex       = (DWORD)pvPacketContext;

    *pdwSubmittedMask &= ~(1UL << dwPacketIndex);
}    


/****************************************************************************
 *
 *  TestAc97Xmo
 *
 *  Description:
 *      Tests the AC97 XMO.
 *
 *  Arguments:
 *      DWORD [in]: channel index.
 *      DWORD [in]: channel mode.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestAc97XmoCallback"

HRESULT
TestAc97Xmo
(
    DWORD                   dwChannel,
    DWORD                   dwMode
)
{
    static const DWORD      dwPacketSize        = 0x1000;
    XAc97MediaObject *      pDevice             = NULL;
    XFileMediaObject *      pWaveFile           = NULL;
    LPVOID                  pvBufferData        = NULL;
    volatile DWORD          dwSubmittedMask     = 0;
    DWORD                   dwSubmittedSize     = 0;
    XMEDIAPACKET            xmp;
    DWORD                   dwRead;
    DWORD                   dwPosition;
    DWORD                   i;
    HRESULT                 hr;

    hr = ValidateResult(Ac97CreateMediaObject(dwChannel, TestAc97XmoCallback, (LPVOID)&dwSubmittedMask, &pDevice));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pDevice->SetMode(dwMode));
    }

    if(SUCCEEDED(hr))
    {
        if(DSAC97_MODE_ENCODED == dwMode)
        {
            hr = ValidateResult(LoadWaveFile("t:\\media\\audio\\ac3\\dd-broadway.wav", NULL, &pWaveFile));
        }
        else
        {
            hr = ValidateResult(LoadStdWaveFile(CreateFormat(WAVE_FORMAT_PCM, 48000, 16, 2), &pWaveFile));
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidatePtr(pvBufferData = XPhysicalAlloc(dwPacketSize * DSAC97_MAX_ATTACHED_PACKETS, ~0UL, 4096, PAGE_READWRITE));
    }

    while(SUCCEEDED(hr))
    {
        while(((1UL << DSAC97_MAX_ATTACHED_PACKETS) - 1) == dwSubmittedMask);

        for(i = 0; i < DSAC97_MAX_ATTACHED_PACKETS; i++)
        {
            if(!(dwSubmittedMask & (1UL << i)))
            {
                break;
            }
        }

        ASSERT(i < DSAC97_MAX_ATTACHED_PACKETS);

        xmp.pvBuffer = (LPBYTE)pvBufferData + (dwPacketSize * i);
        xmp.dwMaxSize = dwPacketSize;
        xmp.pdwCompletedSize = &dwRead;
        xmp.pdwStatus = NULL;
        xmp.pContext = NULL;
        xmp.prtTimestamp = NULL;

        hr = ValidateResult(pWaveFile->Process(NULL, &xmp));

        if(SUCCEEDED(hr))
        {
            if(dwRead)
            {
                dwSubmittedMask |= 1UL << i;

                xmp.dwMaxSize = dwRead;
                xmp.pdwCompletedSize = NULL;
                xmp.pContext = (LPVOID)i;

                dwSubmittedSize += dwRead;

                hr = ValidateResult(pDevice->Process(&xmp, NULL));

                if(SUCCEEDED(hr))
                {
                    hr = ValidateResult(pDevice->Discontinuity());
                }

                if(SUCCEEDED(hr))
                {
                    hr = pDevice->GetCurrentPosition(&dwPosition);
                }

                if(SUCCEEDED(hr))
                {
                    DbgPrint("submitted %lu, position %lu\n", dwSubmittedSize, dwPosition);
                }
            }
            else
            {
                while(dwSubmittedMask);

                hr = pDevice->GetCurrentPosition(&dwPosition);

                if(SUCCEEDED(hr))
                {
                    DbgPrint("FINAL: submitted %lu, position %lu\n", dwSubmittedSize, dwPosition);
                }

                break;
            }
        }
    }

    if(pvBufferData)
    {
        XPhysicalFree(pvBufferData);
    }

    RELEASE(pWaveFile);
    RELEASE(pDevice);

    return hr;
}


/****************************************************************************
 *
 *  RotateVectorAzimuth
 *
 *  Description:
 *      Rotates a vector in a circle or elipse around a point.
 *
 *  Arguments:
 *      LPD3DXVECTOR3 [in/out]: vector.
 *      FLOAT [in]: theta in radians.
 *      FLOAT [in]: circle size in radians.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RotateVectorAzimuth"

__inline void
RotateVectorAzimuth
(
    FLOAT                   flDistance,
    FLOAT                   flTheta,
    LPD3DVECTOR             pvrPosition
)
{
    pvrPosition->x = (float)cos(flTheta) * flDistance;
    pvrPosition->z = (float)sin(flTheta) * flDistance;
}


/****************************************************************************
 *
 *  Test3d
 *
 *  Description:
 *      Moves a sound source around a circle.
 *
 *  Arguments:
 *      FLOAT [in]: listener position (X).
 *      FLOAT [in]: listener position (Y).
 *      FLOAT [in]: listener position (Z).
 *      FLOAT [in]: source circle radians.
 *      FLOAT [in]: source angular velocity.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Test3d"

HRESULT
Test3d
(
    FLOAT                   flListenerPositionX,
    FLOAT                   flListenerPositionY,
    FLOAT                   flListenerPositionZ,
    FLOAT                   flDistance,
    FLOAT                   flAngularVelocity,
	DWORD					dwAmount
)
{
    static const LPCSTR     pszFile             = "t:\\media\\audio\\pcm\\CleanGuitarArpeggios.wav";//"t:\\media\\audio\\pcm\\heli.wav";
    INT                     nLastX              = -1;
    INT                     nLastY              = -1;
    INT                     nLastZ              = -1;
    FLOAT                   flTheta;
    LPDIRECTSOUND           pDirectSound;
    LPDIRECTSOUNDBUFFER     pBuffer;
    D3DXVECTOR3             vrPreviousPosition;
    D3DXVECTOR3             vrCurrentPosition;
    D3DXVECTOR3             vrVelocity;
    DWORD                   dwStartTime;
    DWORD                   dwCurrentTime;
    FLOAT                   flTimeDelta;
    HRESULT                 hr;
	DWORD					dwCount = 0;

    //
    // Convert angular velocity to radians
    //

    flAngularVelocity = (flAngularVelocity * D3DX_PI) / 180.0f;
    flTheta = (90.0f * D3DX_PI) / 180.0f;

    //
    // Calculate the buffer's initial position
    //

    vrPreviousPosition.x = 0;
    vrPreviousPosition.y = 0;
    vrPreviousPosition.z = flDistance;

    vrCurrentPosition = vrPreviousPosition;

    //
    // Set the listener position
    //
    
    hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pDirectSound->SetPosition(flListenerPositionX, flListenerPositionY, flListenerPositionZ, DS3D_IMMEDIATE));
    }

    //
    // Create the buffer
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(CreateBufferFromFile(pszFile, DSBCAPS_CTRL3D, 0, NULL, &pBuffer));
    }

    //
    // Set the buffer's initial position
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetPosition(vrPreviousPosition.x, vrPreviousPosition.y, vrPreviousPosition.z, DS3D_IMMEDIATE));
    }

    //
    // Start the buffer playing
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, TRUE));
    }

    //
    // Get the current system time
    //

    if(SUCCEEDED(hr))
    {
        dwStartTime = GetTickCount();
    }

    //
    // Enter the main loop
    // 

    while( SUCCEEDED(hr) && dwCount < dwAmount )
    {
        //
        // Get the current system time
        //

        while(dwStartTime == (dwCurrentTime = GetTickCount()));

        //
        // Calculate the distance the sound should travel
        //

        flTimeDelta = (FLOAT)(dwCurrentTime - dwStartTime) / 1000.0f;
        flTheta += flAngularVelocity * flTimeDelta;

        //
        // Set the object's new position and velocity
        //

        RotateVectorAzimuth(flDistance, flTheta, &vrCurrentPosition);

        vrVelocity.x = (vrCurrentPosition.x - vrPreviousPosition.x) / flTimeDelta;
        vrVelocity.y = (vrCurrentPosition.y - vrPreviousPosition.y) / flTimeDelta;
        vrVelocity.z = (vrCurrentPosition.z - vrPreviousPosition.z) / flTimeDelta;

        hr = ValidateResult(pBuffer->SetVelocity(vrVelocity.x, vrVelocity.y, vrVelocity.z, DS3D_DEFERRED));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetPosition(vrCurrentPosition.x, vrCurrentPosition.y, vrCurrentPosition.z, DS3D_DEFERRED));
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pDirectSound->CommitDeferredSettings());
        }

        if(SUCCEEDED(hr))
        {
            if(((INT)vrCurrentPosition.x != nLastX) || ((INT)vrCurrentPosition.y != nLastY) || ((INT)vrCurrentPosition.z != nLastZ))
            {
                nLastX = (INT)vrCurrentPosition.x;
                nLastY = (INT)vrCurrentPosition.y;
                nLastZ = (INT)vrCurrentPosition.z;

                DbgPrint("%d %d %d (%d %d %d)\n", nLastX, nLastY, nLastZ, (int)vrVelocity.x, (int)vrVelocity.y, (int)vrVelocity.z);
				dwCount++;
            }
        }

        //
        // Save settings for the next time around
        //

        vrPreviousPosition = vrCurrentPosition;
        dwStartTime = dwCurrentTime;
    }

    //
    // Clean up
    //

    RELEASE(pBuffer);
    RELEASE(pDirectSound);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotBuffer
 *
 *  Description:
 *      Plays a single buffer to completion.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: buffer creation flags.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotBuffer"

HRESULT
PlayOneShotBuffer
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateBufferFromFile(pszFile, dwFlags, 0, NULL, &pBuffer));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBufferToCompletion(pBuffer));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotBuffer
 *
 *  Description:
 *      Plays a single buffer to completion.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotBuffer"

HRESULT
PlayOneShotBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplsPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    LPCWAVEFORMATEX         pwfxFormat  = CreateFormat(dwFormatTag, dwSamplsPerSec, dwBitsPerSample, dwChannelCount);
    LPCSTR                  pszFileName = GetStdWaveFile(pwfxFormat);
    
    return PlayOneShotBuffer(pszFileName, dwFlags);
}


/****************************************************************************
 *
 *  TestSequentialBuffers
 *
 *  Description:
 *      Plays a list of secondary buffers sequentially.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSequentialBuffers"

HRESULT
TestSequentialBuffers
(
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]    = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]  = { 1, 2 };
    static const DWORD      adwBitResolutions[] = { 8, 16 };
    static const DWORD      dwBufferCount       = NUMELEMS(adwSampleRates) * NUMELEMS(adwChannelCounts) * NUMELEMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    HRESULT                 hr                  = DS_OK;
    DWORD                   i;
    LPCWAVEFORMATEX         pwfx;
    DWORD                   dwFreeSGEs;
	LPCSTR					pFilename;
	WIN32_FIND_DATA			findData;
	HANDLE					hFind;
	BOOL					bValidSize;

    for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
    {
        pwfx = CreateFormat(dwFormatTag, 
							adwSampleRates[i % NUMELEMS(adwSampleRates)], 
							adwBitResolutions[i % NUMELEMS(adwBitResolutions)],
							adwChannelCounts[i % NUMELEMS(adwChannelCounts)]);

		// Generate the filename
		pFilename = GetStdWaveFile(pwfx);
		bValidSize = TRUE;

		// Max valid buffer size
		hr = GetFreeSGEs(&dwFreeSGEs);

		// Get the file size
		if(SUCCEEDED(hr))
		{
			// Determine the file size
			hFind = FindFirstFile(pFilename, &findData);
			hr = (hFind == INVALID_HANDLE_VALUE) ? E_FAIL : S_OK;
		}

		// Is the buffer too large to load?
		if(SUCCEEDED(hr))
		{
			FindClose(hFind);
			if((findData.nFileSizeHigh > 0) || (findData.nFileSizeLow > (dwFreeSGEs * 4096)))
				bValidSize = FALSE;
		}

		if(bValidSize)
		{
			hr = PlayOneShotBuffer(0, dwFormatTag, 
								   adwSampleRates[i % NUMELEMS(adwSampleRates)], 
								   adwBitResolutions[i % NUMELEMS(adwBitResolutions)], 
								   adwChannelCounts[i % NUMELEMS(adwChannelCounts)]);
		}
	}

    return hr;
}


/****************************************************************************
 *
 *  TestMultipleBuffers
 *
 *  Description:
 *      Plays multiple buffers of varying formats.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultipleBuffers"

HRESULT
TestMultipleBuffers
(
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]            = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]          = { 1, 2 };
    static const DWORD      adwBitResolutions[]         = { 8, 16 };
    static const DWORD      dwBufferCount               = NUMELEMS(adwSampleRates) * NUMELEMS(adwChannelCounts) * NUMELEMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     apBuffers[dwBufferCount]    = { NULL };
    DWORD                   dwSampleRateIndex           = 0;
    DWORD                   dwChannelCountIndex         = 0;
    DWORD                   dwBitResolutionIndex        = 0;
    DWORD                   dwActiveBuffers             = 0;
    HRESULT                 hr                          = DS_OK;
    DWORD                   dwFreeSGEs;
    DWORD                   dwMaxBufferSize;
    DWORD                   dwBufferSize;
    LPCWAVEFORMATEX         pwfx;
    DWORD                   dwStatus;
    DWORD                   i;
	LPCSTR					pFilename;
	WIN32_FIND_DATA			findData;
	HANDLE					hFind;
	BOOL					bValidSize;

    //
    // Get the count of free SGEs
    //

    hr = GetFreeSGEs(&dwFreeSGEs);

    //
    // Calculate the maximum buffer size
    //

    if(SUCCEEDED(hr))
    {
        dwMaxBufferSize = ((dwFreeSGEs - dwBufferCount) * 4096) / dwBufferCount / 4 * 4;
    }

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveBuffers < dwBufferCount))
    {
        //
        // Create the buffer
        //
        
        pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);
        dwBufferSize = dwMaxBufferSize;
		
		// Generate the filename
		pFilename = GetStdWaveFile(pwfx);
		bValidSize = TRUE;

		// Max valid buffer size
		hr = GetFreeSGEs(&dwFreeSGEs);

		// Get the file size
		if(SUCCEEDED(hr))
		{
			// Determine the file size
			hFind = FindFirstFile(pFilename, &findData);
			hr = (hFind == INVALID_HANDLE_VALUE) ? E_FAIL : S_OK;
		}

		// Is the buffer too large to load?
		if(SUCCEEDED(hr))
		{
			FindClose(hFind);
			if((findData.nFileSizeHigh > 0) || (findData.nFileSizeLow > (dwFreeSGEs * 4096)))
				bValidSize = FALSE;
		}
		
		if(bValidSize)
		{
			if(SUCCEEDED(hr))
				hr = CreateStdBuffer(0, pwfx, 0, NULL, &apBuffers[dwActiveBuffers], &dwBufferSize);

			if(SUCCEEDED(hr))
				hr = PlayBuffer(apBuffers[dwActiveBuffers]);

			if(SUCCEEDED(hr))
				dwActiveBuffers++;
		}

		if(SUCCEEDED(hr))
		{
			dwSampleRateIndex		= (dwSampleRateIndex + 1) % NUMELEMS(adwSampleRates);
			dwChannelCountIndex		= (dwChannelCountIndex + 1) % NUMELEMS(adwChannelCounts);
			dwBitResolutionIndex	= (dwBitResolutionIndex + 1) % NUMELEMS(adwBitResolutions);
		}
    }

    //
    // Wait for all buffers to finish playing
    //

    while(SUCCEEDED(hr) && dwActiveBuffers)
    {
        for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
        {
            if(apBuffers[i])
            {
                hr = ValidateResult(apBuffers[i]->GetStatus(&dwStatus));

                if(SUCCEEDED(hr) && !(dwStatus & DSBSTATUS_PLAYING))
                {
                    RELEASE(apBuffers[i]);

                    dwActiveBuffers--;
                }
            }
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  TestMultipleStreams
 *
 *  Description:
 *      Plays multiple streams of varying formats.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultipleStreams"

HRESULT
TestMultipleStreams
(
    DWORD                   dwFormatTag,
    DWORD                   dwPacketSize
)
{
    static const DWORD      adwSampleRates[]                    = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]                  = { 1, 2 };
    static const DWORD      adwBitResolutions[]                 = { 8, 16 };
    static const DWORD      dwStreamCount                       = NUMELEMS(adwSampleRates) * NUMELEMS(adwChannelCounts) * NUMELEMS(adwBitResolutions);
    LPDIRECTSOUNDSTREAM     apStreams[dwStreamCount]            = { NULL };
    LPVOID                  apvStreamData[dwStreamCount]        = { NULL };
    HANDLE                  ahCompletionEvents[dwStreamCount]   = { NULL };
    DWORD                   dwSampleRateIndex                   = 0;
    DWORD                   dwChannelCountIndex                 = 0;
    DWORD                   dwBitResolutionIndex                = 0;
    DWORD                   dwActiveStreams                     = 0;
    HRESULT                 hr                                  = DS_OK;
    LPCWAVEFORMATEX         pwfx;
    DWORD                   i;

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveStreams < dwStreamCount))
    {
        hr = ValidatePtr(ahCompletionEvents[dwActiveStreams] = CreateEvent(NULL, FALSE, FALSE, NULL));

        if(SUCCEEDED(hr))
        {
            pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);

            dwPacketSize /= pwfx->nBlockAlign;
            dwPacketSize *= pwfx->nBlockAlign;
            
            hr = CreateStdQueuedStream(0, pwfx, 0, &dwPacketSize, ahCompletionEvents[dwActiveStreams], NULL, &apStreams[dwActiveStreams], &apvStreamData[dwActiveStreams]);
		}

        if(SUCCEEDED(hr))
        {
            hr = PauseStream(apStreams[dwActiveStreams], FALSE);
        }

        if(SUCCEEDED(hr))
        {
            dwSampleRateIndex = (dwSampleRateIndex + 1) % NUMELEMS(adwSampleRates);
            dwChannelCountIndex = (dwChannelCountIndex + 1) % NUMELEMS(adwChannelCounts);
            dwBitResolutionIndex = (dwBitResolutionIndex + 1) % NUMELEMS(adwBitResolutions);

            dwActiveStreams++;
        }
    }

    //
    // Wait for each stream to complete
    //

    while(SUCCEEDED(hr) && dwActiveStreams)
    {
        DirectSoundDoWork();
        
        if((i = WaitForMultipleObjects(dwStreamCount, ahCompletionEvents, FALSE, 0)) < dwStreamCount)
        {
            RELEASE(apStreams[i]);
            FREE(apvStreamData[i]);

            dwActiveStreams--;
        }
    }
    //
    // Clean up
    //

    for(i = 0; i < dwStreamCount; i++)
    {
        SAFECLOSEHANDLE(ahCompletionEvents[i]);
		RELEASE( apStreams[i] );
		FREE( apvStreamData[i] );
    }

	if ( E_OUTOFMEMORY == hr )
	{
		DbgPrint( "CreateStdQueueStream returned E_OUTOFMEMORY. Return HR=S_OK from TestMultipleStreams\n" );
		hr = S_OK;
	}

    return hr;
}


/****************************************************************************
 *
 *  TestNotifies
 *
 *  Description:
 *      Tests notifications.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestNotifies"

HRESULT
TestNotifies
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwNotifyCount,
    BOOL                    fLoop
)
{
    LPCWAVEFORMATEX         pwfxFormat      = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPXFILEMEDIAOBJECT      pWaveFile       = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DWORD                   dwVolumeIndex   = 0;
    DWORD                   dwDuration      = 0;
    DWORD                   dwPeriod;
    LPHANDLE                pahEvents;
    LPDSBPOSITIONNOTIFY     padsbpn;
    DSENVELOPEDESC          dseg;
    HRESULT                 hr;
    DWORD                   i;

    //
    // Create the buffer
    //

    hr = CreateStdBuffer(DSBCAPS_CTRLPOSITIONNOTIFY, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    //
    // Calculate the notification period
    //
    
    if(SUCCEEDED(hr))
    {
        dwPeriod = dwDuration / (dwNotifyCount - 1) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign;
    }

    //
    // Create notification events
    //
    
    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pahEvents, HANDLE, dwNotifyCount);
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwNotifyCount; i++)
        {
            if(FAILED(hr = ValidatePtr(pahEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL))))
            {
                break;
            }
        }
    }

    //
    // Set notifications
    //

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padsbpn, DSBPOSITIONNOTIFY, dwNotifyCount);
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwNotifyCount - 1; i++)
        {
            padsbpn[i].dwOffset = i * dwPeriod;
            padsbpn[i].hEventNotify = pahEvents[i];
        }

        padsbpn[dwNotifyCount - 1].dwOffset = DSBPN_OFFSETSTOP;
        padsbpn[dwNotifyCount - 1].hEventNotify = pahEvents[dwNotifyCount - 1];

        hr = ValidateResult(pBuffer->SetNotificationPositions(dwNotifyCount, padsbpn));
    }

    //
    // Start playback
    //

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, fLoop);
    }

    //
    // Wait for playback to complete
    //

    while(SUCCEEDED(hr))
    {
        DirectSoundDoWork();
        
        if((i = WaitForMultipleObjects(dwNotifyCount, pahEvents, FALSE, 100)) < dwNotifyCount)
        {
            DbgPrint("Event %lu signaled\n", i);

            if(WAIT_OBJECT_0 + dwNotifyCount - 1 == i)
            {
                break;
            }
        }
    }

    //
    // Clean up
    //

    if(pahEvents)
    {
        for(i = 0; i < dwNotifyCount; i++)
        {
            SAFECLOSEHANDLE(pahEvents[i]);
        }
    }

    FREE(pahEvents);
    FREE(padsbpn);

    RELEASE(pBuffer);
    RELEASE(pWaveFile);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotStream
 *
 *  Description:
 *      Tests streaming.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotStream"

HRESULT
PlayOneShotStream
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags,
    DWORD                   dwPacketSize
)
{
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvDataBuffer        = NULL;
    HANDLE                  hCompletionEvent;
    HRESULT                 hr;
    
    //
    // Create the completion event
    //
    
    hr = ValidatePtr(hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL));

    //
    // Create the stream 
    //

    if(SUCCEEDED(hr))
    {
        hr = CreateQueuedStreamFromFile(pszFile, dwFlags, 0, &dwPacketSize, hCompletionEvent, NULL, &pStream, &pvDataBuffer);
    }

    //
    // Start playback
    //

    if(SUCCEEDED(hr))
    {
        hr = PauseStream(pStream, FALSE);
    }

    //
    // Wait for the completion event to be signaled
    //

    if(SUCCEEDED(hr))
    {
        while(TRUE)
        {
            DirectSoundDoWork();

            if(WAIT_TIMEOUT != WaitForSingleObject(hCompletionEvent, 0))
            {
                break;
            }
        }
    }

    //
    // Clean up
    //

    RELEASE(pStream);
    FREE(pvDataBuffer);
    SAFECLOSEHANDLE(hCompletionEvent);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotStream
 *
 *  Description:
 *      Tests streaming.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotStream"

HRESULT
PlayOneShotStream
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize
)
{
    LPCWAVEFORMATEX         pwfxFormat  = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPCSTR                  pszFileName = GetStdWaveFile(pwfxFormat);
    
    return PlayOneShotStream(pszFileName, dwFlags, dwPacketSize);
}


/****************************************************************************
 *
 *  TestLoopRegion
 *
 *  Description:
 *      Tests buffer loop regions.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      FLOAT [in]: loop start position (0 to 1).
 *      FLOAT [in]: loop end position (0 to 1).
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestLoopRegion"

HRESULT
TestLoopRegion
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    FLOAT                   flLoopStart,
    FLOAT                   flLoopEnd
)
{
    LPCWAVEFORMATEX         pwfxFormat  = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    DWORD                   dwDuration  = 0;
    DWORD                   dwLoopStart;
    DWORD                   dwLoopLength;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    if(SUCCEEDED(hr))
    {
        dwLoopStart = (DWORD)((FLOAT)dwDuration * flLoopStart) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign;
        dwLoopLength = ((DWORD)((FLOAT)dwDuration * flLoopEnd) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign) - dwLoopStart;

        DbgPrint("Setting loop start offset to %lu and loop end to %lu\n", dwLoopStart, dwLoopStart + dwLoopLength);
        
        hr = ValidateResult(pBuffer->SetLoopRegion(dwLoopStart, dwLoopLength));

    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, TRUE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestSubMix
 *
 *  Description:
 *      Tests basic submixing.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to test MIXIN.  FALSE to test FXIN.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestSubMix"

HRESULT
TestSubMix
(
    BOOL                    fMixIn,
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]            = { /*22050, 32000, */44100, 48000};
    static const DWORD      adwChannelCounts[]          = { 1 };
    static const DWORD      adwBitResolutions[]         = { 16 };
    static const DWORD      dwBufferCount               = NUMELEMS(adwSampleRates) * NUMELEMS(adwChannelCounts) * NUMELEMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     apBuffers[dwBufferCount]    = { NULL };
    LPDIRECTSOUNDBUFFER     apOutputBuffers[2]          = { NULL };
    DWORD                   dwActiveBuffers             = 0;
    DWORD                   dwSampleRateIndex           = 0;
    DWORD                   dwChannelCountIndex         = 0;
    DWORD                   dwBitResolutionIndex        = 0;
    HRESULT                 hr                          = DS_OK;
    DSBUFFERDESC            dsbd;
    DWORD                   dwFreeSGEs;
    DWORD                   dwMaxBufferSize;
    DWORD                   dwBufferSize;
    DWORD                   dwStatus;
    LPCWAVEFORMATEX         pwfx;
    DWORD                   i, z;
	DSMIXBINVOLUMEPAIR		mixBinVolumePair;
	DSMIXBINS				mixBins;

    //
    // Create output buffers
    //

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = fMixIn ? DSBCAPS_MIXIN : DSBCAPS_FXIN;

    for(i = 0; (i < NUMELEMS(apOutputBuffers)) && SUCCEEDED(hr); i++)
    {
		mixBinVolumePair.dwMixBin	= i;
		mixBinVolumePair.lVolume	= 0;
		mixBins.dwMixBinCount		= 1;
		mixBins.lpMixBinVolumePairs	= &mixBinVolumePair;
        dsbd.lpMixBins				= &mixBins;

        if(!fMixIn)
        {
            dsbd.dwInputMixBin = DSMIXBIN_FXSEND_5 << i;
        }
        
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apOutputBuffers[i]));
    }

    //
    // Get the count of free SGEs
    //

    if(SUCCEEDED(hr))
    {
        hr = GetFreeSGEs(&dwFreeSGEs);
    }

    //
    // Calculate the maximum buffer size
    //

    if(SUCCEEDED(hr))
    {
        dwMaxBufferSize = ((dwFreeSGEs - dwBufferCount) * 4096) / dwBufferCount / 4 * 4;
    }

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveBuffers < dwBufferCount))
    {
        //
        // Create the buffer
        //
        
        pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);
        dwBufferSize = dwMaxBufferSize;
        
        hr = CreateStdBuffer(0, pwfx, 0, apOutputBuffers[dwActiveBuffers % NUMELEMS(apOutputBuffers)], &apBuffers[dwActiveBuffers], &dwBufferSize);

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[dwActiveBuffers]);
        }

        if(SUCCEEDED(hr))
        {
            dwSampleRateIndex = (dwSampleRateIndex + 1) % NUMELEMS(adwSampleRates);
            dwChannelCountIndex = (dwChannelCountIndex + 1) % NUMELEMS(adwChannelCounts);
            dwBitResolutionIndex = (dwBitResolutionIndex + 1) % NUMELEMS(adwBitResolutions);

            dwActiveBuffers++;
        }
    }

    //
    // Wait for all buffers to finish playing
    //

    while(SUCCEEDED(hr) && dwActiveBuffers)
    {
        for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
        {
            if(apBuffers[i])
            {
                hr = ValidateResult(apBuffers[i]->GetStatus(&dwStatus));

                if(SUCCEEDED(hr) && !(dwStatus & DSBSTATUS_PLAYING))
                {
                    RELEASE(apBuffers[i]);

                    dwActiveBuffers--;
                }
            }
        }
    }

    //
    // Release output buffers
    //

    for(i = 0; i < NUMELEMS(apOutputBuffers); i++)
    {
        RELEASE(apOutputBuffers[i]);
    }

    return hr;
}


/****************************************************************************
 *
 *  TestDLS
 *
 *  Description:
 *      Tests basic DLS functionality.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDLS"

HRESULT
TestDLS
(
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    static const DWORD      dwSegmentLength = 200;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DSENVELOPEDESC          env;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        env.dwEG = DSEG_AMPLITUDE;
        env.dwMode = DSEG_MODE_DELAY;
        env.dwDelay = dwSegmentLength;
        env.dwAttack = dwSegmentLength;
        env.dwHold = dwSegmentLength;
        env.dwDecay = dwSegmentLength;
        env.dwRelease = dwSegmentLength;
        env.dwSustain = 0xFF;
        env.lPitchScale = 0;
        env.lFilterCutOff = 0;

        hr = ValidateResult(pBuffer->SetEG(&env));
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 10000, FALSE, TRUE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestSurroundEncoder
 *
 *  Description:
 *      Tests surround-sound encoding.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSurroundEncoder"

HRESULT
TestSurroundEncoder
(
    DWORD                       dwFormatTag,
    DWORD                       dwSamplesPerSec,
    DWORD                       dwBitsPerSample
)
{
	typedef enum
	{
		TESTBINMASK_SPEAKER_MASK,
		TESTBINMASK_FRONT_LEFT,
		TESTBINMASK_FRONT_RIGHT,
		TESTBINMASK_FRONT_CENTER,
		TESTBINMASK_BACK_LEFT,
		TESTBINMASK_BACK_RIGHT,
		TESTBINMASK_LOW_FREQUENCY
	} TESTBINMASK;

    typedef struct
    {
        LPCSTR		pszDescription;
        TESTBINMASK	dwMixBin;
    } TESTMIXBINS;

    static const TESTMIXBINS    aMixBins[] =
    {
        { "All speakers",       TESTBINMASK_SPEAKER_MASK },
        { "Front left",         TESTBINMASK_FRONT_LEFT },
        { "Front right",        TESTBINMASK_FRONT_RIGHT },
        { "Front center",       TESTBINMASK_FRONT_CENTER },
        { "Back left",          TESTBINMASK_BACK_LEFT },
        { "Back right",         TESTBINMASK_BACK_RIGHT },
        { "LFE",                TESTBINMASK_LOW_FREQUENCY },
    };
    
    static const DWORD          dwDuration  = 5000;
    LPDIRECTSOUNDBUFFER         pBuffer     = NULL;
    HRESULT                     hr;
    DWORD                       i;
	DSMIXBINVOLUMEPAIR			mixBinVolumePairs[6];
	DSMIXBINS					mixBins;
	
    hr = CreateStdBuffer(0, CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, 1), 0, NULL, &pBuffer);

    for(i = 0; (i < NUMELEMS(aMixBins)) && SUCCEEDED(hr); i++)
    {
        DbgPrint( "%s\n", aMixBins[i].pszDescription);

		switch(aMixBins[i].dwMixBin)
		{
			case TESTBINMASK_SPEAKER_MASK:
				mixBinVolumePairs[0].dwMixBin	= DSMIXBIN_FRONT_LEFT;
				mixBinVolumePairs[0].lVolume	= 0;
				mixBinVolumePairs[1].dwMixBin	= DSMIXBIN_FRONT_RIGHT;
				mixBinVolumePairs[1].lVolume	= 0;
				mixBinVolumePairs[2].dwMixBin	= DSMIXBIN_FRONT_CENTER;
				mixBinVolumePairs[2].lVolume	= 0;
				mixBinVolumePairs[3].dwMixBin	= DSMIXBIN_LOW_FREQUENCY;
				mixBinVolumePairs[3].lVolume	= 0;
				mixBinVolumePairs[4].dwMixBin	= DSMIXBIN_BACK_LEFT;
				mixBinVolumePairs[4].lVolume	= 0;
				mixBinVolumePairs[5].dwMixBin	= DSMIXBIN_BACK_RIGHT;
				mixBinVolumePairs[5].lVolume	= 0;
				mixBins.dwMixBinCount			= 6;
				mixBins.lpMixBinVolumePairs		= mixBinVolumePairs;
				break;
			case TESTBINMASK_FRONT_LEFT:
				mixBinVolumePairs[0].dwMixBin	= DSMIXBIN_FRONT_LEFT;
				mixBinVolumePairs[0].lVolume	= 0;
				mixBins.dwMixBinCount			= 1;
				mixBins.lpMixBinVolumePairs		= mixBinVolumePairs;
				break;
			case TESTBINMASK_FRONT_RIGHT:
				mixBinVolumePairs[0].dwMixBin	= DSMIXBIN_FRONT_RIGHT;
				mixBinVolumePairs[0].lVolume	= 0;
				mixBins.dwMixBinCount			= 1;
				mixBins.lpMixBinVolumePairs		= mixBinVolumePairs;
				break;
			case TESTBINMASK_FRONT_CENTER:
				mixBinVolumePairs[0].dwMixBin	= DSMIXBIN_FRONT_CENTER;
				mixBinVolumePairs[0].lVolume	= 0;
				mixBins.dwMixBinCount			= 1;
				mixBins.lpMixBinVolumePairs		= mixBinVolumePairs;
				break;
			case TESTBINMASK_BACK_LEFT:
				mixBinVolumePairs[0].dwMixBin	= DSMIXBIN_BACK_LEFT;
				mixBinVolumePairs[0].lVolume	= 0;
				mixBins.dwMixBinCount			= 1;
				mixBins.lpMixBinVolumePairs		= mixBinVolumePairs;
				break;
			case TESTBINMASK_BACK_RIGHT:
				mixBinVolumePairs[0].dwMixBin	= DSMIXBIN_BACK_RIGHT;
				mixBinVolumePairs[0].lVolume	= 0;
				mixBins.dwMixBinCount			= 1;
				mixBins.lpMixBinVolumePairs		= mixBinVolumePairs;
				break;
			case TESTBINMASK_LOW_FREQUENCY:
				mixBinVolumePairs[0].dwMixBin	= DSMIXBIN_LOW_FREQUENCY;
				mixBinVolumePairs[0].lVolume	= 0;
				mixBins.dwMixBinCount			= 1;
				mixBins.lpMixBinVolumePairs		= mixBinVolumePairs;
				break;
		}

        hr = ValidateResult(pBuffer->SetMixBins(&mixBins));

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(pBuffer, TRUE);
        }

        if(SUCCEEDED(hr))
        {
            Sleep(dwDuration);
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestSgeSharing
 *
 *  Description:
 *      Tests whether buffer SGE sharing works by creating two very large
 *      buffers and pointing them to the same memory.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSgeSharing"

HRESULT
TestSgeSharing
(
    void
)
{
    LPVOID                      pvBufferData    = NULL;
    LPDIRECTSOUNDBUFFER         apBuffers[2]    = { NULL };
    DWORD                       dwBufferSize;
    DSBUFFERDESC                dsbd;
    WAVEFORMATEX                wfx;
    HRESULT                     hr;
    DWORD                       i;

    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 2;
    wfx.nSamplesPerSec = 48000;
    wfx.wBitsPerSample = 16;
    wfx.nBlockAlign = 2 * 16 / 8;
    wfx.nAvgBytesPerSec = 48000 * wfx.nBlockAlign;
    wfx.cbSize = 0;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.lpwfxFormat = &wfx;

    dwBufferSize = -1;
    
    hr = ClampBufferSize(&dwBufferSize,wfx.nBlockAlign);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvBufferData, BYTE, dwBufferSize);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone16(pvBufferData, dwBufferSize, wfx.nSamplesPerSec, wfx.nChannels, 500);
    }

    for(i = 0; (i < NUMELEMS(apBuffers)) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[i]));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(apBuffers[i]->SetBufferData(pvBufferData, dwBufferSize));
        }

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[i], TRUE);
        }

        i