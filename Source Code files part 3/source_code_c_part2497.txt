tDebugMetric ( hpid, NULL, mtrcProcessorLevel, &mpt );

    return (UINT) mpt;
}

#endif

void UpdateIn386Mode(void) {
    static long l = 0;       // microprocessor type

#if !(defined (OSDEBUG4))
    l = (LONG) SYProcessor();
    fTargetIs386 = (uchar) ( l == mpt386 || l == mpt486 || l == mptPentium );
#else
    l = (LONG) SYProcessor((DWORD) hpidCurr);
    fTargetIs386 = (uchar) ( l == mptix86 );
#endif

    if (fTry386Mode) {
    fIn386Mode = fTargetIs386;
    }
}


/*
 *      DebuggingWin32s
 *              Goes against all the OSDebug tenets but we need this information to give
 *              a very Win32s specific message.
 */

BOOL DebuggingWin32s(  ) {

    if ( DebuggeeAlive( ) && pDebugCurr) {
        // HACK-O-RAMA -- we know that Win32s supports
        // exception but does not support asyncKill.
        
        // Win32s supported only remotely from the IDE.
        if ( pDebugCurr->MtrcRemoteTL( ) ) {

            if ( !(pDebugCurr->MtrcAsync( ) & asyncKill) &&
                  (pDebugCurr->MtrcHasThreads( )) &&
                  (pDebugCurr->MtrcFirstChanceExc())
                ) {
                
                return TRUE;
            }
        }
    }
    return FALSE;
}
                                
        
void SYSetContext ( HPRC hprc, HTHD hthd, BOOL fUpdateUI ) {
    BOOL fChanged = FALSE;

    if ( hprc != hprcCurr ) {
    fChanged = TRUE;

    // Take all of the relevant globals & store them hprcCurr

    if ( hprcCurr != (HPRC) NULL ) {
        UnlockHlle ( hprcCurr );
    }

    hprcCurr = hprc;

    UpdateIn386Mode ( );

    if ((lpprcCurr = (LPPRC)LLLpvFromHlle ( hprc )) != NULL ) {
        SHChangeProcess ( lpprcCurr->hpds );
    }

    if ( hthd != (HTHD) NULL ) {

        // Do we have to do similar state stuff for the thread???

        hthdCurr = hthd;
    }
    else {
        hthdCurr = lpprcCurr->hthdCurr;
    }
    }
    else if ( hthd != hthdCurr && hthd != (HTHD) NULL ) {

    fChanged = TRUE;
    hthdCurr = hthd;
    lpprcCurr->hthdCurr = hthd;
    }

    if ( hthdCurr == (HTHD) NULL ) {

    hthdCurr = GetNthThread ( 0 );
    lpprcCurr->hthdCurr = hthdCurr;
    }

    if ( fChanged ) {
        CLFreeWalkbackStack ( TRUE );
    }

    if ( fChanged && lpprcCurr->fSymLoaded ) {

    BOOL fFoundCxt;

    if ( hprcCurr != 0 && hthdCurr != 0 && lpprcCurr->stp != stpNotStarted ) {

        fEnvirGbl.fAll = FALSE;
        UpdateUserEnvir ( mUserPc | mAsmaddr );
    }
    else {
        memset ( &cxfIp, 0, sizeof ( CXF ) );

        fFoundCxt = get_initial_context ( SHpCXTFrompCXF ( &cxfIp ) );
    }

    if ( fUpdateUI && lpprcCurr->fLoaded ) {

        if ( lpprcCurr->stp != stpNotStarted ) {
        display_pc ( );
        }
        update_watch_window ( );
    }
    }
}

/*
 *  SET_ADDRS
 *
 *  Sets global addresses after run/trace or load
 */
void set_addrs (void)
{

    /* have the old function work as it did before, but update my flags */

    ADDR addr;

    _fmemset ( &addr, 0, sizeof (ADDR));

    SYGetAddr ( hpidCurr, htidCurr, adrPC, &addr );
    if ( SYCmpAddr (
        &addr,
        SHpADDRFrompCXT ( SHpCXTFrompCXF ( &cxfIp ) ) ) != 0 ) {

    fEnvirGbl.fAll = FALSE;
    UpdateUserEnvir ( mUserPc | mAsmaddr );
    }
    else
    fEnvirGbl.fAll |= mUserPc | mAsmaddr;
}


HPRC FindUnusedHprc ( char *szName, LPF lpfAmb ) {
    HPRC hprc = 0;
    BOOL fFound = FALSE;

    *lpfAmb = 0;

    do {
    LPPRC lpprc;

    hprc = LLHlleFindLpv ( llprc, hprc, szName, cmpName );

    if ( hprc != 0 ) {

        lpprc = (LPPRC)LLLpvFromHlle ( hprc );

        if ( !lpprc->fLoaded ) {
        fFound = TRUE;
        }
        else {
        *lpfAmb += 1;
        lpprc->fAmbName = TRUE;
        }

        UnlockHlle ( hprc );
    }
    else {
        break;
    }

    } while ( !fFound );

    return hprc;
}


BOOL
PASCAL
SYDisplayTLError(
    )
/*++

Routine Description:

    Display the last TL error if any.


Return Value:

    TRUE if a message was displayed.

--*/
{
    CString strErr;
    TCHAR*  lpsz = strErr.GetBuffer (TL_ERROR_BUFFER_LENGTH);
    XOSD    xosd;

    xosd = OSDGetLastTLError (htlCurr,
                              hpidCurr,
                              lpsz,
                              TL_ERROR_BUFFER_LENGTH
                              );
    strErr.ReleaseBuffer ();

    // If we have a valid return, and a None Null string.
    
    if ( xosd == xosdNone && lpsz[0] != '\0' )
    {
        MsgBox(Error, strErr);
        return TRUE;
    }
    return FALSE;
}


XOSD 
OSDAPI
SYUtilCreateHpid(
    LPFNSVC lpfnSvc,
    HEM hEM,
    HTL hTL,
    LPHPID lpHpid
) {

    if ( pDebugCurr && pDebugCurr->MtrcRemoteTL()) {
        // Update status bar to indicate we are trying
        // to connect.

        gpISrc->StatusText(DBG_Connecting,STATUS_INFOTEXT,FALSE);
    }

    XOSD xosd = xosdNone;

    xosd = OSDStartTL(hTL);

    if (xosd == xosdNone)
        xosd = OSDCreateHpid(lpfnSvc,hEM,hTL,lpHpid);

    // Display message if not succesful.

    if (xosd != xosdNone)
    {
        if (!SYDisplayTLError())
        {
            // Display the Generic message
            ErrorBox(ERR_Debugger_Init);
        }               
    }


    if ( pDebugCurr && pDebugCurr->MtrcRemoteTL())
    {
        // Reset status bar.
        gpISrc->StatusText(SYS_StatusClear, STATUS_INFOTEXT, FALSE);
    }

    return (xosd);
}

// PRC Constructor: _PRC::_PRC

BOOL PASCAL SYCreateHprc (
    char *szName,
    char *szArgs,
    HPRC hprcParent,
    HPID hpid
) {
    HPRC  hprc;
    LPPRC lpprc;
    char  rgchTitle [ _MAX_CVFNAME ];
    char FAR * lszTitle = rgchTitle;
    BOOL  fNew = FALSE;
    BOOL  fAmbName = FALSE;
    BPTS  bptsSupported;
    XOSD  xosd = xosdNone;

    int ich = 0;

    CVSplitPath ( szName, NULL, NULL, lszTitle, NULL );
    while (
    ich < cbMaxTitle &&
    rgchTitle [ ich ] &&
    rgchTitle [ ich ] != ' '
    ) {
    ich += _ftclen(rgchTitle + ich);
    }

    if ( hprcParent == (HPRC) NULL ) {

    if ( ( xosd = SYUtilCreateHpid (
        &CallBack,
        hemCurr,
        htlCurr,
        &hpid )) != xosdNone ) {

        return FALSE;
    }
    }

    hprc = FindUnusedHprc ( szName, &fAmbName );
    if ( hprc == (HPRC) NULL ) {
    fNew = TRUE;
    hprc = LLHlleCreate ( llprc );
    }
    lpprc = (LPPRC)LLLpvFromHlle ( hprc );

    if ( !fNew ) {
        HPDS    hpds = lpprc->hpds;

        if ( lpprc->llthd ) {
            LLChlleDestroyLl( lpprc->llthd );
        }
        if ( lpprc->szTitle ) {
            _ffree( lpprc->szTitle );
        }
        if ( lpprc->szArgs ) {
            _ffree( lpprc->szArgs );
        }
        _fmemset( lpprc, 0, sizeof( PRC ) );
        lpprc->hpds = hpds;
    }

    lpprc->fAmbName = fAmbName != 0;
    lpprc->hpid   = hpid;
    lpprc->pid    = 0;

    lpprc->fSymLoaded   = FALSE;
    lpprc->llthd        = LLHlliInit (
    sizeof ( THD ), llfAscending, NULL, (LPFNFCMPNODE)TDCompare
    );
    lpprc->stp          = stpNotStarted;
    lpprc->exp          = expStopped;
    lpprc->htidExecuting= (HTID) NULL;
    lpprc->hthdCurr     = (HTHD) NULL;
    lpprc->wEM          = CEXM_MDL_native;
    lpprc->fReallyNew   = TRUE;
    lpprc->fPcodePresent= FALSE;
    lpprc->SetKillReason (krNone);
    lpprc->SetBeyondEntryPoint (FALSE);
    lpprc->SetBPsBound (FALSE);
    lpprc->m_bInsideEvent = FALSE;
    lpprc->m_bGoDeferred = FALSE;
    lpprc->m_bStopDeferred = FALSE;
	lpprc->m_bEncGoPending = FALSE;
	lpprc->fSqlInproc = FIsSqlInproc();

    //
    // when the process first starts, we force source mode
        
    lpprc->SetStepMode (STEP_MODE_FORCE_SOURCE);

    OSDGetDebugMetric ( hpid, htidNull, mtrcThreads, &(lpprc->fHasThreads) );
    OSDGetDebugMetric ( hpid, htidNull, mtrcBreakPoints, &bptsSupported );
    lpprc->fHasMessages = (bptsSupported & ( bptsMessage | bptsMClass )) != 0;

    //
    //      When we start a new debuggee, tell the EE what the target machine
    //      type is.        NOTE: since the EE currently is keeping global state
    //      about what the target machine is, this will break for multiproces
    //      debugging.  It is a workaround for the EE.
    //
    
    MTRC    mtrc;
    if (OSDGetDebugMetric (hpid, NULL, mtrcProcessorType, &mtrc) == xosdNone)
    {
        EESetTarget (mtrc);
    }


    /////////////////////////////////////////////////////////////////////////
    //  WARNING: Disabling memory tracking.

    BOOL bEnable = AfxEnableMemoryTracking(FALSE);
    lpprc->szName  = _ftcsdup ( szName );
    if ( fAmbName ) {
        char FAR *lszT = rgchTitle + _ftcslen ( rgchTitle );
        
        if ( fAmbName < 10 ) {
            *lszT = (char) ('0' + fAmbName);
            *(lszT + 1 ) = '\0';
        }
        else {
            *lszT = (char) ('0' + fAmbName / 10);
            *(lszT + 1) = (char) ('0' + fAmbName % 10);
            *(lszT + 2) = '\0';
        }
    }
    
    lpprc->szTitle = _ftcsdup ( rgchTitle );
    
    if ( fNew ) {
        LLAddHlleToLl ( llprc, hprc );
    }
    
    if ( szArgs != NULL ) {
        lpprc->szArgs = _ftcsdup ( szArgs );
    }
    else {
        lpprc->szArgs = NULL;
    }
    AfxEnableMemoryTracking(bEnable);

    // Re-enabling memory tracking.
    /////////////////////////////////////////////////////////////////////////


    UnlockHlle ( hprc );

    if ( hprcCurr != (HPRC) NULL ) {
    UnlockHlle ( hprcCurr );
    }

    hprcCurr = hprc;
    lpprcCurr = (LPPRC)LLLpvFromHlle ( hprc );
    hthdCurr = (HTHD) NULL;

    UpdateIn386Mode ( );

    if ( fNew ) {
    lpprcCurr->hpds = SHCreateProcess ( );
    }
    else {
    SHChangeProcess ( lpprcCurr->hpds );
    }

    SHSetHpid ( hpid );

    return TRUE;
}


ULONG
GetStepMode(
    );
    

BOOL
SYLoadAllOmf(
	);

ULONG
_PRC::GetStepMode(
    STEP_MODE*      StepMode
    )
{
    if (StepMode)
        *StepMode = m_StepMode;

    if (m_StepMode == STEP_MODE_FORCE_SOURCE)
        return SRCSTEPPING;
    else if (m_StepMode == STEP_MODE_FORCE_ASM)
        return ASMSTEPPING;
    else
        return ::GetStepMode ();
}
    

BOOL WINAPI
SYInitProcessList(
	)
{
    llprc = LLHlliInit (sizeof (PRC),
						NULL,
						PDKill,
						(LPFNFCMPNODE)PDCompare
						);

    return (llprc != 0);
}

VOID
CVDisconnect(
	)
{
    CallBack ( (WORD)dbcRemoteQuit, NULL, NULL, 0, 0L);
}


BOOL WINAPI
SYLoadDebugInfo(
	)
{

	if (!lpprcCurr->fSymLoaded) {

		char *pchExe = lpprcCurr->szName;
		lpprcCurr->fSymLoaded = TRUE;


		if ( SHAddDll ( pchExe, FALSE ) != sheNone ) {
			return FALSE;
		} else {
			return SYLoadAllOmf ( );
		}
    } else {
		return TRUE;
	}
}

#if 0
SHE PASCAL
SheRegisterModule(
    HPID    hpid,
    HTID    htid,
    LSZ     lsz,
    BOOL    fRegEmi
    )
{
    HEXE    hexe = SHGethExeFromName( lsz );
    BOOL    bSql = FIsSqlInproc();
    SHE     she = bSql ? sheNoSymbols : SHLoadDll( lsz, TRUE );     // dont load symbols for SQL

    LPTSTR fix = 0;

    if (*(LPTSTR)lsz == '|') {
		fix = _ftcschr(lsz+1, _T('|'));
		lsz++;
		*fix = '\0';
    }

    if ( hexe && she == sheNone ) {
		LSZ     lszOldPath;
		CHAR    szOMFDrv[_MAX_DRIVE];
		CHAR    szOMFDir[_MAX_DIR];
		CHAR    szNewDrv[_MAX_DRIVE];
		CHAR    szNewDir[_MAX_DIR];

		lszOldPath = SHGetExeName( hexe );
		_splitpath ( lsz, szNewDrv, szNewDir, NULL, NULL );
		_splitpath ( lszOldPath, szOMFDrv, szOMFDir, NULL, NULL );

		if ( _ftcsicmp ( szNewDrv, szOMFDrv ) ||
			_ftcsicmp ( szNewDir, szOMFDir ) ) {

			CVMessage (
				WARNMSG,
				MODNOMATCH,
				CMDWINDOW,
				lsz
				);
		}
		
		fRegEmi = TRUE;
	} else if ( she != sheOutOfMemory && she != sheFileOpen ) {

		if ( she == sheNone ) {
			CVMessage ( FMESSAGEMSG, MODLOADED, CMDWINDOW, lsz );
		} else if ( (she == sheNoSymbols) && !bSql ) {
			CVMessage ( FMESSAGEMSG, NOSYMBOLS, CMDWINDOW, lsz );
		} else if (she==sheSymbolsConverted)
			CVMessage ( WARNMSG, SYMSCONVERTED, CMDWINDOW, lsz );
		else if (she==sheExportsConverted)
			CVMessage ( WARNMSG, EXPORTSCONVERTED, CMDWINDOW, lsz );

		if (fix) {
			*fix = '|';
			lsz--;
			fix = NULL;
		}

		if ( fRegEmi ) {
			hexe = SHGethExeFromName( lsz );
		}
	}

    if (fix) {
		*fix = '|';
		lsz--;
		fix = NULL;
    }

    if ( hexe && fRegEmi ) {

        if (!pDebugCurr || (pDebugCurr && !pDebugCurr->IsJava())) {

            ADDR tAddrEmi = {0};
            ADDR tAddr = {0};

            emiAddr ( tAddrEmi ) = (HEMI)hexe;
            if ( SHPublicNameToAddr(&tAddrEmi, &tAddr, "___pcd_start" ) ) {
                lpprcCurr->fPcodePresent = TRUE;
            }
        }

    if  ( lpprcCurr->fPcodePresent ) {
        OSDNativeOnly ( hpid, htid, !lpprcCurr->fPcodePresent );
    }

        if ( pDebugCurr->MtrcRemoteTL() ) {
            CString strRemote;

            if (*lsz == '|') {      // OSDEBUG4
                lsz++;
                fix = _ftcschr (lsz, _T('|'));
                *fix = '\000';
            }

            MapLocalFileToRemote(lsz, strRemote);

            VERIFY(OSDRegisterEmi(hpid, (HEMI)hexe, (LPTSTR)(LPCTSTR)strRemote) == xosdNone);

        }
        else
        {
			VERIFY(OSDRegisterEmi(hpid, (HEMI)hexe, lsz) == xosdNone);
        }
    }

    return she;
}
#endif



SHE WINAPI
SheRegisterModule(
    HPID    hpid,
    HTID    htid,
    LSZ		lsz
	)
/*++

Routine Description:

	Load the dll and symbols for the dll.  Do the proper local/remote mapping.
	Warn to debug output about status of the loaded dll.

Comments:

	The name that is passed down in lsz MUST be the name passed to
	OSDRegisterEmi ().

--*/

{
	CString	strLocal;
	CString	strLocalUndecorated;
	CString	strUndecorated;
	CString	strT;
	CHAR    szDriveOld [_MAX_DRIVE];
	CHAR    szDriveNew [_MAX_DRIVE];
	CHAR    szDirOld [_MAX_DIR];
	CHAR	szDirNew [_MAX_DIR];
	SHE		she = sheNone;
	XOSD	xosd = xosdNone;
    LPTSTR	fix = NULL;
	HEXE	hexe = NULL;
    ADDR	tAddrEmi = {0};
    ADDR	tAddr = {0};
	BOOL	fDoEncReloadImage = FALSE;


	
	if (*lsz == '|') {
		lsz++;
		fix = _ftcschr (lsz, _T('|'));
		*fix = '\000';
	}

	strUndecorated = lsz;

	if (fix) {
		lsz--;
		*fix = '|';
		fix = NULL;
	}
	
	emiAddr (tAddrEmi) = (HEMI) hexe;

	//
	// Do not be fooled: this check is for the benefit of SQL to see if we
	// should load the SQL NM or not.  In this context 'p-code' means sqlnm.
	//
	
    if (SHPublicNameToAddr (&tAddrEmi, &tAddr, "___pcd_start")) {
		lpprcCurr->fPcodePresent = TRUE;
    }

	if (FIsSqlInproc ()) {

		//
		// Don't bother calling SHLoadDll if SQL debugging (speed up startup),
		// and also force non-native so the SQL NM stays around. Doesn't
		// bother with the p-code symbol lookup stuff either.
		//
		
		strLocal = lsz;
		she = sheNoSymbols;
        lpprcCurr->fPcodePresent = TRUE;
		
	} else {

		ASSERT (pDebugCurr);

		//
		// If remote, map the remote dll to a local dll
		//
		

		if (pDebugCurr->MtrcRemoteTL ()) {

			if (FGetLocalDLLFromRemoteDLL (strLocal, strUndecorated)) {
				ASSERT (!strLocal.IsEmpty ());
				strLocalUndecorated = strLocal;
				ASSERT (strLocalUndecorated [0] != '|');
			} else {
				strLocalUndecorated = strUndecorated;
				strLocal = lsz;
			}

		} else {

			strLocalUndecorated = strUndecorated;
			strLocal = lsz;
		}

		hexe = SHGethExeFromName ((LPSTR) (LPCSTR) strLocal);
		she = SHLoadDll ((LPSTR) (LPCSTR) strLocal, TRUE);

		if (she == sheNone && hexe) {

			//
			// Symbols for this DLL were already loaded.  Make sure the
			// module that was already loaded is the same as the module
			// we now have loaded.
			//
			
			strT = SHGetExeName (hexe);
			ASSERT (strT [0] != '|');

			_splitpath (strT, szDriveNew, szDirNew, NULL, NULL);
			_splitpath (strLocalUndecorated, szDriveOld, szDirOld, NULL, NULL);

			if (_ftcsicmp (szDriveNew, szDriveOld) != 00 ||
				_ftcsicmp (szDirNew, szDirOld) != 00) {

				CVMessage (WARNMSG, MODNOMATCH, CMDWINDOW, strLocalUndecorated);
			}
			else if (ENCIsEditedImage(hexe)) {
				fDoEncReloadImage = TRUE;
			}

		} else {

			switch (she) {

				case sheNone:
					CVMessage (FMESSAGEMSG, MODLOADED, CMDWINDOW, strLocalUndecorated);
					break;

				case sheNoSymbols:
					CVMessage (FMESSAGEMSG, NOSYMBOLS, CMDWINDOW, strLocalUndecorated);
					break;

				case sheSymbolsConverted:			
					CVMessage (WARNMSG, SYMSCONVERTED, CMDWINDOW, strLocalUndecorated);
					break;

				case sheExportsConverted:
					CVMessage (WARNMSG, EXPORTSCONVERTED, CMDWINDOW, strLocalUndecorated);

			}
		}

	}
	
	hexe = SHGethExeFromName ((LPSTR) (LPCSTR) strLocal);


	//
	// This is for SQL -- not real pcode
	//
	
	if (lpprcCurr->fPcodePresent) {
        OSDNativeOnly (hpid, htid, !lpprcCurr->fPcodePresent);
    }

	//
	// The string that is passed down to OSDRegisterModule must be the
	// same as the string that was passed by the EM to callback on
	// dbcModLoad.  Decoration and all.
	//

	if (hexe) {
		xosd = OSDRegisterEmi (hpid, (HEMI) hexe, lsz);
		ASSERT (xosd == xosdNone);

		if (fDoEncReloadImage && !ENCReloadImage(hexe)) {
			// The dll was edited by ENC during this debugging session
			// but the ENC engine was not able to reload the dll
			CString strMsg;
			MsgText(strMsg, IDS_Enc_CantReloadImage, strT);
			OutputWindowQueueHit(OwinGetDebugCommandID(), strMsg, FALSE, TRUE);
		}
 	}

	return she;
}

		

void
SYInstallVirtual(
    HPID    hpid,
    LSZ     lszLibName,
    BOOL    fLoad
    )
{
    HEXE hexe = SHGethExeFromName ( lszLibName );

	//
    // If loading always register the module
	//

	if ( fLoad ) {
		SheRegisterModule (hpid, htidNull, lszLibName);
    }

	//
    // If there's an hexe, then update the breakpoint list
	//
	
    if (hexe) {
		BPInstallVirtual ( hpid, hexe, fLoad );
    }

	//
    // If unloading, unregister the dll and unload
	//

	if ( hexe && !fLoad ) {

		XOSD    xosd;
    
        //      
        // BUGBUG: this used to assert when xosd != xosdNone.  We cannot do
        // this because of a bug when loading multiple DLLs with the same
        // name (but different actual images).  We will need to revisit this
        // problem in the future.  For a repro case, have two versions of
        // some Dll. In the extra's dialog, load one of the versions of the
        // Dll and make sure that the program loads the other one.  Note
        // that the UnRegisterEmi call gets confused below and fails.
        //
           
        xosd = OSDUnRegisterEmi (hpid, (HEMI) hexe);
		SHUnloadDll (hexe);
    }
}

VOID
SYUnFixupOmf(
	)
{
    HEXE    hexeCurr = NULL;
    HEXE    hexeNext = NULL;
    HPID    hpid = hpidCurr;

    hexeCurr = SHGetNextExe (NULL);

    while (hexeCurr) {

		hexeNext = SHGetNextExe (hexeCurr);

		if (SHIsDllLoaded (hexeCurr)) {

            LPTSTR pszExeName = SHGetExeName (hexeCurr);

			if (pszExeName != NULL) {
                SYInstallVirtual (hpid, pszExeName, FALSE);
            } else {
				SHUnloadDll (hexeCurr);
            }
		}
		hexeCurr = hexeNext;
    }
}


/***************************************************************************
 *                                                                         *
 * Memory and List manager load ds thunks                                  *
 *                                                                         *
 ***************************************************************************/

//#define TRACK_DEBUGGER_LEAKS

void FAR * PASCAL LOADDS LDSFmalloc( size_t size ) {
#if defined (TRACK_DEBUGGER_LEAKS)
    return BMAlloc (size);
#else
    return cvw3_fmalloc (size);
#endif
}

void FAR * PASCAL LOADDS LDSFrealloc ( void FAR * buffer, size_t size ) {
#if defined (TRACK_DEBUGGER_LEAKS)
    return BMRealloc (buffer, size);
#else
    return cvw3_frealloc (buffer, size);
#endif
}

void PASCAL LOADDS LDSFfree ( void FAR * buffer ) {
#if defined (TRACK_DEBUGGER_LEAKS)
    BMFree (buffer);
#else
    cvw3_ffree (buffer);
#endif
}

// This is a list of all HLLIs which were allocated by the
// debugger DLLs.  It's kept as a CMapPtrToWord in order to
// allow for fast location of particular elements; however,
// the only part we're actually using is the Ptr (which is
// actually the HLLI); we're not interested in the Word to
// which it maps.
CMapPtrToWord ListOfDbgLists;

void FreeDbgLinkedLists(void)
{
    POSITION pos;

    pos = ListOfDbgLists.GetStartPosition();
    while (pos)
    {
        void* key;
        WORD value;
        HLLI hlli;
        LLI* plli;

        // query key and value, and also advance pos to next position
        ListOfDbgLists.GetNextAssoc(pos, key, value);

        // the key is actually an HLLI
        hlli = (HLLI) key;

        // set the HLLI's lpfnKill and lpfnCmp function pointers
        // to NULL.  We do this because all we're trying to do
        // here is free up resources which were used by the
        // linked list; we must not call the kill or compare
        // functions, because the debuggee code may not be
        // expecting that to happen right now, and also because
        // those code addresses may in fact be invalid!  (They
        // may be in DLLs which have since been released.)

        plli = LockHlli(hlli);
        plli->lpfnKill = NULL;
        plli->lpfnCmp = NULL;
        UnlockHlli(hlli);

        // Free up the list's resources
        LLChlleDestroyLl(hlli);
    }

    ListOfDbgLists.RemoveAll();
}

HLLI
OSDAPI
LDSLLHlliInit (
#ifdef OSDEBUG4
    DWORD cb,
#else
    UINT cb,
#endif
    LLF llf,
    LPFNKILLNODE lpfnKillNode,
    LPFNFCMPNODE lpfnCmpNode
) {
    HLLI hlli = LLHlliInit ( cb, llf, lpfnKillNode, lpfnCmpNode );

    if (hlli) {
        // Store the HLLI in our list of all HLLIs which were
        // created by the debugging DLLs, so that we can delete
        // it ourselves later if necessary.

#ifdef _DEBUG
        WORD value;
        // this HLLI shouldn't already be in the list
        ASSERT(!ListOfDbgLists.Lookup( (void*) hlli, value ));
#endif

        ListOfDbgLists [ (void*) hlli ] = 0;
    }

    return hlli;
}

HLLE
OSDAPI
LDSLLHlleCreate (
    HLLI hlli
    )
{
    return LLHlleCreate ( hlli );
}

void
OSDAPI
LDSLLAddHlleToLl (
    HLLI hlli,
    HLLE hlle
    )
{
    LLAddHlleToLl ( hlli, hlle );
}

void
OSDAPI
LDSLLInsertHlleInLl (
    HLLI hlli,
    HLLE hlle,
    DWORD dword
    )
{

    LLInsertHlleInLl ( hlli, hlle, dword );
}

BOOL
OSDAPI
LDSLLFDeleteHlleFromLl (
    HLLI hlli,
    HLLE hlle
    )
{

    return LLFDeleteHlleFromLl ( hlli, hlle );
}

HLLE
OSDAPI
LDSLLHlleFindNext (
    HLLI hlli,
    HLLE hlle
    )
{
    return LLHlleFindNextFast ( hlli, hlle );
}

DWORD
OSDAPI
LDSLLChlleDestroyLl (
    HLLI hlli
    )
{

    // Since the creator has now destroyed this list, we no longer
    // need to keep track of it for the purpose of destroying it
    // ourselves later.
    ListOfDbgLists.RemoveKey( (void*) hlli );

    return LLChlleDestroyLl ( hlli );
}

HLLE
OSDAPI
LDSLLHlleFindLpv ( HLLI hlli, HLLE hlle, LPV lpv, DWORD dword )
{

    return LLHlleFindLpv ( hlli, hlle, lpv, dword );
}

DWORD
OSDAPI
LDSLLChlleInLl ( HLLI hlli ) 
{
    return LLChlleInLl ( hlli );
}

LPV
OSDAPI
LDSLLLpvFromHlle ( HLLE hlle ) 
{
    return LLLpvFromHlle ( hlle );
}

HLLE
OSDAPI
LDSLLHlleGetLast ( HLLI hlli ) 
{
    return LLHlleGetLast ( hlli );
}

void
OSDAPI
LDSLLHlleAddToHeadOfLI ( HLLI hlli, HLLE hlle ) 
{

    LLHlleAddToHeadOfLI ( hlli, hlle );
}

BOOL
OSDAPI
LDSLLFRemoveHlleFromLl ( HLLI hlli, HLLE hlle ) 
{
    return LLFRemoveHlleFromLl ( hlli, hlle );
}

/***************************************************************************
 *                                                                         *
 *  Callback handling routines                                             *
 *                                                                         *
 ***************************************************************************/

BOOL
HasSource(
    ADDR    addr
    )
{
    WORD  wLine;
    SHOFF dbLine;
    CXT cxt;

    if ( !ADDR_IS_LI( addr ) ) {
        SYUnFixupAddr ( &addr );
    }

    if ( SHSetCxtMod ( &addr, &cxt ) ) {
        emiAddr ( addr ) = emiAddr ( cxt.addr );
#if 0
		// REVIEW: this is the CORRECT usage of SLLineFromAddr
        return SLLineFromAddr ( &addr, &wLine, NULL, &dbLine );
#else
		// this is bad
        SLLineFromAddr ( &addr, &wLine, NULL, &dbLine );
		return (wLine != 0);
#endif
    } else {
        return FALSE;
    }
}

void
AddThread(
    HPID    hpid,
    HTID    htid
    )
{
    HPRC          hprc  = HprcFromHpid ( hpid );
    HTHD          hthd  = 0;
    LPTHD         lpthd = NULL;
    unsigned long tid   = 0;
    BOOL          fHasThreads;


    // OD4 and !OD4 both process the mtrcTidValue message

    //
    // HACK, REVIEW: using OSDGetDebugMetric here instead of
    // OSDGetThreadStatus because of a synchronization problem in the
    // TCP/IP TL.  During a callback, it is not possible to have another
    // thread call into the TL.  Therefore, we cannot use OSDGetThreadStatus
    // which ends up doing a request (tlfRequest).  We need to look at this
    // problem more closely

#if 1                   // !(defined (OSDEBUG4))
    OSDGetDebugMetric ( hpid, htid, mtrcTidValue, &tid );
#else
    {
       TST tst;
       VERIFY(OSDGetThreadStatus( hpid, htid, &tst) == xosdNone);
       tid = tst.dwThreadID;
    }
#endif

    hthd = HthdFromHtid ( hprc, htid );

    if ( hthd == 0 ) {

    hthd =  LLHlleCreate ( LlthdFromHprc ( hprc ) );
    lpthd = (LPTHD)LLLpvFromHlle ( hthd );

    lpthd->htid = htid;
    lpthd->tid  = tid;

    LLInsertHlleInLl ( LlthdFromHprc ( hprc ), hthd, cmpLpthd );
    }
    else {
    lpthd = (LPTHD)LLLpvFromHlle ( hthd );
    }

    lpthd->tdf = tdfUnknown;

    UnlockHlle ( hthd );

    VERIFY(OSDGetDebugMetric( hpid, htid, mtrcThreads, &fHasThreads ) == xosdNone);
    if ( htidCurr == hmemNull || !fHasThreads ) {
    SethtidCurr ( htid );
    }
}


void
ProgLoad (
    HPRC hprcParent,
    HPID hpid,
    HTID htid,
    LSZ  lszName,
    BOOL fReallyNew
    )
{
    char rgchName [ _MAX_CVPATH ];
    HPRC hprc;
    HTHD hthd;
    PID  pid;

    _ftcscpy ( rgchName, lszName );

    SYCreateHprc ( rgchName, NULL, hprcParent, hpid );

    lpprcCurr->fLoaded = TRUE;
    lpprcCurr->fReallyNew = fReallyNew;
    lpprcCurr->hprcParent = hprcParent;

    AddThread ( hpid, htid );
    SethtidCurr ( htid );
    lpprcCurr->hthdCurr = hthdCurr;

    if ( fReallyNew ) {
    lpprcCurr->stp = stpNotStarted;
    }
    else {
    lpprcCurr->stp = stpStopped;
    }

#if !(defined (OSDEBUG4))
    OSDGetDebugMetric ( hpidCurr, htidNull, mtrcPidValue, &pid );
#else
    {
        PST pst;
        if (OSDGetProcessStatus(hpidCurr, &pst) == xosdNone) {
            pid = pst.dwProcessID;
        }
        else ASSERT(FALSE);
    }
#endif
    lpprcCurr->pid = pid;

    set_addrs ( );
    SYGetAddr ( hpidCurr, htidCurr, adrData, &dump_start_address );
    SYGetAddr ( hpidCurr, htidCurr, adrPC, &asmaddr );

    // If this really is a new process, we'll mention it to the user.  (It
    // might not really be new if, for example, a CVW user hit ctrl-alt-
    // sysreq while some process other than the debuggee was running, and
    // this is the first time we've seen this process.)
    if (fReallyNew) {

    hprc = HprcFromHpid ( hpid );
    hthd = HthdFromHtid ( hprc, htid );
    fEnvirGbl.fAll = 0;
    UpdateUserEnvir ( mCtxtIp | mAsmaddr );

    CVMessage (
        INFOMSG,
        (MSGID) "New Process: %Fs",
        CMDWINDOW,
        lszName
    );

    SYSetContext ( hprcParent, 0, FALSE );

    SYContinue ( hprcParent );
    SYSetContext ( hprc, 0, TRUE );
    }
}

/***************************************************************************
 *                                                                         *
 *                           DEBUGGEE ROUTINES                             *
 *                                                                         *
 ***************************************************************************/

/*** DHGetDebuggeeBytes
*
*   Purpose: To read bytes from the debuggee.
*
*   Input:
*   paddr - A debuggee's address to read from.
*   cb    - The number of bytes to read.
*
*   Output:
*   bBuff - A place to read the byte to.
*
*   Returns:
*   The number of bytes actually read.
*
*   Exceptions:
*
*   Notes:
*
*************************************************************************/
size_t LOADDS PASCAL
DHGetDebuggeeBytes( ADDR addr, size_t cb, void FAR *bBuff ) {
    int terrno = errno;
    DWORD cbT = 0;
    XOSD xosd;

    if ( ADDR_IS_LI ( addr ) ) {
    SYFixupAddr ( &addr );
    }

    // check (native) addresses are 32-bit, flat, protected mode
    ASSERT( addr.mode.fSql || addr.mode.fJava || (ADDR_IS_FLAT( addr ) && ADDR_IS_OFF32( addr) && !ADDR_IS_REAL( addr ) ) );

    xosd = OSDReadMemory(hpidCurr, htidCurr, &addr, (LPBYTE)bBuff, cb, &cbT);
    errno = terrno;
    return (size_t) (xosd != xosdNone ? 0 : cbT);
}

/*** DHPutDebuggeeBytes
*
*   Purpose: To +write bytes to the debuggee.
*
*   Input:
*   paddr - A debuggee's address to write to.
*   cb    - The number of bytes to write.
*
*   Output:
*   bBuff - The bytes to write.
*
*   Returns:
*   The number of bytes actually written.
*
*   Exceptions:
*
*   Notes:
*
*************************************************************************/
size_t LOADDS PASCAL
DHPutDebuggeeBytes( ADDR addr, size_t cb, void FAR *bBuff ) {
    int terrno = errno;

    if ( lpprcCurr->stp == stpStopped || lpprcCurr->stp == stpNotStarted ) {

    if ( ADDR_IS_LI ( addr ) ) {
        SYFixupAddr ( &addr );
    }
    {
            // check (native) addresses are 32-bit, flat, protected mode
            ASSERT( addr.mode.fSql || addr.mode.fJava || (ADDR_IS_FLAT( addr ) && ADDR_IS_OFF32( addr) && !ADDR_IS_REAL( addr ) ) );

            DWORD cbWritten;
            if (OSDWriteMemory( hpidCurr, htidCurr, &addr, (LPBYTE)bBuff, cb, &cbWritten) != xosdNone) {
                cb = 0;
            }
            else {
                cb = cbWritten;
            }
        }
    CLFreeWalkbackStack( FALSE );
    }
    else {
    cb = 0;
    }

    errno = terrno;
    return cb;
}



VOID CALLBACK
FuncExecTimerProc(
    HWND,
    UINT,
    UINT,
    DWORD
    )
/*++

Routine Description:

    The function exec has not returned for a long time.  We will stop the
    execution of the function in case if has gone into an infinte loop.

--*/
{
    HTHD    hthd = NULL;
    HPRC    hprc = hprcCurr;
    LPTHD   lpthd;
    LPPRC   lpprc;
    XOSD    xosd = xosdNone;
    
    hthd = HthdFromHtid (hprc, htidCurr);
    lpthd = (LPTHD) LLLpvFromHlle (hthd);
    lpprc = (LPPRC) LLLpvFromHlle (hprc);

    // the process could've died since this we set this timer
    
    if (lpthd == NULL || lpthd->tdf == tdfDead ||
        lpprc == NULL || lpprc->stp == stpDead || lpprc->stp == stpRunning)
    {
        UnlockHlle (hthd);
        UnlockHlle (hprc);
        return;
    }

    if (lpprc->fFuncExec)
    {
        KillTimer (NULL, lpprc->funcExecTimerID);
        lpprc->funcExecTimerID = 0;
    }

    xosd = OSDAsyncStop (hpidCurr, TRUE);

    UnlockHlle (hthd);
    UnlockHlle (hprc);
}       

SHFLAG PASCAL
DHSetupExecute(
    LPHIND  lphdep
    )
/*++

Routine Description:

    This function is called from the expression evaluator to setup things
    up for a function evaluation call.  This request is passed on to the
    execution model.

Arguments:

    lphdep      - Supples a pointer to where a handle is returned

Return Value:

    FALSE on failure.

--*/

{
    HTHD    hthd;
    HPRC    hprc;
    LPTHD   lpthd;
    LPPRC   lpprc;
    XOSD    xosd;
    

    hprc = hprcCurr;
    hthd = HthdFromHtid (hprc, htidCurr);
    lpthd = (LPTHD) LLLpvFromHlle (hthd);
    lpprc = (LPPRC) LLLpvFromHlle (hprc);

    if (lpthd == NULL || lpthd->tdf == tdfDead ||
        lpprc == NULL || lpprc->stp == stpDead || lpprc->stp == stpRunning)
    {
        UnlockHlle (hthd);
        UnlockHlle (hprc);
        return FALSE;
    }

    xosd = OSDSetupExecute (lpprc->hpid, lpthd->htid, lphdep);
    
    UnlockHlle (hthd);
    UnlockHlle (hprc);

    return (xosd == xosdNone);
}



SHFLAG PASCAL
DHStartExecute(
    HIND     hdep,
    LPADDR   lpaddr,
    BOOL     fIgnoreEvents,
    SHCALL   shcall
    )
/*++

Routine Description:

    This function is called when the expression evaluator starts
    the debugging running a function evaluation.  It must be preceded
    by a call to DHSetupExecute.

Arguments:

    hdep        - Supplies the handle to the Execute Function object
    lpaddr      - Supplies the address to start execution at
    fIgnoreEvents - Supplies
    fFarRet     - Supplies TRUE if a far return should be executed

Return Value:

    FALSE if something fails

--*/

{
    XOSD            xosd = xosdNone;
    HTHD            hthd = NULL;
    HPRC            hprc = NULL;
    LPTHD           lpthd;
    LPPRC           lpprc;

    hprc = hprcCurr;
    hthd = HthdFromHtid (hprc, htidCurr);
    lpthd = (LPTHD) LLLpvFromHlle (hthd);
    lpprc = (LPPRC) LLLpvFromHlle (hprc);

    if (lpthd == NULL || lpthd->tdf == tdfDead ||
        lpprc == NULL || lpprc->stp == stpDead || lpprc->stp == stpRunning)
    {
        UnlockHlle (hthd);
        UnlockHlle (hprc);
        return FALSE;
    }

    PrimeDbgMessagePump();

    xosd = OSDStartExecute (lpprc->hpid,
                            hdep,
                            lpaddr,
                            fIgnoreEvents,
                            shcall == SHFar);

    if (xosd != xosdNone) {
        UnlockHlle (hthd);
        UnlockHlle (hprc);
        return FALSE;
    }

    SYFlipScreen (lpprc->hpid, lpthd->htid, CHILDSCREEN, TRUE);

    ASSERT (lpprc->funcExecTimerID == 0);
    lpprc->fFuncExec = TRUE;
    lpprc->funcExecTimerID = SetTimer (NULL, 0, 15 * SECONDS, FuncExecTimerProc);

    DbgMessagePump (FALSE);  // don't pump UI messages as EE not re-entrant

    lpprc->fFuncExec = FALSE;

    if (lpprc->funcExecTimerID != 0)
    {
        KillTimer (NULL, lpprc->funcExecTimerID);
        lpprc->funcExecTimerID = 0;
    }

    UnlockHlle (hthd);
    UnlockHlle (hprc);
    
    return (xosd == xosdNone);
}



SHFLAG PASCAL
DHCleanUpExecute(
    HIND   hdep
    )

/*++

Routine Description:

    This function is used to clean up after doing a function evalution.

Arguments:

    hdep - Supplies the handle to the function evaluation object

Return Value:

    TRUE if something fails

--*/

{
    LPPRC   lpprc;
    XOSD    xosd;

    lpprc = (LPPRC) LLLpvFromHlle (hprcCurr);

    if (lpprc == NULL) {
        return FALSE;
    }
    
    xosd = OSDCleanUpExecute (lpprc->hpid, hdep);

    UnlockHlle (hprcCurr);
    return (xosd == xosdNone);
}


/*** DHGetReg
*
* Purpose: To get a register from the debuggee.
*
*   Input:
*   pReg  The register structure. The member hReg must contain
*       the handle to the register to get.
*
*   pCxt  The context packet to use.
*
*   Output:
*   pReg  The Register field is filled in.
*
*   Returns:
*   pReg if successful, NULL if the call could not be completed.
*
*   Exceptions:
*
*   Notes:
*   Currently the 8087 registers are not implemented. In the future
*   only ST0 will be implemented.
*
*************************************************************************/
PSHREG LOADDS PASCAL
DHGetReg(
    PSHREG  pReg,
    PCXT    pCxt
    )
{
    XOSD    xosd;

    // NOTE: we can get GetReg calls when we are not debugging.
    
    if (!DebuggeeAlive ()) {
        return NULL ;
    }
        
    xosd = OSDReadRegister (hpidCurr,
                            htidCurr,
                            pReg->hReg,
                            &pReg->Byte1);

    if (xosd != xosdNone) {
        return NULL;
    }

    
    return pReg;
}

/*** DHSetReg
*
*   Purpose: To set a register in the debuggee.
*
*   Input:
*   pReg  The register structure. The member hReg must contain
*       the handle to the register to set.
*
*   pCxt  The context packet to use.
*
*   Output:
*
*   Returns:
*   pReg if successful, NULL if the call could not be completed.
*
*   Exceptions:
*
*   Notes:
*   Currently the 8087 registers are not implemented. In the future
*   only ST0 will be implemented.
*
*************************************************************************/
PSHREG LOADDS PASCAL
DHSetReg(
    PSHREG  pReg,
    PCXT    pCxt
    )
{
    XOSD    xosd;
    
    // IDE evaluates expression even if debuggee not started

    if (!DebuggeeAlive ()) {
        return NULL;
    }

	if (!lpprcCurr->IsBeyondEntryPoint())
		return NULL;

    CLFreeWalkbackStack (FALSE);
    
    xosd = OSDWriteRegister (hpidCurr,
                             htidCurr,
                             pReg->hReg,
                             (void*)&pReg->Byte1);

    if (xosd != xosdNone) {
        return NULL;
    }

    set_addrs();
    return pReg;
}


int   reg87Size( void );
void *reg87Save( void );
void  reg87Restore( void FAR * );
void  reg87Reset( void );


/*** DHSaveReg
*
* Purpose: To save the debuggee resgister set
*
* Input:
*   pCxt  The context packet to use.
*
* Output:  register set saved in memory block pReg
*
*   Returns:
*   pReg if successful, NULL if the call could not be completed.
*
*   Exceptions:
*
*   Notes:
*   Currently the 8087 registers are not implemented. In the future
*   only ST0 will be implemented.
*
*************************************************************************/
HMEM LOADDS PASCAL
DHSaveReg(
    PCXT    pCxt
    )
{
    HMEM    hReg = (HMEM)NULL;
    XOSD    xosd;

    if ( DebuggeeAlive() ) {
        xosd = OSDSaveRegs (hpidCurr, htidCurr, (LPHIND)&hReg);
    }

    if (xosd != xosdNone) {
        return NULL;
    }

    return hReg;
}

/*** DHRestoreReg
*
* Purpose: To restore the debuggee register set
*
*   Input:
*   pReg  the memory handle of the register set returned by DHSaveReg.
*       the memory handle will be freed at the end of the call
*
*   pCxt  The context packet to use.
*
* Output:
*
*   Returns:
*   none
*
*   Exceptions:
*
*   Notes:
*   Currently the 8087 registers are not implemented. In the future
*   only ST0 will be implemented.
*
*************************************************************************/
VOID LOADDS PASCAL
DHRestoreReg(
    HMEM    hReg,
    PCXT    pCxt
    )
{
    XOSD    xosd;
    
    if( DebuggeeAlive()) {
        CLFreeWalkbackStack (FALSE);
    xosd = OSDRestoreRegs (hpidCurr, htidCurr, (HIND)hReg);

        if (xosd != xosdNone) {
            return ;
        }

        
        if (wModelTemp != lpprcCurr->wEM) {

        // Return to native if we left it
        SYNativeOnly ( FALSE );
        }
    }
}

void
SYSetFrame(
    FRAME*  pFrame
    )
{
    XOSD    xosd;
    ADDR    addrBase = {0};
    ADDR    addrData = {0};

    xosd = SYGetAddr  (hpidCurr, htidCurr, adrBase, &addrBase);

    if (xosd != xosdNone) {
        return ;
    }
    
    SYFixupAddr (&addrBase);

    xosd = SYGetAddr (hpidCurr, htidCurr, adrData, &addrData);

    if (xosd != xosdNone) {
        return ;
    }
    
    SYFixupAddr ( &addrData );

    SetFrameBPOff ( *pFrame, GetAddrOff ( addrBase ) );
    FrameFlat ( cxfIp.Frame ) = ADDR_IS_FLAT ( addrBase );
    FrameOff32 ( cxfIp.Frame ) = ADDR_IS_OFF32 ( addrBase );

    SetFrameBPSeg ( *pFrame, GetAddrSeg ( addrBase ) );
    pFrame->SS  = (SEG16) GetAddrSeg ( addrBase );
    pFrame->DS  = (SEG16) GetAddrSeg ( addrData );
    pFrame->PID = hpidCurr;
    pFrame->TID = htidCurr;
}

int
SYCmpAddr(
    LPADDR  lpaddr1,
    LPADDR  lpaddr2
    )
{
    SEGMENT seg1 = GetAddrSeg ( *lpaddr1 );
    SEGMENT seg2 = GetAddrSeg ( *lpaddr2 );

#ifdef _DEBUG
    ADDR addrNil = {0};
#endif

    ASSERT ( ( ADDR_IS_LI ( *lpaddr1 ) == ADDR_IS_LI ( *lpaddr2 ) ) ||
             ( _fmemcmp(lpaddr1, &addrNil, sizeof(ADDR)) == 0 ) ||
             ( _fmemcmp(lpaddr2, &addrNil, sizeof(ADDR)) == 0 ) );

    if ( ( seg1 != seg2 ) ||
     ( emiAddr ( *lpaddr1 ) != emiAddr ( *lpaddr2 ) ) ||
     ( GetAddrOff ( *lpaddr1 ) < GetAddrOff ( *lpaddr2 ) ) )
    {
        return -1;
    }
    else if (GetAddrOff ( *lpaddr1 ) > GetAddrOff ( *lpaddr2 ))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

void
SYSetAddr(
    HPID    hpid,
    HTID    htid,
    ADR     adr,
    LPADDR  lpaddr
    )
{

    if ( ADDR_IS_LI ( *lpaddr ) ) {
        SYFixupAddr ( lpaddr );
        OSDSetAddr ( hpid, htid, adr, lpaddr );
        SYUnFixupAddr ( lpaddr );
    }
    else {
        OSDSetAddr ( hpid, htid, adr, lpaddr );
    }
}

void
SYUnassemble(
    HPID    hpid,
    HTID    htid,
    LPSDI   lpsdi
    )
{
    XOSD    xosd;
    
    if ( ADDR_IS_LI ( lpsdi->addr ) ) {
        SYFixupAddr ( &lpsdi->addr );
    }

    xosd = OSDUnassemble ( hpid, htid, lpsdi);

    if (xosd != xosdNone) {
        return ;
    }

    if ( !ADDR_IS_LI ( lpsdi->addr ) ) {
        SYUnFixupAddr ( &lpsdi->addr );
    }
}

void SYFormatSdi ( LPSDI lpsdi, char * pch, BOOL fIgnoreEA ) {
    DOP dop = lpsdi->dop;
    char *pchBeg = pch, *pchPrev;
#if defined(_M_MRX000)
    const int CCHRAW = 9;
#else
    const int CCHRAW = 21;
#endif

    pch += sprintf (
    pch,
    "%Fs %-*.20Fs%-9Fs %Fs %Fs %Fs",
    ( dop & dopAddr ) && lpsdi->ichAddr != -1 ?
        &lpsdi->lpch [ lpsdi->ichAddr ] :
        (LPCH) " ",
        ( dop & dopRaw ) && lpsdi->ichBytes != -1 ? CCHRAW : 2,
    ( dop & dopRaw ) && lpsdi->ichBytes != -1 ?
        &lpsdi->lpch [ lpsdi->ichBytes ] :
        (LPCH) "",
     lpsdi->ichOpcode != -1 ?
        &lpsdi->lpch [ lpsdi->ichOpcode ] :
        (LPCH)"???",
        lpsdi->ichOperands != -1 ?
        &lpsdi->lpch [ lpsdi->ichOperands ] :
        (LPCH) "",
    lpsdi->ichComment != -1 ?
        &lpsdi->lpch [ lpsdi->ichComment ] :
        (LPCH) "",
    !fIgnoreEA && lpsdi->ichEA0 != -1 ?
        &lpsdi->lpch [ lpsdi->ichEA0 ] :
        (LPCH) ""
    );

    // strip pesky trailing blanks
    while ( *(pchPrev = _ftcsdec(pchBeg, pch)) == ' ')
    pch = pchPrev;
    *pch = '\0';
}


XOSD
SYAssemble(
    LPADDR  lpaddr
    )
{
    return OSDAssemble ( hpidCurr, htidCurr, lpaddr, NULL );
}

BOOL
SYGetPrevInst(
    HPID    hpid,
    HTID    htid,
    PADDR   paddr
    )
{
    UOFFSET uoff;
    BOOL fReturn = FALSE;

    ASSERT ( ADDR_IS_LI ( *paddr ) );

    SYFixupAddr ( paddr );
    fReturn = OSDGetPrevInst ( hpid, htid, paddr, &uoff );

    if ( emiAddr ( *paddr ) ) {
        if ( !SYUnFixupAddr ( paddr ) ) {
           return( -1 ); // for DAMFillAsmFromNext
        }
    }

    return fReturn;
}

void
SYSetEmi(
    HPID    hpid,
    HTID    htid,
    LPADDR  lpaddr
    )
{
    ASSERT ( ! ADDR_IS_LI ( *lpaddr ) );
    VERIFY ( OSDSetEmi( hpid, htid, lpaddr ) == xosdNone );
}



XOSD
SYGetAddr(
    HPID    hpid,
    HTID    htid,
    ADR     adr,
    LPADDR  lpaddr
    )
{
    XOSD    xosd;

    // Clear the segment part of the addr.
    // This is an added safety measure for 32-bit segments:
    // we'll clear the segment before calling OSDGetAddr, so if only the
    // bottom two bytes are filled in, the segment will still be valid

    GetAddrSeg(*lpaddr) = 0;

    xosd = OSDGetAddr (hpid, htid, adr, lpaddr);

    if (xosd != xosdNone) {
        return xosd;
    }

    ADDR_IS_LI ( *lpaddr ) = FALSE;

    if (emiAddr (*lpaddr)) {
        SYUnFixupAddr (lpaddr);
    }

    return xosd;
}

/*  SYFlipScreen
 *
 *  Purpose:  Flip the screen between the debugger and CV, if local, or display
 *        the debuggee if remote
 *
 *  Input:  fScreen - True if you want the OS screen, false if you want the
 *            CV screen
 *      fCmd  - True if OSDebug CMD that requested the screen flip is
 *            a command that should always flip
 */

BOOL fSmartSwap = TRUE;
BOOL fLastScreen = FALSE;
BOOL fLocalTransport = TRUE;

void
SYFlipScreen(
    HPID    hpid,
    HTID    htid,
    BOOL    fScreen,
    BOOL    fCmdType
    )
{
    HPRC hprc;

    StartTimer (itmSYFlipScreen);

    if ( hpid != hpidNull && ( hprc = HprcFromHpid ( hpid ) ) ) {

        LPPRC lpprc = (LPPRC)LLLpvFromHlle ( hprc );
        BOOL fFuncExec = lpprc->fFuncExec;

        UnlockHlle ( hprc );
        if ( fFuncExec ) {

            // don't flip if we are executing a function for the EE
            return;
        }
    }

    if ( flip_or_swap )
    {
        if ( fCmdType || ! ( !fCmdType && fSmartSwap ) ||
            ( !fCmdType && !fSmartSwap) )
        {
            if ( !fLocalTransport )
            {
                // remote operation
                VERIFY(OSDShowDebuggee( hpid, fScreen) == xosdNone);
            }
            else
            {
                // Local operation: only flip if we have to.
                
                if ( fLastScreen != fScreen)
                {
                    fLastScreen = fScreen;

                        if ( fScreen == CHILDSCREEN )
                        {
                            dos_screen();
                        }
                        else
                        {
                            island_screen();
                        }
                }
            }
        }
    }
    
    StopTimer (itmSYFlipScreen);
}

HLLI LlthdFromHprc ( HPRC hprc ) {

    if (hprc != 0 && hprc == hprcCurr) {    // optimization
        return lpprcCurr->llthd;
    }
    else {
        LPPRC lpprc;
        HLLI  hlli;
        ASSERT ( hprc != (HPRC) NULL );

        lpprc = (LPPRC)LLLpvFromHlle ( hprc );
        hlli = lpprc->llthd;
        UnlockHlle ( hprc );

        return hlli;
    }
}

HTID HtidFromHthd ( HTHD hthd ) {

    LPTHD lpthd;
    HTID  htid = htidNull;

    if ( hthd != hmemNull ) {
    lpthd = (LPTHD)LLLpvFromHlle ( hthd );
    htid = lpthd->htid;
    UnlockHlle ( hthd );
    }

    return htid;
}

unsigned long TidFromHthd ( HTHD hthd ) {
    unsigned long tid = 0;
    LPTHD lpthd;

    if ( hthd != (HTHD) NULL ) {
    lpthd = (LPTHD)LLLpvFromHlle ( hthd );

    tid = lpthd->tid;
    UnlockHlle ( hthd );
    }

    return tid;
}

HTID HtidFromTid ( HPRC hprc, unsigned long tid ) {

    return HtidFromHthd (
    LLHlleFindLpv ( LlthdFromHprc ( hprc ), hmemNull, &tid, cmpTid )
    );
}

unsigned long TidFromHtid ( HPRC hprc, HTID htid ) {

    return TidFromHthd ( HthdFromHtid ( hprc, htid ) );
}

HTHD HthdFromHtid ( HPRC hprc, HTID htid ) {

    if ( htid != 0 ) {
    return LLHlleFindLpv (
        LlthdFromHprc ( hprc ),
        hmemNull,
        &htid,
        cmpHtid
    );
    }
    else {
    return (HTHD) NULL;
    }
}

HTHD HthdFromTid ( HPRC hprc, unsigned long tid ) {

    return HthdFromHtid ( hprc, HtidFromTid ( hprc, tid ) );
}

HTHD GetNthThread ( WORD ithd ) {
    HTHD hthd = hmemNull;

    for ( hthd = LLHlleFindNext ( LlthdFromHprc ( hprcCurr ), hmemNull );
      hthd != hmemNull;
      hthd = LLHlleFindNext ( LlthdFromHprc ( hprcCurr ), hthd ) ) {

    if ( ithd == 0 ) {
        break;
    }

    ithd -= 1;
    }

    return hthd;
}

unsigned long PidFromHprc ( HPRC hprc ) {

    if (hprc != 0 && hprc == hprcCurr) {    // optimization
        return lpprcCurr->pid;
    }
    else {
        unsigned long pid = 0;

        if ( hprc != (HPRC) NULL ) {
            LPPRC lpprc = (LPPRC)LLLpvFromHlle ( hprc );

            pid = lpprc->pid;

            UnlockHlle ( hprc );
        }

        return pid;
    }
}

HPID HpidFromPid ( unsigned long pid ) {

    return HpidFromHprc ( HprcFromPid ( pid ) );
}

HPID HpidFromHprc ( HPRC hprc ) {

    if (hprc != 0 && hprc == hprcCurr) {    // optimization
        return lpprcCurr->hpid;
    }
    else {
        HPID hpid = hpidNull;

        if ( hprc != (HPRC) NULL ) {
            LPPRC lpprc = (LPPRC)LLLpvFromHlle ( hprc );

            hpid = lpprc->hpid;

            UnlockHlle ( hprc );
        }

        return hpid;
    }
}

HPRC HprcFromHpid ( HPID hpid ) {

    return LLHlleFindLpv ( llprc, 0, &hpid, cmpHpid );
}

HPRC HprcFromPid ( unsigned long pid ) {

    return LLHlleFindLpv ( llprc, 0, &pid, cmpPid );
}

unsigned long PidFromHpid ( HPID hpid ) {
    PID pid = 0;

    if ( hpid != hpidNull ) {
#if !(defined (OSDEBUG4))
    OSDGetDebugMetric ( hpidCurr, htidNull, mtrcPidValue, &pid );
#else
        PST pst;
        if (OSDGetProcessStatus(hpidCurr, &pst) == xosdNone) {
            pid = pst.dwProcessID;
        }
        else ASSERT(FALSE);
#endif
    }

    return (ULONG) pid;
}

int PASCAL TDCompare ( LPTHD lpthd, unsigned long FAR *lpl, LONG l ) {

    switch ( l ) {

    case cmpHtid:

        if ( lpthd->htid == * ( (HTID FAR *) lpl ) ) {
        return fCmpEQ;
        }
        else {
            return fCmpLT;
        }
        break;

    case cmpTid:

    if ( lpthd->tid < *lpl ) {
        return fCmpLT;
        }
    else if ( lpthd->tid > *lpl ) {
        return fCmpGT;
    }
    else {
        return fCmpEQ;
    }
    break;

    case cmpLpthd: {
        LPTHD lpthd2 = (LPTHD) lpl;

        if ( lpthd->tid < lpthd2->tid ) {
        return fCmpLT;
        }
        else if ( lpthd->tid > lpthd2->tid ) {
        return fCmpGT;
        }
        else {
        return fCmpEQ;
        }
    }
    break;

    default:

        return fCmpGT;
    }
}

VOID FAR PASCAL PDKill ( LPV lpv ) {
    LPPRC lpprc = (LPPRC) lpv;

    if ( lpprc->szTitle ) {
    free ( lpprc->szTitle );
    }
    if ( lpprc->szName ) {
    free ( lpprc->szName );
    }
    if ( lpprc->szArgs ) {
    free ( lpprc->szArgs );
    }

    if ( lpprc->llthd ) {
    LLChlleDestroyLl ( lpprc->llthd );
    }
}

static int PASCAL PDCompare ( LPV lpv, unsigned long FAR *lpl, LONG l ) {
    LPPRC lpprc = (LPPRC) lpv;

    switch ( l ) {

    case cmpHpid:

        if ( lpprc->hpid == * ( (HPID FAR *) lpl ) ) {
        return fCmpEQ;
        }
        else {
        return fCmpLT;
        }
        break;

    case cmpPid:

        if ( lpprc->pid == *lpl ) {
        return fCmpEQ;
        }
        else {
        return fCmpLT;
        }
        break;

    case cmpTitle:

        return _ftcsicmp ( lpprc->szTitle, (char FAR *) lpl );
        break;

    case cmpName:

        return _ftcsicmp ( lpprc->szName, (char FAR *) lpl );
        break;

    default:

        ASSERT ( FALSE );
    }
    return fCmpLT;
}

int  GetProcId ( char FAR * lsz, HPRC hprc, EPI epi, int isz ) {
    LPPRC lpprc = (LPPRC)LLLpvFromHlle ( hprc );
    int iReturn = 0;

    if ( epi == epiDefault ) {
    epi = epiDef;
    }

    switch ( epi ) {

       // We use epiDefault through epiDef to get control of
       // an invalid lpprc when no debugging session is started !
    case epiDefault :
        iReturn = 0 ;
        break ;

    case epiTitle:

        CVsprintf ( lsz, "%-8s", lpprc->szTitle );
        iReturn = 8;
        break;

    case epiName:

        _ftcsncpy ( lsz, lpprc->szName, isz );
        *(lsz+isz-1) = '\0';
        iReturn = _ftcslen ( lpprc->szName );
        break;

    case epiPID:

        CVsprintf ( lsz, "%04X", lpprc->pid );
        iReturn = 4;
        break;

    default:

        ASSERT ( FALSE );
        break;
    }

    UnlockHlle ( hprc );

    return iReturn;
}

int ProcStatus ( HPRC hprc, char *sz, int cbLen ) {
    LPPRC lpprc = (LPPRC)LLLpvFromHlle ( hprc );
    char  pchStatus[40];

    switch ( lpprc->stp ) {

    case stpRunning:

        LoadString( hInst, DBG_RUNNING, pchStatus, sizeof( pchStatus ) );
        break;

    case stpDead:

        LoadString( hInst, DBG_TERMINATED, pchStatus, sizeof( pchStatus ) );
        break;

    case stpNotStarted:

        LoadString( hInst, DBG_NOT_STARTED, pchStatus, sizeof( pchStatus ) );
        break;

    case stpStopped:

        LoadString( hInst, DBG_STOPPED, pchStatus, sizeof( pchStatus ) );
        break;

    case stpGone:

        LoadString( hInst, DBG_NOT_EXIST, pchStatus, sizeof( pchStatus ) );
        break;

    default:

        ASSERT ( FALSE );
        break;
    }

    sprintf (
    sz,
    "%04X  %-8s  %-10s  ",
    (WORD) lpprc->pid,
    lpprc->szTitle,
    pchStatus
    );

    _ftcsncat ( sz, lpprc->szName, cbLen - _ftcslen ( sz ) - 1 );

    UnlockHlle ( hprc );

    return TRUE;
}

BOOL SYAfterReturn ( STO sto, HPID hpid, HTID htid ) {
    BOOL fReturn = FALSE;
    LPPRC lpprc = NULL;
    HPRC hprc;
    XOSD xosd;

    ASSERT ( hpid != (HPID) NULL );

	//
	// Cannot step when crash dump debugging
	//
	
	if (IsCrashDump ()) {
		MessageBeep (0);
		return FALSE;
	}

    hprc = HprcFromHpid ( hpid );
    lpprc = (LPPRC)LLLpvFromHlle ( hprc );

    if ( lpprc->stp == stpNotStarted ) {
    lpprc->stp = stpStopped;
    }

    if ( lpprc->stp == stpStopped )
    {
        STP stp = lpprc->stp;
        EXP exp = lpprc->exp;
        HTID htidOld = lpprc->htidExecuting;
        BOOL fStepOver = lpprc->fStepOver;
        EXOP exop = {0};

        freeze_view();

        lpprc->stp = stpRunning;
        lpprc->exp = expAfterRet;
        lpprc->htidExecuting = htid;
        lpprc->fStepOver = TRUE;

        exop.fSetFocus = TRUE;  // Set the debuggee Focus and Active window
        exop.fStepOver = TRUE;
        exop.fSingleThread = !!(sto & stoOneThread);
        exop.fQueryStep = !!(sto & stoQueryStep);
        exop.fInitialBP = !!(sto & stoInitialBP);
        exop.fPassException = !!(sto & stoPassEx);
        exop.fReturnValues = runDebugParams.fReturnValues;

        PrimeDbgMessagePump();
        xosd = OSDReturnStep( hpid, htid, &exop);
        fReturn = (xosd == xosdNone);

        if(!fReturn) {
            // if this fails, then we need to restore the last state...
            lpprc->stp = stp;
            lpprc->exp = exp;
            lpprc->htidExecuting = htidOld;
            lpprc->fStepOver = fStepOver;
        }
        else {
            DbgMessagePump();
        }
    }

    UnlockHlle ( hprc );
    return fReturn;
}

BOOL SYSingleStep ( BOOL fOverCalls, STO sto, HPID hpid, HTID htid ) {
    BOOL fReturn = FALSE;
    LPPRC lpprc = NULL;
    HPRC hprc;
    XOSD xosd;

    ASSERT ( hpid != (HPID) NULL );

	//
	// cannot step in crash dump
	//
	
	if (IsCrashDump ()) {
		MessageBeep (0);
		return FALSE;
	}

    hprc = HprcFromHpid ( hpid );
    lpprc = (LPPRC)LLLpvFromHlle ( hprc );

    if ( lpprc->stp == stpNotStarted ) {
    lpprc->stp = stpStopped;
    }

    if ( lpprc->stp == stpStopped ) {
        EXOP exop = {0};

        freeze_view();
        lpprc->stp = stpRunning;
        lpprc->exp = expStep;
        lpprc->htidExecuting = htid;
        lpprc->fStepOver = fOverCalls;
        lpprc->sto = sto;

        exop.fStepOver = fOverCalls;
        exop.fSingleThread = !!(sto & stoOneThread);
        exop.fQueryStep = !!(sto & stoQueryStep);
        exop.fInitialBP = FALSE;
        exop.fPassException = !!(sto & stoPassEx);
        exop.fReturnValues = runDebugParams.fReturnValues;

        PrimeDbgMessagePump();
        xosd = OSDSingleStep( hpid, htid, &exop);
        fReturn = (xosd == xosdNone);

#if !(defined (OSDEBUG4))
        if (xosd == xosdBrokenPipe) {
            return FALSE;
        }
#endif
        if (!fReturn) {
            lpprc->stp = stpStopped;
        }
        else {
            DbgMessagePump();
        }
    }

    UnlockHlle ( hprc );
    return fReturn;
}

BOOL SYRangeStep (
    BOOL fOverCalls,
    STO  sto,
    ADDR addrStart,
    ADDR addrEnd,
    HPID hpid,
    HTID htid
) {
    BOOL fReturn = FALSE;
    LPPRC lpprc = NULL;
    HPRC hprc;
    XOSD xosd;

    ASSERT ( hpid != (HPID) NULL );

	//
	// Cannot step in crash dump
	//
	
	if (IsCrashDump ()) {
		MessageBeep (0);
		return FALSE;
	}
	
    StartTimer(itmSYRangeStep);

    hprc = HprcFromHpid ( hpid );
    lpprc = (LPPRC)LLLpvFromHlle ( hprc );

    if ( lpprc->stp == stpNotStarted ) {
    lpprc->stp = stpStopped;
    }

    if ( lpprc->stp == stpStopped ) {
        EXOP exop = {0};

        freeze_view();
        lpprc->stp = stpRunning;
        lpprc->exp = expRange;
        lpprc->htidExecuting = htid;
        lpprc->fStepOver = fOverCalls;
        lpprc->addrStart = addrStart;
        lpprc->addrEnd = addrEnd;
        lpprc->sto = sto;

        ASSERT ( ADDR_IS_LI ( addrStart ) );
        ASSERT ( ADDR_IS_LI ( addrEnd ) );

        SYFixupAddr ( &addrStart );
        SYFixupAddr ( &addrEnd );

        StartTimer(itmOSDRangeStep);

        exop.fStepOver = fOverCalls;
        exop.fSingleThread = !!(sto & stoOneThread);
        exop.fQueryStep = !!(sto & stoQueryStep);
        exop.fInitialBP = !!(sto & stoInitialBP);
        exop.fPassException = !!(sto & stoPassEx);
        exop.fReturnValues = runDebugParams.fReturnValues;

        PrimeDbgMessagePump();
        xosd = OSDRangeStep( hpid, htid, &addrStart, &addrEnd, &exop);
        fReturn = (xosd == xosdNone);

        if (!fReturn) {
            lpprc->stp = stpStopped;
        }
        else {
            DbgMessagePump();
        }

		StopTimer(itmOSDRangeStep);
    }


    UnlockHlle ( hprc );
    StopTimer(itmSYRangeStep);
    return fReturn;
}

BOOL SYGo ( const EXOP* pexop, HPID hpid, HTID htid ) {
    BOOL fReturn = FALSE;
    LPPRC lpprc = NULL;
    HPRC hprc;
    HTHD hthd;
    LPTHD lpthd;
    EXOP exop = {0};
    XOSD xosd;

	//
	// Crash dump can't go.
	//
	
	if (IsCrashDump ()) {
		MessageBeep (0);
		return FALSE;
	}
	
    exop = *pexop;
    pexop = NULL;   // from here to end of fn, use exop, not pexop

    ASSERT ( hpid != (HPID) NULL );

    hprc = HprcFromHpid ( hpid );
    lpprc = (LPPRC)LLLpvFromHlle ( hprc );

    // Must find a thread that isn't dead.
    //
    // [FUTURE: I'M NOT SURE IF THIS IS NECESSARY]
    hthd = HthdFromHtid ( hprc, htid );
    lpthd = (LPTHD)LLLpvFromHlle ( hthd );
    ASSERT (lpthd );
    if ( lpthd && lpthd->tdf & tdfDead ) {
        HLLI    llthd = LlthdFromHprc ( hprc );

        UnlockHlle ( hthd );
        hthd = 0;
        while ( (hthd = LLHlleFindNext(llthd, hthd)) != 0 ) {
            lpthd = (LPTHD)LLLpvFromHlle ( hthd );
            if (!(lpthd->tdf & tdfDead))
                break;
            UnlockHlle ( hthd );
        }
    }
    UnlockHlle ( hthd );

    if ( lpprc->stp == stpNotStarted ) {
    lpprc->stp = stpStopped;
    }

    if ( lpprc->stp == stpStopped ) {

        freeze_view();
        lpprc->stp = stpRunning;
        lpprc->exp = expGo;
        lpprc->htidExecuting = htid;
        lpprc->sto = exop.fSingleThread ? stoOneThread : stoNone;
        exop.fQueryStep = TRUE;
        PrimeDbgMessagePump();

        exop.fGo = TRUE;
        xosd = OSDGo(hpid, htid, &exop);
        fReturn = (xosd == xosdNone);

        if (!fReturn) {
            lpprc->stp = stpStopped;
        }
        else {
            DbgMessagePump();
        }
    }

    UnlockHlle ( hprc );

    return fReturn;
}

void SYContinue ( HPRC hprc ) {
    LPPRC lpprc = (LPPRC)LLLpvFromHlle ( hprc );
    HPID  hpid = lpprc->hpid;
    EXOP  exop = {0};                       // Set all fields to false

    exop.fSingleThread = !!( lpprc->sto & stoOneThread );
    exop.fStepOver = lpprc->fStepOver;
    exop.fPassException = !!(lpprc->sto & stoPassEx);
    exop.fQueryStep = !!(lpprc->sto & stoQueryStep);
    exop.fInitialBP = FALSE;
    exop.fReturnValues = runDebugParams.fReturnValues;

    switch ( lpprc->exp ) {

    case expStopped:
        break;

    case expGo:

            PrimeDbgMessagePump();
        if ( OSDGo( hpid, lpprc->htidExecuting, &exop ) != xosdNone ) {
                ASSERT ( FALSE );
            }
            else {
                DbgMessagePump();
            }
        break;

    case expStep:
            PrimeDbgMessagePump();
        if ( OSDSingleStep( hpid, lpprc->htidExecuting, &exop)
                != xosdNone ) {
                ASSERT ( FALSE );
            }
            else {
                DbgMessagePump();
            }
        break;

    case expRange: {
                ADDR addrStart = lpprc->addrStart;
                ADDR addrEnd = lpprc->addrEnd;

                SYFixupAddr ( &addrStart );
                SYFixupAddr ( &addrEnd );
                PrimeDbgMessagePump();
                if ( OSDRangeStep( hpidCurr, lpprc->htidExecuting, &addrStart,
                    &addrEnd, &exop) != xosdNone) {
                    ASSERT(FALSE);
                }
                else {
                    DbgMessagePump();
                }

        }
        break;

    case expAfterRet:
            PrimeDbgMessagePump();
        if ( OSDReturnStep( hpid, lpprc->htidExecuting, &exop)
                != xosdNone ) {
                ASSERT ( FALSE );
            }
            else {
                DbgMessagePump();
            }
        break;

    default:
        ASSERT ( FALSE );
        break;
    }

    UnlockHlle ( hprc );
}

void SYPause ( HPRC hprc ) {
    LPPRC lpprc = (LPPRC)LLLpvFromHlle ( hprc );

    if ( lpprc->stp != stpNotStarted ) {

        if (lpprc->stp != stpDead) {
            lpprc->stp = stpStopped;
        }

    lpprc->exp = expStopped;
    lpprc->fHitBP = TRUE;
    UnlockHlle ( hprc );

    BPFreeType ( BPTMP );

    fEnvirGbl.fs.user_pc = FALSE;
    fEnvirGbl.fs.ctxtIp = FALSE;

    UpdateUserEnvir ( mUserPc | mAsmaddr );
    }
    else {
        UnlockHlle ( hprc );
    }
}

void SYStop ( HPRC hprc ) {

    LPPRC lpprc = (LPPRC)LLLpvFromHlle ( hprc );
    BOOL  fFuncExec;
    BOOL  fDead;

    StartTimer(itmSYStop);

    if ( lpprc->stp != stpNotStarted ) {

        if (lpprc->stp != stpDead) {
            lpprc->stp = stpStopped;
        }

    lpprc->exp = expStopped;
    fFuncExec = lpprc->fFuncExec;
        fDead = (lpprc->stp == stpDead);
    lpprc->fHitBP = TRUE;
    UnlockHlle ( hprc );

        // [cuda#5172 6/23/93 mikemo]  Even if we're doing a function
        // execution, we still want to execute the below block if the
        // function execution caused the debuggee to die.
    if ( !fFuncExec || fDead ) {
        BPFreeType ( BPTMP );

        fEnvirGbl.fs.user_pc = FALSE;
        fEnvirGbl.fs.ctxtIp = FALSE;

        UpdateUserEnvir ( mUserPc | mAsmaddr );
    }
    }
    else {
    // If we're trying to stop a loaded app, assert and die.
    // Otherwise, the app load failed.  That's OK continue
    ASSERT( !lpprc->fLoaded );
    UnlockHlle ( hprc );
    }

    StopTimer(itmSYStop);
}


XOSD SYNativeOnly ( BOOL fNative ) {
    XOSD xosd = xosdNone;

    if ( lpprcCurr->stp == stpRunning ) {
        return xosdProcRunning;
    }
    xosd = OSDNativeOnly ( hpidCurr, htidCurr, fNative );
    CheckCallBack ( TRUE );

    return xosd;
}

/*** SYFixupAddr
*
* Purpose: To fixup and address packet
*
* Input:
*   pADDR - The address in question
*
* Output:
* Returns:
*   TRUE if address fixed up, FALSE otherwise.
*
* Exceptions:
*
* Notes:
*
*
*************************************************************************/

BOOL LOADDS PASCAL SYFixupAddr ( PADDR paddr ) {

    // If this ASSERT fires, it means the segment portion of the addr
    // was not cleared before using/constructing the addr.
    // We check the SQL and Java bits because Galileo and Jakarta set these
    // bits to identify their addr packets.
    ASSERT( modeAddr(*paddr).fSql == 1 || modeAddr(*paddr).fJava == 1 ||
            (GetAddrSeg(*paddr) & 0xFFFF0000) == 0 );

#ifndef _SHIP
    // To help catch the case where the upper two bytes of a seg are
    // not zero, we'll put up a message box to alert the user.
    if (modeAddr(*paddr).fSql == 0 && modeAddr(*paddr).fJava == 0 && (GetAddrSeg(*paddr) & 0xFFFF0000) != 0) {
        if (MsgBox(Error, "Warning! ADDR packet detected with two high bytes non-zero. Please contact the Jakarta Debugger team. (Click Cancel to debug.)", MB_OKCANCEL) == IDCANCEL) {
            DebugBreak();
        }
    }
#endif

    // Clear the upper two bytes of the segment (if the addr isn't SQL or Java).
    // This is an added safety measure for 32-bit segments:
    // we'll clear the upper two bytes to help eliminate any bogus addrs
    if (modeAddr(*paddr).fSql == 0 && modeAddr(*paddr).fJava == 0) {
        GetAddrSeg(*paddr) = (GetAddrSeg(*paddr) & 0x0000FFFF);
    }

    XOSD xosd = xosdNone;

    StartTimer(itmSYFixupAddr);
    if ( ADDR_IS_LI ( *paddr ) ) {
    xosd = OSDFixupAddr( hpidCurr, htidCurr, paddr );
    }
    StopTimer(itmSYFixupAddr);

    return ( xosd == xosdNone && paddr->emi != 0 );
}

/*** SYUnFixupAddr
*
* Purpose: To unfixup an address packet
*
* Input:
*   pADDR - The address in question
*
* Output:
* Returns:
*   TRUE if address unfixed up, FALSE otherwise.
*
* Exceptions:
*
* Notes:
*
*
*************************************************************************/
BOOL LOADDS PASCAL SYUnFixupAddr ( PADDR paddr ) {

    // If this ASSERT fires, it means the segment portion of the addr
    // was not cleared before using/constructing the addr.
    // We check the SQL and Java bits because Galileo and Jakarta set these
    // bits to identify their addr packets.
    ASSERT( modeAddr(*paddr).fSql == 1 || modeAddr(*paddr).fJava == 1 ||
        (GetAddrSeg(*paddr) & 0xFFFF0000) == 0 );

#ifndef _SHIP
    // To help catch the case where the upper two bytes of a seg are
    // not zero, we'll put up a message box to alert the user.
    if (modeAddr(*paddr).fSql == 0 && modeAddr(*paddr).fJava == 0 && (GetAddrSeg(*paddr) & 0xFFFF0000) != 0) {
        if (MsgBox(Error, "Warning! ADDR packet detected with two high bytes non-zero. Please contact the Jakarta Debugger team. (Click Cancel to debug.)", MB_OKCANCEL) == IDCANCEL) {
            DebugBreak();
        }
    }
#endif

    // Clear the upper two bytes of the segment (if the addr isn't SQL or Java).
    // This is an added safety measure for 32-bit segments:
    // we'll clear the upper two bytes to help eliminate any bogus addrs
    if (modeAddr(*paddr).fSql == 0 && modeAddr(*paddr).fJava == 0) {
        GetAddrSeg(*paddr) = (GetAddrSeg(*paddr) & 0x0000FFFF);
    }

    XOSD  xosd = xosdNone;

    StartTimer(itmSYUnFixupAddr);
    if ( !ADDR_IS_LI ( *paddr ) ) {
    xosd = OSDUnFixupAddr( hpidCurr, htidCurr, paddr );
    }

    StopTimer(itmSYUnFixupAddr);
    return  ( xosd == xosdNone && paddr->emi != 0 );
}

BOOL SYProgramHasRun ( void ) {

    return lpprcCurr->stp != stpNotStarted;
}

static  HVOID   hLocked = NULL;

/*** MHOmfLock
*
*   Purpose:
*   To lock the omf in place. This is an EMS swap
*
*   Input:
*   hHandle - The symbol or type handle to swap in.
*
*   Output:
*   Returns:
*   The physical memory location
*
*   Exceptions:
*
*   Notes:
*
*************************************************************************/
HVOID LOADDS PASCAL MHOmfLock ( HVOID hHandle ) {
// VCNT is a hack for now, because we were hitting this assert;
// we'll track it down later

    return (HVOID) hHandle;
}
/*** MHOmfUnLock
*
*   Purpose:
*
*   Input:
*   hHandle     -The handle to unlock
*
*   Output:
*   Returns:
*
*   Exceptions:
*
*   Notes:
*   This is only for the debug version
*
*************************************************************************/
VOID  LOADDS PASCAL MHOmfUnLock( HVOID hHandle ) {
// VCNT is a hack for now, because we were hitting this assert;
// we'll track it down later
}

static int XlateSheErr[sheMax] = {
    0,
    NOSYMBOLS,
    FUTURESYMBOLS,
    MUSTRELINK,
    NOTPACKED,
    EMMINSUFMEM,
    0,
    0,
	0,
	0,
	SYMSCONVERTED,
	0,
	0,
    PDBNOTFOUND,
    PDBBADSIGNATURE,
    PDBINVALIDAGE,
    PDBOLDFORMAT
};

#define IsPdbSheErr(she)        ((BOOL)(shePdbNotFound<=(she) && (she)<=shePdbOldFormat))


BOOL
SYLoadAllOmf(
    )
/*++

Routine Description:

    Load all the DLLs and the EXE that have been registered with the symbol
    handler.

Comments:

--*/
{
    HEXE hexe;
    SHE  she = sheNone;

    she = SHAddDllsToProcess ( );

    for ( hexe = SHGetNextExe ( (HEXE) NULL );
      hexe != (HEXE) NULL && she == sheNone;
      hexe = SHGetNextExe ( hexe )
    )
    {

        LSZ lszExeName;

    lszExeName = SHGetExeName ( hexe );
    she = SHLoadDll ( lszExeName, FALSE );

    if (she == sheOutOfMemory) {
       errno = EMMINSUFMEM;
    }
        else if (XlateSheErr[she] != 0) {

            if ( IsPdbSheErr(she) )
            {
                char    szPdbName[_MAX_PATH];

                SHPdbNameFromExe( lszExeName, szPdbName, sizeof( szPdbName ) );
                CVMessage( WARNMSG, XlateSheErr[she], CMDWINDOW, szPdbName, lszExeName );
            }
            else {

                if (she != sheNoSymbols)
                    // temp hack for sniff test and pending SYOpen fix
                    CVMessage( WARNMSG, XlateSheErr[she], CMDWINDOW, lszExeName );
            }

       // the caller of SYLoadAllOmf expects an error return only
       // if something really serious happens that requires an
       // abort, so for errors where there is no symbol info we
       // set she = sheNone so just the queued warning is
       // displayed

           she = sheNone;
    }
    }

    return she == sheNone;
}

void _HUGE_ * PASCAL LOADDS LDShalloc(long n, size_t size) {
    void _HUGE_ * hpret;

    hpret = _fmalloc ( n * size );
    return hpret;
}

void PASCAL LOADDS LDShfree(void _HUGE_ * buffer) {
    _ffree ( buffer );
}


BOOL LOADDS PASCAL SYFHasSource( HPID hpid, LPADDR lpaddr ) {
    return HasSource(*lpaddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\ddrop.cpp ===
// ddrop.cpp
// OLE Drag/Drop

#include "stdafx.h"
#pragma hdrstop

#include <shlmenu.h>
//#include "inc\dbggrid.h"
//#include "inc\varsview.h"
//#include "inc\extern.h"

UINT g_cfTMText = ::RegisterClipboardFormat(_T("MSDEVDbgTMText"));
UINT g_cfColSelect = ::RegisterClipboardFormat(_T("MSDEVColumnSelect"));

//m_pDragInfo
class CDragInfo
{
public:
	CDragInfo();
	~CDragInfo();
	CDragInfo(CBaseVarsView * pVarView, DROPEFFECT effect);
	CDragInfo(CMultiEdit * pME,  DROPEFFECT effect);

	// do we activate the window?
	//
	BOOL		FTriggerEntryDelay();
	BOOL		IsEntryDelayElapsed();
	void		ResetEntry() { if( 0 == (m_dwDragEnterTime = ::GetTickCount())) m_dwDragEnterTime = 1; }

	// other activation (e.g. tabs)
	BOOL		IsDelayElapsed();
	BOOL        IsDelayRunning() { return m_dwDelayTime != 0; }
	void        ClearDelay() { m_dwDelayTime = 0; }
	void		StartDelay(DWORD dwExtra = 0) { if (0 == (m_dwDelayTime = ::GetTickCount())) m_dwDelayTime = 1; m_dwDelayExtra = dwExtra; }
	void        SetDelayInterval(DWORD dwInterval) { m_dwDelayInterval = dwInterval; }
	
	DWORD       DelayExtra() { return m_dwDelayExtra; }
	void        SetDelayExtra( DWORD dw ) { m_dwDelayExtra = dw; }

	// drop effect
	//
	DROPEFFECT	Effect() { return m_LastDropEffect; }
	void		SetEffect(DROPEFFECT effect) { m_LastDropEffect = effect; }
	void		AddEffect(DROPEFFECT effect) { m_LastDropEffect |= effect; }
	void		SetEffectFromKeys(DWORD dwKeyState);

	// total duration of drag/drop
	DWORD Duration() { return ::GetTickCount() - m_dwStartTime; }

	// context (right mouse) menu
	BOOL		IsContext()                { return m_bContext; }
	void		SetContext(BOOL bContext)  { m_bContext = bContext; }

	// IsFromSelf()
	//
	// Pass GetDocument() to see if you're dragging from this DOC
	// Pass NULL (no arg) to see if you're dragging from this VIEW
	//
	BOOL		IsFromSelf();
	void		ClearSelf();
	CDbgGridWnd *	GridFrom() { return m_pGridFrom; }

private:
	DROPEFFECT      m_LastDropEffect;   // last drop effect
	BOOL			m_bDraggingFrom;    // dragging from this view
	CDbgGridWnd *	m_pGridFrom;		// grid this drag came from

	DWORD			m_dwDragEnterTime;  // time we started drag
	DWORD			m_dwDelayTime;      // time we started this delay
	DWORD           m_dwDelayExtra;     // extra delay info for client
	DWORD			m_dwDelayInterval;  // interval for delay

	DWORD			m_dwStartTime;     // time we started everything

	BOOL			m_bContext;         // show context menu at drop
};


CDragInfo::~CDragInfo()
{
//TRACE("Destroy CDragInfo\n");
	if (m_bDraggingFrom)
	{
		ClearSelf();
	}
}

#if 0
#define DEF_DELAY  (500) // somewhat large for testing delay code
#else
#define DEF_DELAY  (g_dwDragDelay)
#endif

///////////////////////////////////////
// Enforce a minimum total drag duration to sanity-check the whole process:
//
// if (m_pDragInfo->Duration() < g_dwDragDelay + MIN_DRAG_DURATION)
// {
//     // It's lasted long enough that the user may actually
//     // have wanted a real drag-drop op.
// }
//
#ifdef _DEBUG
// not const for debug-time tuning without recompilation
      DWORD MIN_DRAG_DURATION = 50;
#else
const DWORD MIN_DRAG_DURATION = 50;
#endif

////////////////////////////////////////////////////////////////////////

CDragInfo::CDragInfo()
{
	m_LastDropEffect = DROPEFFECT_NONE;
	ResetEntry();
	m_dwDelayTime = 0;
	m_dwDelayInterval = DEF_DELAY;
	m_dwDelayExtra = (DWORD)-1;
	m_bDraggingFrom = FALSE;
	m_pGridFrom = NULL;
	m_bContext = FALSE;
//TRACE("Create Default CDragInfo\n");
	m_dwStartTime = ::GetTickCount();
}

CDragInfo::CDragInfo(CBaseVarsView * pVarView, DROPEFFECT effect)
{
	m_LastDropEffect = DROPEFFECT_NONE;
	ResetEntry();
	m_dwDelayTime = 0;
	m_dwDelayInterval = DEF_DELAY;
	m_dwDelayExtra = (DWORD)-1;
	m_bDraggingFrom = TRUE;
	m_pGridFrom = pVarView->GetActiveGrid();
	m_bContext = FALSE;
//TRACE("Create CBaseVarsView CDragInfo\n");
	m_dwStartTime = ::GetTickCount();
}

CDragInfo::CDragInfo(CMultiEdit * pME,  DROPEFFECT effect)
{
	m_LastDropEffect = DROPEFFECT_NONE;
	ResetEntry();
	m_dwDelayTime = 0;
	m_dwDelayInterval = DEF_DELAY;
	m_dwDelayExtra = (DWORD)-1;
	m_bDraggingFrom = TRUE;
	m_bContext = FALSE;
	m_dwStartTime = ::GetTickCount();
}


BOOL CDragInfo::IsFromSelf()
{ 
	return m_bDraggingFrom;
}

void CDragInfo::ClearSelf()
{
	m_bDraggingFrom = FALSE;
}

void CDragInfo::SetEffectFromKeys(DWORD dwKeyState)
{
	if (dwKeyState & MK_CONTROL)
		SetEffect(DROPEFFECT_COPY);
	else
		SetEffect(DROPEFFECT_MOVE);
}

BOOL CDragInfo::FTriggerEntryDelay()
{
	if (0 == m_dwDragEnterTime)
		return FALSE;
	else if (::GetTickCount() - m_dwDragEnterTime > DEF_DELAY)
	{
//TRACE("Entry delay triggered.\n");
		m_dwDragEnterTime = 0;
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CDragInfo::IsEntryDelayElapsed()
{
	if (0 == m_dwDragEnterTime)
		return TRUE;
	else if (::GetTickCount() - m_dwDragEnterTime > DEF_DELAY)
	{
//TRACE("Non-pulsed entry delay triggered.\n");
		return TRUE;
	}
	else
		return FALSE;
}

BOOL CDragInfo::IsDelayElapsed()
{
	if (0 == m_dwDelayTime)
		return FALSE;
	else if (::GetTickCount() - m_dwDelayTime > m_dwDelayInterval)
	{
		return TRUE;
	}
	else
		return FALSE;
}

////////////////////////////////////////////////////////////////
// MFC OLE Drag/Drop overrides

DROPEFFECT
CBaseVarsView::OnDragEnter( COleDataObject* pData, DWORD grfKeyState, CPoint point )
{
	CDbgGridWnd *pGrid = GetActiveGrid();
	if (NULL == pGrid)
		return DROPEFFECT_NONE;

	{
		CWnd * pWndFocus = GetFocus();
		if ((NULL != m_pDragInfo) && 
			(pWndFocus != this) && !IsChild(pWndFocus))
			m_pDragInfo->ResetEntry();
	}
	
	if (pGrid->CanDropText())
	{
		if ((NULL != m_pDragInfo && m_pDragInfo->Effect() != DROPEFFECT_NONE) || 
			pData->IsDataAvailable(CF_TEXT))
		{
			// create the drag info thing
			if (NULL == m_pDragInfo)
			{
				m_pDragInfo = new CDragInfo;
				if (NULL == m_pDragInfo)
					return DROPEFFECT_NONE;
			}

			// we only copy -- no move or link
			m_pDragInfo->SetEffect(DROPEFFECT_COPY);
			m_pDragInfo->SetContext(grfKeyState & MK_RBUTTON);
			return m_pDragInfo->Effect();
		}
	}
	return DROPEFFECT_NONE;
}


DROPEFFECT
CBaseVarsView::OnDragOver( COleDataObject* pData, DWORD grfKeyState, CPoint point )
{
	if (NULL == m_pDragInfo)
		return DROPEFFECT_NONE;

	CDbgGridWnd *pGrid = GetActiveGrid();
	if (NULL == pGrid)
		return DROPEFFECT_NONE;

	// default to copy -- no move or link
	DROPEFFECT deRet = pGrid->CanDropText() ? DROPEFFECT_COPY : DROPEFFECT_NONE;

	if (m_pDragInfo->Effect() != DROPEFFECT_NONE)
	{
		if (m_pDragInfo->IsFromSelf())
		{
			// check if over current row
			CDbgGridWnd *pGridFrom = m_pDragInfo->GridFrom();
			if (pGridFrom != NULL && pGridFrom == pGrid)
			{
				CTreeGridRow *pRow = pGrid->GetCurSel();
				if (pRow != NULL)
				{
					CRect rc;
					pRow->GetRect(rc);
					if (rc.PtInRect(point))
					{
						// we're over the row the drag came from
						deRet = DROPEFFECT_NONE;
					}
				}
			}
		}
		// we only copy -- no move or link
		m_pDragInfo->SetEffect(DROPEFFECT_COPY);

		// if we're not the active window and the entry delay is elapsed, activate
		if (m_pDragInfo->FTriggerEntryDelay())
		{
			CWnd * pWndFocus = GetFocus();
			if ((pWndFocus != this) && !IsChild(pWndFocus))
			{
				theApp.SetActiveView(GetSafeHwnd());
			}
		}
		else if (m_pDragInfo->IsEntryDelayElapsed())
		{
			// activate another tab?
			CRect rc;
			m_widgetScroller.GetWindowRect(&rc);
			ScreenToClient(&rc);
			if (rc.PtInRect(point))
			{
				for (int i = 0; i < m_arrChildWnd.GetSize(); i++)
				{
					m_widgetScroller.GetTabRect(i, rc);
					// compensate for overlap so we don't flash when you're between tabs
					rc.InflateRect(-9,-1);
					// convert the tab's coords to screen coords
					m_widgetScroller.ClientToScreen(&rc);
					// convert tab's screen coords to this window's client coords
					ScreenToClient(&rc);
					// hit on the tab?
					if (rc.PtInRect(point))
					{
						// don't reactivate the current tab
						if (i != m_curIndex)
						{
							if (m_pDragInfo->IsDelayElapsed() &&
								m_pDragInfo->DelayExtra() == (DWORD)i
								)
							{
								m_widgetScroller.ActivateTab(i);
								m_pDragInfo->ClearDelay();
							}
							else if (!m_pDragInfo->IsDelayRunning() || 
								m_pDragInfo->DelayExtra() != (DWORD)i)
							{
								// start activation delay for this tab
								m_pDragInfo->StartDelay((DWORD)i);
							}
						}
						//else
						//	m_pDragInfo->ClearDelay(); // over the current tab
						break;
					}
				}
			}
			else
				m_pDragInfo->ClearDelay(); // not over a tab
		}
	}
	return deRet;
}

DROPEFFECT
CBaseVarsView::OnDropEx( COleDataObject* pData, DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point)
{
	if (NULL == m_pDragInfo)
		return DROPEFFECT_NONE;
	if ((m_pDragInfo->Effect() == DROPEFFECT_NONE) ||
		(m_pDragInfo->Duration() < g_dwDragDelay + MIN_DRAG_DURATION)
		)
	{
		OnDragLeave();
		return DROPEFFECT_NONE;
	}

//	BOOL bMoveInSelf = m_pDragInfo->IsFromSelf() && 
//		(dropDefault & DROPEFFECT_MOVE);
	
	if (m_pDragInfo->IsContext())
	{
		BEGIN_POPUP_MENU(DragDrop)
			MENU_ITEM_(ID_DRAG_MOVE, IDS_DRAG_MOVE)
			MENU_ITEM_(ID_DRAG_COPY, IDS_DRAG_COPY)
			MENU_SEPARATOR()
			MENU_ITEM_(ID_DRAG_CANCEL, IDS_DRAG_CANCEL)
		END_POPUP_MENU()

		CPoint ptScreen (point);
		ClientToScreen (&ptScreen);

		CBContextPopupMenu menu;
		menu.Create(MENU_CONTEXT_POPUP(DragDrop));
		BOOL bEnableMove = (dropDefault & DROPEFFECT_MOVE) && (dropList & DROPEFFECT_MOVE);
		menu.EnableMenuItem(ID_DRAG_MOVE, bEnableMove ? MF_ENABLED : MF_DISABLED);

	    TRACE2("CBShow: DragDrop (%s, %d)\r\n",__FILE__, __LINE__);

		UINT nCmd = menu.TrackPopupMenu( TPM_RIGHTBUTTON | TPM_RETURNCMD, ptScreen.x, ptScreen.y, AfxGetMainWnd() );
		switch (nCmd)
		{
		case ID_DRAG_MOVE: 
			m_pDragInfo->SetEffect(DROPEFFECT_MOVE); 
			break;
		
		case ID_DRAG_COPY:
			m_pDragInfo->SetEffect(DROPEFFECT_COPY); 
			break;
		
		case ID_DRAG_CANCEL:
		default:
			m_pDragInfo->SetEffect(DROPEFFECT_NONE);
			break;
		}
	}
	else
		m_pDragInfo->SetEffect(DROPEFFECT_COPY);

	if (m_pDragInfo->Effect() != DROPEFFECT_NONE)
	{
		if (!InsertFromDataObject(pData, point))
			m_pDragInfo->SetEffect(DROPEFFECT_NONE);
	}

	DROPEFFECT deRet = m_pDragInfo->Effect();
	OnDragLeave();

	AfxGetMainWnd()->SetForegroundWindow();
	SetFocus();	
	return deRet;
}

void
CBaseVarsView::OnDragLeave()
{
	// m_pDragInfo destruction in drag from self case is handled in DoDrag
	if (NULL != m_pDragInfo && !m_pDragInfo->IsFromSelf())
	{
		delete m_pDragInfo;
		m_pDragInfo = NULL;
	}
}

////////////////////////////////////////////////////////////////
// Drag/Drop utilities
BOOL CBaseVarsView::CanMoveText() 
{
	CDbgGridWnd *pGrid = GetActiveGrid();
	return pGrid->CanMoveText();
}

BOOL CBaseVarsView::CanDropText()
{
	CDbgGridWnd *pGrid = GetActiveGrid();
	return pGrid->CanDropText();
}

BOOL CBaseVarsView::DoDrag(CPoint point)
{
	{
		CWnd * pWndFocus = GetFocus();
		if ((pWndFocus != this) && !IsChild(pWndFocus))
			return FALSE;
	}

	CRect rcSlop;

	{
		CDbgGridWnd *pGrid = GetActiveGrid();
		if (NULL == pGrid)
		{
			ASSERT(0);
			return FALSE;
		}
		CGridElement * pElement = pGrid->ElementFromPoint(point);
		if (NULL == pElement)
		{
			ASSERT(0);
			return FALSE;
		}
		CGridRow * pGRow = pElement->GetRow();
		if (pGRow == pGrid->GetCaptionRow())
		{
			// Don't drag caption
			return FALSE;
		}
		if (static_cast<CTreeGridRow *>(pGRow)->IsNewRow())
		{
			// Don't drag New row
			return FALSE;
		}
		// Don't drag +/- glyph
		CWatchRow * pWRow = static_cast<CWatchRow *>(pGRow);
		if (WRH_GLYPH == pWRow->HitTest(point))
			return FALSE;

		// Get the drag slop rect from the row
		pGrid->GetDragSlopRect(point, rcSlop);
	}

	// drop effects
	DROPEFFECT dropeffect = DROPEFFECT_COPY;
	if (CanMoveText())
		dropeffect |= DROPEFFECT_MOVE;

	// save current selection
	ASSERT(NULL == m_pDragInfo);
	m_pDragInfo = new CDragInfo(this, dropeffect);
	if (NULL == m_pDragInfo)
		return FALSE;

	COleDataSource data;
	if (!InitDataSource(data, point))
	{
		delete m_pDragInfo;
		m_pDragInfo = NULL;
		return FALSE;
	}

	dropeffect = data.DoDragDrop(dropeffect, &rcSlop);

//	// move in self handled by destination in OnDropEx
//	if (dropeffect == DROPEFFECT_MOVE && CanMoveText() && 
//		m_pDragInfo != NULL && m_pDragInfo->IsFromSelf()
//		)
//	{
//		// move from here to somewhere else -- delete here
//		// TODO:
//	}

//  cross-app activation, which we aren't doing from the debugger right now
//	if (DROPEFFECT_NONE == dropeffect)
//	{
//		AfxGetMainWnd()->SetForegroundWindow();
//		theApp.SetActiveView(GetSafeHwnd());
//	}

	if (m_pDragInfo)
	{
		if (m_pDragInfo->Duration() < g_dwDragDelay + MIN_DRAG_DURATION)
		{
			// "It all happened so fast..., it can't be real."
	//		TRACE("Firing debug drag cancel timing heuristic\n");
			dropeffect = DROPEFFECT_NONE;
		}
		delete m_pDragInfo;
		m_pDragInfo = NULL;
	}
	return dropeffect != DROPEFFECT_NONE;
}


BOOL CBaseVarsView::InitDataSource(COleDataSource& data, const CPoint & point)
{
	BOOL bRet = FALSE;
	HANDLE hData = NULL;

//	data.Empty();

	//
	// get active grid
	//
	CDbgGridWnd *pGrid = GetActiveGrid();
	if (NULL == pGrid)
		return FALSE;

	//
	// get TM text
	//
	{
		// Don't allow drag/drop if the user is currently in the midst of editing
		// a name or value.	
//		if (pGrid->m_pControlWnd != NULL)
//			return FALSE;

		UINT uHit = WRH_NONE;
		CGridElement * pElement = pGrid->ElementFromPoint(point);
		if (NULL == pElement)
		{
			ASSERT(0);
			bRet = FALSE;
			goto L_Exit;;
		}
		
		CGridRow * pGRow = pElement->GetRow();
		// Don't drag caption
		if (pGRow == pGrid->GetCaptionRow())
		{
			bRet = FALSE;
			goto L_Exit;
		}

		// Don't drag New row
		if (static_cast<CTreeGridRow *>(pGRow)->IsNewRow())
		{
			bRet = FALSE;
			goto L_Exit;
		}

		// Don't drag +/- glyph
		CWatchRow * pWRow = static_cast<CWatchRow *>(pGRow);
		uHit = pWRow->HitTest(point);
		if (WRH_GLYPH == uHit)
		{
			bRet = FALSE;
			goto L_Exit;
		}

		CString str;
		CTM * pTM =  pGrid->GetSelectedTM( );
		if (pTM != NULL)
		{
			if (WRH_VALUE == uHit)
				str = pTM->GetEditableValue();
			else
			{
				str = pTM->GetExpr();
				if (str.IsEmpty())
				{
					// If the expression is not evaluatable (a var is currently 
					// out of scope, for example), GetExpr() returns an empty string.
					// In this case, get whatever text is in the column.
					static_cast<CTreeGridRow *>(pGRow)->GetColumnText(COL_NAME, str);
				}
			}
			if (!str.IsEmpty())
			{
				// convert string to handle
				hData = HandleFromString(str);
				data.CacheGlobalData(g_cfTMText, hData);
				//
				// get plain text, too, for dragging to the editor
				//
				hData = pGrid->CFTextHandle();
				if (hData != NULL)
				{
					data.CacheGlobalData(CF_TEXT, hData);
				}
				bRet = TRUE;
			}
		}
	}
L_Exit:
	if (bRet)
		return TRUE;
	else
	{
		data.Empty();
		return FALSE;
	}
}

// Insert text from an HGLOBAL
static BOOL InsertFromHandle(CDbgGridWnd *pGrid, HGLOBAL hData)
{
	int size;
	LPSTR pch;

	if (size = RealGlobalSize(hData))
	{
		// Get a pointer to the data.  Leave if we can't do it.
		VERIFY((pch = (LPSTR)RealGlobalLock(hData)));
		if (!pch)
			return FALSE;
		pGrid->ImportWatchFromBuffer(pch, strlen(pch));
		RealGlobalUnlock(hData);
	}
	return TRUE;
}

// Insert text from a COleDataObject
BOOL CBaseVarsView::InsertFromDataObject(COleDataObject * data, const CPoint & point)
{
//TRACE("Elapsed drag time: %d\n", m_pDragInfo ? m_pDragInfo->Duration() : 0);
	CDbgGridWnd *pGrid = GetActiveGrid();
	if (NULL == pGrid)
		return FALSE;

	if (data->IsDataAvailable(g_cfTMText))
	{
		return InsertFromHandle(pGrid, data->GetGlobalData(g_cfTMText));
	}
	else if (data->IsDataAvailable(CF_TEXT))
	{
		return InsertFromHandle(pGrid, data->GetGlobalData(CF_TEXT));
	}
	else
	{
		return FALSE;
	}
}

////////////////////////////////////////////////////////////////

DROPEFFECT CMultiEdit::OnDragEnter( COleDataObject* pData, DWORD grfKeyState, CPoint point )
{
	if (NULL != m_pDragInfo && GetFocus() != this)
		m_pDragInfo->ResetEntry();
	if (CanDropText())
	{
		if ((NULL != m_pDragInfo && m_pDragInfo->Effect() != DROPEFFECT_NONE) || 
			pData->IsDataAvailable(CF_TEXT))
		{
			// create the drag info thing
			if (NULL == m_pDragInfo)
			{
				m_pDragInfo = new CDragInfo;
				if (NULL == m_pDragInfo)
					return DROPEFFECT_NONE;
			}
			// we only copy -- no move or link
			m_pDragInfo->SetEffect(DROPEFFECT_COPY);

			OnDragEnterFeedback(grfKeyState, point);
			m_pDragInfo->SetEffect(m_pDragInfo->Effect() & ~(DROPEFFECT_MOVE|DROPEFFECT_LINK));
			m_pDragInfo->SetContext(grfKeyState & MK_RBUTTON);
			return m_pDragInfo->Effect();
		}
	}
	return DROPEFFECT_NONE;
}



DROPEFFECT CMultiEdit::OnDragOver( COleDataObject* pDataObject, DWORD grfKeyState, CPoint point )
{
	if (NULL == m_pDragInfo)
		return DROPEFFECT_NONE;
	if (m_pDragInfo->Effect() != DROPEFFECT_NONE)
	{
		// we only copy -- no move or link
		m_pDragInfo->SetEffect(DROPEFFECT_COPY);

		// if we're not the active window and the entry delay is elapsed, activate
		if (m_pDragInfo->FTriggerEntryDelay())
		{
			if (GetFocus() != this)
			{
				theApp.SetActiveView(GetSafeHwnd());
			}
		}
		else if (m_pDragInfo->IsEntryDelayElapsed())
		{
			OnDragOverFeedback(grfKeyState, point);
		}
	}
	return m_pDragInfo->Effect();
}


void CMultiEdit::OnDragLeave()
{
	OnDragLeaveFeedback();
	// m_pDragInfo destruction in drag from self case is handled in DoDrag
	if (NULL != m_pDragInfo && !m_pDragInfo->IsFromSelf())
	{
		delete m_pDragInfo;
		m_pDragInfo = NULL;
	}
}


DROPEFFECT CMultiEdit::OnDropEx( COleDataObject* pData, DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point )
{
	if (NULL == m_pDragInfo)
		return DROPEFFECT_NONE;
	if (m_pDragInfo->Effect() == DROPEFFECT_NONE)
	{
		OnDragLeave();
		return DROPEFFECT_NONE;
	}

//	BOOL bMoveInSelf = m_pDragInfo->IsFromSelf() && 
//		(dropDefault & DROPEFFECT_MOVE);
	
	if (m_pDragInfo->IsContext())
	{
		BEGIN_POPUP_MENU(DragDrop)
			MENU_ITEM_(ID_DRAG_MOVE, IDS_DRAG_MOVE)
			MENU_ITEM_(ID_DRAG_COPY, IDS_DRAG_COPY)
			MENU_SEPARATOR()
			MENU_ITEM_(ID_DRAG_CANCEL, IDS_DRAG_CANCEL)
		END_POPUP_MENU()

		CPoint ptScreen (point);
		ClientToScreen (&ptScreen);

		CBContextPopupMenu menu;
		menu.Create(MENU_CONTEXT_POPUP(DragDrop));
		BOOL bEnableMove = (dropDefault & DROPEFFECT_MOVE) && (dropList & DROPEFFECT_MOVE);
		menu.EnableMenuItem(ID_DRAG_MOVE, bEnableMove ? MF_DISABLED : MF_ENABLED);

	    TRACE2("CBShow: DragDrop (%s, %d)\r\n",__FILE__, __LINE__);

		UINT nCmd = menu.TrackPopupMenu( TPM_RIGHTBUTTON | TPM_RETURNCMD, ptScreen.x, ptScreen.y, AfxGetMainWnd() );
		switch (nCmd)
		{
		case ID_DRAG_MOVE: 
			m_pDragInfo->SetEffect(DROPEFFECT_MOVE); 
			break;
		
		case ID_DRAG_COPY:
			m_pDragInfo->SetEffect(DROPEFFECT_COPY); 
			break;
		
		case ID_DRAG_CANCEL:
		default:
			m_pDragInfo->SetEffect(DROPEFFECT_NONE);
			break;
		}
	}
	else
		m_pDragInfo->SetEffect(DROPEFFECT_COPY);

	if (m_pDragInfo->Effect() != DROPEFFECT_NONE)
	{
		if (!InsertFromDataObject(pData, point))
			m_pDragInfo->SetEffect(DROPEFFECT_NONE);
	}

	DROPEFFECT deRet = m_pDragInfo->Effect();

	OnDragLeave();

	AfxGetMainWnd()->SetForegroundWindow();
	SetFocus();	
	return deRet;
}


BOOL CMultiEdit::DoDrag(CPoint point)
{
	// drop effects
	DROPEFFECT dropeffect = DROPEFFECT_COPY;
	if (CanMoveText())
		dropeffect |= DROPEFFECT_MOVE;

	// slop rect for starting drag
	CRect rect;
	rect.TopLeft() = point;
	rect.BottomRight() = point;
	rect.InflateRect(g_dwDragMinRadius, g_dwDragMinRadius);

	// save current selection
	ASSERT(NULL == m_pDragInfo);
	m_pDragInfo = new CDragInfo(this, dropeffect);
	if (NULL == m_pDragInfo)
		return FALSE;

	COleDataSource data;
	if (!InitDataSource(data, point))
		return FALSE;

	dropeffect = data.DoDragDrop(dropeffect, &rect);

//	// move in self handled by destination in OnDropEx
//	if (dropeffect == DROPEFFECT_MOVE && CanMoveText() && 
//		m_pDragInfo != NULL && m_pDragInfo->IsFromSelf()
//		)
//	{
//		// move from here to somewhere else -- delete here
//		// TODO:
//	}

	if (DROPEFFECT_NONE == dropeffect)
	{
		AfxGetMainWnd()->SetForegroundWindow();
		theApp.SetActiveView(GetSafeHwnd());
	}

	if (m_pDragInfo)
	{
		delete m_pDragInfo;
		m_pDragInfo = NULL;
	}
	return dropeffect != DROPEFFECT_NONE;
}


BOOL CMultiEdit::InitDataSource(COleDataSource& data, const CPoint & point)
{
	HANDLE hData = NULL;
	
	hData = CopySelection(0, (size_t)-1);
	if (hData != NULL)
	{
		data.CacheGlobalData(CF_TEXT, hData);
			if (m_fColumnSelect)
			data.CacheGlobalData(g_cfColSelect, HandleFromString(_T("C")));
		return TRUE;
	}
	else
		return FALSE;
}


BOOL CMultiEdit::InsertFromDataObject(COleDataObject * data, const CPoint & point)
{
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\debugopt.cpp ===
// debugopt.cpp : implementation file
// Debugger tab dialog code.
// marklam	14-Oct-93	Created from rundebug.c, mwdlg.cpp, damdlg.cpp, clwdlg.cpp, rwvdlg.cpp

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL FSetupDLL(LPCSTR szFileName, LPCSTR szEntry, MPT mpt);
MPT	 MptFromPlatform (uniq_platform Platform);
BOOL WINAPI GetRegistryRoot (LPTSTR RegistryRoot, LPDWORD pLength);

// Create the tab page
CDlgTab *CreateDebugPage()
{
    if ( !gpIBldPlatforms )
        return NULL;

	return new CDebugOpt;
}

static void InitChildFont(CWnd *pwnd, int nID)
{
	CWnd *pChild = pwnd->GetDlgItem(nID);
	ASSERT(pChild);
	pChild->SetFont(GetStdFont(font_Normal));
}

void CDebugOpt::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDebugOpt)
	DDX_Text(pDX, IDC_DEBUG_ADDRESS, m_szExpr);
	DDX_Check(pDX, IDC_DEBUG_ANNOTATE, m_fAnnotate);
	DDX_Check(pDX, IDC_DEBUG_CODEBYTES, m_fCodeBytes);
	DDX_Check(pDX, IDC_DEBUG_FIXEDWIDTH, m_fFixedWidth);
	DDX_Check(pDX, IDC_DEBUG_HEXMODE, m_fHexMode);
	DDX_Check(pDX, IDC_DEBUG_LIVE, m_fLive);
	DDX_Check(pDX, IDC_DEBUG_OLERPC, m_fOLERPC);
	DDX_Check(pDX, IDC_DEBUG_RAW, m_fRaw);
	DDX_Check(pDX, IDC_DEBUG_SHOWARGS, m_fShowArgs);
	DDX_Check(pDX, IDC_DEBUG_SHOWFPU, m_fFPU);
	DDX_Check(pDX, IDC_DEBUG_SHOWTYPES, m_fShowTypes);
	DDX_Text(pDX, IDC_DEBUG_WIDTH, m_iItemsPerLine);
	DDX_Check(pDX, IDC_SYMBOLS, m_fSymbols);
	DDX_CBIndex(pDX, IDC_DEBUG_FORMAT, m_iFormat);
	DDX_Check(pDX, IDC_DEBUG_JIT, m_fEnableJit);
	DDX_Check(pDX, IDC_DEBUG_RETURN_VALUES, m_fReturnValues);
	DDX_Check(pDX, IDC_DEBUG_UNICODE_STRINGS, m_fUnicodeStrings);
    DDX_Check(pDX, IDC_DEBUG_EC, m_fENCDebugging);
    DDX_Check(pDX, IDC_DEBUG_LOADEXPORTS, m_fLoadExports);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDebugOpt, CDlgTab)
	//{{AFX_MSG_MAP(CDebugOpt)
	ON_BN_CLICKED(IDC_DEBUG_FIXEDWIDTH, OnClickedFixedwidth)
	ON_BN_CLICKED(IDC_DEBUG_JIT, OnClickedJit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Construction

CDebugOpt::CDebugOpt() : CDlgTab( IDDP_DEBUG, IDS_CAP_DEBUG )
{
	m_iFormat = runDebugParams.iMWFormat;
	m_fLive = runDebugParams.fMWLive;
	m_fRaw = runDebugParams.fMWShowRaw;
	m_fFPU = runDebugParams.fCPUFloat;
 	m_fShowArgs = runDebugParams.fCallParams;
	m_fShowTypes = runDebugParams.fCallTypes;
	m_fHexMode = !runDebugParams.decimalRadix;
	m_fOLERPC = runDebugParams.fOleRpc;
	m_fAnnotate = runDebugParams.fDAMAnnotate;
	m_fCodeBytes = runDebugParams.fDAMCodeBytes;
	m_fSymbols = runDebugParams.fDAMSymbols;
	m_fEnableJit = GetJitState();
    m_fReturnValues = runDebugParams.fReturnValues;
	m_fUnicodeStrings = runDebugParams.fUnicodeStrings;
	m_fENCDebugging = runDebugParams.fENCDebugging;
	m_fLoadExports = runDebugParams.fLoadExports;

	if (!m_fEnableJit) m_fOLERPC = FALSE;

	if ( DebuggeeAlive() )
    {
		if ( pViewMemory )
        {
			PMWI	pmwi = &((CMemoryView *)pViewMemory)->m_mwi;

			// reset the memory window format from the mem win if it's open
			m_iFormat = pmwi->pmwd - rgmwd;
			m_szExpr = pmwi->szExpr;
		}
		else if ( runDebugParams.strExpr.IsEmpty() )
        {
    	    ADDR    addr = { 0 };

        	if ( !OSDGetAddr ( hpidCurr, htidCurr, adrData, &addr ) ) {
	    		if ( ADDR_IS_FLAT ( addr ) ) {
					ASSERT( ADDR_IS_OFF32( addr ) );
					sprintf ( szTmp, "0x%08lX", GetAddrOff ( addr ) );
				}
				else {
		    		sprintf (
    	                szTmp,
        	            "0x%04X:0x%0*lX",
            	        GetAddrSeg ( addr ),
						ADDR_IS_OFF32( addr ) ? 8 : 4,
    					GetAddrOff ( addr )
	                );
				}
			}
			else {
				_ftcscpy ( szTmp, szDefaultExpr );
    		}
			m_szExpr = szTmp;
		}
		else
        {
			m_szExpr = runDebugParams.strExpr;
		}
    }
	else if ( !runDebugParams.strExpr.IsEmpty() ) {
		m_szExpr = runDebugParams.strExpr;
	}
	else {
		m_szExpr = szNull;
	}

}

/////////////////////////////////////////////////////////////////////////////
// CDebugOpt message handlers

BOOL CDebugOpt::OnInitDialog()
{
	int		isz;
	int		iszMax;
	char	szTmp[ axMax ];

	CButton *pbut = (CButton *)GetDlgItem(IDC_DEBUG_OLERPC);
	pbut->EnableWindow(m_fEnableJit);

	// The build system might not be present!
	if ( gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK )
	{
		int iPlatforms;

		gpIBldPlatforms->GetSupportedPlatformCount(&iPlatforms);

		if ( iPlatforms >= 2 ) // check for project + addons
		{
			uniq_platform upID;

			gpIBldPlatforms->GetCurrentPlatform(ACTIVE_BUILDER, &upID);
		}
	}

	((CComboBox *)GetDlgItem(IDC_DEBUG_FORMAT))->SetExtendedUI(TRUE);
#if _INTEGRAL_MAX_BITS >= 64
		iszMax = DLG_MemOpt_Last_Ext;
#else
		iszMax = DLG_MemOpt_Last;
#endif

	for ( isz = DLG_MemOpt_First; isz <= iszMax; isz++ ) {
		::LoadString(hInst, isz, szTmp, sizeof(szTmp));
		((CComboBox *)GetDlgItem(IDC_DEBUG_FORMAT))->InsertString(-1, (LPSTR)szTmp);	// use InsertString to add in order
	}

	((CComboBox *)GetDlgItem(IDC_DEBUG_FORMAT))->SetCurSel(m_iFormat);

	if ( (int)runDebugParams.iMWItemsPerLine > 0 ) {
		m_iItemsPerLine = runDebugParams.iMWItemsPerLine;
		m_fFixedWidth = TRUE;
		((CEdit *)GetDlgItem(IDC_DEBUG_WIDTH))->EnableWindow(TRUE);
	}
	else {
		m_iItemsPerLine = 0;
		m_fFixedWidth = FALSE;
		((CEdit *)GetDlgItem(IDC_DEBUG_WIDTH))->EnableWindow(FALSE);
	}


	// If the debuggee is running don't allow changing this setting
	if ( DebuggeeRunning() ) {
		((CEdit *)GetDlgItem(IDC_DEBUG_OLERPC))->EnableWindow(FALSE);
	}

	// Java: if the current configuration is Java, disable the memory and registers options
	// and the 'display return values' option and 'just in time debugging'
	if (pDebugCurr && pDebugCurr->IsJava()) {

		// set of controls to disable
		int rgidControls[] = { IDC_DEBUG_UNICODE_STRINGS, IDC_DEBUG_SHOWFPU,
								IDC_MEMWND_GRP, IDC_DEBUG_ADDRESS_TXT,
								IDC_DEBUG_ADDRESS, IDC_DEBUG_FORMAT_TXT,
								IDC_DEBUG_FORMAT, IDC_DEBUG_LIVE,
								IDC_DEBUG_RAW, IDC_DEBUG_FIXEDWIDTH,
								IDC_DEBUG_WIDTH,
								IDC_VARWND_GRP, IDC_DEBUG_RETURN_VALUES,
								IDC_DEBUG_JIT };
		const int cControls = sizeof(rgidControls) / sizeof(int);

		// disable controls
		for (int i = 0; i < cControls; i++) {
			CWnd* pControl = (CWnd*)GetDlgItem(rgidControls[i]);
			ASSERT(pControl != NULL);
			if (pControl != NULL) {
				pControl->EnableWindow(FALSE);
			}
		}
	}

	UpdateData( FALSE );

 	return TRUE;
}


// TAB changed or OK pressed, update and return success
BOOL CDebugOpt::ValidateTab()
{
	if (!UpdateData(TRUE))
		 return FALSE;

	if (DebuggeeAlive())
	{
		MWI		mwi = {0};
		mwi.szExpr = (LPSTR)(LPCSTR)m_szExpr;

		if ( !MWSetAddrFromExpr(&mwi, MW_NO_AUTO_TYPE) )
		{
		    // MWSetAddributes failed, assume that we weren't
		    // out of memory and the expression was garbage
		    ::SetFocus( GetDlgItem(IDC_DEBUG_ADDRESS)->m_hWnd );
		    SendDlgItemMessage(IDC_DEBUG_ADDRESS, EM_SETSEL, 0, (LPARAM)-1);
		    MessageBeep(0);
			return FALSE;
		}
	}
	return TRUE;
}

void CDebugOpt::CommitTab()
{
	if (GetSafeHwnd() == NULL)
		return;

	// Any errors in this function should have been caught in ValidateTab,
	// and simply assert.

	// dolphin 4640 [patbr]
	// if UpdateData() fails we should bail out here, not continue...
	if (!UpdateData( TRUE ))
	{
		ASSERT(FALSE);
		return;
	}

	if ( DebuggeeAlive() )
	{
		MWI		mwi = {0};
		mwi.szExpr = (LPSTR)(LPCSTR)m_szExpr;

        if ( !MWSetAddrFromExpr(&mwi, runDebugParams.iMWAutoTypes) )
        {
			// error handling code moved to ValidateTab, above
			ASSERT(FALSE);
			return;
        }
	}

	char *	psz;
	SetJitState(m_fEnableJit);

	runDebugParams.iMWFormat = m_iFormat;
	runDebugParams.fMWLive = m_fLive;
	runDebugParams.fMWShowRaw = m_fRaw;
	runDebugParams.fDAMAnnotate = m_fAnnotate;
	runDebugParams.fDAMCodeBytes = m_fCodeBytes;
	runDebugParams.fDAMSymbols = m_fSymbols;
	runDebugParams.fCPUFloat = m_fFPU;
 	runDebugParams.fCallParams = m_fShowArgs;
	runDebugParams.fCallTypes = m_fShowTypes;
	runDebugParams.decimalRadix = !m_fHexMode;
	runDebugParams.iMWItemsPerLine = m_iItemsPerLine;
    runDebugParams.fReturnValues = m_fReturnValues;
	runDebugParams.fUnicodeStrings = m_fUnicodeStrings;
	runDebugParams.fENCDebugging = m_fENCDebugging;
	if (runDebugParams.fLoadExports != m_fLoadExports)
	{
		// update registry immediately
		runDebugParams.fLoadExports = m_fLoadExports;
		HammerLoadExportsRegKey();
	}

	if ( runDebugParams.fOleRpc != m_fOLERPC ) {
		runDebugParams.fOleRpc = m_fOLERPC ;
		// See definition of HammerOleRegKey for an explanation
		// of why we special case the OLE flag.
		HammerOleRegKey();
	}
	runDebugParams.strExpr = m_szExpr;

	// If there is a memory window open, update it
	if ( pViewMemory ) {
		pViewMemory->SendMessage( WM_COMMAND, 0, 0L );
	}

	// Update the display window if it's open.
	if ( pViewDisassy ) {
		pViewDisassy->SendMessage( WM_COMMAND, 0, 0L );
	}

	// Update the display window if it's open.
	if ( pViewCpu ) {
		pViewCpu->SendMessage( WM_COMMAND, 0, 0L );
	}

	// Update the display window if it's open.
	if ( pViewCalls ) {
		pViewCalls->SendMessage( WM_COMMAND, 0, 0L );
	}

	// Update OSDebug's OLE state if OSDebug is resident.
	if (DebuggeeAlive() && !DebuggeeRunning())
	{
		if (pDebugCurr->MtrcOleRpc()) {
			if ( xosdNone == OSDSystemService(hpidCurr, htidCurr, ssvcOleRpc, &runDebugParams.fOleRpc, 1, NULL) )
			{
			}
		}
	}

	// update the radix, it may have changed...
	UpdateRadix(runDebugParams.decimalRadix);

}

void CDebugOpt::OnClickedFixedwidth()
{
	int iCheckState;

	iCheckState = ((CButton *)GetDlgItem(IDC_DEBUG_FIXEDWIDTH))->GetCheck();
	((CEdit *)GetDlgItem(IDC_DEBUG_WIDTH))->EnableWindow(iCheckState);

	// dolphin 4640 [patbr]
	// MFC will validate entry field even if it is disabled, so put value in
	// entry field as we are disabling it so that UpdateData() will succeed.
	//
	// if we are enabling the field because the accompanying check box has
	// been checked, move the focus to the entry field for user convenience.
	if (iCheckState)
		((CEdit *)GetDlgItem(IDC_DEBUG_WIDTH))->SetFocus();
	else
		((CEdit *)GetDlgItem(IDC_DEBUG_WIDTH))->SetWindowText("0");
}

void CDebugOpt::OnClickedJit()
{
	// get the state of the Jit button and enable or disable the
	// ole rpc button as appropriate

	int iCheckState = ((CButton *)GetDlgItem(IDC_DEBUG_JIT))->GetCheck();

	CButton *pbutOleRpc = (CButton *)GetDlgItem(IDC_DEBUG_OLERPC);

	pbutOleRpc->EnableWindow(iCheckState);

	// enable OLE RPC if JIT is enabled...
	pbutOleRpc->SetCheck(iCheckState);
}

#define GetSzValue(x,y) ::GetProfileString(x,y,"",szValue, sizeof(szValue))

static LPCTSTR szAeDebug		= _T("AeDebug");
static LPCTSTR szAuto			= _T("Auto");
static LPCTSTR szDebugger		= _T("Debugger");
static LPCTSTR szOldAuto		= _T("OldAuto");
static LPCTSTR szDrWatson		= _T("drwtsn32 -p %ld -e %ld -g");
static LPCTSTR szJitTemplate	= _T("\"%s\" -p %%ld -e %%ld");

BOOL GetJitState() 
{
	// get the state of JIT debugging by inspecting the registry

	char szValue[256], szTmp[256+32];

	GetModuleFileName(AfxGetApp()->m_hInstance, szValue, sizeof(szValue));
	sprintf(szTmp, szJitTemplate, szValue);

	if (!GetSzValue(szAeDebug, szDebugger))
		return FALSE;

	// [dolphin #13999 6/17/94 mikemo]  Do a case-insensitive compare, in
	// case the exe name is in a different case in the registry from what
	// GetModuleFileName returned to us.  This is also the right thing to
	// do because the IDE's command line options (such as -P and -E in
	// this case) are case-insensitive.
	if (_tcsicmp(szValue, szTmp))
		return FALSE;

	if (!GetSzValue(szAeDebug, szAuto))
		return FALSE;

	return (atoi(szValue) == 0);
} // GetJitState

BOOL CDebugOpt::GetJitState()
{
	return ::GetJitState();
}

VOID SetJitState(BOOL fNewState)
{
	BOOL fOldState = GetJitState();
	if (fNewState == fOldState)
		return;

	char szValue[256], szTmp[256+32];

	if (fNewState)
	{
		// fetch and save the previous auto value
		if (!GetSzValue(szAeDebug, szOldAuto) || !szValue[0])
		{
			if (!GetSzValue(szAeDebug, szAuto))
				szValue[0] = 0;
		}

		CString strSection;
		strSection = "Debug";
		strSection += chKeySep;
		strSection += "Just in Time";
		WriteRegString(strSection, szAuto, szValue);

		if (!GetSzValue(szAeDebug, szDebugger) || !szValue[0])
			_tcscpy(szValue, szDrWatson);

		WriteRegString(strSection, szDebugger, szValue);

		// now that we've saved the old values, make the IDE the new JIT debugger

		GetModuleFileName(AfxGetApp()->m_hInstance, szValue, sizeof(szValue));
		sprintf(szTmp, szJitTemplate, szValue);

		WriteProfileString(szAeDebug, szDebugger, szTmp);
		WriteProfileString(szAeDebug, szAuto,     "0");

		// nuke any temporary OldAuto value
		WriteProfileString(szAeDebug, szOldAuto, NULL);
	}
	else
	{
		// restore the old debugger, or if none available, use Dr. Watson
		CString strSection;
		strSection = "Debug";
		strSection += chKeySep;
		strSection += "Just in Time";
		CString cstr = GetRegString(strSection, szDebugger, szDrWatson);
		WriteProfileString(szAeDebug, szDebugger, cstr);

		cstr = GetRegString(strSection, szAuto, "1");
		WriteProfileString(szAeDebug, szAuto, cstr);

		// nuke any temporary OldAuto value
		WriteProfileString(szAeDebug, szOldAuto, NULL);
	}
} // SetJitState

VOID CDebugOpt::SetJitState(BOOL fNewState)
{
	::SetJitState(fNewState);
}

BEGIN_MESSAGE_MAP(CTLOpt, C3dDialog)
	//{{AFX_MSG_MAP(CTLOpt)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_BN_CLICKED(IDC_SETUP, OnClickedSetup)
	ON_CBN_SELCHANGE(IDC_PLATFORM_LIST, OnPlatformChange)
	ON_LBN_SELCHANGE(IDC_TRANSPORT_LIST, OnTransportChange)
    ON_BN_CLICKED(IDC_CONNECT_NOW, OnClickedConnectNow )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CTLOpt::OnInitDialog()
{
    BOOL    fVisibleConnectNow = FALSE;

	m_plstPlatform  = ((CComboBox *)GetDlgItem(IDC_PLATFORM_LIST));
	m_plstTransport = ((CListBox *)GetDlgItem(IDC_TRANSPORT_LIST));
	m_pbutSetup     = (CButton *)GetDlgItem(IDC_SETUP);

	m_plstPlatform->SetExtendedUI(TRUE);
	m_plstPlatform->ResetContent();

	gpIBldPlatforms->GetSupportedPlatformCount(&m_cPlatforms);
	m_rgPlatforms = (uniq_platform *)malloc(m_cPlatforms * sizeof(uniq_platform));
	m_rgiTL       = (UINT *)malloc(m_cPlatforms * sizeof(UINT));

	if (!m_rgPlatforms)
		return FALSE;

    InitChildFont(this, IDC_CONNECT_NOW_TEXT );

	uniq_platform upCurrent = unknown_platform;

	if ( gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK )
		gpIBldPlatforms->GetCurrentPlatform(ACTIVE_BUILDER, &upCurrent);

	uniq_platform upID = unknown_platform;

	gpIBldPlatforms->InitPlatformEnum();

	int iPlatform = 0;
	BOOL bBuildable = FALSE;
	while ( SUCCEEDED(gpIBldPlatforms->NextPlatform(&upID)) )
	{
		if (!((gpIBldPlatforms->IsPlatformSupported(upID) == S_OK) &&
			 (gpIBldPlatforms->GetPlatformBuildable(upID, &bBuildable) == NOERROR) &&
			 bBuildable))
		{
			m_cPlatforms--;
			continue;	// ignore unsupported platforms
		}

		LPCSTR pszDesc;

		gpIBldPlatforms->GetPlatformUIDescription(upID, &pszDesc);

		m_plstPlatform->AddString((LPSTR)pszDesc);

		if (upID == upCurrent)
			m_plstPlatform->SetCurSel(iPlatform);

        fVisibleConnectNow |= (upID == macppc);

		m_rgPlatforms[iPlatform] = upID;

		gpIBldPlatforms->GetPlatformCurrentTLIndex(upID, &(m_rgiTL[iPlatform]));

		iPlatform++;
	}

	if ( (upCurrent == unknown_platform) || (gpIBldPlatforms->IsPlatformSupported(upCurrent) == S_FALSE) )
		m_plstPlatform->SetCurSel(0);

	ASSERT(iPlatform == m_cPlatforms);

	if (m_cPlatforms < 2)
		m_plstPlatform->EnableWindow(FALSE);

    ((CWnd *)GetDlgItem(IDC_CONNECT_NOW))->ShowWindow(fVisibleConnectNow);
    ((CWnd *)GetDlgItem(IDC_SETTINGS_TEXT))->ShowWindow(!fVisibleConnectNow);
    ((CWnd *)GetDlgItem(IDC_CONNECT_NOW_TEXT))->ShowWindow(fVisibleConnectNow);

	OnPlatformChange();

	return TRUE;
}

CTLOpt::CTLOpt() : C3dDialog(CTLOpt::IDD)
{
	m_rgPlatforms = NULL;
	m_rgiTL       = NULL;
	m_cPlatforms  = 0;
    m_fConnectNow = FALSE;
}

CTLOpt::~CTLOpt()
{
	if (m_rgPlatforms)	free(m_rgPlatforms);
	if (m_rgiTL) 		free(m_rgiTL);
}

void CTLOpt::OnPlatformChange()
{
	int iPlatform = m_plstPlatform->GetCurSel();
	uniq_platform upPlatform = m_rgPlatforms[iPlatform];
    BOOL    fEnableConnectNow;

	m_plstTransport->ResetContent();

	int cTL;

	gpIBldPlatforms->GetPlatformTLCount(upPlatform, &cTL);

	for (int iTL = 0; iTL < cTL; iTL ++)
	{
		const TCHAR *szDesc;

		gpIBldPlatforms->GetPlatformTLDescription(upPlatform, (UINT)iTL, &szDesc);
		m_plstTransport->AddString(szDesc);
	}

	m_plstTransport->SetCurSel(m_rgiTL[iPlatform]);

#pragma message ( "CTLOpt::OnPlatformChange: Need to query EM metrics for remote JIT" )
    fEnableConnectNow = (upPlatform == macppc);
    ((CWnd *)GetDlgItem(IDC_CONNECT_NOW))->EnableWindow(fEnableConnectNow);

	OnTransportChange();
}

void CTLOpt::OnTransportChange()
{
	int iPlatform = m_plstPlatform->GetCurSel();
	uniq_platform upPlatform = m_rgPlatforms[iPlatform];
	int iTL = m_plstTransport->GetCurSel();
	m_rgiTL[iPlatform] = iTL;

	UINT tfl;

	gpIBldPlatforms->GetPlatformTLFlags(upPlatform, iTL, &tfl);

	m_pbutSetup->EnableWindow(!!(tfl & TFL_CFGABLE));
}

void CTLOpt::OnClickedSetup()
{
	int iPlatform = m_plstPlatform->GetCurSel();
	uniq_platform upPlatform = m_rgPlatforms[iPlatform];
	int iTL = m_plstTransport->GetCurSel();

	const TCHAR *szTLName;

	gpIBldPlatforms->GetPlatformTLName(upPlatform, iTL, &szTLName);

	if (!FSetupDLL(szTLName, "TLSetup", MptFromPlatform (upPlatform)))
	{
		const TCHAR *szUIDesc;
		const TCHAR *szTLDesc;

		gpIBldPlatforms->GetPlatformUIDescription(upPlatform, &szUIDesc);
		gpIBldPlatforms->GetPlatformTLDescription(upPlatform, iTL, &szTLDesc);

		ErrorBox(DBG_TL_Config_Err, (LPCSTR)szUIDesc, (LPCSTR)szTLDesc);
	}
}

void CTLOpt::OnClickedConnectNow()
{
    m_fConnectNow = TRUE;
    OnOK();
}

void CTLOpt::OnOK()
{
	m_iPlatform = m_plstPlatform->GetCurSel();
    C3dDialog::OnOK();
}

void CTLOpt::OnHelp()
{
	OnCommandHelp(0, 0);
}


VOID PASCAL InvokeHelp (DWORD dwHelpId)
{
	theApp.HelpOnApplication(dwHelpId);
}


MPT
MptFromPlatform(
	uniq_platform	Platform
	)
{
	switch (Platform)
	{
		case win32x86: return mptix86;
		case macppc: return mptmppc;
		case win32mips: return mptmips;
		case win32alpha: return mptdaxp;
		case win32ppc: return mptntppc;
	}

	return mptUnknown;
}



Protect <HKEY>::~Protect(
	)
/*++

Routine Description:

	Destructor for the HKEY object.

--*/
{
	if (m_h)
	{
		RegCloseKey (m_h);
		m_h = NULL;
	}
}

	

LONG
OSDAPI
RegistryGetSet(
	LPTSTR		KeyName,
	LPTSTR		ValueName,
	DWORD*		pdwType,
	BYTE*		Data,
	DWORD		cbData,
	BOOL		fSet
	)
/*++

Routine Description:

	This function Gets/Sets the registry value ValueName with data Data under the
	debugger's root key.

	KeyName -- relative path for a key name; for example:
			   "Build System\Components\Platforms"
				
	ValueName -- the name of a value to set; for example, "TLN0T"

	Data -- data to set to be set to

	pdwType -- the registry type

	cbData -- size of data to be read/written

	fSet -- TRUE means we are setting (save to registry), FALSE means getting
		  	getting from registry

Return Value:

	size of the data written/read.

--*/
{
	TCHAR			FullKeyName [_MAX_PATH];
	DWORD			dwLength;
	HKEY			hKey = NULL;
	Protect <HKEY>	protect (hKey);
	LONG			Err;
	

	dwLength = sizeof (FullKeyName);
	VERIFY (GetRegistryRoot (FullKeyName, &dwLength));

	if (KeyName && *KeyName)
	{
		//
		// 	this must be a relative registry path
		//
			
		ASSERT (*KeyName != '\\');
			
		if (FullKeyName [dwLength - 1] != '\\')
		{
			FullKeyName [dwLength++] = '\\';
			FullKeyName [dwLength] = '\000';
		}

		strcpy (&FullKeyName [dwLength], KeyName);
	}

	Err = RegCreateKeyEx (HKEY_CURRENT_USER,
						  FullKeyName,
						  0,
						  NULL,		// NULL ok for class ??
						  REG_OPTION_NON_VOLATILE,
						  KEY_ALL_ACCESS,
						  NULL,
						  &hKey,
						  NULL				// NULL ok?
						  );

	if (Err != ERROR_SUCCESS)
		return 0;

	
	if (fSet)
	{
		//
		//	attempting to set value
		//
		
		Err = RegSetValueEx (hKey,
	 						 ValueName,
		 					 0,
							 *pdwType,
							 Data,
 							 cbData
							 );

		if (Err != ERROR_SUCCESS)
			return 0;

		return cbData;
	}
	else
	{
		//
		//	attempting to get value
		//

		DWORD	lcbData = cbData;
		
		Err = RegQueryValueEx (hKey,
							   ValueName,
							   0,
							   pdwType,
							   Data,
							   &lcbData
							   );

		if (Err != ERROR_SUCCESS)
			return 0;

		return lcbData;
	}


	return 0;  // NOTREACHED
}
		
	

		
		
							  
			

BOOL FSetupDLL(LPCSTR szFileName, LPCSTR szEntry, MPT mpt)
{
	BOOL	fRet = FALSE;

	if ( !DebuggeeAlive() )
	{
		char 			szPath[ _MAX_PATH ];
		char 			szDrive[ _MAX_DRIVE ];
		char 			szDir[ _MAX_DIR ];
		char 			szFName[ _MAX_FNAME ];
		char 			szExt[ _MAX_EXT ];
		int 			iOldErrorMode = SetErrorMode ( SEM_NOOPENFILEERRORBOX );
		struct _stat	statbuf;
		HANDLE			h;

		GetModuleFileName(theApp.m_hInstance, szPath, sizeof(szPath));
		_splitpath(szPath, szDrive, szDir, szFName, szExt);
		_makepath(szPath, szDrive, szDir, NULL, NULL);

		// Make sure we are loading a debug or release debugger .dll
		TCHAR rgchDllFile[ _MAX_FNAME ];
		_tcscpy(rgchDllFile, szFileName);
		#ifdef _DEBUG
			_tcscat(rgchDllFile, "D.DLL");
		#else
			_tcscat(rgchDllFile, ".DLL");
		#endif

		_ftcscat(szPath, rgchDllFile);

		// First search for the file in our directory
		if( _stat( szPath, &statbuf ) == 0 && (statbuf.st_mode & _S_IFREG) )
		{
			// Load the dll
			h = LoadLibrary( szPath );
		}

		// Can't find it, let Windows look for it
		else
		{
			h = LoadLibrary( szFileName );
		}

		// Restore the error mode
		SetErrorMode( iOldErrorMode );

		// Handle was valid, continue with setup/config
		// Win32 h non-zero == VALID, Win16 h >= 32
		if ( h )
		{
			typedef void (__stdcall* PFNSETUP) (TLSS* tlss);

			PFNSETUP pfnsetup = (PFNSETUP) GetProcAddress ((HINSTANCE)h, szEntry);

			// If the function/export exists do it
			if ( pfnsetup )
			{

				TLSS	tlss;

				tlss.fInteractive = TRUE;
				tlss.fSave = FALSE;
				tlss.lpvPrivate = (LPVOID) _SushiGetSafeOwner (NULL);
				tlss.lParam = (LPARAM) h;
				tlss.mpt = mpt;
				tlss.fRMAttached = FALSE;
				tlss.lpfnGetSet = RegistryGetSet;

				ASSERT (mpt != mptUnknown);
				pfnsetup (&tlss);
				
				fRet = TRUE;
			}
			else
			{
				ASSERT (FALSE);
			}
			

			// Release the library
			FreeLibrary( (HINSTANCE)h );
		}
	}
	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\enclog.h ===
///////////////////////////////////////////////////////////////////////////////
// 
// enclog.h
//
// Support for logging edit-and-continue results to the net for QA
//
///////////////////////////////////////////////////////////////////////////////

#define LOG_INIT					"Init"
#define LOG_POPEDIT					"PopEdit"
#define LOG_SAVEOLDOBJS				"SaveOldObjs"
#define LOG_GETCOMPILEENV			"GetCompileEnv"
#define LOG_INITIALIZESPAWN			"InitializeSpawn"
#define LOG_COMPILEERROR			"CompileError"
#define LOG_PUSHNEWEDIT				"PushNewEditHResultFailed"
#define LOG_APPLYCURRENTEDIT		"ApplyCurrentEditHResultFailed"
#define LOG_ADDMODSTOEC				"AddModsToEC"
#define LOG_DLGYES					"DlgYes"
#define LOG_DLGNO					"DlgNo"
#define LOG_RELINKFAILED			"RelinkFailed"
#define LOG_HRESULT_MEMMAP			"HResult=MEMMAP"
#define LOG_HRESULT_INITMEMALLOC	"HResult=INITMEMALLOC"
#define LOG_HRESULT_EXPORTPUB		"HResult=EXPORTPUB"
#define LOG_HRESULT_FIXUP			"HResult=FIXUP"
#define LOG_HRESULT_MEMWRITE		"HResult=MEMWRITE"
#define LOG_HRESULT_THUNKWRITE		"HResult=THUNKWRITE"
#define LOG_HRESULT_NOPDBSUPPORT	"HResult=NOPDBSUPPORT"
#define LOG_HRESULT_UNKNOWN			"HResult=Unknown"
#define LOG_SUCCESS					"Success"

#define MAX_NET_ACCESS_ATTEMPTS		40

void ENCLogPerformance(clock_t &start_clock, char* szStatus);
UINT ENCLogToNet(LPVOID pParam);
UINT ENCLogToNetCString(LPVOID pParam);
void ENCLogForHResult(HRESULT hResult);
void ENCLogHmod(HMOD hmod);

#ifdef _ENCLOG

// logs a static string to the net
inline void NET_LOG(LPCTSTR lsz) {
	AfxBeginThread(ENCLogToNet, (LPVOID)lsz);
}

// logs an HRESULT to the net
inline void NET_LOG_HRESULT(HRESULT hResult)	{
	ENCLogForHResult(hResult);
}

// logs information about an obj file used during ENC
inline void NET_LOG_HMOD(HMOD hMod) {
	ENCLogHmod(hMod);
}

// logs a string to the net
inline void NET_LOG_EX(LPCTSTR lsz) {
	CString *pStr = new CString(lsz);
	// pStr will be deleted by the logging thread
	AfxBeginThread(ENCLogToNetCString, (LPVOID)pStr);
}

#else
#define NET_LOG(pParam)
#define NET_LOG_HRESULT(hResult)
#define NET_LOG_HMOD(hMod)
#define NET_LOG_EX(pStr)
#endif

#define PERF_LOG(start_clock, szStatus) ENCLogPerformance(start_clock, szStatus);
#define START_PERF_CLOCK()					\
	clock_t start_clock = clock();			\
	static char szFailure[] = "Failure";	\
	static char szSuccess[] = "Success";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\eetm.cpp ===
//
// This file contains the code that wraps the interface to the EE
//

#include "stdafx.h"
#pragma  hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// CTM - abstract base class which provides the interface to a TM.

IMPLEMENT_DYNAMIC(CTM,CObject);


CTM::~CTM( ) {}

// CRootTM

IMPLEMENT_DYNAMIC(CRootTM, CTM);

CRootTM::CRootTM (LPCSTR lpszName, BOOL bNoFuncEval /* = FALSE */)
{
	// The user typed in a name.
	// create the basic TM corresponding to it.
	// Note that the check to see if the name points to a valid
	// data item happens before we call the constructor.

	ASSERT(lpszName != NULL);

	BOOL fCase = TRUE;
	USHORT iEnd = 0;

	// initialize fields with neutral values in case of failure...

	m_htm = htmNil;
	m_fExpandedTM = FALSE;
	m_bNameTM	= TRUE ;

	CommonInit();
	InvalidateCaches();

	char *szExpr = (char *)lpszName;	// cast away const...

	// save away the expression, we'll need it in case
	// we can't parse & bind right now...

	m_cstrNameCache = szExpr;
	m_fNameCacheValid = TRUE;

	m_bNoFuncEval = bNoFuncEval;

	// parse expression, if can't be parsed we have no useable TM
	if ( (pEXF==NULL) || (EEParse(szExpr, ::radix, fCase, &m_htm, &iEnd) != EENOERROR) )
	{
		m_htm = htmNil;
		return;
	}

	// now try to bind and evaluate, if these fail the item is likely out
	// of scope, save the TM as it may come into scope later...

	if (RebindAndEvaluate() != EENOERROR)
	{
		return;
	}

	// if we get here, all is well, m_htm has been assigned with a bound
	// and evaluated TM and we're ready to go...
}

// Constructor is called with a handle to a codeview object,
// and the second argument indicates the type of the handle.

CRootTM::CRootTM (HIND h , HANDLE_TYPE hType  )
{
	m_fNameCacheValid = FALSE;
	
	CommonInit( );
	InvalidateCaches();

	m_bNameTM = FALSE ; // TM's not created by passing in a string value.

	switch ( hType )
	{
		case IS_HTM:
		{
			// this constructor is given a TM that was already parsed, bound,
			// and evaluated successfully. There is sadly no way to assert this
			// because the EE has no such API's...
			
            HTM htm = HTM(h) ;
			m_htm = htm;
			m_fExpandedTM = TRUE;
			break;
		}
		case IS_HSYM:
		{
			HSYM hSym = h ;
			// this constructor is given an HSYM and needs to convert that
			// to a TM.
			CXF curCxf ( ::CxfWatch( ) );
			PCXF pCxf = &curCxf ;

			USHORT iEnd = 0;

			m_htm = htmNil;
			m_fExpandedTM = FALSE;

			if ( (m_eestatus = EEGetTMFromHSYM( hSym, SHpCXTFrompCXF(pCxf), &m_htm, &iEnd, TRUE, FALSE )) != EENOERROR )
			{
				m_htm = htmNil ;
				return ;
			}
	
			if ( (m_eestatus = EEvaluateTM( &m_htm, SHpFrameFrompCXF(pCxf) , EEVERTICAL)) != EENOERROR )
			{
				m_htmSaved = m_htm ;
				m_htm = htmNil ;
				return ;
			}
			break;
		}
		default:
			ASSERT(FALSE);
	}
}


		
CRootTM::~CRootTM()
{

	// at most one of these may be valid, otherwise we don't
	// know which item to free...

	ASSERT(!m_htmSaved || !m_htm);

	// release the htm we have saved (if any)

	if (m_htm)
	{
		EEFreeTM(&m_htm);
		m_htm = htmNil;
	}

	if (m_htmSaved)
	{
		EEFreeTM(&m_htmSaved);
		m_htmSaved = htmNil;
	}
}

#if _DEBUG
void CRootTM::Dump(CDumpContext& dc) const
{
	CTM::Dump(dc);

	dc << "Name TM=" << (m_bNameTM ? "TRUE" : "FALSE") ;
	dc << "Expanded TM=" << (m_fExpandedTM ? "TRUE" : "FALSE") ;
	dc <<  "Cached Name was " << m_cstrNameCache ;
}
#endif

BOOL CRootTM::IsExpandable ( ) const
{
	BOOL bRet = FALSE ;

	// check for nil TM
	if (!m_htm) return FALSE;

	// must copy the member to preserve const-ness of this function
	HTM htm = m_htm;
	
	switch (EEIsExpandable(&htm))
	{
		case EENOTEXP:			// not expandable
		case EETYPE:			// expandable as type (not handled yet)
		case EETYPENOTEXP:		// not expandable type
		case EETYPEPTR:			// pointer type? -- not handled yet
			bRet = FALSE ;
			break ;

		case EEAGGREGATE:		// a struct, array, union, class, etc.
		case EEPOINTER:			// a pointer that needs to be dereferenced
			bRet =  TRUE;
			break;
	}

	if ( bRet )
	{
		LONG lcChild ;
		SHFLAG shf ;

		// We need to additionally ensure that the TM has a non-zero
		// number of children because the previous check ( EEIsExpandable)
		// does not take care of zero-sized arrays and structures with no members.
		if  (EEcChildrenTM (&htm, &lcChild , &shf) == EENOERROR)
			bRet = (lcChild == 0) ? FALSE : TRUE ;
		else
			bRet = FALSE ;
	}
	return bRet ;
}

BOOL	CRootTM::IsNameEditable (  ) const
{	
	return m_bNameTM ;
}

BOOL  CRootTM::IsSynthChildNode( ) const
{
	// Only valid/expanded TM's could be synthesized children.
	if ( m_htm == htmNil || !m_fExpandedTM )
		return FALSE;

	RTMI rtmi = { 0 }  ;
	HTI hTI ;
	HTM htm = m_htm;
	
	// Request information from the EE.
	rtmi.fSynthChild = TRUE ;	

	if ( ( EEInfoFromTM(&htm, &rtmi, &hTI) != EENOERROR ) )
	{
		return FALSE ;
	}
	ASSERT( hTI != ( HTI ) NULL );

	// Get the TM Info structure.
	PTI pTI = ( PTI ) BMLock(hTI);
	ASSERT(pTI != NULL);

	BOOL retVal = FALSE;
	if (pTI->fResponse.fSynthChild)
	{
		retVal = pTI->fSynthChild;
	}	

	// Free up the resources.
	BMUnlock(hTI);
	EEFreeTI(&hTI);
	
	// FUTURE: Maybe we want to cache this value as well
	// to avoid querying the EE too often.
	return retVal ;
}
	
BOOL  CRootTM::HasSynthChild( )	const
{
	if ( m_htm == htmNil)
		return FALSE;

	// Cast away constness.
	HTM htm = m_htm;
	USHORT iEnd;
	BOOL retval = FALSE;
	BOOL bOldState = EEEnableAutoClassCast(TRUE);

	if (EEIsExpandable(&htm) == EEPOINTER)
	{
		HTM htmDeref;
		if ( EEDereferenceTM(&htm, &htmDeref, &iEnd, TRUE) == EENOERROR)
		{
			if ( EEIsExpandable(&htmDeref) == EEAGGREGATE )
			{
				long cChildren;
				if (EEcSynthChildTM(&htmDeref, &cChildren) == EENOERROR)
				{
					ASSERT(cChildren <= 1);

					if (cChildren != 0 )
						retval = TRUE;
				}
			}
			EEFreeTM(&htmDeref);
		}
	}	
	
	EEEnableAutoClassCast(bOldState);
	return retval;
}

BOOL CRootTM::IsValueValid() const
{
	if (!m_htm)
		return FALSE;
	else
		return TRUE;
}		

BOOL CRootTM::CouldParseName( ) const
{
	ASSERT(m_bNameTM);

	if (m_bNameTM)
	{
		if (m_htm == htmNil && m_htmSaved == htmNil)
			return FALSE;
	}
	return TRUE;
}

BOOL CRootTM::IsClass() const
{
	if (!m_htm && !m_htmSaved)  return FALSE;
	
	HTM htm = (m_htm != NULL) ? m_htm : m_htmSaved ;

	ETI eti;
	if (EEGetExtendedTypeInfo(&htm, &eti) == EENOERROR)
	{
		if ( eti == ETICLASS)
			return TRUE;
	}
	return FALSE;
}
	

BOOL CRootTM::IsDataTM() const
{
	// Does this TM correspond to a data value.
	// Things like 'CWnd' which is a type and function names, labels are excluded.
	
	if (!m_htm && !m_htmSaved) return FALSE;	

	HTM htm = (m_htm != NULL) ? m_htm : m_htmSaved ;

	EEPDTYP eetyp = EEIsExpandable(&htm);

	switch (eetyp)
	{
		case EETYPE:
		case EETYPENOTEXP:
		case EETYPEPTR:
			return FALSE;
	}

	// Check for function names
	ETI eti;
	if (EEGetExtendedTypeInfo(&htm, &eti) == EENOERROR)
	{
		if ( eti == ETIFUNCTION )
			return FALSE;
	}

	RTMI rtmi = { 0 };
	HTI hTI;

	// Request information from the EE.
	rtmi.fLabel = TRUE;

	if ( ( EEInfoFromTM(&htm, &rtmi, &hTI) != EENOERROR ) )
	{
		return FALSE ;
	}
	ASSERT( hTI != ( HTI ) NULL );

	// Get the TM Info structure.
	PTI pTI = ( PTI ) BMLock(hTI);
	ASSERT(pTI != NULL);

	BOOL retVal = TRUE;

	if (pTI->fResponse.fLabel)
	{
		retVal = ! pTI->fLabel;	 // Should not be a label.
	}

	// Free up the resources.
	BMUnlock(hTI);
	EEFreeTI(&hTI);

	return retVal;
}
				
		
BOOL CRootTM::IsTypeIdentical(CTM *pTM)
{
	return (GetType( ) == pTM->GetType());
}

BOOL CRootTM::HadSideEffects( ) const
{
	return m_bHadSideEffects;
}

CTM * CRootTM::GetTMChild(int nChild)
{
	// The TM must be an expandable one...
	ASSERT(IsExpandable());

	HTM htm = m_htm;

	USHORT iEnd;
	BOOL fFreeTM = FALSE;
	CXF curCxf( ::CxfWatch( ) );
	PCXF pCxf = &curCxf;
	CRootTM * pChildTM = NULL;
	BOOL bOldState = EEEnableAutoClassCast(TRUE);

	// If we have a pointer to an aggregate we want to dereference
	// before getting the children.

	switch(EEIsExpandable(&m_htm))
	{
		case EEPOINTER:
			if (EEDereferenceTM(&m_htm, &htm, &iEnd, TRUE) != EENOERROR)
				break;

			if ( EEIsExpandable(&htm) != EEAGGREGATE )
			{

				// Plain pointer. If we were asked for the first
				// child go ahead and pass it back now.
				if ( nChild == 0 )
				{
					// This eval could fail if we have NULL pointer etc. We
					// will intentionally ignore the failure.
					EEvaluateTM(&htm, SHpFrameFrompCXF( pCxf ), EEVERTICAL);

					pChildTM = new CRootTM(HIND(htm), IS_HTM );
					break;
				}
				else
				{
					fFreeTM = TRUE;
					break;
				}

			}

			fFreeTM = TRUE;
			// Fall through.
		
		case EEAGGREGATE:
		{	
			HTM htmNew;
			
			if (EEGetChildTM(&htm, nChild, &htmNew, &iEnd, 0, TRUE) == EENOERROR)
			{
				// It is possible and okay if this evaluate fails, because the memory
				// pointed to is not valid etc.
				EEvaluateTM(&htmNew, SHpFrameFrompCXF( pCxf ), EEVERTICAL);
						
				pChildTM = new CRootTM(HIND(htmNew), IS_HTM );
			}
			break;
		}
	}

	if (fFreeTM) EEFreeTM(&htm);

	EEEnableAutoClassCast(bOldState);

	return pChildTM;
}

CTM * CRootTM::GetSynthChildTM( )
{
	if ( !HasSynthChild( ))
		return NULL;
		
	return GetTMChild(0);
}

DWORD  CRootTM::GetChildCount( )
{
	LONG numChild = 0;
	SHFLAG fVarChildren;

	if (IsExpandable()) 
	{
		if (EEcChildrenTM(&m_htm, &numChild, &fVarChildren) != EENOERROR)
			numChild = 0;
	}
	
	return numChild;
}


BOOL  CRootTM::GetTMChildren(CTMArray& childTMArray)
{
	// the TM must be an expandable one...
	ASSERT (IsExpandable());
	
	ASSERT( childTMArray.GetSize() == 0);

	// we'll either use a computed htm from a dereference pointer
	// or else the member htm if that turns out to be an aggregate
	// setup for the initial operation in either case by copying
	// m_htm...
	HTM htm = m_htm;

	
	SHFLAG fVarChildren;
	USHORT iEnd;
	BOOL fFreeHTM = FALSE;
	CXF curCxf ( ::CxfWatch( ) );
	PCXF pCxf = &curCxf ;
	BOOL bOldState = EEEnableAutoClassCast(TRUE);

	switch (EEIsExpandable(&m_htm))
	{
	// if we're a pointer, we de-reference first then expand...
	case EEPOINTER:
		{
		if (EEDereferenceTM(&m_htm, &htm, &iEnd, TRUE) != EENOERROR)
			break;

		// if this is not an aggregate, then return just the one TM
		// in the array...
		if (EEIsExpandable(&htm) != EEAGGREGATE)
			{
			// evaluate the TM (so far it is only bound)
			// even if the TM cannot be succesfully evaluated,
			// add it to the TM array as we might be able to evaluate
			// it later ( after the debuggee state changes).
			EEvaluateTM(&htm, SHpFrameFrompCXF( pCxf ), EEVERTICAL);
			
			// now add the TM to the array of child TM's

            CRootTM* pChildTM = new CRootTM(HIND(htm), IS_HTM );
			childTMArray.Add(pChildTM);
			break;
			}
		}

	// fall through

	// at this point we know that we're not going to want
	// the htm we've created above, so we're going to throw it away
	// when we're done expanding

	fFreeHTM = TRUE;

	case EEAGGREGATE:
		{
		LONG numChildren;

		// get the number of children and iterate through them

		if (EEcChildrenTM(&htm, &numChildren, &fVarChildren) != EENOERROR)
			break;

		for (LONG i = 0 ; i < numChildren ; i++ )
			{
			HTM htmNew;

			// extract and evaluate the child TM (if possible)

			// If we could not get the child TM,  continue looking  further
			if (EEGetChildTM(&htm, i, &htmNew, &iEnd, 0, TRUE) != EENOERROR )
				continue;

			// It is possible that this evaluate fails, because the memory pointed
			// to is not valid etc. However we still add this TM to the child TM array,
			// as we might be able to evaluate it later ( after the debuggee state changes)

			EEvaluateTM(&htmNew,SHpFrameFrompCXF( pCxf ),EEVERTICAL);

            CRootTM* pChildTM = new CRootTM(HIND(htmNew), IS_HTM);
			childTMArray.Add(pChildTM);
			}

		// we would like to assert that the size of the array is
		// indeed the same as the size of the array but we can't
		// do so because the EE might run out of memory or some
		// such causing the API's to fail and hence not all of the
		// members to be present
		}
		break;
	}

	// if htm is a temporary TM (so far that can only occur if we
	// are dereferencing a pointer to a structure) then we must free it now
	if (fFreeHTM) EEFreeTM(&htm);

	EEEnableAutoClassCast(bOldState);

	if ( childTMArray.GetSize( ) != 0 )
		return TRUE ;
	else
		return FALSE;
}


CString CRootTM::GetName()
{	
	// use the cache if it is valid, a special case of that is
	// if this is a root TM then we saved the name the user typed explicitly...

	if (!m_fNameCacheValid)
	{
		// this will hold the string for the name...
		EEHSTR hstrName;
		HTM htm = (m_htm) ? m_htm : m_htmSaved;

		if (!htm || EEGetNameFromTM(&htm, &hstrName) != EENOERROR)
		{
			// error condition...		
			m_cstrNameCache.Empty();
		}
		else
		{
			// fetch the string and return a good pointer...
			char *buf = (char *)BMLock(hstrName);

			if (buf == NULL)
				m_cstrNameCache.Empty();	
			else
				m_cstrNameCache = buf;

			BMUnlock (hstrName);
			EEFreeStr (hstrName);
		}

		m_fNameCacheValid = TRUE;
	}

	ASSERT(m_fNameCacheValid);

	return m_cstrNameCache;
}

CString CRootTM::GetExpr()
{	
	EEHSTR hstrExpr;
	EERADIX radixT;
	USHORT strIndex;
	CString strExpr;
	HTM htm = (m_htm) ? m_htm : m_htmSaved ;

	if (htm && EEGetExprFromTM(&htm, &radixT, &hstrExpr, &strIndex) == EENOERROR)
	{
		// fetch the string and return a good pointer...
		char *buf = (char *)BMLock(hstrExpr);

		if (buf != NULL)
		{
			strExpr = buf;
		}
				
		BMUnlock (hstrExpr);
		EEFreeStr (hstrExpr);
	}

	return strExpr;
}

// Return the expr without any format qualifiers, so for example if you have
// an expression foo,x this would return just foo.

CString CRootTM::GetExprSansFormat()
{	
	EEHSTR hstrExpr;
	EERADIX radixT;
	USHORT strIndex;
	CString strExpr;
	HTM htm = (m_htm) ? m_htm : m_htmSaved ;

	if (htm && EEGetExprFromTM(&htm, &radixT, &hstrExpr, &strIndex) == EENOERROR)
	{
		// fetch the string and return a good pointer...
		char *buf = (char *)BMLock(hstrExpr);

		if (buf != NULL)
		{
			strExpr = buf;
			strExpr = strExpr.Left(strIndex);
		}
				
		BMUnlock (hstrExpr);
		EEFreeStr (hstrExpr);
	}

	return strExpr;
}

CString CRootTM::GetValue( )
{
	EEHSTR hstrValue;
	
	if (!m_fValueCacheValid)
	{
		EEHSTR hstrErr = NULL;
		LPSTR lpError;
		EESTATUS eestatus;

		m_radix = ::radix ;	// Remember the radix that we last used to get the value.

		if (!m_htm )
		{
			// If m_htm is NULL, the last TM we tried to Bind and evaluate is in
			// m_htmSaved. Use that TM to get the error string. (see RebindAndEvaluate)
			if ( (htmNil != m_htmSaved) &&
				 (EEGetError(&m_htmSaved, m_eestatus, &hstrErr) == EENOERROR) &&
				 ((lpError = (char *)BMLock(hstrErr)) != NULL)
				)
			{
				m_cstrValueCache = lpError;
				BMUnlock(hstrErr);
				EEFreeStr (hstrErr);
			}
			else
			{
				m_cstrValueCache.LoadString(ERR_Unknown_Vars_Error);
			}
		}										  					
		else if ((eestatus = EEGetValueFromTM(&m_htm, ::radix, NULL, &hstrValue)) != EENOERROR)
		{
			if ( (EEGetError(&m_htm, eestatus, &hstrErr) == EENOERROR) &&
				 ((lpError = (char *)BMLock(hstrErr)) != NULL)
				)
			{
				m_cstrValueCache = lpError;
				
				BMUnlock(hstrErr);
				EEFreeStr (hstrErr);
			}
			else
			{
				m_cstrValueCache.LoadString(ERR_Unknown_Vars_Error);
			}

			m_htmSaved = m_htm;
			m_htm = htmNil;

			
		}
		else
		{
			char *buf = (char *)BMLock(hstrValue);

			if (!buf || !buf[0]) {
				m_cstrValueCache.LoadString(ERR_Unknown_Vars_Error);
			    m_htmSaved = m_htm;
			    m_htm = htmNil;

            }
			else {
				m_cstrValueCache = buf;
            }

			BMUnlock (hstrValue);
			EEFreeStr (hstrValue);
		}

		m_fValueCacheValid = TRUE;
	}

	ASSERT(m_fValueCacheValid);

	return m_cstrValueCache;
}

CString CRootTM::GetValueInRadix (int iRadix)
{
	EEHSTR hstrValue;
	EESTATUS eestatus;
	CString strValue;

	// If the TM is in error or we can't get the value for some reason, the radix
	// shouldn't matter, just return the value using the default radix.
	if (!m_htm || (eestatus = EEGetValueFromTM(&m_htm, iRadix, NULL, &hstrValue)) != EENOERROR )
		return GetValue();

	char *buf = (char *)BMLock(hstrValue);
	if (!buf || !buf[0]) {
		strValue.LoadString(ERR_Unknown_Vars_Error);
    }
	else {
		strValue = buf;
    }

	BMUnlock (hstrValue);
	EEFreeStr (hstrValue);

	return strValue;
}


		
CString CRootTM::GetEditableValue( )
{
	CString displayValue(GetValue( ));
	// Extract the sub-string till the first blank.
	int firstBlankIndex = displayValue.Find( _T(' '));
	ASSERT( firstBlankIndex != 0);

	if ( firstBlankIndex == -1 )
	{
		// No blanks => whole string is editable.
		return (displayValue);
	}
	else
	{
		const TCHAR rgchQuote[] = "\'\"";

		int  firstQuoteIndex = displayValue.FindOneOf(rgchQuote);
		
		if ( firstQuoteIndex == -1 || firstBlankIndex < firstQuoteIndex )	
		{
			return ( displayValue.Left(firstBlankIndex));
		}
		else
		{
			// if we get here then we are probably a fortran string
			// that contains spaces
			// eg
			// "'abcd efg'"
			return displayValue;
		}
	}	
}	
	
BOOL CRootTM::IsValueEditable( )
{
	if (m_fValEditableCacheValid)
		return m_fValEditableCache;

	m_fValEditableCache = FALSE;
	m_fValEditableCacheValid  = TRUE ;

	// Can't edit the TM if we don't have a valid TM.
	if ( m_htm == htmNil )
		return FALSE;

	RTMI rtmi = { 0 }  ;
	HTI hTI ;

	// Request information about "lvalue"ness from the EE.
	rtmi.fLvalue = TRUE ;	

	if ( ( EEInfoFromTM(&m_htm, &rtmi, &hTI) != EENOERROR ) )
	{
		return FALSE ;
	}
	ASSERT( hTI != ( HTI ) NULL );

	// Get the TM Info structure.
	PTI pTI = ( PTI ) BMLock(hTI);
	ASSERT(pTI != NULL);

	BOOL retVal = pTI->fResponse.fLvalue  ;

	// Free up the resources.
	BMUnlock(hTI);
	EEFreeTI(&hTI);
	
	return m_fValEditableCache = retVal;		// cache value
}



CString CRootTM::GetType( )
{
	EEHSTR hstrValue;

	if ( !m_fTypeCacheValid )
	{
		HTM htm = m_htm;

		if (!htm || EENOERROR != EEGetTypeFromTM(&htm, NULL, &hstrValue, 0))
		{
			// error condition...
			m_cstrTypeCache.Empty();	// no type, error displayed in the value column.
		}
		else
		{
			char *buf = (char *)BMLock(hstrValue);
	
			if ( buf == NULL )
			{
				// error condition
				m_cstrTypeCache.Empty();
				return m_cstrTypeCache ;
			}

			// At the beginining of the type string is a HDR_TYPE structure followed
			// by the actual string. Increment pointer to get to the string.

			buf += sizeof(HDR_TYPE);

			m_cstrTypeCache = buf;

			BMUnlock (hstrValue);
			EEFreeStr (hstrValue);
		 }

		 m_fTypeCacheValid = TRUE;
	}

	ASSERT(m_fTypeCacheValid);

	return m_cstrTypeCache;
}

BOOL CRootTM::GetBCIA(PHBCIA phBCIA)
{
	BOOL retval = FALSE;
	HTM htm = m_htm;
	BOOL fFreeTM = FALSE;
	BOOL bOldState = EEEnableAutoClassCast(TRUE);
	USHORT iEnd;

	if (!m_htm)
		return retval;

	switch(EEIsExpandable(&m_htm))
	{
		case EEPOINTER:
			if (EEDereferenceTM(&m_htm, &htm, &iEnd, TRUE) != EENOERROR)
				break;

			fFreeTM = TRUE;
			if ( EEIsExpandable(&htm) != EEAGGREGATE )
			{
				// this is a plain pointer, no base classes here.
				break;
			}
			// Fall through
		case EEAGGREGATE:
			if ( EEGetBCIA(&htm, phBCIA) == EENOERROR )
			{
				retval = TRUE;
			}
			break;
		}

	if (fFreeTM)  EEFreeTM(&htm);

	EEEnableAutoClassCast(bOldState);

	return retval;
}

void CRootTM::FreeBCIA(PHBCIA phBCIA)
{
	EEFreeBCIA(phBCIA);
}

CTM::RES_REFRESH
CRootTM::Refresh()
{
	if ( m_bNoFurtherEval )
	{
		return SAME_TYPE; // Don't try and re-evaluate this expression.
	}
		
	// the debugger has stepped or memory has changed...
	// some event requires us to re-evaluate our expression...

	// We need to remember the type string at this point because
	// we are going to override and change back to the last bound
	// TM in the next step.

	CString oldTypeString;
	CString oldValueString;
	int oldRadix;

	BOOL oldValueValid = IsValueValid(); // Was the value valid before.

	if ( oldValueValid)
	{
		oldValueString = GetValue();
		oldRadix = m_radix;
	}

	if ( !m_fExpandedTM )
	{
		oldTypeString = GetType();
	}
	
	// m_fNameCacheValid is preserved through a refresh, but the value other
	// caches must be invalidated as they are no longer meaningful...
	InvalidateCaches();
	

	// if there is a saved TM then try to use that, this means
	// that we couldn't bind the TM in the original context that
	// was given but we might be able to do so now...

		
	if (m_htmSaved)
	{
		ASSERT(m_htm == htmNil);
		m_htm = m_htmSaved;
		m_htmSaved = htmNil;
	}

	// nil HTM cannot be rebound...
	if (!m_htm)
	{
		// check if we have a name that we couldn't parse...
		// if we don't have a name, the status of this TM is unchanged, so return SAME_TYPE.
		if (!m_fNameCacheValid)
			return SAME_TYPE  ;

		// if so, try to parse it now...
		char *szExpr = (char *)(const char *)m_cstrNameCache;

		BOOL fCase = TRUE;
		USHORT iEnd = 0;

		// if this fails, we can't refresh..
		// The parse failed before and still fails so we return SAME_TYPE
		// as the type status is still unknown.
		if (EEParse(szExpr, ::radix, fCase, &m_htm, &iEnd) != EENOERROR)
			return SAME_TYPE ;
	}

	// we now have a TM that we can try to bind and evaluate...

	ASSERT(m_htm != htmNil);

	// optimization .. assume that expanded types will not change because
    // if so the root type would have changed and we wouldn't be
	// re-evaluating this node at all...
	
	RES_REFRESH retVal;

	if (m_fExpandedTM)
	{
		RebindAndEvaluate();
		retVal = SAME_TYPE;
	}
	else
	{
		RebindAndEvaluate();

		// compare types and notify if change...
		CString newTypeString(GetType( ));
		retVal =  (oldTypeString == newTypeString) ? SAME_TYPE : TYPE_CHANGED;
	}

	// Do the neccessary checks to determine if the value changed.
	// The conditions are
	// a) The value should be valid both before and after the refresh.
	// b) the value should have changed.
	// c) we can't do simple string compares of the value string before and after because
	//    only the radix might have changed. So we need to check for that and then get the
	//    value in some canonical radix.
	
	if (oldValueValid && IsValueValid() && (oldValueString != GetValue( )))
	{
		// Check if this might be because the radix changed.
		if ( oldRadix != m_radix )
		{
			CString strValueInOldRadix = GetValueInRadix(oldRadix);
			m_bValueChanged = (oldValueString != strValueInOldRadix);
		}
		else
			m_bValueChanged = TRUE;
	}
	else
	{
		m_bValueChanged = FALSE;
	}

	return retVal;
}


// Update the value of the TM with a given string.
BOOL CRootTM::ModifyValue ( const CString& strValue )
{
	CXF curCxf ( ::CxfWatch( ) );
	PCXF pCxf = &curCxf   ;

	// If we don't have a valid TM we can't change the value.
	if ( m_htm == htmNil )
	{
		return FALSE ;
	}

		
	int radixExpr = 10;

	USHORT strIndex ;

	CString strAssignExpr = GetExprSansFormat();

	if (strAssignExpr.IsEmpty())
	{
		return ( FALSE );
	}

	// Create an assignment  expression of the form
	//  LHS = RHS .

	// Append the assignment operator to the string.
	strAssignExpr += rglan[ESilan()].AssignOp+1 ;

	// Finally append the RHS value
	strAssignExpr += strValue ;

	BOOL retVal = TRUE ;
	EEHSTR hTMAssignExpr  = htmNil ;

	// Cast away the constness so we can pass the string to the EE.
	LPSTR szAssignExpr = (char *)(const char *)strAssignExpr ;


	// Parse, bind and evaluate the expression to cause the value to change.
	if ( (EEParse( szAssignExpr, ::radix, FALSE,  &hTMAssignExpr , &strIndex) != EENOERROR) ||
		 (EEBindTM(&hTMAssignExpr, SHpCXTFrompCXF(pCxf), TRUE,FALSE) != EENOERROR) ||
		 (EEvaluateTM(&hTMAssignExpr , SHpFrameFrompCXF(pCxf), EEHORIZONTAL) != EENOERROR))
	{
		retVal = FALSE;		
	}

	if ( hTMAssignExpr  != htmNil )
	{
		EEFreeTM(&hTMAssignExpr);
	}
	
	return ( retVal );
}
					

EESTATUS
CRootTM::RebindAndEvaluate()
{
	EESTATUS eestatus;
	CXF curCxf( ::CxfWatch( ) ) ;	
	PCXF pCxf = &curCxf ;
	// It is very hard to get the EE/DHExecProc combination to restore
	// the callstack to the right frame. So we remember the frame number
	// before evaluating a function, and restore it after.
	int iCallsPrev = iCallsCxf;
	int chfme = CLChfmeOnStack();

	if ((eestatus = EEBindTM(&m_htm, SHpCXTFrompCXF(pCxf ),TRUE, FALSE)) == EENOERROR )
	{
		// If we succesfully bound it determin if it has a fnction eval.
		// The assumption is that if a succesful bind has a function eval every subsequent
		// bind will also have a function eval.
		if ( !m_bCheckedForFunc )
		{
			m_bCheckedForFunc = TRUE;

			RTMI rtmi = { 0 }  ;
			HTI hTI ;
			HTM htm = m_htm;
			
			// Request information from the EE.
			if ( ( EEInfoFromTM(&m_htm, &rtmi, &hTI) != EENOERROR ) )
			{
				return EEGENERAL ;
			}
			ASSERT( hTI != ( HTI ) NULL );

			// Get the TM Info structure.
			PTI pTI = ( PTI ) BMLock(hTI);
			ASSERT(pTI != NULL);

			BOOL retVal = FALSE;
			if ( pTI->fFunction )
			{
				m_bHasFunctionCall = TRUE;
			}
			
			
			if (m_bHasFunctionCall && m_bNoFuncEval)
			{
				m_bNoFurtherEval = TRUE;
				m_htmSaved = m_htm;
				m_htm = htmNil;
				return EENOERROR;
			}				

			// Free up the resources.
			BMUnlock(hTI);
			EEFreeTI(&hTI);
		}
		
		is_assign = FALSE;
		m_bHadSideEffects = FALSE;

		if (m_bHasFunctionCall && !lpprcCurr->IsBeyondEntryPoint())
		{
			// don't allow function evaluation until we have got to our entry point
			eestatus = EEBADADDR;
		}
		else
		{
			if ((eestatus = EEvaluateTM(&m_htm, SHpFrameFrompCXF(pCxf), EEVERTICAL)) != EENOERROR)
			{
				// Eval failed. If this expression has a function don't evaluate it from now on.
				// Might have an infinite loop or something and could cause bad things to happen.
				m_bNoFurtherEval =  m_bHasFunctionCall;
			}
			else {
				m_bHadSideEffects = is_assign;
			}
		}		
	}
	// restore the call-stack after the function call is done.
	if ( m_bHasFunctionCall && chfme != 0 )
	{
		CLGetWalkbackStack(hpidCurr, htidCurr, chfme);
		iCallsCxf = iCallsPrev;
	}

	if ( eestatus != EENOERROR )
	{
		// we (still) can't bind the TM we have, save it away, maybe later...
		m_htmSaved = m_htm;
		m_htm = htmNil;
	}

	m_eestatus = eestatus;

	// HACK: sometimes the EE will indicate that an evaluation has succeeded, when it
	// has the address to get to the value. The EE will not notice the problem (invalid addr)
	// till we actually try to fetch the value. So we fetch the value here and this should give
	// us the final, correct state of the TM. Note that the value string is cached and will
	// be re-used later.
	GetValue();
	
	
	return eestatus;
}


VOID
CRootTM::Restart()
{
	// the debuggee is restarting, the EE resources have been
	// freed right out from under us... mark them all as invalid
	// if we are not a root TM we will soon be destructed...

	// we DO NOT call EEFreeTM() on these TM's, the EE's memory allocator
	// has been reset completely, these TM's are completely useless...

	m_htm = htmNil;
	m_htmSaved = htmNil;
	m_bCheckedForFunc = FALSE;
	m_bHasFunctionCall = FALSE;
	m_bNoFurtherEval = FALSE;

	m_eestatus = EEGENERAL;
	// m_fNameCacheValid is preserved even through a restart, but the rest of the
	// caches are no longer meaningful...
	InvalidateCaches();
	
}


BOOL DebuggeeAlive(void);
PCXF PcxfLocal(void);
extern char szPath[_MAX_PATH];
BOOL PASCAL GetDebugTarget(PSTR szTarget, UINT cch);

/****************************************************************************

	FUNCTION:	CxfWatch()

	PURPOSE:	Returns a struct (not a pointer to struct) which is the
				context to use for Watch and QuickWatch expressions.
				[CUDA #3038 4/19/93 mikemo]

****************************************************************************/

CXF CxfWatch(void)
{
	CXF		cxf;
	HEXE	hexe;

	// Start with the CXF for the currently active stack frame.
	cxf = *PcxfLocal();

	// If we're in some nasty location that doesn't have source associated
	// with it, then modify our context to use the first module of the
	// program being debugged.

	if (cxf.cxt.hMod == 0 && DebuggeeAlive() &&
		GetDebugTarget(szPath, sizeof(szPath)))
	{
		hexe = SHGethExeFromName(szPath);
		cxf.cxt.hMod = SHGetNextMod(hexe, 0);
	}

	return cxf;
}

////////////////////////////////////////////////////////////////////////////////
// CReturnTM

IMPLEMENT_DYNAMIC(CReturnTM, CTM);

CReturnTM::CReturnTM (LPCSTR szName, LPCSTR szValue, LPCSTR szType)
{
	m_strName = szName;

	CString strReturned;
	strReturned.LoadString (IDS_RETURNED);

	m_strName += strReturned;

	m_strValue = szValue;
	m_strType = szType;

	m_fValueValid = TRUE;
}

CReturnTM::CReturnTM(const CReturnTM& rTM)
{
	m_strName = rTM.m_strName;
	m_strValue = rTM.m_strValue;
	m_strType = rTM.m_strType;
	m_fValueValid = rTM.m_fValueValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\encerr.cpp ===
//
// encerr.cpp
//
// Error message mapping for Edit and Continue
//

#include "stdafx.h"
#pragma hdrstop

#include "dbgenc.h"
#define assert ASSERT
#if defined(_DEBUG)
#define Debug(x)    x
#else
#define Debug(x)
#endif

#include "ref.h"
#include "simparray.h"
#include "enc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

typedef struct ERRTORES {
	ushort   errornum;
	UINT	 idResource;
} ERRTORES;

#define ENCERR(name)	{ name, IDS_##name },

// Edit and Continue error map
const static ERRTORES mpErrToRes[] = {
	ENCERR(Enc_Err_UnsupportedEdit)
	ENCERR(Enc_Err_CantInitialize)
	ENCERR(Enc_Err_ReadOnly)
	ENCERR(Enc_Err_CantCreateFile)
	ENCERR(Enc_Err_ExePath)
	ENCERR(Enc_Err_LinkedFromLib)
	ENCERR(Enc_Err_CantFindObj)
	ENCERR(Enc_Err_ObjMismatch)
	ENCERR(Enc_Err_IgnoringFile)
	ENCERR(Enc_Err_CmdNotExecuted)
	ENCERR(Enc_Err_CantUpdateFrame)
	ENCERR(Enc_Err_FrameFailed)
	ENCERR(Enc_Err_StackWalk)
	ENCERR(Enc_Err_TosEdited)
	ENCERR(Enc_Err_FrameEdited)
	ENCERR(Enc_Err_TooManyFiles)
};
#define MSGCNT	(sizeof (mpErrToRes)/sizeof (ERRTORES))


#define SEERR(name)		IDS_Enc_##name,
#define SEERR_CNT (LAST_SE_ERROR - FIRST_SE_ERROR + 1)

// Stack Editing error map
const static UINT mpSEErrToRes[ SEERR_CNT ] = {
	// These should be defined sequentially
	// in the order they appear in enc.h
	SEERR(E_SPNOTCANONICAL)
	SEERR(E_EXCEPTIONSTATE)
	SEERR(E_LOCALVARCHANGE)
	SEERR(E_IPNOTINEDIT)
	SEERR(E_FUNCSIGCHANGE)
	SEERR(E_FRAMESIZECHANGE)
	SEERR(E_LOCALREQCONDES)
	SEERR(E_UNSAFEFRAMECOND)
	SEERR(E_CANTFINDLINE)
	SEERR(E_DUPLICATEVAR)
	SEERR(E_FUNCBYTEMATCH)
	SEERR(E_REGISTERSPILL)
};


// Edit and Continue error text
LPCTSTR EncErrorText(CString& str, EncError encErr)
{
	for (int i=0; i < MSGCNT; i++) {
		if (mpErrToRes[ i ].errornum == encErr ) {
			if ( str.LoadString( mpErrToRes[ i ].idResource ) ) {
				return str;
			}
		}
	}
	ASSERT(FALSE);
	return NULL;
}


// Stack editing error text
LPCTSTR SeErrorText(CString& str, HRESULT hResult)
{
	int i = hResult - FIRST_SE_ERROR;
	if (i >= 0 && i < SEERR_CNT) {
		str.LoadString(mpSEErrToRes[ i ]);
		return str;
	}
	ASSERT(FALSE);
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\enclog.cpp ===
///////////////////////////////////////////////////////////////////////////////
// 
// enclog.cpp
//
// Support for logging edit-and-continue results to the net for QA
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop
#include <io.h>
#include <time.h>
#include <stdlib.h>
#define assert ASSERT
#include "ref.h"
#include "simparray.h"
#include "enc.h"
#include "enclog.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

void ENCLogPerformance(clock_t &start_clock, char* szStatus)
{	// start_clock set to clock() before task
	// Appends EnC performance data to a local log file in the format:
	// Duration,szStatus<CR/LF>

	double duration = (double)(clock() - start_clock)/CLOCKS_PER_SEC;

	BOOL fLoggingEnabled = theApp.m_bEncPerfLog;
	if (!fLoggingEnabled)
		return;

	HANDLE hLocalFile;
	DWORD dwBytesWritten;
	char szPerfLogFilePath[256];
	GetTempPath(255, szPerfLogFilePath);
	lstrcat(szPerfLogFilePath, "ENCPerf.log");

	CString csLogString;
	csLogString.Format("%f,%s\r\n", duration, szStatus);

	if ( (hLocalFile = CreateFile(szPerfLogFilePath, GENERIC_WRITE,
		FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
		!= INVALID_HANDLE_VALUE )
		{
			SetFilePointer(hLocalFile, 0, NULL, FILE_END);	// Append to file
			WriteFile(hLocalFile, csLogString, csLogString.GetLength(), &dwBytesWritten, NULL);
			CloseHandle(hLocalFile);
		}
}


#ifdef _ENCLOG
static char szLogFileDir[] = "\\\\lang1\\ECLogs";
static char szLogFileName[] = "\\\\lang1\\ECLogs\\ECNetLog.dat";
static char szDLLFileName[] = "MSENC10.DLL";

bool FCanSeeNet() {
	static bool fCanSeeNet = false;
	static bool fTriedOnce = false;
	if (!fTriedOnce) {
		fCanSeeNet = (_access(szLogFileDir, 00) != -1);
		fTriedOnce = true;
	}
	return fCanSeeNet;
}


UINT ENCLogToNetCString(LPVOID pParam)
{
	// Like ENCLogToNet, but accepts a pointer to a CString 
	// and then destructs it.
	CString *pStr = (CString *) pParam;
	UINT retval = ENCLogToNet((LPVOID) (const char *)*pStr);
	delete pStr;
	return retval;
}

UINT ENCLogToNet(LPVOID pParam)
{	// Worker thread function to write EnC data to a log file on the net.
	// Appends the information to the file in the following format:
	// 12/25/97,09:15:33,MachineName,DateOfMSENC10.DLL,Success/FailingFunction<CR/LF>

	LPCTSTR lszParam = (LPCTSTR) pParam;

	if (lszParam == NULL)
		return 1;
	
	BOOL fLoggingEnabled = theApp.m_bEncLog;
	if (!fLoggingEnabled)
		return 2;

	HKEY hKey;
	HANDLE hNetFile;
	HANDLE hEngineDLL;
	FILETIME FileTime;
	SYSTEMTIME SystemTime;
	
	DWORD dwBytesWritten;
	DWORD dwRegType;	

	const DWORD BUFFER_MAX = 512;
	char buffer[BUFFER_MAX];
	char logString[BUFFER_MAX * 2];
	unsigned long lBufferSize = sizeof(buffer);
	short nNetAccessAttempts;

	_strdate(logString);							// Today's date
	lstrcat(logString, ",");
		
	 _strtime(buffer);								// Current time
	lstrcat(logString, buffer);
	lstrcat(logString, ",");

	GetComputerName(buffer, (LPDWORD)&BUFFER_MAX);	// Machine name
	lstrcat(logString, buffer);
	lstrcat(logString, ",");
	HMODULE hModule = GetModuleHandle(szDLLFileName);

	if (hModule && GetModuleFileName(hModule, buffer, sizeof(buffer)))
	{
		if ( (hEngineDLL = CreateFile(buffer, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE &&
			GetFileTime(hEngineDLL, NULL, NULL, &FileTime) )
		{
			CloseHandle(hEngineDLL);
			FileTimeToSystemTime(&FileTime, &SystemTime);
			lstrcat(logString, _itoa(SystemTime.wMonth, buffer, 10));
			lstrcat(logString, "/");
			lstrcat(logString, _itoa(SystemTime.wDay, buffer, 10));
			lstrcat(logString, "/");
			lstrcat(logString, _itoa(SystemTime.wYear, buffer, 10));
		}
	}

	lstrcat(logString, ",");
	lstrcat(logString, lszParam);
	lstrcat(logString, "\r\n");
	
	if (!FCanSeeNet())
	{
		// Can't see net directory, so log to local file
		HANDLE hLocalFile;
		char szLocalLogFilePath[256];
		GetTempPath(255, szLocalLogFilePath);
		lstrcat(szLocalLogFilePath, "ENC.log");
		
		if ( (hLocalFile = CreateFile(szLocalLogFilePath, GENERIC_WRITE,
			FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
			!= INVALID_HANDLE_VALUE )
		{
			SetFilePointer(hLocalFile, 0, NULL, FILE_END);	// Append to file
			WriteFile(hLocalFile, logString, lstrlen(logString), &dwBytesWritten, NULL);
			CloseHandle(hLocalFile);
		}
		else
			return 3;	// Can't open local file
	}
	else
	{
		//  Keep trying to open the net log for writing
		nNetAccessAttempts = 0;
		while ( (hNetFile = CreateFile(szLogFileName, GENERIC_WRITE,
				FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL))
				== INVALID_HANDLE_VALUE && nNetAccessAttempts < MAX_NET_ACCESS_ATTEMPTS)
			{
				nNetAccessAttempts++;
				Sleep(250);	// Sleep(250) = 10 second timeout if MAX_NET_ACCESS_ATTEMPTS = 40
			}

		SetFilePointer(hNetFile, 0, NULL, FILE_END);	// Append to file
		WriteFile(hNetFile, logString, lstrlen(logString), &dwBytesWritten, NULL);
		CloseHandle(hNetFile);
	}

	if (!_tcscmp((char*) lszParam, LOG_PUSHNEWEDIT)	||		// Ask for repro case?
		!_tcscmp((char*) lszParam, LOG_HRESULT_EXPORTPUB)	||
		!_tcscmp((char*) lszParam, LOG_HRESULT_MEMWRITE)	||
		!_tcscmp((char*) lszParam, LOG_HRESULT_THUNKWRITE))
	{
		MessageBox( NULL,
					"\nAn Edit and Continue error has occurred.\n\nPlease IMMEDIATELY send the modified source files,\nalong with a description of the recent code modifications to:    \n\nE-mail alias:  VCENC@Microsoft.com",
					"Edit and Continue",
					MB_ICONEXCLAMATION | MB_OK | MB_SETFOREGROUND | MB_TOPMOST
					);
	}
	
	return 0;
}


void ENCLogForHResult(HRESULT hResult)
{
	switch (hResult)
	{
	  case E_MEMMAP:		NET_LOG(LOG_HRESULT_MEMMAP);		break;	// Prob. illegal edit
	  case E_INITMEMALLOC:	NET_LOG(LOG_HRESULT_INITMEMALLOC);	break;
	  case E_EXPORTPUB:		NET_LOG(LOG_HRESULT_EXPORTPUB);		break;
	  case E_FIXUP:			NET_LOG(LOG_HRESULT_FIXUP);			break;	// Prob. illegal edit
	  case E_MEMWRITE:		NET_LOG(LOG_HRESULT_MEMWRITE);		break;
	  case E_THUNKWRITE:	NET_LOG(LOG_HRESULT_THUNKWRITE);	break;
	  case E_NOPDBSUPPORT:	NET_LOG(LOG_HRESULT_NOPDBSUPPORT);	break;
	  default:				NET_LOG(LOG_HRESULT_UNKNOWN);		break;
	}
}

static DWORD FileSize(LPCTSTR szFile)
{
	DWORD dwSize = 0;
	HANDLE hFile;
	if 	((hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE )
	{
		dwSize = GetFileSize(hFile, NULL);
		CloseHandle(hFile);
	}
	return dwSize;
}

void ENCLogHmod(HMOD hmod)		
{
	char buf[80];
	HEXE hexe = SHHexeFromHmod(hmod);
	CString strMod = SHGetObjPath(hmod);
	CString strExe = SHGetExeName(hexe);

	char szFname[_MAX_FNAME];
	char szExt[_MAX_EXT];
	
	_splitpath(strExe, NULL, NULL, szFname, szExt);

	sprintf(buf, "%d,%d,%s%s", FileSize(strMod), FileSize (strExe), szFname, szExt);

	NET_LOG_EX(buf);
}

#endif // _ENCLOG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\fonts.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// 03-Oct-94 marklam Removed or modified all the old font dialog and font-caching code

void CFontInfo::InitializeFontInfo(const LOGFONT &lf)
{
	// Fill in the LOGFONT member
	m_lf = lf;

	// Fill in the font Handle
	HDC hDC;
	VERIFY (hDC = ::CreateDC("DISPLAY",NULL,NULL,NULL));
	m_hFont = ::CreateFontIndirect(&lf);

	// Fill in the text metric information
	HFONT hOldFont;
	VERIFY (hOldFont = (HFONT)::SelectObject(hDC, m_hFont));
	VERIFY (::GetTextMetrics(hDC, &m_tm));
	m_fFixedPitchFont = !theApp.m_fOEM_MBCS &&
						!(m_tm.tmPitchAndFamily & TMPF_FIXED_PITCH) &&
						(m_tm.tmAveCharWidth == m_tm.tmMaxCharWidth);

	// Get the Single-byte ASCII widths
	VERIFY (::GetCharWidth(hDC, 0, NASCII_WIDTHS - 1, m_rgcxSBWidths));

	// Clean up GDI resources
	::SelectObject(hDC, hOldFont);
	VERIFY(::DeleteDC(hDC));

	// Mark the lead bytes in the table, and resize others if necessary
	for (unsigned int nChar = 0; nChar < NASCII_WIDTHS; nChar++)
	{
		if ( (theApp.m_fOEM_MBCS) && (_ismbblead(nChar)) )
		{
			// Disable all lead bytes
			m_rgcxSBWidths[nChar] = -1;
		}
		else if (m_tm.tmOverhang)
		{
			// Not a lead byte, but needs resizing
			m_rgcxSBWidths[nChar] -= m_tm.tmOverhang;
		}
	}

	// Empty the trail-byte table pointers
	for (unsigned int nLead = 0; nLead < NLEAD_BYTES; nLead++)
		m_rgrgcxTrailTables[nLead] = NULL;		

	// Mark a tab with an (arbitrary?) length
	m_rgcxSBWidths['\t'] = m_rgcxSBWidths[' '];
}

void CFontInfo::DestroyFontInfo(void)
{
	// Release the memory assigned to the character width tables
	for (UINT nLeadByte = 0; nLeadByte < NLEAD_BYTES; nLeadByte++)
	{
		if (m_rgrgcxTrailTables[nLeadByte] != NULL)
		{
			delete[] m_rgrgcxTrailTables[nLeadByte];
		}
	}

	if (m_hFont != NULL)
		VERIFY(DeleteObject(m_hFont));
}

#define IS_MBCS_FONT(cs) (((cs) == SHIFTJIS_CHARSET)) // These others have to be looked-up! || ((cs) == CHINESEBIG5_CHARSET) || ((cs) == HANGEUL_CHARSET))

int *CFontInfo::rgiLoadTrailWidths(const unsigned char chLead)
{
	int *rgiTrailWidths;

	VERIFY(rgiTrailWidths = new int[NTRAIL_WIDTHS]);		// Out of memory?
	if (rgiTrailWidths == NULL)
		return NULL;

	HDC hDC;
	HFONT hOldFont;
	VERIFY (hDC = ::CreateDC("DISPLAY",NULL,NULL,NULL));
	VERIFY (hOldFont = (HFONT)::SelectObject(hDC, m_hFont));

	if (!::GetCharWidth(hDC, FIRST_CHAR(chLead), LAST_CHAR(chLead), rgiTrailWidths))
	{
		ASSERT (FALSE);										// Couldn't get widths
		delete[] rgiTrailWidths;
		rgiTrailWidths = NULL;
	}
	else
	{
		// Add in tmOverhang
		if (m_tm.tmOverhang != 0)
		{
			for (unsigned char nChar = 0; nChar < NTRAIL_WIDTHS; nChar++)
			{
				rgiTrailWidths[nChar] -= m_tm.tmOverhang;
			}
		}
	}

	::SelectObject(hDC, hOldFont);
	VERIFY(DeleteDC(hDC));

	return rgiTrailWidths;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\excep.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

static BOOL fExceptionEdited;	// any edits in current exception fields?
static int SelCount;
static int FAR *lpiSel;

BOOL IsForCompatiblePlatform(UINT idPlatform)
{
	BOOL fRet = FALSE;
	UINT idCurPlatform = pDebugCurr->GetPlatform( );
	
	if ( idPlatform == idCurPlatform || idPlatform == iPlatformGeneric)
	{
		fRet = TRUE;
	}
	else
	{
		// We assume that all Win32 platforms are compatible.
		// as far as exceptions go.
		switch ( idPlatform )
		{
			case win32x86:
			case win32mips:
			case win32alpha:
			case win32ppc:
				switch( idCurPlatform )
				{
					case win32x86:
					case win32mips:
					case win32alpha:
					case win32ppc:
						fRet = TRUE;
						break;
					default:
						break;
				}
			default:
				break;
		}
	}
	
	return fRet;
}
										
			
/****************************************************************************

	FUNCTION:	MakeExceptionObject

	PURPOSE:	Initialize an Exception_Object Structure

****************************************************************************/
void MakeExceptionObject(EXCEPTION_OBJECT *pObject, DWORD dwExceptionCode,
	LPCSTR Name, int iAction, UINT iPlatformId)
{
	pObject->dwExceptionCode = dwExceptionCode;
	_ftcsncpy(pObject->Name,Name,cchExcepName);
	pObject->Name[cchExcepName-1] = '\0';
	pObject->iAction = iAction;
	pObject->iPlatformId = iPlatformId;
}

/****************************************************************************

	FUNCTION:	UnmakeExceptionObject

	PURPOSE:	Get fields of an exception_object struct

****************************************************************************/
void UnmakeExceptionObject(EXCEPTION_OBJECT *pObject, DWORD *pdwExceptionCode,
	LPSTR Name, int *piAction, UINT *piPlatformId)
{
	*pdwExceptionCode = pObject->dwExceptionCode;
	_ftcsncpy(Name,pObject->Name,cchExcepName);
	Name[cchExcepName-1] = '\0';
	*piAction = pObject->iAction;
	*piPlatformId = pObject->iPlatformId;
}

/****************************************************************************

	FUNCTION:	MakeExceptionString

	PURPOSE:	Create a user string from an EXCEPTION_OBJECT struct

****************************************************************************/
void MakeExceptionString(EXCEPTION_OBJECT *pObject, LPSTR Buffer, int cch)
{
	CString	strAction;
	char	Number[cchExcepNumber];
#ifndef _WIN32
	char	LocalBuffer[cchExcepAll];
#endif

	VERIFY(strAction.LoadString(DLG_Exception_Action_First + pObject->iAction));

	sprintf(Number, "%08lx", pObject->dwExceptionCode);

#ifndef _WIN32
	sprintf(LocalBuffer, "%.*s\t%.*s\t%.*s",
		cchExcepNumber-1,	Number,
		cchExcepName-1,		pObject->Name,
		cchExcepAction-1,	(const char *) strAction);
	_ftcscpy(Buffer, LocalBuffer);
#else
	sprintf(Buffer, "%.*s\t%.*s\t%.*s",
		cchExcepNumber-1,	Number,
		cchExcepName-1,		pObject->Name,
		cchExcepAction-1,	(const char *) strAction);
#endif
}

/****************************************************************************

	FUNCTION:	ReInitSystemExceptions

	PURPOSE:	Re-initialize the system exceptions in the list.

****************************************************************************/
VOID ReInitSystemExceptions(BOOL fInsertOnly)
{
	EXCEPTION_OBJECT	ObjSys, ObjCur;
	DWORD	iobjSys, iobjCur;
	DWORD	cobjSys, cobjCur;
	int		cmp;

	cobjSys = ListGetCount(DLG_SYSTEM_EXCEP_LIST);
	cobjCur = ListGetCount(DLG_EXCEP_LIST);

	iobjCur = 0;

	for (iobjSys=0; iobjSys<cobjSys; ++iobjSys)
	{
		// Get the system exception.
		if (!ListGetObject(iobjSys, DLG_SYSTEM_EXCEP_LIST, (LPSTR)&ObjSys))
		{
			ASSERT(FALSE);
			break;
		}

		// See if it's in the current list of exceptions.  Both lists are
		// sorted, so we know that no matter what the current value of iobjCur,
		// the system object we just found is not before iobjCur in the list.
		cmp = -1;
		while (iobjCur < cobjCur && cmp < 0)
		{
			VERIFY(ListGetObject(iobjCur, DLG_EXCEP_LIST, (LPSTR)&ObjCur));

			if (ObjCur.dwExceptionCode < ObjSys.dwExceptionCode)
				cmp = -1;
			else if (ObjCur.dwExceptionCode == ObjSys.dwExceptionCode)
				cmp = 0;
			else
				cmp = 1;

			// if cmp < 0, then we haven't yet reached the point in the list
			// where this element should go
			if (cmp < 0)
			{
				iobjCur++;
			}
			else
			{
				break;
			}
		}
		// if cmp == 0, we've found a match
		if (cmp == 0)
		{
			if (!fInsertOnly)
			{
				ListUpdateObject(iobjCur, DLG_EXCEP_LIST, (LPSTR)&ObjSys,
					sizeof(ObjSys));
			}
		}
		// if cmp != 0, we have to insert the element into the list here
		else
		{
			ListInsertObject(iobjCur, DLG_EXCEP_LIST, (LPSTR)&ObjSys,
				sizeof(ObjSys));
			cobjCur++;
		}
		iobjCur++;
	}
}


/****************************************************************************

	FUNCTION:	GetExceptionInfo

	PURPOSE:	Ask OSDebug for informations about an exception.
				'pdwExceptionCode' and 'Name' are optional args (can be NULL).
				'fSystemOnly' indicates whether caller is only interested
				in system exceptions.

****************************************************************************/
BOOL GetExceptionInfo(BOOL FirstException, BOOL fSystemOnly,
	DWORD *pdwExceptionCode, LPSTR Name, UINT cchName, UINT *piAction, UINT *piPlatformId)
{
static EXCEPTION_DESCRIPTION ExceptionDesc;
#if !(defined (OSDEBUG4))
static EXR ExceptionCode;
#else
EXCEPTION_CONTROL exf;
#endif
HTID htid;
HPID hpid;

	// Get pid of current process
	hpid = HpidFromHprc(hprcCurr);

	// Get tid of current process
	htid = HtidFromHthd(hthdCurr);

#if !(defined (OSDEBUG4))
	// Get next exception number
	do
	{
		if (OSDGetNextExRecord (hpid, htid, &ExceptionCode, FirstException)
			!= xosdNone)
		{
			return (FALSE);
		}
		FirstException = FALSE;
	// if !fSystemOnly, stop on the first exception;
	// if fSystemOnly, stop on the first known exception
	}
	while (fSystemOnly && !ExceptionCode.fKnown);

	// Store exception number
	if (pdwExceptionCode)
		*pdwExceptionCode = ExceptionCode.dwExceptionCode;

	// Setup EXCEPTION_DESC struct to call GetExceptionDescription
	ExceptionDesc.dwExceptionCode = ExceptionCode.dwExceptionCode;
	OSDGetExDescription(hpid, htid, (LPEXCEPTION_DESCRIPTION)&ExceptionDesc);
#else
	if (FirstException) {
	    exf = exfFirst;
	    FirstException = FALSE;
	}
	else {
	    exf = exfNext;
	}
        if (OSDGetExceptionState( hpid, htid, &ExceptionDesc, exf) != xosdNone) {
		return (FALSE);
	}
	// Store exception number
	if (pdwExceptionCode)
		*pdwExceptionCode = ExceptionDesc.dwExceptionCode;
#endif
	// Store the platform id
	if ( piPlatformId )
	{
		ASSERT( pDebugCurr );
		*piPlatformId = pDebugCurr->GetPlatform();
	}

	// Get exception description
	if (Name)
	{
#if !(defined (OSDEBUG4))
		_ftcsncpy(Name,ExceptionDesc.lszDescription,cchName);
#else
		_ftcsncpy(Name,ExceptionDesc.rgchDescription,cchName);
#endif
		Name[cchName-1] = '\0';
	}

	// Get Exception action
	switch(ExceptionDesc.efd)
   	{
	case efdIgnore:
	case efdNotify:
		*piAction = EX_ACTION_2NDCHANCE;
		break;
	case efdStop:
		*piAction = EX_ACTION_1STCHANCE;
		break;
	default:
		ASSERT(FALSE);
	}

	return (TRUE);
}
/****************************************************************************

	FUNCTION:	InitDefaultExceptionList

	PURPOSE:	Get default exception list

	INPUT:		listId = DLG_EXCEP_LIST or DLG_SYSTEM_EXCEP_LIST

****************************************************************************/
static void InitDefaultExceptionList(int listId)
{
EXCEPTION_OBJECT Object;
DWORD dwExceptionCode;
char Name[cchExcepName];
int iAction;
BOOL IsFirstException = TRUE;
UINT iPlatformId;
	EmptyList(listId);

	while (GetExceptionInfo(IsFirstException, (listId == DLG_SYSTEM_EXCEP_LIST),
		&dwExceptionCode, Name, sizeof(Name), (UINT *)&iAction, &iPlatformId))
	{
		MakeExceptionObject(&Object, dwExceptionCode, Name, iAction, iPlatformId);

		// Add exception in the linked list
		ListAddObject(listId, (LPSTR)&Object, sizeof(EXCEPTION_OBJECT));

		// We want the next exceptions from GetExceptionInfo
		IsFirstException = FALSE;
	}

	if (listId == DLG_EXCEP_LIST)
		fExcepListInitialized = TRUE;
}

/****************************************************************************

	FUNCTION:	InitProcessExceptions

	PURPOSE:	Initialize the exceptions for a process.

****************************************************************************/
VOID InitProcessExceptions(VOID)
{
	UINT				iexception;
	EXCEPTION_OBJECT	Object;

	// save the list of system exceptions
	InitList(DLG_SYSTEM_EXCEP_LIST);
	InitDefaultExceptionList(DLG_SYSTEM_EXCEP_LIST);

	// If list empty, get default
	InitList(DLG_EXCEP_LIST);
	if (!fExcepListInitialized)
		InitDefaultExceptionList(DLG_EXCEP_LIST);

	// Update the exception list with the system (OSDebug) exception
	// list.  This may have changed if the platform did.
	ReInitSystemExceptions( TRUE );

	// set up default actions for all exceptions
	for (iexception=0;
		 ListGetObject(iexception, DLG_EXCEP_LIST, (LPSTR)&Object);
		 iexception++)
	{
		if (IsForCompatiblePlatform(Object.iPlatformId))
		{
#if !(defined (OSDEBUG4))
			OSDHandleEx(hpidCurr, htidCurr, Object.dwExceptionCode,
				(Object.iAction == EX_ACTION_1STCHANCE) ? efdStop : efdNotify);
#else
		    EXCEPTION_DESCRIPTION ExceptionDesc = { 0 };

			ExceptionDesc.dwExceptionCode = Object.dwExceptionCode;
			ExceptionDesc.efd = (Object.iAction == EX_ACTION_1STCHANCE)
				? efdStop : efdNotify;
			VERIFY(OSDSetExceptionState( hpidCurr, htidCurr, &ExceptionDesc)
				== xosdNone);
#endif
		}
	}
}

/****************************************************************************

	FUNCTION:	ValidateExceptionStatus

	PURPOSE:	Update the exception actions (ie return, ignore, etc...)

****************************************************************************/
static void ValidateExceptionStatus(void)
{
	int							Count,i;
	DWORD						dwExceptionCode;
	char						Name[cchExcepName];
	int							action;
	EXCEPTION_OBJECT			Object;
	EXCEPTION_FILTER_DEFAULT	efd;
	HTID						htid;
	HPID						hpid;
	BOOL						fFirstException;
	UINT						iPlatformId;

	// Get pid of current process
	hpid = HpidFromHprc(hprcCurr);

	// Get tid of current process
	htid = HtidFromHthd(hthdCurr);

	// If there are any exceptions that have been removed from the list,
	// restore their action to "stop if not handled" (the default).
	fFirstException = TRUE;
	while (GetExceptionInfo(fFirstException, FALSE,
		&dwExceptionCode, Name, sizeof(Name), (UINT *)&action, &iPlatformId))
	{
		BOOL	fFound = FALSE;

		for (i=0; ListGetObject(i, DLG_EXCEP_LIST, (LPSTR)&Object); ++i)
		{
			if (dwExceptionCode == Object.dwExceptionCode)
			{
				fFound = TRUE;
				break;
			}
		}

		if (!fFound) {
#if !(defined (OSDEBUG4))
			OSDHandleEx(hpid, htid, dwExceptionCode, efdNotify);
#else
		    EXCEPTION_DESCRIPTION ExceptionDesc = { 0 };
			ExceptionDesc.dwExceptionCode = dwExceptionCode;
			ExceptionDesc.efd = efdNotify;
			VERIFY(OSDSetExceptionState( hpid, htid, &ExceptionDesc)
				== xosdNone);
#endif
		}

		fFirstException = FALSE;
	}

	// Update exception actions for all exceptions in list
	Count = (int)ListGetCount(DLG_EXCEP_LIST);
	for (i=0; i<Count; i++)
	{
		if (!ListGetObject(i,DLG_EXCEP_LIST,(LPSTR)&Object))
		{
			ASSERT(FALSE);
			break;
		}

		switch(Object.iAction)
		{
		case EX_ACTION_1STCHANCE:
			efd = efdStop;
			break;
		case EX_ACTION_2NDCHANCE:
			efd = efdNotify;
			break;
		default:
			efd = efdStop;
			break;
		}

#if !(defined (OSDEBUG4))
		OSDHandleEx ( hpid, htid, Object.dwExceptionCode, efd );
#else
		{
		    EXCEPTION_DESCRIPTION ExceptionDesc = { 0 };
			ExceptionDesc.dwExceptionCode = Object.dwExceptionCode;
			ExceptionDesc.efd = efd;
			VERIFY(OSDSetExceptionState( hpid, htid, &ExceptionDesc)
				== xosdNone);
		}
#endif
	}
}

/****************************************************************************

	FUNCTION:	GetExceptionDescription

	PURPOSE:	Get the user exception description, for a given exception#
				If the exception is not in our list, get the standard osd
				exception description

****************************************************************************/
void GetExceptionDescription(DWORD dwExceptionCode, CString& strDescription)
{
	int						Count,i;
	EXCEPTION_DESCRIPTION	ExceptionDesc;
	EXCEPTION_OBJECT		Object;
	UINT                    idCurPlatform = pDebugCurr->GetPlatform( );

	// Get # of exception in our list
	Count = (int)ListGetCount(DLG_EXCEP_LIST);

	if (Count != 0)
	{
		// Our list isn't empty, so get our own description
		for (i=0; i<Count; i++)
		{
			if (!ListGetObject(i,DLG_EXCEP_LIST,(LPSTR)&Object))
			{
				ASSERT(FALSE);
				strDescription = "";
				return;
			}
			if ((dwExceptionCode == Object.dwExceptionCode) &&
                (idCurPlatform == Object.iPlatformId))
				break;
		}

		if (i != Count)
		{
			// We've found the exception. Get the name
			strDescription = Object.Name;
			return;
		}
		else
		{
			// Not found in our list
			// So, let osd handle that.
		}
	}

	// If list empty, or our list doesn't know the specified exception code
	// get default osd exception description

	// Setup EXCEPTION_DESCRIPTION struct to call GetExceptionDescription
	ExceptionDesc.dwExceptionCode = dwExceptionCode;
#if !(defined (OSDEBUG4))
	OSDGetExDescription(hpidCurr, htidCurr, (LPEXCEPTION_DESCRIPTION)&ExceptionDesc);
	// Get the name
	strDescription = ExceptionDesc.lszDescription;
#else
	OSDGetExceptionState(hpidCurr, htidCurr, &ExceptionDesc, exfSpecified);
	// Get the name
	strDescription = ExceptionDesc.rgchDescription;
#endif
}

/****************************************************************************

	FUNCTION:	GetExceptionAction

	PURPOSE:	Get the user exception action, for a given exception #.
				If the exception is not in our list, return
				EX_ACTION_2NDCHANCE (only stop on 2nd-chance)

****************************************************************************/
int GetExceptionAction(DWORD dwExceptionCode)
{
	int	Count,i;
	EXCEPTION_OBJECT		Object;

	// Get # of exception in our list
	Count = (int)ListGetCount(DLG_EXCEP_LIST);

	if (Count != 0)
	{
		// Our list isn't empty, so get our own description
		for (i=0; i<Count; i++)
		{
			if (!ListGetObject(i,DLG_EXCEP_LIST,(LPSTR)&Object))
			{
				ASSERT(FALSE);
				return EX_ACTION_2NDCHANCE;
			}
			if (dwExceptionCode == Object.dwExceptionCode)
				break;
		}

		if (i != Count)
		{
			// We've found the exception. Get the action
			return Object.iAction;
		}
		else
		{
			// Not found in our list
		}
	}

	// If list empty, or our list doesn't know the specified exception code
	return EX_ACTION_2NDCHANCE;
}

/****************************************************************************

	FUNCTION:	UpdateListboxContent

	PURPOSE:	Copy the content of the linked list into the listbox

****************************************************************************/
static void UpdateListboxContent(HWND hDlg)
{
int Count,i,j = 0;
char Buffer[cchExcepAll];
EXCEPTION_OBJECT Object;

	SendDlgItemMessage(hDlg,DLG_EXCEP_LIST,LB_RESETCONTENT,0,0);
	Count = (int)ListGetCount(DLG_EXCEP_LIST);
	for (i=0; i<Count; i++)
	{
		if (!ListGetObject(i,DLG_EXCEP_LIST,(LPSTR)&Object))
		{
			ASSERT(FALSE);
			EmptyList(DLG_EXCEP_LIST);
			SendDlgItemMessage(hDlg,DLG_EXCEP_LIST,LB_RESETCONTENT,0,0);
			break;
		}
		if (IsForCompatiblePlatform(Object.iPlatformId))
		{
			MakeExceptionString(&Object,Buffer,sizeof(Buffer));
			SendDlgItemMessage(hDlg,DLG_EXCEP_LIST,LB_INSERTSTRING,j,(LPARAM)(LPSTR)Buffer);
			SendDlgItemMessage(hDlg,DLG_EXCEP_LIST,LB_SETITEMDATA,j,(LPARAM)Object.iAction);
			j++;
		}
	}
}

static int GetNthEnabledObject(DWORD iSel, int iList, EXCEPTION_OBJECT * pObject)
{
	// State:
	//	-1 = Item not found in specified list
	//  all other values = actual index in list of object
	int		iRet = -1;
	DWORD	iSelCur = 0;

	// Increment iSel so iSel == 0 can be used as a termination condition
	++iSel;

	while( iSel && ListGetObject( iSelCur, iList, (LPSTR)pObject ))
	{
		// Matching platform, save current index
		if ( IsForCompatiblePlatform( pObject->iPlatformId ) )
		{
			--iSel;
			iRet = iSelCur;
		}
		++iSelCur;
	}

	// If iSel != 0, then the end of list was found before finding the nth
	// matching entry, return failure
	return iSel ? -1 : iRet;
}

static int GetAction (HWND hDlg)
{
	// Returns state:
	//	-1 = neither radiobutton selected
	//	 0 = 1st chance selected
	//	 1 = last chance selected
	if (SendDlgItemMessage(hDlg,DLG_EXCEP_1STCHANCE,BM_GETCHECK,0,0))
		return 0;
	else if (SendDlgItemMessage(hDlg,DLG_EXCEP_2NDCHANCE,BM_GETCHECK,0,0))
		return 1;
	else
		return -1;
}

static void SetAction (HWND hDlg, int State)
{
	// State:
	//	-1 = neither radiobutton selected
	//	 0 = 1st chance selected
	//	 1 = last chance selected
	SendDlgItemMessage(hDlg,DLG_EXCEP_1STCHANCE,BM_SETCHECK,(State == 0),0);
	SendDlgItemMessage(hDlg,DLG_EXCEP_2NDCHANCE,BM_SETCHECK,(State == 1),0);
}

/****************************************************************************

	FUNCTION:	EnableControls

	PURPOSE:	Enable or disable some buttons in the exception box

****************************************************************************/
static void EnableControls(HWND hDlg)
{
BOOL EnableAdd,EnableChange;
BOOL EnableNumber,EnableName;
char szNumber[cchExcepNumber];
int Length;
char *pchEnd;
DWORD dwExceptionCode;
UINT idDefault;

	// If EXCEPTION NUMBER field empty, disable ADD and CHANGE
	// Else, enable either ADD or CHANGE if the number exists
	EnableAdd = EnableChange = FALSE;
	EnableNumber = EnableName = TRUE;
	if (SelCount > 1)
	{
		// Enable Change as long as one of "Stop always" and "Stop if not
		// handled" is selected
		EnableChange = (GetAction(hDlg) != -1);
		EnableNumber = EnableName = FALSE;
	}
	else if ((Length = (int)SendDlgItemMessage(hDlg,DLG_EXCEP_NUMBER,WM_GETTEXTLENGTH,0,0)) != 0)
	{
		// If Number is not empty, get its text
		SendDlgItemMessage(hDlg, DLG_EXCEP_NUMBER, WM_GETTEXT,
			sizeof(szNumber), (LPARAM)(LPSTR)szNumber);
		// Convert it to 8 digits
		dwExceptionCode = strtoul(szNumber, &pchEnd, 16);
		if (*pchEnd == '\0')	// don't allow non-hex characters
		{
			sprintf(szNumber, "%08lx", dwExceptionCode);
			// Search the listbox for a same number
			if ((int)SendDlgItemMessage(hDlg,DLG_EXCEP_LIST,
				LB_FINDSTRING,(WPARAM)-1,(LPARAM)(LPSTR)szNumber) != LB_ERR)
			{
				EnableChange = TRUE;
			}
			else
			{
				EnableAdd = TRUE;
			}
		}
	}

	EnableWindow(GetDlgItem(hDlg, DLG_EXCEP_ADD),EnableAdd);
	EnableWindow(GetDlgItem(hDlg, DLG_EXCEP_CHANGE),EnableChange);
	EnableWindow(GetDlgItem(hDlg, DLG_EXCEP_NUMBER_LABEL),EnableNumber);
	EnableWindow(GetDlgItem(hDlg, DLG_EXCEP_NUMBER),EnableNumber);
	EnableWindow(GetDlgItem(hDlg, DLG_EXCEP_NAME_LABEL),EnableName);
	EnableWindow(GetDlgItem(hDlg, DLG_EXCEP_NAME),EnableName);

	// Delete button is enabled if any lines of the listbox are selected
	EnableWindow(GetDlgItem(hDlg, DLG_EXCEP_DELETE), SelCount > 0);

	// Set which button is default: Close, Add, or Change
	idDefault = IDOK;
	if (fExceptionEdited)
	{
		if (EnableAdd)
			idDefault = DLG_EXCEP_ADD;
		else if (EnableChange)
			idDefault = DLG_EXCEP_CHANGE;
	}

	SendMessage(hDlg, DM_SETDEFID, idDefault, 0);
}

/****************************************************************************

	FUNCTION:	DrawExceptionListItem

	PURPOSE:	Callback routine to HandleStandardOwnerDrawListBox to
				actually output the text

****************************************************************************/
VOID FAR PASCAL DrawExceptionListItem(
	HWND hDlg,
	LPDRAWITEMSTRUCT lpDIS)
{
	char Buffer[cchExcepAll];
	LPSTR CurStartPos, CurEndPos;
	POINT pt1, pt2;
	RECT rcDraw;

	// Get the exception text.  The fields are separated by the
	// tab character
	VERIFY(SendMessage(lpDIS->hwndItem, LB_GETTEXT, lpDIS->itemID, (LONG)(LPSTR)Buffer) != LB_ERR);

	// So, we draw the exception fields flush with entry fields
	// that appear above the list box.

	// Exception number
	rcDraw = lpDIS->rcItem;
	CurStartPos = Buffer;
	CurEndPos = _ftcschr(CurStartPos, _T('\t'));
	ASSERT(CurEndPos != NULL);
	*CurEndPos = '\0';
	pt1.x = 0; pt1.y = 0;
	ClientToScreen(GetDlgItem(hDlg, DLG_EXCEP_LIST), &pt1);
	pt2.x = 0; pt2.y = 0;
	ClientToScreen(GetDlgItem(hDlg, DLG_EXCEP_NAME), &pt2);
	rcDraw.right = rcDraw.left + pt2.x - pt1.x;
	ExtTextOut(lpDIS->hDC, rcDraw.left+2, rcDraw.top, ETO_CLIPPED, &rcDraw,
		CurStartPos, _ftcslen(CurStartPos), NULL);

	// Exception number
	CurStartPos = CurEndPos+1;
	CurEndPos = _ftcschr(CurStartPos, _T('\t'));
	ASSERT(CurEndPos != NULL);
	*CurEndPos = '\0';
	pt1.x = 0; pt1.y = 0;
	ClientToScreen(GetDlgItem(hDlg, DLG_EXCEP_ACTION), &pt1);
	rcDraw.left = rcDraw.right + 1;
	rcDraw.right = rcDraw.left + pt1.x - pt2.x;
	ExtTextOut(lpDIS->hDC, rcDraw.left+2, rcDraw.top, ETO_CLIPPED, &rcDraw,
		CurStartPos, _ftcslen(CurStartPos), NULL);

	// Exception action
	CurStartPos = CurEndPos+1;
	rcDraw.left = rcDraw.right + 1;
	rcDraw.right = lpDIS->rcItem.right;
	ExtTextOut(lpDIS->hDC, rcDraw.left+2, rcDraw.top, ETO_CLIPPED, &rcDraw,
		CurStartPos, _ftcslen(CurStartPos), NULL);
}

/****************************************************************************

	FUNCTION:	AddChangeException(hDlg)

	PURPOSE:	Adds or changes an exception.

****************************************************************************/
static VOID AddChangeException(HWND hDlg)
{
	HWND				hwndList = GetDlgItem(hDlg, DLG_EXCEP_LIST);
	EXCEPTION_OBJECT	Object;
	char				Buffer[cchExcepAll];
	char				Number[cchExcepNumber];
	char				Name[cchExcepName];
	int					Line,NewLine,iAction;
	DWORD				dwExceptionCode;
	char *pchEnd;
	int					i;
	BOOL				fSelected;
	UINT				iPlatformId;

	// After add/change, there are no changes pending
	fExceptionEdited = FALSE;

	iAction = GetAction(hDlg);
	ASSERT(iAction != -1);

	// Are multiple lines selected?
	if (SelCount <= 1)
	{
		// Get text from controls
		GetWindowText(GetDlgItem(hDlg,DLG_EXCEP_NUMBER),(LPSTR)Number,sizeof(Number));
		GetWindowText(GetDlgItem(hDlg,DLG_EXCEP_NAME),(LPSTR)Name,sizeof(Name));

		// Convert number to 8 digits
		dwExceptionCode = strtoul(Number, &pchEnd, 16);
		if (pchEnd == Number || *pchEnd != '\0')
			return;
		sprintf(Number, "%08lx", dwExceptionCode);

		// Search the listbox for same number
		Line = (int)SendMessage(hwndList, LB_FINDSTRING, (WPARAM)-1,
			(LPARAM)(LPSTR)Number);
		// If same number already exists, delete the current line
		// else insert it sorted into the list
		if (Line != LB_ERR)
		{
			SendMessage(hwndList, LB_DELETESTRING, Line, 0);
			iPlatformId = pDebugCurr->GetPlatform();
		}
		else {
			iPlatformId = iPlatformGeneric;
		}

		MakeExceptionObject(&Object, dwExceptionCode, Name, iAction, iPlatformId);
		MakeExceptionString(&Object,Buffer,sizeof(Buffer));

		// Create the string, and add it in the sorted listbox
		NewLine = SendMessage(hwndList, LB_ADDSTRING, 0,
			(LPARAM)(LPSTR)Buffer);

		// Put the iAction combo index to the data field of the listbox line
		SendMessage(hwndList, LB_SETITEMDATA, NewLine, iAction);

		// Add or update exception in the linked list
		if (Line == LB_ERR)
		{
			DWORD				iItem = 0;
			EXCEPTION_OBJECT	ObjectT;

			// Find the real place in the list for this exception to go
			while(ListGetObject(iItem,DLG_EXCEP_LIST,(LPSTR)&ObjectT))
			{
				if ( ObjectT.dwExceptionCode > dwExceptionCode )
				{
					break;
				}
				++iItem;
			}

			ListInsertObject(iItem,DLG_EXCEP_LIST,(LPSTR)&Object,sizeof(EXCEPTION_OBJECT));
		}
		else
		{
			EXCEPTION_OBJECT	ObjectT;
			DWORD				iObject;

			// Get the nth enabled object and its REAL index
			iObject = GetNthEnabledObject(Line,DLG_EXCEP_LIST,&ObjectT);
			ASSERT( iObject != -1 );

			ListUpdateObject(iObject,DLG_EXCEP_LIST,(LPSTR)&Object,sizeof(EXCEPTION_OBJECT));
		}
	}
	else /* multiple lines selected */
	{
		for (i=0; i<SelCount; ++i)
		{
			DWORD	iObject;

			// Get the nth enabled object and its REAL index
			iObject = GetNthEnabledObject(lpiSel[i],DLG_EXCEP_LIST,&Object);
			ASSERT( iObject != -1 );

			Object.iAction = iAction;
			ListUpdateObject(iObject,DLG_EXCEP_LIST,(LPSTR)&Object,
				sizeof(EXCEPTION_OBJECT));

			MakeExceptionString(&Object, Buffer, sizeof(Buffer));
			fSelected = SendMessage(hwndList, LB_GETSEL, lpiSel[i], 0);
			SendMessage(hwndList, LB_DELETESTRING, lpiSel[i], 0);
			SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)Buffer);
			if (fSelected)
				SendMessage(hwndList, LB_SETSEL, TRUE, lpiSel[i]);
		}
	}

	// Set buttons
	EnableControls(hDlg);
}

/****************************************************************************

	FUNCTION:	DlgException(HWND, unsigned, UINT, LONG)

	PURPOSE:	Processes messages for "EXCEPTION" dialog box

****************************************************************************/
BOOL FAR PASCAL EXPORT DlgException(
	HWND       hDlg,
	unsigned   message,
	UINT       wParam,
	LONG       lParam)
{
	static BOOL	fSelChange = FALSE;
	UINT		id;
	UINT		cmd;
	EXCEPTION_OBJECT	Object;

	switch (message)
	{
	case WM_CONTEXTMENU:
	{
		DoHelpContextMenu(CWnd::FromHandle(hDlg), IDD_EXCEPTIONS, CPoint(LOWORD(lParam),HIWORD(lParam)));
	}
	return TRUE;

	case WM_HELP:
	{
		DoHelpInfo(CWnd::FromHandle(hDlg), IDD_EXCEPTIONS, (HELPINFO *)lParam);
	}
	return TRUE;

	case WM_INITDIALOG:
		{
			// No edits have been made to the current exception
			fExceptionEdited = FALSE;

			lpiSel = NULL;
			SelCount = 0;

			SetAction(hDlg,1);

			// Enable valid controls
			EnableControls(hDlg);

			// Set field length
			SendDlgItemMessage(hDlg,DLG_EXCEP_NUMBER,EM_LIMITTEXT,cchExcepNumber-1,0);
			SendDlgItemMessage(hDlg,DLG_EXCEP_NAME,EM_LIMITTEXT,cchExcepName-1,0);

			// Initialize the linked list, and add the strings
			// in the listbox if the list is not empty
			InitList(DLG_EXCEP_LIST);
			InitList(DLG_EXCEP_LIST_BACKUP);
			ListCopy(DLG_EXCEP_LIST_BACKUP, DLG_EXCEP_LIST, (LPSTR)&Object, sizeof(Object));
			if (!fExcepListInitialized)
				InitDefaultExceptionList(DLG_EXCEP_LIST);
			UpdateListboxContent(hDlg);

            return( TRUE );
		}
		break;
	case WM_COMMAND:
		id = GET_WM_COMMAND_ID(wParam, lParam);
		cmd = GET_WM_COMMAND_CMD(wParam, lParam);
		switch (id)
		{
		case DLG_EXCEP_NUMBER:
			if (cmd == EN_CHANGE)
				EnableControls(hDlg);
			break;
		case DLG_EXCEP_NAME:
			if (cmd == EN_CHANGE && !fExceptionEdited && !fSelChange)
			{
				fExceptionEdited = TRUE;
				EnableControls(hDlg);
			}
			break;
		case DLG_EXCEP_1STCHANCE:
		case DLG_EXCEP_2NDCHANCE:
			if ((cmd == BN_CLICKED || cmd == BN_DOUBLECLICKED)
				&& !fExceptionEdited)
			{
				fExceptionEdited = TRUE;
				EnableControls(hDlg);
			}
			break;
		case DLG_EXCEP_ADD:
		case DLG_EXCEP_CHANGE:
			AddChangeException(hDlg);
			if (id == DLG_EXCEP_ADD)
			{
				SetFocus(GetDlgItem(hDlg, DLG_EXCEP_NUMBER));
				SendDlgItemMessage(hDlg, DLG_EXCEP_NUMBER, EM_SETSEL,
					GET_EM_SETSEL_MPS(0, -1));
			}
			break;
		case DLG_EXCEP_DELETE:
			{
				int Caret;
				int i;
				int Count;

				// Delete strings if any are highlighted
				if (SelCount == 0)
				{
					MessageBeep(0);
					break;
				}
				// Get current caret
				Caret = SendDlgItemMessage(hDlg,DLG_EXCEP_LIST,
										   LB_GETCARETINDEX,0,0);
				// Delete current items
				for (i=SelCount-1; i>=0; --i)
				{
					DWORD	iObject;

					SendDlgItemMessage(hDlg,DLG_EXCEP_LIST,LB_DELETESTRING,
									   lpiSel[i],0);

					iObject = GetNthEnabledObject(lpiSel[i], DLG_EXCEP_LIST, &Object);
					ASSERT( iObject != -1 );

					ListDeleteObject(iObject, DLG_EXCEP_LIST);
					if (lpiSel[i] < Caret)
						Caret--;
				}

				SelCount = 0;
				_ffree(lpiSel);
				lpiSel = NULL;

				// Set listbox selection

				Count = SendDlgItemMessage(hDlg, DLG_EXCEP_LIST, LB_GETCOUNT,
					0, 0);

				if (Caret >= Count)
					Caret = Count-1;
				if (Caret < 0)
					Caret = 0;

				SendDlgItemMessage(hDlg, DLG_EXCEP_LIST,
					LB_SETCARETINDEX, Caret, FALSE);
				SendDlgItemMessage(hDlg, DLG_EXCEP_LIST,
					LB_SETSEL, TRUE, Caret);
				SetFocus(GetDlgItem(hDlg, DLG_EXCEP_LIST));

				fExceptionEdited = FALSE;

				// update edit fields & action buttons
				SendMessage(hDlg, WM_COMMAND,
					GET_WM_COMMAND_MPS(DLG_EXCEP_LIST, 0, LBN_SELCHANGE));
			}
			break;
		case DLG_EXCEP_LIST:
			if (cmd == LBN_SELCHANGE)
			{
				int iAction;
				DWORD dwExceptionCode;
				UINT iPlatformId;
				char Number[cchExcepNumber];
				char Name[cchExcepName];
				EXCEPTION_OBJECT Object;
				int i;
				int FAR *lpiSelNew;
				int selCountNew;

				// Get new list of selected items
				selCountNew = SendDlgItemMessage(hDlg, DLG_EXCEP_LIST,
					LB_GETSELCOUNT, 0, 0);
				lpiSelNew = (int *)malloc(selCountNew * sizeof(int));

				if (!lpiSelNew)
					break;
				// [dolphin #12252 5/18/94 mikemo]  Chicago barfs if we
				// call LB_GETSELITEMS with a count of zero items, so
				// if selCountNew is zero, don't call it
				if (selCountNew > 0)
				{
					SendDlgItemMessage(hDlg, DLG_EXCEP_LIST, LB_GETSELITEMS,
						selCountNew, (LPARAM)(LPSTR)lpiSelNew);
				}

				if (fExceptionEdited)
				{
					// If Change is enabled, it will happen automatically
					// when the user selects another line in the listbox.
					// But if Add is enabled, we don't add, we just beep.
					if (IsWindowEnabled(GetDlgItem(hDlg, DLG_EXCEP_ADD)))
						MessageBeep(0);
					else
					{
						AddChangeException(hDlg);

						// The process of changing exceptions may have caused
						// some of them to be de-selected.  We want to restore
						// the selection to what it was when we began this
						// function.  We don't need to clear the list, because
						// changing exceptions won't have caused any unwanted
						// exceptions to be added.
						for (i=0; i<selCountNew; ++i)
						{
							SendDlgItemMessage(hDlg, DLG_EXCEP_LIST, LB_SETSEL,
								TRUE, lpiSelNew[i]);
						}
					}

					fExceptionEdited = FALSE;
				}

				// Get new list of selected items
				SelCount = selCountNew;
				if (lpiSel)
					_ffree(lpiSel);
				lpiSel = lpiSelNew;

				// Only one item selected?
				if (SelCount == 1)
				{
					// Get object and decode it
					if (GetNthEnabledObject(lpiSel[0],DLG_EXCEP_LIST,&Object) == -1 )
					{
						MessageBeep(0);
						break;
					}

					UnmakeExceptionObject(&Object, &dwExceptionCode, Name,
						&iAction, &iPlatformId);
					sprintf(Number, "%08lx", dwExceptionCode);
				}
				else
				{
					Number[0] = '\0';
					Name[0] = '\0';

					if (SelCount == 0)
						iAction = 1;	// default to "stop if not handled"
					else
					{
						// Set 'iAction' to -1, 0, or 1, depending on the actions of
						// all selected lines
						iAction = -1;
						for (i=0; i<SelCount; ++i)
						{
							GetNthEnabledObject(lpiSel[i],DLG_EXCEP_LIST,&Object);
							if (iAction == -1)
							{
								// first time through loop: get action of first item
								iAction = Object.iAction;
							}
							else if (iAction != Object.iAction)
							{
								// item has different action from previous item;
								// break out of loop
								iAction = -1;
								break;
							}
						}
					}
				}

				// Put the text in the edit fields
				fSelChange = TRUE;
				SendDlgItemMessage(hDlg,DLG_EXCEP_NUMBER,WM_SETTEXT,0,(LPARAM)(LPSTR)Number);
				SendDlgItemMessage(hDlg,DLG_EXCEP_NAME,WM_SETTEXT,0,(LPARAM)(LPSTR)Name);
				fSelChange = FALSE;

				// Set action state
				SetAction(hDlg,iAction);

				EnableControls(hDlg);
			}
			break;
		case DLG_EXCEP_DEFAULT:
			ReInitSystemExceptions( FALSE );
			UpdateListboxContent(hDlg);

			// now no exceptions are selected in listbox
			if (lpiSel)
				_ffree(lpiSel);
			lpiSel = NULL;
			SelCount = 0;

			fSelChange = TRUE;
			SendDlgItemMessage(hDlg, DLG_EXCEP_NAME, WM_SETTEXT, 0,
				(LPARAM)(LPSTR)szNull);
			SendDlgItemMessage(hDlg, DLG_EXCEP_NUMBER, WM_SETTEXT, 0,
				(LPARAM)(LPSTR)szNull);
			SetAction(hDlg, 1);
			fSelChange = FALSE;

			EnableControls(hDlg);
			break;
		case IDCANCEL:
			ListCopy(DLG_EXCEP_LIST, DLG_EXCEP_LIST_BACKUP, (LPSTR)&Object, sizeof(Object));
			EndDialog(hDlg, TRUE);
			if (lpiSel)
			{
				_ffree(lpiSel);
				lpiSel = NULL;
			}
			break;
		case IDOK:
			if (fExceptionEdited)
				AddChangeException(hDlg);
			// Validate exception actions
			ValidateExceptionStatus();
			EndDialog(hDlg, TRUE);
			if (lpiSel)
			{
				_ffree(lpiSel);
				lpiSel = NULL;
			}
			return (TRUE);
		}
		break;

	// Owner-Draw list-box stuff:
	case WM_MEASUREITEM:
	case WM_DRAWITEM:
		if ( HandleStandardOwnerDrawListBox(hDlg, message, (WPARAM)wParam, (LPARAM)lParam,
                                			DLG_EXCEP_LIST, DrawExceptionListItem) )
			return( TRUE );

		return FALSE;

	}

	return DefaultDialogHandler(hDlg, message, wParam, lParam);
}

/****************************************************************************

	FUNCTION:   HandleStandardOwnerDrawListBox

	PURPOSE:    Provide standard handling of "owner draw" list boxes.
				Can be used for all list box controls that are
				owner draw fixed where we write text.

	RETURNS:    TRUE if message handled for the passed item,
				FALSE otherwise

****************************************************************************/
BOOL FAR PASCAL HandleStandardOwnerDrawListBox(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam,UINT CtlID,OWNERDRAWCALLBACK ODCallBack)
{
	switch (message)
	{
		case WM_MEASUREITEM:
		{
			LPMEASUREITEMSTRUCT lpMIS;
			HWND hwndLB;
			HDC hdcLB;
			TEXTMETRIC tm;
			HFONT hFont, hOldFont;

			lpMIS = (LPMEASUREITEMSTRUCT)lParam;

			// Firstly, is this message for us
			if (lpMIS->CtlID != CtlID) return FALSE;

			hwndLB = GetDlgItem(hDlg, lpMIS->CtlID);
			hdcLB = GetDC(hwndLB);
			hFont = (HFONT)SendMessage(hwndLB, WM_GETFONT, 0, 0);
			if (hFont == NULL)
				hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0);
			if (hFont != NULL)
				hOldFont = (HFONT)SelectObject(hdcLB, hFont);
			GetTextMetrics(hdcLB, &tm);
			if (hFont != NULL)
				SelectObject(hdcLB, hOldFont);
			ReleaseDC(hwndLB, hdcLB);
			lpMIS->itemHeight = tm.tmHeight;

			return TRUE;
		}

		case WM_DRAWITEM:
		{
			LPDRAWITEMSTRUCT lpDIS;

			lpDIS = (LPDRAWITEMSTRUCT)lParam;

			// Firstly, is this message for us
			if (lpDIS->CtlID != CtlID) return FALSE;

			if (lpDIS->itemID == -1)
			{
				// We have focus but no items so allow
				// default handling
				return FALSE;
			}

			switch (lpDIS->itemAction)
			{
				case ODA_DRAWENTIRE:
				case ODA_SELECT:
				{
               HBRUSH hBrushBack;
               COLORREF rgbTextColor, rgbBkColor;

					if (lpDIS->itemState & ODS_SELECTED)
					{
						hBrushBack = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
      				FillRect(lpDIS->hDC, &lpDIS->rcItem, hBrushBack);
      				DeleteObject((HGDIOBJ)hBrushBack);
      				rgbTextColor = SetTextColor(lpDIS->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
      				rgbBkColor = SetBkColor(lpDIS->hDC, GetSysColor(COLOR_HIGHLIGHT));
    				}
    				else
    				{
						hBrushBack = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
      				FillRect(lpDIS->hDC, &lpDIS->rcItem, hBrushBack);
      				DeleteObject((HGDIOBJ)hBrushBack);
    				}

					// Call the callback to draw the text
					(*ODCallBack)(hDlg, lpDIS);

					if (lpDIS->itemState & ODS_SELECTED)
					{
      				SetTextColor(lpDIS->hDC, rgbTextColor);
      				SetBkColor(lpDIS->hDC, rgbBkColor);
    				}
					break;
				}

				case ODA_FOCUS:
					DrawFocusRect(lpDIS->hDC, &lpDIS->rcItem);
					break;
			}

			// We've done the processing
			return TRUE;
		}

		default:
			return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\errors.cpp ===
/*** errors.c - error and message tables
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

typedef struct CVERRTORES {
	ushort   errornum;
	UINT	 idResource;
} CVERRTORES;

#define ERR(name)	{ name, CVERR_##name },

const static CVERRTORES mpErrToRes[] = {
	ERR(CV_NOERROR)
	ERR(BADBKPTCMD)
	ERR(NOTLVALUE)
	ERR(EACCES)
	ERR(EFAULT)
	ERR(EINVAL)
	ERR(EIO)
	ERR(EMFILE)
	ERR(EXDEV)
	ERR(ENOENT)
	ERR(ENOEXEC)
	ERR(ENOMEM)
	ERR(E2BIG)
	ERR(ENOSPC)
	ERR(ESRCH)
	ERR(MODLOADERROR)
	ERR(NOCODE)
	ERR(NOSOURCEHERE)
	ERR(NOSYMBOLS)
	ERR(FUTURESYMBOLS)
	ERR(NOTPACKED)
	ERR(MUSTRELINK)
	ERR(SYNTAXERROR)
	ERR(NOROOM)
	ERR(MODLOADED)
	ERR(BADTYPECAST)
	ERR(NOWATCHFUNC)
	ERR(CLSTKCHGD)
	ERR(NOADDRGIVEN)
	ERR(TOOMANYADDR)
	ERR(MODNOMATCH)
	ERR(EMMINSUFMEM)
	ERR(CATASTROPHICTM)
	ERR(EXPRERROR)
	ERR(BADADDR)
	ERR(NODATAMEMBERS)
	ERR(PDBNOTFOUND)
	ERR(PDBBADSIGNATURE)
	ERR(PDBINVALIDAGE)
	ERR(PDBOLDFORMAT)
	ERR(SYMSCONVERTED)
	ERR(EXPORTSCONVERTED)
};

#define MSGCNT	(sizeof (mpErrToRes)/sizeof (CVERRTORES))

/** 	fetch_error - get text of error message
 *
 *		pstr = fetch_error (id);
 *
 *		Entry	id = number of error message
 *				pbuf = pointer to message buffer
 *
 */

void fetch_error (ushort wmsgid, char FAR *pbuf)
{
	int 	   		i;
	CString			str;

	i = 0;
	while( i < MSGCNT ) {
		// Found a match, get the string from the resources and exit
		if (mpErrToRes[ i ].errornum == wmsgid ) {
			if ( str.LoadString( mpErrToRes[ i ].idResource ) ) {
				_ftcscpy( pbuf, (const char FAR *)str );
				return;
			}
		}

		// Next
		++i;
	}

	// Didn't find it, or LoadString failed, get the unknown
	// error string.  Possible OOM (LoadString failed).  If
	// it did, it will probably fail again!
	ASSERT(FALSE);
	if ( str.LoadString( CVERR_UNKNOWNERROR ) ) {
		_ftcscpy( pbuf, (const char FAR *)str );
	}

	// Unable to load the string from the resources, just put
	// a real bad error here!  Don't know what else to put in
	// here!
	else {
		_ftcscpy( pbuf, "Internal error" );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\gotoitem.cpp ===
#include "stdafx.h"

// Helper: return True if pActiveView is a valid CTextView pointer
BOOL FValidPTextView(CPartView * pActiveView)
{
	return 	(pActiveView != NULL && pActiveView->IsKindOf(RUNTIME_CLASS(CMultiEdit)));
}


// Helper: return True if dialog's current active view is a valid CTextView pointer
BOOL FValidCurTextView(CGoToDialog * pDlg)
{
	return 	(pDlg != NULL && pDlg->IsKindOf(RUNTIME_CLASS(CGoToDialog)) &&
		FValidPTextView(pDlg->m_pActiveView));
}

// Helper: returns dialogs current active view if it is a CTextView, otherwise NULL
CMultiEdit *PCurTextView(CGoToDialog * pDlg)
{
	if (FValidCurTextView(pDlg))
		return 	(CMultiEdit *)(pDlg->m_pActiveView);
	else
		return NULL;
}

void CDebugPackage::AddGoToItems(CGoToDialog *pDlg)
{
	// called by CGoToDIalog. That dialog will free up any created objects.
	CGoToAddress *pgtAddress = new CGoToAddress(pDlg);
	pDlg->AddItem(pgtAddress);
}

	// ***Initialization. These functions are used to initialize the Go To
	// dialog. They will be called when the dialog is invoked but may
	// actually be called at any time.


	// REQUIRED: Return the string to show in the Go To What listbox

static CString strGotoaddrWhat;	// static so we can return

CGoToAddress::CGoToAddress(CGoToDialog * pDlg) : CGoToItem(pDlg)
{
    return;
}

const TCHAR * CGoToAddress::GetItemString()
{
	if (strGotoaddrWhat.IsEmpty())
    {
		strGotoaddrWhat.LoadString(IDS_GOTOADDR_WHAT);
		ASSERT(!strGotoaddrWhat.IsEmpty());
    }

	return strGotoaddrWhat;
}


	// ***Callbacks. These functions are called as the user manipulates the Go To
	// dialog or active editor view

	// Called when the item is selected in the Go To What listbox

void CGoToAddress::OnSelectWhat()
{
	// need to set button style, control style, prompt and helper text
	// since this uses an edit control, not a list box, we don;t have
	// list issues. We do need to initialize the edit

	// Called when the item is selected in the Go To What listbox,
	// and at CGoToDialog startup and reactivation.
	// CGoToDialog will call CanGoViewActive after returning from this
	// call, so let it handle situational enabling/disabling

	// Note that this function needs to be able to tolerate a NULL m_pDlg->m_pActiveView
	// or one of the incorrect type. It should set what it can and leave other controls empty.

	ASSERT(m_pDlg != NULL);

	ADDR addr = {0}; // just so we can init m_addr
	m_addr = addr;

	m_pDlg->SetControlStyle(CGoToDialog::csEdit);

	CString str;
	str.LoadString(IDS_GOTOADDR_PROMPT);
	m_pDlg->SetPrompt(str);

	str.LoadString(IDS_GOTOADDR_HELP);
	m_pDlg->SetHelperText(str);
	m_pDlg->SetButtonStyle(CGoToDialog::bsGoTo);


	if (!FValidCurTextView(m_pDlg) || !CanGoViewActive((CPartView *)m_pDlg->m_pActiveView))
		m_pDlg->Select("");
	else
	{
		ASSERT (FValidCurTextView(m_pDlg));
		CMultiEdit   *pCurTextDoc = PCurTextView(m_pDlg);

		ASSERT(pCurTextDoc != NULL);
		
		BOOL fDAMWindow = pCurTextDoc->m_dt == DISASSY_WIN;

		BOOL			fLookAround = TRUE;
		char			sz[ axMax ];
		*sz = '\0';

		if ( IsFindComboActive() )
			CWnd::GetFocus()->GetWindowText((LPTSTR)sz, sizeof(sz));
		else
		{
			if ( fDAMWindow )
			{
    			ICH	ichLeft;

    			PCurTextView(m_pDlg)->GetCurrentText(&fLookAround,(LPSTR)sz,sizeof( sz ),&ichLeft,NULL);
			}
			else
			{
				ASSERT (pCurTextDoc->m_dt == MEMORY_WIN);

				PMWI	pmwi = &((CMemoryView *)pViewMemory)->m_mwi;
				strcpy( sz, pmwi->szExpr );
			}
		}

    	m_pDlg->Select(sz);	
	}
}

	// Called when the active editor changes, and after OnSelectWhat is called.
	// A FALSE return indicates that the item should not be enabled in the dialog,
	// TRUE indicates that the item may be active.
	// check all situations that may require deactivation here (e.g., deactivate if
	// editor specific and in wrong editor, or if going to an empty list, e.g., of bookmarks)

BOOL CGoToAddress::CanGoViewActive(CPartView * pActiveView)
{
	CMultiEdit  *pCurTextDoc;
    DOCTYPE     dt;

	if (!FValidPTextView(pActiveView))
		return FALSE;

	pCurTextDoc = (CMultiEdit *)pActiveView;
    dt          = ((CMultiEdit *)pCurTextDoc)->m_dt;

    return( (dt == DISASSY_WIN || dt == MEMORY_WIN ) && DebuggeeAlive() );
}


	// Called when the selection control changes (either the user changed
	// the text in the edit control or they selected something from the
	// drop list). For csEdit style selection controls, the fSelInList
	// and dwItemData parameters should be ignored (FALSE/-1 will always
	// be passed here).
	// fSelInList will be true if there is an item selected in the list
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	// generally used for simple test like handling empty strings

void CGoToAddress::OnSelectChange(	const TCHAR * szSelect,
								BOOL /* fSelInList */, // ignored since csEdit
								DWORD dwItemData)
{
	ASSERT(m_pDlg != NULL);
	m_pDlg->EnableButton (mskButtonGoToNext, (*szSelect != '\0'));
}

	// Override this to indicate whether or not a go to operation can be
	// attempted. Done when an action button is hit.
	// For goNext and goPrevious operations, the szSelect
	// and dwItemData items are not used.
	// For goGoTo operations, they describe the string and optional
	// user-data selected in the Go To dialog.
	// fSelInList will be true if there is an item selected in the list
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	// m_pDlg and idDlgItemError are used to return focus to in case of error

BOOL CGoToAddress::CanGoTo(int idDlgItemError,
						GOTO_TYPE go,
						const TCHAR * szSelect,
						BOOL /* fSelInList */,
						DWORD /* dwItemData */)
{
	BOOL fRet = FALSE;

	if (!FValidCurTextView(m_pDlg))
	{
		ASSERT (FALSE);
		return FALSE;
	}

	CMultiEdit  *pCurTextDoc = PCurTextView(m_pDlg);
	ASSERT(pCurTextDoc != NULL);

	BOOL fDAMWindow = pCurTextDoc->m_dt == DISASSY_WIN;

	ADDR addr = {0}; // just so we can init m_addr
	m_addr = addr;

	if ( fDAMWindow )
	{
		ADDR	addrFixedUp = {0};
		int		radixInputSave;
		TCHAR	sz[ axMax ];
        TCHAR   *psz = sz;

		extern BOOL FAddrFromSz( char *, ADDR * );

		// To solve the problem that the dialog may be initialized
		// with text from the disassembly window, change the default
		// input radix to hex.  When this code exits, the radix HAD
		// BETTER BE RESTORED!!!!
		radixInputSave = radixInput;
		radixInput = 16;

		_fstrcpy( sz, szSelect );

		// Skip leading zeroes.  We don't want to force this to octal
		// and this will clearly be a bug if the user actually wanted
		// to enter octal!
		if ( *sz == '0' )
        {
			while( *psz && *psz == '0' )
				++psz;

			// The zero is required for specifying hex or dex (ie 0n10 or 0x1fa)
			if ( psz > sz && ( !*psz || *psz == 'n' || *psz == 'N' || *psz == 'x' || *psz == 'X' ) )
				--psz;
 		}

		// Try to get an addr from the expression
		
		fRet = FAddrFromSz (psz, &m_addr);

		if (fRet) {
			addrFixedUp = m_addr;
			SYFixupAddr (&addrFixedUp);
		}

		if (!fRet) {
			CVMessage (ERRORMSG, BADADDR, MSGSTRING, (char FAR *)sz);
			DebuggerMessage (Error, 0, (LPSTR)sz, SHOW_IMMEDIATE);
		}

		// Make sure that the radix gets restored.
		radixInput = radixInputSave;
	}
	else
	{
		char	sz[ axMax ];
		MWI		mwi = {0};

		ASSERT (pCurTextDoc->m_dt == MEMORY_WIN);

		_ftcsncpy( sz, (LPCTSTR)szSelect, sizeof( sz ) );
    	sz[ sizeof( sz ) - 1 ] = '\0';

		mwi.szExpr = sz;

    	fRet = (MWSetAddrFromExpr( &mwi, runDebugParams.iMWAutoTypes));

		if ( fRet )
		{
			// actually do the work here because it is sticky saving part to OnGoTo
			ASSERT(pViewMemory);

			// Update the global address
			MWSaveSettings(sz);
			CMemoryView * pView = (CMemoryView *)pViewMemory;

			// Update the memory window. Note we will see no actula selection, but the edit text
			// will be updated to reflect the new address
			pViewMemory->SendMessage( WM_COMMAND, 0, 0L );

		}
		else
		{
			CVMessage(ERRORMSG, BADADDR, MSGSTRING, (char FAR *)sz);
			DebuggerMessage( Error, 0, (LPSTR)sz, SHOW_IMMEDIATE );
		}
	}

	return fRet;

}

	// Override this to handle a go to operation. For goNext and goPrevious
	// operations, the szSelect and iSelList, and dwItemData items are not used. For goGoTo
	// operations, they describe the string and optional listbox user-data
	// selected in the Go To dialog, and the list selection, if any.
	// fSelInList will be true if there is an item selected in the list
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

void CGoToAddress::OnGoTo(GOTO_TYPE go, const TCHAR * szSelect, BOOL /* fSelInList */,DWORD /* dwItemData */)
{
	ASSERT (FValidCurTextView(m_pDlg));

	CMultiEdit  *pCurTextDoc = PCurTextView(m_pDlg);

	ASSERT(pCurTextDoc != NULL);
	ASSERT (szSelect != NULL);
	ASSERT(go == goGoTo || *szSelect == '\0'); // next/prev should have no text

	BOOL fDAMWindow = ((CMultiEdit *)pCurTextDoc)->m_dt == DISASSY_WIN;

	if ( fDAMWindow )
	{
		CXF		cxf = {0};

		*SHpADDRFrompCXT( SHpCXTFrompCXF( &cxf ) ) = m_addr;

		// This wll make sure that the window is either
		// open or has the input focus
		if ( !pViewDisassy )
			OpenDebugWindow( DISASSY_WIN );
		else
			theApp.SetActiveView( pViewDisassy->GetSafeHwnd() );

		// Window is open, set to new address
		if( pViewDisassy )
		{
			CDAMView *pView = (CDAMView *)pViewDisassy;
			pViewDisassy->SendMessage(WU_UPDATEDEBUG,wPCXF,(DWORD)&cxf);
            pView->SelectWordCur();  // select word at cursor
		}
	}
	else
	{
	   	ASSERT (pCurTextDoc->m_dt == MEMORY_WIN);
		// all work was done in the cangoto code
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\javadbg.cpp ===
//
// javadbg.cpp
//
// Miscellaneous Java debugger support

#include "stdafx.h"
#pragma hdrstop

#include "javadbg.h"

size_t LOADDS PASCAL JavaGetDebuggeeBytes(HTM hTM, size_t cb, void FAR* bBuff, PFRAME pFrame)
{
	// in Java, the notion of debuggee bytes is really the value of the expression,
	// so we'll just use the EE to evaluate the expression and give us the result

	// get the value of the expression in the TM from the EE
	RTMI rtmi = { 0 };
	rtmi.fValue = TRUE;
	rtmi.fSzBytes = TRUE;
	HTI hti;

	if (EEvaluateTM (&hTM, pFrame, EEHORIZONTAL) == EENOERROR &&
		EEInfoFromTM(&hTM, &rtmi, &hti) == EENOERROR)
	{
		PTI pti = (PTI)BMLock(hti);

		// copy the value from the TM info to the buffer
		memset(bBuff, 0, cb);
		memcpy(bBuff, pti->Value, pti->cbValue);

		cb = pti->cbValue;

		BMUnlock(hti);
		EEFreeTI(&hti);
	}
	else {
		cb = 0;
	}

	return cb;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\idbg.cpp ===
#include "stdafx.h"
#pragma hdrstop

#pragma warning(disable:4103)
#include <initguid.h>
#include <olectlid.h>
#include <dbgpguid.h>
#include <prjguid.h>
#include <srcguid.h>
#include <bldguid.h>
#include <utilguid.h>
#include <clvwguid.h>
#pragma warning(default:4103)

BEGIN_INTERFACE_MAP(CDebugPackage, CPackage)
	INTERFACE_PART(CDebugPackage, IID_IDbgPkg, DbgPkg)
	INTERFACE_PART(CDebugPackage, IID_IDLLInfo, DLLInfo)
END_INTERFACE_MAP()

STDMETHODIMP CDebugPackage::XDbgPkg::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP_(ULONG) CDebugPackage::XDbgPkg::AddRef()
{
	// Delegate to our exported AddRef.

	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDebugPackage::XDbgPkg::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP_(BOOL) CDebugPackage::XDbgPkg::DebuggeeAlive(void)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
    return( ::DebuggeeAlive() );
}

STDMETHODIMP_(BOOL) CDebugPackage::XDbgPkg::DebuggeeRunning(void)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
    return( ::DebuggeeRunning() );
}

STDMETHODIMP_(BOOL) CDebugPackage::XDbgPkg::CanShowDataTip(void)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	return runDebugParams.fDataTips && 
			DebuggeeAlive() && 
			!DebuggeeRunning();
}

STDMETHODIMP CDebugPackage::XDbgPkg::EvaluateExpression(LPTSTR szText, BOOL bFromSelection, LPTSTR szResult, ULONG cb)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	if (bFromSelection)
	{
		RemoveSideEffectsExpr(szText);
	}
	if (FEvalExpr(szText, szResult, (int)cb))
		return ResultFromScode(NOERROR);
	else
		return ResultFromScode(E_FAIL);
}

STDMETHODIMP CDebugPackage::XDbgPkg::SetDebugLines(CDocument *pDoc, BOOL ResetTraceInfo)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	::SetDebugLines(pDoc, ResetTraceInfo);
	return ResultFromScode(NOERROR);
}

STDMETHODIMP CDebugPackage::XDbgPkg::AdjustDebugLines(CDocument * pDoc, int StartLine, int NumberLines, BOOL fAdded, BOOL fLineBreak, BOOL fWhiteSpaceOnly)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	::AdjustDebugLines(pDoc, StartLine, NumberLines, fAdded, fLineBreak, fWhiteSpaceOnly);
	return ResultFromScode(NOERROR);
}

STDMETHODIMP CDebugPackage::XDbgPkg::DeleteBreakpointLinesInDoc(LPCTSTR sz)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	CString str(sz);
	::DeleteBreakpointLinesInDoc(str);
	return ResultFromScode(NOERROR);
}

STDMETHODIMP_(void *) CDebugPackage::XDbgPkg::DbgDAMHsfFromFile(LPCTSTR psz)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
    extern HSF PASCAL DAMHsfFromFile( const char FAR * );

    return( DAMHsfFromFile(psz) );
}

STDMETHODIMP_(BOOL) CDebugPackage::XDbgPkg::GetExecutablePath(PSTR pszOut)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
    lstrcpy(pszOut, ExecutablePath);

    return( TRUE );
}

STDMETHODIMP_(BOOL) CDebugPackage::XDbgPkg::IsENCProjectFile(CPath *ppath)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
    extern BOOL ENCProjectFile(CPath *ppath);

    return ENCProjectFile(ppath);
}

STDMETHODIMP CDebugPackage::XDbgPkg::VTestDebugActive(BOOL *bActive)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DbgPkg)
	BOOL bReturn = fVisTestDebugActive;
	fVisTestDebugActive = *bActive;
	*bActive = bReturn;
	return NOERROR;
}

///////////////////////////////////////////////////////////////////
// IUnknown methods (IDLLInfo)

STDMETHODIMP_(ULONG) CDebugPackage::XDLLInfo::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CDebugPackage, DLLInfo)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CDebugPackage::XDLLInfo::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CDebugPackage, DLLInfo)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CDebugPackage::XDLLInfo::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CDebugPackage, DLLInfo)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}

///////////////////////////////////////////////////////////////////
// IDLLInfo methods (IDLLInfo)

extern BOOL DiffDlls(HTARGET, CPtrList &, INT *, UINT *);
IDE_EXPORT int GetDLLCount(HTARGET);
extern void InitDLLList(ULONG, CPtrList &);
extern void SaveDLLList(ULONG, CPtrList &);

STDMETHODIMP CDebugPackage::XDLLInfo::DiffDLLs(ULONG hTarget, CPtrList &listDLLs, INT *piRow, UINT *pidMsg)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DLLInfo);
	return(::DiffDlls(hTarget, listDLLs, piRow, pidMsg) ? S_OK : S_FALSE);
}

STDMETHODIMP CDebugPackage::XDLLInfo::GetDLLCount(ULONG hTarget, int *piCount)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DLLInfo);
	*piCount = ::GetDLLCount((HTARGET)hTarget);
	return NOERROR;
}

STDMETHODIMP CDebugPackage::XDLLInfo::InitDLLList(ULONG hTarget, CPtrList &listDLLs)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DLLInfo);
	::InitDLLList(hTarget, listDLLs);
	return NOERROR;
}

STDMETHODIMP CDebugPackage::XDLLInfo::SaveDLLList(ULONG hTarget, CPtrList &listDLLs)
{
	METHOD_PROLOGUE_EX(CDebugPackage, DLLInfo);
	::SaveDLLList(hTarget, listDLLs);
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\hash.cpp ===
/*++

Copyright(c) 1997  Microsoft Corporation

Module Name:

	hash.cpp

Abstract:

	Some stuff for templated hash table package.  Look at the file
	hash.inl for the implementation of the hash table.

Author:

    Matthew D Hendel (math) 13-May-1997

--*/

#include "stdafx.h"

const ULONG Primes [] =
{
	37,          47,          67,          73,          89,          137,
	149,         173,         211,         257,         263,         269,
	293,         373,         379,         449,         479,         491,
	521,         587,         599,         659,         677,         733,
	787,         919,         929,         977,         983,         997,
	1009,        1061,        1201,        1213,        1217,        1237,
	1259,        1307,        1319,        1361,        1367,        1471,
	1523,        1531,        1543,        1559,        1607,        1709,
	1721,        1861,        1871,        1889,        1931,        1949,
	2143,        2153,        2267,        2287,        2377,        2389,
	2393,        2417,        2503,        2539,        2633,        2657,
	2659,        2729,        2789,        2797,        2837,        2879,
	2939,        2969,        3061,        3067,        3089,        3163,
	3167,        3203,        3209,        3217,        3331,        3389,
	3391,        3407,        3449,        3499,        3631,        3671,
	3691,        3709,        3821,        3847,        3917,        3931,
	3943,        3947,        3967,        3989,        4673,        5309,
	6607,        6761,        7283,        7817,        8513,        8999,
	9103,        9173,        9323,        10091,       10631,       13147,
	13397,       13873,       13997,       14419,       15013,       15031,
	16963,       19081,       20681,       21059,       21487,       21683,
	22769,       23209,       23497,       23599,       23623,       24197,
	24281,       24329,       24877,       25537,       25561,       29347,
	29917,       30851,       32531,       32887,       33589,       34961,
	37273,       37619,       38219,       38321,       38543,       38917,
	39043,       39667,       39953,       39979,       40693,       41579,
	42061,       42443,       43013,       43753,       43759,       44059,
	44531,       44647,       46133,       46727,       47381,       48049,
	48157,       48311,       48449,       49117,       50119,       50359,
	53047,       53101,       53267,       53269,       54083,       54517,
	54577,       54601,       55103,       55147,       56659,       56891,
	57457,       57991,       58211,       58337,       59341,       60013,
	60317,       61253,       62081,       62401,       63311,       63727,
	64433,       65089,       66343,       66449,       66569,       67531,
	68207,       68813,       69191,       69427,       69539,       69809,
	70841,       73181,       73351,       73583,       74093,       74257,
	74377,       75079,       75967,       76031,       77069,       79031,
	79087,       79537,       79559,       81071,       81527,       81967,
	84521,       84589,       85159,       85577,       85781,       86243,
	86813,       87187,       87701,       88681,       89891,       90089,
	91331,       92657,       93941,       93979,       94033,       94307,
	95549,       95857,       96443,       96487,       96517,       96703,
	97397,       97523,       98123,       98297,       100151,      100649,
	102533,      102587,      103591,      103769,      104233,      104491,
	105137,      106163,      108263,      109103,      109567,      109741,
	109751,      110183,      112799,      114311,      114967,      115963,
	117563,      118453,      118603,      118787,      119099,      121271,
	121507,      121843,      122147,      122489,      122839,      123581,
	123631,      124147,      124291,      124567,      124753,      126223,
	127219,      127997,      128717,      129419,      129443,      130769,
	131759,      135479,      136727,      137927,      139291,      140827,
	142501,      142559,      142573,      143333,      144563,      144629,
	144701,      144817,      145303,      146063,      146117,      148429,
	149053,      152083,      152441,      152533,      153271,      153929,
	154303,      154787,      154807,      155231,      155303,      155693,
	159589,      161717,      163193,      166273,      167149,      167213,
	169313,      169591,      171517,      174673,      175709,      176041,
	176489,      177967,      184199,      184607,      185789,      189463,
	189583,      190283,      193441,      194167,      194309,      195457,
	199289,      202219,      203449,      204749,      204913,      205991,
	208931,      212467,      213977,      214351,      216347,      219059,
	219361,      221251,      221537,      224669,      226483,      228181,
	230003,      230239,      230999,      231779,      232643,      233353,
	236207,      236503,      237967,      238141,      239441,      240997,
	241847,      243917,      244243,      247829,      248267,      248309,
	254039,      255869,      256019,      256057,      257339,      257921,
	257981,      260317,      260873,      261223,      263089,      268771,
	273929,      273971,      275623,      284153,      284539,      287237,
	290107,      292223,      293071,      295769,      295943,      298099,
	298451,      298897,      299977,      306809,      309031,      314467,
	315671,      317957,      318023,      321289,      323591,      324757,
	326681,      328037,      331651,      332837,      333041,      336823,
	339239,      342187,      344543,      346627,      346933,      351383,
	351643,      355331,      360007,      360541,      361183,      369293,
	369851,      373393,      373937,      374239,      374929,      381167,
	388169,      388231,      389003,      393451,      393929,      406951,
	412289,      413069,      414157,      417371,      418259,      418751,
	423121,      423307,      424903,      426731,      431857,      435983,
	441631,      446819,      451159,      451657,      453559,      453631,
	456821,      457087,      463663,      465071,      465293,      465407,
	469793,      470149,      471923,      477341,      483787,      484769,
	487637,      488227,      489817,      491039,      500567,      500909,
	502237,      505601,      513347,      514543,      516617,      522763,
	523169,      523177,      532733,      535303,      548323,      548771,
	558241,      571759,      579451,      588311,      592217,      612947,
	621583,      627293,      628673,      628799,      631429,      637129,
	638893,      642791,      644047,      646453,      647147,      648331,
	660181,      662203,      664199,      666607,      667507,      669023,
	686863,      693019,      713737,      723473,      730397,      745517,
	751237,      751321,      752251,      758029,      759223,      762871,
	763513,      778541,      780323,      780841,      809399,      810091,
	825229,      826711,      829159,      830309,      831967,      834497,
	836203,      839693,      852809,      856553,      856897,      859361,
	865717,      875107,      876371,      877817,      880027,      883109,
	883187,      887701,      904987,      907513,      920323,      921191,
	922487,      930973,      934033,      938387,      938437,      956503,
	957599,      964823,      964981,      966233,      975157,      977791,
	993541,      993683,      997769,      997949,      1000609,     1000697,
	1006123,     1008493,     1011827,     1011893,     1018873,     1020839,
	1021651,     1025789,     1028471,     1039279,     1043083,     1045543,
	1069919,     1143341,     1192699,     1229827,     1284317,     1484837,
	1576921,     1728317,     1776989,     1921747,     2136973,     2815993,
	3242741,     3250099,     3356887,     3603253,     3688661,     3728821,
	3878263,     4027519,     5049659,     5099009,     5970287,     6082877,
	6497453,     6941843,     7414843,     8221739,     8227363,     8348911,
	10207181,    10978691,    11769643,    12268411,    12600491,    12677407,
	12833441,    13178593,    14008381,    16632223,    17512069,    19167457,
	21225037,    21375821,    22492991,    25255831,    25769839,    27382181,
	30231937,    33249247,    33656081,    36280501,    48701881,    50044997,
	51524653,    51602263,    55633867,    61605589,    64620401,    65635133,
	72011221,    81148127,    96091343,    96533483,    102767663,   105270679,
	113083961,   121509259,   122008037,   122947933,   144655573,   171798791,
	178803551,   183792571,   184341169,   188621711,   216804967,   244609823,
	249846307,   255327089,   270947893,   295046699,   313227877,   323673101,
	377392009,   396772021,   407300819,   407560381,   432897131,   468734377,
	556368823,   588383363,   633068497,   665362081,   717397817,   771867997,
	773652487,   821146201,   875510453,   900546047,   1154772097,  1187122043,
	1209001181,  1252109039,  1548726757,  1583686249,  1654707661,  1669720813,
	1721118499,  1785257767,  2401783861,  2509908811,  2650017823,  2822422711,
	2833118147,  3514535009,  3571824167,  3646253383,  3775153601,  4136745101,
};

const ULONG nPrimes = (sizeof (Primes) / sizeof (Primes [0]));


ULONG
HashPjw(
	LPCSTR	sz
	)
/*++

Routine Description:

	Peter Weinberger's hash function from the Red Dragon Book.

--*/
{
	LPCSTR		p = NULL;
	ULONG		h = 0;
	ULONG		g = 0;

	for (p = sz; *p ; p++) {
	
		h = (h << 4) + *p;
		g = h & 0xF0000000;

		if (g) {
			h = h ^ (g >> 24);
			h ^= g;
		}
	}

	return h;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\ldouble.cpp ===
//-----------------------------------------------------------------------------
//	ldouble.c
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:
//		define stuff needed for long double in win32
//
//  Revision History:
//
//	[]		06-Apr-1993 Dans	Created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#pragma hdrstop

#if defined (_X86_)
//#include <ldouble.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//
// imported stuff from the CRT for 10-byte real support
//
#define cbMantissaMax	22
#define cdigitPrecision	LDBL_DIG


typedef struct FOS {	/* Floating point Output Structure */
	short	exp;
	char	sign;
	char	cbMantissa;
	char	rgchMantissa[ cbMantissaMax ];
	} FOS, *PFOS;

#ifdef __cplusplus
extern "C"
#endif
unsigned __cdecl
__STRINGTOLD (
	FLOAT10 *,
	const char **	ppchEnd,
	const char *	szFloat,
	int				fMultIn12
	);

#ifdef __cplusplus
extern "C"
#endif
int __cdecl
$I10_OUTPUT (
	FLOAT10,
	int			cDigits,
	unsigned	outputFlags,
	PFOS		pfos
	);

// SzFromLd
//	return a string rep of the long double passed in
//
char *	SzFromLd ( char * pchBuf, size_t cb, FLOAT10 f10 ) {
	FOS	fos;

	if ( $I10_OUTPUT ( f10, cdigitPrecision, 1, &fos ) ) {
		if ( fos.cbMantissa == 1 && fos.rgchMantissa[0] == '0' ) {
			fos.exp++;
			}
		memset ( &fos.rgchMantissa[ fos.cbMantissa ], '0', cbMantissaMax - fos.cbMantissa );

		fos.rgchMantissa[ cdigitPrecision ] = 0;
		if ( fos.sign == 0x20 )
			fos.sign = '+';
		_snprintf (
			pchBuf,
			cb,
			"%c%c.%se%+05hd",
			fos.sign,
			fos.rgchMantissa[0],
			&fos.rgchMantissa[1],
			fos.exp - 1
			);
		}
	else {
		// signifies that it is a special number
		_snprintf ( pchBuf, cb, fos.rgchMantissa );
		}
	return pchBuf;
	}

// LdFromSz
//	generate a FLOAT10 from a string rep
//
FLOAT10	LdFromSz ( char * szFloat, char ** ppchEnd ) {
	
	FLOAT10	f10ret = {0};

	__STRINGTOLD ( &f10ret, (const char **)ppchEnd, szFloat, TRUE );
	return f10ret;
	}
#endif	// _X86_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\linklist.cpp ===
#include "stdafx.h"
#pragma hdrstop


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/*** LLHlliInit
*
* Purpose:
*	Create a new list with specified options
*
* Input:
*	cbUserData :	Number of bytes for user data per node.  Must be > 0.
*	llf        :	List type flags (llfNull, llfAscending, or llfDescending)
*	            	(indicates wether or not list is sorted)
*	lpfnKill   :	callback to application for node deletion notification
*	            	(may be NULL)
*	lpfnCmp    :	Node comparison callback.  May be NULL for non-sorted
*	            	lists.  Otherwise, required.
*
* Output:
*	Either returns valid HLLI for newly created list or NULL for failure.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLI PASCAL
LLHlliInit(
UINT			cbUserData,
LLF				llf,
LPFNKILLNODE	lpfnKill,
LPFNFCMPNODE	lpfnCmp ) {
	HLLI	hlli;
	LPLLI	lplli;

	ASSERT( cbUserData );
	ASSERT( llf == llfNull || lpfnCmp );

	if ( hlli = HlliAlloc() ) {
		lplli = LockHlli( hlli );
		_fmemset( lplli, 0, sizeof( LLI ) );
		AllocCritSec(lplli->pcs);
		lplli->cbUserData = cbUserData;
		lplli->lpfnKill = lpfnKill;
		lplli->lpfnCmp = lpfnCmp;
		lplli->llf = llf;
		UnlockHlli( hlli );
	}
	return hlli;
}

/*** LLHlleCreate
*
* Purpose:
*	Allocate and initialize new node for list
*
* Input:
*	hlli     :	List to create node for.
*
* Output:
*	Returns newly created node (zero filled) if successful, otherwise
*	NULL.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleCreate(
HLLI	hlli ) {
	LPLLE	lplle;
	LPLLI	lplli;
	HLLE	hlle;
	WORD	cbNode;

	ASSERT( hlli );
//
// Ensure that the list is OK
//
#if _DEBUG > 1
	LLFCheckHlli( hlli );
#endif
//
// Compute size of node with user data area
//
	lplli = LockHlli( hlli );
	cbNode = sizeof( LLE ) + lplli->cbUserData;
	UnlockHlli( hlli );

#ifdef _DEBUG
//
// Debug version, we're going to stuff a "sentinel" on to the end of the
// user's data for consistency checks.
//
	cbNode += sizeof( WORD );
#endif	// _DEBUG
//
// Allocate the node
//
	if ( hlle = HlleAllocCb( cbNode ) ) {
		lplle = LockHlle( hlle );
		_fmemset( (LPV)lplle, 0, cbNode );
#ifdef _DEBUG
//
// Stuff in the consistency check stuff
//
		*(WORD FAR *)((BYTE FAR *)lplle + cbNode - sizeof( WORD )) = WCONSIST;
		lplle->wTest = WCONSIST;
#endif	// _DEBUG
		UnlockHlle( hlle );
	}

	return hlle;
}

/*** LLAcquire
*
* Purpose:
*	Acquires the critical section on a linked list.
*
* Input:
*	hlli   :	List to acquire
*
* Output:
*	Nothing.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
VOID PASCAL
LLAcquire(
HLLI	hlli ) {

	LPLLI	lplli;

	ASSERT( hlli );

	lplli = LockHlli ( hlli );
	AcquireLockPcs ( lplli->pcs );

	UnlockHlli( hlli );
}

/*** LLRelease
*
* Purpose:
*	Releases the critical section on a linked list.
*
* Input:
*	hlli   :	List to release
*
* Output:
*	Nothing.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
VOID PASCAL
LLRelease(
HLLI	hlli ) {

	LPLLI	lplli;

	ASSERT( hlli );

	lplli = LockHlli ( hlli );
	ReleaseLockPcs ( lplli->pcs );

	UnlockHlli( hlli );
}

/*** LLFAddHlleToLl
*
* Purpose:
* 	Add a new node to the end of a list.
*
* Input:
*	hlli    :	List to add node to.
*	hlle    :	Node to append to list.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLAddHlleToLl(
HLLI	hlli,
HLLE	hlle ) {
	LPLLE	lplle;
	LPLLI	lplli;

	ASSERT( hlli );
	ASSERT( hlle );

	lplle = LockHlle( hlle );
	lplli = LockHlli( hlli );

	AcquireLockPcs(lplli->pcs);

	ASSERT( lplli->llf == llfNull );
//
//	Initalize node: Since this is to be the last item in the list,
//	pNext should be null.  Also, the pPrev should point to the
//	currently last item in the list (includes NULL)
//
	lplle->hlleNext = hlleNull;
#ifdef DBLLINK
	lplle->hllePrev = lplli->hlleTail;
#endif	// DBLLINK
//
//	Chalk up one more for the list
//
	lplli->chlleMac++;
//
//	If the pHead is NULL then initialize the pHead and pTail
//	(you know, like this is the only item in the list)
//
	if ( lplli->hlleHead == hlleNull ) {
		lplli->hlleHead = lplli->hlleTail = hlle;
	}
//
//	Otherwise, update the tail pointer and the pNext for the old tail
//
	else {
		HLLE	hlleT = lplli->hlleTail;

		LockHlle( hlleT )->hlleNext = hlle;
		UnlockHlle( hlleT );
		lplli->hlleTail = hlle;
	}
	UnlockHlle( hlle );

//
// Ensure that the list is OK
//
#if _DEBUG > 1
	LLFCheckHlli( hlli );
#endif


	ReleaseLockPcs(lplli->pcs);
	UnlockHlli( hlli );
}

/***
*
* Purpose:
*
* Input:
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLInsertHlleInLl(
HLLI	hlli,
HLLE	hlleNew,
DWORD	lParam ) {

	USHORT			fNeedPos = fTrue;
	LPLLI			lplli = LockHlli( hlli );
	HLLE			hlle = hlleNull;
	HLLE			hllePrev = hlleNull;
	WORD			wPos = 0;
	LPFNFCMPNODE	lpfnCmp;
	LPV 			lpv;

	ASSERT( hlli );
	AcquireLockPcs( lplli->pcs );

	lpfnCmp = lplli->lpfnCmp;
	ASSERT( lplli->llf == llfNull || lpfnCmp );

	lpv = LLLpvFromHlle( hlleNew );

	switch( lplli->llf ) {
		case llfNull:
			hlle = LLHlleFindNext( hlli, hlle );
			while( wPos++ < LOWORD( lParam ) ) {
				hllePrev = hlle;
				hlle = LLHlleFindNext( hlli, hlle );
			}
			break;

		case llfAscending:
			while( fNeedPos && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
				fNeedPos = lpfnCmp( LLLpvFromHlle( hlle ), lpv, lParam ) == fCmpLT;
				UnlockHlle( hlle );
				if ( fNeedPos ) {
					hllePrev = hlle;
				}
			}
			break;

		case llfDescending:
			while( fNeedPos && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
				fNeedPos = lpfnCmp( LLLpvFromHlle( hlle ), lpv, lParam ) == fCmpGT;
				UnlockHlle( hlle );
				if ( fNeedPos ) {
					hllePrev = hlle;
				}
			}
			break;
	}
	LLInsertHlle( hlli, hllePrev, hlleNew, hlle );
	UnlockHlle( hlleNew );

	ReleaseLockPcs( lplli->pcs );

	UnlockHlli( hlli );
}

/*** LLFDeleteHlleIndexed
*
* Purpose:
*	Delete the ith node from a list.
*
* Input:
*	hlli    :	List containing node to delete
*   lPos    :	zero based index of node to delete.
*
* Output:
*	Return fTrue for successful deletion, else fFalse.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
BOOL PASCAL
LLFDeleteHlleIndexed(
HLLI	hlli,
DWORD	lPos ) {

	USHORT	fRet = fFalse;
	LPLLI	lplli = LockHlli( hlli );
	HLLE	hlleKill = lplli->hlleHead;
	HLLE	hllePrev = hlleNull;
	DWORD	lPosCur = 0L;

	ASSERT( hlli );

	AcquireLockPcs( lplli->pcs );

//
//	Make sure that we're not deleting past the end of the list!
//
	if ( lPos < lplli->chlleMac ) {
//
//	Chug through the list until we find the sucker to kill!
//
		while ( lPos != lPosCur ) {
			hllePrev = hlleKill;
			hlleKill = LLHlleFindNext( hlli, hlleKill );
			++lPosCur;
		}
		LLDeleteHlle( hlli, hllePrev, hlleKill );
		fRet = fTrue;
	}

#if _DEBUG > 1
	LLFCheckHlli( hlli );
#endif

	ReleaseLockPcs( lplli->pcs );

	UnlockHlli( hlli );
	return fRet;
}

/*** LLFDeleteLpvFromLl
*
* Purpose:
*	Delete a node from a list containing lpv data.
*
* Input:
*	hlli    :	List containing node to delete
*	hlle    :   Node to begin search for delete node at.
*	lpv     :	far pointer to comparison data.  Passed onto compare callback.
*	lParam  :	Application supplied data.  Just passed onto compare callback.
*
* Output:
*	Returns fTrue if node has been deleted, else fFalse
*
* Exceptions:
*
* Notes:
*	There must be a compare routine assiciated with this list!!!
*	For a doubly linked list, this is simple.  For singly linked
*	list, we have to go through the list to get the previous node
*	to ensure that the pointers are correct.
*
*************************************************************************/
BOOL PASCAL
LLFDeleteLpvFromLl(
HLLI	hlli,
HLLE	hlle,
LPV 	lpv,
DWORD	lParam ) {

	ASSERT( hlli );

#ifdef DBLLINK
	LPLLI	lplli = LockHlli ( hlli );

	AcquireLockPcs ( lplli->pcs );

	hlle = LLHlleFindLpv( hlli, hlle, lpv, lParam );
	if ( hlle ) {
		LLDeleteHlle( hlli, LLHlleFindPrev( hlli, hlle ), hlle );
	}

#if _DEBUG > 1
	LLFCheckHlli( hlli );
#endif
	ReleaseLockPcs ( lplli->pcs );
	UnlockHlli ( hlli );
	return hlle != hlleNull;

#else	// DBLLINK

	LPLLI			lplli = LockHlli( hlli );
	HLLE			hlleNext;
	LPFNFCMPNODE	lpfnCmp;

	AcquireLockPcs ( lplli->pcs );

	lpfnCmp = lplli->lpfnCmp;

	ASSERT( lpfnCmp );
//
//	We're goint to delete the first occurance AFTER the one specified!
//
	hlleNext = LLHlleFindNext( hlli, hlle );
//
// Look up the data in the list
//
	while( hlleNext &&
		lpfnCmp( LLLpvFromHlle( hlleNext ), lpv, lParam ) != fCmpEQ ) {
		UnlockHlle( hlleNext );
		hlle = hlleNext;
		hlleNext = LLHlleFindNext( hlli, hlleNext );
	}
//
// if hlleNext is non-null then we've found something to delete!!!
//
	if ( hlleNext ) {
		LLDeleteHlle( hlli, hlle, hlleNext );
	}
#if _DEBUG > 1
	LLFCheckHlli( hlli );
#endif

	ReleaseLockPcs ( lplli->pcs );

	UnlockHlli( hlli );
	return hlleNext != hlleNull;

#endif	// DBLLINK
}

/*** LLHlleFindNext
*
* Purpose:
*	Get the next node in a list.
*
* Input:
*	hlli   :	List to search in.
*	hlle   : Place to begin.  If NULL, then return hlleHead.
*
* Output:
*	Returns a handle to the next item in the list.  hlleNull is returned
*	if the end of the list has been reached.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleFindNext(
HLLI	hlli,
HLLE	hlle ) {
	HLLE		hlleRet;

	ASSERT( hlli || hlle );
//
//	if hlle is non-null, return the next handle
//
	if ( hlle ) {
		hlleRet = LockHlle( hlle )->hlleNext;
		UnlockHlle( hlle );
	}
//
//	otherwise, we want the beginning of the list, so return the "head"
//
	else {
		LPLLI	lplli;

		lplli = LockHlli ( hlli );
		AcquireLockPcs ( lplli->pcs );
		hlleRet = lplli->hlleHead;
		ReleaseLockPcs ( lplli->pcs );
		UnlockHlli( hlli );
		}

	return hlleRet;
}

/*** LLHlleFindPrev
*
* Purpose:
*	Get the previous node in a list.  DOUBLY LINKED LIBRARY ONLY!!!
*
* Input:
*	hlli    :	List to search in.
*	hlle    :	Place to beging search at.  If hlleNull, the return the
*	         	last node in the list.
*
* Output:
*	Return a handle to the previous node in the list, hlleNull if the
*	beginning of the list has been hit.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
#ifdef DBLLINK
HLLE PASCAL
LLHlleFindPrev(
HLLI	hlli,
HLLE	hlle ) {
	HLLE	hlleRet;

	ASSERT( hlli || hlle );

//
//	if hlle is non-null, return the next handle
//
	if ( hlle ) {
		hlleRet = LockHlle( hlle )->hllePrev;
		UnlockHlle( hlle );
	}
//
//	otherwise, we want the beginning of the list, so return the "head"
//
	else {
		LPLLI	lplli;

		lplli = LockHlli ( hlli );
		AcquireLockPcs ( lplli->pcs );
		hlleRet = lplli->hlleTail;
		ReleaseLockPcs ( lplli->pcs );
		UnlockHlli( hlli );
	}

	return hlleRet;
}
#endif	// DBLLINK

/***  LLChlleDestroyList
*
* Purpose:
*	Free all memory associated with a specified list.  Completely
*	destroys the list.  Must call HlliInit() to add new items to list.
*
* Input:
*	hlli    :	List to destroy
*
* Output:
*	Returns number of nodes destroyed in list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
DWORD PASCAL
LLChlleDestroyLl(
HLLI	hlli ) {
	DWORD	cRet = 0;
	LPLLI	lplli;

	ASSERT( hlli );

	lplli = LockHlli ( hlli );
	AcquireLockPcs ( lplli->pcs );

	while ( LLChlleInLl( hlli ) != 0 ) {
		LLFDeleteHlleIndexed( hlli, 0 );
		++cRet;
	}

	ReleaseLockPcs ( lplli->pcs );
	FreePcs ( lplli->pcs );
	FreeHlli( hlli );

	return cRet;
}

/*** LLHlleFindLpv
*
* Purpose:
*	Locate a node in a list containing specific data.
*
* Input:
*	hlli    :	List to search in.
*	hlle    :	Starting place to begin search.  If NULL, start at
*	         	beginning of list.
*  lpv     :	Data passed on to compare callback for match.
*  lParam  :	Application supplied data.  Just passed on to callback.
*
* Output:
*	Returns handle to node meeting compare criteria or NULL if not found.
*
* Exceptions:
*
* Notes:
*	Requires that list has a callback function.
*
*************************************************************************/
HLLE PASCAL
LLHlleFindLpv(
HLLI	hlli,
HLLE	hlle,
LPV	lpvFind,
DWORD	lParam ) {

	HLLE	hlleRet = hlleNull;
	LPLLI	lplli;
	LPLLE	lplle;

	ASSERT( hlli );

	lplli = LockHlli( hlli );
	AcquireLockPcs ( lplli->pcs );

	ASSERT( lplli->lpfnCmp );

	hlle = LLHlleFindNext( hlli, hlle );

	while ( hlle != hlleNull && hlleRet == hlleNull ) {
		lplle = LockHlle( hlle );
		if ( lplli->lpfnCmp( (LPV)lplle->rgw, lpvFind, lParam ) == fCmpEQ ) {
			hlleRet = hlle;
		}
		UnlockHlle( hlle );
		hlle = LLHlleFindNext( hlli, hlle );
	}

	ReleaseLockPcs ( lplli->pcs );
	UnlockHlli( hlli );

	return hlleRet;
}

/*** LLFCheckHlli
*
* Purpose:
*	Consistency check for a list.
*
* Input:
&	hlli      :	List to check.
*
* Output:
*	Returns non-null if list is OK, otherwise failure is indicated.
*
* Exceptions:
*
* Notes:
*	This is a debug only function.  We will zip through the entire list
*	and check the head and tail words of EACH node for our magic WCONSIST
*	value.  If either one is not correct, someone trashed a node.  We also
*	check to see that the last node in the list is actually hlleTail for the
*	list.
*
*************************************************************************/
#ifdef _DEBUG
BOOL PASCAL
LLFCheckHlli(
HLLI	hlli ) {
	LPLLI	lplli;
	LPLLE	lplle;
	HLLE	hlle = hlleNull;
	WORD	cbOffSet;
	USHORT	fRet;
	HLLE	hlleLast;

	ASSERT( hlli );

	lplli = LockHlli( hlli );
	cbOffSet = sizeof( LLE ) + lplli->cbUserData;
	hlleLast = LLHlleFindNext( hlli, hlleNull );

	fRet = lplli->cbUserData; // && lplli->lpfnCmp && lplli->lpfnKill;
	if ( lplli->chlleMac ) {
		fRet = fRet && lplli->hlleHead && lplli->hlleTail;
	}
	else {
		fRet = fRet && !lplli->hlleHead && !lplli->hlleTail;
	}
	while( fRet && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
		lplle = LockHlle( hlle );
		fRet = ( lplle->wTest == WCONSIST &&
			*((WORD FAR *)( (BYTE FAR *)lplle + cbOffSet )) == WCONSIST );
		hlleLast = hlle;
		UnlockHlle( hlle );
	}
	if ( fRet ) {
		fRet = hlleLast == lplli->hlleTail;
	}
	UnlockHlli( hlli );
	ASSERT( fRet );
	return fRet;
}
#endif	// _DEBUG

/*** LLInsertHlle
*
* Purpose:
*	INTERNAL utility function to insert a node into a specified place
*	in the list.  This will update the pointers and head/tail information
*	for the list.
*
* Input:
*	hlli       :	List to insert node into.
*	hllePrev   :	Node which will appear right before the inserted one.
*	hlle       :	Our newly created node.
*	hlleNext   :   The node which will be immediately after the new one.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLInsertHlle(
HLLI	hlli,
HLLE	hllePrev,
HLLE	hlle,
HLLE	hlleNext ) {

	LPLLE	lplle;
	LPLLI	lplli;

	ASSERT( hlli );
	ASSERT( hlle );

//
// Note that we don't need to acquire critical sections here since the
//	higher level routines do that.
//
	lplli = LockHlli( hlli );
	lplle = LockHlle( hlle );
//
//	If there is a previous node, update its hnext
//
	if ( hllePrev ) {
		LockHlle( hllePrev )->hlleNext = hlle;
		UnlockHlle( hllePrev );
	}
//
// Otherwise, update the head
//
	else {
		lplli->hlleHead = hlle;
	}
//
// Set the hNext for the new node
//
	lplle->hlleNext = hlleNext;
//
// We're adding to the end of the list, update the hlleTail
//
	if ( hlleNext == hlleNull ) {
		lplli->hlleTail = hlle;
	}
//
//	If there is a next, update its hPrev
//
#ifdef DBLLINK
	else {
		LockHlle( hlleNext )->hllePrev = hlle;
		UnlockHlle( hlleNext );
	}
//
// Set the hPrev for the new node
//
	lplle->hllePrev = hllePrev;
#endif	// DBLLINK
//
// Increment the number of items on the list
//
	++lplli->chlleMac;
	UnlockHlle( hlle );
	UnlockHlli( hlli );
}

/*** LLFDeleteHlleFromLl
*
* Purpose:
*	Delete a specified hlle.  Update head/tail and node pointers.
*
* Input:
*	hlli      :	List containing node to delete.
*	hlle      : The node to destroy.
*
* Output:
*	None.
*
* Exceptions:
*
* Notes:
*	For doubly linked list, we could just use the hllePrev handle,
*  but there's no guarantee that the node is in the list specified.  So
*	We do a look up just to make sure.
*
*************************************************************************/
BOOL PASCAL
LLFDeleteHlleFromLl(
HLLI	hlli,
HLLE	hlle ) {
	HLLE	hllePrev = hlleNull;
	HLLE	hlleCur = hlleNull;
	USHORT	fRet;
	LPLLI	lplli;

	ASSERT( hlli );
	ASSERT( hlle );

	lplli = LockHlli ( hlli );
	AcquireLockPcs ( lplli->pcs );

	while( ( hlleCur = LLHlleFindNext( hlli, hlleCur ) ) && hlleCur != hlle ) {
		hllePrev = hlleCur;
	}
	if ( fRet = ( hlle == hlleCur ) ) {
		LLDeleteHlle( hlli, hllePrev, hlle );
	}

	ReleaseLockPcs ( lplli->pcs );
	UnlockHlli ( hlli );

	return fRet;
}

/*** LLDeleteHlle
*
* Purpose:
*	INTERNAL utility routine to delete a node.  Update head/tail and
*	node pointers.
*
* Input:
*	hlli      :	List containing node to delete.
*	hllePrev  :	Node immediately preceding node to be deleted in the list.
*	hlle      : The node to destroy.
*
* Output:
*	None.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL
LLDeleteHlle(
HLLI	hlli,
HLLE	hllePrev,
HLLE	hlle ) {

	LPLLI	lplli = LockHlli( hlli );
	HLLE	hlleNext = LLHlleFindNext( hlli, hlle );
//
//	If there is a previous node, update its hnext
//
	if ( hllePrev ) {
		LockHlle( hllePrev )->hlleNext = hlleNext;
		UnlockHlle( hllePrev );
	}
//
// Otherwise, update the head
//
	else {
		lplli->hlleHead = hlleNext;
	}
//
// We're adding to the end of the list, update the hlleTail
//
	if ( hlleNext == hlleNull ) {
		lplli->hlleTail = hllePrev;
	}
//
//	If there is a next, update its hPrev
//
#ifdef DBLLINK
	else {
		LockHlle( hlleNext )->hllePrev = hllePrev;
		UnlockHlle( hlleNext );
	}
#endif	// DBLLINK
//
//	Let the app free up its own mess for the data from this node
//
	if ( lplli->lpfnKill ) {
		lplli->lpfnKill( (LPV)LockHlle( hlle )->rgw );
		UnlockHlle( hlle );
	}
	FreeHlle( hlle );
//
// Decrement the number of items on the list
//
	--lplli->chlleMac;
	UnlockHlli( hlli );
}

/*** LLChlleInLl
*
* Purpose:
*	Return the number of nodes in a list
*
* Input:
*	hlli   :	List to get count for
*
* Output:
*	Number of nodes in the list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
DWORD PASCAL
LLChlleInLl(
HLLI	hlli ) {

	DWORD	lRet;
	LPLLI	lplli;

	ASSERT( hlli );

	lplli = LockHlli ( hlli );
	AcquireLockPcs ( lplli->pcs );

	lRet = lplli->chlleMac;

	ReleaseLockPcs ( lplli->pcs );
	UnlockHlli( hlli );
	return lRet;
}

/*** LLLpvFromHlle
*
* Purpose:
*	Get a FAR pointer to the user data of a node.  This locks the node
*	down.  It is the application's responsibility to unlock it!
*
* Input:
*	hlle    :	Node to get data for.
*
* Output:
*	A FAR pointer to the data.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
LPV PASCAL
LLLpvFromHlle(
HLLE	hlle ) {
	if (hlle == hlleNull) {
		return NULL;
	}
	else {
		return (LPV)( LockHlle( hlle )->rgw );
	}
}

/*** LLHlleGetLast
*
* Purpose:
*	Get the last node in the specified list.
*
* Input:
*	hlli    :	List to look up last item in.
*
* Output:
*	handle to the last item, or NULL if empty list.
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
HLLE PASCAL
LLHlleGetLast(
HLLI	hlli ) {
	HLLE	hlleRet;
	LPLLI	lplli;

	ASSERT( hlli );

	lplli = LockHlli ( hlli );

	AcquireLockPcs ( lplli->pcs );

	hlleRet = lplli->hlleTail;

	ReleaseLockPcs ( lplli->pcs );
	UnlockHlli( hlli );
	return hlleRet;
}


/*** LLHlleAddToHeadOfLI
*
* Purpose:
*	Add a new node to the head of a list.
*
* Input:
*	hlli    :	List to add node to.
*	hlle    :	Node to append to list.
*
* Output:
*
* Exceptions:
*
* Notes:
*
*************************************************************************/
void PASCAL LLHlleAddToHeadOfLI( HLLI	hlli, HLLE	hlle ) {

	LPLLE	lplle;
	LPLLI	lplli;

	ASSERT( hlli );
	ASSERT( hlle );

	lplli = LockHlli( hlli );
	AcquireLockPcs ( lplli->pcs );

	lplle = LockHlle( hlle );
	ASSERT( lplli->llf == llfNull );

	lplle->hlleNext = lplli->hlleHead;

	//	If the pHead is NULL then initialize the pTail
	//	(you know, like this is the only item in the list)
	if ( lplli->hlleHead == hlleNull ) {
		lplli->hlleTail = hlle;
	}
	lplli->hlleHead = hlle;
#ifdef DBLLINK
	lplle->hllePrev = hlleNull;
#endif	// DBLLINK

	//	Chalk up one more for the list
	lplli->chlleMac++;

	// Ensure that the list is OK
	UnlockHlle( hlle );

#if _DEBUG > 1
	LLFCheckHlli( hlli );
#endif

	ReleaseLockPcs ( lplli->pcs );

	UnlockHlli( hlli );

}

/*** LLFRemoveHlleFromLl
*
* Purpose:
*	Remove a specified hlle.	Update head/tail and node pointers.
*
* Input:
*	hlli	  :	List containing node to remove.
*	hlle	  : The node to remove.
*
* Output:
*	None.
*
* Exceptions:
*
* Notes:
*	For doubly linked list, we could just use the hllePrev handle,
*  but there's no guarantee that the node is in the list specified.  So
*	We do a look up just to make sure.
*
*************************************************************************/
BOOL PASCAL LLFRemoveHlleFromLl( HLLI hlli, HLLE hlle ) {

	HLLE	hllePrev = hlleNull;
	HLLE	hlleCur = hlleNull;
	USHORT	fRet;
	LPLLI	lplli;

	ASSERT( hlli );
	ASSERT( hlle );

	lplli = LockHlli ( hlli );

	AcquireLockPcs ( lplli->pcs );

	while( ( hlleCur = LLHlleFindNext( hlli, hlleCur ) ) && hlleCur != hlle ) {
		hllePrev = hlleCur;
	}
	if ( fRet = ( hlle == hlleCur ) ) {

		HLLE	hlleNext = LLHlleFindNext( hlli, hlle );

		//	If there is a previous node, update its hnext
		if ( hllePrev ) {
			LockHlle( hllePrev )->hlleNext = hlleNext;
			UnlockHlle( hllePrev );
		}

		// Otherwise, update the head
		else {
			lplli->hlleHead = hlleNext;
		}

		// We're adding to the end of the list, update the hlleTail
		if ( hlleNext == hlleNull ) {
			lplli->hlleTail = hllePrev;
		}

		//	If there is a next, update its hPrev
#ifdef DBLLINK
		else {
			LockHlle( hlleNext )->hllePrev = hllePrev;
			UnlockHlle( hlleNext );
		}
#endif	// DBLLINK

		// Decrement the number of items on the list
		--lplli->chlleMac;
	}

#if _DEBUG > 1
	LLFCheckHlli( hlli );
#endif

	ReleaseLockPcs ( lplli->pcs );

	UnlockHlli( hlli );

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\hash.inl ===
/*++

Copyright(c) 1997 Microsoft Corporation

Module Name:

	hash.inl

Abstract:

	Inline definitions of templated hash functions.  See hash.h for more
	information.

Author:

    Matthew D Hendel (math) 13-May-1997

--*/

#ifndef _Hash_inl_
#define _Hash_inl_

#include "primes.h"

//
// Implementation of THashedMapOf
//

template <class _KeyType, class _DataType>
THashedMapOf <_KeyType, _DataType>::THashedMapOf(
	ULONG		nInitialSize,	// = 512
	float		highWaterMark,	// = 2.0
	float		lowWaterMark	// = 0.0
	)
  : m_nArraySize (0),
	m_nElements (0),
	m_HighWaterMark (highWaterMark),
	m_LowWaterMark (lowWaterMark)
{
	m_nArraySize = FindPrimeSuccessor (nInitialSize);
	m_HashArray = new Node* [m_nArraySize];
	memset (m_HashArray, 0, m_nArraySize * sizeof (m_HashArray [0]));
	InitializeCriticalSection (&m_cs);
}


template <class _KeyType, class _DataType>
THashedMapOf <_KeyType, _DataType>::~THashedMapOf(
	)
{
	int		i;
	Node*	p = NULL;
	Node*	q = NULL;
	
	for (i = 0; i < m_nArraySize; i++) {
		p = m_HashArray [i];

		while (p) {
			q = p->GetNext ();
			delete p;
			p = q;
		}
	}
	
	delete [] m_HashArray;
	m_HashArray = NULL;
	DeleteCriticalSection (&m_cs);
}

template <class _KeyType, class _DataType>
void
THashedMapOf <_KeyType, _DataType>::Lock(
	)
{
	EnterCriticalSection (&m_cs);
}

template <class _KeyType, class _DataType>
void
THashedMapOf <_KeyType, _DataType>::UnLock(
	)
{
	LeaveCriticalSection (&m_cs);
}

template <class _KeyType, class _DataType>
BOOL
THashedMapOf <_KeyType, _DataType>::Insert(
	_KeyTypeRef	key,
	_DataType	data
	)
{
	Node*	node = NULL;
	Node*	pCur = NULL;
	Node*	pNext= NULL;
	BOOL	fSuccess = FALSE;

	Lock ();
	
	MaybeRehash ();

	node = new Node (key, data);

	fSuccess = InsertNode (m_HashArray, node, m_nArraySize);

	node = NULL;
	
	if (!fSuccess) {
		delete node;
	} else {
		m_nElements++;
	}

	UnLock ();

	return fSuccess;
}


template <class _KeyType, class _DataType>
BOOL
THashedMapOf <_KeyType, _DataType>::InsertNode(
	Node*	hashArray [],
	Node*	pNode,
	int		nArraySize
	)
{
	int		cmp;
	ULONG	n;
	Node*	pCur  = NULL;
	Node*	pPrev = NULL;
	BOOL	fSucc = FALSE;

	Lock ();
	
	n = Hash (pNode->GetKey ()) % nArraySize;

	if (hashArray [n] == NULL) {
		hashArray [n] = pNode;
		fSucc = TRUE;
	} else {
		pCur = hashArray [n];
		pPrev = NULL;
		
		while (pCur->GetNext () &&
			   Compare (pCur->GetKey (), pNode->GetKey ()) > 0) {
			   
			pPrev = pCur;
			pCur = pCur->GetNext ();
		}

		cmp = Compare (pCur->GetKey (), pNode->GetKey ());

		if (cmp == 0) {
			fSucc = FALSE;
		} else if (cmp < 0) {

			fSucc = ReferenceHook (INSERT_HOOK, pCur->GetKey (), pNode->GetData ());

			if (fSucc) {
				
				pNode->SetNext (pCur);

				if (pPrev) {
					pPrev->SetNext (pNode);
				} else {
					hashArray [n] = pNode;
				}

				fSucc = TRUE;
			}
		}
	}

	UnLock ();

	return fSucc;
}

template <class _KeyType, class _DataType>
BOOL
THashedMapOf <_KeyType, _DataType>::Find(
	IN	_KeyTypeRef	key,
	OUT	_DataType*	data
	)
{
	ULONG		n;
	Node*		pCur  = NULL;

	Lock ();
	
	n = Hash (key) % m_nArraySize;

	pCur = m_HashArray [n];

	while (pCur && Compare (pCur->GetKey (), key) > 0) {
		pCur = pCur->GetNext ();
	}

	if (pCur && Compare (pCur->GetKey (), key) != 0) {
		pCur = NULL;
	}
	
	if (pCur) {

		if (ReferenceHook (FIND_HOOK, key, pCur->GetData ())) {
			*data = pCur->GetData ();
		} else {
			pCur = NULL;
		}
	}

	UnLock ();
	
	return pCur ? TRUE : FALSE;
}


template <class _KeyType, class _DataType>
BOOL
THashedMapOf <_KeyType, _DataType>::Remove(
	IN	_KeyTypeRef	key,
	OUT	_DataType*	data	OPTIONAL
	)
{
	int			cmp;
	ULONG		n;
	BOOL		fSucc = FALSE;
	Node*		pCur = NULL;
	Node*		pPrev= NULL;

	Lock ();

	n = Hash (key) % m_nArraySize;

	if (m_HashArray [n]) {
		pCur = m_HashArray [n];
		pPrev = NULL;
		
		while (pCur->GetNext () && Compare (pCur->GetKey (), key) > 0)	{
			pPrev = pCur;
			pCur = pCur->GetNext ();
		}

		cmp = Compare (pCur->GetKey (), key);

		if (cmp == 0) {

			if (ReferenceHook (REMOVE_HOOK, pCur->GetKey (), pCur->GetData ())) {

				if (pPrev == NULL) {
					m_HashArray [n] = m_HashArray [n]->GetNext ();
				} else {
					pPrev->SetNext (pCur->GetNext ());
				}
			}
		}
	}

	if (pCur) {
		fSucc = TRUE;
		if (data) {
			*data = pCur->GetData ();
		}
		delete pCur;
		pCur = NULL;
		m_nElements--;
	} else {
		fSucc = FALSE;
	}

	MaybeRehash ();
	UnLock ();
	
	return fSucc;
}

	

template <class _KeyType, class _DataType>
void
THashedMapOf <_KeyType, _DataType>::MaybeRehash(
	)
{
	Node**	hashArray = NULL;
	Node*	pNode = NULL;
	Node*	pNext = NULL;
	
	int		newArraySize;
	float	factor;
	int		i;

	Lock ();
	
	factor = ((float) m_nElements) / ((float) m_nArraySize);
	
	if ( factor > m_HighWaterMark || factor < m_LowWaterMark ) {	
		newArraySize = FindPrimeSuccessor (m_nElements);
	} else {
		newArraySize = m_nArraySize;
	}

	if (newArraySize != m_nArraySize) {

		hashArray = new Node* [newArraySize];
		memset (hashArray, 0, newArraySize * sizeof (hashArray [0]));

		for (i = 0; i < m_nArraySize; i++) {
			pNode = m_HashArray [i];

			while (pNode) {
				pNext = pNode->GetNext ();
				pNode->SetNext (NULL);
				Verify (InsertNode (hashArray, pNode, newArraySize));
				pNode = pNext;
			}
		}

		delete [] m_HashArray;
		m_HashArray = hashArray;
		hashArray = NULL;
		m_nArraySize = newArraySize;
	}

	UnLock ();
}


template <class _Type>
int
Bsearch(
	_Type	array [],
	int		nElements,
	_Type	n
	)
{
	BOOL	fDone = FALSE;
	int		low;
	int		high;
	int		i;

	//
	// return -1 for out of bounds
	//
	
	if (n < array [0] || n > array [nElements - 1]) {
		return -1;
	}
	
	low = 0;
	high = nElements;

	do {

		i = (high + low) / 2;

		if (i + 1 < nElements && array [i] < n && array [i + 1] > n) {
			fDone = TRUE;
		} else if (array [i] < n) {
			low = i;
		} else if (array [i] > n) {
			high = i;
		} else if (array [i] == n) {
			fDone = TRUE;
		}

	} while (!fDone);

	return i;
}


template <class _KeyType, class _DataType>
ULONG
THashedMapOf <_KeyType, _DataType>::FindPrimeSuccessor(
	ULONG	n
	)
/*++

Routine Description:

	This routine returns a prime number following the number n.  The return
	value is guarenteed not to exceed 2 * n.

--*/
{
	int		i;
	int		nEle = nPrimes;
	ULONG	q = 0;
	

	if (n < Primes [0]) {
		q = Primes [0];
	} else if (n > Primes [nEle - 1]) {
		q = Primes [nEle - 1];
	} else {
		i = Bsearch (Primes, nEle, n);
		q = Primes [i + 1];
	}

	return q;
}



//
// THashIterator template
//

template <class _KeyType, class _DataType>
THashIterator <_KeyType, _DataType>::THashIterator(
	Map*	map
	)
  : m_map (map)
{
	Create ();
}

template <class _KeyType, class _DataType>
THashIterator <_KeyType, _DataType>::THashIterator(
	Map&	map
	)
  : m_map (&map)
{
	Create ();
}


template <class _KeyType, class _DataType>
void
THashIterator <_KeyType, _DataType>::Create(
	)
{
	Assert (m_map);
//		Verify (m_map->IteratorLock ());
	ResetToHead ();
}
	


template <class _KeyType, class _DataType>
BOOL
THashIterator <_KeyType, _DataType>::MoveNext(
	)
{
	BOOL	ret;
	
	m_map->Lock ();
	
	if (m_pNode) {

		m_pNode = m_pNode->GetNext ();

	}

	if (!m_pNode) {

		m_bucket++;
		
		while ( m_map->m_HashArray [m_bucket] == NULL &&
				m_bucket < m_map->m_nArraySize) {

			m_bucket++;
		}

		//
		// No more entries.
		//
		
		if (m_bucket == m_map->m_nArraySize) {
			ret = FALSE;
		} else {
			m_pNode = m_map->m_HashArray [m_bucket];
			ret = TRUE;
		}
	}

	if (m_pNode) {
		ret = TRUE;
	}
	
	m_map->UnLock ();
	return ret;
}


template <class _KeyType, class _DataType>
BOOL
THashIterator <_KeyType, _DataType>::GetValue(
	OUT _DataType*	data
	)
{
	BOOL	ret;
	
	m_map->Lock ();

	if (m_pNode) {
		*data = m_pNode->GetData ();
		ret = TRUE;
	} else {
		ret = FALSE;
	}

	return ret;
}


template <class _KeyType, class _DataType>
BOOL
THashIterator <_KeyType, _DataType>::ResetToHead(
	)
{
	m_bucket = -1;	// this is kindof weird, but correct.
	m_pNode = NULL;
	return MoveNext ();
}


#if 0
#include <windows.h>
#include <stdio.h>

void
THashedMapOf::Dump(
	)
{
	THashNode*	p = NULL;
	int			i = 0;
	char		buffer [512];

	__try {
	
		OutputDebugString ("<< Dump of hash table >>\n\n");
		for (i = 0; i < m_nArraySize; i++) {
			p = m_HashArray [i];

			
			sprintf (buffer, "bucket %d\n", i);
			OutputDebugString (buffer);
			while (p) {
				sprintf (buffer, "  p %#x key %d data %#x\n",
						p,
						p->GetKey (),
						p->GetData ()
						);

				OutputDebugString (buffer);
				p = p->GetNext ();
			}
		}
	}

	__except (1) {
		sprintf (buffer, "exception dumping bucket %d, p = %#x\n", i, p);
		OutputDebugString (buffer);
	}
		
		
}

#endif


		
#endif // _Hash_inl_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\hash.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

	hash.h
	
Abstract:

	This is a self-adjusting hash table package.  It provides the following
	interfaces and templates.

	  o interface IMappingOf <_KeyType, _DataType>.

		This is an interface that describes any type of mapping which
		supports Insert, Find and Remove operators (like the hash table).

	  o template THashedMapOf <_KeyType, _DataType>

		This template maps an object of type KeyType into an object of type
		DataType.  The following things should be considered when using this
		type: the key is constructed in the node data structure internal to
		the hash node.  Because of this, the key should not be too heavy
		weight of an object.  The key object must support the operations:
		copy constructor and destructor.  Type DataType object must support
		copy constructor, destructor and assignment operator.  In general it
		may be advisable limit both Key and Data to fairly simple types that
		trivially implement the above operators (simple C data types plus
		pointers of all kinds are good), or to objects where the user knows
		the cost of constructing, destructing and copying the object and that
		cost is low -- a refcounted string class like MFCs CString class is
		a good example.


Author:

	Matthew D Hendel (math) 13-May-1997


Example Usage:

	ULONG
	THashedMapOf<PID, CProcess*>::Hash(
		const PID&	pid
		)
	{
		return (ULONG) pid;
	}

	int
	THashedMapOf<PID, CProcess*>::Compare(
		const PID&	pid1,
		const PID&	pid2
		)
	{
		return  ((int) pid1) - ((int) pid2) ;
	}
		


	THashedMapOf<PID, CProcess*>	ProcessTable;

	CProcess*	proc;

	proc = new CProcess;
	ProcessTable.Insert (pid, proc);

	ProcessTable.Find (pid, &proc);
	ProcessTable.Remove (pid, &proc);

--*/


#ifndef _Hash_h_
#define _Hash_h_

//#include "defs.h"

#ifndef Verify
#define Verify VERIFY
#endif

#ifndef Assert
#define Assert ASSERT
#endif


template <class _KeyType, class _DataType> class THashedMapOf;
template <class _KeyType, class _DataType> class THashNode;
template <class _KeyType, class _DataType> class THashIterator;

template <class _KeyType, class _DataType>
interface IMappingOf
{
	typedef const _KeyType& _KeyTypeRef;
	
	virtual BOOL
	Insert(
		IN	_KeyTypeRef		key,
		IN	_DataType		data
		) = 0;

	virtual BOOL
	Remove(
		IN	_KeyTypeRef		key,
		OUT _DataType*		data    OPTIONAL
		) = 0;

	virtual BOOL
	Find(
		IN	_KeyTypeRef		key,
		OUT	_DataType*		data
		) = 0;
};


//
// This is a private type of the THashMapping.  But due to the use of
// templates it needs to be declared here in the global namespace.
//

template <class _KeyType, class _DataType>
class THashNode
{
  private: // types

	typedef const _KeyType&	_KeyTypeRef;
	typedef const _DataType& _DataTypeRef;
	
  private:
  
	_KeyType	m_key;
	_DataType	m_data;
	THashNode*	m_next;

  public:

	THashNode(
		_KeyTypeRef		key,
		_DataTypeRef	data
		)
	  : m_key (key),
	    m_data (data),
		m_next (NULL)
	{
	}
		
	_DataTypeRef
	GetData(
		)
	{
		return m_data;
	}

	_KeyTypeRef
	GetKey(
		)
	{
		return m_key;
	}

	THashNode*
	GetNext(
		)
	{
		return m_next;
	}
	
	THashNode*
	SetNext(
		THashNode*	node
		)
	{
		THashNode*	t = m_next;
		m_next = node;
		return t;
	}
};


  

template <class _KeyType, class _DataType>
class THashedMapOf : public IMappingOf <_KeyType, _DataType>
{
	friend THashIterator <_KeyType, _DataType>;

  private:  // local types

	typedef THashNode <_KeyType, _DataType>	Node;
	
  private:  // local data
  
	int			m_nArraySize;
	int			m_nElements;
	Node**		m_HashArray;
	float		m_HighWaterMark;
	float		m_LowWaterMark;

	CRITICAL_SECTION	m_cs;

  public: // types
  
	enum  REFERENCE_TYPE
	{
		INSERT_HOOK,		// just before an element is added to the list
		REMOVE_HOOK,		// just before an element is removed from the list
		FIND_HOOK			// just before a found object is returned from
	};						// a find operation
	
  public:  // construction & destruction

	THashedMapOf(
		ULONG		nInitialSize = 512,
		float		highWaterMark = 2.0, 
		float		lowWaterMark = 0.0
		);

	~THashedMapOf(
		);


  public:  // public interface	

	BOOL
	Insert(
		IN _KeyTypeRef	key,
		IN _DataType	data
		);

	BOOL
	Remove(
		IN	_KeyTypeRef		key,
		OUT _DataType*		data		OPTIONAL
		);

	BOOL
	Find(
		IN	_KeyTypeRef		key,
		OUT _DataType*		data
		);

	void
	Lock(
		);

	void
	UnLock(
		);

	ULONG
	GetCount(
		)
	{
		return m_nElements;
	}

  public:

	virtual ULONG
	Hash(
		_KeyTypeRef	key
		);

	virtual int
	Compare(
		_KeyTypeRef	key1,
		_KeyTypeRef	key2
		);

	virtual BOOL
	ReferenceHook(
		REFERENCE_TYPE		rtype,
		_KeyTypeRef			key,
		_DataType			data
		)
	{
		return TRUE;
	}

  public: // debugging functions
		
	void
	Dump(
		);
		

  private:	// local methods


	void
	MaybeRehash(
		);

	BOOL
	InsertNode(
		Node*	hashArray [],
		Node*	pNode,
		int		nArraySize
		);

	ULONG
	FindPrimeSuccessor(
		ULONG	n
		);
	
};


//
// Allow you to iterate through the Hash table.  Problems: the hash-table
// iterator does not support multiple iterators on the table at one time
// (you will crash and burn); also, the iteration of the hash table is slow
// and should considered only for functions where speed is not of the
// essence.
//

template <class _KeyType, class _DataType>
class THashIterator
{

  private: // types

  typedef THashedMapOf <_KeyType, _DataType> Map;
  typedef THashNode <_KeyType, _DataType>	Node;

	Map*	m_map;
	Node*	m_pNode;
	int		m_bucket;

  public: // public construction + destruction

	THashIterator(
		Map*	map
		);

	THashIterator(
		Map&	map
		);

	void
	Create(
		);
		
  public: // operators

	BOOL
	MoveNext(
		);

	BOOL
	GetValue(
		OUT _DataType*	data
		);

	BOOL
	ResetToHead(
		);
};


ULONG
HashPjw(
	LPCSTR	sz
	);


#include "hash.inl"

#endif // _Hash_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\makefile.inc ===
!include $(IDE_ROOT)\makefile.inc

dbg.cpp: $(PACKVERCHECK)

#--------------------------------------------------------------------
#
#  RESOURCE INCLUDE DEPENDENCIES
#
#--------------------------------------------------------------------
#RC_INC_DEP = \
#	$(INC_DIR)\dlgs.h        \
#	$(INC_DIR)\msvc.ver      \
#	$(LANGAPI_ROOT)\include\verstamp.h

#--------------------------------------------------------------------
#
#  RESOURCE DIALOG DEPENDENCIES
#
#--------------------------------------------------------------------
RC_DLG_DEP =
#--------------------------------------------------------------------
#
#  RESOURCE BITMAP DEPENDENCIES
#
#--------------------------------------------------------------------
#BITMAPS_DEP = \
#	$(ICO_DIR)\maintool.bmp \
#	$(ICO_DIR)\wizbar.bmp

#--------------------------------------------------------------------
#
#  RESOURCE ICON DEPENDENCIES
#
#--------------------------------------------------------------------

#ICONS_DEP = \
#    $(ICO_DIR)\source.ico \
#    $(ICO_DIR)\header.ico \
#    $(ICO_DIR)\browse.ico \
#    $(ICO_DIR)\qcerror.ico


$O\$(RCFILE).res: $(RCFILE).rc $O\$(CMDFILE).rcs $(O)\devdbg.tlb \
                           $(RC_DLG_DEP) $(RC_INC_DEP) $(ICONS_DEP) $(BITMAPS_DEP)

#qcqp.h : inc\qcqp.h
#    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\makeeng.cpp ===
/*********************************************************************

    File:               makeeng.c

    Date created:       27/8/90

    Author:             Tim Bell

    Description:

    Windows Make Engine API

    Modified:

*********************************************************************/

// Ported to QCQP 10/2/91

#include "stdafx.h"
#pragma hdrstop

#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <dos.h>
#include <io.h>
#include <errno.h>
#include <process.h>

#include "sqlprxky.h"
#include "sqlguid.h"
#include "sqlpkapi.h"
#include "autodbg.h"
#include "dbgenc.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// g_PidExecList is a list of pointers to PROCINFO structs for all
// processes which have been started with Project.Execute and
// are still running.  Here's why we keep this info:
//
// Say someone starts their program with Project.Execute, and then the
// app GP faults.  NT will start up a second copy of MSVC as an
// active-process debugger (assuming we've been registered as such).
// The second copy will see that there's already a running copy of MSVC,
// and will ask us if we spawned this PID.  We use g_PidExecList to
// check whether we spawned it.  If so, the new copy of MSVC is going
// to tell us to debug this app.
struct PROCINFO
{
    DWORD   pid;
    CPath   path;
};
CPtrList g_PidExecList;     // list of PROCESS_INFORMATION ptrs

// Return type for MkEngStartDebuggee
typedef enum
{
    SC_ATMAINORDEAD,    // debuggee is at entry point or has died
    SC_FAILED,          // attempt to start debuggee failed
    SC_GONE,            // debuggee running, couldn't find entry point
    SC_BPFAILED,        // attempt to set a breakpoint failed
    SC_STOPPED,         // debuggee stopped, e.g. BP or GPF before main()
} STARTCODE;

/* lifted from cmd.h / cmd.c */
/* Array of legitimate extensions for entries added to program list.
*/
#define CSZPLEXT_TOTAL    7
#define CSZPLEXT_OLDALLOWED 9
#define CSZPLEXT_SRC      6     // NUMBER of source files
#define CSZPLEXT_INC      6     // array POSITION of first include type file
#define CSZPLEXT_INC_MAX  6     // array POSITION of last include type file

static BOOL fForceEdit;     // A new list was specified in Set Program List
static BOOL fListWasNew;    // tested on Cancel from Edit Program List

BOOL fUpdateRemoteTarget;   // Indicates that we need to update the remote
                // target before debugging
#ifdef _DEBUG
BOOL g_bDebugTime = TRUE;   // report debug start times to the output window.
#else
BOOL g_bDebugTime = FALSE;
#endif

//
// Prototypes required for alloc_text pragma
//
void PASCAL ExecuteTarget(void);
STARTCODE PASCAL MkEngStartDebuggee(void);

// Java: prototypes for additional Java debugging support
BOOL GetJavaDebugInfo(BOOL bExecute = FALSE);

ULONG
GetWindowType(
	CView*	view
	)
/*++

Routine Description:

	Returns the type of the window.

--*/
{
	ULONG	WindowType = UNKNOWN_WIN;

	if (view)
	{
		if (view->IsKindOf (RUNTIME_CLASS (CMultiEdit)))
		{
			CMultiEdit* medit = (CMultiEdit*) view;

			WindowType = medit->m_dt;
		}
		else if (gpISrc && gpISrc->ViewBelongsToSrc (view))
		{
			WindowType = DOC_WIN;
		}
	}

	return WindowType;
}
		
	

ULONG
GetStepMode(
	)
/*++

Routine Description:

	The stepping mode is detirmined by the highest MDI window on the Z order
	that is either a source window or a disassembly window.  If the window
	is a disassembly window, then we are in disassembly mode, if the window
	is a source window, then we are in source mode, if there is no highest
	winow, we are in source mode.

Return Value:

	SRCSTEPPING for source mode; ASMSTEPPING for assembly mode.

--*/	
{

	CWnd*	mainFrm = theApp.m_pMainWnd;
	CWnd*	Wnd;

	ASSERT (theApp.m_pMainWnd->IsKindOf (RUNTIME_CLASS (CMDIFrameWnd)));
	
	CMDIFrameWnd*	mainFrame = (CMDIFrameWnd*)theApp.m_pMainWnd;
	CMDIChildWnd*	Frame = NULL;
	ULONG			WindowType;
	CView*			View;
	HWND			hWndForeground;

	View = GetCurView ();

	if (View)
	{
		WindowType = GetWindowType (View);

		switch (WindowType)
		{
			case DISASSY_WIN:
				return ASMSTEPPING;

			case DOC_WIN:
				return SRCSTEPPING;
		}
	}


	//
	//	The current view wasn't a source or debugger window
	//	look for the top view on the MDI list
	//
	
	for (Wnd = mainFrame->MDIGetActive ();
		 Wnd ;
		 Wnd = Wnd->GetWindow (GW_HWNDNEXT)
		 )
	{
		ULONG	WindowType; 

		if (Wnd->IsKindOf (RUNTIME_CLASS (CMDIChildWnd)))
			Frame = (CMDIChildWnd*) Wnd;

		if (!Frame)
			continue;

		View = Frame->GetActiveView ();
			
		WindowType = GetWindowType (View);
		
		switch (WindowType)
		{
			case DISASSY_WIN:
				return ASMSTEPPING;


			case DOC_WIN:
				return SRCSTEPPING;

		}

	}

	//
	//	If we've run through all the windows and none are either a source
	//	window or a disassembly window, then default to source mode stepping.
	//
		
	return SRCSTEPPING;
}

	
/*********************************************************************

    Function:           MkEngSetMakeDriveDir

    Description:

    Changes to the "Make" drive and directory.  This is either the
    directory where the make file is stored if one exists, otherwise
    it is the directory where the single-source file is stored
    (in the case of a Compile/Build/Rebuild command).

*********************************************************************/
BOOL PASCAL MkEngSetMakeDriveDir(void)
{
    char    szTargetDir[_MAX_DIR];
    CDir    ProjDir;
    INT     iType;

    if ( !gpIBldSys )
        return( FALSE );

    HBUILDER hBld;

    gpIBldSys->GetActiveBuilder(&hBld);

    if (hBld != NO_BUILDER && (gpIBldSys->GetBuilderType(ACTIVE_BUILDER, &iType) != ExeBuilder) )
    {
        LPCSTR pszPath;

        gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath);

        if ( ProjDir.CreateFromPath(pszPath) )
            _tcscpy(szTargetDir, (char *)(const char *)ProjDir);
        else
            return FALSE;
    }
    else
        return FALSE;

    return FsSetCurDir(szTargetDir);
}

/*********************************************************************

    Function:   DocInProject

    Description:

*********************************************************************/

BOOL PASCAL DocInProject(LPCTSTR docFileName)
{
    CPath path;

    if (!path.Create(docFileName))
        return(FALSE);

    if ( !gpIBldSys && gpIBldSys->IsActiveBuilderValid() != S_OK )
    {
        // if no project open the file can't be a member
        return(FALSE);
    }
    if ( gpIBldSys->IsProjectFile(&path, FALSE, ACTIVE_BUILDER) == S_OK )
        return(TRUE);

    return(FALSE);
}


/*********************************************************************

    Function:       FParentOfProcess

    Description:    Returns TRUE if we're the parent of the specified
                    process, FALSE if not.  This is used for
                    just-in-time debugging: if the user did Ctrl-F5
                    (Project.Execute), and then the app faults, then
                    the new copy of MSVC spawned by the system will
                    ask us if we are that process's parent.  If we
                    are, then it will let us be the process's debugger
                    rather than the new MSVC being the debugger.

*********************************************************************/

BOOL FParentOfProcess(DWORD pid, const char **pszPath)
// If pszPath is not NULL, it will be pointed to the process's path
{
    POSITION    p = g_PidExecList.GetHeadPosition();
    PROCINFO *  pprocinfo;

    while (p)
    {
        pprocinfo = (PROCINFO *) g_PidExecList.GetNext(p);

        if (pprocinfo->pid == pid)
        {
            if (pszPath)
                *pszPath = pprocinfo->path;
            return TRUE;
        }
    }

    return FALSE;
}

/*********************************************************************

    Function:       ClearPidExecList

    Description:    Clears the list of PIDs for which this instance
                    of the IDE will be the debugger.

*********************************************************************/

void ClearPidExecList(void)
{
    POSITION    p = g_PidExecList.GetHeadPosition();
    PROCINFO *  pprocinfo;

    while (p)
    {
        pprocinfo = (PROCINFO *) g_PidExecList.GetNext(p);
        delete pprocinfo;
    }

    g_PidExecList.RemoveAll();
}

/*********************************************************************

    Function:   Executes the target

    Description:

*********************************************************************/

void PASCAL ExecuteTarget(void)
{
    char szLocalExe[_MAX_PATH];
    CString strCmdLine;
    BOOL bRetry ;

    // no project that generates a target
    if ( gpIBldSys->IsActiveBuilderValid() != S_OK )
    {
        MessageBeep(0);
        return;
    }

	// Java: make sure the class file name and app type are specified
	// by the user; if not, get the from the user
	if (pDebugCurr && pDebugCurr->IsJava())
	{
		CString strLocalExe;

		// get the class file name, app type, and HTML viewer
		if (!GetJavaDebugInfo(TRUE))
			return;
		// fill in szLocalExe with the class name
		CString strClassName;
		gpIBldSys->GetJavaClassName(ACTIVE_BUILDER, strClassName);
		_tcscpy(szLocalExe, strClassName);
	}
	else
	{
		bRetry = TRUE;

		// Get the PROGRAM name (Caller for a DLL or EXE on program)
		while ((GetExecutableFilename(szLocalExe, sizeof(szLocalExe)) == exefromNone) && bRetry)
		{
			// We didn't find a 'Caller Executable' to use
			// In this case prompt for a new name
			bRetry = (gpIBldSys->GetInitialExeForDebug(ACTIVE_BUILDER, TRUE) == S_OK);
			if(!bRetry)
				// No Retry, abort out of here
				return;
		}
		// Try to get the Executable file name again
		if (GetExecutableFilename(szLocalExe, sizeof(szLocalExe)) == exefromNone)
			return;
	}

    PID                 pid;
    PROCINFO *          pprocinfo;
    BOOL                fOk;
    CString             strRemoteExe;
    CString             strRemoteDir;

    // get remote exe name
    // FUTURE: add code here similar to the code above which
    // prompts user to enter remote exe name
    if (pDebugCurr && pDebugCurr->MtrcRemoteTL())
    {
        gpIBldSys->GetRemoteTargetFileName(ACTIVE_BUILDER, strRemoteExe);

        if (strRemoteExe.IsEmpty())
        {
            if ( gpIBldSys->GetInitialRemoteTarget(ACTIVE_BUILDER, FALSE, FALSE) == S_OK )
                gpIBldSys->GetRemoteTargetFileName(ACTIVE_BUILDER, strRemoteExe);
            else
                return;
        }
    }
    else
    {
        strRemoteExe = szLocalExe;
    }

	// get the initial remote directory
	gpIBldSys->GetWorkingDirectory(ACTIVE_BUILDER, strRemoteDir);

	// If no working dir specified, and project is local, use project dir
	if (strRemoteDir.IsEmpty() && !pDebugCurr->MtrcRemoteTL())
	{
		CDir dir;
		LPCSTR pszPath;

		gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath);
		dir.CreateFromPath(pszPath);
		strRemoteDir = dir;
	}

	// Java: we'll pass slightly different parameters to OSDSpawnOrphan for Java
	if (pDebugCurr && pDebugCurr->IsJava())
	{
		// set strRemoteExe to the interpreter
		// set strCmdLine to the command line for the interpreter
		// set strRemoteDir to the class name if not OSDEBUG4 (for FSpawnOrphan)

		// are we executing this Java program using a browser or a stand-alone interpreter?
		ULONG nDebugUsing;
		gpIBldSys->GetJavaDebugUsing(ACTIVE_BUILDER, &nDebugUsing);
		if (nDebugUsing == Java_DebugUsing_Browser)
		{
			GetJavaBrowser(strRemoteExe, strCmdLine);
		}
		else if (nDebugUsing == Java_DebugUsing_Standalone)
		{
			GetJavaStandalone(strRemoteExe, strCmdLine);
		}
		else
		{
			// only Java applets and applications are supported
			ASSERT(FALSE);
		}


		// get the exe to launch, its args, and the class name
		CString strExe;
		CString strExeArgs;

		CDir dirWorking;
		{
			CString strWorkingDir;

			gpIBldSys->GetWorkingDirectory (ACTIVE_BUILDER, strWorkingDir);
			// If no working dir specified, and project is local, use project dir
			if (strWorkingDir.IsEmpty () && !pDebugCurr->MtrcRemoteTL ())
			{
				LPCSTR pszPath;
				gpIBldSys->GetBuilderFile(ACTIVE_BUILDER, &pszPath);
				dirWorking.CreateFromPath(pszPath);
			}
			else
			{
				dirWorking.CreateFromString (strWorkingDir);
			}
		}

		CPath pathClass;
		{
			CString strClassName;
			// get the class name
			gpIBldSys->GetJavaClassName(ACTIVE_BUILDER, strClassName);

			pathClass.CreateFromDirAndFilename (dirWorking, strClassName);
			strRemoteDir = pathClass;
		}

		// set the CLASSPATH environment variable in the current environment,
		// so that the browser/interpreter launched will inherit the correct CLASSPATH
		CString strClassPath;
		gpIBldSys->GetJavaClassPath(ACTIVE_BUILDER, strClassPath);
		SetEnvironmentVariable(_T("CLASSPATH"), strClassPath);

	}
	else
	{
		// get the program arguments
		GetDebuggeeCommandLine(strCmdLine);
		// if we have args to pass, prepend a space to separate from exe name.
		if(strCmdLine.GetLength())
			strCmdLine = " " + strCmdLine;

	}

	TCHAR *strWrkDir;
	if(!_tcslen(strRemoteDir)){
		strWrkDir = NULL;
	} else {
		strWrkDir = LPSTR(LPCSTR(strRemoteDir));
	}
	// NOTE, hpidCurr may be NULL now, but that's okay
	fOk = FSpawnOrphan(hpidCurr, strRemoteExe, strCmdLine, strWrkDir, &pid);

    if (fOk && !(pDebugCurr && pDebugCurr->MtrcRemoteTL()))
    {
        pprocinfo = new PROCINFO;
        // Create CPath for filename
        VERIFY(pprocinfo->path.Create(strRemoteExe));
        pprocinfo->pid = pid;

        // Add this PROCINFO to the list
        g_PidExecList.AddTail(pprocinfo);
    }
}


STARTCODE PASCAL
MkEngStartDebuggee(
	)
{
    int         iRet ;
    char        szLocalExe[_MAX_PATH];
    CString     strRemoteExe;
	CString     strDebuggeeArgs;	
    EXT         exeType;
    STARTCODE   sc;
    EXEFROM     exefrom;
	BOOL		fSucc;
	BOOL		fCrashDump = FALSE;
	BOOL		fDebugActive = FALSE;
	IMAGE_INFO	ImageInfo = {0};

	ImageInfo.Size = sizeof (ImageInfo);

	exefrom = GetExecutableFilename (szLocalExe, sizeof(szLocalExe));

	if (GetImageInfo (szLocalExe, &ImageInfo) &&
		ImageInfo.ImageType == IMAGE_TYPE_CRASHDUMP) {

		fCrashDump = TRUE;
	}

	if (theApp.m_jit.GetActive () && theApp.m_jit.GetEvent ()  == NULL) {
		fDebugActive = TRUE;
	}

	SetCrashDumpDebugging (fCrashDump);
		

	if (exefrom == exefromNone)	{

		//
		// Bring up an appropriate error saying that the caller for
		// the dynamic link library should be set.
		//

		if (gpIBldSys) {
		
			if ( (gpIBldSys->IsActiveBuilderValid() != S_OK) ||
				(gpIBldSys->GetInitialExeForDebug(ACTIVE_BUILDER, FALSE) != S_OK) ) {
				
				return SC_FAILED;
			}

			exefrom = GetExecutableFilename (szLocalExe, sizeof(szLocalExe));

			if (exefrom == exefromNone) {
				return SC_FAILED;
			}

		} else {
			ASSERT (FALSE);
			return SC_FAILED;
		}
	}
	

    if (gpIBldSys && (gpIBldSys->IsActiveBuilderValid() == S_OK) &&
		pDebugCurr && pDebugCurr->MtrcRemoteTL()) {
		
        gpIBldSys->GetRemoteTargetFileName(ACTIVE_BUILDER, strRemoteExe);

        if (strRemoteExe.IsEmpty()) {

			HRESULT hr;
			
            hr = gpIBldSys->GetInitialRemoteTarget (ACTIVE_BUILDER,
													FALSE,
													FALSE);
			if (hr == S_OK) {
			
                gpIBldSys->GetRemoteTargetFileName (ACTIVE_BUILDER,
													strRemoteExe
													);
			} else {
                return SC_FAILED;
			}
        }
	} else {
        strRemoteExe = szLocalExe;
    }

    GetDebuggeeCommandLine (strDebuggeeArgs);
	
	if (strDebuggeeArgs.GetLength ()) {
		strDebuggeeArgs = " " + strDebuggeeArgs;
	}

    _tcscpy(ExecutablePath, szLocalExe);

	//
    // Save the name of the current target for later use
	//

	if (GetDebugTarget (szPath, sizeof(szPath))) {
        SetDebugTarget (szPath);
	}

	
    fSucc = RestartDebuggee (szLocalExe,
							 (LPTSTR) (const char *) strRemoteExe,
							 (LPTSTR)(const char *)strDebuggeeArgs,
							 fCrashDump
							 );

	if (!fSucc) {
		return SC_FAILED;
	}

    TraceInfo.pDoc = NULL;

	//
	// If this is a crashdump do not step
	//

	if (fCrashDump) {
		return SC_STOPPED;
	}

	//
	// HACKHACK: this should probablly be SC_RUNNING, but the caller of
	// MkEngStartDebuggee () doesn't expect that, so this will due.
	// The point is, do not step here.
	
	if (fDebugActive) {
		return SC_ATMAINORDEAD;
	}

	iRet = Step (TRUE, stoQueryStep);

    switch(iRet)
    {
        case STEPN_NOENTRY :
            sc = SC_GONE ;
            break;

        case STEPN_BPFAILED:
            sc = SC_BPFAILED;
            break;

        case STEPN_BREAK:
            sc = SC_STOPPED ; // [cuda#2761 3/20/93 mikemo]
            break;
        
        case STEPN_FAILED:
            sc = SC_FAILED;
            break;

        case STEPN_NOERROR:
        default:
            sc = SC_ATMAINORDEAD;
            break ;
    }

    return( sc );
}



void PASCAL
MkEngStartSqlInProcDebuggee(
	)
/*++

Routine Description:

	Fire up sqlproxy for debugging.

--*/
{

	ASSERT(!DebuggeeAlive());

	ASSERT(pDebugCurr != NULL);

	// This effectively loads the debuggee
	char		szLocalExe[_MAX_PATH];
	char		szPath[_MAX_PATH];
	CString		strRemoteExe;
	EXT			exeType;

	// check the registry is OK for SQL debugging else all sorts of strange
	// things will happen
	{
		const TCHAR *szTL, *szEM, *szSH, *szEE;

		if (
			(!pDebugCurr->GetComponents( "NMSQL", &szTL, &szEM, &szSH, &szEE)) ||
			_tcsicmp(szEM, "EM") ||
			_tcsicmp(szSH, "SHSQL" ) ||
			_tcsicmp(szEE, "EESWT" )
		   )
		{
			ErrorBox( IDS_ERR_BADREGISTRY, NULL );
			return;
		}

		if (_tcsicmp(szTL, "TLLOC"))
		{
			ErrorBox( IDS_ERR_SQLNOTLOCAL, NULL );
			return;
		}
	}

	// get file name of sqlproxy.exe - should reside as same as this exe
	DWORD cbPath;
	if (!(cbPath = GetModuleFileName(NULL, szPath, _MAX_PATH)) ||
		(cbPath > MAX_PATH))
		// something bad happened 
	{
		ErrorBox(ERR_Exe_Open, szLocalExe);
		return;
	}

	char rgchDrive[_MAX_CVDRIVE];
	char rgchDir[_MAX_CVDIR];
	SplitPath(szPath, rgchDrive, rgchDir, NULL, NULL);
	_tcscpy(szLocalExe, rgchDrive);
	_tcsncat(szLocalExe, rgchDir, _MAX_PATH);
	_tcscat(szLocalExe, szSqlProxyBase ".EXE" );

	strRemoteExe = szLocalExe;

	
	exeType = GetExeType(szLocalExe, NULL);

	IMAGE_INFO	ImageInfo = {0};
	
	ImageInfo.Size = sizeof (ImageInfo);
	
	if (!GetImageInfo (szLocalExe, &ImageInfo) ||
		ImageInfo.ImageType != IMAGE_TYPE_WIN32) {

		ErrorBox(ERR_Exe_Open, szLocalExe);
		return;
	}

	// Ensure we start in the project directory - if we don't
	// do a make before running we could be anywhere.  (Also
	// need this for the potential ProjectDiskTimestamp() call)

	MkEngSetMakeDriveDir();



	//
	//	Debugging is taking place for the first
	//	time. Debuggee was not alive. We call
	//	StartDebuggee for loading the debuggee
	//	and check what is returned.
	//

	DWORD dwStartTime;

	dwStartTime = ::GetTickCount();

	// Set the title bar to running
//	SetDebuggeeRunning(TRUE);

	// First debugging command, erase the output window
	// Erase any previous Hits & switch to the virtual build window
	//
	OutputWindowVwinClear(OwinGetDebugCommandID());

	fUpdateRemoteTarget = FALSE;
	_ftcscpy(ExecutablePath, szLocalExe);

	// Note that RestartDebuggee disables the appropriate
	// ribbon controls.  Dll symbol loading + bp application
	// is processed in LoadDebuggee.

	// Build proxy command-line, of a key and a dynamic event name
	char rgchDebugArgs[256];
	strcpy( rgchDebugArgs, " " SZSQLPROXYKEY " ");
	char *p = rgchDebugArgs + strlen(rgchDebugArgs);
	BuildProxyEventName( p );

	if (!RestartDebuggee(szLocalExe, (LPTSTR) (const char *) strRemoteExe,
		rgchDebugArgs, FALSE))
	{
		ErrorBox(ERR_Exe_Open, szLocalExe);
		return;
	}

	TraceInfo.pDoc = NULL;

	// Now step to WinMain

	// [CAVIAR #6390 01/04/93 v-natjm]
	int iRet = Step (TRUE, stoQueryStep);
	g_retVals.CleanUp ();

	// Set our debuggee flag to running before
	// setting the ribbon button controls
//	SetDebuggeeRunning(TRUE);

	// Handle the title bar mode state to reflect
	// the actual debuggee status.
	SetModeName(TBR_Mode_Run) ;

	// [CAVIAR #5848 12/01/92 v-natjm]
	// Clear any bp message from status bar
//	StatusText(SYS_StatusClear,STATUS_INFOTEXT,FALSE) ;

 	// Reset exception flags
	lpprcCurr->SetFirstChance(FALSE);

// 	fIsLaunchingDebuggee = FALSE;

	// interface must exist, else we couldn't have got here
	struct ISqlExec *pISqlExec;
	VERIFY(SUCCEEDED(theApp.FindInterface( IID_ISqlExec, (LPVOID*)&pISqlExec )));

	// and tell the Ent package to issue the query before this final Go
	pISqlExec->DebuggeeLoadNotify(lntSQLThreadCreated, NULL);
	pISqlExec->Release();

	Go (NULL, stoNone, TRUE);
 	UpdateDebuggerState(UPDATE_ALLSTATES);

}

/*********************************************************************

    Function:   ExecDebuggee

    Description:

        Executes the debuggee in the passed manner.  Makes all
        the necessary tests against the make to see if a
        build should take place.

*********************************************************************/
void PASCAL ExecDebuggee(EXECTYPE ExecType)
{    
    BOOL        fShowCSIP = FALSE;	  
    BOOL        fDoBuild = FALSE;
    STARTCODE   StartCode;
    BOOL        fTryExeBuild = FALSE;
    UINT        wError = STEPCUR_NOERROR ;
    UINT        wRes ;
    HCURSOR     hOldCursor = 0;
    BOOL        fPassException = FALSE;
    BOOL        fIsFirstChance = lpprcCurr->IsFirstChance();
    TCHAR       tchRibbonEdit[ 1024 ];
    TCHAR *     ptchRibbonEdit = (TCHAR *)NULL;
    BOOL        fIsExternal;
    BOOL        fEncFailed = FALSE;
    BOOL        fEncSucceeded = FALSE;
    BOOL        fEncCompiledFiles = FALSE;
    BOOL        fEncCompileError = FALSE;
    BOOL        fEncCanceled = FALSE;
    BOOL        fDisableBuildUI = FALSE;

    // Clear any bp message from status bar
    gpISrc->StatusText(SYS_StatusClear, STATUS_INFOTEXT, FALSE);

    // [bug #4984 11-4-92 v-natal]
    // moved the following code line and all the following block if { ... }, to avoid to double ask
    // the user in the case of the exe doesn't exists.
    // This call also handles external project types...
    // [bug #6570 4-1-93 v-natal]
	if (FIsActiveProjectDebuggable( NULL, &fIsExternal, &fTryExeBuild, NULL ))
	{
		// OK to debug and the BOOLs are set by the above call
		;
	}
    else if (theApp.m_jit.GetActive())
    {
        fTryExeBuild = TRUE;
        fIsExternal = FALSE;
    }
    else
    {
        // can't do anything here--no project and not JIT debugging--blow
        if (hOldCursor)
            SetCursor(hOldCursor);

        return;
    }

    if (!DebuggeeAlive())
    {
        if(!theApp.SaveAll(gpISrc->GetSrcEnvironParam(ENV_PROMPT_BEFORE_SAVE), FILTER_PROJECT | FILTER_DEBUG | FILTER_NEW_FILE))
			return;
		gpISrc->InitProjectState();
    }

	if (FIsSqlInproc() && !DebuggeeAlive())
	{
		MkEngStartSqlInProcDebuggee();
		return;
	}

    // If we are not alive yet, can we build the caller (ie. is it our target?
    if (!DebuggeeAlive() && !fDoBuild && fTryExeBuild)
    {
        EXEFROM exefrom;
        char    Executable[_MAX_PATH];

        exefrom = GetExecutableFilename(Executable, sizeof(Executable));

        // if fTryExeBuild is TRUE we already know there is a valid exename.
        ASSERT(exefrom != exefromNone);

        if (exefrom == exefromPid)
        {
            // We're getting the EXE name from the PID that was specified
            // on the command line.  This EXE name may be bogus (it is
            // for now), so don't do any checking on it.
        }
        else if (*Executable)
        {
            // Check if it exists

            if (!FileExist(Executable))  // The FileExists function should be moved from util.cpp to a debugger .cpp file
            {
                int iType;

                if ( (gpIBldSys->IsActiveBuilderValid() == S_OK) && (SUCCEEDED(gpIBldSys->GetBuilderType(ACTIVE_BUILDER, &iType))) && (iType != ExeBuilder))
                {
#ifndef RAD_DEMO
                    if ((exefrom != exefromLastDoc) && (QuestionBox(ERR_No_Exe_Build_It, MB_YESNO, (LPSTR)Executable) == IDYES))
                    {
#endif  // ndef RAD_DEMO
                        // User wants to build the EXE
                        fDoBuild = TRUE;
#ifndef RAD_DEMO
                    }
                    else
                    {
                        // No EXE and user doesn't want to create it!
                        if ( hOldCursor )
                            SetCursor ( hOldCursor );

                        return;
                    }
#endif // ndef RAD_DEMO
                }
                else
                {
                    // dolphin 3642 [patbr] build not allowed.  user
                    // opened EXE as project but EXE does not exist!
                    // Tell him and bail (he has no other option).
                    ErrorBox(ERR_No_Exe_No_Options, (LPSTR)Executable);
                    if ( hOldCursor )
                        SetCursor ( hOldCursor );

                    return;
                }
            }
        }
        else
        {
            ErrorBox(ERR_No_TargetName);

            if ( hOldCursor )
                SetCursor ( hOldCursor );
            return ;
        }
    }

    // See if we should attempt to Edit & Continue
    BOOL fForceENC = ExecType == EXEC_EDITANDCONTINUE ||
                     ExecType == EXEC_ENC_FORCEGO;
    if (DebuggeeAlive() &&
        gpISrc->ENCStateModified() &&
        (fForceENC ||
            (runDebugParams.fENCDebugging && 
            // no ENC if restarting (vc98 #26114)
            ExecType != EXEC_RESTART))
    ){

        DWORD encFlags = DoEditAndContinue();
        WORD updateFlags = UPDATE_ALLDBGWIN | UPDATE_DEBUGGEE | UPDATE_ENC;
        fEncSucceeded = encFlags & EncUpdatedImage;
        fEncCanceled = encFlags & EncCancel;
#if 0
        // Disabled (11/18/97): This is now done by UpdateDebuggerState
        if (pViewDisassy) {
            // have dam window update its map so that it doesn't
            // point to stale line info [ds98 6886]

			// We need to do this no matter whether ENC succeeded or failed
			// since the SAPI cache may have been voided by the ENC engine
            pViewDisassy->SendMessage( WU_UPDATEENC, wPCXF, (DWORD)&cxfIp );
        }
#endif
        if ((ExecType == EXEC_TRACEFUNCTION || ExecType == EXEC_SRC_TRACEFUNCTION)) {
            // Need to rerun SetupStep after ENC  [vc98 18570]
            ASSERT(g_pTraceFunction);
            if (!g_pTraceFunction->SetupStep ()) {
                UpdateDebuggerState(updateFlags);
                if (!fEncCanceled) {
                    ENCOutputErrorSummary();
                }
                return;
            }
        }
        if (!DebuggeeAlive() || (encFlags & EncCancel)) {
            // Stop debugging was invoked by the user during the recompile
            // Or user has canceled the operation
            UpdateDebuggerState(updateFlags);
            if (ExecType != EXEC_ENC_FORCEGO || !DebuggeeAlive()) {
                if (!fEncCanceled) {
                    ENCOutputErrorSummary();
                }
                return;
            }
        }
        if (fEncSucceeded) {
            if (!(encFlags & EncBoundBPs) || (encFlags & EncMovedIP)) {
                // image update successful, but couldn't bind BPs
                // or the ip has been moved to a different location
                // Cancel last debugging operation
                // Update source to provide visual indication of the IP

                if ( ExecType != EXEC_EDITANDCONTINUE ) {
                    // Notify user that EXEC was canceled
                    CString strReason;
                    int idsReason = (encFlags & EncMovedIP) ?
                        IDS_EncEditMoveIp : ERR_Multiple_BP_ENC;
                    strReason.LoadString(idsReason);
                    ENCOutputErr(Enc_Err_CmdNotExecuted, (LPCTSTR)strReason);
                }

                UpdateDebuggerState(updateFlags | UPDATE_SOURCE);

                if (encFlags & EncMovedIP) {
                    // Display msg box after calling UpdateDebuggerState
                    // so that the IP glyph point to the new current line
                    MsgBox(Information, IDS_EncMsgMoveIp);
                }

                ENCOutputErrorSummary();
                return;
            }

            UpdateDebuggerState(updateFlags);
        }
        else {
            if (!(encFlags & EncCancel)) {
                if (encFlags & EncCompileError) {
                    // a non-ZX related compiler error has occurred. In this case
                    // we want to avoid prompting for rebuild, as the rebuild will most
                    // likely fail with the same error
                    fEncCompileError = TRUE;
                    gpISrc->StatusText(IDS_Enc_CompileError, STATUS_ERRORTEXT, FALSE);
                }
                else if (encFlags & EncUnsupportedEdit) {
                    gpISrc->StatusText(IDS_Enc_UnsupportedEdit, STATUS_ERRORTEXT, FALSE);
                }
                else {
                    gpISrc->StatusText(STA_EncFailed, STATUS_ERRORTEXT, FALSE);
                }
            }
            fEncFailed = TRUE;
            fEncCompiledFiles = encFlags & EncCompiledFiles;
        }

        fDisableBuildUI = fEncCompileError || fEncCanceled;
    }

    if (fEncSucceeded || (fEncFailed && !fEncCanceled)) {
        ENCOutputErrorSummary();
    }

    BOOL fPromptUser = FALSE;

    // has the build state of the debuggee changed?
    // we check
    // o timestamps out of date
    // o chaged options
    // o files dirty in memory?
    if (!fDisableBuildUI && !fDoBuild && gpISrc->ProjectStateModified() && !fIsExternal )
    {
        fPromptUser = TRUE;
        switch( gpISrc->HandleBuildStateChange() )
        {
            case IDYES:
                fDoBuild = TRUE;
                break;
            case IDNO:
                break;
            case IDCANCEL:
                if (fEncCompiledFiles) 
                    ENCRestoreObjs();
                if (ExecType == EXEC_ENC_FORCEGO) {
                    break;
                }
                else {
                    return;
                }
            default:
                // No Dlg box was shown to the user
                fPromptUser = FALSE;
                break;
        }
    }
    // have files that are members of the project been changed (but not saved)?
    else if (!fDisableBuildUI && !fDoBuild && gpISrc->DebuggeeStateModified() && !fIsExternal )
    {
        fPromptUser = TRUE;
        switch (gpISrc->HandleProjectStateChange())
        {
            case IDYES:
                fDoBuild = TRUE;
                break;
            case IDNO:
                break;
            case IDCANCEL:
                if (fEncCompiledFiles) 
                    ENCRestoreObjs();
                if (ExecType == EXEC_ENC_FORCEGO) {
                    break;
                }
                else {
                    return;
                }
            default:
                // No Dlg box was shown to the user
                fPromptUser = FALSE;
                break;
        }
    }

    if (fEncCompiledFiles && !fDoBuild) {
        ENCRestoreObjs();
    }

    if (fEncFailed && !fEncCanceled && !fPromptUser) {
        // Notify user about ENC failure 
        if ( ExecType != EXEC_EDITANDCONTINUE &&
            ExecType != EXEC_ENC_FORCEGO) {       
            CString strMsg;
            strMsg.LoadString(fEncCompileError ? 
                IDS_Enc_HandleCompileError : IDS_Enc_CannotComplete);
            switch (MsgBox(Question, strMsg, MB_YESNO | MB_DEFBUTTON2)) {
            case IDYES:
                gpISrc->ResetProjectState();
                break;
            
            case IDNO:
                ShowFirstError();
                if (ExecType == EXEC_ENC_FORCEGO) {
                    break;
                }
                else {
                    return;
                }
            }
        }
        else {
            ShowFirstError();
            MessageBeep(0);
        }
    }

	//
	//	At this point, the project has to be rebuilt. If debuggee was
	//	running, we kill it or let it run depending on its status.
	//

    if( fDoBuild )
    {
        // Check if Debuggee was running...
        if (DebuggeeAlive())
        {
            // Kill him
            if (!ClearDebuggee(FALSE))
            {
                if (hOldCursor)
                    SetCursor(hOldCursor);

                return;
            }
        }

        // Do the build
        if (hOldCursor)
            SetCursor(hOldCursor);

        // If the build fails, bail
        // this is the time where we need to set the values of the 3 global
        // variables since they are always set to FALSE at the end of build.
       if ( gpIBldSys->DoTopLevelBuild(ACTIVE_BUILDER, FALSE, NULL, fcaRebuild, FALSE, TRUE) != S_OK )
            return;

        // NOTE: we need to return if DoTopLevelBuild() returns FALSE

        // OLYMPUS 7688: Re-enable this given incremental builds
        // this is very annoying....
        // matthewt 4/28/95
        //
        // DOLHPIN 9066: This next line will ALWAYS
        // exit if a build happened.  Ideally, this
        // wouldn't happen, but there are concerns
        // that if the build took a long time (define
        // long???) that the user may have forgotten
        // that they wanted a build.  This will disable
        // the fix for 9066 (which has been postponed)
        // markbro  3/21/94
    }


	if (ExecType == EXEC_EDITANDCONTINUE) {
		// The user only wanted to apply code changes
		// and/or rebuild the debuggee
		if (fEncSucceeded) {
			UpdateDebuggerState(UPDATE_ALLSTATES);
		}
		return;
	}

	//
	//	At this point, we check if just running	the program instead of
	//	debugging it.

    if (ExecType == EXEC_TARGET) {
        // Call our magic
        if ( hOldCursor ) SetCursor ( hOldCursor );
        ExecuteTarget() ;
        return ;
    }

	//	
	//	Debugging is taking place for the first time. Debuggee was not alive.

	if(!DebuggeeAlive())
    {
        // Ensure we start in the project directory - if we don't
        // do a make before running we could be anywhere.  (Also
        // need this for the potential ProjectDiskTimestamp() call)

		MkEngSetMakeDriveDir();
    }


	//
    //	Debugging is taking place for the first time. Debuggee was not
	//	alive. We call StartDebuggee for loading the debuggee and check what
	//	is returned.
	//

    DWORD dwStartTime;

    // Check if it is the first time
    if (!DebuggeeAlive()) {

		dwStartTime = ::GetTickCount ();

		//
        // If continue to cursor and the focus is on the
        // ribbon, save the text since the change to the
        // debug layout will change the focus and this
        // it won't work (as the user expects it to)
		//

		if ( ExecType == EXEC_TOCURSOR && IsFindComboActive ()) {
		
            SendMessage (GetFocus(),
						 WM_GETTEXT,
						 sizeof (tchRibbonEdit),
						 (LPARAM)tchRibbonEdit
						 );
						 
            ptchRibbonEdit = tchRibbonEdit;
        }


		//
        // First debugging command, erase the output window
        // Erase any previous Hits & switch to the virtual build window
    
        OutputWindowVwinClear (OwinGetDebugCommandID());
        OutputWindowSelectVwin (OwinGetDebugCommandID(), FALSE);
        fUpdateRemoteTarget = FALSE;

		//
        // This effectively loads the debuggee
		//
		
        StartCode = MkEngStartDebuggee ();

        if (hOldCursor) {
			SetCursor (hOldCursor);
		}

	
        // Debuggee is either at entry point or dead
        if (StartCode == SC_ATMAINORDEAD) {

            if ( DebuggeeAlive () ) {

                ASSERT (IS_STATE_DEBUG(DkGetDockState()));

                // Check mode that was asked for
                switch (ExecType){
                    // Let's fall thru the code that is processed
                    // on a normal GO
                    case EXEC_GO:
                    case EXEC_ENC_FORCEGO:
                        break;

                    // We are at WinMain() or main(), if ToCursor
                    // fails, let's show the current CSIP on current line.
                    case EXEC_TOCURSOR:
                        fShowCSIP = TRUE;
                        break;

                    // All of these situations lead to a Stop
                    // at either WinMain() or main().
                    case EXEC_STEPTORETURN:
                    case EXEC_RESTART:
                    case EXEC_TRACEINTO:
                    case EXEC_TRACEFUNCTION:
                    case EXEC_STEPOVER:
                    case EXEC_SRC_TRACEINTO:
                    case EXEC_SRC_TRACEFUNCTION:
                    case EXEC_SRC_STEPOVER:
                        // Directly update the current CS:IP
                        UpdateDebuggerState (UPDATE_ALLSTATES);

                        DWORD dwEndTime = ::GetTickCount( );
                        DWORD dwElapsedTime = dwEndTime - dwStartTime;
                        int nMinutes = dwElapsedTime/60000;
                        int nSeconds = (dwElapsedTime%60000)/1000;
                        int nTenthsOfSecond = (dwElapsedTime % 1000)/100;

                        if ( g_bDebugTime )
                        {
                            CString strElapsedTime;
                            strElapsedTime.Format("Debug start time: %d:%2.2d:%d",
                                            nMinutes, nSeconds, nTenthsOfSecond);
                            OutputWindowQueueHit(OwinGetDebugCommandID(), strElapsedTime, FALSE, TRUE);
                        }

                        return;
                }
            }


			if (!DebuggeeAlive()) {

                if ((ExecType == EXEC_GO) || (ExecType == EXEC_TOCURSOR) ||
                    (ExecType == EXEC_ENC_FORCEGO)) {
                    UpdateDebuggerState(UPDATE_ALLSTATES);
                }
                // Just return at this point
                return;
            }
        }

		if (StartCode == SC_GONE) {
		
            UpdateDebuggerState (UPDATE_ALLSTATES);
            return;
        }

		//
		// HACKHACK: this is horrible . . .
		//

		if (theApp.m_jit.GetActive () && theApp.m_jit.GetEvent () == NULL) {
			ExecType = EXEC_GO;
		}

		if (StartCode == SC_STOPPED || StartCode == SC_BPFAILED) {

			UpdateDebuggerState(UPDATE_ALLSTATES);
            return;
        }

		//
        // We failed while loading the debuggee. It could have
        // been a problem in loading OSDEBUG, CV410, loading the
        // symbols, wrong debugging information
        //
		
        if (StartCode == SC_FAILED) {
            // Just exit at this point
            return ;
        }

    }

	//
	// Debugging is already in place and this
	// code is a fall thru for the above code.
	//

    g_retVals.CleanUp ();


	// Handle the title bar mode state to reflect
    // the actual debuggee status.

	if (IsCrashDump ()) {
		SetModeName (TBR_Mode_CrashDump);
	} else {
		SetModeName (TBR_Mode_Run);
	}

    // Clear any bp message from status bar
    gpISrc->StatusText(SYS_StatusClear,STATUS_INFOTEXT,FALSE) ;

    // Determine whether to pass exception (if any) to debuggee
    switch (ExecType)
    {
        case EXEC_GO:
        case EXEC_ENC_FORCEGO:
        case EXEC_TOCURSOR:
        case EXEC_STEPTORETURN:
        case EXEC_TRACEINTO:
        case EXEC_TRACEFUNCTION:
        case EXEC_STEPOVER:
        case EXEC_SRC_TRACEINTO:
        case EXEC_SRC_TRACEFUNCTION:
        case EXEC_SRC_STEPOVER:
            // Check if there's a pending exception when we try
            // to run the debuggee
			if (pDebugCurr->IsJava()) {
				fPassException = TRUE;
			}
			else if (fIsFirstChance)
            {
                int ret = IDYES;//BUGBUG: with #ifdefs below
                        //  must init this to something!!
                        //

                // There's one. We may choose to pass exception to debuggee
                // or not, or cancel the Go command.
                ret = QuestionBox(DBG_Pass_Exception,MB_YESNOCANCEL);
                if (ret == IDCANCEL)
                {
                    // Repaint the ribbon controls according to the
                    // new debuggee status.
//                    fIsLaunchingDebuggee = FALSE;

                    // Handle the title bar mode state

					if (DebuggeeAlive ()) {
						if (IsCrashDump ()) {
							SetModeName (TBR_Mode_CrashDump);
						} else {
							SetModeName (TBR_Mode_Break);
						}
					} else {
						SetModeName ( (UINT)0);
					}
                    return;
                }
                if (ret == IDYES)
                    fPassException = TRUE;
            }
    }
    // Reset exception flags
    lpprcCurr->SetFirstChance(FALSE);


    // Handle debugging commands
    switch (ExecType)   {
        // User wants to restart, call StartDebuggee
        // which actually takes care of an eventual
        // restart if debuggee was already running
        // or stopped.
        case EXEC_RESTART:
            dwStartTime = ::GetTickCount();
			theApp.m_jit.SetActive (FALSE);			// clear Attach flag

            // If we fail, just return
            if (MkEngStartDebuggee() == SC_FAILED) {
                // We don't change the dock state when we
                // kill the debuggee for a restart. If the
                // restart fails for some reason, set back the
                // dock state to normal ( not debugging ).
                DkSetDockState(STATE_EDIT);
                return;
            }
            // Otherwise, we update the debugger state
            // which means we just break
            break;

        // We never return from a GO which handles
        // an internal message loop for the debugger.
        // This is mostly an Emulate issue...
        case EXEC_GO:
        case EXEC_ENC_FORCEGO:
            // [matthewt] CUDA bug fix #4179
            // Repaint the ribbon controls according to the
            // new debuggee status.
//            fIsLaunchingDebuggee = FALSE;
            {
                BOOL fFlipScreen = TRUE;
                if (ExecType == EXEC_ENC_FORCEGO &&
                    fEncFailed &&
                    !fEncCanceled) {
                    fFlipScreen = FALSE;
                }
                Go (NULL,fPassException,fFlipScreen);
            }

            // Coming back, we update the debugger,
            // just break
            break;
        // We want to execute to the next cursor position
        // This is done by a GO until temporary BP is
        // reached. This function will return FALSE if
        // we couldn't set the temporary BP at the specified
        // line or if we were already sitting on this line.
        case EXEC_TOCURSOR:
            // GO until...
            if ((wError = ContinueToCursor(fPassException,ptchRibbonEdit)) !=
                STEPCUR_NOERROR)
            {
                // Is that enough ? Well, could be bothering to
                // get a message...
                MessageBeep(0);

                switch (wError) {
                    case STEPCUR_NOCODE: wRes = STA_StepCurNoCode ; break ;
                    case STEPCUR_NOBPSET: wRes = STA_StepCurNoBPSet ; break ;
                    case STEPCUR_NOMOVE: wRes = STA_StepCurNoMove ; break ;
                }
                // [CAVIAR #5848 12/01/92 v-natjm]
                gpISrc->StatusText(wRes,STATUS_ERRORTEXT,FALSE);

                // Remember whether we were in a first-chance exception
                lpprcCurr->SetFirstChance(fIsFirstChance);

                // Update the ribbon button controls
//                fIsLaunchingDebuggee = FALSE;

                // Handle the title bar mode state

				if (DebuggeeAlive ()) {
					if (IsCrashDump ()) {
						SetModeName (TBR_Mode_CrashDump);
					} else {
						SetModeName (TBR_Mode_Break);
					}
				} else {
					SetModeName ( (UINT)0);
				}

                if (fEncSucceeded) {
                    // We are doing an Edit & Continue and run to cursor
                    // has failed. Since E&C was successful, update the 
                    // debugger state
                    UpdateDebuggerState(UPDATE_ALLSTATES);
                }

                // The default is to not update the current CS:IP
                // since the function failed but this code is also
                // a fall thru and we need to update after loading
                // the debuggee ( see EXEC_TOCURSOR above )
                // [CAVIAR #5937 12/01/92 v-natjm]
                if (!fShowCSIP) {
                    return ;
                }
            }
            // Just break if ContinueToCursor was successful or
            // if it failed and we have to show the CS:IP
            break;

        // This look into the call stack, set a temporary BP
        // and run a GO until. The process is the same as an
        // EXEC_TOCURSOR
        case EXEC_STEPTORETURN:
            // GO until...

			wError = StepToReturn (fPassException, lpprcCurr->GetStepMode ());

			if (wError != STEPOUT_NOERROR)
			{
                MessageBeep(0);

				switch(wError)
                {
                    case STEPOUT_NOCALLER : wRes = STA_StepOutNoCaller ;break ;
                    case STEPOUT_NOSOURCE : wRes = STA_StepOutNoSource ;break ;
                    case STEPOUT_NOBPSET  : wRes = STA_StepOutNoBPSet ; break ;
                }

                gpISrc->StatusText(wRes,STATUS_ERRORTEXT,FALSE) ;

                // Remember whether we were in a first-chance exception
                lpprcCurr->SetFirstChance(fIsFirstChance);

                // Repaint the ribbon controls according to the
                // new debuggee status.
//                fIsLaunchingDebuggee = FALSE;

                // Handle the title bar mode state
			
				if (DebuggeeAlive ()) {
					if (IsCrashDump ()) {
						SetModeName (TBR_Mode_CrashDump);
					} else {
						SetModeName (TBR_Mode_Break);
					}
				} else {
					SetModeName ( (UINT) 0);
				}

                // Same as above code. This is a fall thru for
                // EXEC_STEPTORETURN when we ran the first time
                if (!fShowCSIP) {
                    return;
                }
            }
            // Just break if StepToReturn was successful or
            // if it failed and we have to show the CS:IP
            break;


		case EXEC_STEPOVER:
        case EXEC_TRACEINTO:
        case EXEC_TRACEFUNCTION:
        case EXEC_SRC_TRACEFUNCTION:
        case EXEC_SRC_TRACEINTO:
        case EXEC_SRC_STEPOVER:
			{
				ULONG	sto 	  = stoNone;
				BOOL	fStepOver = FALSE;


				if (fPassException)
					sto |= stoPassEx;

                if (ExecType == EXEC_TRACEINTO || ExecType == EXEC_STEPOVER)
                {
					if (lpprcCurr->GetStepMode () == SRCSTEPPING)
                        sto |= stoQueryStep;
                }
                else
                {
                    sto = (STO) (sto | stoQueryStep);
                }


                if (ExecType == EXEC_STEPOVER || ExecType == EXEC_SRC_STEPOVER)
                    fStepOver = TRUE;

                if (ExecType == EXEC_TRACEFUNCTION ||
					ExecType == EXEC_SRC_TRACEFUNCTION)
				{
                    sto |= stoTraceFunction;
				}
				
				Step (fStepOver, (STO) sto);
			}
			break;

        // Any other command is not supported.
        default:
            ASSERT(FALSE);
            break ;
    }


	//
	//  At this point it is possible that we are actually shutting
	//	down; check for this -- in which case we just want to get out

	if (!lpdbf || !lpprcCurr)
	{
		return;
	}

	// Give a chance to ENC engine to handle a pending tmp breakpoint
	ENCHandleTmpBp();

    // If we didn't return before executing this code, it means we
    // have to update the debugger state i.e. the current CS:IP if
    // any and every window that shows some information related to
    // the current context ( LOCALS , REGISTERS , WATCH )
    if (!lpprcCurr->m_bEncGoPending)
    {
        UpdateDebuggerState(UPDATE_ALLSTATES);
    }
    else {
        // We are doing a break/go for ENC
        // Do not update sources to avoid showing the DAM window
        // if we broke in system code. 
        // We'll only need to update sources if ENC fails
        UpdateDebuggerState(UPDATE_ALLSTATES & ~UPDATE_SOURCE);
        AfxGetMainWnd()->PostMessage (WM_COMMAND, IDM_DEBUG_UPDATEIMAGE);
    }

	// Did any of the event handlers try to do a Debugger.Go?
	if (lpprcCurr->m_bGoDeferred)
	{
		// Yes, so do it now
		lpprcCurr->m_bGoDeferred = FALSE;
		pAutoDebugger->PublicGo();
	}

	if (lpprcCurr->m_bStopDeferred)
	{
		lpprcCurr->m_bStopDeferred = FALSE;
		pAutoDebugger->PublicStop(); 
	}

    if (g_bDebugTime && ExecType == EXEC_RESTART)
    {
        DWORD dwEndTime = ::GetTickCount();
        DWORD dwElapsedTime = dwEndTime - dwStartTime;
        int nMinutes = dwElapsedTime/60000;
        int nSeconds = (dwElapsedTime%60000)/1000;
        int nTenthsOfSecond = (dwElapsedTime % 1000)/100;

        if ( g_bDebugTime )
        {
            CString strElapsedTime;
            strElapsedTime.Format("Debug restart time: %d:%2.2d:%d",
                            nMinutes, nSeconds, nTenthsOfSecond);

            OutputWindowQueueHit(OwinGetDebugCommandID(), strElapsedTime, FALSE, TRUE);
        }
    }

}

// get the pertinent Java debug info: the class file name, what to debug the app under (browser
// or stand-alone), and the browser or stand-alone interpreter name.
// If we can't get this from the props, ask the user. If we fail to get the info, return FALSE.
BOOL GetJavaDebugInfo(BOOL bExecute /*= FALSE*/)
{
	// this should only be called if the current project is Java
	ASSERT(pDebugCurr && pDebugCurr->IsJava());

	// get the current project
	if (gpIBldSys != NULL)
	{

		BOOL bDebugInfo = FALSE;

		CString strClassName;
		ULONG nDebugUsing = Java_DebugUsing_Unknown;
		CString strBrowser;
		CString strStandalone;

		// get the information needed to debug
		gpIBldSys->GetJavaClassName(ACTIVE_BUILDER, strClassName);
		gpIBldSys->GetJavaDebugUsing(ACTIVE_BUILDER, &nDebugUsing);
		gpIBldSys->GetJavaBrowser(ACTIVE_BUILDER, strBrowser);
		gpIBldSys->GetJavaStandalone(ACTIVE_BUILDER, strStandalone);

		// do we have the information needed to debug?
		//   - class file name &&
		//     ((debug using browser && browser name) ||
		//     (debug using stand-alone interpreter && interpreter name))
		bDebugInfo = (!strClassName.IsEmpty() &&
			((nDebugUsing == Java_DebugUsing_Browser && !strBrowser.IsEmpty()) ||
			(nDebugUsing == Java_DebugUsing_Standalone && !strStandalone.IsEmpty())));

		// do we know the information needed to debug
		if (!bDebugInfo)
		{
			if (gpIBldSys->GetInitialJavaInfoForDebug(ACTIVE_BUILDER, bExecute) == S_FALSE)
				return FALSE;

			// get the information needed to debug again
			gpIBldSys->GetJavaClassName(ACTIVE_BUILDER, strClassName);
			gpIBldSys->GetJavaDebugUsing(ACTIVE_BUILDER, &nDebugUsing);
			gpIBldSys->GetJavaBrowser(ACTIVE_BUILDER, strBrowser);
			gpIBldSys->GetJavaStandalone(ACTIVE_BUILDER, strStandalone);

			// do we have the information needed to debug?
			//   - class file name &&
			//     ((debug using browser && browser name) ||
			//     (debug using stand-alone interpreter && interpreter name))
			bDebugInfo = (!strClassName.IsEmpty() &&
				((nDebugUsing == Java_DebugUsing_Browser && !strBrowser.IsEmpty()) ||
				(nDebugUsing == Java_DebugUsing_Standalone && !strStandalone.IsEmpty())));
		}

		return bDebugInfo;
	}
	else
	{
		// we should not hit this; we can't debug without a project
		ASSERT(FALSE);
		return FALSE;
	}


}

BOOL GetJavaBrowser(CString& strBrowser, CString& strBrowserArgs)
{
	// this should only be called if the current project is Java
	ASSERT(pDebugCurr && pDebugCurr->IsJava());

	// get the current project
	if (gpIBldSys != NULL)
	{

		// get the browser name from the project
		// REVIEW(briancr): assume that this is the file name
		// should we worry about any args to the browser?
		gpIBldSys->GetJavaBrowser(ACTIVE_BUILDER, strBrowser);

		// get the html page from the project
		gpIBldSys->GetJavaHTMLPage(ACTIVE_BUILDER, strBrowserArgs);

		return TRUE;
	}

	return FALSE;
}

BOOL GetJavaStandalone(CString& strStandalone, CString& strStandaloneArgs)
{
	// this should only be called if the current project is Java
	ASSERT(pDebugCurr && pDebugCurr->IsJava());

	// get the current project
	if (gpIBldSys != NULL)
	{

		// get the stand-alone interpreter name from the project
		gpIBldSys->GetJavaStandalone(ACTIVE_BUILDER, strStandalone);

		// get the stand-alone interpreter args from the project
		gpIBldSys->GetJavaStandaloneArgs(ACTIVE_BUILDER, strStandaloneArgs);

		// is the stand-alone interpreter jview?
		CString strStandaloneT = strStandalone;
		strStandaloneT.MakeLower();
		if (strStandalone.Find(_T("jview")) != -1)
		{
			// add -p to the command line
			strStandaloneArgs += _T(" -p");

			// add -a to the command line if the type of stand-alone
			// debugging is applet
			ULONG nStandaloneDebug;
			gpIBldSys->GetJavaStandaloneDebug(ACTIVE_BUILDER, &nStandaloneDebug);
			if (nStandaloneDebug == 1)
			{
				strStandaloneArgs += _T(" -a");
			}
		}

		// get the class name
		CString strClassName;
		gpIBldSys->GetJavaClassName(ACTIVE_BUILDER, strClassName);
		
		// append it to the args
		strStandaloneArgs += _T(" ") + strClassName;

		// get the class args
		CString strClassArgs;
		gpIBldSys->GetProgramRunArguments(ACTIVE_BUILDER, strClassArgs);

		// append to the args
		strStandaloneArgs += _T(" ") + strClassArgs;

		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\lnklst.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define HUGE

// Linked list variables used to store lists of objects
// Node structure
typedef struct NodeTag {
	DWORD length;	// length of current node
	char string [1]; // used to be []
	} NODE, FAR *LPNODE;

// Header structure
typedef struct {
	HGLOBAL hMem;	// Handle to the node
	DWORD NbItem;	// Nb of items in the structure
	DWORD Size;		// Allocated size in bytes
	DWORD UsedSize;	// Used size in bytes
	DWORD LastNode;	// Offset to last node
	UINT Id;		// Id of the list
	} LISTHEADER;

// 4 linked lists
#define cLists	4
// Initial list size
#define LIST_SIZE	1024
static LISTHEADER ListHeader[cLists];


/****************************************************************************

		  FUNCTION:   GetListIndex(int)

		  PURPOSE:    Internal: given a list ID, returns an index

****************************************************************************/
static int GetListIndex(int listId)
{
	int	iList;

	switch (listId)
	{
	case DLG_EXCEP_LIST:
		iList = 0;
		break;
	case DLG_EXCEP_LIST_BACKUP:
		iList = 1;
		break;
	case DLG_SYSTEM_EXCEP_LIST:
		iList = 2;
		break;
	case DLG_THREAD_LIST:
		iList = 3;
		break;
	default:
		// AuxPrintf2("Val=%d",listId);
		ASSERT(FALSE);
		return 0;
	}

	ASSERT(iList < cLists);
	return iList;
}
/****************************************************************************

		  FUNCTION:   GetObjectPointer(DWORD, int, LPSTR *, DWORD *)

		  PURPOSE:    Internal: Return a pointer to a particular object
					  in a list.

		  INPUT:	  index = index into list
					  ListIndex = index of the list

		  OUTPUT:	  *plpMem = ptr to memory block (must be unlocked later)
					  *poffset = offset of item in list

****************************************************************************/
static BOOL GetObjectPointer(DWORD index, int ListIndex, LPSTR *plpMem, DWORD *poffset)
{
LPNODE lpNode;
LPSTR lpMem;
DWORD i;
DWORD offset;
	if (ListIndex == -1)
		return FALSE;
	if (index >= ListHeader[ListIndex].NbItem)
		return (FALSE);

	// Get pointer to block
	ASSERT (ListHeader[ListIndex].hMem != NULL);
	lpMem = (LPSTR)GlobalLock(ListHeader[ListIndex].hMem);
	if (lpMem == NULL)
		return (FALSE);
	// Get position for new node
	i = 0;
	offset = 0;
	do
	{
		lpNode = (LPNODE)(lpMem + offset);
		ASSERT (lpNode->length < 500);
		if (lpNode->length > 500)	// Assuming length won't be that large
		{
			GlobalUnlock(ListHeader[ListIndex].hMem);
			return (FALSE);
		}
		offset += lpNode->length;
	}
	while (i++ < index);
	offset -= lpNode->length;

	*plpMem = lpMem;
	*poffset = offset;
	return TRUE;
}
/****************************************************************************

		  FUNCTION:   MaybeGrowBuffer(int, DWORD)

		  PURPOSE:    Internal: Grow a buffer if necessary

****************************************************************************/
static BOOL MaybeGrowBuffer(int ListIndex, DWORD AddedSize)
{
HGLOBAL hMem;
	if (AddedSize + ListHeader[ListIndex].UsedSize
												> ListHeader[ListIndex].Size)
	{
		hMem = GlobalReAlloc(ListHeader[ListIndex].hMem,
							 LIST_SIZE + ListHeader[ListIndex].Size,
							 GMEM_MOVEABLE/*|GMEM_DISCARDABLE*/);
		if (hMem == NULL)
		{
			ErrorBox(ERR_Memory_Is_Low);
			return FALSE;
		}
		ListHeader[ListIndex].hMem = hMem;
		ListHeader[ListIndex].Size += LIST_SIZE;
	}
	return TRUE;
}
/****************************************************************************

		  FUNCTION:   InitList(int)

		  PURPOSE:    Create a list if it does not exist

		  RETURN:     TRUE if OK

****************************************************************************/
BOOL InitList(int listId)
{
int ListIndex;

	// Get list array index from Id
	ListIndex = GetListIndex(listId);
	if (ListIndex == -1)
		return (FALSE);

	// Allocate memory if the list isn't created yet
	if (ListHeader[ListIndex].hMem == NULL)
	{
		ListHeader[ListIndex].hMem =
						GlobalAlloc(GMEM_MOVEABLE|GMEM_DISCARDABLE,LIST_SIZE);
		if (ListHeader[ListIndex].hMem == NULL)
			return FALSE;
		ListHeader[ListIndex].Size = LIST_SIZE;
		ListHeader[ListIndex].UsedSize = 0;
		ListHeader[ListIndex].NbItem = 0;
		ListHeader[ListIndex].LastNode = 0;
		ListHeader[ListIndex].Id = listId;
	}

	return (TRUE);
}
/****************************************************************************

		  FUNCTION:   EmptyList(int)

		  PURPOSE:    Reset the content of a list

		  RETURN:     TRUE if OK

****************************************************************************/
BOOL EmptyList(int listId)
{
int ListIndex;

	// Get list array index from Id
	ListIndex = GetListIndex(listId);
	if (ListIndex == -1)
		return (FALSE);

	ListHeader[ListIndex].NbItem = 0;
	ListHeader[ListIndex].LastNode = 0;
	ListHeader[ListIndex].UsedSize = 0;
	ListHeader[ListIndex].Id = listId;

	return (TRUE);
}
/****************************************************************************

		  FUNCTION:   FreeList(int listId)

		  PURPOSE:    Free allocated memory  for the given list
					  This function is called when msvc exit

****************************************************************************/
void FreeList(void)
{
int ListIndex;

	for (ListIndex = 0; ListIndex < cLists; ListIndex++)
	{
		if (ListHeader[ListIndex].hMem != NULL)
		{
			GlobalFree(ListHeader[ListIndex].hMem);
			ListHeader[ListIndex].hMem = NULL;
			ListHeader[ListIndex].Size = 0;
			ListHeader[ListIndex].NbItem = 0;
			ListHeader[ListIndex].LastNode = 0;
		}
	}
}
/****************************************************************************

		  FUNCTION:   ListCopy(int newlist,int oldlist)

		  PURPOSE:    Duplicate a list

****************************************************************************/
BOOL ListCopy(int newId, int oldId, LPSTR buffer, UINT cch)
{
int i,count;
	if (GetListIndex(newId) == -1 || GetListIndex(oldId) == -1)
		return (FALSE);

	InitList(newId);
	EmptyList(newId);
	count = (int)ListGetCount(oldId);
	for (i=0; i<count; i++)
	{
		if (!ListGetObject(i,oldId,buffer))
		{
			ASSERT(FALSE);
			EmptyList(newId);
			return (FALSE);
		}
		if (!ListAddObject(newId,buffer,cch))
		{
			ASSERT(FALSE);
			EmptyList(newId);
			return (FALSE);
		}
	}
	return (TRUE);
}
/****************************************************************************

		  FUNCTION:   ListGetCount(int)

		  RETURN:     number of items in the list

****************************************************************************/
DWORD ListGetCount(int listId)
{
int ListIndex;
	ListIndex = GetListIndex(listId);
	if (ListIndex == -1)
		return 0;
	return (ListHeader[ListIndex].NbItem);
}
/****************************************************************************

		  FUNCTION:   ListInsertObject(int,int,LPSTR, int)

		  PURPOSE:    Insert an object into a linked list

		  RETURN:     TRUE if success

****************************************************************************/
BOOL ListInsertObject(DWORD index, int listId, LPSTR string, int cch)	// cch includes the null terminating byte
{
int ListIndex;
DWORD AddedSize;
LPNODE lpNode;
LPSTR lpMem;
DWORD offset;
	ListIndex = GetListIndex(listId);
	if (ListIndex == -1)
		return FALSE;
	if (index == ListHeader[ListIndex].NbItem)
		return ListAddObject(listId, string, cch);	// append
	AddedSize = sizeof(NODE) + cch;
	AddedSize = (AddedSize + 3) & ~3L;	// align on dword boundary

	// Realloc buffer if necessary
	if (!MaybeGrowBuffer(ListIndex, AddedSize))
		return FALSE;
	// Get offset where we need to insert
	if (!GetObjectPointer(index, ListIndex, &lpMem, &offset))
		return FALSE;
	lpNode = (LPNODE)(lpMem + offset);
	// Shift old nodes
	_fmemmove((LPSTR)lpNode+AddedSize,lpNode,ListHeader[ListIndex].UsedSize-offset);
	// Create new node
	_fmemmove(lpNode->string,string,cch);
	lpNode->length = AddedSize;
	// Update list size
	if (offset < ListHeader[ListIndex].UsedSize)
		ListHeader[ListIndex].LastNode += AddedSize;
	ListHeader[ListIndex].UsedSize += AddedSize;
	ListHeader[ListIndex].NbItem++;
	GlobalUnlock(ListHeader[ListIndex].hMem);
	return (TRUE);
}
/****************************************************************************

		  FUNCTION:   ListAddObject(int, LPSTR, int)

		  PURPOSE:    Add an object at the end of a linked list

		  RETURN:     TRUE if success

****************************************************************************/
BOOL ListAddObject(int listId, LPSTR string, int cch)	// cch includes the null terminating byte
{
int ListIndex;
DWORD AddedSize;
LPNODE lpNode;
LPSTR lpMem;
	ListIndex = GetListIndex(listId);
	if (ListIndex == -1)
		return FALSE;
	AddedSize = sizeof(NODE) + cch;
	AddedSize = (AddedSize + 3) & ~3L;	// align on dword boundary
	ASSERT (ListHeader[ListIndex].hMem != NULL);

	// Realloc buffer if necessary
	if (!MaybeGrowBuffer(ListIndex, AddedSize))
		return FALSE;
	// Get pointer to block
	lpMem = (LPSTR)GlobalLock(ListHeader[ListIndex].hMem);
	if (lpMem == NULL)
		return (FALSE);
	// Create node
	lpNode = (LPNODE)(lpMem + ListHeader[ListIndex].UsedSize);
	_fmemmove(lpNode->string,string,cch);
	lpNode->length = AddedSize;
	// Link the new node
	ListHeader[ListIndex].LastNode = ListHeader[ListIndex].UsedSize;
	ListHeader[ListIndex].UsedSize += AddedSize;
	ListHeader[ListIndex].NbItem++;
	GlobalUnlock(ListHeader[ListIndex].hMem);
	return (TRUE);
}
/****************************************************************************

		  FUNCTION:   ListUpdateObject(int,int,LPSTR)

		  PURPOSE:    Get a string in a linked list

		  RETURN:     TRUE if success

****************************************************************************/
BOOL ListUpdateObject(DWORD index, int listId, LPSTR string, int cch)
{
int ListIndex;
DWORD offset;
LPNODE lpNode;
LPSTR lpMem;
	ListIndex = GetListIndex(listId);
	if (ListIndex == -1)
		return FALSE;
	if (index > ListHeader[ListIndex].NbItem)
		return (FALSE);

	// Get pointer to block
	if (!GetObjectPointer(index, ListIndex, &lpMem, &offset))
		return FALSE;
	lpNode = (LPNODE)(lpMem + offset);

	_fmemmove(lpNode->string, string, (size_t)(lpNode->length-sizeof(NODE)));
	GlobalUnlock(ListHeader[ListIndex].hMem);
	return (TRUE);
}

/****************************************************************************

		  FUNCTION:   ListGetObject(int,int,LPSTR)

		  PURPOSE:    Get a string in a linked list

		  RETURN:     TRUE if success

****************************************************************************/
BOOL ListGetObject(DWORD index, int listId, LPSTR string)
{
int ListIndex;
DWORD offset;
LPNODE lpNode;
LPSTR lpMem;
	ListIndex = GetListIndex(listId);
	if (ListIndex == -1)
		return FALSE;

	// Get pointer to block
	if (!GetObjectPointer(index, ListIndex, &lpMem, &offset))
		return FALSE;
	lpNode = (LPNODE)(lpMem + offset);

	_fmemmove(string, lpNode->string, (size_t)(lpNode->length-sizeof(NODE)));
	GlobalUnlock(ListHeader[ListIndex].hMem);
	return (TRUE);
}

/****************************************************************************

		  FUNCTION:   ListDeleteObject(int,int)

		  PURPOSE:    Delete a string in a linked list

		  RETURN:     TRUE if success

****************************************************************************/
BOOL ListDeleteObject(DWORD index, int listId)
{
int ListIndex;
DWORD offset,NodeLength;
LPNODE lpNode;
LPSTR lpMem;
char HUGE *lp1, HUGE *lp2;
	ListIndex = GetListIndex(listId);
	if (ListIndex == -1)
		return FALSE;
	if (index > ListHeader[ListIndex].NbItem)
		return (FALSE);

	// Get pointer to block
	if (!GetObjectPointer(index, ListIndex, &lpMem, &offset))
		return FALSE;
	lpNode = (LPNODE)(lpMem + offset);

	// Shift the remaining bytes so the node is erased
	NodeLength = lpNode->length;	// length of node to delete
	lp1 = (char HUGE*)lpNode;		// point to current node
	lp2 = lp1 + NodeLength;			// point to next node
	while (offset < ListHeader[ListIndex].UsedSize)
	{
		*lp1++ = *lp2++;
		offset++;
	}
	ListHeader[ListIndex].UsedSize -= NodeLength;
	ListHeader[ListIndex].LastNode -= NodeLength;
	ListHeader[ListIndex].NbItem--;
	GlobalUnlock(ListHeader[ListIndex].hMem);
	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\makeeng4.cpp ===
#include "stdafx.h"
#pragma hdrstop

#define MAX_ATOM_LEN	1024

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// While debugging, szDebugTarget contains the full path name of the target
// which is currently being debugged (whether it be an executable or a DLL).
// The purpose of this is so that we can remember what the user is actually
// debugging even if the user changes the build target of his project while
// in the middle of a debugging session.
static char FAR szDebugTarget[_MAX_PATH];
static CString	strNull = "";

/****************************************************************************

	FUNCTION:	SzLastExeWindow()

	PURPOSE:	If the IDE currently has any windows open which are viewing
				an EXE (viewing resources through the VRES package), this
				will function return a pointer to the EXE name.  Otherwise
				it will return NULL.

	RETURNS:	A full path to an EXE, or NULL.

****************************************************************************/

const CString& SzLastExeWindow(VOID)
{
	CMDIChildWnd *pMDIChildWnd = ((CMDIFrameWnd *) theApp.m_pMainWnd)->MDIGetActive();

	if (pMDIChildWnd)
	{
		CDocument * pDoc = pMDIChildWnd->GetActiveDocument();
		if ( pDoc != NULL )
		{
			const CString& strPath = pDoc->GetPathName();

			if (strPath.Right(4).CompareNoCase(_T(".exe")) == 0)
				return strPath;
		}
	}
	return strNull;
}

/****************************************************************************
	FUNCTION:	GetLastDocWin

	PURPOSE:	Get a pointer to the last document whose window was active.
				This is primarily for VPROJ's benefit, although VCPP could
				conceivably make use of it as well.

	RETURNS:	A pointer to the last active document, or NULL if none.
****************************************************************************/

IDE_EXPORT CDocument * GetLastDocWin()
{
	if (pLastDocWin == NULL)
		return NULL;

	return(pLastDocWin);
}

/****************************************************************************

	FUNCTION:	GetExeOrTarg

	PURPOSE:	Gets the full path name of either the current executable file
				or the current target - from the project if there is one, else
				from the currently open exe if there is one, else from the
				current source file.

				If you are only interested in the return code (exefrom), you
				can pass NULL for the 'executable' argument.

				The difference between the current executable and the current
				target is, the target is what the makefile will build; the
				executable is what the debugger will run (never a DLL).

	RETURNS:	An enum value to indicate where the EXE name came from:
					exefromProj if it comes from the current project
					exefromExe if it comes from an open AppStudio window
							which is looking at the EXE's resources
					exefromLastDoc if it comes from the last document window
							to have had focus
					exefromPid if it comes from the PID on the command line
							(just-in-time debugging)
					exefromNone if no exe was found.
				Filename is returned in ANSI charset.

****************************************************************************/

EXEFROM PASCAL GetExeOrTarg ( PSTR executable, UINT size, BOOL fTarget )
{
	EXEFROM exefrom = exefromNone;
	UINT NumToCopy;
	TCHAR szPath[_MAX_PATH];

	// If asking for EXE, see if we're doing just-in-time debugging
	if (!fTarget && theApp.m_jit.GetActive())
    {
		if (executable)
        {
			_tcsncpy(executable, (LPCTSTR)theApp.m_jit.GetPath(), size);
			executable[size-1] = '\0';
		}
		return exefromPid;
	}
	else if ( gpIBldSys && (gpIBldSys->IsActiveBuilderValid() == S_OK) )
	{
		exefrom = exefromProj;

		// get the caller executable from the project
		CString str;

	    gpIBldSys->GetCallingProgramName(ACTIVE_BUILDER, str);
		_tcscpy(szPath, (LPCTSTR)str);

		if (*szPath == '\0')
			return exefromNone;

		// strip quotes
		str = szPath;
		if (!str.IsEmpty() && str[0]==_T('\"'))
		{
			str = str.Mid(1, str.GetLength()-2);
			_ftcscpy(szPath, str);
		}
	}
	else
	{
		const CString& szExe = SzLastExeWindow();

		if (!szExe.IsEmpty())
		{
			if (executable)
			{
				_ftcsncpy(executable, (LPCTSTR)szExe, size);
				executable[size-1] = '\0';
			}
			return exefromExe;
		}
		else
		{
			// Get current document
			if (pLastDocWin != NULL)
			{
				exefrom = exefromLastDoc;

				if (executable)
				{
					// strip the extension and replace with .exe
					_ftcscpy(szPath, (LPCTSTR)pLastDocWin->GetPathName());
					_splitpath(szPath, szDrive, szDir, szFName, szExt);
					if (_tcsicmp(szExt, _T(".java")) == 0)
						_makepath(szPath, szDrive, szDir, szFName, _T("class"));
					else
						_makepath(szPath, szDrive, szDir, szFName, "exe");
				}
			}
			else
			{
				// no executable available
				return( exefromNone );
			}
		}
	}

	// If we get to here szPath contains what we want
	// Copy it to our passed buffer
	if (executable)
	{
		NumToCopy = min(_ftcslen(szPath)+1, size-1);
		_ftcsncpy(executable, szPath, NumToCopy);
		executable[NumToCopy-1] = '\0';
	}

	ASSERT(exefrom != exefromNone);
	return exefrom;
}

/****************************************************************************

	FUNCTION:	GetExecutableFilename

	PURPOSE:	Gets the full path name of the current executable file -
				from the project if there is one, or from the current
				source file otherwise.

				If you are only interested in the return code (exefrom), you
				can pass NULL for the 'executable' argument.

	RETURNS:	An enum value to indicate where the EXE name came from:
					exefromProj if it comes from the current project
					exefromExe if it comes from an open AppStudio window
							which is looking at the EXE's resources
					exefromPid if it comes from the PID on the command line
							(just-in-time debugging)
					exefromLastDoc if it comes from the last document window
							to have had focus
					exefromNone if no exe was found.
				Filename is returned in ANSI charset.

****************************************************************************/

IDE_EXPORT EXEFROM GetExecutableFilename ( PSTR executable, UINT size )
{
	return GetExeOrTarg(executable, size, FALSE);
}

/****************************************************************************

	FUNCTION:	GetDebuggeeCommandLine

	PURPOSE:	Gets the command line

****************************************************************************/
void PASCAL GetDebuggeeCommandLine(CString& CommandLine)
{
	// get the command-line from the project
	if ( gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK )
	{
		gpIBldSys->GetProgramRunArguments(ACTIVE_BUILDER, CommandLine);
	}
	else
	{
		ASSERT(theApp.m_jit.GetActive());
		CommandLine = "";
	}
}

/****************************************************************************

	FUNCTION:	GetDebugTarget

	PURPOSE:	Gets the full path name of the file which is currently being
				debugged (or would be debugged if a debugging session were
				started).  This is slightly different from GetActiveProject()
				->GetTargetFilename(), in that if the user starts a debugging
				session and then modifies his project to build a different
				target, GetDebugTarget() will still get the name of the
				file which is actually being debugged.

	RETURNS:	TRUE if successful.  Filename is returned in ANSI charset.

****************************************************************************/

BOOL PASCAL GetDebugTarget(PSTR szTarget, UINT cch)
{
	// Check for a current debuggee first
	if (DebuggeeAlive())
	{
		if (theApp.m_jit.GetActive() && theApp.m_jit.FPathIsReal())
			_ftcsncpy(szTarget, (const TCHAR *)theApp.m_jit.GetPath(), cch);
		else
			_ftcsncpy(szTarget, szDebugTarget, cch);
		szTarget[cch-1] = '\0';

		return( TRUE );
	}
	else
		return (GetExeOrTarg(szTarget, cch, TRUE) != exefromNone);
}

/****************************************************************************

	FUNCTION:	SetDebugTarget

	PURPOSE:	Sets the filename of the target that's currently being
				debugged.  The only purpose of this is so that
				GetDebugTarget knows the name of the current target.

****************************************************************************/

VOID PASCAL SetDebugTarget(PCSTR szTarget)
{
	_ftcsncpy(szDebugTarget, szTarget, sizeof(szDebugTarget));
	szDebugTarget[sizeof(szDebugTarget)-1] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\meglobal.cpp ===
/**** GWIN.C - Windows CodeView Mapping layer for CW services          ****
 *                                                                         *
 *  Copyright <C> 1992, Microsoft Corp                                     *
 *                                                                         *
 *  Created: March 29, 1992 by Mark A. Brodsky                             *
 *                                                                         *
 *  Purpose: To provide API equivalents of CW in the Windows world         *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

CMultiEdit *CMultiEdit::m_pList[NUM_ME_WINDOWS] = {NULL, NULL, NULL, NULL, NULL, NULL};

// ClearMultiEdit is called when the debuggee has died or has been terminated.
// This function will call all MultiEdit controlled windows with the
// WU_CLEARDEBUG notification so the window can be cleared.
void ClearMultiEdit ( void )
{
    for (INT i = 0; i < NUM_ME_WINDOWS; i++)
    {
        if ( CMultiEdit::m_pList[i] )
            CMultiEdit::m_pList[i]->SendMessage( WU_CLEARDEBUG, 0, 0L );
	}
}

void AddThisToCMEList(CMultiEdit *pme)
{
    // Add the CME to the list using the doctype as the index.
    ASSERT(!CMultiEdit::m_pList[pme->m_dt]);

    CMultiEdit::m_pList[pme->m_dt] = pme;
}

void RemoveThisFromCMEList(CMultiEdit *pme)
{
    ASSERT(CMultiEdit::m_pList[pme->m_dt] == pme);

    CMultiEdit::m_pList[pme->m_dt] = NULL;
}

void UpdateMultiEditScroll (CMultiEdit *pCME)
{
	pCME->SendMessage(WU_UPDATESCROLLBARS, 0, 0L);
}

void UpdateAllMultiEditScroll()
{
    for (INT i = 0; i < NUM_ME_WINDOWS; i++)
    {
        if ( CMultiEdit::m_pList[i] )
            CMultiEdit::m_pList[i]->SendMessage( WU_UPDATESCROLLBARS, 0, 0L );
	}
}

// Following code is VERY similar to SaveDocument found in docfile.c!+
BOOL SaveMultiEditDocument( CMultiEdit *pme, const CPath &pathSave)
{
    HCURSOR hSaveCursor;
    FILE *	pfile;

    // Put up the hourglass.  EARLY EXIT POINT IS NOW 'error'.
	hSaveCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );

	if ( pfile = fopen( pathSave.GetFullPath(), "w" ) )
    {
		DWORD			lnStart;
		DWORD			lnEnd;

		// ASSERT( pme->IsKindOf( RUNTIME_CLASS( CMultiEdit ) ) );

		// Memory and disassembly windows will only dump currently visible data
		if ( pme->m_dt == MEMORY_WIN || pme->m_dt == DISASSY_WIN )
        {
			lnStart = pme->OlnGetTop();
			lnEnd = lnStart + pme->WinHeight() + 1;
		}
		else
        {
			lnStart = 0;
			lnEnd = pme->CLinesInBuf();
		}

		while( lnStart < lnEnd )
        {
			char	sz[ axMax + 2 ];
			PDLA	pdla;

			pme->CbGetLineBuf(lnStart++, sizeof( sz ) - 1, sz, pdla);

			fprintf( pfile, "%s\n", sz );
		}

		fclose( pfile );
	}

	SetCursor (hSaveCursor);

	return( pfile != NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mepriv.cpp ===
/**** Multiline Edit Control                                           ****
 *                                                                         *
 *                                                                         *
 *  Copyright <C> 1991, Microsoft Corp                                     *
 *                                                                         *
 *  Created: September 16, 1991 by Mark A. Brodsky (as CV4.0: me.c)        *
 *                                                                         *
 *  Purpose: Functional replacement of outdated MASM/CW EDIT_FULLMGR       *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// SUSHI uses child docable windows, treat as such
#define	MakeActive(hwnd)	(::SetFocus(hwnd))
#define FIsActiveWindow(hwnd)	((hwnd)==::GetFocus())

typedef LD *        PLD;
typedef IP *        PIP;
typedef PD *        PPD;

#define cchEditMax  (axMax+2)

BYTE fInsertMode = TRUE;

// Mouse compatability
extern DWORD    lParamMouse;
extern WORD     wParamMouse;

// This macro is used to compare to pip's.  This should be
// much faster than !memcmp( pip1, pip2, sizeof( IP ) )!
#define MEFAreIPsEqual(pip1,pip2)    \
    ( (pip1)->oln == (pip2)->oln && (pip1)->ob == (pip2)->ob )

#define cchDelBack  7
#define idTimer	0x1010


/**** ResizeScroll                                                      ****
 *                                                                         *
 *  PURPOSE: After a window has changed size or line numbers, update the   *
 *           update the scroll bar extents and current value               *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: ResizeScroll() {

	// fAlreadyHere is used to ensure that we don't get recursive.  Set it
	// to TRUE while processing and FALSE when we're done.
	static BOOL	fAlreadyHere = FALSE;

	if ( !fAlreadyHere ) {
		UINT	cln = CLinesInBuf();
        WORD    obMac;
		BOOL	fScrollV = FALSE;
		BOOL 	fScrollH = FALSE;
		RRC		rrc;

		fAlreadyHere = TRUE;

		m_olnMacPrev = (DWORD)cln;

		GetEditRrc( FALSE, &rrc );

		if ( WinHeight() >= cln || !gpISrc->GetSrcEnvironParam(ENV_VSCROLL) )
        {
			if (UseWin4Look())
            {
				SCROLLINFO si;
				si.cbSize = sizeof (si);
				si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;
				si.nMin = 0;
				si.nMax = 0;
				si.nPage = rrc.ryBottom - rrc.ryTop;
				si.nPos = 0;
				SetScrollInfo(SB_VERT, &si, TRUE);
			}
			else
				SetScrollRange (SB_VERT,0,0,TRUE);
		}
		else
        {
			DWORD	dwT;

			if ( !rrc.ryBottom )
				++rrc.ryBottom;

			dwT = ( cln + rrc.ryBottom ) / rrc.ryBottom;

			if ( dwT > SHRT_MAX )//|| dwT > (DWORD)WinHeight() )
				m_dScrollVal = 0;
			else
				m_dScrollVal = (int) dwT;

			fScrollV = TRUE;

			if (UseWin4Look()) {   
				SCROLLINFO si;
				si.cbSize = sizeof (si);
				si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS ; 
				si.nMin = 0;
				si.nMax = ScrollFromOln(cln - 1);
				si.nPage = rrc.ryBottom - rrc.ryTop;
				si.nPos = ScrollFromOln(m_ipCur.oln);
				SetScrollInfo(SB_VERT, &si, TRUE);

			}
			else
			{
				SetScrollPos( SB_VERT, ScrollFromOln( m_ipCur.oln ), FALSE );
				SetScrollRange( SB_VERT, 0, ScrollFromOln( cln - 1 ), TRUE );
			}
		}

        obMac = ObMaxBuf();

		if ( WinWidth() >= obMac || !gpISrc->GetSrcEnvironParam(ENV_HSCROLL) )
        {
			if (UseWin4Look())
            {
				SCROLLINFO si;
				si.cbSize = sizeof (si);
				si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;
				si.nMin = 0;
				si.nMax = 0;
				si.nPage = rrc.ryBottom - rrc.ryTop;
				si.nPos = 0;
				SetScrollInfo(SB_HORZ, &si, TRUE);
			}
			else
				SetScrollRange (SB_HORZ,0,0,TRUE);
		}
		else
        {
			fScrollH = TRUE;
			if (UseWin4Look())
            {
				SCROLLINFO si;
				si.cbSize = sizeof (si);
				si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;
				si.nMin = 0;
				si.nMax = obMac - 1;
				si.nPage = rrc.rxRight - rrc.rxLeft;
				si.nPos = m_pdCur.obleft;
				SetScrollInfo(SB_HORZ, &si, TRUE);
			}
			else
            {
				SetScrollPos( SB_HORZ, m_pdCur.obleft, FALSE );
				SetScrollRange (SB_HORZ,0,obMac - 1,TRUE);
			}
		}

		if (fScrollV != m_fScrollV || fScrollH != m_fScrollH)
        {
			m_fScrollV = fScrollV;
			m_fScrollH = fScrollH;
		}

		fAlreadyHere = FALSE;
	}
}

/**** LGetShiftState                                                    ****
 *                                                                         *
 *  PURPOSE: For character input, get the state of the control and shift   *
 *           keys. Set the return value to have KK_ values OR'd in         *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
long CMultiEdit :: LGetShiftState() {
    long    lRet = 0L;

    if ( GetKeyState( VK_SHIFT ) & 0x8000 ) {
        lRet |= MAKELONG( 0, KK_SHIFT );
     }
    if ( GetKeyState( VK_CONTROL ) & 0x8000 ) {
        lRet |= MAKELONG( 0, KK_CONTROL );
    }
    return lRet;
}

/**** FGetSelection - Get start and end positions of selection          ****
 *                                                                         *
 *  PURPOSE: Determine the beginning and end of a selection.               *
 *                                                                         *
 *  INPUTS:                                                                *
 *     oln      Line to get selection range for                            *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *     pobMic   Pointer to the beginning base offset of a selection        *
 *     pobMac   Pointer to the end base offset of a selection              *
 *                                                                         *
 *      Return Value: TRUE if oln is a "selected" line                     *
 *                                                                         *
 *  IMPLEMENTATION: The selection is obMic <= SELECTION <= obMac.          *
 *                                                                         *
 ***************************************************************************/
BOOL CMultiEdit :: FGetSelection(
DWORD   oln,
WORD *  pobMic,
WORD *  pobMac ) {
    BOOL    fRet = TRUE;
    DWORD   olnMin = min( m_ipAnchor.oln, m_ipCur.oln );;
    DWORD   olnMac = max( m_ipAnchor.oln, m_ipCur.oln );;

	// Column selection, special rules!
    if ( m_fColumnSelect ) {
		if ( ( olnMin <= oln && oln <= olnMac ) &&
			m_ipCur.ob != m_ipAnchor.ob
		) {
            *pobMic = min( m_ipAnchor.ob, m_ipCur.ob );
        	*pobMac = max( m_ipAnchor.ob, m_ipCur.ob ) - 1;

			// Adjust obMic and obMac if DBCS enabled so that
			// the selection doesn't cross DBCS characters
			if ( FDbcsEnabled() )
            {
				IP		ipCurSave = m_ipCur;
				int		iAdjustSave = m_iAdjustDbcs;

				m_ipCur.oln = oln;

				// If the left edge is on the second byte
				// this will adjust the selection to INCLUDE
				// it's lead byte.  This way any partial
				// characters in a selection will be included
				// in the whole
				m_ipCur.ob = *pobMic;
				AdjustDbcsCursor( -1 );
				*pobMic = m_ipCur.ob;

				// If the right edge is on a lead byte,
				// put the cursor on the character after
				// and adjust the cursor.  Then subtract
				// the added 1 back off.  This will include
				// the entire DBCS character as part of the
				// selection.  (Same as above)
				m_ipCur.ob = *pobMac + 1;
				AdjustDbcsCursor( 1 );
				*pobMac = m_ipCur.ob - 1;

				// Restore the real ipCur
				m_ipCur = ipCurSave;
				m_iAdjustDbcs = iAdjustSave;
			}
		}
		else
			fRet = FALSE;
    }

    // If the selection is only on 1 line, the selection is
    // just the limits of the anchor and cursor
    else if ( olnMin == olnMac ) {
		if ( oln != olnMin || m_ipAnchor.ob == m_ipCur.ob ) {
			fRet = FALSE;
		}
		else {
            *pobMic = min( m_ipAnchor.ob, m_ipCur.ob );
        	*pobMac = max( m_ipAnchor.ob, m_ipCur.ob ) - 1;
		}
    }

    // Else if line requested is completely inside of selection, just
    // get the whole line
    else if ( olnMin < oln && oln < olnMac ) {
        *pobMic = 0;
        *pobMac = obMax;
    }

    // Otherwise, we are selecting either the beginning portion of
    // the line or the ending portion or nothing
    else {
        PIP pipMin;
        PIP pipMac;

        // Select which ip is the min and which is the mac
        if ( olnMin == m_ipAnchor.oln ) {
            pipMin = &m_ipAnchor;
            pipMac = &m_ipCur;
        }
        else {
            pipMin = &m_ipCur;
            pipMac = &m_ipAnchor;
        }

        // If we're getting the min line of the selection, then
        // this line will have the end selected
        if ( olnMin == oln ) {
            *pobMic = pipMin->ob;
            *pobMac = obMax;
        }

        // If we're getting the mac, then the beginning is selected
        else if ( olnMac == oln && pipMac->ob ) {
            *pobMic = 0;
            *pobMac = pipMac->ob - 1;
        }

        // Not min or mac or in between, return FALSE (no selection)
        else {
            fRet = FALSE;
        }
    }

	// If the return value is TRUE and the line to check the selection
	// for is greater or equal to the number of lines in the buffer,
	// then the line is out of range, return FALSE;
	if ( fRet && oln >= CLinesInBuf() ) {
		fRet = FALSE;
	}

    return fRet;
}

/**** RedisplaySelection - update the displayed selection based on focus ***
 *                                                                         *
 *  PURPOSE: When the focus is gained or lost, redisplay the selection     *
 *           accordingly                                                   *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: RedisplaySelection() {
    DWORD   olnMin = min( m_ipAnchor.oln, m_ipCur.oln );
    DWORD   olnMac = max( m_ipAnchor.oln, m_ipCur.oln );
	WORD	obMin;
	WORD	obMac;

	if ( FGetSelection( olnMin, &obMin, &obMac ) ||
		FGetSelection( olnMac, &obMin, &obMac ) ) {
		RRC	rrc;

		GetEditRrc( TRUE, &rrc );

		// Convert selection range to visible lines
		if ( olnMin > m_pdCur.olntop ) {
			rrc.ryTop = (RY)( olnMin - m_pdCur.olntop );
		}

		if ( olnMac < m_pdCur.olntop + (DWORD)rrc.ryBottom ) {
			rrc.ryBottom = (RY)( olnMac - m_pdCur.olntop + 1 );
		}

		// Wait for a WM_PAINT!
		InvalidateRrc( &rrc );
	}
}

/**** PasteSelection - copy data from scratchpad into buffer            ****
 *                                                                         *
 *  PURPOSE: Paste data from the scratchpad into the buffer at the current *
 *           position.                                                     *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: PasteSelection() {

    // Delete the current selection
    DeleteSelection();

    // Make sure that there's something in the scratchpad and that
    // we're allowed to alter the line!

    if ( ldEMScratch.cb && !FReadOnlyBuf() ) {
        WORD    cch;
        WORD    cchPaste = ldEMScratch.cb;

        cch = CbGetLineIntoCache( m_ipCur.oln );

        // Make sure that we don't overflow the buffer
        if ( (long)( cch + cchPaste ) < (long)m_pldCur->cbMax ) {

            // If we're beyond the end of the line, just concatentate
            // the line.
            if ( m_ipCur.ob >= cch ) {
                _ftcscat( m_pldCur->prgch, ldEMScratch.prgch );
            }

            // Inserting in the line.  Move the original data over and
            // insert the copy data.
            else {
                char *  pszCur = m_pldCur->prgch + m_ipCur.ob;

                memmove( pszCur + cchPaste, pszCur, cch - m_ipCur.ob + 1 );
                memcpy( pszCur, ldEMScratch.prgch, cchPaste );
            }

            // Put the cursor at the end of the insertion and
            // remove any selection

            m_pldCur->cb += cchPaste;
            m_ipCur.ob += cchPaste;
			m_ipAnchor = m_ipCur;
            if ( !FMoveWindowToCursor(FALSE) ) {
                PaintLine( m_ipCur.oln );
                UpdateCursorPos();
            }
        }
        else {
            MessageBeep( 0 );
        }
    }
}

/**** CopySelection - copy a selection into an buffer with info         ****
 *                                                                         *
 *  PURPOSE: Copy selected text into an LD                                 *
 *                                                                         *
 *  INPUTS:                                                                *
 *		lsz		Output buffer, if null, use clipboard                      *
 *		cbMax	Max size of buffer.  If lsz == NULL and cbMax == -1, then  *
 *				return the allocated handle and don't add to clipboard     *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION: Used by WM_COPY and WM_GETTEXT.  WM_COPY pld will be   *
 *                  the scratchpad LD and WM_GETTEXT will be a temporary   *
 *                  LD which will ultimately copy the data into a lsz      *
 *                                                                         *
 ***************************************************************************/
HANDLE	CMultiEdit :: CopySelection (
char FAR *	lszOut,
size_t		cbMax ) {
	BOOL	fRetHandle = (BOOL)( cbMax == (size_t)-1L );
	HANDLE	hRet = (HANDLE)NULL;

    if ( !MEFAreIPsEqual( &m_ipAnchor, &m_ipCur ) ) {
		DWORD	olnMin;
		DWORD	olnMac;
		DWORD	olnBufMac;
        HANDLE  hMem;
		size_t	cbUsed;

		olnMin = min( m_ipAnchor.oln, m_ipCur.oln );

		// The max line may be out of range during
		// a drag operation

		// Get the number of lines in the buf.  If non-zero
		// then we want the index to the last line, not the count
		if ( olnBufMac = CLinesInBuf() ) {
			--olnBufMac;
		}

		olnMac = min(max( m_ipAnchor.oln, m_ipCur.oln ),olnBufMac);

        hMem = RealGlobalAlloc(GHND, ( olnMac - olnMin + 2 ) * cchEditMax);

        if ( hMem ) {
        	DWORD	oln = olnMin;
            LSZ     lsz = (LSZ)RealGlobalLock( hMem );
            LSZ     lszBegin = lsz;

            do {
	    		char	sz[ cchEditMax ];
    	    	WORD	obMic;
        		WORD	obMac;
				size_t	cchLine;

    			CbGetCachedLine( oln, sizeof( sz ) - 1, sz );
				cchLine = _tcslen( sz );

    	    	if ( FGetSelection( oln, &obMic, &obMac ) ) {
					// must be ">=", not ">", so that if this line has
					// just a cr/lf, we copy that to the clipboard
					if ( cchLine >= obMic ) {
	    				char *	psz;
	    				WORD	cch;

	                    if ( obMac == obMax || cchLine < obMac ||
	                    	( m_fColumnSelect && olnMin != olnMac )
	                    ) {
		                    if ( obMac == obMax || cchLine < obMac ) {
	                        	obMac = cchLine;
							}
							else {
								++obMac;
							}
	                		*( sz + obMac++ ) = '\r';
	                    	*( sz + obMac ) = '\n';
	    			    }
				    	sz[ obMac + 1 ] = '\0';

	    				psz = sz + obMic;
	                    cch = obMac + 1 - obMic;
	                    memcpy( lsz, psz, cch + 1 );
			    		lsz += cch;
					}
                }

            } while( ++oln <= olnMac );

            RealGlobalUnlock( hMem );

            // Free up space not really needed.  Should NEVER fail since
            // we are SHRINKING the Global object
			cbUsed = (size_t)( lsz - lszBegin + 1 );
            hMem = RealGlobalReAlloc( hMem, cbUsed, (UINT)NULL );

            ASSERT( hMem );

            ASSERT( ( olnMac - olnMin + 2 ) * cchEditMax >=
                (DWORD)cbUsed );

			if ( lszOut ) {
				LSZ	lszData = (LSZ)RealGlobalLock( hMem );

				_ftcsncpy( lszOut, lszData, cbMax );
				if ( cbUsed < cbMax ) {
					cbMax = cbUsed;
				}
				*( lszOut + cbMax - 1 ) = '\0';
				RealGlobalUnlock( hMem );
				RealGlobalFree( hMem );
			}
			else if ( fRetHandle ) {
				hRet = hMem;
			}
			else {
				GetDesktopWindow()->OpenClipboard();
	            EmptyClipboard();
    	        SetClipboardData( CF_TEXT, hMem );
				if (m_fColumnSelect)
					SetClipboardData(g_cfColSelect, HandleFromString(_T("C")));
			    CloseClipboard();
			}
        }
	}

	// No selection, copy the current line into the clipboard only
	// if lsz is NULL
	else if ( !lszOut && !fRetHandle ) {
		char	sz[ cchEditMax ];
		WORD	cch;
		HANDLE	hMem;

		CbGetCachedLine( m_ipCur.oln, sizeof( sz ) - 1, sz );
		if ( ( cch = _ftcslen( sz ) ) &&
			( hMem = RealGlobalAlloc( GHND, cch + 3 ) ) ) {

			LSZ	lsz = (LSZ)RealGlobalLock( hMem );

			_ftcscpy( lsz, sz );
            _ftcscat( lsz, "\r\n" );

			RealGlobalUnlock( hMem );

			GetDesktopWindow()->OpenClipboard();
			EmptyClipboard();
			SetClipboardData( CF_TEXT, hMem );
			CloseClipboard();
		}
	}

	return fRetHandle ? hRet : (HANDLE)NULL;
}

/**** DeleteSelection - delete a selection                              ****
 *                                                                         *
 *  PURPOSE: Delete a selection from the buffer.                           *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: DeleteSelection() {

	if ( !FReadOnlyBuf() ) {
	    // Make sure that there's a selection to delete!
	    if ( m_fSelection ) {
	        IP      ip = m_ipCur;
	        WORD    obMic;
	        WORD    obMac;
	        WORD    cch;

	        cch = CbGetLineIntoCache( m_ipAnchor.oln );
	        FGetSelection( m_ipAnchor.oln, &obMic, &obMac );

	        // Make sure that we're deleting REAL text
	        if ( cch > obMic ) {
	            if ( cch < obMac ) {
	                obMac = cch - 1;
	            }

	            // Make sure that we're allowed to delete here.
	            // We only check the beginning of the deletion.  To
	            // do so, we set the cursor to the beginning of the
	            // selection (the buffer owner may look at the ipCur),
	            // and then call the FReadOnlyBuf()

	            m_ipCur.oln = m_ipAnchor.oln;
	            m_ipCur.ob = obMic;

                memmove( m_pldCur->prgch + obMic, m_pldCur->prgch + obMac + 1,
                    cch - obMac + 1 );
                m_pldCur->cb -= obMac - obMic + 1;
	        }

	        // What ever happened, remove the selection and update the
	        // cursor/line as appropriate
	        m_ipAnchor = m_ipCur;

	        if ( !FMoveWindowToCursor( FALSE ) ) {
	            // Don't paint line since the wndproc will force the update
	            // Just update the cursor.
	            UpdateCursorPos();
	        }
	    }
	}
	else {
		MessageBeep( 0 );
	}
}

/**** LcbGetText - Get selected text into a buffer                      ****
 *                                                                         *
 *  PURPOSE: Copy the selected text into a buffer.                         *
 *                                                                         *
 *  INPUTS:                                                                *
 *    cchMax    Maximum size of destination buffer.                        *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *    lsz       far pointer to buffer for selection text.                  *
 *                                                                         *
 *      Return Value: Number of characters put into lsz.                   *
 *                                                                         *
 *  IMPLEMENTATION: Create a temporary LD and get the selection into it.   *
 *                  Then copy string (if there's one) accordingly.         *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
long CMultiEdit :: LcbGetText(
WORD        cchMax,
char FAR *  lsz ) {
	ASSERT( lsz );

	// Make sure that the previous selection (or junk text)
	// is destroyed so we don't return a bogus success
	*lsz = '\0';
    CopySelection( lsz, (size_t)cchMax );

    return (long)_ftcslen( lsz );
}

/**** LcbGetWord - Get the current word                                 ****
 *                                                                         *
 *  PURPOSE: Get the word which cursor is on and (optional) coordinates    *
 *           for the selection.                                            *
 *                                                                         *
 *  INPUTS:                                                                *
 *    cchMax  Maximum number of characters which can be put in lsz         *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *    lsz     far pointer to write "word" to                               *
 *    pobMic  pointer to beginning base offset of selection                *
 *    pobMac  pointer to end base offset of selection                      *
 *                                                                         *
 *      Return Value: Number of characters in lsz.                         *
 *                                                                         *
 *  IMPLEMENTATION: If pobMic (or pobMac) is non-zero, then we want the    *
 *                  word we're actually sitting on.  Otherwise, we want    *
 *                  either the word we're sitting on OR the next word on   *
 *                  the line.                                              *
 *                                                                         *
 ***************************************************************************/
long CMultiEdit :: LcbGetWord(
UINT		cchMax,
char FAR *  lsz,
WORD *      pobMic,
WORD *      pobMac ) {
    char    sz[ cchEditMax];
    char *  szPlus1 = &sz[1];
    WORD    cch;
    WORD    obMic = 0;
    WORD    obMac = 0;
    char *  pch;

    cch = CbGetCachedLine( m_ipCur.oln, sizeof( sz ) - 1, szPlus1 );

    // To get a word:
    //   1) There must be something on the line.
    //   2) The cursor must be inside the line.
    //   3) If we want the current word only and on a non-white-space
    //      character.
    //   4) pobMic and pobMac are zero then try the next word.

    if ( cch && m_ipCur.ob < cch && ( !pobMic || !pobMac ||
        !_istspace((unsigned char) *( szPlus1 + m_ipCur.ob ) ) ) ) {

        // This lets us go backwards w/o checking a counter.
        *sz = '\0';
        pch = szPlus1 + m_ipCur.ob;

        // Skip over white spaces.
        if ( _istspace((unsigned char) *pch ) ) {
            while( *pch && _istspace( (unsigned char)*pch ) ) {
                ++pch;
            }
        }

        // Not on a white space, so back up to beginning of the current word
        else if ( FIsWordChar( *pch ) ) {
            while( *( pch - 1 ) && FIsWordChar( *( pch - 1 ) ) ) {
                --pch;
            }
        }

        // If we're on at the end of the string, mark the beginning of
        // the word
        if ( *pch ) {
            obMic = (WORD)( pch - szPlus1 );
        }

        // Now find the end of the word.
        while( *pch && FIsWordChar( *pch ) ) {
            ++pch;
        }

        // mark the end
        obMac = pch - szPlus1;

        // Put a zero after the word so we can do a _ftcsncpy with
        // a max value of the lsz buffer max.
        *pch = '\0';
        _ftcsncpy( lsz, szPlus1 + obMic, cchMax );

        // If the buffer's too small, put a zero at its end and
        // adjust obMic and obMac so that the return value is cchMax
		if ( (UINT) (obMac - obMic) >= cchMax ) {
            *( lsz + cchMax - 1 ) = '\0';
            obMic = 0;
            obMac = cchMax;
        }
    }

    // Don't update the data if we've go no where to put it
    if ( pobMic ) {
        *pobMic = obMic;
    }
    if ( pobMac ) {
        *pobMac = obMac;
    }

    return (long)( obMac - obMic );
}

/**** GetWordAtPostion - Given a line number and column no, get the     ****
 *                       get the word at that position                     *
 *                                                                         *
 ***************************************************************************/

 // FUTURE : This function is very similar to LcbGetWord, except for the weird meaning
 // of the pobMic and pobMac being passed in as NULL to LcbGetWord, which I don't understand
 // We should just make LcbGetWowrd call GetWordAtPosition [ sanjays ].

 BOOL CMultiEdit::GetWordAtPosition(
 WORD ob,
 DWORD oln,
 LPSTR lsz,
 UINT cchMax,
 WORD *pobMic,
 WORD *pobMac ) {
	char sz[cchEditMax];
	char *szPlus1 = &sz[1];
	WORD cch;
	WORD obMic = 0;
	WORD obMac = 0;
	char *pch;

	cch = CbGetCachedLine(oln, sizeof(sz) - 1, szPlus1);

	if (cch && !_istspace((unsigned char)* (szPlus1 + ob ))) {
		
		// This lets us go backwards w/o checking a counter.
		*sz = '\0';
		pch = szPlus1 + ob;
		
		if ( FIsWordChar ( *pch ) ) {
			while ( *(pch - 1) && FIsWordChar( *( pch - 1 ) ) ) {
				--pch ;
			}
		}

        // If we're on at the end of the string, mark the beginning of
        // the word
        if ( *pch ) {
            obMic = (WORD)( pch - szPlus1 );
        }

        // Now find the end of the word.
        while( *pch && FIsWordChar( *pch ) ) {
            ++pch;
        }

        // mark the end
        obMac = pch - szPlus1;

        // Put a zero after the word so we can do a _ftcsncpy with
        // a max value of the lsz buffer max.
        *pch = '\0';
        _ftcsncpy( lsz, szPlus1 + obMic, cchMax );

        // If the buffer's too small, put a zero at its end and
        // adjust obMic and obMac so that the return value is cchMax
		if ( (UINT) (obMac - obMic) >= cchMax ) {
            *( lsz + cchMax - 1 ) = '\0';
            obMic = 0;
            obMac = cchMax;
        }
    }

    // Don't update the data if we've go no where to put it
    if ( pobMic ) {
        *pobMic = obMic;
    }
    if ( pobMac ) {
        *pobMac = obMac;
    }

    return (( obMac - obMic ) != 0);
}


 	
/**** UpdateAnchor - Update the anchor to new cursor position           ****
 *                                                                         *
 *  PURPOSE: This function is just to shrink code.  This will be done      *
 *           a lot.  We don't want to update if the shift key was down.    *
 *                                                                         *
 *  INPUTS:                                                                *
 *    lParam   long arg for WM_CHAR and mouse messages.  Contains shift    *
 *             key state.                                                  *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: UpdateAnchor(
long   lParam ) {

    if ( !( HIWORD( lParam ) & KK_SHIFT ) ) {
	    m_ipAnchor = m_ipCur;
		m_fColumnSelect = FALSE;
    }

	// Update the selection status
	m_fSelection = !MEFAreIPsEqual( &m_ipAnchor, &m_ipCur );

    // If we haven't initialized m_ipAnchorOld and m_ipCurOld do it
    // and don't bother trying to repaing non-existant selections.  Otherwise,
    // we need to repaint if there was an old selection or there is a new selection

    if ( m_ipAnchorOld.ob != 0xffff &&
    	( !MEFAreIPsEqual( &m_ipAnchorOld, &m_ipCurOld ) ||
    	m_fSelection )
    ) {

    	DWORD	olnSelMin;
	    DWORD	olnSelMac;
    	RRC		rrc;
		RY		ryBottomOld;

		// If the anchor didn't change, then only need to repaint
		// the lines from the old cursor to the new cursor
		olnSelMin = min( m_ipCur.oln, m_ipCurOld.oln );
		olnSelMac = max( m_ipCur.oln, m_ipCurOld.oln );

		// If the anchor changed, then we need to include the old
		// anchor range in the repaint range
		if ( !MEFAreIPsEqual( &m_ipAnchor, &m_ipAnchorOld ) ||
			( m_fColumnSelect && m_ipCur.ob != m_ipCurOld.ob )
		) {
			olnSelMin = min( min( olnSelMin, m_ipAnchor.oln ), m_ipAnchorOld.oln );
			olnSelMac = max( max( olnSelMac, m_ipAnchor.oln ), m_ipAnchorOld.oln );
		}

    	GetEditRrc( TRUE, &rrc );
		ryBottomOld = rrc.ryBottom;

		// Convert the line numbers to window rrc coordinates IF
		// they are still visible w/i the window
	    if ( olnSelMin > m_pdCur.olntop &&
			olnSelMin < m_pdCur.olntop + ryBottomOld
		) {
		   	rrc.ryTop = (RY)( olnSelMin - m_pdCur.olntop );
    	}

		if ( m_pdCur.olntop <= olnSelMac &&
			olnSelMac < m_pdCur.olntop + ryBottomOld + 1
		) {
			rrc.ryBottom = (RY)( olnSelMac - m_pdCur.olntop + 1 );
			if ( rrc.ryBottom > ryBottomOld ) {
	    		rrc.ryBottom = ryBottomOld;
		    }
		}

		// Finally, repaint the old garbage
    	Paint( &rrc, NULL );
    }
    m_ipAnchorOld = m_ipAnchor;
    m_ipCurOld = m_ipCur;
}

/**** CbGetCachedLine - Get a line from callback with cache override    ****
 *                                                                         *
 *  PURPOSE: Get a specific line from the buffer.  If the line requested   *
 *           line is cached, return the cached version and by-pass the     *
 *           callback to the owner of the buffer.                          *
 *                                                                         *
 *  INPUTS:                                                                *
 *     oln      Line number to get                                         *
 *     cchMax   Maximum number of characters in the destination buffer,    *
 *				not including the trailing \0							   *			
 *                                                                         *
 *  OUTPUTS:                                                               *
 *     sz       Pointer to buffer for string.                              *
 *                                                                         *
 *      Return Value: Number of characters in the returned(filled) buffer. *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
WORD CMultiEdit :: CbGetCachedLine(
DWORD   oln,
WORD    cchMax,
char *  sz ) {
    WORD    cch = 0;

#ifdef DEBUG
	sz[cchMax] = '\0';  // Make sure the buffer is big enough.
#endif

    // Only get cached line if the buffer is cached and the requested line
    // is the cached one.
    if ( m_pldCur->flags && oln == m_pdCur.oln ) {
        _ftcscpy( sz, m_pldCur->prgch );
        cch = m_pldCur->cb;
    }
    else if ( oln < CLinesInBuf() ) {
		PDLA	pdla;

        cch = CbGetLineBuf( oln, cchMax, sz, pdla );
    }
	else {
		*sz = '\0';
		cch = 0;
	}

    return cch;
}

/**** CbGetLineIntoCache - Get a line and put into cache for edit       ****
 *                                                                         *
 *  PURPOSE: Copy the requested line into the cache                        *
 *                                                                         *
 *  INPUTS:                                                                *
 *     oln  Line number to put into cache.                                 *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: Number of characters in cached line                  *
 *                                                                         *
 *  IMPLEMENTATION: If there's a cached line already, return the _ftcslen. *
 *                  If not, cache the line.                                *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
WORD CMultiEdit :: CbGetLineIntoCache(
DWORD    oln ) {
    WORD    cch = 0;

    if ( !m_pldCur->flags ) {
		PDLA	pdla;

        cch = CbGetLineBuf( oln, m_pldCur->cbMax, m_pldCur->prgch, pdla );
        m_pldCur->flags = TRUE;
        m_pldCur->cb = cch;
        m_pdCur.oln = oln;
    }
    else {
        cch = m_pldCur->cb;
    }

    return cch;
}

/**** FlushCache - Flush the cached/edited line                         ****
 *                                                                         *
 *  PURPOSE: Flush the cache.  If there is one.  Notify the owner of the   *
 *           the buffer that its contents have changed and clear out the   *
 *           cache info.                                                   *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: FlushCache() {
    if ( m_pldCur->flags && m_pdCur.oln != olnMax ) {
        DWORD    olnCache;

        FReplaceLineBuf( m_pdCur.oln, m_pldCur->cb,
           m_pldCur->prgch );

        m_pldCur->flags = FALSE;
        m_pldCur->cb = 0;
        *m_pldCur->prgch = '\0';
        olnCache = m_pdCur.oln;
        m_pdCur.oln = olnMax;

        // Repaint the line (the owner may have different attributes!
        PaintLine( olnCache );
    }
}

/**** GetEditRrc - Get the bounding rrc for the current window          ****
 *                                                                         *
 *  PURPOSE: Return the bounding rectanngle for the current edit window.   *
 *                                                                         *
 *  INPUTS:                                                                *
 *     fAll TRUE = Get EditRrc for entire window, FALSE = Get area where   *
 *          cursor positions are valid                                     *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *     prrc  -  rectangle is filled with bounding RRC for window           *
 *                                                                         *
 *      Return Value: None                                                 *
 *                                                                         *
 *  IMPLEMENTATION: There is a CLOSE match between this and GetClientRrc() *
 *                  but we completely ignore the WS_ flags since we KNOW   *
 *                  that the window is NOT obscurred by a scrollbar.       *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void
CMultiEdit::GetEditRrc(
	BOOL    fAll,
	PRRC    prrc
	)
{
    RECT    rect;

    GetClientRect( &rect );

	rect.right -= m_cxSelectMargin;

	// The right and bottom may be less than the
	// left and top if the scroll bars are wider than
	// the window is wide/high.  If so, adjust so the
	// values are zero not negative

	if ( rect.right < rect.left ) {
		rect.right = rect.left;
	}

	if ( rect.bottom < rect.top ) {
		rect.bottom = rect.top;
	}

	int tmAveCharWidth = m_pFontInfo->m_tm.tmAveCharWidth;
	int tmHeight = m_pFontInfo->m_tm.tmHeight;

    prrc->rxLeft = 0;
	prrc->rxRight = (RX)( ( rect.right - rect.left ) / tmAveCharWidth ) + 1;
    prrc->ryTop = 0;
    prrc->ryBottom = (RY)( ( rect.bottom - rect.top ) / tmHeight ) + 1;

    if ( !fAll ) {
		if ( prrc->rxRight * tmAveCharWidth > rect.right ) {
			--prrc->rxRight;
		}
    	if ( prrc->ryBottom * tmHeight > rect.bottom ) {
        	--prrc->ryBottom;
		}
    }
}


/**** DrawAttrText - Draw a single line of text with attributes         ****
 *                                                                         *
 *  PURPOSE: Draw a specific line of the window with passed in attributes. *
 *                                                                         *
 *  INPUTS:                                                                *
 *    pdc      Device context for drawing                                  *
 *    fActive  Does the window have the focus?                             *
 *    oln      Line number being painted (for selection)                   *
 *    sz       String to display                                           *
 *    cch      Strlen of sz                                                *
 *    cchSzMax sizeof(sz)                                                  *
 *    pdla     pointer to first element of LINE_ATTRIBUTE information      *
 *    ry       Relative "y" position to display text at.                   *
 *    rxMax    Number of chars which are visible per line.  This is done   *
 *             by caller to avoid overhead of GetEditRrc for each painted  *
 *             line.                                                       *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: Node.                                                *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: DrawAttrText(
CDC *	pdc,
BOOL	fActive,
DWORD	oln,
char *  sz,
WORD    cch,
WORD	cchSzMax,
PDLA    pdla,
RY		ry,
WORD    rxMax ) {
	RX	    	rx;
	RX	    	rxMin;
	WORD    	cchAttr;
	char *  	szEnd;
	WORD    	cchLine;
	WORD    	obSelMic;
	WORD    	obSelMac;
	BOOL    	fSel;
	char *  	szBegin = sz;
	int			rxPaint;
	CBrush		brush;
	LOGBRUSH	lgbr;
	RECT		rectClient;
	int			tmHeight = m_pFontInfo->m_tm.tmHeight;
	int			tmAveCharWidth = m_pFontInfo->m_tm.tmAveCharWidth;

	GetClientRect( &rectClient );
	rectClient.left += m_cxSelectMargin;

	rx = 0;
	rxMin = (RX)m_pdCur.obleft;

	lgbr.lbStyle = BS_SOLID;
	FMT_ELEMENT *rgfmtel = pfmtelFromDocType(m_dt);

	lgbr.lbColor = rgfmtel[FMTEL_TEXT].rgbBackground;
	lgbr.lbHatch = 0L;
	brush.CreateBrushIndirect( &lgbr );

	// Clear out the margin
	if ( m_cxSelectMargin ) {
		RECT	rect;

		rect.left =  0;
		rect.right = m_cxSelectMargin;
		rect.top = ry * tmHeight;
		rect.bottom = rect.top + tmHeight;

		pdc->FillRect( &rect, &brush );
	}

	// Clear out the trailing portion of the line which is out of the
	// line limit length
	if ( ( cchLine = rxMax + rxMin ) > cchSzMax ) {
		RECT	rect;

		rect.left =  ( rxMax - rxMin ) * tmAveCharWidth;
		rect.right = rxMax * tmAveCharWidth;
		rect.top = ry * tmHeight;
		rect.bottom = rect.top + tmHeight;

		pdc->FillRect( &rect, &brush );

		cchLine = cchSzMax;
	}

	brush.DeleteObject();

	// Pad string with spaces up.  This is done so the end of the
	// line gets "filled" with spaces

	if ( cch < cchLine ) {
		memset( sz + cch, ' ', cchLine - cch + 1 );
	}

	// Zero terminate the string at the last visible character for the line
	sz[ cchLine ] = '\0';

	// Skip over attributes which are clipped by the left border et al
	// and set the cchAttr to be the amount left over (still visible)
	cchAttr = pdla->cb;

	rxPaint = -(int)m_pdCur.obleft;

	// Reset the base (left margin) to the beginning
	// since we will let windows clip
	rxMin = 0;
	szEnd = sz + cchLine;
	sz += rxMin;

	// Get the selection range( don't paint selections if we're not
	// active
	fSel = fActive && FGetSelection( oln, &obSelMic, &obSelMac );

	// The obSelMac is the end point (inclusive).  If it is not
	// obMax, increment it so it is just beyond the endpoint
	if ( obSelMac != obMax ) {
		++obSelMac;
	}

	while( sz < szEnd ) {
		WORD cchT = cchAttr;

		if ( cchT == obMax ) {
			cchT = _ftcslen( sz );
		}

		if ( fSel ) {
			WORD    obAttrMic = sz - szBegin;
			WORD    obAttrMac = sz - szBegin;

			// If the cch is obMax set it to the real end of the string
			if ( cchAttr == obMax ) {
				obAttrMac += cchT;
			}

			// Otherwise, set it to the end of the portion with the
			// attribute
			else {
				obAttrMac += cchAttr;
			}

			// Selection not part of this portion, just display it
			if ( obAttrMic > obSelMac || obAttrMac < obSelMic ) {
				pdc->SetTextColor(pdla->pElement->rgbText);
				pdc->SetBkColor(pdla->pElement->rgbBackground);

				pdc->ExtTextOut(
					rxPaint * tmAveCharWidth + m_cxSelectMargin,
					ry * tmHeight,
					ETO_CLIPPED,
					&rectClient,
					sz,
					cchT,
					NULL
				);
			}
			else {
				WORD    db;
				int     rxT = rxPaint;
				char *  szT = sz;

				// Possible regular display before selection
				if ( obAttrMic < obSelMic ) {
					db = min( obAttrMac, obSelMic ) - obAttrMic;

					pdc->SetTextColor(pdla->pElement->rgbText);
					pdc->SetBkColor(pdla->pElement->rgbBackground);

					pdc->ExtTextOut(
						rxT * tmAveCharWidth + m_cxSelectMargin,
						ry * tmHeight,
						ETO_CLIPPED,
						&rectClient,
						szT,
						db,
						NULL
					);

					szT += db;
					rxT += db;
					obAttrMic += db;
				}

				// Selection
				if ( obSelMic < obAttrMac ) {
					db = min( obSelMac, obAttrMac ) - obAttrMic;
					pdc->SetTextColor(rgfmtel[FMTEL_SELC].rgbText);
					pdc->SetBkColor(rgfmtel[FMTEL_SELC].rgbBackground);

					pdc->ExtTextOut(
						rxT * tmAveCharWidth + m_cxSelectMargin,
						ry * tmHeight,
						ETO_CLIPPED,
						&rectClient,
						szT,
						db,
						NULL
					);

					szT += db;
					rxT += db;
					obAttrMic += db;
				}

				// Ending portion (regular)
				if ( obSelMac < obAttrMac ) {
					db = obAttrMac - obAttrMic;

					pdc->SetTextColor(pdla->pElement->rgbText);
					pdc->SetBkColor(pdla->pElement->rgbBackground);

					pdc->ExtTextOut(
						rxT * tmAveCharWidth + m_cxSelectMargin,
						ry * tmHeight,
						ETO_CLIPPED,
						&rectClient,
						szT,
						db,
						NULL
					);
				}
			}
		}
		else {
			// No selection on this line, just regular output
			pdc->SetTextColor(pdla->pElement->rgbText);
			pdc->SetBkColor(pdla->pElement->rgbBackground);

			pdc->ExtTextOut(
				rxPaint * tmAveCharWidth + m_cxSelectMargin,
				ry * tmHeight,
				ETO_CLIPPED,
				&rectClient,
				sz,
				cchT,
				NULL
			);
		}

		// If there's more, update position, string, and attribute info
		if ( cchAttr <= cch ) {
			rxPaint += (int)cchT;
			if ( cchAttr == obMax ) {
				sz = szEnd;
			}
			else {
				sz += cchAttr;
			}
			++pdla;
			cchAttr = pdla->cb;
		}

		// Othewise, get out
		else {
			sz = szEnd;
		}
    }
}

/****UpdateCursorPos - Move the cursor to the current location          ****
 *                                                                         *
 *  PURPOSE: Move the cursor to the current location, provided to make     *
 *           code SMALLER!                                                 *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: UpdateCursorPos() {
    if ( !( m_Style & ES_NOREDRAW ) && FIsActiveWindow( m_hWnd ) ) {
		POINT	pt;

		pt.x =
			(int)( m_ipCur.ob - m_pdCur.obleft ) * m_pFontInfo->m_tm.tmAveCharWidth + m_cxSelectMargin;

		pt.y =
            (int)( m_ipCur.oln - m_pdCur.olntop ) * m_pFontInfo->m_tm.tmHeight;

        SetCaretPos( pt );

		imeMoveConvertWin( m_hWnd, pt.x, pt.y );
    }
}

/**** FMoveWindowToCursor - Scroll Window if necessary                  ****
 *                                                                         *
 *  PURPOSE: To ensure that cursor is contained within a window.  If the   *
 *           cursor has been moved outside the visible rrc of the window,  *
 *           position the WINDOW so that the cursor is at the closest      *
 *           border to where is was scrolled and that the text is moved    *
 *           appropriately.  Otherwise, just position the cursor.          *
 *                                                                         *
 *  INPUTS:                                                                *
 *      fKeepAnchor If TRUE pass KK_SHIFT to scroll routines to keep the   *
 *                  anchor from being reset                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: TRUE if the window was scrolled/repainted, else FALSE*
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
BOOL CMultiEdit :: FMoveWindowToCursor(
BOOL    fKeepAnchor ) {
    RRC     rrc;
    BOOL    fUpdate = TRUE;
    BOOL    fScrolled = FALSE;
    long    lParam = ( fKeepAnchor ? MAKELONG( 0, KK_SHIFT ) : 0L );

    GetEditRrc( FALSE, &rrc );

	// If the bottom line is zero, then the window is displaying part
	// of 1 line.  To ensure that we don't scroll (erroneously), set
	// the window height to 1
	if ( !rrc.ryBottom ) {
		++rrc.ryBottom;
	}

    // Scrolled off of the LEFT border
    if ( m_ipCur.ob < m_pdCur.obleft ) {
        m_pdCur.obleft = m_ipCur.ob;
    }

    // Cursor off of RIGHT
    else if ( m_ipCur.ob > m_pdCur.obleft + (WORD)rrc.rxRight - 1 ) {
        m_pdCur.obleft = 1 + m_ipCur.ob - (WORD)rrc.rxRight;
    }

    // Cursor scrolled 1 line UP, so be smart and do a real scroll
    else if ( m_ipCur.oln + 1 == m_pdCur.olntop ) {
        VScroll( SB_LINEUP, lParam );
        fUpdate = FALSE;
        fScrolled = TRUE;
    }

    // Cursor way off (>1 line) TOP, reposition
    else if ( m_ipCur.oln < m_pdCur.olntop ) {
        m_pdCur.olntop = m_ipCur.oln;
    }

    // Cursor scrolled 1 line DOWN, be smart...
    else if ( m_ipCur.oln == m_pdCur.olntop + (WORD)rrc.ryBottom ) {
        VScroll( SB_LINEDOWN, lParam );
        fUpdate = FALSE;
        fScrolled = TRUE;
    }

    // Cursor way off(>1 line) DOWN, reposition
    else if ( m_ipCur.oln > m_pdCur.olntop + (WORD)rrc.ryBottom - 1 ) {
        m_pdCur.olntop = 1 + m_ipCur.oln - (WORD)rrc.ryBottom;
    }

    // Cursor somewhere on screen, don't repaint anything!
    else {
        fUpdate = FALSE;
    }

    // If fUpdate then we must do a repaint of the screen
    if ( fUpdate ) {
        Paint( (PRRC)0, NULL );
    }

    // Always reposition the cursor (inexpensive, so why not!)
    UpdateCursorPos();

    return fUpdate || fScrolled;
}

/**** ValidateCursor - Move cursor into client area if outside          ****
 *                                                                         *
 *  PURPOSE: Make sure that cursor has not "moved" off of rrc when we      *
 *           we paint.  This may have happened by resizing the window.     *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION: Pretty lame.                                           *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: ValidateCursor() {
    RRC     rrc;
    DWORD   olntop = m_pdCur.olntop;
    WORD    obLeft = (WORD)m_pdCur.obleft;
    BOOL    fUpdate = FALSE;

    GetEditRrc( FALSE, &rrc );

    if ( m_ipCur.oln > olntop + (DWORD)rrc.ryBottom ) {
        m_ipCur.oln = olntop;
        fUpdate = TRUE;
    }

    if ( (WORD)m_ipCur.ob > obLeft + (WORD)rrc.rxRight ) {
        m_ipCur.ob = obLeft;
        fUpdate = TRUE;
    }

    if ( fUpdate ) {
		// Throw out the selection
		UpdateAnchor( 0L );

        UpdateCursorPos();
    }
}

/**** Paint - Draw a window                                             ****
 *                                                                         *
 *  PURPOSE: Paint the whole or a part of the current window.              *
 *                                                                         *
 *  INPUTS:                                                                *
 *      prrc   If non-null, specifies which part of the window to repaint. *
 *             Else, paint the whole window.                               *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: Number of lines in the buffer (CLinesInBuf())        *
 *                                                                         *
 *  IMPLEMENTATION: Fairly straight foward                                 *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
DWORD CMultiEdit :: Paint(
PRRC    prrc,
CDC *   pdc ) {
    DWORD   cLineMax;
    DWORD   dyWin;
    WORD    dxWin;
    DWORD   iln;
    char *   sz;
    DLA     dla;
    PDLA    pdla;
    RY	    ry;
    RY	    ryTop;
    RRC     rrc;
    DWORD   olnMac = CLinesInBuf();
    BOOL    fCached = m_pldCur->flags;
    WORD    cch;
    DWORD   olnAnchor = m_ipAnchor.oln;
    BOOL	fActive = FIsActiveWindow( m_hWnd );
    BOOL    fReleaseDC = FALSE;
	BOOL	fShowSel;
	WORD	cbsz;
	FMT_ELEMENT *rgfmtel = pfmtelFromDocType(m_dt);

	sz = (char *)alloca( cbsz = max( cchEditMax + 2, WinWidth() + 2 ) );

	fShowSel = fActive;

    if ( !( m_Style & ES_NOREDRAW ) ) {
        if ( !pdc ) {
            pdc = GetDC();
            fReleaseDC = TRUE;
        }

		pdc->SelectObject( m_pFontInfo->m_hFont );

        if ( fActive ) {
            HideCaret();
        }

        GetEditRrc( TRUE, &rrc );

        ++rrc.ryBottom;

        ++rrc.rxRight;

		  // For DBCS builds, we want to paint an extra
		  // character to ensure that a clipped DBCS character
		  // gets the non-clipped portion correct
        dxWin = (WORD)rrc.rxRight + 1;

        iln = m_pdCur.olntop;

        if ( prrc ) {
            ry = prrc->ryTop;
            dyWin = prrc->ryBottom - ry;
            iln += prrc->ryTop;
        }
        else {
            ry = 0;
            dyWin = (WORD)rrc.ryBottom;
        }
        ryTop = ry;

        cLineMax = min( olnMac, iln + dyWin );

        for( ; iln < cLineMax; ++iln, ++ry ) {
			RECT	rect;

			// If the display line is cached, create
			// an attribute for it
		    if ( fCached && iln == m_pdCur.oln ) {
                _ftcscpy( sz, m_pldCur->prgch );
                cch = m_pldCur->cb;
			  	dla.pElement = &(rgfmtel[FMTEL_TEXT]);
                dla.cb = obMax;
                pdla = &dla;
            }
            else {
                *sz = '\0';
                CbGetLineBuf( iln, cbsz, sz, pdla );
                cch = _ftcslen( sz );
            }
            DrawAttrText( pdc, fShowSel, iln, sz, cch, cbsz, pdla, ry, dxWin );

			rect.left = 0;
			rect.right = rect.left + m_cxSelectMargin;
			rect.top = ry * m_pFontInfo->m_tm.tmHeight;
			rect.bottom = rect.top + m_pFontInfo->m_tm.tmHeight;
			DrawLineGraphics( pdc, rect, iln );
		}

        // We may need to fill in the bottom of the window since the
        // text does not fill the window up.
        rrc.ryTop = (RY)ry;
        rrc.ryBottom = ryTop + (RY)dyWin ;
        if ( rrc.ryBottom - rrc.ryTop ) {
              RECT      rect;
              LOGBRUSH  lgbr;
			  CBrush	brush;

			  lgbr.lbStyle = BS_SOLID;
			  lgbr.lbColor = rgfmtel[FMTEL_TEXT].rgbBackground;
			  lgbr.lbHatch = 0L;

              brush.CreateBrushIndirect( &lgbr );

              rect.left = 0;
              rect.right = rrc.rxRight * m_pFontInfo->m_tm.tmAveCharWidth + m_cxSelectMargin;
              rect.top = rrc.ryTop * m_pFontInfo->m_tm.tmHeight;
              rect.bottom = ( rrc.ryBottom + 1 ) * m_pFontInfo->m_tm.tmHeight;
              pdc->FillRect( &rect, &brush );

              brush.DeleteObject();
        }


        ValidateCursor();

        if ( fActive ) {
            ShowCaret();
        }

        if ( fReleaseDC ) {
            ReleaseDC( pdc );
        }
    }
    return olnMac;
}

/**** VScroll - Perform VERTICAL scrolling                              ****
 *                                                                         *
 *  PURPOSE: Perform VERTICAL window scrolling                             *
 *                                                                         *
 *  INPUTS:                                                                *
 *     wScrollType  Type of scroll to perform                              *
 *     lParam       Scroll specific information (ala CW spec)              *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: VScroll(
UINT   wScrollType,
long   lParam ) {
    WORD    dyWin;
    WORD    dxWin;
    RRC     rrc;
    DWORD   olnMac = CLinesInBuf();
	RECT	r;

	GetClientRect ( &r );
    GetEditRrc( FALSE, &rrc );
    dyWin = max( (WORD)rrc.ryBottom, 1 );
    dxWin = (WORD)rrc.rxRight;

    switch( wScrollType ) {
        case SB_LINEUP:
            if ( m_pdCur.olntop ) {
				BOOL	fUpdateAnchor = FALSE;

                --m_pdCur.olntop;

                // If the cursor is now below the bottom of the
                // screen, move it to the bottom-most visible line
                if ( m_pdCur.olntop + (DWORD)dyWin == m_ipCur.oln ) {
                    --m_ipCur.oln;
					fUpdateAnchor = TRUE;
                }

				ScrollWindow( 0, m_pFontInfo->m_tm.tmHeight, NULL, NULL );
				AdjustDbcsCursor( m_iAdjustDbcs );
                UpdateCursorPos();
				if ( fUpdateAnchor ) {
					UpdateAnchor( 0L );
				}
                UpdateWindow();
            }
            break;

        case SB_LINEDOWN:

            // Make sure that we keep the buffer full by not
            // scrolling the last line from the bottom (unless
            // the window is larger in height than the file!
            if ( m_pdCur.olntop + 1L < CLinesInBuf() ) {
				BOOL	fUpdateAnchor = FALSE;

                ++m_pdCur.olntop;
                if ( m_pdCur.olntop - 1 == m_ipCur.oln ) {
                    ++m_ipCur.oln;
					fUpdateAnchor = TRUE;
                }
				ScrollWindow( 0, -m_pFontInfo->m_tm.tmHeight, NULL, NULL );
				AdjustDbcsCursor( m_iAdjustDbcs );
                UpdateCursorPos();
				if ( fUpdateAnchor ) {
					UpdateAnchor( 0L );
				}
                UpdateWindow();
            }
            break;

        case SB_PAGEUP: {
            DWORD   olntopNew;

            if ( m_pdCur.olntop <= (DWORD)dyWin ) {
                olntopNew = 0;
                m_ipCur.oln -= m_pdCur.olntop;
            }
            else {
				--dyWin;
                olntopNew = m_pdCur.olntop - (DWORD)dyWin;
                m_ipCur.oln -= (DWORD)dyWin;
            }
            m_pdCur.olntop = olntopNew;
			AdjustDbcsCursor( m_iAdjustDbcs );
            UpdateAnchor( lParam );
			if ( !FMoveWindowToCursor( TRUE ) ) {
            	Paint( (PRRC)0, NULL );
			}
            break;
        }

        case SB_PAGEDOWN: {
            DWORD   olntopNew;
            BOOL    fUpdate = FALSE;

            // We want to keep the cursor in the same
            // position within the window after the pagedown.
            if ( m_pdCur.olntop + (DWORD)dyWin < olnMac ) {
                olntopNew = m_pdCur.olntop + (DWORD)dyWin - 1;
				m_ipCur.oln += (DWORD)dyWin - 1;
				if ( m_ipCur.oln >= olnMac ) {
					m_ipCur.oln = olnMac - 1;
				}
                fUpdate = TRUE;
            }

			// If the page down causes us to go beyond the
			// end of file, position the cursor on the last
			// line of the file (WinWord 2.0 style).
			else if ( m_ipCur.oln != olnMac - 1 ) {
				olntopNew = m_pdCur.olntop;
				m_ipCur.oln = olnMac - 1;
				fUpdate = TRUE;
			}

            // Don't repaint if they pagedown'ed when already at the bottom
            if ( fUpdate ) {
                m_pdCur.olntop = olntopNew;
				AdjustDbcsCursor( m_iAdjustDbcs );
            	UpdateAnchor( lParam );
				if ( !FMoveWindowToCursor( TRUE ) ) {
    	        	Paint( (PRRC)0, NULL );
				}
            }
            break;
        }

        case SB_THUMBPOSITION:
			if (
				lParam <= (long)ScrollFromOln ( olnMac  ) &&
				lParam != (long)ScrollFromOln ( m_pdCur.olntop )
			) {
				m_ipCur.oln =
					OlnFromScrollPos ( (short)LOWORD( lParam ) ) +
					( m_ipCur.oln - m_pdCur.olntop );
                m_pdCur.olntop = OlnFromScrollPos ( (short)LOWORD( lParam ) );

				AdjustDbcsCursor( m_iAdjustDbcs );
				UpdateAnchor( 0L );
				if ( !FMoveWindowToCursor( FALSE ) ) {
	            	Paint( (PRRC)0, NULL );
				}
			}
            break;

        case SB_TOP:
            m_ipCur.oln = 0;
            m_pdCur.olntop = 0;
			AdjustDbcsCursor( m_iAdjustDbcs );
            UpdateAnchor( lParam );
			if ( !FMoveWindowToCursor( TRUE ) ) {
            	Paint( (PRRC)0, NULL );
			}
            break;

        case SB_BOTTOM: {
            WORD    dyCursor = (WORD)( m_ipCur.oln - m_pdCur.olntop );

            // We want to put the last line of the buffer at the
            // bottom of the window

            // If the whole file fits in the window, set the
            // top of the window to be the top of the file.
            if ( olnMac < (DWORD)dyWin ) {
               dyWin = LOWORD( olnMac );
            }
            m_pdCur.olntop = olnMac - (DWORD)dyWin;
            m_ipCur.oln = olnMac - 1;
			AdjustDbcsCursor( m_iAdjustDbcs );
            UpdateAnchor( lParam );
			if ( !FMoveWindowToCursor( TRUE ) ) {
            	Paint( (PRRC)0, NULL );
			}
            break;
        }
    }
}

/**** HScroll - Perform HORIZONTAL scrolling                            ****
 *                                                                         *
 *  PURPOSE: Perform HORIZONTAL window scrolling                           *
 *                                                                         *
 *  INPUTS:                                                                *
 *     wScrollType  Type of scroll to perform                              *
 *     lParam       Scroll specific information (ala CW spec)              *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: HScroll(
UINT   wScrollType,
long   lParam ) {
    WORD    dxWin;
    RRC     rrc;
	DWORD	olnMac = CLinesInBuf();
	char	sz[ cchEditMax ];
	WORD	cch;

    GetEditRrc( TRUE, &rrc );
    dxWin = (WORD)rrc.rxRight;

	CbGetCachedLine ( m_ipCur.oln, sizeof ( sz ) - 1, sz );
	cch = ObMaxBuf();

    switch( wScrollType ) {
        case SB_LINEUP:
            if ( m_pdCur.obleft ) {
                --m_pdCur.obleft;
                if ( m_pdCur.obleft + dxWin == m_ipCur.ob ) {
                    --m_ipCur.ob;
					AdjustDbcsCursor( -1 );
                }
                UpdateCursorPos();
                UpdateAnchor( lParam );
                Paint( (PRRC)0, NULL );
            }
            break;

        case SB_LINEDOWN:
			if ( m_pdCur.obleft + dxWin <= cch ) {
                ++m_pdCur.obleft;
                if ( m_pdCur.obleft - 1 == m_ipCur.ob ) {
                    ++m_ipCur.ob;
					AdjustDbcsCursor( 1 );
                }
                UpdateCursorPos();
                UpdateAnchor( lParam );
                Paint( (PRRC)0, NULL );
            }
            break;

        case SB_PAGEUP: {
            WORD    obleftNew;

            if ( m_pdCur.obleft <= dxWin ) {
                obleftNew = 0;
                m_ipCur.ob -= m_pdCur.obleft;
            }
            else {
                obleftNew = m_pdCur.obleft - dxWin;
                m_ipCur.ob -= dxWin;
            }
            m_pdCur.obleft = obleftNew;
			AdjustDbcsCursor( -1 );
            UpdateAnchor( lParam );
			if ( !FMoveWindowToCursor( TRUE ) ) {
				Paint( (PRRC)0, NULL );
			}
            break;
        }

        case SB_PAGEDOWN: {
            WORD    obleftNew;

            if ( m_pdCur.obleft + ( dxWin << 1 ) < cch ) {
                obleftNew = m_pdCur.obleft + dxWin;
                m_ipCur.ob += dxWin;
            }
            else if ( m_pdCur.obleft + dxWin < cch ) {
                obleftNew = cch - dxWin + 1;
                m_ipCur.ob -= m_pdCur.obleft - obleftNew;
            }
			else {
				// If the display is empty, put the cursor at the top(left edge)
				if ( cch <= 1 ) {
					cch = 1;
				}
	            obleftNew = m_ipCur.ob = cch - 1;
			}

			m_pdCur.obleft = obleftNew;
			AdjustDbcsCursor( 1 );
			UpdateAnchor( lParam );
			if ( !FMoveWindowToCursor( TRUE ) ) {
				Paint( (PRRC)0, NULL );
			}
            break;
        }

        case SB_THUMBPOSITION:
            if ( LOWORD( lParam ) <= cch - 1 ) {
	            m_pdCur.obleft = m_ipCur.ob = LOWORD( lParam );
				AdjustDbcsCursor( m_iAdjustDbcs );
				UpdateAnchor( lParam );
				if ( !FMoveWindowToCursor( TRUE ) ) {
					Paint( (PRRC)0, NULL );
				}
            }
            break;

        case SB_TOP:
            m_ipCur.ob = 0;
            m_pdCur.obleft = 0;
            UpdateAnchor( lParam );
            Paint( (PRRC)0, NULL );
            UpdateCursorPos();
            break;

        case SB_BOTTOM: {
            char    sz[ cchEditMax ];
            WORD    cch;

            cch = CbGetCachedLine( m_ipCur.oln, sizeof( sz ) - 1, sz );
            m_ipCur.ob = cch;
            UpdateAnchor( lParam );
            FMoveWindowToCursor( FALSE );
            break;
        }
    }
}

/**** DeleteChar - Delete the character either before/after cursor      ****
 *                                                                         *
 *  PURPOSE: Delete the character at the current position.                 *
 *                                                                         *
 *  INPUTS:                                                                *
 *     fDeleteCur   if TRUE then DELETE key (delete under cursor),         *
 *                  else, then BACKSPACE key (delete key before cursor)    *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: DeleteChar(
BOOL    fDeleteCur ) {

    // The buffer (OR where cursor sits) must NOT be read-only.  Ask
    // the owner if we're allowed to edit

    if ( !FReadOnlyBuf() ) {
        WORD    cch;
        char *  pch;
        char *  psz = m_pldCur->prgch;

        // If BACKSPACE, then
        //    1) Make sure that we're not attempting to delete before ob == 0
        //    2) Set the cursor back 1 position.  This will be where the
        //       cursor should be AFTER the either delete key has occurred
        if ( !fDeleteCur ) {
            if ( !m_ipCur.ob ) {
                MessageBeep( 0 );
                return;
            }
            --m_ipCur.ob;
        }

        cch = CbGetLineIntoCache( m_ipCur.oln );

        // Reset the selection
		m_ipAnchor = m_ipCur;

        if ( m_ipCur.ob < cch ) {
            pch = psz + m_ipCur.ob;
            memmove( pch, pch + 1, cch - m_ipCur.ob + 1 );
            --m_pldCur->cb;

            if ( m_pdCur.obleft && m_ipCur.ob == m_pdCur.obleft ) {
                if ( m_pdCur.obleft < cchDelBack ) {
                    m_pdCur.obleft = 0;
                }
                else {
                    m_pdCur.obleft -= cchDelBack;
                }
                Paint( (PRRC)0, NULL );
            }
            else {
                if ( !FMoveWindowToCursor( FALSE ) ) {
                    PaintLine( m_ipCur.oln );
                }
            }
        }
        else {
            // They we're deleting (BACKSPACE) beyond the true
            // end of the line, so just move the cursor
            if ( !fDeleteCur ) {
               FMoveWindowToCursor( FALSE );
            }
        }
    }
    else {
        MessageBeep( 0 );
    }
}

/**** InsertChar - Insert a character into the current line/buffer      ****
 *                                                                         *
 *  PURPOSE: Insert a character at the current buffer position.  If        *
 *           insertion point is beyond end of line, pad with spaces.       *
 *                                                                         *
 *  INPUTS:                                                                *
 *     wParam   WM_CHAR specific value.  Usually ASCII value.  This        *
 *              routine will only be called if !isprint( wParam ).         *
 *     lParam   WM_CHAR specific value.  Not used (yet?)                   *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: InsertChar(
UINT   wParam,
long   lParam ) {

    // We can't insert if the cursor is sitting over a read-only
    // area in the file/buffer, so make sure that we're on read-write.
    if ( !FReadOnlyBuf() ) {
        WORD    cch;
        WORD    obCur = m_ipCur.ob;
        char *  psz = m_pldCur->prgch;
        char *  pchInsert = psz + obCur;
        BOOL    fInsertChar = (BOOL)fInsertMode;

        cch = CbGetLineIntoCache( m_ipCur.oln );

        // If the line is already axMax chars, there's no room
        // for more insertions, so Beep at em
        if ( cch + 1 < (WORD)axMax || !fInsertChar ) {

            // If the cursor's beyond the end of the line, pad
            // with spaces before inserting the character.
            if ( cch < obCur ) {
                WORD    cchT = obCur - cch;

                memset( _ftcschr( psz, _T('\0') ), ' ', cchT );
                *( pchInsert + 1 ) = '\0';
                m_pldCur->cb += cchT + 1;
            }
            // Regular insert, move existing text over first
            else if ( fInsertChar || cch == obCur ) {
                memmove( pchInsert + 1, pchInsert, cch + 1 - obCur );
                ++m_pldCur->cb;
            }

            if ( m_ipCur.ob < axMax ) {
                ++m_ipCur.ob;
            }

            // Insert the character into the buffer
            *pchInsert = LOBYTE( wParam );

            // Reset the selection
			m_ipAnchor = m_ipCur;

            // Update the cursor position
            if ( !FMoveWindowToCursor( FALSE ) ) {
                PaintLine( m_ipCur.oln );
            }
        }
        else {
            MessageBeep( 0 );
        }
    }
    else {
        MessageBeep( 0 );
    }
}

/**** PreviousWord - Scroll back to the previous "word"                 ****
 *                                                                         *
 *  PURPOSE: Move the cursor to the beginning of the previous word that    *
 *           that cursor is sitting on.                                    *
 *                                                                         *
 *  INPUTS:                                                                *
 *      lParam   WM_CHAR lParam message value (contains shift key state)   *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: PreviousWord(
long   lParam ) {
    register WORD    cch;
    register CHAR *  pch;
    CHAR             szBuf[ cchEditMax ];
    CHAR *           sz;
    BOOL             fFound = FALSE;
    WORD             obCur = m_ipCur.ob;
    DWORD            olnCur = m_ipCur.oln;
    BOOL             fFirstPass = TRUE;

    // The buffer will be 1 larger than the max size so we
    // can go backwards through the buffer and check the current
    // position - 1 w/o GP faulting
    *szBuf = ' ';
    sz = &szBuf[ 1 ];

    do {
        cch = CbGetCachedLine( m_ipCur.oln, sizeof( szBuf ) - 1, sz );

        cch = min( cch, obCur );
        pch = _tcsdec( szBuf, sz + cch );

        if ( fFirstPass && cch && _istspace((UCHAR)*( pch ) ) ) {
            pch = _tcsdec( szBuf, pch );
            cch -= _tclen( pch );
        }

        // Skip the white spaces
        while( cch && _istspace((UCHAR)*pch ) ) {
            pch = _tcsdec( szBuf, pch );
            cch -= _tclen( pch );
        }

        // Find the beginning of this word
        if ( FIsWordChar( *pch ) && cch ) {
			CHAR *	pchPrev = _tcsdec( szBuf, pch );

            while( cch && FIsWordChar( *pchPrev ) ) {
	            pch = pchPrev;
	            cch -= _tclen( pch );
				pchPrev = _tcsdec( szBuf, pch );
            }
        }

        // If cch is non-zero, then we've found a spot.  Otherwise,
        // try the previous line in the file for search
        if ( !cch ) {
            --m_ipCur.oln;
            pch = sz;
            obCur = (WORD)axMax;
        }
        else {
            m_ipCur.ob = (WORD)( pch - sz );
            fFound = TRUE;
        }

        fFirstPass = FALSE;

        // If the current line == olnMax, we've either found the new
        // position (fFound==TRUE) or we've backed up beyond the beginning
        // of the file.  Either way, get out
    } while ( !fFound && m_ipCur.oln != olnMax );


    // If found, move the cursor (or window) to the correct position
    if ( fFound ) {
		AdjustDbcsCursor( m_iAdjustDbcs );
        UpdateAnchor( lParam );
        if ( !FMoveWindowToCursor( FALSE ) ) {
            PaintLine( m_ipCur.oln );
        }
    }

    // Otherwise, restore the current line (we may have trashed it above)
    // and beep at them.
    else {
        m_ipCur.oln = olnCur;
        MessageBeep( 0 );
    }
}

/**** NextWord - Scroll over to the next "word"                         ****
 *                                                                         *
 *  PURPOSE: Move the cursor to the beginning of the next word in the file *
 *                                                                         *
 *  INPUTS:                                                                *
 *      lParam   WM_CHAR lParam message value (contains shift key state)   *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: NextWord(
long   lParam ) {
    register WORD    cch;
    register TCHAR * pch;
    TCHAR            sz[ cchEditMax ];
    DWORD            olnMac = CLinesInBuf();
    BOOL             fFound = FALSE;
    BOOL             fFirstPass = TRUE;
    DWORD            oln = m_ipCur.oln;

    // Check to make sure that we're in range before looking.  We
    // may be beyond the last line in the file.
    while ( !fFound && m_ipCur.oln < olnMac ) {

        cch = CbGetCachedLine( m_ipCur.oln, sizeof( sz ) - 1, sz );

		// On the first pass, we want to begin on the next character
		if ( fFirstPass && m_ipCur.ob < cch ) {
	    	pch = _tcsinc( sz + m_ipCur.ob );
		}

        if ( fFirstPass && m_ipCur.ob < cch || !fFirstPass && cch ) {

            cch -= pch - sz;

            // First pass only, skip over current word
            if ( fFirstPass ) {
                if ( FIsWordChar( *( _tcsdec( sz, pch ) ) ) ) {
					// Does NOT need to be DBCS here since FIsWordChar
					// only accepts single byte characters!
                    while( FIsWordChar( *pch ) ) {
                        ++pch;
                        --cch;
                    }
                }
            }

            // Skip the white spaces
            while( cch && _istspace( (_TUCHAR)*pch ) ) {
				size_t	cb;
				
				cb = _tclen( pch );
				cch -= cb;
				pch += cb;
            }
        }
        else {
            cch = 0;
        }

        fFirstPass = FALSE;

        // If cch is non-null then we found what we're looking for.
        // Otherwise, start searching the next line for something.
        if ( !cch ) {
            ++m_ipCur.oln;
            pch = sz;
        }
        else {
            m_ipCur.ob = (WORD)( pch - sz );
            fFound = TRUE;
        }
    }

    // If we've found something, set the text and the cursor
    // accordingly.  Otherwise, reset the current line and
    // Beep at them to let them know that we failed
    if ( fFound ) {
		AdjustDbcsCursor( m_iAdjustDbcs );
        UpdateAnchor( lParam );
        if ( !FMoveWindowToCursor( FALSE ) ) {
            PaintLine( m_ipCur.oln );
        }
    }
    else {
        m_ipCur.oln = oln;
        MessageBeep( 0 );
    }
}

void CMultiEdit :: DoEnterKey() {
#ifdef FULL_
    WORD    cch = CbGetLineIntoCache( m_ipCur.oln );
    char *  psz;

    psz = m_pldCur->prgch;
    if ( m_ipCur.ob >= cch ) {
        // Point to zero terminator
        psz += cch;
    }
    else {
        psz += m_ipCur.ob;
    }

    if ( !FReadOnlyBuf() &&
        InsertLineBuf( m_ipCur.oln, _ftcslen( psz ), psz ) ) {
        *psz = '\0';
        m_pldCur->cb = _ftcslen( m_pldCur->prgch );
        FlushCache();
        ++m_ipCur.oln;
        m_ipCur.ob = 0;
		m_ipAnchor = m_ipCur;
        if ( !FMoveWindowToCursor( FALSE ) ) {
            Paint( (PRRC)0, NULL );
            UpdateCursorPos();
        }
    }
    else {
        FlushCache();
    }
#endif	// FULL_
}

/**** DoChar - responses for character (WM_CHAR) input to window        ****
 *                                                                         *
 *  PURPOSE: Main processing for character (keyboard) input.               *
 *                                                                         *
 *  INPUTS:                                                                *
 *    wParam  WM_CHAR specific data.  Usually ASCII character.             *
 *    lParam  WM_CHAR specific data.  Usually contains ctrl/shift/alt      *
 *            states along with untranslated data.  See CW Messages API.   *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: DoChar(
UINT   wParam,
long   lParam ) {

    if ( lParam & 0x02000000L ) {
		char	sz[ cchEditMax ];

		CbGetCachedLine( m_ipCur.oln, sizeof ( sz ) - 1, sz );

        switch( wParam ) {
            case VK_HOME:

                // Ctrl-home: Move to top of file
                // Home: Move to beginning of current line

                if ( HIWORD( lParam ) & KK_CONTROL ) {
                    m_pdCur.obleft = m_ipCur.ob = 0;
                    VScroll( SB_TOP, lParam );
                }
                else {
                    HScroll( SB_TOP, lParam );
                }
                break;

            case VK_END:

                // Ctrl-End: Move to bottom of file
                // End: Move to end of current line

                if ( HIWORD( lParam ) & KK_CONTROL ) {
                    VScroll( SB_BOTTOM, lParam );
                }
                HScroll( SB_BOTTOM, lParam );
                break;

            case VK_PRIOR:

                // Ctrl-PageUp: Scroll LEFT 1 page
                // PageUp: Scroll UP 1 page

                if ( HIWORD( lParam ) & KK_CONTROL ) {
                    HScroll( SB_PAGEUP, lParam );
                }
                else {
                    VScroll( SB_PAGEUP, lParam );
                }
                break;

            case VK_NEXT:

                // Ctrl-PageDn: Scroll RIGHT 1 page
                // PageDn: Scroll DOWN 1 page

                if ( HIWORD( lParam ) & KK_CONTROL ) {
                    HScroll( SB_PAGEDOWN, lParam );
                }
                else {
                    VScroll( SB_PAGEDOWN, lParam );
                }
                break;

            case VK_UP:

                // Ctrl-Up: Scroll 1 line UP
                // Up: Move cursor 1 line UP.  Scroll if necessary.

                if ( HIWORD( lParam ) & KK_CONTROL ) {
                    VScroll( SB_LINEUP, lParam );
                }
                else {
                    if ( m_ipCur.oln ) {
                        --m_ipCur.oln;
						AdjustDbcsCursor( m_iAdjustDbcs );
                        UpdateAnchor( lParam );
                        FMoveWindowToCursor( HIWORD( lParam ) & KK_SHIFT );
                    }
                }
                break;

            case VK_DOWN:

                // Ctrl-Down: Scroll 1 line DOWN
                // Down: Move cursor 1 line DOWN.  Scroll if necessary.

                if ( HIWORD( lParam ) & KK_CONTROL ) {
                    VScroll( SB_LINEDOWN, lParam );
                }
                else {
                    if ( m_ipCur.oln + 1 < CLinesInBuf() ) {
                        ++m_ipCur.oln;
						AdjustDbcsCursor( m_iAdjustDbcs );
                        UpdateAnchor( lParam );
                        FMoveWindowToCursor( HIWORD( lParam ) & KK_SHIFT );
                    }
                }
                break;

            case VK_LEFT:

                // Ctrl-Left: Move cursor to beginning of previous word
                // Left: Move cursor 1 char left.

                if ( HIWORD( lParam ) & KK_CONTROL ) {
                    PreviousWord( lParam );
                }
                else {
                    if ( m_ipCur.ob ) {
                        --m_ipCur.ob;
						AdjustDbcsCursor( -1 );
                        UpdateAnchor( lParam );
						FMoveWindowToCursor( HIWORD( lParam ) & KK_SHIFT );
                    }
                }
                break;

            case VK_RIGHT:

                // Ctrl-Right: Move cursor to beginning of next word
                // Right: Move cursor 1 char right.

                if ( HIWORD( lParam ) & KK_CONTROL ) {
                    NextWord( lParam );
                }
                else {
                    if ( m_ipCur.ob < ObMaxBuf() ) {
                        ++m_ipCur.ob;
						AdjustDbcsCursor( 1 );
                        UpdateAnchor( lParam );
						FMoveWindowToCursor( HIWORD( lParam ) & KK_SHIFT );
                    }
                }
                break;

            case VK_DELETE:
                // Delete the character at the cursor position (DELETE)
                // or delete the character to the LEFT of the cursor
                // position (BACKSPACE)

                DeleteChar( TRUE );
                break;

            default:
                break;
        }
    }
    else {
        // If the character is printable, do something with it
        // (insert into buffer).  Otherwise, we don't do anything
        // special for non-printable stuff so...
        switch( wParam ) {
            case VK_BACK:
                DeleteChar( FALSE );
                break;

            case VK_CANCEL:
                if ( m_pldCur->flags ) {
                   // Throw away the cached line and redraw the
                   // original
                   m_pldCur->flags = FALSE;
                   m_pldCur->cb = 0;
                   *m_pldCur->prgch = '\0';
                   PaintLine( m_pdCur.oln );
                   m_pdCur.oln = 0xffff;
                }
                break;

            case VK_ESCAPE:
				m_ipAnchor = m_ipCur;

                // Clean out cache and throw away changes!
                if ( m_pldCur->flags && m_pdCur.oln != 0xffff ) {
                    DWORD   olnCache = m_pdCur.oln;

                    m_pldCur->flags = FALSE;
                    m_pldCur->cb = 0;
                    m_pdCur.oln = olnMax;
                    *m_pldCur->prgch = '\0';
                    PaintLine( olnCache );
                }
                break;

            case VK_RETURN:
                // ENTER key pressed. Notify buffer owner that a line has
                // (may have) changed.
                DoEnterKey();
                break;

            default:
                if ( _istprint( wParam ) && !FReadOnlyBuf() ) {
                    // Always remove the selection
                    DeleteSelection();
					InsertChar( wParam, lParam );
                }
				else {
					MessageBeep( 0 );
				}
                break;
        }
    }
}

/**** PaintLine - Paint 1 line only                                     ****
 *                                                                         *
 *  PURPOSE: Paint a specific line.  It is assumed that it is already      *
 *           visible and that we're just updating it.  Functionally,       *
 *           this is just to shorten code since we do this all over the    *
 *           place.                                                        *
 *                                                                         *
 *  INPUTS:                                                                *
 *     oln   Line number to paint                                          *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: PaintLine(
DWORD    oln ) {
    RRC rrc;

    // The top line should be the relative window coordinate, so
    // compute it bades upon the top line in the window and the
    // offset line which we want to display.
    // The bounding RRC must have ryBottom - ryTop != 0.  If it's
    // zero, then no painting will be done.

    rrc.ryTop = (RY)( oln - m_pdCur.olntop );
    rrc.ryBottom = rrc.ryTop + (RY)1;
    Paint( &rrc, NULL );
}

void CMultiEdit::ArmDataTip()
{
	CPoint pt;
	GetCursorPos(&pt);

	if (abs(CDataTip::GetX() - pt.x) <= 2 && abs(CDataTip::GetY() - pt.y) <= 2)
		   return;

	if (GetKeyState(VK_CONTROL) < 0)
		SetTimer(DATATIP_TIMER, 100, NULL);
	else
		SetTimer(DATATIP_TIMER, 600, NULL);

	CDataTip::SetX(pt.x);
	CDataTip::SetY(pt.y);

	if (CDataTip::GetTip()) CDataTip::GetTip()->DestroyTip();
}

/**** DoMouse - Perform responsed to mouse messages for window          ****
 *                                                                         *
 *  PURPOSE: Perform mouse responses to window messages.  We will mostly   *
 *           set pipCur and do scrolling in here.  Since most CV windows   *
 *           do something special with double clicks, we will ignore it.   *
 *           normally, we would select the current word.                   *
 *                                                                         *
 *  INPUTS:                                                                *
 *     wMsg     Window message (limited to MOUSE messages in this case)    *
 *     wParam   Message specific WORD data.  See CW Message API for details*
 *     lParam   Message specific long data.  Contains SHIFT key state.     *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: DoMouse(
UINT   wMsg,
UINT   wParam,
long   lParam ) {
    static long  lParamSav;
    static DWORD olnDragMac = 0;
    static BOOL  fTimer = FALSE;

    WORD    obMouse;
    DWORD   olnMouse;
	WORD	obMacBuf;
    int     xMouse;
    int     yMouse;

	PosFromPoint( xMouse, yMouse, CPoint( (DWORD)lParam ) );
    obMouse = ( xMouse - m_cxSelectMargin ) / m_pFontInfo->m_tm.tmAveCharWidth + m_pdCur.obleft;
    olnMouse = (DWORD)( yMouse / m_pFontInfo->m_tm.tmHeight ) + m_pdCur.olntop;

	obMacBuf = ObMaxBuf();
	if ( obMouse > obMacBuf ) {
		obMouse = obMacBuf;
	}

    switch( wMsg ) {

        // LBtnDown: Set the cursor where the mouse is.
        // Later, we will want to make sure that the cursor
        // is being placed w/i the buffers boundaries and if it's
        // not, put it at the end of the buffer.  Also, we will
        // want to set the mouse capture.
        case WM_LBUTTONDOWN: {
			BOOL	fAltKey = (BOOL)!!( GetKeyState( VK_MENU ) & ~1 );

            SetCapture();
            m_ipCur.ob = obMouse;
            if ( olnDragMac = CLinesInBuf() ) {
                --olnDragMac;
            }

            m_ipCur.oln = min( olnMouse, olnDragMac );
			AdjustDbcsCursor( -1 );

			// If the shift key is down and the alt key is
			// down, then the selection is retained, but the
			// mode is set to column select.  UpdateAnchor
			// will redisplay the selection
			if ( ( wParam & MK_SHIFT ) && fAltKey ) {
				m_fColumnSelect = TRUE;
			}
 			UpdateAnchor( MAKELONG( 0, wParam & MK_SHIFT ? KK_SHIFT : 0 ) );

			// Shift key or not, the alt key is down set to column select
			// if the shift key is down, the code above will redisplay the
			// selection to column select, if not, this will set us in
			// column select mode
			if ( fAltKey ) {
				m_fColumnSelect = TRUE;
			}

			FMoveWindowToCursor( TRUE );
           break;
		}

        // Mouse move mouse will be down, do selection stuff (repaint)
        // after resetting pipCur...  We *MAY* want to do scrolling
        // if we're out of the client region.
        case WM_TIMER:
            lParam = lParamSav;
			PosFromPoint( xMouse, yMouse, CPoint( (DWORD)lParam ) );
            obMouse = ( xMouse - m_cxSelectMargin ) / m_pFontInfo->m_tm.tmAveCharWidth + m_pdCur.obleft;
			if ( obMouse > obMacBuf ) {
				obMouse = obMacBuf;
			}
            olnMouse = (DWORD)( yMouse / m_pFontInfo->m_tm.tmHeight ) + m_pdCur.olntop;
            // fall through

        case WM_MOUSEMOVE:
            if ( GetCapture() == this ) {
                BOOL    fNonClient = FALSE;
                RECT    rect;
                RRC     rrc;
				WPARAM	wParamSend = SB_TOP;

                GetClientRect( &rect );
                GetEditRrc( FALSE, &rrc );

				// Horizontal scrolling (no problems)
                if ( xMouse < rect.left ) {
                    fNonClient = TRUE;
                    if ( m_ipCur.ob ) {
                        --m_ipCur.ob;
                    }
                }
                else if ( xMouse >= rect.right ) {
                    fNonClient = TRUE;
					if ( m_ipCur.ob < ObMaxBuf() ) {
                        ++m_ipCur.ob;
                    }
                }
                else {
                    m_ipCur.ob = min( obMouse, ObMaxBuf() );
                }

				// Vertical scrolling, may cause remapping in Disasm/Mixed
				// window.  Need to send WM_VSCROLL messages so the window
				// can readjust itself
                if ( yMouse < rect.top ) {
                    fNonClient = TRUE;
                    if ( m_ipCur.oln ) {
						if ( m_ipCur.oln == m_pdCur.olntop ) {
							wParamSend = SB_LINEUP;
						}
						else {
							--m_ipCur.oln;
						}
                    }
                }

				// The yMouse is out of range if it's past
				// the last FULL line in the window!
                else if ( yMouse >= rrc.ryBottom * m_pFontInfo->m_tm.tmHeight ) {
                    fNonClient = TRUE;
                    if ( m_ipCur.oln < olnDragMac + 1 ) {
						if ( m_ipCur.oln == m_pdCur.olntop + rrc.ryBottom - 1 ) {
							wParamSend = SB_LINEDOWN;
						}
						else {
                        	++m_ipCur.oln;
						}
                    }
                }
                else {
		            m_ipCur.oln = olnMouse;
                }

				if ( m_ipCur.oln > olnDragMac ) {
					m_ipCur.oln = olnDragMac + 1;
				}

                if ( fNonClient ) {
					if ( wParamSend != SB_TOP ) {
						SendMessage( WM_VSCROLL, wParamSend, 0L );
					}
                    if ( !fTimer ) {
                        SetTimer( idTimer, 2, NULL );
                        fTimer = TRUE;
                    }
					lParamSav = lParam;
                }
                else if ( fTimer ) {
                    KillTimer( idTimer );
                    fTimer = FALSE;
                }

				AdjustDbcsCursor( -1 );
                FMoveWindowToCursor( TRUE );
                UpdateAnchor( MAKELONG( 0, KK_SHIFT ) );
			}
			else if ( wMsg == WM_MOUSEMOVE ) {
				CWnd * pActiveWnd = GetActiveWindow();

				if (!(wParam & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON | MK_SHIFT))
					&& (pActiveWnd != NULL) && SupportsDataTips())
				{
					ArmDataTip();
				}
			}
				
            break;

        // Release the capture here and nothing else.
        case WM_LBUTTONUP:
            if ( GetCapture() == this ) {
                ReleaseCapture();
                fTimer = FALSE;
                KillTimer( idTimer );
            }
            break;

        // Don't use wParam and lParam since the BUTTON up/down messages
        // have already positioned the cursor (and possibly the anchor)
        case WM_LBUTTONDBLCLK: {
			SelectWordCur();
            break;
        }
    }
}

/**** SelectWordCur - selects word at cursor location. Assumes cursor and
 * possibly anchor have already been positioned. Used by WM_LBUTTONDBLCLK	*
 ***************************************************************************/
void CMultiEdit :: SelectWordCur()
{
    char    sz[ cchEditMax ];
    WORD    obMic;
    WORD    obMac;

    if ( LcbGetWord( sizeof( sz ), sz, &obMic, &obMac ) )
	 {
        m_ipCur.ob = obMac;
        m_ipAnchor.ob = obMic;
        if ( !FMoveWindowToCursor( FALSE ) )
		{
            UpdateCursorPos();
        }
		UpdateAnchor( MAKELONG( 0, KK_SHIFT ) );
    }

}



/**** FMouseHitSel - determine if the mouse is over a selection         ****
 *                                                                         *
 *  PURPOSE: Used for drag and drop.  If the lparam coordinates of the     *
 *           mouse intersect with a selection in the ACTIVE window,        *
 *           return true.  It is the responsibility of the caller to change*
 *           cursors or initiate drag and drop.                            *
 *                                                                         *
 *  INPUTS:                                                                *
 *     fSetCursor                                                          *
 *              If return value is true and fSetCursor is non-zero, set    *
 *              cursor at specified position                               *
 *                                                                         *
 *     lParam   Mouse message lParam (client coordinates of mouse event).  *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: TRUE if mouse intersects with a selection            *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
BOOL CMultiEdit :: FMouseHitSel( BOOL fSetCursor, LPARAM lParam ) {
	BOOL	fRet = FALSE;

	if ( FIsActiveWindow( m_hWnd ) ) {
		WORD	obSelMic;
		WORD	obSelMac;
		WORD	obMouse;
		DWORD	olnMouse;
		WORD	obMacBuf = ObMaxBuf() - 1;
		int		xMouse;
		int		yMouse;

		PosFromPoint( xMouse, yMouse, CPoint( (DWORD)lParam ) );
	    obMouse = ( xMouse - m_cxSelectMargin ) / m_pFontInfo->m_tm.tmAveCharWidth + m_pdCur.obleft;
		olnMouse = (DWORD)( yMouse / m_pFontInfo->m_tm.tmHeight ) + m_pdCur.olntop;
		if ( obMouse > obMacBuf ) {
			obMouse = obMacBuf;
		}

		if ( FGetSelection( olnMouse, &obSelMic, &obSelMac ) ) {
			if ( obSelMic <= obMouse && obMouse <= obSelMac ) {
				fRet = TRUE;

				// Since the cursor is in a selection, the position
				// must be valid for the buffer and must already be
				// visible.  This will set the cursor position to
				// the specified location, reset the selection (to NULL)
				// and move the cursor
				if ( fSetCursor ) {
					m_ipCur.ob = obMouse;
					m_ipCur.oln = olnMouse;
					UpdateAnchor( 0L );
			        UpdateCursorPos();
				}
			}
		}
	}
	return fRet;
}

/**** AdjustDbcsCursor - update cursor to be on lead byte               ****
 *                                                                         *
 *  PURPOSE: Update ipCur to be on lead byte of dbcs char                  *
 *                                                                         *
 *  INPUTS:                                                                *
 *      iAdjust	Direction to adjust (must be either 1 or -1)               *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *      Possibly updates ipCursor and iDbcsAdjust.  iDbcsAdjust will have  *
 *      the sign flipped if the cursor was adjusted.                       *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: AdjustDbcsCursor( int iAdjust ) {
	if ( FDbcsEnabled() )
    {
		char	sz[ axMax ];
		size_t	cch;

	    cch = CbGetCachedLine( m_ipCur.oln, sizeof( sz ) - 1, sz );

		// If the cursor is beyond the end of the line, no need to adjust
		if ( m_ipCur.ob < cch ) {
			char *	pch = sz;
			char *	pchCursor = &sz[ m_ipCur.ob ];

			// Scan the string until we have found the cursor
			// location
			while( pch < pchCursor ) {
				pch += _tclen( pch );
			}

			// If the cursor location doesn't match the current
			// location, then we need to adjust the ipCur.ob
			if ( pch != pchCursor ) {
				m_ipCur.ob += iAdjust;
				m_iAdjustDbcs = iAdjust * -1;
			}
		}
	}
}
/**** CMultiEdit::LTextProc - Main implementation                       ****
 *                                                                         *
 *  PURPOSE: Entry point for all multiline edit control.  WndProc to       *
 *           respond to CW/window owner messages.                          *
 *                                                                         *
 *                                                                         *
 *  INPUTS:                                                                *
 *     wMsg    Message to respond to or act upon.                          *
 *     wParam  Message specific WORD value.  See CW Message API.           *
 *     lParam  Message specific long value.                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: 1L if message consumed or responded to, else 0L.     *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
LRESULT CMultiEdit :: LTextProc(UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    long    	lRet = 0L;
    DWORD   	oln;
    WORD    	ob;
    BYTE    	fSelection;
    DWORD   	olnAnchor;
	BOOL		fCallDef = TRUE;

    if ( wMsg == WM_DESTROY )
        return(this->WindowProc(wMsg, wParam, lParam) );

	// Save the old current position to determin if we need
	// to update Scrollbars
	oln = m_pdCur.olntop;
	ob = m_pdCur.obleft;
    fSelection = m_fSelection;
    olnAnchor = m_ipAnchor.oln;

    switch( wMsg ) {
        case WM_SETFOCUS:
            ::CreateCaret( m_hWnd, NULL, CURSOR_WIDTH, m_pFontInfo->m_tm.tmHeight );	// m_tmAveCharWidth
            if ( !( m_Style & ES_NOREDRAW ) ) {
                ShowCaret();
            }
            UpdateCursorPos();

			// If there's a selection, we will recheck to see if the status
			// changed during this message.  By setting it to FALSE, we will
			// detect that the selection status has toggled and hide the caret
			// if there's a selection.  If there's no selection, the status
			// will not have changed and nothing will be done with the caret
			fSelection = FALSE;
            break;

        case WM_KILLFOCUS:
            FlushCache();
            if ( ::HideCaret( m_hWnd ) ) {
            	DestroyCaret();
			}
            break;

        case WM_FLUSHFOCUS:
            FlushCache();
            PaintLine( m_ipCur.oln );
            fCallDef = FALSE;
            break;

        case WM_SETREDRAW:
            fCallDef = FALSE;
            if ( wParam ) {
                m_Style &= ~(BYTE)ES_NOREDRAW;
                --ob;
                --oln;
                if ( !FMoveWindowToCursor( FALSE ) ) {
                    Paint( (PRRC)0, NULL );
                }
            }
            else {
                m_Style |= (BYTE)ES_NOREDRAW;
            }
            if ( wParam ) {
                ShowCaret();
            }
            else {
                HideCaret();
            }

			// Reset fSelection so that we don't re-show/hide the caret below
			fSelection = (BYTE)!MEFAreIPsEqual( &m_ipAnchor, &m_ipCur );
            break;

        case WM_PAINTLINE:
            // Paint the line specified in lParam.  If the line
            // is not visible, readjust the screen so it is.
            m_ipCur.oln = lParam;
            if ( !wParam ) {
				m_ipAnchor = m_ipCur;
            }
            if ( !FMoveWindowToCursor( FALSE ) ) {
                PaintLine( m_ipCur.oln );
            }
            break;

        case WM_PAINT: {
            PAINTSTRUCT ps;
			RRC			rrc;
			RRC *		prrc = (PRRC)LOWORD( lParam );

            BeginPaint( &ps );
			if ( !prrc &&
				( ps.rcPaint.left != ps.rcPaint.right ||
				ps.rcPaint.top != ps.rcPaint.bottom ) ) {
					int tmAveCharWidth = m_pFontInfo->m_tm.tmAveCharWidth;
					int tmHeight = m_pFontInfo->m_tm.tmHeight;
					rrc.rxLeft = ps.rcPaint.left / tmAveCharWidth;
					rrc.rxRight = ps.rcPaint.right / tmAveCharWidth + 1;
					rrc.ryTop = ps.rcPaint.top / tmHeight;
					rrc.ryBottom = ps.rcPaint.bottom / tmHeight + 1;
					prrc = &rrc;
			}
            Paint( prrc, CDC::FromHandle( ps.hdc ) );
            ValidateCursor();
            EndPaint( &ps );
	        fCallDef = FALSE;

			lRet = TRUE;	// ??? [dwg] ???
            // Change oln and ob to force scroll bar updateing
            ++oln;
            ++ob;
            break;
        }

        case WM_CLEAR:
            if ( fSelection ) {
                DeleteSelection();
            }
            else {
                DoChar( VK_DELETE, 0x02000000L | LGetShiftState() );
            }
            fCallDef = FALSE;
            break;

        case WM_KEYDOWN:
            fCallDef = FALSE;
            switch( wParam ) {
                case VK_DELETE:
                    if ( fSelection ) {
                        DeleteSelection();
                    }
                    else {
                        DoChar( VK_DELETE, lParam | 0x02000000L );
                    }
                    break;

                case VK_INSERT: {
                    if ( HIWORD( lParam ) & KK_SHIFT ) {
                        PasteSelection();
                    }
                    else if ( HIWORD( lParam ) & KK_CONTROL ) {
                        CopySelection( (char FAR *)NULL, 0 );
                    }
                    break;
                }

                case VK_HOME:
                case VK_END:
                case VK_PRIOR:
                case VK_NEXT:
                case VK_LEFT:
                case VK_RIGHT:
                case VK_UP:
                case VK_DOWN:
                    DoChar( wParam, lParam | 0x02000000L );
                    break;

#if 0
				// the shell already does this on your behalf if you
				// return a nonempty string from package virtual GetHelpWord
				// this is redundant and causes a double lookup
				// ORION bug 13977 - craigc
				//
				case VK_F1: {
					CString strHelp;

					if ( GetHelpWord( strHelp ) ) {
						theApp.HelpOnKeyword( strHelp );
					}
					break;
				}
#endif

                default:
                    fCallDef = TRUE;
                    break;
            }
            break;

        case WM_CHAR:
           	DoChar( wParam, lParam );
            fCallDef = FALSE;
            break;

        case WM_CUT:
            CopySelection( (char FAR *)NULL, 0 );
            DeleteSelection();
            fCallDef = FALSE;
            break;

        case WM_COPY:
            lRet = (long)(LRESULT)CopySelection( (char FAR *)NULL, (size_t)lParam );
            fCallDef = FALSE;
            break;

        case WM_PASTE:
            PasteSelection();
            fCallDef = FALSE;
            break;

        case WM_HSCROLL:
			HScroll( LOWORD ( wParam ), (long)HIWORD( wParam ) );
            fCallDef = FALSE;
            break;

        case WM_VSCROLL:
			VScroll( LOWORD ( wParam ), (long)HIWORD( wParam ) );
            fCallDef = FALSE;
            break;

        case EM_SELCHARS: {
            // Adjust the text and the cursor.
            // wParam == Line to put the cursor on.
            // lParam is as follows:
            //  For selection:
            //     x1 == start (anchor)
            //     x2 == end (cursor)
            //  For display:
            //     x2 == position for cursor on line
            //     x1 == distance from HIWORD for
            //           left margin.
            EMSC *  pemsc = (EMSC *) lParam;

            // Position cursor
			m_ipAnchor.oln = m_ipCur.oln = pemsc->y;

			// Put anchor into ip so the position may be
			// adjusted for DBCS, then put into anchor
            m_ipCur.ob = pemsc->x1;
			AdjustDbcsCursor( m_iAdjustDbcs );
            m_ipAnchor.ob = m_ipCur.ob;

            m_ipCur.ob = pemsc->x2;
			AdjustDbcsCursor( m_iAdjustDbcs );

			UpdateAnchor( MAKELONG( 0, KK_SHIFT ) );
			if ( !FMoveWindowToCursor( FALSE ) ) {
            	PaintLine( m_ipCur.oln );
            }
            fCallDef = FALSE;
            break;
        }

        case WM_TIMER:
			// If not the edit manager's timer, ignore.
			if ( wParam == idTimer ) {
	            wParam = 0;
    	        lParam = 0L;

            	if ( FIsActiveWindow( m_hWnd ) ) {
                	DoMouse( wMsg, wParamMouse, lParamMouse );
	            }
			}
			else if ( wParam == DATATIP_TIMER )
			{
				// This code is plagiarized from data tip handling in the
				// CTextView class.
				KillTimer(DATATIP_TIMER);

				if (CDataTip::GetTip())
                    CDataTip::GetTip()->DestroyTip();

				if (GetKeyState(VK_LBUTTON) < 0 || GetKeyState(VK_RBUTTON) < 0 ||
					GetKeyState(VK_MBUTTON) < 0)
						break;

				if (!DebuggeeAlive() || DebuggeeRunning())
					break;

				CPoint ptScreen;
				GetCursorPos(&ptScreen);
				CMultiEdit* pPointEdit = (CMultiEdit*)WindowFromPoint(ptScreen);

				if (pPointEdit != this)
					break;
				
				CPoint pt = ptScreen;
				ScreenToClient(&pt);

				WORD    obMouse;
				DWORD   olnMouse;
				WORD	obMacBuf;
				int     xMouse;
				int     yMouse;

				PosFromPoint( xMouse, yMouse, pt);
				obMouse = ( xMouse - m_cxSelectMargin ) / m_pFontInfo->m_tm.tmAveCharWidth + m_pdCur.obleft;
				olnMouse = (DWORD)( yMouse / m_pFontInfo->m_tm.tmHeight ) + m_pdCur.olntop;

				obMacBuf = ObMaxBuf();
				if ( obMouse > obMacBuf ) {
					obMouse = obMacBuf;
				}

				WORD obMic, obMac;
				char szExpr[cchEditMax * 2 + 4 ];
				BOOL fOk = TRUE;
				
				// If we have a selection and the cursor is in the selection use the
				// currently selected text. Otherwise just get the word at the current
				// cursor position.
				if ( FGetSelection(olnMouse, &obMic, &obMac) &&
					 FMouseHitSel(FALSE, MAKELPARAM(LOWORD(pt.x), LOWORD(pt.y) ))
				  )
				{
					CopySelection(szExpr, cchEditMax);
					RemoveSideEffectsExpr(szExpr);
				}
				else {
					fOk = GetWordAtPosition(obMouse, olnMouse, szExpr, cchEditMax, &obMic, &obMac);
				}	
						
				char buf[cchEditMax];
				buf[0] = 0;

				if (!fOk || !FEvalExpr(szExpr, buf, sizeof(buf)))
					break;

				// exclude uninteresting tips
				if (0 == buf[0] || 0 == _tcsicmp(szExpr, buf))
					break;

				strcat(szExpr, " = ");
				strcat(szExpr, buf);

				CWnd *pWnd = new CDataTip;

				if (!pWnd->CreateEx(0, AfxRegisterWndClass(CS_SAVEBITS|CS_HREDRAW,
						::LoadCursor(NULL, IDC_ARROW), NULL, NULL),
					&afxChNil, WS_POPUP|WS_BORDER, 0, 0, 0, 0, m_hWnd, NULL))
				{
					delete pWnd;
					break;
				}

				pWnd->SetWindowText(szExpr);

				CPoint point(ptScreen);
				int yAdjust = 10;
				point.x -= 10;
				point.y += yAdjust; 	// Initial postion for the data tip.

				CRect rect;
				pWnd->GetWindowRect(rect);

				// Make sure that the datatip doesn't get clipped by the screen.
				int xScreenRight = ::GetSystemMetrics(SM_CXSCREEN);
				int yScreenBottom = ::GetSystemMetrics(SM_CYSCREEN);

				if ( point.x + rect.Width() > xScreenRight )
					point.x = xScreenRight - rect.Width();	
				if ( point.y + rect.Height()  > yScreenBottom )
					point.y -= yAdjust + yAdjust/2 + rect.Height() ;

				// show it and update it
				pWnd->SetWindowPos(NULL, point.x, point.y, 0, 0,
					SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW|SWP_NOACTIVATE);
				pWnd->UpdateWindow();
			}


	        break;

		case EM_PTINSELECTION: {
			POINT *	ppt = (POINT *)lParam;

			lRet = (long)FMouseHitSel(
				(BOOL)wParam,
				(DWORD)MAKELPARAM( LOWORD( ppt->x ), LOWORD( ppt->y ) )
			);

			fCallDef = FALSE;
			break;
		}

        case WM_MOUSEMOVE:
			if ( GetCapture() == NULL && FMouseHitSel( FALSE, lParamMouse ) )
				SetCursor( ::LoadCursor( NULL, IDC_ARROW ) );
			else
            {
				HCURSOR 		hCursor;

				if ( (int)LOWORD( lParamMouse ) < m_cxSelectMargin ) {
					hCursor = AfxGetApp()->LoadCursor( IDC_RIGHT_ARROW );
				}
				else if (m_pFontInfo->m_tm.tmHeight <= 8) {
					hCursor = ::LoadCursor( hInst, MAKEINTRESOURCE( IDC_SMALL_I ) );
				}
				else {
					hCursor = ::LoadCursor( NULL, IDC_IBEAM );
				}

				SetCursor( hCursor );

			}
        	// fall through

        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
			if (wMsg == WM_LBUTTONDOWN &&
				!( GetKeyState( VK_SHIFT ) & 0x8000 ) &&
				FMouseHitSel( FALSE, lParamMouse )
			) {
				POINTS	pts = MAKEPOINTS( lParamMouse );
				POINT	pt;

				pt.x = (LONG)pts.x;
				pt.y = (LONG)pts.y;
				DoDrag(pt);

				return (LRESULT)lRet;
			}
			// fall through

        case WM_LBUTTONUP:
        case WM_LBUTTONDBLCLK:
//        case WM_RBUTTONUP:
  //      case WM_RBUTTONDBLCLK:
            if ( FIsActiveWindow( m_hWnd ) ) {
                DoMouse( wMsg, wParamMouse, lParamMouse );
            }
			else if ( wMsg == WM_LBUTTONDOWN ) {
				MakeActive( m_hWnd );
			}
            break;

        case WM_UNDO:
            DoChar( VK_CANCEL, 0L );
            fCallDef = FALSE;
            break;

        case EM_GETTEXT:
            lRet = LcbGetText( (WORD)wParam, (char far *)lParam );
            fCallDef = FALSE;
            break;

        case EM_GETWORD: {
			// CV used the last to pWords to get the boundaries for the
			// selected word.  Also, if the values were NULL, the search
			// criteria would look for the next word if the cursor was
			// on a white-space.  We don't want this behavior for SUSHI
			// so, pass in dummy args to ensure that the returned word
			// is where the cursor is not near.  This bogus value is
			// being passed in so the LcbGetWord code doesn't have to
			// change in the event we want that functionality back.
			WORD	wDummy;

            lRet = LcbGetWord( wParam, (char far *)lParam, &wDummy, &wDummy );
            fCallDef = FALSE;
            break;
		}

        case WM_SIZE:
            FMoveWindowToCursor( FALSE );

			// Intentional fall-through

		case WU_UPDATESCROLLBARS:
            ResizeScroll();
            --ob;
            --oln;
			UpdateCursorPos();
            break;

        case EM_MOVECURSOR:
            // Just update the cursor.  The window's wndproc has reset
            // the m_ipCur and pipAnchor.
			AdjustDbcsCursor( m_iAdjustDbcs );
            if ( !FMoveWindowToCursor( TRUE ) ) {
            	Paint( (PRRC)0, NULL );
			}
            --ob;
            --oln;
            break;

        case WM_SYSKEYDOWN:
        case WM_SYSKEYUP:
        case WM_SYSCHAR:
        case WM_SYSDEADCHAR:
        case WM_COMMAND:
        case WM_INITMENU:
        case WM_INITMENUPOPUP:
        case WM_MENUSELECT:
        case WM_MENUCHAR:
            return GetParent()->SendMessage( wMsg, wParam, lParam );

        default:
            if ( wMsg == WM_VIEWACTIVATE )
                RedisplaySelection();

			fCallDef = TRUE;
    }

    // If we're not on the same line which we started out on, then
    // flush the cache.
    if ( m_pdCur.oln != m_ipCur.oln ) {
        FlushCache();
    }

    // Update the selection:  We can be smarter about this!
    m_fSelection = (BYTE)!MEFAreIPsEqual( &m_ipAnchor, &m_ipCur );
	if ( m_fSelection != fSelection ) {
		if ( fSelection ) {
			ShowCaret();
		}
		else {
			HideCaret();
		}
	}

    // Update the scrollbars

    // This code can be cleaned up if we restrict the pipCur
    // to always be contained within the file.  As in, don't
    // allow m_ipCur.oln to be > olnMac.

    if ( !( m_Style & ES_NOREDRAW ) ) {
    	DWORD	olnMac = CLinesInBuf();
		RRC	rrc;
		short	dy;
		short	dx;
		int 	cMax;
		int 	cMin;
		int 	iCur;
        BOOL    fVS;
        BOOL    fHS;

    	GetEditRrc( TRUE, &rrc );
	    if ( !( dy = rrc.ryBottom ) ) {
            ++dy;
        }
        if ( !( dx = rrc.rxRight ) ) {
            ++dx;
        }

		if ( olnMac != m_olnMacPrev ) {
			ResizeScroll();
		}

		if ( ( fVS = m_fScrollV ) && oln != m_ipCur.oln ) {
			if ( olnMac ) {
                GetScrollRange( SB_VERT, &cMin, &cMax );

				if ( cMax && (int)ScrollFromOln( m_ipCur.oln ) > cMax ) {
					m_ipCur.oln = olnMac - 1;
					UpdateCursorPos();
				}

				iCur = m_pdCur.olntop;

                if ( GetScrollPos( SB_VERT ) != ScrollFromOln(iCur) ||
					wMsg == WU_UPDATESCROLLBARS
            	) {
               		SetScrollPos( SB_VERT, ScrollFromOln(iCur), TRUE );
                }
            }
			else {
				SetScrollPos( SB_VERT, ScrollFromOln(olnMac), TRUE );
            }
        }

		if ( ( fHS = m_fScrollH ) && ob != m_pdCur.obleft ) {

			GetScrollRange( SB_HORZ, &cMin, &cMax );

			if ( m_pdCur.obleft > axMax ) {
				m_pdCur.obleft = m_ipCur.ob = axMax;
                UpdateCursorPos();
            }

			iCur = m_pdCur.obleft;
            if ( GetScrollPos( SB_HORZ ) != iCur ||
				wMsg == WU_UPDATESCROLLBARS
			) {
                SetScrollPos( SB_HORZ, iCur, TRUE );
            }
        }
    }

	if ( fCallDef ) {
		return DefWindowProc( wMsg, wParam, lParam );
	}

    return (LRESULT)lRet;
}

BOOL CMultiEdit::GetHelpWord(CString& strHelp)
{
    BOOL    lookAround = TRUE;
    char    sz[255 ];

    if ( GetCurrentText(&lookAround, (PSTR)sz, 255, NULL, NULL) &&
		lookAround &&
         !FWhitespaceOnly(sz, _tcslen(sz)) )
    {
        strHelp = sz;
        return( TRUE );
    }

    return( FALSE );
}

BOOL CMultiEdit::FWhitespaceOnly(PCSTR pCurLine, _CB cbCurLine)
{
    for (IB ib = 0; ib < cbCurLine; ib += _tclen(pCurLine + ib))
    {
        if ( !whitespace(*(unsigned char *)(pCurLine + ib)))
            return( FALSE );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mepublic.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define MAXEDITMGRBUF		256	/* max size of edit mgr buffer */

WORD    wParamMouse;
DWORD   lParamMouse;

char		editbuf[MAXEDITMGRBUF];	/* editmgr line buf */
char		scrchbuf[MAXEDITMGRBUF];/* editmgr scratch buf */
LD ldEMScratch = {		/* editmgr scrach data area */
    0, 0, MAXEDITMGRBUF-1, scrchbuf
};
LD ldEMMultiEdit = {	/* editmgr default scrap */
	0, 0, MAXEDITMGRBUF-1, editbuf
};

IMPLEMENT_DYNCREATE(CMultiEdit, CDockablePartView)

BEGIN_MESSAGE_MAP(CMultiEdit, CDockablePartView)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
   	ON_COMMAND(IDM_GOTO_LINE, OnGotoLine)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo) 
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo) 
   	ON_UPDATE_COMMAND_UI(IDM_GOTO_LINE, OnUpdateGotoLine)
END_MESSAGE_MAP()

CMultiEdit :: CMultiEdit()
{
	m_fUseMultiEdit = FALSE;	// Will be reset when WU_INITDEBUG is received
	m_pDragInfo     = NULL;
	InitEditMgr();
}

BOOL CMultiEdit :: PreTranslateMessage( MSG * pMsg )
{
	BOOL	fRet = FALSE;

	switch (pMsg->message)
    {
		case WM_SYSKEYDOWN:
		case WM_KEYDOWN:
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_MBUTTONDOWN:
		case WM_MBUTTONUP:

		if (CDataTip::GetTip()) CDataTip::GetTip()->DestroyTip();
	}

	if ( pMsg->message == WM_KEYDOWN ) {
		switch ( pMsg->wParam ) {

			// Add keys to this table to bypass global accelerator table!

		/*
			case VK_ESCAPE:
				// If a window needs to get the ESCAPE key, then it should
				// override this PreTranslateMessage and check for a VK_ESCAPE
				// without the CONTROL or SHIFT keys down.  When this condition
				// is met, 'this' should do any checks for "dirtyness" of a
				// buffer and process the event immediately!  Otherwise,
				// the dockmanager will get the key event and do move the
				// active window from the dockable window to the active MDI!
				//
				// MarkBro 11/18/93
				//
		*/

			case VK_TAB:
				// MDI gets Ctrl+Tab.
				if ((GetKeyState(VK_CONTROL) & ~1) != 0) {
					break;
				}
				// fall through

			// Fall through.
			case VK_BACK:
			case VK_DELETE:
			case VK_LEFT:
			case VK_RIGHT:
			case VK_UP:
			case VK_DOWN:
			case VK_END:
			case VK_HOME:
			case VK_NEXT:
			case VK_PRIOR:
			case VK_RETURN:
				TranslateMessage( pMsg );
				DispatchMessage( pMsg );
				fRet = TRUE;
				break;

			case VK_F8:
				if (
					(GetKeyState(VK_CONTROL) & ~1) != 0 &&
					(GetKeyState(VK_SHIFT) & ~1) != 0
				) {
					m_fColumnSelect = TRUE;
					fRet = TRUE;
				}
				break;
				
			default:
				break;
		}
	}

	return( fRet || CPartView::PreTranslateMessage(pMsg) );
}

LRESULT CMultiEdit :: WindowProc(UINT wMsg, WPARAM wParam, LPARAM lParam )
{
	BOOL 	fCallEditProc = TRUE;
	BOOL	fCallBase = FALSE;
	LRESULT	lResult = FALSE;

	// Filter window docking messages
	if (!IsPopupMessage(wMsg) &&
		DkPreHandleMessage(m_hWnd, wMsg, wParam, lParam, &lResult))
	{
		return lResult;
	}

	switch( wMsg ) {
        case WM_SETFOCUS:
            OnViewActivate( this, TRUE );
            break;

		case WM_DESTROY:
        {
			m_fUseMultiEdit = FALSE;

        	switch( m_dt )
            {
        		case CPU_WIN:
        			pViewCpu = NULL;
        			break;
        		case PHINWATCH_WIN:
        			// REVIEW : If we get a WM_VIEWACTIVATE when the
        			// view is being destroyed this is not neccessary.
        			pViewNewWatch = NULL;
        			break;
        		case PHINLOCALS_WIN:
        			pViewNewLocals = NULL;
        			break;
        		case DISASSY_WIN:
        			pViewDisassy = NULL;
        			break;
        		case MEMORY_WIN:
        			pViewMemory = NULL;
        			break;
        		case CALLS_WIN:
        			pViewCalls = NULL;
        			break;
        		default:
        			ASSERT(FALSE);
        			break;
        	}

            break;
        }

		case WU_CLEARDEBUG:
			// Make sure that the LTextProc gets this message
			LTextProc( wMsg, wParam, lParam );
			m_fUseMultiEdit = FALSE;

		case WU_UPDATEDEBUG:
			// When these messages occur, make sure that the window gets
			// completely updated and not just the update region.
			InvalidateRect( (LPRECT)NULL, (BOOL)( wMsg == WU_UPDATEDEBUG ) );
			break;

		case WU_INITDEBUGWIN:
			m_fUseMultiEdit = TRUE;
			LTextProc( wMsg, wParam, lParam );
			SetScrollRange ( SB_HORZ, 0, 0, TRUE );
//SetScrollRange ( SB_VERT, 0, 0, TRUE );

			fCallEditProc = FALSE;
            break;

        case WM_CHAR:
        case WM_KEYDOWN: {
			// Simulate COW key events by adding the shift and control
			// key states in the message parameters.

            WORD    wl = LOWORD( lParam );
            WORD    wh = HIWORD( lParam ) & 0x3fff;

            if ( GetKeyState( VK_SHIFT ) & 0x8000 ) {
                wh |= KK_SHIFT;
            }
            if ( GetKeyState( VK_CONTROL ) & 0x8000 ) {
                wh |= KK_CONTROL;
            }
            lParam = MAKELONG( wl, wh );

			if ( wMsg == WM_CHAR ) {
				// If we haven't received a lead byte,
				// accept one and set the status
				if ( m_fAcceptDbcs ) {
					if ( _ismbblead( LOWORD( wParam ) ) ) {
						m_fAcceptDbcs = FALSE;
						m_bDbcsLead = LOBYTE( LOWORD( wParam ) );

						// Just eat the message since we will
						// pass it on when the second byte is
						// received
						fCallEditProc = fCallBase = FALSE;
					}
				}

				// We have already saved a lead byte and this MUST be
				// the trail byte.  Mask off the high byte of the loword
				// and put in the lead byte.  When the textproc receives
				// the wParam, it will be a complete DBCS character.
				else {
        		    wl = ( LOWORD( wParam ) & 0xff ) | ( m_bDbcsLead << 8 );
    	        	wh = HIWORD( wParam );
	            	wParam = MAKELONG( wl, wh );

					// re-enable accepting of DBCS lead bytes
					m_fAcceptDbcs = TRUE;
				}
			}
            break;
        }

		case WM_FONTCHANGE:
			// We want this message to get through to the TextView
			// wndproc AND then pass it on to the individual window
			break;

        case WM_MOUSEMOVE:
        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_LBUTTONDBLCLK:
            {
				// Mouse messages need to be translated into character coords
				// for the individual wndprocs.  This way it's easy to identify
				// what the textual location of the cursor is.  wParamMouse and
				// lParamMouse are used in the MultiEdit control since it needs
				// the real Windows mouse coordinates.

	            RX    obMouse;
	            RY    olnMouse;

	            obMouse = (SHORT)( ( LOWORD( lParam ) - m_cxSelectMargin ) / m_pFontInfo->m_tm.tmAveCharWidth );
	            olnMouse = (SHORT)( HIWORD( lParam ) / m_pFontInfo->m_tm.tmHeight );

	            wParamMouse = wParam;
	            lParamMouse = lParam;

				lParam = MAKELONG( obMouse, olnMouse );
			}
            break;

        case WM_RBUTTONDOWN:
        	//BLOCK:
        	{
	        	if (!FMouseHitSel(FALSE, lParam))
	        	{
	        		// Hacky way of resetting the cursor.
	        		SendMessage(WM_LBUTTONDOWN, 0, lParam);
	        		SendMessage(WM_LBUTTONUP, 0, lParam);
					UpdateWindow();	// So we don't blow save bits.
	        	}
			}
        	break;

        case WM_RBUTTONUP:
			{
        		CPoint point(lParam);
				ClientToScreen(&point);
				ShowContextPopupMenu(point);
			}
			break;

		case WM_COMMAND:
			if ( wParam ) {
				// All command events should have received
				// a WM_UNDO... message, so ignore the
				// WM_COMMAND stuff!
				fCallEditProc = FALSE;
			}
			break;

        default:
	    	// Copied from qcqp.c ChildWndProc.  Without this, the
	    	// set font and other window commands won't work
			if ( wMsg == WM_VIEWACTIVATE )
				OnViewActivate( this, (BOOL)wParam );

            break;
    }

	if ( fCallBase || !m_fUseMultiEdit ) {
		switch( wMsg )
		{
		case WM_CHAR:
			MessageBeep( 0 );
			// FALL THROUGH //

		case WM_SETFOCUS:
			break;

    	default:
			lResult = CWnd::WindowProc(wMsg, wParam, lParam);
		}
	}
	else if ( fCallEditProc ) {
		lResult = LTextProc( wMsg, wParam, lParam );

		// In order for the debug windows to keep up with the
		// potential rapid fire F10/F8s, force the window to
		// receive it's updates immediately rather than waiting
		// for the input queue to be empty and then having windows
		// send the WM_PAINT on the invalid region
		if ( wMsg == WU_UPDATEDEBUG ) {
			UpdateWindow();
		}
	}

	return lResult;
}

/****************************************************************************

	FUNCTION:   GetCurrentText

	PURPOSE:	
		What is does:
				If there's a selection, return the first line of the selected
				text.  If there's no selection, get the word at the current
				cursor location.

		What it's supposed to do:
			    Retrieve in view the word at cursor, or the first line
				of text if selection is active. If not NULL, beginOffset
				and endOffset return number of chars relative to cursor
				position. If a selection is active and is over several
				lines and cursor in selection is not above a word and
				lookAround is TRUE, the word at left is returned and
				'lookAround' is TRUE, otherwise lookAround is FALSE.

	RETURNS:    FALSE if there is a problem or nothing to get

****************************************************************************/
BOOL CMultiEdit :: GetCurrentText(
	BOOL *lookAround,
	LPSTR pText,
	_CB maxSize,
	ICH * pxLeft,
	ICH * pxRight)
{
	BOOL	fRet = FALSE;

	if ( SendMessage( EM_GETTEXT, (WPARAM)maxSize, (LPARAM)pText ) ) {
		char FAR *	lpch = _ftcschr( pText, _T('\r') );

		if ( lpch ) {
			*lpch = '\0';
		}
		*lookAround = fRet = TRUE;
	}
	else {
		fRet = (BOOL)SendMessage( EM_GETWORD, (WPARAM)maxSize, (LPARAM)pText );
		*lookAround = FALSE;
	}

	// The browser looks at xLeft to NOT be -1 if we've succeeded!
	if ( fRet && pxLeft ) {
		*pxLeft = 0;
	}

	return fRet;
}

void CMultiEdit :: OnFindNext( BOOL * pfSuccess ) {
	MessageBeep(0);
	if ( pfSuccess ) {
		*pfSuccess = FALSE;
	}
}

#ifdef DRAG_DROP
BOOL CMultiEdit::GetDragSourceText(CDragObject& dragObject, HANDLE& hData, long& cchData)
{
	ASSERT(dragObject.InTextView());
	ASSERT(this == dragObject.m_pViewDragFrom);

	if ( hData = (HANDLE)SendMessage( WM_COPY, (WPARAM)0, (LPARAM)-1L ) )
	{
		TCHAR FAR *	lptch;
		
		if ( lptch = (TCHAR FAR *)RealGlobalLock( hData ) )
		{
			cchData = _tcslen( lptch );
			RealGlobalUnlock( hData );
		}
	}
	return (hData != NULL);
}

VOID CMultiEdit::AssimilateDroppedData(CDragObject&, LPSTR, long, POINT)
{
	// If the view supports a drop this is a required override.
	ASSERT(FALSE);
}
#endif // DRAG_DROP

void CMultiEdit :: PosFromPoint( int & X, int & Y, CPoint pt ) {
	if ( pt.x < m_cxSelectMargin ) {
		pt.x = m_cxSelectMargin;
	}

	int tmAveCharWidth = m_pFontInfo->m_tm.tmAveCharWidth;
	X = ( ( pt.x - m_cxSelectMargin + tmAveCharWidth / 2 - 1 ) / tmAveCharWidth )
		* tmAveCharWidth + m_cxSelectMargin;

	int tmHeight = m_pFontInfo->m_tm.tmHeight;
	Y = (pt.y/tmHeight) * tmHeight;
}

#ifdef DRAG_DROP
void CMultiEdit :: SetCaretPosition(RTXVPT txvpt, CTextClip::ScrollActions ScrollAction)
{
	POINT	pt;

	pt.x = txvpt.Ich();
	pt.y = txvpt.Iline();

    SetCaretPos( pt );
}
#endif // DRAG_DROP

BOOL CMultiEdit :: InitEditMgr()
{

	//
	// Set up edit field and associated structures.
	//

	memset( &m_pdCur, 0, sizeof( m_pdCur ) );
	memset( &m_ipCur, 0, sizeof( m_ipCur ) );
	memset( &m_ipAnchor, 0, sizeof( m_ipAnchor ) );

	m_dScrollVal        = 0;
	m_olnMacPrev        = 0;
	m_fScrollV          = TRUE;
	m_fScrollH          = FALSE;
	m_pdCur.oln         = 0xffffffff;
	m_pldCur            = &ldEMMultiEdit;
	m_Style             = ES_MULTILINE;
	m_fSelection        = FALSE;
	m_iAdjustDbcs       = 1;
	m_ipCurOld.oln      = 0xffffffff;
	m_ipCurOld.ob       = 0xffff;
	m_ipAnchorOld.oln   = 0xffffffff;
	m_ipAnchorOld.ob    = 0xffff;
	m_fAcceptDbcs       = TRUE;
	m_fColumnSelect     = FALSE;
	m_pDragInfo         = NULL;

	// undo-redo related.
	m_mePlayCount = REC_CANNOTUNDO;
	m_undoState = usNormal;

	if ( FCanUseMarginSelect() && gpISrc->GetSrcEnvironParam(ENV_ENABLE_MARGIN_GLYPHS) )
		m_cxSelectMargin = gpISrc->GetSrcEnvironParam(ENV_CX_DEFAULT_SELECT_MARGIN);
	else
		m_cxSelectMargin = 0;

	// No longer do allocations, always return true!
	return( TRUE );
}

void CMultiEdit :: DrawWindow() {
	InvalidateRect( NULL, FALSE );
	UpdateWindow();
}

/* MULTIEDIT DEFAULT VIRTUAL FUNCTIONS */
BOOL CMultiEdit :: FReplaceLineBuf( DWORD iln, WORD cb, char * psz ) {
	// Default is no replacing allowed
	return FALSE;
}

BOOL CMultiEdit :: FReadOnlyBuf() {
	// Default is READ_ONLY
	return TRUE;
}

BOOL CMultiEdit :: FIsWordChar( TCHAR ch ) {
    return( ch && ( _istalnum((unsigned char)ch) || _ftcschr(rglan[ESilan()].lszIsIdChar,(_TUCHAR)ch) ) );
}

WORD CMultiEdit :: ObMaxBuf() {
	// By default, MultiEdit docs are axMax chars wide
	return (WORD)axMax;
}

void CMultiEdit :: GetClientRrc( PRRC prrc ) {
	RECT	rect;

	GetClientRect( &rect );

	// The right and bottom may be less than the
	// left and top if the scroll bars are wider than
	// the window is wide/high.  If so, adjust so the
	// values are zero not negative
	if ( rect.right < rect.left ) {
		rect.right = rect.left;
	}
	if ( rect.bottom < rect.top ) {
		rect.bottom = rect.top;
	}

	// Compute RRC of client area.  Only get complete
	// characters (partially clipped, ignore)

    prrc->rxLeft = 0;
    prrc->rxRight = (RX)( ( rect.right - rect.left - m_cxSelectMargin ) / m_pFontInfo->m_tm.tmAveCharWidth );

    prrc->ryTop = 0;
    prrc->ryBottom = (RY)( ( rect.bottom - rect.top ) / m_pFontInfo->m_tm.tmHeight );
}

void CMultiEdit :: InvalidateRrc( PRRC prrc ) {
    RRC     rrc;
    RECT    rect;

    GetClientRrc( &rrc );

    if ( !memcmp( &rrc, prrc, sizeof( RRC ) ) ) {
        GetClientRect( &rect );
    }
    else {
		int tmAveCharWidth = m_pFontInfo->m_tm.tmAveCharWidth;
		int tmHeight = m_pFontInfo->m_tm.tmHeight;

        rect.left = prrc->rxLeft * tmAveCharWidth;
        rect.top = prrc->ryTop * tmHeight;
        rect.right = prrc->rxRight * tmAveCharWidth + m_cxSelectMargin;
        rect.bottom = prrc->ryBottom * tmHeight;
    }
    InvalidateRect( &rect, FALSE );
}

void CMultiEdit :: DrawLine( DWORD oln ) {
	SendMessage( WM_PAINTLINE, 0, oln );
}

DWORD CMultiEdit :: WinHeight( void ) {
	RECT	rect;

	GetClientRect( &rect );

	// if the window is small and the scroll bars take up
	// the remaining client area, it is possible that the
	// client area will be a negative value.  In that case
	// reset the rect so that the returned value is zero
	if ( rect.bottom < rect.top ) {
		rect.bottom = rect.top;
	}

	return (DWORD)( ( rect.bottom - rect.top ) / m_pFontInfo->m_tm.tmHeight );
}

WORD CMultiEdit :: WinWidth( void ) {
	RECT	rect;

	GetClientRect( &rect );

	// if the window is small and the scroll bars take up
	// the remaining client area, it is possible that the
	// client area will be a negative value.  In that case
	// reset the rect so that the returned value is zero
	if ( rect.right < rect.left ) {
		rect.right = rect.left;
	}

	if ( rect.right - rect.left < m_cxSelectMargin ) {
		rect.right = rect.left + m_cxSelectMargin;
	}

	return (WORD)( ( rect.right - rect.left - m_cxSelectMargin ) / m_pFontInfo->m_tm.tmAveCharWidth );
}

WORD CMultiEdit :: ObGetCurPos( void ) {
	return m_ipCur.ob;
}

void CMultiEdit :: SetCurObPos( WORD obNew ) {
	m_ipCur.ob = obNew;
}

DWORD CMultiEdit :: OlnGetCurPos( void ) {
	return m_ipCur.oln;
}

void CMultiEdit :: SetCurOlnPos( DWORD olnNew ) {
	m_ipCur.oln = olnNew;
}

DWORD CMultiEdit :: OlnGetTop( void ) {
	return m_pdCur.olntop;
}

WORD CMultiEdit :: ObGetLeft( void ) {
	return m_pdCur.obleft;
}

void CMultiEdit :: SetCursorAt( WORD ob, DWORD oln ) {
	EMSC	emsc;

	emsc.x1 = emsc.x2 = ob;
	emsc.y = oln;
	CMultiEdit::LTextProc( EM_SELCHARS, 0, (LPARAM)&emsc );
}

void CMultiEdit :: SetWinTopLineCursor(
	DWORD	olnTop,
	WORD	obCursor,
	DWORD	olnCursor
) {

	m_pdCur.olntop = olnTop;
	m_pdCur.oln = (DWORD)-1;
	InvalidateRect( NULL, FALSE );
	SetCursorAt( obCursor, olnCursor );
	UpdateWindow();
}

void CMultiEdit :: SetWinTopLine( DWORD oln ) {
	SetWinTopLineCursor( oln, m_ipCur.ob, oln );
}

void CMultiEdit :: SetWinUpperLeft( WORD ob, DWORD oln ) {
	SetWinTopLineCursor( oln, ob, oln );
}

DWORD CMultiEdit :: GetEditSelection( WORD cbMax, char FAR * lsz ) {
	return (DWORD)SendMessage( EM_GETTEXT, (WPARAM)cbMax, (LPARAM)lsz );
}

DWORD CMultiEdit :: GetEditWord( WORD cbMax, char FAR * lsz ) {
	return (DWORD)SendMessage( EM_GETWORD, (WPARAM)cbMax, (LPARAM)lsz );
}

WORD CMultiEdit :: FInsertMode() {
    return (WORD)fInsertMode;
}

DWORD CMultiEdit :: OlnFromScrollPos( int iScroll ) {
	DWORD	olnMac;
	DWORD	oln;

	if ( m_dScrollVal )
	{
		// 1-1
		oln = (DWORD)( iScroll );
	}
	// else, if the buffer isn't empty, scale
	else if (olnMac = CLinesInBuf())
	{
		oln = (DWORD)( (double)iScroll / (double)SHRT_MAX * (double)olnMac );
	}
	// else buffer's empty, return zero
	else
	{
		oln = 0L;
	}

	return oln;
}

/**** ScrollFromOln                                                     ****
 *                                                                         *
 *  PURPOSE: Given a line number convert to a mapped scroll index          *
 *                                                                         *
 *  INPUTS:                                                                *
 *       oln     Line number to convert                                    *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: index into scroll bar range or zero for failure      *
 *                                                                         *
 *  IMPLEMENTATION: This is a private function, but is in this file to     *
 *  keep it with OlnFromScrollPos                                          *
 *                                                                         *
 ***************************************************************************/
int CMultiEdit :: ScrollFromOln( DWORD	oln ) {
	int	iScroll;
	DWORD	olnMac;

	// If there's a multiplier, use it
	if ( m_dScrollVal )
	{
		iScroll = (int)(oln);
	}

	// else, if the buffer isn't empty calculate a mapped value
	else if ( olnMac = CLinesInBuf() )
	{
		iScroll = (int)( (double)oln / (double)olnMac * (double)SHRT_MAX );
	}

	// else buffer's empty, return zero
	else
	{
		iScroll = 0;
	}

	return iScroll;
}


/**** FlipBytes                                                         ****
 *                                                                         *
 *  PURPOSE: Reverse byte order (toggle big/little endian)                 *
 *                                                                         *
 *  INPUTS:                                                                *
 *       lpb     pointer to byte stream to be reversed                     *
 *       cb      number of bytes in buffer                                 *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *       lpb     byte stream reversed                                      *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CMultiEdit :: FlipBytes( BYTE FAR * lpb, int cb ) {
	if( pDebugCurr && pDebugCurr->MtrcEndian() == endBig ) {
		BYTE	bT;

		while( cb > 1 ) {
			--cb;
			bT = *lpb;
			*lpb = *( lpb + cb );
			*( lpb + cb ) = bT;

			++lpb;
			--cb;
		}
	}
}

BOOL CMultiEdit::Create(LPCSTR lpszClassName, LPCSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
	// m_nID = nID;
	
	DWORD dwStyleEx = 0;

	if (UseWin4Look() && IsKindOf(RUNTIME_CLASS(CDockablePartView)))
	{
		dwStyleEx |= WS_EX_CLIENTEDGE;
		dwStyle &= ~WS_BORDER;
	}

//	if (pContext != NULL)
//		g_pTCreateDoc = (CTextDoc *)(pContext->m_pCurrentDoc);

	if ( !CView::CreateEx(dwStyleEx, AfxRegisterWndClass(CS_DBLCLKS, theApp.LoadCursor(IDC_IBEAM)),
		lpszWindowName,	dwStyle | WS_VISIBLE,
		rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
		pParentWnd->GetSafeHwnd(), (HMENU)nID, pContext) )
    {                                   
		return FALSE;
	}

	m_DropTarget.Register(this);

	return TRUE;
}

void CMultiEdit::OnDraw( CDC *)
{
    // REVIEW: Some paint messages sneak through after we get the WU_CLEARDEBUG
    // We don't need to paint anything since
    // 1) The window is going away.
    // 2) we are going to restart and repaint on WU_INITDEBUGWIN. 
    //  so I am relaxing this assert from FALSE to !m_fUseMultiEdit.
    // However we need to figure out when this is happening and 
    // fix CMultiEdit::WindowProc appropriately.

    ASSERT(!m_fUseMultiEdit);
}

void CMultiEdit::DrawMarginGlyphs(HDC hDC, RECT& rcMargin, UINT uStatus)
{
	FMT_ELEMENT *rgfmtel;

	if ( gpISrc->GetSrcEnvironParam(ENV_ENABLE_MARGIN_GLYPHS) )
	{

		int cxMargin    = rcMargin.right - rcMargin.left;
		int cyMargin    = rcMargin.bottom - rcMargin.top;
		int nMarginSize = min(cyMargin, cxMargin);
		int nGlyphSize  = (nMarginSize - 3) | 1; // at least 2 less and odd

#ifdef CODECOVERAGE
		if (uStatus & COVERAGE_LINE)
		{
			HBRUSH hBrush = CreateSolidBrush(BACKCOLOR(Cols_CodeCoverage));
			HPEN hPen = CreatePen(PS_SOLID, 1, FORECOLOR(Cols_CodeCoverage));
			HBRUSH hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
			HPEN hOldPen = (HPEN)SelectObject(hDC, hPen);

			// Define a circle with center halfway down right side of our
			// glyph space.
			int Radius = cxMargin - 1;
			int xCenter = rcMargin.right - 1;
			int yCenter = rcMargin.top + cyMargin / 2;
			int left = xCenter - Radius;
			int top  = yCenter - Radius;
			int right= xCenter + Radius;
			int bottom = yCenter + Radius;
			int xRadial1 = rcMargin.left;
			int yRadial1 = rcMargin.top;
			int xRadial2 = rcMargin.left;
			int yRadial2 = rcMargin.bottom;

			Pie (hDC, left, top, right, bottom, xRadial1, yRadial1, xRadial2, yRadial2);

			SelectObject(hDC, hOldBrush);
			SelectObject(hDC, hOldPen);
			DeleteObject(hBrush);
			DeleteObject(hPen);
		}
#endif

		if ( uStatus & (BRKPOINT_LINE | DISABLED_BRKPOINT_LINE | MIXED_BRKPOINT_LINE) )
        {
			HBRUSH  hBrush;
			HPEN    hPen;
			HBRUSH  hOldBrush;
			HPEN    hOldPen;

            if ( uStatus & MIXED_BRKPOINT_LINE )
            {
                rgfmtel = gpISrc->GetSourceColor(CLR_BREAKPT);

                hBrush = CreateSolidBrush(GetSysColor(COLOR_GRAYTEXT));
                hPen   = CreatePen(PS_SOLID, 1, rgfmtel->rgbBackground);
            }
            else if ( uStatus & DISABLED_BRKPOINT_LINE )
            {
                rgfmtel = gpISrc->GetSourceColor(CLR_TEXT);
                hBrush  = CreateSolidBrush(rgfmtel->rgbBackground);

                rgfmtel = gpISrc->GetSourceColor(CLR_BREAKPT);
                hPen    = CreatePen(PS_SOLID, 1, rgfmtel->rgbBackground);
            }
            else if ( uStatus & BRKPOINT_LINE )
            {
                rgfmtel = gpISrc->GetSourceColor(CLR_BREAKPT);
                hBrush  = CreateSolidBrush(rgfmtel->rgbBackground);
                hPen    = CreatePen(PS_SOLID, 1, rgfmtel->rgbText);
            }

            hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
            hOldPen   = (HPEN)SelectObject(hDC, hPen);

			RECT rect;

			rect.left   = rcMargin.left + 2;
			rect.top    = rcMargin.top + (cyMargin - nGlyphSize) / 2;
			rect.right  = rect.left + nGlyphSize;
			rect.bottom = rect.top + nGlyphSize;
			Ellipse(hDC, rect.left, rect.top, rect.right, rect.bottom);

			SelectObject(hDC, hOldBrush);
			SelectObject(hDC, hOldPen);
			DeleteObject(hBrush);
			DeleteObject(hPen);
		}

		if (uStatus & CALLER_LINE)
		{
			FMT_ELEMENT *rgfmtelCall = pfmtelFromDocType(CALLS_WIN);

			HBRUSH  hBrush    = CreateSolidBrush( rgfmtelCall[FMTEL_CSHI].rgbBackground );
			HPEN    hPen      = CreatePen(PS_SOLID, 1,  rgfmtelCall[FMTEL_CSHI].rgbText );
			HBRUSH  hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
			HPEN    hOldPen   = (HPEN)SelectObject(hDC, hPen);
			POINT poly [3];
			RECT rect;

			rect.left   = rcMargin.right - (nMarginSize + 2);
			rect.top    = rcMargin.top + (cyMargin - nGlyphSize) / 2;
			rect.right  = rect.left + nGlyphSize;
			rect.bottom = rect.top + nGlyphSize;

			poly[0].x = rect.left;
			poly[0].y = rect.top;
			poly[1].x = rect.right - 1;
			poly[1].y = rect.top + nGlyphSize / 2;
			poly[2].x = poly[0].x;
			poly[2].y = rect.top + nGlyphSize;
			Polygon(hDC, &poly[0], 3);

			SelectObject(hDC, hOldBrush);
			SelectObject(hDC, hOldPen);
			DeleteObject(hBrush);
			DeleteObject(hPen);
		}

		if (uStatus & CURRENT_LINE)
		{
            rgfmtel = gpISrc->GetSourceColor(CLR_CURRENTLINE);

			HBRUSH  hBrush    = CreateSolidBrush(rgfmtel->rgbBackground);
			HPEN    hPen      = CreatePen(PS_SOLID, 1, rgfmtel->rgbText);
			HBRUSH  hOldBrush = (HBRUSH)SelectObject(hDC, hBrush);
			HPEN    hOldPen   = (HPEN)SelectObject(hDC, hPen);
			RECT    rect;

			rect.left   = rcMargin.right - (nMarginSize + 2);
			rect.top    = rcMargin.top + (cyMargin - nGlyphSize) / 2;
			rect.right  = rect.left + nGlyphSize;
			rect.bottom = rect.top + nGlyphSize;

			POINT poly [7];

			poly[0].x = rect.left;
			poly[0].y = rect.top + nGlyphSize / 3;
			poly[1].x = rect.left + nGlyphSize / 2;
			poly[1].y = poly[0].y;
			poly[2].x = poly[1].x;
			poly[2].y = rect.top;
			poly[3].x = rect.right - 1;
			poly[3].y = rect.top + nGlyphSize / 2;
			poly[4].x = poly[2].x;
			poly[4].y = rect.bottom - 1;
			poly[5].x = poly[4].x;
			poly[5].y = rect.bottom - 1 - nGlyphSize / 3;
			poly[6].x = poly[0].x;
			poly[6].y = poly[5].y;
			Polygon(hDC, &poly[0], 7);

			SelectObject(hDC, hOldBrush);
			SelectObject(hDC, hOldPen);
			DeleteObject(hBrush);
			DeleteObject(hPen);
		}
	}
}

void CMultiEdit::ShowContextPopupMenu(CPoint pt)
{
    return;
}

void CMultiEdit::OnEditCopy(void)
{
    SendMessage(WM_COPY, 0, 0L );
}


void CMultiEdit::OnUpdateGotoLine(CCmdUI * pCmdUI)
{
	// bobz - changed so always available due to infoviewer stuff

#if 0
    BOOL bEnable = FALSE;
    if ( IsKindOf(RUNTIME_CLASS(CMemoryView)) || IsKindOf(RUNTIME_CLASS(CDAMView)) )
        bEnable = TRUE;
#endif

    pCmdUI->Enable(TRUE);
}

void CMultiEdit::OnGotoLine( )
{
    ASSERT(IsKindOf(RUNTIME_CLASS(CMemoryView)) || IsKindOf(RUNTIME_CLASS(CDAMView)) );
    GotoLine( ); 
}

BOOL CMultiEdit::FCanUndo( )
{
	return IsEditable() &&
			m_mePlayCount >= 0 && 
			m_undoState == usNormal;
}

BOOL CMultiEdit::FCanRedo( )
{
	return IsEditable() &&
			m_mePlayCount != 0 && 
			m_mePlayCount != REC_CANNOTUNDO &&
			m_undoState == usNormal;

}

void CMultiEdit::OnEditUndo( )
{
	int cReps = max(1, theApp.GetCmdArg());

	for (int i = 0; i < cReps && FCanUndo() ; i++ )
		PostMessage(WM_UNDO, 0, 0L);

	theApp.ClearRepCount();
}

void CMultiEdit::OnEditRedo( )
{
	int cReps = max(1, theApp.GetCmdArg());

	for (int i = 0; i < cReps && FCanRedo() ; i++ )
		PostMessage(WM_UNDO, TRUE, 0L);

	theApp.ClearRepCount();
}

void CMultiEdit::OnUpdateEditUndo(CCmdUI * pCmdUI)
{
	BOOL bEnable = TRUE;
	
	pCmdUI->Enable(FCanUndo());
}

void CMultiEdit::OnUpdateEditRedo(CCmdUI * pCmdUI)
{
	pCmdUI->Enable(FCanRedo());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mwbar.cpp ===
/////////////////////////////////////////////////////////////////////////
//
//	MWBAR.CPP - Memory Window Toolbar Handler
//
//	Copyright (C)1994, Microsoft Corporation
//
//	Purpose: To display and update the memory windows.
//
//  Revision History:
//       Written by: Mark A. Brodsky
//
// 	Notes:
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop


////////////////////////////////////////////////////////////////////////
//
// CMemoryParent
//
// holds the gizmos at the top of the Memory window
//

IMPLEMENT_DYNAMIC(CMemoryParent, CWnd);

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

BEGIN_MESSAGE_MAP(CMemoryParent, CWnd)
	//{{AFX_MSG_MAP(CMemoryParent))
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMemoryParent::CMemoryParent()
{
	m_pView = NULL;
}

int CMemoryParent::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// now create our toolbar...

	m_toolbar.SetDockableID(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_MEMORY_WIN));
	if (!m_toolbar.Create(this, IDD_MEMORYVIEW_DIALOGBAR,
		CBRS_ALIGN_TOP | CBRS_BORDER_3D, AFX_IDW_TOOLBAR))
	{		
		TRACE("Failed to Create/Init Toolbar\n");
		return -1;
	}

	// must manually initialize the dialog bar because there will be no
	// WM_INIT message as there is no dialog per se.  We are just a dialog
	// template...

	if (!m_toolbar.OnInitDialog())
	{
		TRACE("Failed to Init Toolbar\n");
		return -1;
	}

	if (!runDebugParams.fMemoryToolbar)
	{
		m_toolbar.ShowWindow(SW_HIDE);
	}

	return 0;
}

void CMemoryParent::PostNcDestroy()
{
	delete this;	// Dockable windows delete themselves.
}

LRESULT CMemoryParent::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult;
	if (DkPreHandleMessage(m_hWnd, message, wParam, lParam, &lResult))
		return lResult;
	return CWnd::WindowProc(message, wParam, lParam);
}

void CMemoryParent::OnSetFocus(CWnd* pOldWnd)
{
	ASSERT(m_pView != NULL && m_pView->m_hWnd != NULL);
	m_pView->SetFocus();
}

void CMemoryParent::OnSize(UINT nType, int cx, int cy)
{
	if (nType != SIZE_MINIMIZED && cx > 0 && cy > 0)
		RecalcLayout();

	CWnd::OnSize(nType, cx, cy);
}


void CMemoryParent::RecalcLayout()
{
	DOCKPOS dp = DkWGetDock(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_MEMORY_WIN));
	if (UseWin4Look())
		m_toolbar.RecalcBarLayout(dp);

	UINT nIdMemory = IDDW_VCPP_MEMORY_WIN;
	if (dp == dpMDI)
		nIdMemory = AFX_IDW_PANE_FIRST;
	RepositionBars(0, 0xffff, nIdMemory);

	// now do the horizontal computation to move the items to take up available space...

	CRect rcBar, rcEdit, rcBut;
	m_toolbar.GetWindowRect(&rcBar);
	m_toolbar.m_edit.GetWindowRect(&rcEdit);

	int wAvail = rcBar.right - rcBar.left;	 // width of window
	int iOffs  = rcEdit.left - rcBar.left;	 // offset of edit item

	wAvail -= iOffs + 6;			// remove used space + padding

// the following code is here as a reference for when the memory window's
// toolbar has buttons.  The code is just copied out of watchwin.c's toolbar
// stuff
//	int spBut  = rcBut.left - rcEdit.right;	 // spacing to button
//	int wBut   = rcBut.right - rcBut.left;   // width of button
//	wAvail -= iOffs + spBut + wBut + 6;	 	// remove used space + padding

	// we now know how wide we can make the edit item, but lets not
	// make it too small... we'd rather let the button fall off the edge
	// if its going to be too small

//	if (wAvail < 150) wAvail = 150;
	if (wAvail < 24) wAvail = 24;
	if (wAvail == rcEdit.Width()) return;

	HDWP hdwp = ::BeginDeferWindowPos(1);
	hdwp = ::DeferWindowPos(hdwp,m_toolbar.m_edit.m_hWnd,NULL,0,0,wAvail,rcEdit.Height(),
		SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);
	m_toolbar.m_edit.ShowWindow(SW_HIDE);	// 3-d fix - keep window invalid.
	::EndDeferWindowPos(hdwp);
	m_toolbar.m_edit.ShowWindow(SW_SHOWNOACTIVATE);
}

BOOL CMemoryParent::PreTranslateMessage(MSG *pmsg)
{
	if (pmsg->message == WM_SYSKEYDOWN && m_toolbar.PreTranslateSysKey(pmsg))
		return TRUE;

	return CWnd::PreTranslateMessage(pmsg);	
}

BOOL CMemoryParent::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	// Route notifies to main window, for tool tip text handling.
	*pResult = AfxGetMainWnd()->SendMessage(WM_NOTIFY, wParam, lParam);

	return TRUE;
}

//////
// CMemoryDialogBar
//

BEGIN_MESSAGE_MAP(CMemoryDialogBar, C3dDialogBar)
	//{{AFX_MSG_MAP(CMemoryDialogBar))
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CMemoryDialogBar::OnInitDialog()
{
	if (!m_edit.SubclassDlgItem(IDM_CTL_MEMORY_EDIT, this))
	{
		return FALSE;
	}

	m_edit.SetFont(GetStdFont(font_Normal));
	if (UseWin4Look())
	{
		// Use client edge instead of border, but make sure the client are
		// size remains constant.

		CRect rectClient;
		m_edit.GetClientRect(rectClient);

		m_edit.ModifyStyle(WS_BORDER, 0);
		m_edit.ModifyStyleEx(0, WS_EX_CLIENTEDGE);	// Dialog bars don't get 3d dialog.

		::AdjustWindowRectEx(rectClient, m_edit.GetStyle(),
			FALSE, m_edit.GetExStyle());

		m_edit.SetWindowPos(NULL, 0, 0, rectClient.Width(), rectClient.Height(),
			SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);
	}
	
	RecalcBarLayout(DkWGetDock(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_MEMORY_WIN)));

	return TRUE;
}

void CMemoryDialogBar::OnDestroy()
{
	// FUTURE: MFC workaround remove when Olympus #2139 is fixed [rm]
	// this could cancel someone elses tooltip but that's OK since
	// some UI just happened to get rid of this window anyway
	CControlBar::CancelToolTips();
}

void CMemoryDialogBar::OnUpdateCmdUI(CFrameWnd*, BOOL)
{
}

///////
//
// CMemoryEditItem
//

BOOL CMemoryEditItem::PreTranslateMessage(MSG *pmsg)
{
	switch (pmsg->message)
	{
	case WM_KEYDOWN:
		if (pmsg->wParam == VK_RETURN)
		{
			char	sz[ axMax ];
			MWI		mwi = {0};
			CString	str;

			GetWindowText( str );

			_ftcsncpy( sz, (LPCTSTR)str, sizeof( sz ) );
		    sz[ sizeof( sz ) - 1 ] = '\0';

			mwi.szExpr = sz;

		    if ( MWSetAddrFromExpr( &mwi, runDebugParams.iMWAutoTypes ) )
		    {
				// If we get here the window MUST be open already
				ASSERT( pViewMemory );

				// Update the global address
				MWSaveSettings( sz );

				// Update the memory window
				pViewMemory->SendMessage( WM_COMMAND, 0, 0L );
			}
			else
			{
				CVMessage( ERRORMSG, BADADDR, MSGSTRING, (char FAR *)sz );
				DebuggerMessage( Error, 0, (LPSTR)sz, SHOW_IMMEDIATE );
				SetFocus();
				SetSel( 0, -1, TRUE );
			}

			return TRUE;
		}
		else if ( pmsg->wParam == VK_ESCAPE &&
			!( GetKeyState( VK_SHIFT ) & ~1 ) &&
			!( GetKeyState( VK_CONTROL ) & ~1 ))
			{
				ASSERT( pViewMemory );

				PMWI	pmwi = &((CMemoryView *)pViewMemory)->m_mwi;

				SetWindowText( (LPCSTR)pmwi->szExpr );
				SetSel( 0, -1, TRUE );
				pViewMemory->SetFocus();
				return TRUE;
			}
	}

	return CDockEdit::PreTranslateMessage(pmsg);	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mwcache.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//	MW.C - Memory Window Handler
//
//	Copyright (C)1990, Microsoft Corporation
//
//	Purpose: To display and update the memory windows.
//
// 	Notes:
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//// MWCacheDebuggeeData
//
// Purpose: To read in all required debuggee data for repainting a window
// with 1 read, to avoid numerous calls to DHGetDebuggeeBytes.
//
// Input:
//
// Output: None.
//
// Exceptions:
//
// Notes: Uses private locals above
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: CacheDebuggeeData(HLLI *phlli, LPB *plpb )
{
	RRC		rrc;
	WORD	cb;
	WORD	cPage;
	ADDR	addrT;

	if ( !DebuggeeAlive() )
		return;

	// Destroy the old cache before creating a new one
	DestroyCache(phlli, plpb);

	// Begin cache at top of visible window
	MWAddrFromIln( &m_mwi, OlnGetTop(), &addrT );

	// Fiqure out number bytes needed
	GetClientRrc( &rrc );

    // Allow for 1 additional row for partially painted row
	cb = m_mwi.pmwd->cbType * ( rrc.ryBottom + 2 );
    if ( m_mwi.cFmtVals ) {
    	cb *= m_mwi.cFmtVals;
    }
    else {
        cb *= (WORD)rrc.rxRight;
    }

    if ( !cb ) {
        ++cb;
    }

    cPage = ( cb + cbPageMax - 1 ) / cbPageMax;

	if ( ( *plpb = (unsigned char *)_fmalloc( cbPageMax * cPage ) ) &&
        ( *phlli = LLHlliInit( sizeof( MWC ), llfNull, NULL, NULL ) ) ) {
		HLLE	hlleLast = hlleNull;
		LPMWC	lpmwc;
		LPB		lpb = *plpb;
		UOFFSET	uo;
		WORD	cbReq = 0;
        HLLI    hlli = *phlli;

       	// Try to read partial first page
		uo = GetAddrOff( addrT ) & ~( cbPageMax - 1 );
		if ( uo != GetAddrOff( addrT ) ) {
			HLLE	hlle = hlleLast = LLHlleCreate( hlli );

			if ( hlle ) {
				lpmwc = (LPMWC)LLLpvFromHlle( hlle );

				LLAddHlleToLl( hlli, hlle );

				lpmwc->addrBegin = addrT;
				lpmwc->cbReq =
					min( (WORD)( cbPageMax - ( GetAddrOff( addrT ) - uo ) ), cb );
                lpmwc->lpb = lpb;

                lpmwc->cbRead =
                    DHGetDebuggeeBytes( addrT, lpmwc->cbReq, lpb );

				// Don't unlock hlle since it will be unlocked
				// later on.  We will use the lpmwc on the next page
				// to try to have as few entries in this list as possible

				lpb += lpmwc->cbRead;

				// Comparison below checks for overflow in
				// unsigned values.  If there's an overflow,
				// then need to adjust the segment
				if ( uo + cbPageMax < uo ) {
					SetAddrSeg( &addrT, GetAddrSeg( addrT ) + 1 );
				}
				SetAddrOff( &addrT, uo + cbPageMax );

				// If cPage starts out at 1, then we are reading <= 1 pages and
				// we've crossed a page boundary.  If so, don't change cPage,
				// so the loop below doesn't exit before doing anything.
				if ( cPage != 1 || lpmwc->cbReq >= cb ) {
					--cPage;
				}
				cbReq = lpmwc->cbReq;
			}
		}

		// Read remaining full pages and possible partial last page
		while( cPage-- ) {
			MWC	mwc;

			mwc.addrBegin = addrT;
			// If were not on the last page, read an entire page
			if ( cPage ) {
				mwc.cbReq = cbPageMax;
			}
			// Otherwise, read only what's necessary.  The actual
			// number of bytes is the total requested less the
			// total that we've tried to furnish
			else {
				mwc.cbReq = cb - cbReq;
			}
			mwc.lpb = lpb;
			mwc.cbRead = DHGetDebuggeeBytes( addrT, mwc.cbReq, lpb );

			// If the last node was a complete read and the segments
			// match for the next read, then we can extend the previous
			// cache item to include this one
			if ( hlleLast &&
				lpmwc->cbReq == lpmwc->cbRead &&
				GetAddrSeg( lpmwc->addrBegin ) == GetAddrSeg( addrT ) ) {

				lpmwc->cbReq += mwc.cbReq;
				lpmwc->cbRead += mwc.cbRead;
			}
			else {
				HLLE	hlle = LLHlleCreate( hlli );

				if ( hlle ) {
					// Unlock the old last node
					if ( hlleLast ) {
						UnlockHlle( hlleLast );
					}

					// Have the new mwc be the last
					lpmwc = (LPMWC)LLLpvFromHlle( hlle );
					hlleLast = hlle;

					// Add to the list (can't fail) and
					// initialize the mwc's data
					LLAddHlleToLl( hlli, hlle );
					*lpmwc = mwc;

					// Don't unlock the hlleLast since it will
					// be unlocked when we get out of the
					// while loop or we make it back here
				}
				else {
					// Set condition to get out of the while loop
					cPage = 0;
				}
			}

			// Update for the next pass
			cbReq += mwc.cbReq;
			lpb += mwc.cbRead;

			// See if the UNSIGNED offset will overflow to the
			// next segment.  If so, adjust the segment
			if ( GetAddrOff( addrT ) + lpmwc->cbReq < GetAddrOff( addrT ) ) {
				SetAddrSeg( &addrT, GetAddrSeg( addrT ) + 1 );
			}

			// Always page aligned
			SetAddrOff( &addrT, GetAddrOff( addrT ) + cbPageMax );
        }

		if ( hlleLast ) {
			UnlockHlle( hlleLast );
		}
    }
}

//// DestroyCache
//
// Purpose: Free up memory associated with specified cache
//
// Input:
//      phlli   Pointer to list containing cache info
//      plpb    Pointer to buffer for cache data
//
// Output: None.
//
// Exceptions:
//
// Notes: Destroy the list and zero out handle (if not null).  Same
//        for data buffer
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: DestroyCache(
HLLI *  phlli,
LPB *   plpb ) {

    // Destroy the diff info
    if ( *phlli ) {
        LLChlleDestroyLl( *phlli );
        *phlli = (HLLI)NULL;
    }

	// Destroy the data cache
    if ( *plpb ) {
        _ffree( *plpb );
        *plpb = (LPB)NULL;
    }
}

//// UncacheData
//
// Purpose: Free up memory associated with cached debuggee data.
//
// Input: None.
//
// Output: None.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: UncacheData() {
    DestroyCache( &m_hlliCur, &m_rgbCacheCur );
}

//// UncacheAll
//
// Purpose: Free up memory associated with display caches
//
// Input: None.
//
// Output: None.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: UncacheAll() {
    // Destroy the display cache
    DestroyCache( &m_hlliCur, &m_rgbCacheCur );

    // Destroy the diff info
    DestroyCache( &m_hlliPrev, &m_rgbCachePrev );
}

//// LpbFromCache
//
// Purpose: Given a cache and an address, return pointer to data
//  where the cached user memory is.
//
// Input:
//      hlli    	Cache list for data info
//      paddr   	address to get data from cache for
//      cb      	number of bytes at paddr to ensure read for
//		pcbAvail	Number of bytes available for partial reads
//
// Output:
//      returns
//          (LPB)0xffffffffL:  Memory would be cached if there was
//                             data there.
//          (LPB)NULL       :  Memory would not be contained in cache
//          else            :  Valid pointer to cached data
//
// Exceptions:
//
// Notes:
//      This function will return (LPB)NULL if there is no cache
//
///////////////////////////////////////////////////////////////////////////
LPB CMemoryView :: LpbFromCache(
HLLI    	hlli,
PADDR   	paddr,
size_t  	cb,
size_t * 	pcbAvail ) {
    LPB 	lpbRet = 0L;
	size_t	cbRead = 0;
	size_t	cbRequest = cb;
	BOOL    fFound = FALSE;

    // Make sure that there's a list
    if ( hlli ) {
		BOOL	fPartial = FALSE;
        HLLE    hlle = (HLLE)NULL;
        UOFFSET uoReq = GetAddrOff( *paddr );

        // Loop through all entries in cache until exhausted or
        // found
        while( !fFound && ( hlle = LLHlleFindNext( hlli, hlle ) ) ) {
            LPMWC   lpmwc = (LPMWC)LLLpvFromHlle( hlle );

            // First see if segments match up
            if ( GetAddrSeg( *paddr ) == GetAddrSeg( lpmwc->addrBegin ) ) {
                UOFFSET uoSav = GetAddrOff( lpmwc->addrBegin );

                // Segments match up.  See if data is contained within
                // the cached request.
                if ( uoSav <= uoReq && uoReq <= uoSav + lpmwc->cbReq - 1 ) {
					UOFFSET	uoLast = uoReq + (UOFFSET)cb - 1L;

                    // Determine if there is REAL data to satisfy read
                    // request.  If so, return a pointer to the data,
                    // else return 0xffffffff
                    if ( lpmwc->cbRead ) {

						// Entire request can be furnished by this cache
						if ( uoLast <= uoSav + lpmwc->cbRead - 1 ) {
							
							// If !fPartial, then save starting buffer
							// address.  Otherwise, assume that we
							// are attempting to finish a cache read
							// which crosses 2 consecutive caches
							if ( !fPartial ) {
	                        	lpbRet = lpmwc->lpb + uoReq - uoSav;
							}
							// Everything has been read in
							cb = 0;

	                    	fFound = TRUE;
	                    }

						// Cache is not able to fill request, but can
						// fill first part of request and next cache
						// may be able to complete request.  Only do
						// partial reads if pcbAvail != NULL
    	                else if ( lpmwc->cbRead == lpmwc->cbReq && pcbAvail ) {
	                        lpbRet = lpmwc->lpb + uoReq - uoSav;

							// Adjust remaining bytes to read and
							// "beginning" offset
							cb = (size_t)( uoLast - ( uoSav + lpmwc->cbRead - 1 ) );
							uoLast += (UOFFSET)cb;
							fPartial = TRUE;
						}

						// Memory doesn't exist for request to be satisifed
						else {
							fFound = TRUE;
            	        }
					}

					// Memory doesn't exist for request to be satisifed
					else {
						fFound = TRUE;
					}
                }
				else if ( fPartial ) {
					fFound = TRUE;
				}
            }

            UnlockHlle( hlle );
        }
    }

	// If pcbAvail != NULL, then fill in the number of bytes read in.
	// cbRequest is actual requested, cb is remaining bytes to read.
	if ( pcbAvail ) {
		*pcbAvail = cbRequest - cb;

		// If cb == cbRequest, then nothing was read in, but the
		// memory would have been cached if it existed.  But it
		// didn't, so return the number of bytes read plus set the
		// return buffer to indicate that a cached read failed
		if ( cb == cbRequest && fFound ) {
			lpbRet = (LPB)0xffffffffL;
		}
	}

	// Otherwise, if there is anything left to read and at some point
	// we found a buffer with a partial data cached (readable or not),
	// set to a failed read request
	else if ( cb && fFound  ) {
		lpbRet = (LPB)0xffffffffL;
	}

    return lpbRet;
}

//// FCmpUserMemory
//
// Purpose: Compare values with thosed save from the last MWSaveDebuggeData
// call.
//
// Input:
//		paddr	Address of debugged data we're to compare.
//		cbCmp	Number of BYTES to compare.
//		rgbCmp	Data to compare against the debuggee.
//
// Output:
//		Return TRUE if:
//			1) We don't have the debuggee data to compare against, or
//			2) The data are equivalent.
//		Return FALSE if:
//			The data is different.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
BOOL CMemoryView :: FCmpUserMemory(
PADDR	paddr,
USHORT	cbCmp,
BYTE *	rgbCmp ) {
	BOOL	fRet = TRUE;
    LPB     lpb1;

    // Locate display data in cache
    lpb1 = LpbFromCache( m_hlliCur, paddr, cbCmp );

    // If the data's there, continue
    if ( lpb1 && lpb1 != (LPB)0xffffffffL ) {

        // Locate the compare data in the other cache
        LPB lpb2 = LpbFromCache( m_hlliPrev, paddr, cbCmp );

        // If the data's there, then do the compare
        if ( lpb2 && lpb2 != (LPB)0xffffffffL ) {
            switch( cbCmp ) {
                case 1:
                    fRet = *lpb1 == *lpb2;
                    break;

                case 2:
                    fRet = *(UNALIGNED short FAR *)lpb1 == *(UNALIGNED short FAR *)lpb2;
                    break;

                case 4:
                    fRet = *(UNALIGNED long FAR *)lpb1 == *(UNALIGNED long FAR *)lpb2;
                    break;

                case 8: {
                    UNALIGNED long FAR *  lpl1 = (UNALIGNED long FAR *)lpb1;
                    UNALIGNED long FAR *  lpl2 = (UNALIGNED long FAR *)lpb2;

                    fRet = *lpl1 == *lpl2 && *(lpl1 + 1) == *(lpl2 + 1);
					break;
				}

                default:
                    fRet = !_fmemcmp( lpb1, lpb2, cbCmp );
                    break;
            }
        }
    }

	return fRet;
}

//// CbGetDebuggeeBytes
//
// Purpose: Get debuggee data from cached memory to avoid the hit of
// DHGetDebuggeeBytes() calls.
//
// Input:
// 	paddr		Debuggee address to get bytes for.
// 	cbNeeded	# of bytes requested
//
// Output:
// 	lpb		far pointer to buffer to stuff debuggee data.
//
// Return value: Returns the number of bytes actually gotten.
//
// Exceptions:
//
// Notes: If the requested data is not-cached, or there is no cache,
// we will call DHGetDebuggeeBytes() for the request.
//
///////////////////////////////////////////////////////////////////////////
USHORT CMemoryView :: CbGetDebuggeeBytes(
PADDR		paddr,
size_t	    cbNeeded,
BYTE far * 	lpb ) {
	USHORT	cbRet;
    LPB     lpbCache;
	size_t	cbOriginal;

	cbRet = 0;
	cbOriginal = cbNeeded;

	// Let the world know somebody wants nothing.
	ASSERT( cbNeeded );

    // Try to get the data from the cache as it is now
    lpbCache = LpbFromCache( m_hlliCur, paddr, cbNeeded, &cbNeeded );

    // If the read fails, reset the cache and try again
    if ( !lpbCache ) {
        CacheDebuggeeData( &m_hlliCur, &m_rgbCacheCur );
        lpbCache = LpbFromCache( m_hlliCur, paddr, cbOriginal, &cbNeeded );
    }

    // If the read failed from the cache, just go to OSDebug for the read
    if ( !lpbCache ) {
		cbRet = DHGetDebuggeeBytes( *paddr, cbOriginal, lpb );
    }

    // Otherwise, if the lpbCache is NOT -1, then copy the data.  If it
    // is -1, then OSDebug wouldn't be able to satisfy request, so fail

    else if ( lpbCache != (LPB)0xffffffffL ) {
		_fmemcpy( lpb, lpbCache, cbNeeded );
        cbRet = cbNeeded;
    }

    return cbRet;
}

//// FPutDebuggeeBytes
//
// Purpose: To change debuggee data, but keep old data for undo
//
// Input:
//		ucls	Input class (MW_RAW, MW_ASCIIDAT, MW_FMT)
//	 	paddr	Address of changed data
//	 	cb		# of bytes to change
//	 	rgb		Data to update to
//	 	hlli	Linked list information associated with window
//
// Output: Returns TRUE if write succeeded
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
BOOL CMemoryView :: FPutDebuggeeBytes(
USHORT	ucls,
PADDR	paddr,
size_t	cb,
LPB 	rgb,
HLLI	hlliUndo,
HLLI	hlliRedo
) {
	HLLE	hlle;
	LPMUB	lpmub;
	BOOL	fUpdate;
	size_t	cbWritten;
	LPB		lpb;

	// fUpdate indicates if we need to update the list of undoable
	// data.
	fUpdate = TRUE;

	// See if the address and size of the last change matches the current.
	// If so, don't add new item to the list.  Assume that they're changing
	// another digit of the same item.

	if ( hlle = LLHlleGetLast( hlliUndo ) ) {
		lpmub = (LPMUB)LLLpvFromHlle( hlle );
		if ( GetAddrSeg( lpmub->addr ) == GetAddrSeg( *paddr ) &&
			GetAddrOff( lpmub->addr ) == GetAddrOff( *paddr ) &&
			lpmub->cb == cb ) {
			fUpdate = FALSE;
		}
		UnlockHlle( hlle );
	}

	// If the value is not at the end of the list, save the old version
	// of the data before writing the new
	if ( fUpdate ) {
		if ( hlle = LLHlleCreate( hlliUndo ) ) {
			size_t	cbRead;

			lpmub = (LPMUB)LLLpvFromHlle( hlle );
			lpmub->ucls = ucls;
			lpmub->pmwd = m_mwi.pmwd;
			lpmub->addr = *paddr;
			
			// Try to get old data from cache
			if ( lpb = LpbFromCache( m_hlliCur, paddr, cb, &cbRead ) ) {
				if ( lpb != (LPB)0xffffffffL ) {
					_fmemcpy( lpmub->rgb, lpb, cbRead );
				}
			}
			// If not in the cache, go to OSDebug
			else {
				cbRead = DHGetDebuggeeBytes( *paddr, cb, (char far *)lpmub->rgb );
			}

			lpmub->cb = cbRead;

			UnlockHlle( hlle );
			LLAddHlleToLl( hlliUndo, hlle );
			m_undoBuffer = ubUndo;
		}
	}

	// Thow away redo buffer
	m_mePlayCount = 0;

	while( LLFDeleteHlleIndexed( hlliRedo, 0L ) );

	cbWritten = DHPutDebuggeeBytes( *paddr, cb, rgb );

	// Only update the display cache if the WRITE succeeded.  We
	// may have read-only data and we don't want to update the
	// display if we couldn't change the user's memory
	if ( cbWritten ) {
		// Update the cached display data so the cache doesn't
		// need to be invalidated and reloaded.  If it's not
		// already in the cache, we don't have to worry since
		// it will be cached later or read from OSDebug
		if ( ( lpb = LpbFromCache( m_hlliCur, paddr, cbWritten ) ) &&
			lpb != (LPB)0xffffffffL ) {

			_fmemcpy( lpb, rgb, cbWritten );
		}
	}

	return cbWritten == cb;
}

//// SaveDebuggeeData
//
// Purpose: Retrieve the debuggee data for compares to show changes
// between debuggee execution.
//
// Input: None.
//
// Output: None.
//
// Exceptions:
//
// Notes: Save debuggee data.  This data is used for showing diffs
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: SaveDebuggeeData() {
     // Load the cache with private args
	CacheDebuggeeData( &m_hlliPrev, &m_rgbCachePrev );
}

//// ChangeDebuggeeData
//
// Purpose: Visible portion of MW display changed, adjust diff's cache
//          so that user will see diffs for direct edits
//
// Input: None.
//
// Output: None.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: ChangeDebuggeeData() {
	ADDR	addrMin;
	ADDR	addrMac;
	USHORT	cb;
	RRC		rrc;

	// Compute #of bytes displayed in window
	GetClientRrc( &rrc );
	cb = m_mwi.pmwd->cbType * m_mwi.cFmtVals * ( rrc.ryBottom + 1 );

	MWAddrFromIln( &m_mwi, OlnGetTop(), &addrMin );
	addrMac = addrMin;
	SetAddrOff( &addrMac, GetAddrOff( addrMin ) + (UOFFSET)cb - 1 );

    // If either end of the visible data is not cached, reset
    // the cache.  Otherwise, leave it alone.
    if ( !LpbFromCache( m_hlliPrev, &addrMin, 1 ) ||
        !LpbFromCache( m_hlliPrev, &addrMac, 1 ) ) {

        SaveDebuggeeData();
    }
}

//// MWUpdateWorld
//
// Purpose: A memory value has changed, update all other windows
//
// Input:
//	paddr	Address to be updated.
//	cb	Number of bytes being updated.
//
// Output:
//	Windows are updated.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView::UpdateWorld(PADDR paddr, USHORT cb) 
{
	Unreferenced ( paddr );
	Unreferenced ( cb );

	UpdateDebuggerState( UPDATE_ALLDBGWIN & ~UPDATE_MEMORY );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mwcore.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//	MW.C - Memory Window Handler
//
//	Copyright (C)1990, Microsoft Corporation
//
//	Purpose: To display and update the memory windows.
//
// 	Notes:
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//// CchFormatData
//
// Purpose: Format real data into display format.  Broken out from
// MWFormatLine so the compiler can optimize.
//
// Input:
//	 	imwd		Format to use.
//      fShowRaw    If RAW data is being displayed (affects MBCS ASCII)
//	 	rgb			Data to format.
//
// Output:
//		sz			Where to put the formatted data
//		pchAscii	If BYTE display, here's where to put the ascii data
//      pfmbcs      pointer to BOOL indicating if ASCII char processed
//                  is MBCS char.
//
// 	Returns number of characters added to sz.
//
// Exceptions:
//
// Notes:
//      !!! If you dereference rgb as anything other than a 1-byte quantity
//      !!! be sure to use UNALIGNED so as not to fault on MIPS
//
///////////////////////////////////////////////////////////////////////////
int CMemoryView :: CchFormatData(USHORT imwd, BOOL fShowRaw, BYTE *rgb, char *sz, char *pchAscii, BOOL *pfmbcs)
{
	int	cch = 0;

	switch( imwd ) {
		case MW_ASCII:
			cch = 1;

			// If not processing second mbcs byte, handle
			// normally
			if ( !*pfmbcs )
            {
				// If any of the conditions are FALSE, then
				// we want to evaluate the char as an MBCS
				// character.  Else it must be a single byte
				// char
				if (fShowRaw || !FDbcsEnabled() || !_ismbblead(*(UCHAR *)rgb) )
                {
					if ( isprint( *rgb ) || _ismbbkana( *rgb ) ) {
						*sz = *(char *)rgb;
					}
					else {
						*sz = '.';
					}
				}
				// MB char (possibly.  Validate the second byte
				else {
					// Second byte is valid trail byte, set
					// flag and copy 2 bytes
                    if ( _ismbbtrail( *(UCHAR *)( rgb + 1 ) ) ) {
                        *pfmbcs = TRUE;
                        *sz = *rgb;
                        *( sz + 1 ) = *( rgb + 1 );
                    }

					// Invalid trail byte.  Treat as non-printable
					// single byte char
                    else {
                        *sz = '.';

                    }
				}
			}
			else {
				*pfmbcs = FALSE;
			}
			break;

#ifdef _WIN32
        case MW_WCHAR: {
			wchar_t	wc;
			char	rgchMB[ 5 ];

			ASSERT( sizeof( rgchMB ) >= MB_CUR_MAX );
				
			FlipBytes(rgb, 2);
			wc = *(UNALIGNED wchar_t *)rgb;

			*sz = '\0';
			if ( iswprint( wc ) && wctomb( rgchMB, wc ) != -1 ) {
				sprintf( sz, "%-2lc", wc );
				ASSERT( _tcslen( sz ) == 2 );
				cch = 2;
			}
			else {
				_tcscpy( sz, ". " );
				cch = 2;
			}
			break;
		}
#endif	// _WIN32

		case MW_BYTE:
			*sz++ = mpbHex[ *rgb >> 4 & 0x0f ];
			*sz = mpbHex[ *rgb & 0x0f ];
			cch = 2;

            CchFormatData(
                MW_ASCII,
                FALSE,
                rgb,
                pchAscii,
                (char *)NULL,
                pfmbcs
            );
			break;

		case MW_INT:
			FlipBytes(rgb, 2);
			cch = sprintf( sz, "%6d", *(UNALIGNED short *)rgb );
			break;

		case MW_INT_HEX:
			FlipBytes(rgb, 2);
			cch = sprintf( sz, "%04X", *(UNALIGNED USHORT *)rgb );
			break;

		case MW_INT_UNSIGNED:
			FlipBytes(rgb, 2);
			cch = sprintf( sz, "%5u", *(UNALIGNED USHORT *)rgb );
			break;

		case MW_LONG:
			FlipBytes(rgb, 4);
			cch = sprintf( sz, "%11ld", *(UNALIGNED long *)rgb );
			break;

		case MW_LONG_HEX:
			FlipBytes(rgb, 4);
			cch = sprintf( sz, "%08lX", *(UNALIGNED long *)rgb );
			break;

		case MW_LONG_UNSIGNED:
			FlipBytes(rgb, 4);
			cch = sprintf( sz, "%10lu", *(UNALIGNED ULONG *)rgb );
			break;

		case MW_REAL:
			FlipBytes(rgb, 4);
			cch = sprintf( sz, "%+.5E", *(UNALIGNED float *)rgb );
			break;

		case MW_REAL_LONG:
			FlipBytes(rgb, 8);
			cch = sprintf( sz, "%+.14lE", *(UNALIGNED double *)rgb );
			break;

#ifndef _WIN32
		case MW_REAL_TEN:
			sz += ( cch = sprintf( sz, "%+.19LE", *(long double *)rgb ) );
			if ( *( sz - 5 ) == 'E' ) {
				memmove( ( sz - 2 ), ( sz - 3 ), 3 );
				*( sz - 3 ) = '0';
				++sz;
				++cch;
			}
			break;
#else	// !_WIN32
#if _INTEGRAL_MAX_BITS >= 64
		case MW_INT64:
			FlipBytes(rgb, 8);
			cch = sprintf( sz, "%20I64d", *(UNALIGNED __int64 *)rgb );
			break;

		case MW_INT64_HEX:
			FlipBytes(rgb, 8);
			cch = sprintf( sz, "%016I64X", *(UNALIGNED __int64 *)rgb );
			break;

		case MW_INT64_UNSIGNED:
			FlipBytes(rgb, 8);
			cch = sprintf( sz, "%20I64u", *(UNALIGNED __int64 *)rgb );
			break;
#endif	// _INTEGRAL_MAX_BITS >= 64
#endif	// !_WIN32
    }
	return cch;
}

//// FormatLine
//
// Purpose: Format a given line for the specified window
//
// Input:
//		iLn		Relative line number to format
//		sz		Buffer for formatted line (assumes sizeof( sz ) == axMax )
//
// Output:
//		sz			is filled with the line data for the requested line.
//		m_mwi.rgf	contains the information indictating debuggee
//					data change since the last debuggee execution.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: FormatLine(
DWORD	iln,
char *	sz ) {
	ADDR		addrT;
	BYTE *		pbT;
	const MWD * pmwd;
	USHORT		cItemsLeft;
	USHORT		cb;
	USHORT		imwd;
	USHORT		cbNeeded;
	USHORT		cbRequest;
	char		szAscii[ cchBufMax ];
	USHORT		ichCur;
	USHORT		cchPadT;
	BOOL FAR *	lpf;
	BYTE		rgb[ cbDataMax + 1 ];
	short		dSeg;
	BOOL 		fmbcs = FALSE;

	pmwd = m_mwi.pmwd;
	imwd = pmwd - rgmwd;
	cbNeeded = pmwd->cbType;

	lpf = m_mwi.rgf;

	ichCur = 1;
	// We require an additional space between the byte data and the
	// ASCII data, so ...
	*szAscii = ' ';
	cchPadT = ( imwd == MW_BYTE ? 1 : cchPad );

	cItemsLeft = m_mwi.cFmtVals;

	// Get address for line
	MWAddrFromIln( &m_mwi, iln, &addrT );

	// Format address
	// Don't forget 16:32, 0:32???  have expression evaluator for
	// OSDEB format addresses
	dSeg = (short)GetAddrSeg( addrT ) - (short)GetAddrSeg( m_mwi.addr );

	dSeg += (short)GetAddrSeg( m_mwi.addr );

	SetAddrSeg( &addrT, (SEGMENT)dSeg );

	if ( ADDR_IS_FLAT( addrT ) ) {
		ASSERT( ADDR_IS_OFF32( addrT ) );
		sz += sprintf( sz, "%.8lX  ", GetAddrOff( addrT ) );
	}
	else {
		sz += sprintf( sz, "%.4X:%.*X  ", GetAddrSeg( addrT ),
			ADDR_IS_OFF32( addrT ) ? 8 : 4,
			GetAddrOff( addrT ) );
	}

	cbRequest = cbNeeded;

	// For DBCS and ASCII or BYTE mode, we will need to read an
	// extra byte so we can display DBCS caracters.
	if ( FDbcsEnabled() && ( imwd == MW_BYTE || imwd == MW_ASCII ) ) {
		++cbRequest;
	}

	while( cItemsLeft-- ) {
		// Get the data from the debuggee

		// If we are on the last item, do not read any extra bytes
		// for DBCS.  We want there to be an invalid trail byte so
		// it gets displayed as a '.'.  So just reset the number
		// of bytes to read to the actual number for this display type
		if ( cItemsLeft == 0 ) {
			cbRequest = cbNeeded;
		}

		// Set the byte after sizeof data to zero.  If MBCS and the last
		// byte is a lead byte, zero is an invalid trailing byte
		rgb[ cbNeeded ] = 0;

		if (cbNeeded > CbGetDebuggeeBytes( &addrT, cbRequest, rgb )) {

			// We were not able to get enough bytes to display
			// the entire value, so print out "?"s for bogus
			// values.
			if ( m_mwi.fShowRaw && imwd != MW_BYTE ) {
				cb = cbNeeded;
				while( cb-- ) {
					*sz++ = ' ';
					*sz++ = '?';
					*sz++ = '?';
					*lpf++ = TRUE;
				}
				ASSERT( cchPad == 2 );
				*sz++ = ' ';
				*sz++ = ' ';
			}
			memset( sz, '?', pmwd->cchFormatted );
			sz += pmwd->cchFormatted;
			*lpf++ = TRUE;
			szAscii[ ichCur++ ] = '?';
		}
		else {
			BOOL	fmbcsPrev;

			if ( m_mwi.fShowRaw && imwd != MW_BYTE ) {
            	ADDR    addrRaw = addrT;
				BOOL	fNoChange = TRUE;

				pbT = rgb;
				cb = cbNeeded;
				while ( cb-- ) {
					fNoChange &=
						( *lpf++ = FCmpUserMemory(
							&addrRaw,
							sizeof(BYTE),
							pbT )
						);

					*sz++ = ' ';
					*sz++ = mpbHex[ *pbT >> 4 & 0x0f ];
					*sz++ = mpbHex[ *pbT & 0x0f ];
					++pbT;
					// Update address packet.
					// If we're on the last byte of a
					// segment, update segment in
					// addr packet.
					if ( GetAddrOff( addrRaw ) ==
						(UOFFSET)(-1) ) {
						SetAddrSeg( &addrRaw,
							GetAddrSeg( addrRaw ) + 1 );
					}
					SetAddrOff( &addrRaw,
						GetAddrOff( addrRaw ) + 1 );
				}
				ASSERT( cchPad == 2 );
				*sz++ = ' ';
				*sz++ = ' ';

				*lpf++ = fNoChange;
			}
			else {
				*lpf++ = FCmpUserMemory( &addrT, cbNeeded,
					rgb );
			}

			// Format the real data

			fmbcsPrev = fmbcs;

			sz += CchFormatData(
                imwd,
                m_mwi.fShowRaw,
                rgb,
                sz,
                &szAscii[ ichCur++ ],
                &fmbcs
            );

			// If the following conditions are met, we have just formatted a
			// dbcs character.  Go back and make sure that the differences
			// for the two bytes are the same
			if ( !fmbcs && fmbcsPrev && imwd == MW_ASCII && !m_mwi.fShowRaw ) {
				*( lpf - 2 ) = *( lpf - 1 ) = ( *( lpf - 2 ) && *( lpf - 1 ) );
			}
		}

		// Put padding between the data.
		if ( !IsCharFormat( imwd ) || m_mwi.fShowRaw ) {
			memset( sz, ' ', cchPadT );
			sz += cchPadT;
		}

		// Update address packet
		if ( GetAddrOff( addrT ) >= (UOFFSET)-(long)cbNeeded ) {
			SetAddrSeg( &addrT, GetAddrSeg( addrT ) + 1 );
		}
		SetAddrOff( &addrT, GetAddrOff( addrT ) + cbNeeded );
	}

	*sz = chNull;

	// If we're in BYTE mode, append the ASCII data to the end of the
	// line.
	if ( imwd == MW_BYTE ) {
		szAscii[ ichCur ] = chNull;
		_ftcscat( sz, szAscii );

		if ( FDbcsEnabled() ) {
			BOOL FAR *	lpfCur = m_mwi.rgf;
			BOOL FAR *	lpfMax = lpf;
			char *		pch = szAscii + 1;

	        // Walk through the MBCS string and keep track of duplicates
	        // Create the ASCII diffs by walking the previous diffs and
	        // checking character length
	        while( lpfCur < lpfMax ) {
				size_t	cch = _tclen( pch );

				pch += cch;
	            if ( cch == 1 ) {
	                *lpf++ = *lpfCur++;
	            }
	            else {
	                BOOL    fT;

	                ASSERT( cch == 2 );

	                //
	                // The optimizer screws up if the following is done,
	                // which is why there's a temporary fT
	                // *lpf++ = *lpf++ = *lpfCur && *( lpfCur + 1 )
	                //
	                fT = *lpfCur && *( lpfCur + 1 );
	                *lpf++ = fT;
	                *lpf++ = fT;
	                lpfCur += 2;
	            }
	        }
		}
		else {
			// Duplicate the byte value changes.  Simple 1-1 correlation.
			_fmemcpy(
				lpf,
				m_mwi.rgf,
				(size_t)( sizeof( BOOL ) * ( lpf - m_mwi.rgf ) )
			);
		}
	}
	// Create the line attribute information in the m_rgla buffer.
	BuildRgla();
}

//// MWSetAddrFromExpr
//
// Purpose: Reevaluate the expression from the specified window.
//
// Input:
//	pmwi		Pointer to MWI data containing addr packet for evaluation.
// iAutoType	Auto type setting.
//					-1 = Auto type enabled, use HEX, update mwi
//					 0 = Auto type disabled, don't update mwi
//					 1 = Auto type enabled use, [un]signed, update mwi
//
// Output:
//	Returns FALSE for failure or TRUE for success.  If successful,
//	the addr packet in pmwi is updated.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
USHORT PASCAL MWSetAddrFromExpr( PMWI pmwi, int iAutoType ) {
	USHORT		usRet = FALSE;
	ADDR		addrT = {0};
	char *		psz;
	char *		pszExpr;
	int			radixInputSave = radixInput;
	BOOL		fSourceExpr = FALSE;

    ASSERT( pmwi );

	errno = CV_NOERROR;

    if ( !pmwi->szExpr ) {
        return ( usRet );
    }

	// Force the expression to hex if the address started with a zero
	pszExpr = psz = pmwi->szExpr;
	if ( *psz == '0' ) {
		while( *psz && *psz == '0' ) {
			++psz;
		}

		// The zero is required for specifying hex or dex (ie 0n10 or 0x1fa)
		if ( psz > pszExpr &&
			( !*psz || *psz == 'n' || *psz == 'N' || *psz == 'x' || *psz == 'X' )
		) {
			--psz;
		}
	}
	else {
		TCHAR FAR *	lptch = (TCHAR FAR *)psz;

		if ( _ftcschr( lptch, _T('{') ) ) {
			// Character past context
			lptch = _ftcschr( lptch, _T('}') ) + 1;

			if((int)lptch == 1)
				// _ftcschr didn't find a '}' and returned 0.
				return FALSE;
		}

		// Skip white space
		while( _istspace( (_TUCHAR)*lptch ) ) {
			lptch = _ftcsinc( lptch );
		}

		// Source line must have a period or an 'at sign' as the
		// 1st character outside of a context operator
		if ( *lptch == '.' || *lptch == '@' ) {
			fSourceExpr = TRUE;
		}
	}
	

	// Default to hex
	radixInput = 16;

    // Line number or simple address expression
    if ( fSourceExpr && line_number_address( &addrT, EEDATA | EECODE, psz ) ) {
		usRet = TRUE;
    }
    // Complex expression
    else if ( errno != NOCODE ) {
	    HTM			htm;
    	PCXF		pcxf = PcxfLocal();
    	PCXT		pcxt = SHpCXTFrompCXF( pcxf );

    	if ( ( CVParseBind (
    		    &htm, pcxt, radixInput, fCaseSensitive, TRUE, psz ) == EENOERROR
    		) &&
		     ( EEvaluateTM ( &htm, SHpFrameFrompCXF( pcxf ),
                            EEHORIZONTAL ) == EENOERROR ) ) {

#ifdef AUTO_DEREF
			EEPDTYP	eepdtyp = EEIsExpandable( &htm );

			// If the expression is a pointer, then display
			// what it points to, not the address of the address
			if ( eepdtyp == EETYPEPTR || eepdtyp == EEPOINTER ) {
				EEHSTR	eehstr;

				// The EE has the address of the pointer internally, but
				// there is no API to access it.  So, just get the string
				// value from the EE and reparse it as a constant address
				// to build up the addr packet
				if (!EEGetValueFromTM( &htm, radixInput, (PEEFORMAT)"p", &eehstr )) {
					LPSTR		lpstr = (LPSTR)BMLock( eehstr );
					TCHAR FAR *	lptch = (TCHAR FAR *)lpstr;

					// strip off ANYTHING past and address field
					while( *lptch && !_istspace( *lptch ) ) {
						lptch = _ftcsinc( lptch );
					}
					*lptch = '\0';
					if ( line_number_address( &addrT, EEDATA | EECODE, lpstr ) ) {
						usRet = TRUE;
					}

					BMUnlock( eehstr );
					EEFreeStr( eehstr );
				}
	 		}
#endif	// AUTO_DEREF

			// Get the address of the TM if it wasn't an lvalue
			if ( !usRet ) {
	            USHORT	usSegType = EEANYSEG;

	            if ( !BPADDRFromTM ( &htm, &usSegType, &addrT ) ) {
				    usRet = TRUE;
    			}
			}
	    	EEFreeTM( &htm );
    	}
    }

	// Have a parsed address in addrT, adjust so the number of lines
	// is correct
    if ( usRet ) {
		// We only deal with fixed up addresses.  So fix it up and
		// save in the mwi
		SYFixupAddr( &addrT );
		pmwi->addr = addrT;

        if ( MWIlnFromAddr( pmwi, &addrT ) >= pmwi->cLines ) {
            ++pmwi->cLines;
        }
        else {
            MWAddrFromIln( pmwi, pmwi->cLines - 1, &addrT );

            if ( ADDR_IS_FLAT( addrT ) && !GetAddrOff( addrT ) ||
                !LOWORD( GetAddrOff( addrT ) ) ) {

                --pmwi->cLines;
            }
        }
    }

	// Restore the radix
	radixInput = radixInputSave;

	return usRet;
}

//// MWChangeTitle
//
// Purpose: Change the title of the specified window.  The status window is
// NOT updated.
//
// Input:
//
// Output: The information in the cvWin struct is updated in ChangeTitle()
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: ChangeTitle() {
	CMemoryParent *	pMemoryParent = (CMemoryParent *)GetParent();

	ASSERT(pMemoryParent->IsKindOf(RUNTIME_CLASS(CMemoryParent)));
	pMemoryParent->m_toolbar.m_edit.SetWindowText( (LPCSTR)m_mwi.szExpr );
	pMemoryParent->m_toolbar.m_edit.SetSel( 0, -1, TRUE );
}

//// NextField
//
// Purpose: Move the cursor in the desired direction to the next field of
// any type (address, raw, or formatted).
//
// Input:
//		sDirection	One of MW_FWD or MW_REV.
//		fUpdate		Update the screen (TRUE), else update the editmgr info
//
// Output:  Screen is updated to have cursor on new position and visible.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: NextField(
short	sDirection,
BOOL	fUpdate ) {
	const MWD * pmwd;
	WORD		ich;
	DWORD		iln;
	DWORD		ilnMac;
    WORD FAR *  lpw;
    WORD FAR *  lpwMin;
    WORD FAR *  lpwMac;
    WORD        wT;

	pmwd = m_mwi.pmwd;

    lpw = lpwMin = m_mwi.rgwLineInfo + 1;
    lpwMac = lpw + m_mwi.cwLineInfo - 1;

	ich = ObGetCurPos();
	iln = OlnGetCurPos();

    if ( FDbcsEnabled() && sDirection == MW_FWD ) {
    	char		sz[ axMax ];

	    FormatLine( iln, sz );
	    if( _ismbblead( *( sz + ich ) ) ) {
        	ich++;
	    }
    }

    lpw += ich;

	if ( lpw <= lpwMac ) {
		wT = *lpw;

		// Locate different field in specified direction
        while( *lpw && *lpw == wT ) {
			lpw += sDirection;
		}

		// Skip over blanks (if any)
        while( *lpw && *lpw == wNoType ) {
			lpw += sDirection;
		}
	}
	else {
	    lpw = lpwMac;
		if ( sDirection == MW_FWD ) {
			++lpw;
		}
	}

	// If we're on top of a valid field, look for the first occurance of
	// the character and that's where the cursor belongs.
    if ( lpwMin <= lpw && lpw <= lpwMac ) {
        wT = *lpw;
        while( *( lpw - 1 ) == wT ) {
            --lpw;
        }
        ich = lpw - lpwMin;
	}
	// If we're at the beginning or the buffer and the cursor was beyond
	// the address portion and we were going backwards, put the cursor
	// on the beginning of the address field.
	else if ( sDirection == MW_REV && lpw == lpwMin - 1 && ich >= m_mwi.cchAddr ) {
		ich = 0;
	}
	// Otherwise, we're either past the end of the line or at the
	// beginning...
	else {
		iln += (DWORD)sDirection;
		ilnMac = m_mwi.cLines - 1;

		// Make sure that the new line number is valid
		if ( iln >= ilnMac ) {
			iln = ilnMac;
		}
		// If FWD put cursor on address field, otherwise,
		// put cursor on first occurence of last field.
		if ( sDirection == MW_FWD ) {
			ich = 0;
		}
		else {
			// Find the end of the string and get the
			// preceeding char.
            lpw = lpwMac;
            wT = *lpw;
            while( *( lpw - 1 ) == wT ) {
                --lpw;
            }
            ich = lpw - lpwMin;
		}
	}

    if ( FDbcsEnabled() && sDirection == MW_REV ) {
		char	sz[ axMax ];
        WORD    ichT = 0;

        FormatLine( iln, sz );
        while( ichT < ich ) {
            ichT += _tclen( &sz[ ichT ] );
        }
        if ( ich != ichT ) {
            --ich;
        }
    }

	if ( fUpdate ) {
		SetCursorAt( ich, iln );
	}
	else {
		SetCurObPos( ich );
		SetCurOlnPos( iln );
	}
}

//// NextLikeField
//
// Purpose: Locate next field with same class (Either RAW or FMT)
//
// Input:
//
// Output: Cursor is moved to new field of same type in foward direction.
//
// Exceptions:
//
// Notes: This function EXPECTS that the cursor is already on a
// RAW or FMT field
//
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: NextLikeField( char * sz ) {
	const MWD * pmwd;
	WORD		ich;
	DWORD		iln;
    WORD        wT;
    WORD FAR *  lpw;
	DWORD		ilnMac;

	pmwd = m_mwi.pmwd;
	lpw = m_mwi.rgwLineInfo + 1;

	ich = ObGetCurPos();
	iln = OlnGetCurPos();

	if( FDbcsEnabled() && _ismbblead( *( sz + ich ) ) ) {
		// If the last character is a DBCS character, we
		// may move off the map, so check to see if the
		// new map entry is the EOM before incrementing
		// ich
		if ( *( lpw + ich + 1 ) ) {
	    	ich++;
		}
	}
	
	lpw += ich;

    // wT Should be the next field found unless we're at the EOL
    wT = *lpw + 1;

    // Skip along until we've found the new field or hit EOL
    while( *++lpw && *lpw != wT );

    // if !*lpw, then we need to find the first item of same type
    // on the next line.  Preserve the mask bit and the beginning
    // index is 1
    if ( !*lpw ) {
        wT = wT & wFmtMask | 1;
        lpw = m_mwi.rgwLineInfo;
        while( *++lpw != wT );

		// We have to get the last valid line number.
		ilnMac = m_mwi.cLines - 1;

        // Validate the new line number
        if ( iln == ilnMac ) {
            iln = 0L;
        }
        else {
            ++iln;
        }
	}
	ich = lpw - m_mwi.rgwLineInfo - 1;
	SetCursorAt( ich, iln );
}

//// CchGetCellInfo
//
// Purpose: Get the cell information for the cell which the cursor is in.
//
// Input:
//      fBkSpc      TRUE if a back space is being processed
//
// Output:
//		Returns the width of the cell.
//		*puo		Offset address WITHIN THE LINE, NOT ABSOLUTE!!
//					(indeterminate if class is MW_NONE)
//		*puClass	One of MW_NONE, MW_ADDR, MW_RAW, MW_FMT, or
//					MW_ASCIIDAT indictating what the cursor is sitting on.
//		*pichStart	Index to character which is starting position for
//					cell. (indeterminate if class is MW_NONE)
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
USHORT CMemoryView :: CchGetCellInfo(
BOOL        fBkSpc,
UOFFSET *	puo,
USHORT *	puClass,
WORD *		pichStart ) {
	const MWD * pmwd;
	USHORT		ich;
	USHORT		cch;
    WORD        wT;
    WORD FAR *  lpw;

	pmwd = m_mwi.pmwd;
    lpw = m_mwi.rgwLineInfo + 1;

	ich = ObGetCurPos();
    if ( ich && fBkSpc ) {
        --ich;
    }
	*pichStart = 0;

	// Address field, real quick
	if ( ich < m_mwi.cchAddr ) {
		*puo = (UOFFSET)0;
		*puClass = MW_ADDR;
		*pichStart = 0;
		cch = m_mwi.cchAddr;
	}

	// Past the end or on a space (filler)
	else if ( ich >= m_mwi.cwLineInfo ||
        ( wT = *( lpw + ich ) ) == wNoType ) {

		*puClass = MW_NONE;
		cch = 0;
	}

	// We're sitting on type of a BYTE formatted field
	// (either MW_BYTE or on a RAW data.  Either way, tell 'em RAW)
	else if ( !( wT & wFmtMask ) ) {
		*puo = (UOFFSET)( wT - wFmtLoMin );
		*puClass = MW_RAW;
		*pichStart = MWNINCH;
		cch = cchRaw - 1;
	}

	// Last case, it's formatted or ascii
	else {
		*puo = (UOFFSET)( pmwd->cbType * ( wT - wFmtHiMin ) );

		// If we're here and its BYTE mode, then we're on top of the
		// ascii portion of the line.
		if ( pmwd == &rgmwd[ MW_BYTE ] ) {
			*puClass = MW_ASCIIDAT;
			cch = 1;
		}

		// Otherwise, it's really a formatted field
		else {
			*puClass = MW_FMT;
			cch = pmwd->cchFormatted;
		}
		*pichStart = MWNINCH;
	}

	// If RAW, FMT, or ASCII, fiqure out the length of the field.
	if ( *pichStart == MWNINCH ) {
		if ( ich < cch ) {
			ich = cch;
		}
		lpw = m_mwi.rgwLineInfo;
        while( *lpw != wT ) {
            ++lpw;
        }

		*pichStart = (WORD)( lpw - m_mwi.rgwLineInfo - 1 );
	}
	return cch;
}

//// FDoChar
//
// Purpose: Handle single character input to memory windows.
//
// Input:
//	wParam	word value of WM_CHAR message
//	lParam	dword value of WM_CHAR message
//
// Output: Depending on character we may:
//		1) Change the address expression,
//		2) Change a memory value, or
//		3) Beep() for an invalid input!
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
BOOL CMemoryView :: FDoChar(
UINT	wParam,
DWORD	lParam ) {
	BOOL	fRet;
	const MWD *pmwd;
	USHORT	imwd;
	DWORD	iln;
	WORD	ich;
	UOFFSET	uo;
	USHORT	ucls;
	USHORT	cch;
	WORD	ichStart;
	char	szBuf[ cchBufMax ];
	char	sz[ cchBufMax ];
	char	rgch[ 2 ];
	ADDR	addrT;
	char	ch;
	size_t	cchInput;
	
	rgch[ 1 ] = (UCHAR)LOBYTE( wParam );
	rgch[ 0 ] = (UCHAR)HIBYTE( wParam );
	cchInput = _tclen( rgch );

	// If the debuggee is running or there's a selection,
	// don't allow typing
	if ( GetEditSelection( 2, sz ) ) {
		MessageBeep( 0 );
		return TRUE;
	}

	fRet = FALSE;
	pmwd = m_mwi.pmwd;
	imwd = pmwd - rgmwd;

	iln = OlnGetCurPos();
	ich = ObGetCurPos();

	MWAddrFromIln( &m_mwi, iln, &addrT );

	cch = CchGetCellInfo( FALSE, &uo, &ucls, &ichStart );

	// Only allow DB chars if in ASCIIDAT or ASCII w/o RAW
	if ( cchInput > 1 &&
		ucls != MW_ASCIIDAT &&
		( ucls != MW_FMT || imwd != MW_ASCII || m_mwi.fShowRaw )
	) {
		MessageBeep( 0 );
		return fRet;
	}

	FormatLine( iln, sz );

	// If it's not printable, then we can't use it!
	if ( _istprint( wParam ) ) {
		BOOL	fUpdateExtraLine = FALSE;

		fRet = TRUE;
		ch = (char)wParam;
		switch( ucls ) {
			// Not on an editable field, BEEP at them!
			case MW_NONE:
				MessageBeep( 0 );
				break;

			// On an editable field,  replace the
			// character where the cursor is sitting with
			// the on the user just typed in.  After that,
			// adjust the cursor.
			case MW_ADDR:
				if (
					cchInput > 1 ||
					sz[ ich ] == ':' ||
					!_ftcschr( mpbHex, (_TUCHAR)ch )
				) {
					MessageBeep( 0 );
					break;
				}
				else {
					// Convert to upper-case to title string will be
					// consistent.
					ch = (char)_totupper( (_TUCHAR)ch );
				}
			case MW_ASCIIDAT:
			case MW_RAW:
			case MW_FMT: {
				char *	pch;


				// Spaces are only allowed for ASCII OR leading chars of
				// int's and longs
				if ( cchInput > 1 || ch != ' ' || ucls == MW_ASCIIDAT ||
					( ucls == MW_FMT &&
						( imwd == MW_ASCII ||
#ifdef _WIN32
							imwd == MW_WCHAR ||
#endif	// _WIN32
							imwd == MW_INT ||
							imwd == MW_LONG
						)
					)
				) {
#ifdef _WIN32
					// If we're editing in a wchar field, convert from
					// mbcs to wchar before passing on
					if ( ucls == MW_FMT && imwd == MW_WCHAR ) {
						wchar_t	wc;
						char	rgchLow[ sizeof( wchar_t ) ];
						
						*(WORD *)rgchLow = LOWORD( wParam );

						// Since this comes from WM_CHAR, should ALWAYS
						// be valid!
						VERIFY( mbtowc( &wc, rgchLow, 2 ) > 0 );
						memcpy( szBuf, &wc, cchInput = sizeof( wc ) );
						szBuf[ cchInput ] = '\0';
						ich += cchInput;
					}
					else
#endif	// _WIN32
					{
						if ( cchInput > 1 ) {
							// if the input clips the current line,
							// accept the change, just update the extra line
							if ( ich + 1 == (WORD)strlen( sz ) ) {
								fUpdateExtraLine = TRUE;
							}

							sz[ ich++ ] = (char)( wParam >> 8 );
							++cch;
						}

						sz[ ich++ ] = ch;

						_ftcsncpy( szBuf, sz + ichStart, cch );
						szBuf[ cch ] = chNull;

						// Zero fill the field in case they've typed
						// in a field which is left justified.
						if ( ucls == MW_ADDR ) {
							if ( sz[ ich ] == ':' ) {
								++ich;
							}
							memmove( szBuf + 2, szBuf, _ftcslen( szBuf ) + 1 );
							szBuf[ 0 ] = '0';
							szBuf[ 1 ] = 'x';
							if(!ADDR_IS_FLAT( addrT )) {
								pch = _ftcschr( szBuf, _T(':') ) + 1;
								memmove( pch + 2, pch, _ftcslen( pch ) + 1 );
								*pch++ = '0';
								*pch = 'x';
							}
						}
						else {
							pch = szBuf + ich - ichStart;
							while ( *pch ) {
								if ( *pch == ' ' ) {
									*pch = '0';
								}
								++pch;
							}
						}
					}

	                // Make sure that we can show a diff on the visible data
	                ChangeDebuggeeData();

					// Make the change.  If we fail, beep at em.
					if ( FChangeMemory( FALSE, cchInput, szBuf ) ) {
						// See if we need to move to the
						// next field, or...
						DrawLine( iln = OlnGetCurPos() );

						// If fUpdateExtraLine,, then a DBCS char was input
						// at the end of the line and we need to advance
						// an extra time onto the next line
						if ( fUpdateExtraLine ) {
							NextLikeField( sz );
							DrawLine( ++iln );
							FormatLine( iln, sz );

							// Move to the next field (off of the trail
							// byte) from the previous edit
							NextLikeField( sz );
						}
						else {
							if ( ich >= ichStart + cch ) {
								if ( ucls == MW_ADDR ) {
									NextField( MW_FWD, TRUE );
								}
								else {
									NextLikeField( sz );
								}
							}
							// Just go to the new cursor position
							else {
								iln = OlnGetCurPos();
								SetCursorAt( ich, iln );
							}
						}
					}
				}
				else {
					MessageBeep( 0 );
				}
				break;
			}
		}
	}
	return fRet;
}

//// FChangeMemory
//
// Purpose: Change the address expresssion from editing or change some
// debuggee data.
//
// Input:
//  fBkSpc  	Is a backspace char being processed
//  cchInput	Number of characters changed.  Only non-1 for DBCS
//				on ASCII input
//	szIn		String to parse for input as update information
//
// Output: Return TRUE if OK, else FALSE.  Window will be updated to reflect
// change.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
BOOL CMemoryView :: FChangeMemory(
BOOL        fBkSpc,
int			cchInput,
char *	    szIn ) {
	const MWD *pmwd;
	USHORT	imwd;
	USHORT	cch;
	UOFFSET	uo;
	USHORT	ucls;
	WORD	iStart;
	BOOL	fRet;
	DWORD	iln;
	ADDR	addrT;

	pmwd = m_mwi.pmwd;
	imwd = pmwd - rgmwd;
	iln = OlnGetCurPos();
	fRet = FALSE;
	cch = CchGetCellInfo( fBkSpc, &uo, &ucls, &iStart );

	switch( ucls ) {
		case MW_ADDR: {
			// Update the address expression.  Editing this
			// field FORCES non-LIVE expression evaluation.
			if ( SetAttributes( MWNINCH, szIn, MWNINCH,
				MWNINCH, MWNINCH ) ) {

				// Do not reset live expressions
				// m_mwi.fLiveExpr = FALSE;

				MWSaveSettings( szIn );

                // Update the differences cache if necessary
                ChangeDebuggeeData();
				fRet = TRUE;
			}
			break;
		}
		case MW_ASCIIDAT:
		case MW_RAW:
		case MW_FMT: {
			BYTE	rgb[ cbDataMax ];
			UINT	cbIn;
			char	szFmt[ 10 ];	// scanf format

			// IF RAW or ASCII, get correct input format
			if ( ucls == MW_RAW ) {
				imwd = MW_BYTE;
			}
			else if ( ucls == MW_ASCIIDAT ) {
				imwd = MW_ASCII;
			}
			pmwd = &rgmwd[ imwd ];
			_ftcscpy( (char far *)szFmt, (char far *)pmwd->bszFmtIn );
			_ftcscat( szFmt, "%n" );

			if ( cchInput > 1 && imwd == MW_ASCII
#ifdef _WIN32
				|| imwd == MW_WCHAR
#endif	// _WIN32
			) {
				ASSERT( cchInput == 2 );
				memcpy( rgb, szIn, cchInput );
				cbIn = cchInput;
			}
			else {
				char *	pch;
				
				pch = szIn + _ftcslen( szIn );
				*pch = ' ';
				sscanf( szIn, szFmt, rgb, &cbIn );
				*pch = chNull;
			}

            if ( !*szIn ) {
                rgb[0] = *szIn;
            }
			if (
#ifdef _WIN32
				imwd != MW_WCHAR &&
#endif	// _WIN32
				cbIn != _ftcslen( szIn ) &&
                !( IsCharFormat( imwd ) && !*szIn ) ) {
				MessageBeep( 0 );
			}
			else {
				MWAddrFromIln( &m_mwi, iln, &addrT );
				if ( uo &&  GetAddrOff( addrT ) >= 	(UOFFSET)0 - uo ) {
					SetAddrSeg( &addrT, GetAddrSeg( addrT ) + 1 );
				}
				SetAddrOff( &addrT, GetAddrOff( addrT ) + uo );

				if ( !m_mwi.hlliUndo ) {
					m_mwi.hlliUndo =
						LLHlliInit( sizeof( MUB ), llfNull, NULL, NULL	);
				}

				if ( !m_mwi.hlliRedo ) {
					m_mwi.hlliRedo =
						LLHlliInit( sizeof( MUB ), llfNull, NULL, NULL	);
				}

				// Set the number of bytes being input to the number
				// of bytes for the type, unless the input was a
				// dbcs char, in which case 2 bytes will be updated.
				// In any event, the cchInput must be 1 or we have
				// already set cbIn to be 2!
				ASSERT( cchInput == 1 || cbIn == 2 );

				if ( cchInput == 1 ) {
					cbIn = pmwd->cbType;
				}
				
				FlipBytes(rgb, pmwd->cbType);
				if ( FPutDebuggeeBytes( ucls, &addrT, cbIn, rgb,
					m_mwi.hlliUndo, m_mwi.hlliRedo ) ) {

		    		// We need to update other windows
			    	UpdateWorld( &addrT, cbIn );

				    fRet = TRUE;
                }

                // Write failed, probably read_only
                else {
                    MessageBeep( 0 );
                }
			}
			break;
		}
	}
	return fRet;
}

//// MWAddrFromIln
//
// Purpose: Given window information and a line number, compte the
// starting address for the line.
//
// Input:
//		pmwi	Window information
//		iln		Line number to obtain address for.
//
// Output:
//		paddr	addr packet updated.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void PASCAL
MWAddrFromIln(
PMWI	pmwi,
DWORD	iln,
PADDR	paddr ) {
	USHORT	cbLine;
	DWORD	loffset;

	ASSERT( pmwi );

	if ( !pmwi->pmwd ) {
	    pmwi->pmwd = &rgmwd[ 0 ];
	}

	// # of bytes per displayed line
	cbLine = pmwi->cFmtVals * pmwi->pmwd->cbType;

	// If none, then no address!
	if ( !cbLine ) {
		_fmemset( paddr, 0, sizeof( ADDR ) );
	}
	else {
		// Initialize the addr packet
		*paddr = pmwi->addr;

		// compute the number of bytes left over once
		// the address expression is paged back to beginning
		// of window
		loffset = (DWORD)cbLine -
			(DWORD)( GetAddrOff( pmwi->addr ) % cbLine );

		// if the offset == cbLine, then there really ain't an offset
		if ( loffset == (DWORD)cbLine ) {
			loffset = 0L;
		}

		// On line zero, we may be showing some bytes in the
		// previous segment, so adjust segment #
		if ( iln == 0L && loffset ) {
			SetAddrSeg( paddr, GetAddrSeg( pmwi->addr ) - 1 );
		}
		else {
			SetAddrSeg( paddr, GetAddrSeg( pmwi->addr ) );
		}

		// The offset address is a simple calculation
		SetAddrOff( paddr,
			(UOFFSET)( iln * (DWORD)cbLine - loffset ) );

		emiAddr ( *paddr ) = 0;
		SYSetEmi ( hpidCurr, htidCurr, paddr );
	}
    ADDR_IS_FLAT(*paddr) = ADDR_IS_FLAT(pmwi->addr);
    ADDR_IS_OFF32(*paddr) = ADDR_IS_OFF32(pmwi->addr);
}

//// MWIlnFromAddr
//
// Purpose: Determine which line the addr byte appears on.
//
// Input:
//		pmwi	window information.
//		paddr	Address to find line number for.
//
// Output: Returns the line number for the specified address or,
// zero if the address is not in the window!
//
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
DWORD PASCAL
MWIlnFromAddr(
PMWI	pmwi,
PADDR	paddr ) {
	USHORT	cbLine;
	UOFFSET	uo;
	DWORD	iln;

	ASSERT( pmwi );

	if ( !pmwi->pmwd ) {
	    pmwi->pmwd = &rgmwd[ 0 ];
	}

    // If we didn't get an adress, get the expression address
	if ( !paddr ) {
    	paddr = &pmwi->addr;
	}

    cbLine = pmwi->cFmtVals * pmwi->pmwd->cbType;

    // If the # of bytes / line is zero, we have to be at line 0.
	if ( !cbLine ) {
    	iln = 0L;
	}
    else {
		// Byte offset/line
	    uo = (UOFFSET)(cbLine) -
		    (UOFFSET)( GetAddrOff( pmwi->addr ) % cbLine );

    	if ( uo == (UOFFSET)cbLine ) {
			uo = (UOFFSET)0;
	    }

    	// If segments aren't equal, force to beginning
		if ( GetAddrSeg( pmwi->addr ) !=
            GetAddrSeg( *paddr ) ) {

	    	iln = 0L;
    	}
		else {
			UOFFSET	uoMod;

			iln  = GetAddrOff( *paddr ) / cbLine;
			uoMod = GetAddrOff( *paddr ) - iln * cbLine;
			if ( (USHORT)( uoMod + uo ) >= cbLine ) {
				++iln;
			}
    	}
	}
	return iln;
}

//// UpdateExprFromMwiAddr
//
// Purpose: Update the expression from the address specified in the mwi.
//
// Input: None.
//
// Output: m_mwi.szExpr may be updated.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: UpdateExprFromMwiAddr() {

	// Save new expression if not-live.  And prepare new title
	// when we come back from debuggee execution.
	if ( m_mwi.fNoUpdate && m_mwi.fLiveExpr == MW_DEAD &&
		!ADDR_IS_LI( m_mwi.addr ) ) {

		char	sz[ cchAddrMax + 4 ];
		MWI		mwi;
		MWI		mwiT;

		mwiT = mwi = m_mwi;

		// Need to get string expression from expression evaluator
		if ( ADDR_IS_FLAT( m_mwi.addr ) ) {
			ASSERT( ADDR_IS_OFF32( m_mwi.addr ) );
			sprintf( sz, "0x%.8lX", GetAddrOff( m_mwi.addr ) );
		}
		else {
			sprintf( sz, "0x%.4X:0x%.*X", GetAddrSeg( m_mwi.addr ),
				ADDR_IS_OFF32 ( m_mwi.addr ) ? 8 : 4,
				GetAddrOff( m_mwi.addr ) );
		}
		mwi.szExpr = sz;

		if ( !MWSetAddrFromExpr( &mwiT, MW_NO_AUTO_TYPE ) ) {
			mwiT.addr = m_mwi.addr;
		}

		if ( MWSetAddrFromExpr( &mwi, MW_NO_AUTO_TYPE ) &&
			!FAddrsEq( mwi.addr, mwiT.addr )
		) {

			if ( m_mwi.szExpr ) {
				free( m_mwi.szExpr );
			}
			if ( !( m_mwi.szExpr = _ftcsdup( sz ) ) ) {
				OOMError();
				return;
			}
			ChangeTitle();
		}
	}
}

//// LpwFindNotEq
//
// Purpose: Locate the first occurance of a WORD not equal to *lpw
//
// Input:
//	lpw Buffer to look in.
//
// Output: Returns a pointer to the location where non-match
// was found.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
WORD FAR * CMemoryView :: LpwFindNotEq( WORD FAR *	lpw ) {
	WORD    wT = *lpw;

	while ( *++lpw == wT );

	return lpw;
}

//// BuildRgla
//
// Purpose: From the rgwLineInfo and rgf information update the
// line attribute information for the last line formatted.  This
// API should ONLY be called from MWFormatLine()!
//
// Input:
//
// Output: Updates m_rgla
//
// Exceptions:
//
// Notes: THIS NEEDS TO BE REAL FAST!!!!
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: BuildRgla() {
	WORD FAR *			lpw;
	USHORT				cla;
	WORD FAR *			rgwLineInfo;
	WORD FAR *			lpwLast;
	register PDLA		pdlaPrev;
	register PDLA		pdla;
	register BOOL FAR *	lpf;
	FMT_ELEMENT *rgfmtel = pfmtelFromDocType((DOCTYPE)MEMORY_WIN);
	FMT_ELEMENT *fmtelMemory = &(rgfmtel[FMTEL_TEXT]);
	FMT_ELEMENT *fmtelHilight = &(rgfmtel[FMTEL_MMHI]);

	// Get initial values
	rgwLineInfo = m_mwi.rgwLineInfo + 1;
	lpf = m_mwi.rgf;
	pdla = m_rgdla;

	// Set the address field value (it's never hilited!)
	lpw = LpwFindNotEq( rgwLineInfo );
	pdla->cb = lpw - rgwLineInfo;
	pdla->pElement = fmtelMemory;

	// Set the maximum number of values remaining.  We've already
	// filled 1 and if we go over, we'll use another. Array is
	// zero indexed, so subtract another 1. == -3.
	cla = MW_LAMAX - 3;

    pdlaPrev = pdla++;
	while( *lpw && cla-- ) {

		// Determine length of this field
		lpwLast = lpw;
		lpw = LpwFindNotEq( lpwLast );
		pdla->cb = lpw - lpwLast;

		// Determine the attribute for the field
		pdla->pElement = *( lpwLast ) == wNoType || *lpf++ ? fmtelMemory : fmtelHilight;

        if ( pdlaPrev->pElement == pdla->pElement ) {
            pdlaPrev->cb += pdla->cb;
        }
        else {
            pdlaPrev = pdla++;
        }
	}
	// Beyond the end of the line, or out of range, just display
	// non-hilited.
    if ( pdlaPrev->pElement == fmtelMemory) {
        pdla = pdlaPrev;
    }
    else {
    	pdla->pElement = fmtelMemory;
    }
    pdla->cb = 0xffff;
}

//// MakeWindowActive
//
// Purpose: Update the active memory window information and the
// status bar.
//
// Input:
//
// Output:
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: MakeWindowActive() {
}

//// OOMError
//
// Purpose: Let user know that an OOM error has occured and terminate
// the window which received the error.
//
// Input:
//
// Output:
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: OOMError() {
	// CVMessage ( ERRORMSG, ENOMEM, MSGBOX );
	ASSERT ( FALSE );
}

//// DoDelChar
//
// Purpose: Handle either BSP or DEL key.
//
// Input:
//	fBkSpc	Is this a BackSpce key hit?
//
// Output:
//	Updated window or Beep
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: DoDelChar( BOOL	fBkSpc ) {
	USHORT	cch;
	UOFFSET	uo;
	USHORT	ucls;
	WORD	ichStart;
	DWORD	iln;
	WORD	ich;
	char	sz[ cchBufMax + 2 ];
	USHORT	imwd;
	char *	psz;
	int		cbMove;
	int		cbOff;
	char *	pch;

	// If the debuggee is running or there's a selection,
	// don't allow typing
	if ( GetEditSelection( 2, sz ) ) {
		MessageBeep( 0 );
		return;
	}

	// Get the information about the current line
	cch = CchGetCellInfo( fBkSpc, &uo, &ucls, &ichStart );
	iln = OlnGetCurPos();
	ich = ObGetCurPos();

	imwd = m_mwi.pmwd - rgmwd;

	// Don't allow editing of ASCII data, padding, and don't
	// allow back-spacing on the first char of a cell.  The
	// Delete would be a space anyway.
	if ( ucls == MW_ASCIIDAT || ucls == MW_NONE ||
		( fBkSpc && ich == ichStart ) ||
		( IsCharFormat( imwd ) && ucls == MW_FMT ) ) {

		MessageBeep( 0 );
	}
	else {
		FormatLine( iln, sz + 2 );

		// If they're DEL-ing, delete this char.
		// Otherwise, delete the previous char.
		cbOff = ( fBkSpc ? 1 : 0 );
		psz = sz + 2 + ichStart;
		cbMove = ich - ichStart - cbOff;

		// If we're not at the beginning of the field
		// then we have to shift the other data right.
		if ( cbMove ) {
			memmove( psz + 1, psz, cbMove );
		}

		// Replace the leading char with a space.
		// The sscanf will take care of the rest.
        if ( ucls == MW_ADDR ) {
            sz[ 0 ] = '0';
            sz[ 1 ] = 'x';
    		*psz = '0';
            psz -= 2;
            cch += 2;
        }
        else {
    		*psz = ' ';
        }

		// If we've deleted the rightmost char, then
		// we have to pop in a zero to ensure a zero
		// value.
		pch = psz + cch - 1;
		if ( *pch == ' ' ) {
		 	*pch = '0';
		}

		// Null terminate the cell and change the user's
		// memory.
		*( psz + cch ) = chNull;
		FChangeMemory( fBkSpc, 1, psz );

		// Redraw the changes.
        if ( ucls != MW_ADDR ) {
    		DrawLine( iln );
        }
	}
}

//// FIsAddrInRange
//
// Purpose: Determin if one address is contained within a pair of
// addresses.
//
// Input:
//	paddrLook	Address to see if in range.
//	paddrMin	Low address for range.
//	paddrMac	High address for range.
//
// Output: Returns TRUE if paddrMin <= paddrLook <= paddrMac
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
BOOL CMemoryView :: FIsAddrInRange(
PADDR	paddrLook,
PADDR	paddrMin,
PADDR	paddrMac ) {
    BOOL    fRet = FALSE;
	DWORD	result;

	VERIFY(OSDCompareAddrs(hpidCurr, paddrMin, paddrLook, &result) == xosdNone);
	if ((long)result <= 0) {
		VERIFY(OSDCompareAddrs(hpidCurr, paddrLook, paddrMac, &result) == xosdNone);
		fRet = ((long)result <= 0);
	}	
	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\miscdlgs.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "plist.h"
#include "fbrdbg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////
// CMapRemoteDllDlg implementation
///////////////////////////////////////////////////////////////////////////////

CMapRemoteDllDlg::CMapRemoteDllDlg(LPCTSTR szRemote,
			       CWnd * pParent /* = NULL */)
	: C3dDialog(CMapRemoteDllDlg::IDD, pParent)
{
	m_strRemote = szRemote;
}

BEGIN_MESSAGE_MAP(CMapRemoteDllDlg, C3dDialog)
	//{{AFX_MSG_MAP(CMapRemoteDllDlg)
		ON_EN_CHANGE(IDC_REMOTE_MAP_LOCAL_NAME, OnNameChange)
		ON_BN_CLICKED(ID_BROWSE, OnBrowse)
		ON_BN_CLICKED(IDC_PROMPT_DLLS, OnPromptDLLs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
// BOOL CMapRemoteDllDlg::OnInitDialog()
///////////////////////////////////////////////////////////////////////////////
BOOL CMapRemoteDllDlg::OnInitDialog()
{
	// Set the text for the remote file we are trying to map
	((CStatic *)GetDlgItem(IDC_REMOTE_FILE_TXT))->SetWindowText(m_strRemote);
	((CEdit *)GetDlgItem(IDC_REMOTE_MAP_LOCAL_NAME))->SetWindowText(m_strRemote);

	// Init the state of the "try to locate any more" box in proj
	m_fPrompt = TRUE;
	((CButton *)GetDlgItem(IDC_PROMPT_DLLS))->SetCheck(1);

	// Enable the OK button
	UpdateOKState();

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// void CMapRemoteDllDlg::UpdateOKState()
///////////////////////////////////////////////////////////////////////////////
void CMapRemoteDllDlg::UpdateOKState()
{
	// Enable OK if there is a local name entered
	BOOL bOK = ((CEdit *)GetDlgItem(IDC_REMOTE_MAP_LOCAL_NAME))->LineLength() > 0;

	// Enable OK if the "Try to local other DLLs" checkbox is checked
	// (and we're not trying to locate the JIT exe)
	if ( !(theApp.m_jit.GetActive() && !theApp.m_jit.FPathIsReal()) ) {
		bOK |= ( ((CButton *)GetDlgItem(IDC_PROMPT_DLLS))->GetCheck() == 0);
	}

	((CButton *)GetDlgItem(IDOK))->EnableWindow(bOK);
}

///////////////////////////////////////////////////////////////////////////////
// void CMapRemoteDllDlg::OnNameChange()
///////////////////////////////////////////////////////////////////////////////
void CMapRemoteDllDlg::OnNameChange()
{
	UpdateOKState();
}

///////////////////////////////////////////////////////////////////////////////
// void CMapRemoteDllDlg::OnOK()
///////////////////////////////////////////////////////////////////////////////
void CMapRemoteDllDlg::OnOK()
{	
	CString strLocalName;
	CString strDLLPath;

	((CEdit *)GetDlgItem(IDC_REMOTE_MAP_LOCAL_NAME))->GetWindowText(strLocalName);

	// str can be empty if one of the checkboxes is checked.
	if (!strLocalName.IsEmpty()) {
		if (FFindDLL(strLocalName, strDLLPath)
			&& CheckEXEForDebug(strDLLPath, TRUE, FALSE)) {

			m_strLocal = strDLLPath;
			m_fPrompt = ( ((CButton *)GetDlgItem(IDC_PROMPT_DLLS))->GetCheck() == 1 );
			CDialog::OnOK();
		}
		return;
	}

	m_strLocal.Empty();
	m_fPrompt = ( ((CButton *)GetDlgItem(IDC_PROMPT_DLLS))->GetCheck() == 1 );

	CDialog::OnOK();
}

void
CMapRemoteDllDlg::OnCancel(
	)
{
	// If the user doesn't ever want to be prompted for *this*
	// DLL again, save the remote name in DLLInfo and exit.

	if (!theApp.m_jit.GetActive() || theApp.m_jit.FPathIsReal())
	{
		HBLDTARGET hTarget;
		gpIBldSys->GetActiveTarget(ACTIVE_BUILDER, &hTarget);

		UpdateDLLInfoRec (_T(""), m_strRemote, TRUE, (ULONG) hTarget, FALSE);
		
//		AddRecToDLLInfo("", m_strRemote, TRUE, (UINT)hTarget);
	}

	m_fPrompt = ( ((CButton *)GetDlgItem (IDC_PROMPT_DLLS))->GetCheck() == 1 );

	CDialog::OnCancel();
}

void
CMapRemoteDllDlg::OnBrowse(
	)
{
	CString strTitle;
	CString str;
	CString strFilter;
	CFileDialog dlg(TRUE);

	strTitle.LoadString(IDS_FIND_LOCAL_MODULE);
	dlg.m_ofn.lpstrTitle = strTitle;
    dlg.m_ofn.Flags |= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NONETWORKBUTTON;

	if (theApp.m_jit.GetActive() && !theApp.m_jit.FPathIsReal()) {
		VERIFY(str.LoadString(IDS_FILTER_EXES));
	} else {
		VERIFY(str.LoadString(IDS_FILTER_DLLS));
	}
	AppendFilterSuffix(strFilter, dlg.m_ofn, str);
	dlg.m_ofn.lpstrFilter = strFilter;
	dlg.m_ofn.nFilterIndex = 1;

	for ( ; ; ) {
		if (dlg.DoModal() == IDCANCEL) {
			return;
		}
		str = dlg.GetPathName();
		if (CheckEXEForDebug(str, TRUE, FALSE)) {
			((CEdit *)GetDlgItem(IDC_REMOTE_MAP_LOCAL_NAME))->SetWindowText(str);
			return;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// void CMapRemoteDllDlg::OnPromptDLLs()
///////////////////////////////////////////////////////////////////////////////
void CMapRemoteDllDlg::OnPromptDLLs()
{
	UpdateOKState();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAssertFailedDlg dialog


CAssertFailedDlg::CAssertFailedDlg(CWnd* pParent /*=NULL*/)
	: C3dDialog(CAssertFailedDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAssertFailedDlg)
	m_strAssertText = _T("");
	//}}AFX_DATA_INIT
}


void CAssertFailedDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAssertFailedDlg)
	DDX_Text(pDX, IDC_ASSERT_TEXT, m_strAssertText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAssertFailedDlg, C3dDialog)
	//{{AFX_MSG_MAP(CAssertFailedDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
//	Attach to Active Dialog
//


//
//	CAttachToActive Message Map

BEGIN_MESSAGE_MAP(CAttachToActive, C3dDialog)
	ON_BN_CLICKED (IDC_SYSTEM_PROCESSES,OnChangeSystemProcess)
END_MESSAGE_MAP()


CAttachToActive::CAttachToActive(
	CWnd*	pParent // = NULL
	)
	: C3dDialog (CAttachToActive::IDD, pParent)
{
	m_ProcessId = 0;
	m_TaskList = NULL;
}

CAttachToActive::~CAttachToActive(
	)
{
	delete [] m_TaskList;
	m_TaskList = NULL;
}

void
CAttachToActive::DoDataExchange(
	CDataExchange*	pDX
	)
{
	C3dDialog::DoDataExchange (pDX);
}

#define PL_INDEX_NAME	0
#define PL_INDEX_PID	1
#define PL_INDEX_TITLE	2


int CALLBACK
PLCompareFunction(
	LPARAM	lParam1,
	LPARAM	lParam2,
	LPARAM	nSortField
	)
{
	TASK_LIST*	Task1 = (TASK_LIST*)lParam1;
	TASK_LIST*	Task2 = (TASK_LIST*)lParam2;
	
	
	switch (nSortField)
	{
		case PL_INDEX_NAME:
			return lstrcmpi (Task1->ProcessName, Task2->ProcessName);

		case PL_INDEX_PID:
			return ((int)Task1->dwProcessId - (int)Task2->dwProcessId);

		case PL_INDEX_TITLE:
		{
			if (!Task1->hwnd && !Task2->hwnd)
				return 0;
				
			if (!Task1->hwnd)
				return 1;

			if (!Task2->hwnd)
				return -1;
			
			return lstrcmpi (Task1->WindowTitle, Task2->WindowTitle);
		}

		default:
			ASSERT (FALSE);
	}

	return 0;
}


BOOL
CAttachToActive::OnNotify(
	WPARAM		wParam,
	LPARAM		lParam,
	LRESULT*	lResult
	)
{
	switch ( ((LPNMHDR)lParam)->code )
	{
		case LVN_COLUMNCLICK:
			return OnLvnColumnClick ((NM_LISTVIEW*) lParam, lResult);
		case NM_DBLCLK:
			return OnNmDblClk((NMHDR*) lParam, lResult);
	}

	return 0;
}

BOOL
CAttachToActive::OnLvnColumnClick(
	NM_LISTVIEW*	ListData,
	LRESULT*		lResult
	)
{
	
	CListCtrl*	ProcessList = (CListCtrl*) GetDlgItem (IDC_PROCESS_LIST);
	ULONG		nSortField;

	ASSERT (ProcessList);

	//
	//	this is a sort request
	
	ProcessList->SortItems (PLCompareFunction, ListData->iSubItem);

	return TRUE;
}

BOOL
CAttachToActive::OnNmDblClk(
	NMHDR*		Data,
	LRESULT*	lResult
	)
{
	OnOK();
	return TRUE;
}

BOOL
CAttachToActive::OnInitDialog(
	)
/*++

Routine Description:

	Initialize dialog with list of processes.

Return Value:

	Returns TRUE to denote success.

--*/
{
	C3dDialog::OnInitDialog ();

	CButton* SysProc = (CButton*) GetDlgItem (IDC_SYSTEM_PROCESSES);

	SysProc->SetCheck (FALSE);

	m_TaskList = new TASK_LIST [512];
	m_nTasks = 512;
	
	CListCtrl*	ProcessList = (CListCtrl*)GetDlgItem (IDC_PROCESS_LIST);
    CString str;

    str.LoadString(IDS_PROCESS);
	ProcessList->InsertColumn (PL_INDEX_NAME, str, LVCFMT_LEFT, 110);

    str.LoadString(IDS_PROCESSID);
	ProcessList->InsertColumn (PL_INDEX_PID, str, LVCFMT_LEFT, 75);

    str.LoadString(IDS_TITLE);
	ProcessList->InsertColumn (PL_INDEX_TITLE, str, LVCFMT_LEFT, 200);

	FillProcessList (FALSE);
	return TRUE;
}


void
CAttachToActive::EmptyProcessList(
	)
{
	CListCtrl*	ProcessList = (CListCtrl*) GetDlgItem (IDC_PROCESS_LIST);

	ProcessList->DeleteAllItems ();
}
	

void
CAttachToActive::FillProcessList(
	BOOL	fSystemProcesses
	)
{
	TASK_LIST_ENUM	TaskListEnum;
	int				nTasks;
	TCHAR			Buffer [15];
	int				nItem;
	ULONG			CurrentProcessId  = GetCurrentProcessId ();
	CListCtrl*		ProcessList = (CListCtrl*)GetDlgItem (IDC_PROCESS_LIST);
	CWaitCursor		boy_oh_boy_is_c_plus_plus_a_neato_language;
	bool            fWinNT = (GetOsVersion() == VER_PLATFORM_WIN32_NT); 

	if (!InitPlistApi ()) 
	{
		return;
	}

	SetDebugPrivilege (fSystemProcesses);
	do 
	{
	    nTasks = GetTaskList (m_TaskList, m_nTasks);

	    if (m_nTasks < nTasks && fWinNT) 
		{
	    	//
	    	// compensate for new PSAPI code - NT alone)
	    	//

	    	m_nTasks   = nTasks; 
	        m_TaskList = new TASK_LIST [nTasks];

		    if (!m_TaskList) 
		    {
		    	return;
		    }
		} else {
			break;
		}

	} while (1);

	TaskListEnum.tlist = m_TaskList;
	TaskListEnum.numtasks = nTasks;
	GetWindowTitles (&TaskListEnum);

	/*
	for (int i = 0; i < nTasks; i++)
	{
		if (m_TaskList [i].dwProcessId == CurrentProcessId)
		{
			// do not list our own process
			
			m_TaskList [i].BinaryType = IMAGE_BAD_EXECUTABLE;
			continue;
		}

		//
		// get imageinfo is already done by GetTaskList on NT
		//
		if (!GetTaskImageInfo (&m_TaskList [i]))
		{
		    m_TaskList [i].BinaryType = IMAGE_BAD_EXECUTABLE;
		}
	}
	*/

	FreePlistApi ();


	
	for (int i = 0; i < nTasks; i++)
	{
		if (m_TaskList [i].dwProcessId == CurrentProcessId) {
			continue;
		}


		
		if (fWinNT) {
			if (!fSystemProcesses &&  
				(m_TaskList[i].flags & TASK_SYSTEM_PROCESS)) {
				continue;
			}
		    _ultoa (m_TaskList[i].dwProcessId, Buffer, 10);
		} else {
		    //
	    	//	if image is anything but a 32 bit GUI or CUI App, ignore
			if (!GetTaskImageInfo(&m_TaskList[i])) 
			{
				continue;
		    }

		    if (m_TaskList [i].BinaryType != IMAGE_SUBSYSTEM_WINDOWS_CUI &&
		    	m_TaskList [i].BinaryType != IMAGE_SUBSYSTEM_WINDOWS_GUI) {
		    	continue;
			}
		    _ultoa (m_TaskList[i].dwProcessId, Buffer, 16);
		}

			
		nItem = ProcessList->InsertItem (0, m_TaskList[i].ProcessName);
		ProcessList->SetItemText (nItem, 1, Buffer);
		ProcessList->SetItemText (nItem, 2, (m_TaskList[i].hwnd ? m_TaskList [i].WindowTitle : "                      "));
		ProcessList->SetItemData (nItem, (LPARAM)&m_TaskList [i]);
	}

	ProcessList->SetItemState (0, LVNI_SELECTED, LVNI_SELECTED);

}



void
CAttachToActive::OnChangeSystemProcess(
	)
{
	CButton*	SysProc = (CButton*) GetDlgItem (IDC_SYSTEM_PROCESSES);

	EmptyProcessList ();
	
	if (SysProc->GetCheck ())
	{
		FillProcessList (TRUE);
	}
	else
	{
		FillProcessList (FALSE);
	}
}


	
void
CAttachToActive::OnOK(
	)
{
	int			nItem;
	CListCtrl*	ProcessList = (CListCtrl*) GetDlgItem (IDC_PROCESS_LIST);
	CString		str;
	PTASK_LIST	Task;

	ASSERT (ProcessList);

	nItem = ProcessList->GetNextItem (-1, LVNI_SELECTED);

	if (nItem != -1)
	{
		Task = (PTASK_LIST) ProcessList->GetItemData (nItem);

		ASSERT (Task);

		m_ProcessId = Task->dwProcessId;
		m_ProcessName = Task->ProcessName;
		m_ImageName = Task->ImageName ;
		C3dDialog::OnOK ();
		return;
	}

	C3dDialog::OnCancel ();
}


//
//	List Module Dialog
//

static const char *GetBaseName( const char *pFullPath )
{
	const char *pSlash = _tcsrchr( pFullPath, '\\' );
	return pSlash ? pSlash+1 : pFullPath;
}
//
//	CModuleDialog Message Map

BEGIN_MESSAGE_MAP(CModuleDialog, C3dDialog)
	ON_BN_CLICKED (IDC_SYSTEM_PROCESSES,OnChangeModule)
END_MESSAGE_MAP()

CModuleDialog::CModuleDialog(
	CWnd*	pParent // = NULL
	)
	: C3dDialog (CModuleDialog::IDD, pParent)
{
	m_pModuleList = NULL;
}

CModuleDialog::~CModuleDialog(
	)
{
	if (m_pModuleList)
		BMFree( m_pModuleList );
	m_pModuleList = NULL;
}

void
CModuleDialog::DoDataExchange(
	CDataExchange*	pDX
	)
{
	C3dDialog::DoDataExchange (pDX);
}

#define PL_BASENAME		0
#define PL_ADDR			1
#define PL_FULLPATH		2
#define	PL_ORDER		3


int CALLBACK
PLCompareFunctionModule(
	LPARAM	lParam1,
	LPARAM	lParam2,
	LPARAM	nSortField
	)
{
	LPMODULE_ENTRY Mod1 = (LPMODULE_ENTRY)lParam1;
	LPMODULE_ENTRY Mod2 = (LPMODULE_ENTRY)lParam2;

	ASSERT( Mod1 && Mod2 );

	switch (nSortField)
	{
		case PL_BASENAME:
			return _tcsicmp (GetBaseName(ModuleEntryName(Mod1)), GetBaseName(ModuleEntryName(Mod2)) );

		case PL_ADDR:
			if (ModuleEntryBase(Mod1) > ModuleEntryBase(Mod2))
				return 1;
			else if (ModuleEntryBase(Mod1) != ModuleEntryBase(Mod2))
				return -1;
			else
				return 0;

		case PL_FULLPATH:
			return _tcsicmp (ModuleEntryName(Mod1), ModuleEntryName(Mod2) );

		case PL_ORDER:
			return (Mod1-Mod2);

		default:
			ASSERT (FALSE);
	}

	return 0;
}


BOOL
CModuleDialog::OnNotify(
	WPARAM		wParam,
	LPARAM		lParam,
	LRESULT*	lResult
	)
{
	switch ( ((LPNMHDR)lParam)->code )
	{
		case LVN_COLUMNCLICK:
			return OnLvnColumnClick ((NM_LISTVIEW*) lParam, lResult);
		case NM_DBLCLK:
			return OnNmDblClk((NMHDR*) lParam, lResult);
	}

	return 0;
}

BOOL
CModuleDialog::OnLvnColumnClick(
	NM_LISTVIEW*	ListData,
	LRESULT*		lResult
	)
{
	
	CListCtrl*	ProcessList = (CListCtrl*) GetDlgItem (IDC_MODULE_LIST);
	ULONG		nSortField;

	ASSERT (ProcessList);

	//
	//	this is a sort request
	
	ProcessList->SortItems (PLCompareFunctionModule, ListData->iSubItem);

	return TRUE;
}

BOOL
CModuleDialog::OnNmDblClk(
	NMHDR*		Data,
	LRESULT*	lResult
	)
{
//	OnOK();
	return TRUE;
}

BOOL
CModuleDialog::OnInitDialog(
	)
/*++

Routine Description:

	Initialize dialog with list of modules

Return Value:

	Returns TRUE to denote success.

--*/
{
	C3dDialog::OnInitDialog ();

	CListCtrl*	ProcessList = (CListCtrl*)GetDlgItem (IDC_MODULE_LIST);
	DWORD dwStyle = ProcessList->GetExtendedStyle();
	ProcessList->SetExtendedStyle( dwStyle | LVS_EX_FULLROWSELECT );

    CString str;

    str.LoadString(IDS_MODULENAME);
	ProcessList->InsertColumn (PL_BASENAME, str, LVCFMT_LEFT, 100 );

    str.LoadString(IDS_ADDRESS);
	ProcessList->InsertColumn (PL_ADDR, str, LVCFMT_LEFT, 200 );

    str.LoadString(IDS_FULLPATH);
	ProcessList->InsertColumn (PL_FULLPATH, str, LVCFMT_LEFT, 300 );

	str = "Order";
	ProcessList->InsertColumn (PL_ORDER, str, LVCFMT_LEFT, 40 );

	FillModuleList ();
	return TRUE;
}


void
CModuleDialog::EmptyModuleList(
	)
{
	if (m_pModuleList)
		BMFree( m_pModuleList );
	m_pModuleList = NULL;

	CListCtrl*	ProcessList = (CListCtrl*) GetDlgItem (IDC_MODULE_LIST);

	ProcessList->DeleteAllItems ();
}
	

void
CModuleDialog::FillModuleList(
	)
{
	int				nTasks;
	int				nItem;
	CListCtrl*		ProcessList = (CListCtrl*)GetDlgItem (IDC_MODULE_LIST);
	CWaitCursor		boy_oh_boy_is_c_plus_plus_a_neato_language;

	XOSD xosd = OSDGetModuleList(
		hpidCurr, 
		htidCurr,
		NULL,
		&m_pModuleList
	);

	if (xosd!=xosdNone)
		return;

	LPMODULE_ENTRY pMod = FirstModuleEntry( m_pModuleList );

	for (int i=0; i<ModuleListCount(m_pModuleList); i++)
	{
// code used for Win95 testing only
//		if (ModuleEntryBase(pMod) > 0x70000000)
//			ModuleEntryBase(pMod) += 0x80000000;

		nItem = ProcessList->InsertItem( i, GetBaseName( ModuleEntryName(pMod) ) );

		TCHAR szAddr[ MAX_PATH ];
		wsprintf( szAddr, "0x%08lX - 0x%08lX", ModuleEntryBase(pMod), ModuleEntryBase(pMod)+ModuleEntryLimit(pMod)-1 );
		ProcessList->SetItemText( nItem, PL_ADDR, szAddr );

		ProcessList->SetItemText( nItem, PL_FULLPATH, ModuleEntryName(pMod) );

		wsprintf( szAddr, "%d", pMod-FirstModuleEntry(m_pModuleList)+1 );
		ProcessList->SetItemText( nItem, PL_ORDER, szAddr );

		ProcessList->SetItemData( nItem, (LPARAM)pMod );

		pMod = NextModuleEntry( pMod );
	}

}



void
CModuleDialog::OnChangeModule(
	)
{
	EmptyModuleList ();
	FillModuleList ();
}


	
void
CModuleDialog::OnOK(
	)
{
	C3dDialog::OnOK ();
}


//
//	No symbolic information dialog
//

BEGIN_MESSAGE_MAP(CNoSymbolInfoDlg, C3dDialog)
END_MESSAGE_MAP()


CNoSymbolInfoDlg::CNoSymbolInfoDlg(
	CWnd*	pParent // = NULL
	)
	: C3dDialog (CNoSymbolInfoDlg::IDD, pParent)
{
	m_fNoPrompt = FALSE;
	m_strCaption = "";
	m_strPrompt = "";
}


void
CNoSymbolInfoDlg::DoDataExchange(
	CDataExchange*	pDX
	)
{
	C3dDialog::DoDataExchange (pDX);

	DDX_Check (pDX, IDC_NO_PROMPT, m_fNoPrompt);
}


BOOL
CNoSymbolInfoDlg::OnInitDialog(
	)
{
	CString 	str;
	TCHAR		buffer [512];
	CStatic*	st = (CStatic*) GetDlgItem (IDC_PROMPT);

	if (m_strCaption != "")
	{
		SetWindowText (m_strCaption);
	}

	str.LoadString (ERR_No_Debug_Info);
	sprintf (buffer, str, (LPCTSTR) m_strPrompt);
	m_strPrompt = buffer;

	st->SetWindowText (m_strPrompt);

	return TRUE;
}


//
//	CFibers Message Map

BEGIN_MESSAGE_MAP(CFibers, C3dDialog)
END_MESSAGE_MAP()


CFibers::CFibers(
	CWnd*	pParent // = NULL
	)
	: C3dDialog (CFibers::IDD, pParent)
{
}

#define FL_INDEX_NAME	0
#define FL_INDEX_PID	1
#define FL_INDEX_TITLE	2

CFibers::~CFibers(
	)
{

	delete [] m_FbrLst;
	m_FbrCntx = NULL;
}

void
CFibers::DoDataExchange(
	CDataExchange*	pDX
	)
{
	C3dDialog::DoDataExchange (pDX);
}

int CALLBACK
FLCompareFunction(
	LPARAM	lParam1,
	LPARAM	lParam2,
	LPARAM	nSortField
	)
{
	PFBRLST fbrl1 = (PFBRLST) lParam1;
	PFBRLST fbrl2 = (PFBRLST) lParam2;
	
	switch (nSortField)
	{
		case FL_INDEX_NAME:
			return lstrcmpi (fbrl1->strFbr, fbrl2->strFbr);
			break;
		case FL_INDEX_PID:
			return ((int)fbrl1->FbrCntx - (int)fbrl2->FbrCntx);
			break;
		case FL_INDEX_TITLE:
		{
			return 0;
		}
		default:
			ASSERT (FALSE);
	}

	return 0;
}

extern BOOL GetSymbolFromAddr(PADDR, CString&);


BOOL
CFibers::OnNotify(
	WPARAM		wParam,
	LPARAM		lParam,
	LRESULT*	lResult
	)
{
	switch ( ((LPNMHDR)lParam)->code )
	{
		case LVN_COLUMNCLICK:
			return OnLvnColumnClick ((NM_LISTVIEW*) lParam, lResult);
	}

	return 0;
}

BOOL
CFibers::OnLvnColumnClick(
	NM_LISTVIEW*	ListData,
	LRESULT*		lResult
	)
{
	
	CListCtrl*	FiberList = (CListCtrl*) GetDlgItem (IDC_FIBERS_LIST);
	ULONG		nSortField;

	ASSERT (FiberList);

	//
	//	this is a sort request
	
	FiberList->SortItems (FLCompareFunction, ListData->iSubItem);

	return TRUE;
}
		
BOOL
CFibers::OnInitDialog(
	)
/*++

Routine Description:

	Initialize dialog with list of processes.

Return Value:

	Returns TRUE to denote success.

--*/
{
	TASK_LIST_ENUM	TaskListEnum;
	TCHAR			Buffer [15];
	TCHAR			Location[256];
	DWORD				nFbrs=0;
	DWORD			nItem;
	OFBRS			ofbrs;
	DWORD			sizebuf[16];
	DWORD			*dwFbrLst;

	C3dDialog::OnInitDialog ();
	
	CListCtrl*	FiberList = (CListCtrl*)GetDlgItem (IDC_FIBERS_LIST);

	FiberList->InsertColumn (FL_INDEX_NAME, "Fiber", LVCFMT_LEFT, 110);
	FiberList->InsertColumn (FL_INDEX_PID, "Fiber Id", LVCFMT_LEFT, 75);
	//FiberList->InsertColumn (FL_INDEX_TITLE, "Title", LVCFMT_LEFT, 150);

	ofbrs.op = OFBR_QUERY_LIST_SIZE;
	// Sytem services return values in the same buffer as the command
	// so copy the command to the return buffer.
	memcpy(sizebuf,&ofbrs,sizeof(OFBRS));
	OSDSystemService (hpidCurr,
					  htidCurr,
					  ssvcFiberDebug,
					  (LPVOID) sizebuf,
					  sizeof(OFBRS),//should use two calls
					  &nFbrs
					  );
	int lstsize = *((int *)sizebuf);
	// must have enough room for OFBRS
	lstsize = (lstsize < sizeof(OFBRS)) ? sizeof(OFBRS) : lstsize;
	dwFbrLst = new DWORD [lstsize];
	m_FbrLst = new FBRLST [lstsize];

	ofbrs.op = OFBR_GET_LIST;
	// Sytem services return values in the same buffer as the command
	// so copy the command to the return buffer.
	memcpy(dwFbrLst,&ofbrs,sizeof(OFBRS));
	OSDSystemService (hpidCurr,
					  htidCurr,
					  ssvcFiberDebug,
					  (LPVOID) dwFbrLst,
					  lstsize,//should use two calls
					  &nFbrs
					  );
	nFbrs = nFbrs>>2;//number of fibers rather than bytes
	for (int i = 0; i < nFbrs; i++)
	{
		CString	strLocation;
		ADDR Addr = {0};
		_snprintf(Buffer,16,"0x%08x",dwFbrLst[i]);
		m_FbrLst[i].FbrCntx = (LPVOID) dwFbrLst[i];
		ofbrs.op = OFBR_SET_FBRCNTX;
		ofbrs.FbrCntx = (LPVOID) dwFbrLst[i];
		OSDSystemService (hpidCurr,
					  htidCurr,
					  ssvcFiberDebug,
					  (LPVOID) &ofbrs,
					  sizeof(OFBRS),
					  NULL
					  );

		HTID htid = htidCurr;
		OSDGetFrame(hpidCurr,htid,1,&htid);		
		OSDGetAddr(hpidCurr,htid,adrPC,(PADDR)&Addr);
		// Get the thread location.  First, see if we can determine a function
		// name for the current CS:EIP.  If we can't, then look up the stack
		// for the first address for which we DO have symbols.
		if (!GetSymbolFromAddr(&Addr,strLocation))
		{
		// If the address that the top of stack doesn't have a symbol,
		// then look up the stack, and if we find something we recognize,
		// put its function name in brackets
			int i;
			HFME hfme;
			LPFME lpfme;

			for (i = 0; (hfme = CLHfmeGetNth(i)) != NULL; ++i)
			{
				lpfme = (LPFME)LLLpvFromHlle(hfme);
				if (lpfme->clt == cltProc)
				{
					// found a function: format as "[func_name]"
					if (GetSymbolFromAddr(&lpfme->addrProc, strLocation))
					{
						_snprintf(Location,256, "[%s]",
							(const char*)strLocation);
						break;
					}
				}
				UnlockHlle(hfme);
			}
			if (hfme) {
				UnlockHlle(hfme);
			}
		}
		else
		{
			_tcsncpy(Location, (LPCTSTR)strLocation, 256);
			Location[255-1] = '\0';
		}
		m_FbrLst[i].strFbr = Location;
		nItem = FiberList->InsertItem (0, Location);
		FiberList->SetItemText (nItem, 1, Buffer);
		//FiberList->SetItemText (nItem, 2, "                      ");
		FiberList->SetItemData (nItem, (LPARAM)&(m_FbrLst[i]));
	}

	FiberList->SetItemState (0, LVNI_SELECTED, LVNI_SELECTED);
	
	// Put the old thread back
	ofbrs.op = OFBR_SET_FBRCNTX;
	ofbrs.FbrCntx = NULL;	
	OSDSystemService (hpidCurr,
					  htidCurr,
					  ssvcFiberDebug,
					  (LPVOID) &ofbrs,
					  sizeof(OFBRS),
					  NULL
					  );
	HTID htid = htidCurr;
	OSDGetFrame(hpidCurr,htid,1,&htid);		
	delete [] dwFbrLst;
	return TRUE;  
}


void
CFibers::OnOK(
	)
{
	int			nItem;
	CListCtrl*	FiberList = (CListCtrl*) GetDlgItem (IDC_FIBERS_LIST);
	CString		str;
	PFBRLST		fbrl;
	
	ASSERT (FiberList);

	nItem = FiberList->GetNextItem (-1, LVNI_SELECTED);

	if (nItem != -1)
	{
		fbrl = (PFBRLST) FiberList->GetItemData (nItem);

		ASSERT (fbrl);

		m_FbrCntx = fbrl->FbrCntx;
		C3dDialog::OnOK ();
		return;
	}

	C3dDialog::OnCancel ();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mw.cpp ===
/////////////////////////////////////////////////////////////////////////
//
//	MW.C - Memory Window Handler
//
//	Copyright (C)1990, Microsoft Corporation
//
//	Purpose: To display and update the memory windows.
//
//  Revision History:
//       Written by: Mark A. Brodsky
//
// 	Notes:
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop

IMPLEMENT_DYNCREATE( CMemoryView, CMultiEdit )

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

UINT        CMemoryView::g_cRef         = 0;
CFontInfo   *CMemoryView::g_pFontInfo   = NULL;

CMemoryView :: CMemoryView()
{
	memset(&m_mwi, 0, sizeof(MWI));

	m_hlliCur       = (HLLI)NULL;
	m_rgbCacheCur   = (BYTE FAR *)NULL;
	m_hlliPrev      = (HLLI)NULL;
	m_rgbCachePrev  = (BYTE FAR *)NULL;

	if (g_cRef++ == 0)
		g_pFontInfo = new CFontInfo(*(pfmtcatFromDocType((DOCTYPE)MEMORY_WIN)->pLogFont));

    m_pFontInfo = g_pFontInfo;
    m_dt        = MEMORY_WIN;

    AddThisToCMEList(this);
}

CMemoryView :: ~CMemoryView()
{
	UncacheAll();

	DestroyUndoList();

	if ( m_mwi.szExpr )
    {
		runDebugParams.strExpr = m_mwi.szExpr;
		free(m_mwi.szExpr);
		m_mwi.szExpr = NULL;
	}

	if ( --g_cRef == 0 )
	{
		delete g_pFontInfo;

		g_pFontInfo = NULL;
	}

	if ( m_mwi.rgwLineInfo )
	{
		_ffree(m_mwi.rgwLineInfo);

		m_mwi.rgwLineInfo = NULL;
	}

	if ( m_mwi.rgf )
	{
		_ffree(m_mwi.rgf);
		m_mwi.rgf = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//
//	      PUBLIC API's - Interfaces to the Memory Window
//
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//// MWSaveSettings
//
// Purpose: Save information into global runDebugParams for global access
//
// Input:
//	sz	Address expression to save into global runDebugParams.pszExpr
//
// Output:
//	none.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void PASCAL MWSaveSettings( char * sz )
{
	runDebugParams.strExpr = sz;
}

//// MWScanType
//
// Purpose: Circularly loop through display types resulting from <Sh+F3>
// accelerator.
//
// Input:
//	iDir	Direction for change ( 1 == foward, -1 == backwards )
//
// Output:
//	Active memory window changes display format.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void PASCAL MWScanType(short	iDir )
{
	if ( pViewMemory )
    {
		USHORT			imwd;
		USHORT			imwdMax;
		CMemoryView *	pmv;
	
		pmv = (CMemoryView *)pViewMemory;
		ASSERT(pmv->IsKindOf(RUNTIME_CLASS(CMemoryView)));

#if _INTEGRAL_MAX_BITS >= 64
		imwdMax = MW_cDisplayTypesExt;
#else
		imwdMax = MW_cDisplayTypes;
#endif

		if ( !(imwd = pmv->m_mwi.pmwd - rgmwd) && iDir == -1 )
			imwd = imwdMax - 1;
		else
			imwd = ( imwd + iDir ) % imwdMax;

		pmv->SetAttributes(imwd, NULL, MWNINCH, MWNINCH, MWNINCH);

		runDebugParams.iMWFormat = imwd;
	}
	else
		MessageBeep( 0 );
}

//// UpdateWindows
//
// Purpose: Update the memory windows. This should be called when
// the debuggee returns from execution.
//
// Input: None.
//
// Output: Window upating.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: UpdateView()
{
	// If the window's open, re-evaluate the expression if live, and
	// repaint the window.

	if ( m_mwi.fLiveExpr == MW_LIVE )
		SetAttributes(MWNINCH, NULL, MWNINCH, MWNINCH, MWNINCH);
	else
		UpdateExprFromMwiAddr();

    UncacheData();

	InvalidateRect( NULL, FALSE );

	CMultiEdit::LTextProc(WU_UPDATESCROLLBARS, (WPARAM)0, (LPARAM)0);
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//
//                     Memory Text Window Procedure
//
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//// LTextProc
//
// Purpose: Main window procedure for the memory windows.
//
// Input:
//	wMsg		Message for window.
//	wParam		Message specific information.
//	lParam		Message specific information.
//
// Output:
//	Varies with message.  Usually, 0 == OK, non-zero == failure/error
//
// Exceptions:
//	WM_CLOSE: Free up any allocated data associated with the window
//
//	WM_CHAR: Special case the following:
//		TAB: Skip to the next field of any type.
//		SHIFT-TAB: Skip to the previous field of any type.
//		Ctrl-E: If cursor is on valid field, bring up a dialog to
//		     edit field.
//		BSP: Fake backspace, by shifting field data 1 char right
//                   up to insertion point-1.
//		Other chars: If printable, make edit and redisplay line.
//		     Otherwise, pass data on to the edit manager for normal
//                   interpretation.
//
//	WM_CLEAR: Delete key has been pressed. Fake delete key, by
//	     shifting field data 1 char right up to the insertion point.
//
//	WM_CREATE: Allocate required space and set default display conditions.
//
//	WM_SETFOCUS: Make the window receiving the focus the active memory
//	     window.
//
//	WM_SIZE and WM_ZOOM: Window size is being changed.  Recalculate
//	     the display information for the window and redisplay if
//	     necessary.
//
//	WM_UNDO: Undo the last edit command.
//
// Notes: For the most part, let the EditMgr take care of everything.
//
///////////////////////////////////////////////////////////////////////////
LRESULT CMemoryView :: LTextProc(UINT wMsg, WPARAM wParam, LPARAM lParam )
{
	LRESULT lRet    = 0L;
    BOOL    fUseEM  = TRUE; // Use the EditMgr?
	PMWI    pmwi    = NULL;

	errno = CV_NOERROR;

	switch( wMsg )
    {
		case WM_CHAR:
            switch( wParam )
            {
		    	case VK_TAB:
                {
                    WORD    cRep = LOWORD( lParam );

                    ASSERT( cRep );
	    			fUseEM = FALSE;
                    while( cRep-- )
						NextField ((short)( HIWORD( lParam ) & KK_SHIFT ? MW_REV : MW_FWD ), TRUE);

                    break;
                }

                case (WORD)chBsp:
                {
                    WORD    cRep = LOWORD(lParam);

                    ASSERT( cRep );
       				fUseEM = FALSE;

                    while( cRep-- )
	        			DoDelChar(TRUE);

                    break;
                }

                default:
                    if ( _istprint( wParam ) )
				       	fUseEM = !FDoChar(wParam, lParam);

                    break;
            }
			break;

		case WM_KEYDOWN:
			if ( wParam == VK_DELETE )
            {
				DoDelChar(FALSE);
				fUseEM = FALSE;
			}

			break;

		case WU_CLEARDEBUG:
			UncacheAll();
			DestroyUndoList();
			MWSaveSettings(m_mwi.szExpr);
			break;

		case WU_UPDATEDEBUG:
			UpdateView();
			break;

		case WU_FREEZEDATA:
			SaveDebuggeeData();
			DestroyUndoList();
			break;

		case WU_UPDATESCROLLBARS:
			SetAttributes(MWNINCH, NULL, MWNINCH, MWNINCH, MWNINCH);
			break;

		case WU_INITDEBUGWIN:
			lRet = 1L;
			InitEditMgr();
			errno = CV_NOERROR;

			// Reset this to uninitialized so we
			// pick up the configuration from
			// the rundebugparams later!
			m_mwi.fNoUpdate = FALSE;
			m_mwi.fRetry = FALSE;
			break;

        case WM_SYSCOMMAND:
            switch ( wParam )
            {
                case SC_MINIMIZE:
        			SetAttributes(MWNINCH, NULL, MWNINCH, MWNINCH, MWNINCH);
        			break;

		        case SC_SIZE:
		        case SC_MAXIMIZE:
    		    	// window size being altered, adjust redisplay
	    		    // buffer size so we can indicate correct data
    		    	// changes.
    	    		if ( m_mwi.fNoUpdate )
	    	    		SetAttributes(MWNINCH, NULL, MWNINCH, MWNINCH, MWNINCH);
            }
			break;

		case WM_SIZE:
			// window size being altered, adjust redisplay
			// buffer size so we can indicate correct data
			// changes.
			if ( m_mwi.fNoUpdate )
				SetAttributes(MWNINCH, NULL, MWNINCH, MWNINCH, MWNINCH);
			break;

		case WM_SETFOCUS:
			MakeWindowActive();
			break;

		case WM_UNDO:
			fUseEM = FALSE;
			UndoValue((BOOL) wParam);
			break;

		case WM_COMMAND:
			// lParam (if non-null) is a POINT FAR * for drag and
			// drop.  The new address should be placed on this line
			if ( lParam )
            {
				DWORD	 oln;

				oln = (DWORD)(((POINT FAR *)lParam)->y / m_pFontInfo->m_tm.tmHeight) + OlnGetTop();

				SetCursorAt(ObGetCurPos(), oln);
			}

            SetAttributes(runDebugParams.iMWFormat,
                          (LPSTR)(LPCSTR)runDebugParams.strExpr,
                          runDebugParams.fMWLive,
                          runDebugParams.fMWShowRaw,
                          (USHORT)runDebugParams.iMWItemsPerLine);

			wMsg = WU_UPDATESCROLLBARS;
			ChangeDebuggeeData();
			break;

		default:
			break;
	}

	if ( fUseEM )
		lRet = CMultiEdit::LTextProc(wMsg, wParam, lParam);

	return( lRet );
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//
//          Edit Manager Initialization and Callback Procedures
//
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//// CbGetLineBuf
//
// Purpose: Get a requested display line and pass back to the EditMgr.
//
// Input:
//	iLn	index to the requested line number.
//	cbMax	maximum size of returned string(s).
//	rgch	Place to put data.
//
// Output: Number of bytes stuffed into rgch.
//
// Exceptions:  If this routine is called by functions outside
// of the EditMgr the caller MUST SET pwndEditCur to
// the window
//
// Notes:  To get around a previous problem, the global variable
// pwndEditCur can be used to determine which window request is
// servicing.  The EditMgr maintains this value.
//
///////////////////////////////////////////////////////////////////////////
WORD CMemoryView :: CbGetLineBuf(DWORD iln, WORD cbMax, char *rgch, PDLA &pdla )
{
	// MWFormatLine is generic which uses window information.
	FormatLine(iln, rgch);

	pdla = m_rgdla;

	return( _ftcslen(rgch) );
}

//// CLinesInBuf
//
// Purpose: To inform the EditMgr how many lines are in this buffer.
//
// Input:
//
// Output: The number of lines which we can display.
//
// Exceptions:
//
// Notes:  We will be using the pwndEditCur to delve into the data
// structures for the specified window.
//
///////////////////////////////////////////////////////////////////////////
DWORD CMemoryView :: CLinesInBuf()
{
	DWORD	dwRet;

	// Try setting the memory window to the expression from runDebugParams
	// a) The first time we get in.
	// b) if we failed the first time and the debuggee hasn't reached
	//    the entry point restart. [sanjays]
	if ( !m_mwi.fNoUpdate || (m_mwi.fRetry && lpprcCurr && lpprcCurr->IsBeyondEntryPoint()) )
    {
		MWI		mwi = {0};
		char 	rgch[20];
		ADDR 	addr = {0};
		char *	psz = 0;
		BOOL	fFailed = FALSE;

		m_mwi.fNoUpdate = TRUE;
		m_mwi.fRetry  = FALSE;

		// The user may have tried to entered something
		// which we can't parse/bind/eval, so if that
		// happens, restore the address to OSDebug default
		// data address
		if (!runDebugParams.strExpr.IsEmpty())
			mwi.szExpr = (LPSTR)(LPCTSTR)runDebugParams.strExpr; // hack
		if ( mwi.szExpr && !MWSetAddrFromExpr(&mwi, MW_NO_AUTO_TYPE) )
        {
			fFailed = TRUE;
            // If we haven't reached the entry point yet, we should retry when 
            // all the modules are loaded. 
			if ( !lpprcCurr || !lpprcCurr->IsBeyondEntryPoint() )
				m_mwi.fRetry = TRUE;
		}

		if ( fFailed || runDebugParams.strExpr.IsEmpty() )
        {
			if ( !OSDGetAddr(hpidCurr, htidCurr, adrData, &addr) )
            {
				if ( ADDR_IS_FLAT(addr) )
                {
					ASSERT(ADDR_IS_OFF32(addr));

					sprintf(rgch, "0x%08lX", GetAddrOff ( addr ));
				}
				else
                {
					sprintf(rgch, "0x%04X:0x%0*lX",
                            GetAddrSeg(addr),
    						ADDR_IS_OFF32(addr) ? 8 : 4,
    						GetAddrOff( addr ) );
				}
			}
			else
				_ftcscpy(rgch, szDefaultExpr);

			psz = rgch;
		}
		// we either set the default (psz) or user's was ok (rundebugParams.strExpr)
		psz = psz ? psz : mwi.szExpr;
		if ( !SetAttributes(runDebugParams.iMWFormat,
            				psz, 
            				runDebugParams.fMWLive,
            				runDebugParams.fMWShowRaw,
            				(USHORT)runDebugParams.iMWItemsPerLine) )
			return 0L;

		SaveDebuggeeData();
		MakeWindowActive();
    }

	dwRet = m_mwi.cLines;

	return( dwRet );
}

WORD CMemoryView :: ObMaxBuf()
{
	return( m_mwi.cwLineInfo );
}

BOOL CMemoryView::InsertFromDataObject(COleDataObject * data, const CPoint & point)
{
	UINT cf;
	HGLOBAL hData = NULL;
	LPSTR pszExpr;

	if (data->IsDataAvailable(g_cfTMText))
	{
		cf = g_cfTMText;
	}
	else if (data->IsDataAvailable(CF_TEXT))
	{
		cf = CF_TEXT;
	}
	else
	{
		return FALSE;
	}

	hData = data->GetGlobalData(cf);
	if (NULL == hData)
		return FALSE;

	if (RealGlobalSize(hData))
	{
		// Get a pointer to the data.  Leave if we can't do it.
		VERIFY((pszExpr = (LPSTR)RealGlobalLock(hData)));
		if (!pszExpr)
			return FALSE;
		CPoint pt(point);
		MWDropNewAddress(pszExpr, strlen(pszExpr), &pt);
		RealGlobalUnlock(hData);
		return TRUE;
	}
	return FALSE;
}

void CMemoryView::OnDragEnterFeedback(DWORD grfKeyState, CPoint point)
{
//	CreateGrayCaret(CURSOR_WIDTH, m_pFontInfo->m_tm.tmHeight);
	OnDragOverFeedback(grfKeyState,point);
	ShowCaret();
}

void CMemoryView::OnDragOverFeedback(DWORD grfKeyState, CPoint point)
{
	DWORD oln;
	oln = (DWORD)((point.y / m_pFontInfo->m_tm.tmHeight) + OlnGetTop());
	//SetCursorAt(ObGetCurPos(), oln);

	CRect rc;
	GetClientRect(&rc);
	// make sure line is completely in window so SetCursorAt doesn't scroll
	if ((oln + 1 - OlnGetTop())*m_pFontInfo->m_tm.tmHeight < rc.bottom)
	{
//		SetCursorAt(ObGetLeft(), oln);
		EMSC	emsc;
		emsc.x1 = ObGetLeft();
		emsc.x2 = ObGetLeft() + 8;
		emsc.y = oln;
		CMultiEdit::LTextProc( EM_SELCHARS, 0, (LPARAM)&emsc );
	}
}

void CMemoryView::OnDragLeaveFeedback()
{
//	CreateSolidCaret(CURSOR_WIDTH, m_pFontInfo->m_tm.tmHeight);
}

	
BOOL CMemoryView::Create(LPCSTR lpszClassName, LPCSTR lpszWindowName, DWORD dwStyle, const RECT &rect, CWnd *pParentWnd, UINT nID, CCreateContext *pContext )
{
	CMemoryParent   *pMemoryParent = new CMemoryParent;
	DWORD           styleP         = dwStyle & ~(WS_HSCROLL | WS_VSCROLL | WS_BORDER);

	if ( !pMemoryParent->Create(NULL, NULL, styleP, rect, pParentWnd, nID, NULL) )
		return FALSE;

	if ( !CMultiEdit::Create(lpszClassName, lpszWindowName,
                       dwStyle | WS_VISIBLE | WS_CLIPSIBLINGS,
                       rect, pMemoryParent, nID, pContext) )
	{
		return FALSE;
	}

	pMemoryParent->m_pView = this;

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////
//	ShowContextPopupMenu

BEGIN_POPUP_MENU(Memory)
	MENU_ITEM(IDM_DBGSHOW_MEMBYTE)
	MENU_ITEM(IDM_DBGSHOW_MEMSHORT)
	MENU_ITEM(IDM_DBGSHOW_MEMLONG)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_DBGSHOW_MEMORY_BAR)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_TOGGLE_MDI)
	MENU_ITEM(ID_WINDOW_POPUP_HIDE)
END_POPUP_MENU()

void CMemoryView::ShowContextPopupMenu(CPoint pt)
{
    #ifndef NO_CMDBARS
        TRACE2("CBShow: CMemoryView (%s, %d)\r\n", __FILE__, __LINE__);
        ::CBShowContextPopupMenu(MENU_CONTEXT_POPUP(Memory), pt);
    #else
    	::ShowContextPopupMenu(MENU_CONTEXT_POPUP(Memory), pt);
    #endif
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//
//	      PUBLIC UTILITY API's - Interfaces to the Memory Window
//
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/*
 * LINE_NUMBER_ADDRESS
 *
 *  Parses line number and address expressions.  Error if module is not
 *      loaded.  In DOS5, non-breakpoint addresses have to be loaded.
 */

int PASCAL line_number_address(PADDR paddr, ushort BPSegType, char *s)
{
    PBP pbp;
	BREAKPOINTNODE bpn;
	EESTATUS eest;
	TCHAR sz[cbBpCmdMax];

	// BPParseAddress requires the bp string to be in the canonical form.
	// So we have to do the Parse - MakeCV400BPCmd bit.
	memset( &bpn, 0, sizeof(BREAKPOINTNODE));

	if ( !ParseCV400Location(s, &bpn) && !ParseQC25Location (s, &bpn) )
		return FALSE ;

	// Create a CV BP descriptor string from our descriptor
	*sz = '\0';
	MakeCV400BPCmd(&bpn, sz, sizeof(sz));

    memset( &pbp, 0, sizeof(PBP) );

    pbp.lszCmd		= (char FAR *)sz;
    pbp.BPSegType	= BPSegType;
    pbp.pCXF		= PcxfLocal();

    if ( eest = BPParseAddress( &pbp, TRUE ) )
    {
		errno = eest;
		return FALSE;
    }

    if ( !errno  && ( pbp.BPSegType == EECODE ) && !SHFIsAddrNonVirtual(&pbp.Addr))
    {
		errno = MODLOADERROR;
		return FALSE;
    }

    *paddr = pbp.Addr;

	return(TRUE);
}

// Drag and drop support.  Call this function when
// a string is available for dropping to set the
// memory window's top line to
void MWDropNewAddress(LPSTR lszExpr, DWORD cbData, POINT FAR * lppt)
{

	ASSERT( pViewMemory );

	// Only support this when debugging
	if ( DebuggeeAlive() )
    {
		TCHAR	sz[ axMax ];
		TCHAR *	ptch = sz;
		MWI		mwi = {0};
		
		// Copy the string into local memory and only
		// replace an eol or end of buffer with a zero
		// terminator since FAddrToSz only allows for
		// a single-line zero terminated string
		memset(sz, 0, sizeof(sz));
		_ftcsncpy(sz, lszExpr, (size_t)min((DWORD)sizeof(sz) - 1, cbData));

		while( *ptch && *ptch != '\n' && *ptch != '\r' )
			ptch = _tcsinc( ptch );

		*ptch = '\0';

		mwi.szExpr = sz;

	    if ( MWSetAddrFromExpr( &mwi, runDebugParams.iMWAutoTypes ) ) {
			// Update the global address
			MWSaveSettings( sz );

			// Update the memory window
			pViewMemory->SendMessage(WM_COMMAND, 0, (LPARAM)lppt);
		}
		else
			MessageBeep( 0 );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mwdlg.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////
// Edit.Goto... (Address)

void CMemoryView :: GotoLine()
{
	CString str;
	str.LoadString(IDS_GOTOADDR_WHAT);

	DoGoToDialog(IDD_GOTOADDR, str);
}

#if 0 // old code
class CMWGotoDlg : public CGotoDlg {
	public:
		CMWGotoDlg( void );

	protected:
		virtual BOOL FCanDeactivate( void );
};

void CMemoryView :: GotoLine() {
	CMWGotoDlg		mdg;
	BOOL			fLookAround = TRUE;
	char			sz[ axMax ];

	*sz = '\0';

	// If the ribbon has the focus, get the text from it
	// (this probably can't happen!)
	if ( IsFindComboActive() ) {
		GetFocus()->SendMessage(
			WM_GETTEXT,
			sizeof( sz ),
			(LPARAM)(LPSTR)sz
		);
	}

	// Memory window is up, get the current address!
	else {
		PMWI	pmwi = &((CMemoryView *)pViewMemory)->m_mwi;

		strcpy( sz, pmwi->szExpr );
	}

	// Set up the dialog object and begin....
	mdg.m_strGoto = sz;
	mdg.m_strEditTitle.LoadString( IDS_GOTOEXPR );
	mdg.DoModal();
}

CMWGotoDlg :: CMWGotoDlg()
	: CGotoDlg( IDD_GOTOADDR, (CWnd *)NULL )
{
}

BOOL CMWGotoDlg :: FCanDeactivate() {
	char	sz[ axMax ];
	MWI		mwi = {0};
	BOOL	fExit = FALSE;

	_ftcsncpy( sz, (LPCTSTR)m_strGoto, sizeof( sz ) );
    sz[ sizeof( sz ) - 1 ] = '\0';

	mwi.szExpr = sz;

    if ( MWSetAddrFromExpr( &mwi, runDebugParams.iMWAutoTypes ) ) {
		// If we get here the window MUST be open already
		ASSERT( pViewMemory );

		// Update the global address
		MWSaveSettings( sz );

		// Update the memory window
		pViewMemory->SendMessage( WM_COMMAND, 0, 0L );

		fExit = TRUE;
	}
	else {
		CVMessage( ERRORMSG, BADADDR, MSGSTRING, (char FAR *)sz );
		DebuggerMessage( Error, 0, (LPSTR)sz, SHOW_IMMEDIATE );
	}

	return fExit;
}

#endif // old code
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mwundo.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//	MWUNDO.C - Memory Window Handler
//
//	Copyright (C)1990, Microsoft Corporation
//
//	Purpose: To display and update the memory windows.
//
// 	Notes:
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//// UndoValue
//
// Purpose: Undo the last changed value in the active memory window.
//
// Input: none.
//
// Output: none.
//
// Exceptions:
//
// Notes: Forces cached data to be uncached.
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: UndoValue(
BOOL	fRedo
) {
	HLLE	hlle;
	HLLE    hlleNew;
	LPMUB	lpmub;
	LPMUB	lpmubNew;
	DWORD	iln;
	DWORD	ilnTop;
	DWORD	ilnBottom;
	WORD	ich;
    DWORD	dln;
	RRC		rrc;
	ADDR	addrT;
	UOFFSET	uo;
	USHORT	ucls;

	if ( !m_mwi.hlliUndo ) {
		m_mwi.hlliUndo = LLHlliInit( sizeof( MUB ), llfNull, NULL, NULL  );
	}
	if ( !m_mwi.hlliRedo ) {
		m_mwi.hlliRedo = LLHlliInit( sizeof( MUB ), llfNull, NULL, NULL  );
	}

	if ( hlle = LLHlleGetLast( (fRedo ? m_mwi.hlliRedo : m_mwi.hlliUndo )) ) {
		lpmub = (LPMUB)LLLpvFromHlle( hlle );

		// Set up for moving from undo/redo

		hlleNew 	= LLHlleCreate( fRedo ? m_mwi.hlliUndo : m_mwi.hlliRedo );
		lpmubNew  	= (LPMUB)LLLpvFromHlle( hlleNew );

		lpmubNew->ucls = lpmub->ucls;
		lpmubNew->pmwd = lpmub->pmwd;

		lpmubNew->addr = lpmub->addr;
		lpmubNew->cb   = lpmub->cb;

		DHGetDebuggeeBytes( lpmub->addr, lpmub->cb, (char far *)lpmubNew->rgb );

		// Save cursor/window position info.
		ilnTop = OlnGetTop();
		dln = OlnGetCurPos() - ilnTop;
		iln = MWIlnFromAddr( &m_mwi, &lpmub->addr );
		ich = ObGetCurPos();
		GetClientRrc( &rrc );
		ilnBottom = (DWORD)( ilnTop + rrc.ryBottom - 1 );

		// Update the debuggees data
		DHPutDebuggeeBytes( lpmub->addr, lpmub->cb, lpmub->rgb );
		UpdateWorld( &lpmub->addr, (USHORT)lpmub->cb );

		// update screen (if necessary)
        if ( GetAddrSeg( lpmub->addr ) ==
             GetAddrSeg( m_mwi.addr ) ) {
			
			BOOL	fFound = FALSE;
			
			UncacheData();

			// position cursor
			MWAddrFromIln( &m_mwi, iln, &addrT );

			// If type is same as when changed, try to find exact
			// match on address and class
			if ( lpmub->pmwd == m_mwi.pmwd ) {
				// Start at the beginning of the line and work foward
				SetCurObPos( 0 );

				// Set to the correct line
				SetCurOlnPos( iln );

				do {
					// Move to the next field and get the info
					NextField( MW_FWD, FALSE );
				    CchGetCellInfo( FALSE, &uo, &ucls, &ich );

					fFound = (
						uo + GetAddrOff( addrT ) == GetAddrOff( lpmub->addr ) &&
						ucls == lpmub->ucls
					);
				} while( !fFound && iln == OlnGetCurPos() );
			}

			if ( !fFound ) {
				WORD	ichPrev;
				UOFFSET	cb = (UOFFSET)lpmub->cb;

				// Start at the beginning of the line and work foward
				SetCurObPos( ich = 0 );

				// Set to the correct line
				SetCurOlnPos( iln );

				do {
					// Move to the next field and get the info
					NextField( MW_FWD, FALSE );
					ichPrev = ich;
				    CchGetCellInfo( FALSE, &uo, &ucls, &ich );
					
					// If address matches exactly then done
					if ( uo + GetAddrOff( addrT ) == GetAddrOff( lpmub->addr ) ) {
						fFound = TRUE;
					}

					// Else if the current beginning address is bigger than the
					// current value, put the cursor at the previous field
					else if ( uo + GetAddrOff( addrT ) > GetAddrOff( lpmub->addr ) ) {
						fFound = TRUE;
						ich = ichPrev;
					}
				} while( !fFound && iln == OlnGetCurPos() );

				// Wrapped lines, set cursor to last value on line
				if ( !fFound ) {
					ich = ichPrev;
				}
			}

			if ( iln < ilnTop || iln > ilnBottom ) {
			    if ( iln < dln ) {
			        dln = iln;
			    }
				SetWinTopLineCursor( iln - dln, ich, iln );
			}
			else {
				DWORD	ilnMac;

				addrT = lpmub->addr;
				SetAddrOff( &addrT, GetAddrOff( addrT ) + (UOFFSET)lpmub->cb - 1 );
				ilnMac = MWIlnFromAddr( &m_mwi, &addrT );

				// Redraw all lines which may have been updated
				do {
					DrawLine( ilnMac-- );
				} while( ilnMac >= iln );
				
			    SetCursorAt( ich, iln );
			}
        }

		UnlockHlle ( hlleNew );		
		UnlockHlle ( hlle );

		if ( !fRedo ) {
			// Add the undone item to the redo list
				
			LLAddHlleToLl( m_mwi.hlliRedo, hlleNew );

			// Remove the undo'ed item from the list of changes
			LLFDeleteHlleFromLl( m_mwi.hlliUndo, hlle );

			m_undoBuffer = ubRedo;

			if ( !LLHlleFindNext  ( m_mwi.hlliUndo, 0 ) )
            {
				m_mePlayCount = -2;

				gpISrc->StatusText(STA_End_Of_Undo, STATUS_INFOTEXT, FALSE);
			}
			else
            {
				m_mePlayCount = 1;
				gpISrc->StatusText (STA_Undo, STATUS_INFOTEXT, TRUE);
			}
		}	
		else {
			// Add the redone item to the unredo list
				
			LLAddHlleToLl( m_mwi.hlliUndo, hlleNew );

			// Remove the redone item from the list of changes
			LLFDeleteHlleFromLl( m_mwi.hlliRedo, hlle );

			if ( !LLHlleFindNext  ( m_mwi.hlliRedo, 0 ) )
            {
				m_undoBuffer = ubUndo;
				m_mePlayCount = 0;
				gpISrc->StatusText(STA_End_Of_Redo, STATUS_INFOTEXT, FALSE);
			}
			else
            {
				m_mePlayCount = 1;
				gpISrc->StatusText (STA_Redo, STATUS_INFOTEXT, TRUE);
			}
		}
	}
}

//// DestroyUndoList
//
// Purpose: Destroy the list data associated with a window.  This will be
// called before the debuggee steps or gos, so they can't undo from a
// previous step.
//
// Input: none.
//
// Output: none.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void CMemoryView :: DestroyUndoList() {
	HLLI	hlli;

	if ( pViewMemory )
    {
		m_undoState = usNormal;
		m_mePlayCount = -1;
	}

	if ( hlli = m_mwi.hlliUndo )
    {
		LLChlleDestroyLl( hlli );
		m_mwi.hlliUndo = (HLLI)NULL;
	}

	if ( hlli = m_mwi.hlliRedo )
    {
		LLChlleDestroyLl( hlli );
		m_mwi.hlliRedo = (HLLI)NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mwdata.cpp ===
/////////////////////////////////////////////////////////////////////////
//
//	MWDATA.C - Memory Window Handler
//
//	Copyright (C)1990, Microsoft Corporation
//
//	Purpose: To display and update the memory windows.
//
//  Revision History:
//       Written by: Mark A. Brodsky
//
// 	Notes: Private global data for the memory window
//
//////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// Data for the memory window

#ifdef _WIN32
const MWD rgmwd[] =
#else
MWD _based(_segname("MW_CODE")) rgmwd[] =
#endif
{
	{ sizeof( char ),    1, "%c"	},
#ifdef _WIN32
    { sizeof( wchar_t ), 2, "%wc"	},
#endif	// _WIN32
	{ sizeof( BYTE ),    2, "%2x"	},
	{ sizeof( USHORT ),  6, "%d"	},
	{ sizeof( USHORT ),  4, "%x"	},
	{ sizeof( USHORT ),  5, "%u"	},
	{ sizeof( long ),   11, "%ld"	},
	{ sizeof( long ),    8, "%lx"	},
	{ sizeof( long ),   10, "%lu"	},
	{ sizeof( float ),  13, "%e"	},
	{ sizeof( double ), 22, "%le"	},
#ifndef _WIN32
	{ 10,               28, "%Le"	}
#else	// !_WIN32
#if _INTEGRAL_MAX_BITS >= 64
	{ sizeof( __int64 ),20, "%I64d" },
	{ sizeof( __int64 ),16, "%I64x" },
	{ sizeof( __int64 ),20, "%I64u" }
#endif	// _INTEGRAL_MAX_BITS >= 64
#endif	// !_WIN32
};																  	

const char rgchType[] = {
    'A',
#ifdef _WIN32
    'C',
#endif	// _WIN32
    'B', 'I', 'W', 'U',
    'Z', 'D', 'X', 'S', 'L',
#ifndef _WIN32
    'T'
#else	// !_WIN32
#if _INTEGRAL_MAX_BITS >= 64
	 'M', 'N', 'P'
#endif	// _INTEGRAL_MAX_BITS >= 64
#endif	// !_WIN32
};

// mpbHex is for converting bytes to ascii hex.  The lowercase and
// zero terminator are for quick scans for editing addresses.
const char mpbHex[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                  'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd',
				  'e', 'f', '\0' };

BOOL	fDumping = (BOOL)FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\primes.h ===
/*++

Copyright(c) 1997  Microsoft Corporation

Module Name:

	primes.h

Abstract:

	Declarations for prime numbers.  Actual numbers live in util\hash.cpp.

Author:

    Matthew D Hendel (math) 13-May-1997

--*/


#ifndef _Primes_h_
#define _Primes_h_

extern const ULONG Primes [];
extern const ULONG nPrimes;


#endif // _Primes_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\plist.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*		  Copyright (C) 1994-1995 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

#ifndef _PLIST_H_
#define _PLIST_H_

#define TITLE_SIZE          64
#define PROCESS_SIZE	_MAX_FNAME

#ifdef __cplusplus
extern "C" {
#endif

//
// task list structure
//

//	
//	NOTE:
//
//		The WindowTitle member is filled in by the GetWindowTitles ()
//		function.  It will not be valid before calling that fucntion.  Also,
//		it is only valid when hwnd != NULL.  The ImageName and BinaryType
//		parameters are valid only after calling GetTaskImageInfo ().
//

typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    BOOL        flags;
    HWND		hwnd;
    CHAR        ProcessName [PROCESS_SIZE];
    CHAR        WindowTitle [TITLE_SIZE];
	CHAR		ImageName [_MAX_PATH];
	ULONG		BinaryType;
} TASK_LIST, *PTASK_LIST;


typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;


DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    );

BOOL
GetTaskImageInfo(
	IN OUT	PTASK_LIST	pTask
	);

BOOL
SetDebugPrivilege(
	BOOL	fEnable
    );

BOOL
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    );

VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    );

BOOL
MatchPattern(
    PUCHAR String,
    PUCHAR Pattern
    );

BOOL
InitPlistApi(
	);

void
FreePlistApi(
	);

BOOL
GetImageType(
	LPCSTR	ImageName,
	ULONG*	BinaryType
	);

ULONG
GetOsVersion(
	);

#define IMAGE_DOS_STUB			(((ULONG) -1) - 1)
#define IMAGE_WIN16_OR_OS2		(((ULONG) -1) - 2)
#define IMAGE_BAD_EXECUTABLE	(((ULONG) -1) - 3)

#define TASK_NORMAL_PROCESS 0x00000000
#define TASK_SYSTEM_PROCESS 0x00000001

#ifdef __cplusplus
};
#endif

#endif // _PLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\mwutil.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//	MWUTIL.C - Memory Window Handler
//
//	Copyright (C)1990, Microsoft Corporation
//
//	Purpose: To display and update the memory windows.
//
// 	Notes:
//
//////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//// SetAttributes
//
// Purpose: Change display attributes for specified memory window
//
// Input:
//	iMwType	display type (index into rgmwd table).  If MWNINCH, then
//			do not change display type.
//	szExpr		New expression for window.  If NULL, use old expr.
//	usOpts		Make expression live if TRUE.  If MWNINCH, don't
//			alter setting.
//	wRaw		Show raw data along with the formatted values if TRUE.
//			If FALSE, only show the formatted data.  If MWNINCH,
//			don't alter setting.
// cFixedFmt	If not MWNINCH, set the number of args (!= 0).
//
// Output: Window may be redisplayed if any formats or the display address
// has changed.
//
// Exceptions:
//
// Notes: There are some diferences between overlapped and non-overlapped
// behaviors.  The overlapped version has the scroll bars as children of
// the border window.  The non-overlapped version has the scroll bars as
// children of the TEXT window.  To force repaints, of the border (with
// the display information), we send a WM_PAINT message to the parent.
// We don't want to call DrawWindow( PwndParent() ) becuase this would
// cause a duplicate painting of the memory window.  The
// MESetWinTopLineCursor() call forces a repaint of the text window only.
//
// To correctly paint the window, the non-overlapped model needs to send
// WM_PAINT messages to the scroll bars, since just painting the border
// MAY cause the scroll bar(s) to get over painted and temporarily disappear.
//
///////////////////////////////////////////////////////////////////////////
BOOL CMemoryView :: SetAttributes(
WORD	iMwType,
char *	szExpr,
USHORT	usOpts,
WORD	wRaw,
USHORT	cFixedFmt ) {
	ADDR	addrT;
	DWORD	dln;
	DWORD	iln;
	WORD	ich;
	BOOL	fUpdate;	// Do we need to repaint?

	if ( emiAddr ( m_mwi.addr ) == 0 ) {
		// clear the segment part of the addr, so if only the
		// bottom two bytes are filled in, the segment will still be valid
		GetAddrSeg(m_mwi.addr) = 0;

		OSDGetAddr ( hpidCurr, htidCurr, adrData, &m_mwi.addr );
	}

	// Nothing has changed, so don't require any forced updating.
	fUpdate = FALSE;

	// Get the current cursor position within the file and the
	// vertical offset cursor positon within the visible window.
	iln = OlnGetCurPos();
	dln = iln - OlnGetTop();
	ich = ObGetCurPos();

	// Get the address of the line where the cursor is. If we're going
	// to change everything but the address, we will make sure that
	// the cursor is on the same line and same horizontal offset
	// position within the line after we've udpated.
	MWAddrFromIln( &m_mwi, iln, &addrT );

	// Change display type - Force a new cursor position and display
	// data information.
	if ( iMwType != MWNINCH && m_mwi.pmwd != &rgmwd[ iMwType ] ) {
		m_mwi.pmwd = &rgmwd[ iMwType ];
		fUpdate = TRUE;
	}

	if ( wRaw != MWNINCH && m_mwi.fShowRaw != (BOOL)wRaw ) {
		m_mwi.fShowRaw = (BOOL)wRaw;
		fUpdate = TRUE;
	}

	if ( cFixedFmt != MWNINCH && ( m_mwi.cFixedFmt != cFixedFmt ||
		m_mwi.cFmtVals != cFixedFmt ) ) {
		m_mwi.cFixedFmt = cFixedFmt;
		fUpdate = TRUE;
	}
	// Rebuild any display information necessary.  We may not be forcing
	// an update, but, if the screen size has changed, we may need to
	// redisplay if the number of formatted values per line has changed.
	fUpdate |= FUpdateInfo( fUpdate );

	// If something has been altered to set fUpdate, then we need to
	// set the addr packet to where we left off.
	if ( fUpdate ) {
		if ( GetAddrSeg( m_mwi.addr ) != GetAddrSeg( addrT ) ) {
			ADDR	addrT1;

			MWAddrFromIln( &m_mwi, 1, &addrT1 );
			m_mwi.addr = addrT1;
		}
		else {
			m_mwi.addr = addrT;
		}
        UncacheData();
	}

	// Change expression.  If there's an old one, free it's memory.
	// Here, only the address is getting updated, so don't force a
	// display data info. update.
	if ( szExpr ) {
		char *	psz;

		psz = (char *)NULL;
		if ( m_mwi.szExpr ) {
			psz = m_mwi.szExpr;
		}
		if ( !( m_mwi.szExpr = _ftcsdup( szExpr ) ) ) {
			OOMError();
			return FALSE;;
		}
		fUpdate = TRUE;

		// Re-evaluate the expression.
		if ( MWSetAddrFromExpr( &m_mwi, MW_NO_AUTO_TYPE ) ) {
			// if fRetry is TRUE we are going to try again
			// with the string.
			if ( psz) {
				free( psz );
                psz = NULL;
			}
		}
		else {
			free( m_mwi.szExpr );
            m_mwi.szExpr = psz;
            // return FALSE;
		}

		// Change the addr packet for the line to leave the cursor on.
		addrT = m_mwi.addr;
	}

	// Just update the address if the expression is live
	if ( !szExpr && m_mwi.fLiveExpr ) {
		MWSetAddrFromExpr( &m_mwi, MW_NO_AUTO_TYPE );
		addrT = m_mwi.addr;

        // Foce the update of the cursor position
        fUpdate = TRUE;
	}

	// Set expression to be living or static.  Doesn't require a
	// redisplay, only save value for reevaluating expression between
	// debugge trace, step, and go commands.
	if ( usOpts != MWNINCH ) {
		m_mwi.fLiveExpr = usOpts;
	}

	if ( fUpdate ) {
		char	sz[ axMax ];
        WORD	ichMax;
		WORD	obLeft;
		WORD	dx = min( WinWidth(), (WORD)axMax );

		iln = MWIlnFromAddr( &m_mwi, &addrT );

		// If iln < dln, there's not enough space to display in
		// the offset position, so display the iln(th) line at
		// the iln(th) vertical position.
		if ( iln < dln ) {
			dln = 0L;
		}
		// If the cursor is now positioned beyond the end of the
		// line, set it to the end of the line
		FormatLine( OlnGetTop(), sz );
		ichMax = _ftcslen( sz );
        if ( ich > ichMax ) {
			ich = ichMax;
		}
		if ( ich >= dx ) {
			obLeft = ich - dx + 1;
		}
		else {
			obLeft = 0;
		}

		SetWinTopLineCursor( iln - dln, obLeft, iln );
		SetCursorAt( ich, iln );
		ChangeTitle();
	}

	InvalidateRect( NULL, FALSE );

	return TRUE;
}

//// MWMemWSet
//
// Purpose: Same as memset, but WORD sized instead of BYTE
//
// Input:
//  lpw     Buffer to set
//  wVal    Value to set buffer to
//  cw      Number of WORDS to set
//
// Output: none
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
void PASCAL MWMemWSet(
WORD FAR *  lpw,
WORD        wVal,
size_t      cw ) {
    while( cw-- ) {
        *lpw++ = wVal;
    }
}

//// FUpdateInfo
//
// Purpose: Update the information about the window.  This runction should
// only be called by MWSetAttributes().
//
// Input:
//		fForceChange	Force data to be updated.  This should be set,
//						if the display information has changed.  This
//						will only be false if the address expression
//						and/or the dead/live status has changed and
//						nothing else.
//
// Output: Returns TRUE if display data has changed, else FALSE.
//
// Exceptions:
//
// Notes:
//
///////////////////////////////////////////////////////////////////////////
BOOL CMemoryView :: FUpdateInfo( BOOL fForceChange ) {
	WORD		rgwBuf[ cchBufMax ];
	const MWD * pmwd;
	USHORT		imwd;
	USHORT		cchAddr;
	USHORT		cchSpace;
	USHORT		cchData;
	USHORT		cchExtra;
	WORD		wRaw;
	WORD		wFmt;
	USHORT		cCell;
	USHORT		cCellRaw;
	WORD *		pwEnd;
	USHORT		cFmtLast;
	WORD *		pwLineP1;
    USHORT      us;
	DWORD		dw;
	DWORD		dwT;
    DWORD       lcbMax;
	WORD		dx;
	register WORD *	pw;

	pmwd = m_mwi.pmwd;

	imwd = pmwd - rgmwd;

    // Set cchAddr
    m_mwi.cchAddr = ADDR_IS_OFF32( m_mwi.addr ) ? cchAddr32 : cchAddr16;
	// Overhead (address and space between address and 1st data item
	cchAddr = m_mwi.cchAddr + cchPad;

	// Field width (normal)
	cchData = pmwd->cchFormatted;

	// cchExtra is extra space overhead for BYTE displays.  No other
	// formats use it.  When calculating the number of items which
	// fit on a line, the formula throws out the final trailing pad,
	// but for BYTE displays, the pad is consumed in the two spaces
	// between the last byte and the first ASCII field
	cchExtra = 0;
	
	// cchSpace is the padding between data items.
	//		ASCII or WCHAR w/o RAW data will have zero
	//		BYTE will have one
	//		all others will have cchPad
	//
	// The code to do this will be done below

	// Byte -- only 1 space between data items
	if ( imwd == MW_BYTE ) {
		// For BYTE display, also add in ASCII data for double data display.
		// This could be done below, but this simplifies the source code
		// and we don't need to have an Assertion that cchPad == 2
		++cchData;

		// Also, there is an extra space between the BYTE and the ASCII
		// data, so change the overhead
		++cchAddr;

		cchExtra = cchSpace = 1;
	}

	// Non-character (ASCII or wchar_t), normal spacing OR
	// character data with RAW
	else if ( !IsCharFormat( imwd ) || m_mwi.fShowRaw ) {
		cchSpace = cchPad;
	}
	else {
		cchSpace = 0;
	}

	// Now add in space for RAW data
	if ( m_mwi.fShowRaw && imwd != MW_BYTE ) {
		cchData += pmwd->cbType * cchRaw + cchPad;
	}

	// Make sure that xRight is within range
	dx = min( (WORD)axMax, WinWidth() );

	// Fixed format, just make sure that the output line doesn't exceed max
	if ( m_mwi.cFixedFmt ) {

		// The max number of items per line is the total number of
		// character less the line overhead (address) less the padding
		// between data items (padding is put after the data, so there
		// is 1 extra pad at the end of the info) divided by the number
		// of charcters to display and item plus the space between items.
		// cchExtra is described above
		us = min(
			m_mwi.cFixedFmt,
			((USHORT)axMax-cchAddr-cchSpace+cchExtra) / (cchData+cchSpace),
		);
	}
	else if ( (USHORT)dx > cchData ) {
        // Same formula as above, except look at width of window instead of
		// edit manager line max
		us = max(
			((USHORT)dx-cchAddr-cchSpace+cchExtra) / (cchData+cchSpace),
			1
		);
	}
	// Variable format where window is more narrow than 1 item.  Force to 1.
    else {
        us = 1;
    }

	// Save the old count to compare if we've changed
	cFmtLast = m_mwi.cFmtVals;

	lcbMax = ( ADDR_IS_OFF32( m_mwi.addr ) ? 0xffffffffL : 0x10000L );
	// Make sure that we do boof EditMgr with too many lines
	dw = (DWORD)( pmwd->cbType * us );
	while( ( lcbMax / dw ) > 0x7FFFFFFFL ) {
		dw += pmwd->cbType;
		++us;
	}
	dwT = lcbMax / dw;
    if ( dwT * dw != lcbMax ) {
		++dwT;
	}

	m_mwi.cLines = dwT;

	m_mwi.cFmtVals = us;

    if ( MWIlnFromAddr( &m_mwi, &m_mwi.addr ) >= dwT ) {
        ++m_mwi.cLines;
    }
    else {
        ADDR    addrT;

        MWAddrFromIln( &m_mwi, dwT - 1, &addrT );

        if ( ADDR_IS_FLAT( addrT ) && !GetAddrOff( addrT ) ||
            !LOWORD( GetAddrOff( addrT ) ) ) {

            --m_mwi.cLines;
        }
    }
	fForceChange |= ( cFmtLast != us );

	// If we're forced to update the information or the # of values/line
	// have changed, update the display information.
	if ( fForceChange ) {
		if ( m_mwi.rgwLineInfo ) {
			_ffree( m_mwi.rgwLineInfo );
            m_mwi.cwLineInfo = 0;
		}
		if ( m_mwi.rgf ) {
			_ffree ( m_mwi.rgf );
		}
		//
		// Build rgwLineInfo
		// The format line data is done as follows:
		//   1)  The address area and all places where there are
		//       fixed spaces are, the value "wNoType" is placed.
		//   2)  Any place on the line where a BYTE value appears, a
		//       wFmtLoMin is placed.
		//   3)  All remaining positions where non-byte values
		//       appear, will be filled with wFmtHiMin.
		//   4)  The line data is preceeded and terminated by a
		//       wNull.
		//
		// This formatting of data allows for FAST tabbing to
		// next field upon character input.
		wFmt = imwd == MW_BYTE ? wFmtLoMin : wFmtHiMin;
		wRaw = wFmt ^ wFmtMask;

		pw = rgwBuf;
		*pw++ = wNull;
		pwLineP1 = pw;
		MWMemWSet( pw, wNoType, m_mwi.cchAddr + cchPad );
		pw += m_mwi.cchAddr + cchPad;

		for( cCell = m_mwi.cFmtVals; cCell; --cCell ) {

			// Add format info for raw data.
			if ( m_mwi.fShowRaw && imwd != MW_BYTE ) {
				for( cCellRaw = pmwd->cbType; cCellRaw;
					--cCellRaw ) {

					*pw++ = wNoType;
					MWMemWSet( pw, wRaw++, cchRaw - 1 );
					pw += cchRaw - 1;
				}
				ASSERT( cchPad == 2 );
				*pw++ = wNoType;
				*pw++ = wNoType;
			}

			// Append the information for the actual formatted
			// data here
			MWMemWSet( pw, wFmt++, pmwd->cchFormatted );
			pw += pmwd->cchFormatted;
			pwEnd = pw;
			if ( cchSpace ) {
				MWMemWSet( pw, wNoType, cchSpace );
				pw += cchSpace;
			}
		}
		if ( imwd == MW_BYTE ) {
			// Add real pad.  There's already 1 space, add another.
			ASSERT( cchPad == 2 );
			*pw++ = wNoType;

			// BYTE display, add the ASCII values to the end
			// of the line
			for( cCell = m_mwi.cFmtVals; cCell; --cCell ) {
				*pw++ = wRaw++;
			}
		}
		// Remove trailing spaces
		while( *--pw == wNoType );
		*++pw = wNull;

		// Allocate space for the final product and save away.
		if ( !( m_mwi.rgwLineInfo =
			(WORD FAR *)_fmalloc( sizeof( WORD ) * ( pw - rgwBuf + 2 ) ) ) ) {

			OOMError();
			return FALSE;
		}
		else if ( !( m_mwi.rgf =
			(BOOL FAR *)_fmalloc( sizeof( BOOL ) *
				( ( wRaw & ~wFmtMask ) - wFmtLoMin +
				  ( wFmt & ~wFmtMask ) - wFmtLoMin ) ) ) ) {

			OOMError();
			return FALSE;
		}
		else {
			_fmemcpy(
                m_mwi.rgwLineInfo,
                rgwBuf,
				sizeof( WORD ) * ( pw - rgwBuf + 2 )
            );

            m_mwi.cwLineInfo = (WORD)( pw - rgwBuf - 1 );
		}
	}
	return fForceChange;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\plist.cpp ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1994-1995 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/


/*++

Module Name:

	plist.cpp

Abstract:

	This module provides APIs for getting task lists and for killing processes
	under Windows NT and Windows 95.

--*/
#include "stdafx.h"

#include <winperf.h>
#include <tlhelp32.h>

#include "plist.h"


//
// manafest constants
//

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         "software\\microsoft\\windows nt\\currentversion\\perflib"
#define REGSUBKEY_COUNTERS  "Counters"
#define PROCESS_COUNTER     "process"
#define PROCESSID_COUNTER   "id process"
#define UNKNOWN_TASK        "unknown"

//
// For dynamically loading TOOLHELP32 -- W95 only
//

#define CreateToolhelp32Snapshot _CreateToolhelp32Snapshot
#define Module32First _Module32First
#define Module32Next _Module32Next
#define Process32First _Process32First
#define Process32Next _Process32Next
#define Thread32First _Thread32First
#define Thread32Next _Thread32Next

typedef BOOL(WINAPI *MODULEWALK)(HANDLE hSnapshot, LPMODULEENTRY32 lpme); 
typedef BOOL (WINAPI *THREADWALK)(HANDLE hSnapshot, LPTHREADENTRY32 lpte); 
typedef BOOL (WINAPI *PROCESSWALK)(HANDLE hSnapshot,LPPROCESSENTRY32 lppe); 
typedef HANDLE (WINAPI *CREATESNAPSHOT)(DWORD dwFlags,DWORD th32ProcessID); 



CREATESNAPSHOT	CreateToolhelp32Snapshot	= NULL; 
MODULEWALK		Module32First				= NULL; 
MODULEWALK		Module32Next				= NULL; 
PROCESSWALK		Process32First				= NULL; 
PROCESSWALK		Process32Next				= NULL; 
THREADWALK		Thread32First				= NULL; 
THREADWALK		Thread32Next				= NULL; 

//
//	For dynimcally loading psapi.dll -- WinNT only
//

typedef DWORD (WINAPI *GETMODULEFILENAMEEXA) (HANDLE hProcess, HMODULE hModule,
										   LPSTR lpFilename,DWORD nSize);

typedef DWORD (WINAPI *GETMODULEFILENAMEEXW) (HANDLE hProcess, HMODULE hModule,
										   LPWSTR lpFilename,DWORD nSize);

typedef BOOL (WINAPI *ENUMPROCESSES) ( DWORD* rgProcessIds, DWORD  cb, 
		                               DWORD* cbNeeded);


LUID                  SeDebugLuid                 = {0, 0};
GETMODULEFILENAMEEXA	GetModuleFileNameExA = NULL;
GETMODULEFILENAMEEXW	GetModuleFileNameExW = NULL;
HMODULE					hModPsApi			 = NULL;
ENUMPROCESSES           EnumProcesses               = NULL;

//
// prototypes
//

BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    LPARAM  lParam
    );

DWORD
W95GetTaskList(
	PTASK_LIST	pTask,
	DWORD		dwNumTasks
	);

DWORD
WNtGetTaskList(
    PTASK_LIST  pTask,
    DWORD     dwNumTasks
    );

BOOL
InitPsApi(
	);

void
FreePsApi(
	);

BOOL
InitToolhelp32(
	);

BOOL
W95GetImageInfo(
	PTASK_LIST	Task
	);

BOOL
WNtGetImageInfo(
	PTASK_LIST	Task
	);

BOOL
WINAPI
IsDebugPrivilegeSet(
    );
BOOL
WINAPI
GetImageNameUsingPsapiEx(
    HANDLE               hProcess,		
	HMODULE              hDll,
	DWORD                dwProcessId,
    GETMODULEFILENAMEEXA pfnGetModuleFileNameExA,
	LPTSTR               szImageName,
	DWORD                cbBufferSize
	);

ULONG
GetOsVersion(
	)
{
	BOOL			fSucc;
	OSVERSIONINFO	VersionInfo;

	VersionInfo.dwOSVersionInfoSize = sizeof (VersionInfo);
	
	fSucc = GetVersionEx (&VersionInfo);
	ASSERT (fSucc);
	return VersionInfo.dwPlatformId;
}



BOOL
InitPlistApi(
	)
{
	ULONG	OsVersion = GetOsVersion ();

	if (OsVersion == VER_PLATFORM_WIN32_NT)
	{
		return InitPsApi ();
	}
	else if (OsVersion == VER_PLATFORM_WIN32_WINDOWS)
	{
		return InitToolhelp32 ();
	}
	else
	{
		// neither NT nor W95
		ASSERT (FALSE);
		return FALSE;
	}
}

void
FreePlistApi(
	)
{
	ULONG	OsVersion = GetOsVersion ();

	if (OsVersion == VER_PLATFORM_WIN32_NT)
	{
		FreePsApi ();
	}
	else if (OsVersion == VER_PLATFORM_WIN32_WINDOWS)
	{
		// no freeing necessary under W95
	}
	else
	{
		ASSERT (FALSE);
	}
}


BOOL
InitToolhelp32(
	)
/*++

Routine Description:

	Dynamically load the Win95-only TOOLHELP32 functions.  This is necessary
	so we will run under NT.

	Toolhelp32 does not need to be unloaded, hence there is no FreeToolhelp32
	function.

Return Value:

	True if the TOOLHELP32 functions were successfully loaded and all entry
	points were successfully setup.  False otherwise.

Environment:

	W95 only.
	
--*/
{ 
    BOOL   	bRet  = FALSE; 
    HMODULE hKernel = NULL; 

	if (GetOsVersion () != VER_PLATFORM_WIN32_WINDOWS)
	{
		ASSERT (FALSE);
		return FALSE;
	}
	
    hKernel = GetModuleHandle("KERNEL32.DLL"); 
 
    if (hKernel)
	{ 
        CreateToolhelp32Snapshot =
			(CREATESNAPSHOT) GetProcAddress (hKernel, "CreateToolhelp32Snapshot"); 
 
        Module32First  = (MODULEWALK)GetProcAddress(hKernel, "Module32First"); 
		Module32Next   = (MODULEWALK)GetProcAddress(hKernel, "Module32Next"); 
		Process32First = (PROCESSWALK)GetProcAddress(hKernel,"Process32First");
		Process32Next  = (PROCESSWALK)GetProcAddress(hKernel, "Process32Next");
		Thread32First  = (THREADWALK)GetProcAddress(hKernel, "Thread32First"); 
		Thread32Next   = (THREADWALK)GetProcAddress(hKernel,  "Thread32Next"); 
 
		bRet =  Module32First && Module32Next  && Process32First && 
                Process32Next && Thread32First && Thread32Next && 
                CreateToolhelp32Snapshot; 
    } 
    else 
        bRet = FALSE;
 
    return bRet; 
} 

BOOL
InitPsApi(
	)
/*++

Routine Description:

	Dynamically load the WinNT-only PSAPI function(s).  These functions must
	be dynamically loaded so this will run properly under W95.

	If this function is successful, you must call FreePsApi () function when
	you are done using the psapi dll.  If you do not, resources will not be
	properly deallocated.

Return Value:

	True if the PSAPI dll was successfully loaded and all entry points to that
	dll were successfully setup.  False otherwise.

Comments:

	At this time we are only getting entries to GetModuleFileHandleEx.

Environment:

	WinNT only.

--*/
{
	ASSERT (!hModPsApi);
	
	if (GetOsVersion () != VER_PLATFORM_WIN32_NT)
	{
		ASSERT (FALSE);
		return FALSE;
	}

	hModPsApi = LoadLibrary ("psapi.dll");

	if (!hModPsApi)
		return FALSE;

	GetModuleFileNameExA = (GETMODULEFILENAMEEXA)
			GetProcAddress (hModPsApi, "GetModuleFileNameExA");

	GetModuleFileNameExW = (GETMODULEFILENAMEEXW)
			GetProcAddress (hModPsApi, "GetModuleFileNameExW");

	EnumProcesses = (ENUMPROCESSES)
		        GetProcAddress (hModPsApi, "EnumProcesses");
			

	if (!GetModuleFileNameExA || !EnumProcesses || !GetModuleFileNameExW)
	{
		FreePsApi ();
		return FALSE;
	}

	return TRUE;
}


void
FreePsApi(
	)
/*++

Routine Description:

	This frees all PSAPI resources.

--*/
{
	if (hModPsApi)
	{
		FreeLibrary (hModPsApi);
	}

	hModPsApi = NULL;
	GetModuleFileNameExA = NULL;
	GetModuleFileNameExW = NULL;
    EnumProcesses        = NULL;

}


BOOL
GetTaskImageInfo(
	IN OUT	PTASK_LIST	Task
	)
{
	ULONG OSVersion = GetOsVersion ();
	
	if (OSVersion == VER_PLATFORM_WIN32_WINDOWS)	// W95
	{
		return W95GetImageInfo (Task);
	}
	else if (OSVersion == VER_PLATFORM_WIN32_NT)
	{
		return WNtGetImageInfo (Task);
	}
	else
	{
		//	Not NT or W95
		
		return FALSE;
	}
}


BOOL
WNtGetImageInfo(
	IN OUT PTASK_LIST	Task
	)
{
	HANDLE	hProcess;
	BOOL	fStatus = TRUE;
	CHAR*	ImageName;
	CHAR	Buffer [_MAX_PATH];
	CHAR*	foo;
	WCHAR	Buffer2 [_MAX_PATH];

	hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
							Task->dwProcessId);

	if (!hProcess)
		return FALSE;

	fStatus = GetModuleFileNameExA (hProcess,
									NULL,
									Buffer,
									sizeof (Buffer)
									);

	GetModuleFileNameExW (hProcess, NULL, Buffer2, sizeof (Buffer2));

	if (!fStatus)
	{
		CloseHandle (hProcess);
		return fStatus;
	}


	if (strncmp (Buffer, "\\??\\", 3) == 00)
	{
		ImageName = &Buffer [4];
	}
	else
	{
		ImageName = Buffer;
	}
	
	//	Sometimes we get funky image names; fix them up a little

	if (GetFullPathName (ImageName, sizeof (Task->ImageName),
					 Task->ImageName, &foo) < 0)
	{
		strcpy (Task->ImageName, ImageName);
	}

	//	If we can't get the proper binary type, we set BinaryType == -1
	//	to signify unknown.
	
	if (!GetImageType (Task->ImageName, &Task->BinaryType))
	{
		Task->BinaryType = IMAGE_BAD_EXECUTABLE;
	}

	return fStatus;
}

	
BOOL
W95GetImageInfo(
	IN OUT	PTASK_LIST	Task
	)
/*++

Routine Description:

	On W95 the W95GetTaskList () function has already filled in the
	ImageName.  We just need to fill in the binary type.

--*/
{

	if (!GetImageType (Task->ImageName, &Task->BinaryType))
		Task->BinaryType = IMAGE_BAD_EXECUTABLE;

	return TRUE;
}


DWORD
GetTaskList(
	PTASK_LIST	pTask,
	DWORD		dwNumTasks
	)
{
	ULONG	OsVersion = GetOsVersion ();
	
	if (OsVersion == VER_PLATFORM_WIN32_WINDOWS)
	{
		return W95GetTaskList (pTask, dwNumTasks);
	}
	else if (OsVersion == VER_PLATFORM_WIN32_NT)
	{
		return WNtGetTaskList (pTask, dwNumTasks);
	}
	else
	{
		ASSERT (FALSE);
		return 0;
	}
}


DWORD
W95GetTaskList(
	PTASK_LIST	pTask,
	DWORD		dwNumTasks
	)
/*++

Routine Description:

	Provides an API for getting a list of running tasks using TOOLHELP32 API.

Environment:

	Win95 only.

s--*/
{
	DWORD			i;
	PROCESSENTRY32	ProcessInfo;
	BOOL			Success;
	HANDLE			hSnapshot;
	
	if (!InitToolhelp32 ())
		return 0;

	hSnapshot = CreateToolhelp32Snapshot (TH32CS_SNAPPROCESS, 0);

	ProcessInfo.dwSize = sizeof (ProcessInfo);

	i = 0;

	for (i = 0, Success = Process32First (hSnapshot, &ProcessInfo);
		 Success;
		 Success = Process32Next (hSnapshot, &ProcessInfo)
		)
	{
		pTask [i].dwProcessId = ProcessInfo.th32ProcessID ;
		pTask [i].dwInheritedFromProcessId = ProcessInfo.th32ParentProcessID ;
		pTask [i].flags = 0;
		pTask [i].hwnd = 0;
		pTask [i].WindowTitle [0] = '\000';

		_splitpath (ProcessInfo.szExeFile, NULL, NULL, pTask [i].ProcessName,
					NULL);

		if (_tcsicmp (pTask [i].ProcessName, "KERNEL32") == 00)
			continue;
			
		strcpy (pTask [i].ImageName, ProcessInfo.szExeFile);

		i++;
	}

	CloseHandle (hSnapshot);

	return i;
}


BOOL
GetImageNameUsingPsapi(
	DWORD dwProcessId,
	LPTSTR szImageName,
	DWORD cbBufferSize
	)
{
	HANDLE	hProcess = NULL;
	DWORD	dwStatus = 0;
	BOOL	fSucc = FALSE;
	TCHAR*	pchImageName = NULL;
	BOOL	fDebugPrivilege;

	fDebugPrivilege = IsDebugPrivilegeSet ();
	SetDebugPrivilege (TRUE);

	hProcess = OpenProcess (PROCESS_ALL_ACCESS,
							FALSE,
							dwProcessId
							);

	if (!hProcess) {
		fSucc = FALSE;
		goto Cleanup;
	}

	fSucc = GetImageNameUsingPsapiEx( hProcess, 
									  NULL,
			                          dwProcessId,
			                          GetModuleFileNameExA,
			                          szImageName,
									  cbBufferSize
									 );


Cleanup:

	if (hProcess) {
		CloseHandle (hProcess);
		hProcess = FALSE;
	}

	SetDebugPrivilege (fDebugPrivilege);
	
	return fSucc;
}


BOOL
WINAPI
IsDebugPrivilegeSet(
	)

/*++

Routine Description:

	Check if the SE_DEBUG_PRIVILEGE is set.

Return Values:

	TRUE - if SE_DEBUG_PRIVILEGE is set.

	FALSE - if not or error.

--*/

{
	HANDLE hToken;
	BOOL fSucc;
	BOOL Result;
	PRIVILEGE_SET Privileges;

	
	fSucc = OpenProcessToken (GetCurrentProcess (),
							  TOKEN_QUERY,
							  &hToken
							  );

	if (!fSucc) {
		return FALSE;
	}

	Privileges.PrivilegeCount = 1;
	Privileges.Control = 0;
	Privileges.Privilege [0].Luid = SeDebugLuid;
	Privileges.Privilege [0].Attributes = 0;

	fSucc = PrivilegeCheck (hToken,
							&Privileges,
							&Result);

	if (!fSucc) {
		Result = FALSE;
	}

	CloseHandle(hToken);

	return Result;
}

LOCAL
BOOL
GetLongFileNameAlt(
    LPCTSTR	szInFilename,
    LPTSTR	szOutLongFileName
    )
/*++

Routine Description:

    Converts 8.3 fileNames to LongFileNames and fixes the upper/lower case 
	of a filename and so that it matches what is on disk.  


Arguments:

	szInFilename - Name of file.

	szOutLongFileName - Upper/lower case changed, long filename variant.
					 Assumes size is big enough to hold long filename.

Comments:

    NT5 and Win'98 have an api called GetLongFileName which could be used 

	This is a rip off of FixFileName in debugger\dm - any changes made
	there needs to be propogated here

--*/
{
	CHAR            rgchDrive[MAX_PATH];   /* "X:\ or \\machine_name" */
    WIN32_FIND_DATA wfd;
    CHAR *          pch;
    CHAR *          pchTemp;
    CHAR *          pchStart;
    CHAR            ch;
    HANDLE          hSearch;
    CHAR            szFilename[512];

	//
	// Make Local copy
	//

    _tcscpy( szFilename, szInFilename );                

	if (szFilename[0] && szFilename[1] == ':') {
		sprintf(rgchDrive, "%c:\\", szFilename[0]);
	} else {

		//
		// we don't have the absolute location since there is no drive
		// name - Don't ask me ask GetModuleFileNameEx -that's what
		// returned the garbage in the first place
		//

		return false;
	}

    // 
    // For each filename component, check what case it has on disk.
    // 
		
    pch = szFilename;
    pchTemp = szOutLongFileName;


	//
	// skip past  drive letter and upper case it
	//


    _tcsncpy(pchTemp, pch, 2);
    *pchTemp = (char) CharUpper ((LPTSTR)(*pchTemp));      
    pch += 2;
    pchTemp += 2;

    if (*pch == '/' || *pch == '\\') {
        *pch = *pchTemp = '\\';
        ++pchTemp;
        ++pch;
    }

    while (*pch) {
       size_t iLen;
       pchStart = pch;

       while (*pch && *pch != '\\' && *pch != '/')
       pch = _tcsinc( pch );

       ch = *pch;
       *pch = '\0';

       //
       // Find this filename component
       // 
       hSearch = FindFirstFile(szFilename, &wfd);

       //
       // If the search failed, we'll give
       // up and convert the rest of the name to lower case

       if (hSearch == INVALID_HANDLE_VALUE) {
            return false;
	   }
       //
       // Copy the correct name into the temp filename,
       // 
       iLen = _tcslen(wfd.cFileName);
       _tcsncpy ( pchTemp, wfd.cFileName, iLen );
       pchTemp += iLen;

       //
       // Close the search
       // 
#ifdef _DEBUG
       if  (FindNextFile(hSearch, &wfd) ) {
           DebugBreak();
       }
#endif
       FindClose ( hSearch );

       //
       // Restore the slash or NULL
       // 
       *pch = ch;
       //
       // If we're on a separator, move to next filename component
       // 
       if (*pch) {
           *pchTemp = *pch = '\\';
           pch++; pchTemp++;
       }
    }
    *pchTemp = '\0';
	
	return true;
}
BOOL
WINAPI
GetImageNameUsingPsapiEx(
    HANDLE               hProcess,		
	HMODULE              hDll,
	DWORD                dwProcessId,
    GETMODULEFILENAMEEXA pfnGetModuleFileNameExA,
	LPTSTR               szImageName,
	DWORD                cbBufferSize
	)
{
	DWORD	dwStatus = 0;
	BOOL	fSucc = FALSE;
	TCHAR	szBuffer [_MAX_PATH + 10];
	TCHAR	szBufferLongName [_MAX_PATH + 10];
	TCHAR*	pchImageName = NULL;

	ASSERT (pfnGetModuleFileNameExA || !"Bogus Input");

	dwStatus =(*pfnGetModuleFileNameExA)(hProcess,
			                             hDll,
									     szBuffer,
									     sizeof (szBuffer)
									     );

	if (dwStatus == 00) {
		fSucc = FALSE;
		goto Cleanup;
	}

	//
	// Fixup funky image names.
	//

	if (_tcsncmp (szBuffer, "\\??\\", 3) == 00) {
		pchImageName = &szBuffer [4];
	} else {
		pchImageName = szBuffer;

	}

	//
	// Compenstate for the occasional 8.3 fileName that comes
	// out of GetModuleFileNameExA
	//
	if (GetLongFileNameAlt(pchImageName, szBufferLongName)) {
	    _tcsncpy (szImageName, szBufferLongName, cbBufferSize);
	} else {
	    _tcsncpy (szImageName, pchImageName, cbBufferSize);
	}

	fSucc = TRUE;

Cleanup:
	/*
	if (!fSucc) {
		if (dwProcessId == 0) {
			_tcsncpy (szImageName, "System Idle Process", cbBufferSize);
			fSucc = TRUE;
		} else if (dwProcessId == 2) {
			_tcsncpy (szImageName, "System", cbBufferSize);
			fSucc = TRUE;
		}
	}
	*/
	return fSucc;
}
	

BOOL
WINAPI
IsSystemProcess(
	DWORD dwProcessId
	)

/*++

Routine Description:

	We define a system process as a process whose handle cannot be opened
	without the SE_DEBUG privledge set. This is probably only meaningful
	on NT.

--*/

{
	HANDLE hProcess;
	BOOL fDebugPrivilege;
	BOOL fSystemProcess;

	if (GetOsVersion () != VER_PLATFORM_WIN32_NT) {
		return FALSE;
	}
	
	fDebugPrivilege = IsDebugPrivilegeSet ();
	SetDebugPrivilege (FALSE);

	hProcess = OpenProcess (PROCESS_ALL_ACCESS,
							FALSE,
							dwProcessId
							);

	
	if (hProcess) {
		fSystemProcess = FALSE;
		if (GetOsVersion () == VER_PLATFORM_WIN32_NT) {
			if (dwProcessId == 0 || dwProcessId == 2) {
				fSystemProcess = TRUE;
			}
		}
		goto Cleanup;
	}

	SetDebugPrivilege (TRUE);
	hProcess = OpenProcess (PROCESS_ALL_ACCESS,
							FALSE,
							dwProcessId
							);

	if (hProcess) {
		fSystemProcess = TRUE;
		goto Cleanup;
	}

	fSystemProcess = FALSE;


Cleanup:

	if (hProcess) {
		CloseHandle (hProcess);
		hProcess = NULL;
	}

	SetDebugPrivilege (fDebugPrivilege);
	return fSystemProcess;
}
DWORD
WNtGetTaskList(
    PTASK_LIST  rgTasks,
	DWORD       maxCount
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses the registry performance data to get the
    task list and is therefor straight WIN32 calls that anyone can call.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

Environment:

	WinNT only.

--*/

{

	DWORD i;
	DWORD cb;
	BOOL succ;
	PTASK_LIST pTask = NULL;
	IMAGE_INFO ImageInfo;
	DWORD* rgProcessIds = NULL;
	DWORD AllocatedCount = 0;
	DWORD Count = 0;
	int   returningTaskCount  = 0;

	//
	// EnumProcesses has a very strange protocol for returning the number
	// of processes in the list. If the number used is the same as the
	// max number, assume EnumProcesses did not have enough space, realloc
	// more space and try again.
	//
	do {

		if (rgProcessIds) {
			free (rgProcessIds);
			rgProcessIds = NULL;
		} else {
			AllocatedCount = 200;
		}

		AllocatedCount *= 2;

		rgProcessIds = (DWORD*) malloc (sizeof (DWORD) * AllocatedCount);
		succ = EnumProcesses (rgProcessIds, AllocatedCount, &cb);

		if (!succ) {
			free( rgProcessIds );
			return 0;
		}

	} while (cb == AllocatedCount);


	Count = cb / sizeof (DWORD);

	if (maxCount< Count) {
		free( rgProcessIds );
		return Count;
	}


	for (i = 0; i < Count; i++) {

		pTask = &rgTasks [returningTaskCount];

		ZeroMemory (pTask, sizeof (*pTask));

		pTask->dwProcessId = rgProcessIds [i];

		if (IsSystemProcess (pTask->dwProcessId)) {
		    pTask->flags |= TASK_SYSTEM_PROCESS;
		} else{ 
		    pTask->flags |= TASK_NORMAL_PROCESS;
		}

		succ = GetImageNameUsingPsapi ( pTask->dwProcessId,
		                    			pTask->ImageName,
					                    sizeof (pTask->ImageName)
					                  );
	 	if (succ) {
		    _splitpath (pTask->ImageName,
		    			NULL,
		    			NULL,
		    			pTask->ProcessName,
		    			NULL	
		    			);
		    ImageInfo.Size = sizeof (ImageInfo);
		    succ = GetImageInfo (pTask->ImageName, &ImageInfo);

		   	if (!succ) {
		        pTask->BinaryType= IMAGE_BAD_EXECUTABLE;
		    } else {
		        pTask->BinaryType= ImageInfo.ImageType;
		    }
		    returningTaskCount++;
		} else {
			//
			// BUG BUG - We can't get to the process (lack of permissions) - 
			// we're going to assume system processes - SUCKS!!!!!!!!!!
			//
		    //pTask->flags |= TASK_SYSTEM_PROCESS;
		

		}

	}

	free (rgProcessIds);
	rgProcessIds = NULL;

	return returningTaskCount;
}

//#if 0
//DWORD
//WNtGetTaskList(
//    PTASK_LIST  pTask,
//    DWORD       dwNumTasks
//    )
//
///*++
//
//Routine Description:
//
//    Provides an API for getting a list of tasks running at the time of the
//    API call.  This function uses the registry performance data to get the
//    task list and is therefor straight WIN32 calls that anyone can call.
//
//Arguments:
//
//    dwNumTasks       - maximum number of tasks that the pTask array can hold
//
//Return Value:
//
//    Number of tasks placed into the pTask array.
//
//Environment:
//
//	WinNT only.
//
//--*/
//
//{
//    DWORD                        rc;
//    HKEY                         hKeyNames;
//    DWORD                        dwType;
//    DWORD                        dwSize;
//    LPBYTE                       buf = NULL;
//    CHAR                         szSubKey[1024];
//    LANGID                       lid;
//    LPSTR                        p;
//    LPSTR                        p2;
//    PPERF_DATA_BLOCK             pPerf;
//    PPERF_OBJECT_TYPE            pObj;
//    PPERF_INSTANCE_DEFINITION    pInst;
//    PPERF_COUNTER_BLOCK          pCounter;
//    PPERF_COUNTER_DEFINITION     pCounterDef;
//    DWORD                        i;
//    DWORD                        dwProcessIdTitle;
//    DWORD                        dwProcessIdCounter;
//    CHAR                         szProcessName[MAX_PATH];
//    DWORD                        dwLimit = dwNumTasks - 1;
//	DWORD						 dwT = 0;
//
//
//
//    //
//    // Look for the list of counters.  Always use the neutral
//    // English version, regardless of the local language.  We
//    // are looking for some particular keys, and we are always
//    // going to do our looking in English.  We are not going
//    // to show the user the counter names, so there is no need
//    // to go find the corresponding name in the local language.
//    //
//    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
//    sprintf( szSubKey, "%s\\%03x", REGKEY_PERF, lid );
//    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
//                       szSubKey,
//                       0,
//                       KEY_READ,
//                       &hKeyNames
//                     );
//    if (rc != ERROR_SUCCESS) {
//        goto exit;
//    }
//
//    //
//    // get the buffer size for the counter names
//    //
//    rc = RegQueryValueEx( hKeyNames,
//                          REGSUBKEY_COUNTERS,
//                          NULL,
//                          &dwType,
//                          NULL,
//                          &dwSize
//                        );
//
//    if (rc != ERROR_SUCCESS) {
//        goto exit;
//    }
//
//    //
//    // allocate the counter names buffer
//    //
//    buf = (LPBYTE) malloc( dwSize );
//    if (buf == NULL) {
//        goto exit;
//    }
//    memset( buf, 0, dwSize );
//
//    //
//    // read the counter names from the registry
//    //
//    rc = RegQueryValueEx( hKeyNames,
//                          REGSUBKEY_COUNTERS,
//                          NULL,
//                          &dwType,
//                          buf,
//                          &dwSize
//                        );
//
//    if (rc != ERROR_SUCCESS) {
//        goto exit;
//    }
//
//    //
//    // now loop thru the counter names looking for the following counters:
//    //
//    //      1.  "Process"           process name
//    //      2.  "ID Process"        process id
//    //
//    // the buffer contains multiple null terminated strings and then
//    // finally null terminated at the end.  the strings are in pairs of
//    // counter number and counter name.
//    //
//
//    p = (LPSTR) buf;
//    while (*p) {
//        if (p > (LPSTR) buf) {
//            for( p2=p-2; isdigit(*p2); p2--) ;
//            }
//        if (lstrcmpi(p, PROCESS_COUNTER) == 0) {
//            //
//            // look backwards for the counter number
//            //
//            for( p2=p-2; isdigit(*p2); p2--) ;
//            strcpy( szSubKey, p2+1 );
//        }
//        else
//        if (lstrcmpi(p, PROCESSID_COUNTER) == 0) {
//            //
//            // look backwards for the counter number
//            //
//            for( p2=p-2; isdigit(*p2); p2--) ;
//            dwProcessIdTitle = atol( p2+1 );
//        }
//        //
//        // next string
//        //
//        p += (strlen(p) + 1);
//    }
//
//    //
//    // free the counter names buffer
//    //
//    free( buf );
//
//
//    //
//    // allocate the initial buffer for the performance data
//    //
//    dwSize = INITIAL_SIZE;
//    buf = (LPBYTE) malloc( dwSize );
//    if (buf == NULL) {
//        goto exit;
//    }
//    memset( buf, 0, dwSize );
//
//
//    while (TRUE) {
//		dwT = dwSize;	
//        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
//                              szSubKey,
//                              NULL,
//                              &dwType,
//                              buf,
//                              &dwSize
//                            );
//
//        pPerf = (PPERF_DATA_BLOCK) buf;
//
//        //
//        // check for success and valid perf data block signature
//        //
//        if ((rc == ERROR_SUCCESS) &&
//            (dwSize > 0) &&
//            (pPerf)->Signature[0] == (WCHAR)'P' &&
//            (pPerf)->Signature[1] == (WCHAR)'E' &&
//            (pPerf)->Signature[2] == (WCHAR)'R' &&
//            (pPerf)->Signature[3] == (WCHAR)'F' ) {
//            break;
//        }
//
//		//
//		// This is a workaround for a bug either in the API call, or
//		// in one of the performance DLLs.  The return value is
//		// ERROR_MORE_DATA, but the API sometimes tells us either the
//		// same size or a smaller size!!!  This may be related to having
//		// SQL server installed and running.  It only seems to repro in
//		// that case.
//		//
//#if 0		
//		if (rc == ERROR_MORE_DATA && dwT <= dwSize) {
//
//			if (pPerf->Signature [0] == (WCHAR) 'P' &&
//				pPerf->Signature [1] == (WCHAR) 'E' &&
//				pPerf->Signature [2] == (WCHAR) 'R' &&
//				pPerf->Signature [3] == (WCHAR) 'F')
//			{
//				break;
//			} else {
//				goto exit;
//			}
//		}
//#endif			
//
//        //
//        // if buffer is not big enough, reallocate and try again
//        //
//		
//        if (rc == ERROR_MORE_DATA) {
//            dwSize += EXTEND_SIZE;
//            buf = (LPBYTE) realloc( buf, dwSize );
//            memset( buf, 0, dwSize );
//        }
//        else {
//            goto exit;
//        }
//    }
//
//    //
//    // set the perf_object_type pointer
//    //
//    pObj = (PPERF_OBJECT_TYPE) ((DWORD)pPerf + pPerf->HeaderLength);
//
//    //
//    // loop thru the performance counter definition records looking
//    // for the process id counter and then save its offset
//    //
//    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD)pObj + pObj->HeaderLength);
//    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
//        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
//            dwProcessIdCounter = pCounterDef->CounterOffset;
//            break;
//        }
//        pCounterDef++;
//    }
//
//    dwNumTasks = min( dwLimit, (DWORD)pObj->NumInstances );
//
//    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD)pObj + pObj->DefinitionLength);
//
//    //
//    // loop thru the performance instance data extracting each process name
//    // and process id
//    //
//    for (i=0; i<dwNumTasks; i++) {
//        //
//        // pointer to the process name
//        //
//        p = (LPSTR) ((DWORD)pInst + pInst->NameOffset);
//
//        //
//        // convert it to ascii
//        //
//        rc = WideCharToMultiByte( CP_ACP,
//                                  0,
//                                  (LPCWSTR)p,
//                                  -1,
//                                  szProcessName,
//                                  sizeof(szProcessName),
//                                  NULL,
//                                  NULL
//                                );
//
//        if (!rc) {
//
//			//
//			// if we cant convert the string then use a default value
//			//
//			
//            strcpy( pTask->ProcessName, UNKNOWN_TASK );
//        }
//
//        if (strlen(szProcessName)+4 <= sizeof(pTask->ProcessName)) {
//            strcpy( pTask->ProcessName, szProcessName );
////            strcat( pTask->ProcessName, ".exe" );
//        }
//
//        //
//        // get the process id
//        //
//		
//        pCounter = (PPERF_COUNTER_BLOCK) ((DWORD)pInst + pInst->ByteLength);
//		pTask->hwnd = NULL;
//        pTask->flags = 0;
//        pTask->dwProcessId = *((LPDWORD) ((DWORD)pCounter + dwProcessIdCounter));
//		pTask->WindowTitle [0] = '\000';
//		
//        if (pTask->dwProcessId == 0) {
//            pTask->dwProcessId = (DWORD)-2;
//        }
//
//        //
//        // next process
//        //
//        pTask++;
//        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD)pCounter + pCounter->ByteLength);
//    }
//
//exit:
//    if (buf) {
//        free( buf );
//    }
//
//    RegCloseKey( hKeyNames );
//    RegCloseKey( HKEY_PERFORMANCE_DATA );
//
//    return dwNumTasks;
//}
//
//#endif



BOOL
SetDebugPrivilege(
	BOOL	fEnable
    )

/*++

Routine Description:

    Changes the process's privilege so that we can open process on all
	processes.  In partucluar, on services.

Arguments:

	fEnable - TRUE means enable the debug privledge; FALSE means
			  disable the privledge.

Return Value:

    TRUE             - success
    FALSE            - failure

--*/

{
    HANDLE 				hToken;
    LUID 				DebugValue;
    TOKEN_PRIVILEGES 	tkp;
	BOOL				fSuccess;

    //
    // Retrieve a handle of the access token
    //

	fSuccess = OpenProcessToken (GetCurrentProcess(),
					             TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
						         &hToken);

	if (!fSuccess)
		return FALSE;

    //
    // Enable the SE_DEBUG_NAME privilege
    //


	fSuccess = LookupPrivilegeValue ((LPSTR) NULL,
									 SE_DEBUG_NAME,
									 &DebugValue);

	if (!fSuccess)
        return FALSE;

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = DebugValue;
    tkp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;

    AdjustTokenPrivileges (hToken,
		 				   FALSE,
						   &tkp,
						   sizeof (TOKEN_PRIVILEGES),
						   (PTOKEN_PRIVILEGES) NULL,
						   (PDWORD) NULL);

    //
    // The return value of AdjustTokenPrivileges can't be tested
    //
	
    if (GetLastError () != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}



Protect <HANDLE>::~Protect(
	)
/*++

Routine Description:

	Destructor for HANDLE objects.  NOTE: must be initialized to NULL.

--*/
{
	if (m_h)
	{
		CloseHandle (m_h);
		m_h = NULL;
	}
}


BOOL
GetImageType(
	LPCSTR	ImageName,
	ULONG*	BinaryType
	)
/*++

Routine Description:

	This is basically the same function as GetBinaryType () with slightly
	different semantics.  But this works under both WinNT and W95
	(GetBinaryType () is WinNT only).

Return Value:

	Returns False when it cannot find the file asked for.  Otherwise returns
	True and places the binary type in the BinaryType parameter.  This may
	be IMAGE_BAD_EXECUTABLE.  Note that unlike GetBinaryType () this
	function will not recognize PIF files; nor will it recognize a COM file
	(edit.com) as an executable.

    The Parameter BinaryType will always be valid.

--*/
{
    HANDLE				hImage = NULL;
	Protect <HANDLE>	protect (hImage);
	
    DWORD		bytes;
    DWORD		iSection;
    DWORD		SectionOffset;
    DWORD		CoffHeaderOffset;
    DWORD		MoreDosHeader[16];
    ULONG		ntSignature;
	BOOL		fSuccess;
	ULONG		cbRead;

	IMAGE_DOS_HEADER      image_dos_header;
    IMAGE_FILE_HEADER     image_file_header;
    IMAGE_OPTIONAL_HEADER image_optional_header;
    IMAGE_SECTION_HEADER  image_section_header;

	*BinaryType = IMAGE_BAD_EXECUTABLE;

    hImage = CreateFile (ImageName,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
						 );

    if (INVALID_HANDLE_VALUE == hImage)
		return FALSE;


    fSuccess = ReadFile (hImage,
						 &image_dos_header,
						 sizeof(IMAGE_DOS_HEADER),
						 &cbRead,
						 NULL
						 );

	if (!fSuccess || IMAGE_DOS_SIGNATURE != image_dos_header.e_magic)
		return TRUE;

	*BinaryType = IMAGE_DOS_STUB;

    fSuccess = ReadFile (hImage,
						 MoreDosHeader,
						 sizeof(MoreDosHeader),
						 &cbRead,
						 NULL
						 );

	if (!fSuccess)
		return TRUE;

#if 1

	CoffHeaderOffset = SetFilePointer (hImage,
									  image_dos_header.e_lfanew,
									  NULL,
									  FILE_BEGIN
									  );

	if (CoffHeaderOffset == (ULONG) -1)
		return FALSE;

	CoffHeaderOffset += sizeof (ULONG);


#else

    CoffHeaderOffset = AbsoluteSeek (hImage, image_dos_header.e_lfanew) +
									 sizeof(ULONG);

#endif

    fSuccess = ReadFile (hImage, &ntSignature, sizeof(ULONG), &cbRead, NULL);

	if (IMAGE_OS2_SIGNATURE == ntSignature)
		*BinaryType = IMAGE_WIN16_OR_OS2;

    if (IMAGE_NT_SIGNATURE != ntSignature)
		return TRUE;

    SectionOffset = CoffHeaderOffset + IMAGE_SIZEOF_FILE_HEADER +
                    IMAGE_SIZEOF_NT_OPTIONAL_HEADER;

	fSuccess = ReadFile (hImage,
						 &image_file_header,
						 IMAGE_SIZEOF_FILE_HEADER,
						 &cbRead,
						 NULL
						 );

	if (!fSuccess)
		return TRUE;
		
    fSuccess = ReadFile (hImage,
						 &image_optional_header,
						 IMAGE_SIZEOF_NT_OPTIONAL_HEADER,
						 &cbRead,
						 NULL
						 );

	if (!fSuccess)
		return TRUE;

	*BinaryType = image_optional_header.Subsystem;

	return TRUE;
}



BOOL
KillProcess(
    PTASK_LIST tlist,
    BOOL       fForce
    )
{
    HANDLE            hProcess;


    if (fForce || !tlist->hwnd)
	{
        hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
								tlist->dwProcessId );

		if (hProcess)
		{
            hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE,
									tlist->dwProcessId );

			if (hProcess == NULL) {
                return FALSE;
            }

            if (!TerminateProcess( hProcess, 1 )) {
                CloseHandle( hProcess );
                return FALSE;
            }

            CloseHandle( hProcess );
            return TRUE;
        }
    }

    //
    // kill the process
    //
	
    PostMessage( tlist->hwnd, WM_CLOSE, 0, 0 );

    return TRUE;
}


VOID
GetWindowTitles(
    PTASK_LIST_ENUM te
    )
{
    //
    // enumerate all windows
    //
	
    EnumWindows( EnumWindowsProc, (LPARAM) te );
}



BOOL CALLBACK
EnumWindowsProc(
    HWND    hwnd,
    LPARAM 	lParam
    )

/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    hwnd             - window handle
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

{
    DWORD             pid = 0;
    DWORD             i;
    CHAR              buf[TITLE_SIZE];
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    PTASK_LIST        tlist = te->tlist;
    DWORD             numTasks = te->numtasks;


    //
    // get the processid for this window
    //
	
    if (!GetWindowThreadProcessId( hwnd, &pid )) {
        return TRUE;
    }

    //
    // look for the task in the task list for this window
    //
	
    for (i=0; i<numTasks; i++)
	{
		//
		//	we walk the window tree in Z Order (highest in Z order first);
		//	so if we already have a window associated with this process
		//	dont replace it
		//
		
        if (tlist[i].dwProcessId == pid && IsWindowVisible (hwnd) &&
			tlist [i].hwnd == NULL)
		{
            tlist[i].hwnd = hwnd;

			//
		    // we found the task so lets try to get the
            // window text
            //
			
            if (GetWindowText( tlist[i].hwnd, buf, sizeof(buf) )) {

			//
			//	got it, so lets save it
    	    //
            	strcpy( tlist[i].WindowTitle, buf );
            }
            break;
        }
    }

    //
    // continue the enumeration
    //
    return TRUE;
}


BOOL
MatchPattern(
    PUCHAR String,
    PUCHAR Pattern
    )
{
    UCHAR   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = toupper(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (toupper(c) != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\qwatch.cpp ===
// ..\qwatch.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


CStringArray CQuickW::s_rgstr;
extern DWORD dwFuncTimeOut;


/////////////////////////////////////////////////////////////////////////////
// CQWGridEdit window

class CQWGridEdit : public CEdit
{
    // Construction
    public:
    	CQWGridEdit(CQWGrid *);

    // Attributes
    public:
    	CQWGrid * m_pGrid;

    // Operations
    public:

    // Overrides
    	// ClassWizard generated virtual function overrides
    	//{{AFX_VIRTUAL(CQWGridEdit)
    	//}}AFX_VIRTUAL

    // Implementation
    public:
    	virtual ~CQWGridEdit();

    	// Generated message map functions
    protected:
    	//{{AFX_MSG(CQWGridEdit)
    	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    	afx_msg UINT OnGetDlgCode();
    	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    	//}}AFX_MSG

    	DECLARE_MESSAGE_MAP()
};


CQWGridEdit::CQWGridEdit(CQWGrid *pGrid)
	:  CEdit(), m_pGrid(pGrid)
{
}

CQWGridEdit::~CQWGridEdit()
{
}


BEGIN_MESSAGE_MAP(CQWGridEdit, CEdit)
	//{{AFX_MSG_MAP(CQWGridEdit)
	ON_WM_CREATE()
	ON_WM_GETDLGCODE()
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

int CQWGridEdit::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CEdit::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// REVIEW: Figure out what we need to do to deal with Ctl3d here.
	
	return 0;
}

UINT CQWGridEdit::OnGetDlgCode()
{
	return CEdit::OnGetDlgCode() | DLGC_WANTTAB | DLGC_WANTARROWS | DLGC_WANTALLKEYS;
}

void CQWGridEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_TAB || nChar == VK_RETURN || nChar == VK_ESCAPE || nChar == VK_F2)
		m_pGrid->ProcessKeyboard((MSG*)GetCurrentMessage());
	else
		CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

/////////////////////////////////////////////////////////////////////////////
// CQWGridRow

class CQWGridRow : public CWatchRow
{
// Construction.
public:
	CQWGridRow(CQWGrid *pGrid, CTM *pTM, CQWGridRow *pParent = NULL );
	~CQWGridRow();
	typedef CWatchRow CBaseClass;

	virtual CWatchRow * NewWatchRow(CTreeGridWnd *, CTM *, CTreeGridRow *);
	
	virtual void OnModify();
	virtual void OnSelect(BOOL bSelected);
	virtual CEdit * NewEdit( );	
};

CQWGridRow::CQWGridRow(CQWGrid *pGrid, CTM *pTM, CQWGridRow *pParent /* = NULL*/)
	: CBaseClass(pGrid, pTM, pParent)
{
}	

CQWGridRow::~CQWGridRow( )
{
}

void CQWGridRow::OnModify()
{
	CQWGrid *pGrid = (CQWGrid *)GetTreeGrid();
	pGrid->OnUpdateDebug(0,0);
}

CWatchRow * CQWGridRow::NewWatchRow(CTreeGridWnd *pGrid, CTM *pTM, CTreeGridRow *pRow)
{
	return new CQWGridRow((CQWGrid *)pGrid, pTM, (CQWGridRow *)pRow);
}

void CQWGridRow::OnSelect(BOOL bSelected)
{
	CBaseClass::OnSelect(bSelected);

	if (bSelected)
	{
		CQuickW * pDlg = ((CQWGrid *)m_pGrid)->m_pDlg;
		pDlg->OnSelChanged(this);
	}
}

CEdit* CQWGridRow::NewEdit( )
{
	CQWGridEdit *pEdit = new CQWGridEdit((CQWGrid *)GetGrid());
	
	return pEdit;
}
			
/////////////////////////////////////////////////////////////////////////////
// CQWGrid

CQWGrid::CQWGrid()
	: CBaseClass("")
{
	m_bDockable = FALSE;
	m_bIsModified = FALSE;

	// turn off multiple selection in the quick watch grid only.
	EnableMultiSelect(FALSE);
	ShowSelection(FALSE);
}

CQWGrid::~CQWGrid()
{
}

// Adds a new expression to the quick watch window.
// RETURNS- .
// returns FALSE otherwise.

expr_status CQWGrid::AddNewExpression(const CString& str)
{
	ClearCurEntries();

	if (str.IsEmpty())
		return expr_illegal;

	CWaitCursor wc; // turn on a wait cursor

	// We can afford to have a longer time out for the quickwatch
	// window. The compiler backend guys need it because they
	// evaluate huge functions from the debugger.
	DWORD dwOldFuncTimeOut = dwFuncTimeOut;
	dwFuncTimeOut =  10 * 60 * 1000;

	CRootTM *pTM = new CRootTM(str);

	dwFuncTimeOut = dwOldFuncTimeOut;

	if (!pTM->CouldParseName())
	{
		delete pTM;
		return expr_illegal;
	}

	if (pTM->HadSideEffects())
	{
		::UpdateDebuggerState(UPDATE_ALLDBGWIN);
	}

	CWatchRow *pRow = new CQWGridRow(this, pTM);
	VERIFY(InsertTopLevelRow(pRow, FALSE));

	expr_status expr_return;

	if (pTM->IsValueValid() )
	{
		expr_return = expr_valid;
		// By default we always expand one-level if possible.
		if (pRow->IsExpandable())
			Expand(pRow, FALSE);
	}
	else
	{
		expr_return = expr_invalid;
	}
	
	Select(pRow);	// Select the first row that was added.	
	InvalidateGrid();
	return expr_return;
}
							
BOOL CQWGrid::ProcessKeyboard(MSG *pMsg, BOOL bPreTrans /* = FALSE */ )
{
	switch(pMsg->message)
	{
	case WM_SYSKEYDOWN:
	case WM_KEYDOWN:
		switch(pMsg->wParam)
		{
		
		case VK_RETURN:
			if (m_pControlWnd == NULL)
			{
				BOOL bMenu =  GetKeyState(VK_MENU) < 0;

				if (!bMenu)
				{
					CTreeGridRow *pRow = GetCurSel();
					
					if (pRow != NULL)
					{
						ToggleExpansion(pRow);
						return TRUE;
					}
				}
				
			}
			// fall through

		case VK_ESCAPE:
			if (m_pControlWnd == NULL)
			{
				CWnd *pParent = GetParent();
				
				if (pParent != NULL)
				{
					if (bPreTrans)
						pMsg->hwnd = pParent->m_hWnd;
					else
						pParent->PostMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
				}

				return CGridWnd::ProcessKeyboard(pMsg, bPreTrans);
			}
			break;
						
		case VK_TAB:
			// control-tab is mdi window switching.
			if (GetKeyState(VK_CONTROL) < 0)
				break;

			if (!AcceptControl(FALSE))
				return TRUE;

			// BLOCK: Tab between elements, or dlg controls
			{
				CGridElement* pOldActive = m_pActiveElement;

				if (GetKeyState(VK_SHIFT) < 0)
					ActivatePrevControl();
				else
					ActivateNextControl();

				if (pOldActive == m_pActiveElement)
				{
					// We must be at the last (or first) element in the grid
					CloseActiveElement();

					CWnd* pParent = GetParent();
					// Move focus to the next/previous control.
					if (m_pDlg == pParent)
					{
						if (GetKeyState(VK_SHIFT) < 0)
							m_pDlg->PrevDlgCtrl();
						else
							m_pDlg->NextDlgCtrl();
					}
					return CGridWnd::ProcessKeyboard(pMsg, bPreTrans); // must skip CGridControlWnd
				}

				return TRUE;
			}
			break;
		case 'C':
			if (m_pControlWnd == NULL)
			{
				// No Alt, just Ctrl-C implies copy to clipboard.
				if (GetKeyState(VK_MENU) >= 0 && GetKeyState(VK_CONTROL) < 0)
				{
					SendMessage(WM_COMMAND, ID_EDIT_COPY);
					return TRUE;
				}
			}
			break;
		}
	}

	return CBaseClass::ProcessKeyboard(pMsg, bPreTrans);
}

LRESULT CQWGrid::OnUpdateDebug(WPARAM wParam, LPARAM lParam)
{
	m_bIsModified = TRUE;
	return CBaseClass::OnUpdateDebug(wParam, lParam);
}
																			
BEGIN_MESSAGE_MAP(CQWGrid, CQWGrid::CBaseClass)
	//{{AFX_MSG_MAP(CQWGrid)
	ON_WM_GETDLGCODE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CQWGrid message handlers

UINT CQWGrid::OnGetDlgCode()
{
	return (CBaseClass::OnGetDlgCode() | DLGC_WANTARROWS | DLGC_WANTALLKEYS);
}

int CQWGrid::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CBaseClass::OnCreate(lpCreateStruct) == -1)
		return -1;

	CRect rc;
	GetWindowRect(rc);
		
	int widthName = runDebugParams.iQWNameColWidth;

	// zero implies un-initialized, the second case could
	// happen if the user switches resolutions.
	if (widthName == 0 || widthName >= rc.Width())
	{
		widthName = (2 * rc.Width())/5;
	}

	SetColumnWidth(COL_NAME, widthName);
	
	
	return 0;
}

void CQWGrid::OnDestroy()
{
	runDebugParams.iQWNameColWidth = GetColumnWidth(COL_NAME);

	CBaseClass::OnDestroy();
}

void CQWGrid::OnKillFocus(CWnd* pNewWnd)
{
	ShowSelection(FALSE);
	CBaseClass::OnKillFocus(pNewWnd);
	
}

void CQWGrid::OnSetFocus(CWnd* pOldWnd)
{
	ShowSelection(TRUE);	
	CBaseClass::OnSetFocus(pOldWnd);
}

/////////////////////////////////////////////////////////////////////////////
// CQuickW dialog


CQuickW::CQuickW(CWnd* pParent /*=NULL*/)
	: CBaseClass(CQuickW::IDD, pParent)
{
	m_qwGrid.m_pDlg = this;

	// If the find combo is active when the command is issued, remember the
	// string in the find combo.
	if (IsFindComboActive())
		GetFocus()->GetWindowText(m_strInit);
			
	//{{AFX_DATA_INIT(CQuickW)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

inline CTM * CQuickW::GetCurTM( )
{
	CQWGridRow *pRow = (CQWGridRow *)m_qwGrid.GetCurSel();
	
	if ( pRow )
	{
		return pRow->GetTM();
	}
	
	return NULL;
}

inline BOOL CQuickW::IsCurRowEditable()
{
	CTM *pTM = GetCurTM();

	if ( pTM ) return pTM->IsValueEditable();
	
	return FALSE;
}

// strips leading and trailing white space from a string.			
CString CQuickW::StripWhiteSpace(const CString& str)
{

	if (str.IsEmpty())
	{
		return str;
	}

	int lindex;
	for (lindex = 0 ; lindex < str.GetLength() ; lindex++ )
	{
		if (!whitespace(str[lindex]))
			break;
	}
	
	if (lindex == str.GetLength())
		return "";

	int rindex;
	for (rindex = str.GetLength() - 1 ; rindex >= 0; --rindex)
	{
		if (!whitespace(str[rindex]))
			break;
	}

	ASSERT(rindex >= lindex);

	return str.Mid(lindex, rindex - lindex + 1);
}

void CQuickW::ChangeDefButton(UINT nID)
{
	ASSERT(nID == IDCANCEL || nID == ID_QUICKW_NEWEXPR /* || nID == ID_QUICKW_MODIFY */);

	// If we are going to make this the default button it better be enabled.
	if ( !GetDlgItem(nID)->IsWindowEnabled() )
		nID = IDCANCEL;

	UINT oldDefID = LOWORD(GetDefID());

	if (oldDefID != nID)
	{
		// tell the old button it is no longer the default.
		if (oldDefID != 0)
		{
			CButton *pButton = ((CButton *)GetDlgItem(oldDefID));

			if ( pButton) pButton->SetButtonStyle(BS_PUSHBUTTON);
		}

		SetDefID(nID);
	}
}

void CQuickW::UpdateControls(UINT nForceID /* = 0 */ )
{
	UINT defID;
	BOOL bIsModifiable = m_bIsValidExpr && IsCurRowEditable();

	CComboBox * pComboExpr =  (CComboBox *)GetDlgItem(ID_QUICKW_EXPRESSION);
	int cbExpr = 0;
	cbExpr = pComboExpr->GetWindowTextLength();

	// the edit control might not have the text yet, but the list box
	// could have the element selected. Happens when we get a CBN_SELCHANGE
	// on dismissing the drop-down.

	if (cbExpr == 0)
	{
		int index = pComboExpr->GetCurSel();
		if ( index != CB_ERR )
			cbExpr = pComboExpr->GetLBTextLen(index);
	}
				
	GetDlgItem(ID_QUICKW_NEWEXPR)->EnableWindow(cbExpr > 0);

#if ENABLE_VALUE_EDIT	// FUTURE: remove if we don't re-introduce the value edit field.
	CWnd * pEditValue = GetDlgItem(ID_QUICKW_VALUE);
	CString strValue;
	pEditValue->GetWindowText(strValue);

	GetDlgItem(ID_QUICKW_MODIFY)->EnableWindow(bIsModifiable && !strValue.IsEmpty());
	GetDlgItem(ID_QUICKW_TXT_VALUE)->EnableWindow(bIsModifiable && DebuggeeAlive());
	pEditValue->EnableWindow(bIsModifiable && DebuggeeAlive());
#endif
	
	BOOL bHasRows = m_qwGrid.GetRowCount() != 0;
	m_qwGrid.EnableWindow(bHasRows);
	GetDlgItem(ID_QUICKW_TXT_MEMBERS)->EnableWindow(bHasRows);

	GetDlgItem(ID_QUICKW_ADD)->EnableWindow(cbExpr > 0 && DebuggeeAlive());

	if ( !m_bIsValidExpr && (cbExpr > 0))
	{
		defID = ID_QUICKW_NEWEXPR;
	}
	else if ( nForceID != 0 )
	{
		defID = nForceID;
	}

#if ENABLE_VALUE_EDIT
	else if ( bIsModifiable && !strValue.IsEmpty())
	{
		defID = ID_QUICKW_MODIFY;
	}
#endif
	else
	{
		defID = IDCANCEL;
	}

	ChangeDefButton(defID);
}
		
expr_status CQuickW::ReplaceQWExpr(const CString& str)
{
	if (str.IsEmpty())
		return expr_invalid;
		
	int iStr;
	CComboBox *pExprCombo = (CComboBox *)GetDlgItem(ID_QUICKW_EXPRESSION);

	for (iStr = 0 ; iStr < s_rgstr.GetSize(); ++iStr)
	{
		if (s_rgstr[iStr] == str)
		{
			// remove it from its current position.
			pExprCombo->DeleteString(iStr);
			s_rgstr.RemoveAt(iStr);
			break;
		}
	}
	
	// Insert the latest string at the beginining of the list.
	pExprCombo->InsertString(0, str);
	s_rgstr.InsertAt(0, str);
	
	expr_status expr_return = m_qwGrid.AddNewExpression(str);

	if ( expr_return == expr_valid )
	{
		m_bIsValidExpr = TRUE;
	}
	else
	{
		m_bIsValidExpr = FALSE;
	}

	return expr_return;
}

void CQuickW::DoDataExchange(CDataExchange* pDX)
{
	CBaseClass::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQuickW)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQuickW, CQuickW::CBaseClass)
	//{{AFX_MSG_MAP(CQuickW)
	ON_BN_CLICKED(ID_QUICKW_NEWEXPR, OnQuickwNewexpr)
	ON_CBN_EDITCHANGE(ID_QUICKW_EXPRESSION, OnCBEditChange)
	ON_CBN_SETFOCUS(ID_QUICKW_EXPRESSION, OnCBSetFocus)
	ON_CBN_SELCHANGE(ID_QUICKW_EXPRESSION, OnCBSelChange)
	ON_BN_CLICKED(ID_QUICKW_ADD, OnQuickwAdd)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CQuickW message handlers

BOOL CQuickW::OnInitDialog()
{
	CBaseClass::OnInitDialog();
	
	m_bIsValidExpr = FALSE;

	CComboBox * pExprCombo = (CComboBox *)GetDlgItem(ID_QUICKW_EXPRESSION);

	ASSERT(pExprCombo != NULL);

	VERIFY(pExprCombo->SetExtendedUI() == CB_OKAY);

	// Add previous quickwatch'd strings to the combo box.
	int iStr;
	for ( iStr = 0; iStr < s_rgstr.GetSize() ; ++iStr)
		VERIFY(pExprCombo->AddString(s_rgstr[iStr]) >= 0);
												
	// replace placeholder by the grid control.
	m_qwGrid.ReplaceControl(this, IDC_PLACEHOLDER, IDC_QW_GRID);
	
	CView   *pCurView = GetCurView();

	if (m_strInit.IsEmpty() && pCurView != NULL)
	{
		BOOL lookAround = TRUE;

		LPSTR lpStr = m_strInit.GetBuffer(MAX_USER_LINE);
		if (gpISrc->ViewBelongsToSrc(pCurView))
		{
			gpISrc->GetCurrentText(pCurView, &lookAround, lpStr, MAX_USER_LINE, NULL, NULL);
		}
		else if (pCurView->IsKindOf(RUNTIME_CLASS(CMultiEdit)))
		{
			CMultiEdit *pMultiEdit = (CMultiEdit *)pCurView;
			pMultiEdit->GetCurrentText(&lookAround, lpStr, MAX_USER_LINE, NULL, NULL );
		}

		m_strInit.ReleaseBuffer();
	}
	
	// Skip over any leading white space.
	m_strInit = StripWhiteSpace(m_strInit);
	
	BOOL bRet = FALSE;
	if (m_strInit.IsEmpty())
	{
		bRet = TRUE;
	}
	else
	{
		if (ReplaceQWExpr(m_strInit) == expr_valid )
		{
			// We might want to change this behavior to do
			// some intelligent determination if the user
			// explicitly picked the value to be qwatched,
			// (for ex: if the value is from the find combo)
			// and set the focus to the grid in that case.
			GotoDlgCtrl(GetDlgItem(ID_QUICKW_EXPRESSION));
		}
		else
			GotoDlgCtrl(GetDlgItem(ID_QUICKW_EXPRESSION));
	}

	return bRet;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CQuickW::OnQuickwNewexpr()
{
	CString strNew;
	CComboBox *pExprCombo = (CComboBox *)GetDlgItem(ID_QUICKW_EXPRESSION);

	pExprCombo->GetWindowText(strNew);
	strNew = StripWhiteSpace(strNew);
	
	if (strNew.IsEmpty())
	{
		GotoDlgCtrl(pExprCombo);
		return;
	}		
		
	switch ( ReplaceQWExpr(strNew) )
	{
		case expr_valid:
			m_qwGrid.SetFocus();
			break;
		case expr_illegal:
			ErrorBox(SYS_Cannot_Watch, strNew);		
			// fall through.
		case expr_invalid:
			GotoDlgCtrl(GetDlgItem(ID_QUICKW_EXPRESSION));
			break;
		default:
			ASSERT(FALSE);
	}

}


void CQuickW::OnSelChanged(CQWGridRow *pRow)
{
	ASSERT(m_qwGrid.IsSelected(pRow));

	CString str = pRow->GetTM()->GetExpr();
	if ( str.GetLength() == 0 )
		str = pRow->GetTM()->GetName();	// this could happen if the string is in error.


	SetDlgItemText(ID_QUICKW_EXPRESSION, str);
	SendMessage(WM_COMMAND, GET_WM_COMMAND_MPS(
								ID_QUICKW_EXPRESSION,
								GetDlgItem(ID_QUICKW_EXPRESSION)->GetSafeHwnd(),
								CBN_EDITCHANGE
							  ));
}


void CQuickW::OnOK()
{
	UINT nID = GetDefID();
	if (nID == ID_QUICKW_NEWEXPR)
		OnQuickwNewexpr();
#if ENABLE_VALUE_EDIT		
	else if (nID == ID_QUICKW_MODIFY)
		OnQuickwModify();
#endif
	else
	{
		ASSERT(nID == IDCANCEL);
		OnCancel();
	}
}

void CQuickW::OnCancel()
{
	// TODO: Add extra cleanup here
	
	CBaseClass::OnCancel();
}


void CQuickW::OnCBEditChange()
{
	if ( GetDlgItem(ID_QUICKW_EXPRESSION)->IsChild(GetFocus()) )	
		m_bIsValidExpr = FALSE;

	UpdateControls(ID_QUICKW_NEWEXPR);
}

void CQuickW::OnCBSetFocus()
{
	UpdateControls(ID_QUICKW_NEWEXPR);	
}

void CQuickW::OnCBSelChange()
{
	m_bIsValidExpr = FALSE;
	UpdateControls(ID_QUICKW_NEWEXPR);
}


void CQuickW::OnQuickwAdd()
{
	CString strExpr;
	GetDlgItem(ID_QUICKW_EXPRESSION)->GetWindowText(strExpr);

	CRootTM rootTM(strExpr);

	if (rootTM.CouldParseName())
	{
		// first close down the dialog.
		EndDialog(IDOK);

		if (CGridWatchView::EnsureWatchWindow())
			g_pWatchView->AddNewWatch(strExpr);
	}
	else
	{
		ErrorBox(SYS_Cannot_Watch, strExpr);
		GotoDlgCtrl(GetDlgItem(ID_QUICKW_EXPRESSION));
	}		

}

#if ENABLE_VALUE_EDIT

void CQuickW::OnQuickwModify()
{
	// TODO: Add your control notification handler code here
	
}

void CQuickW::OnENChange()
{
	UpdateControls(ID_QUICKW_MODIFY);
}

void CQuickW::OnENSetFocus()
{
	UpdateControls(ID_QUICKW_MODIFY);	
}

#endif

void CQuickW::OnDestroy()
{
	CBaseClass::OnDestroy();
	
	if (m_qwGrid.m_bIsModified)
		::UpdateDebuggerState(UPDATE_ALLDBGWIN);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\privguid.h ===
#ifndef __PRIVGUID_H
#define __PRIVGUID_H

// Copyright 1996, Microsoft Corp.

// This file contains dispatch GUID's for the debugger automation object model that
// we don't want to expose to the public.

// Debugger object
// dispatch interface GUID
// {34C63002-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_IDispDebugger,0x34C63002L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);

// Debugger object
// event source dispatch interface GUID
// {34C6301B-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_IDispDebuggerEvents,0x34C6301BL,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);

// Breakpoint object
// dispatch interface GUID
// {34C63005-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_IDispBreakpoint,0x34C63005L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);

// Breakpoints collection
// dispatch interface GUID
// {34C63008-AE64-11cf-AB59-00AA00C091A1}
DEFINE_GUID(IID_IDispBreakpoints,0x34C63008L,0xAE64,0x11CF,0xAB,0x59,0x00,0xAA,0x00,0xC0,0x91,0xA1);

#endif // __PRIVGUID_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\retvals.cpp ===
#include "stdafx.h"
#pragma  hdrstop


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#ifdef ERROR_HANDLING
#include <tchar.h>
#endif	

CRetVals g_retVals;

CRetVals::CRetVals ()
{
}

CRetVals::~CRetVals ()
{
	CleanUp ();
}

VOID CRetVals::CleanUp ()
{
	POSITION pos = m_lstTMs.GetHeadPosition();
	while (pos)
	{
		CReturnTM *pTM = (CReturnTM *)m_lstTMs.GetNext(pos);
		ASSERT(pTM->IsKindOf(RUNTIME_CLASS(CReturnTM)));
		delete pTM;
	}

	m_lstTMs.RemoveAll ();
}

VOID CRetVals::AddTM (LPCSTR szName, LPCSTR szValue, LPCSTR szType)
{
	CReturnTM *pTM = new CReturnTM (szName, szValue, szType);

	if (pTM->IsValueValid ())
	{
		m_lstTMs.AddTail (pTM);
	}
	else
	{
		delete pTM;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\qcqp.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/****************************************************************************

	FUNCTION:   StopDebugConfirm

	PURPOSE:    if Debugger is running, asks if you really want to stop it

****************************************************************************/

BOOL
StopDebugConfirm(BOOL fFailSilently /*= FALSE*/)
{
	BOOL fRet = TRUE;

	if (lpprcCurr &&
		(lpprcCurr->stp == stpRunning || lpprcCurr->stp == stpStopped))
	{
		int	idMsgBox;

		ASSERT(pDebugCurr);
		if (!(pDebugCurr->MtrcAsync() & asyncKill) && DebuggeeRunning()) {
			idMsgBox = IDS_CmdWillStopDebuggerRemoteRestart;
		}
		else {
			idMsgBox = IDS_CmdWillStopDebugger;
		}
		if (!fFailSilently)
			fRet = (AfxMessageBox(idMsgBox, MB_OKCANCEL) == IDOK);
		else
			fRet = FALSE;

		if ( fRet ) {
			// After we put up the message box the debuggee might
			// have died a natural death. make sure it still exists
			// before trying to kill it.
			if (DebuggeeAlive() && !ClearDebuggee(TRUE)) {
				fRet = FALSE;
			}
		}
		else {
			fRet = FALSE;
		}
	}
	return fRet;
}

// [CAVIAR #5904 12/02/92 v-natjm]
/****************************************************************************

	FUNCTION:       ControlExecDebuggee()

	PURPOSE:                Control if a modeless dialog box is present before
					executing a debug command

****************************************************************************/
VOID PASCAL ControlExecDebuggee(WORD CommandId,WORD wExec)
{
	ExecDebuggee((EXECTYPE)wExec) ;
}

LRESULT OnAutosaveTick(HWND, WPARAM, LPARAM lParam)
{
	CAutosave *const pAutosaveServices = (CAutosave *const) lParam;

//	CAutosave *const pAutosaveServices = (CAutosave *const) &gVeryBigHackAutosaver;
//	pAutosaveServices->EnterTick();

	// Sanity check on the autosaver.

	ASSERT(pAutosaveServices->IsEnabled());
	ASSERT(pAutosaveServices->InTick());

	return 0;
}

/****************************************************************************

	FUNCTION:	OnQueryJit

	PURPOSE:	Determine whether or not we would like to be the just-in-time
				debugger for the specified process.  Another copy of MSVC,
				which was started by the system, is asking us this.

	RETURNS:	TRUE for yes, FALSE for no.

****************************************************************************/

BOOL OnQueryJit(PID pid)
{
	// If we're already debugging something then we can't begin debugging
	// another process
	if (DebuggeeAlive())
		return FALSE;

	// If a GO command isn't legal right now then we don't want to start
	// debugging something else
	BOOL bEnabled = FALSE;

	CommandIdEnabled(IDM_RUN_GO, bEnabled);

	if (!bEnabled)
		return FALSE;

	// If we created the specified process, then we'll debug it
	return FParentOfProcess((DWORD)pid, NULL);
}

/****************************************************************************

	FUNCTION:	OnBeginJit

	PURPOSE:	Begin just-in-time debugging.  Another copy of MSVC,
				which was started by the system, is sending us this
				message.

	RETURNS:	TRUE if we begin just-in-time debugging, FALSE if not.

****************************************************************************/

BOOL OnBeginJit(PID pid, HANDLE hEvent)
{
	const char *szPath;

	// There's a slim chance that even though we responded yes to an earlier
	// WU_QUERYJIT message, we are now don't want to be the just-in-time
	// debugger (perhaps because in the meantime we've started debugging
	// something else).
	if (!OnQueryJit(pid))
	{
		CloseHandle(hEvent);
		return FALSE;
	}

	// get path
	VERIFY(FParentOfProcess(pid, &szPath));

	// Set up just-in-time debugging
	theApp.m_jit.SetPid(pid);
	theApp.m_jit.SetEvent(hEvent);
	VERIFY(theApp.m_jit.FSetPath(szPath, TRUE));
	theApp.m_jit.SetActive(TRUE);

	// [dolphin#1685 9/30/93 mikemo]
	if (theApp.m_pMainWnd->IsIconic())
		theApp.m_pMainWnd->ShowWindow(SW_RESTORE);

	SetForegroundWindow(theApp.m_pMainWnd->GetSafeHwnd());
	theApp.m_pMainWnd->UpdateWindow();

	// Post ourselves a Go message so that we'll start debugging.
	theApp.m_pMainWnd->PostMessage(WM_COMMAND,
		GET_WM_COMMAND_MPS(IDM_RUN_GO, 0, 0));

	return TRUE;
}


// FUTURE: Move these to appropriate views or the package!
BOOL MainWnd_OnCommand(WPARAM wParam, LPARAM lParam)
{
	UINT CommandId;
	CommandId = GET_WM_COMMAND_ID(wParam, lParam);
	switch (CommandId)
	{
		case IDM_GOTO_CODE:
			ASSERT(GetCurView() == pViewCalls);
			// Hacky way of telling the calls view to go to source
			// for current cursor position.
			pViewCalls->SendMessage(WM_CHAR, VK_RETURN, 0L);
			return TRUE;

		case IDM_GOTO_SOURCE:
		case IDM_GOTO_DISASSY:
		case IDM_VIEW_MIXEDMODE:
        {
			extern void SwitchToMixedMode(void);
			SwitchToMixedMode();
			return TRUE;
		}
	}
	return FALSE;
}


/****************************************************************************

	FUNCTION:   MainWndProc

	PURPOSE:    Processes window messages.

****************************************************************************/
long PASCAL MainWndProc(HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
	if (message == WU_QUERYJIT)
		return OnQueryJit((PID)wParam);
	else if (message == WU_BEGINJIT)
		return OnBeginJit((PID)wParam, (HANDLE)lParam);

	switch ( message )
    {
		case WM_TIMER:
			switch (wParam)
			{
				case DBGCALLBACKTIMERID:
					// Prevent showing multiple Find Local Module dlgs
					if (!fInFindLocalDlg) {
						DoCallBackAndQueueReturn();
					}
					break;
			}
			goto DefProcessing;

		case WM_COMMAND:
			return (LRESULT)MainWnd_OnCommand(wParam, lParam);

		case WM_QUERYENDSESSION:
			//Before session ends, check that it is ok to quit when debugging
			extern int BoxCount;
			if (BoxCount > 0)
			{
				// we have a dialog up
				ErrorBox(ERR_Cannot_Quit);
				return FALSE;
			}
			if (DebuggeeAlive() && (QuestionBox(ERR_Close_When_Debugging, MB_YESNO) != IDYES))
				return FALSE;

			return TRUE;

		case WU_FINDSYMBOLS:
			{
				PSEARCHDEBUGINFOANDRETURN psdir = (PSEARCHDEBUGINFOANDRETURN) lParam;

				ASSERT (psdir);
				
				psdir -> fSuccess = SYFindDebugInfoFile (psdir -> psdi);

				g_evFindSymbols.Unlock();
				return 0;
			}


		case WU_MESSAGEBOX:
			{
				MsgBoxTypes mboxType = (MsgBoxTypes)wParam;
				CString *pStr = (CString *)lParam ;

				ASSERT(mboxType < NUMBER_OF_MESSAGE_BOXES);
				LRESULT lResult = MsgBox(mboxType, (*pStr));

				delete pStr;
				return lResult;
			}

		case WU_REMOTEQUIT:
			ErrorBox(DBG_Remote_Quit);
			FakeAsyncKillDebuggee(TRUE);
			return 0;
					
		default:
		DefProcessing:
			return DefWindowProc(hwnd, message, wParam, lParam);
	}
	return 0;
}

// Stolen from the MDI child fram's WM_MDIACTIVATE handler
//
void OnViewActivate(CMultiEdit *pcme, BOOL bActivate)
{
	// Sushi: stolen from the MDI child frame's WM_MDIACTIVATE handler
	if ( bActivate )
	{
		if ( pcme->m_dt == DOC_WIN )
		{
			TraceInfo.StepMode = SRCSTEPPING;

			// Save pLastDocWin
			pLastDocWin = (CIDEDoc *)pcme->GetDocument();
		}
		else if ( pcme->m_dt == DISASSY_WIN) // && !fIsLaunchingDebuggee )
		{
			TraceInfo.StepMode = ASMSTEPPING;
		}
	}
}



// Helper for various Debug menu commands as well as
// Project.Execute...
// Returns whether active project (or JIT) along with whether the
// current target is unknown (ie. can't do anything with this target).

BOOL EnsureActiveProjectOrJIT(BOOL & fUnknownTarget)
{
	fUnknownTarget = FALSE;

	if (FIsActiveProjectDebuggable( &fUnknownTarget, NULL, NULL, NULL ))
		return TRUE;

	if (theApp.m_jit.GetActive())
		return TRUE;	// JIT debugging -> everything hunky-dorey

	if (MsgBox(Question, IDS_ACTIVE_PROJ_REQUIRED, MB_YESNO) == IDNO)
		return FALSE;	// User refused to create project

	LPSOURCEEDIT pISrcEdit = NULL;
	CString strActiveDocPath;
	
	ASSERT(NULL != gpISrcQuery); //we should have gotten this when the package loaded
	if (NULL == gpISrcQuery)
		return FALSE;

	if (SUCCEEDED(gpISrcQuery->CreateSourceEditForActiveDoc(&pISrcEdit, TRUE)))
	{
		pISrcEdit->GetPath(strActiveDocPath);
		// Force the source file to be saved if it's untitled:
		if (strActiveDocPath.IsEmpty())
		{
			if (!SUCCEEDED(pISrcEdit->CommitChanges()))
			{
				pISrcEdit->Release();
				return FALSE;	// Save failed or user cancelled Save As dlg
			}
			// Get new name
			pISrcEdit->GetPath(strActiveDocPath);
		}
		pISrcEdit->Release();
	}
	else
		return FALSE;

	if (strActiveDocPath.IsEmpty())
		return FALSE; // no file to base the new project upon

	if (gpIProjectWorkspace)
	{
		CDocument * pDocument;
		if (FAILED(gpIProjectWorkspace->CreateDefaultWorkspace(&pDocument, strActiveDocPath)))
		{
			return FALSE;	// Project creation failed for some reason
		}

		ASSERT(gpIBldSys != NULL && gpIBldSys->IsActiveBuilderValid() == S_OK);	// Better have one now!
	}
	else 
		return FALSE;
	return TRUE;
}

void PASCAL EnsureDebugWindow(int winType)
{
	HWND win = GetDebugWindowHandle(winType);

	if (win == NULL)
        CreateView(winType);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dbg.rc
//
#define IDC_DAMWND_GRP                  1008
#define IDC_GENERAL_GRP                 1009
#define IDC_CALLWND_GRP                 1010
#define IDC_VARWND_GRP                  1011
#define IDC_REGWND_GRP                  1012
#define IDC_MEMWND_GRP                  1013
#define IDC_DEBUG_ADDRESS_TXT           1014
#define IDC_DEBUG_FORMAT_TXT            1015
#define ID_BPCONTEXT_FUNC_TXT           1016
#define ID_BPCONTEXT_MODULE_TXT         1017
#define IDC_NO_PROMPT                   1021
#define IDC_PROMPT                      1022
#define IDS_HS_DEBUG_TYPELIB            10012
#define IDS_HS_DEBUGGER_EVENTS          10013
#define IDS_HS_DEBUGGER_EVENTS_BREAKPOINT_HIT 10014
#define IDS_HS_DEBUGGER                 10015
#define IDS_HS_DEBUGGER_APPLICATION     10016
#define IDS_HS_DEBUGGER_PARENT          10017
#define IDS_HS_DEBUGGER_BREAKPOINTS     10018
#define IDS_HS_DEBUGGER_DEFAULTRADIX    10019
#define IDS_HS_DEBUGGER_PROCESS_STATE   10020
#define IDS_HS_DEBUGGER_JIT             10021
#define IDS_HS_DEBUGGER_RPC             10022
#define IDS_HS_DEBUGGER_GO              10023
#define IDS_HS_DEBUGGER_STEP_INTO       10024
#define IDS_HS_DEBUGGER_STEP_OVER       10025
#define IDS_HS_DEBUGGER_STEP_OUT        10026
#define IDS_HS_DEBUGGER_RESTART         10027
#define IDS_HS_DEBUGGER_STOP            10028
#define IDS_HS_DEBUGGER_BREAK           10029
#define IDS_HS_DEBUGGER_EVALUATE        10030
#define IDS_HS_DEBUGGER_WAIT_FOR_BREAK  10031
#define IDS_HS_DEBUGGER_SHOW_NEXT_STATEMENT 10032
#define IDS_HS_DEBUGGER_RUN_TO_CURSOR   10033
#define IDS_HS_DEBUGGER_SET_NEXT_STATEMENT 10034
#define IDS_HS_BREAKPOINT               10035
#define IDS_HS_BREAKPOINT_APPLICATION   10036
#define IDS_HS_BREAKPOINT_PARENT        10037
#define IDS_HS_BREAKPOINT_ENABLED       10038
#define IDS_HS_BREAKPOINT_LOCATION      10039
#define IDS_HS_BREAKPOINT_FILE          10040
#define IDS_HS_BREAKPOINT_FUNCTION      10041
#define IDS_HS_BREAKPOINT_EXECUTABLE    10042
#define IDS_HS_BREAKPOINT_CONDITION     10043
#define IDS_HS_BREAKPOINT_ELEMENTS      10044
#define IDS_HS_BREAKPOINT_PASSCOUNT     10045
#define IDS_HS_BREAKPOINT_MESSAGE       10046
#define IDS_HS_BREAKPOINT_WINDOW_PROCEDURE 10047
#define IDS_HS_BREAKPOINT_TYPE          10048
#define IDS_HS_BREAKPOINT_REMOVE        10049
#define IDS_HS_BREAKPOINTS              10050
#define IDS_HS_BREAKPOINTS_COUNT        10051
#define IDS_HS_BREAKPOINTS_APPLICATION  10052
#define IDS_HS_BREAKPOINTS_PARENT       10053
#define IDS_HS_BREAKPOINTS_ITEM         10054
#define IDS_HS_BREAKPOINTS_REMOVE_ALL_BREAKPOINTS 10055
#define IDS_HS_BREAKPOINTS_REMOVE_BREAKPOINT_AT_LINE 10056
#define IDS_HS_BREAKPOINTS_ADD_BREAKPOINT_AT_LINE 10057
#define IDS_HS_DBG_DSLOCATION           10059
#define IDS_HS_DBG_DSLOCATIONWITHTRUEEXPRESSION 10060
#define IDS_HS_DBG_DSTRUEEXPRESSION     10061
#define IDS_HS_DBG_DSCHANGEDEXPRESSION  10062
#define IDS_HS_DBG_DSMESSAGE            10063
#define IDS_HS_DBG_EXECUTION_STATE      10064
#define IDS_HS_DBG_DSNODEBUGGEE         10065
#define IDS_HS_DBG_DSBREAK              10066
#define IDS_HS_DBG_DSRUNNING            10067
#define IDS_HS_DBG_BREAKPOINT_TYPES     10068
#define IDS_HS_DBG_DSLOCATIONWITHCHANGEDEXPRESSION 10069
#define IDS_HS_DSDEBUGGERNOTRUNNING     10070
#define IDS_HS_DSBREAKPOINTALREADYREMOVED 10071
#define IDS_HS_DSCANTEVALUATEEXPRESSION 10072
#define IDS_HS_DSCANTSETIPTOTHISLINE    10073
#define IDS_HS_DSDEBUGGEEISRUNNING      10074
#define IDCT_DBGPACKAGE                 24000
#define IDS_DUPE_DIR_SPEC               24000
#define DLG_THREAD_SUSPEND              24001
#define DLG_EXCEP_NUMBER_LABEL          24001
#define ID_QUICKW_ADD                   24001
#define ID_MESSAGES_CLASS               24001
#define ID_AMB_LIST                     24001
#define IDS_NOINTERFACE                 24001
#define DLG_THREAD_LIST                 24002
#define DLG_EXCEP_NUMBER                24002
#define ID_QUICKW_VALUE                 24002
#define ID_MESSAGES_LISTMESSAGE         24002
#define ID_AMB_SYM                      24002
#define DLG_THREAD_RESUME               24003
#define DLG_EXCEP_NAME_LABEL            24003
#define ID_MESSAGES_LISTCLASS           24003
#define ID_AMB_OK                       24003
#define DLG_THREAD_FOCUS                24004
#define DLG_EXCEP_NAME                  24004
#define ID_MESSAGES_SELECTION           24004
#define ID_AMB_CANCEL                   24004
#define DLG_THREAD_NAME                 24005
#define DLG_EXCEP_ACTION                24005
#define ID_QUICKW_MODIFY                24005
#define IDS_BAD_DIR_SPEC                24005
#define DLG_THREAD_ADDRESS              24006
#define DLG_EXCEP_DEFAULT               24006
#define ID_QUICKW_EXPRESSION            24006
#define IDS_DIR_NOT_EXIST               24006
#define DLG_THREAD_ID                   24007
#define DLG_EXCEP_ADD                   24007
#define ID_QUICKW_NEWEXPR               24007
#define ID_PRINTABORT_FILENAME          24008
#define ID_FIND_TAGALL                  24008
#define DLG_THREAD_STATE                24008
#define DLG_EXCEP_CHANGE                24008
#define ID_PRINTABORT_DEVICE            24009
#define DLG_THREAD_PRIORITY             24009
#define DLG_EXCEP_DELETE                24009
#define DLG_THREAD_LOCATION             24010
#define DLG_EXCEP_LIST                  24010
#define ID_TOOLARGS_ARGUMENTS           24010
#define DLG_EXCEP_1STCHANCE             24011
#define DLG_EXCEP_2NDCHANCE             24012
#define ID_PRINT_PRINTER                24020
#define ID_REPLACE_REPLACEWITH          24020
#define ID_TOOLARGS_REDIRECT            24020
#define ID_PRINT_ALL                    24021
#define ID_PRINT_SELECTION              24022
#define ID_REPLACE_REPLACEALL           24023
#define IDS_GOTOADDR_PROMPT             24025
#define IDS_GOTOADDR_WHAT               24026
#define IDS_GOTOADDR_HELP               24027
#define IDC_BARTEXT                     24038
#define IDS_BPMENU_LINE                 24040
#define IDS_BPMENU_ADVANCED             24041
#define IDS_BPCONTEXT_LOCATION          24042
#define IDS_BPCONTEXT_EXPRESSION        24043
#define IDS_BP_SET                      24044
#define IDS_BP_NOT_SET                  24045
#define IDC_READONLY                    24046
#define IDS_CPOP_TRACEFUNCTION          24046
#define IDS_EXPANSION_WARN              24047
#define IDC_BACKUP_NAME                 24048
#define IDC_OPEN_DOCUMENTS_LIST         24054
#define IDC_OPEN_DOCUMENTS_CLOSE        24059
#define IDC_BOOKMARK_LIST               24061
#define IDS_DRAG_MOVE                   24065
#define IDC_OPEN_DOCUMENTS_SAVE         24065
#define IDS_DRAG_COPY                   24066
#define IDC_BOOKMARK_NAME               24066
#define IDS_DRAG_CANCEL                 24067
#define IDC_OPEN_DOCUMENTS_PRINT        24069
#define IDC_GOTOADDR                    24081
#define ID_AMB_SRC                      24083
#define IDC_SYMBOLS                     24086
#define IDC_BOOKMARK_FILE               24087
#define IDC_DEBUG_SHOWFPU               24088
#define IDC_DEBUG_SHOWARGS              24090
#define IDC_DEBUG_SHOWTYPES             24091
#define ID_BPCONTEXT_FUNC               24092
#define IDC_DEBUG_ADDRESS               24094
#define IDC_DEBUG_FORMAT                24095
#define IDC_DEBUG_LIVE                  24096
#define IDC_DEBUG_RAW                   24097
#define IDC_DEBUG_WIDTH                 24098
#define IDC_DEBUG_ANNOTATE              24099
#define IDC_DEBUG_CODEBYTES             24100
#define IDC_DEBUG_NEWWINDOW             24102
#define IDC_DEBUG_OLERPC                24103
#define IDC_DEBUG_JIT                   24104
#define IDC_DEBUG_FIXEDWIDTH            24105
#define IDC_DEBUG_HEXMODE               24106
#define IDC_COMBO_FUNS                  24107
#define IDC_COMBO_DATA                  24108
#define IDC_QY_NAME                     24109
#define IDC_DEBUG_REMOTE                24119
#define IDC_DEBUG_CONFIG                24120
#define IDC_PLATFORM_LIST               24121
#define IDC_TRANSPORT_LIST              24122
#define IDC_SETUP                       24123
#define ID_REPLACE_REPLACE              24124
#define ID_QUICKW_TXT_VALUE             24126
#define ID_QUICKW_TXT_MEMBERS           24127
#define DLG_Cols_Disassembly            24132
#define IDC_LOCATION                    24134
#define IDC_MESSAGE                     24137
#define IDC_WNDPROC                     24138
#define IDC_BPTAB_MSG1                  24146
#define IDC_PLACEHOLDER                 24162
#define IDC_QW_GRID                     24163
#define IDC_REMOTE_FILE_TXT             24164
#define IDC_PROMPT_DLLS                 24165
#define DLG_EXCEP_LIST_BACKUP           24166
#define DLG_SYSTEM_EXCEP_LIST           24167
#define IDC_REMOTE_FILE_MAP_TXT         24168
#define IDC_REMOTE_MAP_LOCAL_NAME       24169
#define IDC_AUTOWIN                     24170
#define IDR_CPU_TYPE                    24176
#define IDS_KnownTargetOutOfdate        24176
#define IDR_MEMORY_TYPE                 24178
#define IDR_WATCH_TYPE                  24179
#define IDR_LOCALS_TYPE                 24180
#define ERR_No_Async_BPs                24180
#define IDS_FILTER_DLLS                 24190
#define IDS_FILTER_EXES                 24191
#define IDS_FIND_LOCAL_MODULE           24192
#define IDS_CouldNotExecuteProgram      24212
#define ERR_Pathname_Too_Long           24215
#define ERR_Save_MakeTempName           24218
#define ERR_Save_TempFileCreate         24221
#define ERR_Save_CreateBackupFile       24222
#define ERR_Save_RenameTempFile         24224
#define ERR_File_Not_Found              24228
#define ERR_File_Open                   24229
#define ERR_Bad_File_Spec               24251
#define ERR_Change_Directory            24258
#define ERR_Change_Drive                24259
#define ERR_Couldnt_Set_Breakpoint      24289
#define ERR_Breakpoint_Moved            24290
#define ERR_Close_When_Debugging        24291
#define ERR_Multiple_Breakpoints        24292
#define ERR_Multiple_BP_ENC             24293
#define ERR_File_Wrong_Platform         24296
#define ERR_Line_OutOfRange             24298
#define ERR_Cannot_Quit                 24299
#define ERR_Invalid_Exe                 24300
#define ERR_Corrupt_Omf                 24301
#define ERR_No_Debug_Info               24302
#define ERR_Must_Relink                 24303
#define ERR_Not_Packed                  24304
#define ERR_Future_Symbols              24305
#define ERR_SH_No_Memory                24306
#define ERR_No_Code_For_Line            24307
#define ERR_No_Exe_Build_It             24308
#define ERR_Memory_Is_Low               24310
#define ERR_Memory_Is_Low_2             24311
#define SYS_StatusClear                 24344
#define SYS_CpuWin_Title                24345
#define SYS_WatchWin_Title              24346
#define SYS_ThisWin_Title               24347
#define SYS_LocalsWin_Title             24348
#define SYS_AutoWin_Title               24349
#define SYS_MemoryWin_Title             24350
#define SYS_CallsWin_Title              24351
#define SYS_DisassyWin_Title            24352
#define SYS_ErrorsWin_Title             24353
#define SYS_BreakptWin_Title            24354
#define SYS_Nb_Of_Occurrences_Replaced  24356
#define SYS_Nb_Of_Occurrences_Found     24357
#define SYS_File_Changed                24358
#define SYS_Save_Changes_To             24363
#define SYS_My_String                   24364
#define SYS_File_Filter                 24365
#define SYS_Location_BP                 24374
#define IDS_UnsupportedBpType           24377
#define SYS_Proc_Term                   24378
#define IDS_UnsupportedBpTypes          24379
#define DBG_Windows_Fatal_Error         24381
#define DBG_Thread_Term                 24382
#define DBG_Pass_Exception              24384
#define DBG_Exception_Msg               24385
#define DBG_First_Chance                24386
#define DBG_Last_Chance                 24387
#define DBG_Cannot_Suspend_Thread       24389
#define DBG_Exception_ExeDll            24391
#define DBG_TL_Config_Err               24392
#define DBG_EM_Config_Err               24393
#define ERR_MACRO_NO_VIEW               24394
#define ERR_MACRO_NO_INSERT             24395
#define ERR_MACRO_NO_SWITCH             24396
#define DBG_Remote_Quit                 24397
#define SYS_VarsWin_Title               24398
#define DBG_Exception                   24399
#define IDS_WATCH1                      24400
#define IDS_WATCH2                      24401
#define IDS_WATCH3                      24402
#define IDS_WATCH4                      24403
#define IDS_COL_NAME                    24404
#define IDS_COL_VALUE                   24405
#define IDS_COL_TYPE                    24406
#define DLG_Cols_CpuWindow              24416
#define DLG_Cols_MemoryWindow           24417
#define DLG_Cols_VarsWindow             24418
#define DLG_Cols_CallsWindow            24419
#define DLG_Cols_DisassemblyWindow      24420
#define DLG_Cols_WatchWindow            24421
#define DLG_Cols_SourceWindow           24422
#define DLG_Cols_Selection              24423
#define DLG_Cols_Register               24424
#define DLG_Cols_Value                  24425
#define DLG_Cols_MemoryHighlight        24426
#define DLG_Cols_CpuWindowHighlight     24427
#define DLG_Cols_CallsHighlight         24428
#define DLG_Cols_CurrentLine            24429
#define DLG_Cols_BreakpointLine         24430
#define DLG_Cols_WatchHighlight         24433
#define DLG_Cols_VarsHighlight          24434
#define DLG_Cols_DebuggerWindows        24435
#define DLG_Cols_Code_Coverage          24436
#define DLG_Cols_Superceded             24437
#define DLG_Exception_Action_First      24451
#define DLG_Exception_1stChance         24451
#define DLG_Exception_2ndChance         24452
#define ERR_Unknown_Vars_Error          24456
#define STA_Undo                        24457
#define STA_Redo                        24458
#define STA_End_Of_Undo                 24459
#define STA_End_Of_Redo                 24460
#define DLG_MemOpt_Ascii                24469
#define DLG_MemOpt_First                24469
#define DLG_MemOpt_WideChar             24470
#define DLG_MemOpt_Byte                 24471
#define DLG_MemOpt_Short                24472
#define DLG_MemOpt_ShortHex             24473
#define DLG_MemOpt_UShort               24474
#define DLG_MemOpt_Long                 24475
#define DBG_Classes_Start               24476
#define DLG_MemOpt_HexLong              24476
#define DLG_MemOpt_ULong                24477
#define DLG_MemOpt_Real                 24478
#define DLG_MemOpt_RealLong             24479
#define DLG_MemOpt_Last                 24479
#define DLG_MemOpt_I64                  24480
#define DLG_MemOpt_HexI64               24481
#define DLG_MemOpt_UI64                 24482
#define DLG_MemOpt_Last_Ext             24482
#define DBG_Classes_End                 24483
#define STS_MESSAGE_OVERTYPE            24484
#define STS_MESSAGE_READONLY            24485
#define STS_MESSAGE_LINE                24488
#define STS_MESSAGE_COLUMN              24489
#define STS_MESSAGE_TID                 24490
#define STS_MESSAGE_COLSEL              24491
#define TBR_Mode_Run                    24492
#define TBR_Mode_Break                  24493
#define DBG_Brk                         24494
#define TBR_Mode_ENC                    24495
#define TBR_Mode_CrashDump              24496
#define DBG_Load_Symbols                24555
#define IDS_ASKPATH_GETPATH             24566
#define IDS_ASKPATH_CAPTION             24567
#define IDS_ASKPATH_CAPTION_SOURCE      24567
#define IDS_ASKPATH_CAPTION_SYMBOLS     24568
#define IDS_ASKPATH_CAPTION_OTHER       24569
#define ERR_No_TargetName               24577
#define IDS_DBG_RADIX_HEX               24586
#define IDS_DBG_RADIX_DECIMAL           24587
#define ERR_No_App_Debugging            24593
#define TXT_Win16_Type_App              24594
#define TXT_Dos_Type_App                24595
#define TXT_OS2_Type_App                24596
#define TXT_Other_Type_App              24597
#define SYS_Debug_Error                 24671
#define SYS_Cannot_Watch                24675
#define SYS_MSVCColSelect               24678
#define IDS_TargetOutOfdate             24692
#define ERR_Unknown                     24695
#define STA_StepOutNoSource             24728
#define STA_StepOutNoBPSet              24729
#define STA_StepOutNoCaller             24730
#define STA_StepCurNoCode               24731
#define STA_StepCurNoBPSet              24732
#define STA_StepCurNoMove               24733
#define DBG_CantKillChild               24739
#define IDA_VIEW_MIXEDMODE              24752
#define IDA_VIEW_NEXTERROR              24753
#define IDS_NO_SOURCE                   24753
#define IDA_VIEW_PREVIOUSERROR          24754
#define IDA_VIEW_TOGGLETAG              24755
#define IDA_VIEW_NEXTTAG                24756
#define IDA_VIEW_PREVIOUSTAG            24757
#define IDA_RUN_GO                      24768
#define IDA_RUN_RESTART                 24769
#define IDA_RUN_STOPDEBUGGING           24770
#define IDA_RUN_TOCURSOR                24771
#define IDA_RUN_TRACEINTO               24772
#define IDA_RUN_SRC_STEPOVER            24773
#define IDA_RUN_SRC_TRACEINTO           24774
#define IDA_RUN_STEPOVER                24775
#define IDA_RUN_STOPAFTERRETURN         24776
#define IDA_RUN_CALLS                   24777
#define IDS_OPENAS_TEXT                 24778
#define IDA_RUN_QUICKWATCH              24779
#define IDA_ZAPINT3                     24780
#define IDA_VIEWTABS                    24781
#define IDA_MAXIMIZE_MDI                24782
#define IDA_RESTORE_MDI                 24783
#define IDA_DEBUG_ASSEMBLY              24784
#define IDA_DEBUG_RADIX                 24785
#define IDA_DELWORD_BACK                24787
#define IDA_DUMP_UNDO                   24788
#define IDA_DUMP_REDO                   24789
#define IDA_COMPACT_DOC                 24790
#define IDA_TOOL_STOP                   24797
#define IDA_MEMORY_NEXTFORMAT           24798
#define IDA_MEMORY_PREVFORMAT           24799
#define IDA_WINDOWCHILD                 24800
#define IDM_CURSOR_SCREENLEFT           24802
#define IDM_CURSOR_SCREENRIGHT          24803
#define IDM_EXTENDSELECT_CHARLEFT       24804
#define IDM_EXTENDSELECT_CHARRIGHT      24805
#define IDM_EXTENDSELECT_FILEEND        24806
#define IDM_EXTENDSELECT_FILESTART      24807
#define IDM_EXTENDSELECT_LINEDOWN       24808
#define IDM_EXTENDSELECT_LINEEND        24809
#define IDM_EXTENDSELECT_LINESTART      24810
#define IDM_EXTENDSELECT_LINEUP         24811
#define IDM_EXTENDSELECT_SCREENDOWN     24812
#define IDM_EXTENDSELECT_SCREENUP       24813
#define IDM_EXTENDSELECT_WORDLEFT       24814
#define IDM_EXTENDSELECT_WORDRIGHT      24815
#define IDB_MAINTOOLS                   24826
#define IDB_MAINLARGETOOLS              24827
#define ERR_No_Exe_No_Options           24827
#define DOS_Err_0                       24875
#define IDA_RUN_TRACEFUNCTION           24876
#define IDA_RUN_SRC_TRACEFUNCTION       24877
#define ERR_FileNotFound                24877
#define ERR_PathNotFound                24878
#define ERR_BadExeFormat                24886
#define DBG_Msgs_Start                  24900
#define DBG_Msgs_End                    25080
#define IDS_DllsNotUnloaded             25172
#define IDD_AMBIG_SRCLINES              25176
#define IDDP_DEBUG                      25178
#define DBG_Exception_NoName            25179
#define IDM_TEXTVIEW_HELP               25180
#define IDC_SMALL_I                     25183
#define IDD_RESOLVEAMBIGUITY            25190
#define IDD_EXCEPTIONS                  25196
#define IDS_VARS_PROP_TITLE             25201
#define IDM_FILE_GOTO                   25210
#define ERR_CVMsg                       25217
#define IDD_QUICKWATCH                  25218
#define ERR_CVWarn                      25219
#define ERR_CVErr                       25221
#define IDD_THREADS                     25222
#define IDC_FIBERS_LIST                 25223
#define IDD_FIBERS                      25224
#define IDR_DISASSY_TYPE                25226
#define IDR_CALLS_TYPE                  25228
#define IDD_FIND_SRC                    25229
#define DBG_RUNNING                     25230
#define DBG_TERMINATED                  25231
#define DBG_NOT_STARTED                 25233
#define DBG_STOPPED                     25235
#define IDD_TRANSPORT_SELECT            25236
#define DBG_NOT_EXIST                   25237
#define IDD_MEMORYVIEW_DIALOGBAR        25239
#define IDS_PROJMENU_EXECUTE            25240
#define IDS_ACTIVE_PROJ_REQUIRED        25242
#define IDD_BPTAB_GENERAL               25243
#define IDD_BPTAB_MESSAGES              25245
#define IDS_CmdWillStopDebugger         25246
#define IDD_BPTAB_ADVANCED              25247
#define IDS_DEBUG                       25248
#define IDD_BPTAB_DATA                  25249
#define IDB_VARSEXPAND                  25256
#define IDS_GOTOEXPR                    25263
#define CVERR_CV_NOERROR                25265
#define CVERR_BADBKPTCMD                25266
#define IDS_CmdWillStopDebuggerRemoteRestart 25267
#define CVERR_NOTLVALUE                 25268
#define IDS_CAP_DEBUG                   25269
#define IDD_REMOTE_FILE_MAP             25270
#define CVERR_EACCES                    25271
#define CVERR_EFAULT                    25272
#define CVERR_EINVAL                    25273
#define CVERR_EIO                       25274
#define CVERR_EMFILE                    25275
#define CVERR_EXDEV                     25276
#define CVERR_ENOENT                    25277
#define CVERR_ENOEXEC                   25278
#define CVERR_ENOMEM                    25279
#define CVERR_E2BIG                     25280
#define CVERR_ENOSPC                    25281
#define CVERR_ESRCH                     25282
#define CVERR_MODLOADERROR              25283
#define CVERR_NOCODE                    25284
#define CVERR_NOSOURCEHERE              25285
#define CVERR_NOSYMBOLS                 25286
#define CVERR_FUTURESYMBOLS             25287
#define CVERR_NOTPACKED                 25288
#define CVERR_MUSTRELINK                25289
#define CVERR_SYNTAXERROR               25290
#define CVERR_NOROOM                    25291
#define CVERR_MODLOADED                 25292
#define CVERR_BADTYPECAST               25293
#define CVERR_NOWATCHFUNC               25294
#define CVERR_CLSTKCHGD                 25295
#define CVERR_NOADDRGIVEN               25296
#define CVERR_TOOMANYADDR               25297
#define CVERR_MODNOMATCH                25298
#define CVERR_EMMINSUFMEM               25299
#define CVERR_CATASTROPHICTM            25300
#define CVERR_EXPRERROR                 25301
#define CVERR_BADADDR                   25302
#define CVERR_NODATAMEMBERS             25303
#define CVERR_UNKNOWNERROR              25304
#define IDS_SOURCE_DIFFERS              25305
#define CVERR_EXPORTSCONVERTED          25308
#define CVERR_SYMSCONVERTED             25309
#define CVERR_PDBNOTFOUND               25310
#define CVERR_PDBBADSIGNATURE           25311
#define CVERR_PDBINVALIDAGE             25312
#define CVERR_PDBOLDFORMAT              25313
#define DBG_No_Callers_Avail            25314
#define ERR_Pdb_Not_Found               25315
#define ERR_Pdb_Bad_Signature           25316
#define ERR_Pdb_Invalid_Age             25317
#define ERR_Pdb_Old_Format              25318
#define ERR_App_Exe_Mismatch_Update     25325
#define ERR_Remote_No_MSCV              25327
#define IDD_VARSVIEW_DIALOGBAR          25330
#define IDD_BPTAB_DATA1                 25332
#define IDD_BPTAB_LOCATION              25333
#define ERR_Proj_Target_Mismatch        25337
#define IDD_BP_DLG_CONTEXT              25337
#define ERR_App_Exe_Mismatch            25338
#define IDD_BP_DLG_CONDITION            25338
#define ERR_Exe_Open                    25340
#define ERR_Remote_Debuggee_Missing     25342
#define IDD_ASSERT_FAILED               25342
#define ERR_Remote_Debuggee_Running     25344
#define ERR_Remote_Exe_Invalid          25345
#define ERR_RemoteExe_Cannot_Open       25346
#define ERR_Debugger_Init               25349
#define ERR_Tool_Path_Invalid           25361
#define ERR_No_Disk_Image               25364
#define IDS_WillMoveToNewProc           25365
#define IDS_CantMoveToNewProc           25366
#define IDS_PDB_NOT_FOUND               25367
#define IDS_PROCESS                     25368
#define IDS_PROCESSID                   25369
#define IDS_TITLE                       25370
#define IDS_MODULENAME                  25371
#define IDS_ADDRESS                     25372
#define IDS_FULLPATH                    25373
#define IDS_MODULEORDER                 25374
#define DBG_Connecting                  25379
#define ERR_Const_Address_Breakpoint    25380
#define IDS_NO_PROFILE                  25381
#define IDS_HARDCODEDBP                 25382
#define IDS_SAVE_UNNAMED_FILE           25387
#define ERR_BADOSDEBUGDLL               25390
#define BPFMT_LOCATION                  25391
#define BPFMT_WHENCHANGES               25392
#define BPFMT_WHENTRUE                  25393
#define BPFMT_ONMESSAGE                 25394
#define BPFMT_PASSCOUNT                 25395
#define BPFMT_PASSCOUNTREMAIN           25396
#define IDS_BPTAB_GENERAL               25397
#define IDS_BPTAB_MESSAGES              25398
#define IDS_BPTAB_ADVANCED              25399
#define IDS_BPDLG                       25400
#define IDS_BPLABEL                     25401
#define IDS_BP_GOTOCODE                 25402
#define IDS_BP_REMOVE                   25403
#define IDS_BP_REMOVE_ALL               25404
#define IDS_BPTAB_DATA                  25405
#define IDS_BP_INVALID_LOCATION         25409
#define IDS_BP_INVALID_WNDPROC          25410
#define IDS_BP_INVALID_EXPRESSION       25411
#define IDS_BP_INVALID_LENGTH           25412
#define IDS_BP_INVALID_MESSAGE          25413
#define IDS_BP_INVALID_HITCOUNT         25414
#define IDS_BP_INVALID_CAPTION          25415
#define IDS_JAVA_BPCXT_CLASS            25416
#define ID_BROWSE                       25422
#define IDC_CONNECT_NOW                 25445
#define IDC_CONNECT_NOW_TEXT            25446
#define IDC_DEBUG_RETURN_VALUES         25447
#define ID_BPCOND_EXPR                  25449
#define ID_BPCOND_SKIPCOUNT             25450
#define IDC_BP_BTN_COND                 25452
#define ID_BP_BTN_CONTEXT               25453
#define IDC_BP_EXPRESSION               25453
#define ID_BPCONTEXT_SOURCE             25455
#define ID_BPCONTEXT_MODULE             25456
#define IDC_LOC_MENU                    25457
#define IDC_EXPR_MENU                   25457
#define IDC_BP_NUM_ELEMENTS             25460
#define IDC_BP_HELPTXT                  25461
#define IDC_ASSERT_TEXT                 25462
#define IDC_BP_WHERE                    25464
#define IDS_BPTAB_LOCATION              25465
#define IDC_BP_TXT_WHERE                25465
#define IDS_BPTAB_DATA1                 25466
#define IDC_HELPTEXT1                   25466
#define IDC_HELPTEXT2                   25467
#define IDC_BP_TXT_NUM_ELEMENTS         25468
#define ID_BPCOND_TXT_SKIPCOUNT         25469
#define IDS_SOUND_DEBUG_HITBP           25473
#define IDS_SOUND_DEBUG_HITBP2          25474
#define IDC_VAR_EXPR                    25485
#define IDC_VAR_VALUE                   25486
#define IDC_GRP_ADDITIONAL              25486
#define IDC_VAR_TYPE                    25487
#define IDDP_VARS_GEN                   25488
#define IDC_SETTINGS_TEXT               25489
#define ID_BUTTON25490                  25490
#define ID_BUTTON25491                  25491
#define IDC_BP_BREAK_WHEN_TRUE          25491
#define ID_BUTTON25492                  25492
#define IDC_BP_BREAK_WHEN_CHANGES       25492
#define ID_BUTTON25493                  25493
#define ID_BUTTON25494                  25494
#define ID_BUTTON25495                  25495
#define ID_BUTTON25496                  25496
#define ID_BUTTON25497                  25497
#define ID_BUTTON25498                  25498
#define ID_BUTTON25499                  25499
#define ID_BUTTON25500                  25500
#define ID_BUTTON25501                  25501
#define ID_BUTTON25502                  25502
#define ID_BUTTON25503                  25503
#define ID_BUTTON25504                  25504
#define ID_BUTTON25505                  25505
#define ID_BUTTON25506                  25506
#define ID_BUTTON25507                  25507
#define ID_BUTTON25508                  25508
#define ID_BUTTON25509                  25509
#define ID_BUTTON25510                  25510
#define ID_BUTTON25511                  25511
#define ID_BUTTON25512                  25512
#define ID_BUTTON25513                  25513
#define ID_BUTTON25514                  25514
#define ID_BUTTON25515                  25515
#define ID_BUTTON25516                  25516
#define ID_BUTTON25517                  25517
#define ID_BUTTON25518                  25518
#define ID_BUTTON25519                  25519
#define ID_BUTTON25520                  25520
#define ID_BUTTON25521                  25521
#define ID_BUTTON25522                  25522
#define ID_BUTTON25523                  25523
#define ID_BUTTON25524                  25524
#define ID_BUTTON25525                  25525
#define ID_BUTTON25526                  25526
#define ID_BUTTON25527                  25527
#define ID_BUTTON25528                  25528
#define ID_BUTTON25529                  25529
#define ID_BUTTON25530                  25530
#define ID_BUTTON25531                  25531
#define ID_BUTTON25532                  25532
#define ID_BUTTON25533                  25533
#define ID_BUTTON25534                  25534
#define ID_BUTTON25535                  25535
#define ID_BUTTON25536                  25536
#define ID_BUTTON25537                  25537
#define ID_BUTTON25538                  25538
#define ID_BUTTON25539                  25539
#define ID_BUTTON25540                  25540
#define ID_BUTTON25554                  25554
#define ID_BUTTON25555                  25555
#define ID_BUTTON25556                  25556
#define ID_BUTTON25560                  25560
#define ID_BUTTON25561                  25561
#define IDR_DEFAULT_GLOBAL              25561
#define IDR_GLOBAL_DEBUGGER_KEYS        25565
#define IDS_DISABLE_BREAKPOINT          25576
#define IDS_REMOVE_BREAKPOINT           25577
#define IDS_RETURNED                    25579
#define IDS_ERR_DBG_PKG_RELEASED        25580
#define IDD_ATTACH_TO_ACTIVE            25581
#define IDC_PROCESS_LIST                25582
#define IDS_ERR_BP_REMOVED              25583
#define IDC_DEBUG_UNICODE_STRINGS       25584
#define IDD_NO_SYMBOL_INFO              25585
#define IDC_DEBUG_EC                    25585
#define IDS_ERR_DBG_CANT_EVAL           25586
#define IDS_ERR_DBG_SET_IP              25587
#define IDC_SYSTEM_PROCESSES            25588
#define IDS_ERR_DBG_RUNNING             25589
#define IDS_ERR_BADREGISTRY             25590
#define IDC_DEBUG_LOADEXPORTS           25590
#define IDS_ERR_SQLNOTLOCAL             25591
#define IDC_FRAME_LIST                  25591
#define IDC_ReasonTitle                 25592
#define IDC_ReasonText                  25593
#define IDC_TMPBP                       25594
#define IDC_MODULE_LIST                 25596
#define IDS_CANNOTBREAK                 25612
#define STA_Recompiling                 25617
#define STA_EncFailed                   25618
#define IDS_EncCannotWalkStack          25621
#define IDS_EncEditMoveIp               25624
#define IDS_EncOutPrefix                25626
#define IDS_EncOutFrameFailed           25629
#define IDS_Err_FrameFailed             25629
#define IDS_Enc_Err_FrameFailed         25629
#define IDS_EncOutStackWalk             25630
#define IDS_Err_StackWalk               25630
#define IDS_Enc_Err_StackWalk           25630
#define IDS_EncOutCancel                25632
#define IDS_EncOutTosEdited             25633
#define IDS_Err_TosEdited               25633
#define IDS_Enc_Err_TosEdited           25633
#define IDS_EncOutFrameEdited           25634
#define IDS_Err_FrameEdited             25634
#define IDS_Enc_Err_FrameEdited         25634
#define IDS_EncAutoBpHit                25636
#define IDS_EncTmpBpHit                 25636
#define IDS_Enc_EXCEPTIONSTATE          25637
#define IDS_Enc_E_EXCEPTIONSTATE        25637
#define IDS_Enc_LOCALVARCHANGE          25638
#define IDS_Enc_E_LOCALVARCHANGE        25638
#define IDS_Enc_FUNCBYTEMATCH           25639
#define IDS_Enc_E_FUNCBYTEMATCH         25639
#define IDS_Enc_FUNCSIGCHANGE           25640
#define IDS_Enc_E_FUNCSIGCHANGE         25640
#define IDS_Enc_FRAMESIZECHANGE         25641
#define IDS_Enc_E_FRAMESIZECHANGE       25641
#define IDS_Enc_LOCALREQCONDES          25642
#define IDS_Enc_E_LOCALREQCONDES        25642
#define IDS_Enc_UNSAFEFRAMECOND         25643
#define IDS_Enc_E_UNSAFEFRAMECOND       25643
#define IDS_Enc_CANTFINDLINE            25644
#define IDS_Enc_E_CANTFINDLINE          25644
#define IDS_Enc_DUPLICATEVAR            25645
#define IDS_Enc_E_DUPLICATEVAR          25645
#define IDS_Enc_INTERNALERROR           25646
#define IDS_Enc_E_IPNOTINEDIT           25646
#define IDS_EncTmpBpHitOK               25647
#define IDS_Enc_SPNOTCANONICAL          25648
#define IDS_Enc_E_SPNOTCANONICAL        25648
#define IDS_Enc_Relinking               25651
#define IDS_Enc_CantCreateFile          25652
#define IDS_Err_CantCreateFile          25652
#define IDS_Enc_Err_CantCreateFile      25652
#define IDS_Enc_ExePath                 25653
#define IDS_Err_ExePath                 25653
#define IDS_Enc_Err_ExePath             25653
#define IDS_Enc_RecompilingFile         25654
#define IDS_Enc_RelinkingFile           25655
#define IDS_Enc_CompiledFiles           25656
#define IDS_Enc_StopBuildMenu           25657
#define IDS_Enc_UpdateImageMenu         25658
#define IDS_Enc_FileIsReadOnly          25659
#define IDS_Enc_CmdNotExecuted          25660
#define IDS_Err_CmdNotExecuted          25660
#define IDS_Enc_Err_CmdNotExecuted      25660
#define IDS_Enc_Thread                  25661
#define IDS_Enc_Call                    25662
#define IDS_Enc_Function                25663
#define IDD_STACK_EDIT                  25664
#define IDS_Enc_CompileError            25664
#define IDS_Enc_UnsupportedEdit         25665
#define IDD_MODULELIST                  25665
#define IDS_Enc_CannotComplete          25666
#define IDS_Enc_LinkedFromLib           25667
#define IDS_Err_LinkedFromLib           25667
#define IDS_Enc_Err_LinkedFromLib       25667
#define IDS_Enc_CantFindObj             25668
#define IDS_Err_CantFindObj             25668
#define IDS_Enc_Err_CantFindObj         25668
#define IDS_Enc_ObjMismatch             25669
#define IDS_Err_ObjMismatch             25669
#define IDS_Enc_Err_ObjMismatch         25669
#define IDS_Enc_IgnoringFile            25670
#define IDS_Err_IgnoringFile            25670
#define IDS_Enc_Err_IgnoringFile        25670
#define IDS_Enc_DetectedNoChanges       25671
#define IDS_Enc_AppliedCodeChanges      25672
#define IDS_Enc_HandleCompileError      25674
#define IDS_EncMsgMoveIp                25675
#define IDS_Enc_SourceChanged           25676
#define IDS_Enc_REGISTERSPILL           25677
#define IDS_Enc_E_REGISTERSPILL         25677
#define IDS_Enc_ErrorCode               25678
#define IDS_Enc_WarningCode             25679
#define IDS_Enc_InfoCode                25680
#define IDS_Enc_Error                   25681
#define IDS_Enc_Warning                 25682
#define IDS_Enc_ErrorSummary            25683
#define IDS_Err_UnsupportedEdit         25684
#define IDS_Enc_Err_UnsupportedEdit     25684
#define IDS_Enc_ApplyingChanges         25685
#define IDS_Err_CantUpdateFrame         25686
#define IDS_Enc_Err_CantUpdateFrame     25686
#define IDS_Err_CantInitialize          25687
#define IDS_Enc_Err_CantInitialize      25687
#define IDS_Err_ReadOnly                25688
#define IDS_Enc_Err_ReadOnly            25688
#define IDS_Enc_LoadingIdb              25689
#define IDS_Enc_CantReloadImage         25690
#define IDS_Enc_Err_TooManyFiles        25691

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         25597
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\qcini.cpp ===
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

const DWORD DEBUG_INI_VERSION = 0x00000001;

typedef enum INITYPE			// The type of an INI file variable
{
	IT_UINT,
	IT_BOOL,
	IT_LONG,
	IT_BYTE
} INITYPE;

typedef struct INIVAL			// Describes a value that goes in the INI file
{
	INITYPE		it;				// The value's type
	union {
		void * pv;				// Where the value is kept in memory
		UINT * pu;
		BOOL * pbool;
		BYTE * pb;
		long * pl;
	};
	LPCTSTR		szKey;			// Name of the value
} INIVAL;

inline static void LoadIniValue(LPCTSTR szSection, const INIVAL *piv)
{
	switch (piv->it)
	{
	case IT_UINT:
		*piv->pu = GetRegInt(szSection, piv->szKey, *piv->pu);
		break;

	case IT_BOOL:
		*piv->pbool = GetRegInt(szSection, piv->szKey, *piv->pbool);
		break;

	case IT_LONG:
		*piv->pl = (long)GetRegInt(szSection, piv->szKey, *piv->pl);
		break;

	case IT_BYTE:
		*piv->pb = (BYTE)GetRegInt(szSection, piv->szKey, *piv->pb);
		break;
								  
	default:
		ASSERT(FALSE);
		break;
	}
}

inline static void SaveIniValue(LPCTSTR szSection, const INIVAL *piv)
{
	switch (piv->it)
	{
	case IT_UINT:
		// It's okay for us to write this as an int rather than uint
		WriteRegInt(szSection, piv->szKey, (int)*piv->pu);
		break;

	case IT_BOOL:
		WriteRegInt(szSection, piv->szKey, (int)*piv->pbool);
		break;

	case IT_LONG:
		WriteRegInt(szSection, piv->szKey, *piv->pl);
		break;

	case IT_BYTE:
		WriteRegInt(szSection, piv->szKey, *piv->pb);
		break;

	default:
		ASSERT(FALSE);
		break;
	}
}

static LPCTSTR cszGeneral               = _T("General");
static LPCTSTR cszDebug                 = _T("Debug");
static LPCTSTR cszVersion               = _T("Version");
static LPCTSTR cszRunDebugMode          = _T("DebugMode");
static LPCTSTR cszExtendedRegisters     = _T("ExtendedRegisters");
static LPCTSTR cszOleRpc                = _T("OleRpcDebugging");
static LPCTSTR cszReturnValues          = _T("ShowReturnValues");
static LPCTSTR cszDataTips              = _T("ShowDataTips");
static LPCTSTR cszWatchExt              = _T("AutoWindow");
static LPCTSTR cszDecimalRadix          = _T("Radix");
static LPCTSTR cszFiberDebugging		= _T("FiberDebugging");
static LPCTSTR cszCallParams            = _T("CallParameters");
static LPCTSTR cszCallTypes             = _T("CallTypes");
static LPCTSTR cszDAMAnnotate           = _T("DisassemblyAnnotations");
static LPCTSTR cszDAMCodeBytes          = _T("DisassemblyCodeBytes");
static LPCTSTR cszDAMLowerCase          = _T("DisassemblyLowerCase");
static LPCTSTR cszDAMSymbols            = _T("DisassemblySymbols");
static LPCTSTR cszCPURegs               = _T("CPURegisters");
static LPCTSTR cszCPUFlags              = _T("CPUFlags");
static LPCTSTR cszCPUEA                 = _T("CPUEffectiveAddress");
static LPCTSTR cszCPUFloat              = _T("CPUFloatingPoint");
static LPCTSTR cszLocalsToolbar         = _T("LocalsToolbar");
static LPCTSTR cszWatchToolbar          = _T("WatchToolbar");
static LPCTSTR cszMemoryToolbar         = _T("MemoryToolbar");
static LPCTSTR cszVarsToolbar           = _T("VariablesToolbar");
static LPCTSTR cszWatchNameColWidth     = _T("WatchColWidth");
static LPCTSTR cszVarsNameColWidth      = _T("VariablesColWidth");
static LPCTSTR cszQWNameColWidth        = _T("QuickWatchColWidth");
static LPCTSTR cszDebugCommandLine      = _T("DebugCommandLine");
static LPCTSTR cszUnicodeStrings		= _T("UnicodeStrings");
static LPCTSTR cszENCDebugging   		= _T("EditAndContinueDebugging");
static LPCTSTR cszLoadExports			= _T("LoadExports");
static LPCTSTR cszENCRelink		   		= _T("ENCRelink");
static LPCTSTR cszENCTraceLevel   		= _T("ENCTraceLevel");
static LPCTSTR cszENCRepro		   		= _T("ENCRepro");
static LPCTSTR cszENCLoadIdb			= _T("ENCLoadIdbFiles");

//static LPCTSTR csz		= _T("");

static const INIVAL rgivDebug[] =	// Table of debug options (runDebugParams vars)
{
	IT_BYTE,    &runDebugParams.debugMode,              cszRunDebugMode,
	IT_BOOL,    &runDebugParams.extendedRegisters,      cszExtendedRegisters,
	IT_BOOL,    &runDebugParams.fOleRpc,                cszOleRpc,
	IT_BOOL,    &runDebugParams.fReturnValues,          cszReturnValues,
	IT_BOOL,    &runDebugParams.fDataTips,              cszDataTips,
	IT_BOOL,    &runDebugParams.fWatchExt,              cszWatchExt,
	IT_BOOL,    &runDebugParams.decimalRadix,           cszDecimalRadix,
//	IT_BOOL,	&runDebugParams.fFiberDebugging,		cszFiberDebugging,
	IT_BOOL,    &runDebugParams.fCallParams,            cszCallParams,
	IT_BOOL,    &runDebugParams.fCallTypes,             cszCallTypes,
	IT_BOOL,    &runDebugParams.fDAMAnnotate,           cszDAMAnnotate,
	IT_BOOL,    &runDebugParams.fDAMCodeBytes,          cszDAMCodeBytes,
	IT_BOOL,    &runDebugParams.fDAMLowerCase,          cszDAMLowerCase,
	IT_BOOL,    &runDebugParams.fDAMSymbols,            cszDAMSymbols,
	IT_BOOL,    &runDebugParams.fCPURegs,               cszCPURegs,
	IT_BOOL,    &runDebugParams.fCPUFlags,              cszCPUFlags,
	IT_BOOL,    &runDebugParams.fCPUEA,                 cszCPUEA,
	IT_BOOL,    &runDebugParams.fCPUFloat,              cszCPUFloat,
	IT_BOOL,    &runDebugParams.fLocalsToolbar,         cszLocalsToolbar,
	IT_BOOL,    &runDebugParams.fWatchToolbar,          cszWatchToolbar,
	IT_BOOL,    &runDebugParams.fMemoryToolbar,         cszMemoryToolbar,
	IT_UINT,    &runDebugParams.iWatchNameColWidth,     cszWatchNameColWidth,
	IT_UINT,    &runDebugParams.iVarsNameColWidth,      cszVarsNameColWidth,
	IT_UINT,    &runDebugParams.iQWNameColWidth,        cszQWNameColWidth,
	IT_BOOL,    &runDebugParams.fVarsToolbar,           cszVarsToolbar,
	IT_BOOL,	&runDebugParams.fUnicodeStrings,		cszUnicodeStrings,
	IT_BOOL,	&runDebugParams.fENCDebugging,   		cszENCDebugging,
	IT_BOOL,	&runDebugParams.fLoadExports,			cszLoadExports,
	IT_BOOL,	&runDebugParams.fENCRelink,				cszENCRelink,
	IT_UINT,	&runDebugParams.iENCTraceLevel,			cszENCTraceLevel,
	IT_BOOL,	&runDebugParams.fENCRepro,				cszENCRepro,
	IT_BOOL,	&runDebugParams.fENCLoadIdb,			cszENCLoadIdb,
	(INITYPE)0, NULL,                                   0
};

static void ClearKey()
{
	CString str(GetRegistryKeyName());
	str += chKeySep;
	str += cszDebug;
	RegDeleteKey(HKEY_CURRENT_USER, str);
}

/****************************************************************************

	FUNCTION:	GetIniString

	RETURNS:	TRUE if the string was read successfully, FALSE if string empty.

****************************************************************************/

static BOOL GetIniString(LPCTSTR szSectionName, LPCTSTR szKeyName, LPCTSTR szDefault, LPTSTR sz, UINT cb)
{
	static CString str;
	str = GetRegString( szSectionName,szKeyName,szDefault);
	if (!str.IsEmpty())
	{
		_tcsncpy(sz, str, cb);
		return TRUE;
	}
	return FALSE;
}

/****************************************************************************

	FUNCTION:	IniExist

****************************************************************************/

static BOOL IniExist()
{
	HKEY hkeyMain;
	BOOL bRet = (0 == RegOpenKey(HKEY_CURRENT_USER, GetRegistryKeyName(), &hkeyMain));
	RegCloseKey(hkeyMain);
	return bRet;
}

void CDebugPackage::SaveSettings()
{
	WriteRegInt(cszDebug, cszVersion, DEBUG_INI_VERSION);
	for (int iLoop=0; rgivDebug[iLoop].pv; ++iLoop)
		SaveIniValue(cszDebug, &rgivDebug[iLoop]);

	WriteRegString(cszDebug, cszDebugCommandLine, runDebugParams.commandLine);

}


/****************************************************************************

	FUNCTION:	HammerOleRegKey
	Purpose:	The user might enable OLE debugging in one IDE and then step
				into a new IDE where OLE debugging will still be disabled
				because the changes are not comitted to the registry till
				we exit the IDE. So we have special function to force the
				registry update for this key.
	Note:		runDebugParams must be updated prior to calling this function.
******************************************************************************/
void HammerOleRegKey()
{
	
	for ( int i = 0; i < (sizeof(rgivDebug)/sizeof(rgivDebug[0])) ; i++ )
	{
		if ( rgivDebug[i].szKey == cszOleRpc )
		{
			SaveIniValue(cszDebug, &rgivDebug[i]);
		 	return;
		}
	}
	// We should find the OLE key in the debugger ini table.
	ASSERT(0);
}

void HammerLoadExportsRegKey()
{
	for ( int i = 0; i < (sizeof(rgivDebug)/sizeof(rgivDebug[0])) ; i++ )
	{
		if ( rgivDebug[i].szKey == cszLoadExports )
		{
			SaveIniValue(cszDebug, &rgivDebug[i]);
		 	return;
		}
	}
	// We should find the LoadExports key in the debugger ini table.
	ASSERT(0);
}

/****************************************************************************

	FUNCTION:	LoadIniFile

	INPUT:
		cchLastProject = length of buffer pointed to by szLastProject

	OUTPUT:
		szLastProject filled in with last project name.  May be NULL.

****************************************************************************/
void LoadIniFile()
{
	if (!IniExist() || theApp.m_bFirstInstance)
	{
		InitDefaults();
		return;
	}
	if (GetRegInt(cszDebug, cszVersion, 0) != DEBUG_INI_VERSION ||
		!GetRegString( cszGeneral, cszVersion ).IsEmpty() )
	{
		ClearKey();
		InitDefaults();
		return;
	}
	for (int i = 0; rgivDebug[i].pv; ++i)
		LoadIniValue(cszDebug, &rgivDebug[i]);
// Code below turns on fibers iff an unpublished key is set
	CString str(GetRegistryKeyName());
	str += chKeySep;
	str += cszDebug;
	HKEY hKeyNames;
	DWORD rc = RegOpenKeyEx(HKEY_CURRENT_USER,(LPCTSTR)str,0,KEY_ALL_ACCESS,&hKeyNames);
	if(rc == ERROR_SUCCESS){
		DWORD dwTypeBuf;
		BYTE bValBuf[4];
		DWORD cbValBuf = sizeof(bValBuf);
		RegQueryValueEx(hKeyNames,_T("FiberDebugging"),NULL,&dwTypeBuf,bValBuf,&cbValBuf);
		if(*((DWORD *)bValBuf)){
			runDebugParams.fFiberDebugging = TRUE;
		}
		RegCloseKey(hKeyNames);
	}
	GetIniString(cszDebug, cszDebugCommandLine, 0, runDebugParams.commandLine, sizeof(runDebugParams.commandLine));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\rundebug.cpp ===
#include "stdafx.h"
#pragma hdrstop
#define _XBDM_
#define XbeGetLocalModulePathA HrXbeGetLocalModulePath
#include <xboxdbg.h>

#define MAX_ATOM_LEN	1024

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// DLLGridInfoList contains a list of pointers to GRIDINFOs
//	(one for each build target)
// Each GRIDINFO contains an HTARGET and a list of pointers to DLLRECs
//	(one for each grid entry)
CPtrList DLLGridInfoList;


/****************************************************************************

	FUNCTION:	DLLRecListFromTarget()

	PURPOSE:	Find the list of DLLRec's associated with a given target.

	INPUT:		The given target.

	OUTPUT:		A pointer to the CPtrList containing the targets DLLRec's.

****************************************************************************/
static CPtrList *DLLRecListFromTarget(HTARGET hTarget)
{
	POSITION posGridList;
	GRIDINFO *pGridInfo;

	posGridList = DLLGridInfoList.GetHeadPosition();

	// For every build target...
	while (posGridList != NULL)
	{
		pGridInfo = (GRIDINFO *)DLLGridInfoList.GetNext(posGridList);

		// ...look for a matching hTarget
		if (pGridInfo->hTarget == hTarget)
		{
			return &pGridInfo->DLLRecList;
		}
	}

	// For some reason, we didn't know about this target, so create it
	// (probably a corrupt or missing vcp file)
	pGridInfo = new GRIDINFO;
	pGridInfo->hTarget = hTarget;
	DLLGridInfoList.AddTail(pGridInfo);
	return &pGridInfo->DLLRecList;
}


/****************************************************************************

	FUNCTION:	BuildLocalDLLsStringList

	PURPOSE:	Build a CString of the local DLLs from DLLGridInfoList.

	INPUT:		fPreloadOnly - if TRUE we only put the DLLs marked as preload
				into the string.

	OUTPUT:		String containing the list of local DLLs, separated by spaces

****************************************************************************/
void BuildLocalDLLsStringList(CStringList& slLocalDLLs, BOOL fPreloadOnly)
{
	DLLREC *pDLLRec;
	CPtrList *pDLLRecList;
	POSITION posDLLRecList;
	HBLDTARGET hTarget;

	ASSERT(gpIBldSys);

	gpIBldSys->GetActiveTarget(ACTIVE_BUILDER, &hTarget);
	pDLLRecList = DLLRecListFromTarget((HTARGET)hTarget);
	posDLLRecList = pDLLRecList->GetHeadPosition();

	slLocalDLLs.RemoveAll();
	while (posDLLRecList != NULL)
    {
		pDLLRec = (DLLREC *)pDLLRecList->GetNext(posDLLRecList);

		// If we are debugging, there may be deleted DLLs still around
		if (pDLLRec->fDelete)
			continue;

		// Filter non-preload DLLs if so requested
		if ( !pDLLRec->strLocalName.IsEmpty() && ( !fPreloadOnly || pDLLRec->fPreload ) ) {
			slLocalDLLs.AddTail(pDLLRec->strLocalName);
		}
	}
}


BOOL FCreateDLLMappingsKey(CString strMapKeyName, UINT nCurrentPlatform)
{
	typedef struct {
		PCHAR szRemote;
		PCHAR szLocal;
	} DLLMAP;

	static const DLLMAP rgMacPPCMaps[] =
	{
		// Mapped MS DLLs
		{"MicrosoftMFC40Lib",					"mfc40p.dll"},
		{"MicrosoftMFC40DLib",					"mfc40pd.dll"},

		{"MicrosoftMFC42Lib",					"mfc42p.dll"},
		{"MicrosoftMFC42DLib",					"mfc42pd.dll"},

		{"MicrosoftMFCD40Lib",					"mfcd40p.dll"},
		{"MicrosoftMFCD40DLib",					"mfcd40pd.dll"},

		{"MicrosoftMFCD42Lib",					"mfcd42p.dll"},
		{"MicrosoftMFCD42DLib",					"mfcd42pd.dll"},

		{"MicrosoftMFCO40Lib",					"mfco40p.dll"},
		{"MicrosoftMFCO40DLib",					"mfco40pd.dll"},

		{"MicrosoftMFCO42Lib",					"mfco42p.dll"},
		{"MicrosoftMFCO42DLib",					"mfco42pd.dll"},

		{"MicrosoftCRT4.0Library",				"msvcrt40.dll"},
		{"DebugCRT4.0Library",					"msvcr40d.dll"},

		// Unmapped MS DLLs
		{"MicrosoftControlsLib",				""},
		{"DebugMicrosoftControlsLib",			""},

		{"MicrosoftOLEPortabilityLib",			""},
		{"DebugMicrosoftOLEPortabilityLib",		""},

		{"MicrosoftOLEUIPortabilityLib",		""},
		{"DebugMicrosoftOLEUIPortabilityLib",	""},

		{"Microsoft_OLE2",						""},
		{"MicrosoftOLE2AutomationLib",			""},

		{"MicrosoftPortabilityLib",				""},
		{"DebugMicrosoftPortabilityLib",		""},

		{"MicrosoftRichEditLib",				""},
		{"DebugMicrosoftRichEditLib",			""},

		// ODBC fragments
		{"vsi:ODBC$ConfigMgr",					""},
		{"vsi:ODBC$CursorLibrary",				""},
		{"vsi:ODBC$DriverMgr",					""},
		{"vsi:ODBC$NetLibADSP",					""},
		{"vsi:ODBC$NetLibTCPIP",				""},
		{"vsi:ODBC$SQLServer",					""},

		// New system DLLs not filtered by DM
		// Keep these alphabetical so individual items remain easy to find
		// as more and more are added.
		{"AOCELib",								""},
		{"ColorPickerLib",						""},
		{"DragLib",								""},
		{"MathLib",								""},
		{"ObjectSupportLib",					""},
		{"StdCLib",								""},
		{"ThreadsLib",							""},
		{"ThreadsLib.1248",						""},
		{"Translation",							""},
	};

#define nMacPPCMaps (sizeof(rgMacPPCMaps) / sizeof(DLLMAP))
	
	const DLLMAP *pDLLMap;
	int nMaps;
		
	switch (nCurrentPlatform)
	{
		case (macppc):
			pDLLMap = rgMacPPCMaps;
			nMaps = nMacPPCMaps;
			break;

		default:
			ASSERT (FALSE);
			return FALSE;
			break;
	}

	TCHAR szFullKeyName[_MAX_PATH];
	TCHAR sz[20];

	for (int i=0; i < nMaps; i++)
	{
		sprintf(sz, "Mapping%d", i+1);
		_ftcscpy(szFullKeyName, strMapKeyName);
		_ftcscat(szFullKeyName, sz);
		if ( !theApp.WriteProfileString(szFullKeyName, _T("Remote Name"), rgMacPPCMaps[i].szRemote) ) {
			return FALSE;
		}
		if ( !theApp.WriteProfileString(szFullKeyName, _T("Local Name"), rgMacPPCMaps[i].szLocal) ) {
			return FALSE;
		}

	}

	return TRUE;
}

/****************************************************************************

	FUNCTION:	FGetLocalDLLFromRemoteDLL
	
	PURPOSE:	Search the appropriate DLLRecList to see if we have an entry
				for the given remote DLL name. If not found in DLLRecList,
				check the registry mappings.

	INPUT:		strRemote is the remote DLL we are trying to find a match for.

	OUTPUT:		If an entry is found for strRemote, strLocal will contain
				the associated local name, including the FULL PATH.
				NOTE: this string may be empty even though a remote name was
				found, which means the user doesn't want to be prompted
				anymore for this DLL's local file.

	RETURNS:	TRUE if the remote name was found.  NOTE: you shouldn't
				use strLocal.IsEmpty to see if an entry exists.  See above
				explanation.

****************************************************************************/
BOOL FGetLocalDLLFromRemoteDLL(CString& strLocal, CString strRemote)
{
	CString strT;

	strLocal.Empty();

	// During JIT session, we may not have project info
	if ( gpIBldSys && gpIBldSys->IsActiveBuilderValid() == S_OK )
	{
		DLLREC *pDLLRec;
		CPtrList *pDLLRecList;
		POSITION posDLLRecList;
		HBLDTARGET hTarget;

		ASSERT(gpIBldSys);

		gpIBldSys->GetActiveTarget(ACTIVE_BUILDER, &hTarget);
		pDLLRecList = DLLRecListFromTarget((HTARGET)hTarget);
		posDLLRecList = pDLLRecList->GetHeadPosition();

		while (posDLLRecList != NULL)
        {
			pDLLRec = (DLLREC*) pDLLRecList->GetNext(posDLLRecList);
			
			if (strRemote.CompareNoCase(pDLLRec->strRemoteName) == 0)
			{

				strT = pDLLRec->strLocalName;

				// If we started debugging, this mapping must always exist
				// (even if the grid entry is deleted, our internal mapping
				// should will linger until the end of the debug session).

				if (strT.IsEmpty()) {
					strLocal.Empty();
				} else {
					VERIFY (FFindDLL (strT, strLocal, TRUE));
				}
				
				return TRUE;
			}
		}
	}

	// If we're debugging xbox, see if we can pluck the mapping out of the
	// xbe -- but we won't return the EXE
	if(pDebugCurr->GetPlatform() == xbox && lpprcCurr) {
		char szPath[MAX_PATH + 1];
		char szPathExe[MAX_PATH + 1];

		HRESULT hr = HrXbeGetLocalModulePath(lpprcCurr->szName, strRemote,
			szPath, sizeof szPath);
		if(SUCCEEDED(hr)) {
			hr = HrXbeGetLocalModulePath(lpprcCurr->szName, NULL, szPathExe,
				sizeof szPathExe);
			if(FAILED(hr) || _tcsicmp(szPath, szPathExe)) {
				strLocal = szPath;
				return TRUE;
			}
		}
	}

	//
	// Not found in DLL info.  Check the registry.
	//

	// Currently, only macppc stores remote mappings in the registry
	
	if (pDebugCurr->GetPlatform() != macppc) {
		return FALSE;
	}

	// First get a ptr to the current CPlatform
	UINT nCurrentPlatform = pDebugCurr->GetPlatform();
	uniq_platform upPlatform = unknown_platform;
	HKEY hkey;
	CString strRegRemoteName;
	CString strBaseKeyName;
	TCHAR szFullKeyName[_MAX_PATH];
	TCHAR sz[20];

	gpIBldPlatforms->InitPlatformEnum();

	while (SUCCEEDED(gpIBldPlatforms->NextPlatform(&upPlatform)))
	{
		if (upPlatform == (uniq_platform)nCurrentPlatform)
		{
			// We have found the current platform
			ASSERT(gpIBldPlatforms->IsPlatformSupported(upPlatform) == S_OK);
			break;
		}
	}

	// We better have found the current platform...
	ASSERT(upPlatform == (uniq_platform)nCurrentPlatform);

	// see if "Remote DLL Mappings" exists.  If not, create it.
	const TCHAR *szKey;

	gpIBldPlatforms->GetPlatformCompRegKeyName(upPlatform, TRUE, &szKey);
	strBaseKeyName = szKey;
	strBaseKeyName += _T("Remote DLL Mappings");	// Do not localize;

	if (RegOpenKeyEx(HKEY_CURRENT_USER, strBaseKeyName, 0, KEY_READ, &hkey) != ERROR_SUCCESS) {
		gpIBldPlatforms->GetPlatformCompRegKeyName(upPlatform, FALSE, &szKey);
		strBaseKeyName = szKey;
		strBaseKeyName += _T("Remote DLL Mappings\\");

		if (!FCreateDLLMappingsKey(strBaseKeyName, nCurrentPlatform))
        {
			RegCloseKey(hkey);
			return FALSE;
		}
	}

	RegCloseKey(hkey);

	gpIBldPlatforms->GetPlatformCompRegKeyName(upPlatform, FALSE, &szKey);
	strBaseKeyName = szKey;
	strBaseKeyName += _T("Remote DLL Mappings\\");

	for (int i=1; ; i++)
	{
		// FUTURE - put "Mapping%d" into .rc file
		sprintf(sz, "Mapping%d", i);
		_ftcscpy(szFullKeyName, strBaseKeyName);
		_ftcscat(szFullKeyName, sz);
		strRegRemoteName = theApp.GetProfileString(szFullKeyName, _T("Remote Name"));
		if (strRegRemoteName.IsEmpty()) {
			return FALSE;
		}
		if (strRemote.CompareNoCase(strRegRemoteName) == 0) {
			strT = theApp.GetProfileString(szFullKeyName, _T("Local Name"));
			if (strT.IsEmpty()) {
				strLocal.Empty();
				return TRUE;
			}
			if (FFindDLL(strT, strLocal, TRUE)) {
				return TRUE;
			} else {
				return FALSE;
			}
		}
	}

	return FALSE;
}


/****************************************************************************

	FUNCTION:	FGetRemoteDLLFromLocalDLL

	PURPOSE:	Search the appropriate DLLRecList to see if we have an entry
				for the given local DLL name.

	INPUT:		strLocal       - the local DLL we are trying to find a match
								 for.

	OUTPUT:		If an entry is found for strLocal, strRemote will contain
				the associated remote name.

	RETURNS:	TRUE if the remote name was found.  NOTE: you shouldn't
				use strLocal.IsEmpty to see if an entry exists.  See above
				explanation.

****************************************************************************/
BOOL
FGetRemoteDLLFromLocalDLL(
	CString 	strLocal,
	CString& 	strRemote
	)
{
	CString strLocalNoPath;
	DLLREC *pDLLRec;
	CPtrList *pDLLRecList;
	POSITION posDLLRecList;

	strRemote.Empty();

    // Are we trying to find the local name of the exe?
    // If we couldn't create a project, the exe mapping will be stored with
    // the DLL mappings
	
    if ((strLocal.CompareNoCase(ExecutablePath) == 0) &&
         gpIBldSys &&
        (gpIBldSys->IsActiveBuilderValid() == S_OK))
    {
		gpIBldSys->GetRemoteTargetFileName(ACTIVE_BUILDER, strRemote);

		// ppc and 68k only send module name, should be sending the full path
		if ((pDebugCurr->GetPlatform() == macppc) || (pDebugCurr->GetPlatform() == mac68k))
			strRemote = LtszRemoteFileFromPath(strRemote);

		return TRUE;
	}

#ifdef _DEBUG
	// The incoming local name must always include a full path (possibly UNC)
	_splitpath(strLocal, szDrive, szDir, szFName, szExt);
	ASSERT((*szDrive != '\0' && *szDir != '\0') ||
			(strLocal[0] == '\\' && strLocal[1] == '\\'));
#endif

	// NOTE:
	// o  strLocal will always specify a full path.
	// o  The local name in the grid may or may not have a full path
	// o  The local name in the registry may or may not have a full path

	// Get the filename from the full path
	_splitpath(strLocal, szDrive, szDir, szFName, szExt);
	strLocalNoPath = szFName;
	strLocalNoPath += szExt;


	// First look for this local name in the dll grid.  Compare using both
	// the full path and also just the filename of the given file since the
	// grid may contain either form.
	
	ASSERT(gpIBldSys);

	HBLDTARGET hTarget;

	gpIBldSys->GetActiveTarget(ACTIVE_BUILDER, &hTarget);
	pDLLRecList = DLLRecListFromTarget((HTARGET)hTarget);
	posDLLRecList = pDLLRecList->GetHeadPosition();

	while (posDLLRecList != NULL)
    {
		pDLLRec = (DLLREC *)pDLLRecList->GetNext(posDLLRecList);

		if (strLocal.CompareNoCase(pDLLRec->strLocalName) == 0 ||
			strLocalNoPath.CompareNoCase(pDLLRec->strLocalName) == 0)
		{
			strRemote = pDLLRec->strRemoteName;
			return TRUE;
		}
	}

	// Now look for this local name in the registry mappings.  Compare using both
	// the full path and also just the filename of the given file since the
	// registry may contain either form.

	// Currently, only macppc stores remote mappings in the registry
	if (pDebugCurr->GetPlatform() != macppc) {
		return FALSE;
	}


	UINT nCurrentPlatform = pDebugCurr->GetPlatform();
	CString strRegRemoteName;
	CString strRegLocalName;
	CString strBaseKeyName;
	uniq_platform upPlatform = unknown_platform;
	TCHAR szFullKeyName[_MAX_PATH];
	TCHAR sz[20];

	// First get a ptr to the current CPlatform
	gpIBldPlatforms->InitPlatformEnum();
	while (SUCCEEDED(gpIBldPlatforms->NextPlatform(&upPlatform)))
	{
		if (upPlatform == (uniq_platform)nCurrentPlatform)
		{
			// We have found the current platform
			ASSERT(gpIBldPlatforms->IsPlatformSupported(upPlatform) == S_OK);
			break;
		}
	}

	// We better have found the current platform...
	ASSERT(upPlatform == (uniq_platform)nCurrentPlatform);

	const TCHAR *szKey;

	gpIBldPlatforms->GetPlatformCompRegKeyName(upPlatform, FALSE, &szKey);
	strBaseKeyName = szKey;
	strBaseKeyName += _T("Remote DLL Mappings\\");

	for (int i=1; ; i++)
	{
		// FUTURE - put "Mapping%d" into .rc file
		sprintf(sz, "Mapping%d", i);
		_ftcscpy(szFullKeyName, strBaseKeyName);
		_ftcscat(szFullKeyName, sz);

		// Make sure we haven't reached the end of the mappings
		strRegRemoteName = theApp.GetProfileString(szFullKeyName, _T("Remote Name"));
		if (strRegRemoteName.IsEmpty()) {
			return FALSE;
		}

		// Now see if the local names match
		strRegLocalName = theApp.GetProfileString(szFullKeyName, _T("Local Name"));

		if (strLocal.CompareNoCase(strRegLocalName) == 0 ||
			strLocalNoPath.CompareNoCase(strRegLocalName) == 0)
		{
			strRemote = strRegRemoteName;
			return TRUE;
		}
	}

	return FALSE;
}


/****************************************************************************

	FUNCTION:	ClearDLLInfo

	PURPOSE:	Delete all records from DLLGridInfoList, or from just
				one target if a target is specified.

****************************************************************************/
void ClearDLLInfo(HTARGET hTarget)
{
	// Clear info for a specific target, or for all targets?
	if (hTarget)
	{
		CPtrList *pDLLRecList = DLLRecListFromTarget(hTarget);

		// ...free mem for every DLL record
		while ( !pDLLRecList->IsEmpty() ) {
			DLLREC *pDLLRec = (DLLREC *)pDLLRecList->RemoveTail();
			delete pDLLRec;
		}
	}
	else
	{
		GRIDINFO *pGridInfo;
		CPtrList *pDLLRecList;

		// For every build target...
		while (!DLLGridInfoList.IsEmpty())
		{
			pGridInfo = (GRIDINFO *)DLLGridInfoList.RemoveTail();
			pDLLRecList = &pGridInfo->DLLRecList;

			// ...free mem for every DLL record
			while ( !pDLLRecList->IsEmpty() ) {
				DLLREC *pDLLRec = (DLLREC *)pDLLRecList->RemoveTail();
				delete pDLLRec;
			}

			delete pGridInfo;
		}

	}
}


/****************************************************************************

	FUNCTION:	AddRecToDLLInfo

	PURPOSE:	Add a record to the DLLInfo list.

	INPUT:		strLocal - the local name of the new entry
				strRemote - the name of the drummer for Rush.  Just kidding.
				fPreload - do we preload symbols for this DLL
				hTarget - specifies the build target grid to which we are
					adding the DLL
							
	RETURNS:	absolutely nothing

****************************************************************************/
void AddRecToDLLInfo(CString strLocal, CString strRemote, BOOL fPreload, HTARGET hTarget)
{
	DLLREC *pDLLRec = new DLLREC;
	CPtrList *pDLLRecList = DLLRecListFromTarget(hTarget);

	pDLLRec->fPreload = fPreload;
	pDLLRec->fDelete = FALSE;
	pDLLRec->strLocalName = strLocal;
	pDLLRec->strRemoteName = strRemote;
	pDLLRecList->AddTail(pDLLRec);
}


void
UpdateDLLInfoRec(
	CString	strLocal,
	CString	strRemote,
	BOOL	fPreLoad,
	HTARGET	hTarget,
	BOOL	fSearchOnLocal
	)
/*++

Routine Description:

	This routine is much like AddRecToDLLInfo except that it attempts to
	UPDATE the information before blindly adding it.  This is important in
	several circumstances.

Arguments:

	fSearchOnLocal - TRUE means that we should search using strLocal as the
					 key.  FALSE means search using strRemote as the key.

	fPreLoad - The fPreLoad argument is only used if this is NOT and update;
			   if this is an update, the fPreLoad field is unchanged.

	All other args are as in AddRecToDLLInfo.

Comments:

	If we're searching on the local string, allow it to match on either a
	full path match or only a image-name, extension match.  If we're
	searching on remote, match only on complete match.  This is how we
	search elsewhere.

--*/
{
	CPtrList*	list = DLLRecListFromTarget (hTarget);
	POSITION	cur;
	BOOL		fFound = FALSE;
	CString		strShortLocal;
	TCHAR		FileName [_MAX_FNAME + 1];
	TCHAR		Ext [_MAX_EXT + 1];
	DLLREC*		entry = NULL;

	_tsplitpath (strLocal, NULL, NULL, FileName, Ext);

	strShortLocal = FileName;
	strShortLocal += Ext;

	cur = list->GetHeadPosition ();
	
	while (!fFound && cur)
    {
		entry = (DLLREC*) list->GetNext (cur);

		if (fSearchOnLocal)
		{
			if (strLocal.CompareNoCase (entry->strLocalName) == 0 ||
				strShortLocal.CompareNoCase (entry->strLocalName) == 0)
			{
				fFound = TRUE;
			}
		}
		else
		{
			if (strRemote.CompareNoCase (entry->strRemoteName) == 0)
			{
				fFound = TRUE;
			}
		}
	}


	if (fFound)
	{
		ASSERT (entry);

		entry->strLocalName = strLocal;
		entry->strRemoteName = strRemote;
	}
	else
	{
		AddRecToDLLInfo (strLocal, strRemote, fPreLoad, hTarget);
	}
}

		

	

	
	

/****************************************************************************

	FUNCTION:	PurgeDLLInfo

	PURPOSE:	Remove any records marked for deletion during debugging.

****************************************************************************/
void PurgeDLLInfo(void)
{
	POSITION posGridList;
	POSITION posDLLRecList;
	GRIDINFO *pGridInfo;
	CPtrList *pDLLRecList;
	DLLREC *pDLLRec;

	posGridList = DLLGridInfoList.GetHeadPosition();

	// For every build target...
	while (posGridList != NULL)
	{
		pGridInfo = (GRIDINFO *)DLLGridInfoList.GetNext(posGridList);
		pDLLRecList = &pGridInfo->DLLRecList;

		posDLLRecList = pDLLRecList->GetHeadPosition();

		// remove any DLL records marked for deletion
		while (posDLLRecList != NULL) {
			POSITION posCur = posDLLRecList;
			pDLLRec = (DLLREC *)pDLLRecList->GetNext(posDLLRecList);
			if (pDLLRec->fDelete) {
				pDLLRecList->RemoveAt(posCur);
				delete pDLLRec;
			}
		}
	}
}


/****************************************************************************

	FUNCTION:	GetDLLCount()

	PURPOSE:	The bld package calls GetDLLCount to determine how much
				memory to alloc for the rgDLLRec that will be initialized in
				InitDLLGrid().

	INPUT:		hTarget: specifies a certain build target's grid

	RETURNS:	count of DLLs

****************************************************************************/
IDE_EXPORT int GetDLLCount(HTARGET hTarget)
{
	int i=0;
	DLLREC *pDLLRec;
	CPtrList *pDLLRecList = DLLRecListFromTarget(hTarget);
	POSITION posDLLRecList = pDLLRecList->GetHeadPosition();

	while (posDLLRecList != NULL) {
		pDLLRec = (DLLREC *)pDLLRecList->GetNext(posDLLRecList);
		if (!pDLLRec->fDelete) {
			i++;
		}
	}
	// If debuggee isn't running, no records should be marked for deletion
	// (they should have all been purged)
	ASSERT(DebuggeeAlive() || i == pDLLRecList->GetCount());
	return i;
}


/****************************************************************************

	FUNCTION:	InitDLLList()

	PURPOSE:	The bld package calls InitDLLList to initialize the
				"Additional DLLs" DLL list (after calling GetDLLCount() to
				determine how much mem to allocate at rgDLLRec).

	INPUT:		rgDLLRec: the memory allocated after calling GetDLLCount().

	RETURNS:	nothing

****************************************************************************/
void InitDLLList(HTARGET hTarget, CPtrList &listDLLs)
{
	DLLREC *pDLLRec;
	CPtrList *pDLLRecList = DLLRecListFromTarget(hTarget);
	POSITION posDLLRecList = pDLLRecList->GetHeadPosition();

	while (posDLLRecList != NULL)
	{
		pDLLRec = (DLLREC *)pDLLRecList->GetNext(posDLLRecList);
		if (!pDLLRec->fDelete)
			listDLLs.AddTail(pDLLRec);
		else
			ASSERT (DebuggeeAlive());
	}
}


/****************************************************************************

	FUNCTION:	SaveDLLList()

	PURPOSE:	The bld package calls SaveDLLList to save away the info
				entered in the "Additional DLLs" grid.

	INPUT:		A list of DLLRECs.

	RETURNS:	nothing

****************************************************************************/
void SaveDLLList(HTARGET hTarget, CPtrList &listDLLs)
{
	int cDLLs;
	DLLREC *pDLLRec;
	CPtrList *pDLLRecList = DLLRecListFromTarget(hTarget);

	cDLLs = listDLLs.GetCount();

	// First update DLLInfo
	ASSERT(gpIBldSys);

	HBLDTARGET hActiveTarget;
	gpIBldSys->GetActiveTarget(ACTIVE_BUILDER, &hActiveTarget);

	if (!DebuggeeAlive() || hTarget != (HTARGET)hActiveTarget)
	{
		// Easy case - just create a new DLL list	
		ClearDLLInfo(hTarget);
	}
	else
	{
		// Not as easy.  We need to keep the old mappings around for when we
		// call UnRegisterEmi (we'll need the remote name)

		// Check to see if the user has removed any DLLs
		POSITION posDLLRecList = pDLLRecList->GetHeadPosition();
		POSITION posCur;

		// For every local DLL in the old list...
		while (posDLLRecList != NULL)
		{
			posCur = posDLLRecList;
			pDLLRec = (DLLREC *)pDLLRecList->GetNext(posDLLRecList);
			// If it doesn't have a local name, we don't care about it
			if (pDLLRec->strLocalName.IsEmpty())
			{
				pDLLRecList->RemoveAt(posCur);
				delete pDLLRec;
				continue;
			}
			// Mark all DLLRECs with a local name for deletion.  If we find a
			// new record that has the same local name, unmark it for deletion.
			pDLLRec->fDelete = TRUE;

			// ...is there a match in the new list?
			POSITION pos = listDLLs.GetHeadPosition();
			while (pos != NULL)
			{
				DLLREC *pSaveDLLRec = (DLLREC *)listDLLs.GetNext(pos);

				if (pSaveDLLRec->strLocalName == pDLLRec->strLocalName)
				{
					pDLLRec->fDelete = FALSE;		// use the old mapping
					pSaveDLLRec->fDelete = TRUE;	// don't use the new mapping
					break;
				}
			}
		}
	}

	// Add new (non-duplicate) mappings
	POSITION pos = listDLLs.GetHeadPosition();
	while (pos != NULL)
	{
		DLLREC *pSaveDLLRec = (DLLREC *)listDLLs.GetNext(pos);
		
		if (!pSaveDLLRec->fDelete)
		{
			pDLLRec = new DLLREC;
			pDLLRec->fPreload = pSaveDLLRec->fPreload;

			pDLLRec->strLocalName = pSaveDLLRec->strLocalName;
			pDLLRec->strRemoteName = pSaveDLLRec->strRemoteName;
			pDLLRec->fDelete = FALSE;
			pDLLRecList->AddTail(pDLLRec);
		}
	}

	// If debugging, load symbols for any new DLLs in the active target
	if (DebuggeeAlive() && hTarget == (HTARGET)hActiveTarget)
	{
		// Put up hourglass (the constructor does it)
		CWaitCursor	wc;

		CStringList sl;
		// include ALL DLLs (not just preload)
		BuildLocalDLLsStringList(sl, FALSE);
		// NOTE: the fQuiet flag MUST be TRUE here!  Otherwise, a dialog may
		// appear which, when dismissed, will set focus back to the project
		// settings dialog, which will cause a depency to be added to the CProxySlob
		// that will never be removed (because this func is being called during
		// OnOK processing which has already removed the dependency).  Then we
		// will crash in InformDependents.
		LoadAdditionalDLLs(&sl, FALSE, TRUE);		
	}
}

/****************************************************************************

	FUNCTION:	DiffDlls()

	PURPOSE:	If the user brings up the Options.Debug dialog while the
				debuggee is already running, we want to load symbols for
				any DLLs he has added to the list.  Note, we do NOT unload
				symbols for any DLLs that he has removed from the list; but
				we do warn him about this.

	INPUT:		szNewDLLs = new list of DLLs
				pichBegin = pointer where, if a DLL load fails, the starting
					offset of the DLL name that caused the failure will be
					stored.
				pichEnd = pointer, goes with pichBegin.  Will point just
					after last character of DLL name.

	RETURNS:	pidMsg = when not -1 this is a message concerning recent diff.
				TRUE for success.

****************************************************************************/

BOOL DiffDlls(HTARGET hTarget, CPtrList &listDLLs, int *piRow, UINT *pidMsg)
{
	CString strNewLocalDLLs;
	int i = 0;

	*pidMsg = (UINT)-1;	// default is *no* message
	*piRow = 0;

	// Validate all local DLLs listed
	POSITION pos = listDLLs.GetHeadPosition();
	while (pos != NULL)
	{
		DLLREC *pDiffDLLRec = (DLLREC *)listDLLs.GetNext(pos);
		if (!pDiffDLLRec->strLocalName.IsEmpty())
		{
			CString strLocalPath;
			// Can't call CheckEXEForDebug here because debuggee might not
			// be running
			if (!FFindDLL(pDiffDLLRec->strLocalName, strLocalPath))
			{
				*piRow = i;
				return FALSE;
			}
		}

		i++;
	}

	// If we aren't debugging, we don't have to worry about warning
	// that symbols will not be unloaded from memory.		
	if (!DebuggeeAlive())
		return TRUE;

	// Check to see if the user has removed any DLLs
	DLLREC *pDLLRec;
	CPtrList *pDLLRecList = DLLRecListFromTarget(hTarget);
	POSITION posDLLRecList = pDLLRecList->GetHeadPosition();
	BOOL fFound;

	// For every local DLL in the old list...
	while ( posDLLRecList != NULL )
	{
		pDLLRec = (DLLREC *)pDLLRecList->GetNext(posDLLRecList);
		if (pDLLRec->strLocalName.IsEmpty())
		{
			continue;
		}
		fFound = FALSE;

		// ...is there a match in the new list?
		POSITION pos = listDLLs.GetHeadPosition();
		while (pos != NULL)
		{
			DLLREC *pDiffDLLRec = (DLLREC *)listDLLs.GetNext(pos);
			if (pDiffDLLRec->strLocalName == pDLLRec->strLocalName)
			{
				fFound = TRUE;
				break;
			}
		}
		if (!fFound)
		{
			*pidMsg = IDS_DllsNotUnloaded;
			break;
		}
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes

#include "stdafx.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//		are changed infrequently
//

#pragma warning(disable: 4100)

#include "vshell.h"
#include "srcguid.h"
#include "prjapi.h"
#include "prjguid.h"
#include "bldguid.h"
#include "utilguid.h"
#include "clvwguid.h"

#define USE_CPLUSPLUS_TOKENS
#include "srcapi.h"

#include "bldapi.h"
#include "utilapi.h"
#include "clvwapi.h"

#include <windowsx.h>
#include <errno.h>
#include <fcntl.h>
#include <share.h>
#include <tchar.h>
#include "hash.h"
#include "inc\datatip.h"
#include "inc\idedoc.h"
#include "inc\ideview.h"
#include <shlbar.h>
#include <shldocs.h>
#include <shlfutr_.h>
#include <shlmenu.h>
#include <shlsrvc.h>
#include <util.h>
#include <proppage.h>
#include <dlgbase.h>

#include "types.h"                      // in Langapi
#include <od4.h>
#include <cvinfo.h>                     // in Langapi
#include <shapi.h>                    // in Langapi
#include <symapi.h>						// in Langapi 
#include "symimpl.h"
#include "od.h"                         // in Langapi
#include "tlui.h"                       // in Langapi
#include "resource.h"
#include "qcqp.h"
#include "brkpt.h"
#include "cmgrnew.h"
#include "cmgrlow.h"
#include "cdebug.h"
#include "cl.h"
#include "cp.h"
#include "cvinc\cp.hmd"
#include "dbgnew.h"
#include "colors.h"
#include "dbgguid.h"
#include "dbgpguid.h"
#include "dbgpkapi.h"
#include "dbgpkg.h"
#include "cvinc\sy.hmd"
#include "inc\dbg.h"
#include "inc\fonts.h"
#include "inc\meclass.h"
#include "inc\mw.h"
#include "inc\rwv.h"
#include "inc\treegrid.h"
#include "inc\dbggrid.h"
#include "inc\varsview.h"
#include "inc\qwatch.h"
#include "inc\eetm.h"
#include "inc\watchrow.h"
#include "inc\extern.h"
#include "inc\breakpts.h"
#include "inc\makeeng.h"
#include "inc\ambig.h"
#include "inc\askpath.h"
#include "cvinc\brkpt.hmd"
#include "inc\bpdlgex.h"
#include "cvinc\cvwin32.h"
#include "cvinc\newexe.h"
#include "inc\excep.h"
#include "inc\rundebug.h"
#include "inc\tracefn.h"
#include "inc\retvals.h"
#include "inc\miscdlgs.h"
#include "cvinc\linklist.hmd"
#include "cvinc\debtimer.h"
#include "inc\debugopt.h"
#include "inc\eetm.h"
#include "inc\lnklst.h"
#include "inc\thread.h"
#include "inc\ldouble.h"
#include "inc\keycheck.h"
#include "inc\dam.h"
#include "inc\clw.h"
#include "inc\gotoitem.h"
#include "inc\stsfile.h"
#include "inc\owinwrap.h"
#include <afxctl.h>
#include <image.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\stsfile.cpp ===
// STSFILE.C
//		Status file handling
//
//
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// [CAVIAR #5459 11/27/92 v-natjm]
// RebuildBreakpoint
//
static BOOL NEAR PASCAL RebuildBreakpoint (
	PBREAKPOINTNODE pBPDest,
	BREAKPOINTTYPES wType,
	LPSTR lpszLocation,
	LPSTR lpszExpression,
	int iLength,
	LPSTR lpszWndProc,
	UINT uMessageClass,
	UINT uMessageNum,
	BOOL bEnabled,
	BOOL bAmbig,
	int  TMindex,
	BOOL bWarnedUnsupported,
	long cPass,
	BOOL fSqlBp )
{

	// Clear all fields in the BREAKPOINTNODE destination
	_fmemset ( pBPDest, 0, sizeof ( BREAKPOINTNODE ) );

	// Action - breakpointtype
	pbpnType ( pBPDest ) = wType;
	pbpnPassCount( pBPDest ) = (USHORT)cPass;
	pbpnSqlBp( pBPDest ) = fSqlBp;

	// Location
	if ( ( wType == BPLOC ) ||
		 ( wType == BPLOCEXPRTRUE ) ||
		 ( wType == BPLOCEXPRCHGD ) ) {

		if  ( ! ParseCV400Location ( lpszLocation, pBPDest ) &&
			 ! ParseQC25Location ( lpszLocation, pBPDest ) ) {
			return FALSE;
		}
	}

	// Wnd Proc
	if ( wType == BPWNDPROCMSGRCVD ) {
		// Must have a wndproc and a message class/message
		if ( ! ParseWndProc ( lpszWndProc, pBPDest ) ||
			uMessageClass == msgNone
		) {
			return FALSE;
		}

		// Messages
		pbpnMessageClass ( pBPDest ) = uMessageClass;
		pbpnMessageNum ( pBPDest ) = uMessageNum;
	}

	// Expression
	if ( ( wType == BPLOCEXPRTRUE ) ||
		 ( wType == BPLOCEXPRCHGD ) ||
		 ( wType == BPEXPRTRUE) ||
		 ( wType == BPEXPRCHGD ) ) {
		if ( ! ParseExpression ( lpszExpression, pBPDest ) ) {
			return FALSE;
		}
	}

	// Length
	if ( ( wType == BPLOCEXPRCHGD ) ||
		 ( wType == BPEXPRCHGD ) ) {
		pbpnExprLen(pBPDest) = iLength;
	}

	// Set the enabled/disabled flag
	pbpnEnabled ( pBPDest ) = bEnabled;
	pbpnAmbigBP ( pBPDest ) = bAmbig ;
	pbpnBPTMindex ( pBPDest ) = TMindex ;
	pbpnWarnedUnsupported ( pBPDest ) = bWarnedUnsupported;

	// if "line type" bp, set the line numbers to indicate that breakpoint
	// is "restorable"
	// (i.e. set non- -1 initial line number
	if (pbpnFileLineNode(pBPDest))
		pbpnInitLine(pBPDest) = pbpnCurLine(pBPDest);

	// If get to here the Breakpoint action has necessary data
	return TRUE;
}

UINT nVersionNumber = 0x0003000A;

#define ENDOFRECORD ((DWORD)0x47414D00)

static const char BASED_CODE szOPTInfo[] = "Debugger";

BOOL LoadFromOPTFile(CStateSaver &stateSave)
{
	BOOL bRetval = TRUE;
	CInitFile fileInit;

	ASSERT(stateSave.IsLoading());

	if (!stateSave.OpenStream(fileInit, szOPTInfo))
		return FALSE;

	CArchive ar(&fileInit, CArchive::bNoFlushOnDelete | CArchive::load);
	CString str;

	try
	{
		long nFormatVersion;

		ar >> nFormatVersion;

		// For the OPT files, the formats must match exactly.
		if ((UINT&)nFormatVersion != nVersionNumber )
			AfxThrowArchiveException(CArchiveException::badSchema);

		//
		// Serialize breakpoint list
		//
		char szGeneralBuffer[cbBpCmdMax];
		WORD wLoop;
		WORD wBPCount;
		UINT uMsgNum, uMsgClass;
		long iTmp;
		long lBrkptType;
		BREAKPOINTTYPES wBrkptType;
		int iRet;
		LPSTR pc1, pc2;
		long bEnable;
		long bAmbig;
		long TMindex;
		long bWarnedUnsupported;
		BREAKPOINTNODE BpNode;
		long cPass;
		long fSqlBp;

	 	// read the number of breakpoints
		ar >> wBPCount;

		if (wBPCount)
		{
			// we have breakpoints to set. read them one by one
			// if an info is missing for a breakpoint, just skip it.
			// load the generic entry names
			// [CAVIAR # 11/26/92 v-natjm]
			// Save all necessary flags to restore Ambiguous BP

			for (wLoop = 0; wLoop < wBPCount; wLoop++)
			{
				ar >> lBrkptType;
				wBrkptType = (BREAKPOINTTYPES)lBrkptType;
				ar >> bEnable;
				ar >> bAmbig;
				ar >> TMindex;
				ar >> bWarnedUnsupported;
				ar >> cPass;
				ar >> fSqlBp;

				switch ( wBrkptType )
				{
					case BPLOC:
						// breakpoint at location
						ar >> str;
						_tcscpy(szGeneralBuffer, str);
						pc1 = szGeneralBuffer + _fstrlen(szGeneralBuffer);	// use strlen, not _tcslen, to get bytes not chars
						if (RebuildBreakpoint(&BpNode, wBrkptType,
								szGeneralBuffer, pc1, 0, pc1, 0, 0, bEnable,
								bAmbig, TMindex, bWarnedUnsupported, cPass, fSqlBp))
							AddBreakpointNode(&BpNode, FALSE, TRUE, TRUE, &iRet); // iRet unused here
						break;

					case BPLOCEXPRTRUE:
						// breakpoint at location when expression is true
						ar >> str;
						_tcscpy(szGeneralBuffer, str);
						pc1 = szGeneralBuffer + _fstrlen(szGeneralBuffer) + 1;	// use strlen, not _tcslen, to get bytes not chars
						ar >> str;
						_tcscpy(pc1, str);
						pc2 = pc1 + _fstrlen(pc1);
						if (RebuildBreakpoint(&BpNode, wBrkptType,
								szGeneralBuffer, pc1, 0, pc2, 0, 0, bEnable,
								bAmbig, TMindex, bWarnedUnsupported, cPass, fSqlBp))
							AddBreakpointNode(&BpNode, FALSE, TRUE, TRUE, &iRet);
						break;

					case BPLOCEXPRCHGD:
						// breakpoint at location when expression has changed
						ar >> str;
						_tcscpy(szGeneralBuffer, str);
						pc1 = szGeneralBuffer + _fstrlen(szGeneralBuffer) + 1;	// use strlen, not _tcslen, to get bytes not chars
						ar >> str;
						_tcscpy(pc1, str);
						pc2 = pc1 + _fstrlen(pc1);
						ar >> iTmp;
						if (RebuildBreakpoint(&BpNode, wBrkptType,
								szGeneralBuffer, pc1, iTmp, pc2, 0, 0,
								bEnable, bAmbig, TMindex, bWarnedUnsupported,
								cPass, fSqlBp))
							AddBreakpointNode(&BpNode, FALSE, TRUE, TRUE, &iRet);
						break;

					case BPEXPRTRUE:
						// breakpoint when expression is true
						ar >> str;
						_tcscpy(szGeneralBuffer, str);
						pc1 = szGeneralBuffer + _fstrlen(szGeneralBuffer);	// use strlen, not _tcslen, to get bytes not chars
						if (RebuildBreakpoint(&BpNode, wBrkptType, pc1,
								szGeneralBuffer, 0, pc1, 0, 0, bEnable,
								bAmbig, TMindex, bWarnedUnsupported, cPass, fSqlBp))
							AddBreakpointNode(&BpNode, FALSE, TRUE, TRUE, &iRet);
						break;

					case BPEXPRCHGD:
						// breakpoint when expression has changed
						ar >> str;
						_tcscpy(szGeneralBuffer, str);
						pc1 = szGeneralBuffer + _fstrlen(szGeneralBuffer);	// use strlen, not _tcslen, to get bytes not chars
						ar >> iTmp;
						if (RebuildBreakpoint(&BpNode, wBrkptType, pc1,
								szGeneralBuffer, iTmp, pc1, 0, 0, bEnable,
								bAmbig, TMindex, bWarnedUnsupported, cPass, fSqlBp))
							AddBreakpointNode(&BpNode, FALSE, TRUE, TRUE, &iRet);
						break;

					case BPWNDPROCMSGRCVD:
						// breakpoint at window procedure
						ar >> str;
						_tcscpy(szGeneralBuffer, str);
						pc1 = szGeneralBuffer + _fstrlen(szGeneralBuffer);	// use strlen, not _tcslen, to get bytes not chars
						ar >> iTmp;
						uMsgNum = (UINT)iTmp;
						ar >> iTmp;
						uMsgClass = (UINT)iTmp;
						if (RebuildBreakpoint(&BpNode, wBrkptType, pc1, pc1,
								0, szGeneralBuffer, uMsgClass, uMsgNum,
								bEnable, bAmbig, TMindex, bWarnedUnsupported,
								cPass, fSqlBp))
							AddBreakpointNode(&BpNode, FALSE, TRUE, TRUE, &iRet);
						break;
				}
			}
		}

		// free mem from old list
		ClearDLLInfo();

		// Restore the additional DLL grid information
		long cTargets;

		ar >> cTargets;
		for (int iTarg=0; iTarg < cTargets; iTarg++)
		{
			long cDLLRecs;
			CString strTargetName;
			HBLDTARGET hTarget;

			ar >> strTargetName;
			gpIBldSys->GetTarget(strTargetName, ACTIVE_BUILDER, &hTarget);
			ar >> cDLLRecs;
			for (int iRecs=0; iRecs < cDLLRecs; iRecs++)
			{
				long fPreload;
				CString strLocalName;
				CString strRemoteName;

				ar >> fPreload;  
				ar >> strLocalName;
				ar >> strRemoteName;

				// if target doesn't exist, don't add to dll info
				if (hTarget != NO_TARGET)
				{
					AddRecToDLLInfo(strLocalName, strRemoteName, (BOOL) fPreload, (HTARGET)hTarget);
				}
			}
		}


		//
		// Serialize the exception list
		//
		long Count,i;
		EXCEPTION_OBJECT Object;
		DWORD dwExceptionCode;
		LONG iAction;
		LONG iPlatformId;

		// Get # of exception in the file
		ar >> Count;

		// Reset current list
		InitList(DLG_EXCEP_LIST);
		EmptyList(DLG_EXCEP_LIST);

		// Check if list isn't empty
	    if (Count == -1)
			fExcepListInitialized = FALSE;
		else
		{
			fExcepListInitialized = TRUE;

			// Get each exception, and build a string
			for (i = 0; i < Count; i++)
			{
				ar >> dwExceptionCode;
				ar >> str;
				ar >> iAction;
				ar >> iPlatformId;

				MakeExceptionObject(&Object, dwExceptionCode, str,
					(int) iAction, (UINT) iPlatformId);

	            ListAddObject(DLG_EXCEP_LIST, (LPSTR)&Object,
					sizeof(EXCEPTION_OBJECT));
			}
		}


		//
		// Serialize the debugger file alias list
		//
		int cRestore;
		ar >> (long &)cRestore;
		while( cRestore-- )
		{
			CString	strFrom;
			CString	strTo;

			ar >> strFrom;
			ar >> strTo;

			// No hocus pocus, just call the internal routine.
			AddMapping(
				(LPSTR)(const char FAR *)strFrom,
				(LPSTR)(const char FAR *)strTo
			);
		}


		//
		// Serialize the watch window state.
		//
		g_persistWatch.Serialize(ar);
		g_persistVars.Serialize(ar);

		ar >> ((DWORD&) g_fPromptNoSymbolInfo);
		
		ar.Close();
		fileInit.Close();
	}
	catch (CArchiveException *e)
	{
		e->Delete();
		ar.Close();
		fileInit.Abort(); // will not throw an exception
		g_persistWatch.InitDefault();
		g_persistVars.InitDefault();
		g_fPromptNoSymbolInfo = TRUE;
		bRetval = FALSE;
	}

	// Note: At this point, if bRetval is false, then the OPT file is only
	// partially loaded and we may be in some sort of weird state

	if (bRetval)
	{
	}

	return bRetval;
}

BOOL SaveIntoOPTFile(CStateSaver &stateSave)
{
	BOOL bRetval = TRUE;
	CInitFile fileInit;

	ASSERT(stateSave.IsStoring());

	if (!stateSave.OpenStream(fileInit, szOPTInfo))
	{
		SetFileError(CFileException::generic);
		return FALSE;
	}

	CArchive ar(&fileInit, CArchive::bNoFlushOnDelete | CArchive::store);
	CString str;

	TRY
	{
		// Save format version:
		ar << ((long)nVersionNumber);

		//
		// Serialize breakpoint list
		//
		char szGeneralBuffer[cbBpCmdMax];
		WORD wBPCount = 0;
		BREAKPOINTTYPES wBrkptType;
		PBREAKPOINTNODE	pBpNode;
		long wLoop;

		// do a pass on the eventually existing breakpoints,
		// eliminating the breakpoints on assembly
		pBpNode = BHFirstBPNode();
		while (pBpNode != NULL)
		{
			// [CAVIAR #5878 11/27/92 v-natjm]
			++wBPCount;
			pBpNode = pbpnNext(pBpNode);
		}

		// write out the number of breakpoints to be saved
		ar << wBPCount;
		// write out the breakpoints
		pBpNode = BHFirstBPNode();
		for (wLoop = 0; wLoop < wBPCount; wLoop++)
		{
			// [CAVIAR #5878 11/27/92 v-natjm]
			// [CAVIAR #5459 11/27/92 v-natjm]
	 		wBrkptType = pbpnType(pBpNode);
			ar << (long)wBrkptType;
			ar << (long)pbpnEnabled(pBpNode);
			ar << (long)pbpnAmbigBP(pBpNode);
			ar << (long)pbpnBPTMindex(pBpNode);
			ar << (long)pbpnWarnedUnsupported(pBpNode);
			ar << (long)pbpnPassCount(pBpNode);
			ar << (long)pbpnSqlBp(pBpNode);

	 		// build the expression depending on each breakpoint type
			switch (wBrkptType)
			{
				case BPLOC:
					// breakpoint at location
					BuildCV400Location(pBpNode, szGeneralBuffer,
						sizeof(szGeneralBuffer), TRUE, TRUE, FALSE, FALSE);
					ar << (CString) szGeneralBuffer;
					break;

				case BPLOCEXPRTRUE:
					// breakpoint at location when expression is true
					BuildCV400Location(pBpNode, szGeneralBuffer,
						sizeof(szGeneralBuffer), TRUE, TRUE, FALSE, FALSE);
					ar << (CString) szGeneralBuffer;
					BuildCV400Expression(pBpNode, szGeneralBuffer,
						sizeof(szGeneralBuffer), TRUE, TRUE, FALSE);
					ar << (CString) szGeneralBuffer;
					break;

				case BPLOCEXPRCHGD:
					// breakpoint at location when expression has changed
					BuildCV400Location(pBpNode, szGeneralBuffer,
						sizeof(szGeneralBuffer), TRUE, TRUE, FALSE, FALSE);
					ar << (CString) szGeneralBuffer;
					BuildCV400Expression(pBpNode, szGeneralBuffer,
						sizeof(szGeneralBuffer), TRUE, TRUE, FALSE);
					ar << (CString) szGeneralBuffer;
					ar << (long)pbpnExprLen(pBpNode);
					break;

				case BPEXPRTRUE:
					// breakpoint when expression is true
					BuildCV400Expression(pBpNode, szGeneralBuffer,
						sizeof(szGeneralBuffer), TRUE, TRUE, FALSE);
					ar << (CString) szGeneralBuffer;
					break;

				case BPEXPRCHGD:
					// breakpoint when expression has changed
					BuildCV400Expression(pBpNode, szGeneralBuffer,
						sizeof(szGeneralBuffer), TRUE, TRUE, FALSE);
					ar << (CString) szGeneralBuffer;
					ar << (long)pbpnExprLen(pBpNode);
					break;

				case BPWNDPROCMSGRCVD:
					// breakpoint at window procedure
					BuildCV400Location(pBpNode, szGeneralBuffer,
						sizeof(szGeneralBuffer), TRUE, TRUE, FALSE, FALSE);
					ar << (CString) szGeneralBuffer;
					ar << (long)pbpnMessageNum(pBpNode);
					ar << (long)pbpnMessageClass(pBpNode);
					break;
			}

			pBpNode = pbpnNext(pBpNode);
		}



		//
		// Serialize DLL grid information
		//

		POSITION posGridList;
		POSITION posDLLRecList;
		GRIDINFO *pGridInfo;
		CPtrList *pDLLRecList;
		DLLREC *pDLLRec;
		CString strTargetName;

		long count = (long)DLLGridInfoList.GetCount();

		if (!DLLGridInfoList.IsEmpty())	{
			posGridList = DLLGridInfoList.GetHeadPosition();
		} else {
			posGridList = NULL;
		}

		while (posGridList != NULL)
		{
			pGridInfo = (GRIDINFO *)DLLGridInfoList.GetNext(posGridList);
			if( !(gpIBldSys->GetTargetName((HBLDTARGET)pGridInfo->hTarget, strTargetName, ACTIVE_BUILDER) == S_OK) ){
				count--;
			}
		}

		ar << count;

		if (!DLLGridInfoList.IsEmpty())	{
			posGridList = DLLGridInfoList.GetHeadPosition();
		} else {
			posGridList = NULL;
		}

		while (posGridList != NULL)
		{
			pGridInfo = (GRIDINFO *)DLLGridInfoList.GetNext(posGridList);
			pDLLRecList = &pGridInfo->DLLRecList;

			BOOL bTest;

			bTest = gpIBldSys->GetTargetName((HBLDTARGET)pGridInfo->hTarget, strTargetName, ACTIVE_BUILDER) == S_OK;

			if( bTest ){
				ar << strTargetName;
				ar << (long)pDLLRecList->GetCount();
		
				posDLLRecList = pDLLRecList->GetHeadPosition();
				while (posDLLRecList != NULL) {
					pDLLRec = (DLLREC *)pDLLRecList->GetNext(posDLLRecList);

					ar << (long)pDLLRec->fPreload;
					ar << pDLLRec->strLocalName;
					ar << pDLLRec->strRemoteName;
				}
			}
		}

		
		//
		// Serialize exception list
		//
		int Count,i;
		EXCEPTION_OBJECT Object;

		// Get # of exception in our list
		// and write it in the sts file
		if (fExcepListInitialized)
		{
			Count = (int)ListGetCount(DLG_EXCEP_LIST);
			ar << (long)Count;
		}
		else
		{
			Count = 0;
			ar << (long)-1;
		}

		// Get each exception, and build a string
		for (i = 0; i < Count; i++)
		{
			if (!ListGetObject(i, DLG_EXCEP_LIST, (LPSTR)&Object))
			{
				ASSERT(FALSE);
			}
			else
			{
			ar << (DWORD) Object.dwExceptionCode;
			ar << (CString) Object.Name;
			ar << (LONG) Object.iAction;
			ar << (LONG) Object.iPlatformId;
			}
		}


		//
		// Serialize the debugger file alias list
		//
		ar << (long)cmappath;
		for(i = 0; i < cmappath; i++)
		{
			ASSERT( rgmappath[i].lszFrom );
			ASSERT( rgmappath[i].lszTo );

			ar << (CString) rgmappath[i].lszFrom;
			ar << (CString) rgmappath[i].lszTo;
		}


		//
		// Serialize the watch window state.
		//
		g_persistWatch.Serialize(ar);
		g_persistVars.Serialize(ar);

		ar << (DWORD) g_fPromptNoSymbolInfo ;
		
		ar.Close();
		fileInit.Close();
	}
	CATCH_ALL (e)
	{
#ifdef _DEBUG
		AfxDump(e);
		TRACE("\n");
#endif	// _DEBUG

		if (e->IsKindOf(RUNTIME_CLASS(CFileException)))
			SetFileError(((CFileException*) e)->m_cause);
		else
			SetFileError(CFileException::generic);
		ar.Close();
		fileInit.Abort();
		g_fPromptNoSymbolInfo = TRUE;
		bRetval = FALSE;
	}
	END_CATCH_ALL

	return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\symimpl.h ===
#ifndef _SYMIMPL_H_
#define _SYMIMPL_H_
//	Implementation of new interface for SAPI

class ISymbolHandlerImpl : public ISymbolHandler
{
public:
    ISymbolHandlerImpl( SHF* pshf ) : m_pshf( pshf ) 
    {}
    virtual SHE     SHAddDll             (LSZ lsz, BOOL flg)         // Changed for NT
    {
        return (*m_pshf->pSHAddDll)( lsz, flg );
    }
    virtual SHE     SHAddDllsToProcess   (VOID)    {
        return (*m_pshf->pSHAddDllsToProcess)();
    }

    virtual SHE     SHLoadDll            (LSZ lsz, BOOL flg)    {
        return (*m_pshf->pSHLoadDll)( lsz, flg );
    }

    virtual VOID    SHUnloadDll          (HEXE hexe)    {
        (*m_pshf->pSHUnloadDll)( hexe );
    }

    virtual UOFFSET SHGetDebugStart      (HSYM hsym)    {
        return (*m_pshf->pSHGetDebugStart)( hsym );
    }

    virtual LSZ     SHGetSymName         (HSYM hsym, LSZ lsz)    {
        return (*m_pshf->pSHGetSymName)( hsym, lsz );
    }

    virtual BOOL    SHAddrFromHsym       (PADDR paddr, HSYM hsym)    {
        return (*m_pshf->pSHAddrFromHsym)( paddr, hsym );
    }
    virtual HMOD    SHHModGetNextGlobal  (HEXE *hexe , HMOD hmod)    {
        return (*m_pshf->pSHHModGetNextGlobal)( hexe, hmod );
    }

    virtual int     SHModelFromAddr      (PADDR paddr, LPW lpw, LPB lpb, UOFFSET *off)    {
        return (*m_pshf->pSHModelFromAddr)( paddr, lpw, lpb, off );
    }

    virtual int     SHPublicNameToAddr   (PADDR paddr1, PADDR paddr2, LSZ lsz)    {
        return (*m_pshf->pSHPublicNameToAddr)( paddr1, paddr2, lsz );
    }

    virtual LSZ     SHGetSymbol          (LPADDR paddr1, LPADDR paddr2, SOP sop, LPODR podr)    {
        return (*m_pshf->pSHGetSymbol)( paddr1, paddr2, sop, podr );
    }

    virtual BOOL    SHGetPublicAddr      (PADDR paddr, LSZ lsz)    {
        return (*m_pshf->pSHGetPublicAddr)( paddr, lsz );
    }

    virtual BOOL    SHIsLabel            (HSYM hsym )    {
        return (*m_pshf->pSHIsLabel)( hsym );
    }


    virtual VOID    SHSetDebuggeeDir     (LSZ lsz)    {
        (*m_pshf->pSHSetDebuggeeDir)( lsz );
    }

    virtual BOOL    SHAddrToLabel        (PADDR paddr, LSZ lsz)    {
        return (*m_pshf->pSHAddrToLabel)( paddr, lsz );
    }


    virtual int     SHGetSymLoc          (HSYM hsym, LSZ lsz, UINT ui, PCXT pcxt)    {
        return (*m_pshf->pSHGetSymLoc)( hsym, lsz, ui, pcxt );
    }

    virtual BOOL    SHFIsAddrNonVirtual  (PADDR paddr)    {
        return (*m_pshf->pSHFIsAddrNonVirtual)( paddr );
    }

    virtual BOOL    SHIsFarProc          (HSYM hsym )    {
        return (*m_pshf->pSHIsFarProc)( hsym );
    }


    virtual HEXE    SHGetNextExe         (HEXE hexe)    {
        return (*m_pshf->pSHGetNextExe)( hexe );
    }

    virtual HEXE    SHHexeFromHmod       (HMOD hmod )    {
        return (*m_pshf->pSHHexeFromHmod)( hmod );
    }

    virtual HMOD    SHGetNextMod         (HEXE hexe, HMOD hmod )    {
        return (*m_pshf->pSHGetNextMod)( hexe, hmod );
    }

    virtual PCXT    SHGetCxtFromHmod     (HMOD hmod, PCXT pcxt )    {
        return (*m_pshf->pSHGetCxtFromHmod)( hmod, pcxt );
    }

    virtual PCXT    SHSetCxt             (PADDR paddr, PCXT pcxt )    {
        return (*m_pshf->pSHSetCxt)( paddr, pcxt );
    }

    virtual PCXT    SHSetCxtMod          (PADDR paddr, PCXT pcxt )    {
        return (*m_pshf->pSHSetCxtMod)( paddr, pcxt );
    }

    virtual HSYM    SHFindNameInGlobal   (HSYM hsym,
                                             PCXT pcxt,
                                             LPSSTR pstr,
                                             SHFLAG flg,
                                             PFNCMP pfn,
                                             PCXT pcxt2
                                            )    {
        return (*m_pshf->pSHFindNameInGlobal)( hsym, pcxt, pstr, flg, pfn, pcxt2 );
    }

    virtual HSYM    SHFindNameInContext  (HSYM hsym,
                                             PCXT pcxt,
                                             LPSSTR pstr,
                                             SHFLAG flg,
                                             PFNCMP pfn,
                                             PCXT pcxt2
                                            )    {
        return (*m_pshf->pSHFindNameInContext)( hsym, pcxt, pstr, flg, pfn, pcxt2 );
    }

    virtual HSYM    SHGoToParent         (PCXT pcxt, PCXT pcxt2 )    {
        return (*m_pshf->pSHGoToParent)( pcxt, pcxt2 );
    }

    virtual HSYM    SHHsymFromPcxt       (PCXT pcxt )    {
        return (*m_pshf->pSHHsymFromPcxt)( pcxt );
    }

    virtual HSYM    SHNextHsym           (HMOD hmod, HSYM hsym )    {
        return (*m_pshf->pSHNextHsym)( hmod, hsym );
    }

    virtual LPCH    SHGetModName         (HMOD hmod)    {
        return (*m_pshf->pSHGetModName)( hmod );
    }

    virtual LPCH    SHGetExeName         (HEXE hexe)    {
        return (*m_pshf->pSHGetExeName)( hexe );
    }

    virtual HEXE    SHGethExeFromName    (LPCH pch )    {
        return (*m_pshf->pSHGethExeFromName)( pch );
    }

    virtual UOFF32  SHGetNearestHsym     (PADDR pa, HMOD hmod, int i, PHSYM phsym)    {
        return (*m_pshf->pSHGetNearestHsym)( pa, hmod, i, phsym );
    }

    virtual SHFLAG  SHIsInProlog         (PCXT pcxt )    {
        return (*m_pshf->pSHIsInProlog)( pcxt );
    }

    virtual SHFLAG  SHIsAddrInCxt        (PCXT pcxt, PADDR pa)    {
        return (*m_pshf->pSHIsAddrInCxt)( pcxt, pa );
    }

    virtual SHFLAG  SHCompareRE          (LPCH pch, LPCH pch2, BOOL flg)    {
        return (*m_pshf->pSHCompareRE)( pch, pch2, flg );
    }

    virtual BOOL    SHFindSymbol         (LSZ lsz, PADDR pa, LPASR pasr)    {
        return (*m_pshf->pSHFindSymbol)( lsz, pa, pasr );
    }

    virtual UOFF32  PHGetNearestHsym     (PADDR pa, HEXE hexe, PHSYM phsym)    {
        return (*m_pshf->pPHGetNearestHsym)( pa, hexe, phsym );
    }

    virtual HSYM    PHFindNameInPublics  (HSYM hsym, HEXE hexe, LPSSTR pstr, SHFLAG flg, PFNCMP pfn)    {
        return (*m_pshf->pPHFindNameInPublics)( hsym, hexe, pstr, flg, pfn );
    }

    virtual HTYPE   THGetTypeFromIndex   (HMOD hmod, THIDX thidx)    {
        return (*m_pshf->pTHGetTypeFromIndex)( hmod, thidx );
    }

    virtual HTYPE   THGetNextType        (HMOD hmod, HTYPE htype)    {
        return (*m_pshf->pTHGetNextType)( hmod, htype );
    }

    virtual LPVOID  SHLpGSNGetTable      (HEXE hexe)    {
        return (*m_pshf->pSHLpGSNGetTable)( hexe );
    }

    virtual BOOL    SHCanDisplay         (HSYM hsym)    {
        return (*m_pshf->pSHCanDisplay)( hsym );
    }


    //  Source Line handler API Exports

    virtual BOOL    SLLineFromAddr       (LPADDR pa, LPW pw, SHOFF * off1, SHOFF * off2)    {
        return (*m_pshf->pSLLineFromAddr)( pa, pw, off1, off2 );
    }

    virtual BOOL    SLFLineToAddr        (HSF hsf, WORD w, LPADDR pa, SHOFF * off1, WORD *pw )    {
        return (*m_pshf->pSLFLineToAddr)( hsf, w, pa, off1, pw );
    }

    virtual LPCH    SLNameFromHsf        (HSF hsf )    {
        return (*m_pshf->pSLNameFromHsf)( hsf );
    }

    virtual LPCH    SLNameFromHmod       (HMOD hmod, WORD w)    {
        return (*m_pshf->pSLNameFromHmod)( hmod, w );
    }

    virtual BOOL    SLFQueryModSrc       (HMOD hmod)    {
        return (*m_pshf->pSLFQueryModSrc)( hmod );
    }

    virtual HMOD    SLHmodFromHsf        (HEXE hexe, HSF hsf)    {
        return (*m_pshf->pSLHmodFromHsf)( hexe, hsf );
    }

    virtual HSF     SLHsfFromPcxt        (PCXT pcxt)    {
        return (*m_pshf->pSLHsfFromPcxt)( pcxt );
    }

    virtual HSF     SLHsfFromFile        (HMOD hmod, LSZ lsz)    {
        return (*m_pshf->pSLHsfFromFile)( hmod, lsz );
    }


    virtual int     SLCAddrFromLine      (HEXE hexe, HMOD hmod, LSZ lsz, WORD w, LPSLP *pslp)    {
        return (*m_pshf->pSLCAddrFromLine)( hexe, hmod, lsz, w, pslp );
    }

    virtual VOID    SHFree               (PVOID pv)    {
        (*m_pshf->pSHFree)( pv );
    }

    virtual VOID    SHUnloadSymbolHandler(BOOL flg)    {
        (*m_pshf->pSHUnloadSymbolHandler)( flg );
    }

// REVIEW: piersh
#ifdef NT_BUILD_ONLY
    virtual SHE     SHGetExeTimeStamp    (LPSTR pstr, ULONG * ul)    {
        return (*m_pshf->pSHGetExeTimeStamp)( pstr, ul );
    }

#else
    virtual SHE     SHGetExeTimeStamp    (LPSTR pstr, ULONG* Time, ULONG* Check)    {
        return (*m_pshf->pSHGetExeTimeStamp)( pstr, Time, Check );
    }

#endif
    virtual VOID    SHPdbNameFromExe     (LSZ lszExe, LSZ lszPdb, UINT size)    {
        (*m_pshf->pSHPdbNameFromExe)( lszExe, lszPdb, size );
    }

    virtual LPDEBUGDATA SHGetDebugData   (HEXE hexe)    {
        return (LPDEBUGDATA)((*m_pshf->pSHGetDebugData)( hexe ));
    }

    virtual BOOL    SHIsThunk            (HSYM hsym, THUNK_ORDINAL* ord, ULONG* length)    {
        return (*m_pshf->pSHIsThunk)( hsym, ord, length);
    }

    virtual HSYM    SHFindSymInExe       (HEXE hexe, LPSSTR pstr, BOOL flg)    {
        return (*m_pshf->pSHFindSymInExe)( hexe, pstr, flg );
    }

    virtual HSYM    SHFindSLink32        (PCXT pcxt )    {
        return (*m_pshf->pSHFindSLink32)( pcxt );
    }

    virtual BOOL    SHIsDllLoaded        (HEXE hexe)    {
        return (*m_pshf->pSHIsDllLoaded)( hexe );
    }


// Entries added for NT work.

    virtual LSZ     SHGetModule          (PADDR pa, LSZ lsz)    {
        return (*m_pshf->pSHGetModule)( pa, lsz );
    }

    virtual PCXT    SHGetCxtFromHexe     (HEXE hexe, PCXT pcxt)    {
        return (*m_pshf->pSHGetCxtFromHexe)( hexe, pcxt );
    }

    virtual LPCH    SHGetModNameFromHexe (HEXE hexe)    {
        return (*m_pshf->pSHGetModNameFromHexe)( hexe );
    }

    virtual LPCH    SHGetSymFName        (HEXE hexe)    {
        return (*m_pshf->pSHGetSymFName)( hexe );
    }

    virtual HEXE    SHGethExeFromModuleName (LPCH pch)    {
        return (*m_pshf->pSHGethExeFromModuleName)( pch );
    }

    virtual LSZ     SHLszGetErrorText    (SHE she)    {
        return (*m_pshf->pSHLszGetErrorText)( she );
    }

    virtual BOOL    SHWantSymbols        (HEXE hexe)    {
        return (*m_pshf->pSHWantSymbols)( hexe );
    }

    virtual HSYM    SHFindNameInTypes    ( PCXT pcxt, LPSSTR pstr, SHFLAG flg, PFNCMP pfn, PCXT pcxt2 )    {
        return (*m_pshf->pSHFindNameInTypes)( pcxt, pstr, flg, pfn, pcxt2 );
    }


// Entries added for separate type pools work
    virtual BOOL    THAreTypesEqual      (HMOD hmod, CV_typ_t t1, CV_typ_t t2)    {
        return (*m_pshf->pTHAreTypesEqual)( hmod, t1, t2 );
    }


// LoadDllEx is for V7 only (right now)
	virtual SHE     SHLoadDllEx          (LSZ	szName,
											 BOOL	fLoading,
											 ULONG	TimeStamp,
											 ULONG	CheckSum,
											 ULONG	LoadAddress,
											 HEXE*	lphexe)    {
        return (*m_pshf->pSHLoadDllEx)(szName, fLoading, TimeStamp, CheckSum, LoadAddress, lphexe );
    }

											 
// Entries for Edit and Continue work
    virtual LSZ     SHGetSrcPath (HMOD hmod)    {
        return (*m_pshf->pSHGetSrcPath)( hmod );
    }

    virtual LSZ     SHGetObjPath (HMOD hmod)    {
        return (*m_pshf->pSHGetObjPath)( hmod );
    }

    virtual LSZ     SHGetCompileEnv (HMOD hmod)    {
        return (*m_pshf->pSHGetCompileEnv)( hmod );
    }

    virtual BOOL    SHModSupportsEC(HMOD hmod)    {
        return (*m_pshf->pSHModSupportsEC)( hmod );
    }

    virtual BOOL    SHExeSupportsEC (HEXE hexe)    {
        return (*m_pshf->pSHExeSupportsEC)( hexe );
    }

    virtual BOOL    SHModLinkedFromLib (HMOD hmod)    {
        return (*m_pshf->pSHModLinkedFromLib)( hmod );
    }


    virtual BOOL    SHModFromHmod ( HMOD hmod, PHANDLE phandle )    {
        return (*m_pshf->pSHModFromHmod)( hmod, phandle );
    }
    virtual BOOL    SHFlushModSyms( HMOD hmod )    {
        return (*m_pshf->pSHFlushModSyms)( hmod );
    }
    virtual void    SHUseAltPdb ( PFNPDBOpenValidateEx pfn )    {
        (*m_pshf->pSHUseAltPdb)( pfn );
    }
private:
    SHF* m_pshf;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\rwv.cpp ===
/*** RWV.C - Register Window Handler - Varialbe Width
*
*   Copyright (C)1993, Microsoft Corporation
*
*   Purpose: To display ad update the register window
*
*   Revision History:
*        Written by: Mark A. Brodsky
*
*   Notes:
*
*************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

// simple class to switch numeric locales temporarily
#include "locale.h"
class EnglishLocale
{
public:
	EnglishLocale()
	{
		setlocale( LC_NUMERIC, "C" );
	}

	~EnglishLocale()
	{
		setlocale( LC_NUMERIC, "" );
	}
};

void CCpuView :: InitializeMembers() {
	m_hlliRuiUndo = (HLLI)NULL;
	m_hlliRuiRedo = (HLLI)NULL;
	m_hlliRwi = (HLLI)NULL;
	m_hrwiEdit = hrwiNull;
	m_fShowCpu = runDebugParams.fCPURegs;
	m_fShowFlags = runDebugParams.fCPUFlags;
	m_fShowEA = runDebugParams.fCPUEA;
	m_fShowFPU = runDebugParams.fCPUFloat;
	m_obMax = 0;
	m_obMacPrev = 0;
	m_wEM = 0xffff;
	m_wModel = 0xffff;
	m_cEA = 0;
	m_ihrwiEA = (DWORD)-1;

#if defined (_X86_)
	m_cchLongDouble = 0;
#endif	// _X85_

	m_f386Mode = 'a';	// A bogus junk value
}

#ifdef _DEBUG
#undef new
#endif

IMPLEMENT_DYNCREATE( CCpuView, CMultiEdit )

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

UINT CCpuView::g_cRef = 0;
CFontInfo *CCpuView::g_pFontInfo = NULL;

CCpuView :: CCpuView() {
	InitializeMembers();

	if (g_cRef++ == 0)
	{
		g_pFontInfo = new CFontInfo(*(pfmtcatFromDocType((DOCTYPE)CPU_WIN)->pLogFont));
	}

	m_pFontInfo = g_pFontInfo;
    m_dt        = CPU_WIN;

    AddThisToCMEList(this);
}

CCpuView :: ~CCpuView() {
	DestroyInfo();

	if (--g_cRef == 0)
	{
		delete g_pFontInfo;
		g_pFontInfo = NULL;
	}
}

/* spacing for equals sign */
const char	szEqual[] = " = ";
#define cchEqual (sizeof(szEqual)/sizeof(szEqual[0])-1)

size_t CCpuView :: CchFloatFromRwi( LPRWI lprwi ) {
	ASSERT( lprwi->rui.rwf == rwfFloat );

    if ( lprwi->cbit == 32 ) {
        return 13;
    }
    else  if ( lprwi->cbit == 64 ) {
        return 22;
    } else {
#if defined (_X86_)
	if ( !m_cchLongDouble ) {
		FLOAT10	f10 = {0};
		char	sz[ axMax ];

		// Calculate the display width of a FLOAT10.  This doesn't need
		// to be done here, but this will reduce the number of times
		// this gets set

		SzFromLd( sz, sizeof( sz ), f10 );
		m_cchLongDouble = _ftcslen( sz );
	}
	return m_cchLongDouble;
#else // _X86_
	return 0;
#endif	// _X86_
	}
}

BOOL CCpuView :: FIsVisible( HRWI hrwi ) {
	BOOL	fRet;
	LPRWI	lprwi;

	ASSERT( hrwi );

	lprwi = (LPRWI)LLLpvFromHlle( hrwi );

	if(lprwi->rui.ut.rt & rtInvisible) {
		fRet = FALSE;
	} else switch( lprwi->rui.rwf ) {
		case rwfEffAddr:
		case rwfEffAddrOnly:
		case rwfEffData:
			fRet = m_fShowEA;
			break;

		case rwfFloat:
		case rwfHexReg:
			if ( lprwi->rui.ut.rt & rtFPU ) {
				fRet = m_fShowFPU;
			}
			else {
				fRet = m_fShowCpu;
			}
			break;

		case rwfFlag:
			fRet = m_fShowFlags;
			break;

		default:
			fRet = FALSE;
			break;
	}

	UnlockHlle( hrwi );

	return fRet;
}


void CCpuView :: UpdateDocInfo() {
	// Undo list isn't empty
	if ( m_hlliRuiUndo && LLChlleInLl( m_hlliRuiUndo ) ) {

		// If redo list isn't empty, playCount = 1 enables
		// both, == 0 disables REDO
		if ( m_hlliRuiRedo && LLChlleInLl(m_hlliRuiRedo) )
        {
			m_mePlayCount = 1;
		}
		else
        {
			m_mePlayCount = 0;
		}
		m_undoBuffer = ubUndo;
		m_undoState = usNormal;
	}

	// No undo, just redo, playcount < = disables UNDO, enables REDO
	else if ( m_hlliRuiRedo && LLChlleInLl( m_hlliRuiRedo ) )
    {
		m_mePlayCount = -1;
		m_undoBuffer = ubUndo;
		m_undoState = usNormal;
	}

	// Default, nothing to undo or redo
	else
    {
		m_mePlayCount = -1;
		m_undoState = usSuspendedError;
	}
}

void CCpuView :: SaveForUndo( LPRUI	lpruiSet ) {

	// Make sure that there's an undo list available
    if ( !m_hlliRuiUndo ) {
        m_hlliRuiUndo = LLHlliInit( sizeof( RUI ), llfNull, NULL, NULL );
    }

    // If we're allowed to undo this change and there's a list
    // add change to list...

    if ( m_hlliRuiUndo ) {
        HRUI    hrui;

        if ( hrui = LLHlleCreate( m_hlliRuiUndo ) ) {
            LPRUI   lprui = (LPRUI)LLLpvFromHlle( hrui );

            *lprui = *lpruiSet;

			// The cached value may already be changed,
			// so get the real value from OSDEBUG
			switch( lprui->rwf ) {
				case rwfFloat:
				case rwfHexReg:
					OSDReadRegister(
						hpidCurr,
						htidCurr,
						lprui->hReg,
						lprui->ur.rgb
					);
					break;

				case rwfFlag:
					OSDReadFlag(
						hpidCurr,
						htidCurr,
						lprui->iFlag,
						&lprui->ur.ul
					);
					break;

				case rwfEffData:
				case rwfEffAddr:
					DHGetDebuggeeBytes(
						lprui->addrEA,
						lprui->cbEA,
						&lprui->ur.rgb
					);
					FlipBytes(
						(BYTE *)&lprui->ur.rgb,
						lprui->cbEA
					);
					break;

			}

            UnlockHlle( hrui );
            LLAddHlleToLl( m_hlliRuiUndo, hrui );

			// New edits destroy the Redo list
    		if ( m_hlliRuiRedo ) {
		        LLChlleDestroyLl( m_hlliRuiRedo );
		        m_hlliRuiRedo = (HLLI)NULL;
			}

			UpdateDocInfo();
        }
    }
}

void CCpuView :: WriteReg(
LPRUI		lprui,
LPUR		lpur) {
	ADDR		addrPCCur;
	ADDR		addrPCNew;
	WORD		UpdateFlags = UPDATE_ALLDBGWIN;

	// Save PC before register change
	SYGetAddr( hpidCurr, htidCurr, adrPC, (LPADDR)&addrPCCur ) ;

	// Here we have to get to the child directly to make the change
    switch( lprui->rwf ) {
    	case rwfEffAddr:
	    case rwfEffData: {
			BYTE	rgb[ cbRegMax ];

			ASSERT( lprui->cbEA <= cbRegMax );
			memcpy( rgb, lpur->rgb, lprui->cbEA );
			FlipBytes( rgb, lprui->cbEA );
			DHPutDebuggeeBytes(
				lprui->addrEA,
				lprui->cbEA,
				(char FAR *)rgb
			);
            break;
		}

		case rwfFloat:
			OSDWriteRegister(
				hpidCurr,
				htidCurr,
				lprui->hReg,
				lpur->rgb
			);
	        break;

	    case rwfHexReg:
			OSDWriteRegister(
				hpidCurr,
				htidCurr,
				lprui->hReg,
				&lpur->ul
			);
	        break;

        case rwfFlag:
        	OSDWriteFlag(
    	        hpidCurr,
	            htidCurr,
                lprui->iFlag,
        	    (VOID FAR *)&lpur->ul
    	    );
	        break;
    }

	// Get new PC
	SYGetAddr( hpidCurr, htidCurr, adrPC, &addrPCNew );
	if ( !FAddrsEq( addrPCCur, addrPCNew ) ) {
		// Need to update source window
		UpdateFlags |= UPDATE_SOURCE;

		// Make sure that the cxfIp is also updated
		set_addrs();
	}

	// Update all of the windows since the edit may have altered data
	UpdateDebuggerState( UpdateFlags );
}

void CCpuView :: FlushEdit( BOOL fThrowOut ) {
	if ( m_hrwiEdit ) {
		if ( fThrowOut ) {
			LPRWI	lprwi = (LPRWI)LLLpvFromHlle( m_hrwiEdit );

			if ( lprwi->rui.rwf == rwfEffAddr ||
				lprwi->rui.rwf == rwfEffData
			) {
				DHGetDebuggeeBytes(
					lprwi->rui.addrEA,
					lprwi->rui.cbEA,
					lprwi->rui.ur.rgb
				);

				FlipBytes( (BYTE *)lprwi->rui.ur.rgb, lprwi->rui.cbEA );
			}
			else {
	            OSDReadRegister(
					hpidCurr,
					htidCurr,
					lprwi->rui.hReg,
					lprwi->rui.ur.rgb
				);
			}

			if ( FIsVisible( m_hrwiEdit ) ) {
				DrawLine( lprwi->oln );
			}

			UnlockHlle( m_hrwiEdit );
			m_hrwiEdit = hrwiNull;
		}
		else {
			RUI	rui = ((LPRWI)LLLpvFromHlle( m_hrwiEdit ))->rui;

			UnlockHlle( m_hrwiEdit );
			m_hrwiEdit = hrwiNull;

			SaveForUndo( &rui );

			WriteReg( &rui, &rui.ur );
		}
	}
}


/**** NextField                                                         ****
 *                                                                         *
 *  PURPOSE: Move the cursor to the next field in the window               *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: NextField() {

    DWORD   oln = OlnGetCurPos();
    WORD    ob = ObGetCurPos();
    HRWI    hrwi = hrwiNull;
    BOOL    fFound = FALSE;
    BOOL    fForce = FALSE;

    while( !fFound && ( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) ) {
		if ( FIsVisible( hrwi ) ) {
	        LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

    	    // If we've gone beyond the end of the data which is on the line
        	// of the cursor, change the current position so that the current
	        // item will be selected.
    	    if ( oln < lprwi->oln ) {
        	    oln = lprwi->oln;
            	fForce = TRUE;
	        }

    	    // Don't allow cursor to be set on EffAddrOnly field since there is
        	// no editable data
	        if ( lprwi->rui.rwf != rwfEffAddrOnly &&
    	        oln == lprwi->oln &&
	            ( fForce || ob < lprwi->obValMin ) ) {

    	        SetCursorAt( lprwi->obValMin, lprwi->oln );
        	    fFound = TRUE;
	        }

    	    UnlockHlle( hrwi );
		}
    }

    // If the next item hasn't been found, then we've reached the bottom.
    // Just get the first item in the list and put the cursor there
    if ( !fFound ) {
        ASSERT( !hrwi );

        while( !fFound && ( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) ) {
			if ( FIsVisible( hrwi ) ) {
	        	LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

		        SetCursorAt( lprwi->obValMin, lprwi->oln );
    		    UnlockHlle( hrwi );
				fFound = TRUE;
			}
		}
    }
}


/**** PrevField                                                         ****
 *                                                                         *
 *  PURPOSE: Move the cursor to the previous field in the window           *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: PrevField() {
    DWORD   oln = OlnGetCurPos();
    WORD    ob = ObGetCurPos();
    HRWI    hrwi = LLHlleGetLast( m_hlliRwi );
    BOOL    fFound = FALSE;

    // When the list was created, we added a prev pointer so this would
    // be much easier!

    do {
        LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

		if ( FIsVisible( hrwi ) ) {

			// Set to the previous line if no prev entry on current
			// line.  Set ob to end of line so we can find the
			// last entry on the new line
    	    if ( oln > lprwi->oln ) {
        	    oln = lprwi->oln;
            	ob = (WORD)-1;
	        }

    	    // Don't allow cursor to move to the EffAddrOnly field since there
        	// is no editable data there.
	        if ( lprwi->rui.rwf != rwfEffAddrOnly &&
    	        oln == lprwi->oln &&
	            ob >= lprwi->obValMac ) {

    	        SetCursorAt( lprwi->obValMin, lprwi->oln );
        	    fFound = TRUE;
			}
		}
       	UnlockHlle( hrwi );
        hrwi = lprwi->hrwiPrev;

    } while( !fFound && hrwi );

    // If not found, we're trying to go past the top, just get the last item
    // (always valid) and put the cursor there
    if ( !fFound ) {
		HRWI	hrwiLast = hrwiNull;
        ASSERT( !hrwi );

		while( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) {
			if ( FIsVisible( hrwi ) ) {
				hrwiLast = hrwi;
			}
		}

		if ( hrwiLast ) {
	        LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwiLast );

        	SetCursorAt( lprwi->obValMin, lprwi->oln );
	        UnlockHlle( hrwiLast );
		}
    }
}


/**** SetReg                                                            ****
 *                                                                         *
 *  PURPOSE: Change/set a register, flag, or PCode stack item.             *
 *                                                                         *
 *  INPUTS:                                                                *
 *      lpur    Union containing long/rgb[10] to change data to            *
 *      fUndo   Flag indicating if SetReg is being called from UNDO.       *
 *              If in undo, then don't save change.                        *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: SetReg(
LPUR		lpur,
HRUI        hruiSet,
BOOL        fUndo ) {
    LPRUI   lpruiSet = (LPRUI)LLLpvFromHlle( hruiSet );

    // Unlock the ruiSet since update destroys the hrwi if it's an EA thing!
    UnlockHlle( hruiSet );

	// If we need to save the change so we can undo....
	// rwfHexReg will be saved un FlushEdit
	if ( !fUndo ) {
	    // Here we have to get to the child directly to make the change
		memcpy( lpruiSet->ur.rgb, lpur->rgb, cbRegMax );
		m_hrwiEdit = (HRWI)hruiSet;

		// When not undo, the HRUISET is really an HRWI!
		DrawLine( ((LPRWI)lpruiSet)->oln );
	}
 	else {
		WriteReg( lpruiSet, lpur );
	}
}


/**** UndoValue                                                         ****
 *                                                                         *
 *  PURPOSE: Undo the user's last change and position cursor.              *
 *                                                                         *
 *  INPUTS:                                                                *
 *      fRedo   TRUE = redo, FALSE = undo                                  *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: UndoValue(
BOOL	fRedo ) {
	HLLI	hlliFrom;
	HLLI *	phlliTo;

	if ( fRedo ) {
		hlliFrom = m_hlliRuiRedo;
		phlliTo = &m_hlliRuiUndo;
	}
	else {
		hlliFrom = m_hlliRuiUndo;
		phlliTo = &m_hlliRuiRedo;
	}

    // Make sure that there's something to undo!
    if ( hlliFrom ) {
        HRUI    hrui = LLHlleGetLast( hlliFrom );

        if ( hrui ) {
            LPRUI   lprui = (LPRUI)LLLpvFromHlle( hrui );
            BOOL    fFound = FALSE;
            HRWI    hrwi = hrwiNull;
            WORD    ob;
            DWORD   oln;
			UR		ur;
			BOOL	fVisible;

            ASSERT( m_hlliRwi );

            // Also, make sure that we CAN undo.  If the register
            // set is changed (ie options.native...), we won't allow
            // undos from the old register set.

            while( !fFound && ( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) ) {
                LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

                if ( lprwi->rui.hReg == lprui->hReg &&
                    lprwi->rui.rwf == lprui->rwf &&
                    lprwi->rui.iFlag == lprui->iFlag ) {

					// If the undo item is an EA item, make sure that
					// we have a match
					if ( lprui->rwf != rwfEffAddr &&
						lprui->rwf != rwfEffData ||
						lprwi->cbit &&
						FAddrsEq( lprwi->rui.addrEA, lprui->addrEA )
					) {
	                    fFound = TRUE;
	                    ob = lprwi->obValMin;
	                    oln = lprwi->oln;
						ur = lprwi->rui.ur;
						fVisible = FIsVisible( hrwi );
					}
                }
                UnlockHlle( hrwi );
            }

            if ( fFound ) {
	            SetReg( &lprui->ur, hrui, TRUE );
				if ( fVisible ) {
                	SetCursorAt( ob, oln );
				}

				// Save value which was just overridden so the reverse
				// operation has the correct data
				lprui->ur = ur;
            }
            UnlockHlle( hrui );

			if ( !*phlliTo ) {
				*phlliTo = LLHlliInit( sizeof( RUI ), llfNull, NULL, NULL );
			}

			if ( *phlliTo ) {
				// Just move the node fro, one list to another
				LLFRemoveHlleFromLl( hlliFrom, hrui );
				LLAddHlleToLl( *phlliTo, hrui );
			}
			else {
	            // Remove the undone value from the list.
            	LLFDeleteHlleFromLl( hlliFrom, hrui );
			}
        }
        else {
            MessageBeep( 0 );
        }
    }
    else {
        MessageBeep( 0 );
    }

	UpdateDocInfo();
}


/**** RwfFieldType                                                      ****
 *                                                                         *
 *  PURPOSE: Determine the field type which the cursor is on top of        *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *      *phrwi  sets phrwi to the handle for the register struct           *
 *                                                                         *
 *      Return Value: Type of field                                        *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
RWF CCpuView :: RwfFieldType(
HRWI *  phrwi ) {
    RWF     rwf = rwfNone;

	if ( m_hlliRwi ) {
    	DWORD   oln = OlnGetCurPos();
	    WORD    ob = ObGetCurPos();
	    HRWI    hrwi = hrwiNull;
    	BOOL    fFound = FALSE;

	    // Search for the rwi which is at the current location and if cursor
    	// is inside of its editable data area, return its rwf

	    while( !fFound && ( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) ) {
    	    LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

        	if ( oln == lprwi->oln ) {
				if ( lprwi->obValMin <= ob && ob < lprwi->obValMac ) {
	        	    fFound = TRUE;
    	        	*phrwi = hrwi;
	    	        rwf = lprwi->rui.rwf;
				}

				// Text part of a value
				else if ( lprwi->obSzMin <= ob && ob < lprwi->obValMin ) {
	        	    fFound = TRUE;
    	        	*phrwi = hrwi;
	    	        rwf = rwfText;
				}
    	    }
        	UnlockHlle( hrwi );
	    }
	}

    return rwf;
}


/**** ToggleFlag                                                        ****
 *                                                                         *
 *  PURPOSE: Flip the flag that the cursor is sitting on.                  *
 *                                                                         *
 *  INPUTS:                                                                *
 *      hrwi    handle of register(flag) to flip                           *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: ToggleFlag(
HRWI    hrwi ) {
    LPRWI   lprwi;
	UR		ur = {0};

    ASSERT( hrwi );
    lprwi = (LPRWI)LLLpvFromHlle( hrwi );
    ASSERT( lprwi->rui.rwf == rwfFlag );

    ur.ul = !lprwi->rui.ur.ul;

    UnlockHlle( hrwi );

    SetReg( &ur, (HRUI)hrwi, FALSE );
}

/**** CbGetLineBuf                                                      ****
 *                                                                         *
 *  PURPOSE: Get a specific display line and return to edit manager        *
 *                                                                         *
 *  INPUTS:                                                                *
 *      oln     Line number requested                                      *
 *      cbMax   Size of destination buffer                                 *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *      szBuf   Data space to put display line                             *
 *                                                                         *
 *      Return Value: _ftcslen( szBuf )                                    *
 *                                                                         *
 *  IMPLEMENTATION: Format appropriate data and create m_rgla which will   *
 *                  be returned to edit manager in GetLineAttrs()          *
 *                                                                         *
 ***************************************************************************/
WORD CCpuView :: CbGetLineBuf(
DWORD   oln,
WORD    cbMax,
char *  szBuf,
PDLA &	pdla
) {
	*szBuf = '\0';

	if ( m_hlliRwi ) {
		char *		pszFmt;
		char *		pszFmtNibble;
		HRWI        hrwi = hrwiNull;
		char *      psz = szBuf;
		int			cReg = (int)LLChlleInLl( m_hlliRwi );
		BOOL		fDone = FALSE;
	 	FMT_ELEMENT *rgfmtel = pfmtelFromDocType((DOCTYPE)CPU_WIN);
		FMT_ELEMENT *fmtelValue = &(rgfmtel[FMTEL_TEXT]);
		FMT_ELEMENT *fmtelHilight = &(rgfmtel[FMTEL_RGHI]);

		pdla = m_rgdla;
		pszFmt = "%02X";
		pszFmtNibble = "%01X";

		// Loop through the rwi's in the window and pick off
		// what should be on this line
		while( !fDone && ( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) ) {
			LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

			// If the item is hidden (not selected), don't bother
			if ( FIsVisible( hrwi ) ) {
				// Include the item if it belongs on this line
				// and won't cause a buffer overflow
				if ( oln == lprwi->oln && lprwi->obValMac < cbMax ) {
					BOOL    fChanged = FALSE;
					RWF		rwf = lprwi->rui.rwf;

					// Check for differences for everything except
					// EA addr string only or EAs with invalid addresses
					if (
						rwf == rwfEffAddr && lprwi->cbit ||
						rwf == rwfEffData && lprwi->cbit ||
						rwf != rwfEffAddr &&
						rwf != rwfEffAddrOnly &&
						rwf != rwfEffData
					) {
						fChanged = memcmp(
							&lprwi->rui.ur,
							&lprwi->urDiff,
							lprwi->cbit / 8
						);
					}

					// Flags treated specially (no spaces between flagname
					// and value)
					if ( rwf == rwfFlag ) {
						WORD	cch = sprintf( psz, " %Fs=", lprwi->lsz );

						psz += cch;
						pdla->cb = cch;
						pdla->pElement = fmtelValue;

						psz += sprintf( psz, pszFmtNibble, lprwi->rui.ur.ul );
						if ( fChanged ) {
							++pdla;
							pdla->cb = 1;
							pdla->pElement = fmtelHilight;
						}
						else {
							++pdla->cb;
						}
						++pdla;
					}

					// Floating point value.  Display as +x.yyyyy+eeee
					else if ( rwf == rwfFloat ) {
						char *	pszBefore = psz;
						size_t	cch;
						size_t	cchFloat;

						psz += sprintf(
							psz,
							" %Fs%s",
							lprwi->lsz,
							szEqual
						);	
						pdla->cb = _ftcslen( pszBefore );
						pdla->pElement = fmtelValue;

						cchFloat = CchFloatFromRwi( lprwi );

                        if (lprwi->cbit == 32) {
                            sprintf(
	                            psz,
	                            "%+.5E",
	                            *( UNALIGNED float * ) lprwi->rui.ur.rgb
                            );
                        } else if (lprwi->cbit == 64) {
                            sprintf(
	                            psz,
	                            "%+.14LE",
	                            *( UNALIGNED double * ) lprwi->rui.ur.rgb
                            );
                        } else if (lprwi->cbit == 80) {
							SzFromLd(
								psz,
								cchFloat + 1,
								*(FLOAT10 *)lprwi->rui.ur.rgb
							);
                        } else {
                            ASSERT(FALSE);
                        }

						cch = strlen( psz );
                        if (cch < cchFloat) {
                            memset( psz + cch, ' ', cchFloat - cch );
                        }
						psz += cchFloat;
						if ( fChanged ) {
							++pdla;
							pdla->pElement = fmtelHilight;
							pdla->cb = cchFloat;
						}
						else {
							pdla->cb += cchFloat;
						}

						++pdla;
					}

					// Hexadecimal value.  Handle all cases of power of 2 bytes
					// up to cbRegMax
					else {
						WORD        cb = lprwi->cbit / 8;
						BYTE FAR *  lpb = (BYTE FAR *)&lprwi->rui.ur.rgb + cb - 1;

						// EffData does not have the string on the same line,
						// so, don't include it
						if ( rwf != rwfEffData ) {
							int	cch;

							cch = sprintf(
								psz,
								" %Fs",
								lprwi->lsz
							);

							psz += cch;
							pdla->cb = cch;
						}
						else {
							*psz++ = ' ';
							pdla->cb = 1;
						}
						pdla->pElement = fmtelValue;

						// EffAddrOnly and EffData do
						// not have both text and value,
						// so no need to include the '='
						// seperator
						if ( rwf != rwfEffAddrOnly &&
							rwf != rwfEffData
						) {

							_ftcscat( psz, szEqual );
							psz += cchEqual;
							pdla->cb += cchEqual;
						}
						++pdla;

						// effAddrOnly has no value, just text
						if ( lprwi->rui.rwf != rwfEffAddrOnly ) {
							WORD	cbT = cb << 1;

							// This case will cover everything
							// except EAs with invalid addresses
							if ( cb ) {
								while( cb-- ) {
								    psz += sprintf(
								        psz,
								        pszFmt,
								        *lpb--
								    );
								}
							}
							else {
								// EA with invalid address.  Fill
								// with corresponsing number of '?'
								// to coinside with the number of
								// hex digits to display the value
								// if there was one
								cbT = lprwi->rui.cbEA << 1;
								memset( psz, '?', cbT );
								psz += cbT;
							}

							if ( fChanged ) {
								pdla->pElement = fmtelHilight;
								pdla->cb = cbT;
							}
							else {
								--pdla;
								pdla->cb += cbT;
							}
							++pdla;
						}
					}
				}
				
				// If the node's line number is greater than the
				// requested line, then no need to go on since
				// the nodes are increasing in line number
				else if ( lprwi->oln > oln ) {
					fDone = TRUE;
				}
			}
			pdla->pElement = fmtelValue;
			pdla->cb = 0xffff;

			*psz = '\0';
			UnlockHlle( hrwi );
		}
	}

	pdla = m_rgdla;
	return _ftcslen( szBuf );
}


/**** ObMaxBuf                                                          ****
 *                                                                         *
 *  PURPOSE: Get the max number of characters in the buffer                *
 *                                                                         *
 *  INPUTS:                                                                *
 *      hBuf    Window Id of parent window                                 *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: Number of characters (max) for the register window   *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
WORD CCpuView :: ObMaxBuf() {
    return m_obMax;
}


/**** CLinesInBuf                                                       ****
 *                                                                         *
 *  PURPOSE: Get the number of lines in the buffer                         *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: Number of lines in the register window               *
 *                                                                         *
 *  IMPLEMENTATION: The last item in the rwi list will have a cooridnate   *
 *  oln for the last line in the window.  Add 1 to it so it becomes a count*
 *  instead of an index                                                    *
 *                                                                         *
 ***************************************************************************/
DWORD CCpuView :: CLinesInBuf() {
    DWORD   dwRet = 0;

    if ( m_hlliRwi ) {
		HRWI	hrwi = hrwiNull;

		while( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) {
			if ( FIsVisible( hrwi ) ) {
		        LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

    		    dwRet = lprwi->oln + 1;

        		UnlockHlle( hrwi );
			}
		}
    }
    return dwRet;
}

BOOL CCpuView :: FDoKeyDown(
WPARAM	wParam,
LPARAM	lParam ) {
	BOOL	fUseEM = TRUE;

	switch( wParam ) {
		case VK_TAB:
			if ( m_hlliRwi ) {
				FlushEdit( FALSE );
    		    if ( HIWORD( lParam ) & KK_SHIFT ) {
				    PrevField();
	        	}
	    	    else {
    				NextField();
				}
	        }
			break;

		case VK_BACK:
		case VK_DELETE:
			MessageBeep( 0 );
			fUseEM = FALSE;
			break;

		case VK_LEFT:
		case VK_RIGHT:
			if ( m_hrwiEdit ) {
				HRWI	hrwi;
				WORD	ob = ObGetCurPos();
				WORD	obPrev = ob;

				// Set cursor in appropriate direction
				// since RwfFieldType uses current
				// cursor position to determine what
				// hrwi we really want.  Avoid sign
				// changes from incr and decr
				if ( wParam == VK_RIGHT ) {
					if ( ob + 1 < (WORD)-1 ) {
						++ob;
					}
				}
				else {
					if ( ob > 0 ) {
						--ob;
					}
				}

				// This does NOT update the UI
				SetCurObPos( ob );

				RwfFieldType( &hrwi );

				// Reset the cursor pos to the
				// original
				SetCurObPos( obPrev );

				if ( hrwi != m_hrwiEdit ) {
					FlushEdit( FALSE );
				}
			}
			break;

		case VK_ESCAPE:
			FlushEdit( TRUE );
			fUseEM = FALSE;
			break;

		case VK_UP:
		case VK_DOWN:
		case VK_END:
		case VK_HOME:
		case VK_NEXT:
		case VK_PRIOR:
		case VK_RETURN:
			FlushEdit( FALSE );
			break;
	}

	return fUseEM;
}

/**** FDoChar                                                           ****
 *                                                                         *
 *  PURPOSE: Process character input for the register window.  This        *
 *           function will be called when a WM_CHAR is received by the     *
 *           Register Window WndProc.                                      *
 *                                                                         *
 *  INPUTS:                                                                *
 *      wParam  ASCII value of WM_CHAR (see CW docs)                       *
 *      lParam  Untranslated character info along with ctrl/shift/alt state*
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: TRUE if the edit manager is to get the message.      *
 *                    If FALSE is returned, the character input has been   *
 *                    'eaten' and should NOT be passed on the the edit mgr.*
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
BOOL CCpuView :: FDoChar(
WPARAM	wParam,
LPARAM	lParam ) {
	BOOL fUseEM = TRUE;
	char szSel[ 2 ];
	EnglishLocale SetTheLocaleToC;//This sets the functions locale to "C"

	// [dolphin#5001 12/30/93 mikemo]
	if ( wParam == TAB || wParam == CR ) {
		fUseEM = FALSE;
	}
	else if ( DebuggeeRunning() ||
		GetEditSelection( sizeof( szSel ), szSel ) ||
		!_istprint( wParam )
	) {
		MessageBeep( 0 );
		fUseEM = FALSE;
	}
	else {
		RWF     rwf;
		HRWI    hrwi;
		char *	szBuf = (char *)alloca( m_obMax + 1 );

		ASSERT( szBuf );

		fUseEM = FALSE;

		// Normal input here!
		switch( rwf = RwfFieldType( &hrwi ) ) {
			case rwfText:
			case rwfNone:
				fUseEM = FALSE;
				MessageBeep( 0 );
				break;

			case rwfFlag:
				if ( wParam == (WORD)(unsigned char)'0' ||
					wParam == (WORD)(unsigned char)'1'
				) {

					UR	ur = {0};
#ifdef _DEBUG
					LPRWI	lprwi = (LPRWI)LLLpvFromHlle( hrwi );

					ASSERT( lprwi->cbit == 1 );
					UnlockHlle( hrwi );
#endif	// _DEBUG

					ur.ul = (ULONG)( wParam == (WORD)(unsigned char)'1' );
					SetReg( &ur, (HRUI)hrwi, FALSE );

					CMultiEdit::LTextProc( WM_KEYDOWN, VK_RIGHT, 0L );
				}
				else if ( wParam == VK_SPACE ) {
					ToggleFlag( hrwi );
					FlushEdit( FALSE );
					fUseEM = FALSE;
				}
				else {
					MessageBeep( 0 );
				}
				break;

			case rwfEffAddr:
			case rwfEffData: {
				LPRWI	lprwi = (LPRWI)LLLpvFromHlle( hrwi );
				WORD	cbEA = lprwi->cbit * 8;

				UnlockHlle( hrwi );

				if ( cbEA == 0 ) {
					MessageBeep( 0 );
					break;
				}
			}
				// fall through

			case rwfHexReg: {
				LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

				if ( _istxdigit( wParam ) ) {
					WORD    ob = ObGetCurPos();
					WORD    obIns = ob;
					WORD    obMac;
					char *  pch;
					UR      ur = { 0 };
					char    rgch[ 3 ];
					BYTE *  pb = ur.rgb + lprwi->cbit / 8 - 1;
					PDLA	pdla;

					CbGetLineBuf( OlnGetCurPos(), m_obMax + 1, szBuf, pdla );

					*( szBuf + ob ) = LOBYTE( wParam );

					obMac = lprwi->obValMac;
					obIns = lprwi->obValMin;
					pch = szBuf + obIns;
					rgch[ 2 ] = '\0';

					while( obIns < obMac ) {
						WORD    wT;

						_ftcsncpy( rgch, pch, 2 );
						sscanf( rgch, "%hX", &wT );
						*pb = LOBYTE( wT );
						--pb;
						pch += 2;
						obIns += 2;
					}

					// Unlock here since SetReg will destroy
					// hrwi if it's an EA thing!
					UnlockHlle( hrwi );
					SetReg( &ur, (HRUI)hrwi, FALSE );
					CMultiEdit::LTextProc( WM_KEYDOWN, VK_RIGHT, 0L );
				}
				else {
					UnlockHlle( hrwi );
					MessageBeep( 0 );
				}
				break;
			}

			case rwfFloat: {
				LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );
				BOOL    fOK = TRUE;
				WORD    ob = ObGetCurPos();
				char    ch;
				PDLA	pdla;

				CbGetLineBuf( OlnGetCurPos(), m_obMax + 1, szBuf, pdla );

				ch = *( szBuf + ob );

				if ( ch == '+' || ch == '-' ) {
					fOK =
						(BOOL)( (char)wParam == '+' || (char)wParam == '-' );
				}
				else if ( ch == 'E' || ch == 'e' ) {
					fOK =
						(BOOL)( (char)wParam == 'E' || (char)wParam == 'e' );
				}
				else if ( ch == '.' ) {
					fOK = (BOOL)( (char)wParam == '.' );
				}
				else if ( !_istdigit( wParam ) ) {
					fOK = FALSE;
				}

				if ( fOK ) {
					WORD    obIns;
					WORD    obMac;
					char *  pch;
					UR      ur = { 0 };

					*( szBuf + ob ) = LOBYTE( wParam );

                    obMac = lprwi->obValMac;
                    obIns = lprwi->obValMin;
                    pch = szBuf + obIns;
                    *( szBuf + obMac ) = '\0';

                    if (lprwi->cbit == 64) {
						sscanf( pch, "%le", (UNALIGNED double *)ur.rgb );
					}
					else if ( lprwi->cbit == 32 ) {
						sscanf( pch, "%e", (UNALIGNED float *)ur.rgb );
					}
					else if ( lprwi->cbit == 80 ) {
						char *	pchRet;
						*(FLOAT10 *)ur.rgb = LdFromSz( pch, &pchRet );
					} 
					else {
						ASSERT (FALSE);
					}

					// Unlock here since SetReg will destroy
					// hrwi if it's an EA thing!
					UnlockHlle( hrwi );

					SetReg( &ur, (HRUI)hrwi, FALSE );

					CMultiEdit::LTextProc( WM_KEYDOWN, VK_RIGHT, 0L );
				}
				else {
					MessageBeep( 0 );
				}
				break;
			}
		}
	}

	return fUseEM;
}


/**** Freeze                                                            ****
 *                                                                         *
 *  PURPOSE: Save the current state of the register window for showing     *
 *           differences between execution of the child.                   *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: Freeze() {

	FlushEdit( FALSE );
    if ( m_hlliRwi ) {
        WORD    creg = (WORD)LLChlleInLl( m_hlliRwi );
        HRWI    hrwi = hrwiNull;

        // Copy all of the old values
        while( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) {
	        LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

	        lprwi->urDiff = lprwi->rui.ur;
    	    UnlockHlle( hrwi );
		}
    }

    // We don't allow undo's across execs, so empty the list
    if ( m_hlliRuiUndo ) {
        LLChlleDestroyLl( m_hlliRuiUndo );
        m_hlliRuiUndo = (HLLI)NULL;
	}

	if ( m_hlliRuiRedo ) {
        LLChlleDestroyLl( m_hlliRuiRedo );
        m_hlliRuiRedo = (HLLI)NULL;
    }

	UpdateDocInfo();
}


/**** RecalcCoords                                                      ****
 *                                                                         *
 *  PURPOSE: Recalculate rwi cooridnates for variable width display        *
 *                                                                         *
 *  INPUTS:                                                                *
 *      fRealign    Process this message during WM_SIZE, allow items to    *
 *                  move.  Otherwise, just adding an ea into a blank line  *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *  NOTE: This implementation is directly tied to CbGetLineBuf.  Any       *
 *        changes here should be echoed there also.                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: RecalcCoords(
BOOL fRealign  ) {

    ASSERT( m_hWnd );

	m_obMax = 0;

    // Must have a list or rwis
    if ( m_hlliRwi ) {
        HRWI    hrwi = hrwiNull;
        WORD    obMac;
		DWORD	iReg = 0;
   	    WORD    ob = 1;
   		DWORD   oln = 0L;
		DWORD	dwGrpCur = (DWORD)rwfNone;

		if ( fRealign || !m_obMacPrev ) {
	        // Ensure that the data in the window has a valid width
        	obMac = max( min( WinWidth(), (WORD)axMax ), 1 );
			m_obMacPrev = obMac;
		}
		else {
			obMac = m_obMacPrev;
		}

        while( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) {
			if ( FIsVisible( hrwi ) ) {
			    LPRWI   lprwi;
				WORD    cch;
    	        WORD    cchDisp;
				BOOL	fInsertExtraLine = FALSE;

	            lprwi = (LPRWI)LLLpvFromHlle( hrwi );

    	        cch = _ftcslen( lprwi->lsz );

                // Room for the '='
				if ( lprwi->rui.rwf == rwfFlag ) {
					++cch;
				}
				else {
   	            	cch += cchEqual;
				}

				if ( lprwi->rui.rwf == rwfFloat ) {
					cchDisp = CchFloatFromRwi( lprwi );
				}
				else if ( lprwi->cbit ) {
    	            // The display bytes are number of nibbles.
   	    	        cchDisp = max( lprwi->cbit / 4, 1 );
				}
				// EA on invalid or unevaluateable address
				else {
					cchDisp = lprwi->rui.cbEA * 2;  // number of '?' to display
				}

				// We previously displayed the EA address and data on
				// different lines.  Merge them back together so we
				// can reset
				if ( lprwi->rui.rwf == rwfEffAddrOnly ) {
					HRWI	hrwiNext = LLHlleFindNext( m_hlliRwi, hrwi );
					LPRWI	lprwiNext;

					ASSERT( hrwiNext );
					lprwiNext = (LPRWI)LLLpvFromHlle( hrwiNext );
					*lprwi = *lprwiNext;
					lprwi->rui.rwf = rwfEffAddr;
					UnlockHlle( hrwiNext );
					LLFDeleteHlleFromLl( m_hlliRwi, hrwiNext );
					if ( lprwi->cbit ) {
	   	    	        cchDisp = lprwi->cbit / 4;
					}
					else {
						cchDisp = lprwi->rui.cbEA * 2;
					}
				}

				if ( dwGrpCur != (DWORD)rwfNone &&
					dwGrpCur != lprwi->dwGrp
				) {
					if ( ob == 1 ) {
						++oln;
					}
					else {
						oln += 2;
					}
					ob = 1;
				}
				dwGrpCur = lprwi->dwGrp;

        	    // If the item is an EffAddr (addr and data) AND it doesn't
	            // fit on the current line any longer, create a EffData and
    	        // make this the EffAddrOnly to have a two line display of the EA
        	    if ( lprwi->rui.rwf == rwfEffAddr ) {

					// Only allow EA splitting when there is only 1 EA.  Otherwise,
					// the display will get real ugly!
					if ( m_cEA == 1 && obMac && ob + cch + cchDisp > obMac ) {
        	            HRWI    hrwiNew = LLHlleCreate( m_hlliRwi );

            	        if ( hrwiNew ) {
                	        LPRWI   lprwiNew = (LPRWI)LLLpvFromHlle( hrwiNew );

                    	    *lprwiNew = *lprwi;
                        	lprwiNew->rui.rwf = rwfEffData;

	                        lprwi->rui.rwf = rwfEffAddrOnly;
	                        if ( ob ) {
        	                    ob = 1;
            	            }
                    	    lprwi->oln = oln++;
                	        lprwi->obSzMin = ob;
                        	lprwi->obValMac = lprwi->obValMin = ob + cch;
	                        lprwi->cbit = 0;
    	                    lprwiNew->hrwiPrev = hrwi;
        	                ob = 1;
            	            cch = 0;

							m_obMax = max( m_obMax, lprwi->obValMac );

                    	    UnlockHlle( hrwi );
                        	LLInsertHlleInLl( m_hlliRwi, hrwiNew, m_ihrwiEA + 1 );
	                        hrwi = hrwiNew;
    	                    lprwi = lprwiNew;
        	            }
            	    }
					else if ( ( fIn386Mode && obMac < 32 ) ||
						( !fIn386Mode && obMac < 16 )
					) {
						fInsertExtraLine = TRUE;
					}
            	}

	            // See if the item will fit on the current line.
    	        // If not, reset to the beginning of the next line
                // v-vadimp or it has to be on a new line
                if ( (ob > 1 && ob + cch + cchDisp > obMac) || (lprwi->rui.ut.rt & rtNewLine)) { 
            	    ob = 1;
                	++oln;
	            }

    	        // Beginning of the display string (ie "EAX")
        	    lprwi->obSzMin = ob;

               	// Nothing special here, just set the values min to the
                // beginning of the display string plus its length
   	            lprwi->obValMin = ob + cch;

       	        // The end is the beginning plus the data width
           	    lprwi->obValMac = lprwi->obValMin + cchDisp;

    	        lprwi->oln = oln;

				m_obMax = max( m_obMax, lprwi->obValMac );

				if ( fInsertExtraLine ) {
					ob = 1;
					++oln;
				}
				else {
        	    	// Place a space at the end.
	   	    	    ob = lprwi->obValMac + 1;
				}

            	UnlockHlle( hrwi );
			}
			++iReg;
        }
    }
}


/**** RwiUpdateEA                                                       ****
 *                                                                         *
 *  PURPOSE: Update the rwi list to include EA data if there's an EA       *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: RwiUpdateEA() {
    SDI	sdi;
	int	cEAPrev = m_cEA;

	SYGetAddr( hpidCurr, htidCurr, adrPC, &sdi.addr );
	sdi.dop = (DOP)( dopEA + dopHexUpper + dopUpper );
	SYUnassemble( hpidCurr, htidCurr, &sdi );

	m_cEA = 0;
	AddEANode( m_ihrwiEA + m_cEA, sdi.ichEA0, sdi.lpch, &sdi.addrEA0, sdi.cbEA0 );
	AddEANode( m_ihrwiEA + m_cEA, sdi.ichEA1, sdi.lpch, &sdi.addrEA1, sdi.cbEA1 );
	AddEANode( m_ihrwiEA + m_cEA, sdi.ichEA2, sdi.lpch, &sdi.addrEA2, sdi.cbEA2 );

	// All of the code below is to support displaying differences in the EA
	// across execution or editing
	if ( cEAPrev ) {
		int		ihrwi;
		HRWI	hrwi;
		HRWI	hrwiPrev;

		// Walk the list to find the previous entry
		ihrwi = m_ihrwiEA + 1;
		hrwi = hrwiNull;

		// Locate the beginning of the new EA nodes
		while( ihrwi-- ) {
			hrwiPrev = hrwi;
			hrwi = LLHlleFindNext( m_hlliRwi, hrwi );
		}

		// There is only updating if there are new EA nodes
		if ( m_cEA ) {
			HRWI	hrwiNew = hrwi;
			HRWI	hrwiOldBegin;
			int		iEA = m_cEA;

			// Skip over the new records
			while( iEA-- ) {
				hrwiOldBegin = hrwi;
				hrwi = LLHlleFindNext( m_hlliRwi, hrwi );
			}

			// Now try to copy "old" data to new records
			iEA = m_cEA;
			while( iEA-- && cEAPrev-- ) {
				LPRWI	lprwiNew = (LPRWI)LLLpvFromHlle( hrwiNew );
				LPRWI	lprwiOld = (LPRWI)LLLpvFromHlle( hrwi );

				if (lprwiOld == NULL || lprwiNew == NULL)
				{
					ASSERT(FALSE);
					break;
				}

				// If rwfEffAddr only, skip to next node to get to
				// the data node
				if ( lprwiOld->rui.rwf == rwfEffAddrOnly ) {
					UnlockHlle( hrwi );
					hrwi = LLHlleFindNext( m_hlliRwi, hrwi );
					lprwiOld = (LPRWI)LLLpvFromHlle( hrwi );
				}

				// This node must be a data node for the EA
				ASSERT(
					lprwiOld->rui.rwf == rwfEffAddr ||
					lprwiOld->rui.rwf == rwfEffData
				);

				// If both the old and new are non-errors and the addresses
				// match, then copy the diff data
				if ( lprwiOld->cbit && lprwiNew->cbit &&
					FAddrsEq( lprwiOld->rui.addrEA, lprwiNew->rui.addrEA )
				) {
					lprwiNew->urDiff = lprwiOld->urDiff;
				}

				// Advance to the next nodes
				UnlockHlle( hrwi );
				UnlockHlle( hrwiNew );
				hrwi = LLHlleFindNext( m_hlliRwi, hrwi );
				hrwiNew = LLHlleFindNext( m_hlliRwi, hrwiNew );
			}

			// Set up to remove
			hrwiPrev = hrwiOldBegin;
			hrwi = LLHlleFindNext( m_hlliRwi, hrwiPrev );
		}

		// Go through the list of old EA nodes and remove them from the
		// list.  All "important" data has been copied out of them.  The
		// EA nodes are consecutive, so when a non-EA node has been found
		// stop.
		while( hrwi ) {
			LPRWI	lprwi = (LPRWI)LLLpvFromHlle( hrwi );

			UnlockHlle( hrwi );

			if ( lprwi->rui.rwf == rwfEffAddr ||
				lprwi->rui.rwf == rwfEffAddrOnly ||
				lprwi->rui.rwf == rwfEffData
			) {
				LLFDeleteHlleFromLl( m_hlliRwi, hrwi );
				hrwi = LLHlleFindNext( m_hlliRwi, hrwiPrev );
			}
			else {
				// Reset the "previous" pointer since it
				// points to a deleted node
				lprwi = (LPRWI)LLLpvFromHlle( hrwi );
				lprwi->hrwiPrev = hrwiPrev;
				UnlockHlle( hrwi );

				hrwi = (HRWI)NULL;
			}
		}
	}
}


/**** AddEANode                                                         ****
 *                                                                         *
 *  PURPOSE: Add the EA data to the list of registers                      *
 *                                                                         *
 *  INPUTS:                                                                *
 *      ihrwiInsert index into rwi list to place node                      *
 *      ichEA   index into lpch string for nth EA.  -1 == no EA            *
 *      lpch    string containing one or more zero terminated EAs          *
 *      lpaddr  pointer to address for specific EA                         *
 *      cbEA    number of bytes for specific EA                            *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: AddEANode(
DWORD	ihrwiInsert,
int		ichEA,
LPCH	lpch,
LPADDR	lpaddr,
int		cbEA
) {
	if ( ichEA != -1 && cbEA != 0) {
		LSZ		lsz;
		LPCH	lpchEq;

		lpchEq = _ftcschr( lpch + ichEA, _T('=') );
		ASSERT( lpchEq );
		*lpchEq = '\0';

		if ( lsz = (LSZ)malloc( _ftcslen( lpch + ichEA ) + 1 ) ) {
	        HRWI    hrwi = LLHlleCreate( m_hlliRwi );
			HRWI	hrwiT;
			DWORD	ihrwi;

	        // Create a new EA item with rwf == rwfEffAddr.  This may
	        // be broken up in RecalcCoords if the window is too narrow

	        if ( hrwi ) {
	            LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );
				USHORT	cbRead;

				// Increment the number of EAs (for RecalcCoords)
				++m_cEA;

	            lprwi->lsz = lsz;
				_ftcscpy( lsz, lpch + ichEA );

	            lprwi->cbit = cbEA * 8;

	            ASSERT( cbEA <= cbRegMax );

	            // Save the EA data
	            cbRead = DHGetDebuggeeBytes(
	            	*lpaddr,
	            	cbEA,
	            	lprwi->rui.ur.rgb
	            );

				FlipBytes( (BYTE *)lprwi->rui.ur.rgb, cbEA );

				// Walk the list to find the previous entry
				ihrwi = ihrwiInsert;
				hrwiT = hrwiNull;
				while( ihrwi-- ) {
					hrwiT = LLHlleFindNext( m_hlliRwi, hrwiT );
				}

	            lprwi->hrwiPrev = hrwiT;
	            lprwi->rui.rwf = rwfEffAddr;
				lprwi->rui.ut.rt = rtInteger;
				lprwi->rui.addrEA = *lpaddr;
				lprwi->dwGrp = (DWORD)rwfEffAddr;

				if ( cbEA != cbRead ) {
					lprwi->cbit = 0;
				}
				cbEA <<= 1;

		        // cbEA from above is actually cchEA so...
		        // Note that hex 4567 is 4 characters, but is two bytes.
		        // Get it?!
				lprwi->rui.cbEA = cbEA >> 1;

				lprwi->urDiff = lprwi->rui.ur;

	            UnlockHlle( hrwi );

				LLInsertHlleInLl( m_hlliRwi, hrwi, ihrwiInsert );
				if ( hrwiT = LLHlleFindNext( m_hlliRwi, hrwi ) ) {
					lprwi = (LPRWI)LLLpvFromHlle( hrwiT );

					lprwi->hrwiPrev = hrwi;
					UnlockHlle( hrwiT );
				}
	        }
	        else {
	            errno = ENOMEM;
				free( lsz );
	        }
		}
		else {
			errno = ENOMEM;
		}
	}
}


/**** RwvKillRwiNode                                                    ****
 *                                                                         *
 *  PURPOSE: Callback from linklist manager to free up any allocated data  *
 *  in a RWI node.                                                         *
 *                                                                         *
 *  INPUTS:                                                                *
 *      lpvRwiNode   void pointer to RWI node.                             *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION: Only nodes with allocated memory are effective address *
 *      nodes which contain the EA string.                                 *
 *                                                                         *
 ***************************************************************************/
void FAR PASCAL RwvKillRwiNode( LPV lpvRwiNode ) {
	LPRWI	lprwi = (LPRWI)lpvRwiNode;

	if ( lprwi->rui.rwf == rwfEffAddr || lprwi->rui.rwf == rwfEffAddrOnly ) {
		ASSERT( lprwi->lsz );
		free( lprwi->lsz );
		lprwi->lsz = (LSZ)NULL;
	}
}


/**** UpdateRwi                                                         ****
 *                                                                         *
 *  PURPOSE: Reset the rwi list since we are either creating a new         *
 *  register set or changing EM/NMs.  This will get all of the info from   *
 *  OSDebug                                                                *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: UpdateRwi() {

    if ( m_hlliRwi ) {
        LLChlleDestroyLl( m_hlliRwi );
        m_hlliRwi = (HLLI)NULL;
    }

    m_hlliRwi = LLHlliInit(
    	sizeof( RWI ),
    	llfNull,
    	RwvKillRwiNode,
    	NULL
    );

    if ( m_hlliRwi ) {
        RD      rd;
        RT      rt = rtRegular;
        FD      fd;
        USHORT  ird = 0;
        HPID    hpid = hpidCurr;
		HTID	htid = htidCurr;
        HRWI    hrwiPrev = hrwiNull;

#if !(defined (_MIPS_))
        if ( fIn386Mode ) {
            rt = rtExtended;
        }
#else
        rt = rtRegular | rtExtended;
#endif
		// Regular CPU registers
        while( xosdNone == OSDGetRegDesc( hpid, htid, ird++, &rd ) ) {
            if ( rd.rt & rtCPU && rd.rt & rt ) {
                HRWI	hrwi = LLHlleCreate( m_hlliRwi );

                if ( hrwi ) {
                    LPRWI    lprwi = (LPRWI)LLLpvFromHlle( hrwi );

                    lprwi->lsz = rd.lszName;
                    lprwi->cbit = rd.dwcbits;
                    lprwi->rui.hReg = rd.dwId;
	  				lprwi->dwGrp = rd.dwGrp;

					OSDReadRegister(
						hpid,
						htid,
						lprwi->rui.hReg,
						lprwi->rui.ur.rgb
					);


					lprwi->rui.ut.rt = rd.rt;
                    lprwi->rui.rwf = rwfHexReg;
                    lprwi->hrwiPrev = hrwiPrev;
                    hrwiPrev = hrwi;
                    UnlockHlle( hrwi );
                    LLAddHlleToLl( m_hlliRwi, hrwi );
                }
                else {
                    errno = ENOMEM;
                    break;
                }
            }
        }

		// Regular CPU flags
        ird = 0;
        while( xosdNone == OSDGetFlagDesc( hpid, htid, ird, &fd ) ) {
            if ( !( fd.ft & ftInvisible ) ) {
                HRWI	hrwi = LLHlleCreate( m_hlliRwi );

                if ( hrwi ) {
                    LPRWI    lprwi = (LPRWI)LLLpvFromHlle( hrwi );

                    lprwi->lsz = fd.lszName;
                    lprwi->cbit = fd.dwcbits;
                    lprwi->rui.hReg = fd.dwId;
		    		lprwi->rui.ut.ft = fd.ft;
				    lprwi->dwGrp = fd.dwGrp;

                    OSDReadFlag(
                        hpid,
                        htid,
                        ird,
                        (VOID FAR *)&lprwi->rui.ur.ul
                    );

                    lprwi->rui.iFlag = ird;
                    lprwi->rui.rwf = rwfFlag;
                    lprwi->hrwiPrev = hrwiPrev;
                    hrwiPrev = hrwi;
                    UnlockHlle( hrwi );
                    LLAddHlleToLl( m_hlliRwi, hrwi );
                }
                else {
                    errno = ENOMEM;
                    break;
                }
            }
            ++ird;
        }

        // After all the CPU regs and flags are loaded, add in the EA stuff
		m_ihrwiEA = LLChlleInLl( m_hlliRwi );
        RwiUpdateEA();

		// Regular FPU registers
		ird = 0;
        while( xosdNone == OSDGetRegDesc( hpid, htid, ird++, &rd ) ) {
            if ( rd.rt & rtFPU && rd.rt & rt ) {
                HRWI	hrwi = LLHlleCreate( m_hlliRwi );

                if ( hrwi ) {
                    LPRWI    lprwi = (LPRWI)LLLpvFromHlle( hrwi );

                    lprwi->lsz = rd.lszName;
                    lprwi->cbit = rd.dwcbits;
                    lprwi->rui.hReg = rd.dwId;
					lprwi->dwGrp = rd.dwGrp;

					OSDReadRegister(
						hpid,
						htid,
						lprwi->rui.hReg,
						lprwi->rui.ur.rgb
					);

					lprwi->rui.ut.rt = rd.rt;
					if ( rd.rt & rtFloat ) {
						lprwi->rui.rwf = rwfFloat;
					}
					else {
                    	lprwi->rui.rwf = rwfHexReg;
					}
                    lprwi->hrwiPrev = hrwiPrev;
                    hrwiPrev = hrwi;
                    UnlockHlle( hrwi );
                    LLAddHlleToLl( m_hlliRwi, hrwi );
                }
                else {
                    errno = ENOMEM;
                    break;
                }
            }
        }

        // Now, reset the display cooridnates
        RecalcCoords( FALSE );
    }
}


/**** UpdateRegs                                                        ****
 *                                                                         *
 *  PURPOSE: Update all of the DATA in the rwi list.  Usually done after   *
 *  execution                                                              *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: UpdateRegs() {

    HRWI    hrwi = hrwiNull;
    HPID    hpid = hpidCurr;
    HTID    htid = htidCurr;
    HRWI    hrwiPrev;
	
    while( hrwi = LLHlleFindNext( m_hlliRwi, hrwi ) ) {
        LPRWI   lprwi = (LPRWI)LLLpvFromHlle( hrwi );

        // Unlock here since we may delete the node below!
        UnlockHlle( hrwi );

        switch( lprwi->rui.rwf ) {

            case rwfFlag:
                OSDReadFlag(
                    hpid,
                    htid,
                    lprwi->rui.iFlag,
                    (VOID FAR *)&lprwi->rui.ur.ul
                );
                hrwiPrev = hrwi;
                break;

            case rwfHexReg:
			case rwfFloat:
				OSDReadRegister(
					hpid,
					htid,
					lprwi->rui.hReg,
					lprwi->rui.ur.rgb
				);
                hrwiPrev = hrwi;
				break;

            // EA addr and/or data.  Delete the nodes from the list
            // since the call to RwiUpdateEA will add them back
            // if necessary

/*            case rwfEffAddr:
            case rwfEffAddrOnly:
            case rwfEffData:
                LLFDeleteHlleFromLl( m_hlliRwi, hrwi );
                hrwi = hrwiPrev;
                break;
*/
        }
    }

    // Get new EA info
    RwiUpdateEA();

    // Update the display cooridnates (necessary if EA info changed)
    RecalcCoords( FALSE );
}


/**** UpdateDisplay                                                     ****
 *                                                                         *
 *  PURPOSE: Update the register display.  This is called when the kernel  *
 *           comes back from executing the child or a value is changed     *
 *           via the command window or something like that                 *
 *                                                                         *
 *  INPUTS:                                                                *
 *      fForce  Force a repaint of the register window.  If FALSE, no paint*
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: UpdateDisplay(
BOOL    fForce ) {

	if ( DebuggeeAlive() ) {
		BOOL update = FALSE;
		ADDR pc = {0};
		WORD model = m_wModel;
		LPVOID pSym;
		CV_uoff32_t off;

		// If we have P-code present we need to look for model changes as well. 
		if ( lpprcCurr->fPcodePresent && 
       			(SYGetAddr( hpidCurr, htidCurr, adrPC, &pc )==xosdNone )
			)
		{
			SHModelFromAddr( &pc, &model, (LPB)&pSym, &off );
		}

    	if ( !m_hlliRwi ||
        	m_f386Mode != fIn386Mode ||
        	m_wEM != lpprcCurr->wEM  || 
			model != m_wModel )
		{	
			update = TRUE;
		}

		if (update) {
    	    m_f386Mode = fIn386Mode;
	        m_wEM = lpprcCurr->wEM;
			m_wModel = model;
			m_cEA = 0; // No previous EA values. 
        	UpdateRwi();
    	}
	    else {
        	UpdateRegs();
    	}
	}

   	// Only paint the window if we're fForce'd to
   	if ( fForce ) {
   	    DrawWindow();
    }
}


/**** InitWndMgr                                                        ****
 *                                                                         *
 *  PURPOSE: Initialize the edit manager.                                  *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value: non-zero for success.                                *
 *                                                                         *
 *  IMPLEMENTATION: Copy the data structure from _based memory.  It's      *
 *                  faster and smaller than initializing fields.           *
 *                                                                         *
 ***************************************************************************/
int CCpuView :: InitWndMgr() {
	return InitEditMgr();
}


/**** DestroyInfo                                                       ****
 *                                                                         *
 *  PURPOSE: Destroy all internal data structures associated with register *
 *           display                                                       *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
void CCpuView :: DestroyInfo() {
	m_hrwiEdit = hrwiNull;

    if ( m_hlliRuiUndo ) {
        LLChlleDestroyLl( m_hlliRuiUndo );
        m_hlliRuiUndo = (HLLI)NULL;
    }

	if ( m_hlliRuiRedo ) {
        LLChlleDestroyLl( m_hlliRuiRedo );
        m_hlliRuiRedo = (HLLI)NULL;
    }

    if ( m_hlliRwi ) {
        LLChlleDestroyLl( m_hlliRwi );
        m_hlliRwi = (HLLI)NULL;
    }

	// Reset the EA information to initial state
	m_cEA = 0;
	m_ihrwiEA = (DWORD)-1;

	// Reset edit state
	m_hrwiEdit = hrwiNull;

	// When the window is destroyed and the
	// destructor of CCpuView is called, don't
	// update the Doc undo info
	if ( pViewCpu ) {
		UpdateDocInfo();
	}
}

BOOL CCpuView :: PreTranslateMessage( MSG *	pMsg ) {
	BOOL	fRet = FALSE;

	// If we get an unshift'd/unctrl'd ESCAPE
	// key, throw out the current edit if there
	// is one.  Else, pass the key on to the next
	// handler

	if ( pMsg->message == WM_KEYDOWN &&
		pMsg->wParam == VK_ESCAPE &&
		!( GetKeyState( VK_SHIFT ) & ~1 ) &&
		!( GetKeyState( VK_CONTROL ) & ~1 ) &&
		m_hrwiEdit
	) {
		// Translate the message to something that
		// will get by the dockmanager!
		pMsg->message = WU_FLUSHEDITS;
		pMsg->wParam = TRUE;
	}

	return CMultiEdit::PreTranslateMessage( pMsg );
}


/**** LTextProc                                                         ****
 *                                                                         *
 *  PURPOSE: Main entry point for display/update of register window        *
 *                                                                         *
 *  INPUTS: standard WndProc                                               *
 *                                                                         *
 *  OUTPUTS: standard WndProc                                              *
 *                                                                         *
 *      Return Value:                                                      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 ***************************************************************************/
LRESULT CCpuView :: LTextProc(
UINT    wMsg,
WPARAM  wParam,
LPARAM  lParam ) {
	LRESULT	lRet = 0L;
	BOOL	fUseEM = TRUE;	// Use the EditMgr?

    switch( wMsg ) {
        case WU_INITDEBUGWIN:
			fUseEM = FALSE;
			InitializeMembers();
            lRet = InitWndMgr();
            UpdateDisplay( FALSE );
            Freeze();
            break;

        case WU_CLEARDEBUG:
			fUseEM = FALSE;
            DestroyInfo();
            break;

		case WM_KEYDOWN:
			fUseEM = FDoKeyDown( wParam, lParam );
			break;

        case WM_CHAR:
            fUseEM = FDoChar( wParam, lParam );
            break;

		case WM_KILLFOCUS:
		case WM_VSCROLL:
		case WM_HSCROLL:
		case WM_LBUTTONDOWN:
			FlushEdit( FALSE );
			break;

        case WM_LBUTTONDBLCLK: {
			HRWI    hrwi;
			RWF		rwf = RwfFieldType( &hrwi );

			// If we're on text, see if it's a flag
			// text item.  If so, allow the toggle
			if ( rwf == rwfText ) {
				LPRWI	lprwi = (LPRWI)LLLpvFromHlle( hrwi );

				rwf = lprwi->rui.rwf;
				UnlockHlle( hrwi );
			}

			if ( rwf == rwfFlag ) {
				if ( DebuggeeRunning() ) {
					MessageBeep( 0 );
				}
				else {
					ToggleFlag( hrwi );
					FlushEdit( FALSE );
				}
				fUseEM = FALSE;
			}
            break;
		}

		case WM_UNDO:
			fUseEM = FALSE;
			UndoValue( (BOOL) wParam );
			break;

		case WU_UPDATESCROLLBARS:
		case WM_SIZE:
			// Make sure that the cursor is reset so
			// we don't end up with a selection or
			// have the cursor beyond the end of the
			// window
			SetCursorAt( 0, 0 );
			RecalcCoords( (BOOL)( wMsg == WM_SIZE ) );
			InvalidateRect(NULL, FALSE);
			break;

        case WM_CLEAR:
            break;

		case WU_UPDATEDEBUG:
			fUseEM = FALSE;
	        UpdateDisplay( TRUE );
			break;

		case WU_FREEZEDATA:
			fUseEM = FALSE;
			Freeze();
			break;

		case WU_FLUSHEDITS:
			fUseEM = FALSE;
			FlushEdit( !!wParam );
			break;

		case WM_COMMAND:
 			fUseEM = FALSE;

			// Set the cursor to 0,0 before resetting the
			// display parameters.  This will cause a repaint
			// and since the recalc hasn't been done, we may
			// overflow the buffer
			SetCursorAt( 0, 0 );

			m_fShowFlags = runDebugParams.fCPUFlags;
			m_fShowCpu = runDebugParams.fCPURegs;
			m_fShowEA = runDebugParams.fCPUEA;
			m_fShowFPU = runDebugParams.fCPUFloat;

			RecalcCoords( FALSE );
			InvalidateRect( NULL, FALSE );
			break;
	}

    // Some messages may have been already processed, so don't
    // pass on if eaten already
    if ( fUseEM ) {
        lRet = CMultiEdit::LTextProc( wMsg, wParam, lParam );
    }

    return lRet;
}

BEGIN_POPUP_MENU(Registers)
	MENU_ITEM(IDM_DBGSHOW_FLOAT)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_TOGGLE_MDI)
	MENU_ITEM(ID_WINDOW_POPUP_HIDE)
END_POPUP_MENU()

void CCpuView::ShowContextPopupMenu(CPoint pt)
{
    #ifndef NO_CMDBARS
        TRACE2("Registers (%s, %d)\r\n", __FILE__, __LINE__);
        ::CBShowContextPopupMenu(MENU_CONTEXT_POPUP(Registers), pt);
    #else
    	::ShowContextPopupMenu(MENU_CONTEXT_POPUP(Registers), pt);
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\thread.cpp ===
#include "stdafx.h"
#include "fbrdbg.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

extern int iCallsCxf ;
extern BOOL CLDispCallInfo( int iCall );

static BOOL LocationDisplay = TRUE;		// True if we're displaying function names, false if address
static BOOL OldLocationDisplay;			// Save the LocationDisplay BOOL if the user clicks CANCEL
static UINT FocusThread = (UINT) -1;	// Index of focus thread
static BOOL fMustRestoreStack;			// We must restore current thread's stack when we're done

/****************************************************************************

	FUNCTION:	MakeThreadObject

	PURPOSE:	Initialize a Thread_Object Structure

****************************************************************************/
static void MakeThreadObject(THREAD_OBJECT *Object, DWORD id,
	DWORD cSuspend, DWORD cSuspendNew, LPSTR priority, BOOL HasFocus,
	DWORD Address, PSTR Location)
{
	Object->id = id;
	Object->cSuspend = cSuspend;
	Object->cSuspendNew = cSuspendNew;
	_ftcsncpy(Object->szPriority,priority,sizeof(Object->szPriority)-1);
	Object->szPriority[sizeof(Object->szPriority)-1] = '\0';
	Object->HasFocus = HasFocus;
	Object->address = Address;
	_ftcsncpy((char *)Object->Location,Location,THREAD_FIELD5-THREAD_FIELD4-1);
}

/****************************************************************************

	FUNCTION:	MakeString

	PURPOSE:	Create a user string from a THREAD_OBJECT struct

****************************************************************************/
static void MakeString(THREAD_OBJECT *Object, char *Buffer, int cch)
{
	char szState[THREAD_FIELD3-THREAD_FIELD2+1];
	char szAddress[THREAD_FIELD5-THREAD_FIELD4+1];

	if (cch < THREAD_FIELD5)
	{
		ASSERT(FALSE);
		Buffer[0] = '\0';
		return;
	}

	// show suspend count
	_snprintf(szState, sizeof(szState), "%lu", Object->cSuspendNew);

	if (LocationDisplay)
	{
		_ftcsncpy(szAddress, Object->Location, sizeof(szAddress));
		szAddress[sizeof(szAddress)-1] = _T('\0');
	}
	else
		sprintf(szAddress, "%08lx", Object->address);

	sprintf(Buffer, "%c%-*.*lx %-*.*s %-*.*s %-*.*s",
		Object->HasFocus?'*':' ',
		THREAD_FIELD2-THREAD_FIELD1-1,8,
		Object->id,
		THREAD_FIELD3-THREAD_FIELD2-1,THREAD_FIELD3-THREAD_FIELD2-1,
		szState,
		THREAD_FIELD4-THREAD_FIELD3-1,THREAD_FIELD4-THREAD_FIELD3-1,
		Object->szPriority,
		THREAD_FIELD5-THREAD_FIELD4-1,THREAD_FIELD5-THREAD_FIELD4-1,
		szAddress);
}

/****************************************************************************

	FUNCTION:	GetSymbolFromAddr

	PURPOSE:	Given an ADDR, search for the nearest symbol name
				Returns TRUE if symbol found

****************************************************************************/
BOOL GetSymbolFromAddr(PADDR pAddr, CString& strSymbolName)
{
	CXT CXTT;
	HMOD hmod = 0;
	HSYM hSym;
	char rgch [100];
	ADDR Addr; // Unfixed up address

	// Setup context struct
	memset(&CXTT, 0, sizeof(CXT));
	SHHMODFrompCXT(&CXTT) = (HMOD) NULL;

	// Unfix up the address
	Addr = *pAddr;
	SYUnFixupAddr(&Addr);

	// load the context from the address
	if(!SHSetCxt(&Addr, &CXTT))
	{
		return (FALSE); // problem
	}

	// Get hmod from context
	hmod = SHHMODFrompCXT(&CXTT);
	if (!hmod)
	{
		return (FALSE); // problem
	}

	// check the symbol table
	if (SHGetNearestHsym(&Addr,hmod,EECODE,&hSym) == CV_MAXOFFSET)
	{
		// check the publics
		if (PHGetNearestHsym(&Addr,SHHexeFromHmod(hmod),&hSym) == CV_MAXOFFSET)
		{
			// Not found..
			return (FALSE);
		}
	}

	// At this point we have a valid HSYM
	memset(rgch, 0, sizeof(rgch));
	if (SHGetSymName (hSym, rgch) != NULL)
	{
		strSymbolName = rgch;
		return TRUE;
	}
	else
	{
		strSymbolName.Empty();
		return FALSE;
	}
}

/****************************************************************************

	FUNCTION:	GetThreadInfo

	PURPOSE:	Ask OSDebug for information about a thread

****************************************************************************/
static BOOL GetThreadInfo(BOOL FirstThread, UINT *id,
					DWORD *cSuspend, LPSTR *Priority, UINT *HasFocus,
					DWORD *Address, LPSTR Location, UINT cch)
{
	static HTHD hthd;
	static TST ThreadStatus; // static so we can pass part of it back to caller
	HLLI ListId;
	LPTHD lpthd;
	HTID htid;
	HPID hpid;
	ADDR Addr = {0};
	BOOL fAlive;
	CString strLocation;

	if (FirstThread)
		hthd = NULL;	// We want the first thread of the list

	// Get pid of current process
	hpid = HpidFromHprc(hprcCurr);

	// Get the ID of the list of threads
	ListId = LlthdFromHprc (hprcCurr);

	// Get the handle of a live thread
	do
	{
		hthd = (HTHD)LLHlleFindNext(ListId,hthd);
		if (hthd)
		{
			lpthd = (LPTHD)LLLpvFromHlle(hthd);
			fAlive = !(lpthd->tdf & tdfDead);
			UnlockHlle(hthd);
		}
	}
	while (hthd && !fAlive);

	// Is there any thread ?
	if (hthd == NULL)
		return (FALSE);

	// Get a pointer to the thread structure
	lpthd = (LPTHD)LLLpvFromHlle ( hthd );
	if (lpthd == NULL)
		return (FALSE);

	// Unlock the thread structure
	UnlockHlle(hthd);

	// Get NT thread ID
	*id = lpthd->tid;

	// Get OSD thread ID
	htid = lpthd->htid;

	// Is it the current thread ?
	if (hthd == hthdCurr)
	{
		*HasFocus = TRUE;

		// Print current tid in status bar
// this has never been enabled, but if the feature gets added, here's the place.
//		StatusTid(*id);
	}
	else
		*HasFocus = FALSE;

	// Get the thread PC address
	OSDGetAddr(hpidCurr,htid,adrPC,(PADDR)&Addr);

	*Address = GetAddrOff(Addr); // only get the 32-bit offset

	// Get the thread location.  First, see if we can determine a function
	// name for the current CS:EIP.  If we can't, then look up the stack
	// for the first address for which we DO have symbols.
	Location[0] = '\0';
	if (!GetSymbolFromAddr(&Addr,strLocation))
	{
		// If the address that the top of stack doesn't have a symbol,
		// then look up the stack, and if we find something we recognize,
		// put its function name in brackets
		int i;
		HFME hfme;
		LPFME lpfme;

		// We need to get the callstack for a different thread, but when
		// we're done, we are going to need to restore whatever callstack
		// info is currently available.
		if ( fMustRestoreStack = (hthdCurr != hthd) )
		{
			CLFreeWalkbackStack( TRUE );
		}

		// Initialize the call stack chain with the appropriate thread
		CLGetWalkbackStack(hpidCurr, htid, 0);

		// start at i==1, to skip first element, which we already checked
		for (i = 1; (hfme = CLHfmeGetNth(i)) != NULL; ++i)
		{
			lpfme = (LPFME)LLLpvFromHlle(hfme);
			if (lpfme->clt == cltProc)
			{
				// found a function: format as "[func_name]"
				if (GetSymbolFromAddr(&lpfme->addrProc, strLocation))
				{
					sprintf(Location, "[%.*s]", cch-3,
						(const char*)strLocation);
					break;
				}
			}
			UnlockHlle(hfme);
		}
		if (hfme) {
			UnlockHlle(hfme);
		}
	}
	else
	{
		_tcsncpy(Location, (LPCTSTR)strLocation, cch);
		Location[cch-1] = '\0';
	}

	// Get thread status in tst structure
	VERIFY(OSDGetThreadStatus(hpidCurr,htid, &ThreadStatus) == xosdNone);

	*cSuspend = ThreadStatus.dwSuspendCount;
	*Priority = ThreadStatus.rgchPriority;

	if (ThreadStatus.rgchThreadID[0])
	{
		// thread has a name, insert on the front of Location
		CString oldLoc = Location;
		_snprintf( Location, cch-1, "%s,%s", ThreadStatus.rgchThreadID, (LPCTSTR)oldLoc );
		Location[cch-1] = 0;
	}

	return (TRUE);
}

/****************************************************************************

	FUNCTION:	InitDefaultThreadList

	PURPOSE:	Get default thread list

****************************************************************************/
static void InitDefaultThreadList(void)
{
	THREAD_OBJECT Object;
	char Location[THREAD_FIELD5-THREAD_FIELD4+1];
	UINT id, HasFocus;
	LPSTR Priority;
	UINT ListboxIndex = 0;
	DWORD Address;
	DWORD cSuspend;
	BOOL IsFirstThread = TRUE;
	int chfme;
	int iCallsPrev;

	// GetThreadInfo may call ClGetWalkbackStack on some thread other than
	// the current thread, in which case we'll need to restore the stack
	// to its previous state after we're done looping
	chfme = CLChfmeOnStack();
	fMustRestoreStack = FALSE ;
	iCallsPrev = iCallsCxf;

	FocusThread = (UINT) -1;

	// Get the thread informations
	while (GetThreadInfo(IsFirstThread, &id, &cSuspend, &Priority,
		&HasFocus, &Address, Location, sizeof(Location)))
	{
		// Create an object
		MakeThreadObject(&Object, id, cSuspend, cSuspend, Priority,
			HasFocus, Address, Location);

		// Add the thread object in the linked list
		VERIFY(ListAddObject(DLG_THREAD_LIST,(LPSTR)&Object,sizeof(THREAD_OBJECT)));

		// Remember if this is the thread with focus
		if (HasFocus)
			FocusThread = ListboxIndex;

		// We want the next threads from GetThreadInfo
		IsFirstThread = FALSE;

		// Move on to the next listbox entry
		ListboxIndex++;
	}

	// Now restore whatever stack info existed before we started
	if (fMustRestoreStack)
	{
		if (chfme == 0)
			CLFreeWalkbackStack(FALSE);
		else
		{
			CLGetWalkbackStack(hpidCurr, htidCurr, chfme);
			iCallsCxf = iCallsPrev;
		}
	}
}

/****************************************************************************

	FUNCTION:	UpdateListboxContent

	PURPOSE:	Copy the content of the linked list into the listbox

 ****************************************************************************/
static void UpdateListboxContent(HWND hDlg)
{
	int		Count,i;
	char	Buffer[THREAD_FIELD5+1];
	THREAD_OBJECT Object;

	SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_RESETCONTENT,0,0);
	Count = (int)ListGetCount(DLG_THREAD_LIST);
	for (i=0; i<Count; i++)
	{
		if (!ListGetObject(i,DLG_THREAD_LIST,(LPSTR)&Object))
		{
			ASSERT(FALSE);
			EmptyList(DLG_THREAD_LIST);
			SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_RESETCONTENT,0,0);
			break;
		}
		MakeString(&Object,Buffer,sizeof(Buffer));
		SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_INSERTSTRING,i,(LPARAM)(LPSTR)Buffer);
	}
}

/****************************************************************************

	FUNCTION:	EnableControls

	PURPOSE:	Enable or disable some buttons in the thread box

****************************************************************************/
static void EnableControls(HWND hDlg)
{
	UINT	Selection;
	BOOL	CanSuspend,CanResume,CanSetFocus;
	THREAD_OBJECT Object;
	ULONG	cSuspendMax;

	// If no selection, disable all buttons
	CanSuspend = CanResume = CanSetFocus = FALSE;
	Selection = (UINT)SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_GETCURSEL,0,0);
	if (Selection != LB_ERR)
	{
		// Thread selected, what can we do with it ?
		if (!ListGetObject(Selection,DLG_THREAD_LIST,(LPSTR)&Object))
		{
			ASSERT(FALSE);
			EmptyList(DLG_THREAD_LIST);
		}
		else
		{
		TST tst;

		if (OSDGetThreadStatus(hpidCurr, htidCurr, &tst) != xosdNone)
			cSuspendMax = 0;
		else
			cSuspendMax = tst.dwSuspendCountMax;
		CanSetFocus = TRUE;
		CanSuspend = (Object.cSuspendNew < cSuspendMax);
		CanResume = (Object.cSuspendNew > 0);
	}
	}

	// Dis/Enable the buttons
	EnableWindow(GetDlgItem(hDlg, DLG_THREAD_FOCUS),CanSetFocus);
	EnableWindow(GetDlgItem(hDlg, DLG_THREAD_SUSPEND),CanSuspend);
	EnableWindow(GetDlgItem(hDlg, DLG_THREAD_RESUME),CanResume);
}

/****************************************************************************

	FUNCTION:	SetThreadState(HWND hDlg, UINT id, UINT NewState)

	PURPOSE:	Modify the state of a thread

****************************************************************************/
void SetThreadState(
	HWND hDlg,
	UINT SelectedId,		// SelectedId = index of thread in list
	UINT ModifiedState)
{
	THREAD_OBJECT Object;
	char Buffer[THREAD_FIELD5+1];

	// Get object from list
	if (ListGetObject(SelectedId,DLG_THREAD_LIST,(LPSTR)&Object))
	{
		// Modify state
		if (ModifiedState == THREAD_FOCUS)
		{
			// If thread is given focus, remove focus from other thread
			if (FocusThread != (UINT) -1)
				SetThreadState(hDlg, FocusThread, THREAD_KILLFOCUS);
			Object.HasFocus = TRUE;
			FocusThread = SelectedId;
		}
		else if (ModifiedState == THREAD_KILLFOCUS)
			Object.HasFocus = FALSE;
		else if (ModifiedState == DLG_THREAD_SUSPEND)
			Object.cSuspendNew++;
		else if (ModifiedState == DLG_THREAD_RESUME)
		{
			ASSERT(Object.cSuspendNew > 0);
			Object.cSuspendNew--;
		}
		else
			ASSERT(FALSE);	// unrecognized command

		// Update the list
		ListUpdateObject(SelectedId,DLG_THREAD_LIST,(LPSTR)&Object,sizeof(THREAD_OBJECT));

		// Update the listbox
		SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_DELETESTRING,SelectedId,0);
		// Create the string, and add it in the listbox
		MakeString(&Object,Buffer,sizeof(Buffer));
		SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_INSERTSTRING,SelectedId,(LPARAM)(LPSTR)Buffer);
		SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_SETCURSEL,SelectedId,0);
	}
	// Enable valid controls
	EnableControls(hDlg);
}

/****************************************************************************

	FUNCTION:	ValidateNewThreadStates(void)

	PURPOSE:	Make all the changes made in the dialog box come true

****************************************************************************/
static void ValidateNewThreadStates(void)
{
	THREAD_OBJECT Object;
	DWORD cSuspend;
	HTID htid;
	HPID hpid;
	UINT ThreadNumber,index;

	// for each thread in the list, check if state has changed
	ThreadNumber = ListGetCount(DLG_THREAD_LIST);

	for (index = 0; index <ThreadNumber; index++)
	{
		// Get object from list
		if (ListGetObject(index,DLG_THREAD_LIST,(LPSTR)&Object))
		{
		cSuspend = Object.cSuspend;

		// Does the state change ?
		if (cSuspend != Object.cSuspendNew)
		{
			hpid = HpidFromHprc(hprcCurr);
			htid = HtidFromTid(hprcCurr, Object.id);

			// one of these two loops will execute, the other won't
			while (cSuspend < Object.cSuspendNew)
			{
				if (OSDFreezeThread(hpid, htid, TRUE) != xosdNone)
				{
					ErrorBox(DBG_Cannot_Suspend_Thread, Object.id);
					break;
				}
				cSuspend++;
			}
			while (cSuspend > Object.cSuspendNew)
			{
				if (OSDFreezeThread(hpid, htid, FALSE) != xosdNone)
				{
					ASSERT(FALSE);
					break;
				}
				cSuspend--;
			}
		}

		// Is this thread the current thread ?
		if (Object.HasFocus)
		{
			// Get the htid from the tid
			htid = HtidFromTid (hprcCurr, Object.id);

			// Don't do anything if the current thread hasn't changed
			if (htid != htidCurr)
			{
				// Print current tid in status bar
// this has never been enabled, but if the feature gets added, here's the place.
//				StatusTid(Object.id);

				// Set the hthdcurr value
				SYSetContext(hprcCurr, HthdFromHtid(hprcCurr, htid), FALSE);
				// Refresh all debug windows
				UpdateDebuggerState(UPDATE_DEBUGGEE|UPDATE_ALLDBGWIN|UPDATE_SOURCE);
			}
		}
	}
	}
}

/****************************************************************************

	FUNCTION:	AlignColumnHeaders(HWND, HFONT)

	PURPOSE:	Repositions the column headers above the list box based
				on the size of of the fixed font, so that they line up
				nicely with the text in the listbox.

****************************************************************************/
static void
AlignColumnHeaders(HWND hDlg, HFONT hFont)
{
	HDC hdc;
	TEXTMETRIC tm;
	RECT rect;
	LONG xLeft;
	LONG cx, cy;
	HWND hwndItem;

	hdc = CreateIC("DISPLAY", NULL, NULL, NULL);
	ASSERT(hdc != NULL);
	SelectObject(hdc, (HGDIOBJ) hFont);
	VERIFY(GetTextMetrics(hdc, &tm));
	VERIFY(DeleteDC(hdc));

	VERIFY(GetWindowRect(GetDlgItem(hDlg, DLG_THREAD_LIST), &rect));
	VERIFY(ScreenToClient(hDlg, (LPPOINT) &rect.left));
	// FUTURE: HACK: I can't figure out how to get the left edge of the
	// actual text in the listbox, rather than the left edge of the listbox
	// itself.  The "+3*GetSystemMetrics(SM_CXBORDER)" below is a hack to
	// work around this: on my high-res screen the border is one pixel and
	// this is followed by two pixels of whitespace, so this calculation
	// is good enough.
	xLeft = rect.left + 3*GetSystemMetrics(SM_CXBORDER);

	hwndItem = GetDlgItem(hDlg, DLG_THREAD_STATE);
	VERIFY(GetWindowRect(hwndItem, &rect));
	cx = rect.right - rect.left;
	cy = rect.bottom - rect.top;
	VERIFY(ScreenToClient(hDlg, (LPPOINT) &rect.left));
	VERIFY(MoveWindow(hwndItem,
		xLeft + tm.tmAveCharWidth * THREAD_FIELD2,
		rect.top, cx, cy, TRUE));

	hwndItem = GetDlgItem(hDlg, DLG_THREAD_PRIORITY);
	VERIFY(GetWindowRect(hwndItem, &rect));
	cx = rect.right - rect.left;
	cy = rect.bottom - rect.top;
	VERIFY(ScreenToClient(hDlg, (LPPOINT) &rect.left));
	VERIFY(MoveWindow(hwndItem,
		xLeft + tm.tmAveCharWidth * THREAD_FIELD3,
		rect.top, cx, cy, TRUE));

	hwndItem = GetDlgItem(hDlg, DLG_THREAD_LOCATION);
	VERIFY(GetWindowRect(hwndItem, &rect));
	cx = rect.right - rect.left;
	cy = rect.bottom - rect.top;
	VERIFY(ScreenToClient(hDlg, (LPPOINT) &rect.left));
	VERIFY(MoveWindow(hwndItem,
		xLeft + tm.tmAveCharWidth * THREAD_FIELD4,
		rect.top, cx, cy, TRUE));
}

/****************************************************************************

	FUNCTION:	DlgThread(HWND, unsigned, UINT, LONG)

	PURPOSE:	Processes messages for "THREAD" dialog box

****************************************************************************/
BOOL FAR PASCAL EXPORT DlgThread(
	HWND       hDlg,
	unsigned   message,
	UINT       wParam,
	LONG       lParam)
{
	OFBRS ofbr;
	HTID htid;
			
	switch (message)
	{
	case WM_CONTEXTMENU:
	{
		// "What's this?" help
		DoHelpContextMenu(CWnd::FromHandle(hDlg), IDD_THREADS, CPoint(LOWORD(lParam),HIWORD(lParam)));
	}
	return TRUE;

	case WM_HELP:
	{
		// handler for click after arrow button pressed
		DoHelpInfo(CWnd::FromHandle(hDlg), IDD_THREADS, (HELPINFO *)lParam);
	}
	return TRUE;

	case WM_INITDIALOG:
		{
		int Count;
			HFONT hFont;
			// Radio button state
			OldLocationDisplay = LocationDisplay;
			SendDlgItemMessage(hDlg,DLG_THREAD_NAME,BM_SETCHECK,LocationDisplay,0);
			SendDlgItemMessage(hDlg,DLG_THREAD_ADDRESS,BM_SETCHECK,!LocationDisplay,0);

			// Fixed font for the listbox
            hFont = (HFONT)GetStockObject(SYSTEM_FIXED_FONT);
	
			//Turn off fiber support in the dm
			//renable in CANCEL or OK
			if(runDebugParams.fFiberDebugging){
				ofbr.op = OFBR_DISABLE_FBRS;
				OSDSystemService (hpidCurr,
						  htidCurr,
						  ssvcFiberDebug,
						(LPVOID) &ofbr,
						sizeof(ofbr),
						NULL
						);
				OSDGetFrame(hpidCurr,htidCurr,1,&htid);		
			}
			if (hFont != NULL)
			{
				SendDlgItemMessage(hDlg,DLG_THREAD_LIST,WM_SETFONT,(WPARAM)hFont,MAKELONG(FALSE,0));

				// Reposition column headers based on size of fixed font,
				// so they line up nicely with the text in the listbox
				AlignColumnHeaders(hDlg, hFont);
			}

			// Initialize the linked list, and add the strings
			// in the listbox if the list is not empty
			InitList(DLG_THREAD_LIST);
			Count = (int)ListGetCount(DLG_THREAD_LIST);
			if (Count != 0)
			{
				EmptyList(DLG_THREAD_LIST);
			}
			// list empty, get thread list
			InitDefaultThreadList();
			Count = (int)ListGetCount(DLG_THREAD_LIST);
			UpdateListboxContent(hDlg);
			if (FocusThread != -1)
			{
				SendDlgItemMessage(hDlg, DLG_THREAD_LIST, LB_SETCURSEL,
					FocusThread, 0);
			}

			// Enable valid controls
			EnableControls(hDlg);
		}
		break;
	case WM_COMMAND:
		switch (GET_WM_COMMAND_ID(wParam, lParam))
		{
		case DLG_THREAD_NAME:
		case DLG_THREAD_ADDRESS:
			{
				UINT Selection;
				// Get current listbox item
				Selection = SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_GETCURSEL,0,0);
				// Get button state
				LocationDisplay = (BOOL)SendDlgItemMessage(hDlg,DLG_THREAD_NAME,BM_GETCHECK,0,0);
				// Refresh listbox screen
				UpdateListboxContent(hDlg);
				// Set current item
				if (Selection != LB_ERR)
					SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_SETCURSEL,Selection,0);
			}
			break;
		case DLG_THREAD_LIST:
			switch (GET_WM_COMMAND_CMD(wParam,lParam))
			{
				case LBN_SELCHANGE:
					// Enable valid controls
					EnableControls(hDlg);
					break;
				case LBN_DBLCLK:
					// Set focus to specified thread
					if (IsWindowEnabled(GetDlgItem(hDlg, DLG_THREAD_FOCUS)))
					{
						// Disable repainting of the listbox, since we're
						// about to zap it anyway
						SendDlgItemMessage(hDlg, DLG_THREAD_LIST,
							WM_SETREDRAW, FALSE, 0);

						// Set which thread has focus
						SendMessage(
							hDlg,
							WM_COMMAND,
							GET_WM_COMMAND_MPS(
								DLG_THREAD_FOCUS,
								GET_WM_COMMAND_HWND(wParam,lParam),
								0
							)
						);
						// exit
						return SendMessage(
							hDlg,
							WM_COMMAND,
							GET_WM_COMMAND_MPS(
								IDOK,
								GET_WM_COMMAND_HWND(wParam,lParam),
								0
							)
						);
					}
					break;
			}
			break;
		case DLG_THREAD_FOCUS:
			SetThreadState(hDlg,(UINT)SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_GETCURSEL,0,0),THREAD_FOCUS);
			break;
		case DLG_THREAD_SUSPEND:
			SetThreadState(hDlg,(UINT)SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_GETCURSEL,0,0),DLG_THREAD_SUSPEND);
			break;
		case DLG_THREAD_RESUME:
			SetThreadState(hDlg,(UINT)SendDlgItemMessage(hDlg,DLG_THREAD_LIST,LB_GETCURSEL,0,0),DLG_THREAD_RESUME);
			break;
		case IDCANCEL:
			//REENABLE Fiber support in the dm
			if(runDebugParams.fFiberDebugging){
				ofbr.op = OFBR_ENABLE_FBRS;
				OSDSystemService (hpidCurr,
						  htidCurr,
						  ssvcFiberDebug,
						(LPVOID) &ofbr,
						sizeof(ofbr),
						NULL
						);
				OSDGetFrame(hpidCurr,htidCurr,1,&htid);		
			}
			// Restore BOOL flag	
			LocationDisplay = OldLocationDisplay;
			// Don't save anything
			EmptyList(DLG_THREAD_LIST);
			EndDialog(hDlg, TRUE);
			return (TRUE);
		case IDOK:
			//REENABLE Fiber support in the dm
			if(runDebugParams.fFiberDebugging){
				ofbr.op = OFBR_ENABLE_FBRS;
				OSDSystemService (hpidCurr,
						  htidCurr,
						  ssvcFiberDebug,
						(LPVOID) &ofbr,
						sizeof(ofbr),
						NULL
						);
			//Unset the fiber context
				ofbr.op = OFBR_SET_FBRCNTX;
				ofbr.FbrCntx = NULL;
				OSDSystemService (hpidCurr,
						  htidCurr,
						  ssvcFiberDebug,
						  (LPVOID) &ofbr,
						sizeof(ofbr),
						NULL
						);
				OSDGetFrame(hpidCurr,htidCurr,1,&htid);		
			}
			// Make all the changes valid
			ValidateNewThreadStates();
			// HACK: There seems to be an NT bug where it sometimes does
			// not send a WM_SETFOCUS to the child MDI window.  I think
			// this is related to all the SetFocus junk we're doing in
			// UpdateDebuggerState.  Anyway, we can work around the problem
			// by setting focus to the dialog right before it goes away.

			SetFocus(hDlg);
			EmptyList(DLG_THREAD_LIST);
			EndDialog(hDlg, TRUE);
			
			//Some windows don't update on switch to same thread from fiber
			//So force everything
			UpdateDebuggerState(UPDATE_DEBUGGEE|UPDATE_ALLDBGWIN|UPDATE_SOURCE);
			return (TRUE);
		}
		break;
	}

	return( DefaultDialogHandler(hDlg, message, wParam, lParam) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\tokens.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "tokens.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CToken - Wrapper for a TOKEN returned from the lexer.


// Coarse level categorization of tokens.
const static TOKCLS rgtokCls[] = 
{
		tokclsError, 
		tokclsKeyWordMin,
		tokclsOpMin,
		tokclsOpSpecMin,
		tokclsIdentMin,
		tokclsIdentUser,
		tokclsConstInteger,
		tokclsConstReal,
		tokclsConstString,
		tokclsCommentMin,
		tokclsUserMax		// REVIEW: what should we do about the user range. 
};
		
const TOKCLS * CToken::s_rgtokCls = rgtokCls;
int CToken::ctokCls = sizeof(rgtokCls)/sizeof(rgtokCls[0]);

CToken::CToken()
{
	m_token = tokclsError;
	m_tokCls = tokclsError;
}

CToken::CToken(const TOKEN& token)
{
	m_token = token;
	m_tokCls = (TOKCLS)-1;	// Just implies we have not initialized this yet.
}

const CToken& CToken::operator= (const CToken& ctoken)
{
	m_token = ctoken.m_token;
	m_tokCls = (TOKCLS)-1;
	return *this;
}					

const CToken& CToken::operator= (const TOKEN& token)
{
	m_token = token;
	m_tokCls = (TOKCLS)-1;
	return *this;
}					

CToken::operator TOKEN() const
{
	return m_token;
}

TOKCLS CToken::GetTokClass() const
{
	if ( m_tokCls == (TOKCLS)-1)	// not yet determined.
	{
		TOKEN tokSearch = m_token & tokclsMask;

		for ( int i = 0 ; i < ctokCls ; i++ )
		{
			if ( s_rgtokCls[i] > tokSearch)
			{
				((CToken *)this)->m_tokCls = s_rgtokCls[i - 1];	 // logically const.
				break;
			}
		}
		ASSERT(m_tokCls != (TOKCLS)-1);
	}

	return m_tokCls;
}

BOOL CToken::IsCxxIdent() const
{
	return IsUserIdent() || m_token ==  tokKEYW_THIS ;
}

// Is this one of the class of assignment operators.
// i.e. =, +=, -=, *= etc etc.
BOOL CToken::IsAssignOp() const
{
	TOKCLS tokCls = GetTokClass();
	if ( tokCls == tokclsOpMin )
	{
		switch (m_token)
		{
			case tokOP_MODEQ:
			case tokOP_ANDEQ:	
			case tokOP_MULEQ:	
			case tokOP_PLUSEQ:	
			case tokOP_MINUSEQ:	
			case tokOP_DIVEQ:	
			case tokOP_LEQ:	
			case tokOP_ASGN:	
			case tokOP_GEQ:	
			case tokOP_XOREQ:
			case tokOP_OREQ:
			case tokOP_RSHIFTEQ:
			case tokOP_LSHIFTEQ:
				return TRUE;
		}
	}

	return FALSE;
}

BOOL CToken::IsIndirectionOp() const
{
	if (m_token == tokOP_AND || m_token == tokOP_MUL )
		return TRUE;
	else
		return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CTokenStream

CTokenStream::CTokenStream(LPSOURCEEDIT pISourceEdit, ILINE begLine, ILINE endLine)
{
	ASSERT(pISourceEdit != NULL);
	ASSERT(begLine <= endLine);

	// The two conditions below could happen if we found the 
	// incorrect source file or have bad debug info.
	ILINE cLines = 0;
	pISourceEdit->CLines((ULONG*)&cLines);
	if (begLine < 0 || begLine >= cLines)
		return;
	
	if (endLine < 0 || endLine >= cLines)
		return;

	// get the lexer
	CLex *pLex = NULL;
	pISourceEdit->GetLexer((LPVOID*)&pLex);
	if (NULL == pLex)
		return;

	// Make sure we have a "C/C++" lexer, ignore if we have something else
	CString strLang;
	pISourceEdit->GetLanguage(strLang);
	if ((strLang != "C/C++") && (strLang != "Microsoft TSQL") && (strLang != "Microsoft SQL") && (strLang != "Java"))
		return;

	LXS lxs = 0; // O is the ground state for a LXS.
	DWORD dwReserved = 0;

	if ( begLine > 0 )
		pISourceEdit->GetLXS( begLine - 1, &lxs);

	m_rgTokenLine.SetSize(0, endLine - begLine + 1);

	ILINE iLine = begLine;

	int cNonTrivialLines = 0;

	for (int nIndex = 0; iLine <= endLine ; nIndex++, iLine++ )
	{
		PCSTR pcurLine;
		ULONG cb;
		CTokenLine *pTokLine =  new CTokenLine( );
	
		// retrieve the line from the text editor.
		if (!(NO_ERROR == pISourceEdit->GetLineTextSansCrLf(iLine, &pcurLine, &cb)))
			continue;

		// REVIEW: Does the compiler optimize away the redundant CString object in this case. 
		pTokLine->m_strLine = CString(pcurLine, cb);
		
		pLex->CbLexLine(pTokLine->m_strLine, pTokLine->m_strLine.GetLength(), &lxs, pTokLine->m_rgtxtb, dwReserved); 			

		if ( pTokLine->m_rgtxtb.GetSize() != 0 )
		{
			m_rgTokenLine.SetAtGrow(cNonTrivialLines++, pTokLine);
		}
		else 
		{
			delete pTokLine;	// free up the allocated memory.
		}
	}

	m_rgTokenLine.SetSize(cNonTrivialLines);
}

CTokenStream::~CTokenStream( )
{
	for ( int nIndex = 0; nIndex < m_rgTokenLine.GetSize() ; nIndex++ )
		delete m_rgTokenLine[nIndex];
}

CTokenStreamPos CTokenStream::GetHeadPosition() const
{
	
	CTokenStreamPos pos;

	if ( m_rgTokenLine.GetSize() != 0 )
		pos.m_nIndex = 0;
	else
		pos.m_nIndex = -1;

	pos.m_nToken = 0;

	return pos;
}

CTokenStreamPos CTokenStream::GetTailPosition () const
{
	CTokenStreamPos pos;

	if ( m_rgTokenLine.GetSize() == 0 )
	{
		pos.m_nIndex = -1;
		pos.m_nToken = 0;
	}
	else 
	{
		pos.m_nIndex = m_rgTokenLine.GetSize () - 1;
		pos.m_nToken = m_rgTokenLine[pos.m_nIndex]->m_rgtxtb.GetSize () - 1;
	}

	return pos;
}

TXTB* CTokenStream::GetAt (CTokenStreamPos& pos)
{
	ASSERT_VALID(this);

	if (!pos.IsValid ())
	{
		return NULL;
	}
	return &m_rgTokenLine[pos.m_nIndex]->m_rgtxtb[pos.m_nToken];
}

TXTB* CTokenStream::GetNext (CTokenStreamPos& pos)
{
	ASSERT_VALID(this);

	TXTB *ptxtb = GetAt (pos);

	if (ptxtb == NULL)
		return NULL;

	if ( pos.m_nToken + 1 < m_rgTokenLine[pos.m_nIndex]->m_rgtxtb.GetSize() )
	{
		pos.m_nToken++;
	}
	else 
	{
		// Search forward looking for the next valid token.
		int nIndex = pos.m_nIndex;
		while (++nIndex < m_rgTokenLine.GetSize() )
		{
			if ( m_rgTokenLine[nIndex]->m_rgtxtb.GetSize() != 0 )
			{
				pos.m_nToken = 0;
				pos.m_nIndex = nIndex;
				ASSERT_VALID(this);
				return ptxtb;
			}
		}
		pos.m_nIndex = -1;
	}
	return ptxtb;
}

TXTB* CTokenStream::GetPrev (CTokenStreamPos& pos)
{
	ASSERT_VALID(this);

	TXTB *ptxtb = GetAt (pos);

	if (ptxtb == NULL)
		return NULL;

	if ( pos.m_nToken > 0  )
	{
		pos.m_nToken--;
	}
	else 
	{
		// Search backwards looking for the previous valid token.
		int nIndex = pos.m_nIndex;
		while (--nIndex >= 0 )
		{
			if ( m_rgTokenLine[nIndex]->m_rgtxtb.GetSize() != 0 )
			{
				pos.m_nToken = m_rgTokenLine[nIndex]->m_rgtxtb.GetSize() - 1;
				pos.m_nIndex = nIndex;
				ASSERT_VALID(this);
				return ptxtb;
			}
		}
		pos.m_nIndex = -1;
	}

	return ptxtb;
}

CString CTokenStream::GetStringAt (CTokenStreamPos& pos)
{
	ASSERT_VALID(this);

	if (!pos.IsValid ())
	{
		return "";
	}

	TXTB &txtb = m_rgTokenLine[pos.m_nIndex]->m_rgtxtb[pos.m_nToken];
	CString strLine = m_rgTokenLine[pos.m_nIndex]->m_strLine;

	return strLine.Mid(txtb.ibTokMin, txtb.ibTokMac - txtb.ibTokMin);
}

#ifdef _DEBUG

void CTokenStream::AssertValid( ) const
{
}

void CTokenStream::Dump(CDumpContext &dc) const
{
	CObject::Dump(dc);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\treegrid.cpp ===
/// varswnd.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTreeGridRow

CTreeGridRow::CTreeGridRow(CTreeGridWnd *pGridWnd,
						 CTreeGridRow *pParent /*= NULL */)
	: CGridControlRow(pGridWnd)
{
	m_pParent = pParent;

	if ( m_pParent )
		m_nLevels = m_pParent->m_nLevels + 1;
	else
		m_nLevels = 0;

	m_nFlags = TGF_NONE;
}	
	
CTreeGridRow::~CTreeGridRow( )
{
	// We don't allocate any data dynamically.
}

BOOL CTreeGridRow::IsNewRow() const
{
	return FALSE;
}

void CTreeGridRow::Update( )
{
	// Sub-classes should provide interesting behavior if need be.
}

void CTreeGridRow::Restart( )
{
	// Sub-classes should provide interesting behavior if need be.
}

/////////////////////////////////////////////////////////////////////////////
// CTGNewRow

CTGNewRow::CTGNewRow(CTreeGridWnd *pGrid, int editColumn)
	: CBaseClass(pGrid)
{
	m_editColumn = editColumn;
}	

CTGNewRow::~CTGNewRow()
{
}

BOOL CTGNewRow::IsExpandable() const
{
	return FALSE;
}

BOOL CTGNewRow::GetChildren(CTreeGridRowArray&)
{
	ASSERT(FALSE);
	return FALSE;
}

DWORD CTGNewRow::GetChildCount() 
{
	return 0;
}

BOOL CTGNewRow::IsNewRow() const
{
	return TRUE;
}

void CTGNewRow::GetColumnText(int, CString& rStr)
{
	rStr.Empty();
}
	
void CTGNewRow::OnActivate(BOOL bActivate, int nColumn)
{
	if ( bActivate )
	{
		CreateControl(edit, m_editColumn, ES_AUTOHSCROLL);
	}
	else
	{
		CreateControl(none, -1);
	}
}

BOOL CTGNewRow::OnAccept(CWnd *pControlWnd)
{	
	static bInAccept = FALSE;
	if (pControlWnd != NULL)
	{
		// HACK, Adding a new row can cause us to introduce
		// a scrollbar and get an OnSize message. The default
		// OnSize handling calls AcceptControl again. So we end up adding
		// two rows. We just prevent the re-entrancy here.
		if (!bInAccept)
		{
			bInAccept = TRUE;	
			CString str;
		
			pControlWnd->GetWindowText(str);

			if ( !str.IsEmpty())
			{
				// Inform the treegrid about the new value.
				((CTreeGridWnd *)GetGrid())->OnEnterNew(str);
			}
			bInAccept = FALSE;
		}
	}

	return TRUE;
}																		

void CTGNewRow::DrawCell(CDC *pDC, const CRect& cellRect, int nColumn)
{
	if (nColumn == m_editColumn)
	{
		CRect textRect = cellRect;
		AdjustForMargins(textRect, nColumn);

		pDC->ExtTextOut(textRect.left, textRect.top, ETO_CLIPPED | ETO_OPAQUE,
			cellRect, "", 0, NULL);

		pDC->DrawFocusRect(textRect);
	}
	else
	{
		CBaseClass::DrawCell(pDC, cellRect, nColumn);
	}
}
							
void CTGNewRow::ResetSize(CDC *pDC)
{
	// FUTURE: what is the right thing to do here.
	CWindowDC dc(NULL);	
	TEXTMETRIC tm;
	
	dc.GetTextMetrics(&tm);
	m_cyHeight = tm.tmHeight + tm.tmExternalLeading;
}

CSize CTGNewRow::GetCellSize(CDC *, int) const
{
	CSize size;
	
	size.cy = m_cyHeight;
	// This row is flexible so we will not make any size demands.
	size.cx = 0;		

	return size;
}
					 	
int CTGNewRow::GetNextControlColumn(int nColumn)
{
	if ( nColumn < m_editColumn )
		return m_editColumn;
	else
		return -1;
}

int CTGNewRow::GetPrevControlColumn(int nColumn)
{
	if ( nColumn > m_editColumn )
		return m_editColumn;
	else
		return -1;
}



/////////////////////////////////////////////////////////////////////////////
// CTreeGridWnd

CTreeGridWnd::CTreeGridWnd(int nColumns, BOOL bDisplayCaption)
	: CGridControlWnd(nColumns, bDisplayCaption)
{
	// Tree-like grids should not be sorted by other criterion.
	EnableSort(FALSE);
	EnableAutoSort(FALSE);
	m_bNewRow = FALSE;
	m_bForceAccept = FALSE;
}

CTreeGridWnd::~CTreeGridWnd()
{
	// The CGridWnd destructor deletes the rows so we don't
	// need to do the destruction.
}


IMPLEMENT_DYNAMIC(CTreeGridWnd, CGridControlWnd)

BEGIN_MESSAGE_MAP(CTreeGridWnd, CTreeGridWnd::CBaseClass)
	//{{AFX_MSG_MAP(CTreeGridWnd)
	ON_WM_PAINT()
	ON_WM_DESTROY()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_DISMISS_CONTROL, OnDismissControl)
	ON_MESSAGE(WM_WARN_AND_EXPAND, OnWarnAndExpand)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTreeGridWnd Attributes

BOOL CTreeGridWnd::IsExpanded(CTreeGridRow *pRow)
{
	if ( pRow != NULL )
		return ((pRow->m_nFlags & TGF_EXPANDED) != 0);
	else
		return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTreeGridWnd Operations

CTreeGridRow * CTreeGridWnd::GetCurSel( ) const
{
	POSITION pos = GetHeadSelPosition();

	// We should have exactly one item selected.
	if ( pos != NULL)
	{
		CGridElement *pElement = GetNextSel(pos);
	
		ASSERT ( pElement != NULL );
		CGridRow *pRow = pElement->GetRow();
				
		// We should have exactly one row selected
		// the row shouldn'be the caption row.
		if (pos == NULL && pRow != GetCaptionRow())
			return (CTreeGridRow *)pRow;
	}
	return NULL;
}

CTreeGridRow * CTreeGridWnd::GetRow(int nIndex /* = -1*/ )
{
	if ( nIndex == -1 )
		return GetCurSel();
	else
		return (CTreeGridRow *)CBaseClass::GetRow(nIndex);
}

CTreeGridRow * CTreeGridWnd::GetChildRow(CTreeGridRow * pParentRow, int nIndex)
{
	ASSERT(nIndex >= 0);
	ASSERT(pParentRow != NULL);

	
	CTreeGridRow * pChildRow = NULL;
	POSITION pos = m_rows.Find(pParentRow);
	// Skip over the parent row.
	(void)GetNextRow(pos);

	int count = 0;
	while ( pos != NULL )
	{
		CTreeGridRow *pRow = (CTreeGridRow *)GetNextRow(pos);

		if (pRow->m_nLevels <= pParentRow->m_nLevels)
			break;

		if (pRow->m_nLevels == (pParentRow->m_nLevels + 1))
		{
			if (count == nIndex)
			{
				pChildRow = pRow;
				break;
			}
			else
			{
				count++;
			}
		}
	}							
	
	return pChildRow;
}
			
void CTreeGridWnd::Expand(CTreeGridRow *pParent, BOOL bRedraw /* = TRUE */)
{
	ExpandHelper(pParent, bRedraw, TRUE);
}
						  
void CTreeGridWnd::ExpandHelper(CTreeGridRow *pParent, BOOL bRedraw, BOOL bWarn)
{
	ASSERT(pParent != NULL);
	ASSERT(!pParent->IsNewRow());

	// Update the rows expandable/unexpandable bit. Then see if we
	// can really expand this node.

	if (!((pParent->m_nFlags & TGF_EXPANDABLE) ||
		   (pParent->m_nFlags & TGF_NOT_EXPANDABLE)))
	{
		pParent->m_nFlags |= pParent->IsExpandable()
								? TGF_EXPANDABLE : TGF_NOT_EXPANDABLE;

		if (pParent->m_nFlags & TGF_NOT_EXPANDABLE)						
		{
			pParent->m_nFlags &= ~TGF_EXPANDED;
			return;						
		}
	}

	if ( pParent->m_nFlags & TGF_EXPANDED )
		return;		// we are already expanded.

	if (bWarn && pParent->GetChildCount() > GetExpansionWarnCount())
	{
		// Putting up a message box here confuses the drag-drop code 
		// Hence we post a message to warn about the expansion after
		// the current message handler has unwound.
		PostMessage(WM_WARN_AND_EXPAND, (WPARAM)pParent);
		return;
	}
	
	CWaitCursor waitCursor;

   	InsertLevel(pParent, bRedraw);
}

BOOL CTreeGridWnd::InsertLevel(CTreeGridRow *pParent, BOOL bRedraw /* = TRUE*/)
{
	ASSERT(!pParent->IsNewRow());
	ASSERT(pParent->IsExpandable());
	CTreeGridRowArray rgRowArray;

	if ( !pParent->GetChildren(rgRowArray) )
		return FALSE;

	pParent->m_nFlags |= TGF_EXPANDED | TGF_EXPANDABLE;
	pParent->m_nFlags &= ~TGF_NOT_EXPANDABLE;
	if ( rgRowArray.GetSize( ) != 0 )
	{
		CTreeGridRow * pLastRow = rgRowArray[rgRowArray.GetSize() - 1];
		pLastRow->m_nFlags |= TGF_LASTLEVELENTRY;
	}

	InsertMultipleRows(&rgRowArray, pParent, bRedraw);

	// Free up the memory for the array.
	rgRowArray.RemoveAll();

	return TRUE;
}

BOOL CTreeGridWnd::InsertTopLevelRow(CTreeGridRow *pRow, BOOL bRedraw /* = TRUE*/)
{
	ASSERT(pRow->m_pParent == NULL);
	ASSERT(pRow->m_nLevels == 0);

	if ( m_bNewRow )
	{
		POSITION pos = m_rows.GetTailPosition();
		ASSERT(((CTreeGridRow *)GetRowAt(pos))->IsNewRow());
		m_rows.InsertBefore(pos, pRow);
	}
	else
	{
		AddRow(pRow, FALSE);
	}

	if (bRedraw)
		InvalidateGrid();

	return TRUE;
}

BOOL CTreeGridWnd::DeleteTopLevelRow(CTreeGridRow *pRow, BOOL bRedraw /* = TRUE*/)
{
	ASSERT(pRow->m_pParent == NULL);
	ASSERT(pRow->m_nLevels == 0);
	ASSERT(!pRow->IsNewRow());	// Use EnableNewRow for this.

	Collapse(pRow, FALSE);
	RemoveRow(pRow, FALSE);
	delete (pRow);
	
    if (bRedraw)
    {
        AdjustTopVisible();
        InvalidateGrid();
    }

	return TRUE;
}				
	
void CTreeGridWnd::Collapse(CTreeGridRow *pParentRow, BOOL bRedraw /* = TRUE*/)
{
	ASSERT(!pParentRow->IsNewRow());

	int cDeleted = 0;

	if ( !(pParentRow->m_nFlags & TGF_EXPANDED))
		return;		// nothing to do.

	POSITION pos = m_rows.Find(pParentRow);
	// Skip over the parent row.
	(void)GetNextRow(pos);

	// This is kind of tricky, we delete exactly one row
	// at a time, pos is already at the next entry so
	// it is okay to modify the list and still assume
	// that pos is valid.
	while (pos != NULL)
	{
		CTreeGridRow *pRow = (CTreeGridRow *)GetNextRow(pos);
		ASSERT(pRow != NULL);
					
		if ( pRow->m_nLevels <= pParentRow->m_nLevels )
			break;
		
		RemoveRow(pRow, FALSE);
		delete pRow;
		cDeleted++;
	}

	if (bRedraw)
	{
		AdjustTopVisible();
		InvalidateGrid();
	}

	pParentRow->m_nFlags &= ~TGF_EXPANDED;
}	

BOOL CTreeGridWnd::ToggleExpansion(CTreeGridRow *pRow)
{
	BOOL bRet = TRUE;

	if (IsExpanded(pRow))
	{
		Collapse(pRow);
	}
	else {
		if (pRow->IsExpandable( ))
			Expand(pRow);
		else
			bRet = FALSE;
	}
	
	return bRet;
}

void CTreeGridWnd::ActivatePrevControl()
{
	POSITION pos;

	if (GetRowCount() == 0)
		return;

	if ( m_pActiveElement != NULL )
	{
		pos = m_rows.Find(m_pActiveElement->GetRow());
	}
	else if ( !m_selection.IsEmpty() )
	{
		pos = m_rows.Find(m_selection.GetHead());
	}
	else if ( m_posTopVisibleRow != NULL )
	{
		pos = m_posTopVisibleRow;
	}
	else
	{
		// FUTURE: This really should look for the last visible row!
		MessageBeep(0);
		return;
	}

	int nPrevControlColumn = m_nControlColumn;	
	while ( pos != m_rows.GetHeadPosition() )
	{
		nPrevControlColumn = ((CGridControlRow *)GetRowAt(pos))->GetPrevControlColumn(nPrevControlColumn);

		if ( nPrevControlColumn != -1 )
		{
			break;
		}
		else
		{
			m_rows.GetPrev(pos);
		}
	}
			 		
	
	if (pos != NULL && pos != m_rows.GetHeadPosition())
	{
		CGridElement* pElement = (CGridElement*)m_rows.GetAt(pos);
		if (pElement != m_pActiveElement)
			Select(pElement);

		SetActiveElement(pElement, nPrevControlColumn);
		m_posCurRow = pos;
	}
}

void CTreeGridWnd::ActivateNextControl()
{
	POSITION pos;
	
	if (GetRowCount() == 0)
		return;

	if ( m_pActiveElement != NULL )
	{
		pos = m_rows.Find(m_pActiveElement->GetRow());
	}
	else if ( !m_selection.IsEmpty() )
	{
		pos = m_rows.Find(m_selection.GetHead());
	}
	else if ( m_posTopVisibleRow != NULL )
	{
		pos = m_posTopVisibleRow;
	}
	else
	{
		// FUTURE: This really should look for the last visible row!
		MessageBeep(0);
		return;
	}
	
	int nNextControlColumn = m_nControlColumn;
	while ( pos != NULL )
	{
		nNextControlColumn = ((CGridControlRow *)GetRowAt(pos))->GetNextControlColumn(nNextControlColumn);

		if ( nNextControlColumn != -1 )
		{
			break;
		}
		else
		{
			m_rows.GetNext(pos);
		}
	}
	
	if (pos != NULL)
	{
		CGridElement* pElement = (CGridElement*)m_rows.GetAt(pos);
		if (pElement != m_pActiveElement)
			Select(pElement);
		SetActiveElement(pElement, nNextControlColumn);
		m_posCurRow = pos;
	}
}

BOOL CTreeGridWnd::ProcessKeyboard( MSG *pMsg, BOOL bPreTrans /* = FALSE */)
{
	switch(pMsg->message)
	{
	default:
		break;
	case WM_KEYDOWN:
		{
			BOOL bControl = GetKeyState(VK_CONTROL) < 0;
			BOOL bMenu = GetKeyState(VK_MENU) < 0;
			// Is an edit control currently active.
			BOOL bEditCtrl = m_pControlWnd != NULL;
			CTreeGridRow * pRow = GetCurSel();

			switch(pMsg->wParam)
			{

			case VK_TAB:
				// If we are currently editing in the new row, just treat Tab to mean
				// add a new value. This is important as the interaction of default
				// tab behavior with the fact that a new row gets inserted produces
				// strange behavior.
				if ( pRow != NULL && m_pControlWnd != NULL && pRow->IsNewRow( ))
				{
					// control-tab is mdi window switching
					if (bControl)
						break;

					AcceptControl();
					return TRUE;
				}
				break;
			case VK_ADD:
			case VK_RIGHT:
				if ( !bEditCtrl && pRow != NULL && pRow->IsExpandable() )
				{
					if (!bControl)
						Expand(pRow);

					return TRUE;
				}
				break;

			case VK_SUBTRACT:
				if (!bEditCtrl && pRow != NULL && pRow->IsExpandable())
				{
					if (!bControl && IsExpanded(pRow) )
					{
						Collapse(pRow);
					}
					return TRUE;
				}
				break;

			case VK_LEFT:
				if (!bEditCtrl && pRow != NULL)
				{
					if ( !bControl && IsExpanded(pRow) )
					{
						Collapse(pRow);
						return TRUE;
					}	
				}
				// Fall through.
											
			case VK_BACK:
				// In a tree-control backspace is
				// "go to parent".
				if ( !bEditCtrl && pRow != NULL)
				{
					if ( !bControl && pRow->m_pParent != NULL )
					{	// Go to the parent row.
						Select(pRow->m_pParent);
					}
					return TRUE;
				}
				break;

			case VK_RETURN:
				if ( m_pControlWnd == NULL && !bMenu)
				{
					if ( pRow != NULL && ToggleExpansion(pRow))
					{	
						return TRUE;
					}
				}
				break;

			default:
				break;
			} /* end switch */

		}
		
	case WM_CHAR:
		{
			CTreeGridRow * pRow = GetCurSel();

			if (pRow != NULL && m_pControlWnd == NULL)
			{
				switch(pMsg->wParam)
				{
					case '+':
						if (pRow->IsExpandable())
						{
							Expand(pRow);
							return TRUE;
						}
						break;
					case '-':
						if (pRow->IsExpandable())
						{
							if (IsExpanded(pRow))
								Collapse(pRow);

							return TRUE;
						}
						break;

					default:
						break;
				}
			}
		}
					
	}

	return CBaseClass::ProcessKeyboard(pMsg, bPreTrans);
}

BOOL CTreeGridWnd::Refresh(CTreeGridRow *pRow, int& nIndex)
{
	BOOL bRetVal = FALSE;

	if (pRow->m_nFlags & TGF_DIRTY_DELETE)	
	{
		// FUTURE: This will cause us to miss a row in RefreshAllRoots
		// if a top level row is marked TGF_DIRTY_DELETE.

		// This row and any of its children need to be deleted.
		if (pRow->m_nFlags & TGF_EXPANDED )
			Collapse(pRow, FALSE);
		
		RemoveRow(pRow, FALSE);
		delete pRow;
		nIndex--;	// the current index should be refreshed again.
		bRetVal = TRUE;
	}					
	else if (pRow->m_nFlags & TGF_DIRTY_CONTENT)
	{
		BOOL bWasExpanded = FALSE;

		// reset the dirty node.
		pRow->m_nFlags &= ~TGF_DIRTY_CONTENT;

		// If it is expanded, collapse it.
		if (pRow->m_nFlags & TGF_EXPANDED)
		{
			bWasExpanded = TRUE;
			Collapse(pRow, FALSE);
		}

		pRow->m_nFlags &= ~(TGF_EXPANDABLE|TGF_NOT_EXPANDABLE);
		pRow->m_nFlags |= pRow->IsExpandable() ? TGF_EXPANDABLE : TGF_NOT_EXPANDABLE;

		if ( bWasExpanded )
		{
			if ( pRow->m_nFlags & TGF_EXPANDABLE)
				Expand(pRow, FALSE);

			bRetVal = TRUE;
		}				
	}
	// If we have children and they are expanded,
	// perform this function on them first.	
	else if  ( pRow->m_nFlags & TGF_EXPANDED )						
	{
		int nIndexT =  nIndex + 1;
		POSITION pos;

		while  ((pos = m_rows.FindIndex(nIndexT)) != NULL )
		{
			CTreeGridRow * pRowChild;

			if ((pRowChild = (CTreeGridRow *)GetRowAt(pos)) == NULL)
			{
				ASSERT(FALSE);
				break;
			}

			if (pRowChild->m_nLevels <= pRow->m_nLevels )
				break;

			// Just refresh our children.
			if (pRowChild->m_nLevels == (pRow->m_nLevels + 1))
			{
				if ( Refresh(pRowChild, nIndexT) )
					bRetVal = TRUE;
			}

			nIndexT++;
		}
	}

	if (pRow->m_nFlags & TGF_DIRTY_ITEM)
	{
		bRetVal = TRUE;
		pRow->m_nFlags &= ~TGF_DIRTY_ITEM;
	}

	return bRetVal;
}

void CTreeGridWnd::RefreshAllRoots( )
{
	POSITION pos;
	int nIndex = 1;
	BOOL bInvalidate = FALSE;

	// Note: we use the index for iterating instead of
	// using GetNextRow on the pos, because the pos could
	// become invalid if refresh causes some items to be
	// add/deleted from the list.

	while ((pos = m_rows.FindIndex(nIndex)) != NULL)
	{
		CTreeGridRow * pRow = (CTreeGridRow *)GetRowAt(pos);
		if ( pRow->m_nLevels == 0 && !pRow->IsNewRow())
		{
			if (Refresh(pRow, nIndex))
				bInvalidate = TRUE;
		}					
		nIndex++;
	}

	// If any of the refreshing requires us to invalidate do it now.
	if (bInvalidate)
		InvalidateGrid( );
}


CTGNewRow * CTreeGridWnd::CreateNewRow( )
{
	// You need to provide an override in a sub-class
	// if you want this capability.
	ASSERT(FALSE);
	return NULL;
}	

void CTreeGridWnd::OnEnterNew(CString str)
{
	// Sub-class should override this to deal with the user
	// entering a new row.
	ASSERT(FALSE);
	return;
}

void CTreeGridWnd::EnableNewRow(BOOL bEnable /* = TRUE */)
{
	if ( m_bNewRow == bEnable )
		return;
		
	m_bNewRow = bEnable;
	
	if ( m_bNewRow )
	{
		CTGNewRow * pNewRow = CreateNewRow();
		if ( pNewRow )
			AddRow(pNewRow);
		else
		{
			m_bNewRow = FALSE;
			return;
		}		
	}
	else {									
		int cRows = GetRowCount();
		CTreeGridRow *pRow = GetRow(cRows - 1);

		ASSERT(pRow != NULL);
		if ( pRow->IsNewRow( ))
		{
			RemoveRow(pRow);
			delete pRow;
		}
		else
		{
			ASSERT(FALSE);
		}
	}
	
	return;
}			
		
			
						

void CTreeGridWnd::DirtyRow(CTreeGridRow *pRow, int tf)
{
	ASSERT(pRow != NULL);
	ASSERT(!pRow->IsNewRow());

	pRow->m_nFlags |= tf;
	Invalidate( );
}

BOOL CTreeGridWnd::DeleteSelectedRows( )
{
	POSITION pos = GetHeadRowPosition( );
	CTreeGridRow *pRowFirstSelected = NULL;
	CTreeGridRow *pRowSelectLater = NULL;

	while ( pos != NULL )
	{
		CTreeGridRow *pRow = (CTreeGridRow *)GetNextRow(pos);
		// Either we are a top-level row or atleast
		// somebody up on the chain should also be marked for
		// deletion.
		if ( IsSelected(pRow))
		{
			// Remember the first selected row. This will be used
			// to set the selection after the deletion is done.
			if (pRowFirstSelected == NULL)
				pRowFirstSelected = pRow;

			if ( pRow->m_nLevels != 0 )
			{
				CTreeGridRow * pRowParent = pRow->m_pParent;
				while ( pRowParent )
				{
					if (IsSelected(pRowParent))
					{
						break;
					}
					else {
						pRowParent = pRowParent->m_pParent;
					}
				}

				if (pRowParent == NULL)
				{	
					// None of this rows parents are selected.
					// it is illegal to delete this row.
					return FALSE;
				}
			}
		}
		else
		{
			if ( pRowFirstSelected != NULL && pRowSelectLater == NULL)
			{
				// Figure out which row gets the selection after the deletion is done.
				// The rules are
				// a) Pick the first non-selected row after the first selected row.
				//    In case of the treegrid this row has to be at level 0 as all children
				//    of the selected row will get deleted automatically.
				// b) If there is no such row pick the row before the first selected row.
				if ( pRow->m_nLevels == 0 )
					pRowSelectLater = pRow;
			}
		}
	}

	
	if (pRowSelectLater == NULL)
	{
		POSITION pos = m_rows.Find(pRowFirstSelected);
		(void)GetPrevRow(pos);		// Skip over the First selected row.
		if (pos != NULL)
			pRowSelectLater = GetRowAt(pos);		
	}

	// We can now proceed with the actual deletion.
	int nIndex = 1;

	while ( (pos = m_rows.FindIndex(nIndex++)) != NULL)
	{
		CTreeGridRow *pRow = (CTreeGridRow *)GetRowAt(pos);

		if (IsSelected(pRow) && pRow->m_nLevels == 0 && !pRow->IsNewRow())
		{
			if ( DeleteTopLevelRow(pRow, FALSE) )
				nIndex--;
		}
	}

	// it is possible that the new row is still selected.
	if ((GetHeadSelPosition() == NULL) && pRowSelectLater != NULL)
		Select(pRowSelectLater);

    AdjustTopVisible();
	InvalidateGrid();

	return TRUE;
}		

	
void CTreeGridWnd::FreeAllData( )
{
}

void CTreeGridWnd::InsertRowAfter(CTreeGridRow *pRow, CTreeGridRow *pRowAfter,
						BOOL bRedraw /* = TRUE*/ )
{
	ASSERT_VALID(this);
	ASSERT(!pRowAfter->IsNewRow());

	POSITION pos;

	if ( pRowAfter == NULL)
		pos = m_rows.GetHeadPosition();
	else
	{
		pos = m_rows.Find(pRowAfter);
	}
	
	ASSERT( pos != NULL);
	m_rows.InsertAfter(pos, pRow);

	if (bRedraw )
		InvalidateGrid();
}			

			
void CTreeGridWnd::InsertMultipleRows(CTreeGridRowArray *rgpRow,
				CTreeGridRow *pRowAfter, BOOL bRedraw /* = TRUE */)
{
	ASSERT_VALID(this);
	ASSERT(!pRowAfter->IsNewRow());

	POSITION pos;
	
	if (pRowAfter == NULL)
	{
		pos = m_rows.GetHeadPosition();
	}
	else
	{
		pos = m_rows.Find(pRowAfter);
	}

	ASSERT(pos != NULL);

	for ( int i = 0 ; i < rgpRow->GetSize( ); i++ )
	{
		pos = m_rows.InsertAfter(pos, (*rgpRow)[i]);
	}

	if (bRedraw )
		InvalidateGrid();
}
				
void CTreeGridWnd::InvalidateGrid()
{
	if (m_hWnd != NULL)
	{
		ResetSize();
		Invalidate(FALSE);
		ResetScrollBars();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTreeGridWnd diagnostics

#ifdef _DEBUG
void CTreeGridWnd::AssertValid() const
{
	// Sorted tree control doesn't make sense.
	// ASSERT(m_nSortColumn == -1);
	CBaseClass::AssertValid();
}

void CTreeGridWnd::Dump(CDumpContext& dc) const
{
	CBaseClass::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTreeGridWnd message handlers


void CTreeGridWnd::OnPaint()
{
	// we want to search through the tree control
	// for any dirty nodes, if we find one of these
	// we want to update it's contents
	RefreshAllRoots();		// refresh from our roots down

	CBaseClass::OnPaint();	// pass on to our base instance
}

void CTreeGridWnd::OnDestroy()
{
	CBaseClass::OnDestroy();

}


BOOL CTreeGridWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{

	// HACK begets HACK. CGridControlWnd bypasses command handlers
	// in the grid window if no control is enabled. We need to handle
	// commands even when no control is available. So directly
	// call CGridWnd's OnCmdMsg.	
	return CGridWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}




int CTreeGridWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CBaseClass::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (GetRowCount() != 0)
		Select(GetRow(0));
			
	return 0;
}

LRESULT CTreeGridWnd::OnDismissControl(WPARAM, LPARAM)
{
	m_bForceAccept = TRUE;
	AcceptControl();
	m_bForceAccept = FALSE;

	return 0;
}

LRESULT CTreeGridWnd::OnWarnAndExpand(WPARAM wParam, LPARAM)
{
	CTreeGridRow * pParent = (CTreeGridRow *)wParam;

	if (MsgBox(Question, IDS_EXPANSION_WARN, MB_YESNO|MB_DEFBUTTON2) == IDYES)
	{
		ExpandHelper(pParent, TRUE, FALSE);
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\watchrow.cpp ===
// watchrow.cpp : implementation file
//

#include "stdafx.h"
#pragma	  hdrstop	

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new	DEBUG_NEW
#endif


CImageWell CWatchRow::s_imgPlusMinus;
int CWatchRow::s_cUsage;


/////////////////////////////////////////////////////////////////////////////
// CWatchRow


CWatchRow::CWatchRow ( CTreeGridWnd * pGrid, CTM *pTM, CTreeGridRow *pParent)
	: CBaseClass ( pGrid, pParent )
{
	m_pTM = pTM;	
	m_bValueBeingEdited  = FALSE ;  // TREAD carefully when changing anything about this variable.
	m_bHasSynthChild	= FALSE;
	m_bValueChanged		= FALSE;

	if (!s_cUsage++)
	{
		s_imgPlusMinus.LoadSysColor(IDB_VARSEXPAND, CSize(cxBitmap, cyBitmap));
		s_imgPlusMinus.Open();
		pGrid->m_cxSelectMargin = cxBeforeBmap ;
	}		
}


CWatchRow::~CWatchRow ( )
{
	delete m_pTM;
	if (!--s_cUsage)
	{
		s_imgPlusMinus.Close();
		s_imgPlusMinus.Unload();
	}		
}

CWatchRow * CWatchRow::NewWatchRow(CTreeGridWnd * pGrid, CTM *pTM, CTreeGridRow *pParent)
{
	return new CWatchRow(pGrid, pTM, pParent);
}

int CWatchRow::GetNextControlColumn ( int nColumn )
{
	ASSERT(COL_NAME < COL_VALUE);

	CDbgGridWnd *pGrid = (CDbgGridWnd *)GetTreeGrid();

	if ( nColumn < COL_NAME )
	{
		if (GetTM()->IsNameEditable() && pGrid->IsEditable())
			return COL_NAME;
		else if (GetTM()->IsValueEditable())
			return COL_VALUE;
		else
			return -1;
	}			
	else if ( nColumn == COL_NAME )
	{
		if (GetTM()->IsValueEditable())
			return COL_VALUE;
		else
			return -1;	
	}
	else
	{
		return -1;
	}
}

int CWatchRow::GetPrevControlColumn ( int nColumn )
{
	CDbgGridWnd *pGrid = (CDbgGridWnd *)GetTreeGrid();

	if ( nColumn == -1 )
	{
		if (GetTM()->IsValueEditable())
			return COL_VALUE;
		else if (GetTM()->IsNameEditable() && pGrid->IsEditable())
			return COL_NAME;
		else
			return -1;
	}
	else if (nColumn == COL_VALUE)
	{
		if (GetTM()->IsNameEditable() && pGrid->IsEditable())
		 	return COL_NAME;
		else
			return -1;
	}
	else
	{
		return -1;
	}		
}					
	

// This is called to supply text for default column drawing as
// well as to fill the edit-box

void CWatchRow::GetColumnText( int nColumn, CString& str )
{
	CTM *pTM = GetTM( );
	
	switch ( nColumn )
	{
		case COL_NAME:
			str = pTM->GetName( );
			break;

		case COL_VALUE:
			if ( m_bValueBeingEdited  )
			{
				str = pTM->GetEditableValue( );
			}
			else
			{
				str = pTM->GetValue( );
			}
			break;
		default:
			ASSERT(FALSE);
	}
}		

void CWatchRow::GetValueStr( CString & str)
{
	str = GetTM()->GetValue();
}

int CWatchRow::Compare(const CGridRow *pCompareRow) const
{
	CString strRow, strCompareRow;

	// Currently we have no way to deal with child rows.
	ASSERT(m_nLevels == 0);

	// We should never be sorting two rows which are at different levels.
	ASSERT(m_nLevels == ((CTreeGridRow *)pCompareRow)->m_nLevels);

	strRow = ((CWatchRow *)this)->GetTM()->GetName();
	strCompareRow = ((CWatchRow *)pCompareRow)->GetTM()->GetName();

	int nIndex;

	// remove leading *'s and &'s from the first string.
	for (nIndex = 0; nIndex < strRow.GetLength() ; nIndex++)
	{
		TCHAR tch = strRow[nIndex];

		if (tch != '*' && tch != '&')
			break;
	}

	ASSERT(nIndex < strRow.GetLength());

	strRow = strRow.Mid(nIndex);

	// trim the second string as well.
	for (nIndex = 0; nIndex < strCompareRow.GetLength() ; nIndex++)
	{
		TCHAR tch = strCompareRow[nIndex];

		if (tch != '*' && tch != '&')
			break;
	}

	ASSERT(nIndex < strCompareRow.GetLength());
	strCompareRow = strCompareRow.Mid(nIndex);

	return strRow.CompareNoCase(strCompareRow);
}

// This is called when the user types in a new value for a variable.

BOOL  CWatchRow::OnAccept ( CWnd* pControlWnd  )
{
	if ( pControlWnd != NULL )
	{
		CString strNew ;
		CTM * pTM = GetTM( );
		pControlWnd->GetWindowText(strNew);

		// Which column are we editing.

		switch ( GetTreeGrid()->m_nControlColumn )
		{
			case COL_NAME:
				// Don't do anything if the string didn't change.
				if (pTM->GetName( ) == strNew )
					return TRUE ;
				
				if ( strNew.IsEmpty( ) )
				{
					GetTreeGrid()->DirtyRow(this, TGF_DIRTY_DELETE);
					return TRUE;
				}
				// Ok new name, we need to replace our TM.
				delete m_pTM;
				m_pTM = new CRootTM(strNew);
	
				{
				int tgf = TGF_DIRTY_ITEM;
				if ( GetTreeGrid()->IsExpanded(this) )
					tgf |= TGF_DIRTY_CONTENT;

				GetTreeGrid( )->DirtyRow(this, tgf);
				}
					
				if ( m_pTM->HadSideEffects() )
				{
					OnModify();
				}

				break;
			case COL_VALUE:
				m_bValueBeingEdited = FALSE;
				// If the string hasn't changed don't update the value
				if ( pTM->GetEditableValue( ) == strNew )
					return TRUE ;

				// Tell the CWtchPane to update the expression..
				if ( ! GetTM()->ModifyValue(strNew) )
				{
					// not succesful in updating the value.
					// display message box indicating there is a problem.
					// FUTURE: use MessageBeep instead of MessageBox,
					// till setting up msg boxes from docking windows
					// works correctly.
					::MessageBeep(0);
					return GetTreeGrid()->m_bForceAccept;
				}
				else
				{
					OnModify();
				}
				break ;
			default:
					ASSERT(FALSE);
		}
	}
	return ( TRUE );
}

void CWatchRow::OnModify()
{
	// Default action is to update all the debugger windows, whenever a value is modified.
	::UpdateDebuggerState(UPDATE_ALLDBGWIN);
}

void CWatchRow::OnControlNotify( UINT nControl, UINT nNotification)
{
	CTreeGridWnd *pGrid = GetTreeGrid( );

	switch ( pGrid->m_controlType)
	{
		case edit:
			if (nNotification == EN_KILLFOCUS)
			{
				CWnd *pNewWnd = CWnd::GetFocus( );

				// This code causes the auto-commit of the active control
				// if the user clicks in some other window.
				// pNewWnd != NULL => don't commit if focus is lost to another app.
				//
				if (  pNewWnd != NULL && (pNewWnd != pGrid) &&
					!pGrid->IsChild(pNewWnd) && !pNewWnd->IsChild(pGrid))
				{
					pGrid->PostMessage(WM_DISMISS_CONTROL);
					return;
				}
			}
			break;
	}
	CBaseClass::OnControlNotify(nControl, nNotification);
}
			
		
void CWatchRow::OnActivate(BOOL bActivate, int nColumn )
{
	if ( bActivate )
	{
		ASSERT(GetTreeGrid()->IsKindOf(RUNTIME_CLASS(CDbgGridWnd)));

		CDbgGridWnd *pGrid = (CDbgGridWnd *)GetTreeGrid();

		switch ( nColumn )
		{
			case COL_NAME:
				if ( DebuggeeAlive() && !DebuggeeRunning() &&
					 GetTM( )->IsNameEditable( ) &&
					 pGrid->IsEditable() )
				{
					CreateControl(edit, COL_NAME, ES_AUTOHSCROLL);
				}
				break ;
			case COL_VALUE:
				{
					CTM * pTM  = GetTM( );

					// If the value field is editable, create the edit control
					if ( DebuggeeAlive() && !DebuggeeRunning() &&
							pTM->IsValueEditable( ) )
					{	
						// FUTURE: refer to code in GetColumnRect which uses
						// m_bValueBeingEdited. The value should be assigned
						// before calling CreateControl. BAD HACK
						// this depends on the understanding of how the grid
						// control itself works.
						m_bValueBeingEdited = TRUE ;	
						CreateControl(edit, COL_VALUE, ES_MULTILINE);
					}
					break;
				}
			default:
				ASSERT(nColumn == -1);
				break;
		}
		// If we didn't create a control we don't want to be the
		// active element. This is neccessary because otherwise
		// clicking on the row header causes a visible state change
		// as the currently active element gets a wider highlight
		// then ordinary selected elements.
		if ( pGrid->m_pControlWnd == NULL )
			pGrid->SetActiveElement(NULL);
	}
	else
	{
		m_bValueBeingEdited = FALSE;
		CreateControl(none, -1);
	}
}

void CWatchRow::ResetSize ( CDC *pDC )
{
	
	CRect rect(0,0, GetGrid()->GetColumnWidth(COL_VALUE) - 2 * cxMargin, 0);
	CString str;
	GetValueStr(str);

	UINT dt = DT_CALCRECT|DT_NOPREFIX;

	// Strings in error are only displayed in single-line. This is so
	// useless error messages don't take up too much space.
	if ( GetTM()->IsValueValid() )
		dt |= DT_WORDBREAK;
	else
		dt |= DT_SINGLELINE;

	// Black Magic that I don't understand. If the row's height is less 
	// than the number we get from the calculation below, the edit control
	// that comes up in the grid doesn't have anything visible on certain
	// settings ( NT 3.5 1024*768 Large Fonts). Similar logic is found in
	// the version editor and the use of CWindowDC dc(NULL) is common in the
	// grid control code as well. Need to figure out what the real deal here is.
	// [sanjays]

	TEXTMETRIC tm;
	CWindowDC dc(NULL);
	dc.GetTextMetrics(&tm);
	int cyMinHeight = tm.tmAscent + tm.tmInternalLeading + 1;

	if ( cyMinHeight < cyMinPlusColHeight )
		cyMinHeight = cyMinPlusColHeight;

	m_cyHeight = 2 * cyMargin + pDC->DrawText(str, str.GetLength(), rect, dt);

	if ( m_cyHeight < cyMinHeight)
		m_cyHeight = cyMinHeight;

	// m_sizeM = pDC->GetTextExtent("M", 1);
}

void CWatchRow::AdjustForMargins( CRect& rect, int nColumn )
{
	// The default margins used by the CGridWnd class are too big
	// for us, so we use our own.
	rect.InflateRect(-cxMargin, -cyMargin);
}
	
CSize  CWatchRow::GetCellSize(CDC* pDC, int nColumn)	 const
{
	// Calculate size to display the text .
	CSize size ;

	if ( nColumn == COL_NAME )
	{
		CString str;
		// Cast away the constness so we can call this function
		// to get the text for this column.
		((CWatchRow *)this)->GetColumnText(nColumn, str);				
		size = 	pDC->GetTextExtent(str, str.GetLength( ));
	 	size.cx += 2 * cxMargin ;
		// Now add the space for the +/- portion.
		size.cx += GetPlusColWidth() ;
		// size.cx += m_nLevels * m_sizeM.cx;
	}
	else if (nColumn  == COL_VALUE)
	{
		size.cx = GetGrid()->GetColumnWidth(COL_VALUE);
	}
	
	// Should be the same as the height we already indicated.
	size.cy = m_cyHeight;
		
	return size;
}

CRect CWatchRow::ComputeGlyphRect(CDC *pDC, const CRect& cellRect)
{
	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);

	CRect glyphRect(cellRect);

	AdjustForMargins(glyphRect, COL_NAME);

	int height = tm.tmHeight + tm.tmExternalLeading;

	// We want to center the glyph assuming that we have single-line row,
	// so assume that the row height is just the char height.
	glyphRect.bottom = glyphRect.top + height;

	// Factor in the fact that we might have increased the size beyond the size reqd by the
	// font to make the glyph look good.
	if ( height + 2 * cyMargin < cyMinPlusColHeight )
		glyphRect.bottom += cyMinPlusColHeight - (height + 2 * cyMargin);

	
	glyphRect.left = cxBeforeBmap + m_nLevels * cxBitmap ; // x-placement is static.
	glyphRect.top += (glyphRect.Height() - cyBitmap)/2;

	glyphRect.right = glyphRect.left + cxBitmap;
	glyphRect.bottom = glyphRect.top + cyBitmap;

	// Rememeber the displacement of the glyph rectangle from the top-left border of the cell.
	m_dispGlyph.cx = glyphRect.left - cellRect.left;
	m_dispGlyph.cy = glyphRect.top - cellRect.top;

	return glyphRect;
}


CRect CWatchRow::GetGlyphRect(const CRect& cellRect) const
{
	CRect glyphRect;

	glyphRect.left = cellRect.left + m_dispGlyph.cx;
	glyphRect.top = cellRect.top + m_dispGlyph.cy;
	glyphRect.right = glyphRect.left + cxBitmap;
	glyphRect.bottom = glyphRect.top + cyBitmap;

	return glyphRect;
}

void CWatchRow::DrawCell( CDC *pDC , const CRect& cellRect, int nColumn )
{

	COLORREF rgbForeground = pDC->SetTextColor(GetSysColor(COLOR_BTNSHADOW));
	CBrush* pOldBrush = pDC->SelectObject(CDC::GetHalftoneBrush());

	// Cell Rect excluding border regions if any.
	CRect cellRectSansBorder(cellRect);

	// Draw the border, each cell takes responsibility for painting
	// their bottom and right edges.

	pDC->PatBlt(cellRect.left, cellRect.bottom -1,  cellRect.Width(), 1, PATCOPY);

	// Exclude the border region.
	cellRectSansBorder.bottom -= 1;

	// The last column doesn't need the vertical border
	//  as the frame window has a border.	
	if ( (nColumn + 1) !=  GetGrid()->GetColumnCount() )
	{
		pDC->PatBlt(cellRect.right -1, cellRect.top, 1, cellRect.Height(), PATCOPY);
		cellRectSansBorder.right -= 1 ;
	}
	
	pDC->SelectObject(pOldBrush);
	pDC->SetTextColor(rgbForeground);

	// Get the string we are supposed to draw.
	CString str ;
	GetColumnText(nColumn, str);
		
	// Adjust for the margins on the top and bottom.
	CRect textRect(cellRect);
	AdjustForMargins(textRect, nColumn);
	

	if  ( nColumn == COL_NAME )
	{	
		// clear the background
		pDC->ExtTextOut(0,0, ETO_OPAQUE, cellRectSansBorder, NULL, 0, NULL);

		CRect glyphRect = ComputeGlyphRect(pDC, cellRect);

		// Select gray brush for drawing the actual tree.
		pOldBrush = (CBrush *) pDC->SelectStockObject(GRAY_BRUSH);


		if ( IsExpandable() || IsRetVal())
		{
			BOOL bExpanded = GetTreeGrid()->IsExpanded(this);

			UINT nImage;
			if (IsRetVal() )
			{
				ASSERT(!IsExpandable());
				nImage = IMG_RETVAL;
			}
			else
				nImage = bExpanded ? IMG_MINUS : IMG_PLUS;

			CPoint destPoint = glyphRect.TopLeft();

			s_imgPlusMinus.DrawImage(pDC, destPoint, nImage, SRCCOPY);

			// If we are expanded draw the line from the center of the glyph to the bottom.
			if ( bExpanded )
			{
				CPoint point;
				point.x = glyphRect.left + glyphRect.Width()/2;
				point.y = glyphRect.bottom;
				pDC->PatBlt(point.x, point.y, 1, (cellRect.bottom - glyphRect.bottom), PATCOPY);
			}	
		}
		
		if ( m_pParent != NULL )
		{
			int x = cxBeforeBmap + ((m_nLevels - 1) * cxBitmap) + cxBitmap/2;
			int y = glyphRect.top + glyphRect.Height() / 2;

			// Draw the horizontal line to the item
			int cxWidth;
			
			if (IsExpandable())
				cxWidth = (cxBitmap/2);
			else if (m_nFlags & TGF_LASTLEVELENTRY)
				cxWidth = (cxBitmap + cxBitmap/2); // Arms for the last row are slightly longer for demarcation.
			else
				cxWidth = cxBitmap;

			pDC->PatBlt(x, y, cxWidth, 1, PATCOPY);
			
			// Draw the vertical line from the parent.
			if ( m_nFlags & TGF_LASTLEVELENTRY )
				pDC->PatBlt(x, cellRect.top, 1, (y - cellRect.top), PATCOPY);
			else
				pDC->PatBlt(x, cellRect.top, 1, m_cyHeight, PATCOPY);

			// Draw the verticals in the left connecting other nodes.
			int nLevel = m_nLevels;
			for (CTreeGridRow * pRowT = m_pParent ; pRowT != NULL ; pRowT = pRowT->m_pParent)
			{
				nLevel -= 1;
				x -= cxBitmap;

				if (!(pRowT->m_nFlags & TGF_LASTLEVELENTRY) && (pRowT->m_pParent != NULL))
					pDC->PatBlt(x, cellRect.top, 1, m_cyHeight, PATCOPY);
			}		
		}
		
		pDC->SelectObject(pOldBrush);

		int cxBeginName = glyphRect.left + glyphRect.Width() + cxAfterBmap;

		// Finally draw the text after the glyph has been drawn.
		pDC->ExtTextOut(cxBeginName, textRect.top,  ETO_CLIPPED,
						cellRectSansBorder , str, str.GetLength( ), NULL);
				
	}
	else if (nColumn == COL_VALUE)
	{
		// clear the background
		pDC->ExtTextOut(0,0, ETO_OPAQUE, cellRectSansBorder, NULL, 0, NULL);

		UINT dt;
		if ( GetTM()->IsValueValid( ))
			dt = DT_NOPREFIX | DT_WORDBREAK ;
		else
			dt = DT_NOPREFIX | DT_SINGLELINE ;
		
		CDbgGridWnd *pGrid = (CDbgGridWnd *)GetTreeGrid();
		// Only permanent windows i.e watch and variables which have a
		// view attached to it, show color highlighting.
		BOOL bHiliteChanges = IsValueChanged() &&
				(pGrid->GetView() != NULL) && GetTM()->IsValueValid();

		COLORREF crOldText, crText, crBk;

		if (bHiliteChanges)
		{	
			pGrid->GetChangeHighlightColors(crText, crBk);
			crOldText = pDC->SetTextColor(crText);
		}
				
		// The value column can be m ulti-row if need be.
		pDC->DrawText(str, str.GetLength(), textRect, dt);

		if (bHiliteChanges)
		{
			pDC->SetTextColor(crOldText);
		}
	}
	else			
	{
		ASSERT(FALSE);
	}

}

UINT CWatchRow::HitTest(CPoint pt)
{
	CTreeGridWnd *pGrid = GetTreeGrid();
	CRect rcCell;
	GetRect(rcCell); // top, bottom and left are correct here

	int cxName = pGrid->GetColumnWidth(COL_NAME);
	int cxValue = pGrid->GetColumnWidth(COL_VALUE);
	rcCell.right = rcCell.left + cxName + cxValue;

	if (!rcCell.PtInRect(pt))
		return WRH_NONE;
	
	if (rcCell.left + cxName <= pt.x)
		return WRH_VALUE;

	if (rcCell.left + GetPlusColWidth() <= pt.x)
		return WRH_NAME;
	
	if (IsExpandable())
	{
		CRect rcGlyph( GetGlyphRect(rcCell) );
		if ( rcGlyph.PtInRect(pt) )
			return WRH_GLYPH;
	}

	return WRH_SELMARGIN;
}

BOOL CWatchRow::OnLButtonDown(UINT nFlags, CPoint pt)
{
	if ( !(nFlags & MK_CONTROL || nFlags & MK_SHIFT) )
	{
		if ( WRH_GLYPH == HitTest(pt) )
		{
			GetTreeGrid()->ToggleExpansion(this);
			// We still want the default action of selection to happen.
		}
	}
		
	return CBaseClass::OnLButtonDown(nFlags, pt) ;
}				

BOOL CWatchRow::OnLButtonUp( UINT nFlags, CPoint pt)
{
	// We don't want to activate the name field if the
	// hit-test put us in the tree part of the column.
	if ( m_bWasSelected &&  pt.x <= GetPlusColWidth())
		return FALSE;
	else
		return CBaseClass::OnLButtonUp(nFlags, pt);
}

BOOL CWatchRow::OnLButtonDblClk( UINT nFlags, CPoint pt)
{
	if (pt.x <= GetPlusColWidth())
		return FALSE;
	else
		return CBaseClass::OnLButtonDblClk(nFlags, pt);
}

BOOL CWatchRow::OnMouseMove(UINT nFlags, CPoint pt)
{
	if (WRH_GLYPH == HitTest(pt))
	{
		SetCursor(LoadCursor(NULL,IDC_ARROW));
		return TRUE;
	}
	return CBaseClass::OnMouseMove(nFlags, pt);
}

// Since the watch window is dockable  we need to create
// special child controls so things like right-mouse popup
// still work when the control is active.
																											
CEdit*  CWatchRow::NewEdit(  )
{
	return ( new CDockEdit );
}

CComboBox* CWatchRow::NewCombo( )
{
	return ( new CDockCombo ) ;
}


void CWatchRow::AdjustControlRect ( GRID_CONTROL_TYPE controlType, int nColumn,
										 CRect& rect )
{
	if ( nColumn == COL_NAME )
	{
		// We don't want the edit control to go over the tree control parts.
		rect.left += GetPlusColWidth();
	}

	CBaseClass::AdjustControlRect(controlType, nColumn, rect);
}


BOOL CWatchRow::IsExpandable( ) const
{
	return GetTM()->IsExpandable( );
}

DWORD CWatchRow::GetChildCount()
{
	return m_pTM->GetChildCount();
}

BOOL CWatchRow::GetChildren(CTreeGridRowArray& rgTGRow )
{
	CTMArray rgTM;

	if  (!m_pTM->GetTMChildren(rgTM))
		return FALSE;

	m_bHasSynthChild = m_pTM->HasSynthChild();
	
	// Currently we should never call this function with entries
	// already filled in.
	ASSERT(rgTGRow.GetSize() == 0);

	for ( int i = 0; i < rgTM.GetSize(); i++ )
	{
		CWatchRow * pRow = NewWatchRow(GetTreeGrid( ), rgTM[i], this);
		rgTGRow.Add(pRow);
	}

	rgTM.RemoveAll();
	return TRUE;
}

				
void CWatchRow::Update( )
{
	// Make sure that the ValueChanged bit is not set before Update
	this->SetValueChanged(FALSE);

	// First check if our parent is Dirty, if so don't even bother
	// refreshing anything here.
	if ( m_pParent && (m_pParent->m_nFlags & TGF_DIRTY_CONTENT))
	{
		// Okay then we are dirty as well.
		GetTreeGrid()->DirtyRow(this, TGF_DIRTY_CONTENT|TGF_DIRTY_ITEM);
	}
	else
	{
		// This logic is significantly complicated by the presence of synthesized
		// child TM's. There  are 3 cases possible.
		// 1) We have a new synthesized child which didn't exist before.
		// 2) Our parent still has a synthesized child but its type might have
		//	  changed. The current TM is not valid in this case.
		// 3) We are a synthesized child but the parent no longer has one.
		
		if ( m_pTM->IsSynthChildNode( ))
		{
			ASSERT(m_pParent != NULL);

			// If our parent is not supposed to have a synthesized
			// child anymore mark ourself for deletion.	We require that
			// the parent's Update be called before the childs.
			CWatchRow * pParent = (CWatchRow *)m_pParent;

			if ( !pParent->GetTM()->HasSynthChild() )
			{
				GetTreeGrid()->DirtyRow(this, TGF_DIRTY_DELETE);
				pParent->m_bHasSynthChild = FALSE;
			}
			else {
				CTM *pTM = pParent->GetTM()->GetSynthChildTM();

				// If the type of the synthesized child didn't
				// change we can just leave it as is.
				if ( GetTreeGrid()->IsExpanded(this) && !pTM->IsTypeIdentical(m_pTM) )
				{
					GetTreeGrid()->DirtyRow(this, TGF_DIRTY_CONTENT|TGF_DIRTY_ITEM);
				}
				else {
					GetTreeGrid()->DirtyRow(this, TGF_DIRTY_ITEM);
				}
				delete ( m_pTM );
				m_pTM = pTM;	// replace the TM with the new one.
			}				
		}	
		else if ( m_pTM->Refresh( ) == CTM::TYPE_CHANGED )
		{
			ASSERT(m_pParent == NULL);
			int tgf = TGF_DIRTY_ITEM;
			if ( GetTreeGrid()->IsExpanded(this) )
				tgf |= TGF_DIRTY_CONTENT;

			GetTreeGrid()->DirtyRow(this, tgf);
		}
		else
		{
			if ( GetTreeGrid( )->IsExpanded(this) && !m_bHasSynthChild
				  && m_pTM->HasSynthChild( ))
			{
				// We have a new synthesized child, even though our
				// own type didn't change. The synthesized child is
				// always at position 0.
				CTM *pTM = m_pTM->GetSynthChildTM();
					
				if ( pTM )
				{
					CWatchRow *pRow = NewWatchRow(GetTreeGrid(), pTM, this);

					if ( pRow != NULL )
					{
						GetTreeGrid()->InsertRowAfter(pRow, this);
						m_bHasSynthChild = TRUE;
					}
					else
						delete pTM;					
				}	
			}
			GetTreeGrid()->DirtyRow(this, TGF_DIRTY_ITEM);
		}
	}
}


void CWatchRow::Restart( )
{
	// For a root level node, call
	if (m_pParent == NULL)
	{
		m_pTM->Restart();
	}
	
	GetTreeGrid()->DirtyRow(this, TGF_DIRTY_ITEM|TGF_DIRTY_CONTENT);
}


void CWatchRow::OnSelect(BOOL bSelect)
{
	CBaseClass::OnSelect(bSelect);
	
	// If we are connected to a view inform the view that the selection has changed.
	CDbgGridWnd *pGrid = (CDbgGridWnd *)GetTreeGrid();
	if ( pGrid->GetView() != NULL )
		pGrid->GetView()->OnGridRowSelectionChange();
}
	
				
/////////////////////////////////////////////////////////////////////////
// CNewWatchRow

CNewWatchRow::CNewWatchRow(CDbgGridWnd *pGrid)
	: CBaseClass(pGrid, COL_NAME)
{
}

CNewWatchRow::~CNewWatchRow()
{
}

void CNewWatchRow::ResetSize(CDC *pDC)
{
	TEXTMETRIC tm;
	
	pDC->GetTextMetrics(&tm);
	m_cyHeight = tm.tmHeight + tm.tmExternalLeading + 2 * CWatchRow::cyMargin;

	// This is so the row height is the same as the CWatchRow's in the 
	// grid. See comments in CWatchRow::ResetSize.
	CWindowDC dc(NULL);
	dc.GetTextMetrics(&tm);
	int cyMinHeight = tm.tmAscent + tm.tmInternalLeading + 1;

	if ( m_cyHeight < cyMinHeight )
		m_cyHeight = cyMinHeight;

	if ( m_cyHeight < CWatchRow::cyMinPlusColHeight )
		m_cyHeight = CWatchRow::cyMinPlusColHeight;
}

CSize CNewWatchRow::GetCellSize(CDC *pDC, int nColumn) const
{
	if ( nColumn != COL_NAME )
		return CBaseClass::GetCellSize(pDC, nColumn);
	else
	{
		CSize size;
        size.cx = CWatchRow::cxMinPlusColWidth;
		size.cy = m_cyHeight;
		return size;
	}
}
								
void CNewWatchRow::DrawCell(CDC *pDC, const CRect& cellRect, int nColumn)
{

	// FUTURE: Figure out a better way to erase the background.	
	pDC->ExtTextOut(cellRect.left, cellRect.top, ETO_CLIPPED| ETO_OPAQUE,
			 cellRect,"", 0, NULL);

	COLORREF rgbForeground = pDC->SetTextColor(GetSysColor(COLOR_BTNSHADOW));
	CBrush* pOldBrush = pDC->SelectObject(CDC::GetHalftoneBrush());

	// Cell Rect excluding border regions if any.
	CRect cellRectSansBorder(cellRect);

	// Draw the border, each cell takes responsibility for painting
	// their bottom and right edges.

	pDC->PatBlt(cellRect.left, cellRect.bottom -1,  cellRect.Width(), 1, PATCOPY);

	// Exclude the border region.
	cellRectSansBorder.bottom -= 1;

	// The last column doesn't need the vertical border
	//  as the frame window has a border.	
	if ( (nColumn + 1) !=  GetGrid()->GetColumnCount() )
	{
		pDC->PatBlt(cellRect.right -1, cellRect.top, 1, cellRect.Height(), PATCOPY);
		cellRectSansBorder.right -= 1 ;
	}
	
	pDC->SelectObject(pOldBrush);
	pDC->SetTextColor(rgbForeground);

	switch ( nColumn )
	{
		case COL_NAME:
		{
			CRect textRect(cellRect);

			AdjustForMargins(textRect, nColumn);
			pDC->DrawFocusRect(textRect);
			break;
		}
		default:
			break;
	}
}							

int CNewWatchRow::Compare(const CGridRow *) const
{
	ASSERT(FALSE);

	return 1;		// We are bigger than everyone else.
}

void CNewWatchRow::OnActivate(BOOL bActivate, int nColumn)
{
	if ( bActivate && DebuggeeRunning())
	{
		return;
	}
	
	CBaseClass::OnActivate(bActivate, nColumn);
}						

void CNewWatchRow::OnControlNotify( UINT nControl, UINT nNotification)
{
	CGridControlWnd *pGrid = (CGridControlWnd *)GetGrid( );

	switch ( pGrid->m_controlType)
	{
		case edit:
			if (nNotification == EN_KILLFOCUS)
			{
				CWnd *pNewWnd = CWnd::GetFocus( );

				if (  pNewWnd != NULL && (pNewWnd != pGrid) &&
					!pGrid->IsChild(pNewWnd) && !pNewWnd->IsChild(pGrid))
				{
					pGrid->PostMessage(WM_DISMISS_CONTROL);
				}
			}
			break;
	}
	CBaseClass::OnControlNotify(nControl, nNotification);
}

CEdit * CNewWatchRow::NewEdit( )
{
	return (new CDockEdit);
}

CComboBox * CNewWatchRow::NewCombo( )
{
	return (new CDockCombo);
}

void CNewWatchRow::AdjustForMargins(CRect &rect, int nColumn)
{
	rect.InflateRect(-CWatchRow::cxMargin, -CWatchRow::cyMargin);
}

BOOL CNewWatchRow::OnMouseMove(UINT, CPoint)
{
	// The new watch row always puts up the edit box when the user clicks on it.
	// So we never show just the selection only cursor.
	SetCursor(LoadCursor(NULL, IDC_ARROW));
	return TRUE;
}

void CNewWatchRow::OnSelect(BOOL bSelect)
{
	CBaseClass::OnSelect(bSelect);
	
	// If we are connected to a view inform the view that the selection has changed.
	CDbgGridWnd *pGrid = (CDbgGridWnd *)GetTreeGrid();
	if ( pGrid->GetView() != NULL )
		pGrid->GetView()->OnGridRowSelectionChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\wmalloc.cpp ===
/*** wmalloc.c - Memory management entry points not implemented by WINDOWS 386
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose: To supply the C runtime memory management entry points,
*      which are defective in the WINDOWS 386 runtime library.
*
*   Revision History:
*     24-Apr-1989 ArthurC Created
*   [1]     09-Jul-1989 ArthurC Assume near pointer is local handle
*   [2]     21-Jul-1989 ArthurC Fixed definition of _cvw3_hmalloc
*   [3]     22-Aug-1989 ArthurC Fixed order of if evaluation to prevent GP
*   [4]     02-Oct-1989 ArthurC Removed unused local variable
*	[5]		03-May-1994 DanS	Rewrote to use Win32 heaps
*
*************************************************************************/
#include "stdafx.h"
#pragma hdrstop

#ifdef _DEBUG
	// For the release build, we *definately* want to use the old 
	// blow-away-the-heap-each-session method

// Uncomment this line to use the CRT heap.
// #define USE_REGULAR_HEAP_TO_FIND_LEAKS 1
#endif

#ifdef HOST32
#ifndef _HUGE_
        #define _HUGE_
#endif
#else	// !HOST32
    #define _HUGE_	_huge
#endif	// HOST32

extern "C" {	// rest of file

#if defined( USE_REGULAR_HEAP_TO_FIND_LEAKS ) 
	// We map these calls back onto the CRT memory management
	// code to help us track leaks.

void cvw3_minit (void) {}
void cvw3_mcleanup(void) {}
void *	CDECL cvw3_fmalloc (size_t cb) { return _fmalloc (cb); }
void *	CDECL cvw3_frealloc (void * pv, size_t cb) { return _frealloc (pv, cb); }
void	CDECL cvw3_ffree (void * pv) { _ffree (pv); }

#else

// handle to our debugger heap
static HANDLE	hDbgHeap = 0;

// self-tuning initial size reservation for HeapCreate call
const DWORD		cbInitialHeapMin = (512 * 1024) ;		// minimum heap size is 512K.
DWORD			cbInitialHeap = cbInitialHeapMin;	// give ourselves cbInitialHeapMin reserved
DWORD			cbAlloc = 0;						// current allocation size of heap

#if defined (_DEBUG) && !(defined (DBG_MEM_STATS))
// turn on debugger memory allocator stats for all debug builds
# define DBG_MEM_STATS	1
#endif

#if defined (DBG_MEM_STATS)
struct MEMSTATS {
	DWORD	cbAlloc;
	DWORD	cAllocs;
	DWORD	cbFree;
	DWORD	cFrees;
	DWORD	cReallocs;
	DWORD	cbHeap;
	DWORD	cbMinAlloc;
	DWORD	cbMaxAlloc;
	};

MEMSTATS	ms = {0};

#endif

__inline size_t CbAlign ( size_t cb ) {
	return (cb + 7) & ~7;
	}
	
BOOL cvw3_minit(void)
{
	if ( hDbgHeap == 0 )
	{
		hDbgHeap = HeapCreate(0, cbInitialHeap, 0);
		if (hDbgHeap==NULL)
			return FALSE;
		// reset our allocation counter so that we can self-tune
		//	the initial reserved memory of the heap to be roughly
		//	the size last time.
		cbInitialHeap = cbInitialHeapMin;
		cbAlloc = 0;
#if defined (DBG_MEM_STATS)
		ms.cbAlloc = ms.cAllocs = ms.cbFree = ms.cFrees = ms.cReallocs = ms.cbHeap = 0;
		ms.cbMaxAlloc = 0;
		ms.cbMinAlloc = 0xffffffff;
#endif
	}
	return TRUE;
}

void cvw3_mcleanup(void)
{
	if ( hDbgHeap != 0 )
	{
		VERIFY(HeapDestroy(hDbgHeap));
	}
	hDbgHeap = 0;
}

void *	CDECL cvw3_fmalloc(size_t cb)
{
#if defined (DBG_MEM_STATS)
	ms.cbAlloc += cb;
	ms.cbHeap += cb;
	ms.cAllocs++;
	if ( cb < ms.cbMinAlloc ) ms.cbMinAlloc = cb;
	if ( cb > ms.cbMaxAlloc ) ms.cbMaxAlloc = cb;
#endif
	cbAlloc += CbAlign ( cb );
	if ( cbAlloc > cbInitialHeap )
	{
		cbInitialHeap = cbAlloc;
	}	
	return HeapAlloc(hDbgHeap, HEAP_ZERO_MEMORY, cb);
}

size_t	CDECL cvw3_fmsize(void * pv)
{
	return HeapSize(hDbgHeap, 0, pv);
}

void *	CDECL cvw3_frealloc(void * pv, size_t cb)
{
	if (pv == NULL)
	{
		return cvw3_fmalloc(cb);
	}
#if defined (DBG_MEM_STATS)
	ms.cReallocs++;
	ms.cbHeap -= cvw3_fmsize(pv);
	ms.cbAlloc += cb;
	ms.cbHeap += cb;
#endif

	// Adjust and verify cbAlloc
	DWORD cbChunk = CbAlign(cvw3_fmsize(pv));
	if (cbAlloc >= cbChunk)
	{
		cbAlloc -= cbChunk;
	}
	else
	{
		// It is possible we're freeing more memory than we thought we ever
		// allocated, because HeapAlloc can alloc more than the requested amount.
		// Set cbAlloc to 0 so we don't call HeapCreate with some HUGE number
		// like 0xFFFFFFB8.
		cbAlloc = 0;
	}
	cbAlloc += CbAlign ( cb );
	return HeapReAlloc(hDbgHeap, 0, pv, cb);
}

void	CDECL cvw3_ffree(void * pv)
{
	// Chicago's HeapFree doesn't allow you to free NULL pointers
	if (pv == NULL)	return;

#if defined (DBG_MEM_STATS)
	ms.cbFree += cvw3_fmsize(pv);
	ms.cFrees++;
	ms.cbHeap -= cvw3_fmsize(pv);
#endif

	// Adjust and verify cbAlloc
	DWORD cbChunk = CbAlign(cvw3_fmsize(pv));
	if (cbAlloc >= cbChunk)
	{
		cbAlloc -= cbChunk;
	}
	else
	{
		// It is possible we're freeing more memory than we thought we ever
		// allocated, because HeapAlloc can alloc more than the requested amount.
		// Set cbAlloc to 0 so we don't call HeapCreate with some HUGE number
		// like 0xFFFFFFB8.
		cbAlloc = 0;
	}
	VERIFY(HeapFree(hDbgHeap, 0, pv));
}

#endif // USE_REGULAR_HEAP_TO_FIND_LEAKS

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\brkpt.h ===
/*** brkpt.h - header file for breakpoint api
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*   Revision History:
*
*
*************************************************************************/
#ifndef _BRKPT_H	// WHOLE FILE {
#define _BRKPT_H

// Just to hide things
#define HBPI        HLLE
#define hbpiNull    hlleNull


#define chBeginCxtOp    _T('{')
#define chEndCxtOp      _T('}')
#define chQuote         _T('\"')


// Types of breakpoints.  These
// should be sorted by priority
// so when walking the entire
// bp list, the last entry is
// the one returned as the current
// status. (deadchild, abort, and
// hardcodedbp are not regular
// conditions, so they do not need
// to be in any specific order
typedef enum {
	BPDEADCHILD,
	BPABORT,
	BPHARDCODEDBP,
	BPCONTINUE,
	BPTMP,
	BPBREAKPT,
	BPTMPENC	// temp BP for edit & continue
} BPC;

typedef enum {
    BPUNKNOWN,
    BPSYMBOL,
    BPLINE,
    BPADDR
} EBPT;

#if defined (_X86_)
typedef BYTE BP_UNIT;
#define BRKPTOPCODE ((BYTE)0xCC)
#elif defined(_MIPS_)
typedef DWORD BP_UNIT;
#define BRKPTOPCODE 0x0016000D
BOOL MassageBPAddr(LPADDR, LPUOFFSET); // see brkpt0.c
#elif defined(_ALPHA_)
typedef DWORD BP_UNIT;
#define BRKPTOPCODE 0x80L
BOOL MassageBPAddr(LPADDR, LPUOFFSET); // see brkpt0.c
#else
#error "Need arch specific breakpoint"
#endif
#define DPLBITS ((unsigned int) 0x3)

#define SKIPBPUIFLAGS    3
#define SKIPOS2FLAGS     4

typedef union _bpf {
    unsigned        flags;
    struct {
        unsigned    fBpCode     : 1;    // Is there a Code bp
        unsigned    fBpData     : 1;    // Is there a watch/trace point
        unsigned    fActive     : 1;    // Breakpoint is active
        unsigned    fBPLoaded   : 1;    // is BRKPTOPCODE in the code
        unsigned    fVirtual    : 1;    // This is a virtual bp
        unsigned    fAmbig      : 1;    // This BP came from an ambiguous expression
        unsigned    fPass       : 1;    // if a passcount was specified
        unsigned    fUser       : 1;    // for use WITHIN a proc, up to you how to use
        unsigned    fDlgActive  : 1;    // Dialog hold are for orignal fActive state
        unsigned    fDlgMarkDel : 1;    // This breakpoint has been marked for deletion
        unsigned    fDlgMarkAdd : 1;    // This breakpoint has been marked for addition
        unsigned    BpType      : 3;    // The type of breakpoint
        unsigned    fMessage    : 1;
        unsigned    fNoStop     : 1;
        unsigned    fParamGiven : 1;
    } f;
} BPF;
typedef BPF *   PBPF;

typedef union _dpf {
    unsigned        flags;
    struct {
        unsigned    fEmulate    : 1;    // If emulation is required
        unsigned    fFuncBpSet  : 1;    // if a function breakpoint is set
        unsigned    fTpFuncHit  : 1;    // When we hit a breakpoint set by tracepoint
        unsigned    fFuncLoad   : 1;    // We must load the breakpoint value on function entry
        unsigned    fEvalExpr   : 1;    // Is the expr not an lvalue
        unsigned    fDataRange  : 1;    // if a datarange was specifed
        unsigned    fBpRel      : 1;    // if a code range was specified
        unsigned    fContext    : 1;    // if context checking is required
        unsigned    fReg        : 1;    // if it is in a register
        unsigned    fUser       : 1;    // for use WITHIN a proc, up to you how to use
        unsigned    fIsTrue     : 1;    // Have we already told the user
                                        //  that this wp has fired?
    } f;
} DPF;
typedef DPF FAR *   LPDPF;

/*
 * This defines a function callback mechanism which can be used to
 * generalize the breakpoint facility.
 * The messages and responses are defined earlier in this file.
 */
typedef struct _bcm {
    unsigned    wMsg;        // A message giving the reason for the call
    unsigned    wInstance;   // BPBrkExec call count
    char FAR *  lpch;        // A buffer for return info
    HBPI        hbpi;        // Points to the parent bpi
} BCM;  // Breakpoint Callback Method
typedef BCM FAR *   LPBCM;

typedef struct _dpi {
    union {
        struct {
            ADDR        DataAddr;     // Data address to watch
        } d;
        struct {
            ADDR        BlkAddr;      // the start address of the block
            UOFFSET     oEnd;         // The end offset of the function
            long        ldbBp;        // ofset from the bp
        } bp;
    } u;
    CXF                 cxf;          // the frame
    char *              pValue;       // pointer to the initial value
    short               iReg;         // if in register, the reg index
    ushort              cData;        // Number of data items to watch
    ushort              cbData;       // Number of bytes in data item
    HTM                 hTM;          // a TM handle for the data breakpoint
    LPBPS               lpbps;        // The OSD bps associated w/ this
} DPI;
typedef DPI *   PDPI;
typedef DPI FAR *   LPDPI;

typedef struct _bpi {
    BPF             bpf;        // flags
    DPF             dpf;        // the data bp flags
    int             fLang;      // the language type
    unsigned char   OpCode;     // The orignal opcode
    ADDR            CodeAddr;   // Code address of breakpoint
    SEGMENT         segFixed;   // Fixedup segment for MOVE BPFixSeg (unload)
    LPDPI           lpDpi;      // pointer to the DataBreakpoint
/*
 * This defines a function callback mechanism which can be used to
 * generalize the breakpoint facility.
 * The messages and responses are defined earlier in this file.
 */
    DWORD  dwMask;
    DWORD lMessage;
    ushort   cPass;      // Initial Pass count
    ushort   cPassCur;   // Current Pass count
    char FAR *lszCmd;    // Offset of the command to Execute
    HPRC     hprc;       // The process this bp is associated with
    HTHD     hthd;       // The tread to break at
                         //  NULL breaks on all threads
} BPI;
typedef BPI *   PBPI;
typedef BPI FAR *   LPBPI;

typedef enum ABPT {
    abptNotAmbig = 0,   // Not ambiguous
    abptRestoredAmbig,  // Used in restoring ambiguous BP's
    abptAmbigExpr,      // The expression evaluator tells us that it is ambig
    abptAmbigUser       // User gave a parameter list, it may have be ambiguous
} ABPT;

typedef struct _pbp {
    HTHD        hthd;
    ushort      BPType;
    PCXF        pCXF;
    ushort      BPSegType;
    char FAR *  lszCmd;
    ABPT        abpt;
    union {
        ADDR    Addr;
        struct {
            unsigned int    cBPMax;
            TML             tml;
        };
    };
    LPDPI       lpDpi;
    DPF         DPF;
    ushort      cPass;
    char FAR *  lszOptCmd;
    int         iErr;
    BOOL        fNoStop;
    BOOL        fMessage;
    DWORD       lMessage;
    DWORD       dwMask;
    BOOL        fInsert;
} PBP;
typedef PBP FAR *LPPBP;

typedef struct _sfi {
    int       fLang;
    ushort    fEnable;
    HTHD      hthd;
} SFI;
typedef SFI *   PSFI;

// user global variable  YUK! this should not be visable to the world!
// extern PBPI pbpiFirst;
extern int   G_BPfEmulate;

/***
 *
 *    Breakpoint Handler API
 *
 */
extern int  PASCAL      BPUIAdd( char *, HMEM);
extern int  PASCAL      BPUIEnable(char *);
extern int  PASCAL      BPUIDisable(char *);
extern int  PASCAL      BPUIList(char *);
extern int  PASCAL      BPUIClear(char *);
extern char FAR * PASCAL    BPUIFormat(HBPI, ushort, ushort, char FAR *, ushort);

extern void PASCAL     BPFreeType( ushort );
extern EESTATUS PASCAL BPParse( LPPBP );
extern HBPI PASCAL     BPCommitBP ( LPPBP );
extern void PASCAL     BPFixSeg( ushort );
extern HBPI PASCAL     BPIsAddr( PADDR, UOFFSET, HTHD, int, BOOL fCheckDisabled = FALSE, UINT *pWidgetFlags = 0, BPC bpcType = BPBREAKPT );
extern void PASCAL     BPDelete( HBPI );
extern int  PASCAL     BPGetNbr(HBPI);
extern int  PASCAL     BPCheckBpt(PADDR, LPMSGI, HTID);
extern void PASCAL     BPResetAllPassCnt( void );
extern int  PASCAL     BPBrkExec(PADDR, HTID, BPI **ppBPI = NULL);
extern void PASCAL     BPListDlg( void );
extern void PASCAL     BPModifyDlg( void );
extern void PASCAL     BPUISetOp( char * );
extern HBPI PASCAL     BPFirstBPI( void );
extern EESTATUS PASCAL BPParseAddress(LPPBP, BOOL);
extern EESTATUS PASCAL BPADDRFromTM (PHTM, unsigned short FAR *, PADDR);
extern LSZ  PASCAL     BPShortenSzCxt ( LSZ, LSZ );
extern VOID PASCAL	   BPInstallVirtual(HPID, HEXE, BOOL);
extern XOSD PASCAL     SetWatch ( LPBPI, BOOL );

extern HLLI    llbpi;

#endif	// _BRKPT_H }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\varsview.cpp ===
// varsview.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop
#include "autownd.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

CGridWatchView * g_pWatchView;
CVarsView * g_pVarsView;
CPersistWatch g_persistWatch;
CPersistVariables g_persistVars;
UINT CGridWatchView::g_cRef;
CFontInfo * CGridWatchView::g_pFontInfo;
UINT CVarsView::g_cRef;
CFontInfo * CVarsView::g_pFontInfo;

UINT WSB_CHANGETAB = RegisterWindowMessage("WSB_CHANGETAB");

/////////////////////////////////////////////////////////////////////////////
// CBaseVarsView

IMPLEMENT_DYNAMIC(CBaseVarsView, CDockablePartView)

CBaseVarsView::CBaseVarsView(UINT nIDWnd, UINT nIDPacket)
{
	m_slob.m_pView = this;
	m_nIDWnd = nIDWnd;
	m_nIDPacket = nIDPacket;
	m_bHasVScroll = TRUE;
	m_bFirstNonZeroSize = TRUE;
	m_curIndex = -1;	// No child is active initially.
	c_nSplitterPref = 0;
	m_iNameColWidth = 0;	// Zero means unspecified.
	m_pDragInfo = 0;
}

CBaseVarsView::~CBaseVarsView()
{
	// Delete the children.
	for (int i = 0; i < m_arrChildWnd.GetSize(); i++)
		delete m_arrChildWnd[i];
}

BOOL CBaseVarsView::EnsureWindow( )
{
	BOOL bRet = TRUE;

	// No window created yet.
	if ( GetSafeHwnd( ) == NULL )
	{
		DWORD dwStyle = WS_CHILD | WS_CLIPCHILDREN | DWS_STRETCHY ;

		bRet = Create(NULL, NULL, dwStyle, CRect(0,0,0,0),
						 theApp.m_pMainWnd,
						 m_nIDWnd);
		m_pPacket = theApp.GetPacket(PACKAGE_DEBUG, m_nIDPacket);
	}

	return bRet;
}
			
		
BEGIN_MESSAGE_MAP(CBaseVarsView, CBaseVarsView::CBaseClass)
	//{{AFX_MSG_MAP(CBaseVarsView)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
	ON_REGISTERED_MESSAGE(WSB_CHANGETAB, OnChangeTab)
	ON_MESSAGE(WU_UPDATEDEBUG, OnUpdateDebug)
	ON_MESSAGE(WU_CLEARDEBUG, OnClearDebug)
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CBaseVarsView diagnostics

#ifdef _DEBUG
void CBaseVarsView::AssertValid() const
{
	ASSERT(m_curIndex < m_arrChildWnd.GetSize( ));
	CBaseClass::AssertValid();
}

void CBaseVarsView::Dump(CDumpContext& dc) const
{
	CBaseClass::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBaseVarsView overrides

LRESULT CBaseVarsView::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult;

	if ( DkPreHandleMessage(GetSafeHwnd(), message, wParam, lParam, &lResult) )
	{
		return lResult;
	}	
		
	return CBaseClass::WindowProc(message, wParam, lParam);
}


void CBaseVarsView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
	ShowSelection(bActivate);
	CBaseClass::OnActivateView(bActivate, pActivateView, pDeactiveView);
}

/////////////////////////////////////////////////////////////////////////////
// CBaseVarsView message handlers

BOOL CBaseVarsView::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// First let the active child window get a shot at handling the command.
	if (m_curIndex != -1 &&
		m_arrChildWnd[m_curIndex]->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo)
	   )
	{
		return TRUE;
	}
			
	return CBaseClass::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

int CBaseVarsView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CBaseClass::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (::CreateWindow(_T("SCROLLBAR"), NULL,
		SBS_SIZEBOX | WS_DISABLED | WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS,
		0, 0, 1, 1, m_hWnd, (HMENU)AFX_IDW_SIZE_BOX,
		AfxGetInstanceHandle(), NULL) == NULL)
	{
		return -1;
	}

	if (::CreateWindow(_T("SCROLLBAR"), NULL,
		SBS_VERT | WS_CHILD,
		0, 0, 1, 1, m_hWnd, (HMENU)AFX_IDW_VSCROLL_FIRST,
		AfxGetInstanceHandle(), NULL) == NULL)
	{
		return -1;
	}
	
	m_widgetScroller.SetSplitterPref(c_nSplitterPref);

	if (!m_widgetScroller.Create(NULL, NULL,
			WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
			CRect(0, 0, 1, 1), this, AFX_IDW_HSCROLL_FIRST))
	{
		return -1;
	}

	// We don't use our scrollbars.
	GetScrollBarCtrl(SB_HORZ)->ShowWindow(SW_HIDE);
	GetScrollBarCtrl(SB_VERT)->ShowWindow(SW_HIDE);

	m_DropTarget.Register(this);

	return 0;
}

void CBaseVarsView::PostNcDestroy()
{
	// re-fetch the final column width so we will restore it correctly
	// the next time we open this window.
	if ( m_curIndex != -1 )
		m_iNameColWidth = m_arrChildWnd[m_curIndex]->GetNameColWidth();

	m_font.Detach();	
	delete this ; // Dockable windows delete themselves.
}

BOOL CBaseVarsView::PreTranslateMessage(MSG* pMsg)
{
	int nTab;

	switch (pMsg->message)
	{
	case WM_KEYDOWN:
		switch (pMsg->wParam)
		{
		case VK_NEXT:
		case VK_PRIOR:
			if ( GetKeyState(VK_CONTROL) >= 0)
				break;

			if ( m_curIndex != -1 )
			{
				if ( pMsg->wParam == VK_NEXT )
				{
					if ( m_curIndex == (m_arrChildWnd.GetSize() - 1))
						nTab = 0;
					else
						nTab = m_curIndex + 1;
				}
				else
				{
					if ( m_curIndex == 0 )
						nTab = m_arrChildWnd.GetSize( ) - 1;
					else
						nTab = m_curIndex - 1;
				}
				m_widgetScroller.ActivateTab(nTab);
				return TRUE;
			}
		}
	}
								
	return CBaseClass::PreTranslateMessage(pMsg);
}


CScrollBar* CBaseVarsView::GetScrollBarCtrl(int nBar) const
{
	ASSERT ( nBar == SB_HORZ || nBar == SB_VERT );

	return ((CScrollBar*) (GetDescendantWindow(nBar==SB_HORZ?
				AFX_IDW_HSCROLL_FIRST : AFX_IDW_VSCROLL_FIRST)));		
}

void CBaseVarsView::UpdateTabs( )
{
	m_widgetScroller.ResetTabs( );

	// We should have atleast one child.
	ASSERT ( m_arrChildWnd.GetSize( ) != 0);
	
	for ( int i = 0; i < m_arrChildWnd.GetSize( ) ; i++ )
	{
		m_widgetScroller.AddTab(m_arrChildWnd[i]->GetTabName(), 0);
	}

	if ( m_curIndex == -1)
		m_curIndex = 0;
	
	ASSERT(m_curIndex < m_arrChildWnd.GetSize());
		
	m_widgetScroller.ActivateTab(m_curIndex);
}

			

LRESULT CBaseVarsView::OnChangeTab(WPARAM wParam, LPARAM)
{
	m_iNameColWidth = m_arrChildWnd[m_curIndex]->GetNameColWidth();

	// First tell the previous window it is time to sleep
	m_arrChildWnd[m_curIndex]->MakeWindowAlive(FALSE, m_iNameColWidth);
	m_curIndex = wParam;

	// the second option with be to maintain all the windows
	// at the correct size and just BringWindowToTop when the tabs
	// change.
	GetActiveGrid()->SetWindowPos(&wndTop, 0, 0, 0, 0,
					SWP_NOMOVE | SWP_NOREDRAW | SWP_NOSIZE );
	// Position the window correctly.
	RecalcLayout();

	// Force a repaint on the grid. This strange order is neccessary
	// so we don't see the border of the window being painted, which
	// causes a flicker on the edge of the currently selected tab.
	// FUTURE : Could we do this a better way?
	GetActiveGrid()->Invalidate();
	GetActiveGrid()->SetWindowPos(&wndTop, 0, 0, 0, 0,
					SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
	
   	m_arrChildWnd[m_curIndex]->MakeWindowAlive(TRUE, m_iNameColWidth);

	// If we or our progeny had the Focus
	// then set it to the child we just activated.
	CWnd * pWnd = CWnd::GetFocus();

	if (this == pWnd || (pWnd && IsChild(pWnd)))
		m_arrChildWnd[m_curIndex]->SetFocus();

	// Finally inform ourself that the selection within the grid's has changed.
	OnGridRowSelectionChange();
	return 0;
}

void CBaseVarsView::OnSize(UINT nType, int cx, int cy)
{
	if ( nType != SIZE_MINIMIZED && cx > 0 && cy > 0 )
	{
		RecalcLayout( );
		if ( m_bFirstNonZeroSize )
		{
			// HACK the hack below is probably not neccessary if we
			// get rid of the zeroeth column altogether.
			// The grid will truncate the first column to zero-width if we do the
			// UpdateTabs right after Creating the grid, since it is still 0-width
			// We depend on the first-column sizing itself
			m_bFirstNonZeroSize = FALSE;
			UpdateTabs( );
		}
	}

	CBaseClass::OnSize(nType, cx, cy);
}

void CBaseVarsView::RecalcLayout( )
{
	int cxVScroll = GetSystemMetrics(SM_CXVSCROLL);
	int cyHScroll = GetSystemMetrics(SM_CYHSCROLL);
	int cxBorder = GetSystemMetrics(SM_CXBORDER);
	int cyBorder = GetSystemMetrics(SM_CYBORDER);
	
	CRect view;
	GetClientRect(view);

	// We assume
	// a) The view itself does not have a border.
	// b) The child window has a border.

	ASSERT((GetStyle() & WS_BORDER) == 0);
	ASSERT( (m_curIndex == -1) ||
		    ((m_arrChildWnd[m_curIndex]->GetStyle() & WS_BORDER) != 0) );

	BOOL bHasVScroll = m_bHasVScroll;
	if (bHasVScroll)
	{
		CWnd* pScrollBar = GetDlgItem(AFX_IDW_VSCROLL_FIRST);
		ASSERT(pScrollBar != NULL);
		if ((pScrollBar->GetStyle() & WS_VISIBLE) == 0)
			bHasVScroll = FALSE;
	}

	if (bHasVScroll)
	{
		view.right -= cxVScroll;
	 	// NOTE: This code has never been tried with the vertical scrollbars
		// visible. Some tweaking might be required to get the
		// vertical toolbar and size box to line up.
	 	ASSERT(FALSE);
	}

	view.bottom -= cyHScroll;

	HDWP hDWP = BeginDeferWindowPos(4);

	CWnd* pScrollBar;
	pScrollBar = GetDlgItem(AFX_IDW_HSCROLL_FIRST);
	ASSERT(pScrollBar != NULL);


	int nOverlapSizeBox;
	if (!gpISrc->GetSrcEnvironParam(ENV_HSCROLL) && bHasVScroll)
		nOverlapSizeBox = cxVScroll;
	else
		nOverlapSizeBox = 0;

	DeferWindowPos(hDWP, pScrollBar->m_hWnd, HWND_TOP,
		0 , view.bottom,
		view.Width() + nOverlapSizeBox, cyHScroll,
		SWP_NOACTIVATE);

	CWnd* pSizeBox;
	pSizeBox = GetDlgItem(AFX_IDW_SIZE_BOX);
	if (pSizeBox != NULL)
	{
		DeferWindowPos(hDWP, pSizeBox->m_hWnd, HWND_TOP,
			view.right + cxBorder, view.bottom + cyBorder,
			cxVScroll - 2 * cxBorder, cyHScroll - 2 * cyBorder,
			SWP_NOACTIVATE);
	}

	pScrollBar = GetDlgItem(AFX_IDW_VSCROLL_FIRST);
	if (pScrollBar != NULL)
	{
		DeferWindowPos(hDWP, pScrollBar->m_hWnd, NULL,
			view.right, 0,
			cxVScroll, view.Height() ,
			SWP_NOZORDER | SWP_NOACTIVATE);
	}

	if (m_curIndex != -1)
	{
		// The bottom border is provided by the widget bar.
		DeferWindowPos(hDWP, m_arrChildWnd[m_curIndex]->GetSafeHwnd(),
			NULL, 0, 0,
			view.Width(), view.Height() + cyBorder,
			SWP_NOZORDER | SWP_NOACTIVATE);
	}

	EndDeferWindowPos(hDWP);
}

CSlob * CBaseVarsView::GetSelection( )
{
	return &m_multiSlob;
}

CSlob * CBaseVarsView::GetEditSlob( )
{
	return GetSelection();
}

void	CBaseVarsView::OnGridRowSelectionChange( )
{
	CDbgGridWnd *pGrid = GetActiveGrid();
	
	m_multiSlob.Clear();

	if (pGrid == NULL)
		return;

	POSITION pos = pGrid->GetHeadSelPosition();
	if ( pos == NULL)
		return;				

	CGridRow * pRow = (CGridRow *)(pGrid->GetNextSel(pos)->GetRow());

	// We have only one item selected and that is the caption row.
	if ( pos == NULL && pRow == pGrid->GetCaptionRow() )
		return;

	m_slob.InformDependants(P_VarExpr);
	m_slob.InformDependants(P_VarType);
	m_slob.InformDependants(P_VarValue);

	if (pGrid->GetCurSel() != NULL)
	{
		m_multiSlob.Add(&m_slob);
	}
	else
	{
		m_multiSlob.Add(&m_slob);
		m_multiSlob.Add(&m_fakeSlob);
	}
}	
	
			
		
void CBaseVarsView::OnSetFocus(CWnd* pOldWnd)
{
	// Just pass on the focus to our child.	
	if (m_curIndex != -1)
	{
		CWnd *pWnd = m_arrChildWnd[m_curIndex];

		ASSERT(pWnd->GetSafeHwnd() != NULL);
		pWnd->SetFocus( );
	}	
}

void CBaseVarsView::ResetWidgetScrollBar( )
{
	m_widgetScroller.Invalidate(FALSE);
}

LRESULT CBaseVarsView::OnUpdateDebug(WPARAM wParam, LPARAM lParam)
{
	CTreeGridWnd *pGrid = GetActiveGrid( );
	
	if ( pGrid )
		return pGrid->SendMessage(WU_UPDATEDEBUG, wParam, lParam);
	else
		return Default( );
}


LRESULT CBaseVarsView::OnClearDebug(WPARAM wParam, LPARAM lParam)
{
	// On Clear debug we have to iterate over the windows as the
	// underlying data structures might no longer be valid between
	// debug sessions. All the grids need a chance to deal with this. 	
	for ( int i = 0; i < m_arrChildWnd.GetSize() ; i++ )
	{
		m_arrChildWnd[i]->SendMessage(WU_CLEARDEBUG, wParam, lParam);
	}

	return 0;
}


void CBaseVarsView::OnFontColorChange( )
{
	ASSERT(m_pFontInfo != NULL);
	if (m_font.GetSafeHandle())
		m_font.Detach();

	m_font.Attach(m_pFontInfo->m_hFont);

	// Get the new colors.
	FMT_ELEMENT *rgfmtel = pfmtelForVarsWnd(m_nIDWnd);
	COLORREF colText = rgfmtel[FMTEL_TEXT].rgbText;
	COLORREF colBkground = rgfmtel[FMTEL_TEXT].rgbBackground;
	COLORREF colSelc = rgfmtel[FMTEL_SELC].rgbBackground;
	COLORREF colSelcText = rgfmtel[FMTEL_SELC].rgbText;
	COLORREF colChangeText = rgfmtel[FMTEL_VCHI].rgbText;
	COLORREF colChangeBk = rgfmtel[FMTEL_VCHI].rgbBackground;
			
	for ( int i = 0 ; i < m_arrChildWnd.GetSize(); i++ )
	{
		m_arrChildWnd[i]->SetColor(colText, colBkground, colSelc, colSelcText);
		m_arrChildWnd[i]->SetChangeHighlightColors(colChangeText, colChangeBk);
		m_arrChildWnd[i]->SetFont(&m_font);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CVarsSlob + helpers to do the property page for the variables window.

BEGIN_IDE_CONTROL_MAP(CVarsPropPage, IDDP_VARS_GEN, IDS_GENERAL)
	MAP_THIN_TEXT(IDC_VAR_TYPE, P_VarType)
	MAP_THIN_TEXT(IDC_VAR_EXPR, P_VarExpr)
	MAP_THIN_TEXT(IDC_VAR_VALUE, P_VarValue)
END_IDE_CONTROL_MAP()

IMPLEMENT_DYNCREATE(CVarsSlob, CSlob)

CString CVarsSlob::s_strPropCaption;
CVarsPropPage CVarsSlob::s_varsPropPage;

CVarsSlob::CVarsSlob()
{
}

CVarsSlob::~CVarsSlob()
{
}

BOOL CVarsSlob::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	AddPropertyPage(&s_varsPropPage, this);

	CSlob::SetupPropertyPages(pNewSel, FALSE);

	if( bSetCaption )
	{
		if (s_strPropCaption.IsEmpty())
			s_strPropCaption.LoadString(IDS_VARS_PROP_TITLE);
		SetPropertyCaption(s_strPropCaption);
	}

	return TRUE;
}

GPT CVarsSlob::GetStrProp(UINT nPropID, CString& val)
{
	ASSERT(m_pView != NULL);
	CDbgGridWnd *pGridWnd = m_pView->GetActiveGrid();

	if (pGridWnd == NULL)
		return invalid;
	
	CTreeGridRow *pRow = pGridWnd->GetCurSel();

	if (pRow == NULL || pRow->IsNewRow())
		return invalid;

	CTM * pTM = ((CWatchRow *)pRow)->GetTM();
	if (pTM == NULL)
		return invalid;

	switch (nPropID)
	{
	default:
		return CSlob::GetStrProp(nPropID, val);
	
	case P_VarExpr:
		val = pTM->GetExpr();
		// If the watch is in error, the EE could return an empty
		// string for the expression.
		if (val.IsEmpty())
			val = pTM->GetName();

		break;
		
	case P_VarType:
		val = pTM->GetType();
		break;
		
	case P_VarValue:
		val = pTM->GetValue();;
		break;
	}

	return valid;
}
					


 	
/////////////////////////////////////////////////////////////////////////////
// CGridWatchView

IMPLEMENT_DYNCREATE(CGridWatchView, CBaseVarsView)

CGridWatchView::CGridWatchView():CBaseClass(IDDW_VCPP_WATCH_WIN, PACKET_NIL)
{
	m_iNameColWidth = runDebugParams.iWatchNameColWidth;

	if (g_cRef++ == 0)
		g_pFontInfo = new CFontInfo(*(pfmtcatForVarsWnd(m_nIDWnd)->pLogFont));

	m_pFontInfo = g_pFontInfo;
}

CGridWatchView::~CGridWatchView()
{
	runDebugParams.iWatchNameColWidth = m_iNameColWidth;

	if (--g_cRef == 0)
	{
		delete g_pFontInfo;
		g_pFontInfo = NULL;
	}
}

// Static function to make sure the watch window is available.
BOOL CGridWatchView::EnsureWatchWindow()
{
	if ( g_pWatchView == NULL )
	{
		DkWShowWindow(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_WATCH_WIN), TRUE);
	}
	
	return (g_pWatchView != NULL);
}		 				
	
BEGIN_MESSAGE_MAP(CGridWatchView, CGridWatchView::CBaseClass)
	//{{AFX_MSG_MAP(CGridWatchView)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGridWatchView overrides.


BEGIN_POPUP_MENU(GridWatch)
	MENU_ITEM(ID_EDIT_PASTE)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_DEBUG_RADIX)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_TOGGLE_MDI)
	MENU_ITEM(ID_WINDOW_POPUP_HIDE)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_WINDOW_SHOWPROPERTIES)
END_POPUP_MENU()

void CGridWatchView::ShowContextPopupMenu(CPoint pt)
{
    #ifndef NO_CMDBARS
        TRACE2("GridWatch (%s, %d)\r\n", __FILE__, __LINE__);
        ::CBShowContextPopupMenu(MENU_CONTEXT_POPUP(GridWatch), pt);
    #else
    	::ShowContextPopupMenu(MENU_CONTEXT_POPUP(GridWatch), pt);
    #endif
}

BOOL CGridWatchView::AddNewWatch(CString str)
{
	return(GetActiveGrid()->AddNewWatch(str));
}
			
/////////////////////////////////////////////////////////////////////////////
// CGridWatchView diagnostics

#ifdef _DEBUG
void CGridWatchView::AssertValid() const
{
	CBaseClass::AssertValid();
}

void CGridWatchView::Dump(CDumpContext& dc) const
{
	CBaseClass::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGridWatchView message handlers


int CGridWatchView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CBaseClass::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// Add the child windows to the view.
	DWORD dwStyle = WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE;
	CRect rectNull(0,0,0,0);

	// Go through adding the various child windows
	ASSERT(g_persistWatch.GetTabCount() != 0);

	for ( int i = 0; i < g_persistWatch.GetTabCount(); i++ )
	{
		CPersistWatchTab& rPersistTab = g_persistWatch.GetWatchTab(i);
		CDbgGridWnd * pGrid = new CDbgGridWnd(rPersistTab.GetTabName(), this, TRUE);
										
		pGrid->RestoreSettings(rPersistTab, m_iNameColWidth);
				
		if (pGrid->Create(dwStyle, rectNull, this, (i + 1)))
		{
			m_arrChildWnd.Add(pGrid);
		}
		
	}
	
	m_widgetScroller.SetSplitterPref(g_persistWatch.m_nSplitterPref);
							
	// Add our child windows to the tab.
	m_curIndex = g_persistWatch.GetActiveTabIndex();

	ShowSelection(FALSE);	// don't show selection till we get the ActivateView.
	OnFontColorChange();

	return 0;
}

void CGridWatchView::OnDestroy()
{
	CBaseClass::OnDestroy();

	g_persistWatch.ClearAll();
	g_persistWatch.m_nSplitterPref = m_widgetScroller.GetSplitterPref();

	// Remember the watches so we get them the next time over.
	for ( int i = 0; i < m_arrChildWnd.GetSize() ; i++ )
	{
		CDbgGridWnd *pGrid = m_arrChildWnd[i];
		g_persistWatch.AddWatchTab(pGrid->GetTabName());
		pGrid->RememberSettings(g_persistWatch.GetWatchTab(i));
	}
		
	g_persistWatch.SetActiveTab(m_curIndex);	
	
	g_pWatchView = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CVarsCombo

CVarsCombo::CVarsCombo()
{
}

CVarsCombo::~CVarsCombo()
{
}


BEGIN_MESSAGE_MAP(CVarsCombo, CComboBox)
	//{{AFX_MSG_MAP(CVarsCombo)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CVarsCombo message handlers

BOOL CVarsCombo::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message != WM_KEYDOWN)
		return CComboBox::PreTranslateMessage(pMsg);

	switch (pMsg->wParam)
	{
	default:
		return CComboBox::PreTranslateMessage(pMsg);

	case VK_ESCAPE:
		if ( !( GetKeyState( VK_SHIFT ) & ~1 ) &&
		!( GetKeyState( VK_CONTROL ) & ~1 ))
		{
			m_pToolBar->m_fDoUpdate = FALSE;

			ShowDropDown(FALSE);
			return TRUE;
		}
		break;

	case VK_RETURN:
		if (GetDroppedState())
		{
			ShowDropDown(FALSE);
			return TRUE;
		}
		break;

	case VK_UP:
	case VK_DOWN:
	case VK_NEXT:
	case VK_PRIOR:
		break;
	}

	// Getting this far means we should short-circuit the normal
	// accelerator processing and dispatch immediately...
	TranslateMessage(pMsg);
	DispatchMessage(pMsg);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CVarsDialogBar

BOOL CVarsDialogBar::OnInitDialog()
{
	m_list.m_pToolBar = this;


	// dialog box is coming up, initialize items
	if (!m_list.SubclassDlgItem(IDM_CTL_VARS_FUNCS, this))
		return FALSE;

	m_list.SetExtendedUI();
	m_list.SetFont(GetStdFont(font_Normal));

	RecalcBarLayout(DkWGetDock(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_VARIABLES_WIN)), TRUE);

	return TRUE;
}

void CVarsDialogBar::OnUpdateCmdUI(CFrameWnd *,  BOOL)
{
	m_list.EnableWindow(DebuggeeAlive() && !DebuggeeRunning());
}

/////////////////////////////////////////////////////////////////////////////
// CVarsView

IMPLEMENT_DYNCREATE(CVarsView, CBaseVarsView)

CVarsView::CVarsView()
	:CBaseClass(IDDW_VCPP_VARIABLES_WIN, PACKET_NIL)
{
	m_iNameColWidth = runDebugParams.iVarsNameColWidth;

	if (g_cRef++ == 0)
		g_pFontInfo = new CFontInfo(*(pfmtcatForVarsWnd(m_nIDWnd)->pLogFont));

	m_pFontInfo = g_pFontInfo;
}

CVarsView::~CVarsView()
{
	runDebugParams.iVarsNameColWidth = m_iNameColWidth;

	if (--g_cRef == 0)
	{
		delete g_pFontInfo;
		g_pFontInfo = NULL;
	}
}

BOOL CVarsView::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_SYSKEYDOWN && m_toolbar.PreTranslateSysKey(pMsg))
	{
		if (&m_toolbar.m_list == GetFocus( ))
			m_toolbar.m_list.ShowDropDown( );

		return TRUE;
	}
				
	return CBaseClass::PreTranslateMessage(pMsg);
}

BOOL CVarsView::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT *pResult)
{
	// Route notifies to main window, for tool tip text handling.
	*pResult = AfxGetMainWnd()->SendMessage(WM_NOTIFY, wParam, lParam);

	return TRUE;
}

// It is unfortuante that this code is almost the same as
// the base classes RecalcLayout but duplicated here.
// We want to however do the multi-window layout only once.

void CVarsView::RecalcLayout( )
{
	int cxVScroll = GetSystemMetrics(SM_CXVSCROLL);
	int cyHScroll = GetSystemMetrics(SM_CYHSCROLL);
	int cxBorder = GetSystemMetrics(SM_CXBORDER);
	int cyBorder = GetSystemMetrics(SM_CYBORDER);
	
	CRect view;
	GetClientRect(view);

	// We assume
	// a) The view itself does not have a border.
	// b) The child window has a border.
	ASSERT((GetStyle() & WS_BORDER) == 0);
	ASSERT( (m_curIndex == -1) ||
		    ((m_arrChildWnd[m_curIndex]->GetStyle() &  WS_BORDER) != 0) );

	BOOL bHasToolBar = FALSE;
	if ((m_toolbar.GetStyle( ) & WS_VISIBLE) != 0)
	{
		view.top += m_toolbar.m_sizeDefault.cy;
		bHasToolBar = TRUE;
	}

	if ( bHasToolBar && UseWin4Look() )
		m_toolbar.RecalcBarLayout(DkWGetDock(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_WATCH_WIN)));		

	BOOL bHasVScroll = m_bHasVScroll;
	if (bHasVScroll)
	{
		CWnd* pScrollBar = GetDlgItem(AFX_IDW_VSCROLL_FIRST);
		ASSERT(pScrollBar != NULL);
		if ((pScrollBar->GetStyle() & WS_VISIBLE) == 0)
			bHasVScroll = FALSE;
	}

	if (bHasVScroll)
	{
		view.right -= cxVScroll;
	 	// NOTE: This code has never been tried with the vertical scrollbars
		// visible. Some tweaking might be required to get the
		// vertical toolbar and size box to line up.
	 	ASSERT(FALSE);
	}

	view.bottom -= cyHScroll;

	HDWP hDWP = BeginDeferWindowPos(5);

	CWnd* pScrollBar;
	pScrollBar = GetDlgItem(AFX_IDW_HSCROLL_FIRST);
	ASSERT(pScrollBar != NULL);

	int nOverlapSizeBox;
	if (!gpISrc->GetSrcEnvironParam(ENV_HSCROLL) && bHasVScroll)
		nOverlapSizeBox = cxVScroll;
	else
		nOverlapSizeBox = 0;

	DeferWindowPos(hDWP, pScrollBar->m_hWnd, HWND_TOP,
		0, view.bottom,
		view.Width() + nOverlapSizeBox, cyHScroll,
		SWP_NOACTIVATE);

	if ( bHasToolBar )
	{
		CRect rectClient;
		GetClientRect(&rectClient);

		DeferWindowPos(hDWP, m_toolbar.m_hWnd, HWND_TOP,
			rectClient.left, rectClient.top,
			rectClient.Width(), m_toolbar.m_sizeDefault.cy,
			SWP_NOACTIVATE);
	}

	CWnd* pSizeBox;
	pSizeBox = GetDlgItem(AFX_IDW_SIZE_BOX);
	if (pSizeBox != NULL)
	{
		DeferWindowPos(hDWP, pSizeBox->m_hWnd, HWND_TOP,
			view.right + cxBorder, view.bottom + cyBorder,
			cxVScroll - 2 * cxBorder, cyHScroll - 2 * cyBorder,
			SWP_NOACTIVATE);
	}

	pScrollBar = GetDlgItem(AFX_IDW_VSCROLL_FIRST);
	if (pScrollBar != NULL)
	{
		DeferWindowPos(hDWP, pScrollBar->m_hWnd, NULL,
			view.right, 0,
			cxVScroll, view.Height(),
			SWP_NOZORDER | SWP_NOACTIVATE);
	}

	if (m_curIndex != -1)
	{

		DeferWindowPos(hDWP, m_arrChildWnd[m_curIndex]->GetSafeHwnd(),
			NULL, 0, view.top,
			view.Width(), view.Height() + cyBorder,
			SWP_NOZORDER | SWP_NOACTIVATE);
	}

	EndDeferWindowPos(hDWP);

	// now do the computation to move the combo box
	// appropriately within the toolbar.

	CRect rcBar, rcList;
	m_toolbar.GetWindowRect(&rcBar);
	m_toolbar.m_list.GetDroppedControlRect(&rcList);

	int wAvail = rcBar.right - rcBar.left;	 // width of window
	int iOffs  = rcList.left - rcBar.left;	 // offset of listbox

	wAvail -= iOffs + 6;	 				 // remove used space + padding

	// we now know how wide we can make the listbox but lets not
	// make it too small... we'd rather let some fall off the edge
	// if its going to be too small

//	if (wAvail < 150) wAvail = 150;
	if (wAvail < 24) wAvail = 24;
	// Even if the width of the window hasn't changed we do the SetWindowPos.
	// This causes the drop-down to get dismissed. If this is not done the drop
	// down detaches from the combo-box ( see OlYMPUS:1375)
	// if (wAvail == rcList.Width()) return;

	m_toolbar.m_list.ShowWindow(SW_HIDE);	// 3-d fix - keep window invalid.
	m_toolbar.m_list.SetWindowPos(NULL,0,0, wAvail, rcList.Height(),
			SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER);
	m_toolbar.m_list.ShowWindow(SW_SHOWNOACTIVATE);
}

	
BEGIN_MESSAGE_MAP(CVarsView, CVarsView::CBaseClass)
	//{{AFX_MSG_MAP(CVarsView)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_COMMAND(IDM_DBGSHOW_VARS_BAR, OnToggleVarsBar)
	ON_UPDATE_COMMAND_UI(IDM_DBGSHOW_VARS_BAR, OnUpdateToggleVarsBar)
	ON_CBN_DROPDOWN(IDM_CTL_VARS_FUNCS, OnDropDown)
	ON_CBN_CLOSEUP(IDM_CTL_VARS_FUNCS, OnCloseUp)
	ON_MESSAGE(WU_UPDATEDEBUG, OnUpdateDebug)
	ON_MESSAGE(WU_FREEZEDATA, OnFreezeData)
END_MESSAGE_MAP()


BEGIN_POPUP_MENU(Variables)
	MENU_ITEM(IDM_DBGSHOW_VARS_BAR)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_DEBUG_RADIX)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_TOGGLE_MDI)
	MENU_ITEM(ID_WINDOW_POPUP_HIDE)
	MENU_SEPARATOR()
	MENU_ITEM(IDM_WINDOW_SHOWPROPERTIES)
END_POPUP_MENU()

void CVarsView::ShowContextPopupMenu(CPoint pt)
{
    #ifndef NO_CMDBARS
        TRACE2("Variables (%s, %d)\r\n", __FILE__, __LINE__);
        ::CBShowContextPopupMenu(MENU_CONTEXT_POPUP(Variables), pt);
    #else
    	::ShowContextPopupMenu(MENU_CONTEXT_POPUP(Variables), pt);
    #endif
}


void CVarsView::ResetCallStack( )
{
	m_toolbar.m_fUpdateListbox = TRUE;
}

void CVarsView::UpdateCallStack( )
{
	// not safe to update if debuggee is running...
	if (!DebuggeeAlive() || DebuggeeRunning())
		return;
	
	int iCall = (iCallsCxf < 0 ) ? 0 : iCallsCxf;

	char buf[256];
	CLGetWalkbackStack(hpidCurr, htidCurr, iCall + 1);
	CLGetProcName(iCall, buf, sizeof(buf), FALSE);

	CString str;
	m_toolbar.m_list.GetWindowText(str);
	if (str == buf)
		return;

	m_toolbar.m_list.ResetContent();
	m_toolbar.m_fUpdateListbox = TRUE;
	m_toolbar.m_list.AddString(buf);
	m_toolbar.m_list.SetCurSel(0);
}

			
/////////////////////////////////////////////////////////////////////////////
// CVarsView diagnostics

#ifdef _DEBUG
void CVarsView::AssertValid() const
{
	CBaseClass::AssertValid();
}

void CVarsView::Dump(CDumpContext& dc) const
{
	CBaseClass::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CVarsView message handlers.

int CVarsView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CBaseClass::OnCreate(lpCreateStruct) == -1)
		return -1;

	// First create the toolbar window.
	m_toolbar.SetDockableID(MAKEDOCKID(PACKAGE_DEBUG, IDDW_VCPP_WATCH_WIN));	

	if (!m_toolbar.Create(this, IDD_VARSVIEW_DIALOGBAR,
		CBRS_ALIGN_TOP | CBRS_BORDER_3D, AFX_IDW_TOOLBAR))
	{		
		TRACE("Failed to Create/Init Toolbar\n");
		return -1;
	}

	// must manually initialize the dialog bar because there will be no
	// WM_INIT message as there is no dialog per se.  We are just a dialog
	// template...

	if (!m_toolbar.OnInitDialog())
	{
		TRACE("Failed to Init Toolbar\n");
		return -1;
	}

	if (!runDebugParams.fVarsToolbar)
	{
		m_toolbar.ShowWindow(SW_HIDE);
	}


	// Add the child windows to the view.
	DWORD dwStyle = WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE;
	CRect rectNull(0,0,0,0);

	BOOL fCreateCPPWindows =
		runDebugParams.fWatchExt &&
		(IsPackageLoaded(PACKAGE_LANGCPP) ||
		 !IsPackageLoaded(PACKAGE_LANGFOR));

	if (fCreateCPPWindows)
	{
		CAutoWnd   * pAutoWnd = new CAutoWnd(this);
		pAutoWnd->RestoreSettings(g_persistVars.m_auto, m_iNameColWidth);

		if (pAutoWnd->Create(dwStyle, rectNull, this, 1))
		{
			m_arrChildWnd.Add(pAutoWnd);
		}
	}

	CLocalsWnd * pLocalsWnd = new CLocalsWnd(this);
	pLocalsWnd->RestoreSettings(g_persistVars.m_locals, m_iNameColWidth);
													
	if (pLocalsWnd->Create(dwStyle, rectNull, this, 1))
	{
		m_arrChildWnd.Add(pLocalsWnd);
	}

	if (fCreateCPPWindows)
	{
		CThisWnd * pThisWnd = new CThisWnd(this);
		pThisWnd->RestoreSettings(g_persistVars.m_this, m_iNameColWidth);
		
		if (pThisWnd->Create(dwStyle, rectNull, this, 1))
		{
			m_arrChildWnd.Add(pThisWnd);
		}
	}

	m_widgetScroller.SetSplitterPref(g_persistVars.m_nSplitterPref);
	m_curIndex = g_persistVars.GetActiveTabIndex();

	ShowSelection(FALSE); // don't show selections till we get activation.
	OnFontColorChange();
		
	return 0;
}

void CVarsView::OnDestroy()
{
	CBaseClass::OnDestroy();
	
	g_persistVars.m_nSplitterPref = m_widgetScroller.GetSplitterPref();

	m_arrChildWnd[indexLocals]->RememberSettings(g_persistVars.m_locals);

	ASSERT(m_curIndex >= 0);
	g_persistVars.SetActiveTab(m_curIndex);
	g_pVarsView = NULL;
}


void CVarsView::OnToggleVarsBar( )
{
	BOOL fShow = runDebugParams.fVarsToolbar = !runDebugParams.fVarsToolbar;
	
	m_toolbar.ShowWindow(fShow ? SW_SHOWNA : SW_HIDE);
	RecalcLayout();

	// Let the dock frame adjust to the new toolbar state
	// if it needs to.
	DkRecalcBorders(this);		

	if ( m_toolbar.IsChild(CWnd::GetFocus()) )
		SetFocus();
}

void CVarsView::OnUpdateToggleVarsBar ( CCmdUI *pCmdUI )
{
	pCmdUI->SetCheck(runDebugParams.fVarsToolbar);
}


void CVarsView::OnDropDown()
{
	if ( m_toolbar.m_fUpdateListbox )
	{
		m_toolbar.m_list.ResetContent();

		if (!DebuggeeAlive() || DebuggeeRunning())
		{
			MessageBeep(0);
			return;
		}

		CLGetWalkbackStack(hpidCurr, htidCurr, 0);

		int cfme = CLChfmeOnStack();

		for (int ifme = 0; ifme < cfme; ifme++)
		{
			char buf[256];
			CLGetProcName(ifme, buf, sizeof(buf), FALSE);
			m_toolbar.m_list.AddString(buf);
		}
	
		int iCall = (iCallsCxf < 0 ) ? 0 : iCallsCxf;

		m_toolbar.m_list.SetCurSel(iCall);

		m_toolbar.m_fUpdateListbox = FALSE;
	}
	m_toolbar.m_fDoUpdate = TRUE;
}

// a new frame has been selected, change the locals & source being displayed

void CVarsView::OnCloseUp()
{

	int isel = m_toolbar.m_list.GetCurSel();

	if (isel != LB_ERR && m_toolbar.m_fDoUpdate)
	{
		int iCall = (iCallsCxf < 0) ? 0 : iCallsCxf;

		if ( isel != iCallsCxf )
			CLDispCallInfo(isel);
	}
	else
	{
		// if we don't update the callstack at CloseUp make sure the current
		// selection in the combo box is set correctly.
		int iCall = (iCallsCxf < 0)? 0 : iCallsCxf;
		m_toolbar.m_list.SetCurSel(iCall);
	}
}



LRESULT CVarsView::OnUpdateDebug(WPARAM wParam, LPARAM lParam)
{
	// Besides refreshing the grid we also need to update the callstack
	// entries.
	
	// FUTURE: This is the comment from the old locals window.
	// I do not understand this part completely -- sgs --

	// If wParam is zero, then we have a passed in CXT,
	// invalidate the entire client area to force a repaint
	if  (wParam ==wPCXF)  	
	{
		// lParam is zero, then we are updating because memory has been
		// updated, reset the callstack so it will be reset and updated
		// when dropped.
		if (!lParam)
		{
			// Want to make sure that when the listbox is
			// dropped, that it gets reset and updated
			ResetCallStack();
		}
		lParam = NULL;
	}

	UpdateCallStack( );

	return CBaseClass::OnUpdateDebug(wParam, lParam);
}


LRESULT CVarsView::OnFreezeData(WPARAM wParam, LPARAM lParam)
{
	ResetCallStack();

	return 0;
}

			
//////////////////////////////////////////////////////////////////////////////
// Persistence related classes.

IMPLEMENT_SERIAL(CPersistWatchTab, CObject, 1)

CPersistWatchTab::CPersistWatchTab( )
{
	InitDefault();
}

CPersistWatchTab::CPersistWatchTab(const CString& str)
	: m_strTabName(str)
{
	InitDefault();
}

void CPersistWatchTab::InitDefault()
{
	// Place-holder if we need to do any common initializations.
}
		
const CPersistWatchTab& CPersistWatchTab::operator=(const CPersistWatchTab& p)
{
	m_strTabName = p.m_strTabName;

	m_arrWatchNames.RemoveAll();

	for ( int i = 0; i < p.m_arrWatchNames.GetSize() ; i++ )
		m_arrWatchNames[i] = p.m_arrWatchNames[i];

	return *this;
}				

void CPersistWatchTab::ChangeTabName(const CString& str)
{
	m_strTabName = str;
}

void CPersistWatchTab::AddWatchName(CString& str)
{
	m_arrWatchNames.Add(str);
}

void CPersistWatchTab::ClearAllWatches( )
{
	// Will the memory for the strings be reclaimed correctly.
	m_arrWatchNames.RemoveAll( );
}

void CPersistWatchTab::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);
	m_arrWatchNames.Serialize(ar);

	if ( ar.IsStoring( ))
	{
		ar << m_strTabName;
	}
	else
	{
		ar >> m_strTabName;
	}
}

void AFXAPI ConstructElements(CPersistWatchTab *pTab, int nCount)
{
	for ( int i = 0; i < nCount ; i++, pTab++ )
	{
		pTab->CPersistWatchTab::CPersistWatchTab();
	}
}

void AFXAPI DestructElements(CPersistWatchTab *pTab, int nCount)
{
	for ( int i = 0; i < nCount ; i++, pTab++ )
	{
		pTab->CPersistWatchTab::~CPersistWatchTab();
	}
}

void AFXAPI SerializeElements(CArchive& ar, CPersistWatchTab* pTab, int nCount)
{
	for ( int i = 0; i < nCount ; i++, pTab++ )
	{
		pTab->Serialize(ar);
	}
}

IMPLEMENT_SERIAL(CPersistWatch, CObject, 1)

CPersistWatch::CPersistWatch( )
{
	
}

void CPersistWatch::InitDefault()
{
	CString str;

	VERIFY(str.LoadString(IDS_WATCH1));
	CPersistWatchTab watch1(str);
	VERIFY(str.LoadString(IDS_WATCH2));
	CPersistWatchTab watch2(str);
	VERIFY(str.LoadString(IDS_WATCH3));
	CPersistWatchTab watch3(str);
	VERIFY(str.LoadString(IDS_WATCH4));
	CPersistWatchTab watch4(str);

	ClearAll();

	m_arrWatchTab.Add(watch1);
	m_arrWatchTab.Add(watch2);
	m_arrWatchTab.Add(watch3);
	m_arrWatchTab.Add(watch4);
	m_curIndex = 0;
	m_nSplitterPref = 0;
}

void CPersistWatch::AddWatchTab(const CString& str)
{
	CPersistWatchTab watchTab(str);

	m_arrWatchTab.Add(watchTab);
}

void CPersistWatch::AddWatchTab(CPersistWatchTab& rTab)
{
	m_arrWatchTab.Add(rTab);
}

CPersistWatchTab& CPersistWatch::GetWatchTab(int index)
{
	return m_arrWatchTab[index];
}

int CPersistWatch::GetTabCount( )
{
	return m_arrWatchTab.GetSize();
}

void CPersistWatch::ClearAll( )
{
	for ( int i = 0 ; i < m_arrWatchTab.GetSize() ; i++ )
		m_arrWatchTab[i].ClearAllWatches();

	m_arrWatchTab.RemoveAll( );
	m_curIndex = 0;	
}
		
void CPersistWatch::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);

	m_arrWatchTab.Serialize(ar);

	if ( ar.IsStoring() )
	{
		ar << (WORD)m_curIndex;
		ar << (WORD)m_nSplitterPref;
	}
	else
	{
		WORD w;
		ar >> w;
		m_curIndex = w;
		// We saved a 32 bit int as a 16 bit unsigned.
		// This is fine, except that the value "-1" is used
		// as a special flag.  So convert 65535 to "-1" if
		// we hit it.  This preserves backward compat with
		// saved files.
		if (m_curIndex == 0xffff) m_curIndex = -1;
		ar >> w;
		m_nSplitterPref = w;
	}
}


// variables window persistence information.
IMPLEMENT_SERIAL(CPersistVarsTab, CObject, 1)

CPersistVarsTab::CPersistVarsTab( )
{
	InitDefault();
}

void CPersistVarsTab::InitDefault()
{
	// Place-holder for common initializations.
}

void CPersistVarsTab::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);

	if ( ar.IsStoring( ))
	{
	}
	else
	{
	}
}

	
IMPLEMENT_SERIAL(CPersistVariables, CObject, 1)

CPersistVariables::CPersistVariables( )
{
}

void CPersistVariables::InitDefault( )
{
	m_curIndex = 0;
	m_nSplitterPref = 0;
}		


void CPersistVariables::Serialize(CArchive& ar)
{
	CObject::Serialize(ar);

	if ( ar.IsStoring() )
	{
		ar << (WORD)m_curIndex;
		ar << (WORD)m_nSplitterPref;
	}
	else
	{
		WORD w;
		ar >> w;
		m_curIndex = w;
		// We saved a 32 bit int as a 16 bit unsigned.
		// This is fine, except that the value "-1" is used
		// as a special flag.  So convert 65535 to "-1" if
		// we hit it.  This preserves backward compat with
		// saved files.
		if (m_curIndex == 0xffff) m_curIndex = -1;
		ar >> w;
		m_nSplitterPref = w;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\bm.h ===
/*** bm.h - Memory Manager routines
*
*	Copyright <C> 1990, Microsoft Corporation
*
* Purpose:  handle the near and far memory requests of dlls & linked list
*
*
*************************************************************************/

BOOL PASCAL        BMInit ( VOID );
HMEM PASCAL LOADDS BMAlloc ( UINT );
HMEM PASCAL LOADDS BMRealloc ( HMEM, UINT );
VOID PASCAL LOADDS BMFree ( HMEM );
LPV  PASCAL LOADDS BMLock ( HMEM );
VOID PASCAL LOADDS BMUnlock ( HMEM );
BOOL PASCAL LOADDS BMIsLocked ( HMEM );

#ifndef BMHANDLES
#define BMLock(HMEM) ((LPV)(HMEM))
#define BMUnlock(HMEM)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\tracefn.cpp ===
////////////////////////////////////////////////////////////////////////////////
// Trace into specific function

#include "stdafx.h"
#pragma hdrstop
#include "tokens.h"

CTraceFunction *g_pTraceFunction = NULL;

CTraceFunction::CTraceFunction ()
{
	m_fTmlInitialized = FALSE;
}

CTraceFunction::~CTraceFunction ()
{
	if (m_fTmlInitialized)
	{
		EEFreeTML (&m_tml);
	}
}

BOOL CTraceFunction::SetupStep()
{
	BOOL bRet = FALSE;
	unsigned long ilineCurrent;
	_CB ibCurrent;
	LPSOURCEEDIT piSrcEdit = NULL; 
	CString strCall;
	LPSLP rgslp;
	int cslp;
	int islp;

	// get ISourceEdit
	ASSERT(gpISrcQuery);
	if (!SUCCEEDED(gpISrcQuery->CreateSourceEditForActiveDoc(&piSrcEdit,FALSE)))
	{
		return FALSE;
	}
	ASSERT(piSrcEdit);

	// Get current line and column
	if ((S_OK == piSrcEdit->FHasSelection()) &&
		SUCCEEDED(piSrcEdit->GetSelection(NULL, NULL, &ilineCurrent, &ibCurrent, NULL))
		)
	{
		ibCurrent--;
	}
	else 
	{
		piSrcEdit->GetCaretLine(&ilineCurrent);
		piSrcEdit->GetCaretIndex(&ibCurrent);
	}

	// get the address of the IP
	if (SYGetAddr (hpidCurr, htidCurr, adrPC, &m_addrPC) != xosdNone ||
		!SYUnFixupAddr (&m_addrPC))
	{
		goto L_Exit;
	}

	m_wLineEnd = ilineCurrent + 1;

	// Block: get a list of all addresses at this line
	{
		CString strPathName;
		piSrcEdit->GetPath(strPathName);
		// for some reason the EE complains about blank filenames
		if (strPathName == "")
			goto L_Exit;

		cslp = SLCAddrFromLine(
			(HEXE)NULL,
			(HMOD)NULL,
			(LPSTR) (LPCSTR) strPathName,
			m_wLineEnd,
			&rgslp
		);
	}

	// see if the address is in the list
	for (islp = 0; islp < cslp; islp++)
	{
		const LPSLP lpslp = &rgslp [islp];

		ASSERT (ADDR_IS_LI (lpslp->addr));

		if (GetAddrSeg (m_addrPC) == GetAddrSeg (lpslp->addr) &&
			GetAddrOff (m_addrPC) >= GetAddrOff (lpslp->addr) &&
			GetAddrOff (m_addrPC) <  GetAddrOff (lpslp->addr) + lpslp->cb)
		{
			break;
		}
	}

	// free up the RGSLP if necessary
	if (rgslp)
		SHFree( (LPV)rgslp );

	// quit if we didn't find any matches
	if (islp >= cslp)
		goto L_Exit;

	// take a guess at where to start parsing
	if (m_wLineEnd > 10)
		m_wLineStart = m_wLineEnd - 10;
	else
		m_wLineStart = 1;

	{ // block: parse text
		CTokenStream tokStream(piSrcEdit, m_wLineStart - 1, m_wLineEnd - 1);
		CTokenStreamPos posFunc = tokStream.GetTailPosition();
		while (posFunc.IsValid() && !posFunc.IsAtStartOfLine())
		{
			TXTB *ptxtb = tokStream.GetAt (posFunc);
			if (ptxtb->ibTokMin <= ibCurrent)
				break;
			tokStream.GetPrev (posFunc);
		}

		if (!posFunc.IsValid() || tokStream.GetAt(posFunc)->ibTokMin > ibCurrent)
			goto L_Exit;

		ASSERT(posFunc.IsValid());

		CTokenStreamPos posStart = posFunc;
		BOOL fContinue = TRUE;
		BOOL fLastTokenWasID = FALSE;
		do
		{
			CToken token(tokStream.GetAt(posStart)->tok);
			if (token.IsCxxIdent())
			{
				if (fLastTokenWasID)
					// don't allow two IDs in a row
					goto L_Exit;
				fContinue = TRUE;
				fLastTokenWasID = TRUE;
			}
			else
			{
				fLastTokenWasID = FALSE;
				if (token.IsOperator())
				{
					switch (token)
					{
					case tokOP_ARROW:
					case tokOP_DOT:
					case tokOP_DCOLON:
						fContinue = TRUE;
						break;

					default:
						fContinue = FALSE;
					}
				}
				else
				{
					fContinue = FALSE;
				}
			}

			if (fContinue)
			{
				tokStream.GetPrev (posStart);
			}
		} while (fContinue && posStart.IsValid());

		if (posStart == posFunc)
			// the cursor is not on a relevant token type
			goto L_Exit;

		// move posStart to point to the first token in our call
		if (posStart.IsValid ())
			tokStream.GetNext (posStart);
		else
			posStart = tokStream.GetHeadPosition ();

		CTokenStreamPos posTmp = posStart;

		while (posTmp != posFunc)
		{
			strCall += tokStream.GetStringAt (posTmp);
			tokStream.GetNext (posTmp);
		}
		strCall += tokStream.GetStringAt (posFunc);
	}

	// block: EEParse call
	{
		CXF curCxf (::CxfWatch());
		PCXF pCXF = &curCxf;
		USHORT strIndex;
		EESTATUS eestatus;

		eestatus = EEParseBP(
			(LSZ)(const char *)strCall,
			0x10,	//radixInput,
			TRUE,	//fCaseSensitive,
			pCXF,
			&m_tml,
			0L,
			&strIndex,
			FALSE
			);

		if (eestatus == EEGENERAL)
		{
			// not in current context
			// FUTURE: should check in each DLL??
			goto L_Exit;
		}

		if (eestatus == EEGENERAL)
		{
			HEXE hexe = (HEXE) NULL;

			// We couldn't find the symbol in the current context
			//  and the user didn't specify a context so we'll
			//  try all the other dlls

			// first, we save away the error msg
			EEFreeTML(&m_tml);

			while ((hexe = SHGetNextExe(hexe)) != 0 && eestatus == EEGENERAL)
			{
				CString strBP;

				strBP.Format ("%c,,%s%c%s", chBeginCxtOp, SHGetExeName (hexe), chEndCxtOp, strCall);
				eestatus = EEParseBP (
					(LSZ) (const char *) strBP,
					0x10,		// radixInput
					TRUE,		// fCaseSensitive
					pCXF,
					&m_tml,
					0L,
					&strIndex,
					FALSE
				);

				// If we failed, just delete the TM list
				if ( eestatus != EENOERROR )
				{
					EEFreeTML(&m_tml);
				}
			}
		}

		if (eestatus != NOERROR)  // failed for some other reason
			goto L_Exit;
	}
	m_fTmlInitialized = TRUE;
	bRet = TRUE;

L_Exit:
	if (piSrcEdit)
		piSrcEdit->Release();
	return bRet;
}

BOOL CTraceFunction::GetString(CString & str)
{
	EESTATUS eestatus;
	BOOL fSuccess = FALSE;

	PHTM rgHTM = (PHTM)BMLock(m_tml.hTMList);

	HCXTL hCXTL;
	HTM &htm = rgHTM[0];

	eestatus = EEGetCXTLFromTM(&htm, &hCXTL);
	if (eestatus == EENOERROR)
	{
		// Check for function names
		ETI eti;
		RTMI rtmi = { 0 };
		HTI hTI ;

		// Request information about "lvalue"ness from the EE.
		rtmi.fLvalue = TRUE;	

		if (EEGetExtendedTypeInfo(&htm, &eti) == EENOERROR &&
			eti == ETIFUNCTION &&
			EEInfoFromTM(&htm, &rtmi, &hTI) == EENOERROR)
		{
			ASSERT( hTI != ( HTI ) NULL );

			// Get the TM Info structure.
			PTI pTI = ( PTI ) BMLock(hTI);
			ASSERT(pTI != NULL);

			// can't do anything with function calls
			if (!pTI->fFunction)
			{
				PCXTL pCXTL = (PCXTL) BMLock (hCXTL);

				ASSERT (pCXTL->cHCS >= 1);

				char rgch[257];
				HSYM hSym = pCXTL->rgHCS[pCXTL->cHCS - 1].hSym;

				if (hSym != NULL && SHGetSymName (hSym, rgch))
				{
					str = rgch;
					fSuccess = TRUE;
				}

				BMUnlock (hCXTL);
				EEFreeCXTL (&hCXTL);
			}

			// Free up the resources.
			BMUnlock(hTI);
			EEFreeTI(&hTI);
		}
	}

	BMUnlock (m_tml.hTMList);

	return fSuccess;
}

BOOL CTraceFunction::CompareCxt(PCXT pCXT)
{
	EESTATUS eestatus;
	BOOL fFound = FALSE;

	PHTM rgHTM = (PHTM) BMLock(m_tml.hTMList);

	HSYM hSym;
	UOFF32 uoff = SHGetNearestHsym (
		SHpADDRFrompCXT (pCXT),
		SHHMODFrompCXT (pCXT),
		EECODE, &hSym );

	for (UINT iCXT = 0; !fFound && iCXT < m_tml.cTMListAct; iCXT++)
	{
		HCXTL hCXTL;

		eestatus = EEGetCXTLFromTM (&rgHTM[iCXT], &hCXTL);
		if (eestatus == EENOERROR)
		{
			CXT cxt;
			ADDR addrT = {0};
			ushort usSegType = EEANYSEG;

			// Get the BP address from TM...
			BPADDRFromTM (&rgHTM[iCXT], &usSegType, &addrT);

			// And then the context from the addr...
			if (!SHSetCxt (&addrT, &cxt))
			{
				// Build the cxt
				cxt = *(PCXT) BMLock (hCXTL);
				BMUnlock (hCXTL);
			}
			// Free the allocated space from the EE
			EEFreeCXTL (&hCXTL);

			if (pCXT->hProc == cxt.hProc)
			{
				fFound = TRUE;
			}
		}
	}

	BMUnlock (m_tml.hTMList);

	return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\cvdef.h ===
/***	cvdef.h - header for cv global symbol definitions.
 *
 *		Copyright <C> 1989, Microsoft Corporation
 *
 *		Purpose:
 *
 */


#include "nothunk.h"

#define CC
#define CV3
#define HELP_BUTTON

#ifdef DOS5
#define INCL_NOPM
#define _MAX_CVPATH	  259	  /* max. length of full pathname */
#define _MAX_CVDRIVE	3	  /* max. length of drive component */
#define _MAX_CVDIR	  257	  /* max. length of path component */
#define _MAX_CVFNAME  257	  /* max. length of file name component */
#define _MAX_CVEXT	  257	  /* max. length of extension component */

#else

#define _MAX_CVPATH	 144	  /* max. length of full pathname */
#define _MAX_CVDRIVE   3	  /* max. length of drive component */
#define _MAX_CVDIR	 130	  /* max. length of path component */
#define _MAX_CVFNAME  32      /* max. length of file name component */
#define _MAX_CVEXT	   5	  /* max. length of extension component */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\cv.h ===
#ifndef _CV_H
#define _CV_H
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>

#include "cvdef.h"

#include "types.h"
#include "cvtypes.h"
#include "cvinfo.h"
#include "shapi.h"
#include "eeapi.h"

#include "island.h"
#include "globals.h"

#include "bm.h"

#include "linklist.h"
#include "shproto.h"

#include "eeproto.h"
#include "cvexpr.h"
#include "cvmsg.h"

#include "od4.h"
#include "sy.h"

#include "fcndef.h"
#endif // _CV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\cp.h ===
/*** cp.h -- Header file for subsystem Command Parse Handler

Copyright <C> 1990, Microsoft Corporation

Purpose:

    Define all exported functions and data from Command Parsing Handler.

***********************************************************************/
typedef enum {
	CPNOERROR,
	CPNOARGS,
	CPISOPENQUOTE,
	CPISCLOSEQUOTE,
	CPISOPENANDCLOSEQUOTE,
	CPISDELIM,
	CPNOTINQUOTETABLE
}CPRETURNS;



char FAR * PASCAL CPToken ( char FAR * szSrc, char FAR * szUserDelim );
int PASCAL CPQueryChar ( char FAR * szSrc, char FAR * szUserDelim );
int PASCAL CPQueryQuoteIndex ( char FAR * szSrc );
char FAR * PASCAL CPAdvance ( char FAR * szSrc, char FAR * szUserDelim );
char FAR * PASCAL CPTrim ( char FAR * szSrc, char chTrim );
char FAR * PASCAL CPszToken ( char FAR * szSrc, char FAR * szUserDelim );
int PASCAL CPCreateDebuggeeArgs( char *, char *** );
void PASCAL CPCreateCmdLine( int, char *** );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\cl.h ===
#ifndef CL_INCLUDED
#define CL_INCLUDED

typedef enum {
    cltNone,
    cltPub,
    cltProc,
    cltBlk,
} CLT;

typedef struct _FME {
    char FAR *symbol;
    char	clt;
	BOOL	fSetProc;	 /* has CLSetProcAddr been called? */
	LSZ		lsz;		 /* cached display string */
    ADDR	addrProc;    /* start of procedure, or block */
    ADDR	addrRet;
    ADDR	addrCSIP;    /* current return location */
    FRAME	Frame;
    HMOD	module;      /* pointer to module */

} FME; // FraMe Entry
typedef FME FAR *   LPFME;

extern int	PASCAL CLLookupAddress( ADDR );
extern void PASCAL CLGetWalkbackStack (  HPID, HTID, UINT );
extern void PASCAL CLFreeWalkbackStack( BOOL );
extern char *  PASCAL CLGetProcName(int, char *,int,BOOL);
extern BOOL CLDispCallInfo( int iCall );

void PASCAL CLDumpStackItem ( int );
void PASCAL CLDumpStackTrace ( void );

PCXF PcxfLocal ( void );

typedef HLLE        HFME;

extern HLLI hlliFME;
extern int iCallsCxf;

int  PASCAL CLChfmeOnStack( void );
HFME PASCAL CLHfmeGetNth( int );

#endif	// !CL_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\cvwmem.h ===
#ifndef _CVWMEMMAP
#define _CVWMEMMAP

#ifdef __cplusplus
extern "C" {
#endif

void FAR * cvw3_fmalloc( size_t );
void _HUGE_ * CDECL cvw3_halloc( long, size_t );
size_t cvw3_fmsize(void FAR *buffer);
void FAR *cvw3_frealloc(void FAR *buffer, size_t size);
void cvw3_ffree( void FAR * );
void cvw3_hfree( void _HUGE_ * );

#ifdef __cplusplus
} //extern "C"
#endif

#endif	// !_CVWMEMMAP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\cvmsg.h ===
/*** cvmsg.h - miscellaneous defines for cvmsg.c and anybody that needs it.
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*   Revision History:
*
*   [ds]    31-Aug-1989 dans	Changed prototype of CVMessage, added MESSAGEMSG
*   [xx]    08-Feb-1989 Dans	Created
*
*************************************************************************/

#define MAXERRMSG	256

enum _MSG_TYPE {
	ERRORMSG = 1,	// output="CVnnnn Error: %s", msgid=errno
	WARNMSG,		// output="CVnnnn Warning: %s", msgid=errno
	INFOMSG,		// output="%s", msgid=nsz
	MESSAGEMSG,		// output="CVnnnn Message: %s", msgid=errno
	FMESSAGEMSG,	// output="CVnnnn Message: %s", msgid=errno referring to
					//   string which has a "%s" in it, 1st vararg=lsz
	EXPREVALMSG		// output="CVnnnn Error: %s", 1st vararg=lsz
	};

enum _MSG_WHERE {
	CMDWINDOW = 1,	// if command window is open, display there, otherwise
					//   message box
	MSGBOX,			// message box
	STATLINE,		// status line
	MSGSTRING,		// 1st vararg=lsz where message is written
    MSGGERRSTR,     // save to global err string, to be output later when
                    //   MSGID==GEXPRERR
    CVMSGSTRING
	};

typedef int				MSGTYPE;
typedef unsigned int	MSGID;		// must not be short--VCNT needs 4 bytes
typedef int				MSGWHERE;

//
//  api call
//
extern "C" void		CVMessage ( MSGTYPE, MSGID, MSGWHERE, ... );
extern void PASCAL	CVExprErr ( EESTATUS, MSGWHERE, PHTM, char FAR * );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\cvexpr.h ===
/*** cvexpr.h - header file for codeview expression evaluator stuff
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*   Revision History:
*
*   [05]    17-Aug-1990 Glennn	changed ESSet_eval to char far *
*   [04]    11-Jul-1990 Glennn	changed fIsLoaded to fIsFound
*   [03]    06-Jul-1990 Glennn	Added def of hDLL field and fIsloaded
*   [2]     18-May-1989 ArthurC Installed Windows Message tracing
*   [ds]    24-Apr-1989 dans	Added BPDEADTHREAD.
*
*************************************************************************/

#define clanMax 10

typedef struct _lan {			// language
    char *		szFile;	    	// full path to file name after ESFindExpr call
    char *		szName;	    	// name displayed to user
    char *		szTitle;
    char *		szExt;	    	// ext by default it will be .dll
	char FAR *	lszIsIdChar;	// chars that are legal in identifiers
	char FAR *	AssignOp; 		// assignment operator for language
	PEXF		pexf; 			// point to struct that holds ee initialization stuff
    int			Radix;	    	// current
    char		fCaseSensitive; // current
    ushort		hDLL;    		// handle to dll DOS3
    int			fIsFound;       // [03][04]whether the file has been found
    } LAN;

extern LAN     rglan[];
extern int     clan;
extern int     fAuto;
extern PEXF    pEXF;

extern long		PASCAL CVGetNbr(char FAR *, int, int,
					PCXF, char FAR *, int FAR *);
extern int      PASCAL CVGetCastNbr(char FAR *, CV_typ_t, int, int,
					PCXF, char FAR *, char FAR *);
extern int		PASCAL CVGetList(char *, int, int, PCXF,
					int, char [], int *);
extern int		PASCAL CVEvaluate(char FAR *, int, int, PCXF, char *);

extern void PASCAL  ESInitExpr( char *szEval );
extern void PASCAL  ESDefaultExpr( void );
extern void PASCAL  ESSet_language(void);
extern void PASCAL  ESLoadExpr(int, unsigned int, LPFNEEINIT);
extern void	PASCAL  ESUnLoadAllExpr (void);
extern int 	PASCAL  ESilan (void);
extern int 	PASCAL  ESSetFromIndex (int);
extern void	PASCAL  ESSet_eval (char  FAR *);
extern void	PASCAL  ESSet_auto (int);
extern void	PASCAL  ESShow_language (void);
extern int  PASCAL  ESFindEEIndex ( char *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\cvwin32.h ===
//-----------------------------------------------------------------------------
//	cvwin32.h
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:
//		api for the 4 functions in cvwin32.c
//
//  Functions/Methods present:
//
//  Revision History:
//
//	[]		05-Mar-1993 Dans	Created
//
//-----------------------------------------------------------------------------

#if !(defined (_cvwin32_h))
#define _cvwin32_h 1

typedef enum ICS {	// index to critical section
	icsBm,			// handle-based memory allocation routines
	icsWmalloc,		// pointer-based memory allocation routines
	icsMax
} ICS;

typedef void *	PCS;

void _fastcall		CVInitCritSection(ICS);
void _fastcall		CVLeaveCritSection(ICS);
void _fastcall		CVEnterCritSection(ICS);
void _fastcall		CVDeleteCritSection(ICS);
PCS  _fastcall		PcsAllocInit();
void _fastcall		FreePcs(PCS);

// These routines are called thousands of times when stepping,
// and show up in the profile reports
void inline 	AcquireLockPcs ( PCS pcs ) {
        EnterCriticalSection ( (CRITICAL_SECTION *)pcs );
}

void inline		ReleaseLockPcs ( PCS pcs ) {
        LeaveCriticalSection ((CRITICAL_SECTION *)pcs );
}

// void _fastcall          AcquireLockPcs(PCS);
// void _fastcall          ReleaseLockPcs(PCS);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\debtimer.h ===
/** debtimer.h - quick include file for simple CV timing
 *
 */



#include <time.h>
#include <sys\timeb.h>

typedef struct _timearray {
	clock_t 	tWinMain;
	clock_t 	tMain;
	clock_t 	tExeLoadStart;
	clock_t 	tExeLoadEnd;
	clock_t 	tOmfLoadStart;
	clock_t 	tOmfLoadEnd;
	clock_t 	tMkModuleStart;
	clock_t 	tMkModuleEnd;
	clock_t 	tPublicsStart;
	clock_t 	tPublicsEnd;
	clock_t 	tGlobalsStart;
	clock_t 	tGlobalsEnd;
	clock_t 	tTypesStart;
	clock_t 	tTypesEnd;
	clock_t 	tDupStart;
	clock_t 	tDupEnd;
	clock_t 	tSymLoad;
	clock_t 	tSrcModLoad;
	clock_t 	tLoadEnd;
	clock_t 	tExit;

} TIMEARRAY;

extern TIMEARRAY	TimeArray;


#if defined (_DEBUG)
#define TIMER(name) TimeArray.name=clock()
#else
#define TIMER(name) /*TimeArray.name=clock()*/
#endif

#define InitTimer()
#define StartTimer(itm)
#define StopTimer(itm)
#define ShowElapsedTime(itm)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\island.h ===
/*** island.h - global include file
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*   this file is portable, and contains include information for
*   the portable code in ISLAND.
*
*   Revision History:
*
*
*************************************************************************/

/* ISLAND definitions */

#define emsptr(x) (x)
#define ptrems(x) (x)
#define ems_alloc(size) ((char FAR *)_fmalloc(size))

#ifdef DOS5
void FAR * _fmalloc ( size_t );
#define IsSegEqual(a,b) (((a) & ~0x3) == ((b) & ~0x3))

#ifndef DOSBOX
#define SetExeType(a)	NOERROR
#endif

#define IsEmsPageLoaded(x) (TRUE)

#if (defined (EMSDEBUG) || defined (EMSSWAP)) && defined (DOS5)
// for debug do a 2's complement so NULL is still NULL
//#define emsptr(x) ((char FAR *) ((~((unsigned long) (x))) + 1) )
//
// ems debugging
//

#if (defined (EMSDEBUG) || defined (EMSSWAP)) && defined (DOS5)
char FAR * FAR emsptr ( void FAR * );
#endif

#define ptrems(x) emsptr(x)
#else
#define emsptr(x) (x)
#define ptrems(x) (x)
#endif

#define ems_alloc(size) ptrems(((char FAR *)_fmalloc(size)))
#else
#define IsSegEqual(a,b) ((a) == (b))
#endif

#define IsEmiEqual(a,b) ((a) == (b))

typedef uchar FAR *emstype; //* emsptr cast type

#define EMSPTR(a,b) ((a) emsptr((uchar FAR *) b))
#define PTREMS(a,b) ((a) ptrems((uchar FAR *) b))

extern	int IsEmiLoaded(ushort);

#define MAXINPLINE 256		/* longest user input line */
#define MAXLINE    256		/* longest source line */
#define MAXSTRING  128		/* longest string */

#ifndef SetExeType
extern int SetExeType( int );	// If not "defined", then need prototype
#endif	// !SetExeType

/* additional numbers for errno.h */

#define NOSYMBOLS		 101
#define NOTPACKED		 102	// file must be packed
#define MUSTRELINK		 103	// file must be relinked
#define FUTURESYMBOLS	 104	// file has OMF that is newer than this CV
#define PDBNOTFOUND      105    // pdb cannot be found
#define PDBBADSIGNATURE  106	// no symbolic information in pdb
#define PDBINVALIDAGE    107    // pdb is older than exe
#define PDBOLDFORMAT     108	// pdb is not current format
#define CV_NOERROR		   0	// no error condition
#define BADBKPTCMD		1001	// bad breakpoint command
#define SYNTAXERROR 	1017	// syntax error
#define NOCODE			1023	// no code at this line number
#define NOSOURCEHERE	1031	// address with no source line
#define MODLOADERROR	1042	// library module not loaded
#define NOTLVALUE		1050	// tp addr not lvalue

// Lang independent expression evaluator errors
#define CATASTROPHICTM	1250	// catastrophic TM error
#define EXPRERROR		1252	// to print the expression evaluators error strings!!
#define GEXPRERR		1253	// use the Expr Eval error saved by the message routines
#define BADADDR         1254    // not a valid address expression
#define NODATAMEMBERS   1255    // expanded a class with no data members

#define MODLOADED		2207	// loading OMF info for dll
#define NOADDRGIVEN     2212    // didn't specify an address
#define TOOMANYADDR     2213    // tried to specify more than one addr exp
#define MODNOMATCH      2214    // Mod name already loaded doesn't match
#define SYMSCONVERTED   2215
#define	EXPORTSCONVERTED 2216

#define EMMINSUFMEM 	3007	// Insufficent EMS memory

#define BADTYPECAST		1008	// bad type cast
#define NOROOM			3608	// out of memory

#define CVMSGMIN		(5000)

#define NOWATCHFUNC     (CVMSGMIN + 14) // Warning: Function Execution not Support in Watch Window
#define CLSTKCHGD       (CVMSGMIN + 15) // User changed memory/reg which
                                        // altered the call stack while
                                        // viewing function in walkback

/* Please note: This codes also enable the dependent functions to insure
   correct results. If a code is disabled, make sure all functions depending
   on it are disabled! That is if user_pc is disabled, so must ctxtIp and
   stack. */


typedef union fEnvir
	{
	unsigned short	 fAll;
	struct	fs
	    {
	    unsigned int     user_pc :1;	  /* indicates if user_pc is valid */
	    unsigned int     ctxtIp  :1;	  /* current context is valid */
	    unsigned int     stack   :1;	  /* stack frame is set up */
	    unsigned int     asmaddr :1;	  /* assembly addres is valid */
	    unsigned int	     	:12;	  /* reserved, must be zero */
	    } fs;
	} fEnvir;


/* enabling masks */

#define mUserPc     0x0001
#define mCtxtIp     0x0003		/* ctxtIp depends on user pc */
#define mStack	    0x0007		/* depends on ctxtIp and user pc */
#define mAsmaddr    0x0008

/* disabling masks */

#define mdUserPc     0xFFF8
#define mdCtxtIp     0xFFF9
#define mdStack      0xFFFB
#define mdAsmaddr    0xFFF7

/*
** Define for max length prefixed strings converted to sz style
*/
#define CCHMAXPREFIXTOSZ    (256)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\eeproto.h ===
//  **********************************************************************
//  *                                                                    *
//  *   Expr Evaluator Declarations                                      *
//  *                                                                    *
//  **********************************************************************

extern	PEXF	pEXF;

#define EEFreeStr			(*pEXF->pEEFreeStr)
#define EEGetError			(*pEXF->pEEGetError)
#define EEParse 			(*pEXF->pEEParse)
#define EEBindTM			(*pEXF->pEEBindTM)
#define EEvaluateTM 		(*pEXF->pEEvaluateTM)
#define EEGetExprFromTM 	(*pEXF->pEEGetExprFromTM)
#define EEGetValueFromTM	(*pEXF->pEEGetValueFromTM)
#define EEGetNameFromTM 	(*pEXF->pEEGetNameFromTM)
#define EEGetTypeFromTM 	(*pEXF->pEEGetTypeFromTM)
#define EEFormatCXTFromPCXT	(*pEXF->pEEFormatCXTFromPCXT)
#define EEFreeTM			(*pEXF->pEEFreeTM)
#define EEParseBP			(*pEXF->pEEParseBP)
#define EEFreeTML			(*pEXF->pEEFreeTML)
#define EEInfoFromTM		(*pEXF->pEEInfoFromTM)
#define EEFreeTI			(*pEXF->pEEFreeTI)
#define EEGetCXTLFromTM 	(*pEXF->pEEGetCXTLFromTM)
#define EEFreeCXTL			(*pEXF->pEEFreeCXTL)
#define EEAssignTMToTM		(*pEXF->pEEAssignTMToTM)
#define EEIsExpandable		(*pEXF->pEEIsExpandable)
#define EEAreTypesEqual 	(*pEXF->pEEAreTypesEqual)
#define EEcChildrenTM		(*pEXF->pEEcChildrenTM)
#define EEGetChildTM		(*pEXF->pEEGetChildTM)
#define EEDereferenceTM 	(*pEXF->pEEDereferenceTM)
#define EEcParamTM			(*pEXF->pEEcParamTM)
#define EEGetParmTM 		(*pEXF->pEEGetParmTM)
#define EEGetTMFromHSYM 	(*pEXF->pEEGetTMFromHSYM)
#define EEFormatAddress 	(*pEXF->pEEFormatAddress)
#define EEGetHSYMList		(*pEXF->pEEGetHSYMList)
#define EEFreeHSYMList		(*pEXF->pEEFreeHSYMList)
#define EEGetAccessFromTM  (*pEXF->pEEGetAccessFromTM)
#define EEGetExtendedTypeInfo (*pEXF->pEEGetExtendedTypeInfo)
#define EEEnableAutoClassCast (*pEXF->pEEEnableAutoClassCast)
#define EEcSynthChildTM  (*pEXF->pEEcSynthChildTM)
#define EEInvalidateCache	(*pEXF->pEEInvalidateCache)
#define EEGetBCIA			(*pEXF->pEEGetBCIA)
#define EEFreeBCIA			(*pEXF->pEEFreeBCIA)
#define EESetTarget			(*pEXF->pEESetTarget)
#define EEUnload			(*pEXF->pEEUnload)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\fcndef.h ===
typedef HWND    PWND;
typedef struct _region *PREGION;

//
//  load.c
//
void			quit (int);
//
//  process.c
//

void			set_addrs (void);
//  cv0.c
//
void    PASCAL  ESLoadExpr(int, unsigned int, LPFNEEINIT);
int 	PASCAL  ESilan (void);
int 	PASCAL  ESSetFromIndex (int);
int     PASCAL  get_initial_context (PCXT);
int 	PASCAL  line_number_address (PADDR, USHORT, char *);
void    PASCAL  go_until(PADDR, HTHD, int, BOOL);
//
//  cv1.c
//
void    PASCAL  display_pc (void);
void	PASCAL 	UpdateUserEnvir (USHORT);
void	PASCAL 	freeze_view (void);
//
//  debcom.c
//
void	PASCAL FAR compare (PADDR, long, PADDR);
//
//  utils.c
//
char *				 error_string (USHORT);
char *				 get_string (void);
int 				 eol (void);
void				 skip_white (void);
void				 skip_not_white (void);
void				 skip_to_eol (void);
void				 reset_ptxt (void);
void				 SplitPath (char *, char *, char *, char *, char *);
#ifdef OSDEBUG4
int    OSDAPI dsquit (DWORD);
#else
int    OSDAPI dsquit (unsigned);
#endif

int    LOADDS		 ds_eprintfT (const char *, char *, char *, int);
int    LOADDS		 ds_eprintf (const char  FAR *, char  FAR *, char  FAR *, int);
int    LOADDS		 ds_sprintf(char near *, const char FAR *, ...);
char * LOADDS		 ds_ultoa ( ULONG, char *, int );
char * LOADDS		 ds_itoa ( int, char *, int );
char * LOADDS		 ds_ltoa ( long, char *, int );
FLOAT10 LOADDS		 ds_strtold ( const char *, char ** );
void				 _fswap(void FAR *, void FAR *, size_t);
void				 _fqsort(void FAR *, size_t, size_t, int (*)
					 	(const void FAR *, const void FAR *));
//
//  errors.c
//
void				 fetch_error (USHORT, char  FAR *);
//
//  dispset.c
//
int 				 update_watch_window (void);
//
//	system<x>.c
//
int 				 readfar(UINT, char FAR *, UINT);

void				 dos_screen (void);
void				 island_screen (void);
void	PASCAL 	 	 DispPrompt (void);
void				 dprintf (char *, ...);
void				 dputs (char *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\globals.h ===
/*** globals.h -- global variable extern header file
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*   Revision History:
*
*   [ 6]    13-Apr-1990 ArthurC Change the reg structure
*   [ 5]    26-Mar-1990 ArthurC Abolish symbol_name
*   [ 4]    03-Apr-1989 dans	Added szCONSOLE, for space savings.
*   [ 3]    01-Apr-1989 dans	Started using C6.00 runtime support for
*								10 byte reals.	Bug 34.  Added printf formats
*								for some floating point output. (externs from
*								isledata.c).
*   [ds]    17-Mar-1989 dans	Redid expression evaluator flags.
*   [ 2]    24-Jan-1989 dans	Added extern of _fDosExt under DOSE switch.
*   [ 1]    10-Jan-1989 dans	Added pfPlayback extern from auxcow.c
*		    19-Mar-1987 brianwi Added help_topics array
*
*************************************************************************/

/* register table and friends */

extern ADDR asmaddr;

extern char *ptxt;

/* text selection */

extern char		*ptst;		    /* ptr to text selection buffer */
extern char		input_text[];
extern char		text_selected;
extern char		text_selection_inserted;
extern char		text_selection[80];

extern int radix;				// radix to use for output
extern int radixInput;			// used to be #defined, but need to change
								// on the fly

extern char		fTargetIs386;	// hpidCurr is on a 386 or higher
extern char		fTry386Mode;	// user specified Options.386 Instructions
extern char		fIn386Mode;		// always == fTargetIs386 && fTry386Mode

extern FILE *	pfPlayback;											// [ 1]

#if defined (DOSE)	// [ 2]
extern unsigned short	_fDosExt;									// [ 2]
#endif	// [ 2]

//  miscellaneous externs from isledata.c

extern CXF cxfIp;

//  defines for targeting the mac

#ifdef MAC

#define cbTargetMax 256

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\nothunk.h ===
/*** nothunk.h -- gets rid of thunks
*
*   Copyright <C> 1989, Microsoft Corporation
*
*   Purpose:
*
*   Revision History:
*
*   [xx]    30-Sep-1989 Dans	Created
*
*************************************************************************/
#if !(defined (_NOTHUNKH_))
#define _NOTHUNKH_

#define RESassemble_context		assemble_context
#define RESenter_context		enter_context
#define RESregister_context		register_context
#define ResBPDlgList			BPDlgList
#define ResBlankTextWndProc		BlankTextWndProc
#define ResBorderWndProc		BorderWndProc
#define ResButtonWndProc		ButtonWndProc
#define ResCMDFReadOnlyBuf		CWndFReadOnlyBuf
#define ResCMDGetLineAttrs		CWndGetLineAttrs
#define ResCMDInsertLineBuf		CWndInsertLineBuf
#define ResCMDLinesInBuf		CWndLinesInBuf
#define ResCMDReplaceLineBuf		CWndReplaceLineBuf
#define ResCMDcbGetLineBuf		CWndcbGetLineBuf
#define ResDialogFilterProc		DialogFilterProc
#define ResDialogWndProc		DialogWndProc
#define ResDlgListDelWatch		DlgListDelWatch
#define ResFDlgOpen				FDlgOpen
#define ResDummyFilter			DummyFilter
#define ResFDlgBPAdd			FDlgBPAdd
#define ResFDlgBPList			FDlgBPList
#define ResBPDlgRList			BPDlgRList
#define ResFDlgBPResolve		FDlgBPResolve
#define ResFDlgDelWatch 		FDlgDelWatch
#define ResFDlgFind			FDlgFind
#define ResFDlgHOvrW			FDlgHOvrW
#define ResFDlgHelp			FDlgHelp
#define ResFDlgLang			FDlgLang
#define ResFDlgModules			FDlgModules
#define ResFDlgPrint			FDlgPrint
#define ResFDlgQckWatch 		FDlgQckWatch
#define ResFDlgDebuggee		FDlgDebuggee
#define ResFDlgRun              FDlgRun
#define ResFDlgSource			FDlgSource
#define ResFDlgSysIsa		FDlgSysIsa
#define ResFDlgTrunc			FDlgTrunc
#define ResFDlghistopt			FDlghistopt
#define ResGeneralWndProc		GeneralWndProc
#define ResHLPGetLineAttrs		hlpGetLineAttrs
#define ResHLPLinesInBuf		hlpLinesInBuf
#define ResHLPcbGetLineBuf		hlpcbGetLineBuf
#define ResHelpTextWndProc		HelpTextWndProc
#define ResMWTypeList			MWTypeList
#define ResLCLFDlgLocalOptions  LCLFDlgLocalOptions
#define ResWATGetLineAttrs		WATGetLineAttrs
#define ResLOCFReadOnlyBuf		LTFReadOnlyBuf
#define ResLOCFReplaceLineBuf		LTReplaceLineBuf
#define ResLOCGetLineAttrs		LTGetLineAttrs
#define ResLOCLinesInBuf		LTLinesInBuf
#define ResLOCcbGetLineBuf		LTcbGetLineBuf
#define ResListBoxWndProc		ListBoxWndProc
#define ResMboxWndProc			MboxWndProc
#define ResMenuFilterProc		MenuFilterProc
#define ResModulesDlgList		ModulesDlgList
#define ResSourcesDlgList       SourcesDlgList
#define ResMWCbGetLineBuf		MWCbGetLineBuf
#define ResMWCLinesInBuf		MWCLinesInBuf
#define ResMWGetLineAttrs		MWGetLineAttrs
#define ResMWFDlgMwEdit			MWFDlgMwEdit
#define ResMWFDlgMwOption       MWFDlgMwOption
#define ResMWTypeListProc		MWTypeListProc
#define ResParentKeyResizeWndProc	ParentKeyResizeWndProc
#define ResParentMouResizeWndProc	ParentMouResizeWndProc
#define ResParentWndProc		ParentWndProc
#define ResQckWatchListProc		QckWatchListProc
#define ResR87GetLineAttrs		reg87GetLineAttrs
#define ResR87LinesInBuf		reg87LinesInBuf
#define ResR87cbGetLineBuf		reg87cbGetLineBuf
#define ResREGGetLineAttrs		regGetLineAttrs
#define ResREGLinesInBuf		regLinesInBuf
#define ResREGcbGetLineBuf		regcbGetLineBuf
#define ResResizeTextWndProc		ResizeTextWndProc
#define ResSRCGetLineAttrs		SWGetLineAttrs
#define ResSRCLinesInBuf		SWLinesInBuf
#define ResSRCcbGetLineBuf		SWcbGetLineBuf
#define ResScrollBarWndProc		ScrollBarWndProc
#define ResSdmDialogProc		SdmDialogProc
#define ResStaticWndProc		StaticWndProc
#define ResStatusWndProc		StatusWndProc
#define ResTextWndProc			TextWndProc

#ifdef OSDEBUG
#define ResCNFKillNode          CNFKillNode
#define ResCNFWMultiListProc	  CNFWMultiListProc
#define ResCNFWSingleListProc	  CNFWSingleListProc
#define ResCNFWMultiDllListProc CNFWMultiDllListProc
#define ResCNFFDlgConfig        CNFFDlgConfig
#define ResCNFFDlgSingle        CNFFDlgSingle
#define ResCNFFDlgMulti         CNFFDlgMulti
#endif	// OSDEBUG

#endif	// _NOTHUNKH_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\linklist.h ===
#ifndef _LINKLIST_
#define _LINKLIST_

#if !(defined (OSDEBUG4))
//
//	Return values from lpfnCmpNode functions
//
#define	fCmpLT		-1
#define	fCmpEQ		0
#define	fCmpGT		1
//
// Magical linklist types
//
#define	HLLI	HMEM
#define	HLLE	HMEM
//
//	Prototypes for callbacks
//
typedef void	(FAR PASCAL * LPFNKILLNODE)( LPV );
typedef int		(FAR PASCAL * LPFNFCMPNODE)( LPV, LPV, LONG );
//
// List flags
typedef WORD	LLF;
#define	llfNull				(LLF)0x0
#define	llfAscending		(LLF)0x1
#define	llfDescending		(LLF)0x2
#endif	// OSDEBUG4
//
//
// -- Here's the APIs
//
extern	HLLI	PASCAL	LLHlliInit( UINT, LLF, LPFNKILLNODE, LPFNFCMPNODE );
extern	HLLE	PASCAL	LLHlleCreate( HLLI );
extern	void	PASCAL	LLAcquire( HLLI );
extern	void	PASCAL	LLRelease( HLLI );
extern	void	PASCAL	LLAddHlleToLl( HLLI, HLLE );
extern	void	PASCAL	LLInsertHlleInLl( HLLI, HLLE, DWORD );
extern	BOOL	PASCAL	LLFDeleteHlleIndexed( HLLI, DWORD );
extern	BOOL	PASCAL	LLFDeleteLpvFromLl( HLLI, HLLE, LPV, DWORD );
extern	BOOL	PASCAL	LLFDeleteHlleFromLl( HLLI, HLLE );
extern	HLLE	PASCAL	LLHlleFindNext( HLLI, HLLE );

#ifndef BMHANDLES
#define LLHlleFindNextFast(hlli, hlle) \
	(HLLE)((hlle) ? \
	       ((LPLLE)(hlle))->hlleNext : \
			LLHlleFindNext(hlli, hlle))
#else
#define LLHlleFindNextFast(HLLI, HLLE) LLHlleFindNext(HLLI, HLLE)
#endif

#ifdef DBLLINK
extern	HLLE	PASCAL	LLHlleFindPrev( HLLI, HLLE );
#endif	// DBLLINK
extern	DWORD	PASCAL	LLChlleDestroyLl( HLLI );
extern	HLLE	PASCAL	LLHlleFindLpv( HLLI, HLLE, LPV, DWORD );
extern	DWORD	PASCAL	LLChlleInLl( HLLI );
extern	LPV		PASCAL	LLLpvFromHlle( HLLE );
extern  HLLE    PASCAL  LLHlleGetLast( HLLI );
extern	void	PASCAL	LLHlleAddToHeadOfLI( HLLI, HLLE );
extern	BOOL	PASCAL	LLFRemoveHlleFromLl( HLLI, HLLE );

//
// FCheckHlli is for debug versions ONLY as an integrity check
//
#ifdef _DEBUG
extern	BOOL  PASCAL  LLFCheckHlli( HLLI );
#else	// _DEBUG
#define LLFCheckHlli(hlli)	1
#endif	// _DEBUG
//
// Map memory manager to our source versions
//
#ifdef CODEVIEW
    #define AllocHmem(cb)   BMAlloc(cb) // _fmalloc(cb)
    #define FreeHmem(h)     BMFree(h)          // _ffree(h)
    #define LockHmem(h)     BMLock(h)          // (h)
    #define UnlockHmem(h)   BMUnlock(h)          //
#else	// !CODEVIEW
	HMEM		LOADDS PASCAL MHMemAllocate(unsigned int);
	void		LOADDS PASCAL MHMemFree(HMEM);
	void FAR*	LOADDS PASCAL MHMemLock(HMEM);
	void		LOADDS PASCAL MHMemUnLock(HMEM);
	#define AllocHmem(cb)	MHMemAllocate(cb)
	#define FreeHmem(h)		MHMemFree(h)
	#define LockHmem(h)		MHMemLock(h)
	#define UnlockHmem(h)	MHMemUnLock(h)
#endif	// !CODEVIEW
//
//	This helps the codes appearance!
//
#define	UnlockHlle(hlle)	UnlockHmem(hlle)
#define	UnlockHlli(hlli)	UnlockHmem(hlli)

#ifndef hlleNull
#define hlleNull	(HLLE)NULL
#endif	// !hlleNull

#endif	// _LINKLIST_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\newexe.h ===
/* SCCSID = @(#)newexe.h	4.6 86/09/10 */
/*
 *  Title
 *
 *	newexe.h
 *	Pete Stewart
 *	(C) Copyright Microsoft Corp 1984-1987
 *	17 August 1984
 *
 *  Description
 *
 *	Data structure definitions for the DOS 4.0/Windows 2.0
 *	executable file format.
 *
 *  Modification History
 *
 *	84/08/17	Pete Stewart	Initial version
 *	84/10/17	Pete Stewart	Changed some constants to match OMF
 *	84/10/23	Pete Stewart	Updates to match .EXE format revision
 *	84/11/20	Pete Stewart	Substantial .EXE format revision
 *	85/01/09	Pete Stewart	Added constants ENEWEXE and ENEWHDR
 *	85/01/10	Steve Wood	Added resource definitions
 *	85/03/04	Vic Heller	Reconciled Windows and DOS 4.0 versions
 *	85/03/07	Pete Stewart	Added movable entry count
 *	85/04/01	Pete Stewart	Segment alignment field, error bit
 *	85/10/03	Reuben Borman	Removed segment discard priority
 *	85/10/11	Vic Heller	Added PIF header fields
 *	86/03/10	Reuben Borman	Changes for DOS 5.0
 *	86/09/02	Reuben Borman	NSPURE ==> NSSHARED
 *	87/05/04	Reuben Borman	Added ne_cres and NSCONFORM
 *	87/07/08	Reuben Borman	Added NEAPPTYPE definitions
 *	87/10/28	Wieslaw Kalkus	Added ne_exetyp
 *	89/03/23	Wieslaw Kalkus	Added ne_flagsothers for OS/2 1.2
 */



    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |	DOS3 .EXE FILE HEADER DEFINITION			       |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

#define EMAGIC		0x5A4D		/* Old magic number */
#define ENEWEXE 	sizeof(struct exe_hdr)
					/* Value of E_LFARLC for new .EXEs */
#define ENEWHDR 	0x003C		/* Offset in old hdr. of ptr. to new */
#define ERESWDS 	0x000d		/* No. of reserved words (OLD) */
#define ERES2WDS	0x000A		/* No. of reserved words in e_res2 */
#define ECP		0x0004		/* Offset in struct of E_CP */
#define ECBLP		0x0002		/* Offset in struct of E_CBLP */
#define EMINALLOC	0x000A		/* Offset in struct of E_MINALLOC */
#define EKNOWEAS	0x0001		/* e_flags - program understands EAs */
#define EDOSEXTENDED	0x0002		/* e_flags - program runs under DOS extender */
#define EPCODE          0x0004          /* e_flags - memory image constructed from PCODE */

struct exe_hdr				/* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned long       e_sym_tab;      /* offset of symbol table file */
    unsigned short      e_flags;        /* old exe header flags  */
    unsigned short      e_res;          /* Reserved words */
    unsigned short      e_oemid;        /* OEM identifier (for e_oeminfo) */
    unsigned short      e_oeminfo;      /* OEM information; e_oemid specific */
    unsigned short      e_res2[ERES2WDS];/* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_SYM_TAB(x)	(x).e_sym_tab
#define E_FLAGS(x)	(x).e_flags
#define E_RES(x)        (x).e_res
#define E_OEMID(x)      (x).e_oemid
#define E_OEMINFO(x)    (x).e_oeminfo
#define E_RES2(x)       (x).e_res2
#define E_LFANEW(x)     (x).e_lfanew


    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |	OS/2 & WINDOWS .EXE FILE HEADER DEFINITION - 286 version       |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

#define NEMAGIC 	0x454E		/* New magic number */
#define NERESBYTES	0		/* No bytes reserved after Windows 3.0 changes */
#define NECRC		8		/* Offset into new header of NE_CRC */

struct new_exe				/* New .EXE header */
  {
    unsigned short	ne_magic;	/* Magic number NE_MAGIC */
    unsigned char	ne_ver; 	/* Version number */
    unsigned char	ne_rev; 	/* Revision number */
    unsigned short	ne_enttab;	/* Offset of Entry Table */
    unsigned short	ne_cbenttab;	/* Number of bytes in Entry Table */
    long		ne_crc; 	/* Checksum of whole file */
    unsigned short	ne_flags;	/* Flag word */
    unsigned short	ne_autodata;	/* Automatic data segment number */
    unsigned short	ne_heap;	/* Initial heap allocation */
    unsigned short	ne_stack;	/* Initial stack allocation */
    long		ne_csip;	/* Initial CS:IP setting */
    long		ne_sssp;	/* Initial SS:SP setting */
    unsigned short	ne_cseg;	/* Count of file segments */
    unsigned short	ne_cmod;	/* Entries in Module Reference Table */
    unsigned short	ne_cbnrestab;	/* Size of non-resident name table */
    unsigned short	ne_segtab;	/* Offset of Segment Table */
    unsigned short	ne_rsrctab;	/* Offset of Resource Table */
    unsigned short	ne_restab;	/* Offset of resident name table */
    unsigned short	ne_modtab;	/* Offset of Module Reference Table */
    unsigned short	ne_imptab;	/* Offset of Imported Names Table */
    long		ne_nrestab;	/* Offset of Non-resident Names Table */
    unsigned short	ne_cmovent;	/* Count of movable entries */
    unsigned short	ne_align;	/* Segment alignment shift count */
    unsigned short	ne_cres;	/* Count of resource entries */
    unsigned char	ne_exetyp;	/* Target operating system */
    unsigned char	ne_flagsothers; /* Other .EXE flags */
    unsigned short	ne_pretthunks;	/* Windows 3.0 - offset to return thunks */
    unsigned short	ne_psegrefbytes;/* Windows 3.0 - offset to segment ref. bytes */
    unsigned short	ne_swaparea;	/* Windows 3.0 - minimum code swap size */
    unsigned short	ne_expver;	/* Windows 3.0 - expected windows version number */
  };

#define NE_MAGIC(x)	    (x).ne_magic
#define NE_VER(x)	    (x).ne_ver
#define NE_REV(x)	    (x).ne_rev
#define NE_ENTTAB(x)	    (x).ne_enttab
#define NE_CBENTTAB(x)	    (x).ne_cbenttab
#define NE_CRC(x)	    (x).ne_crc
#define NE_FLAGS(x)	    (x).ne_flags
#define NE_AUTODATA(x)	    (x).ne_autodata
#define NE_HEAP(x)	    (x).ne_heap
#define NE_STACK(x)	    (x).ne_stack
#define NE_CSIP(x)	    (x).ne_csip
#define NE_SSSP(x)	    (x).ne_sssp
#define NE_CSEG(x)	    (x).ne_cseg
#define NE_CMOD(x)	    (x).ne_cmod
#define NE_CBNRESTAB(x)     (x).ne_cbnrestab
#define NE_SEGTAB(x)	    (x).ne_segtab
#define NE_RSRCTAB(x)	    (x).ne_rsrctab
#define NE_RESTAB(x)	    (x).ne_restab
#define NE_MODTAB(x)	    (x).ne_modtab
#define NE_IMPTAB(x)	    (x).ne_imptab
#define NE_NRESTAB(x)	    (x).ne_nrestab
#define NE_CMOVENT(x)	    (x).ne_cmovent
#define NE_ALIGN(x)	    (x).ne_align
#define NE_CRES(x)	    (x).ne_cres
#define NE_RES(x)	    (x).ne_res
#define NE_EXETYP(x)	    (x).ne_exetyp
#define NE_FLAGSOTHERS(x)   (x).ne_flagsothers
#define NE_PRETTHUNKS(x)    (x).ne_pretthunks
#define NE_PSEGREFBYTES(x)  (x).ne_psegrefbytes
#define NE_SWAPAREA(x)	    (x).ne_swaparea
#define NE_EXPVER(x)	    (x).ne_expver


#define NE_USAGE(x)	(WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)	(WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)	(WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)


/*
 *  Target operating systems
 */

#define NE_UNKNOWN	0x0		/* Unknown (any "new-format" OS) */
#define NE_OS2		0x1		/* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS	0x2		/* Microsoft Windows */
#define NE_DOS		0x3		/* Microsoft MS-DOS */
#define NE_DEV386       0x4             /* Microsoft Windows 386 */

/*
 *  Format of NE_FLAGS(x):
 *
 *  p					Not-a-process
 *   x					Unused
 *    e 				Errors in image
 *     x				Unused
 *	b				Bound Family/API
 *       ttt				Application type
 *	    f				Floating-point instructions
 *	     3				386 instructions
 *	      2 			286 instructions
 *	       0			8086 instructions
 *		P			Protected mode only
 *		 p			Per-process library initialization
 *		  i			Instance data
 *		   s			Solo data
 */
#define NENOTP		0x8000		/* Not a process */
#define NEPRIVLIB	0x4000		/* A one customer Windows 3.0 library */
#define NEIERR		0x2000		/* Errors in image */
#define NEBOUND 	0x0800		/* Bound Family/API */
#define NEAPPLOADER	0x0800		/* Aplication specific loader - valid only for Windows */
#define NEAPPTYP	0x0700		/* Application type mask */
#define NENOTWINCOMPAT	0x0100		/* Not compatible with P.M. Windowing */
#define NEWINCOMPAT	0x0200		/* Compatible with P.M. Windowing */
#define NEWINAPI	0x0300		/* Uses P.M. Windowing API */
#define NEFLTP		0x0080		/* Floating-point instructions */
#define NEI386		0x0040		/* 386 instructions */
#define NEI286		0x0020		/* 286 instructions */
#define NEI086		0x0010		/* 8086 instructions */
#define NEPROT		0x0008		/* Runs in protected mode only */
#define NEPPLI		0x0004		/* Per-Process Library Initialization */
#define NEINST		0x0002		/* Instance data */
#define NESOLO		0x0001		/* Solo data */

/*
 *  Format of NE_FLAGSOTHERS(x):
 *
 *      7 6 5 4 3 2 1 0  - bit no
 *		| | | |
 *		| | | +---------------- Support for EAs and Long filenames
 *		| | +------------------ Reserved for Win30
 *		| +-------------------- Reserved for Win30
 *		+---------------------- Reserved for Win30
 */

#define NENEWFILES	0x01		/* os/2 app understands eas and longnames */
#define NEINFONT	0x02		/* 2.x app gets proportional font */
#define NEINPROT	0x04		/* 2.x app runs in 3.x prot mode  */
#define NEGANGLOAD	0x08		/* Reserved for Win 3.0 */

struct new_seg				/* New .EXE segment table entry */
  {
    unsigned short	ns_sector;	/* File sector of start of segment */
    unsigned short	ns_cbseg;	/* Number of bytes in file */
    unsigned short	ns_flags;	/* Attribute flags */
    unsigned short	ns_minalloc;	/* Minimum allocation in bytes */
  };

#define NS_SECTOR(x)	(x).ns_sector
#define NS_CBSEG(x)	(x).ns_cbseg
#define NS_FLAGS(x)	(x).ns_flags
#define NS_MINALLOC(x)	(x).ns_minalloc


/*
 *  Format of NS_FLAGS(x)
 *
 *  Flag word has the following format:
 *
 *	15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0  - bit no
 *	    |  |  |  |	| | | | | | | | | | |
 *	    |  |  |  |	| | | | | | | | +-+-+--- Segment type DATA/CODE
 *	    |  |  |  |	| | | | | | | +--------- Iterated segment
 *	    |  |  |  |	| | | | | | +----------- Movable segment
 *	    |  |  |  |	| | | | | +------------- Segment can be shared
 *	    |  |  |  |	| | | | +--------------- Preload segment
 *	    |  |  |  |	| | | +----------------- Execute/read-only for code/data segment
 *	    |  |  |  |	| | +------------------- Segment has relocations
 *	    |  |  |  |	| +--------------------- Code conforming/Data is expand down
 *	    |  |  |  +--+----------------------- I/O privilege level
 *	    |  |  +----------------------------- Discardable segment
 *	    |  +-------------------------------- 32-bit code segment
 *	    +----------------------------------- Huge segment/GDT allocation requested
 *
 */

#define NSTYPE		0x0007		/* Segment type mask */

#if !EXE386
#define NSCODE		0x0000		/* Code segment */
#define NSDATA		0x0001		/* Data segment */
#define NSITER		0x0008		/* Iterated segment flag */
#define NSMOVE		0x0010		/* Movable segment flag */
#define NSSHARED	0x0020		/* Shared segment flag */
#define NSPRELOAD	0x0040		/* Preload segment flag */
#define NSEXRD		0x0080		/* Execute-only (code segment), or
					*  read-only (data segment)
					*/
#define NSRELOC 	0x0100		/* Segment has relocations */
#define NSCONFORM	0x0200		/* Conforming segment */
#define NSEXPDOWN	0x0200		/* Data segment is expand down */
#define NSDPL		0x0C00		/* I/O privilege level (286 DPL bits) */
#define SHIFTDPL	10		/* Left shift count for SEGDPL field */
#define NSDISCARD	0x1000		/* Segment is discardable */
#define NS32BIT 	0x2000		/* 32-bit code segment */
#define NSHUGE		0x4000		/* Huge memory segment, length of
					 * segment and minimum allocation
					 * size are in segment sector units
					 */
#define NSGDT		0x8000		/* GDT allocation requested */

#define NSPURE		NSSHARED	/* For compatibility */

#define NSALIGN 9	/* Segment data aligned on 512 byte boundaries */

#define NSLOADED    0x0004	/* ns_sector field contains memory addr */
#endif


struct new_segdata			/* Segment data */
  {
    union
      {
	struct
	  {
	    unsigned short	ns_niter;	/* number of iterations */
	    unsigned short	ns_nbytes;	/* number of bytes */
	    char		ns_iterdata;	/* iterated data bytes */
	  } ns_iter;
	struct
	  {
	    char		ns_data;	/* data bytes */
	  } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo			/* Relocation info */
  {
    unsigned short	nr_nreloc;	/* number of relocation items that */
  };					/* follow */

#pragma pack(1)


struct new_rlc				/* Relocation item */
  {
    char		nr_stype;	/* Source type */
    char		nr_flags;	/* Flag byte */
    unsigned short	nr_soff;	/* Source offset */
    union
      {
	struct
	  {
	    char	nr_segno;	/* Target segment number */
	    char	nr_res; 	/* Reserved */
	    unsigned short nr_entry;	/* Target Entry Table offset */
	  }		nr_intref;	/* Internal reference */
	struct
	  {
	    unsigned short nr_mod;	/* Index into Module Reference Table */
	    unsigned short nr_proc;	/* Procedure ordinal or name offset */
	  }		nr_import;	/* Import */
	struct
	  {
	    unsigned short nr_ostype;	/* OSFIXUP type */
	    unsigned short nr_osres;	/* reserved */
	  }		nr_osfix;	/* Operating system fixup */
      } 		nr_union;	/* Union */
  };

#pragma pack()


#define NR_STYPE(x)	(x).nr_stype
#define NR_FLAGS(x)	(x).nr_flags
#define NR_SOFF(x)	(x).nr_soff
#define NR_SEGNO(x)	(x).nr_union.nr_intref.nr_segno
#define NR_RES(x)	(x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)	(x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)	(x).nr_union.nr_import.nr_mod
#define NR_PROC(x)	(x).nr_union.nr_import.nr_proc
#define NR_OSTYPE(x)	(x).nr_union.nr_osfix.nr_ostype
#define NR_OSRES(x)	(x).nr_union.nr_osfix.nr_osres



/*
 *  Format of NR_STYPE(x) and R32_STYPE(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *		 | | | |
 *		 +-+-+-+--- source type
 *
 */

#define NRSTYP		0x0f		/* Source type mask */
#define NRSBYT		0x00		/* lo byte (8-bits)*/
#define NRSSEG		0x02		/* 16-bit segment (16-bits) */
#define NRSPTR		0x03		/* 16:16 pointer (32-bits) */
#define NRSOFF		0x05		/* 16-bit offset (16-bits) */
#define NRPTR48 	0x06		/* 16:32 pointer (48-bits) */
#define NROFF32 	0x07		/* 32-bit offset (32-bits) */
#define NRSOFF32	0x08		/* 32-bit self-relative offset (32-bits) */


/*
 *  Format of NR_FLAGS(x) and R32_FLAGS(x):
 *
 *	 7 6 5 4 3 2 1 0  - bit no
 *		   | | |
 *		   | +-+--- Reference type
 *		   +------- Additive fixup
 */

#define NRADD		0x04		/* Additive fixup */
#define NRRTYP		0x03		/* Reference type mask */
#define NRRINT		0x00		/* Internal reference */
#define NRRORD		0x01		/* Import by ordinal */
#define NRRNAM		0x02		/* Import by name */
#define NRROSF		0x03		/* Operating system fixup */


#if NOT

/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;	    /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are	      */
    unsigned short rn_offset;	/* file offset to resource data */
    unsigned short rn_length;	/* length of resource data */
    unsigned short rn_flags;	/* resource flags */
    unsigned short rn_id;	/* resource name id */
    unsigned short rn_handle;	/* If loaded, then global handle */
    unsigned short rn_usage;	/* Initially zero.  Number of times */
				/* the handle for this resource has */
				/* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000	/* if high bit of ID set then integer id */
				/* otherwise ID is offset of string from
				   the beginning of the resource table */

				/* Ideally these are the same as the */
				/* corresponding segment flags */
#define RNMOVE	    0x0010	/* Moveable resource */
#define RNPURE	    0x0020	/* Pure (read-only) resource */
#define RNPRELOAD   0x0040	/* Preloaded resource */
#define RNDISCARD   0xF000	/* Discard priority level for resource */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;	/* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align


#endif	/* NOT EXE386 */

    /*_________________________________________________________________*
     |                                                                 |
     |                                                                 |
     |	JAVA .CLASS FILE HEADER DEFINITION						       |
     |                                                                 |
     |_________________________________________________________________|
     *                                                                 */

#define JAVA_MAGIC		0xbebafeca		// Java magic number (0xcafebabe)

struct JAVA_CLASS_HEADER				// Java class header
{
    unsigned long		magic;			// Magic number
    unsigned short      minor_version;	// Minor version number
    unsigned short      major_version;	// Major version number
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\od4.h ===
#if !(defined (__OD4__))
#if defined (__cplusplus)
extern "C" {
#if !(defined (INLINE))
#define INLINE inline
#endif
#else
#if !(defined (INLINE))
#define INLINE __inline
#endif
#endif

#define __OD4__

#if !(defined (DECLARE_HANDLE))
#define DECLARE_HANDLE(name) typedef void* name
#define DECLARE_HANDLE32(name) DECLARE_HANDLE(name)
#endif
// INCLUDE should be set to load first from Osdebug4 inc then langapi

#include <od.h>

typedef LPADDR PADDR;
typedef HDEP HMEM;

#undef CEXM_MDL_native

typedef struct _CBP {
    DWORD wMessage;
    HPID hpid;
    HTID htid;
    LPARAM dwParam;
    LPARAM lParam;
} CBP;            // CallBack Parameters.  Not used by OSDebug itself,
               // but possibly handy for the debugger.
typedef CBP FAR *LPCBP;


#define hmemNull 0
#define hpidNull 0
#define htidNull 0
#define htlNull  0
#define hemNull  0

#define wNull 0
#define lNull 0L

#if defined (__cplusplus)
}
#endif

#endif  // __OD4__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\shproto.h ===
//  **********************************************************************
//  *                                                                    *
//  *   API callback function proto types                                *
//  *                                                                    *
//  **********************************************************************

#ifndef dcvotxs

extern SHF FAR * lpshf;

#define SHCreateProcess     (*lpshf->pSHCreateProcess)
#define SHSetHpid           (*lpshf->pSHSetHpid)
#define SHDeleteProcess     (*lpshf->pSHDeleteProcess)
#define SHChangeProcess     (*lpshf->pSHChangeProcess)
#define SHGetDebugStart     (*lpshf->pSHGetDebugStart)
#define SHGetSymName        (*lpshf->pSHGetSymName)
#define SHAddrFromHsym      (*lpshf->pSHAddrFromHsym)
#define SHHModGetNextGlobal (*lpshf->pSHHModGetNextGlobal)
#define SHModHasSrc         (*lpshf->pSHModHasSrc)
#define SHModelFromAddr     (*lpshf->pSHModelFromAddr)
#define SHPublicNameToAddr  (*lpshf->pSHPublicNameToAddr)
#define SHGetSymbol         (*lpshf->pSHGetSymbol)
#define SHGetPublicAddr     (*lpshf->pSHGetPublicAddr)
#define SHAddDll            (*lpshf->pSHAddDll)
#define SHIsLabel           (*lpshf->pSHIsLabel)
#define SHSetDebuggeeDir    (*lpshf->pSHSetDebuggeeDir)
#define SHUnloadDll         (*lpshf->pSHUnloadDll)
#define SHLoadDll           (*lpshf->pSHLoadDll)
#define SHGetSymLoc         (*lpshf->pSHGetSymLoc)
#define SHFIsAddrNonVirtual (*lpshf->pSHFIsAddrNonVirtual)
#define SHIsFarProc         (*lpshf->pSHIsFarProc)
#define SHAddDllsToProcess  (*lpshf->pSHAddDllsToProcess)

#define SHSetDebuggeeDir    (*lpshf->pSHSetDebuggeeDir)
#define SHSetUserDir        (*lpshf->pSHSetUserDir)
#define SHGetSourceName     (*lpshf->pSHGetSourceName)
#define SHAddrToLabel       (*lpshf->pSHAddrToLabel)

#define SHGetNextExe        (*lpshf->pSHGetNextExe)
#define SHHexeFromHmod      (*lpshf->pSHHexeFromHmod)
#define SHGetNextMod        (*lpshf->pSHGetNextMod)
#define SHGetCxtFromHmod    (*lpshf->pSHGetCxtFromHmod)
#define SHSetCxt            (*lpshf->pSHSetCxt)
#define SHSetCxtMod         (*lpshf->pSHSetCxtMod)
#define SHFindNameInGlobal  (*lpshf->pSHFindNameInGlobal)
#define SHFindNameInContext (*lpshf->pSHFindNameInContext)
#define SHGoToParent        (*lpshf->pSHGoToParent)
#define SHHsymFromPcxt      (*lpshf->pSHHsymFromPcxt)
#define SHNextHsym          (*lpshf->pSHNextHsym)
#define SHGetFuncCxf        (*lpshf->pSHGetFuncCxf)
#define SHGetModName        (*lpshf->pSHGetModName)
#define SHGetFileName       (*lpshf->pSHGetFileName)
#define SHGetExeName        (*lpshf->pSHGetExeName)
#define SHGethExeFromName   (*lpshf->pSHGethExeFromName)
#define SHGetNearestHsym    (*lpshf->pSHGetNearestHsym)
#define SHIsInProlog        (*lpshf->pSHIsInProlog)
#define SHIsAddrInCxt       (*lpshf->pSHIsAddrInCxt)
#define PHGetNearestHsym    (*lpshf->pPHGetNearestHsym)
#define PHFindNameInPublics (*lpshf->pPHFindNameInPublics)
#define THGetTypeFromIndex  (*lpshf->pTHGetTypeFromIndex)
#define THGetNextType       (*lpshf->pTHGetNextType)
#define SHLpGSNGetTable     (*lpshf->pSHLpGSNGetTable)
#define SHFindSymbol        (*lpshf->pSHFindSymbol)
#define SHCanDisplay        (*lpshf->pSHCanDisplay)

#define SLLineFromAddr      (*lpshf->pSLLineFromAddr)
#define SLFLineToAddr       (*lpshf->pSLFLineToAddr)
#define SLNameFromHsf       (*lpshf->pSLNameFromHsf)
#define SLNameFromHmod      (*lpshf->pSLNameFromHmod)
#define SLFQueryModSrc      (*lpshf->pSLFQueryModSrc)
#define SLHmodFromHsf       (*lpshf->pSLHmodFromHsf)
#define SLHsfFromPcxt       (*lpshf->pSLHsfFromPcxt)
#define SLHsfFromFile       (*lpshf->pSLHsfFromFile)
#define SLCAddrFromLine		(*lpshf->pSLCAddrFromLine)
#define SHFree				(*lpshf->pSHFree)
#define SHUnloadSymbolHandler (*lpshf->pSHUnloadSymbolHandler)
#define SHPdbNameFromExe	(*lpshf->pSHPdbNameFromExe)
#define SHIsDllLoaded		(*lpshf->pSHIsDllLoaded)

#define SHGetExeTimeStamp	(*lpshf->pSHGetExeTimeStamp)
#define SHIsThunk           (*lpshf->pSHIsThunk)

#define SHFindSymInExe		(*lpshf->pSHFindSymInExe)

#define SHGetSrcPath        (*lpshf->pSHGetSrcPath)
#define SHGetObjPath        (*lpshf->pSHGetObjPath)
#define SHGetCompileEnv		(*lpshf->pSHGetCompileEnv)
#define SHModSupportsEC     (*lpshf->pSHModSupportsEC)
#define SHExeSupportsEC     (*lpshf->pSHExeSupportsEC)
#define SHModLinkedFromLib  (*lpshf->pSHModLinkedFromLib)

#define SHModFromHmod		(*lpshf->pSHModFromHmod)
#define SHFlushModSyms		(*lpshf->pSHFlushModSyms)
#define SHUseAltPdb			(*lpshf->pSHUseAltPdb)

#else

#define SHGetPublicAddr PHGetAddr

BOOL    LOADDS PASCAL SHCreateProcess       ( VOID );
VOID    LOADDS PASCAL SHSetHpid             ( WORD );
BOOL    LOADDS PASCAL SHDeleteProcess       ( WORD );
VOID    LOADDS PASCAL SHChangeProcess       ( WORD );
BOOL    LOADDS PASCAL SHAddDll              ( LSZ, BOOL );
BOOL    LOADDS PASCAL SHAddDllsToProcess    ( VOID );
SHE     LOADDS PASCAL SHLoadDll             ( LSZ, BOOL );
VOID    LOADDS PASCAL SHUnloadDll           ( HEXE );
UOFFSET LOADDS PASCAL SHGetDebugStart       ( HSYM );
LSZ     LOADDS PASCAL SHGetSymName          ( HSYM, LSZ );
VOID    LOADDS PASCAL SHAddrFromHsym        ( PADDR, HSYM );
HMOD    LOADDS PASCAL SHHModGetNextGlobal   ( HEXE FAR *, HMOD );
int     LOADDS PASCAL SHModelFromAddr       ( PADDR, LPW, UOFFSET FAR * );
int     LOADDS PASCAL SHPublicNameToAddr    ( PADDR, PADDR, LSZ );
LSZ     LOADDS PASCAL SHGetSymbol           ( PADDR, UINT, PADDR, LSZ, LPL );
BOOL    LOADDS PASCAL SHGetPublicAddr       ( PADDR, LSZ );
BOOL    LOADDS PASCAL SHIsLabel             ( HSYM );

VOID    LOADDS PASCAL SHSetDebuggeeDir      ( LSZ );
VOID    LOADDS PASCAL SHSetUserDir          ( LSZ );
BOOL    LOADDS PASCAL SHAddrToLabel         ( PADDR, LSZ );

short   LOADDS PASCAL SHGetSymLoc           ( LPB, LSZ, WORD, PCXT);
BOOL    LOADDS PASCAL SHFIsAddrNonVirtual	( PADDR );
BOOL    LOADDS PASCAL SHIsFarProc           ( LPB );

HEXE    LOADDS PASCAL SHGetNextExe          ( HEXE );
HEXE    LOADDS PASCAL SHHexeFromHmod        ( HMOD );
HMOD    LOADDS PASCAL SHGetNextMod          ( HEXE, HMOD );
PCXT    LOADDS PASCAL SHGetCxtFromHmod      ( HMOD, PCXT );


PCXT    LOADDS PASCAL SHSetCxt              ( PADDR, PCXT );
PCXT    LOADDS PASCAL SHSetCxtMod           ( PADDR, PCXT );
HSYM    LOADDS PASCAL SHFindNameInGlobal    ( HSYM,
                                              PCXT,
                                              HVOID,
                                              SHFLAG,
                                              PFNCMP,
                                              SHFLAG,
                                              PCXT
                                            );
HSYM    LOADDS PASCAL SHFindNameInContext   ( HSYM,
                                              PCXT,
                                              HVOID,
                                              SHFLAG,
                                              PFNCMP,
                                              SHFLAG,
                                              PCXT
                                            );
HSYM    LOADDS PASCAL SHGoToParent          ( PCXT, PCXT );
HSYM    LOADDS PASCAL SHHsymFromPcxt        ( PCXT );
HSYM    LOADDS PASCAL SHNextHsym            ( HMOD, HSYM );
PCXF    LOADDS PASCAL SHGetFuncCxf          ( PADDR, PCXF );
LPCH    LOADDS PASCAL SHGetModName          ( HMOD );
LPCH    LOADDS PASCAL SHGetExeName          ( HEXE );
HEXE    LOADDS PASCAL SHGethExeFromName     ( LPCH );
ULONG   LOADDS PASCAL SHGetNearestHsym      ( PADDR, HMOD, short, PHSYM );
SHFLAG  LOADDS PASCAL SHIsInProlog          ( PCXT );
SHFLAG  LOADDS PASCAL SHIsAddrInCxt         ( PCXT, PADDR );
SHFLAG  LOADDS PASCAL SHCompareRE           ( LPCH, LPCH );
ULONG   LOADDS PASCAL PHGetNearestHsym      ( PADDR, HEXE, PHSYM );
HSYM    LOADDS PASCAL PHFindNameInPublics   ( HSYM,
                                              HEXE,
                                              HVOID,
                                              SHFLAG,
                                              PFNCMP
                                            );
HTYPE   LOADDS PASCAL THGetTypeFromIndex    ( HMOD, THIDX );
HTYPE   LOADDS PASCAL THGetNextType         ( HMOD, HTYPE );


LPV     LOADDS PASCAL SHLpGSNGetTable       ( HEXE );
BOOL    LOADDS PASCAL SHCanDisplay ( HSYM );

// Source Line Handler

BOOL           LOADDS PASCAL SLLineFromAddr ( PADDR, LPW, SHOFF FAR *, SHOFF FAR * );
BOOL		   LOADDS PASCAL SLFLineToAddr	( HSF, SHOFF, LPADDR, SHOFF FAR *, WORD FAR * );
char FAR *     LOADDS PASCAL SLNameFromHsf  ( HSF );
char FAR *     LOADDS PASCAL SLNameFromHmod ( HMOD, WORD );
BOOL           LOADDS PASCAL SLFQueryModSrc ( HMOD );
HMOD           LOADDS PASCAL SLHmodFromHsf  ( HEXE, HSF );
HSF            LOADDS PASCAL SLHsfFromPcxt  ( PCXT );
HSF            LOADDS PASCAL SLHsfFromFile  ( char FAR * );

int		LOADDS PASCAL SLCAddrFromLine ( HEXE, HMOD, LSZ, WORD, LPSLP FAR * );
VOID	LOADDS PASCAL SHFree( LPV );
VOID	LOADDS PASCAL SHUnloadSymbolHandler( VOID );
VOID	LOADDS PASCAL SHPdbNameFromExe( LSZ, LSZ, UINT );
HSYM	LOADDS PASCAL SHFindSymInExe( HEXE, LPSSTR, BOOL );

SHE	LOADDS PASCAL SHGetExeTimeStamp ( LSZ, ULONG * );
BOOL LOADDS PASCAL SHIsThunk( HSYM );

LSZ     LOADDS PASCAL SHGetSrcPath (HMOD);
LSZ     LOADDS PASCAL SHGetObjPath (HMOD);
LSZ     LOADDS PASCAL SHGetCompileEnv (HMOD);
BOOL    LOADDS PASCAL SHModSupportsEC (HMOD);
BOOL    LOADDS PASCAL SHExeSupportsEC (HEXE);
BOOL    LOADDS PASCAL SHModLinkedFromLib (HMOD);

BOOL    LOADDS PASCAL SHModFromHmod( HMOD, PHANDLE );
BOOL    LOADDS PASCAL SHFlushModSyms( HMOD hmod );
BOOL    LOADDS PASCAL SHUseAltPdb ( PFNPDBOpenValidateEx );

#endif


HDEP    LOADDS PASCAL MHMemAllocate( UINT );
HDEP    LOADDS PASCAL MHMemReAlloc(HDEP, UINT);
void    LOADDS PASCAL MHMemFree(HDEP);

HVOID   LOADDS PASCAL MHMemLock(HDEP);
void    LOADDS PASCAL MHMemUnLock(HDEP);
HVOID   LOADDS PASCAL MHOmfLock(HVOID);
void    LOADDS PASCAL MHOmfUnLock(HVOID);
SHFLAG  LOADDS PASCAL MHIsMemLocked(HDEP);

SHFLAG  LOADDS PASCAL DHExecProc(PADDR, SHCALL);
UINT    LOADDS PASCAL DHGetDebuggeeBytes(ADDR, UINT, void FAR *);
UINT    LOADDS PASCAL DHPutDebuggeeBytes(ADDR, UINT, void FAR *);
PSHREG	LOADDS PASCAL DHGetReg(PSHREG, PCXT);
PSHREG	LOADDS PASCAL DHSetReg(PSHREG, PCXT);
HDEP	LOADDS PASCAL DHSaveReg(PCXT);
void	LOADDS PASCAL DHRestoreReg(HDEP, PCXT);
SHFLAG LOADDS PASCAL DHSetupExecute(LPHIND lphdep);
SHFLAG LOADDS PASCAL DHStartExecute(HIND hdep, LPADDR lpaddr, BOOL fIgnoreEvents, SHCALL shcall);
SHFLAG LOADDS PASCAL DHCleanUpExecute(HIND hdep);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\ambig.h ===
BOOL FAR PASCAL EXPORT DlgResolveAmbig(HWND,unsigned,UINT,LONG) ;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\cvinc\sy.h ===
/**** SY.H - System Support Generic using osdebug                       ****
 *                                                                         *
 *                                                                         *
 *  Copyright <C> 1990, Microsoft Corp                                     *
 *                                                                         *
 *  Created: October 15, 1990 by David W. Gray                             *
 *                                                                         *
 *  Purpose:                                                               *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/

typedef HMEM HPRC;
typedef HMEM HTHD;

extern HMEM hprcCurr;
extern HMEM hthdCurr;
extern HMEM hthdLast;
extern HMEM hthdPrompt;

typedef enum {
    stpNotStarted,
    stpRunning,
    stpDead,
    stpStopped,
    stpGone
} STP; // Process State

typedef enum {
    expStopped,		// debuggee is stopped
    expGo,			// we just did a go
    expStep,		// we just did a single-step
    expRange,		// we just did a range-step
    expAfterRet		// we just did a return-step
} EXP; // Process execution mode

typedef enum {
    tdfUnknown,
    tdfFrozen,
    tdfThawed,
    tdfDead,
} TDF; // Thread state

typedef enum {
	stoNone				= 0x00,
	stoOneThread		= 0x01,	// Execute a single thread
	stoInitialBP		= 0x02,	// Stop on initial breakpoint
	stoQueryStep		= 0x04,	// Query before stepping into
	stoPassEx			= 0x08,	// Pass exception on to debuggee
	stoTraceFunction	= 0x10,	// Stepping into specific function
} STO; // STep Options

typedef enum {
	edsNone,
	edsLaunching,		// we are currently launching the debuggee
	edsAsyncStop,		// we are currently attempting to async stop debuggee
	edsKilling,			// we are currently attempting to kill the debuggee
} DEBUGGEE_STATE_EX;

typedef enum {
	krNone			= 0x00,
	krQuiet			= 0x01,	// this is a quiet kill (no message box)
	krRestart		= 0x02,	// this is a kill for restart
	krFastRestart	= 0x04	// this is a kill for fast restart (note: the krRestart
							// flag is ignored in this case)
} KILL_REASON;


enum STEP_MODE
{
	STEP_MODE_FORCE_ASM = 0,	// force asm stepping
	STEP_MODE_FORCE_SOURCE,		// force source stepping
	STEP_MODE_FROM_WINDOW		// determine the stepping mode from the type
};								// of the top level window.  if the type is
								// source, we are in source mode, if the type
								// is asm, we are in disassembly mode

	
typedef struct _THD {
    HTID htid;
    unsigned long tid;
    TDF tdf;    // thread "deadness"
} THD;  // Thread info structure

typedef THD *PTHD;
typedef THD FAR *LPTHD;

typedef struct _PRC {
    BOOL fLoaded;
    BOOL fSymLoaded;
    BOOL fAmbName;

	// Flags to keep track of asynchronous call to Debugger.Go
	//  from inside the BreakpointHit event handler
	BOOL				m_bInsideEvent;			// we are currently executing a bp hit event handler.
	BOOL				m_bGoDeferred;			// event handler did a Debugger.Go, which thus was deferred
	BOOL				m_bStopDeferred;		// Debugger.Stop
	BOOL				m_bEncGoPending;		// Break/Go for edit and Continue while debuggee is running
	
    HPID hpid;
    HPDS hpds;
    HTHD hthdCurr;
    unsigned long pid;
    char *szTitle;
    char *szName;
    char *szArgs;
    HPRC hprcParent;
    STP  stp;
	EXP  exp;			// what type of action are we executing right now?
	BOOL fBpInitialCxt;	// do we currently have a BP at initial cxt (WinMain)?
	WORD wEM;
    BOOL fStepOver;
    STO  sto;
    ADDR addrStart;
    ADDR addrEnd;
    HTID htidExecuting;
    BOOL fFuncExec;
	UINT funcExecTimerID; 
    BOOL fHitBP;
	DBC  dbcLastStop;	// the most recently received dbc which caused
						// execution to stop, e.g. dbcBpt, dbcException,
						// dbcProcTerm, and so on
    HLLI llthd;
    BOOL fReallyNew;
    BOOL fPcodePresent;
    BOOL fHasThreads;
    BOOL fHasMessages;

	BOOL fHaveInitialContext;	// Is there a cached get_initial_context?
	int  iReturnInitialContext;	//    If so, what was the return value?
	CXT  cxtInitial;			//    Also, if it succeeded, what's the context?
	BOOL fSqlInproc;			// SQL inproc debugging?

	

	BOOL IsFirstChance()		{ return this ? fExceptionHappening : FALSE; }
	VOID SetFirstChance(BOOL f)	{ fExceptionHappening = !!f; }

		// [v-natpm] Flag set when a 1st chance exception happens
		// (upon a dbcException notification).
		// When this flag is set :
		// - Step commands are disabled (step over, step into, step out)
		// - The Go command brings up a "pass exception to debuggee ?
		//   YES/NO/CANCEL" dialogbox. The response of the user sets (YES),
		//   or resets (NO) the fPassException field of the EXOP struct
		//   used by OSDGo().  The flag is reset by Go/Restart/Stop
		//   debugging



	DEBUGGEE_STATE_EX
	GetDebuggeeStateEx(
		)
	{
		return m_DebuggeeStateEx;
	}

	void
	SetDebuggeeStateEx(
		DEBUGGEE_STATE_EX	State
		)
	{
		m_DebuggeeStateEx = State;
	}
	
	//	why was this debuggee killed. NB: the debugger must be in the process
	//	of being killed
	
	ULONG
	GetKillReason(
		)
	{
		ASSERT (m_DebuggeeStateEx == edsKilling);
		return m_KillReason;
	}

	void
	SetKillReason(
		ULONG	KillReason
		)
	{
		if (m_KillReason & krFastRestart)
			KillReason |= krFastRestart;
			
		m_KillReason = KillReason;
	}

	// have we seen dbcEntryPoint yet or not?
	
	BOOL
	IsBeyondEntryPoint(
		)
	{
		return m_fBeyondEntryPoint;
	}

	void
	SetBeyondEntryPoint(
		BOOL	fBeyondEntryPoint		
		)
	{
		m_fBeyondEntryPoint = fBeyondEntryPoint;
	}

	// were the BPs for this debuggee all successfully bound?
	
	BOOL
	IsBPsBound(
		)
	{
		return m_fBPsBound;
	}

	void
	SetBPsBound(
		BOOL	BPsBound
		)
	{
		m_fBPsBound = BPsBound;
	}

	BOOL
	IsOmfLoaded(
		)
	{
		return m_OmfLoaded;
	}


	void
	SetOmfLoaded(
		BOOL	OmfLoaded
		)
	{
		m_OmfLoaded = OmfLoaded;
	}


	//
	// NOTE: this returns SRCSTEPPING or ASMSTEPPING -- i.e., whether we are
	// currently source stepping or asm stepping, *NOT* the m_StepMode
	// variable.  The m_StepMode variable is returned in the optional
	// parameter.

	ULONG
	GetStepMode(
		STEP_MODE*	StepMode = NULL
		);

	void
	SetStepMode(
		STEP_MODE	StepMode
		)
	{
		m_StepMode = StepMode;
	}

private:

	// access through {Is,Set}FirstChance()

	BOOL				fExceptionHappening;

	ULONG				m_KillReason;			// see KILL_REASON above
	BOOL				m_fBeyondEntryPoint;	// have we reached the entry point?
	BOOL				m_fBPsBound;			// were all BPs successfully bound
	DEBUGGEE_STATE_EX	m_DebuggeeStateEx;
	BOOL				m_OmfLoaded;			// whether the OMF is loaded or not
	STEP_MODE			m_StepMode;				// stepping mode

} PRC;  // PRoCess info structure

typedef PRC *PPRC;
typedef PRC FAR *LPPRC;

extern LPPRC lpprcCurr;

#define hpidCurr   HpidFromHprc ( hprcCurr )
#define htidCurr   HtidFromHthd ( hthdCurr )
#define htidLast   HtidFromHthd ( hthdCurr )
#define htidPrompt HtidFromHthd ( hthdCurr )

#define SethtidCurr(htid)   hthdCurr   = HthdFromHtid ( hprcCurr, htid )
#define SethtidLast(htid)   hthdLast   = HthdFromHtid ( hprcCurr, htid )
#define SethtidPrompt(htid) hthdPrompt = HthdFromHtid ( hprcCurr, htid )

#define SetHpidCurr(hpid)   hprcCurr   = HprcFromHpid ( hpid );

BOOL   PASCAL SYInitProcessList ( void );
BOOL   PASCAL SYLoadDebugInfo ( void );
BOOL   PASCAL SYCreateHprc ( char *, char *, HPRC, HPID );
char * PASCAL SYGetDebuggeeArgs ( char * );
BOOL   PASCAL SYDisplayTLError();

// Wrapper for OSDCreateHpid, this reports errors when appropriate.
XOSD   PASCAL SYUtilCreateHpid(LPFNSVC, HEM, HTL, LPHPID);

BOOL SYSingleStep ( BOOL, STO, HPID, HTID );
BOOL SYRangeStep ( BOOL, STO, ADDR, ADDR, HPID, HTID );
BOOL SYAfterReturn ( STO, HPID, HTID );
BOOL SYGo ( const EXOP*, HPID, HTID );
XOSD SYNativeOnly ( BOOL );
void SYFlipScreen ( HPID, HTID, BOOL, BOOL );
BOOL SYProgramHasRun ( void );
void SYSetContext ( HPRC, HTHD, BOOL );

HPRC HprcFromHpid ( HPID );
HLLI LlthdFromHprc ( HPRC );

unsigned long TidFromHtid ( HPRC, HTID );
unsigned long TidFromHthd ( HTHD );
HTID HtidFromTid ( HPRC, unsigned long );
HTID HtidFromHthd ( HTHD );
HTHD HthdFromHtid ( HPRC, HTID );
HTHD HthdFromTid ( HPRC, unsigned long );

unsigned long PidFromHpid ( HPID );
unsigned long PidFromHprc ( HPRC );
HPID HpidFromPid ( unsigned long );
HPID HpidFromHprc ( HPRC );
HPRC HprcFromHpid ( HPID );
HPRC HprcFromPid ( unsigned long );

HTHD GetNthThread ( WORD );

void			SYSetFrame ( FRAME * );
int				SYCmpAddr ( LPADDR, LPADDR );
void			SYSetAddr ( HPID, HTID, ADR, LPADDR );
void            SYUnassemble ( HPID, HTID, LPSDI );
void            SYFormatSdi ( LPSDI, char *, BOOL );
XOSD            SYAssemble ( LPADDR );
BOOL            SYGetPrevInst ( HPID, HTID, PADDR );
void			SYSetEmi ( HPID, HTID, PADDR );
XOSD			SYGetAddr ( HPID, HTID, ADR, LPADDR );
void			SYSaveModels ( char *, WORD );
void			SYUnloadDlls ( void );
void            SYUnFixupOmf ( void );

#define write_registers()
#define get_registers()

TDF PASCAL FAR ThreadStatus ( HMEM, char *, BOOL );

BOOL LOADDS PASCAL SYFixupAddr ( PADDR );
BOOL LOADDS PASCAL SYUnFixupAddr ( PADDR );
UINT LOADDS PASCAL SYFIsOverlayLoaded ( PADDR );

// Enum Process Identifier Type
typedef enum { epiDefault, epiTitle, epiName, epiPID } EPI;

extern EPI epiDef;

int GetProcId ( char FAR *, HPRC, EPI, int );
int ProcStatus ( HPRC, char *, int );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\askpath.h ===
#include <stdlib.h>			// for _MAX_PATH
#include <afxmt.h>
#include "path.h"			// for CDir

typedef struct MAPPATH
{
	LPSTR		lszFrom;	// path to map from
	LPSTR		lszTo;		// path to map it to
} MAPPATH;

extern int cmappath;
#define cmappathMax 100		// I can't be bothered to make this variable-sized
extern MAPPATH FAR rgmappath[cmappathMax];

#define LPFNFMAPPATHTEST LPFNFILEFINDVALIDATOR

BOOL FMapPath(
	const CDir& dirProj,
	CHAR AlternatePath[_MAX_PATH],
	LPSTR lszFilename,
	LPDIALOGPARAM lpdlgparam,
	LPFNFMAPPATHTEST lpfnFMapPathTest,
	LONG lParam);

VOID ClearPathMappings(VOID);
VOID AddMapping(LPSTR,LPSTR);

// The following are for Find Symbols

extern class CSemaphore g_evFindSymbols;
typedef struct _SEARCHDEBUGINFOANDRETURN {
	PSEARCHDEBUGINFO	psdi;
	BOOL				fSuccess;
} SEARCHDEBUGINFOANDRETURN, *PSEARCHDEBUGINFOANDRETURN;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\bpdlgex.h ===
//
// bpdlg.h
//
// class declarations for tabbed breakpoint dialog
//

#ifndef INCLUDE_BPDLG_H
#define INCLUDE_BPDLG_H

#include <dlgbase.h>
#include <utilctrl.h>
#include <shlmenu.h>

#define IDC_BP_LIST  		2000
#define IDC_BP_GOTOCODE		2001
#define IDC_BP_REMOVE 		2002
#define IDC_BP_REMOVE_ALL	2003

#define LOCATION_TAB		0
#define DATA_TAB			1
#define MESSAGES_TAB		2


class CLocationTab : public CDlgTab
{
protected:
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CLocationTab)

	friend class CBPDlgEx;
	
// Construction
public:
	CLocationTab();

	// Dialog Data
	//{{AFX_DATA(CLocationTab)
	enum { IDD = IDD_BPTAB_LOCATION };
	CEdit	m_edLocation;
	//}}AFX_DATA

	CMenuBtn m_butLocMenu;
	CString m_strCurAddr;
	CString m_strCurLine;
	CString m_strCurFile;	// used with current line when disasm wnd is active
	CString m_strCurFunc;

	BOOL m_fInitialized;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLocationTab)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(CLocationTab)
	afx_msg void OnChangeLocation();
	afx_msg void OnCondition();
	afx_msg void OnCurrentAddr();
	afx_msg void OnCurrentLine();
	afx_msg void OnCurrentFunc();
	afx_msg void OnAdvanced();
	//}}AFX_MSG

// Implementation
protected:

	virtual BOOL OnInitDialog();
	virtual BOOL ValidateTab();
	void 		 InitializeLocationMenu();
	void		 SetBPFields();
	virtual BOOL PreTranslateMessage(MSG *pmsg);
};

class CDataTabEx : public CDlgTab
{
protected:
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CDataTabEx)

	friend class CBPDlgEx;
	
// Construction
public:
	CDataTabEx();

	// Dialog Data
	//{{AFX_DATA(CDataTabEx)
	enum { IDD = IDD_BPTAB_DATA1 };
	//CEdit	m_edLocation;
	CEdit	m_edExpr;
	//CStatic	m_txtLength;
	CEdit	m_edLength;
	//}}AFX_DATA

	CMenuBtn m_butExprMenu;
	BOOL m_fInitialized;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDataTabEx)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(CDataTabEx)
	afx_msg void OnChangeExpression();
	afx_msg void OnChangeLength();
	afx_msg void OnChangeLocation();
	afx_msg void OnAdvanced();
	//afx_msg void OnClickedChanges();
	//afx_msg void OnClickedTrue();
	//}}AFX_MSG
	
	virtual BOOL 	OnInitDialog();
	virtual BOOL	ValidateTab();
	void			SetBPFields();
	virtual BOOL	PreTranslateMessage(MSG *pmsg);
};

class CMessagesTabEx : public CDlgTab
{
protected:
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CMessagesTabEx)

	friend class CBPDlgEx;
	
// Construction
public:
	CMessagesTabEx();

	// Dialog Data
	//{{AFX_DATA(CMessagesTabEx)
	enum { IDD = IDD_BPTAB_MESSAGES };
	CComboBox	m_lstWndProc;
	CComboBox	m_lstMessage;
	//}}AFX_DATA

	BOOL m_fInitialized;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMessagesTabEx)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(CMessagesTabEx)
	afx_msg void OnDropdownMessage();
	afx_msg void OnDropdownWndproc();
	afx_msg void OnChangeWndProc();
	afx_msg void OnChangeMessage();
	afx_msg void OnSelchangeMessage();
	afx_msg void OnSelchangeWndproc();
	//}}AFX_MSG
	virtual BOOL 	OnInitDialog();
	virtual BOOL	ValidateTab();
	void			SetBPFields();
	virtual BOOL	PreTranslateMessage(MSG *pmsg);
};

class CBPListEx : public CCheckList
{
protected:

	DECLARE_MESSAGE_MAP()

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

public:
	virtual void SetCheck(int nItem, int nCheck);
	virtual int  GetCheck(int nItem);

protected:
	afx_msg void OnLButtonDown(UINT, CPoint);
};

class CBPDlgEx : public CTabbedDialog
{
	DECLARE_DYNAMIC(CBPDlgEx)
	CBPDlgEx();
	~CBPDlgEx();

public:

	void OnOK();
	void OnCancel();

	virtual void 		GetMargins(CRect & rect);
	virtual void 		CreateButtons();
	virtual void 		MoveButtons(int nLeft, int nCenter);
	virtual CButton*	GetButtonFromIndex(int index);
	virtual void		OnSelectTab(int nTab);
	virtual BOOL 		PreTranslateMessage(MSG *pmsg);

	friend class CLocationTab;
	friend class CDataTabEx;
	friend class CMessagesTabEx;
	//friend class CAdvancedTab;
	friend class CBPListEx;

protected:
	DECLARE_MESSAGE_MAP()

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBPDlgEx)
	protected:
	//}}AFX_VIRTUAL

	// ClassWizard generated message map functions	
	//{{AFX_MSG(CBPDlgEx)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnChangedSel();
	afx_msg	void OnRemoveBP();
	afx_msg	void OnToggleBP();
	afx_msg void OnGotoCode();
	afx_msg	void OnRemoveAllBP();
	//}}AFX_MSG

	CLocationTab* 	m_pdlgLocation;
	CDataTabEx*		m_pdlgData;
	CMessagesTabEx* m_pdlgMessages;
	//CAdvancedTab* m_pdlgAdvanced;

	CStatic			m_lblBP;		// breakpoints label
	CBPListEx		m_lstBP;		// breakpoints list
	CButton			m_butGotoCode;	// goto source button
	CButton			m_butRemove;	// remove breakpoint button
	CButton			m_butRemoveAll;	// remove all breakpoints button
	
	BREAKPOINTTYPES	m_bptypeCur;	// current breakpoint type
	BOOL			m_fCurBPDirty;	// current breakpoint has been modified
	BOOL			m_fSelfChange;	// ignore changes, dialog is manipulating itself
	BOOL			m_fInsertingNew;// true if a new BP is being inserted
	int				m_iItemChanging;// the index of the breakpoint being added or edited

	char 			m_szLocation[cbBpCmdMax];
	char 			m_szExpression[cbBpCmdMax];
	char 			m_szLength[20];
	char 			m_szPassCnt[20];
	char			m_szMessage[128];
	//BOOL			m_fChanges;
	BOOL			m_fExpTrue;
	int 			m_iedLocStart;
	int 			m_iedLocEnd;
	int 			m_iedExpStart;
	int 			m_iedExpEnd;

	int				m_itabPrev;

private:
	PBREAKPOINTNODE GetBreakPoint(UINT wItemID);
	void 			FillBPList();
	int  			GetBPNodeFromControls(PBREAKPOINTNODE pBreakpoint);
	void 			AcceptChanges();
	void 			RejectChanges();
	BOOL 			AddReplaceBP();
	void			ClearBPFields();
	void 			SetBPFields();
	void 			UpdateCurrentBP(BREAKPOINTTYPES bptype);
	void 			UpdateListString(char *buf);
	LRESULT 		OnInitMoveFocus(WPARAM wParam, LPARAM lParam);
	BOOL			FCurrentBPIsEmpty();
	BREAKPOINTTYPES	GetCurrentBPType();
	void			HandleBPError(int ierr, BOOL fQuiet);
};

///////////////////////////////////////////////////////////////////////////////
// CBPCondDlg class
///////////////////////////////////////////////////////////////////////////////

class CBPCondDlg : public C3dDialog
{
	DECLARE_MESSAGE_MAP()

// Construction
public:
	CBPCondDlg (CWnd * pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CCallingExeDlg)
	enum { IDD = IDD_BP_DLG_CONDITION };
	//}}AFX_DATA

	//{{AFX_MSG(CCallingExeDlg)
	afx_msg void OnChangeExpression();
	//}}AFX_MSG

	virtual BOOL OnInitDialog();
	virtual void OnOK();

	BOOL	m_fBreakWhenExprTrue;
	CString m_strExpr;
	CString m_strLength;
	CString m_strSkip;
};

///////////////////////////////////////////////////////////////////////////////
// CBPContextDlg class
///////////////////////////////////////////////////////////////////////////////

class CBPContextDlg : public C3dDialog
{
// Construction
public:
	CBPContextDlg (CWnd * pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CCallingExeDlg)
	enum { IDD = IDD_BP_DLG_CONTEXT };
	//}}AFX_DATA

	//{{AFX_MSG(CCallingExeDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG

	CString m_strlblWhere;
	CString m_strWhere;
	CString m_strFunc;
	CString m_strSource;
	CString m_strModule;
};

#endif // _INCLUDE_BPDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\autownd.h ===
// autownd.h : header file
//
#ifndef __AUTOWND_H__
#define __AUTOWND_H__

/////////////////////////////////////////////////////////////////////////////
// CAutoWnd window
#include "tokens.h"

class CAutoWnd : public CDbgGridWnd
{
// Construction
public:
	CAutoWnd(CBaseVarsView *pView);
	virtual ~CAutoWnd();
	typedef CDbgGridWnd CBaseClass;

// Attributes
public:

// Operations
public:
	virtual void UpdateEntries();

	void AddExprsFromSourceLines (const CString&, HSF, LONG);
	void AddExprsFromReturnValues ();
	void DeleteRetValRows();

	BOOL IsInterestingAutoTM(CTM *pTM); // Does this TM have the goodness to be put in the auto tab.

	void Parse(CTokenStream&, CTMArray&, CStrArray&);
	BOOL SkipComments(CTokenStream&, CTokenStreamPos&, BOOL bForward = TRUE);

	// Moves the position to the first location where an auto watch could start.
	BOOL MoveToStartToken(CTokenStream&, CTokenStreamPos&);
	BOOL IsAddressOperator(CTokenStream&, CTokenStreamPos&);	// see comments at begining of function defn.

	BOOL GetInitialOperators(CTokenStream&, CTokenStreamPos&, CString&);
	BOOL CollectIndexStr(CTokenStream&, CTokenStreamPos&, CString&);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoWnd)
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL m_bLineInfoValid:1;

	enum { maxLinesScanned = 10 };
	
	HSF m_hsf;			// Handle to the source file which has the current address.
	LONG m_curLineNo;	// Line no within the file where the current CXF is.
	CString m_strFileName;	// The actual filename last time around.

	// Generated message map functions
protected:
	//{{AFX_MSG(CAutoWnd)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	virtual LRESULT OnUpdateDebug(WPARAM, LPARAM);
	virtual LRESULT OnClearDebug(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif // __AUTOWND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\cmgrlow.h ===
// Low-level codemgr routines (ie those requiring inside
// knowledge of CV400)

BOOL GetSourceFrompADDR(LPADDR,LPSTR,WORD,LONG FAR *,SHOFF FAR *,HSF FAR *);

CView * PASCAL MoveEditorToAddr(LPADDR);

HBPI FAR PASCAL AsyncBPCommitBP(LPPBP ppbp);

void FAR PASCAL AsyncBPDelete(HBPI hbpi);

XOSD PASCAL DoAllCallBacks(void);

VOID DoCallBacksUntil(void);

XOSD PASCAL CheckCallBack(BOOL);

// Get the HSF for a document
DIS_RET PASCAL GetHsfFromDoc(CDocument *pDoc, HSF FAR * lpHsf);

void GoUntil(PADDR paddr, HTHD hthd, int BpType, BOOL fGoException, BOOL fFlipScreen) ;

void PrimeDbgMessagePump(void);

void DbgMessagePump(BOOL fPump = TRUE);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\cdebug.h ===
#ifndef _CDEBUG_H_
#define _CDEBUG_H_

#include <bldapi.h>

#if !(defined (OSDEBUG4))
#include <od.h>
#else
#include <od4.h>
#endif

enum {
	DLL_SH = 0,
	DLL_TL,
	DLL_EM,
	DLL_EE,
    DLL_NM
};

// Maximum number of NM DLLs we can load at once
#define MAX_NM_DLL	4


class CDebug : public CObject
{
public:
	CDebug ();
	~CDebug ();
	BOOL Init(BOOL fSrcInit);
	void UpdateMetrics (HPID hpid);
	void OnDebugStart (HPID hpid);
	void OnConfigChange ();
	void ConfigChange (uniq_platform upID);  
	BOOL GetComponents( const TCHAR *szNM, const TCHAR**szTL, const TCHAR **szEM, const TCHAR**szSH, const TCHAR**szEE );

private:
	BOOL	m_fInitialized;
	BOOL	m_fMtrcOleRpc;
	BOOL	m_fMtrcNativeDebugger;
	BOOL	m_fMtrcRemoteTL;
	BOOL	m_fMtrcHasThreads;
	BOOL	m_fMtrcExceptionHandling;
	BOOL	m_fMtrcMultipleInstances;
	BOOL	m_fQuickRestart;
	BOOL	m_fEditedByENC;
	END		m_endMtrcEndian;
	BPTS	m_bptsMtrcBreakPoints;
	ASYNC	m_asyncMtrcAsync;

	CString	m_strExeExtension;

	UINT	m_platform;

	HINSTANCE m_hInstTL;
	HINSTANCE m_hInstEM;
	HINSTANCE m_hInstSH;
	HINSTANCE m_hInstEE;
	HINSTANCE m_rghInstNM [MAX_NM_DLL];

	const TCHAR* m_szTLName;
	const TCHAR* m_szEMName;
	const TCHAR* m_szSHName;
	const TCHAR* m_szEEName;
	const TCHAR* m_rgszNMName [MAX_NM_DLL];

	UINT m_nNMCount;

public:
	BOOL	MtrcOleRpc ()			{ return m_fMtrcOleRpc; }
	BOOL	MtrcNativeDebugger ()	{ return m_fMtrcNativeDebugger; }
	BOOL	MtrcRemoteTL ()			{ return m_fMtrcRemoteTL; }
	BOOL	MtrcHasThreads ()		{ return m_fMtrcHasThreads; }
	BOOL	MtrcFirstChanceExc ()	{ return m_fMtrcExceptionHandling; }
	BOOL	MtrcMultipleInstances()	{ return m_fMtrcMultipleInstances; }
	END		MtrcEndian ()			{ return m_endMtrcEndian; }
	BPTS	MtrcBreakPoints ()		{ return m_bptsMtrcBreakPoints; }
	ASYNC	MtrcAsync ()			{ return m_asyncMtrcAsync; }

	CString	GetExeExtension ()		{ return m_strExeExtension; }

	UINT	GetPlatform()			{ return m_platform; }

	BOOL	SupportsQuickRestart() const;
	void	SetQuickRestart (BOOL	f) { m_fQuickRestart = f; }
	BOOL	IsQuickRestart () { return m_fQuickRestart && !m_fEditedByENC; };
	void	SetEditedByENC (BOOL	f) { m_fEditedByENC = f; }
	BOOL	IsEditedByENC () { return m_fEditedByENC; }

	BOOL	LoadComponent(int DLLtype, int nWhichOne = -1);
	BOOL	UnLoadComponent(int DLLtype, int nWhichOne = -1);

	BOOL	InitializeComponent(int DLLtype, int nWhichOne = -1);
	BOOL	UnInitializeComponent(int DLLtype, int nWhichOne = -1);

	BOOL	InitOSD(VOID);
	BOOL	UnInitOSD(VOID);

	BOOL	InitDBF();
	BOOL	UnInitDBF();
	

	void	SetTLName(const TCHAR* szNewTLName)
									{ m_szTLName = szNewTLName; }
	
	BOOL	IsMacintosh() const;
	BOOL	IsJava() const;
};

extern CDebug *pDebugCurr;

BOOL
IsCrashDump(
	);

enum {
	FUNCTION_NORMAL,
	FUNCTION_NOSTEPINTO
};


class CExecutionExts
{
	THashedMapOf <CString, DWORD>	m_map;

  public:

	BOOL
	Enter(
		LPCSTR	str,
		DWORD	status
		)
	{
		return m_map.Insert (str, status);
	}
	
	BOOL
	IsNoStepInto(
		CString	strFunctionName
		)
	{
		DWORD	dw = 0;
		int		index = -1;

		//
		// Search for the full name: Foo::Bar
		//
		
		if (m_map.Find (strFunctionName, &dw)) {
			return (dw == FUNCTION_NOSTEPINTO);
		}

		//
		// Also check for all methods of this class: Foo::*
		//
		
		index = strFunctionName.Find ("::");

		if (index != -1) {
			strFunctionName = strFunctionName.Left (index + 2);
			strFunctionName += '*';

			if (m_map.Find (strFunctionName, &dw)) {
				return (dw == FUNCTION_NOSTEPINTO);
			}
		}

		return FALSE;
	}

};


extern CExecutionExts		g_ExecutionExts;
	

#endif	// _CDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\breakpts.h ===
/**********************************************************************

	FILE:           BREAKPTS.H

	PURPOSE:        Defines and prototypes for the QCQP persistent
					breakpoint handler.

**********************************************************************/

#ifndef _BREAKPTS_H_
#define _BREAKPTS_H_

#include "cdebug.h"

#define INT int

#include "brkpt.h"

// Dependent upon od.h definitions!
#define	msgMaskMin		msgMaskWin
#define msgMaskMac		msgMaskDDE
#define msgSingleOnly	((UINT)(~msgMaskAll))
#define msgNone			0

// CV400/CANWIN context delimeters
#define OPENCXT         _T('{')
#define CLOSECXT        _T('}')

#define BP_LINELEADER '.'
#define BP_LINELEADER_OTHER '@'

// Mask optimization for dialog box
#define ENABLE_EDIT1    0x0001
#define ENABLE_EDIT2    0x0002
#define ENABLE_EDITL    0x0004
#define ENABLE_EDITW    0x0008
#define ENABLE_LABEL1   0x0010
#define ENABLE_LABEL2   0x0020
#define ENABLE_LABELL   0x0040
#define ENABLE_MSG      0x0080

#define ENABLE_BPLOC			(ENABLE_EDIT1 | ENABLE_LABEL1)
#define ENABLE_BPEXPRTRUE		(ENABLE_EDIT2 | ENABLE_LABEL2)
#define ENABLE_BPEXPRCHGD		(ENABLE_EDIT2 | ENABLE_LABEL2 | \
								 ENABLE_EDITL | ENABLE_LABELL)
#define ENABLE_BPLOCEXPRTRUE	(ENABLE_EDIT1 | ENABLE_LABEL1 | \
								 ENABLE_EDIT2 | ENABLE_LABEL2)
#define ENABLE_BPLOCEXPRCHGD	(ENABLE_EDIT1 | ENABLE_LABEL1 | \
								 ENABLE_EDIT2 | ENABLE_LABEL2 | \
								 ENABLE_EDITL | ENABLE_LABELL)
#define ENABLE_BPWNDPROCMSGRCVD	(ENABLE_EDIT1 | ENABLE_LABEL1 | \
								 ENABLE_EDIT2 | ENABLE_LABEL2)

// define for maximum line # we can set bp's on
#if defined (_WIN32)
#define cLineBPLim	0xffffL
#else
#define cLineBPLim	0x7fffL
#endif

typedef enum {
	ERR_NULL = 0,
	ERR_ACTION,
	ERR_LOC,
	ERR_PROC,
	ERR_EXPR,
	ERR_LEN,
	ERR_MSG,
	ERR_PASSCNT
} ERR_PARSE ;

#define AMB_STS_UNRESOLVED -1

typedef enum {
	BPNIL = -1,
	BPLOC = 0,
	BPLOCEXPRTRUE,
	BPLOCEXPRCHGD,
	BPEXPRTRUE,
	BPEXPRCHGD,
	BPWNDPROCMSGRCVD
}
BREAKPOINTTYPES;


typedef enum
{
	BPLOCFILELINE,		// Simple foo.c @ line
	BPLOCADDREXPR,		// Expression to parse (not line)
}
LOCATIONTYPES;


// The component parts of a CV400 {f,s,e} context

#define FUNC_NAME_LEN 150
typedef struct
{
	char Function[FUNC_NAME_LEN+1];	// or proc
	char Source[_MAX_PATH+2];		//    mod (+2 bytes for open/close quotes)
	char Exe[_MAX_PATH+2];			//    exe (+2 bytes for open/close quotes)
}
BPCONTEXT;

typedef BPCONTEXT _far *PBPCONTEXT;

// define the maximum length of bp commands
#define cbBpCmdMax	(sizeof(BPCONTEXT) + FUNC_NAME_LEN)

typedef struct
{
	int InitLine;	// Line number when BP first specified
	int CurLine;	// Current editor BP line number
	int Offset;		// Asm offset
}
BPLINEINFO;


typedef struct
{
	char AddrExpr[MAX_EXPRESS_SIZE];
}
BPADDREXPR;


typedef struct
{
	char WndProcName[FUNC_NAME_LEN+1];
}
BPWNDPROCEXPR;


typedef union
{
	BPLINEINFO 		l;
	BPADDREXPR 		ae;
	BPWNDPROCEXPR 	wpe;
}
BPLOCATION;


typedef struct
{
	BPCONTEXT 		Cxt;
	BPLOCATION 		Loc;
	LOCATIONTYPES 	LocType;
}
BPLOCATIONNODE;


// NB Contexts for expressions are treated as part of
// the expressions and left in the Expr string

typedef struct
{
	char 		Expr[MAX_EXPRESS_SIZE];
	int 		Len;				// used for expression changed
	BPCONTEXT 	Cxt;				// Cxt of expression
	BOOL 		UseCxt;				// TRUE if Cxt used in setting the bp
}
NORMALEXPRESSION;


typedef struct
{
	UINT MessageClass;
	UINT MessageNum;
}
WNDPROCEXPRESSION;


typedef union
{
	NORMALEXPRESSION ne;
	WNDPROCEXPRESSION we;
}
BPEXPRESSIONNODE;


typedef union
{
	UINT AllFlags;          // Flags bit fields
	struct
	{
		// Flags used only for storing breakpoint dialog info
		UINT DlgMarkAdd     : 1 ; // This breakpoint has been marked for addition
		UINT DlgMarkDel     : 1 ; // This breakpoint has been marked for deletion
		UINT DlgMarkEnable  : 1 ; // This breakpoint has been marked for enabling
		UINT DlgMarkDisable : 1 ; // This breakpoint has been marked for disabling

		// Miscellaneous other flags
		UINT fEnabled      : 1 ; // This breakpoint is enabled
		UINT fAmbig        : 1 ; // Set this flag for ambiguous
		UINT fExtInfo      : 1 ; // This BP needs extended info on display
		UINT fSymbolized   : 1 ; // Have we already tried to convert this
								 // BP node to a symbolic address?
		UINT fWarnedUnsupp : 1 ; // Have we already warned the user if this
								 // BP's type is unsupported on this platform?
		UINT fSqlBp        : 1 ; // SQL Specific breakpoints
	} f;
}
BREAKPOINTFLAGS;

#ifdef DEBUGGER_AUTOMATION
class CAutoBreakpoint;
#endif

typedef struct BREAKPOINTNODEtag
{
	BREAKPOINTTYPES 				Type;
	BPLOCATIONNODE  				bpl;
	BPEXPRESSIONNODE 				bpe;
	struct BREAKPOINTNODEtag _far *	Next;
	INT TMindex;
	BREAKPOINTFLAGS 				Flags;
	USHORT							cPass;

	// Breakpoint type (for BPLOC and BPLOCEXPRxxx aka LocatonNode)
	EBPT							ebpt;

	// Error during initialization, RESERVED FOR FUTURE USE (markbro)
	// Someday we will decide to queue up non-bound BPs at startup
	// and only display one dialog/message box instead of a seperate
	// one for each BP which didn't bind.  The error will be cached
	// here and cleared once the BP error is displayed
	UINT							idInitError;

	// This is a handle to the corresponding
	// CV400 breakpoint structure.  It is
	// only, (possibly), non-NULL while the
	// debuggee exists.
#ifdef _WIN32
	HBPI 							hbpi;
#else
	WORD 							hbpi;
#endif
	INT								iGroup;
#ifdef DEBUGGER_AUTOMATION
	CAutoBreakpoint *				pAutoBP;
#endif
}
BREAKPOINTNODE;

typedef BREAKPOINTNODE _far *PBREAKPOINTNODE;



// BREAKPOINTNODE access macros:

#define bpnNext(bpn)					((bpn).Next)
#define pbpnNext(pbpn)					((pbpn)->Next)

// BP type:
#define bpnType(bpn)					((bpn).Type)
#define pbpnType(pbpn)					((pbpn)->Type)

// BP location type:
#define bpnLocType(bpn)					((bpn).bpl.LocType)
#define pbpnLocType(pbpn)				((pbpn)->bpl.LocType)

// BP locations:
#define bpnLocCxt(bpn)					((bpn).bpl.Cxt)
#define pbpnLocCxt(pbpn)				((pbpn)->bpl.Cxt)
#define bpnLocCxtFunction(bpn)			((bpn).bpl.Cxt.Function)
#define pbpnLocCxtFunction(pbpn)		((pbpn)->bpl.Cxt.Function)
#define bpnLocCxtSource(bpn)			((bpn).bpl.Cxt.Source)
#define pbpnLocCxtSource(pbpn)			((pbpn)->bpl.Cxt.Source)
#define bpnLocCxtExe(bpn)				((bpn).bpl.Cxt.Exe)
#define pbpnLocCxtExe(pbpn)				((pbpn)->bpl.Cxt.Exe)
#define bpnFileName(bpn)				bpnLocCxtSource(bpn)
#define pbpnFileName(pbpn)				pbpnLocCxtSource(pbpn)
#define bpnInitLine(bpn)				((bpn).bpl.Loc.l.InitLine)
#define pbpnInitLine(pbpn)				((pbpn)->bpl.Loc.l.InitLine)
#define bpnCurLine(bpn)					((bpn).bpl.Loc.l.CurLine)
#define pbpnCurLine(pbpn)				((pbpn)->bpl.Loc.l.CurLine)
#define bpnOffset(bpn)					((bpn).bpl.Loc.l.Offset)
#define pbpnOffset(pbpn)				((pbpn)->bpl.Loc.l.Offset)
#define bpnAddrExpr(bpn)				((bpn).bpl.Loc.ae.AddrExpr)
#define pbpnAddrExpr(pbpn)				((pbpn)->bpl.Loc.ae.AddrExpr)
#define bpnWndProc(bpn)					((bpn).bpl.Loc.wpe.WndProcName)
#define pbpnWndProc(pbpn)				((pbpn)->bpl.Loc.wpe.WndProcName)

// BP expressions:
#define bpnExpression(bpn)				((bpn).bpe.ne.Expr)
#define pbpnExpression(pbpn)			((pbpn)->bpe.ne.Expr)
#define bpnExprLen(bpn)					((bpn).bpe.ne.Len)
#define pbpnExprLen(pbpn)				((pbpn)->bpe.ne.Len)
#define bpnExprCxt(bpn)					((bpn).bpe.ne.Cxt)
#define pbpnExprCxt(pbpn)				((pbpn)->bpe.ne.Cxt)
#define bpnExprCxtFunction(bpn)			((bpn).bpe.ne.Cxt.Function)
#define pbpnExprCxtFunction(pbpn)		((pbpn)->bpe.ne.Cxt.Function)
#define bpnExprCxtSource(bpn)			((bpn).bpe.ne.Cxt.Source)
#define pbpnExprCxtSource(pbpn)			((pbpn)->bpe.ne.Cxt.Source)
#define bpnExprCxtExe(bpn)				((bpn).bpe.ne.Cxt.Exe)
#define pbpnExprCxtExe(pbpn)			((pbpn)->bpe.ne.Cxt.Exe)
#define bpnMessageClass(bpn)			((bpn).bpe.we.MessageClass)
#define pbpnMessageClass(pbpn)			((pbpn)->bpe.we.MessageClass)
#define bpnMessageNum(bpn)				((bpn).bpe.we.MessageNum)
#define pbpnMessageNum(pbpn)			((pbpn)->bpe.we.MessageNum)
#define bpnExprUseCxt(bpn)				((bpn).bpe.ne.UseCxt)
#define pbpnExprUseCxt(pbpn)			((pbpn)->bpe.ne.UseCxt)

// BP flags
#define bpnMarkAdd(bpn)					((bpn).Flags.f.DlgMarkAdd)
#define pbpnMarkAdd(pbpn)				((pbpn)->Flags.f.DlgMarkAdd)
#define bpnMarkDel(bpn)					((bpn).Flags.f.DlgMarkDel)
#define pbpnMarkDel(pbpn)				((pbpn)->Flags.f.DlgMarkDel)
#define bpnMarkEnable(bpn)				((bpn).Flags.f.DlgMarkEnable)
#define pbpnMarkEnable(pbpn)			((pbpn)->Flags.f.DlgMarkEnable)
#define bpnMarkDisable(bpn)				((bpn).Flags.f.DlgMarkDisable)
#define pbpnMarkDisable(pbpn)			((pbpn)->Flags.f.DlgMarkDisable)
#define bpnAmbigBP(bpn)					((bpn).Flags.f.fAmbig)
#define pbpnAmbigBP(pbpn)				((pbpn)->Flags.f.fAmbig)
#define bpnOldStatus(bpn)				((bpn).Flags.f.DlgOldStatus)
#define pbpnOldStatus(pbpn)				((pbpn)->Flags.f.DlgOldStatus)
#define bpnBPTMindex(bpn)				((bpn).TMindex)
#define pbpnBPTMindex(pbpn)				((pbpn)->TMindex)
#define bpnEnabled(bpn)					((bpn).Flags.f.fEnabled)
#define pbpnEnabled(pbpn)				((pbpn)->Flags.f.fEnabled)
#define bpnBPExtInfo(bpn)				((bpn).Flags.f.fExtInfo)
#define pbpnBPExtInfo(pbpn)				((pbpn)->Flags.f.fExtInfo)
#define bpnSymbolIzed(bpn)				((bpn).Flags.f.fSymbolized)
#define pbpnSymbolized(pbpn)			((pbpn)->Flags.f.fSymbolized)
#define bpnWarnedUnsupported(bpn)		((bpn).Flags.f.fWarnedUnsupp)
#define pbpnWarnedUnsupported(pbpn)		((pbpn)->Flags.f.fWarnedUnsupp)
#define bpnSqlBp(pbpn)					((pbpn).Flags.f.fSqlBp)
#define pbpnSqlBp(pbpn)					((pbpn)->Flags.f.fSqlBp)

// CV400 breakpoint structure
// This is a handle to the linked list manager which
// when locked gives an LPBPI
#define bpnBPhbpi(bpn)					(bpn).hbpi
#define pbpnBPhbpi(pbpn)				(pbpn)->hbpi

// This macro checks for a virtual BP
// It's an existing BP that has not been bound at Startup...
#define bpnBPVirtual(bpn)				(bpnBPhbpi(bpn) == (HBPI)0)
#define pbpnBPVirtual(pbpn)				(pbpnBPhbpi(pbpn) == (HBPI)0)

// This macro checks if an ambiguous BP has been resolved
#define bpnBPResolved(bpn)				((bpn).TMindex > AMB_STS_UNRESOLVED)
#define pbpnBPResolved(pbpn)			((pbpn)->TMindex > AMB_STS_UNRESOLVED)

// This macro gets/sets an associated group number with a breakpoint
#define bpnBPGroup(bpn)					((bpn).iGroup)
#define pbpnBPGroup(pbpn)				((pbpn)->iGroup)

// This macro gets/sets pass count
#define bpnPassCount(bpn)				((bpn).cPass)
#define pbpnPassCount(pbpn)				((pbpn)->cPass)

// BP type if pbpnLocationNode
#define bpnEbpt(bpn)					((bpn).ebpt)
#define pbpnEbpt(pbpn)					((pbpn)->ebpt)

// Initialization error
#define bpnInitError(bpn)				((bpn).idInitError)
#define pbpnInitError(pbpn)				((pbpn)->idInitError)

// Utitlity macros
#define bpnFileLineNode(bpn) \
	(((bpnType(bpn) == BPLOC) ||\
	  (bpnType(bpn) == BPLOCEXPRTRUE) ||\
	  (bpnType(bpn) == BPLOCEXPRCHGD)) &&\
	 (bpnLocType(bpn) == BPLOCFILELINE))

#define pbpnFileLineNode(pbpn)			(bpnFileLineNode(*(pbpn)))

#define bpnLocationNode(bpn) \
	(((bpnType(bpn) == BPLOC) ||\
	  (bpnType(bpn) == BPLOCEXPRTRUE) ||\
	  (bpnType(bpn) == BPLOCEXPRCHGD)))

#define pbpnLocationNode(pbpn)			(bpnLocationNode(*(pbpn)))

#define bpnExpressionNode(bpn) \
	(((bpnType(bpn) == BPLOCEXPRTRUE) ||\
	  (bpnType(bpn) == BPLOCEXPRCHGD) ||\
	  (bpnType(bpn) == BPEXPRTRUE) ||\
	  (bpnType(bpn) == BPEXPRCHGD)))

#define pbpnExpressionNode(pbpn)		(bpnExpressionNode(*(pbpn)))


// Prototypes
BOOL PASCAL ParseCV400Location(
	LPSTR Location,
	PBREAKPOINTNODE Target);

BOOL PASCAL ParseQC25Location(
	LPSTR Location,
	PBREAKPOINTNODE Target);

LPSTR FindNonQuotedChar(LPSTR sz, UINT ch);

BOOL FFilenameNeedsQuotes(LPCSTR szFile);

BOOL PASCAL ExtractCV400Context(
	LPCTSTR StartContext,
	PBPCONTEXT Context);

void PASCAL FnNameFromHsym(
	HSYM	hsym,
	PCXT	pcxt,
	LPSTR	lpstrName);

BOOL PASCAL ParseExpression(
	LPCTSTR Expression,
	PBREAKPOINTNODE Target);

BOOL PASCAL ParseWndProc(
	LPSTR WndProc,
	PBREAKPOINTNODE Target);

// Breakpoint node procs:

PBREAKPOINTNODE PASCAL AddBreakpointNode(
	PBREAKPOINTNODE NewNodeData,
	BOOL fReset,
	BOOL fQuiet,
	BOOL fRestoring,
	LPINT lpiErr);

BOOL PASCAL DeleteBreakpointNode(int BreakpointNodeIndex);

BOOL PASCAL DeleteBreakpointNode(PBREAKPOINTNODE pbpn);

int PASCAL ClearCV400Breakpoints(void);

int PASCAL ClearBreakpointNodeList(void);


/***********************************************************************

    BREAKPOINT HANDLER MSVC API

***********************************************************************/
BOOL            PASCAL BHBindBPList(VOID);
VOID            PASCAL BHUnBindBPList(BOOL fPerformingENC = FALSE) ;
VOID			PASCAL BHRememberBPDLLs(VOID) ;
PBREAKPOINTNODE PASCAL BHFirstBPNode(VOID) ;
PBREAKPOINTNODE PASCAL BHLastBPNode(VOID) ;
PBREAKPOINTNODE PASCAL BHLastBPCreated(VOID) ;
BOOL            PASCAL BHCreateBPHandle(PBREAKPOINTNODE,BOOL,BOOL,LPINT) ;
VOID 			PASCAL BHSetLastBPNode(PBREAKPOINTNODE) ;
VOID			PASCAL BHGotoBP(PBREAKPOINTNODE) ;
BOOL			PASCAL BHCanGotoBP(PBREAKPOINTNODE) ;


/***********************************************************************

    BREAKPOINT FILE HANDLER MSVC API

***********************************************************************/
BOOL            PASCAL BFHShowCodeBP(PBREAKPOINTNODE) ;
BOOL            PASCAL BFHShowBPNode(PBREAKPOINTNODE) ;
VOID            PASCAL BFHShowAllBPNode(VOID) ;
VOID            PASCAL BFHResetShowAllBPNode(VOID) ;
INT             PASCAL BFHGetLineBPIndex(LPSTR,INT,LPINT,BOOL fCheckDisabled = FALSE, UINT *pWidgetFlag = 0) ;
BOOL 			PASCAL BFHFindDoc(LPCSTR, CDocument **);

void PASCAL AdjustBreakpointLines(
	const CString &strDocFileName, int StartLine, int NumberLines,
	BOOL fAdded, BOOL fLineBreak);

void PASCAL DeleteBreakpointLinesInDoc(
	const CString &strDocFileName);

void PASCAL CementBreakpointLinesInDoc(
	const CString &strDocFileName);

void PASCAL BuildCV400Location(
	PBREAKPOINTNODE pBreakpoint,
	PSTR LocSpec, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem,
	BOOL Quote);

void PASCAL BuildCV400Expression(
	PBREAKPOINTNODE pBreakpoint,
	PSTR ExprSpec, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem);

void PASCAL BuildCV400LocationMessage(
	PBREAKPOINTNODE pBreakpoint,
	PSTR LocSpec, UINT Len,
	BOOL FullPaths, BOOL ToLower, BOOL ToOem);

void PASCAL FormatDisplayBP(
	PBREAKPOINTNODE pBreakpoint,
	PSTR DisplayBP, UINT DisplayLen);

BOOL PASCAL ToggleLocBP(
	void);

enum BPSetOpt { bplset, bplclear, bpltoggle, bplfind};

BOOL PASCAL SetEditorLocBP(BPSetOpt, PBREAKPOINTNODE * ppbpn = NULL, int line = -1);

UINT GetBPLineState(
    VOID);

VOID PASCAL EnableDisableLocBP(
	BOOL fEnable);

VOID PASCAL DisableAllBreakpoints(
	VOID);

void PASCAL HighlightAllBPNodes(
	BOOL Set);

void PASCAL MakeCV400BPCmd(
	PBREAKPOINTNODE pBreakpoint,
	PSTR CV400BPCmd, UINT CmdLen);

void SaveStatusFile ( char * pszMakefile );

void LoadStatusFile ( char * pszMakefile );

BOOL PASCAL SetCV400Breakpoint(
	PBREAKPOINTNODE bpNode,
	BOOL SetAtStartUp,
	BOOL fQuiet,
	LPINT lpiErr);

BOOL PASCAL HighlightBPNode ( PBREAKPOINTNODE pBpNode, BOOL Set );

struct _pbp;

BOOL PASCAL LoopExeGetCV400BPPacket(
	PBREAKPOINTNODE bpNode,
	_pbp *pBPPacket);

BOOL BHFIsValidWindowForBP(void);
void UpdateBPInViews(void);
void CheckBPsAtRestart(void);

BOOL BHFTypeSupported( WORD wBPType );
BOOL BHFTypeEnabled( WORD wBPType );

BOOL LoadBPReferencedClasses(void);

#endif	// _BREAKPTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\clw.h ===
#include "cl.h"

class CCallsView : public CMultiEdit {
	DECLARE_DYNCREATE(CCallsView)

	private:
		DLA 		m_dla;
		int			m_radixLast;
		BOOL		m_fShowBlank;
		UINT		m_WidgetFlags;

		BOOL		DispCallInfo( int );
		void		DumpHfme( HFME, int, WORD, char * );
		
	public:
		/* default constructor/destructor */
		CCallsView();
		virtual ~CCallsView();

		virtual DWORD GetHelpID() { return HID_WND_CALL_STACK; }

		virtual void ShowContextPopupMenu(CPoint pt);

		WORD 		CbGetLineBuf( DWORD, WORD, char *, PDLA &);
		DWORD		CLinesInBuf( void );
		void		DrawLineGraphics( CDC *, RECT &, DWORD );

		LRESULT	LTextProc( UINT, WPARAM, LPARAM );

		virtual BOOL FCanUseMarginSelect( void ) { return TRUE; }

	private:
        friend class CDebugPackage;

		// g_cRef is the count of instantiations of CTextView, used to
		// initialize g_pFontInfo which is the pointer to the CFontInfo
		// for this view type
		static UINT g_cRef;
		// Pointer to the font information for this view type
		static CFontInfo *g_pFontInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\colors.h ===
FMT_ELEMENT *pfmtelFromDocType(DOCTYPE doctype);
FMT_WINDOW  *pfmtcatFromDocType(DOCTYPE doctype);
FMT_ELEMENT *pfmtelForVarsWnd(UINT);
FMT_WINDOW *pfmtcatForVarsWnd(UINT);

// Text Windows
#define FMTEL_TEXT (0)	// Text
#define FMTEL_SELC (1)	// Selected text
#define FMTEL_BRKP (2)	// Breakpoint
#define FMTEL_CRNT (3)	// Current line

// Call Stack
#define FMTEL_CSHI (2)	// Highlight
#define FMTEL_CSSU (3)	// Superceded code

// Memory Window
#define FMTEL_MMHI (2)	// Highlight

// Register Window
#define FMTEL_RGHI (2)	// Register highlight

// Vars/Watch window.
#define FMTEL_VCHI (2)  // Variables/watch change highlight color.

// Disassembly window.
#define FMTEL_DASM (2)  // Assembly code in disassembly window.

// Number of predefined token classes - from colors.cpp
#define CPREDEFTOKCLS (10)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\cmgrnew.h ===
#ifndef CMGRNEW_H
#define CMGRNEW_H

#include "path.h"		// for CPath
#include "msgboxes.h"	// for MsgBoxType

#define DOUG_HACK // enable Doug Rosen's temp hacks

// Process ID.  Note that ULONG is used because it's (hoped to be)
// OS-independent; code shouldn't assume that a PID is actually exactly
// 4 bytes (it may be just 2).
typedef ULONG PID;

// StepN return codes
#define STEPN_NOERROR      0   // StepN with no error
#define STEPN_BREAK        1   // StepN with BP break
#define STEPN_NOENTRY      2   // StepN with no entry point
#define STEPN_BPFAILED     3   // StepN with not all BP applied
#define STEPN_FAILED       4   // StepN really failed.   

// Step return codes
#define STEPOUT_NOERROR    0   // Step out no error
#define STEPOUT_NOSOURCE   1   // Step out no source available
#define STEPOUT_NOCALLER   2   // Step out no calling function
#define STEPOUT_NOBPSET    3   // Step out cannot set BP

// Step to cursor return codes
#define STEPCUR_NOERROR    0   // Step to cursor no error
#define STEPCUR_NOCODE     1   // Step to cursor no code at line
#define STEPCUR_NOMOVE     2   // Step to cursor on actual line
#define STEPCUR_NOBPSET    3   // Step to cursor cannot set BP

#define SRCSTEPPING	0
#define ASMSTEPPING	1

// Timer ID for WM_TIMER messages
#define DBGCALLBACKTIMERID	1	// To dequeue debugger callbacks

// This is used for CV messages
#define SHOW_IMMEDIATE		0
#define SHOW_ASYNCHRONOUS   1
#define SHOW_REPORT			2

// Debugger Messages - Generic for ALL debugger windows

// For WU_UPDATEDEBUG the #defines below specify what lParam is
typedef enum {
	// lParam specifies what frame to use.  (See CallStack walking
	// for user)  If lParam is NULL, there is no context change.
	// Probably the result of updating a register, memory, or data
	// Upon updating after debuggee execution, this will point to
	// cxfIp
	wPCXF	= 0,

	// lParam is a rectangle to invalidate for repainting, this
	// will go away whent he newwatch replaces the watch and locals
	// windows.
	wRECT

} UPDATEDEBUGLPARAM;

typedef enum {
	// Sent when the debuggee has restarted and returned from initial
	// execution.  The window should reinitialize itself
	WU_INITDEBUGWIN	= WU_DEBUGGERMSGBASE,

	// Sent after the debuggee has returned from exeution or the UI
	// is being updated as the result of an edit in a debug window...
	// if wParam specifies the meaning of lParam see comments above
	// for values.
	WU_UPDATEDEBUG,

	// Sent when the debuggee has died.  Any debugger memory allocations
	// should be freed here.  After this message is processed, all CodeView
	// memory allocations will be freed.
	WU_CLEARDEBUG,

	// Sent when a MultiEdit window has been resized, or it's contents
	// require the scroll bar(s) range{s} to be updated.
	WU_UPDATESCROLLBARS,

	// Sent when a breakpoint has been added/deleted.
	// lParam should contain information about the BP (file, address, hbpt)???
	WU_BREAKPTCHANGE,

	// Sent when a debug function requires the address of the line
	// where the cursor is.  This is for Execute to cursor, toggle
	// breakpoint, set PC...  lParam contains a pointer to a GCAINFO
	// (description of struct below) packet to be filled in by the window.
	// If this packet is filled in the WndProc should return a gcafXXX enum
	// specified below.
	WU_GETCURSORADDR,

	// Sent when the current window should flush edits before the debuggee
	// is about to restart (only sent to the active debug window)
	WU_FLUSHEDITS,

	// Sent just before resuming execution of the debuggee.  When this message
	// is received, the window should save any data necessary to show
	// differences
	WU_FREEZEDATA,

	// Sent after the debuggee has returned from an edit & continue operation
	WU_UPDATEENC,

	// Place holder for last debugger message
	WU_DEBUGGERMSGMAX

} DEBUGGERMSGS;

// Values to be returned from wndprocs when replying
// to a WU_GETCURSORADDR message
typedef enum {
	// No address ad cursor location or not supported
	gcafNone,

	// Single specific address, addr packet filled in
	gcafAddress,

	// File/Address expression returned, must be parsed
	// to check for multiple occurances
	gcafExpression
} GCAF;

// Information returned by replying wndproc to
// WU_GETCURSORADDR message
typedef struct _gcainfo {
	ADDR	addr;			// Address of cursor (gcafAddress)
	char	szExpr[ 1024 ];	// A VERY large string to
							// reply (gcafExpression)
} GCAINFO;	// Get Cursor Address Information
typedef GCAINFO FAR *	PGCAINFO;

// Go
void PASCAL Go(HTHD,BOOL,BOOL);

void PASCAL StepAndGo(void);

int PASCAL Step(BOOL fOverCalls, STO sto);

// Go to the current cursor position
WORD PASCAL ContinueToCursor(BOOL fPassException, TCHAR * ptchGotoExpression);

// Step to the return address for the current function
WORD PASCAL StepToReturn(BOOL fPassException, int iStepMode );

// Move the instruction pointer to where the cursor is
BOOL PASCAL MoveIPToCursor(int iLine = -1);

// Process one OSDebug callback and queue its return code
void DoCallBackAndQueueReturn(void);

#ifdef _DEBUG
VOID ToggleHackFlipScreen(VOID);
#endif

BOOL TerminateDebuggee(void);

BOOL PASCAL ClearDebuggee(ULONG Reason);

VOID AsyncStopDebuggee(VOID);

BOOL TryingToAsyncStop(VOID);

BOOL PASCAL CheckEXEForDebug(LPCSTR lpszEXE, BOOL InANSI, BOOL fQuiet);

void LoadJITProject(void);

BOOL LoadDebuggee (LPTSTR	lszLocalExe,
				   LPTSTR	lszRemoteExe,
				   LPTSTR	lszDebuggeeArgs,
				   BOOL		fDebugActive,
				   ULONG	DebugActivePid,
				   HANDLE	DebugActiveEvent,
				   BOOL		fRestarting,
				   BOOL		fCrashDump);

BOOL FSpawnOrphan(HPID hpid, LPCTSTR lszRemoteExe, LPCTSTR lszCmdLine,
	LPCTSTR lszRemoteDir, PID FAR *lppid);

BOOL RestartDebuggee(LPTSTR lszLocalExe, LPTSTR lszRemoteExe,
	LPTSTR lszDebuggeeArgs, BOOL fCrashDump);

void SetUpNotification(struct dbg _far *pWDbg);

BOOL DEBUGGlobalInit(VOID);	// Perform 1-time debugger initialization

BOOL DEBUGInitialize (BOOL fQuickRestart = FALSE);

VOID DEBUGDestroy(VOID);	// UnInitialize debugger

BOOL DebuggeeAlive(void);

BOOL DebuggingWin32s(void);

BOOL PASCAL StoppedBecauseOfBrk(void);

// Get name of executable to run.  This is usually the same as the target
// to be built, but if the target is a DLL, this will be different.
IDE_EXPORT EXEFROM GetExecutableFilename(PSTR executable, UINT size);

// Get the name of the last document (source) window that was active.
IDE_EXPORT CDocument * GetLastDocWin();

// Get the name of the current debugging target.  This is usually the same
// as the target to be built, but it may be differernt if you did a
// project-less build and have since then loaded other source files.
BOOL PASCAL GetDebugTarget(PSTR target, UINT cch);

// Set the name which will be returned by later calls to GetDebugTarget.
VOID PASCAL SetDebugTarget(PCSTR target);

VOID PASCAL GetDebuggeeCommandLine(CString& CommandLine);

BOOL PASCAL FFindDLL(LPCTSTR szDLL, CString& strDLLPath, BOOL fQuiet = FALSE);
BOOL PASCAL LoadAdditionalDLLs(
	CStringList *pslDLLs,
	BOOL fStarting,
	BOOL fQuiet = FALSE,
	POSITION *piPos = NULL);

// Return filename portion of a remote path
LPTSTR LtszRemoteFileFromPath(LPCTSTR ltszRemotePath);

// Mappings between local & remote filenames
//VOID BuildMpStrLocalDllStrRemoteDll(CString strLocalDllList, CString strRemoteDllList);
BOOL MapRemoteFileToLocal(LPCTSTR ltszRemote, CString& strLocal);
VOID MapLocalFileToRemote(LPCTSTR ltszLocal, CString& strRemote);

// #defines for UpdateFlags passed to UpdateDebuggerState
#define UPDATE_CPU			0x0001
#define UPDATE_LOCALS		0x0002
#define UPDATE_WATCH  		0x0004
#define UPDATE_SOURCE  		0x0008
#define UPDATE_DEBUGGEE		0x0010
#define UPDATE_NOSETFOCUS	0x0020
#define UPDATE_MEMORY		0x0040
#define UPDATE_CALLS        0x0080
#define UPDATE_DISASSY      0x0100
#define UPDATE_BREAKPT      0x0200
#define UPDATE_ENC			0x0400	 // Indicates special update mode after ENC

// UPDATE_ALLDBGWIN no longer includes the source window.  We do
// not want to update the source window when data edits occur, only
// when we need to redisplay the PC or breakpoints, so use that
// seperately
#define UPDATE_ALLDBGWIN (UPDATE_CPU|UPDATE_LOCALS|UPDATE_WATCH\
						 |UPDATE_MEMORY|UPDATE_CALLS|UPDATE_DISASSY|UPDATE_BREAKPT)
#define UPDATE_ALLSTATES (UPDATE_ALLDBGWIN|UPDATE_SOURCE|UPDATE_DEBUGGEE)


// Sends messages to appropriate windows to update their displays according
// to the value of UpdateFlags
void PASCAL UpdateDebuggerState(WORD UpdateFlags);

// Forces a repaint of all debug windows with the given cxf
VOID PASCAL UpdateAllDebugWindows(struct CXF FAR * pcxf);

//Set in an newly opened file, visual breakpoints and current line
#ifdef DOUG_HACK
void SetDebugLines(CDocument * pTextDoc, BOOL ResetTraceInfo, BOOL fBPOnly = FALSE);
void PASCAL AdjustDebugLines(CDocument * pTDoc, int StartLine, int NumberLines, BOOL fAdded, BOOL fLineBreak, BOOL fWhiteSpaceOnly);
#else
void SetDebugLines(BOOL ResetTraceInfo);
void PASCAL AdjustDebugLines(int StartLine, int NumberLines, BOOL fAdded, BOOL fLineBreak);
#endif // DOUG_HACK

BOOL PASCAL CheckExpression(
	LPCTSTR Expr, int Radix, int Case);

void PASCAL AnimatePeekMessage(
	void);

void PASCAL UpdateRadix(
	BOOL Decimal);

void PASCAL UpdateHexCase(
	BOOL fUpper);

BOOL PASCAL DebuggeeRunning(
	void);

void PASCAL SetDebuggeeRunning(
	BOOL Runnning);

void PASCAL ZapInt3s(void);


// Errors returned by the Unassemble function
typedef enum {
	DIS_NOERROR,		// Unassembling was OK
	DIS_NOEXE,			// Couldn't find a corresponding EXE
	DIS_NOMODULE,		// Couldn't find the corresponding module
	DIS_AMBIGUOUS,		// Ambiguous module
	DIS_NOLINEADDR,		// No code for this line
	DIS_NOFIXUP			// Couldn't get fixup for address
	} DIS_RET ;

// Unassemble the given line in a formatted buffer
DIS_RET PASCAL Unassemble(int,UINT,LPSTR far *) ;

// Get the current line and delta for a given address
BOOL PASCAL GetLineOffsetFromAddr(
	void far *lpaddr,
	int *pLine,
	long *pOffset) ;

// Get the current address for a given line and delta
BOOL PASCAL GetAddrFromLineOffset(
	int Doc,
	UINT uLine,
	UOFFSET uoff,
	void far *lpaddr,
	BOOL fAddrli) ;

// Erases the current CS:IP and returns the doc that owned the CS:IP
CDocument *PASCAL EraseTraceLine(VOID) ;

// Restore the trace line, to be used with EraseTraceLine()
VOID PASCAL RestoreTraceLine(CDocument *, BOOL fEditing = FALSE) ;

// Sets the current caller hilite
void PASCAL SetCallerLine(CDocument *, int, BOOL );

// Erases the current caller hilite
void PASCAL EraseCallerLine(void);

// Debugger message box: give IDE focus & display message box
int DebuggerMsgBox(
	MsgBoxTypes	MsgBoxType,
	LPCTSTR		pszMessage,
	UINT		nButtonIDs		= DEFAULT_BUTTONS,
	UINT		nHelpContext	= DEFAULT_HELP);

// Debugger message box: give IDE focus & display message box
int DebuggerMsgBox(
	MsgBoxTypes	MsgBoxType,
	int			nMessageID,
	UINT		nButtonIDs		= DEFAULT_BUTTONS,
	UINT		nHelpContext	= DEFAULT_HELP);

extern BOOL
SetCrashDumpDebugging(
	BOOL	fCrashDump
	);

#endif	// CMGRHIGH_H (whole file)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\datatip.h ===
// datatip.h : header file for CDataTip class

#ifndef __DATATIP_H__
#define __DATATIP_H__

class CDataTip : public CWnd
{
// Implementation
public:
	CDataTip();

	static CDataTip *m_pTip;
	static int m_x;
	static int m_y;

	virtual void DestroyTip();

	static CDataTip *GetTip() { return m_pTip; }
	static int GetX() { return m_x; }
	static int GetY() { return m_y; }
	static void SetX(int x) { m_x = x; }
	static void SetY(int y) { m_y = y; }

	//{{AFX_MSG(CDataTip)
	afx_msg void OnPaint();
	afx_msg void OnTimer(UINT nTimerID);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDisableModal(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#endif // __DATATIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\dam.h ===
class CGoToAddress;

// This value is the maximum length of a symbol.  It should
// probably be in shapi.h since this is determined by the OMF
// the current size of a symbol is an unsigned 8-bit value,
// which is 255 and we add 1 in for a zero terminator
#define	cbSymMax	256

typedef struct _mdf {				// Data structure associated
									// with each opened file
    HSF         hsf;				// The OMF file handle
    long        clnBuf;				// Number of lines in the file
	char FAR *      lszFile;		// Name of file that we opened
	BYTE FAR *      lpbFile;		// Pointer to buffer containing
									// translated file
	long FAR *      mpLineToOff;	// mapping of line numbers to
									// buffer offsets.
	BOOL		bRetry;				// We will search for ths file corresponding to this hsf again if this bit is set.	
} MDF;
typedef MDF FAR *       LPMDF;

typedef struct MFL {
	HSF		hsf;
    WORD	wLine;
} MFL; // MapFileLine information

typedef enum {
    metNone,																	
    metSource,
    metDisasm,
    metLabel,
	metFileName
} MET; // Map Entry Type

typedef struct DML {
    MET 	met;
	ADDR	addr;			// address of line information
	MFL		mfl;			// file/line information (source line)
}DML;       // Diasm/Mixed Line

typedef DML FAR *	PDML;

// structure definition for window info-block  - to be made global

typedef struct dmi {
	BOOL	fAnnotate;		// annotate disassembly with source code
							// (mixed mode)
    BOOL    fDoCodeBytes;	// do code bytes display in disassembly?
    BOOL    fLowerCase;		// display mnemonics && regs in lower case
    BOOL    fDoSymbols;		// display symbols in disassembly
    BOOL    fDontDraw;		// To suppress redundant painting
    BOOL    fNextAddrSet;	// cbGetLine buf set the addr @idmlInvalid
    BOOL    fNewMap;		// Did a new map get set for this window?

    ADDR    addrCSIP;       // The address CS:IP
	ADDR	addrCall;		// Cached address of viewed context for
							// displaying callstack selection

	ADDR	addrSegLim;		// Addr of the current limit info for
							// caching OSDGetObjectLength info

    // Caching Information

    DWORD   lnLastCSIP;     // The last line with the CS:IP bar

    // Mapping Information
    DWORD   lnMapStart;     // The top of the map
    DWORD   lnEnd;          // The end of the (virtual) file.
    int    	idmlInvalid;    // The index of the start of invalid
                                // region in map
	int		cdml;			// Number of DMLs allocated to rgdml
    PDML	rgdml; // The map for the disasm/mixed lines
} DMI;		// Disasm/Mixed Info

// Smallest number of DMLs allowed
#define cdmlMin		50

// Main wndprocs
extern DWORD FAR PASCAL DAMLTextWndProc( HWND, UINT, WPARAM, LPARAM );

// Drag-drop support.
void DAMDropNewAddress(LPSTR lpstr, DWORD cchData);

// New APIs for file handling based on HSFs
BOOL PASCAL DAMFLoadHSFFile( HSF );
void PASCAL DAMUnloadAll( void );
BOOL PASCAL DAMFGetLine( HSF, long, int, char *, UINT ctchTab );
LPMDF   DAMLpmdfFromHSF( HSF hsf );

class CDAMView : public CMultiEdit {
	DECLARE_DYNCREATE(CDAMView)

	private:
		DMI			m_dmi;
		DLA			m_dla;
		UINT		m_WidgetFlags;
		BOOL		m_bAskForFile;

		// WM_xxx message intercepters (DAMAPI.CPP)
		BOOL	FDoScrollChar( WPARAM, LPARAM * );
		BOOL	FDoVScroll( WPARAM, LPARAM );

		// Map Management APIs (DAMMAP.CPP)
		int		FillAsmFromNext( BOOL, PDML, PDML );
		void	FillEntryFromPrev( int );
		void  	FillAsmFromPrev( int );
		void  	FillMixedFromPrev( int );
		int  	FillEntryFromNext( int );
		int  	ShiftMap( int );
		BOOL	SetMap( HSF, WORD, PADDR, BOOL, WORD );
		BOOL	SetMapFromFile( HSF, WORD, WORD );
		BOOL	SetMapFromAddr( PADDR, BOOL );
		MET 	RangeFromPdml( PDML, PADDR, PADDR );
		BOOL 	PreDraw( int, BOOL );
		void 	SetMapToTop( void );

		// Misc utility APIs (DAMUTIL.CPP)
		void	ShiftTopLine( DWORD );
		UOFFSET GetFixedOff( ADDR );
		void	AlignAddrWithSource( PADDR, PADDR );
		void	ResetMap( DWORD );
		BOOL	FSetCursorAtAddr( PADDR );
		void	SetAttributes ( PDML );
		long	SetAddress( PADDR );
		BOOL 	LineToAddr ( HSF, WORD, PADDR, BOOL );
		UOFFSET SegmentLength ( ADDR );
		void	GotoTopOrEnd( BOOL );
		void	GotoTop();
		void	GotoEnd();
		BOOL	SetCsip( PADDR, BOOL bForce = FALSE );
		void	DestroyMap( void );
		GCAF	GcafGetCursorAddr( PGCAINFO );
		void	ResizeMapToWindow( void );
		void	ChangeOpts( void );

	public:
		CDAMView();
		~CDAMView();

		virtual DWORD	GetHelpID() { return HID_WND_DISASSEMBLY; }

		virtual void	ShowContextPopupMenu(CPoint pt);
		virtual BOOL	CanDropText( void ) { return TRUE; }
		virtual BOOL	SupportsDataTips( ) const { return TRUE; }
		virtual BOOL	InsertFromDataObject(COleDataObject * data, const CPoint & point);
		virtual BOOL	FCanUseMarginSelect( void ) { return TRUE; }
		virtual void	GotoLine( void );

		void		UpdateView( PCXF );

		// Edit manager overrides
		WORD 		CbGetLineBuf( DWORD, WORD, char *, PDLA & );
		DWORD		CLinesInBuf( void );
		void 		DrawLineGraphics( CDC *, RECT &, DWORD );

		LRESULT		LTextProc( UINT, WPARAM, LPARAM );
		BOOL		OkToAskForFile() const
		{	return m_bAskForFile; }
			
	private:
        friend class CDebugPackage;
		friend class CGoToAddress;
		// g_cRef is the count of instantiations of CTextView, used to
		// initialize g_pFontInfo which is the pointer to the CFontInfo
		// for this view type
		static UINT g_cRef;
		// Pointer to the font information for this view type
		static CFontInfo *g_pFontInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\dbg.h ===
/****************************************************************************
	Aug 1993 Split codemgr.c into dbg.h, dbgosd.c, and dbgmisc.c
	[MarkBro]

			 Revision J.M. Dec 1991
			 This file is derived from CV400
			 SYSTEM   layer ( SYSTEM.C LOAD.C CONFIG.C )

			 CODEMGR  code management
			 OSDEBUG  CallBack
			 CONFIG   Dll configuration
			 LOAD     OSDebug loading

****************************************************************************/
#ifndef __DBG_H__
#define __DBG_H__

/*
#include "ansistub.h"
#include "util.h"
#include "makeeng.h"
#include "mk_make.h"
#include "outwin.h"
#include "excep.h"
#include "main.h"
#include "sushutil.h"

#include "..\..\include\project.h"

#include "tlui.h"

// Special low-level functions
#ifndef _WIN32
#include "toolhelp.h"
#endif

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <malloc.h>


#include "cvexefmt.h"

#include "cmgrhigh.h"
#include "brkpt.h"
#include "breakpts.h"
#include "cmgrlow.h"
#include "askpath.h"
#include "outwin.h"

// Prototypes for SYSTEM.C Functions
#include "sy.hmd"

#include "codemgr.h"
#include "extern.h"

// NEW EXE header information
#include "newexe.h"

//prototypes for CL.C functions
#define MENU void
#define MENUITEM void
#include "cl.h"
*/

// Properties
#define P_VarExpr                   128
#define P_VarType                   129
#define P_VarValue                  130

void PASCAL ResetCV400Globals(void);
void PASCAL UpdateUserEnvir(unsigned short fReq);

// 4th caviar merge : 2 following constants
#define GRANUL                  0x1000  // 4K block size as a default...
#define MAX_BLOCK               0x0008  // 8 blocks of 4K memory

typedef void (LOADDS PASCAL *QUIT)(UINT);
typedef HDEP (LPFNSYM MMALLOCMEM) (UINT);
typedef VOID (LPFNSYM LPFNFREEHUGE) (LPV);

void ProgLoad(HPRC,HPID,HTID,LSZ,BOOL) ;

#define cmpHtid   0
#define cmpTid    1
#define cmpLpthd  2

#define cmpHpid   0
#define cmpPid    1
#define cmpTitle  2
#define cmpName   3

#define cbMaxTitle (8)

#define SF_NOERROR      0
#define SF_NOFILE       1
#define SF_NODOCAVAIL   2
#define SF_DONTOPENFILE 3

#define SHpADDRFrompCXF(pCXF)  SHpADDRFrompCXT(SHpCXTFrompCXF(pCXF))

// Prototypes
VOID PASCAL UnInitOSD(void) ;
BOOL PASCAL InitOSDDlls(void) ;
BOOL PASCAL DllLoad(int DLLtype) ;
XOSD PASCAL DoCallBack (LPCBP lpcbp);
void PASCAL StopChild(void) ;
void PASCAL InitCallBack(void);

DIS_RET PASCAL GetHsfFromDoc(CDocument *,HSF FAR *) ;
int PASCAL SearchFileFromModule(LPSTR, CDocument **, HSF, BOOL *, UINT);
BOOL PASCAL LoadFileFromModule(LPSTR,LPCSTR,CDocument **,HSF,BOOL *,UINT) ;
void TextDocCallback(CDocument *, UINT);

void PASCAL RetrySearchFile();	// Forces search file to forget cache information.
BOOL GetCurrentSource(LPSTR,WORD,ILINE *,SHOFF *,HSF FAR *) ;
void nsWaitForDebugEvent(void) ;
LOCAL int PASCAL near StartExec(void) ;
BOOL FSetUpTempBp(PADDR paddr,HTHD hthd,int BpType) ;
BOOL FSetUpTempSourceLineBp(LSZ, ILINE, HTHD);
void GoUntil(PADDR paddr, HTHD hthd, int BpType, BOOL fGoException,
	BOOL fFlipScreen) ;
BOOL PASCAL KillDebuggee(ULONG Reason);
BOOL PASCAL FakeAsyncKillDebuggee(ULONG Reason);
BOOL PASCAL AsyncKillDebuggee(ULONG Reason);

void AuxAddr(PADDR);
BOOL FAddrFromRibbonEdit(ADDR*);
BOOL FAddrFromSz(char *, ADDR*);
void BreakStatus(int);
BOOL GetSourceFrompADDR( LPADDR, LPSTR, WORD, LONG FAR *, UOFFSET FAR *, HSF FAR *);
int PASCAL BPNbrAtAddr(LPADDR,UOFFSET,BOOL fCheckDisabled = FALSE, UINT *pWidgetFlag = 0 );
BOOL PASCAL InitOSD(void) ;
BOOL PASCAL DebuggeeInCallBack(void);
CString GetDebugPathName(CDocument* pDoc);
BOOL LoadNonDiskDocument(LPCTSTR szName, CDocument** ppDoc);
BOOL FIsSqlInproc();
BOOL FIsActiveProjectDebuggable( BOOL *pUnknownTarget, BOOL *pIsExternal, BOOL *pTryToBuild, uniq_platform *pPlat );

#ifdef __cplusplus

template <class TYPE> class Protect
/*++

Abstract:

	A little template-class to make sure resources (handles) are properly
	deallocated.

	Use as:

	{
		HANDLE				hBla;
		Protect <HANDLE>	protect (hBla);

		.
		.
		.

		// Protect <HANDLE>::~Protect  automatically called to destruct hBla
	}

	Protect <HANDLE>::~Protect(
		)
	{
		if (m_h)
		{
			CloseHandle (m_h);
			m_h = NULL;
		}
	}

--*/
{
	TYPE&	m_h;
	
  public:
  
	Protect(
		TYPE&	h
		) : m_h (h)
	{
	}

	~Protect(
		);
};

#endif // __cplusplus


#if defined (TARGMACPPC)

typedef void (*SF)(TLUI *);

extern void QCEMSetup(HWND hwndOwner);
extern BOOL FMacQuit(void);
extern BOOL FMacDeleteEM(void);



#endif

#endif // __DBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\dbgnew.h ===
#ifndef DBGNEW_H
#define DBGNEW_H

/* New - taken from makeeng4.cpp */
IDE_EXPORT EXEFROM GetExecutableFilename ( PSTR executable, UINT size );

/* Taken from qlimits.h */
#define MAX_LINE_SIZE       2048
#define MAX_EXPRESS_SIZE    256
#define TMP_STRING_SIZE     MAX_LINE_SIZE + 60
#define ENVSTR_SIZE         1024
#define MAX_MSG_TXT         200
#define MAX_VAR_MSG_TXT     400
#define DOS_EXT_SIZE        6
#define CURSOR_WIDTH        2
#define MAX_TOOL_NB         16
#define MAX_STD_TOOL_NB     5
#define MAX_TOTAL_TOOLS     (MAX_TOOL_NB + MAX_STD_TOOL_NB)

/* Taken from util.h */
//ANSI/ASCII compatible isspace() test
// We really should use isspace() since it's faster.
#define whitespace(c) ((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\r')

/* Taken from meclass.h */
#define axMax       (256 + 128) // This should be plenty

/* taken from qcqp.h */
BOOL StopDebugConfirm(BOOL fFailSilently = FALSE);
BOOL EnsureActiveProjectOrJIT(BOOL & fUnknownTarget);

/* taken from menu.cpp */
UINT CommandIdEnabled(UINT CommandId, BOOL& Enabled);

/* from textview.h */
#define DATATIP_TIMER   101

/* new thingies */

#define NUM_ME_WINDOWS  6

typedef VOID (FAR PASCAL *OWNERDRAWCALLBACK)(HWND hDlg, LPDRAWITEMSTRUCT lpDIS);

HGLOBAL     HandleFromString(const CString & str);
HGLOBAL     HandleFromString(LPCTSTR str);
BOOL        StartDialog(UINT rcDlgNb,DLGPROC dlgProc);
BOOL        StartDialogParam (UINT rcDlgNb, DLGPROC dlgProc, LPVOID lpParam, UINT helpID);
BOOL        DefaultDialogHandler(HWND hDlg, unsigned message, UINT wParam, LONG lParam);
BOOL PASCAL fScanAnyLong(LPCTSTR lpszSource, long *plDest, long lMin, long lMax);
void PASCAL freeze_view (void);
BOOL        FileExist(LPCSTR fileName);
BOOL PASCAL ValidFilename( LPCSTR lpszName, BOOL fWildOkay );
char *      NormalizePath (LPSTR lpProjDir, LPSTR lpSearchDir, LPSTR lpFileDir, LPSTR lpPath, int cbPath);
void        EnsureFinalBackslash(LPSTR path);
BOOL        FsSetCurDir(LPCTSTR pathName);
BOOL        IsNonLocalDecimalPoint();
BOOL        InitDebugPackage(HINSTANCE);
void        InitDefaults(void);
void        InitDefaultRunDebugParams(RUNDEBUGPARAMS *);
BOOL        DefaultDialogHandler(HWND, UINT, UINT, LONG);
BOOL PASCAL HandleStandardOwnerDrawListBox(HWND, UINT, WPARAM, LPARAM, UINT, OWNERDRAWCALLBACK);
void PASCAL EnsureDebugWindow(int winType);
void        EnsureShellNotMinimized( void );
HWND        GetShellWindow( void );
long PASCAL MainWndProc(HWND, UINT, UINT, LONG);
HWND        GetDebugWindowHandle(UINT);
CView *     CreateView(int);
CView *     GetCurView(void);
BOOL PASCAL OpenDebugWindow(UINT);
BOOL        FEvalExpr(char *szExpr, char *szOut, int cbOut);
void        RemoveSideEffectsExpr(char *szExpr);

// Internal error handling
VOID PASCAL     SetGlobalError( ERR_TYPE errnum, BOOL fForce ) ;
ERR_TYPE PASCAL CheckGlobalError( BOOL fClear ) ;
VOID PASCAL     ClearGlobalError( VOID ) ;

// This function extracts a suitable top level parent window
HWND PASCAL _SushiGetSafeOwner(CWnd* pParent);

// INI file stuff
void HammerOleRegKey( void );
void HammerLoadExportsRegKey( void );
IDE_EXPORT void MarkIniFileAsDirty(void);

#endif  // DBGNEW_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\dbggrid.h ===
// dbggrid.h : header file
//
#ifndef __DBGGRID_H__
#define __DBGGRID_H__

/////////////////////////////////////////////////////////////////////////////
// CDbgGridWnd view

// This class is the debugger specific sub-class of CTreeGrid.
// It handles things like dockableness, refresh, clipboard, which are common
// to all the debugger windows.

class CPersistWatchTab;	 // Forward declaration.
class CPersistVarsTab;	 // Forward declaration.
class CWatchRow;		 // Forward declaration.
class CTM;			// forward declaration.
class CBaseVarsView;

class CDragInfo; //forward decl

class CWRInfo 	// Information about watch rows.
{
public:
	CString strName;
	CString strValue;
	BOOL bExpanded;
};

void AFXAPI ConstructElements(CWRInfo * pWRInfo, int nCount);
void AFXAPI DestructElements(CWRInfo * pWRInfo, int nCount);

typedef CArray<CString, CString&> CStrArray;
typedef CArray<CWRInfo, CWRInfo&> CWRInfoArray;

class CDbgGridWnd : public CTreeGridWnd
{
	DECLARE_DYNAMIC(CDbgGridWnd);

public:
	CDbgGridWnd(CString wndName, CBaseVarsView * pView = NULL, BOOL bEditable = FALSE);
	virtual ~CDbgGridWnd();
	typedef CTreeGridWnd  CBaseClass;

// Attributes
public:
	const CString& GetTabName( ) { return m_strTabName; }

	// Values are always editable, this function only tells you if
	// a) the names can be edited.
	// b) if the rows can be deleted from this window by user action.
	BOOL  IsEditable( ) const { return m_bEditable; }
	CBaseVarsView * GetView() const { return m_pView; }
	int GetNameColWidth() const;

	// Color handling.
	inline void SetChangeHighlightColors(COLORREF crText, COLORREF crBkground)
	{	m_crChangedText = crText; m_crChangedBk = crBkground; }
	inline void GetChangeHighlightColors(COLORREF &crText, COLORREF &crBkground)
	{	crText = m_crChangedText; crBkground = m_crChangedBk; }
	
	BOOL CanDropText() { return m_bEditable && DebuggeeAlive() && !DebuggeeRunning(); }
	BOOL CanMoveText() { return FALSE; }
	void GetDragSlopRect( const CPoint& pt, CRect & rc );

// Operations
public:
	// Persistence related stuff.
	virtual void RememberSettings(CPersistWatchTab&);
	virtual void RememberSettings(CPersistVarsTab&);
	virtual void RestoreSettings(CPersistWatchTab&,int nColumnWidth);
	virtual void RestoreSettings(CPersistVarsTab&,int nColumnWidth);
	
	virtual int  GetDefaultNameWidth();
	virtual void MakeWindowAlive(BOOL bAlive, int nNameColWidth);

	virtual CTGNewRow *CreateNewRow( );
	virtual void OnEnterNew(CString);

	virtual BOOL AddNewWatch(CString);
	virtual BOOL AddNewWatch(CString, CWatchRow*&);

	virtual void Expand(CTreeGridRow *, BOOL bRedraw = TRUE);
	virtual void Collapse(CTreeGridRow *, BOOL bRedraw = TRUE);
	virtual BOOL ProcessKeyboard(MSG *pMsg, BOOL bPreTrans = FALSE);

	virtual BOOL InsertTopLevelRow(CTreeGridRow *, BOOL bRedraw = TRUE);
	virtual BOOL DeleteTopLevelRow(CTreeGridRow *, BOOL bRedraw = TRUE);

	virtual void ClearCurEntries( );
	virtual void DirtyRow(CTreeGridRow *pRow, int tf);	
	// expansion persistence related functions.
	BOOL IsStrInArray(CStrArray& rgStr, const CString&);
	void RememberPrevState(CWRInfoArray& rgWRInfo);
	void RefreshUsingPrevState(CWRInfoArray& rgWRInfo);

		
	// Clipboard related functions.
	virtual HANDLE CFTextHandle( );
	virtual BOOL ImportWatchFromBuffer(LPCSTR p, DWORD size);

public:
	virtual CTM * GetSelectedTM();
	virtual void ShowContextPopupMenu(POPDESC* ppop, CPoint pt);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDbgGridWnd)
	protected:
		virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

	// CTreeGridWnd override
	virtual BOOL BeginDrag(UINT nFlags, const CPoint& point);

// Implementation
protected:
	CString m_strTabName;
	CBaseVarsView * m_pView; // Can be NULL if grid is not contained within view.
	COLORREF m_crChangedText ; // colors to be used to do change highlighting.
	COLORREF  m_crChangedBk;

	BOOL m_bEditable:1;
	// Only those windows that are alive track the values from the debugger.
	BOOL m_bAlive:1;	
	BOOL m_bDragging:1;
	BOOL m_bDockable:1;

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CDbgGridWnd)
	afx_msg void OnEditClear( );
	afx_msg void OnEditCopy( );
	afx_msg void OnEditCut( );
	afx_msg void OnEditPaste( );
	afx_msg void OnUpdateEditClear(CCmdUI *pCmdUI);
	afx_msg void OnUpdateEditCopy(CCmdUI *pCmdUI);
	afx_msg void OnUpdateEditCut(CCmdUI *pCmdUI);
	afx_msg void OnUpdateEditPaste(CCmdUI *pCmdUI);
	//}}AFX_MSG
	virtual LRESULT OnUpdateDebug(WPARAM, LPARAM);
	virtual LRESULT OnClearDebug(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CLocalsWnd window

class CLocalsWnd : public CDbgGridWnd
{
// Construction
public:
	CLocalsWnd(CBaseVarsView * pView);
	virtual ~CLocalsWnd();
	typedef CDbgGridWnd CBaseClass;
		
// Attributes
public:
		
// Operations
public:
	void UpdateEntries( );
   	
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLocalsWnd)
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL m_bContextValid :1	;
	BOOL m_bProlog:1;

	CXF	 m_lastCxf;

	// Generated message map functions
protected:
	//{{AFX_MSG(CLocalsWnd)
	//}}AFX_MSG
	virtual LRESULT OnUpdateDebug(WPARAM, LPARAM);
	virtual LRESULT OnClearDebug(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CThisWnd window

class CThisWnd : public CDbgGridWnd
{
// Construction
public:
	CThisWnd(CBaseVarsView * pView);
	virtual ~CThisWnd();
	typedef CDbgGridWnd CBaseClass;

// Attributes
public:

// Operations
public:
	void ExpandBaseClasses(CWatchRow *);
	void UpdateThis();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CThisWnd)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(CThisWnd)
	//}}AFX_MSG
	virtual LRESULT OnUpdateDebug(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif // __DBGGRID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\dbgpkg.h ===
//#define PACKAGE_DEBUG       90
#define PACKET_DEBUG        1

////////////////////////////////////////////////////////////////////////////
// Packages must provide exactly one instance of a sub-class of CPackage.
//

#ifdef DEBUGGER_AUTOMATION
class CAutoObj;
#endif // DEBUGGER_AUTOMATION

class CDebugPackage : public CPackage
{
    private:

       CFormatInfo                   m_FormatInfo;
       CFormatInfo                   m_FormatInfoDefault;

    private:

        void    InitColors( void );

    protected:
    	// Package interface map
    	BEGIN_INTERFACE_PART(DbgPkg, IDbgPkg)
            INIT_INTERFACE_PART(CDebugPackage, DbgPkg)

            STDMETHOD_(BOOL, DebuggeeAlive)(void);
            STDMETHOD_(BOOL, DebuggeeRunning)(void);
			STDMETHOD_(void *, DbgDAMHsfFromFile)(LPCTSTR);
            STDMETHOD_(BOOL, GetExecutablePath)(PSTR);
			STDMETHOD_(BOOL, CanShowDataTip)(void);
			STDMETHOD(EvaluateExpression)(LPTSTR szText, BOOL bFromSelection, LPTSTR szResult, ULONG cb);
			STDMETHOD(SetDebugLines)(CDocument *pDoc, BOOL ResetTraceInfo);
			STDMETHOD(AdjustDebugLines)(CDocument * pDoc, int StartLine, int NumberLines, BOOL fAdded, BOOL fLineBreak, BOOL fWhiteSpaceOnly);
			STDMETHOD(DeleteBreakpointLinesInDoc)(LPCTSTR sz);
            STDMETHOD_(BOOL, IsENCProjectFile)(CPath *ppath);
            STDMETHOD(VTestDebugActive)(BOOL *bActive);

		END_INTERFACE_PART(DbgPkg)

		BEGIN_INTERFACE_PART(DLLInfo, IDLLInfo)
			INIT_INTERFACE_PART(CDebugPackage, DLLInfo)

			STDMETHOD(DiffDLLs)(ULONG hTarget, CPtrList &listDLLs, INT *piRow, UINT *pidMsg);
			STDMETHOD(GetDLLCount)(ULONG hTarget, int *piCount);
			STDMETHOD(InitDLLList)(ULONG hTarget, CPtrList &listDLLs);
			STDMETHOD(SaveDLLList)(ULONG hTarget, CPtrList &listDLLs);
		END_INTERFACE_PART(DLLInfo)

		DECLARE_INTERFACE_MAP()

    public:
    	CDebugPackage();

 		GetApplicationExtensions(SApplicationExtension** ppAppExts);
 		
    	// Add flags here when overriding applicable package virtuals.
    	enum { PKS = (PKS_IDLE | PKS_PRETRANSLATE | PKS_COMMANDS |
                      PKS_NOTIFY | PKS_INIT | PKS_QUERYEXIT | PKS_SERIALIZE |
                      PKS_INTERFACES | PKS_FORMAT
#ifdef DEBUGGER_AUTOMATION
											| PKS_AUTOMATION
#endif // DEBUGGER_AUTOMATION
											) };

#ifdef DEBUGGER_AUTOMATION
		// OLE automation support
		virtual LPDISPATCH GetPackageExtension(LPCTSTR szExtensionName);
		virtual IDispatch* GetAutomationObject(BOOL bAddRef);
//		virtual void AutomationObjectReleased(); // called by Automation object when it goes away
#endif // DEBUGGER_AUTOMATION

        // Dockable window interface.  These functions must be overridden only if
        // the package provides new kinds of dockable windows, or default toolbars.
    	virtual HGLOBAL     GetDockInfo();
    	virtual HWND        GetDockableWindow(UINT nID, HGLOBAL hglob);
    	virtual HGLOBAL     GetToolbarData(UINT nID);
    	virtual HICON       GetDockableIcon(UINT nID);
    	virtual BOOL        AskAvailable(UINT nID);
//		virtual void        LoadGlobalAccelerators();
    	virtual BOOL        OnInit();
        virtual BOOL        OnNotify(UINT id, void *Hint, void *ReturnArea);
    	virtual DWORD       GetIdRange(RANGE_TYPE rt);
    	virtual void        OnExit();
        virtual BOOL        OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
    	virtual void        SerializeWorkspaceSettings(CStateSaver &pStateSave, DWORD dwFlags);
        virtual void        AddOptDlgPages(class CTabbedDialog* pOptionsDialog, OPTDLG_TYPE type);
        virtual void        AddGoToItems(CGoToDialog *pDlg);

    //	Fonts/Colors Interface
    	virtual CFormatInfo *GetFormatInfo ();
    	virtual void        GetDefaultFormatInfo (CFormatInfo& fiDefault);
    	virtual void        OnFormatChanged ();
    	virtual void        OnFontChange ();
    	virtual void        OnColorChange ();

    // Registry settings save interface.  All settings that need to be saved in
    // the registry should be written here.  (Read them anytime.)
    	virtual void SaveSettings();
		virtual BOOL IsVisibleProjectCommand(UINT nID, GUID *pGuids, UINT cGuidCount);

    /*
    // Hook for idle processing; works just like the one in MFC's CWinApp.
    	virtual BOOL OnIdle(long lCount);

    // Hook for message dispatching; works just like the one in MFC's CWinApp.
    	virtual BOOL PreTranslateMessage(MSG* pMsg);
    */

    	void    OnDebugGo                       ();
    	void    OnDebugJITGo                    ();
    	void    OnExecuteTarget                 ();
        void    OnExceptions                    ();
        void    OnThreads                       ();
		void	OnFibers						();
        void    OnDebugRegFloat                 ();
        BOOL    OnDebugStackSet                 (UINT nIDCmd );
        void    OnDebugSourceAnnotate           ();
        void    OnDebugShowCodeBytes            ();
        void    OnToggleMemoryBar               ();
        BOOL    OnDebugMemorySet                (UINT nIDCmd );
        void    OnDebugRestart                  ();
        void    OnDebugStop                     ();
        void    OnDebugToCursor                 ();
        void    OnDebugTraceInto                ();
        void    OnDebugTraceFunction            ();
        void    OnUpdateTraceFunction			(CCmdUI* pCmdUI );
        void    OnDebugStepOver                 ();
        void    OnDebugSrcTraceInto             ();
        void    OnDebugSrcStepOver              ();
        void    OnDebugStopAfterReturn          ();
        void    OnBreakpoints                   ();
        void    OnUpdateClearBreakpoints        (CCmdUI* pCmdUI );
        void    OnClearBreakpoints              ();
        void    OnQuickWatch                    ();
        BOOL    OnDebugBreak                    (UINT nCmdId );
        void    OnDebugRadix                    ();
        void    OnNextMemWinFmt                 ();
        void    OnPrevMemWinFmt                 ();
        void    OnDisableAllBreakpoints         ();
        void    OnUpdateDisableAllBreakpoints   (CCmdUI* pCmdUI );
        void    OnDebugSetIP                    ();
        void    OnDebugActive                   ();
        BOOL    OnToggleBreakpoint              (UINT);
        void    OnEnableDisableBreakpoint       ();
        void    OnUpdateActivateSrcWnd          (CCmdUI* pCmdUI );
        void    OnActivateSrcWnd                (UINT nCmd );
        void    OnUpdateToggleSrcWnd            (CCmdUI* pCmdUI );
        void    OnToggleSrcWnd                  (UINT nCmd );
        void    OnUpdateDebugRadix              (CCmdUI* pCmdUI );
        void    OnUpdateDebugOptions            (CCmdUI* pCmdUI );
        void    OnUpdateToggleBreakpoint        (CCmdUI* pCmdUI );
        void    OnUpdateEnableDisableBreakpoint (CCmdUI* pCmdUI );
        void    OnRemoteDebugger                ();
        void    OnUpdateDebugActive             (CCmdUI* pCmdUI );
        BOOL    OnDebugGoPostMsg                (UINT);
        void    OnDebugRestartPostMsg           ();
        BOOL    OnDebugStopPostMsg              (UINT);
        void    OnDebugToCursorPostMsg          ();
        BOOL    OnDebugTraceIntoPostMsg         (UINT);
        void    OnDebugTraceFunctionPostMsg     ();
        BOOL    OnDebugStepOverPostMsg          (UINT);
        void    OnDebugSrcTraceIntoPostMsg      ();
        void    OnDebugSrcStepOverPostMsg       ();
        BOOL    OnDebugStopAfterReturnPostMsg   (UINT);
        void    OnUpdateProjectExecute          (CCmdUI* pCmdUI );
#ifdef CODECOVERAGE
        void    OnCodeCoverageToggle            ();
        void    OnCodeCoverageClear             ();
#endif
        void    OnGotoCurrentInstruction        ();
        void    OnUpdateGotoCurrentInstruction  (CCmdUI* pCmdUI );
		void	OnAttachToActive				();
		void	OnDebugUpdateImage				();
		void	OnDebugUpdateImagePostMsg		();
		void	OnDebugUpdateImageToggle		();
		void	OnUpdateDebugUpdateImage		(CCmdUI* pCmdUI );
		void	OnUpdateDebugUpdateImageToggle	(CCmdUI* pCmdUI );
		void	OnModuleView					();
		void	OnUpdateModuleView				(CCmdUI* pCmdUI );
		
    	DECLARE_MESSAGE_MAP()
};

/*
////////////////////////////////////////////////////////////////////////////
// This is the view class for the simple docking window

class CDebugDockWnd : public CDockablePartView
{
    public:

    	CDebugDockWnd();

    	        LRESULT WindowProc( UINT, WPARAM, LPARAM );
    	        void    OnNcDestroy();
    	afx_msg void    OnPaint();
    	
    	DECLARE_MESSAGE_MAP()
};
*/

HINSTANCE GetResourceHandle();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\debugopt.h ===
/////////////////////////////////////////////////////////////////////////////
// CDebugOpt dialog

class CDebugOpt : public CDlgTab
{
// Construction
public:
	CDebugOpt();	// standard constructor

// Dialog Data
	//{{AFX_DATA(CDebugOpt)
	enum { IDD = IDDP_DEBUG };
	CString	m_szExpr;
	BOOL	m_fAnnotate;
	BOOL	m_fCodeBytes;
	BOOL	m_fFixedWidth;
	BOOL	m_fHexMode;
	BOOL	m_fLive;
	BOOL	m_fOLERPC;
	BOOL	m_fRaw;
	BOOL	m_fShowArgs;
	BOOL	m_fFPU;
	BOOL	m_fShowTypes;
	int		m_iItemsPerLine;
	BOOL	m_fSymbols;
	int		m_iFormat;
	BOOL	m_fEnableJit;
	BOOL	m_fReturnValues;
	BOOL	m_fUnicodeStrings;
    BOOL    m_fENCDebugging;
	BOOL	m_fLoadExports;
	//}}AFX_DATA

// Implementation
public:
	virtual BOOL	OnInitDialog();
	virtual BOOL	ValidateTab();
	virtual void	CommitTab();

	BOOL GetJitState();
	VOID SetJitState(BOOL);

protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CDebugOpt)
	afx_msg void OnClickedFixedwidth();
	afx_msg void OnClickedJit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CTLOpt dialog

class CTLOpt : public C3dDialog
{
// Construction
public:
	CTLOpt();
    ~CTLOpt();

// Dialog Data
	//{{AFX_DATA(CDebugOpt)
	enum { IDD = IDD_TRANSPORT_SELECT };
	//}}AFX_DATA

public:
	int 			m_cPlatforms;
	int				m_iPlatform;
	uniq_platform *	m_rgPlatforms;
	UINT *			m_rgiTL;
    BOOL            m_fConnectNow;

private:
	CComboBox *		m_plstPlatform;
	CListBox *		m_plstTransport;
	CButton *		m_pbutSetup;

// Implementation
public:
	virtual BOOL	OnInitDialog();

protected:

	// Generated message map functions
	//{{AFX_MSG(CTLOpt)
	afx_msg void OnHelp();
	afx_msg void OnClickedSetup();
	afx_msg void OnPlatformChange();
	afx_msg void OnTransportChange();
    afx_msg void OnClickedConnectNow ();
    afx_msg void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\extern.h ===
#ifndef EXTERN_H
#define EXTERN_H

extern char ExecutablePath[_MAX_PATH];

// temp variables
extern char szPath[_MAX_PATH];
extern char szDrive[_MAX_DRIVE];
extern char szDir[_MAX_DIR];
extern char szFName[_MAX_FNAME];
extern char szExt[_MAX_EXT];

// Currently highlighted trace line (F8/F10)
extern TRACEINFO TraceInfo;

//extern BOOL fIsLaunchingDebuggee;

//Handle to instance data
extern HINSTANCE	hInst;

//Temp variables for various modules
extern char szTmp[TMP_STRING_SIZE];

// from dbg.h - will be pulled in later
extern char is_assign;

//Autotest mode for test suites
extern BOOL AutoTest;

// Whether or not to ask the user when the EXE we're about to debug has no symbols.
extern BOOL g_fPromptNoSymbolInfo;

//Empty string
extern char const szNull[1];

extern UINT FAR CDECL LOADDS CVsprintf(LSZ, LSZ, ... );
extern int PASCAL BPResolveDlg( PHTM , int, BOOL );
extern EESTATUS PASCAL CVParseBind ( PHTM phtm, PCXT pcxt, int iRadix,
        char fCase, char fForce, char FAR * sz);
extern EESTATUS PASCAL CVParseBindCxtl ( PHTM phtm, PCXT pcxt, int iRadix,
        char fCase, char fForce, PHCXTL phcl, char FAR * sz);

extern void FAR * PASCAL LOADDS LDSFmalloc(size_t);
extern void PASCAL LOADDS LDSFfree(void FAR *);
extern void FAR * PASCAL LOADDS LDSFrealloc(void FAR *, size_t);

extern BOOL     fIgnoreAmbigBPs;
extern int      fBlocking;
extern BOOL     fMultiDebug;
extern char     is_assign;

//typedef unsigned long HPID;
//typedef unsigned long HTID;

extern	HPID	Hpid;
extern	HTID	Htid;


// Memory management functions
extern void FAR * PASCAL LOADDS LDScvw3_fmalloc(size_t) ;
extern void FAR * PASCAL LOADDS LDScvw3_frealloc(void FAR *,size_t) ;
extern void FAR * PASCAL LOADDS LDScvw3_ffree(void FAR *) ;


extern unsigned short LOADDS PASCAL LDSbUnlockMb(HMEM) ;
extern HLLE LOADDS PASCAL LDSLLHlleGetLast(HLLI) ;
extern void LOADDS PASCAL LDSLLHlleAddToHeadOfLI(HLLI,HLLE) ;
extern BOOL LOADDS PASCAL LDSLLFRemoveHlleFromLl(HLLI,HLLE) ;
extern void LOADDS PASCAL LDShfree(void _HUGE_ *) ;
extern UINT LOADDS PASCAL SYReadFar(UINT,LPB,UINT) ;
extern LONG LOADDS PASCAL SYSeek(UINT,LONG,UINT) ;

#if defined(OSDEBUG4)
extern UINT LOADDS PASCAL SYProcessor(DWORD) ;
#else
extern UINT LOADDS PASCAL SYProcessor(VOID) ;
#endif

extern VOID LOADDS PASCAL SYClose(UINT hfile) ;
extern UINT LOADDS PASCAL SYOpen(LSZ) ;
extern LONG LOADDS PASCAL SYTell(UINT hfile);
#if defined(OSDEBUG4)
extern UINT PASCAL SYFindExeFile(LSZ, LSZ, UINT, LPVOID, PFNVALIDATEEXE);
extern VOID PASCAL DLoadedSymbols(SHE, HPID, LSZ);
extern BOOL PASCAL SYGetDefaultShe(LSZ, SHE *);
#endif

extern BOOL FAR PASCAL SYFindDebugInfoFile (PSEARCHDEBUGINFO);

// Path string manipulations
extern void FAR LOADDS PASCAL CVSplitPath(LSZ,LSZ,LSZ,LSZ,LSZ) ;
extern void FAR LOADDS PASCAL CVSearchEnv(LSZ,LSZ,LSZ) ;
extern LSZ  FAR LOADDS PASCAL CVFullPath(LSZ,LSZ,UINT) ;
extern void FAR LOADDS PASCAL CVMakePath(LSZ,LSZ,LSZ,LSZ,LSZ) ;
extern UINT FAR LOADDS PASCAL CVStat(LSZ,LPCH) ;
extern UINT FAR LOADDS CDECL  CVsprintf(LSZ,LSZ,...) ;
extern void _HUGE_ * LOADDS PASCAL LDShalloc(long,size_t) ;

extern void FAR * PASCAL LOADDS LDSFmalloc(size_t);
extern void FAR * PASCAL LOADDS LDSFrealloc(void FAR *,size_t);
extern void PASCAL LOADDS LDSFfree(void FAR *);
extern void ModLoad(LSZ,BOOL) ;
extern BOOL LOADDS PASCAL SYFHasSource(HPID,LPADDR) ;
extern "C" BOOL cvw3_minit(void);
extern "C" void cvw3_mcleanup(void);
extern BOOL PASCAL SHFInit(void);
extern int fBlocking ;
extern unsigned long ulChildFlags ;
extern fEnvir fEnvirGbl ;
extern CVF FAR * lpcvf;

// CVEXTRAS items that need C linkage for access by vcnt.lib
extern char is_assign ;

// ERRORWIN.C
extern VOID PASCAL DBGOutputDebugString(LPSTR,BOOL) ;

// CL.C prototypes
extern PCXF LOADDS PASCAL CLGetFuncCXF(PADDR paddr,PCXF pcxf) ;

// CVEXTRAS.C externs and prototypes
extern ushort ArrayDefault ;
extern ADDR asmaddr ;

// DAMFILE.C
extern void DAMSaveDebugFile( LPCSTR, HSF );

// From BREAKPTS.C
extern int PASCAL ClearCV400Breakpoints(void) ;

//extern BOOL FAR fIsLaunchingDebuggee;

extern CXF cxfIp ;                     // Global context
extern char FAR DebugMessage[256];

// SYSTEM.C prototypes and variables
extern void FAR CDECL LOADDS CVDisconnect( void ) ;
extern void _HUGE_ * PASCAL LOADDS LDShalloc(long,size_t) ;
extern SHF FAR * lpshf;

extern void PASCAL LOADDS LDShfree(void _HUGE_ *) ;
extern void SYSetContext(HPRC,HTHD,BOOL) ;
extern void UpdateIn386Mode(void) ;
extern EPI epiDef ;
extern void SYContinue(HPRC) ;
extern void SYStop(HPRC);
extern void SYPause(HPRC);
extern void SYInstallVirtual(HPID,LSZ,BOOL) ;
extern BOOL PASCAL BPMsgBpt ( BOOL, LPMSGI );

extern BOOL fCanKillChild ;
extern HEM	hemCurr ;		// handle on current execution model
extern HEM	hnmCurr ;		// handle on current non-native execution model
extern HTL	htlCurr ;		// handle on current transport layer
extern HLLI llprc ;         // handle on processes linked list
extern LPDBF lpdbf ;        // Pointer to DBF entry structure


extern BOOL OmfLoaded;
extern BOOL fInFindLocalDlg;
extern CRITICAL_SECTION csDbgTimerSet; // guards fDbgTimerSet
extern BOOL fBPsBoundSuccessfully;
extern HMEM 	hprcCurr ;	// handle on current process
extern LPPRC	lpprcCurr ;	// pointer to current process in list
extern HMEM 	hthdCurr ;	// handle on current thread in list

extern PEXF pEXF ;

extern HLLI	qCallBack;				// Our internal notifications linked list
extern HLLI qCallBackReturns;		// Return codes from processed notifications

extern DWORD dwFuncTimeOut;
extern char FAR AlternatePath[255] ;

extern BOOL PASCAL LOADDS RECompare(char FAR *,char FAR *) ;
extern int  PASCAL TDCompare(LPTHD lpthd,unsigned long FAR *lpl,LONG l) ;
extern void AddThread(HPID,HTID) ;
extern void set_addrs(void) ;

extern BOOL FSetTLName(LPSTR szNewDLLName);
extern LPSTR SzGetTLName(void);
extern void QCTLSetup(HWND hwndOwner);
extern void ActivateRemoteDebugger(void);

extern HLLI hlliFME;
extern int fBPCCInExe;
extern char fCaseSensitive;
extern fEnvir fEnvirGbl ;

extern void fetch_error(ushort, char FAR *);
extern char FAR *fetch_signal(int);

extern int PASCAL BPNbrAtAddr(LPADDR,UOFFSET);

extern BOOL fLoadingJitProject;

//RunDebug Params
extern RUNDEBUGPARAMS runDebugParams;

extern ADDR dump_start_address;
extern char flip_or_swap;
extern fEnvir fEnvirGbl;

extern VOID PASCAL ControlExecDebuggee(WORD, WORD);

extern BOOL fExcepListInitialized;

extern void ActivateRemoteDebugger(void);
extern void PrereadFile();

extern UINT WU_QUERYJIT;
extern UINT WU_BEGINJIT;

// Last document of type DOC_WIN that had the focus
extern CIDEDoc  *pLastDocWin;

extern char		fCaseSensitive;

extern VOID PASCAL UpdateAllDebugWindows(PCXF) ;

interface IDBGProj;

extern PSRCUTIL         gpISrc;
extern LPBUILDSYSTEM    gpIBldSys;
extern LPBUILDPLATFORMS gpIBldPlatforms;
extern LPSOURCEQUERY    gpISrcQuery;
extern LPOUTPUTWINDOW	gpIOutputWindow;
extern IProjectWorkspace *gpIProjectWorkspace;
extern IPkgProject		 *gpActiveIPkgProject;
extern IDBGProj			 *gpActiveIDBGProj;

// Use this to get the interfaces, doing a QI if necessary
extern IPkgProject		*GetActiveIPkgProject(void);
extern IDBGProj			*GetActiveIDBGProj(void);

extern CDebug   *pDebugCurr;
extern BOOL     fVisTestPresent; // Is the Visual Test package present.
extern BOOL     fVisTestDebugActive; // Is a Visual Test debug session active currently.
extern void     UpdateMultiEditScroll( CMultiEdit * );

// Full Screen Data
extern FULLSCREENDATA FullScreenData;

//Debugger window view #
extern CIDEView *	pViewCpu;
extern CIDEView *	pViewMemory;
extern CIDEView *	pViewCalls;
extern CIDEView *	pViewDisassy;
extern CIDEView *	pViewNewWatch;
extern CIDEView *	pViewNewLocals;

//CrLf
extern char const CrLf[3];

extern HWND g_hWndShell;

//Handle to edit control
extern HWND hwndActiveEdit;

// Handle to currently activated child
extern HWND hwndActive;

//Main window frame
extern HWND hwndFrame;

// If you use these, you have to have a local copy.
extern UINT WM_VIEWACTIVATE;

extern DWORD g_dwDragDelay;
extern DWORD g_dwDragScrollInset;
extern DWORD g_dwDragScrollDelay;
extern DWORD g_dwDragScrollInterval;
extern DWORD g_dwDragMinRadius;

// clipboard formats
extern UINT g_cfTMText;
extern UINT g_cfColSelect;

#endif	// EXTERN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\excep.h ===
// Field widths for listbox, INCLUDING terminating NULLs
#define cchExcepNumber	9
#define cchExcepName	42
#define cchExcepAction	26

// Width for a string containing all three of the above, separated by tabs
#define cchExcepAll		(cchExcepNumber + cchExcepName + cchExcepAction)

#define iPlatformGeneric	((UINT)-1)
#define IsForCurrentPlatform(id)	((BOOL)(pDebugCurr->GetPlatform()==id)||id==iPlatformGeneric)

// Structure for storing the exceptions
typedef struct {
	DWORD	dwExceptionCode;		// Exception number
	char	Name[cchExcepName];		// Exception description
	int		iAction;				// Exception action 
									// (0-1 = index of string in combobox)
	UINT	iPlatformId; 			// Platform for exception
									// iPlatformGeneric == all platforms,
									// user added
} EXCEPTION_OBJECT;


// Exception actions (Action field of EXCEPTION_OBJECT)
#define EX_ACTION_1STCHANCE		DLG_Exception_1stChance - DLG_Exception_Action_First
#define EX_ACTION_2NDCHANCE		DLG_Exception_2ndChance - DLG_Exception_Action_First

void CopyListbox(HWND hDlg, UINT id);

BOOL GetExceptionInfo(
	BOOL FirstException,
	BOOL fSystemOnly,
	DWORD *pdwExceptionCode,
	LPSTR Name,
	UINT cchName,
	UINT *piAction,
	UINT *piPlatformId);

void GetExceptionDescription(DWORD dwExceptionCode, CString& strDescription);

int GetExceptionAction(DWORD dwExceptionCode);

void MakeExceptionObject(EXCEPTION_OBJECT *pObject, DWORD dwExceptionCode,
	LPCSTR Name, int iAction, UINT iPlatformId);

void UnmakeExceptionObject(EXCEPTION_OBJECT *pObject, DWORD *pdwExceptionCode,
	LPSTR Name, int *piAction, UINT *piPlatformId);

void MakeExceptionString(EXCEPTION_OBJECT *Object, LPSTR Buffer, int cch);

BOOL FAR PASCAL EXPORT DlgException(HWND, unsigned, UINT, LONG);

VOID InitProcessExceptions(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\fonts.h ===
#ifndef _fonts_h_
#define _fonts_h_

#define FIRST_CHAR(lb)		(((lb) << 8) + (0x40))
#define LAST_CHAR(lb)		(((lb) << 8) + (0xFC))
#define NORMALIZE_LEAD(lb)	(unsigned short)((lb) - (0x81))
#define NORMALIZE_TRAIL(tb)	(unsigned short)((tb) - (0x40))

// CFontInfo - holds all the information about a font needed by the view classes to draw text,
// position the caret etc.
class CFontInfo
{
	// Data Members
	public:
		// Font Information
		LOGFONT		m_lf;
		HFONT		m_hFont;
		TEXTMETRIC	m_tm;								
		BOOL 		m_fFixedPitchFont;					// Are we displaying a fixed-pitch font?
		int 		m_rgcxSBWidths[NASCII_WIDTHS];		// Array of ASCII widths (-1 indicates lead byte)
		int 		*m_rgrgcxTrailTables[NLEAD_BYTES];	// Table of pointers (indexed by lead byte)
														// to table of widths (indexed by trail byte)
	// Operations
	private:
		int *rgiLoadTrailWidths(const unsigned char chLead);
		void InitializeFontInfo(const LOGFONT &lf);
		void DestroyFontInfo(void);

	public:
		// Constructor
		CFontInfo(const LOGFONT &lf)
			{ InitializeFontInfo(lf); }

		// Destructor
		~CFontInfo()
			{ DestroyFontInfo(); }

		// Replace the information in a CFontInfo with a new font
		void ChangeFontInfo(const LOGFONT &lf)
			{ DestroyFontInfo(); InitializeFontInfo(lf); }

};

#endif // ! _fonts_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\eetm.h ===
#ifndef __EETM_H__
#define __EETM_H__
// This file contains the basic EE TM structure encapsulations.
// The hope is that a similar interface can be provided by
// encapsulating the EE.

class CTM;
typedef CTypedPtrArray<CObArray, CTM*> CTMArray;

#define htmNil ((HTM)NULL)
extern struct CXF CxfWatch( ); 

// To allow for overloading on different types of CodeView
// HANDLES we define an enumeration which is used as
// an extra argument.

enum  HANDLE_TYPE { IS_HTM, IS_HSYM };

class CTM : public CObject
{
	protected:																	
		DECLARE_DYNAMIC(CTM);

	public:
		// Return values from the Refresh function.
		enum RES_REFRESH  { SAME_TYPE,  TYPE_CHANGED  };  
	public:
		virtual ~CTM ( );
	// Interface function.
	public:
		// Properties of this TM.
		virtual BOOL	IsExpandable() const { return FALSE; }
		virtual BOOL 	IsNameEditable( ) const { return FALSE; }
		virtual BOOL    IsValueEditable( ) { return FALSE; }
		virtual BOOL	IsSynthChildNode( ) const { return FALSE; }
		virtual BOOL	HasSynthChild( ) const { return FALSE; }

		// Is the value valid or has an error occured.
		virtual BOOL	IsValueValid( ) const { return FALSE; }
		virtual BOOL	DidValueChange( ) const { return FALSE; }
		virtual BOOL	CouldParseName() const { return FALSE; } 

		// Does this TM correspond to a data value.
		// Types and functions will return FALSE.
		virtual BOOL	IsDataTM( ) const { return FALSE; }	
		
		virtual BOOL	IsClass() const { return FALSE; }
		virtual BOOL	IsTypeIdentical(CTM *) { return FALSE; }
		// Did the last eval have any side effects?	
		virtual BOOL 	HadSideEffects( ) const { return FALSE; }

		virtual CString	GetName( ) = 0 ;
		virtual CString GetExpr( ) = 0 ;
		virtual CString GetValue( ) = 0 ; 
		virtual CString GetType( ) = 0;

		virtual CString GetEditableValue( ) { return GetValue (); }

		// Should be called only if IsExpandable is true.
		virtual BOOL GetTMChildren(CTMArray& ) = 0;
		virtual DWORD GetChildCount() = 0 ; 
		virtual CTM * GetTMChild(int childNo) = 0;
		virtual CTM * GetSynthChildTM( ) = 0;

		virtual BOOL  GetBCIA(PHBCIA) { return FALSE; }
		virtual void  FreeBCIA(PHBCIA) { };

		virtual RES_REFRESH	Refresh( ) { return SAME_TYPE; }
		virtual VOID	Restart( ) { };

		virtual BOOL  ModifyValue( const CString& ) { return FALSE; }
};

class CRootTM : public CTM
{
	public:
		CRootTM(LPCSTR lpszRootName, BOOL bNoFuncEval = FALSE);
		CRootTM( HIND  handle, HANDLE_TYPE  );
		virtual ~CRootTM ( );

		virtual BOOL  IsExpandable ( ) const;
		virtual BOOL  IsNameEditable( ) const;
		virtual BOOL  IsValueEditable( );
		virtual BOOL  IsSynthChildNode( ) const;
		virtual BOOL  HasSynthChild(  )  const;
		virtual BOOL  IsValueValid( ) const;
		virtual BOOL  DidValueChange( ) const { return m_bValueChanged; }
		virtual BOOL  CouldParseName() const;
		virtual BOOL  IsDataTM() const;

		virtual BOOL  IsClass() const;
		virtual BOOL  IsTypeIdentical(CTM *);
		virtual BOOL  HadSideEffects( ) const;

		virtual CString GetName ( );
		virtual CString GetExpr ( );
		virtual CString GetValue ( );
		virtual CString GetValueInRadix(int radix);
		virtual CString GetExprSansFormat();

		virtual CString GetEditableValue( );
		virtual CString GetType ( );
		virtual BOOL GetTMChildren(CTMArray&);
		virtual DWORD GetChildCount();
		virtual CTM * GetTMChild(int nChild);
		virtual CTM * GetSynthChildTM( );

		virtual BOOL  GetBCIA(PHBCIA);
		virtual void  FreeBCIA(PHBCIA);

		virtual RES_REFRESH  Refresh();
		virtual VOID	Restart();

		virtual BOOL ModifyValue(const CString& str);

	protected:
		BOOL		m_bNameTM : 1 ;			// Was this TM created by passing in a name.
		BOOL		m_fValEditableCache : 1;
		BOOL		m_fExpandedTM : 1;		
		BOOL		m_fValueCacheValid : 1;
		BOOL		m_fNameCacheValid : 1;
		BOOL		m_fValEditableCacheValid : 1;
		BOOL		m_fTypeCacheValid : 1;
		BOOL		m_bCheckedForFunc:1;	// Make function calling more robust.
		BOOL		m_bHasFunctionCall:1;
		BOOL		m_bNoFurtherEval:1;
		BOOL		m_bNoFuncEval:1;
		BOOL		m_bHadSideEffects:1;	// TRUE if last eval caused side-effects.
		BOOL		m_bValueChanged:1;     // TRUE if the value changed during the 
										   // last refresh.

		HTM			m_htm;
		HTM 		m_htmSaved;
		CString		m_cstrValueCache;
		CString		m_cstrNameCache;
		CString		m_cstrTypeCache;
		EESTATUS	m_eestatus;
		int			m_radix;

		EESTATUS RebindAndEvaluate();
		inline void InvalidateCaches(); 
		inline void CommonInit( ) ;
#if _DEBUG
		virtual void Dump(CDumpContext& dc) const;
#endif

	protected:
		DECLARE_DYNAMIC(CRootTM);
};

void CRootTM::InvalidateCaches()
{
	m_fValueCacheValid = FALSE;
	m_fValEditableCacheValid = FALSE;
	m_fTypeCacheValid = FALSE;
	m_bValueChanged = FALSE;
}

void CRootTM::CommonInit( )
{
	m_eestatus = EENOERROR;
	m_htmSaved = htmNil;
	m_bCheckedForFunc = FALSE;
	m_bHasFunctionCall = FALSE;
	m_bNoFurtherEval = FALSE;
	m_bNoFuncEval = FALSE;
	m_bHadSideEffects = FALSE;
	m_radix	= ::radix;
}

////////////////////////////////////////////////////////////////////////////////
// CReturnTM

class CReturnTM : public CTM
{
	public:
		CReturnTM (LPCSTR szName, LPCSTR szValue, LPCSTR szType = "");
		CReturnTM (const CReturnTM&);

		virtual ~CReturnTM () {};

		// Is the value valid or has an error occured.
		virtual BOOL	IsValueValid( ) const
			{ return m_fValueValid; }

		virtual CString	GetName ()
			{ return m_strName; }

		virtual CString	GetType ()
			{ return m_strType; }

		virtual CString	GetValue ()
			{ return m_strValue; }

		virtual CString	GetExpr ()
			{ return m_strExpr; }

		virtual BOOL GetTMChildren(CTMArray&)
			{ ASSERT (FALSE); return FALSE; }

		virtual DWORD GetChildCount()
			{ ASSERT (FALSE); return 0; }
		
		virtual CTM * GetTMChild(int nChild)
			{ ASSERT (FALSE); return NULL; }

		virtual CTM * GetSynthChildTM( )
			{ ASSERT (FALSE); return NULL; }

	private:
		BOOL	m_fValueValid;
		CString	m_strName;
		CString	m_strValue;
		CString	m_strType;
		CString	m_strExpr;

	protected:
		DECLARE_DYNAMIC(CReturnTM);
};
	
#endif	// __EETM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\idedoc.h ===
class CIDEView;


////////////////////////////////////////////////////////////
//	CIDEDoc

class CIDEDoc : public CPartDoc
{
	DECLARE_DYNCREATE(CIDEDoc);

public:
	CIDEDoc() {};
	~CIDEDoc() {};

	// data
public:
	CIDEView *	m_pFirstView;

private:
	UINT		m_docType;

	// methods
public:
	UINT 	GetDocType(void) { return m_docType; }
	void	SetDocType(UINT docType) { m_docType = docType; }

#ifndef NO_VBA
	DECLARE_DISPATCH_MAP();
#endif	// NO_VBA
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\javadbg.h ===
//
// javadbg.h
//
// Miscellaneous Java debugger header

#ifndef __JAVADBG_H__
#define __JAVADBG_H__

size_t LOADDS PASCAL JavaGetDebuggeeBytes(HTM hTM, size_t cb, void FAR* bBuff, PFRAME pFrame);

#endif // __JAVADBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\keycheck.h ===
#ifndef KEYCHECK_H

#define KEYCHECK_H	1

#ifdef _DEBUG

#define	KEYENTRY				long	nKEY;

#define	KEYSET(ptr, key) ((ptr) -> nKEY = key)
BOOL AuxPrintf(
	LPSTR text,
	...);

#define	KEYCHECKRET(ptr, key, ret)	\
if(!(ptr) || ((ptr) -> nKEY != key)) \
{ _KeyError(__FILE__, __LINE__); return ret;}

#define	KEY0CHECKRET(ptr, key, ret)	\
if((ptr) && ((ptr) -> nKEY != key)) \
{ _KeyError(__FILE__, __LINE__); return ret;}

#define	KEYCHECK(ptr, key)	\
if(!(ptr) || ((ptr) -> nKEY != key)) { _KeyError(__FILE__, __LINE__); }

#define	KEY0CHECK(ptr, key)	\
if((ptr) && ((ptr) -> nKEY != key)) { _KeyError(__FILE__, __LINE__); }

void	_KeyError(LPSTR pszFileName, UINT nLine);
#else

#define	KEYENTRY
#define	KEYSET(ptr, key)

#define	KEYCHECKRET(ptr, key, ret)
#define	KEY0CHECKRET(ptr, key, ret)
#define	KEYCHECK(ptr, key)
#define	KEY0CHECK(ptr, key)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\ideview.h ===
class CIDEDoc;

////////////////////////////////////////////////////////////
// CIDEView

class CIDEView : public CPartView
{
	DECLARE_DYNCREATE(CIDEView)

public:

	// Constructors, destructors

	CIDEView();
	virtual			~CIDEView() {}

	UINT	m_nID;					// save the window ID for use w/ dockables.

	// methods
	CIDEDoc * 	GetDocument(void) const { return (CIDEDoc*)m_pDocument; }
	UINT		GetDocType(void) const { return GetDocument()->GetDocType(); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\lnklst.h ===
BOOL ListUpdateObject(DWORD index, int listId, LPSTR string, int cch);
BOOL ListGetObject(DWORD index, int listId, LPSTR string);
BOOL ListDeleteObject(DWORD index, int listId);
BOOL ListInsertObject(DWORD index, int listId, LPSTR string, int cch);
BOOL ListAddObject(int listId, LPSTR string, int cch);
DWORD ListGetCount(int listId);
void FreeList(void);
BOOL EmptyList(int listId);
BOOL InitList(int listId);
BOOL ListCopy(int newId, int oldId, LPSTR buffer, UINT cch);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\gotoitem.h ===
#ifndef _GOTOITEM_H_
#define _GOTOITEM_H_

// Helper: return True if pActiveView is a valid CTextView pointer
BOOL FValidPTextView(CPartView * pActiveView);
// Helper: return True if current active view is a valid CTextView pointer
BOOL FValidCurTextView(CGoToDialog * pDlg);
// Helper: returns dialogs current active view if it is a CTextView, otherwise NULL
CMultiEdit *PCurTextView(CGoToDialog * pDlg);

////////////////////////////////////////////////////////////
// CGoToLine

class CGoToLine : public CGoToItem
{

public:
	ILINE m_ilineGoTo;  // computed in CanGoTo, used in OnGoTo;

public:

	// ctor
	CGoToLine(CGoToDialog * pDlg);

	// ***Initialization. These functions are used to initialize the Go To
	// dialog. They will be called when the dialog is invoked but may
	// actually be called at any time.

	// REQUIRED: Return the string to show in the Go To What listbox

	virtual const TCHAR * GetItemString();

	// ***Callbacks. These functions are called as the user manipulates the Go To
	// dialog or active editor view

	// Called when the item is selected in the Go To What listbox,
	// and at CGoToDialog startup and reactivation.
	// CGoToDialog will call CanGoViewActive after returning from this
	// call, so let it handle situational enabling/disabling

	// Note that this function needs to be able to tolerate a NULL m_pDlg->m_pActiveView
	// or one of the incorrect type. It should set what it can and leave other controls empty.

	// Do not put up error messages or dialogs during this function, as it can be called when focus
	// is changing. If you need to check a state that might bring up such a message it would be better
	// to enable the goto button and check at CanGoTo or OnGoTo rather than doing it here

	virtual void OnSelectWhat();

	// Called when the active editor changes, and after OnSelectWhat is called.
	// A FALSE return indicates that the item should not be enabled in the dialog,
	// TRUE indicates that the item may be active.
	// check all situations that may require deactivation here (e.g., deactivate if
	// editor specific and in wrong editor, or if going to an empty list, e.g., of bookmarks)

	virtual BOOL CanGoViewActive(CPartView * pActiveView);

	// Called when the selection control changes (either the user changed
	// the text in the edit control or they selected something from the
	// drop list). For csEdit style selection controls, the fSelInList
	// and dwItemData parameters should be ignored (FALSE/-1 will always
	// be passed here).
	// fSelInList will be true if there is an item selected in the list
	// or combo box.

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	// generally used for simple test like handling empty strings

	virtual void OnSelectChange(const TCHAR * szSelect,
								BOOL fSelInList,
								DWORD dwItemData);

	// Override this to indicate whether or not a go to operation can be
	// attempted. Done when an action button is hit.
	// For goNext and goPrevious operations, the szSelect
	// and dwItemData items are not used.
	// For goGoTo operations, they describe the string and optional
	// user-data selected in the Go To dialog.
	// fSelInList will be true if there is an item selected in the list
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"


	// pDlg and idDlgItemError are used to return focus to in case of error

	virtual BOOL CanGoTo(int idDlgItemError,
						GOTO_TYPE go,
						const TCHAR * szSelect,
						BOOL fSelInList,
						DWORD dwItemData);


	// Override this to handle a go to operation. For goNext and goPrevious
	// operations, the szSelect and iSelList, and dwItemData items are not used. For goGoTo
	// operations, they describe the string and optional listbox user-data
	// selected in the Go To dialog, and the list selection, if any.
	// fSelInList will be true if there is an item selected in the list
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"


	virtual void OnGoTo(GOTO_TYPE go,
						const TCHAR * szSelect,
						BOOL fSelInList,
						DWORD dwItemData);

};

class CGoToAddress : public CGoToItem
{
public:
	ADDR	m_addr;  // set in CanGoTo, used in OnGoTo

public:

	// ctor
	CGoToAddress(CGoToDialog * pDlg);

	// ***Initialization. These functions are used to initialize the Go To
	// dialog. They will be called when the dialog is invoked but may
	// actually be called at any time.

	// REQUIRED: Return the string to show in the Go To What listbox

	virtual const TCHAR * GetItemString();

	// ***Callbacks. These functions are called as the user manipulates the Go To
	// dialog or active editor view

	// Called when the item is selected in the Go To What listbox,
	// and at CGoToDialog startup and reactivation.
	// CGoToDialog will call CanGoViewActive after returning from this
	// call, so let it handle situational enabling/disabling

	// Do not put up error messages or dialogs during this function, as it can be called when focus
	// is changing. If you need to check a state that might bring up such a message it would be better
	// to enable the goto button and check at CanGoTo or OnGoTo rather than doing it here

	virtual void OnSelectWhat();

	// Called when the active editor changes, and after OnSelectWhat is called.
	// A FALSE return indicates that the item should not be enabled in the dialog,
	// TRUE indicates that the item may be active.
	// check all situations that may require deactivation here (e.g., deactivate if
	// editor specific and in wrong editor, or if going to an empty list, e.g., of bookmarks)

	virtual BOOL CanGoViewActive(CPartView * pActiveView);

	// Called when the selection control changes (either the user changed
	// the text in the edit control or they selected something from the
	// drop list). For csEdit style selection controls, the fSelInList
	// and dwItemData parameters should be ignored (FALSE/-1 will always
	// be passed here).
	// fSelInList will be true if there is an item selected in the list
	// or combo box.

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"

	// generally used for simple test like handling empty strings

	virtual void OnSelectChange(const TCHAR * szSelect,
								BOOL fSelInList,
								DWORD dwItemData);

	// Override this to indicate whether or not a go to operation can be
	// attempted. Done when an action button is hit.
	// For goNext and goPrevious operations, the szSelect
	// and dwItemData items are not used.
	// For goGoTo operations, they describe the string and optional
	// user-data selected in the Go To dialog.
	// fSelInList will be true if there is an item selected in the list
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"


	// pDlg and idDlgItemError are used to return focus to in case of error

	virtual BOOL CanGoTo(int idDlgItemError,
						GOTO_TYPE go,
						const TCHAR * szSelect,
						BOOL fSelInList,
						DWORD dwItemData);


	// Override this to handle a go to operation. For goNext and goPrevious
	// operations, the szSelect and iSelList, and dwItemData items are not used. For goGoTo
	// operations, they describe the string and optional listbox user-data
	// selected in the Go To dialog, and the list selection, if any.
	// fSelInList will be true if there is an item selected in the list
	// or combo box

	// SzSelect note: For csEdit it is the edit text, for csDropList, the
	// text of the list box selection. For csDropCombo, szSelect will be the
	// text in the LIST BOX if fSelInList, otherwise it will be the edit text. If you need
	// to get the edit text when fSelInEdit call CGoToDialog::IdCtlSelection
	// to get at the "selection control"


	virtual void OnGoTo(GOTO_TYPE go,
						const TCHAR * szSelect,
						BOOL fSelInList,
						DWORD dwItemData);

};

#endif // !_GOTOITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\ldouble.h ===
//-----------------------------------------------------------------------------
//	ldouble.h
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:
//		define stuff needed for long double in win32
//
//  Revision History:
//
//	[]		06-Apr-1993 Dans	Created
//
//-----------------------------------------------------------------------------
#if !(defined (_ldouble_h))
#define _ldouble_h

#include <cvinfo.h>	// for FLOAT10

#pragma pack(2)
// little endian, 10byte float, same as FLOAT10, but easier to parse!
typedef struct F10_REP {
	unsigned long	ulManLo;
	unsigned long	ulManHi;
   	unsigned short	usExp : 15;
	unsigned short	bSign : 1;
	} F10_REP;
#pragma pack()

// special bits
#define bNan		0x40000000
#define bInd		0xc0000000
#define bExpSp		0x7fff
#define bSign		0x8000
#define bMsbShort	0x8000
#define bMsbLong	0x80000000

// get a string rep of long doubles
// always scientific notation:
// [+-]x.yyyyyyyyyyyyyyyyyye[+-]zzzz, LDBL_DIG digits of precision
//
char *	SzFromLd ( char * pchBuf, size_t cb, FLOAT10 f10 );

// get a float10 rep of a string
//  (basically _strtold from 16-bit runtimes)
//
FLOAT10	LdFromSz ( char * szFloat, char ** ppchEnd );

// compare a 10-byte float to zero
//  
#define PF10(x)	((F10_REP*)&x)
__inline BOOL
FCmpLdZero ( FLOAT10 f10 ) {
	return !(PF10(f10)->ulManLo || PF10(f10)->ulManHi || PF10(f10)->usExp);
	}


// give the real values for 10-byte reals in place of the CRT in float.h
//  values were retrieved from 16-bit version of float.h.
// 
#undef LDBL_MAX_10_EXP
#define LDBL_MAX_10_EXP		4932

#undef LDBL_MIN_10_EXP
#define LDBL_MIN_10_EXP		-4931

#undef LDBL_DIG
#define LDBL_DIG			18

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\makeeng.h ===
/*********************************************************************

	File:   			makeeng.h

	Date created:    	27/8/90

	Author:				Tim Bell

	Description:

	Windows Make Engine API

	Modified:

*********************************************************************/
#ifndef MAKEENG_H
#define MAKEENG_H

typedef enum
{
	EXEC_RESTART,
	EXEC_GO,
	EXEC_STEPANDGO,
	EXEC_TOCURSOR,
	EXEC_TRACEINTO,
	EXEC_TRACEFUNCTION,
	EXEC_STEPOVER,
	EXEC_SRC_STEPOVER,
	EXEC_SRC_TRACEINTO,
	EXEC_SRC_TRACEFUNCTION,
	EXEC_ANIMATE,
	EXEC_STEPTORETURN,
	EXEC_TARGET,
	EXEC_EDITANDCONTINUE,	// Apply code changes, no run
	EXEC_ENC_FORCEGO,		// Apply code changes, then force a "go"
							// to simulate seamless ENC when the debuggee
							// is running
} EXECTYPE;

void PASCAL UpdateProjectState(int doc, LPCTSTR docFileName, BOOL ChangedOnDisk, BOOL ClearDebuggeeState);

void PASCAL ExecDebuggee(EXECTYPE ExecType);

// Return exe name from most recently active, still-open window on an EXE
const CString& SzLastExeWindow(VOID);

// Return whether we're the parent of the specified process
BOOL FParentOfProcess(DWORD pid, const char **pszPath);

// Clear list of PIDs for which we'll be the JIT debugger
void ClearPidExecList(void);

BOOL PASCAL DocInProject(LPCTSTR docFileName);

// Indicates if we need to update the remote target before debugging
extern BOOL fUpdateRemoteTarget;
extern BOOL g_bDebugTime; // Report build timings to the output window.

// Java debugging support
BOOL GetJavaBrowser(CString& strBrowser, CString& strBrowserArgs);
BOOL GetJavaStandalone(CString& strStandalone, CString& strStandaloneArgs);

#endif	// MAKEENG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\osdstr.h ===
/**************************************************************************

                   NOTIFICATIONS FROM OSDEBUG

                   mapping id <==> notification


**************************************************************************/

#ifndef __MSVC_DEBUG__	// {
#define __MSVC_DEBUG__

	#define dbcBase       dbcNil

#define MAX_OSD_LEN       20

	#undef DECL_DBC
	#define DECL_DBC(name, fRequest, dbct)	"dbc" #name,

char far dbcStr[][MAX_OSD_LEN] = {
	#include <dbc.h>
    } ;

#undef DECL_DBC

#endif	// __MSVC_DEBUG__ }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\miscdlgs.h ===
#include "plist.h"

///////////////////////////////////////////////////////////////////////////////
// CMapRemoteDllDlg class
// definition for remote-to-local name mapping dialog
///////////////////////////////////////////////////////////////////////////////

class CMapRemoteDllDlg : public C3dDialog
{
// Construction
public:
	CMapRemoteDllDlg (LPCTSTR szRemote, CWnd * pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CCallingExeDlg)
	enum { IDD = IDD_REMOTE_FILE_MAP };
	//}}AFX_DATA

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

public:
	//{{AFX_MSG(CCallingExeDlg)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	void OnNameChange();
	void OnBrowse();
	void OnPromptDLLs();
	//}}AFX_MSG

	CString m_strLocal;
	BOOL	m_fPrompt;

private:
	CString m_strRemote;
	void UpdateOKState();
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAssertFailedDlg dialog

class CAssertFailedDlg : public C3dDialog
{
// Construction
public:
	CAssertFailedDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAssertFailedDlg)
	enum { IDD = IDD_ASSERT_FAILED };
	CString	m_strAssertText;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAssertFailedDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAssertFailedDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



//
// Attach To Active Dialog

class CAttachToActive : public C3dDialog
{

  private:

	TASK_LIST*	m_TaskList;
	int			m_nTasks;
	

  public:

	enum { IDD = IDD_ATTACH_TO_ACTIVE };

	ULONG	m_ProcessId;
	CString	m_ProcessName;
	CString	m_ImageName;
	

  public:	// operations

	CAttachToActive(
		CWnd*	pParent = NULL
		);
	
	~CAttachToActive(
		);
		

  protected:
  
	virtual void
	DoDataExchange(
		CDataExchange*	pDX
		);
		
	virtual BOOL
	OnInitDialog(
		);
		
	virtual void
	OnOK(
		);

	virtual BOOL
	OnNotify(
		WPARAM		wParam,
		LPARAM		lParam,
		LRESULT*	lResult
		);

	BOOL
	OnLvnColumnClick(
		NM_LISTVIEW*	ListData,
		LRESULT*		lResult
		);

	BOOL
	OnNmDblClk(
		NMHDR*	Data,
		LRESULT*	lResult
		);

	void
	EmptyProcessList(
		);

	void
	FillProcessList(
		BOOL	fListSystemProcesses
		);

	void
	OnChangeSystemProcess(
		);
	
	DECLARE_MESSAGE_MAP()
};

class CModuleDialog : public C3dDialog
{
  private:
  	LPMODULE_LIST m_pModuleList;

  public:

	enum { IDD = IDD_MODULELIST };


  public:	// operations

	CModuleDialog (
		CWnd*	pParent = NULL
		);
	
	~CModuleDialog (
		);
		

  protected:
  
	virtual void
	DoDataExchange(
		CDataExchange*	pDX
		);
		
	virtual BOOL
	OnInitDialog(
		);
		
	virtual void
	OnOK(
		);

	virtual BOOL
	OnNotify(
		WPARAM		wParam,
		LPARAM		lParam,
		LRESULT*	lResult
		);

	BOOL
	OnLvnColumnClick(
		NM_LISTVIEW*	ListData,
		LRESULT*		lResult
		);

	BOOL
	OnNmDblClk(
		NMHDR*	Data,
		LRESULT*	lResult
		);

	void
	EmptyModuleList(
		);

	void
	FillModuleList(
		);

	void
	OnChangeModule(
		);

	DECLARE_MESSAGE_MAP()
};


class CNoSymbolInfoDlg	: public C3dDialog
{

  public:

	BOOL	m_fNoPrompt;
	CString	m_strCaption;
	CString	m_strPrompt;

  public:

    enum { IDD = IDD_NO_SYMBOL_INFO };

	CNoSymbolInfoDlg(
		CWnd*	pParent = NULL
		);


  protected:
  
	virtual BOOL
	OnInitDialog(
		);

	virtual void
	DoDataExchange(
		CDataExchange*	pDX
		);

	DECLARE_MESSAGE_MAP ()
};

//
//  Fiber dialog
//

typedef struct _FBRLST {
	LPVOID	FbrCntx;
	CString	strFbr;
} FBRLST, *PFBRLST;

class CFibers : public C3dDialog
{

  private:

	FBRLST *m_FbrLst;
	DWORD  iFbrCnt;

  public:

	enum { IDD = IDD_FIBERS };	

	LPVOID m_FbrCntx;

  public:	// operations

	CFibers(
		CWnd*	pParent = NULL
		);
	
	~CFibers(
		);
		

  protected:
  
	virtual void
	DoDataExchange(
		CDataExchange*	pDX
		);
		
	virtual BOOL
	OnInitDialog(
		);
		
	virtual void
	OnOK(
		);

	virtual BOOL
	OnNotify(
		WPARAM		wParam,
		LPARAM		lParam,
		LRESULT*	lResult
		);

	BOOL
	OnLvnColumnClick(
		NM_LISTVIEW*	ListData,
		LRESULT*		lResult
		);
	
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\meclass.h ===
#ifndef _MECLASS	// WHOLE FILE
#define _MECLASS

/*
	This file contains macros and functions to have CodeView COW oriented
	functions work under real windows.
*/

/*************************************************************************
	[begin] MultiEdit utility functions, types, and defines
 ************************************************************************/

typedef struct dla {
	FMT_ELEMENT	*pElement;
	WORD		cb;
} DLA;

typedef DLA *	PDLA;

/*** emsc - edit message sel char */
typedef struct emsc {
    WORD    x1;     /* old hiword( lParam ) */
    WORD    x2;     /* old loword( lParam ) */
    DWORD   y;      /* old wparam */
} EMSC;
typedef EMSC FAR *	LPEMSC;

/*** ld - line buffer */
typedef struct ld {
	WORD	flags;
	WORD	cb;		/* count of bytes in buffer */
	WORD	cbMax;	/* max buffer length */
	char *	prgch;	/* pointer to buffer */
} LD;

/*** ip - insert point */
typedef struct ip {	/* insert point */
	WORD 	ob;	    /* offset to current column position */
	DWORD 	oln;	/* offset to current line position */
} IP;

/*** pd - program descripter */
typedef struct pd {
	DWORD	olntop;	/* offset within progrm display at top of screen */
	WORD 	obleft;	/* offset within list buffer of left most character */
	DWORD	oln;	/* current ld line offset within program */
} PD;

extern BOOL fPasteOk;
extern BYTE fInsertMode;
extern LD  ldEMScratch;

extern WORD emFlags;
#define EMF_IN_EDITMGR 0x01

/* styles */
#define ES_NOREDRAW	0x0002
#define ES_NOSELECT	0x0004

/* control messages: */
#define EM_SELCHARS		(WM_USER+700+0)
#define EM_GETWORD		(WM_USER+700+2)
#define EM_GETLINESEL	(WM_USER+700+3)
#define EM_MOVECURSOR	(WM_USER+700+16)
#define WM_PAINTLINE	(WM_USER+700+17)
#define WM_GETPASTELINE (WM_USER+700+18)
#define WM_REDO			(WM_USER+700+19)
#define WM_PAINTSCREEN	(WM_USER+700+20)
#define WM_FLUSHFOCUS	(WM_USER+700+22)
#define EM_GETTEXT    	(WM_USER+700+23)
#define EM_PTINSELECTION (WM_USER+700+24)

/* ldCur.flags values */
#define LD_fDirty			0x0001

typedef short    RX;
typedef short    RY;
typedef short    AX;
typedef short    AY;

typedef struct _rrc {
   RX  rxLeft;
   RX  rxRight;
   RY  ryTop;
   RY  ryBottom;
} RRC;

typedef RRC *  PRRC;

#define olnMax      ((DWORD)-1L)
#define obMax       ((WORD)-1)

#define KK_SHIFT    (0x8000)
#define KK_CONTROL  (0x4000)

class CDragInfo; //forward decl

class CMultiEdit : public CDockablePartView
{
    friend void ClearMultiEdit          ( void );
    friend void AddThisToCMEList        ( CMultiEdit * );
    friend void RemoveThisFromCMEList   ( CMultiEdit * );
    friend HWND GetDebugWindowHandle    ( UINT );
	friend void UpdateAllMultiEditScroll();

    DECLARE_DYNCREATE(CMultiEdit)

protected:
    /* from CTextView */
    CFontInfo   *m_pFontInfo;
    /* end from CTextView */

private:

    static CMultiEdit   *m_pList[NUM_ME_WINDOWS];   // there are 6 possible multi-edit windows

private:
	// Edit manager data

	// File/view position of top left corner
	PD	    m_pdCur;

	// Location of cursor within the view (always visible)
	IP	    m_ipCur;

	// Location of the anchor during selections
	IP	    m_ipAnchor;

	// No-longer used? for copy/paste operations (COW version)
	LD	*   m_pldCur;

	// Display vertical and horizontal scroll bars?
   	BOOL	m_fScrollV;
   	BOOL	m_fScrollH;

	// Indicates if window is redraw or not
	BYTE	m_Style;

	// Is there a selection?
	BYTE	m_fSelection;

	// Multiplier for very large scroll ranges.  This will
	// let us have 32-bit line numbers in a 16-bit space
	int		m_dScrollVal;

	// Cached value for determining vertical scrollbar
	// ranges
	DWORD	m_olnMacPrev;

	// Cursor and anchor positions for intelligent
	// painting of selection range changes
	IP		m_ipCurOld;
	IP		m_ipAnchorOld;

	// Direction to adjust cursor when cursor placed on a
	// trail byte.  This will be toggled between 1 and -1
	// for adjustments on vertical realignment
	int		m_iAdjustDbcs;

	// Is view in a state where CMultiEdit should start
	// processing things?  This will be set to true after
	// the window has received a WU_INITDEBUG and cleared
	// when the window receives the WU_CLEARDEBUG.  Only
	// used in CMultiEdit::WindowProc!
	BOOL	m_fUseMultiEdit;

	// Dbcs characters are passed in byte by byte, so we
	// receive 2 wm_char messages.  CMultiEdit::WindowProc
	// will cache the 1st byte and when the 2nd is received
	// it will create a single 2-byte char which will get
	// passed on to the TextProc.  Note, the 1st byte's
	// WM_CHAR message will NOT be reveived by the TextProc!

	// Is dbcs cache empty?
	BOOL	m_fAcceptDbcs;

	// Only valid when m_fAcceptDbcs == FALSE!  When valid, it
	// contains the lead byte which is to be combined with the
	// next WM_CHAR value to form a DBCS character
	BYTE	m_bDbcsLead;

	// TRUE if doing column selections, FALSE otherwise (default)
	BOOL	m_fColumnSelect;

	// Internal edit manager workings
	void    ResizeScroll( void );
	long    LGetShiftState( void );
	BOOL    FGetSelection( DWORD, WORD *, WORD * );
	void    RedisplaySelection( void );
	void    PasteSelection( void );
	HANDLE  CopySelection( char FAR *, size_t );
	void    DeleteSelection( void );
	long    LcbGetText( WORD,char FAR * );
	long    LcbGetWord( UINT, char FAR *,WORD *,WORD * );
	void    UpdateAnchor( long );
	WORD    CbGetCachedLine( DWORD, WORD, char * );
	WORD    CbGetLineIntoCache( DWORD );
	void    FlushCache( void );
	void    GetEditRrc( BOOL, PRRC );
	void    DrawAttrText(CDC *, BOOL, DWORD, char *, WORD, WORD, PDLA, RY, WORD );
	void    UpdateCursorPos( void );
	BOOL    FMoveWindowToCursor( BOOL );
	void    ValidateCursor( void );
	DWORD   Paint( PRRC, CDC * );
	void    VScroll( UINT, long );
	void    HScroll( UINT, long );
	void    DeleteChar( BOOL );
	void    InsertChar( UINT, long );
	void    PreviousWord( long );
	void    NextWord( long );
	void    DoEnterKey( void );
	void    DoChar( UINT, long );
	void    PaintLine( DWORD );
	void    DoMouse( UINT, UINT, long );
	BOOL    FMouseHitSel( BOOL, LPARAM );
	int     ScrollFromOln( DWORD );
	void	AdjustDbcsCursor( int );
    BOOL    GetHelpWord(CString&);
    BOOL    FWhitespaceOnly(PCSTR, _CB);

protected:

	// Undo/Redo stuff
	// States of engine
	enum UNDO_STATE {

		usNormal,		// Edits should record.
		usSuspendedError		// Edits should not record -- suspended due to error

	}; 

	enum UNDO_BUFFER {

		ubUndo,			// current recording buffer
		ubRedo

	};

	INT		m_mePlayCount;
	UNDO_BUFFER  m_undoBuffer;	 // current recording buffer.
	UNDO_STATE  m_undoState;	 // state of recording process.


	virtual	LRESULT	WindowProc(UINT, WPARAM, LPARAM);
				// The WndProc for this window.
	int     OnCreate(LPCREATESTRUCT lpCreateStruct);
    void    OnEditCopy();
    void    OnEditUndo();
    void    OnEditRedo();

    void    OnUpdateGotoLine(CCmdUI *);
    void    OnUpdateEditUndo(CCmdUI *);
    void    OnUpdateEditRedo(CCmdUI *);

    void    OnGotoLine();
	void	SelectWordCur();

    DECLARE_MESSAGE_MAP()

public:

    DOCTYPE     m_dt;

    /* from CTextView */
    INT         m_cxSelectMargin;
    UINT        m_cbTab;          // Cached tab from doc
    /* end from CTextView */

public:
	// Constructors, destructors

	CMultiEdit();
	CMultiEdit(INT);
	virtual			~CMultiEdit() { RemoveThisFromCMEList(this); }

	// Don't let message mapping occur for keys handled by edit manager
	virtual BOOL 	PreTranslateMessage(MSG* pMsg);

	// Selection management
	virtual BOOL	GetCurrentText(BOOL *lookAround, LPSTR pText, _CB  maxSize,	ICH * xLeft, ICH * xRight);
	virtual void 	OnFindNext(BOOL* pbSuccess = NULL); // called for a find

	// Drawing methods
	virtual	VOID	OnDraw(CDC *); 
	void            DrawMarginGlyphs(HDC hDC, RECT& rcMargin, UINT uStatus);

	// Edit manager overridables/callbacks
	// NOTE: The following functions should be pure virtuals, but
	// IMPLEMENT_DYNCREATE will choke on the class since it is
	// an abstract class.  For this reason, the functions have
	// bodies here which will assert!
	virtual DWORD		CLinesInBuf( void ) { ASSERT( FALSE ); return NULL; }
	virtual WORD 		CbGetLineBuf( DWORD, WORD, char *, PDLA & ) { ASSERT( FALSE ); return NULL; }
	virtual BOOL		FReplaceLineBuf( DWORD, WORD, char * );
	virtual BOOL		FReadOnlyBuf( void );
	virtual BOOL		FIsWordChar( TCHAR );
	virtual WORD		ObMaxBuf( void );
	virtual void 		DrawLineGraphics( CDC *, RECT &, DWORD ) {};
	virtual LRESULT		LTextProc( UINT, WPARAM, LPARAM );	
    virtual void        ShowContextPopupMenu( CPoint );
    // GoToLine should be over-ridden if the view supports it.
    virtual void        GotoLine( void ) { ASSERT(FALSE); ::MessageBeep(0); }

	// Override if user can edit this window.
	virtual BOOL		IsEditable( ) { return FALSE; }
	void	GetClientRrc( PRRC );
	void	InvalidateRrc( PRRC );
	void	DrawLine( DWORD );
	void	DrawWindow( void );
	DWORD	WinHeight( void );
	WORD	WinWidth( void );
	WORD	ObGetCurPos( void );
	void	SetCurObPos( WORD );
	DWORD	OlnGetCurPos( void );
	void	SetCurOlnPos( DWORD );
	DWORD	OlnGetTop( void );
	WORD	ObGetLeft( void );
	void	SetCursorAt( WORD, DWORD );
	void	SetWinTopLineCursor( DWORD, WORD, DWORD );
	void	SetWinTopLine( DWORD );
	void	SetWinUpperLeft( WORD, DWORD );
	DWORD	GetEditSelection( WORD, char FAR * );
	DWORD	GetEditWord( WORD, char FAR * );
	WORD	FInsertMode( void );
	DWORD	OlnFromScrollPos( int );
	BOOL	InitEditMgr();
	BOOL	GetWordAtPosition(WORD, DWORD, LPSTR pBuf, UINT maxSize, WORD * obMic,
									WORD *obMac);

	void	FlipBytes( BYTE FAR *, int );
	BOOL		FCanUndo( );	
	BOOL		FCanRedo( );
	
	virtual BOOL SupportsDataTips( ) const   { return FALSE; }
	void ArmDataTip();

	// OLE Drag/Drop
public:
	virtual BOOL	CanDropText( void ) { return FALSE; }
	virtual BOOL	CanMoveText( void ) { return FALSE; }
	virtual DROPEFFECT	OnDropEx( COleDataObject* pDataObject, DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point );
	virtual DROPEFFECT	OnDragEnter( COleDataObject* pDataObject, DWORD grfKeyState, CPoint point );
	virtual DROPEFFECT	OnDragOver( COleDataObject* pDataObject, DWORD grfKeyState, CPoint point );
	virtual void		OnDragLeave();
	// utilities
	virtual BOOL		DoDrag(CPoint point);
	virtual void        OnDragEnterFeedback(DWORD grfKeyState, CPoint point) { HideCaret(); }
	virtual void        OnDragOverFeedback(DWORD grfKeyState, CPoint point) { ; }
	virtual void        OnDragLeaveFeedback() { ; }
	virtual BOOL		InitDataSource(COleDataSource& data, const CPoint & point);
	virtual BOOL		InsertFromDataObject(COleDataObject * data, const CPoint & point);
	virtual BOOL		IsDragActive() { return FALSE; }
	// Drag & Drop implementation
private:
	COleDropTarget	m_DropTarget;
	CDragInfo *		m_pDragInfo;

public:
	virtual void	PosFromPoint( int &, int &, CPoint );
	virtual BOOL	FCanUseMarginSelect( void ) { return FALSE; }
	inline BOOL	FDbcsEnabled( void ) { return (BOOL)( m_pFontInfo->m_tm.tmAveCharWidth != m_pFontInfo->m_tm.tmMaxCharWidth ); }
	virtual BOOL Create(LPCSTR lpszClassName,
		LPCSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);
};

#endif	// !_MECLASS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\mw.h ===
class CGoToAddress;

#define	MWNINCH	(0xffff)

enum _autotypes
{
 MW_AUTO_HEX = -1,
 MW_NO_AUTO_TYPE,
 MW_AUTO
};

enum _expropts
{
 MW_DEAD = 0,
 MW_LIVE,
};

enum _movmnt
{
 MW_REV = -1,
 MW_CUR,
 MW_FWD
};

enum _celltype
{
 MW_NONE = 0,
 MW_ADDR,
 MW_FMT,
 MW_RAW,
 MW_ASCIIDAT
};

enum _mpiimwd
{
 MW_ASCII = 0,
#ifdef _WIN32
 MW_WCHAR,
#endif	// _WIN32
 MW_BYTE,
 MW_INT,
 MW_INT_HEX,
 MW_INT_UNSIGNED,
 MW_LONG,
 MW_LONG_HEX,
 MW_LONG_UNSIGNED,
 MW_REAL,
 MW_REAL_LONG,
#ifndef _WIN32
 MW_REAL_TEN,
#endif	// !_WIN32
 MW_cDisplayTypes,
#if _INTEGRAL_MAX_BITS >= 64
 MW_INT64 = 		MW_cDisplayTypes,
 MW_INT64_HEX,
 MW_INT64_UNSIGNED,
 MW_cDisplayTypesExt
#else	//	_INTEGRAL_MAX_BITS >= 64
 MW_cDisplayTypesExt = MW_cDisplayTypes
#endif	//	_INTEGRAL_MAX_BITS >= 64
};

#ifndef _WIN32
#define IsCharFormat(imwd)  (imwd==MW_ASCII)
#else	// !_WIN32
#define IsCharFormat(imwd)  (imwd==MW_ASCII || imwd==MW_WCHAR)
#endif	// _WIN32

#ifdef _WIN32
typedef char *BSZ;
typedef char BCH;
#else
typedef char _based(_segname("_CODE")) *	BSZ;
typedef char _based(_segname("_CODE")) 	BCH;
#endif

typedef struct _mwd
{
	USHORT	cbType;
	USHORT	cchFormatted;	 // Number of chars occupied by formatted
	char	bszFmtIn[ 6 ];	 // sscanf format for input
							 // data type.
} MWD;		// Memory Window Display information
#ifdef _WIN32
typedef MWD *PMWD;
#else
typedef MWD _based(_segname("MW_CODE")) *	PMWD;
#endif

#define cbDataMax		10
#define cchAddr32		8
#define cchAddr16		9
#define cchAddrMax		cchAddr16
#define cchPad			2
#define cchRaw			3
#define cchFixedMax		126
#define chBsp			((char)0x08)
#define chCtrlE			((char)0x05)
#define chNull			((char)0x00)
#define chLineFeed		((char)0x0a)
#define cchBufMax		(axMax+2)
#ifdef MAC
#define szDefaultExpr	"0x00000000"
#else	// MAC
#define szDefaultExpr	"DS:0"
#endif	// MAC
#define wNoType		    ((WORD)0x8000)
#define wFmtHiMin		((WORD)0x8001)
#define wFmtLoMin		((WORD)0x0001)
#define wFmtMask		((WORD)0x8000)
#define wAsciiMask		((WORD)0x7fff)

#ifdef _WIN32
extern MWD const rgmwd[ MW_cDisplayTypesExt ];
#else
extern MWD const _based(_segname("MW_CODE")) rgmwd[ MW_cDisplayTypesExt ];
#endif
extern char const rgchType[ MW_cDisplayTypesExt ];

// mpbHex is for converting bytes to ascii hex.  The lowercase and
// zero terminator are for quick scans for editing addresses.

extern char const mpbHex[];

typedef struct _mwi
{
    const MWD * pmwd;         // display information for type
    char *      szExpr;       // character version of expression
    ADDR        addr;         // evaluated expression - or scrolled current
    USHORT      fLiveExpr;    // Is expression live or dead?
    BOOL        fShowRaw;     // Show raw data?
    USHORT      cFmtVals;     // Number of values/line to display
    DWORD       cLines;       // Number of lines in window
	HLLI		hlliUndo;	  // linked list of undo data
	HLLI		hlliRedo;	  // linked list of redo data
    WORD FAR *  rgwLineInfo;  // line cell information
    WORD        cwLineInfo;   // number of cells in line info
    BOOL FAR *  rgf;          // Value has changed array
    USHORT      cFixedFmt;    // Fixed # of display values.
    USHORT      cchAddr;      // Display width of address
    BOOL        fNoUpdate;    // This is a value to let us
                              // update if its the first time
                              // we've set focus to this window
	BOOL		fRetry;		  // If this is true the first time
							  // we tried updating it was to early.
							  // so we will retry setting the memory
							  // window to the original expression.
} MWI; // Memory Window Information - per window data
typedef MWI *	PMWI;

typedef struct _mub
{
	USHORT		ucls;		// class for edit MW_RAW, MW_FORMAT, MW_ASCIIDAT
	const MWD * pmwd;		// display format when created
	ADDR		addr;
	size_t		cb;
	BYTE		rgb[ cbDataMax ];
} MUB;		// Memory window Undo Buffer
typedef MUB FAR *	LPMUB;

typedef struct _mwc
{
    ADDR    addrBegin;	// beginning address of data
    WORD    cbReq;      // cb requested for read at addrBegin
    WORD    cbRead;     // Successful cb read at addrBegin
    LPB     lpb;        // pointer to alloc'd buffer where addrBegin is
} MWC;      // Memory Window Cache
typedef MWC FAR *   LPMWC;

// We may want this to come from OSDebug later
#define cbPageMax	(4096)

#define MW_LAMAX	256

extern BOOL	fDumping;

#define CBMWCacheMax    (80*50)

extern void		PASCAL MWAddrFromIln( PMWI, DWORD, PADDR );
extern DWORD	PASCAL MWIlnFromAddr( PMWI, PADDR );
extern USHORT	PASCAL MWSetAddrFromExpr( PMWI, int );
extern void		PASCAL MWSaveSettings( char * );
extern void     PASCAL MWScanType( short );
extern void	MWDropNewAddress(LPSTR, DWORD, POINT * lppt);
extern EESTATUS PASCAL CVParseBind ( PHTM, PCXT, int, char, char, char FAR * );
extern char		fCaseSensitive;

class CMemoryView : public CMultiEdit
{
	friend class CGoToAddress;

	DECLARE_DYNCREATE(CMemoryView)

	private:
		DLA	 		m_rgdla[ MW_LAMAX ];

		HLLI		m_hlliCur;
		BYTE FAR *	m_rgbCacheCur;

		HLLI		m_hlliPrev;
		BYTE FAR *	m_rgbCachePrev;

		BOOL		FUpdateInfo( BOOL );
		int		    CchFormatData( USHORT, BOOL, BYTE *, char *, char *, BOOL * );
		void		FormatLine( DWORD, char * );
		void		ChangeTitle( void );
		void		NextField( short, BOOL );
		void		NextLikeField( char * );
		USHORT	    CchGetCellInfo( BOOL, UOFFSET *, USHORT *, WORD * );
		BOOL		FDoChar( UINT, DWORD );
		BOOL		FChangeMemory( BOOL, int, char * );
		void        ChangeDebuggeeData( void );
		void		SaveDebuggeeData( void );
		void		UpdateExprFromMwiAddr( void );
		BOOL		FCmpUserMemory( PADDR, USHORT, BYTE * );
		WORD FAR *  LpwFindNotEq( WORD FAR * );
		void		BuildRgla( void );
		void		MakeWindowActive( void );
		void		OOMError( void );
		void		DoEditField( void );
		void		DoDelChar( BOOL );
		void		UpdateWorld( PADDR, USHORT );
		BOOL		FIsAddrInRange( PADDR, PADDR, PADDR );
		LPB         LpbFromCache( HLLI, PADDR, size_t, size_t * pcbRead = NULL );
		void		CacheDebuggeeData( HLLI *, LPB * );
		void        DestroyCache( HLLI *, LPB * );
		void		UncacheData( void );
		void        UncacheAll( void );
		USHORT	    CbGetDebuggeeBytes( PADDR, size_t, BYTE FAR * );
		BOOL		FPutDebuggeeBytes( USHORT, PADDR, size_t, LPB, HLLI, HLLI );
		void		UndoValue( BOOL );
		void		DestroyUndoList( void );
		void		UpdateView( void );

	protected:
		virtual BOOL Create(LPCSTR lpszClassName,
			LPCSTR lpszWindowName, DWORD dwStyle,
			const RECT& rect,
			CWnd* pParentWnd, UINT nID,
			CCreateContext* pContext = NULL);

	public:
		MWI			m_mwi;
		
		/* default constructor/destructor */
		CMemoryView();
		virtual ~CMemoryView();

		virtual DWORD 	GetHelpID() { return HID_WND_MEMORY; }

		virtual void 	ShowContextPopupMenu(CPoint pt);

		virtual BOOL	CanDropText( void ) { return TRUE; }
		virtual BOOL	InsertFromDataObject(COleDataObject * data, const CPoint & point);
		virtual void    OnDragEnterFeedback(DWORD grfKeyState, CPoint point);
		virtual void    OnDragOverFeedback(DWORD grfKeyState, CPoint point);
		virtual void    OnDragLeaveFeedback();
		virtual void	GotoLine( void );
		virtual BOOL	IsEditable() { return TRUE; }

		// No textual help available for this window!
		virtual BOOL GetHelpWord( CString& strHelp ) { return FALSE; }
		

		WORD 		CbGetLineBuf( DWORD, WORD, char *, PDLA & );
		WORD		ObMaxBuf( void );
		DWORD		CLinesInBuf( void );

		LRESULT		LTextProc( UINT, WPARAM, LPARAM );

		BOOL		SetAttributes( WORD, char *, USHORT, WORD, USHORT );

	private:
		friend class CDebugPackage;
		// g_cRef is the count of instantiations of CTextView, used to
		// initialize g_pFontInfo which is the pointer to the CFontInfo
		// for this view type
		static UINT g_cRef;
		// Pointer to the font information for this view type
		static CFontInfo *g_pFontInfo;
};

inline PMWI MWPmwiOfPwnd(PWND pWnd)
{
	CMemoryView *	pMemoryView = (CMemoryView *)CWnd::FromHandle(pWnd);

	ASSERT(pMemoryView->IsKindOf(RUNTIME_CLASS(CMemoryView)));
	return(&pMemoryView->m_mwi);
}

/////////
// CMemoryEditItem
//
// edit item in the Memory class...
// needs subclass so that it can handler ENTER to add a new Memory...
//

class CMemoryEditItem: public CDockEdit
{
public:
	virtual BOOL PreTranslateMessage(MSG *pMsg);
};

////////
// CMemoryDialogBar
//
// the dialog bar wrapper class for the Memory window
//

class CMemoryDialogBar : public C3dDialogBar
{
public:
	CMemoryEditItem	m_edit;			// the edit field

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL OnInitDialog();				// dialog is coming up, init buttons

protected:
	//{{AFX_MSG(CMemoryDialogBar)
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMemoryParent
//
// This window serves as a parent for the Memory window
// it holds the check boxes and the edit field widget for the Memory window
//

class CMemoryParent : public CWnd
{
	DECLARE_DYNAMIC(CMemoryParent)
	friend class CMemoryView;
	
public:
	CMemoryParent();
	void RecalcLayout();	

	CMemoryDialogBar	m_toolbar;			// the toolbar for this class
	
protected:
	virtual void PostNcDestroy();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL PreTranslateMessage(MSG *pMsg);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	
	CMemoryView*  m_pView;

protected:
	//{{AFX_MSG(CMemoryParent)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\owinwrap.h ===
#ifndef OWINWRAP_H

#define OWINWRAP_H	1

/* This file contains inline wrappers to make it easier to call output window
   functionality from the debugger */

inline void OutputWindowQueueHit(UINT nCommandId, LPCSTR lpszError,
                                 BOOL fToolError, BOOL fAppendCrLf, BOOL fForceFlush = FALSE)
{
	BOOL	fFull;
	
	ASSERT(gpIOutputWindow != NULL);

	VERIFY (SUCCEEDED (gpIOutputWindow->OwinIsBufferFull (&fFull)));

	if (!fFull) {

		HRESULT	hr;

		hr = gpIOutputWindow->OutputWindowQueueHit (nCommandId,
													lpszError,
													fToolError,
													fAppendCrLf,
													fForceFlush
													);

		ASSERT (SUCCEEDED (hr));
	}
}

inline void ShowOutputWindow( )
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->ShowOutputWindow()))
		ASSERT(FALSE);
}

inline void ClearOutputWindow( )
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->ClearOutputWindow()))
		ASSERT(FALSE);
}

inline void WriteStringToOutputWindow(LPCSTR lpszError, BOOL fToolError, BOOL fAppendCrLf)
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->WriteStringToOutputWindow(lpszError, fToolError, fAppendCrLf)))
		ASSERT(FALSE);
}

inline void OutputWindowDeleteVwin(UINT nCommandId)
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OutputWindowDeleteVwin(nCommandId)))
		ASSERT(FALSE);
}

inline void OutputWindowShowVwin(UINT nCommandId)
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OutputWindowShowVwin(nCommandId)))
		ASSERT(FALSE);
}

inline void OutputWindowSelectVwin(UINT nCommandId, BOOL fOnTop)
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OutputWindowSelectVwin(nCommandId, fOnTop)))
		ASSERT(FALSE);
}

inline UINT OutputWindowAddVwin(LPSTR szToolName, BOOL fCurrentVwin)
{
	UINT uRet = 0;

	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OutputWindowAddVwin(szToolName, fCurrentVwin, &uRet)))
		ASSERT(FALSE);

	return uRet;
}

inline UINT OutputWindowModifyVwin(UINT nCommandId, LPSTR lpszToolName)
{
	UINT uRet = 0;

	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OutputWindowModifyVwin(nCommandId, lpszToolName, &uRet)))
		ASSERT(FALSE);

	return uRet;
}

inline void OutputWindowVwinClear(UINT nCommandId)
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OutputWindowVwinClear(nCommandId)))
		ASSERT(FALSE);
}

inline void OutputWindowClearWindow(UINT nCommandId)
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OutputWindowClearWindow(nCommandId)))
		ASSERT(FALSE);
}

inline void OutputWindowClearContents(UINT nCommandId)
{
	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OutputWindowClearContents(nCommandId)))
		ASSERT(FALSE);
}

inline UINT OwinGetBuildCommandId( )
{
	UINT uRet;

	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OwinGetBuildCommandID(&uRet)))
		ASSERT(FALSE);

	return uRet;
}

inline UINT OwinGetDebugCommandID( )
{
	UINT uRet;

	ASSERT(gpIOutputWindow != NULL);
	if (!SUCCEEDED(gpIOutputWindow->OwinGetDebugCommandID(&uRet)))
		ASSERT(FALSE);

	return uRet;
}

#endif // OWINWRAP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\qcqp.h ===
#ifndef QCQP_H
#define QCQP_H

#ifndef OSDEBUG4
#define OSDAPI PASCAL
#endif

#define _pascal		PASCAL
#define _loadds
#define _export
#define _fcalloc	calloc
#define _huge
#define __huge
#define _far
#define __far
#define alloc_text(x,y) warning(disable:4762)	/* disable a warning we will never get in win32! */
#define gUnlockNull	0	/* prevent warnings */

// critical-section macros
#define QCInitCritSection(pcs)		InitializeCriticalSection(pcs)
#define QCLeaveCritSection(pcs)		LeaveCriticalSection(pcs)
#define QCEnterCritSection(pcs)		EnterCriticalSection(pcs)
#define QCDeleteCritSection(pcs)	DeleteCriticalSection(pcs)

// prune the tree of windows crap...

#define NOGDICAPMASKS
#define NOMETAFILE
#define NOSOUND
#define NOCOMM
#define NOKANJI
#define NOICONS
#define NORASTEROPS
#define NOCOLOR
#define NOSERVICE
#define NOPROFILER


// end of pruning...

// turn off min rebuild info for sure on mfc/windows stuff
#pragma component(minrebuild,off)

#if defined (USE_DMALLOC) && defined (_DEBUG)
	#define HOOK_WINDOWS_MEM
	#include <dmalloc.h>
#else
	#define RealGlobalAlloc		GlobalAlloc
	#define RealGlobalLock		GlobalLock
	#define RealGlobalUnlock	GlobalUnlock
	#define RealGlobalSize		GlobalSize
	#define RealGlobalFree		GlobalFree
	#define RealGlobalReAlloc	GlobalReAlloc
#endif

// Packets
// REVIEW: Why not enumerate?
#define PACKET_TEXTEDIT  1
#define PACKET_BASE      2
#define PACKET_MULTI     3

// Dockable Windows
// REVIEW: Why not enumerate?
#define IDDW_VCPP_BASE          (IDDW_PACKAGE_BASE + 0x0100)
#define IDDW_VCPP_WATCH_WIN     (IDDW_VCPP_BASE+1)
#define IDDW_VCPP_VARIABLES_WIN (IDDW_VCPP_BASE+2)
#define IDDW_VCPP_CPU_WIN       (IDDW_VCPP_BASE+3)
#define IDDW_VCPP_MEMORY_WIN    (IDDW_VCPP_BASE+4)
#define IDDW_VCPP_CALLS_WIN     (IDDW_VCPP_BASE+5)
//#define IDDW_VCPP_BROWSE_WIN  (IDDW_VCPP_BASE+6)
#define IDDW_VCPP_DISASSY_WIN   (IDDW_VCPP_BASE+7)
#define IDDW_VCPP_BREAKPT_WIN   (IDDW_VCPP_BASE+8)
#define IDDW_VCPP_OLDWATCH_WIN	(IDDW_VCPP_BASE+9)
#define IDDW_VCPP_LOCALS_WIN    (IDDW_VCPP_BASE+10)

// Offsets from IDTB_VCPP_BASE
#define IDTB_VCPP_BASE          (IDTB_PACKAGE_BASE + 0x0100)
#define IDTB_VCPP_DEBUG			(IDTB_VCPP_BASE+0)


// For all our modules to avoid multiple redefinitions
typedef unsigned short USHORT ;
typedef void * 			PV;			// Pointer to generic Data
typedef LONG			ILINE;
typedef LONG			DCP;		// Delta-CP
typedef ULONG			_CB;
typedef _CB				CP;
typedef CP	*			PCP;
typedef UINT			HDCMP;
typedef UINT			IDCMP;
typedef _CB				IB;
typedef _CB				ICH;		// Character Index
typedef ICH				CCH;		// Count of characters
typedef const char *	PCCH;
typedef HANDLE 			HHEAP;

#define ilineNil (ILINE)-1
#define ichNil (ICH)-1
#define ibNil (IB)-1
#define hdcmpNil (HDCMP)-1
#define cpNil (CP)-1

// turn on min rebuild info for rest of the bld sys stuff in the pch
#pragma component(minrebuild,on)

//Compilation options
#ifndef RC_INVOKED
#ifdef _DEBUG
		#pragma message( "Debugging Version" )
#else
		#pragma message( "Release Version" )
#endif
#endif

// INTERNAL ERROR SECTION
//
// you can add to this section whatever is too far to be checked
// in nested calls and use it with the following functions:
//
// void SetGlolbalError(ERR_TYPE errnum)
// ERR_TYPE CheckGlobalError(void)
// void ClearGlobalError(void)
//
// REVIEW: Why not enumerate?
typedef int ERR_TYPE ;

#define ERR_NOERROR		0
#define ERR_FILELOCK	1
#define ERR_FILEOPEN	2
#define ERR_FILEREAD	3
#define ERR_FILEMAX		4

//Font types and defines

typedef HANDLE HFONT_OBJECT;
typedef HANDLE HCHAR_WIDTHS;

#define NASCII_WIDTHS	256					// Char-width array length for lead byte of 0
#define NTRAIL_WIDTHS  	(0xFC - 0x40 + 1)	// Char-width array length for all other lead bytes
#define NLEAD_BYTES		(0xFC - 0x81 + 1)	// Number of valid lead bytes

typedef struct font {
	LOGFONT			lf;
	HFONT			hFont;
	TEXTMETRIC		tm;
	int				cRef;								// Reference count
	int 			asciiWidths[NASCII_WIDTHS];			// Array of ascii widths
	BOOL			bIsDefault;							// Default font indicator
	HCHAR_WIDTHS 	rgh[NLEAD_BYTES];					// Lead-byte table of handles to char width data
} FONT_OBJECT, FAR *LPFONT_OBJECT;


//Undo/Redo : Type of Editing Action

typedef enum {

		eaMark,							// indicates beginning/end of next set of records
		eaInsertStream,
		eaDeleteStream,
		eaReplaceChar,
		eaNone				// used just to init buffer

} EDIT_ACTION;

// Undo/Redo: What action is next on list to undo/redo
typedef enum {

		mtTyping,
		mtDelete,
		mtReplaceAll,
		mtReplaceOne,
		mtOvertype,
		mtChangeCase,
		mtRecording,
		mtRecordingEnd,
		mtTranspose,
		mtModifyWord,
		mtPaste,
		mtReformat,
		mtMove,
		mtAutomated,	// Automated edits, such as those from ClassWizard, etc.
		mtAutomatedEnd,
		mtFileInsert,
		mtClean,		// If this mark is on the top of either of the stacks, the file is clean
						// w/respect to undo/redo actions
		mtBookmark,		// Not actually recorded, just used to set g_mtMoveType so that the Epsilon
						// bookmark move knows what action occured last
		mtCut,			// Similarly for the Epsilon 'kill' behavior
		mtEpsIndentPrevious,	// And Epsilon's "indent-previous" command
		mtBriefHome,	// And the Brief Home/End behavior
		mtBriefHomeHome,
		mtBriefEnd,
		mtBriefEndEnd,  // Do not fragment the range mtBookmark -> mtBriefEndEnd as it is used in
						// undoredo.cpp to distinguish these marks from *real* undo/redo marks
		mtNil

} MARK_TYPE;


// Undo/Redo : Character classifications for typing
typedef enum {

	ccAlpha,		// includes all non-alpha symbols that aren't punc, space, tab, newline
	ccPunc,
	ccSpace,
	ccTab,
	ccNewline,
	ccNone			// for all non-typing marks

} CHAR_CLASS;


// Undo/Redo : To store DeleteStream's col2, line2, and "type"
typedef struct {

	ILINE	iline;
	IB		ib;

} TXUPT;		// TeXt Undo PoinT

// Undo/Redo : To store InsertStream's len and chars
typedef struct {
	_CB		cbStream;
	char	rgch[1];
} STREAM;

// Undo/redo : Mark data
typedef struct {
	MARK_TYPE	mt;
	CHAR_CLASS	cc;		// for use when mt == mtTyping : class of last char typed
	BOOL		fRestoreSelection;
} MARK;

// Undo/redo : Variant record
typedef union {
	TXUPT		txuptLim;		// Stores the second point for a delete operation
	char		ch;
	STREAM		s;
	MARK		mark;
} X;

// Undo/Redo : Structure of record definition
typedef struct {

	_CB			cbPrevRec;		// MUST BE FIRST FIELD !
	ILINE		ilineFirst;
	IB			ibFirst;

	EDIT_ACTION	edAction;		// Type of logical editing action
	X			x;				// Variant part

} UNDO_REC;
typedef UNDO_REC UNALIGNED *PUNDO_REC;

// Undo/Redo : Size of variant components
#define HDR_INSERTSTREAM_SIZE (sizeof(UNDO_REC) - sizeof(X) + sizeof(STREAM))
#define HDR_DELETESTREAM_SIZE (sizeof(UNDO_REC) - sizeof(X) + sizeof(TXUPT))
#define HDR_REPLACECHAR_SIZE (sizeof (UNDO_REC) - sizeof (X) + sizeof (STREAM))
#define HDR_MARK_SIZE (sizeof(UNDO_REC) - sizeof(X) + sizeof(MARK))

// Undo/Redo: Mark state
typedef enum {

	msNormal,			// Allow marks to be pushed
	msIgnoreNormal,		// Don't allow marks to be pushed -- part of a large edit
	msIgnoreError		// Don't allow marks to be pushed -- had error

} MARK_STATE;

// #3623 [mannyv] 21-Apr-1994.
// #define REC_CANNOTUNDO   -1
// (we should really use LONG_MIN here, but this is fine for now [mikemo])
#define REC_CANNOTUNDO  0x80000001

// Undo/redo : Information in a document.  This must be created by calling "CreateRecBuf"
// in the document's initialization process.
typedef struct {

	HANDLE		hUndoRecBuf;	// Handle to memory, ptr stored in pUndoRecBuf when locked
	_CB			cbUndoBuf;		// No. bytes currently allocated in pUndoRecBuf
	IB			ibCurOffset;	// Offset of current undo/redo rec in buffer
	UINT		cRecsTotal;		// Count of records in the buffer (total)
	UINT		cRecsMark;		// Count of mark records in the buffer (i.e., undoable actions)
	UINT		cRecsMove;		// Count of Move records in the buffer
	MARK_STATE	ms;				// Should marks be pushed/ignored
	UINT		cNestLevel;		// Counter for the nesting level of Begin/EndCompoundEdit
	PUNDO_REC	pUndoRecBuf;	// Pointer to stream of undo/redo records

} UNDO_REC_HDR, *PUNDO_REC_HDR;


//Messages : User messages
// These must be unique, and DEBUGGERMSGBASE must have
// the greatest value.
// REVIEW: why not enumerate? :
// enum {
//   WMU_RELOADFILE = W_USER + 10,
//   WMU_STATUSREADONLY,
//	 ...
// };
#define WMU_RELOADFILE 				(WM_USER + 10)
#define WMU_STATUSREADONLY			(WM_USER + 11)
#define WU_CLOSECHILDCLIENT			(WM_USER + 12)
#define WU_MESSAGEBOX				(WM_USER + 13)
#define WU_REMOTEQUIT				(WM_USER + 14)
#define WU_FINDSYMBOLS				(WM_USER + 15)
#define WU_DEBUGGERMSGBASE			(WM_USER + 16)  // Must be last!

//CPU : Actions
// REVIEW: Why not enumerate?
#define CPU_FIRST			0
#define CPU_LAST			1
#define CPU_FIRSTONLINE		2
#define CPU_LASTONLINE		3
#define CPU_NEXT			4
#define CPU_PREVIOUS		5

//CPU : Areas
// REVIEW: Why not enumerate?
#define CPU_NONE			0
#define CPU_REGISTERSAREA	1
#define CPU_FLAGSAREA		2

// Full Screen : Structure definition
typedef struct {
	BOOL	bFullScreen;
	BOOL	bFirstTime;	// Is this the first time into full screen ever?
	RECT	rectFullScreen;
	BOOL	bVert;	// Were there scroll bars before?
	BOOL	bHorz;
} FULLSCREENDATA;


//Run/Debug : Structure definition
typedef struct {
	char commandLine[50];
	BYTE animateSpeed;
	BYTE debugMode ;
	BOOL extendedRegisters;
	BOOL fHardMode ;
	BOOL fOleRpc;			// whether to trace into OLE remote proc calls
    BOOL fReturnValues;		// Display Return Values in Auto Tab
    BOOL fDataTips;			// Display Data Tips
    BOOL fWatchExt;			// Display Watch window extensions (auto/this)
    BOOL decimalRadix;      // hex or decimal display mode
	BOOL fFiberDebugging;		// whether to enable fiber debugging support

	// Toolbars
	BOOL fLocalsToolbar;	// locals toolbar enabled
	BOOL fWatchToolbar;		// watch window toolbar enabled
	BOOL fMemoryToolbar;	// memory window toolbar enabled

	// Call stack window
	BOOL fCallParams ;
	BOOL fCallTypes ;

	// Disassembly window
	BOOL fDAMAnnotate ;
	BOOL fDAMCodeBytes ;
	BOOL fDAMLowerCase ;
	BOOL fDAMSymbols ;

	// Register window
	BOOL fCPURegs ;
	BOOL fCPUFlags ;
	BOOL fCPUEA ;
	BOOL fCPUFloat ;

	// Memory window
	CString strExpr;
	UINT iMWFormat;
	BOOL fMWLive;
	BOOL fMWShowRaw;
	UINT iMWItemsPerLine;
	int	 iMWAutoTypes;

	// Watch window.
	UINT iWatchNameColWidth;
	UINT iVarsNameColWidth;
	UINT iQWNameColWidth;
	BOOL fVarsToolbar;
	BOOL fUnicodeStrings;
	BOOL fLoadExports;

#ifdef CODECOVERAGE
	BOOL fCodeCoverage;
#endif

    // Edit and Continue
    BOOL fENCDebugging;     // whether to enable edit & continue debugging
    BOOL fENCRelink;        // relink after ENC session?
    UINT iENCTraceLevel;    // Trace level for ENC warning messages 
                            // Messages with level <= iENCTraceLevel will appear in the output window
	BOOL fENCRepro;			// Switch to assist reproducing / debugging ENC test cases
	BOOL fENCLoadIdb;		// load .idb files to detect header dependencies?

} RUNDEBUGPARAMS;
typedef RUNDEBUGPARAMS near *NPRUNDEBUGPARAMS;
typedef RUNDEBUGPARAMS far *LPRUNDEBUGPARAMS;

//Status Bar : Actions
// REVIEW: Why not enumerate?
#define STATUS_SIZE        1
#define STATUS_HIDE        2
#define STATUS_UNHIDE      3

//Status Bar : Display Text type
#define STATUS_INFOTEXT							0
#define STATUS_MENUTEXT							1
#define STATUS_ERRORTEXT						2
#define STATUS_CHILDMENUTEXT					3

//Status Bar : Size of strings components
#define STATUS_OVERTYPE_SIZE 					3
#define STATUS_READONLY_SIZE					4
#define STATUS_LINE_SIZE						5
#define STATUS_COLUMN_SIZE						3
#define STATUS_TID_SIZE							8
#define STATUS_COL_SIZE							3

//Status Bar : Pens and Brushes colors
#define GRAYLIGHT 				0x00C0C0C0
#define GRAYDARK 				0x00808080
#define WHITEBKGD				0x00FFFFFF

#ifdef BYEBYE
//Status Bar : Structure definition
typedef struct {
	BOOL errormsg;								// status text is an error message

	BOOL overtype;								//Overtype status
	char overtypeS[STATUS_OVERTYPE_SIZE + 1];	//Overtype string

	BOOL readOnly;								//ReadOnly status
	char readOnlyS[STATUS_READONLY_SIZE + 1];	//ReadOnly string

	BOOL colSelect;
	char colSelectS[STATUS_COL_SIZE + 1];		//Col string

	int line;									//Current line (Not displayed when values 0)
	char lineS[STATUS_LINE_SIZE + 1];			//Line string

	int column;									//Current column (Not displayed when values 0)
	char columnS[STATUS_COLUMN_SIZE + 1];		//Column string

	DWORD tid;
	char tidS[STATUS_TID_SIZE + 1];				//TID string
	
	UINT lastTxt;								//Last text ressource # loaded
		
} STATUS;
typedef STATUS near *NPSTATUS;
typedef STATUS far *LPSTATUS;
#endif // BYEBYE

//Workspace : Basic window information
typedef struct {
	RECT coord;
	long style;
} WININFO;
typedef WININFO near *NPWININFO;
typedef WININFO far *LPWININFO;



//Editor & Project: Type of file kept
#define 	EDITOR_FILE		0

//Editor : Horizontal scroll ratio (1/5 of the window)
#define SCROLL_RATIO		5

//Editor : Code for No View
#define NOVIEW 						255

//Editor : Standard chars in text files
#define LF 						10
#define CR                 		13
#define TAB                		9
#define BS                 		8

//Editor : Status of a line
// REVIEW: Why not use shift?
// #define COMMENT_LINE				(1 << 0)
// #define MULTISTRING_LINE			(1 << 1)
// ...
#define COMMENT_LINE				0x1		//This line is fully commented
#define MULTISTRING_LINE			0x2  	//This line is a multiline string
#define TAGGED_LINE					0x4  	//Tagged by the user
#define BRKPOINT_LINE				0x8  	//Brk Point Commited
#define CURRENT_LINE				0x10 	//Current line when debugging
#define ERROR_LINE					0x20 	//Line with compile error
#define ASSEMBLY_LINE	  			0x40 	//AL.
#define AFX_LINE					0x080	//In AFX modified block
#define AFX_BEGIN					0x100 	//Start AFX modified block
#define AFX_END						0x200	//End AFX modified block
#define AFX_BITS					(AFX_BEGIN 	|\
									 AFX_LINE	|\
									 AFX_END)
#ifdef CODECOVERAGE
#define COVERAGE_LINE				0x1000	// Has been current line while debugging
#endif
#define CALLER_LINE					0x2000  // Viewed line when walking back
											// the call chain
#define DISABLED_BRKPOINT_LINE	    0x4000  // Disabled Breakpoints
#define MIXED_BRKPOINT_LINE	        0x8000  // Mixed Enabled/Disabled Breakpoints
#define HAS_BRKPOINT	            (BRKPOINT_LINE |\
                                     DISABLED_BRKPOINT_LINE |\
                                     MIXED_BRKPOINT_LINE) // any breakpoint line

//Editor : State when reading a file
// REVIEW: Why not enumerate?
#define END_OF_LINE		0
#define END_OF_FILE 	1
#define END_ABORT 		2

//Editor : Last line convention
#define LAST_LINE	 					MAX_LINE_NUMBER + 1

//Editor : Line status action
enum LINESTATUSACTION
{
	LINESTATUS_ON,
	LINESTATUS_OFF,
	LINESTATUS_TOGGLE
};

#define MAX_USER_LINE		MAX_LINE_SIZE	//Max length of user line
typedef USHORT LSTAT;		// Line STATus


// The selection margin feature allows the editor views to display lines
// starting at a settable offset from the left edge of their window.  This
// margin can be used for line/function selection as well as the display of
// icons indicating the "current line (IP)", breakpoints, etc...
//
// The selection margin is set to DEF_SELECT_MARGIN for all	document views.
// Debug and output views to not have margins by default.
// The margin of a view may be set at any time by simply changing the view's
// cxSelectMargin member and invalidating it.

// Default width of a selection margin for a DOC_WIN (others use 0)
#define DEF_SELECT_MARGIN 20

//Document : Type of document

typedef enum {
	CPU_WIN			= 0,		// registers
	MEMORY_WIN,					// memory
	CALLS_WIN,					// call stack
	DISASSY_WIN,				// disassembly
	PHINWATCH_WIN,				// watch
	PHINLOCALS_WIN,				// variables
	BREAKPT_WIN,				// breakpoints ?? is this used??
	DOC_WIN,					// source document
	UNKNOWN_WIN					// unknown window type
} DOCTYPE;


#if 0
//
//	These are the different types of MDI windows that are of interest to the
//	debugger.
	
enum DBG_WINDOW_TYPE
{
	DBG_WINDOW_UNKNOWN = 0,
	DBG_WINDOW_OUTPUT,
	DBG_WINDOW_WATCH,
	DBG_WINDOW_VARIABLES,
	DBG_WINDOW_REGISTERS,
	DBG_WINDOW_MEMORY,
	DBG_WINDOW_CALL_STACK,
	DBG_WINDOW_DISASSEMBLY,
	DBG_WINDOW_SOURCE
};

#endif
struct DOCK_IDS_TAB {
	UINT	nID;
	UINT	nIDPacket;
	UINT	nIDResource;
	UINT	nIDString;
	DOCTYPE	type;
};

const DOCK_IDS_TAB* DockTabFromID(UINT nID);
const DOCK_IDS_TAB* DockTabFromType(DOCTYPE type);

//Document : Mode when opening files
typedef enum {
	MODE_OPENCREATE		= 0,// Open in new window, prompt to create if not exist
	MODE_CREATE,			// Create in new window
	MODE_OPEN,				// Open in new window, error if not exist
	MODE_DUPLICATE,			// Duplicate window
	MODE_RELOAD,			// Reload file in current window (?)
	MODE_RELOADOTHER,		// Reload file in other window (?)
	MODE_SAMEWINDOW,		// Open in same window, prompt to create if not exist
} FOPENMODE;

//Debugger : Animate speeds
// REVIEW: Why not enumerate?
#define SLOW_SPEED			0
#define MEDIUM_SPEED		1
#define FAST_SPEED			2

//Debugger : Debugging Mode
// REVIEW: Why not enumerate?
#define SOFT_DEBUG			0
#define HARD_DEBUG			1

//Debugger : Special UOFFSET value
#define UOFF_NIL			((UOFFSET) -1)

//Debugger : Breakpoint buffer sizes
#define BKPT_LOCATION_SIZE	128
#define BKPT_WNDPROC_SIZE 	128
#define BKPT_EXPR_SIZE 		128

//Degugger : Breakpoints types
typedef enum
{
	BRK_AT_LOC,
	BRK_AT_LOC_EXPR_TRUE,
	BRK_AT_LOC_EXPR_CHGD,
	BRK_EXPR_TRUE,
	BRK_EXPR_CHGD,
	BRK_AT_WNDPROC,
	BRK_AT_WNDPROC_EXPR_TRUE,
	BRK_AT_WNDPROC_EXPR_CHGD,
	BRK_AT_WNDPROC_MSG_RECVD
} BREAKPOINTACTIONS;

//Debugger : Set Breakpoint structure definition
typedef struct {
	BREAKPOINTACTIONS nAction;
	char szLocation[BKPT_LOCATION_SIZE];
	char szWndProc[BKPT_WNDPROC_SIZE];
	char szExpression[BKPT_EXPR_SIZE];
	UINT wLength;
	UINT MessageClass;
	UINT Message;
} BRKPTSTRUC;

//Debugger : Current debugging informations
typedef struct
{
	CDocument   *pDoc;
	int         CurTraceLine;
	UOFFSET     CurTraceDelta;
	int         StepMode;
#if 0
	BOOL        fInHardMode;
#endif
	BOOL        fModeChanged ;
}  TRACEINFO;

typedef enum {HARDMODE, SOFTMODE, CHECKMODE} DEBUGMODE;

// Structure for STATUS file
typedef struct {
	char ucInitialState;
	RECT rcInit;
} INITSTS;


// DIALOG PARAMETERS Structure
typedef struct {
	LPSTR lpCaption;
	LPSTR lpParam;
} DIALOGPARAM, _far * LPDIALOGPARAM;

// Calling of Dirs Dialog with Params
// REVIEW: Why not enumerate?
#define DIRS_HELP_FOCUS					1
#define DIRS_LIB_FOCUS					2
#define DIRS_INC_FOCUS					3
#define DIRS_MFC_FOCUS					4

//Windows 3.1 defines
#define WM_MDITILEVERTICAL		0
#define WM_MDITILEHORIZONTAL	1
#define SCALABLE_FONTTYPE		0x0004

// Debugging DLL's
#define 	NB_DLLS			5

// Timer ID's
#define TID_RELOADFILES		8
#define TID_PREREAD			9

#define INITIAL_PRELOAD_INTERVAL	2000
#define MINIMUM_PRELOAD_INTERVAL	500

// signed versions of LOWORD/HIWORD macros for routines that take int parms
// and must have the sign extension take place (eg Mouse messages!)
#define SIGNED_LOWORD(x)		((SHORT)LOWORD(x))
#define SIGNED_HIWORD(x)		((SHORT)HIWORD(x))


/****************************************************************************

	CALL BACKS:

****************************************************************************/
extern void ExitInstance();

// WIN32 - change all WndProc prototypes...
long FAR PASCAL EXPORT MainWndProc(HWND, UINT, UINT, LONG);

//Call Back to Handle About Dialog BOX
BOOL FAR PASCAL EXPORT DlgAbout(HWND, UINT, UINT, LONG);

//Call Back to Handle File Print Dialog BOX
BOOL FAR PASCAL EXPORT DlgPrint(HWND, UINT, UINT, LONG);

//Call Back to Handle Page Setup Dialog BOX
BOOL FAR PASCAL EXPORT DlgPageSetup(HWND, UINT, UINT, LONG);

//Call Back to Handle Edit Syntax Dialog BOX
BOOL FAR PASCAL EXPORT DlgSyntax(HWND, UINT, UINT, LONG);

//Call Back to Handle Edit Find Dialog BOX
BOOL FAR PASCAL EXPORT DlgFind(HWND, UINT, UINT, LONG);

//Call Back to Handle Edit Replace Dialog BOX
BOOL FAR PASCAL EXPORT DlgReplace(HWND, UINT, UINT, LONG);

//Call Back to Handle View Line Dialog BOX
BOOL FAR PASCAL EXPORT DlgLine(HWND, UINT, UINT, LONG);

//Call Back to Handle View Function Dialog BOX
BOOL FAR PASCAL EXPORT DlgFunction(HWND, UINT, UINT, LONG);

//Call Back to Handle Debug Calls Dialog BOX
BOOL FAR PASCAL EXPORT DlgCalls(HWND, UINT, UINT, LONG);

//Call Back to Handle Debug Modify Value Dialog BOX
BOOL FAR PASCAL EXPORT DlgModify(HWND, UINT, UINT, LONG);

//Call Back to Handle Debug QuickWatch Dialog BOX
BOOL FAR PASCAL EXPORT DlgQuickW(HWND, UINT, UINT, LONG);

//Call Back to Handle Debug Watch Value Dialog BOX
BOOL FAR PASCAL EXPORT DlgWatch(HWND, UINT, UINT, LONG);

//Call Back to Handle Debug Set Break Point Message Dialog BOX
BOOL FAR PASCAL EXPORT DlgMessage(HWND, UINT, UINT, LONG);

//Call Back to Handle Debug Set Breakpoint Dialog BOX
BOOL FAR PASCAL EXPORT DlgSetBreak(HWND, UINT, UINT, LONG);

//Call Back to Handle Option Tools Dialog BOX
BOOL FAR PASCAL EXPORT DlgTools(HWND, UINT, UINT, LONG);

//Call Back to Handle Tool Arguments Dialog BOX
BOOL FAR PASCAL EXPORT DlgToolArgs(HWND, UINT, UINT, LONG);

//Call Back to Handle Options Workspace Dialog BOX
BOOL FAR PASCAL EXPORT DlgWorkspace(HWND, UINT, UINT, LONG);

//Call Back to Handle Options Directories Dialog BOX
BOOL FAR PASCAL EXPORT DlgDirs(HWND, UINT, UINT, LONG);

//Call Back to Handle Options Colors Dialog BOX
BOOL FAR PASCAL EXPORT DlgColors(HWND, UINT, UINT, LONG);

//Call Back to Handle Fonts Select Dialog BOX
BOOL FAR PASCAL EXPORT DlgFonts(HWND, UINT, UINT, LONG);

// call back to handle user control buttons
LONG FAR PASCAL EXPORT QCQPCtrlWndProc (HWND, UINT, UINT, LONG) ;

//Call Back to Handle File Open Save and Open Project
BOOL FAR PASCAL EXPORT DlgFile(HWND, UINT, UINT, LONG);

//Call Back to Handle Edit Confirm Replace Dialog BOX
BOOL FAR PASCAL EXPORT DlgConfirm(HWND, UINT, UINT, LONG);

//Call Back to Handle Edit Find Next Dialog BOX
BOOL FAR PASCAL EXPORT DlgFindNext(HWND, UINT, UINT, LONG);

BOOL FAR PASCAL DlgMemory(HWND,unsigned,UINT,LONG);

#define FMultiEditView(pv)	((pv)->IsKindOf(RUNTIME_CLASS(CMultiEdit)))
#define FMultiEditDocType(dt) ((dt)==MEMORY_WIN||(dt)==CALLS_WIN||(dt)==DISASSY_WIN||(dt)==CPU_WIN)

class CMultiEdit;

void OnViewActivate( CMultiEdit *, BOOL );

//	inline helper functions.

inline BOOL IsCmdFromPopupMenu(CCmdUI * pCmdUI)
{
	return ((pCmdUI->m_pMenu != NULL) ||
		CBMenuPopup::IsCBMenuCmdUI(pCmdUI));
}

// For functions that we export up to the shell:

#ifdef __cplusplus
#define IDE_EXPORT extern "C" __declspec (dllexport)
#else
#define IDE_EXPORT __declspec (dllexport)
#endif	// __cplusplus

// Include CodeView types, prototypes, and variables

#define INC_ASSERT
#define INC_CVINFO
#define INC_CW
#define INC_EXPRESSIONS
#define INC_GLOBALS
#define INC_LINKEDLIST
#define INC_MEMORY
#define INC_MESSAGES
#define INC_OSDEBUG
#define INC_PROTOTYPES
#define INC_REGISTERS
#define INC_SYMBOLS
#define GUIDE
#include "cv.h"

#endif

#include "path.h" // For BAM-BAM _chdir fix
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\retvals.h ===
// retvals.h : header file
//
#ifndef __RETVALS_H__
#define __RETVALS_H__


class CRetVals : public CObject
{
public:
	CRetVals ();
	~CRetVals ();

	VOID CleanUp ();
	VOID AddTM (LPCSTR szName, LPCSTR szValue, LPCSTR szType = "");
	CPtrList &GetList () { return m_lstTMs; }


private:
	CPtrList m_lstTMs;
};


extern CRetVals g_retVals;	// the global instance


#endif // __RETVALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\qwatch.h ===
// ..\inc\qwatch.h : header file
//

// Forward declaration
class CTM;
class CQuickW;
class CQWGrid;

// Defined in qwatch.cpp, these are private to the quick watch implementation.
class CQWGridEdit;
class CQWGridRow;

enum expr_status { expr_valid, expr_invalid, expr_illegal};

/////////////////////////////////////////////////////////////////////////////
// CQWGrid window

class CQWGrid : public CDbgGridWnd
{
// Construction
public:
	CQWGrid();
	typedef CDbgGridWnd CBaseClass;


// Attributes
public:
	CQuickW	*m_pDlg;
	BOOL m_bIsModified;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQWGrid)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CQWGrid();

	expr_status AddNewExpression(const CString&);

	virtual BOOL ProcessKeyboard(MSG *pMsg, BOOL bPreTrans = FALSE);
	virtual LRESULT OnUpdateDebug(WPARAM, LPARAM);

	// Generated message map functions
protected:
	//{{AFX_MSG(CQWGrid)
	afx_msg UINT OnGetDlgCode();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CQuickW dialog

class CQuickW : public C3dDialog
{
// Construction
public:
	CQuickW(CWnd* pParent = NULL);   // standard constructor
	typedef C3dDialog CBaseClass ;

	CQWGrid m_qwGrid;
	CString  m_strInit;

	expr_status ReplaceQWExpr(const CString&);

	// Helper functions.
	inline CTM * GetCurTM( );
	inline BOOL IsCurRowEditable();
	CString StripWhiteSpace(const CString& str);

	void ChangeDefButton(UINT nID); // Changes the default push-button, correctly.
	void UpdateControls(UINT nForceId = 0 );		// enable-disable buttons etc.

	// grid control sends this notification when a new row 
	// within the grid control gets selected.
	void OnSelChanged(CQWGridRow *pRow);

// Dialog Data
	//{{AFX_DATA(CQuickW)
	enum { IDD = IDD_QUICKWATCH };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQuickW)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL m_bIsValidExpr;
	
	// Generated message map functions
	//{{AFX_MSG(CQuickW)
	virtual BOOL OnInitDialog();
	afx_msg void OnQuickwNewexpr();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnCBEditChange();
	afx_msg void OnCBSetFocus();
	afx_msg void OnCBSelChange();
	afx_msg void OnQuickwAdd();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// static members.
public:
	static CStringArray s_rgstr;	
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\rundebug.h ===
//
// Variables
//
extern CPtrList DLLGridInfoList;

//
// Functions
//
void ClearDLLInfo(HTARGET hTarget = NULL);
void PurgeDLLInfo(void);
void BuildLocalDLLsStringList(CStringList& slLocalDLLs, BOOL fPreloadOnly);
BOOL FGetLocalDLLFromRemoteDLL(CString& strLocal, CString strRemote);
BOOL FGetRemoteDLLFromLocalDLL(CString strLocal, CString& strRemote);
void AddRecToDLLInfo(CString strLocal, CString strRemote, BOOL fPreload, HTARGET hTarget);
void UpdateDLLInfoRec (CString	strLocal,
					   CString	strRemote,
					   BOOL		fPreload,
					   HTARGET	hTarget,
					   BOOL		fSearchOnLocal);

//
// Structs
//

// DLLGridInfoList contains a list of pointers to GRIDINFOs 
//	(one for each build target)
// Each GRIDINFO contains an HTARGET and a list of pointers to DLLRECs 
//	(one for each grid entry)
typedef struct {
	HTARGET hTarget;
	CPtrList DLLRecList;
} GRIDINFO;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\stsfile.h ===
BOOL LoadFromOPTFile(CStateSaver &stateSave);
BOOL SaveIntoOPTFile(CStateSaver &stateSave);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\rwv.h ===
// Start at 0x1000 to ensure that we do not collide with
// !OSDEBUG4s dwGrp values
typedef enum _rwf {
    rwfNone = 0x1000,		// Nothing in location
    rwfHexReg,				// Hex displayed value
    rwfFlag,				// Flag (bit) value
	rwfFloat,				// floating point displayed value

	// Text.  Used when DBL_CLICKING to toggle a flag
	// this will effectively "widen" the DBL_CLICK region
	rwfText,

	// rwfEffAddr and effData will BOTH be present if there's
	// an EA and the entire display doesn't fit on 1 line.  If
	// there's enough room, then rwfEffAddr will be present.

    rwfEffAddr,				// EA combination (addr & value)
    rwfEffAddrOnly,			// EA address only, not editable
    rwfEffData				// EA data only, editable
} RWF;

#define cbRegMax    64
typedef union _ur {
    BYTE    rgb[ cbRegMax ];
    ULONG   ul;
} UR;
typedef UR FAR * LPUR;

typedef union _ut {
	RT	rt;
	FT	ft;
} UT;
typedef UT FAR * LPUT;

typedef struct _rui {
    RWF		rwf;
	UT		ut;
    DWORD	hReg;
    WORD    iFlag;
	WORD	cbEA;			// Number of bytes for EAs only
	ADDR	addrEA;			// Address for EAs only
    UR		ur;
} RUI;
typedef RUI FAR *   LPRUI;
typedef HLLE    	HRUI;

typedef HLLE    	HRWI;
#define hrwiNull    ((HRWI)hlleNull)

typedef struct _rwi {
    RUI     rui;            // This MUST be the first item in this struct
    LSZ     lsz;            // since RWIs and RUIs are BOTH passed to
							// RWSetReg!!!
    UINT    cbit;
    WORD    obSzMin;		// char index for beginning of label
    WORD    obValMin;		// char index for beginning of value
    WORD    obValMac;		// char index for end+1 of value
    DWORD   oln;			// display line for item
	DWORD	dwGrp;			// display group (determines breaks)
    HRWI    hrwiPrev;		// Previous pointer (for non-dbl linked)
	UR		urDiff;			// data from previous execution
} RWI;
typedef RWI FAR *    LPRWI;

class CCpuView : public CMultiEdit {
	DECLARE_DYNCREATE(CCpuView)

	private:
		/* List of edits for undo/redo */
		HLLI    	m_hlliRuiUndo;
		HLLI    	m_hlliRuiRedo;

		/* List of registers, values, and cooridnates */
		HLLI    	m_hlliRwi;

		/* Item which needs to be saved */
		HRWI		m_hrwiEdit;

		/* Display attributes */
		BOOL		m_fShowCpu;
		BOOL		m_fShowFlags;
		BOOL		m_fShowEA;
		BOOL		m_fShowFPU;

		/* Update parameters */
		WORD		m_wEM;
		WORD		m_wModel;
		BOOL		m_f386Mode;

		/* Index to here the EA item should be placed */
		DWORD		m_ihrwiEA;
		int			m_cEA;

		/* max display width (calculated) */
		WORD		m_obMax;
		WORD		m_obMacPrev;

#if defined (_X86_)
		/* display width of long double */
		size_t		m_cchLongDouble;
#endif	// _X86X

		/*
		*  axMax == max chars per line
		*  4 == (smallest display entry == flag)
		* 		1 + 	space
		* 		1 + 	single char flag name
		* 		1 +		'='
		* 		1 +		value ( 0 || 1 )
		*
		* The following will allow us to display axMax * 4 - 1
		* flags on a SINGLE line.  This is overkill, but here
		* we will not have to worry about dynamic allocations
		* and memory failures.
		*/
		DLA 	m_rgdla[ axMax ];

		/* member functions */
		BOOL 	FIsVisible( HRWI );
		void 	UpdateDocInfo();
		void 	SaveForUndo( LPRUI );
		void	WriteReg( LPRUI, LPUR );
		void 	FlushEdit( BOOL );
		void 	NextField( void );
		void 	PrevField( void );
		void 	SetReg( LPUR, HRUI, BOOL );
		RWF 	RwfFieldType( HRWI * );
		void 	ToggleFlag( HRWI );
		void 	RwiUpdateEA( void );
		void	AddEANode( DWORD, int, LPCH, LPADDR, int );
		void 	UpdateRwi( void );
		void 	UpdateRegs( void );
		void 	UndoValue( BOOL );
		BOOL 	FDoKeyDown( WPARAM, LPARAM );
		BOOL 	FDoChar( WPARAM, LPARAM );
		void 	Freeze( void );
		void 	RecalcCoords( BOOL );
		void 	UpdateDisplay( BOOL );
		int		InitWndMgr( void );
		void 	DestroyInfo( void );
		void	InitializeMembers( void );
		size_t	CchFloatFromRwi( LPRWI );

	protected:
		BOOL	PreTranslateMessage( MSG * pMsg );

	public:
		/* default constructor/destructor */
		CCpuView();
		virtual ~CCpuView();

		virtual DWORD GetHelpID() { return HID_WND_REGISTERS; }
		virtual BOOL  IsEditable( ) { return TRUE; }

		virtual void ShowContextPopupMenu(CPoint pt);

		// No textual help available for this window!
		virtual BOOL GetHelpWord( CString& strHelp ) { return FALSE; }

		WORD 		CbGetLineBuf( DWORD, WORD, char *, PDLA & );
		WORD		ObMaxBuf( void );
		DWORD		CLinesInBuf( void );

		LRESULT	LTextProc( UINT, WPARAM, LPARAM );

	private:
		friend class CDebugPackage;
		// g_cRef is the count of instantiations of CTextView, used to
		// initialize g_pFontInfo which is the pointer to the CFontInfo
		// for this view type
		static UINT g_cRef;
		// Pointer to the font information for this view type
		static CFontInfo *g_pFontInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\thread.h ===
// Wndproc for the thread dialog box
BOOL FAR PASCAL EXPORT DlgThread(
		  HWND       hDlg,
		  unsigned   message,
		  UINT       wParam,
		  LONG       lParam);

// Fields padding for the listbox
#define THREAD_FIELD1       1                           // fCurrent
#define THREAD_FIELD2       (THREAD_FIELD1 + 1 + 8)     // id
#define THREAD_FIELD3       (THREAD_FIELD2 + 1 + 6)     // cSuspend
#define THREAD_FIELD4       (THREAD_FIELD3 + 1 + 4)     // szPriority
#define THREAD_FIELD5       (THREAD_FIELD4 + 1 + 36)    // szLocation

// Structure for storing the exceptions
typedef struct {
	DWORD id;		// NT Thread ID
	DWORD cSuspend;	// Suspend count
	DWORD cSuspendNew; // New suspend count after user modifications in dialog
	CHAR szPriority[STATESTRINGSIZE]; // Thread priority, as string from OSDebug
	DWORD address;	// Thread address
	CHAR Location[THREAD_FIELD5-THREAD_FIELD4+1]; // Thread function name
	BOOL HasFocus;	// Is this the current thread ?
	}THREAD_OBJECT;


// used to give/kill focus to a thread
#define THREAD_FOCUS				1000
#define THREAD_KILLFOCUS			1001
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\tracefn.h ===
// tracefn.h : header file
//
#ifndef __TRACEFN_H__
#define __TRACEFN_H__

/////////////////////////////////////////////////////////////////////////////
// CTraceFunction

class CTraceFunction : public CObject
{
// Construction
public:
	CTraceFunction();
	~CTraceFunction();

// Attributes
public:

// Operations
public:
	BOOL SetupStep (VOID);
	BOOL GetString (CString &);
	BOOL CompareCxt (PCXT pCXT);

// Implementation
protected:
	ADDR m_addrPC;
	ADDR m_addrLine;
	WORD m_wLineStart;
	WORD m_wLineEnd;
	TML	m_tml;
	BOOL m_fTmlInitialized;
};

extern CTraceFunction *g_pTraceFunction;

/////////////////////////////////////////////////////////////////////////////
#endif // __TRACEFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\treegrid.h ===
#ifndef __TREEGRID_H__
#define __TREEGRID_H__

// varswnd.h : header file
//

#include "utilctrl.h"

class CTreeGridRow;

class CTreeGridWnd;

typedef CTypedPtrArray<CPtrArray, CTreeGridRow *> CTreeGridRowArray;

// Private messages 
#define WM_DISMISS_CONTROL  (WM_USER + 10)	 // send to dismiss control
#define WM_WARN_AND_EXPAND	(WM_USER + 11)	 // warn about expansion time and then expand.

/////////////////////////////////////////////////////////////////////////////
// CTreeGridRow 
// A specialized grid row which can live in a Tree like Grid control.



class CTreeGridRow : public CGridControlRow 
{
public:
	CTreeGridRow(CTreeGridWnd *, CTreeGridRow * = NULL );
	virtual ~CTreeGridRow();
	typedef CGridControlRow  CBaseClass;

// Attributes	
public:
	virtual BOOL IsExpandable( ) const = 0;
	virtual BOOL GetChildren(CTreeGridRowArray& ) = 0;
	virtual DWORD GetChildCount() = 0;

	// Only the special row for adding new entries should 
	// return TRUE on this function call.
	virtual BOOL IsNewRow( ) const; 

	// Place holders for function to call if some external
	// state change should force the GridRow to update itself.
	virtual void Update( );
	virtual void Restart( );

	CTreeGridRow * m_pParent;
	int m_nLevels;
	int m_nFlags;
};

class CTGNewRow : public CTreeGridRow 
{
public:
	// Indicates what column should have the fuzzy border and allow
	// editing. Currently only supports one column editing.
	CTGNewRow(CTreeGridWnd *, int editColumn);
	~CTGNewRow( );
	typedef CTreeGridRow CBaseClass;
public:
	virtual BOOL IsExpandable() const;
	virtual BOOL GetChildren(CTreeGridRowArray&);
	virtual DWORD GetChildCount();
		
	virtual BOOL IsNewRow() const;

	virtual void GetColumnText(int nColumn, CString& rStr);
	virtual void OnActivate(BOOL bActivate, int nColumn);
	virtual BOOL OnAccept(CWnd *pControlWnd);
	virtual void DrawCell(CDC *pDC, const CRect& cellRect, int nColumn);
	virtual void ResetSize(CDC *pDC);
	virtual CSize GetCellSize(CDC *pDC, int nColumn) const;
	virtual int GetNextControlColumn(int nColumn);
	virtual int GetPrevControlColumn(int nColumn);
protected:
	int m_editColumn;
};
	
			
// Flags used by the treegrid control.
// plagiarized from utilctrl.h
#define TGF_NONE				0x0000
#define TGF_LASTLEVELENTRY		0x0001
#define TGF_EXPANDED				0x0002
#define TGF_DISABLED				0x0004
#define TGF_EXPANDABLE			0x0008
#define TGF_NOT_EXPANDABLE		0x0020
#define TGF_DIRTY_CONTENT		0x0040
#define TGF_DIRTY_ITEM			0x0010
#define TGF_DIRTY_DELETE		0x0080
#define TGF_DROPTARGET           0x0100
#define TGF_DRAGSOURCE           0x0200
#define TGF_MARK_FOR_DELETE		 0x0400

/////////////////////////////////////////////////////////////////////////////
// CTreeGridWnd window
// A Grid Control with a tree like hierarcichal structure.

class CTreeGridWnd : public CGridControlWnd
{
	DECLARE_DYNAMIC(CTreeGridWnd);

// Construction
public:
	CTreeGridWnd (int nColumns, BOOL bDisplayCaption = TRUE);
	virtual ~CTreeGridWnd();
	typedef CGridControlWnd CBaseClass;

// Attributes
public:
	// is a particular row expanded.    
	BOOL IsExpanded(CTreeGridRow *);

// 
// Operations
public:
	virtual void Expand(CTreeGridRow *, BOOL bRedraw = TRUE);		
	virtual void Collapse(CTreeGridRow *, BOOL bRedraw = TRUE);
	virtual BOOL ToggleExpansion(CTreeGridRow *pRow);

	// Control handling
	virtual void ActivatePrevControl();
	virtual void ActivateNextControl();
	virtual BOOL ProcessKeyboard(MSG *pMsg, BOOL bPreTrans = FALSE);

	virtual BOOL Refresh(CTreeGridRow *, int&);	 
	virtual void RefreshAllRoots( );


	inline CTreeGridRow *GetRowAt(POSITION pos) const
	{	return (CTreeGridRow *)CBaseClass::GetRowAt(pos); }

	CTreeGridRow *GetCurSel( ) const;	// returns the row iff there is exactly 
					    				// 1 item selected, NULL otherwiase

	// The New Row is a special row, which allows to user to enter
	// new values into the grid. Functions related to the new row.
	virtual CTGNewRow * CreateNewRow( );
	virtual void OnEnterNew (CString str);
	virtual void EnableNewRow(BOOL bEnable = TRUE);

	CTreeGridRow * GetRow(int nIndex = -1);
	CTreeGridRow * GetChildRow(CTreeGridRow *, int nIndex);

	virtual void DirtyRow(CTreeGridRow *, int tf);

	// Warn if # if children is greater than count before expanding.
	virtual BOOL GetExpansionWarnCount() { return 1000; }
	// Call if you want to expand a given row.
	virtual BOOL InsertLevel(CTreeGridRow *pParent, BOOL bRedraw = TRUE);

	// Call  if you want to insert a row at level 1.
	virtual BOOL InsertTopLevelRow(CTreeGridRow *pRow, BOOL bRedraw = TRUE);
	virtual BOOL DeleteTopLevelRow(CTreeGridRow *pRow, BOOL bRedraw = TRUE);
	virtual BOOL DeleteSelectedRows( );

	virtual void FreeAllData( );
	virtual void InvalidateGrid();
			
	void InsertRowAfter(CTreeGridRow *pRow, CTreeGridRow *pRowAfter,
			 BOOL bRedraw = TRUE);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTreeGridWnd)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

public:
	BOOL m_bNewRow:1;
	BOOL m_bForceAccept:1; 

protected:

	// These are really grid primitives that are implemented here.
	void InsertMultipleRows(CTreeGridRowArray *rgpRow, CTreeGridRow *pRowAfter,
			BOOL bRedraw = TRUE);
	// True if some row in the grid is selected.
	BOOL HasASelection() const
	{	return (GetHeadSelPosition() != NULL);	}

	void ExpandHelper(CTreeGridRow *pParent, BOOL bRedraw, BOOL bWarn);

public:	
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CTreeGridWnd)mber functions here.
	afx_msg void OnPaint();
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	afx_msg LRESULT OnDismissControl(WPARAM, LPARAM);
	afx_msg LRESULT OnWarnAndExpand(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

	
/////////////////////////////////////////////////////////////////////////////

#endif // __TREEGRID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\tokens.h ===
// tokens.h : header file
//
#ifndef __TOKENS_H__
#define __TOKENS_H__

/////////////////////////////////////////////////////////////////////////////
/// Support classes for wrapping the language packages

// Convenient wrapper for a TXTB. Knows about C++ token values.
// This can only be used with the C++ lexer package loaded. 
class CToken
{
public:
	CToken();
	CToken(const TOKEN&);

	const CToken& operator=(const CToken&);
	const CToken& operator=(const TOKEN&);
	operator TOKEN() const;

	TOKCLS GetTokClass() const;

	inline BOOL IsKeyword( ) const
	{	return (GetTokClass() == tokclsKeyWordMin); }

	inline BOOL IsInError( ) const
	{	return (GetTokClass() == tokclsError);  }

	inline BOOL IsConstant( ) const
	{ TOKCLS tokCls = GetTokClass();  return(tokCls >= tokclsConstInteger && tokCls <= tokclsConstString); }

	inline BOOL IsOperator( ) const
	{	return (GetTokClass() == tokclsOpMin); }

	inline BOOL IsUserIdent( ) const
	{	TOKCLS tokCls = GetTokClass(); return ( tokCls == tokclsIdentMin || tokCls == tokclsIdentUser); }


	BOOL IsCxxIdent( ) const; 		// includes "this" and user idents.
	BOOL IsAssignOp( ) const;
	BOOL IsIndirectionOp() const;	// '*' and '&'
	   
	  
private:
	TOKEN m_token;
	TOKCLS m_tokCls;
	static const TOKCLS * s_rgtokCls;
	static int ctokCls;
};	
		

////////////////////////////////////////////////////////////////////////////////
// CTokenLine

struct CTokenLine : public CObject
{
	CTokenLine( ) { };

	CString m_strLine;
	RGTXTB m_rgtxtb;
#ifdef _DEBUG
	virtual void Dump(CDumpContext &dc) const
	{
		dc << "CTokenLine" ; CObject::Dump(dc);
	}
#endif
};


typedef CTypedPtrArray<CObArray, CTokenLine *> CTokenLineArray;

// Given a CTextDoc and a set of lines this class lets you access the various tokens within 
// the corresponding stream from the textdoc. 


////////////////////////////////////////////////////////////////////////////////
// CTokenStream

class CTokenStreamPos
{
	int m_nIndex;
	int m_nToken;
	friend class CTokenStream;
public:
	inline BOOL IsValid () 
	{	return (m_nIndex != -1); }

	inline BOOL operator == (CTokenStreamPos &pos) const
	{	return (m_nIndex == pos.m_nIndex && m_nToken == pos.m_nToken); }

	inline BOOL operator != (CTokenStreamPos &pos) const 
	{	return !(m_nIndex == pos.m_nIndex && m_nToken == pos.m_nToken); }

	inline BOOL IsAtStartOfLine ()
	{	return (IsValid () && m_nToken == 0); }
};


class CTokenStream : public CObject
{
public:
	CTokenStream(LPSOURCEEDIT pISourceEdit, ILINE begLine, ILINE endLine);	// both begLine and endLine are inclusive.
	virtual ~CTokenStream();

	CTokenStreamPos GetHeadPosition() const;
	CTokenStreamPos GetTailPosition() const;

	TXTB* GetAt (CTokenStreamPos& pos);
	TXTB* GetNext (CTokenStreamPos& pos);
	TXTB* GetPrev (CTokenStreamPos& pos);

	CString GetStringAt (CTokenStreamPos &pos);

// Implementation.
protected:
	CTokenLineArray m_rgTokenLine;

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	
};		

/////////////////////////////////////////////////////////////////////////////
#endif // __TOKENS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\aut1api.h ===
/////////////////////////////////////////////////////////////////////////////
//	AUT1API.H
//		Automation1 package interfaces

#ifndef __AUT1API_H__
#define __AUT1API_H__


/////////////////////////////////////////////////////////////////////////////
//		Macro recording API declarations.  Implemented in devaut1.pkg
//		Further documentation available in recorder.doc (v5spec\vba tree)


/////////////////////////////////////////////////////////////////////////////
//	IMacroRecorder interface

// To check whether to record VBS code, test theApp.ShouldRecordText() before
//  calling this interface's methods.  It will return true if we're recording,
//  pause is off, and it's actually safe to record text (e.g., your code isn't
//  being called from another macro whose invocation was already recorded).
// This function is in the shell so that devaut1.pkg need not
//  be loaded in memory (caused by a call, say, to IMacroRecorder::IsRecording) every
//  time a command is executed.  Also, the shell needs to know whether recording
//  is occurring anyway, since it provides the default "ExecuteCommand" recorded
//  text described below.

#define REC_MAX_TEXT_OWNER_NAME 16

#undef  INTERFACE
#define INTERFACE IMacroRecorder

DECLARE_INTERFACE_(IMacroRecorder, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IMacroRecorder methods

	// This is the method you use to send the VBS text to duplicate the action
	//  just committed by the user in the UI.  For szPkg, provide a string that
	//  identifies yourself so other packages can query the recorder about who
	//  recorded the last text.  For szPkg, provide your package name as in your .pkg
	//  filename, e.g., "devMyPg(d).pkg" would pass "MyPg" as szPkg.
	//
	// If you want to record multiple lines, either call this multiple times, or
	//  call it once, separating the multiple lines with \n.  (Do not begin or end
	//  szText with \n unless you really want the extra newline in there; successive
	//  calls to RecordText are automatically separated by \n.)
	// 
	// If you do not call this method in response to a command, then the shell
	//  will provide a default recorded text:
	//		"ExecuteCommand("<command-name>")"
	//  This will cause "shl" to be the last record text owner (see
	//  GetLastTextOwner below)
	// If you intentionally do not want this command to be recorded at all,
	//  then call RecordText with NULL as szText.  Providing NULL as
	//  szText tells the recorder not to generate any text in the VBS macro
	//  for this action *AND* to tell the shell not to generate any default
	//  text either.
	// The length of szPkg must not exceed REC_MAX_TEXT_OWNER_NAME bytes
	//  (the ending NULL character is included in this count).
	STDMETHOD(RecordText)(LPCTSTR szText, LPCTSTR szPkg) PURE;

	// Before calling ReplaceLastText (see below), call this to find out who
	//  recorded the last piece of text.  This returns the szPkg passed to the
	//  recorder by the last package who called RecordText or ReplaceLastText.
	// The caller must allocate space for rszLastTextOwner.  This method
	//  expects that rszLastTextOwner points to REC_MAX_TEXT_OWNER_NAME
	//  many allocated bytes (including the byte for the NULL character
	//  at the end).  Typically a package will allocate a character array
	//  of this length on the stack, and pass the pointer to the array
	//  as rszLastTextOwner.
	STDMETHOD(GetLastTextOwner)(LPTSTR rszLastTextOwner) PURE;

	// Call this to replace the last text recorded (via RecordText or
	//  ReplaceLastText).  This is used to coalesce commands into a
	//  single VBS call.  For example, if a window is moved twice, the
	//  second move's VBS text can replace the first (since the first
	//  is rendered useless).  Similarly, if the user types "ab", both
	//  kepresses may be coalesced into a single VBS call.  Use
	//  GetLastTextOwner first to make sure you're really the package who
	//  wrote the last text.  Note that if the previous call to RecordText
	//  or RecordLastText contained several lines of code (separated with
	//  \n as described above) then ALL THOSE LINES will be replaced.
	// The length of szPkg must not exceed REC_MAX_TEXT_OWNER_NAME bytes
	//  (the ending NULL character is included in this count).
	STDMETHOD(ReplaceLastText)(LPCTSTR szText, LPCTSTR szPkg) PURE;
};

#endif //__AUT1API_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\aut1api_.h ===
/////////////////////////////////////////////////////////////////////////////
//	AUT1API_.H
//		Automation1 private package interfaces

#ifndef __AUT1API__H__
#define __AUT1API__H__

/////////////////////////////////////////////////////////////////////////////
//	IAut1Misc interface

// Miscellaneous methods we expose to the shell, which don't have a better home can go here

#undef  INTERFACE
#define INTERFACE IAut1Misc

DECLARE_INTERFACE_(IAut1Misc, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IAut1Misc methods

	// Called by tools customize tabs to reload the macros.  Returns
	//  S_OK on success, S_FALSE if an error occurred in loading
	//  one of the macro files (e.g., syntax error).
	STDMETHOD(ReloadMacros)() PURE;
};

	
/////////////////////////////////////////////////////////////////////////////
//	IAddIn interface

#undef  INTERFACE
#define INTERFACE IAddIn

DECLARE_INTERFACE_(IAddIn, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IAddIn methods

	// These are delegated to directly by the OLE Automation Application
	//  object.  These are typically called by an AddIn through the
	//  DevStudio object model's Application object.

	// Returns S_OK for TRUE, S_FALSE for FALSE.  It will throw
	//  an exception via DsThrowOleDispatchException if something
	//  bad happens.
	STDMETHOD(AddCommand)(LPCTSTR szCmdName, LPCTSTR szMethodName,
							long nBitmapOffset, long dwCookie) PURE;

	// Just returns S_OK.  If this returns an error, that error should
	//  be returned from the caller
	STDMETHOD(SetAddInInfo)(long nInstanceHandle, LPDISPATCH pCmdDispatch,
		long nIDBitmapResourceMedium, long nIDBitmapResourceLarge,
		long dwCookie) PURE;

	// Just returns S_OK.  It will throw an exception via 
	//  DsThrowOleDispatchException if something bad happens.
	STDMETHOD(AddCommandBarButton)(long nButtonType, LPCTSTR szCmdName,
		long dwCookie) PURE;
};


// NOTE: This is a private interface used ONLY by the shell to hook in
//  to recording and provide default recorded text if none is provided by
//  the package.
//
// The shell will use this interface in the following way:
//
//	1) A command comes in from the user
//	2) The shell checks to see if recording is on.  If it is,
//	3) Shell calls IRecorderForShell::BeginListenForRecord()
//	4) Shell dispatches command
//	5) Shell calls IRecorderForShell::EndListenForRecord()
//	6) If *pbWasTextRecorded is FALSE, the shell will record the action
//		as a call to Application::ExecuteCommand("<command-name>").
//	7) If *pbWasTextRecorded is TRUE, the shell returns to the message pump


// Note that this interface is not to be used by any client other
//  than the shell.  If two clients try to use this interface,
//  the Begin/End ListenForRecord bracketing will get all fouled
//  up.

#undef  INTERFACE
#define INTERFACE IRecorderForShell

DECLARE_INTERFACE_(IRecorderForShell, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IRecorderForShell methods

	// The shell calls this method to let the macro recorder know that in
	//  the future, the shell will call EndListenForRecord.  When it makes
	//  this call, the recorder will return whether
	//  IMacroRecorder::RecordText was called by any package since
	//  this call to BeginListenForRecord().
	STDMETHOD(BeginListenForRecord)() PURE;

	// Returns (in *pbWasTextRecorded) whether a package called
	//  IMacroRecorder::RecordText (or IMacroRecorder::ReplaceLastText)
	//  since the last call to BeginListenForRecord.  This method has the
	//  side effect of "ending" listening for record, which means that if this
	//  is called two times in a row, the second time will *always*
	//  return FALSE in pbTextRecorded.  In other words, EACH
	//  call to this method must be preceded by its own matching
	//  BeginListenForRecord
	STDMETHOD(EndListenForRecord)(BOOL* pbWasTextRecorded) PURE;
};



#endif //__AUT1API__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\aut1guid.h ===
/////////////////////////////////////////////////////////////////////////////
//	AUT1GUID.H
//		Automation package interface ids.

// Interface ID for the public VBS Macro Recorder interface
//  {E97C65E0-83EF-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IMacroRecorder, 
0xe97c65e0, 0x83ef, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);

// Interface ID for dynamic command provider interface (used by shell)
// {EF272700-112F-11d0-AD07-00A0C9034965}
DEFINE_GUID(IID_ICommandProvider, 
0xef272700, 0x112f, 0x11d0, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\varsview.h ===
class CPersistWatchTab;

void AFXAPI ConstructElements(CPersistWatchTab*, int nCount);
void AFXAPI DestructElements(CPersistWatchTab *, int nCount);
void AFXAPI SerializeElements(CArchive& ar, CPersistWatchTab *, int nCount);

class CBaseVarsView; // Forward declaration.
class CVarsDialogBar;

class CVarsPropPage : public CSlobPage
{
public:
	DECLARE_IDE_CONTROL_MAP()
};

class CVarsSlob : public CSlob
{
	DECLARE_DYNCREATE(CVarsSlob)
public:
	CVarsSlob();
	~CVarsSlob();

	virtual GPT  GetStrProp(UINT nPropId, CString& val);

	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);
	
	static CString  s_strPropCaption;
	static CVarsPropPage s_varsPropPage;

	CBaseVarsView * m_pView;

};


/////////////////////////////////////////////////////////////////////////////
// CBaseVarsView view
class CBaseVarsView : public CDockablePartView
{
protected:	// so we don't create an object of this class directly.
	CBaseVarsView(UINT, UINT);
	DECLARE_DYNAMIC(CBaseVarsView)
	typedef CDockablePartView CBaseClass; 	// another name for our base class.

// Attributes
public:
	inline CDbgGridWnd * GetActiveGrid() const;
 	UINT m_nIDWnd;
	UINT m_nIDPacket;
	CFontInfo * m_pFontInfo;
	CFont	m_font;

// Operations
public:
	virtual BOOL EnsureWindow(); // Creates window if it doesn't exist currently.
	virtual void UpdateTabs( );
	virtual void ResetWidgetScrollBar( );
	virtual void OnFontColorChange();

	// call this function when the grid rows selection status
	// changes in any fashion.
	virtual void OnGridRowSelectionChange( );

	inline void ShowSelection(BOOL bShow);


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBaseVarsView)
	public:
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

protected:
	BOOL m_bHasVScroll:1;
	BOOL m_bFirstNonZeroSize:1;

	CWidgetScrollBar m_widgetScroller;
	int c_nSplitterPref;
	UINT m_iNameColWidth;

	
	CVarsSlob m_slob;	
	CMultiSlob m_multiSlob;
	// Slob added to the MultiSlob to get the multiple selection dialog.
	CSlob m_fakeSlob;

	// Sub-classes should add their windows to this array.
	CTypedPtrArray <CObArray, CDbgGridWnd *> m_arrChildWnd;
	int m_curIndex ; 	// Which child is currently active.
			
	// OLE Drag/Drop
public:
	virtual BOOL		CanDropText();
	virtual BOOL		CanMoveText();
	virtual DROPEFFECT	OnDropEx( COleDataObject* pDataObject, DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point );
	virtual DROPEFFECT	OnDragEnter( COleDataObject* pDataObject, DWORD grfKeyState, CPoint point );
	virtual DROPEFFECT	OnDragOver( COleDataObject* pDataObject, DWORD grfKeyState, CPoint point );
	virtual void		OnDragLeave();
	// utilities
	BOOL				DoDrag(CPoint point);
	BOOL				InitDataSource(COleDataSource& data, const CPoint & point);
	BOOL				InsertFromDataObject(COleDataObject * data, const CPoint & point);
	BOOL				IsDragActive() { return (m_pDragInfo != NULL); }
	// Drag & Drop implementation
private:
	COleDropTarget	m_DropTarget;
	CDragInfo *		m_pDragInfo;

// Implementation
protected:
	virtual ~CBaseVarsView();
	virtual void RecalcLayout();

    virtual CSlob* GetSelection();
    virtual CSlob* GetEditSlob();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBaseVarsView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	afx_msg LRESULT OnChangeTab(WPARAM, LPARAM);
	afx_msg  LRESULT OnUpdateDebug(WPARAM, LPARAM);	
	afx_msg  LRESULT OnClearDebug(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
};

inline CDbgGridWnd * CBaseVarsView::GetActiveGrid( ) const
{
	if ( m_curIndex == -1 )
		return NULL;
	else
		return (m_arrChildWnd[m_curIndex]);
}

inline void  CBaseVarsView::ShowSelection( BOOL bShow )
{
	// tell each of the child windows to show the selection
	for (int i = 0; i < m_arrChildWnd.GetSize(); i++)
		m_arrChildWnd[i]->ShowSelection(bShow);
}	

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CGridWatchView view

class CGridWatchView : public CBaseVarsView
{
public:
	CGridWatchView();
	virtual ~CGridWatchView();

	DECLARE_DYNCREATE(CGridWatchView)
	typedef CBaseVarsView CBaseClass;
	static BOOL EnsureWatchWindow();

// Attributes
public:


// Operations
public:
	virtual void ShowContextPopupMenu(CPoint pt);
	virtual BOOL AddNewWatch(CString);
	virtual DWORD GetHelpID( )	{ return HID_WND_WATCH ; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGridWatchView)
	//}}AFX_VIRTUAL

// Implementation
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CGridWatchView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	friend class CDebugPackage;
	// Font selection info.
	static UINT g_cRef;		// reference count
	static CFontInfo *g_pFontInfo;	
};




/////////////////////////////////////////////////////////////////////////////

class CVarsCombo : public CDockCombo
{
// Construction
public:
	CVarsCombo();

// Attributes
public:
	CVarsDialogBar *m_pToolBar;	
	
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarsCombo)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CVarsCombo();

	// Generated message map functions
protected:
	//{{AFX_MSG(CVarsCombo)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////
// CVarsDialogBar
//
// toolbar wrapper for the variables window...
//

class CVarsDialogBar : public C3dDialogBar
{
public:
	CVarsCombo		m_list;
	BOOL			m_fUpdateListbox;
	BOOL			m_fDoUpdate;
	CSize			m_sizeBar;

	virtual BOOL OnInitDialog();				// dialog is coming up, init items
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
};

/////////////////////////////////////////////////////////////////////////////
// CVarsView view

class CVarsView : public CBaseVarsView
{
public:
	CVarsView();
	virtual ~CVarsView();
	DECLARE_DYNCREATE(CVarsView)

	typedef CBaseVarsView CBaseClass;

// Attributes
public:
	enum { indexLocals = 0 };

// Operations
public:
	virtual void ShowContextPopupMenu(CPoint pt);
	virtual void RecalcLayout( );
	virtual DWORD GetHelpID( )	{ return HID_WND_VARS ; }

	void ResetCallStack( );
	void UpdateCallStack( );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarsView)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL
	protected:
	virtual BOOL OnNotify(WPARAM, LPARAM, LRESULT *);

// Implementation
protected:
	CVarsDialogBar m_toolbar;

protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CVarsView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	afx_msg void OnToggleVarsBar();
	afx_msg void OnUpdateToggleVarsBar(CCmdUI *);
	afx_msg void OnDropDown();
	afx_msg void OnCloseUp();
	afx_msg  LRESULT OnUpdateDebug(WPARAM, LPARAM);	
	afx_msg  LRESULT OnFreezeData(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

private:
	friend class CDebugPackage;
	// Font selection info.
	static UINT g_cRef;		// reference count
	static CFontInfo *g_pFontInfo;	

};

/////////////////////////////////////////////////////////////////////////////

// Perisistence information for the watch window.

class CPersistWatchTab : public CObject
{
	DECLARE_SERIAL(CPersistWatchTab);
public:
	CPersistWatchTab ( );
	CPersistWatchTab (const CString& strTabName);
	const CPersistWatchTab& operator=(const CPersistWatchTab&);

	inline CString& GetTabName();
	void ChangeTabName(const CString& str);
	inline CString& GetWatchName(int index);
	inline int GetWatchCount();
	void AddWatchName(CString& str);
	void ClearAllWatches( );
	void InitDefault( );
			
	CString m_strTabName;
	CStringArray m_arrWatchNames;

	virtual void Serialize(CArchive& ar);
};

CString& CPersistWatchTab::GetTabName( )
{
	return m_strTabName;
}

CString& CPersistWatchTab::GetWatchName(int index)
{
	return m_arrWatchNames[index];
}

int CPersistWatchTab::GetWatchCount( )
{
	return m_arrWatchNames.GetSize();
}

class CPersistWatch : public CObject
{
	DECLARE_SERIAL(CPersistWatch);
	
public:
	CPersistWatch( );

	void InitDefault();
	void ClearAll();

	CPersistWatchTab&  GetWatchTab(int);
	void AddWatchTab(CPersistWatchTab& );
	void AddWatchTab(const CString&);
	int GetTabCount();

	inline void SetActiveTab(int index);
	inline int GetActiveTabIndex();

	int m_curIndex;
	int m_nSplitterPref;
	CArray<CPersistWatchTab, CPersistWatchTab&>	m_arrWatchTab;		

	virtual void Serialize(CArchive& ar);
};


void CPersistWatch::SetActiveTab(int index)
{
	m_curIndex = index;
}

int CPersistWatch::GetActiveTabIndex()
{
	return m_curIndex;
}

/////////////////////////////////////////////////////////////////////////
// Persistence information for the variables window.

class CPersistVarsTab : public CObject
{
	DECLARE_SERIAL(CPersistVarsTab);
public:
	CPersistVarsTab ( );
	void InitDefault();

	virtual void Serialize(CArchive& ar);
};

class CPersistVariables : public CObject
{
	DECLARE_SERIAL(CPersistVariables)
public:
	CPersistVariables();
	void InitDefault();

	CPersistVarsTab m_locals;
	CPersistVarsTab m_auto ;
	CPersistVarsTab m_this ;

	inline void SetActiveTab(int index);
	inline int GetActiveTabIndex();

	int m_curIndex;
	int m_nSplitterPref;

	virtual void Serialize(CArchive& ar);
};


void CPersistVariables::SetActiveTab(int index)
{
	m_curIndex = index;
}

int CPersistVariables::GetActiveTabIndex()
{
	return m_curIndex;
}


extern CGridWatchView * g_pWatchView;
extern CVarsView * g_pVarsView;
extern CPersistWatch g_persistWatch;
extern CPersistVariables g_persistVars;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\aut1gui_.h ===
/////////////////////////////////////////////////////////////////////////////
//	AUT1GUI_.H
//		Automation package private interface ids.

// {69D0A1C0-87D8-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IAddIn, 
0x69d0a1c0, 0x87d8, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);

// Interface ID for the private VBS Macro Recorder interface to the shell
//  {E97C65E1-83EF-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IRecorderForShell, 
0xe97c65e1, 0x83ef, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);

// Interface ID for the "miscellaneous" interface to the shell
// {704F3160-10A9-11d0-AD07-00A0C9034965}
DEFINE_GUID(IID_IAut1Misc, 
0x704f3160, 0x10a9, 0x11d0, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\bldapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	BLDAPI.H
//		Build package interface declarations.

#ifndef __BLDAPI_H__
#define __BLDAPI_H__

#include "slob.h"


interface IBuildProject;		// Defined in pkgs\include\auto\bldauto.h, used in
						// IBuildWizard::GetAutoProject.
interface IPkgProject;

#ifndef STRICT
typedef UINT HBUILDER;
typedef UINT HBLDTARGET;
typedef UINT HFILESET;
typedef UINT HBLDFILE;
typedef UINT HPROJDEP;
typedef UINT HFOLDER;
#else	// STRICT
DECLARE_HANDLE(HBUILDER);
DECLARE_HANDLE(HBLDTARGET);
DECLARE_HANDLE(HFILESET);
DECLARE_HANDLE(HBLDFILE);
DECLARE_HANDLE(HPROJDEP);
DECLARE_HANDLE(HFOLDER);
#endif	// STRICT

#define ACTIVE_BUILDER	(HBUILDER)NULL
#define ACTIVE_TARGET	(HBLDTARGET)NULL
#define ACTIVE_FILESET	(HFILESET)NULL

#define NO_BUILDER		(HBUILDER)NULL
#define NO_TARGET		(HBLDTARGET)NULL
#define NO_FILESET		(HFILESET)NULL
#define NO_FILE			(HBLDFILE)NULL
#define NO_PROJDEP		(HPROJDEP)NULL
#define NO_FOLDER		(HFOLDER)NULL

// default extension for builder file
#define BUILDER_EXT	".dsp"

// Option switches for AddFile's fSettings argument
//NYI: use target's default settings
#define ADB_USE_DEFAULT_SETTINGS	0x01

#define ADB_EXCLUDE_FROM_SCAN		0x04
#define ADB_EXCLUDE_FROM_BUILD		0x08

typedef enum {TrgDefault, TrgCopy, TrgMirror} TrgCreateOp;
typedef enum {SettingsDefault, SettingsClone} SettingOp;
typedef enum {ExeBuilder, InternalBuilder} BuilderType;
typedef enum {fcaNeverQueried, fcaRebuild, fcaIgnore} FlagsChangedAction;

// state of targets
#define TRG_STAT_Unknown			0x0
#define TRG_STAT_Dep_Missing		0x1
#define TRG_STAT_Out_Of_Date		0x2
#define TRG_STAT_Current			0x4

// Target attributes
typedef enum
{
	// Image Types:
	ImageStaticLib		= 0x1,
	ImageDLL			= 0x2,
	ImageExe			= 0x4,
	// Subsystems:
	SubsystemConsole	= 0x8,
	SubsystemWindows	= 0x10,
	// Can we debug the resulting target?
	TargetIsDebugable	= 0x20,
	// Is this an unknown target?
	TargetUnknown		= 0x40,
	
	ImageJava           = 0x80,
    ImageXbe            = 0x100,
} TargetAttributes;

typedef enum
{
	unknown_platform	= 0,	// Not yet used -- error condition!
	win32x86			= 1,
	win16x86			= 2,
	mac68k				= 3,
	macppc				= 4,
	win32mips			= 5,
	win32alpha			= 6,
	win32ppc			= 7,
    java                = 8,
    generic             = 9,
    vistest             = 10,
    xbox                = 11,
} uniq_platform;

typedef enum
{
	unknown_projtype = 0,
	application      = 1,
	dynamiclib       = 2,
	consoleapp       = 3,
	staticlib        = 4,
	sharedlib        = 5,
	exttarget        = 6,
	quickwin         = 7,
	standardgraphics = 8,
	javaapplet       = 9,
} uniq_projtype;

// notification info structure, filled with info about the
// notification (e.g. adding files to a particular target).
typedef struct tagNOTIFYINFO
{
	HFILESET hFileSet;			// fileset (null if not bld pkg)
	CPathList lstFiles;			// regular files (part of fileset)
	CPathList lstDepFiles;		// dependency files (not part of fileset)
	CStringList lstOtherFiles;	// other non-buildable files (other packages)
	IPkgProject *pPkgProject;	// IPkgProject (not refcounted)
} NOTIFYINFO;

// notification info structure, filled with info about the
// file that has been renamed
typedef struct tagNOTIFYRENAME
{
	CPath OldFileName;
	CPath NewFileName;
} NOTIFYRENAME;

// merged from vinfoapi.h
#define CCHMAX_TARGET_FILE_NAME 	50
#define CCHMAX_TARGET_PRODUCT_NAME 	100

typedef struct tagPROJECT_VERSION_INFO
{
	DWORD	dwBuildType;
	DWORD	dwTargetType;
	DWORD	dwTargetSubtype;
	DWORD	dwTargetOS;
	DWORD	dwVersionNumberLS;
	DWORD	dwVersionNumberMS;
	char	szTargetFileName [CCHMAX_TARGET_FILE_NAME];
	char	szTargetProductName [CCHMAX_TARGET_PRODUCT_NAME];
} PROJECT_VERSION_INFO;

class CImageWell;		// Non-standard COM.
class CBldrSection;		// Non-standard COM.

// callback for builder file 'sections'
// 'pbldsect' is the section data
// 'op' is the callback operation

#define SECT_READ 0x0	// writing (supply buffer)
#define SECT_WRITE 0x1	// reading (process buffer)
#define SECT_END 0x2	// ended read or write (free buffer?)

// callback used for synchronous notification of read/write
typedef BOOL (*PfnSectionCallBack)(CBldrSection * pbldsect, UINT op);

class CBldrSection	// Non-standard COM.
{
public:
	CBldrSection(HBUILDER hBld = ACTIVE_BUILDER) {m_pfn = NULL; m_pch = NULL; m_cch = 0; m_dw = 0; m_hBld = hBld;}

	CString m_strName;			// section name
	
	TCHAR * m_pch;				// char. buffer
	UINT m_cch;					// size of buffer (not used for write)
	// o format of this data is each line zero-terminated with a double terminator
	//   signifying the end of the buffer 

	PfnSectionCallBack m_pfn;	// our callback (if NULL, assume async retrieval)
	DWORD m_dw;					// user-supplied word
	HBUILDER m_hBld;
};

// enumerate files in a fileset filters
#define FileEnum_All			0x0
#define FileEnum_RemoveExcluded	0x1
#define FileEnum_RemoveDeps		0x2

// transport layer information flags
#define TFL_NIL		0x0000			// Nil value
#define TFL_LOCAL	0x0001			// Local TL (else remote)
#define TFL_CFGABLE	0x0002			// Configurable (else not)

#define IDFILE_COMPILER_PDB		0x0	// full path of the compiler .pdb
#define IDFILE_COMPILER_PCH		0x1	// full path of the compiler .pch
#define IDFILE_COMPILER_IDB		0x2	// full path of the compiler .idb

// Constants used and returned by the Java build system API
#define Java_DebugUsing_Unknown			-1
#define Java_DebugUsing_Browser			1
#define Java_DebugUsing_Standalone		2
#define Java_ParamSource_Unknown		-1
#define Java_ParamSource_HTMLPage		1
#define Java_ParamSource_User			2
#define Java_DebugStandalone_Unknown	-1
#define Java_DebugStandalone_Applet		1
#define Java_DebugStandalone_Application	2

// old way
interface IBuildSystem;
interface IBuildWizard;
interface IBuildPlatforms;
interface IBuildComponents;
interface IBuildStatus;
interface IBuildDirManager;

typedef IBuildSystem* LPBUILDSYSTEM;
typedef IBuildWizard* LPBUILDWIZARD;
typedef IBuildPlatforms* LPBUILDPLATFORMS;
typedef IBuildComponents* LPBUILDCOMPONENTS;
typedef IBuildStatus* LPBUILDSTATUS;
typedef IBuildDirManager* LPBUILDDIRMANAGER;

// new way
interface IBSProject;
interface IBSProjectFileManager;
interface IBSRemoteProject;
interface IBSOptionManager;
interface IEnumConfigurations;
interface IEnumBSProjects;
interface IEnumBSActions;
interface IBSAction;
interface IEnumBuildFile;
interface IBuildSystemAddOn;
interface IEnumBuildTools;
interface IEnumProjectTypes;
interface IEnumPlatforms;
interface IBuildTool;
interface IDepScanner;
interface IOptionHandler;
interface IEnumOptionStrings;
interface IEnumOptionTypes;
interface IProjectType;
interface IPlatform;
interface ICPPPlatform;
interface ISetJavaProjectInfo;

interface IBuildFile;
interface IBuildFileSet;
#if 0
typedef IBuildFile *				LPBUILDFILE;
typedef IBuildFileSet *				LPBUILDFILESET;
#else
class CFileRegFile;
class CFileRegSet;
typedef CFileRegFile *			LPBUILDFILE;
typedef CFileRegSet *				LPBUILDFILESET;
#endif

typedef IBSProject *				LPBSPROJECT;
typedef IBSProjectFileManager *		LPBSPROJECTFILEMANAGER;
typedef IBSRemoteProject *			LPBSREMOTEPROJECT;
typedef IBSOptionManager *			LPBSOPTIONMANAGER;
typedef IEnumConfigurations *		LPENUMCONFIGURATIONS;
typedef IEnumBSProjects *			LPENUMBSPROJECTS;
typedef IEnumBSActions *			LPENUMBSACTIONS;
typedef IBSAction *					LPBSACTION;
typedef IEnumBuildFile *			LPENUMBUILDFILE;
typedef IBuildSystemAddOn *			LPBUILDSYSTEMADDON;
typedef IEnumBuildTools *			LPENUMBUILDTOOLS;
typedef IEnumProjectTypes *			LPENUMPROJECTTYPES;
typedef IEnumPlatforms *			LPENUMPLATFORMS;
typedef IBuildTool *				LPBUILDTOOL;
typedef IDepScanner *				LPDEPSCANNER;
typedef IOptionHandler *			LPOPTIONHANDLER;
typedef IEnumOptionStrings *		LPENUMOPTIONSTRINGS;
typedef IEnumOptionTypes *			LPENUMOPTIONTYPES;
typedef IProjectType *				LPPROJECTTYPE;
typedef IPlatform *					LPPLATFORM;
typedef ICPPPlatform *				LPCPPPLATFORM;
typedef ISetJavaProjectInfo*		LPSETJAVAPROJECTINFO;

typedef void		*HCONFIGURATION;

/////////////////////////////////////////////////////////////////////////////
//	IBuildSystem interface

#undef  INTERFACE
#define INTERFACE IBuildSystem

DECLARE_INTERFACE_(IBuildSystem, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildSystem methods
	STDMETHOD(GetActiveBuilder)(HBUILDER *pHandle) PURE;
	STDMETHOD(IsActiveBuilderValid)() PURE;
	STDMETHOD(GetBuilderType)(HBUILDER hBld, int *pBuilderType) PURE;
	STDMETHOD(GetBuilderFile)(HBUILDER hBld, LPCSTR *ppszPath) PURE;
	STDMETHOD(CreateBuilder)(LPCSTR pchBldPath, BOOL fForce, BOOL fOpen, HBUILDER *pHandle) PURE;
	STDMETHOD(SetDirtyState)(HBUILDER hBld, BOOL fDirty) PURE;
	STDMETHOD(GetDirtyState)(HBUILDER hBld) PURE;
	STDMETHOD(SaveBuilder)(HBUILDER hBld) PURE;
	STDMETHOD(CloseBuilder)(HBUILDER hBld) PURE;
	STDMETHOD(OnOpenWorkspace)(LPCSTR pszWorkspaceName, BOOL bTemporary) PURE;
	STDMETHOD(OnDefaultWorkspace)(LPCSTR pszFileToAdd) PURE;
	STDMETHOD(OpenWorkspace)(LPCSTR pszWorkspace) PURE;
	STDMETHOD(GetFileSetFromTargetName)(LPCSTR pchFileSet, HBUILDER hBld, HFILESET *pHandle) PURE;
	STDMETHOD(GetTargetNameFromFileSet)(HFILESET hFileSet, CString &str, BOOL bInvalid, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(GetFileSetName)(HFILESET hFileSet, CString &str, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(GetTargetFromFileSet)(HFILESET hFileSet, HBLDTARGET &hTarg, BOOL bInvalid, HBUILDER hBld) PURE;
	STDMETHOD(GetActiveTarget)(HBUILDER hBld, HBLDTARGET *pHandle) PURE;
	STDMETHOD(GetTarget)(LPCSTR pchTarg, HBUILDER hBld, HBLDTARGET *pHandle) PURE;
	STDMETHOD(GetTargetName)(HBLDTARGET hTarg, CString &str, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(DeleteTarget)(HBLDTARGET hTarg, HBUILDER hBld) PURE;
	STDMETHOD(AddProjectDependency)(HFILESET hFileSet, HFILESET hDependantFileSet, HBUILDER hBld, HPROJDEP *pHandle) PURE;
	STDMETHOD(RemoveProjectDependency)(HPROJDEP hProjDep, HFILESET hFileSet, HBUILDER hBld) PURE;
	STDMETHOD(GetDependantProject)(HFILESET *pHandle, HPROJDEP hProjDep, HFILESET hFileSet, HBUILDER hBld) PURE;
	STDMETHOD(GetTargetDirectory)(HBLDTARGET hTarg, CString &strDir, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(GetTargetFileName)(HBUILDER hBld, LPTSTR *ppszPath) PURE;
	STDMETHOD(GetTargetAttributes)(HBUILDER hBld, int *piAttrs) PURE;
	STDMETHOD(MakeTargPropsDefault)(HBLDTARGET hTarg, HBUILDER hBld) PURE;
	STDMETHOD(CheckFile)(HFILESET hFileSet, CPath &pathFile, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(AddFolder)(HFOLDER *pHandle, HFILESET hFileSet, LPCSTR pszFolder, HBUILDER hBld, HFOLDER hFolder, LPCSTR pszFilter) PURE;
	STDMETHOD(AddFile)(HBLDFILE *pHandle, HFILESET hFileSet, const CPath *ppathFile, 	// Non-standard COM.
		int fSettings, HBUILDER hBld, HFOLDER hFolder) PURE;
	STDMETHOD(AddDependencyFile)(HFILESET hFileSet, const CPath *ppathFile, HBUILDER hBld, HFOLDER hFolder) PURE;	// Non-standard COM.
	STDMETHOD(DelFile)(HBLDFILE hFile, HFILESET hFileSet, HBUILDER hBld) PURE;
	STDMETHOD(GetFile)(const CPath *ppathFile, HBLDFILE &hFile, HFILESET hFileSet, 	// Non-standard COM.
		HBUILDER hBld, BOOL bSimple) PURE;
	STDMETHOD(SetFileProp)(HBLDTARGET hTarg, HBLDFILE hFile, UINT idProp, int i) PURE;
	STDMETHOD(SetFileProp)(HBLDTARGET hTarg, HBLDFILE hFile, UINT idProp, CString &str) PURE;	// Non-standard COM.
	STDMETHOD(MakeFilePropsDefault)(HBLDTARGET hTarg, HBLDFILE hFile) PURE;
	STDMETHOD(TargetState)(UINT *puState, CObList *plstPath, 	// Non-standard COM.
		LPCSTR pchTarget, HBLDTARGET hTarg, HBUILDER hBld) PURE;
	STDMETHOD(FileState)(UINT *puState, const CPath *pathFile) PURE;	// Non-standard COM.
	STDMETHOD(ResolveIncludeDirectives)(const CPath &pathSrc, const CStringList &strlstIncs, 
		CStringList &lstPath, BOOL fIgnStdIncs, const CString &strPlat) PURE;	// Non-standard COM.
	STDMETHOD(ResolveIncludeDirectives)(const CDir &dirBase, const CStringList &strlstIncs,
		CStringList &lstPath, BOOL fIgnStdIncs, const CString &strPlat) PURE;	// Non-standard COM.
	STDMETHOD(ResolveIncludeDirectives)(const CObList &lstpathSrc, const CStringList &strlstIncs,
		CStringList &lstPath, HBLDTARGET hTarget) PURE;	// Non-standard COM.
	STDMETHOD(GetIncludePath)(CObList &lstIncDirs, const CString &strPlat, const CPath *ppathSrc, const CString &strTool, HBUILDER hBld ) PURE;	// Non-standard COM.
	STDMETHOD(UpdateDependencyList)(const CPath &pathSrc, const CStringList &strlstIncs,	// Non-standard COM.
		HBLDTARGET hTarg, HBUILDER hBld) PURE;
	STDMETHOD(InitBuilderEnum)() PURE;
	STDMETHOD(GetNextBuilder)(CString &strTarget, BOOL bOnlyLoaded, HBUILDER *pHandle) PURE;
	STDMETHOD(InitTargetEnum)(HBUILDER hBld) PURE;
	STDMETHOD(GetNextTarget)(HBUILDER hBld, CString &strTarget, HBLDTARGET *pHandle) PURE;	// Non-standard COM.
	STDMETHOD(InitProjectDepEnum)(HBUILDER hBld, HFILESET hFileSet) PURE;
	STDMETHOD(GetNextProjectDep)(HBUILDER hBld, HFILESET hFileSet, HPROJDEP *pHandle) PURE;
	STDMETHOD(InitFileSetEnum)(HBUILDER hBld) PURE;
	STDMETHOD(GetNextFileSet)(HBUILDER hBld, HFILESET *pHandle) PURE;
	STDMETHOD(InitFileEnum)(HFILESET hFileSet, UINT filter) PURE;
	STDMETHOD(GetNextFile)(HFILESET hFileSet, FileRegHandle & frh, HBLDFILE *pHandle) PURE;
	STDMETHOD(GetFileSetTargets)(HFILESET hFileSet, CStringList &strlstTargs) PURE;	// Non-standard COM.
	STDMETHOD(GetFileSet)(HBUILDER hBld, HBLDTARGET hTarg, HFILESET *pHandle) PURE;
	STDMETHOD(GetBuildFile)(UINT idFile, LPSTR szFileName, int cchFileBuffer,
		HBLDTARGET hTarg, HBUILDER hBld) PURE;
	STDMETHOD(RegisterSection)(CBldrSection * pbldsect) PURE;	// Non-standard COM.
	STDMETHOD(DeregisterSection)(const CBldrSection * pbldsect) PURE;	// Non-standard COM.
	STDMETHOD(InitSectionEnum)() PURE;
	STDMETHOD(GetNextSection)(CBldrSection **ppSection, CString &strSection) PURE;	// Non-standard COM.
	STDMETHOD(FindSection)(CBldrSection **ppSection, LPCSTR pchName) PURE;	// Non-standard COM.
	STDMETHOD(GetResourceFileList)(CPtrList &listRcPath, BOOL fOnlyBuildable, 	// Non-standard COM.
		HFILESET hFileSet, HBUILDER hBld) PURE;
	STDMETHOD(GetResourceIncludePath)(CPath *pResFile, CString &strIncludes) PURE; 	// Non-standard COM.
	STDMETHOD(LanguageSupported)(UINT idLang) PURE;
	STDMETHOD(GetSelectedFile)(CPath *path) PURE;	// Non-standard COM.
	STDMETHOD(GetProjectDir)(HBLDTARGET HBLDTARGET, HBUILDER hBld, CString& str) PURE;	// Non-standard COM.
	STDMETHOD(GetWorkspaceDir)(HBUILDER hBld, CString& str) PURE;	// Non-standard COM.
	STDMETHOD(BuildSystemEnabled)() PURE;
	STDMETHOD(IsBuildInProgress)() PURE;
	STDMETHOD(GetBuilderToolset)(int *piToolset, HBUILDER hBuilder) PURE;
	STDMETHOD(GetRegistryEntryPath)(FileRegHandle frh, const CPath **ppPath) PURE;	// Non-standard COM.
	STDMETHOD(GetRemoteTargetFileName)(HBUILDER hBld, CString &str) PURE;	// Non-standard COM.
	STDMETHOD(SetRemoteTargetFileName)(HBUILDER hBld, CString &str) PURE;	// Non-standard COM.
	STDMETHOD(GetSlobWnd)(HBUILDER hBld, CWnd **ppWnd) PURE;	// Non-standard COM.
	STDMETHOD(IsProjectFile)(const CPath *pPath, BOOL bIncludeDeps, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(UpdateBrowserDatabase)(HBUILDER hBld) PURE;
	STDMETHOD(GetBrowserDatabaseName)(HBUILDER hBld, const CPath **ppPath) PURE;	// Non-standard COM.
	STDMETHOD(GetCallingProgramName)(HBUILDER hBld, CString &str) PURE;	// Non-standard COM.
	STDMETHOD(GetProgramRunArguments)(HBUILDER hBld, CString &str) PURE;	// Non-standard COM.
	STDMETHOD(SetProgramRunArguments)(HBUILDER hBld, CString &str) PURE;	// Non-standard COM.
	STDMETHOD(GetWorkingDirectory)(HBUILDER hBld, CString &str) PURE;	// Non-standard COM.
	STDMETHOD(TargetIsCaller)(HBUILDER hBld) PURE;
	STDMETHOD(GetPromptForDlls)(HBUILDER hBld) PURE;
	STDMETHOD(SetPromptForDlls)(HBUILDER hBld, BOOL bPrompt) PURE;
	STDMETHOD(SetProjectState)(HBUILDER hBld) PURE;
	STDMETHOD(GetClassWizAddedFiles)(HBUILDER hBld) PURE;
	STDMETHOD(SetClassWizAddedFiles)(HBUILDER hBld, BOOL bPrompt) PURE;
	STDMETHOD(ScanAllDependencies)(HBUILDER hBld) PURE;
	STDMETHOD(GetVersionInfo)(HBUILDER hBld, void *ppvi) PURE;
	STDMETHOD(GetInitialExeForDebug)(HBUILDER hBld, BOOL bExecute) PURE;
	STDMETHOD(GetInitialRemoteTarget)(HBUILDER hBld, BOOL bBuild, BOOL fAlways) PURE;
	STDMETHOD(UpdateRemoteTarget)(HBUILDER hBld) PURE;
	STDMETHOD(DoTopLevelBuild)(HBUILDER hBld, BOOL bBuildAll, CStringList *pConfigs,	// Non-standard COM.
		FlagsChangedAction fca, BOOL bVerbose, BOOL bClearOutputWindow) PURE;
	STDMETHOD(GetEnvironmentVariables)(HBUILDER hBld, void *pEnvList) PURE;
	STDMETHOD(IsProfileEnabled)(HBUILDER hBld) PURE;
	STDMETHOD(IsScanableFile)(HBLDFILE hFile) PURE;
	STDMETHOD(GetBuilder)(HBLDTARGET hTarg, HBUILDER *pHandle) PURE;
	STDMETHOD(GetBuilderFromFileSet)(HFILESET hFileSet, HBUILDER *pHandle) PURE;
	// Additions
	STDMETHOD(EnumBuildTools)( LPENUMBUILDTOOLS *, LPBUILDTOOL * ) PURE;
	STDMETHOD(EnumProjectTypes)( LPENUMPROJECTTYPES *, LPPROJECTTYPE * ) PURE;
	STDMETHOD(EnumPlatforms)( LPENUMPLATFORMS *, LPPLATFORM * ) PURE;
	STDMETHOD(GetCommandLineOptions)( HFILESET hFileSet, HBLDFILE hFile, CString &rval ) PURE;

	STDMETHOD(GetSccProjName)(HBUILDER, CString&) PURE;
	STDMETHOD(SetSccProjName)(HBUILDER, const CString&) PURE;
	STDMETHOD(GetSccRelLocalPath)(HBUILDER, CString&) PURE;
	STDMETHOD(SetSccRelLocalPath)(HBUILDER, const CString&) PURE;
//	STDMETHOD(GetSccAuxPath)(HBUILDER, CString&) PURE;
//	STDMETHOD(SetSccAuxPath)(HBUILDER, const CString&) PURE;

	// Java support
	STDMETHOD(GetJavaClassName)(HBUILDER hBld, CString& str) PURE;
	STDMETHOD(GetJavaClassFileName)(HBUILDER hBld, CString& str) PURE;
	STDMETHOD(GetJavaDebugUsing)(HBUILDER hBld, ULONG* pDebugUsing) PURE;
	STDMETHOD(GetJavaBrowser)(HBUILDER hBld, CString& str) PURE;
	STDMETHOD(GetJavaStandalone)(HBUILDER hBld, CString& str) PURE;
	STDMETHOD(GetJavaStandaloneArgs)(HBUILDER hBld, CString& str) PURE;
	STDMETHOD(GetJavaHTMLPage)(HBUILDER hBld, CString& str) PURE;
	STDMETHOD(GetJavaClassPath)(HBUILDER hBld, CString& str) PURE;
	STDMETHOD(GetJavaStandaloneDebug)(HBUILDER hBld, ULONG* pStandaloneDebug) PURE;
	STDMETHOD(GetInitialJavaInfoForDebug)(HBUILDER hBld, BOOL bExecute) PURE;
	// more additions
	STDMETHOD(GetPreCompiledHeaderName)(HBUILDER hBld, CString &strPch) PURE;
	STDMETHOD(GetPkgProject)(HBUILDER builder, IPkgProject** outPkgProject) PURE;
	STDMETHOD(GetProjectGlyph)(HBUILDER hBld, HFILESET hFileSet, CImageWell& imageWell, UINT * pnImage) PURE;

	// Addition for Rational VM - ShankarV
	STDMETHOD(GetBuilderFromName)(LPCTSTR pszBuilder, HBUILDER *pHandle) PURE;
	STDMETHOD(GetNameFromBuilder)(HBUILDER hBld, CString& szBuilder) PURE;
	STDMETHOD(SetCallingProgramName)(HBUILDER hBld, CString &str) PURE;	// Non-standard COM.

	// Addition for Edit and Continue builds
	STDMETHOD(DoSpawn)(CStringList& lstCmd,	LPCTSTR szDirInit,BOOL fClear, BOOL fASync, DWORD *pcErr, DWORD *pcWarn) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IBuildWizard interface

#undef  INTERFACE
#define INTERFACE IBuildWizard

DECLARE_INTERFACE_(IBuildWizard, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildWizard methods
	STDMETHOD(SetActiveTarget)(HBLDTARGET hTarg, HBUILDER hBld) PURE;
	STDMETHOD(SetDefaultTarget)(HBLDTARGET hTarg, HBUILDER hBld) PURE;
	STDMETHOD(GetTargetTypeNames)(const CStringList **ppList, LPCSTR pchPlat, BOOL fUIDesc) PURE;	// Non-standard COM.
	STDMETHOD(AssignCustomBuildStep)(LPCSTR pchCommand, LPCSTR pchOutput, 
		LPCSTR pchDescription, HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld) PURE;
	STDMETHOD(UnassignCustomBuildStep)(HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld) PURE;
	STDMETHOD(SetToolSettings)(HBLDTARGET hTarg, LPCSTR pchSettings, LPCSTR pchTool, 
		BOOL fAdd, BOOL fClear, HBUILDER hBld) PURE;
	STDMETHOD(SetToolSettings)(HBLDTARGET hTarg, HBLDFILE hFile, LPCSTR pchSettings, 
		LPCSTR pchTool, BOOL fAdd, BOOL fClear) PURE;
	STDMETHOD(AddTarget)(HBLDTARGET *pHandle, LPCSTR pchTarg, LPCSTR pchPlat, LPCSTR pchType, 
		BOOL fUIDesc, BOOL fDebug, TrgCreateOp trgop, HBLDTARGET hOtherTarg, SettingOp setop, 
		HBLDTARGET hSettingsTarg, BOOL fQuiet, BOOL fOutDir, BOOL fUseMFC, HBUILDER hBld) PURE;
	STDMETHOD(AddDefaultTargets)(LPCSTR pchPlat, LPCSTR pchType, 
		HBLDTARGET &hDebugTarg, HBLDTARGET &hReleaseTarg, BOOL fUIDesc, BOOL fOutDir, 
		BOOL fUseMFC, HBLDTARGET hMirrorTarg, HBUILDER hBld, LPCSTR pchTarg) PURE;
	STDMETHOD(GetTargetOutDir)(HBLDTARGET hTarg, CString &strOut, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(SetTargetOutDir)(HBLDTARGET hTarg, CString &strOut, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(SetTargetIntDir)(HBLDTARGET hTarg, CString &strInt, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(SetTargetIsAppWiz)(HBLDTARGET hTarg, int iIsAppWiz, HBUILDER hBld) PURE;
	STDMETHOD(SetTargetUseOfMFC)(HBLDTARGET hTarg, int iUseOfMFC, HBUILDER hBld) PURE;
	STDMETHOD(SetTargetDefExt)(HBLDTARGET hTarg, CString &strExt, HBUILDER hBld) PURE;	// Non-standard COM.
	STDMETHOD(SetBuildExclude)(HBLDTARGET hTarg, HBLDFILE hFile, BOOL fExclude) PURE;
	STDMETHOD(AddFolder)(HFOLDER *pHandle, HFILESET hFileSet, LPCSTR pszFolder, HBUILDER hBld, HFOLDER hFolder, LPCSTR pszFilter) PURE;
	STDMETHOD(AddFile)(HBLDFILE *pHandle, HFILESET hFileSet, const CPath *ppathFile,  	// Non-standard COM.
		int fSettings, HBUILDER hBld, HFOLDER hFolder) PURE;
	STDMETHOD(AddMultiFiles)(HFILESET hFileSet, const CPtrList *plstpathFiles, 	// Non-standard COM.
		CPtrList *plstHBldFiles, int fSettings, HBUILDER hBld, HFOLDER hFolder) PURE;
	STDMETHOD(AddDependencyFile)(HFILESET hFileSet, const CPath *ppathFile, HBUILDER hBld, HFOLDER hFolder) PURE;	// Non-standard COM.
	STDMETHOD(GetFileSet)(HBUILDER hBld, HBLDTARGET hTarg, HFILESET *pHandle) PURE;
	STDMETHOD(GetAutoProject)(HBUILDER hBld, IBuildProject** ppProject) PURE;
	STDMETHOD(GetTargetUseOfMFC)(HBLDTARGET hTarg, int *iUseOfMFC, HBUILDER hBld) PURE;
	STDMETHOD(SetUserDefinedDependencies)(LPCSTR pchUserDeps, HBLDTARGET hTarg, HBLDFILE hFile, HBUILDER hBld) PURE;
	STDMETHOD(GetTargetIntDir)(HBLDTARGET hTarg, CString &strInt, HBUILDER hBld) PURE;	// Non-standard COM.
};

/////////////////////////////////////////////////////////////////////////////
//	IBuildPlatforms interface

#undef  INTERFACE
#define INTERFACE IBuildPlatforms

DECLARE_INTERFACE_(IBuildPlatforms, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildPlatforms methods
	STDMETHOD(GetAvailablePlatforms)(const CStringList **ppList, LPCSTR pchTarg, BOOL fUIDesc) PURE;	// Non-standard COM.
	STDMETHOD(GetSupportedPlatformCount)(int *piCount) PURE;
	STDMETHOD(GetPrimaryPlatform)(uniq_platform *pupID) PURE;
	STDMETHOD(GetCurrentPlatform)(HBUILDER hBld, uniq_platform *pupID) PURE;
	STDMETHOD(IsPlatformSupported)(uniq_platform upID) PURE;
	STDMETHOD(InitPlatformEnum)() PURE;
	STDMETHOD(NextPlatform)(uniq_platform *pupID) PURE;
	STDMETHOD(GetPlatformUIDescription)(uniq_platform upID, LPCSTR *ppszDesc) PURE;
	STDMETHOD(GetPlatformSHName)(uniq_platform upID, LPCSTR *ppszName) PURE;
	STDMETHOD(GetPlatformEMName)(uniq_platform upID, LPCSTR *ppszName) PURE;
	STDMETHOD(GetPlatformEEName)(uniq_platform upID, LPCSTR *ppszName) PURE;
	STDMETHOD(GetPlatformLocalTLIndex)(uniq_platform upID, UINT *puTLIndex) PURE;
	STDMETHOD(GetPlatformCurrentTLIndex)(uniq_platform upID, UINT *puTLIndex) PURE;
	STDMETHOD(SetPlatformCurrentTLIndex)(uniq_platform upID, UINT uTLIndex) PURE;
	STDMETHOD(GetPlatformCompRegKeyName)(uniq_platform upID, BOOL fInclAppKey, LPCSTR *ppszName) PURE;
	STDMETHOD(GetPlatformNMCount)(uniq_platform upID, int *piNMCount) PURE;
	STDMETHOD(GetPlatformNMName)(uniq_platform upID, UINT uNMIndex, LPCSTR *ppszName) PURE;
	STDMETHOD(GetPlatformTLCount)(uniq_platform upID, int *piTLCount) PURE;
	STDMETHOD(GetPlatformTLName)(uniq_platform upID, UINT uTLIndex, LPCSTR *ppszName) PURE;
	STDMETHOD(GetPlatformTLDescription)(uniq_platform upID, UINT uTLIndex, LPCSTR *ppszDesc) PURE;
	STDMETHOD(GetPlatformTLFlags)(uniq_platform upID, UINT uTLIndex, UINT *puFlags) PURE;
	STDMETHOD(GetPlatformBuildable)(uniq_platform upID, BOOL * pfBuildable) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IBuildComponents interface

#undef  INTERFACE
#define INTERFACE IBuildComponents

DECLARE_INTERFACE_(IBuildComponents, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildComponents methods
	STDMETHOD(GetBldSysCompName)(DWORD dwID, LPSTR*ppszName) PURE;
	STDMETHOD(GenerateBldSysCompPackageId)(LPSTR pszName, WORD *pwID) PURE;
	STDMETHOD(LookupBldSysComp)(DWORD dwID, void **ppBldSysCmp) PURE;	//REVIEW: Use handle?
	STDMETHOD(GetProjTypeFromProjItem)(void *pProjItem, int *iProjType) PURE;	//REVIEW: Use handle?
	STDMETHOD(GetProjItemAttributes)(void *pProjItem, int *iAttrs) PURE;	//REVIEW: Use handle?
};

/////////////////////////////////////////////////////////////////////////////
//	IBuildStatus interface

#undef  INTERFACE
#define INTERFACE IBuildStatus

DECLARE_INTERFACE_(IBuildStatus, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildStatus methods
	STDMETHOD(IsBuildPossible)() PURE;
	STDMETHOD(GetErrorCount)(LPDWORD pdwErrorCount) PURE;
	STDMETHOD(GetWarningCount)(LPDWORD pdwWarningCount) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IBuildDirManager

#define PLATFORM_CURRENT -1

enum DIRLIST_TYPE
{
	DIRLIST_PATH,
	DIRLIST_INC,
	DIRLIST_LIB,
    DIRLIST_SOURCE,
	C_DIRLIST_TYPES
};

#undef  INTERFACE
#define INTERFACE IBuildDirManager
DECLARE_INTERFACE_(IBuildDirManager, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildDirManager methods
	STDMETHOD(GetPlatformIndex)(LPCTSTR lpszPlatform, int* pnPlatform) PURE;
	STDMETHOD(GetDirList)(int nPlatform, DIRLIST_TYPE type,
		const CObList** ppList) PURE;	// Non-standard COM
	STDMETHOD(GetDirListString)(int nPlatform, DIRLIST_TYPE type,
		LPSTR* ppszPath) PURE;
	STDMETHOD(FindFileOnPath)(int nPlatform, DIRLIST_TYPE type, LPCSTR pszFile,
		LPSTR* ppszFullPath) PURE;
};

// *************************************************************************
// *************************************************************************
// ************************  This is the new add on model  *****************
// *************************************************************************
// *************************************************************************


/////////////////////////////////////////////////////////////////////////////
// IBSProjects

#undef  INTERFACE
#define INTERFACE IBSProject
DECLARE_INTERFACE_(IBSProject, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBSProject
	STDMETHOD(SetDirtyState)(BOOL b) PURE;
	STDMETHOD(AddDependentProject)(IBSProject *) PURE;
	STDMETHOD(RemoveDependentProject)(IBSProject *) PURE;
	STDMETHOD(EnumDependentProjects)(IEnumBSProjects **) PURE;
	STDMETHOD(SetCurrentConfiguration)(HCONFIGURATION) PURE;
	STDMETHOD(AddConfiguration)(HCONFIGURATION) PURE;
	STDMETHOD(RemoveConfiguration)(HCONFIGURATION) PURE;
	STDMETHOD(EnumConfigurations)(IEnumConfigurations **) PURE;
	STDMETHOD(GetConfigurationName)(HCONFIGURATION,LPOLESTR *) PURE;
	STDMETHOD(GetConfigurationPlatform)(HCONFIGURATION,IPlatform **) PURE;
	STDMETHOD(Build)(HCONFIGURATION,UINT type) PURE;
	STDMETHOD(AssignCustomBuildStep)(HCONFIGURATION,LPBUILDFILE,LPCOLESTR) PURE;
	STDMETHOD(RemoveCustomBuildStep)(HCONFIGURATION,LPBUILDFILE) PURE;
	STDMETHOD(SetToolSettings)(HCONFIGURATION,LPBUILDFILE) PURE;
	STDMETHOD(GetCallingProgramName)(HCONFIGURATION,LPOLESTR *) PURE;
	STDMETHOD(GetRunArguments)(HCONFIGURATION,LPOLESTR *) PURE;
	STDMETHOD(SetRunArguments)(HCONFIGURATION,LPOLESTR) PURE;
	STDMETHOD(GetCProject)(void **) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IBSProjectFileManager

#undef  INTERFACE
#define INTERFACE IBSProjectFileManager
DECLARE_INTERFACE_(IBSProjectFileManager, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBSProjectFileManager
	STDMETHOD(AddFile)(LPCOLESTR,LPBUILDFILE *) PURE;
	STDMETHOD(GetFileSet)(LPBUILDFILESET *) PURE;
	STDMETHOD(IsInProject)(LPCOLESTR,LPBUILDFILE *) PURE;
	STDMETHOD(IsBuildableFile)(LPBUILDFILE) PURE;
	STDMETHOD(IsScanableFile)(LPBUILDFILE) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IBSRemoteProject

#undef  INTERFACE
#define INTERFACE IBSRemoteProject
DECLARE_INTERFACE_(IBSRemoteProject, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBSRemoteProject
	STDMETHOD(GetRemoteTargetName)(HCONFIGURATION, LPCOLESTR*) PURE;
	STDMETHOD(SetRemoteTargetName)(HCONFIGURATION, LPCOLESTR) PURE;
	STDMETHOD(GetInitialRemoteTarget)(HCONFIGURATION, LPCOLESTR*) PURE;
	STDMETHOD(UpdateRemoteTarget)(HCONFIGURATION) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IBSOptionManager

#undef  INTERFACE
#define INTERFACE IBSOptionManager
DECLARE_INTERFACE_(IBSOptionManager, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBSOptionManager
	STDMETHOD(GetBoolProp)(UINT id,IBuildTool*,LPBUILDFILE,HCONFIGURATION, BOOL *rval) PURE;
	STDMETHOD(GetIntProp)(UINT id, IBuildTool*,LPBUILDFILE,HCONFIGURATION, int  *rval) PURE;
	STDMETHOD(GetStrProp)(UINT id, IBuildTool*,LPBUILDFILE,HCONFIGURATION, LPOLESTR *rval) PURE;
	STDMETHOD(SetBoolProp)(UINT id,IBuildTool*,LPBUILDFILE,HCONFIGURATION, BOOL val) PURE;
	STDMETHOD(SetIntProp)(UINT id, IBuildTool*,LPBUILDFILE,HCONFIGURATION, int  val) PURE;
	STDMETHOD(SetStrProp)(UINT id, IBuildTool*,LPBUILDFILE,HCONFIGURATION, LPOLESTR val) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IEnumConfigurations

#undef  INTERFACE
#define INTERFACE IEnumConfigurations
DECLARE_INTERFACE_(IEnumConfigurations, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnum methods
	STDMETHOD(Next)(THIS_ ULONG celt, HCONFIGURATION *rgelt, ULONG *pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumConfigurations **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IEnumBSProjects

#undef  INTERFACE
#define INTERFACE IEnumBSProjects
DECLARE_INTERFACE_(IEnumBSProjects, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnum methods
	STDMETHOD(Next)(THIS_ ULONG celt, IBSProject **rgelt, ULONG *pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumBSProjects **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IEnumBSActions

#undef  INTERFACE
#define INTERFACE IEnumBSActions
DECLARE_INTERFACE_(IEnumBSActions, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnumBSActions
	STDMETHOD(Next)(THIS_ ULONG celt, IBSAction **rgelt, ULONG *pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumBSActions **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IBSAction

#undef  INTERFACE
#define INTERFACE IBSAction
DECLARE_INTERFACE_(IBSAction, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBSActions
	STDMETHOD(GetInputs)(LPBUILDFILESET *) PURE;
	STDMETHOD(GetOutputs)(LPBUILDFILESET *) PURE;
	STDMETHOD(GetTool)(LPBUILDTOOL *) PURE;
	STDMETHOD(GetFile)(LPBUILDFILE *) PURE;
	STDMETHOD(GetConfiguration)(HCONFIGURATION *) PURE;
	STDMETHOD(AddOutput)(const CPath *) PURE;
	STDMETHOD(GetCommandOptions)(CString *) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IBuildFile

#undef  INTERFACE
#define INTERFACE IBuildFile
DECLARE_INTERFACE_(IBuildFile, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildFile
};

/////////////////////////////////////////////////////////////////////////////
// IBSFileSet

#undef  INTERFACE
#define INTERFACE IBSFileSet
DECLARE_INTERFACE_(IBSFileSet, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBSFileSet
};

/////////////////////////////////////////////////////////////////////////////
// IBuildFileEnum

#undef  INTERFACE
#define INTERFACE IBuildFileEnum
DECLARE_INTERFACE_(IBuildFileEnum, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildFileEnum
	STDMETHOD(Next)(THIS_ ULONG celt, IBuildFile **rgelt, ULONG *pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IBuildFileEnum **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IBuildSystemAddOn

#undef  INTERFACE
#define INTERFACE IBuildSystemAddOn
DECLARE_INTERFACE_(IBuildSystemAddOn, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildSystemAddOn
	STDMETHOD(GetName)( char ** ) PURE;
	STDMETHOD(SetClient)( LPBUILDSYSTEM ) PURE;
	STDMETHOD(EnumBuildTools)( LPENUMBUILDTOOLS *, LPBUILDTOOL * ) PURE;
	STDMETHOD(EnumProjectTypes)( LPENUMPROJECTTYPES *, LPPROJECTTYPE * ) PURE;
	STDMETHOD(EnumPlatforms)( LPENUMPLATFORMS *, LPPLATFORM * ) PURE;
	STDMETHOD(ModifyProjectTypes)( LPENUMPROJECTTYPES ) PURE;
	STDMETHOD(GetID)( UINT * ) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IEnumBuildTools

#undef  INTERFACE
#define INTERFACE IEnumBuildTools
DECLARE_INTERFACE_(IEnumBuildTools, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnumBuildTools
	STDMETHOD(Next)(THIS_ ULONG celt, IBuildTool **rgelt, ULONG *pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumBuildTools **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IBuildTool

#undef  INTERFACE
#define INTERFACE IBuildTool
DECLARE_INTERFACE_(IBuildTool, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IBuildTool
	STDMETHOD(IsCollectorTool)(void) PURE;
	STDMETHOD(Filter)(LPBUILDFILE) PURE;
	STDMETHOD(PerformBuild)( int type, int stage,LPENUMBSACTIONS, int *result ) PURE;
	STDMETHOD(GenerateCommandLines)( LPENUMBSACTIONS, CStringList &, CStringList & ) PURE;
	STDMETHOD(GenerateOutputs)( LPENUMBSACTIONS ) PURE;
	STDMETHOD(GetDependencies)( LPENUMBSACTIONS ) PURE;
	STDMETHOD(EnumOptionStrings)( LPENUMOPTIONSTRINGS * ) PURE;
	STDMETHOD(EnumOptionTypes)( LPENUMOPTIONTYPES * ) PURE;
	STDMETHOD(GetID)( UINT *pId ) PURE;
	STDMETHOD(GetPkgID)(UINT *id) PURE;
	STDMETHOD(GetName)(CString *str) PURE;
	STDMETHOD(GetUIName)(CString *str) PURE;
	STDMETHOD(GetPrefix)(CString *str) PURE;

};

/////////////////////////////////////////////////////////////////////////////
// IEnumProjectTypes

#undef  INTERFACE
#define INTERFACE IEnumProjectTypes
DECLARE_INTERFACE_(IEnumProjectTypes, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnumProjectTypes
	STDMETHOD(Next)(THIS_ ULONG celt, IProjectType **rgelt, ULONG *pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumProjectTypes **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IProjectType

#undef  INTERFACE
#define INTERFACE IProjectType
DECLARE_INTERFACE_(IProjectType, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IProjectType
	STDMETHOD(GetName)( CString *str ) PURE;
	STDMETHOD(GetType)( UINT *id ) PURE;
	STDMETHOD(GetPlatform)( LPPLATFORM *) PURE;
	STDMETHOD(IsSupported)(void) PURE;

	STDMETHOD(PickTool)( LPBUILDFILE pFile, LPBUILDTOOL *pBuildTool) PURE;
	STDMETHOD(AddTool)( LPBUILDTOOL pBuildTool) PURE;
	STDMETHOD(EnumBuildTools)( LPENUMBUILDTOOLS *, LPBUILDTOOL * ) PURE;

//	STDMETHOD(EnumDefaultConfigs)( LPENUMDEFAULTCONFIGS *, LPDEFAULTCONFIG * ) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IPlatform

#undef  INTERFACE
#define INTERFACE IPlatform
DECLARE_INTERFACE_(IPlatform, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IPlatform
};

/////////////////////////////////////////////////////////////////////////////
// IEnumPlatforms

#undef  INTERFACE
#define INTERFACE IEnumPlatforms
DECLARE_INTERFACE_(IEnumPlatforms, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnumPlatforms
	STDMETHOD(Next)(THIS_ ULONG celt, LPPLATFORM *rgelt, ULONG *pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumPlatforms **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ISetJavaProjectInfo

#undef  INTERFACE
#define INTERFACE ISetJavaProjectInfo
DECLARE_INTERFACE_(ISetJavaProjectInfo, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// ISetJavaProjectInfo methods
	STDMETHOD_(BOOL, SetPrimaryClassName)(CString& strProjName, CString& strPrimaryClassName) PURE;
};

#endif	// __BLDAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\bldapi_.h ===
/////////////////////////////////////////////////////////////////////////////
//	BLDAPIP.H
//		Bld package private interfaces

#ifndef __BLDAPIP_H__
#define __BLDAPIP_H__

/////////////////////////////////////////////////////////////////////////////
//	IAutoBld interface

// This guy is a helper interface called by the shell to help it implement
//  the build-specific properties/methods of the Application automation
//  object.

// CAUTION!  These methods are meant only to be called in response to
//  a dispatch or dual call from the outside.  They will throw
//  OLE Dispatch exceptions (DsThrowOleDispatchException), so the
//  caller better be one of those MFC dispatch handlers or be
//  prepared to catch the error.
// Because these methods throw exceptions on errors, when they return they
//  return S_OK.

#undef  INTERFACE
#define INTERFACE IAutoBld

DECLARE_INTERFACE_(IAutoBld, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IAutoBld methods
	STDMETHOD(Build)(THIS_ const VARIANT FAR& configuration, BOOL bRebuildAll) PURE;
	STDMETHOD(GetDefaultConfiguration)(THIS_ LPDISPATCH* DefaultConfiguration) PURE;
	STDMETHOD(SetDefaultConfiguration)(THIS_ LPDISPATCH DefaultConfiguration) PURE;
	STDMETHOD(Clean)(THIS_ const VARIANT FAR& configuration) PURE;
	STDMETHOD(Errors)(THIS_ long &nErrors) PURE;
	STDMETHOD(Warnings)(THIS_ long &nWarnings ) PURE;
	STDMETHOD(AddProject)(THIS_ LPCTSTR szName, LPCTSTR szPath, LPCTSTR szType, VARIANT_BOOL bAddDefsultFolders) PURE;
};


#endif //__BLDAPIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\dbg\inc\watchrow.h ===
// watchrow.h : header file
//

/////////////////////////////////////////////////////////////////////////////

enum {COL_NAME, COL_VALUE, WATCH_NUM_COLUMNS /* should be last */};

// Corresponds to one row in a Watch Pane.

// HitTest return values
enum { WRH_NONE, WRH_GLYPH, WRH_SELMARGIN, WRH_NAME, WRH_VALUE };

class CWatchRow : public CTreeGridRow
{
public:
	CWatchRow(CTreeGridWnd *pGrid, CTM *pTM, CTreeGridRow *pParent = NULL );
	~CWatchRow( );
	typedef CTreeGridRow CBaseClass;

	// virtual constructor for the CWatchRow object, which also allocates the memory.
	virtual CWatchRow * NewWatchRow(CTreeGridWnd *, CTM *, CTreeGridRow *);

	virtual BOOL IsExpandable( ) const;
	virtual BOOL GetChildren(CTreeGridRowArray&);
	virtual DWORD GetChildCount();

	virtual void Update();
	virtual void Restart();	

	virtual void DrawCell(CDC *pDC, const CRect& cellRect, int nColumn);
	virtual CSize GetCellSize(CDC *pDC, int nColumn) const ;
	virtual void ResetSize(CDC *pDC);
	virtual void OnActivate(BOOL bActivate, int nColumn);
	virtual void GetColumnText( int nColumn, CString& str);
	virtual void GetValueStr(CString &str);	// Special func which always gives the display value string.
	virtual BOOL  OnAccept (CWnd* pControlWnd );
	virtual int GetNextControlColumn(int nColumn);
	virtual int	GetPrevControlColumn(int nColumn);
	virtual void OnControlNotify(UINT nControlId,  UINT nNotification);
	virtual void AdjustForMargins(CRect& rect, int nColumn);
	virtual int Compare(const CGridRow* pCompareRow) const;
	virtual void OnSelect(BOOL bSelect);

	// Override to handle the case where the user modified the value of a variable.
	virtual void OnModify();

	CRect   ComputeGlyphRect(CDC *pDC, const CRect& cellRect);
	CRect	GetGlyphRect(const CRect& cellRect ) const;
	virtual  UINT HitTest(CPoint);
	virtual  BOOL OnLButtonDown(UINT, CPoint );
	virtual  BOOL OnLButtonUp(UINT, CPoint );
	virtual  BOOL OnLButtonDblClk(UINT, CPoint );
	virtual  BOOL OnMouseMove(UINT, CPoint );
		
	// Override to ensure that controls created are dockable.
	virtual CEdit* NewEdit( );
	virtual CComboBox* NewCombo( );

	virtual	void AdjustControlRect( GRID_CONTROL_TYPE, int nColumn, CRect& rect);

// Helper functions
public:
	inline CTM * GetTM() const;
	inline CTreeGridWnd * GetTreeGrid();
	inline BOOL IsRetVal( ) const;
	inline int GetPlusColWidth( ) const;
	inline void SetValueChanged(BOOL bSet = TRUE );
	inline BOOL IsValueChanged( );

protected:
	CTM * m_pTM; // Our TM.

	BOOL m_bValueBeingEdited:1 ;
	BOOL m_bHasSynthChild:1;
	BOOL m_bValueChanged:1;

	CSize m_sizeM;	// size of the character "M" in the current font.
	CSize m_dispGlyph ;

	enum { cxMargin = 4 , cyMargin = 1 };

public:	
	enum { cxBitmap = 11, cyBitmap = 11, cxBeforeBmap = 7, cxAfterBmap = 7, cyExtra = 6};

	enum { cxMinPlusColWidth = cxBeforeBmap + cxBitmap + cxAfterBmap };
	enum { cyMinPlusColHeight = cyBitmap + cyExtra };

	enum { IMG_PLUS = 0, IMG_MINUS = 1, IMG_RETVAL = 2 };
	static CImageWell s_imgPlusMinus;
	static int s_cUsage;
											
	friend class CNewWatchRow;
};


class CNewWatchRow : public CTGNewRow
{
public:
	CNewWatchRow(CDbgGridWnd *);
	~CNewWatchRow();
	typedef CTGNewRow CBaseClass;
public:
	virtual void ResetSize(CDC *pDC);
        virtual CSize GetCellSize(CDC *pDC, int nColumn) const;
	virtual void DrawCell(CDC *pDC, const CRect& cellRect, int nColumn);
	virtual void AdjustForMargins(CRect&, int nColumn);
	virtual void OnActivate(BOOL bActivate, int nColumn);
	virtual void OnControlNotify(UINT nControlId,  UINT nNotification);
	virtual BOOL OnMouseMove(UINT nFlags, CPoint);
	virtual int Compare(const CGridRow* pCompareRow) const;
	virtual void OnSelect(BOOL bSelect);

	virtual CEdit* NewEdit();
	virtual CComboBox * NewCombo();
	
	inline CTreeGridWnd * GetTreeGrid();
};


inline CTM * CWatchRow::GetTM( ) const
{
	return m_pTM;
}

inline CTreeGridWnd * CWatchRow::GetTreeGrid( )
{
	return (CTreeGridWnd *)GetGrid( );
}

inline BOOL CWatchRow::IsRetVal( ) const
{
	return GetTM()->IsKindOf(RUNTIME_CLASS(CReturnTM));
}

inline int CWatchRow::GetPlusColWidth() const
{
	return cxMinPlusColWidth + m_nLevels * cxBitmap;
}

inline CTreeGridWnd * CNewWatchRow::GetTreeGrid( )
{
	return (CTreeGridWnd *)GetGrid( );
}

inline void CWatchRow::SetValueChanged(BOOL bSet /* = TRUE*/)
{
	m_bValueChanged = bSet;
}

inline BOOL CWatchRow::IsValueChanged( )
{
	return m_bValueChanged || GetTM()->DidValueChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\clvwapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	CLVWAPI.H
//		ClassView package interface declarations.

#ifndef __CLVWAPI_H__
#define __CLVWAPI_H__

#ifndef __GALAPI_H__
#include <galapi.h>		// need IObjectGallery
#endif

#include "parse.h"  // for IINST mostly
#include "wizapi.h"  // for LPLANGUAGENODE

#define CHAR_UNKNOWN			0x0001
#define	CHAR_COMMA				0x0002
#define CHAR_DOT				0x0004
#define CHAR_ARROW				0x0008
#define	CHAR_COLONCOLON			0x0010
#define	CHAR_OPENPAREN			0x0020
#define CHAR_CLOSEPAREN			0x0040
#define	CHAR_CRLF				0x0080
#define CHAR_CARETMOVE			0x0100
#define	CHAR_DELETED			0x0200
#define CHAR_LEFTANGLE			0x0400
#define CHAR_RIGHTANGLE			0x0800
#define	CMD_TYPE_INFO			0x1000
#define CMD_PARAMETER_INFO		0x2000
#define CMD_COMPLETE_WORD		0x4000
#define CMD_VIEW_KILLED			0x8000

interface IClassView;
interface IClassProvider;
interface IClassProviderFactory;
interface IWizardBar;
interface IWizBarClntEditor;
interface IWizBarClntLang;
interface IWizBarClntEditors;
interface IWizBarClntLangProvider;

typedef IClassView* LPCLASSVIEW;
typedef IWizardBar* LPWIZARDBAR;
typedef IWizBarClntEditor* LPWIZBARCLNTEDITOR;
typedef IWizBarClntLang* LPWIZBARCLNTLANG;
typedef IWizBarClntEditors* LPWIZBARCLNTEDITORS;
typedef IWizBarClntLangProvider* LPWIZBARCLNTLANGPROVIDER;

/////////////////////////////////////////////////////////////////////////////
// IClassView

#undef  INTERFACE
#define INTERFACE IClassView
DECLARE_INTERFACE_(IClassView, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IClassView methods

	STDMETHOD(GetCurrentSelInfo)(char **psz, BYTE *ptyp, USHORT *patr) PURE;
	STDMETHOD(GetCurrentConfiguration)(BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(RegisterProviderFactory)(IClassProviderFactory FAR* pClassProviderFactory) PURE;

	// AutoComplete methods
	STDMETHOD(IdleInitializeAutoCompletionManager)(INT count) PURE;
	STDMETHOD(DoAutoComplete) (ULONG flags, LPCTSTR szIdentifier, 
		ULONG ichInsert, ULONG ilineInsert, ULONG ichRealInsert, ULONG ilineRealInsert, BOOL fJingle) PURE;
	STDMETHOD(OnChangeInTextEditor) (ULONG flags, LPCTSTR pszString, ULONG ichInsert, ULONG ilineInsert) PURE;
	STDMETHOD(CanShowQuickInfo) (BOOL *pfShow) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IClassProviderFactory

#undef  INTERFACE
#define INTERFACE IClassProviderFactory
DECLARE_INTERFACE_(IClassProviderFactory, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IClassProviderFactory methods
	STDMETHOD(GetClassProvider)(THIS_ VOID *pvBsc, IINST iinst,
		IClassProvider FAR* FAR* ppClassProvider) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IClassProvider

#undef  INTERFACE
#define INTERFACE IClassProvider
DECLARE_INTERFACE_(IClassProvider, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IClassProvider methods
	STDMETHOD(GetInterfaceInfo)(THIS_ IINST iisnt, UINT iInterface,
		LPCTSTR FAR* pszInterfaceName) PURE;
	STDMETHOD(GetMemberInfo)(THIS_ IINST iinst, LPCTSTR FAR* pszInterfaceName) PURE;
	STDMETHOD(CreateMember)(THIS_ LPCTSTR szMember, UINT ichClassName, UINT nAccess,
		LPCTSTR szInterfaceName, LPOBJECTGALLERY pObjectGallery) PURE;
	STDMETHOD(UpdateClass)() PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IWizardBar
// This interface exposes methods that the Wizard bar clients use, though ActivateWizBar 
// and WizBarInvalidate are used by "outsiders"


// structures required as passed arguments for IWizardBar and IWizardBarClient

enum WB_LIST_TYPE {WBL_INVALID = -1, WBL_CLASS = 0, WBL_OBJECT = 1, WBL_TARGET = 2}; // types of wizard bar lists
enum WB_CTL_TYPE  {WBC_INVALID = -1, WBC_CLASS = 0, WBC_OBJECT = 1, WBC_TARGET = 2, WBC_ACTION = 3}; // types of wizard bar controls

enum WB_TARGET_TYPE 
{
	// BEGIN WARNING
	// if you change or add any of these, change the corresponding IW_* #defines
	// in clsview\clsnode.h
	IW_CLASS = 0, 
	IW_FUNC_PRIVATE,
	IW_FUNC_PROTECTED,
	IW_FUNC_PUBLIC,
	IW_VAR_PRIVATE,
	IW_VAR_PROTECTED,
	IW_VAR_PUBLIC,
	IW_INTERFACE_DEF,
	IW_IFACE_METHOD,
	IW_IFACE_PROP,
	IW_DIALOG_ID,
	IW_FUNC_DEFAULT,
	IW_FUNC_JAVA_PROTECTED,
	IW_VAR_DEFAULT,
	IW_VAR_JAVA_PROTECTED,
	IW_ENUM_PRIVATE,
	IW_ENUM_PROTECTED,	
	IW_ENUM_PUBLIC,
	IW_TYPEDEF,
	IW_TEMPLATE,
	IW_NAMESPACE
	// if you change or add any of these, change the corresponding IW_* #defines
	// in clsview\clsnode.h
	// END WARNING
}; // ids of standard targets/glyphs

enum WB_ERROR_CODE
{
	WB_ERR_NO_DEF_FUNCTION = 1,
	WB_ERR_NO_NEXTPREV,
	WB_ERR_NO_DEF_CLASS
}; // ids for errors that ShowWBError can handle

const cItemContext = (WBL_TARGET - WBL_CLASS + 1);
const cWBControls =  (WBC_ACTION - WBC_CLASS + 1);

typedef struct _WBContext
{
	// an array of 3 items (class, filter, memner)
	void *rgwbcitem[cItemContext];
	BOOL fScopeIsProject;  // if true, include all project elements (e.g., classes.) if false limit to context
} WBContext; // Wizard Bar Context

// this is data gathered by an editor that does tracking. Its corresponding language/project
// knows how to interpret the data and return equivalent WBContext entries.
typedef struct _WBContextTrack
{
	// an array of 3 items (class, filter, member + 1 "extra item" for additional data)
	void *rgwbtitem[cItemContext + 1];
} WBContextTrack; // Wizard Bar Tracking Data for Context


// bit flag masks for pbfSupportsWB in FSupportsWBActivate
enum MASK_TYPES 
{
	mskSWANoSupport = 0,
	mskSWAProjectSupport = 1,
	mskSWATrackingSupport = 2,
	mskSWAFilterSupport = 4,
	mskSWAUninitialized = 8
};


// bit flag masks for GetWizBarFlags

#define mskWBFlagsNotExist 0
#define mskWBExists 1
#define mskWBEnabled 2
#define mskWBInvalid 4
#define mskWBTrackedByView 8
#define mskWBSetupTrackForCmd 16

// bit flag masks for puDrawStringFlags in DrawWBItemGlyph
// Note these are mutually exclusive flags. Setting more that more will only
// do 1 action. Don't do it!

#define mskWBDrawStringNormal 0
#define mskWBDrawStringGray 1
#define mskWBDrawStringBold 2

#undef  INTERFACE
#define INTERFACE IWizardBar
DECLARE_INTERFACE_(IWizardBar, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IWizardBar methods

	// Methods for determining Wiz Bar status


	// ********* Begin Method*****************************************
	// Basically a subset of GetWizBarFlags. Return S_OK if the CWizBarUniversal
	// object has been created. If fCreateIfNone, force creation of the object
	// if not there already.

	STDMETHOD(FExistWizBar)(BOOL fCreateIfNone = FALSE) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Force creation of the Wizard bar object if not there already.

	STDMETHOD(FCreateWizBar)() PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// more status info than FExistsWizBar. Tells if it exists,or is tracking
	// etc. See mks definitions above. If fCreateIfNone, force creation of the object
	// if not there already.

	// returns ULONG. Use mskWB*  to interpret values
	STDMETHOD(GetWizBarFlags)(ULONG *puFlags, BOOL fCreateIfNone = FALSE) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Called by shell when active view changes. 
	STDMETHOD(ActivateWizBar)(BOOL bActivate) PURE; 
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Called by tracking editor when the current selection changes. 
	// Wizard Bar will update at idle time. Should only call when
	// the selection changes enough to change the Wizard Bar status - in the
	// source editor, call when the line selected has changed, not for changes
	// within the line.

	STDMETHOD(WizBarInvalidate)() PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Enable or disable the WizardBar. Should be used with caution (no current callers 6/96)
	STDMETHOD(EnableWizBar)(BOOL bEnable = TRUE) PURE;

  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// free any interface data. If fNoRefill, leave disabled and empty, otherwise
	// refill with current data.

	STDMETHOD(ResetWizBar)(BOOL fNoRefill = FALSE) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Perform specified action. Will force immediate update of Wizard Bar before action is 
	// performed. If WB does not exist, it will be created.
	// If fOnlyIfTracked (useful for double click in dialog editor), ignore action
	// if not tracking. *pfHandledAction indicates whether action ever happened.

	STDMETHOD(DoWizBarAction)(UINT idAction, BOOL *pfHandledAction, BOOL fOnlyIfTracked, BOOL fReportError = TRUE) PURE;
  	// ********* End Method ******************************************



	// IWizardBar methods for context lists


	// ********* Begin Method*****************************************
    // Returns the position of the current selection (*pdwPos) for the WB list
	// specified by wblType. Useful as input to GetWizBarItem, etc.
	
  	STDMETHOD(GetCurSelList)(WB_LIST_TYPE wblType, DWORD *pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Sets the position of the current selection (*pdwPos) for the WB list
	// specified by wblType. 

	STDMETHOD(SetCurSelList)(WB_LIST_TYPE wblType, DWORD *pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Find position of a specified item (pwbItem) in a list specified by wblType.
	// Does NOT addref item
	STDMETHOD(FindWizBarItemExact)(WB_LIST_TYPE wblType, void * pWbItem, DWORD * pdwPosItem) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Return pointer (*ppWbItem) to the item at position dwPos in list specified by wblType.
	// note: this will call AddRef on the item returned

	STDMETHOD(GetWizBarItem)(WB_LIST_TYPE wblType, void ** ppWbItem, DWORD dwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************
	// Return pointer (*ppWbItemSel) to the currently selected item in list specified by wblType.
	// note: this will call AddRef on the item returned

	STDMETHOD(GetSelWizBarItem)(WB_LIST_TYPE wblType, void ** ppWbItemSel) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Empties list specified by wblType. Causes items in list to be Released.
	// If fNoDelPosSel, do not rlease the currently selected item (Note:
	// fNoDelPosSel may be obsolete. I recommend only using FALSE)

	STDMETHOD(EmptyWizBarList)(WB_LIST_TYPE wblType, BOOL fNoDelPosSel) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Sorts list specified by wblType. Uses qsort and calls IWizBarLang::CompareWBItems
	// Lists are sorted to make filtering combos faster

	STDMETHOD(SortWizBarList)(WB_LIST_TYPE wblType) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Add item specified by pwbItem to list specified by wblType. Returns
	// location where item was added in *pdwPos

	STDMETHOD(AddTailList)(WB_LIST_TYPE wblType, void * pWbItem, DWORD * pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Return in *pdwPos the location of the first item in the list
	// specified by wblType.

	STDMETHOD(GetHeadList)(WB_LIST_TYPE wblType, DWORD *pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Analog of CObList::GetNext. Return in *ppWbItem the item in table wblType
	// at position *pdwPos.  Update *pdwPos to point to the next item in the list.
	// note: this will call AddRef on the item returned

	STDMETHOD(GetNextList)(WB_LIST_TYPE wblType, void ** ppWbItem, DWORD *pdwPos) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Return in *pcEntries the number of items in list specified by wblType

	STDMETHOD(GetCountList)(WB_LIST_TYPE wblType, UINT *pcEntries) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Draw the "standard" glyph specified by idGlyphStd and associated with an item (pwbItem, wblType)
	// at rect lpRect in hDC. Usually called by IWizBarClntLang::DrawWBItemGlyph
	// NOTE: if this function succeeds, lpRect will be set to the area remaining in the original
	// rect after the glyph id drawn (usually means left value is increased). It is untouched on failure

	STDMETHOD(DrawWBStdGlyph) (WB_TARGET_TYPE idGlyphStd, HDC hDC, RECT *lpRect) PURE; 
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************
	// Returns current string for a shared wizard bar command control specified by wbcType to use
	// for its command or tooltip text. This lets us specify new tooltips or menu
	// text for commands in the wizard bar core set (defined in ClsView package)

	STDMETHOD(GetDynamicCmdString)(UINT nID, UINT iString, BSTR FAR* pbstrCmd) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************
	// Returns command id for default command based on current Wizard bar context
	// will put up an error message on failure if fReportError.

	STDMETHOD(GetCmdDefault)(UINT *pnIDDefault, BOOL fReportError = TRUE) PURE;

  	// ********* End Method ******************************************

	// IWizardBar methods for action button menu. More can be added if needed, essentially CMenu / CPopupMenu APIs


	// ********* Begin Method*****************************************

	// Fill us action button memu with commands specified in POPDESC structure. See
	// shlmenu.h for POPDESC description

	STDMETHOD(CreateMenuFromPopdesc)(POPDESC *ppop) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Remove command from menu. See CMenu::RemoveMenu for description

	STDMETHOD(RemoveMenu)(UINT nPosition, UINT nFlags, BOOL *pfOK) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Append command to menu. See CMenu::AppendMenu for description

	STDMETHOD(AppendMenu)(UINT nFlags, UINT nIDNewItem, LPCTSTR lpszNewItem, BOOL *pfOK) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Insert command to menu at nPosition. See CMenu::InsertMenu for description

	STDMETHOD(InsertMenu)(UINT nPosition, UINT nFlags, UINT nIDNewItem, LPCTSTR lpszNewItem, BOOL *pfOK) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Modify command to menu at nPosition. See CMenu::InsertMenu for description

	STDMETHOD(ModifyMenu)(UINT nPosition, UINT nFlags, UINT nIDNewItem, LPCTSTR lpszNewItem, BOOL *pfOK) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Analog of CMenuPopup::AddMenuItem
	// appends command with id id and text lpszText to menu

	STDMETHOD(AddMenuItem)(UINT id, LPCTSTR lpszText) PURE;
  	// ********* End Method ******************************************


	// IWizardBar methods for accessing "current" client interfaces


	// ********* Begin Method*****************************************

	// Returns pointer to currently active IWizBarClntEditor interface or
	// NULL if none

	STDMETHOD(GetCurWizBarClntEditor)(LPWIZBARCLNTEDITOR *ppWBClntEditor) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Returns pointer to currently active IWizBarClntLang interface or
	// NULL if none

	STDMETHOD(GetCurWizBarClntLang)(LPWIZBARCLNTLANG *ppWBClntLang) PURE;
  	// ********* End Method ******************************************


	// IWizardBar methods for accessing *specific* client interfaces


	// ********* Begin Method*****************************************

	// Returns pointer to IWizBarClntEditor interface specified by lpszLang and pguidEditor,  or
	// NULL if none

	STDMETHOD(GetWizBarClntEditor)(LPCTSTR lpszLang, GUID* pguidEditor, LPWIZBARCLNTEDITOR *ppWBClntEditor) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Returns pointer to IWizBarClntLang interface specified by lpszLang or
	// NULL if none

	STDMETHOD(GetWizBarClntLang)(LPCTSTR lpszLang, LPWIZBARCLNTLANG *ppWBClntLang) PURE;
  	// ********* End Method ******************************************

	// Misc functions
	// ********* Begin Method*****************************************

	// Displays error message for specified error (needed for shared
	// errors in langlib only)

	STDMETHOD(ShowWBError)(WB_ERROR_CODE wec) PURE;
  	// ********* End Method ******************************************
};



/////////////////////////////////////////////////////////////////////////////
// IWizBarClntLang
// This interface does most of the work for a Wizard bar client. If not present, these is no
// Wizard Bar support for a particular programming language.

// Methods in this interface create objects that fill the Wizard bar combos. They compare, display and handle
// AddRef and Release on iitems in the list. They fill the lists and perform actions based onthe combo contents.

// This interface may be associated with one or more IWizardBarEditor interfaces, which support
// selection tracking in an editor

// These methods are all called by the Wizard Bar itself. Noone else should be calling them.


#undef  INTERFACE
#define INTERFACE IWizBarClntLang
DECLARE_INTERFACE_(IWizBarClntLang, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IWizBarClntLang methods

	// ********* Begin Method *****************************************
	// Returns flags through pbfSupportsWB indicating whether this interface supports the current project
	// Typically returns mskSWAProjectSupport if the project can be supported or mskSWANoSupport otherwise. 
	// May use existence of a parser database to determine if it supports this project.
	// If mskSWANoSupport, the Wizard bar will be deactivated.

	STDMETHOD(FSupportsWBActivate)(UINT *pbfSupportsWB) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method *****************************************
	// Initializes any data required by this interface. Called after FSupportsWBActivate succeeds.
	// bfSupportsWB is the value returned by FSupportsWBActivate.

	STDMETHOD(InitWBLangData)(UINT bfSupportsWB) PURE; // argument is what you get back from FSupportsWBActivate
  	// ********* End Method *******************************************

	// ********* Begin Method *****************************************
	// Frees any interface specific data when a project	configuration changes or at shutdown

 	STDMETHOD(ClearWBLangData)() PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method *****************************************
	// Used to fill succeeding context entries with information based on the previous context
	// entries. wbltFirstEmpty indicated which items need to be filled in; any items in pwbcontext
	// >= wbltFirstEmpty will be NULL and need to be filled in.
	// This is a tricky and important method. If someone changes the 2nd combo, this is called to
	// fill up the third. You may not have to refill the entire list to do this; You do not need
	// to empty a list - You need to produce at most 3 items. Typically the Wizard Bar will take
	// what you give it here and empty its lists and refill with the context.
	// This is called directly from the Wizard Bar. GetCurWBCFromTrackData may also find it useful.

	// This method fill up the "surface" of the lists - only 1 item deep. It is called when tracking
	// as part of getting the current context, and also when dropping the first or 2nd combo. The list
	// associated with the item we return here is marked as needing to be filled if dropped.

	STDMETHOD(CompleteWBContext)(WBContext * pwbcontext, WB_LIST_TYPE wbltFirstEmpty) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method *****************************************
	// The wizard Bar has 3 "lists" each associated with one of the combos. When a combo is dropped
	// this method is called to fill the list. wblType indicates which list is to be filled. The
	// data in pwbcontext is often useful for determining what goes in this list.

	// Current implementations save the current context entry to use for reselecting, then empty the
	// list, then create objects appropriate to the list, and call IWizardBar::AddTailList to add them
	// to the list. The Wizard Bar knows nothing of the nature of these objects, except that they
	// support some interfaces (GetWBItemText, DrawWBItemGlyph, CompareWBItems, AddRefWBItem, ReleaseWBItem).
	// It just holds a pointer and calls the interface to do what it needs

	STDMETHOD(FillWizBarList) (WBContext * pwbcontext, WB_LIST_TYPE wblType, BOOL *pfSortedByFiller) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Called by the Wizard Bar when the action menu is dropped. Fill the menu with commands appropriate
	// to the context in pwbcontext. Indicate the index of the default command in piMenuDefault.
	// Several IWizardBar methods are available for filling the menu (CreateMenuFromPopdesc, RemoveMenu,
	// AppendMenu, InsertMenu, ModifyMenu, AddMenuItem).

	STDMETHOD(CreateWBMenuAction)(WBContext * pwbcontext, int *piMenuDefault) PURE; 
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Implements action menu commands that are unique to this language, appropriate to the 
	// context in pwbcontext, and which were added to the menu by CreateWBMenuAction.
	// Set *pfHandledAction	TRUE if you have implemented the command idAction.
	// This function is called after the IWizBarClntEditor equivalent.

	STDMETHOD(DoWBAction)(WBContext * pwbcontext, UINT idAction, BOOL *pfHandledAction) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// called by IWizBarClntEditor::GetCurWBContext. Knows how to interpret data in pwbctrack
	// to produce a valid pwbcontext. This lets the IWizBarClntEditor be ignorant of the 
	// details of the objects that fill the lists. This function needs to be in sync with GetCurWBContext.
	// For example, in the C++ SOurce editor, the editor interface gets the name of the class and function
	// from the current line in the editor. This is passed in pwbctrack, and this function knows how to
	// produce appropriate Class, Object and Target objects to fill the context with.

	STDMETHOD(GetCurWBCFromTrackData)(WBContextTrack * pwbctrack, WBContext * pwbcontext) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Returns ILanguageNode associated with this interface, if any. Not currently (6/96) used
	// by the Wizard Bar itself, may be useful in the future. If there is no associated
	// IULanguageNode, return something other than S_OK (E_NOTIMPL might be a good choice).

	STDMETHOD(GetLanguageNode)(LPLANGUAGENODE FAR* ppvLangNode) PURE;  // associated ILanguageNode
  	// ********* End Method *******************************************

	// ********* Begin Method*******************************************
	// Returns language name associated with the IWizBarClntLang interface.
	// The language string is usually the same as those used by the Source editor (ISourceEdit::GetLanguage)
	// or that returned by ILanguageNode::get_LanguageName

	STDMETHOD(GetLanguageName)(BSTR FAR* pbstrLang) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************

	// Returns pointer to a collection interface containing IWizBarClntEditor interface
	// pointers for this language. Example, in C++, there are Source and Dialog editor interfaces
	// These interfaces are optional. If you have none return a non S_OK value and set
	// *ppvClntEditors NULL.

	STDMETHOD(GetAllClntEditors)(LPWIZBARCLNTEDITORS FAR* ppvClntEditors) PURE;  // associated IWizBarClntEditors interface
  	// ********* End Method *******************************************



	// IWizBarClntLang methods for list items
	// These methods are called by the Wizard Bar to manipulate individual list objects.



	// ********* Begin Method*****************************************

	// Given an item (pwbItem) and its type (wblType), return its associated text in *ppText.
	// If there should be different text in the edit control of a combo than what appears in the
	// list, use fTextForEdit to determine which to return. 

	STDMETHOD(GetWBItemText) (void * pwbItem, WB_LIST_TYPE wblType, BSTR FAR* pbstrText, BOOL fTextForEdit) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Draw the glyph associated with an item (pwbItem, wblType) at rect lpRect in hDC.
	// If the glyph should be a "standard" Class View glyph, you can have IWizardBar::DrawWBStdGlyph
	// draw it for you.
	// uDrawStringFlags are hints to the drawing code that the string drawn with the glyph
	// should be drawn in a special way. Basically a hanger on argument to avoid a new member function.
	// see mskWBDrawString* for available options
	// NOTE: if this function succeeds, lpRect will be set to the area remaining in the original
	// rect after the glyph id drawn (usually means left value is increased). It is untouched on failure

	STDMETHOD(DrawWBItemGlyph) (void * pwbItem, WB_LIST_TYPE wblType, HDC hDC, RECT *lpRect, UINT *puDrawStringFlags) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Compare 2 list object items. Return Zero if the items are identical, < 0 if pwbItem1 is less 
	// than pwbItem2, or > 0 if this pwbItem1 is greater than pwbItem2.  Usually this is a
	// comarison of the text returned by GetWBItemText.You can choose
	// whether to make this case sensitive or not. (For C++ comparisons ARE case sensitive).

	STDMETHOD(CompareWBItems) (const void * pwbItem1, const void * pwbItem2, WB_LIST_TYPE wblType, int *pRetCompare) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Increases the reference count of the specified item. The Wizard Bar calls this
	// when it gets its current context from its lists so we can have multiple copies and 
	// still delete at the right time. When you create an item, set its ref count to 1. Don;t
	// addref again if adding to a WizBar list.

	STDMETHOD(AddRefWBItem) (void * pwbItem, WB_LIST_TYPE wblType) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Decreases the reference count on the item. When the count goes to 0
	// the item should be deleted. At item destruction time, the ref count
	// should be 0 or 1 (similar to how CCmdTarget works).
	STDMETHOD(ReleaseWBItem) (void * pwbItem, WB_LIST_TYPE wblType) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Returns current string for a shared wizard bar command control specified by wbcType to use
	// for its command or tooltip text. This lets us specify new tooltips or menu
	// text for commands in the wizard bar core set (defined in ClsView package)
	// if not implemented, NULL is returned, which means get string from command table

	STDMETHOD(GetDynamicCmdString)(UINT nID, UINT iString, BSTR FAR* pbstrCmd) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Returns command id for default command based on Wizard bar context
	// if not handled, returns FALSE in *pfHandled.

	STDMETHOD(GetCmdDefault)(WBContext *pwbcontext, UINT *pnIDDefault, BOOL *pfHandled) PURE;
  	// ********* End Method *******************************************

};




/////////////////////////////////////////////////////////////////////////////
// IWizBarClntEditor
// This interface is optional. If not implemented, the user can still use the Wizard Bar
// by changing the combos by hand. It is used primarily to implement tracking of selection (via the
// GetCurWBContext method (which can call GetCurWBCFromTrackData in IWizBarClntLang)). It can also 
// add menu commands that are active only in this editor (AddWBMenuAction, DoWBAction)

// This interface is associated with a single editor and programming language, and is accessed
// through the IWizBarClntLang method GetAllClntEditors. You can have several of these interfaces
// associated with a single programming language.

// These methods are all called by the Wizard Bar itself. Noone else should be calling them.

#undef  INTERFACE
#define INTERFACE IWizBarClntEditor
DECLARE_INTERFACE_(IWizBarClntEditor, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IWizBarClntEditor methods

	// ********* Begin Method*******************************************

	// Returns flags through pbfSupportsWB indicating whether this interface supports the current active
	// view. Typically returns mskSWATrackingSupport if it can track selection changes, and  mskSWANoSupport
	// otherwise. Typically uses info on the current editor and language of the doc in the view to
	// determine if it has support

	STDMETHOD(FSupportsWBActivate)(UINT *pbfSupportsWB) PURE; 
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// Initializes any data required by this interface. Called after FSupportsWBActivate succeeds.
	// bfSupportsWB is the value returned by FSupportsWBActivate.

	STDMETHOD(InitWBEditorData)(UINT bfSupportsWB) PURE; // argument is what you get back from FSupportsWBActivate
	// ********** End Method ******************************************

	// ********* Begin Method*****************************************

	// Frees any editor specific data when a new editor is activated

	STDMETHOD(ClearWBEditorData)() PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************

	// The main tracking interface. Fills pwbcontext with information appropriate to
	// the current selection. (Note that the editor must call IWizardBar::WizBarInvalidate()
	// when its selection changes to make this work).
	// pwbcontext is empty when this is called. Set *pfUnchanged true if the selection
	// has not changed since the last call. 
	// This method usually has a contract with GetCurWBCFromTrackData in IWizBarClntLang. It
	// analyzes the current selection and gathers data that	GetCurWBCFromTrackData can use to
	// fill pwbcontext. These 2 methods should be written in tamdem.

	STDMETHOD(GetCurWBContext)(WBContext * pwbcontext, BOOL *pfUnchanged) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Optional. Use to add commands that are unique to this editor, not common to the language
	// implementation. Example, in C++ source editor, GoToNextFunction uses editor tracking
	// and so is implemented in this interface.

	STDMETHOD(AddWBMenuAction)(WBContext * pwbcontext) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Optional. Implements commands that are unique to this editor, not common to the language,
	// and which were added to the menu by AddWBMenuAction.
	// Set *pfHandledAction	TRUE if you have implemented the command idAction.
	// This function is called before the IWizBarClntLang equivalent, so it has first try.

	STDMETHOD(DoWBAction)(WBContext * pwbcontext, UINT idAction, BOOL *pfHandledAction) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*******************************************
	// Identification of interface. This info is usually hard coded. Editors are identified by
	// a guid, accessible through CPartView::GetEditorID, and we store the approriate value.
	// The language string is usually the same as those used by the Source editor (ISourceEdit::GetLanguage)

	STDMETHOD(GetLangAndEditor)(BSTR FAR* pbstrLang, GUID* pguidEditor) PURE;
  	// ********* End Method ******************************************

	// ********* Begin Method*****************************************
	// A convenience call. Each of these interfaces is associated with an IWizBarClntLang and the
	// pointer to that interface should be returned here.

	STDMETHOD(GetIClntLang)(LPWIZBARCLNTLANG *ppWBClntLang) PURE;  // get associated IWizBarClntLang interface
	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Returns current string for a shared wizard bar command control specified by wbcType to use
	// for its command or tooltip text. This lets us specify new tooltips or menu
	// text for commands in the wizard bar core set (defined in ClsView package)
	// if not implemented, NULL is returned, which means get string from command table

	STDMETHOD(GetDynamicCmdString)(UINT nID, UINT iString, BSTR FAR* pbstrCmd) PURE;
  	// ********* End Method *******************************************

	// ********* Begin Method*****************************************
	// Returns command id for default command based on Wizard bar context
	// if not handled, returns FALSE in *pfHandled.

	STDMETHOD(GetCmdDefault)(WBContext *pwbcontext, UINT *pnIDDefault, BOOL *pfHandled) PURE;
  	// ********* End Method *******************************************

};

/////////////////////////////////////////////////////////////////////////////
// IWizBarClntEditors
// Collections of wiz bar client editors (get from IWizBarClntLang)
// If you derive an object from CWizBarEditorCollection (see langlib package)
// You will get these interfaces for free. You will have to implement the
// CWizBarEditorCollection Init() and destructors, but those are pretty simple.
// See CWizBarEditorCollectionCpp in the langcpp package for an example.

#undef  INTERFACE
#define INTERFACE IWizBarClntEditors
DECLARE_INTERFACE_(IWizBarClntEditors, IUnknown)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

	STDMETHOD(_NewEnum)(THIS_ IEnumVARIANT **ppenum) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IWizBarClntLangProvider
// Provides access to IWizBarClntLang interface implemented on object
// in the package. A package that implements IWizBarClntLang have have
// one of these interfaces to give the Wizard Bar access to IWizBarClntLang

#undef  INTERFACE
#define INTERFACE IWizBarClntLangProvider
DECLARE_INTERFACE_(IWizBarClntLangProvider, IUnknown)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

	// ********* Begin Method*****************************************

	// Returns pointer to IWizBarClntLang interface or NULL if none

	STDMETHOD(GetClntLang)(LPWIZBARCLNTLANG *ppWBClntLang) PURE;
	// ********* End Method ******************************************

};


/////////////////////////////////////////////////////////////////////////////

#endif	// __CLVWAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\bldguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	BLDGUID.H
//		Build package interface ids.

// Interface ID for BuildSystem {1DA4E0C1-19F8-11cf-B24F-00AA0057AFF3}
DEFINE_GUID(IID_IBuildSystem, 
	0x1da4e0c1, 0x19f8, 0x11cf, 0xb2, 0x4f, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for BuildWizard {3B652951-318C-11cf-B252-00AA0057AFF3}
DEFINE_GUID(IID_IBuildWizard, 
	0x3b652951, 0x318c, 0x11cf, 0xb2, 0x52, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for BuildPlatforms {9F2C9681-30F5-11cf-B252-00AA0057AFF3}
DEFINE_GUID(IID_IBuildPlatforms, 
	0x9f2c9681, 0x30f5, 0x11cf, 0xb2, 0x52, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for BuildComponents {9F2C9682-30F5-11cf-B252-00AA0057AFF3}
DEFINE_GUID(IID_IBuildComponents, 
	0x9f2c9682, 0x30f5, 0x11cf, 0xb2, 0x52, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for BuildStatus {1675BE11-7385-11cf-8FA9-00A0C903494F}
DEFINE_GUID(IID_IBuildStatus, 
	0x1675be11, 0x7385, 0x11cf, 0x8f, 0xa9, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x4f);

// Interface ID for BuildDirManager {FB089D40-B4C0-11cf-B3D5-00A0C9034961}
DEFINE_GUID(IID_IBuildDirManager, 
	0xfb089d40, 0xb4c0, 0x11cf, 0xb3, 0xd5, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x61);

// Class ID for build document {34866980-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_BuildDocument, 
	0x34866980, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Interface ID for BSProject {5181A141-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBSProject,
	0x5181a141, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for ProjectFileManager {5181A142-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBSProjectFileManager ,
	0x5181a142, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for RemoteProject {5181A143-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBSRemoteProject,
	0x5181a143, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for OptionManager {5181A144-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBSOptionManager,
	0x5181a144, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for BuildTool {5181A145-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBuildTool,
	0x5181a145, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for Action {5181A146-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBSAction ,
	0x5181a146, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for EnumConfigurations {5181A147-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IEnumConfigurations,
	0x5181a147, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for BuildFile {5181A148-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBuildFile,
	0x5181a148, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for Platform {5181A149-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IPlatform,
	0x5181a149, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for EnumActions {5181A14A-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IEnumBSActions,
	0x5181a14a, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for IBuildSystemAddOn {5181A14B-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBuildSystemAddOn,
	0x5181a14b, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for IEnumBuildTools {5181A14C-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IEnumBuildTools,
	0x5181a14c, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for IEnumProjectTypes {5181A14C-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IEnumProjectTypes,
	0x5181a14d, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for IEnumPlatforms {5181A14E-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IEnumPlatforms,
	0x5181a14e, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for IEnumBSProjects {5181A14F-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IEnumBSProjects,
	0x5181a14f, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for IProjectType {5181A150-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IProjectType,
	0x5181a150, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface for setting Java 'primary' class name in project
DEFINE_GUID(IID_ISetJavaProjectInfo,
	0x2330b308, 0xc631, 0x11cf, 0xb3, 0xab, 0x00, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);

// Interface ID for BSProject {5181A151-A6B6-11cf-BABC-00AA00A3F593}
DEFINE_GUID(IID_IBSJavaProject,
	0x5181a151, 0xa6b6, 0x11cf, 0xba, 0xbc, 0x0, 0xaa, 0x0, 0xa3, 0xf5, 0x93);

// Interface ID for BSProject {F157A294-1AE7-11D0-A911-00A0C915070C}
DEFINE_GUID(IID_IBSCxxProject, 
	0xf157a294, 0x1ae7, 0x11d0, 0xa9, 0x11, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for BSProject {F157A297-1AE7-11D0-A911-00A0C915070C}
DEFINE_GUID(IID_IBSExeProject, 
	0xf157a297, 0x1ae7, 0x11d0, 0xa9, 0x11, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

// Interface ID for TestProject {5C28D560-90FE-11d1-AB95-0000F8026984}
DEFINE_GUID(IID_ITestProject, 
	0x5c28d560, 0x90fe, 0x11d1, 0xab, 0x95, 0x0, 0x0, 0xf8, 0x2, 0x69, 0x84);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\clvwguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	CLVWGUID.H
//		ClassView package interface ids.

// Interface ID for Class View
DEFINE_GUID(IID_IClassView, 
	0xee099ce0, 0x9c05, 0x11ce, 0xbb, 0x53, 0x0, 0xaa, 0x0, 0x3d, 0xa7, 0xad);

DEFINE_GUID(IID_IClassProvider, 
	0xca4423c0, 0x2fd0, 0x11cf, 0x81, 0xf2, 0x0, 0xaa, 0x0, 0x6c, 0x1d, 0x8);

DEFINE_GUID(IID_IClassProviderFactory, 
	0xddcf7f20, 0x2fd0, 0x11cf, 0x81, 0xf2, 0x0, 0xaa, 0x0, 0x6c, 0x1d, 0x8);

DEFINE_GUID(IID_IWizardNode,
	0xa7d23560, 0x5d01, 0x11cf, 0xb1, 0x1b, 0x0, 0xaa, 0x0, 0x6c, 0x28, 0xb3);

DEFINE_GUID(IID_IWizardStrings, 
	0xc1925605, 0xdf6a, 0x11cf, 0xa8, 0xe7, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);

DEFINE_GUID(IID_IWizardBar, 
0x1909ad40, 0x5fce, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);

DEFINE_GUID(IID_IWizBarClntLang, 
0xcc552ba2, 0xa29e, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);

DEFINE_GUID(IID_IWizBarClntEditor, 
0xcc552ba1, 0xa29e, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);

// guid for collection of wiz bar client editor interfaces
DEFINE_GUID(IID_IWizBarClntEditors, 
0x42d8fdc0, 0xb946, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);

// guid for provider of wiz bar client language interface
DEFINE_GUID(IID_IWizBarClntLangProvider, 
0x92a40220, 0xde47, 0x11cf, 0xb4, 0x15, 0x0, 0xaa, 0x0, 0xa4, 0x80, 0x1a);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\bldguid_.h ===
/////////////////////////////////////////////////////////////////////////////
//	BLDGUIDP.H
//		Build package private IIDs.

// {AE166B00-A9A0-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IAutoBld, 
0xae166b00, 0xa9a0, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\clwzapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	CLWZAPI.H
//		Class Wizard package interface declarations.

#ifndef __CLWZAPI_H__
#define __CLWZAPI_H__

#ifdef _WIZ_INTERNAL
#define WIZ_EXPORT _declspec(dllexport)
#else
#define WIZ_EXPORT _declspec(dllimport)
#endif

interface IClassWizard;
interface IChangeClasses;
interface ICreateClasses2;


typedef IClassWizard* LPCLASSWIZARD;


/////////////////////////////////////////////////////////////////////////////
// IClassWizard
//   This interface is used to access ClassWizard features.  The interface
//   is implemented in the CPP package which implibs to the classwizard DLL.
//

#undef INTERFACE
#define INTERFACE IClassWizard

class CITextDoc;
class CClsWizClass;
#include "ogapi.h"	// need IApplyContext

#define MAX_LINECOUNTS	4

// Defines for Verb Flags
#define CWV_VIRTFUNCT	0x2
#define CWV_PROTFUNCT	0x4
#define CWV_CONSTFUNCT	0x8
#define CWV_ADVFUNCT	0x10
#define CWV_NOTIFY		0x20	/* verb is a type of WM_NOTIFY */
#define CWV_REFLECTED	0x40	/* verb represents a Windows control message which has been
								   reflected to the message map in the control class.
								 */
#define CWV_WM			0x80	/* verb is a window message (currently this flag is
								 * used only with CWV_REFLECTED).
								 */
#define CWV_NIL			0

// CClassWizInterface::Run return values
#define CODEWIZ_FAILED	0
#define CODEWIZ_OK	1
#define CODEWIZ_UPDATE_CLW	2

// flags for nRequest parameter of IClassWizard::Run
#define	CODEWIZ_CLASS_NAME			0			// lpszWholeName = class name
#define	CODEWIZ_DIALOG_RESOURCE		1			// lpszWholeName = resource
#define	CODEWIZ_MENU_RESOURCE		2			// lpszWholeName = resource
#define CODEWIZ_ACCELERATOR_RESOURCE 3			// lpszWholeName = resource
#define CODEWIZ_LAST_CLASS			4			// lpszWholeName = NULL
#define CODEWIZ_FLUSH_PROJECT		5			// lpszWholeName = NULL
#define CODEWIZ_TOOLBAR_RESOURCE	6			// lpszWholeName = resource

// Non-standard COM
class CClsWizVerb : public CObject
{
public:
	CClsWizVerb() {	m_strVerb.Empty(); m_strData.Empty(); m_nVerbFlags = 0; }
	virtual LPCSTR GetDisplayString() { return m_strVerb; }
	virtual UINT GetFlags() { return m_nVerbFlags; }
	virtual void SetFlags(UINT nFlags) { m_nVerbFlags = nFlags; }
	virtual UINT GetEvents() { return m_indexEvents; }
	virtual void SetEvents(UINT nEvents) { m_indexEvents = nEvents; }
	virtual CString &GetVerb() { return m_strVerb; }
	virtual void SetVerb(CString strVerb) { m_strVerb = strVerb; }
	virtual CString &GetCast() { return m_strCast; }
	virtual void SetCast(CString strCast) { m_strCast = strCast; }
	virtual CString &GetData() { return m_strData; }
	virtual void SetData(CString strData) { m_strData = strData; }
	virtual void GetMFCName(CString& strBuf)
	{
		int index = m_strData.Find('|');
		if (index != -1)
			strBuf = m_strData.Left(index);
		else
			strBuf.Empty();
	}
	virtual void GetHelpText(CString& strBuf)
	{
		int index = m_strData.Find('|');
		if (index != -1)
			strBuf = m_strData.Right(m_strData.GetLength()-index-1);
		else
			strBuf.Empty();
	}

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const
	{
		CObject::Dump(dc);
		dc << " named " << m_strVerb;
		dc << " data: " << m_strData;
		dc << "\n";
	}
#endif //_DEBUG

private:
	CString m_strVerb;
	CString m_strData;
	UINT m_nVerbFlags;
	UINT m_indexEvents;
	CString m_strCast;
};

// Non-standard COM.
class CClsWizNoun : public CObject
{
public:
	CClsWizNoun(LPCSTR lpszName) { m_strNoun = lpszName; m_ptinfoEvents = NULL; }
	virtual ~CClsWizNoun() { if (m_ptinfoEvents != NULL) m_ptinfoEvents->Release(); }

	// Temporary in nature - Don't hold this pointer and don't write to it.
	virtual LPCSTR GetDisplayString() { return m_strNoun; }
	virtual void SetNoun(CString strNoun) { m_strNoun = strNoun; }
	virtual UINT GetFlags() { return m_nNounFlags; }
	virtual void SetFlags(UINT nFlags) { m_nNounFlags = nFlags; }
	virtual ITypeInfo *GetEvents() { return m_ptinfoEvents; }
	virtual void SetEvents(ITypeInfo *ptInfo) { m_ptinfoEvents = ptInfo; }
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const
	{
		CObject::Dump(dc);
		dc << " named " << m_strNoun;
		dc << "\n";
	}
#endif //_DEBUG

private:
	CString m_strNoun;
	UINT m_nNounFlags;
	ITypeInfo *m_ptinfoEvents;
};

// There are no exports for the CString object embedded below.
// so turn off Warning 4251 "Don't Ask and don't tell."
#pragma warning(disable: 4251 4275)

typedef CTypedPtrList<CObList, CClsWizVerb*> CClsWizVerbListBase;

class WIZ_EXPORT CClsWizVerbList : public CClsWizVerbListBase
{
// Implementation use only
public:
	virtual BOOL AddVirtualFunctionsToList(const CString& strFilter);
	virtual BOOL AddToListFromResource(LPCSTR lpszResourceName, LPCSTR lpszNoun, char chFilter = '\0',
							   WORD wKey = CWV_NIL, BOOL fFormDlgFilter = FALSE);
	virtual BOOL AddToListFromMemory(LPCSTR lpch, LPCSTR lpszFilter, WORD wKey = 0, BOOL fFormDlgFilter = FALSE);
	virtual BOOL AddToListFromTypeinfo(ITypeInfo *ptinfo);
};

typedef CTypedPtrList<CObList, CClsWizNoun*> CClsWizNounList;


// Non-standard COM.

typedef struct _CWNounEnum
{
	CClsWizNounList *pNounList;
	POSITION posNounEnum;
} CWNounEnum; // Class Wizard noun enumeration state

// Non-standard COM.

typedef struct _CWVerbEnum
{
	CClsWizVerbList *pVerbList;
	POSITION posVerbEnum;
} CWVerbEnum; // Class Wizard verb enumeration state


DECLARE_INTERFACE_(IClassWizard, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IClassWizard methods

	STDMETHOD(IsDBAvailable)(THIS) PURE;
	STDMETHOD(PickDataSource)(THIS_ BOOL& bDAO, BOOL& bBindAll, BOOL& bAutoDetect, BOOL bEnableDAO,
									CString& strSQL, CString& strConnect, CString& strTableType,
									CStringList& columns, CStringList& defVarNames,
									CString& strParamVars, CString& strParamBindings, CString& strParamMap,
									CString& strOpen,
									CString& strTableClass,
									CWnd* pParent) PURE; 	// Non-standard COM.
	STDMETHOD(GenerateControlWrapper)(const GUID& guid, IApplyContext *pAC, LPCSTR szOCXFile) PURE;
	STDMETHOD(RegisterOLEControl)(LPCSTR pszPath) PURE;

	STDMETHOD(Run)(int *i, UINT nRequest, LPCSTR lpszProjPath, HWND hWndOwner,
			LPCSTR lpszWholeName, LPCSTR lpszPartName, LPCSTR lpszAutoContext) PURE;
	STDMETHOD(Update)(UINT nRequest, LPCSTR lpszProjPath, LPCSTR lpszResourceName, LPSTR lpResClwInfo) PURE;
	STDMETHOD(Update)(UINT nRequest, LPCSTR lpszProjPath, LPCSTR lpszOldName,
			LPCSTR lpszNewName, LPSTR lpResClwInfo, BOOL bRebuilding) PURE;
	STDMETHOD(UpdateResourceRebuildStatus)(LPCSTR lpszProjPath, BOOL bForceRebuild) PURE;

	STDMETHOD(DatabaseValid)() PURE;
	STDMETHOD(UpdateCmdUIDatabaseValid)() PURE;
	STDMETHOD(ClassFromFileName)(LPCSTR lpszPathName, CClsWizClass* pClass) PURE; 	// Non-standard COM.
	STDMETHOD(GetClwFileFromFileset)(UINT hFileSet, CString& rstrClwFile) PURE; 	// Non-standard COM.
	STDMETHOD(ImportClass)(UINT hFileSet, LPCSTR lpszClassName, 
							LPCSTR lpszHFileName, LPCSTR lpszCppFileName) PURE;
	STDMETHOD(CreateClassObject)(CClsWizClass** ppClass) PURE; 	// Non-standard COM.
	STDMETHOD(DeleteClassObject)(CClsWizClass* pClass) PURE; 	// Non-standard COM.
	STDMETHOD(GetCreateClasses)(ICreateClasses** ppCreateClasses) PURE;
	STDMETHOD(IsValidClass)(LPCSTR lpszClassName, LPCSTR lpszFileName) PURE;
	STDMETHOD(IsValidFile)(LPCSTR lpszFile, CString* pstrClass) PURE; 	// Non-standard COM.
	STDMETHOD(GetAssocFile)(LPCSTR lpszFile, CString& strClass, CString* pstrAssocFile) PURE; 	// Non-standard COM.
	STDMETHOD(SetClass)(CClsWizClass* pClass, LPCSTR lpszFileName, LPCSTR lpszClass) PURE; 	// Non-standard COM.
	STDMETHOD(InitNounEnum)(CClsWizClass *pClass, CWNounEnum *pCWNounEnum) PURE; 	// Non-standard COM.
	STDMETHOD(GetNextNoun)(CClsWizClass *pClass, CWNounEnum *pCWNounEnum, CClsWizNoun **ppNoun) PURE; 	// Non-standard COM.
	STDMETHOD(ReleaseNounEnum)(CClsWizClass *pClass, CWNounEnum *pCWNounEnum, CClsWizNoun *pNounNoDelete) PURE; 	// Non-standard COM.
	STDMETHOD(InitVerbEnum)(CClsWizClass *pClass, CClsWizNoun *pNoun, CWVerbEnum *pCWVerbEnum) PURE;
	STDMETHOD(InitVerbEnumFromFilter)(char chFilterType, CWVerbEnum *pCWVerbEnum) PURE;
	STDMETHOD(GetNextVerb)(CClsWizClass *pClass, CClsWizNoun *pNoun, CWVerbEnum *pCWVerbEnum, CClsWizVerb **ppVerb) PURE; 	// Non-standard COM.
	STDMETHOD(ReleaseVerbEnum)(CClsWizClass *pClass, CClsWizNoun *pNoun, CWVerbEnum *pCWVerbEnum, CClsWizVerb *pVerbNoDelete) PURE; 	// Non-standard COM.
	STDMETHOD(SetNoun)(CClsWizClass *pClass, CClsWizNoun *pNoun) PURE; 	// Non-standard COM.
	STDMETHOD(GetClassDisplayString)(CClsWizClass *pClass, CString &strDisplay) PURE; 	// Non-standard COM.
	STDMETHOD(GetClassFunctionName)(CClsWizClass *pClass, CClsWizVerb *pVerb, CString &strName) PURE; 	// Non-standard COM.
	STDMETHOD(IsClassVerbHandled)(CClsWizClass *pClass, CClsWizVerb *pVerb) PURE; 	// Non-standard COM.
	STDMETHOD(AddClassVerbHandler)(CClsWizClass *pClass, CClsWizVerb *pVerb, BOOL bVerbose) PURE; 	// Non-standard COM.
	STDMETHOD(RemoveClassVerbHandler)(CClsWizClass *pClass, CClsWizVerb *pVerb) PURE; 	// Non-standard COM.
	STDMETHOD(FinishClassChanges)(CClsWizClass *pClass, BOOL bCommit = TRUE) PURE; 	// Non-standard COM.
	STDMETHOD(ClassNameFromResource)(LPCSTR lpszPathName, LPCSTR lpszResourceName, LPCSTR lpszResourceType, CString& rstrClass) PURE;  // Non-standard COM.
	STDMETHOD(GetChangeClasses)(IChangeClasses** ppChangeClasses) PURE;
	STDMETHOD(GetCreateClassesInnerDlg)(ICreateClasses2** ppCreateClasses2) PURE;
	STDMETHOD(GetClassFilterType)(CClsWizClass* pClass, char *pchFilterType) PURE; 	// Non-standard COM.
	STDMETHOD(SetClassFilterType)(CClsWizClass* pClass, char chFilterType, BOOL fWriteToCLW = TRUE) PURE; 	// Non-standard COM.
	STDMETHOD(SetDefaultConfiguration)(LPCTSTR lpszConfig) PURE;
	STDMETHOD(GetCtlDefaultEvent)(LPCTSTR lpszIDCtl, LPCTSTR lpszTypeCtl, CString &rstrEventDef) PURE;
	STDMETHOD(UpdateClassWizardInfo)() PURE;
	STDMETHOD(UpdateClassWizardInfoForRC)(LPCSTR lpszRCFile) PURE;
	STDMETHOD(GetResourceRebuildStatus)(BOOL* pbDoRebuild) PURE;
	STDMETHOD(SetResourceRebuildStatus)(BOOL bDoRebuild) PURE;
};

/////////////////////////////////////////////////////////////////////////
// IChangeClasses Interface
// This interface allows you to add properties and methods to existing 
// classes.
/////////////////////////////////////////////////////////////////////////
#undef  INTERFACE
#define INTERFACE IChangeClasses
DECLARE_INTERFACE_(IChangeClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 

	// IChangeClasses methods
	STDMETHOD(AddProperty)(THIS_ LPCSTR pszClass) PURE;
	STDMETHOD(AddMethod)(THIS_ LPCSTR pszClass) PURE;
	STDMETHOD (AddEvent) (THIS_ LPCSTR pszClass) PURE;
}; 

/////////////////////////////////////////////////////////////////////////
// ICreateClasses2 Interface
// This interface allows you to manipulate ClassWizard's 'Create New Class'
// dialog as a child dialog instead of as a stand-alone one.
/////////////////////////////////////////////////////////////////////////
#undef  INTERFACE
#define INTERFACE ICreateClasses2
DECLARE_INTERFACE_(ICreateClasses2, IUnknown)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 
	// INewClass methods
	STDMETHOD(SetName)(THIS_ LPCSTR pszName) PURE;
	STDMETHOD(SetBaseClass)(THIS_ LPCSTR pszName) PURE;
	STDMETHOD(SetFiles)(THIS_ LPCSTR pszHeader, LPCSTR pszImplementation) PURE;

	STDMETHOD(SetOLEOptions)(THIS_ UINT nFlags, LPCSTR pszName) PURE;

	// Only for classes that require a dialog template.
	STDMETHOD(SetDialogTemplate)(THIS_ LPCSTR pszDialogID) PURE;

	// These methods are used to allow the user to change class information.
	STDMETHOD(SetNameFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetBaseClassFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetFilesFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetOLEOptionsFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetDialogTemplateFlags)(THIS_ UINT nFlags) PURE;

	// These methods are used to manipulate the window
	STDMETHOD(DoCreate)(THIS_ CWnd* pParentWnd) PURE;
	STDMETHOD(DoDestroyWindow)(THIS) PURE;
	STDMETHOD(OnInitDialog)(THIS) PURE;
    STDMETHOD(DoSetWindowPos)(THIS_ const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags) PURE;
    STDMETHOD(DoShowWindow)(THIS_ int nCmdShow) PURE;
    STDMETHOD(DoEnableWindow)(THIS_ BOOL bEnable) PURE;
	STDMETHOD(DoSetFocus)(THIS_ BOOL bFirst) PURE;
	STDMETHOD(DoUpdateData)(THIS_ BOOL bSaveAndValidate) PURE;
	STDMETHOD(ProcessOnOK)(THIS) PURE;
	STDMETHOD(GetAutoTrackFiles)(THIS_ BOOL FAR* pbAutoTrack) PURE;
	STDMETHOD(SetAutoTrackFiles)(THIS_ BOOL bAutoTrack) PURE;

	// This method actually creates the class.
	STDMETHOD(CreateClass)(THIS) PURE;

	// Error handling for during CreateClass.  We may need to call these
	// if we only called into ICreateClass programatically.  (UI path
	// includes checking with the user in these situations and handling
	// problems that way)
	STDMETHOD(SetGuidFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetResFlags)(THIS_ UINT nFlags) PURE;

	// Information retrieval.
	STDMETHOD(GetName)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetBaseClass)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetFiles)(THIS_ LPSTR FAR* ppszHeader, LPSTR FAR* ppszImplementation) PURE;
	STDMETHOD(GetOLEOptions)(THIS_ UINT FAR* pnFlags, LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetDialogTemplate)(THIS_ LPSTR FAR* ppszDialogID) PURE;

	STDMETHOD(GetFormStrings)(THIS_ UINT nTypeForm, LPFORMSTRINGS *ppFormStrings) PURE;
}; 


#endif	// __CLWZAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\dbgguid.h ===
/////////////////////////////////////////////////////////////////////////////
// DBGGUID.H
//    Debug package interface ids.

// Interface ID for Debug Command {C4E620E1-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_IDebugCmd,
0xc4e620e1, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

// Interface ID for OSDebug {C4E620E2-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_IOSDebug,
0xc4e620e2, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

// Interface ID for Expression Evaluator {C4E620E3-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_IExprEval,
0xc4e620e3, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

// Interface ID for Symbol Handler {C4E620E4-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_ISymbolHandler,
0xc4e620e4, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

// Interface ID for Miscellaneous Debug Command {C4E620E5-60EF-11cf-AA7D-00006B829112}
DEFINE_GUID(IID_IMiscDebug,
0xc4e620e5, 0x60ef, 0x11cf, 0xaa, 0x7d, 0x0, 0x0, 0x6b, 0x82, 0x91, 0x12);

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\commapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	COMMAPI.H
//		Common package interfaces
//
//  Interfaces that may be implemented by more than one package
//   should be declared here.  For example, ICommandProvider is
//   an interface that any package who provides dynamic (transient) commands
//   determined at run-time should implement.

#ifndef __COMMAPI_H__
#define __COMMAPI_H__


/////////////////////////////////////////////////////////////////////////////
// ICommandProvider interface
// A package who provides dynamic (transient) commands (commands not determined
//  until run-time) must implement this interface and return it
//  in response to a call to CPackage::GetCommandProvider.

// DevAut1 is an example of a package which implements this, since it
//  provides commands from macros & Add-Ins, which are unknown until run-time

#undef  INTERFACE
#define INTERFACE ICommandProvider

DECLARE_INTERFACE_(ICommandProvider, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ICommandProvider methods

	// This is called when the shell is persisting the command bars into the
	//  registry, and gives the package a chance to save custom information
	//  alongside the command bar button.
	// This function returns the size of the extra information that needs
	//  to be saved to uniquely identify this command id. If pData is
	//  non-NULL, then the information should be placed into pData,
	//  and pData can be assumed to be large enough to accommodate all the data.
	// The shell calls this function once to ascertain the size of memory block
	//  required, and then again with a memory block of the correct (or larger) size.
	// If the package does not want to save special information for this command
	//  (because it is not transient, for example), then it can return 0, and
	//  the shell will do the default saving of the toolbar.
	STDMETHOD_(WORD, SaveCommand)(WORD nId, LPVOID pData) PURE;

	// Given a block of data previously returned by SaveCommand, this function
	//  converts the block of data to a command id which is valid for this
	//  session of Developer Studio.
	// The shell will be smart enough to know not to call this function for
	//  those commands which the ICommandProvider-implementation did not provide
	//  extra info via SaveCommand.
	STDMETHOD_(WORD, LoadCommand)(LPVOID pData, DWORD dwSize) PURE;

	// This function returns the glyph index and bitmap for a given id and
	//  large/small state.  The shell may call this for commands which the
	//  ICommandProvider-implementation did not provide extra info via
	//  SaveCommand.  For example, if the user right clicks on a command bar,
	//  the shell needs to know if it should enable the menu item to reset
	//  the glyph to the default--thus, it will call this to see if the package
	//  has a default glyph to provide.
	// If the package does not have a default glyph to provide, it may return
	//  NULL, and the shell will deal with it in a mature fashion.
	STDMETHOD_(HBITMAP, GetBitmap)(WORD nId, BOOL bLarge, LPDWORD pnGlyph) PURE;
};

#endif //__COMMAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\galapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	GALAPI.H
//		Gallery package interface declarations.

#ifndef __GALAPI_H__
#define __GALAPI_H__

#ifndef STRICT
typedef DWORD HCUSTOMFEATUREREF;
#else	// STRICT
DECLARE_HANDLE(HCUSTOMFEATUREREF);
#endif	// STRICT

interface IObjectGallery;

typedef IObjectGallery* LPOBJECTGALLERY;

/////////////////////////////////////////////////////////////////////////////
// IObjectGallery
//   This interface is used by ClassWizard and custom oglets
//   to interact with the database, and create apply contexts.

#undef  INTERFACE
#define INTERFACE IObjectGallery
DECLARE_INTERFACE_(IObjectGallery, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IObjectGallery methods

	// Apply context creation methods
	STDMETHOD(CreateApplyContext)(THIS_ REFGUID rFeatureID, UINT nCreateFlags, LPVOID FAR* ppvObj) PURE;

	// Object Gallery Extension creation methods
	STDMETHOD(BeginNewExtension)(THIS_ LPCSTR pszName, HCUSTOMFEATUREREF* phExt) PURE;
	STDMETHOD(AddFile)(THIS_ HCUSTOMFEATUREREF hExt, LPCSTR pszFilename) PURE;
	STDMETHOD(AddResource)(THIS_ HCUSTOMFEATUREREF hExt, LPCSTR pszType, LPCSTR pszSymbol) PURE;
	STDMETHOD(EndExtension)(THIS_ HCUSTOMFEATUREREF hExt) PURE;
	STDMETHOD(ScanProject)(THIS_ LPCSTR pszConfig) PURE;
	STDMETHOD(ScanClass)(THIS_ LPCSTR pszClass) PURE;

	// Code writer methods.
	STDMETHOD(CreateMember)(THIS_ LPCSTR pszMember, UINT nAccess) PURE;
	STDMETHOD(CreateImplementation)(THIS_ LPCSTR pszMember, LPCSTR pszCode) PURE;

	// Misc.
	STDMETHOD(SetDefaultConfiguration)(THIS_ LPCSTR pszConfig) PURE;
	STDMETHOD(CommitEdits)(THIS) PURE;
	STDMETHOD(RevertEdits)(THIS) PURE;
	STDMETHOD(GetClassFiles)(THIS_ LPCSTR pszClass, CString& rstrHeader, CString& rstrImpl) PURE; 	// Non-standard COM.
	STDMETHOD(ClassAccess)(THIS_ LPCSTR pszClass, UINT nMode) PURE;
	STDMETHOD(FindInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
};
#define OPEN_ALWAYS_AC   (0)
#define CREATE_NEW_AC    (1)
#define OPEN_EXISTING_AC (2)

// Access mode flags
#ifndef MODE_READ
#define MODE_READ   (0)
#endif
#ifndef MODE_WRITE
#define MODE_WRITE  (1)
#endif

/////////////////////////////////////////////////////////////////////////////

#endif	// __GALAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\clwzguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	CLWZGUID.H
//		Class Wizard package interface ids.

// Interface ID for ClassWizard
DEFINE_GUID(IID_IClassWizard, 
	0xac448bc1, 0x9670, 0x11ce, 0xa5, 0xba, 0x0, 0xaa, 0x0, 0x6e, 0xba, 0xf3);

// Interface ID for IChangeClasses
// {E3B38FE2-F9DF-11CF-9916-00AA006C28B3}
DEFINE_GUID(IID_IChangeClasses, 
	0xe3b38fe2, 0xf9df, 0x11cf, 0x99, 0x16, 0x0, 0xaa, 0x0, 0x6c, 0x28, 0xb3);

// Interface ID for ICreateClasses2
// {6FF07122-02BD-11D0-A900-00A0C915070C}
DEFINE_GUID(IID_ICreateClasses2, 
0x6ff07122, 0x2bd, 0x11d0, 0xa9, 0x0, 0x0, 0xa0, 0xc9, 0x15, 0x7, 0xc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\dbgpkapi.h ===
#ifndef __DBGPKAPI_H__
#define __DBGPKAPI_H__

interface IDbgPkg;
interface IDLLInfo;

typedef IDbgPkg* PIDBGPKG;
typedef IDbgPkg* LPDEBUGPACKAGE;
typedef IDLLInfo* LPDLLINFO;

/////////////////////////////////////////////////////////////////////////////
//	IDbgPkg interface

#undef INTERFACE
#define INTERFACE IDbgPkg

DECLARE_INTERFACE_(IDbgPkg, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	/*
	** IDbg
	**
	*/

    STDMETHOD_(BOOL, DebuggeeAlive)(void) PURE;
    STDMETHOD_(BOOL, DebuggeeRunning)(void) PURE;
    STDMETHOD_(void *, DbgDAMHsfFromFile)(LPCSTR) PURE;
    STDMETHOD_(BOOL, GetExecutablePath)(LPSTR) PURE;
	STDMETHOD_(BOOL, CanShowDataTip)(void) PURE;
	STDMETHOD(EvaluateExpression)(LPSTR szText, BOOL bFromSelection, LPSTR szResult, ULONG cb) PURE;

	STDMETHOD(SetDebugLines)(CDocument *pDoc, BOOL ResetTraceInfo) PURE;
	STDMETHOD(AdjustDebugLines)(CDocument * pDoc, int StartLine, int NumberLines, BOOL fAdded, BOOL fLineBreak, BOOL fWhiteSpaceOnly) PURE;
	STDMETHOD(DeleteBreakpointLinesInDoc)(LPCSTR sz) PURE;
    STDMETHOD_(BOOL, IsENCProjectFile)(CPath *pPath) PURE;
	STDMETHOD(VTestDebugActive)(BOOL *bActive) PURE;

};

/////////////////////////////////////////////////////////////////////////////
//	IDLLInfo interface

typedef struct
{
	BOOL fPreload;
	CString strLocalName;
	CString strRemoteName;
	BOOL fDelete;
} DLLREC;	// DLL record


#undef  INTERFACE
#define INTERFACE IDLLInfo

DECLARE_INTERFACE_(IDLLInfo, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IDLLInfo methods
	STDMETHOD(DiffDLLs)(ULONG hTarget, CPtrList &listDLLs, INT *piRow, UINT *pidMsg) PURE;
	STDMETHOD(GetDLLCount)(ULONG hTarget, int *piCount) PURE;
	STDMETHOD(InitDLLList)(ULONG hTarget, CPtrList &listDLLs) PURE;
	STDMETHOD(SaveDLLList)(ULONG hTarget, CPtrList &listDLLs) PURE;
};

#endif // __DBGPKAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\idbgproj.h ===
//-----------------------------------------------------------------------------
// 
//
// Microsoft Confidential
// Copyright 1994 - 1995 Microsoft Corporation. All Rights Reserved.
//
// File: idbgproj.h
// Area: Non-Buildable Projects that can still Debug
// Contents:
//	Interface for Debugging without Building
//
// Owner: apennell		(10/2/96)	-	Created 
//-----------------------------------------------------------------------------

#ifndef _IDBGPROJ_H_
#define _IDBGPROJ_H_


//-----------------------------------------------------------------------------
// Name: IDBGProj
//
// Description:
// COM interface definition allowing non-builder projects to support debugging
//-----------------------------------------------------------------------------
DECLARE_INTERFACE_(IDBGProj, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID, LPVOID *) PURE;
	STDMETHOD_(ULONG, AddRef) (VOID) PURE;
	STDMETHOD_(ULONG, Release) (VOID) PURE;

	// IDBDisp methods
	STDMETHOD(SupportsDebugging)(UINT*) PURE;
	STDMETHOD(CommandExecute)(UINT) PURE;
	STDMETHOD(CommandEnabled)( UINT, BOOL* ) PURE;
};
typedef IDBGProj *PDBGPROJ;



#endif  // _IDBDGPROJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\dbgpguid.h ===
// Interface ID for Debugger Functions

DEFINE_GUID(IID_IDbgPkg,
    0xbbdc8f00, 0x68a9, 0x11cf, 0xa8, 0xd, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x54);

// Interface ID for DLLInfo {1A26E5E2-2905-11cf-B250-00AA0057AFF3}
DEFINE_GUID(IID_IDLLInfo, 
	0x1a26e5e2, 0x2905, 0x11cf, 0xb2, 0x50, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

/*
DEFINE_GUID(CLSID_, // {605CD000-7C2F-11cf-A815-00AA00B60154}
    0x605cd000, 0x7c2f, 0x11cf, 0xa8, 0x15, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x54);
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\lex.h ===
#ifndef __LEX__
#define __LEX__

#include <tchar.h>
#include <afx.h>
#include <afxtempl.h>
#include <shlsrvc.h>
#include "memref.h"

//#include "srcapi.h"
//#include "objmodel/textdefs.h"
//#include "objmodel/textauto.h"

#define P_IN(x)     const x &
#define P_OUT(x)    x &
#define P_IO(x)     x &
#define PURE        = 0

// POPDESC is used for popup menus
// defined in shlmenu.h
struct POPDESC;

class CLex;
// Lex state, kept at the beginning of every line (lxsBOL) from
// previous line's state at its end (lxsEOL). Must fit all bits
// necessary to restart lexing on a line by line basis.

const int       cbLexState = sizeof (DWORD);
typedef DWORD   LXS;
typedef LXS *   PLXS;
const LXS       lxsMaskFortranFixed =   0x80000000;
const LXS       lxsMaskFortranTab6 =    0x40000000;
const LXS       lxsMaskFortran =        lxsMaskFortranFixed | lxsMaskFortranTab6;
const LXS       lxsMaskValid =          0x20000000; // Set internally, lexers should not use

inline LXS  LxsFortranBits ( LXS lxs ) { return lxs & lxsMaskFortran; }
inline BOOL FFortranFixed ( LXS lxs ) { return !!(lxs & lxsMaskFortranFixed); }
inline BOOL FFortranTab6 ( LXS lxs ) { return (lxs & lxsMaskFortran) == lxsMaskFortran; }

//
// smart indent support
//
enum INDENT_TYPE {	// Indent Type
	itNone,		// always move caret to home
	itStd,		// move caret to previous lines indent
	itSmart		// smart, context based indenting
	};

// CMemoryBlock TBD, but supports 2 sizes (allocated/used)
// as well as pointer casting operators.
typedef CRefMem * PMEMBL;

typedef DWORD _TS;  // Tabs and Spaces

struct TAB_METRIC;  // forward declaration
typedef TAB_METRIC *PTABMETRIC;
typedef const TAB_METRIC *PCTABMETRIC;

struct GET_LINE_STATE
{
	UINT        lineCur;
	LXS         lxsBolCur;  // necessary for some impls.
	PCTABMETRIC pTabMetric;
	VOID *      pvReserved; // for holding a CTextDoc*
};
typedef GET_LINE_STATE *PGLST;

// The smart indent functions below require a PMEMBL for the editor
// to copy lines into when PfnFGetLine is called from the lexer.
//
// _TS * is a pointer to an array of cLines entries.  Each entry
// describes the number of spaces that need to appear at the beginning
// of the corresponding line.  (The editor is then responsible for
// converting cSpaces into the correct number of tabs and spaces.)

typedef BOOL (__stdcall *PfnFGetLine)(PGLST, INT dLine, PMEMBL);
typedef BOOL (__stdcall *PfnFGetLxs)(PGLST, INT dLine, PLXS & plxs);
typedef void (__stdcall *PfnSmartIndent)
	(CLex *, PGLST, _TS *, UINT cLines, PfnFGetLine, PfnFGetLxs, PMEMBL );

// A tab expansion block is used to determine how to expand tabs
// in the cases where the lexer does special tab expansion as
// well as for variable indent levels.  Given both the tab
// expansion and an array of TABEXBs describing indents,
// the lexer (or anyone) can handle all tabbing/indent behaviors.
typedef INT CTAB;
const CTAB  ctabEnd = 0;
const CTAB  ctabInfinite = -1;  // also implies end of list

struct TABEXB // Tab Expansion Block
{
	CTAB ctabRun;  // run of tabs this width expand to
	union
	{
		UINT ctchIndent; // count of spaces to expand indent
		UINT ctchTab;    // count of spaces to expand tab
	};
};
typedef TABEXB * PTABEXB;
typedef const TABEXB * PCTABEXB;

struct TAB_METRIC
{
	UINT            iTabHead;           // back pointer to extra info
	BOOL            fTrackDefault;      // track the default settings
	BOOL            fInsertSpaces;
	INDENT_TYPE     itCur;
	INDENT_TYPE     itSupported;
	BOOL            fIndentOpen;
	BOOL            fIndentClose;
	UINT            cLinesLookBack;
	PfnSmartIndent  pfnSmartIndent;
	UINT            ctchTab;    // in spaces
	UINT            ctabexb;
	TABEXB          rgtabexb[1];
};

enum SMTSTY  // Smart Styles, dealing with smart indent
{
	smtstyNone = 0,
	smtstySmartIndent = 0x1,
	smtstyIndentSpacesOnly = 0x2,   // only use spaces for indent
	smtstyIndentTabsOnly = 0x4,     // only use tabs (implies tab==indent)
	smtstyIndentBlockTokens = 0x8,  // supports indenting block tokens
	smtstyIndentLookBack = 0x10,    // supports the lookback var
};

// this info comes from the lexer and supplies us with
// the smart indent styles it supports as well as the
// smart indent function pointer and a phrase to use for
// "block token".  in C/C++, that phrase will be "Brace".
const unsigned		ctchBlockTokenPhrase = 31;
struct SMART_STYLES 
{
	DWORD          dwStyles;
	TCHAR          szBlockTokenPhrase[ ctchBlockTokenPhrase + 1 ];
	LPCSTR *       rgExtensions;			// same info as in LANGMETRICS
	PfnSmartIndent pfnSmartIndent;
};


#if 0 // unused
//
// utility functions/defines
//
inline UINT CTabFromTs( _TS ts )	{ return ts >> 16; }
inline UINT CSpaceFromTs( _TS ts )	{ return ts & 0xffff; }
inline _TS TsFromTabSpace( UINT cTab, UINT cSpace ) { return _TS((cTab << 16) + cSpace); }
#endif

// Lexer and language Metrics
const unsigned ctchUserTokenPhrase = 100;
struct USERTOKENS
{
	INT			token;		// preassigned in the user range
	TCHAR		szToken[ctchUserTokenPhrase+1];	// token class name exposed to user
	COLORREF	RGBText;
	COLORREF	RGBBackground;
	AUTO_COLOR	autocolorFore;
	AUTO_COLOR	autocolorBack;
};

typedef USERTOKENS *		PUSERTOKENS;
typedef const USERTOKENS *	PCUSERTOKENS;

struct LANGMETRICS
{
	DWORD			cbMetrics;			// sizeof (LANGMETRICS)
	DWORD			verMetrics;			// version support
	DWORD			cbLXS;				// currently hardwired to 4
	DWORD			fSimpleLxsCmp;		// currently hardwired to TRUE
	LPCSTR * 		rgExtensionsLexed;	// list of file extensions this lexer handles
	PCUSERTOKENS	rgusertok;			// user token list for editor to map
										// new tokens to. NULL szToken denotes
										// end of array.
};

typedef LANGMETRICS * PLANGMETRICS;
typedef const LANGMETRICS * PCLANGMETRICS;

typedef int 	TOKEN;

enum TOKCLS { // token classes
	tokclsError = 0,

	// all standard language keywords
	tokclsKeyWordMin = 1,

	// for block start/end that are keywords instead of operators...like
	// Pascal or BASIC for instance.
	tokclsKeyWordOpenBlock = 0xfe,
	tokclsKeyWordCloseBlock = 0xff,

	tokclsKeyWordMax = 0x100,

	// all language operators
	tokclsOpMin = 0x100,
	tokclsOpSpecOpenBlock = 0x1fe,
	tokclsOpSpecCloseBlock = 0x1ff,
	tokclsOpMax = 0x200,

	// special, hard coded operators that editor keys off of
	tokclsOpSpecMin = 0x200,
	tokclsOpSpecEOL = 0x200,
	tokclsOpSpecLineCmt = 0x201, // automatic skip to eol on this one
	tokclsOpSpecEOS = 0x202,
	tokclsOpSpecMax = 0x210,

	// all identifiers, give ~500 possibilities
	tokclsIdentMin = 0x210,
	tokclsIdentUser = 0x211,	// special idents (user keywords)
	tokclsIdentMax = 0x400,

	// all constants (numeric and string)
	tokclsConstMin = 0x400,
	tokclsConstInteger = 0x400,
	tokclsConstReal = 0x401,
	tokclsConstString = 0x402,
	tokclsStringPart = 0x402,		// partial string ("....)
	tokclsConstMax = 0x410,

	// comments
	tokclsCommentMin = 0x500,
	tokclsCommentPart = 0x500,	// partial comment (/* ...)
	tokclsCommentMax = 0x510,

	// language dependent token class(es) start at 0x800 to 0xfff
	tokclsUserMin = 0x800,
	tokclsUserLast = 0xfff,
	tokclsUserMax = 0x1000,

	// mask to ignore all the bits in a token[class] that the lexer can use
	// for private status.	they will be masked off and ignored by clients
	// of the lexer.  A good use of this feature is to encode the real token
	// type in the lexer private portion (area is ~tokclsMask) when including
	// meta-token types (such as MFC/Wizard user token types) so that other
	// clients of the lexer can keep that information.
	tokclsUserMask = ~(tokclsUserMin - 1),
	tokclsMask = tokclsUserLast,

};

// Alternate way of looking at a token, editor will only look at tokUser.
// Other clients of the lexer (like the parser or the EE) may want to look
// at the actual token in tokAct.  If any of tokAct is set, then it is expected
// that the actual token is different than the meta token it passed back.
// The status bits are only used by the lexer for whatever it wants.

union TOK_ALT  {
	TOKEN 	tok;
	struct {
        unsigned        tokUser : 12;
        unsigned        tokUserStatus : 4;
		unsigned		tokAct : 12;
		unsigned		tokActStatus : 4;
    };
};

// A text token block indicates the token, and its starting and ending 
// indexes in the line of source just lexed.
// Note that for any N > 0, rgtxtb[N].ibTokMin >= rgtxtb[N-1].ibTokMac.
// if it is such that rgtxtb[N].ibTokMin > rgtxtb[N-1].ibTokMac, then 
// the intervening unclassified characters are treated as white space tokens.
struct TXTB { // Text token class block
	TOKEN 	tok;
	UINT	ibTokMin;		// token length given by ibTokMac - ibTokMin
	UINT	ibTokMac;		// given in bytes
};

typedef CArray <TXTB, TXTB> RGTXTB;

// A SUBLANG structure was originally used for identifying different 
// dialects of the same language (like fortran fixed and fortran free) 
// that use the same lexer, can be treated as two languages in the editor, 
// and share all the same color/font info in the format dialog.
//
// We've extended it to be a general descriptor for a type of text file.
//
struct SUBLANG
{
	LPCSTR  szSubLang;
	LXS     lxsInitial;
	UINT    nIdTemplate; // Icon and MFC doc template string resource id
	CLSID   clsidTemplate;
};
typedef SUBLANG * PSUBLANG;
typedef const SUBLANG *	PCSUBLANG;

// Editor Interface Request flags
#define EIR_IEdit   0x0001
#define EIR_IDoc    0x0002
#define EIR_ISel    0x0004

// forward decls
interface ISourceEdit;
interface ITextDocument;
interface ITextSelection;
class CBContextPopupMenu;

///////////////////////////////////////////////////////
// Class CLex
// 	specific lexer should derive from this class
///////////////////////////////////////////////////////
class CLex
{
protected:
	// ctor and dtor are protected and can only be called 
	// internally by the creator in the owning package.
	CLex() {};

	virtual ~CLex() {};

public:
	// give a pointer to the language specific metrics.
	// Lexer can expect it to be used at any time, so leave
	// it allocated and unchanged. It can ( and probably
	// should) be in r/o memory.
	virtual void QueryLangMetrics ( P_IO(LANGMETRICS) ) PURE;

	// return a string indicating the language this lexer
	// understands, eg: "C/C++", "Fortran", or "Basic"

// REVIEW [paulde]: see if we can just get this from the sublang,
// since we're pretty much requiring a PSUBLANG override now.
	virtual LPCSTR SzLanguage() PURE;

// [paulde]	To be removed: use sublangs instead.
	// return a default file extension string id for this language
	virtual UINT GetDefaultFileExtension( LPCSTR szSubLanguage ) PURE;

	// see if this lexer will by default handle this type of file
	virtual BOOL FCanLexFile ( LPCSTR szFilename ) PURE;

	// compare two lexer states for equality or not.
// REVIEW [paulde]: see if we can remove this.
	virtual BOOL FCmpLxsLxs ( PLXS, PLXS ) PURE;

	// lex the line, giving us back ton'o'info,
	// returns count of TCHAR that were tokenized in
	// ptchLine.

	virtual UINT CbLexLine (
					LPCSTR			ptchLine,
					UINT			cbLine,
					PLXS			plxs,	  // in: BOL state, out: eol state
					P_OUT (RGTXTB)	rgtxtb,
					P_IO(DWORD)		dwReserved
					) PURE;

	// slim version of lex line
	// since only interested in the plxs.
	virtual UINT CbLexLine (
					LPCSTR			ptchLine,
					UINT			cbLine,
					PLXS			plxs,	  // in: BOL state, out: eol state
					P_IO(DWORD)		dwReserved
					) PURE;

	// give out the smart indent info
	virtual void QuerySmartStyles ( P_IO(SMART_STYLES) ) PURE;

	// get the initial LXS for this file, so one lexer can handle multiple
	//	languages or variations of the same language.
	virtual LXS LxsInitial ( LPCSTR szFilename ) { return LXS(0); }

	// inform the lexer that the default set of extensions to be lexed has
	//	been changed and the new list should be used instead.
	virtual void SetExtensionsLexed ( P_IN(CStringList) ) { }

	// gives back a pointer to an array of SUBLANGs, ending with a szSubLang == NULL
	virtual PCSUBLANG PSubLang() { return NULL; }

// REVIEW [paulde]: see if we can remove the 'special state' methods
	// returns TRUE if LXS is in the special state (in C++, in AFX_WIZARD state for instance)
	virtual BOOL IsInSpecialState (LXS lxs) { return FALSE;}

	// reset the state if it is in the special state
	virtual void UnsetSpecialState (P_IO(LXS) lxs) { return; }

	// get the size of the first tab (used only for fortran fixed form)
	virtual UINT CbFirstTab(
					LPCSTR			ptchLine,
					UINT			cbLine,
					LXS				lxs	  // BOL state
					) { return 0; };

	// return a popdesc array with the menu to display
	// OBSOLETE: override FCanDoContextMenu and and DoContextMenu instead.
    virtual POPDESC* GetContextMenu() {return NULL;}

	// Can lexer display a popup menu?
	// If so, return TRUE with dwFlags set with the EIR_... values to indicate 
	// which interfaces you want passed to you by DoContextMenu().
	virtual BOOL FCanDoContextMenu( P_OUT(ULONG) dwFlags ) { dwFlags = 0; return FALSE; }

	// Display the context menu.
	// Recommended lexer implementation:
    // void CMyLexer::DoContextMenu( ... )
    // {
    //    CBContextPopupMenu menuLexer; // lexer's context menu
    //    // Create lexer menu, probably using menuLexer.Create(PPOPDESC);
    //    ...
    //    // Merge editor menu with lexer menu
    //    // Note that the lexer menu is empty after merging.
    //    menu.MergeMenu( nMergePos, nMergeFlags, & menuLexer );
    //
    //   // Show menu
    //    menu.TrackPopup(TPM_LEFTALIGN | TPM_RIGHTBUTTON, pt.x, pt.y, AfxGetMainWnd());
    //
    //   // release interfaces
    //   piEdit->Release();
    //   ...
    // }
	virtual void DoContextMenu(
		CPoint pt,                 // Mouse position
		CBContextPopupMenu & menu, // Editor's menu - should merge lexer's items with editor's
		UINT nMergePos,
		UINT nMergeFlags,
		// Requested interfaces - can be NULL
		ISourceEdit * piEdit,
		ITextDocument * piDoc,
		ITextSelection * piSel
		)
	{ ASSERT(0); } // must provide an implementation if FCanDoContextMenu returns TRUE

	// Can lexer render a file template (called at FileNew)?
	// If so, return TRUE with dwFlags set with the EIR_... values to indicate 
	// which interfaces you want passed to you by RenderTemplate().
	virtual BOOL FCanRenderTemplate( P_OUT(ULONG) dwFlags ) { return FALSE; }

	virtual void RenderTemplate(
		ISourceEdit* piEdit, 
		ITextDocument* piDoc, 
		ITextSelection* piSel )
	{ ASSERT(0); } // must provide an implementation if FCanRenderTemplate returns TRUE
};

typedef CLex *	PLEX;

// Maximum length (not including \0 at end) of name returned by CLex::SzLanguage()
#define MAX_LANGNAMELEN (50)

// C/C++ tokens included here for historical/migration reasons
#ifdef USE_CPLUSPLUS_TOKENS
#include "tokcpp.h"
#endif	// USE_CPLUSPLUS_TOKENS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\iswsguid.h ===
//=[f========================================================================
// 	iswsguid.h
//
//	Guids defined for IStudio. Include after <initguid.h> to define storage.
//
//	Copyright (C) 1996 Microsoft Corporation,
//	All rights reserved.
//
//=f]========================================================================

// Our doc template guid
// {6F97F641-726F-11cf-97EA-00AA00C006B6}
DEFINE_GUID(CLSID_IStudioDoc, 0x6f97f641, 0x726f, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);

// Webscope document guid (used by shell)
#ifndef GUID_CLSID_WebScope
#define GUID_CLSID_WebScope
DEFINE_GUID(CLSID_WebScopeDoc, 0x4d6ff300, 0x7cde, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);
#endif

// {1AEE2F43-A42B-11cf-97EA-00AA00C006B6}
DEFINE_GUID(IID_IWebProject, 0x1aee2f43, 0xa42b, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);
// {0C11C141-A4C0-11cf-97EA-00AA00C006B6}
DEFINE_GUID(SID_SWebProject, 0xc11c141, 0xa4c0, 0x11cf, 0x97, 0xea, 0x0, 0xaa, 0x0, 0xc0, 0x6, 0xb6);


// {50BC5FE5-AEA2-11cf-B4D3-00AA00B8DDEA}
DEFINE_GUID(IID_IWebService, 0x50bc5fe5, 0xaea2, 0x11cf, 0xb4, 0xd3, 0x0, 0xaa, 0x0, 0xb8, 0xdd, 0xea);
// {0ACD4D51-B345-11cf-B7D4-00AA00B8DDEA}
DEFINE_GUID(SID_SWebService, 0xacd4d51, 0xb345, 0x11cf, 0xb7, 0xd4, 0x0, 0xaa, 0x0, 0xb8, 0xdd, 0xea);


// {9834F751-168C-11d0-8158-00A0C91E29D5}
DEFINE_GUID(SID_SDBConnection, 0x9834f751, 0x168c, 0x11d0, 0x81, 0x58, 0x0, 0xa0, 0xc9, 0x1e, 0x29, 0xd5);


// {7FE1F3C1-076E-11d0-8BEC-00A0C90F55D6}
DEFINE_GUID(IID_IDBConnectionRuntime, 0x7fe1f3c1, 0x76e, 0x11d0, 0x8b, 0xec, 0x0, 0xa0, 0xc9, 0xf, 0x55, 0xd6);


// Guid to differinate us from other PkgProjects
// {0A535520-DF5F-11cf-B4B2-00C04FD71DE9}
DEFINE_GUID(IID_IWebPkgProject, 0xa535520, 0xdf5f, 0x11cf, 0xb4, 0xb2, 0x0, 0xc0, 0x4f, 0xd7, 0x1d, 0xe9);


// {D11F0D22-1333-11d0-8155-00A0C91E29D5}
DEFINE_GUID(IID_IWebProjectFiles, 0xd11f0d22, 0x1333, 0x11d0, 0x81, 0x55, 0x0, 0xa0, 0xc9, 0x1e, 0x29, 0xd5);

// End of iswsguid.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\iswsapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.59 */
/* at Wed Dec 11 12:17:47 1996
 */
/* Compiler settings for iswsapi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iswsapi_h__
#define __iswsapi_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IGenericDocument_FWD_DEFINED__
#define __IGenericDocument_FWD_DEFINED__
typedef interface IGenericDocument IGenericDocument;
#endif 	/* __IGenericDocument_FWD_DEFINED__ */


#ifndef __IGenericWindow_FWD_DEFINED__
#define __IGenericWindow_FWD_DEFINED__
typedef interface IGenericWindow IGenericWindow;
#endif 	/* __IGenericWindow_FWD_DEFINED__ */


#ifndef __IGenericProject_FWD_DEFINED__
#define __IGenericProject_FWD_DEFINED__
typedef interface IGenericProject IGenericProject;
#endif 	/* __IGenericProject_FWD_DEFINED__ */


#ifndef __IDBConnection_FWD_DEFINED__
#define __IDBConnection_FWD_DEFINED__
typedef interface IDBConnection IDBConnection;
#endif 	/* __IDBConnection_FWD_DEFINED__ */


#ifndef __IDBConnections_FWD_DEFINED__
#define __IDBConnections_FWD_DEFINED__
typedef interface IDBConnections IDBConnections;
#endif 	/* __IDBConnections_FWD_DEFINED__ */


#ifndef __IDBConnectionRuntime_FWD_DEFINED__
#define __IDBConnectionRuntime_FWD_DEFINED__
typedef interface IDBConnectionRuntime IDBConnectionRuntime;
#endif 	/* __IDBConnectionRuntime_FWD_DEFINED__ */


#ifndef __IWebProject_FWD_DEFINED__
#define __IWebProject_FWD_DEFINED__
typedef interface IWebProject IWebProject;
#endif 	/* __IWebProject_FWD_DEFINED__ */


#ifndef __IWebService_FWD_DEFINED__
#define __IWebService_FWD_DEFINED__
typedef interface IWebService IWebService;
#endif 	/* __IWebService_FWD_DEFINED__ */


#ifndef __IWebProjectFiles_FWD_DEFINED__
#define __IWebProjectFiles_FWD_DEFINED__
typedef interface IWebProjectFiles IWebProjectFiles;
#endif 	/* __IWebProjectFiles_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_iswsapi_0000
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif
#include "ObjModel\AppDefs.h"
#include "ObjModel\AppAuto.h"


extern RPC_IF_HANDLE __MIDL_itf_iswsapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iswsapi_0000_v0_0_s_ifspec;


#ifndef __DSWebProjects_LIBRARY_DEFINED__
#define __DSWebProjects_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: DSWebProjects
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


#if 0
typedef /* [hidden] */ 
enum tagDSWINDOWSTATE
    {	dsWindowStateMaximized	= 1,
	dsWindowStateMinimized	= 2,
	dsWindowStateNormal	= 3
    }	DsWindowState;

typedef /* [hidden] */ 
enum tagDSARRANGESTYLE
    {	dsMinimize	= 1,
	dsTileHorizontal	= 2,
	dsTileVertical	= 3,
	dsCascade	= 4
    }	DsArrangeStyle;

typedef /* [hidden] */ 
enum tagDSBUTTONTYPE
    {	dsGlyph	= 1,
	dsText	= 2
    }	DsButtonType;

typedef /* [hidden] */ 
enum tagDSSAVECHANGES
    {	dsSaveChangesYes	= 1,
	dsSaveChangesNo	= 2,
	dsSaveChangesPrompt	= 3
    }	DsSaveChanges;

typedef /* [hidden] */ 
enum tagDSSAVESTATUS
    {	dsSaveSucceeded	= 1,
	dsSaveCanceled	= 2
    }	DsSaveStatus;

#endif // 0

EXTERN_C const IID LIBID_DSWebProjects;

#ifndef __IGenericDocument_INTERFACE_DEFINED__
#define __IGenericDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericDocument
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FB7FDAE1-89B8-11cf-9BE8-00A0C90A632C")
    IGenericDocument : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *pPath) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Saved( 
            /* [retval][out] */ boolean __RPC_FAR *pSaved) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveWindow( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ReadOnly( 
            /* [in] */ boolean ReadOnly) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Windows( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ boolean bActive) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ boolean __RPC_FAR *pbActive) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NewWindow( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save( 
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Undo( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Redo( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PrintOut( 
            /* [retval][out] */ boolean __RPC_FAR *pSuccess) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pPath);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Saved )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSaved);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveWindow )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadOnly )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pReadOnly);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ReadOnly )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ boolean ReadOnly);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Windows )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IGenericDocument __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewWindow )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )( 
            IGenericDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vFilename,
            /* [optional][in] */ VARIANT vBoolPrompt,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PrintOut )( 
            IGenericDocument __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pSuccess);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IGenericDocument __RPC_FAR * This,
            /* [optional][in] */ VARIANT vSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericDocument __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericDocument __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericDocumentVtbl;

    interface IGenericDocument
    {
        CONST_VTBL struct IGenericDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericDocument_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IGenericDocument_get_FullName(This,pName)	\
    (This)->lpVtbl -> get_FullName(This,pName)

#define IGenericDocument_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#define IGenericDocument_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IGenericDocument_get_Path(This,pPath)	\
    (This)->lpVtbl -> get_Path(This,pPath)

#define IGenericDocument_get_Saved(This,pSaved)	\
    (This)->lpVtbl -> get_Saved(This,pSaved)

#define IGenericDocument_get_ActiveWindow(This,ppWindow)	\
    (This)->lpVtbl -> get_ActiveWindow(This,ppWindow)

#define IGenericDocument_get_ReadOnly(This,pReadOnly)	\
    (This)->lpVtbl -> get_ReadOnly(This,pReadOnly)

#define IGenericDocument_put_ReadOnly(This,ReadOnly)	\
    (This)->lpVtbl -> put_ReadOnly(This,ReadOnly)

#define IGenericDocument_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IGenericDocument_get_Windows(This,ppWindows)	\
    (This)->lpVtbl -> get_Windows(This,ppWindows)

#define IGenericDocument_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IGenericDocument_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IGenericDocument_NewWindow(This,ppWindow)	\
    (This)->lpVtbl -> NewWindow(This,ppWindow)

#define IGenericDocument_Save(This,vFilename,vBoolPrompt,pSaved)	\
    (This)->lpVtbl -> Save(This,vFilename,vBoolPrompt,pSaved)

#define IGenericDocument_Undo(This,pSuccess)	\
    (This)->lpVtbl -> Undo(This,pSuccess)

#define IGenericDocument_Redo(This,pSuccess)	\
    (This)->lpVtbl -> Redo(This,pSuccess)

#define IGenericDocument_PrintOut(This,pSuccess)	\
    (This)->lpVtbl -> PrintOut(This,pSuccess)

#define IGenericDocument_Close(This,vSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,vSaveChanges,pSaved)

#define IGenericDocument_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericDocument_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericDocument_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericDocument_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericDocument_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericDocument_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericDocument_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericDocument_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericDocument_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericDocument_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Name_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IGenericDocument_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_FullName_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IGenericDocument_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Application_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IGenericDocument_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Parent_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IGenericDocument_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Path_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pPath);


void __RPC_STUB IGenericDocument_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Saved_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_get_Saved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_ActiveWindow_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);


void __RPC_STUB IGenericDocument_get_ActiveWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_ReadOnly_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pReadOnly);


void __RPC_STUB IGenericDocument_get_ReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericDocument_put_ReadOnly_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [in] */ boolean ReadOnly);


void __RPC_STUB IGenericDocument_put_ReadOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Type_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IGenericDocument_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Windows_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindows);


void __RPC_STUB IGenericDocument_get_Windows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericDocument_put_Active_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [in] */ boolean bActive);


void __RPC_STUB IGenericDocument_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericDocument_get_Active_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbActive);


void __RPC_STUB IGenericDocument_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_NewWindow_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWindow);


void __RPC_STUB IGenericDocument_NewWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Save_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [optional][in] */ VARIANT vFilename,
    /* [optional][in] */ VARIANT vBoolPrompt,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Undo_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Redo_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_Redo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_PrintOut_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pSuccess);


void __RPC_STUB IGenericDocument_PrintOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Close_Proxy( 
    IGenericDocument __RPC_FAR * This,
    /* [optional][in] */ VARIANT vSaveChanges,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericDocument_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved1_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved2_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved3_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved4_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved5_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved6_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved7_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved8_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved9_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericDocument_Reserved10_Proxy( 
    IGenericDocument __RPC_FAR * This);


void __RPC_STUB IGenericDocument_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericDocument_INTERFACE_DEFINED__ */


#ifndef __IGenericWindow_INTERFACE_DEFINED__
#define __IGenericWindow_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericWindow
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD20FC80-A9D2-11cf-9C13-00A0C90A632C")
    IGenericWindow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Caption( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Active( 
            /* [in] */ boolean bActive) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Active( 
            /* [retval][out] */ boolean __RPC_FAR *pbActive) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Left( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Left( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Top( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Top( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Next( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Previous( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WindowState( 
            /* [in] */ DsWindowState lVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WindowState( 
            /* [retval][out] */ DsWindowState __RPC_FAR *plVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ VARIANT boolSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericWindow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericWindow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericWindow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Caption )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Active )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ boolean bActive);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Active )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ boolean __RPC_FAR *pbActive);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Left )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Left )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Top )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Top )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ long lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Index )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Next )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Previous )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WindowState )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ DsWindowState lVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WindowState )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ DsWindowState __RPC_FAR *plVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericWindow __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close )( 
            IGenericWindow __RPC_FAR * This,
            /* [in] */ VARIANT boolSaveChanges,
            /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericWindow __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericWindow __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericWindowVtbl;

    interface IGenericWindow
    {
        CONST_VTBL struct IGenericWindowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericWindow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericWindow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericWindow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericWindow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericWindow_get_Caption(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Caption(This,pbstrCaption)

#define IGenericWindow_get_Type(This,pbstrCaption)	\
    (This)->lpVtbl -> get_Type(This,pbstrCaption)

#define IGenericWindow_put_Active(This,bActive)	\
    (This)->lpVtbl -> put_Active(This,bActive)

#define IGenericWindow_get_Active(This,pbActive)	\
    (This)->lpVtbl -> get_Active(This,pbActive)

#define IGenericWindow_put_Left(This,lVal)	\
    (This)->lpVtbl -> put_Left(This,lVal)

#define IGenericWindow_get_Left(This,plVal)	\
    (This)->lpVtbl -> get_Left(This,plVal)

#define IGenericWindow_put_Top(This,lVal)	\
    (This)->lpVtbl -> put_Top(This,lVal)

#define IGenericWindow_get_Top(This,plVal)	\
    (This)->lpVtbl -> get_Top(This,plVal)

#define IGenericWindow_put_Height(This,lVal)	\
    (This)->lpVtbl -> put_Height(This,lVal)

#define IGenericWindow_get_Height(This,plVal)	\
    (This)->lpVtbl -> get_Height(This,plVal)

#define IGenericWindow_put_Width(This,lVal)	\
    (This)->lpVtbl -> put_Width(This,lVal)

#define IGenericWindow_get_Width(This,plVal)	\
    (This)->lpVtbl -> get_Width(This,plVal)

#define IGenericWindow_get_Index(This,plVal)	\
    (This)->lpVtbl -> get_Index(This,plVal)

#define IGenericWindow_get_Next(This,ppDispatch)	\
    (This)->lpVtbl -> get_Next(This,ppDispatch)

#define IGenericWindow_get_Previous(This,ppDispatch)	\
    (This)->lpVtbl -> get_Previous(This,ppDispatch)

#define IGenericWindow_put_WindowState(This,lVal)	\
    (This)->lpVtbl -> put_WindowState(This,lVal)

#define IGenericWindow_get_WindowState(This,plVal)	\
    (This)->lpVtbl -> get_WindowState(This,plVal)

#define IGenericWindow_get_Application(This,ppDispatch)	\
    (This)->lpVtbl -> get_Application(This,ppDispatch)

#define IGenericWindow_get_Parent(This,ppDispatch)	\
    (This)->lpVtbl -> get_Parent(This,ppDispatch)

#define IGenericWindow_Close(This,boolSaveChanges,pSaved)	\
    (This)->lpVtbl -> Close(This,boolSaveChanges,pSaved)

#define IGenericWindow_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericWindow_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericWindow_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericWindow_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericWindow_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericWindow_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericWindow_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericWindow_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericWindow_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericWindow_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Caption_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);


void __RPC_STUB IGenericWindow_get_Caption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Type_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCaption);


void __RPC_STUB IGenericWindow_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Active_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ boolean bActive);


void __RPC_STUB IGenericWindow_put_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Active_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ boolean __RPC_FAR *pbActive);


void __RPC_STUB IGenericWindow_get_Active_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Left_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Left_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Left_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Top_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Top_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Top_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Height_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Height_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_Width_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ long lVal);


void __RPC_STUB IGenericWindow_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Width_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Index_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_Index_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Next_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Previous_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IGenericWindow_put_WindowState_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ DsWindowState lVal);


void __RPC_STUB IGenericWindow_put_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_WindowState_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ DsWindowState __RPC_FAR *plVal);


void __RPC_STUB IGenericWindow_get_WindowState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Application_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IGenericWindow_get_Parent_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IGenericWindow_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Close_Proxy( 
    IGenericWindow __RPC_FAR * This,
    /* [in] */ VARIANT boolSaveChanges,
    /* [retval][out] */ DsSaveStatus __RPC_FAR *pSaved);


void __RPC_STUB IGenericWindow_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved1_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved2_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved3_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved4_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved5_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved6_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved7_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved8_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved9_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericWindow_Reserved10_Proxy( 
    IGenericWindow __RPC_FAR * This);


void __RPC_STUB IGenericWindow_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericWindow_INTERFACE_DEFINED__ */


#ifndef __IGenericProject_INTERFACE_DEFINED__
#define __IGenericProject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IGenericProject
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][dual][hidden][oleautomation][uuid] */ 



EXTERN_C const IID IID_IGenericProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8CA5A960-FC7D-11cf-927D-00A0C9138C45")
    IGenericProject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FullName( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *pType) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved1( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved2( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved3( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved4( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved5( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved6( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved7( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved8( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved9( void) = 0;
        
        virtual /* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE Reserved10( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGenericProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGenericProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGenericProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IGenericProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IGenericProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IGenericProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IGenericProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IGenericProject __RPC_FAR * This);
        
        END_INTERFACE
    } IGenericProjectVtbl;

    interface IGenericProject
    {
        CONST_VTBL struct IGenericProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGenericProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGenericProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGenericProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGenericProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGenericProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGenericProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGenericProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGenericProject_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IGenericProject_get_FullName(This,Name)	\
    (This)->lpVtbl -> get_FullName(This,Name)

#define IGenericProject_get_Application(This,Application)	\
    (This)->lpVtbl -> get_Application(This,Application)

#define IGenericProject_get_Parent(This,Parent)	\
    (This)->lpVtbl -> get_Parent(This,Parent)

#define IGenericProject_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IGenericProject_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IGenericProject_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IGenericProject_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IGenericProject_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IGenericProject_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IGenericProject_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IGenericProject_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IGenericProject_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IGenericProject_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IGenericProject_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Name_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IGenericProject_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_FullName_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IGenericProject_get_FullName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Application_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);


void __RPC_STUB IGenericProject_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Parent_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);


void __RPC_STUB IGenericProject_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_get_Type_Proxy( 
    IGenericProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pType);


void __RPC_STUB IGenericProject_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved1_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved2_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved3_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved4_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved5_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved6_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved6_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved7_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved7_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved8_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved9_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved9_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][hidden][id] */ HRESULT STDMETHODCALLTYPE IGenericProject_Reserved10_Proxy( 
    IGenericProject __RPC_FAR * This);


void __RPC_STUB IGenericProject_Reserved10_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGenericProject_INTERFACE_DEFINED__ */


#ifndef __IDBConnection_INTERFACE_DEFINED__
#define __IDBConnection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBConnection
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDBConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("F7CCDBA0-AF0C-11cf-97EA-00AA00C006B6")
    IDBConnection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectString( 
            /* [retval][out] */ BSTR __RPC_FAR *pConnectString) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectString( 
            /* [in] */ BSTR ConnectString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionTimeout( 
            /* [retval][out] */ long __RPC_FAR *pTimeout) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ConnectionTimeout( 
            /* [in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CommandTimeout( 
            /* [retval][out] */ long __RPC_FAR *pTimeout) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CommandTimeout( 
            /* [in] */ long Timeout) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Runtime( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Connected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDBConnection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Name )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectString )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pConnectString);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectString )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ BSTR ConnectString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pTimeout);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ConnectionTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ long Timeout);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CommandTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pTimeout);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CommandTimeout )( 
            IDBConnection __RPC_FAR * This,
            /* [in] */ long Timeout);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Runtime )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Connected )( 
            IDBConnection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IDBConnection __RPC_FAR * This);
        
        END_INTERFACE
    } IDBConnectionVtbl;

    interface IDBConnection
    {
        CONST_VTBL struct IDBConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBConnection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDBConnection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDBConnection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDBConnection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDBConnection_get_Name(This,pName)	\
    (This)->lpVtbl -> get_Name(This,pName)

#define IDBConnection_put_Name(This,Name)	\
    (This)->lpVtbl -> put_Name(This,Name)

#define IDBConnection_get_Parent(This,pParent)	\
    (This)->lpVtbl -> get_Parent(This,pParent)

#define IDBConnection_get_ConnectString(This,pConnectString)	\
    (This)->lpVtbl -> get_ConnectString(This,pConnectString)

#define IDBConnection_put_ConnectString(This,ConnectString)	\
    (This)->lpVtbl -> put_ConnectString(This,ConnectString)

#define IDBConnection_get_ConnectionTimeout(This,pTimeout)	\
    (This)->lpVtbl -> get_ConnectionTimeout(This,pTimeout)

#define IDBConnection_put_ConnectionTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_ConnectionTimeout(This,Timeout)

#define IDBConnection_get_CommandTimeout(This,pTimeout)	\
    (This)->lpVtbl -> get_CommandTimeout(This,pTimeout)

#define IDBConnection_put_CommandTimeout(This,Timeout)	\
    (This)->lpVtbl -> put_CommandTimeout(This,Timeout)

#define IDBConnection_get_Runtime(This,pRuntime)	\
    (This)->lpVtbl -> get_Runtime(This,pRuntime)

#define IDBConnection_get_Connected(This,pValid)	\
    (This)->lpVtbl -> get_Connected(This,pValid)

#define IDBConnection_Connect(This)	\
    (This)->lpVtbl -> Connect(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Name_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IDBConnection_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_Name_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IDBConnection_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Parent_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);


void __RPC_STUB IDBConnection_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_ConnectString_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pConnectString);


void __RPC_STUB IDBConnection_get_ConnectString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_ConnectString_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ BSTR ConnectString);


void __RPC_STUB IDBConnection_put_ConnectString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_ConnectionTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pTimeout);


void __RPC_STUB IDBConnection_get_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_ConnectionTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ long Timeout);


void __RPC_STUB IDBConnection_put_ConnectionTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_CommandTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pTimeout);


void __RPC_STUB IDBConnection_get_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnection_put_CommandTimeout_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [in] */ long Timeout);


void __RPC_STUB IDBConnection_put_CommandTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Runtime_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pRuntime);


void __RPC_STUB IDBConnection_get_Runtime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnection_get_Connected_Proxy( 
    IDBConnection __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pValid);


void __RPC_STUB IDBConnection_get_Connected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnection_Connect_Proxy( 
    IDBConnection __RPC_FAR * This);


void __RPC_STUB IDBConnection_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBConnection_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DBConnection;

class DECLSPEC_UUID("F7CCDBA2-AF0C-11cf-97EA-00AA00C006B6")
DBConnection;
#endif

#ifndef __IDBConnections_INTERFACE_DEFINED__
#define __IDBConnections_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBConnections
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDBConnections;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("79937DA0-AA6D-11cf-97EA-00AA00C006B6")
    IDBConnections : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR Name,
            /* [in] */ BSTR ConnectString,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveConnections( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBConnectionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBConnections __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBConnections __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDBConnections __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDBConnections __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ BSTR ConnectString,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IDBConnections __RPC_FAR * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveConnections )( 
            IDBConnections __RPC_FAR * This);
        
        END_INTERFACE
    } IDBConnectionsVtbl;

    interface IDBConnections
    {
        CONST_VTBL struct IDBConnectionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBConnections_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBConnections_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBConnections_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBConnections_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDBConnections_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDBConnections_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDBConnections_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDBConnections_get__NewEnum(This,_ppNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,_ppNewEnum)

#define IDBConnections_Item(This,Index,pDBConnection)	\
    (This)->lpVtbl -> Item(This,Index,pDBConnection)

#define IDBConnections_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define IDBConnections_get_Parent(This,pWebProject)	\
    (This)->lpVtbl -> get_Parent(This,pWebProject)

#define IDBConnections_Add(This,Name,ConnectString,pDBConnection)	\
    (This)->lpVtbl -> Add(This,Name,ConnectString,pDBConnection)

#define IDBConnections_Remove(This,Index)	\
    (This)->lpVtbl -> Remove(This,Index)

#define IDBConnections_SaveConnections(This)	\
    (This)->lpVtbl -> SaveConnections(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get__NewEnum_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);


void __RPC_STUB IDBConnections_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Item_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);


void __RPC_STUB IDBConnections_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get_Count_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB IDBConnections_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnections_get_Parent_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pWebProject);


void __RPC_STUB IDBConnections_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Add_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ BSTR ConnectString,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pDBConnection);


void __RPC_STUB IDBConnections_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_Remove_Proxy( 
    IDBConnections __RPC_FAR * This,
    /* [in] */ VARIANT Index);


void __RPC_STUB IDBConnections_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDBConnections_SaveConnections_Proxy( 
    IDBConnections __RPC_FAR * This);


void __RPC_STUB IDBConnections_SaveConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBConnections_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DBConnections;

class DECLSPEC_UUID("79937DA2-AA6D-11cf-97EA-00AA00C006B6")
DBConnections;
#endif

#ifndef __IDBConnectionRuntime_INTERFACE_DEFINED__
#define __IDBConnectionRuntime_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDBConnectionRuntime
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IDBConnectionRuntime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7FE1F3C1-076E-11d0-8BEC-00A0C90F55D6")
    IDBConnectionRuntime : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserName( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UserName( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Password( 
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Password( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CursorLocation( 
            /* [retval][out] */ long __RPC_FAR *pLocation) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CursorLocation( 
            /* [in] */ long Location) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDBConnectionRuntimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDBConnectionRuntime __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDBConnectionRuntime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserName )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserName )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Password )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Password )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorLocation )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pLocation);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorLocation )( 
            IDBConnectionRuntime __RPC_FAR * This,
            /* [in] */ long Location);
        
        END_INTERFACE
    } IDBConnectionRuntimeVtbl;

    interface IDBConnectionRuntime
    {
        CONST_VTBL struct IDBConnectionRuntimeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDBConnectionRuntime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDBConnectionRuntime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDBConnectionRuntime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDBConnectionRuntime_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDBConnectionRuntime_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDBConnectionRuntime_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDBConnectionRuntime_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDBConnectionRuntime_get_Parent(This,pParent)	\
    (This)->lpVtbl -> get_Parent(This,pParent)

#define IDBConnectionRuntime_get_UserName(This,pName)	\
    (This)->lpVtbl -> get_UserName(This,pName)

#define IDBConnectionRuntime_put_UserName(This,Name)	\
    (This)->lpVtbl -> put_UserName(This,Name)

#define IDBConnectionRuntime_get_Password(This,pName)	\
    (This)->lpVtbl -> get_Password(This,pName)

#define IDBConnectionRuntime_put_Password(This,Name)	\
    (This)->lpVtbl -> put_Password(This,Name)

#define IDBConnectionRuntime_get_CursorLocation(This,pLocation)	\
    (This)->lpVtbl -> get_CursorLocation(This,pLocation)

#define IDBConnectionRuntime_put_CursorLocation(This,Location)	\
    (This)->lpVtbl -> put_CursorLocation(This,Location)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_get_Parent_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [retval][out] */ LPDISPATCH __RPC_FAR *pParent);


void __RPC_STUB IDBConnectionRuntime_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_get_UserName_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IDBConnectionRuntime_get_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_put_UserName_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IDBConnectionRuntime_put_UserName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_get_Password_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB IDBConnectionRuntime_get_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_put_Password_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IDBConnectionRuntime_put_Password_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_get_CursorLocation_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pLocation);


void __RPC_STUB IDBConnectionRuntime_get_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IDBConnectionRuntime_put_CursorLocation_Proxy( 
    IDBConnectionRuntime __RPC_FAR * This,
    /* [in] */ long Location);


void __RPC_STUB IDBConnectionRuntime_put_CursorLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDBConnectionRuntime_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_DBConnectionRuntime;

class DECLSPEC_UUID("FF35DE52-0772-11d0-8BEC-00A0C90F55D6")
DBConnectionRuntime;
#endif

#ifndef __IWebProject_INTERFACE_DEFINED__
#define __IWebProject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWebProject
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IWebProject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("1AEE2F43-A42B-11cf-97EA-00AA00C006B6")
    IWebProject : public IGenericProject
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WorkingDirectory( 
            /* [retval][out] */ BSTR __RPC_FAR *pWorkingDirectory) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
            /* [retval][out] */ BSTR __RPC_FAR *pServerName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VirtualRoot( 
            /* [retval][out] */ BSTR __RPC_FAR *pVirtualRoot) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FPWebProject( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFpWebProject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DBConnections( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDBConnections) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddFolder( 
            /* [in] */ BSTR FolderURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddFile( 
            /* [in] */ BSTR FileURL,
            /* [in] */ BSTR LocalFilename,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFiles( 
            /* [in] */ BSTR ProjectRelativeURL,
            /* [in] */ long Flags,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseFiles( 
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateFiles( 
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFileStatus( 
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SyncProject( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MoveFiles( 
            /* [in] */ BSTR FromProjectRelativeURL,
            /* [in] */ BSTR ToProjectRelativeURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RenameFiles( 
            /* [in] */ BSTR FromProjectRelativeURL,
            /* [in] */ BSTR ToProjectRelativeURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteFiles( 
            /* [in] */ BSTR ProjectRelativeURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseProject( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeleteProject( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebProjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebProject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebProject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebProject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FullName )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Application);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *Parent);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pType);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved1 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved2 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved3 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved4 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved5 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved6 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved7 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved8 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved9 )( 
            IWebProject __RPC_FAR * This);
        
        /* [restricted][hidden][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reserved10 )( 
            IWebProject __RPC_FAR * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WorkingDirectory )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pWorkingDirectory);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerName )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pServerName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VirtualRoot )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVirtualRoot);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FPWebProject )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFpWebProject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DBConnections )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDBConnections);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFolder )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR FolderURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFile )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR FileURL,
            /* [in] */ BSTR LocalFilename,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL,
            /* [in] */ long Flags,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileStatus )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SyncProject )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR FromProjectRelativeURL,
            /* [in] */ BSTR ToProjectRelativeURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenameFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR FromProjectRelativeURL,
            /* [in] */ BSTR ToProjectRelativeURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteFiles )( 
            IWebProject __RPC_FAR * This,
            /* [in] */ BSTR ProjectRelativeURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseProject )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteProject )( 
            IWebProject __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);
        
        END_INTERFACE
    } IWebProjectVtbl;

    interface IWebProject
    {
        CONST_VTBL struct IWebProjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebProject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebProject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebProject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebProject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebProject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebProject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebProject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebProject_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IWebProject_get_FullName(This,Name)	\
    (This)->lpVtbl -> get_FullName(This,Name)

#define IWebProject_get_Application(This,Application)	\
    (This)->lpVtbl -> get_Application(This,Application)

#define IWebProject_get_Parent(This,Parent)	\
    (This)->lpVtbl -> get_Parent(This,Parent)

#define IWebProject_get_Type(This,pType)	\
    (This)->lpVtbl -> get_Type(This,pType)

#define IWebProject_Reserved1(This)	\
    (This)->lpVtbl -> Reserved1(This)

#define IWebProject_Reserved2(This)	\
    (This)->lpVtbl -> Reserved2(This)

#define IWebProject_Reserved3(This)	\
    (This)->lpVtbl -> Reserved3(This)

#define IWebProject_Reserved4(This)	\
    (This)->lpVtbl -> Reserved4(This)

#define IWebProject_Reserved5(This)	\
    (This)->lpVtbl -> Reserved5(This)

#define IWebProject_Reserved6(This)	\
    (This)->lpVtbl -> Reserved6(This)

#define IWebProject_Reserved7(This)	\
    (This)->lpVtbl -> Reserved7(This)

#define IWebProject_Reserved8(This)	\
    (This)->lpVtbl -> Reserved8(This)

#define IWebProject_Reserved9(This)	\
    (This)->lpVtbl -> Reserved9(This)

#define IWebProject_Reserved10(This)	\
    (This)->lpVtbl -> Reserved10(This)


#define IWebProject_get_WorkingDirectory(This,pWorkingDirectory)	\
    (This)->lpVtbl -> get_WorkingDirectory(This,pWorkingDirectory)

#define IWebProject_get_ServerName(This,pServerName)	\
    (This)->lpVtbl -> get_ServerName(This,pServerName)

#define IWebProject_get_VirtualRoot(This,pVirtualRoot)	\
    (This)->lpVtbl -> get_VirtualRoot(This,pVirtualRoot)

#define IWebProject_get_FPWebProject(This,ppFpWebProject)	\
    (This)->lpVtbl -> get_FPWebProject(This,ppFpWebProject)

#define IWebProject_get_DBConnections(This,ppDBConnections)	\
    (This)->lpVtbl -> get_DBConnections(This,ppDBConnections)

#define IWebProject_AddFolder(This,FolderURL,pSuccess)	\
    (This)->lpVtbl -> AddFolder(This,FolderURL,pSuccess)

#define IWebProject_AddFile(This,FileURL,LocalFilename,pSuccess)	\
    (This)->lpVtbl -> AddFile(This,FileURL,LocalFilename,pSuccess)

#define IWebProject_GetFiles(This,ProjectRelativeURL,Flags,pSuccess)	\
    (This)->lpVtbl -> GetFiles(This,ProjectRelativeURL,Flags,pSuccess)

#define IWebProject_ReleaseFiles(This,ProjectRelativeURL,pSuccess)	\
    (This)->lpVtbl -> ReleaseFiles(This,ProjectRelativeURL,pSuccess)

#define IWebProject_UpdateFiles(This,ProjectRelativeURL,pSuccess)	\
    (This)->lpVtbl -> UpdateFiles(This,ProjectRelativeURL,pSuccess)

#define IWebProject_GetFileStatus(This,ProjectRelativeURL,pSuccess)	\
    (This)->lpVtbl -> GetFileStatus(This,ProjectRelativeURL,pSuccess)

#define IWebProject_SyncProject(This,pSuccess)	\
    (This)->lpVtbl -> SyncProject(This,pSuccess)

#define IWebProject_MoveFiles(This,FromProjectRelativeURL,ToProjectRelativeURL)	\
    (This)->lpVtbl -> MoveFiles(This,FromProjectRelativeURL,ToProjectRelativeURL)

#define IWebProject_RenameFiles(This,FromProjectRelativeURL,ToProjectRelativeURL)	\
    (This)->lpVtbl -> RenameFiles(This,FromProjectRelativeURL,ToProjectRelativeURL)

#define IWebProject_DeleteFiles(This,ProjectRelativeURL)	\
    (This)->lpVtbl -> DeleteFiles(This,ProjectRelativeURL)

#define IWebProject_CloseProject(This,pSuccess)	\
    (This)->lpVtbl -> CloseProject(This,pSuccess)

#define IWebProject_DeleteProject(This,pSuccess)	\
    (This)->lpVtbl -> DeleteProject(This,pSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_WorkingDirectory_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pWorkingDirectory);


void __RPC_STUB IWebProject_get_WorkingDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_ServerName_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pServerName);


void __RPC_STUB IWebProject_get_ServerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_VirtualRoot_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVirtualRoot);


void __RPC_STUB IWebProject_get_VirtualRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_FPWebProject_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFpWebProject);


void __RPC_STUB IWebProject_get_FPWebProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebProject_get_DBConnections_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDBConnections);


void __RPC_STUB IWebProject_get_DBConnections_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_AddFolder_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR FolderURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_AddFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_AddFile_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR FileURL,
    /* [in] */ BSTR LocalFilename,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_AddFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_GetFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL,
    /* [in] */ long Flags,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_GetFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_ReleaseFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_ReleaseFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_UpdateFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_UpdateFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_GetFileStatus_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_GetFileStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_SyncProject_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_SyncProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_MoveFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR FromProjectRelativeURL,
    /* [in] */ BSTR ToProjectRelativeURL);


void __RPC_STUB IWebProject_MoveFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_RenameFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR FromProjectRelativeURL,
    /* [in] */ BSTR ToProjectRelativeURL);


void __RPC_STUB IWebProject_RenameFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_DeleteFiles_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [in] */ BSTR ProjectRelativeURL);


void __RPC_STUB IWebProject_DeleteFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_CloseProject_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_CloseProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebProject_DeleteProject_Proxy( 
    IWebProject __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSuccess);


void __RPC_STUB IWebProject_DeleteProject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebProject_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WebProject;

class DECLSPEC_UUID("E50D4940-A9BD-11cf-97EA-00AA00C006B6")
WebProject;
#endif

#ifndef __IWebService_INTERFACE_DEFINED__
#define __IWebService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWebService
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



EXTERN_C const IID IID_IWebService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("50BC5FE5-AEA2-11cf-B4D3-00AA00B8DDEA")
    IWebService : public IDispatch
    {
    public:
        virtual /* [hidden][helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch) = 0;
        
        virtual /* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;
        
        virtual /* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentSelection( 
            /* [retval][out] */ BSTR __RPC_FAR *pCurrentURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFPWebServer( 
            /* [in] */ BSTR Server,
            /* [in] */ BSTR User,
            /* [in] */ BSTR Password,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFPWebServer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWebProjectFromLocalFile( 
            /* [in] */ BSTR Filename,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWebProjectFromUrl( 
            /* [in] */ BSTR ProjectURL,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoesProjectFileExist( 
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR LocalDirectory,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateProjectFile( 
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR LocalDirectory,
            /* [in] */ BSTR ServerName,
            /* [in] */ BSTR WebName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBaseUrlFromLocalFile( 
            /* [in] */ BSTR LocalFileName,
            /* [retval][out] */ BSTR __RPC_FAR *pBaseURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFile( 
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenFile( 
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PreviewFile( 
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebService __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebService __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebService __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebService __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebService __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [hidden][helpstring][restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )( 
            IWebService __RPC_FAR * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        /* [hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);
        
        /* [hidden][helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Parent )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentSelection )( 
            IWebService __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pCurrentURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFPWebServer )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR Server,
            /* [in] */ BSTR User,
            /* [in] */ BSTR Password,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFPWebServer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWebProjectFromLocalFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR Filename,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWebProjectFromUrl )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR ProjectURL,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoesProjectFileExist )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR LocalDirectory,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateProjectFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR ProjectName,
            /* [in] */ BSTR LocalDirectory,
            /* [in] */ BSTR ServerName,
            /* [in] */ BSTR WebName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaseUrlFromLocalFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR LocalFileName,
            /* [retval][out] */ BSTR __RPC_FAR *pBaseURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PreviewFile )( 
            IWebService __RPC_FAR * This,
            /* [in] */ BSTR BaseURL,
            /* [in] */ BSTR FileURL,
            /* [in] */ long Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);
        
        END_INTERFACE
    } IWebServiceVtbl;

    interface IWebService
    {
        CONST_VTBL struct IWebServiceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebService_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebService_get__NewEnum(This,_ppNewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,_ppNewEnum)

#define IWebService_Item(This,index,ppDispatch)	\
    (This)->lpVtbl -> Item(This,index,ppDispatch)

#define IWebService_get_Count(This,pCount)	\
    (This)->lpVtbl -> get_Count(This,pCount)

#define IWebService_get_Parent(This,ppParent)	\
    (This)->lpVtbl -> get_Parent(This,ppParent)

#define IWebService_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#define IWebService_get_CurrentSelection(This,pCurrentURL)	\
    (This)->lpVtbl -> get_CurrentSelection(This,pCurrentURL)

#define IWebService_GetFPWebServer(This,Server,User,Password,ppFPWebServer)	\
    (This)->lpVtbl -> GetFPWebServer(This,Server,User,Password,ppFPWebServer)

#define IWebService_GetWebProjectFromLocalFile(This,Filename,ppWebProject)	\
    (This)->lpVtbl -> GetWebProjectFromLocalFile(This,Filename,ppWebProject)

#define IWebService_GetWebProjectFromUrl(This,ProjectURL,ppWebProject)	\
    (This)->lpVtbl -> GetWebProjectFromUrl(This,ProjectURL,ppWebProject)

#define IWebService_DoesProjectFileExist(This,ProjectName,LocalDirectory,vtBoolean)	\
    (This)->lpVtbl -> DoesProjectFileExist(This,ProjectName,LocalDirectory,vtBoolean)

#define IWebService_CreateProjectFile(This,ProjectName,LocalDirectory,ServerName,WebName,vtBoolean)	\
    (This)->lpVtbl -> CreateProjectFile(This,ProjectName,LocalDirectory,ServerName,WebName,vtBoolean)

#define IWebService_GetBaseUrlFromLocalFile(This,LocalFileName,pBaseURL)	\
    (This)->lpVtbl -> GetBaseUrlFromLocalFile(This,LocalFileName,pBaseURL)

#define IWebService_GetFile(This,BaseURL,FileURL,Flags,pLocalFileName)	\
    (This)->lpVtbl -> GetFile(This,BaseURL,FileURL,Flags,pLocalFileName)

#define IWebService_OpenFile(This,BaseURL,FileURL,Flags,pLocalFileName)	\
    (This)->lpVtbl -> OpenFile(This,BaseURL,FileURL,Flags,pLocalFileName)

#define IWebService_PreviewFile(This,BaseURL,FileURL,Flags,pLocalFileName)	\
    (This)->lpVtbl -> PreviewFile(This,BaseURL,FileURL,Flags,pLocalFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [hidden][helpstring][restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get__NewEnum_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *_ppNewEnum);


void __RPC_STUB IWebService_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_Item_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ VARIANT index,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);


void __RPC_STUB IWebService_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get_Count_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB IWebService_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get_Parent_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IWebService_get_Parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get_Application_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IWebService_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebService_get_CurrentSelection_Proxy( 
    IWebService __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pCurrentURL);


void __RPC_STUB IWebService_get_CurrentSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetFPWebServer_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR Server,
    /* [in] */ BSTR User,
    /* [in] */ BSTR Password,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppFPWebServer);


void __RPC_STUB IWebService_GetFPWebServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetWebProjectFromLocalFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR Filename,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject);


void __RPC_STUB IWebService_GetWebProjectFromLocalFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetWebProjectFromUrl_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR ProjectURL,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppWebProject);


void __RPC_STUB IWebService_GetWebProjectFromUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_DoesProjectFileExist_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR ProjectName,
    /* [in] */ BSTR LocalDirectory,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean);


void __RPC_STUB IWebService_DoesProjectFileExist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_CreateProjectFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR ProjectName,
    /* [in] */ BSTR LocalDirectory,
    /* [in] */ BSTR ServerName,
    /* [in] */ BSTR WebName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vtBoolean);


void __RPC_STUB IWebService_CreateProjectFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetBaseUrlFromLocalFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR LocalFileName,
    /* [retval][out] */ BSTR __RPC_FAR *pBaseURL);


void __RPC_STUB IWebService_GetBaseUrlFromLocalFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_GetFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR BaseURL,
    /* [in] */ BSTR FileURL,
    /* [in] */ long Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);


void __RPC_STUB IWebService_GetFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_OpenFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR BaseURL,
    /* [in] */ BSTR FileURL,
    /* [in] */ long Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);


void __RPC_STUB IWebService_OpenFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebService_PreviewFile_Proxy( 
    IWebService __RPC_FAR * This,
    /* [in] */ BSTR BaseURL,
    /* [in] */ BSTR FileURL,
    /* [in] */ long Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pLocalFileName);


void __RPC_STUB IWebService_PreviewFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebService_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WebService;

class DECLSPEC_UUID("50BC5FE7-AEA2-11cf-B4D3-00AA00B8DDEA")
WebService;
#endif
#endif /* __DSWebProjects_LIBRARY_DEFINED__ */

#ifndef __IWebProjectFiles_INTERFACE_DEFINED__
#define __IWebProjectFiles_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWebProjectFiles
 * at Wed Dec 11 12:17:47 1996
 * using MIDL 3.01.59
 ****************************************/
/* [object][uuid] */ 



EXTERN_C const IID IID_IWebProjectFiles;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("D11F0D22-1333-11d0-8155-00A0C91E29D5")
    IWebProjectFiles : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumFolders( 
            /* [in] */ LPCOLESTR pszFolder,
            /* [retval][out] */ CALPOLESTR __RPC_FAR *calFolders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumFiles( 
            /* [in] */ LPCOLESTR pszFolder,
            /* [retval][out] */ CALPOLESTR __RPC_FAR *calFiles) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebProjectFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebProjectFiles __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebProjectFiles __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebProjectFiles __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumFolders )( 
            IWebProjectFiles __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFolder,
            /* [retval][out] */ CALPOLESTR __RPC_FAR *calFolders);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumFiles )( 
            IWebProjectFiles __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszFolder,
            /* [retval][out] */ CALPOLESTR __RPC_FAR *calFiles);
        
        END_INTERFACE
    } IWebProjectFilesVtbl;

    interface IWebProjectFiles
    {
        CONST_VTBL struct IWebProjectFilesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebProjectFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebProjectFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebProjectFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebProjectFiles_EnumFolders(This,pszFolder,calFolders)	\
    (This)->lpVtbl -> EnumFolders(This,pszFolder,calFolders)

#define IWebProjectFiles_EnumFiles(This,pszFolder,calFiles)	\
    (This)->lpVtbl -> EnumFiles(This,pszFolder,calFiles)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWebProjectFiles_EnumFolders_Proxy( 
    IWebProjectFiles __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFolder,
    /* [retval][out] */ CALPOLESTR __RPC_FAR *calFolders);


void __RPC_STUB IWebProjectFiles_EnumFolders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWebProjectFiles_EnumFiles_Proxy( 
    IWebProjectFiles __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszFolder,
    /* [retval][out] */ CALPOLESTR __RPC_FAR *calFiles);


void __RPC_STUB IWebProjectFiles_EnumFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebProjectFiles_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\msodcid.h ===
/*-----------------------------------------------------------------------------
Microsoft Sterling

Microsoft Confidential
Copyright 1994-1996 Microsoft Corporation.  All Rights Reserved.

File:		msodcid.h
Contents:	This file describes the data context interfaces
-----------------------------------------------------------------------------*/

// {A43D9461-EA36-11ce-AE99-00AA00A28331}
DEFINE_GUID(SID_NAMESPACE,
0xa43d9461, 0xea36, 0x11ce, 0xae, 0x99, 0x0, 0xaa, 0x0, 0xa2, 0x83, 0x31);

// {A43D9462-EA36-11ce-AE99-00AA00A28331}
DEFINE_GUID(IID_INamespaceSource,
0xa43d9462, 0xea36, 0x11ce, 0xae, 0x99, 0x0, 0xaa, 0x0, 0xa2, 0x83, 0x31);

// {A43D9463-EA36-11ce-AE99-00AA00A28331}
DEFINE_GUID(IID_IPersistDataStore,
0xa43d9463, 0xea36, 0x11ce, 0xae, 0x99, 0x0, 0xaa, 0x0, 0xa2, 0x83, 0x31);




// **** IID_IDBConnectObject ****
//
// {B7A1D4A0-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IDBConnectObject, 
0xb7a1d4a0, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

// **** IID_IODBCConnectObject ****
//
// {B7A1D4A1-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IODBCConnectObject, 
0xb7a1d4a1, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

// **** IID_IJetConnectObject ****
//
// {B7A1D4A2-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IJetConnectObject, 
0xb7a1d4a2, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);



// **** IID_IDBConnectionManager ****
//
// {B7A1D4A3-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IDBConnectionManager, 
0xb7a1d4a3, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#define SID_IDBConnectionManager  IID_IDBConnectionManager

// **** IID_IAsyncQueryBuilder ****
//
// {B7A1D4A4-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IAsyncQueryBuilder, 
0xb7a1d4a4, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);


// **** IID_IDBDisp ****
// {B7A1D4A5-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IDBTextDisp, 
0xb7a1d4a5, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#define SID_IDBTextDisp IID_IDBTextDisp

// **** IID_IDataSrcClient ****
//
// {B7A1D4A6-7210-11cf-BE16-00AA0062C2EF}
DEFINE_GUID(IID_IDataSrcClient, 
0xb7a1d4a6, 0x7210, 0x11cf, 0xbe, 0x16, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);

#define SID_SDataSrcClient IID_IDataSrcClient

// {BE377880-0B1D-11d0-8923-00AA00BF0506}
DEFINE_GUID(IID_IDataSrcDebug, 
0xbe377880, 0xb1d, 0x11d0, 0x89, 0x23, 0x0, 0xaa, 0x0, 0xbf, 0x5, 0x6);

#define SID_SDataSrcDebug IID_IDataSrcDebug

// **** IID_IDataSrcDebugConsumer ****
//
// {b0c47fd0-1220-11d0-9d16-00c04fd9dfd9}

DEFINE_GUID(IID_IDataSrcDebugConsumer,
    0xb0c47fd0, 0x1220, 0x11d0, 0x9d, 0x16, 0x00, 0xc0, 0x4f, 0xd9, 0xdf, 0xd9) ;

#define SID_SDataSrcDebugConsumer IID_IDataSrcDebugConsumer

// {8B072243-8C1A-11cf-BE23-00AA0062C2EF}
DEFINE_GUID(IID_DataPkgProject, 0x8b072243, 0x8c1a, 0x11cf, 0xbe, 0x23, 0x0, 0xaa, 0x0, 0x62, 0xc2, 0xef);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\memref.h ===
#ifndef __MEMREF_H__
#define __MEMREF_H__

#if defined(_DEBUG)
#define	MRDebug(x)	x
#else
#define	MRDebug(x)
#endif

/////////////////////////////////////////////////////////////////////////////
// CRefObj--handles ref counted garbage collection and dyncasting

class CRefObj
{
private:
	unsigned _cUses;

public:
	CRefObj() { _cUses = 0; }

	// copy ctor, does not copy usage count of object being copied from
	CRefObj(const CRefObj &) { _cUses = 0; }

	// virtual dtor should cause all descendents of CRefObj to have a virtual dtor
	virtual ~CRefObj() { }

	CRefObj &operator= (const CRefObj &) { return *this; }

	unsigned CUses() { return _cUses; }

	void Use() { _cUses++; }

	BOOL FUnUse() { return !(--_cUses); }
};

/////////////////////////////////////////////////////////////////////////////
// CRefMem

class CRefMem : public CRefObj
{
private:
	VOID * _pv;
	size_t _cbAlloc;
	size_t _cbUsed;
	HANDLE _hHeap;

	inline void Uninit();

public:
	CRefMem(HANDLE hHeap = 0)
	{
		_pv = 0;
		_cbAlloc = 0;
		_cbUsed = 0;
		_hHeap = hHeap;
	}

	~CRefMem() { Uninit(); }

	inline BOOL FInit(size_t cb);
	inline BOOL FRealloc(size_t cb);	// If the allocation succeeds, the old
										// data will be copied to the new address;
										// otherwise, the original allocation is
										// left intact.

	operator BYTE *() { return ((BYTE *) _pv); }
	operator VOID *() { return _pv; }
	operator TCHAR *() { return (TCHAR *) _pv; }

	operator const BYTE *() const { return (const BYTE *) _pv; }
	operator const VOID *() const { return (const VOID *) _pv; }
	operator const TCHAR *() const { return (const TCHAR *) _pv; }

	size_t CbAlloc() { return _cbAlloc; }

	size_t CbUsed() { return _cbUsed; }

	void SetCbUsed(size_t cb) 
	{
		if (cb < _cbAlloc)
			_cbUsed = cb;
		else
			_cbUsed = _cbAlloc;
	}
};

/////////////////////////////////////////////////////////////////////////////

#define refNil	0

template <class TARG> class Ref
{
private:
	TARG *_ptarg;

	// unuse pointer and free if last user
	VOID Release()
	{
		if (_ptarg != NULL && _ptarg->FUnUse())
			delete _ptarg;
		// put garbage in pointer
		MRDebug(_ptarg = (TARG *)0xdadadada);
	}

public:
	// constructors
	Ref<TARG>() { _ptarg = NULL; }

	Ref<TARG>(TARG *ptargNew)
	{
		_ptarg = ptargNew;
		if (ptargNew != NULL)
			ptargNew->Use();
	}

	Ref<TARG>(const Ref<TARG> &rtarg)
	{
		_ptarg = rtarg._ptarg;
		if (rtarg._ptarg != NULL)
			rtarg._ptarg->Use();
	}

	// destructor
	~Ref<TARG>() { Release(); }

	// assignment functions (mirror the ctors)
	Ref<TARG>& operator=(TARG *ptargNew)
	{
		if (ptargNew != NULL)
			ptargNew->Use();
		Release();
		_ptarg = ptargNew;
		return *this;
	}

	Ref<TARG>& operator=(const Ref<TARG> &rtarg)
	{
		if (rtarg._ptarg != NULL)
			rtarg._ptarg->Use();
		Release();
		_ptarg = rtarg._ptarg;
		return *this;
	}

	BOOL  operator==(TARG *ptarg) const { return _ptarg == ptarg; }
	BOOL  operator!=(TARG *ptarg) const { return _ptarg != ptarg; }
	TARG &operator*()			  const { return *_ptarg; }
	TARG *operator->()			  const { return _ptarg; }
		  operator TARG *()		  const { return _ptarg; }
};

/////////////////////////////////////////////////////////////////////////////

typedef Ref<CRefMem> RMEM;

inline BOOL MEM_FCreate(RMEM &refMem, size_t cb, HANDLE hHeap = 0)
{
	BOOL f = FALSE;
	CRefMem *pMem = new CRefMem(hHeap);

	if (pMem)
	{
		if (!(f = pMem->FInit(cb)))
		{
			delete pMem;
			pMem = 0;
		}
	}
	refMem = pMem;
	return f;
}

inline BOOL CRefMem::FInit(size_t cb)
{
	BOOL f = FALSE;
	if (_pv && _cbAlloc)
		Uninit();
	if (_hHeap)
		f = (_pv = HeapAlloc(_hHeap, HEAP_ZERO_MEMORY, cb)) != NULL;
	else
		f = (_pv = calloc( 1, cb)) != NULL;
	MRDebug((f ? memset(_pv, 0xcc, cb) : 0));
	if (f)
		_cbAlloc = _cbUsed = cb;
	return f;
}

inline void CRefMem::Uninit()
{
	if (_pv)
	{
		MRDebug(memset(_pv, 0xda, _cbAlloc));
		if (_hHeap)
			HeapFree(_hHeap, 0, _pv);
		else
			free(_pv);
		_pv = 0;
		_cbAlloc = _cbUsed = 0;
	}
}

inline BOOL CRefMem::FRealloc(size_t cb)
{
	BOOL f = FALSE;

	if (_pv)
	{
		VOID *pvT;
		if (_hHeap)
			pvT = HeapAlloc(_hHeap, HEAP_ZERO_MEMORY, cb);
		else
			pvT = calloc(1, cb);
		if (pvT)
		{
			memcpy(pvT, _pv, min(cb, _cbAlloc));
			MRDebug(memset(_pv, 0xda, _cbAlloc));
			if (_hHeap)
				HeapFree(_hHeap, 0, _pv);
			else
				free(_pv);
			MRDebug((cb > _cbAlloc ? memset((BYTE *)pvT + _cbAlloc, 0xcc, cb - _cbAlloc) : 0));
			_cbAlloc = cb;
			if (_cbUsed > cb)
				_cbUsed = cb;
			_pv = pvT;
			f = TRUE;
		}		
	}
	else
		f = FInit(cb);

	return f;
}

#endif	// __MEMREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\parse.h ===
#ifndef __PARSER__
#define __PARSER__

#include "lex.h"
#include "ncparse.h"

#define PARSE_NOERROR				0
#define E_PARSE_MISMATCH_PARENT		1
#define E_PARSE_NO_TEMPLATE_DEFN	2
#define E_PARSE_NO_DEFN				3
#define E_PARSE_MULTI_LINE			4
#define E_PARSE_INVALID_TOKEN		5
#define E_PARSE_NO_LEXER			6
#define E_PARSE_EMPTY_STREAM		7
#define E_PARSE_MISMATCH_BRACKET	8
#define E_PARSE_UNEXPECTED_EOL		9
#define E_PARSE_EXTRA_TOKEN			10
#define E_PARSE_CTOR_RET_TYPE       11
#define E_PARSE_DUP_ACCESS_SPEC     12
#define E_PARSE_INVALID_MODIFIER    13
#define E_PARSE_MACROERROR			14
#define E_PARSE_PARAM_COUNT_MISMATCH 15

#define PARSE_TYP_FUNC			0x00000001
#define PARSE_TYP_VAR			0x00000002
#define PARSE_TYP_PURE			0x00000004
#define PARSE_TYP_STATIC		0x00000008
#define PARSE_TYP_VIRTUAL		0x00000010
#define PARSE_TYP_EXTERN		0x00000020
#define PARSE_TYP_INLINE		0x00000040
#define PARSE_TYP_CONSTFUNC		0x00000080

//////////////////////////////////////////////////////////////
enum parsetype 
{
	functionType = 0x0001,
	classType = 0x0002,
	varType = 0x0004,
	templateType = 0x0008,
	typedefType = 0x0010,
	unionType = 0x0020,
	enumType = 0x0040,
	structType = 0x0080,
	fileType = 0x0100,
	msgmapType = 0x0200,
	mapitemType = 0x0400,
	unknownType = 0x0800,
};

enum decldefn
{
	decl,
	defn
};

enum Action
{
	initFile,	
	addFile,		
	updateFile,
	delFile,
	initDone,
	reparseTarget,
	updateFileFromBuffer,
};

class CParser
{
public:	 
	CParser() {};
	~CParser() {};
	// initialize parser w/ specific filename
	// or should it be a pointer to a Doc ?
	virtual BOOL Init (LPCSTR szFilename, void * pTextDocs) PURE;
	// parsing the file we just opened
	virtual BOOL Parse (LPCSTR szFilename, void * pTextDoc, Action action, HTARGET hTarget, CLex * lexer, NcbParse * pDBase, BOOL bParseIncludeFiles, BOOL bPrjSource, BOOL & bSuspendThread) PURE;
	virtual BOOL ParseFunction (CLex * pLex, LPCSTR ptchLine, UINT cbLine, PLXS plxs, CStringList & slFunc) PURE;
	virtual BOOL ParseFunction (CLex * pLex, LPCSTR ptchLine, UINT cbLine, PLXS plxs, CStringList & slFunc, BOOL & bFunction) PURE;
	virtual UINT ParseFunction (CLex * pLex, LPCSTR ptchLine, UINT cbLine, PLXS plxs, CStringList & slFunc, DWORD & dwFlags, UINT & iPos) PURE;
	// closing the file
	virtual void Close() PURE;
	// loading the macros
	// virtual LoadMacros (LPCSTR pszFile) PURE;
	virtual CParser * Duplicate() PURE;
	virtual void Release() PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\pkgapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	PKGAPI.H
//		Sample package interface declarations.

#ifndef __PKGAPI_H__
#define __PKGAPI_H__

interface IExample;

typedef IExample* LPEXAMPLE;

/////////////////////////////////////////////////////////////////////////////
// IExample

#undef  INTERFACE
#define INTERFACE IExample
DECLARE_INTERFACE_(IExample, IUnknown)
{
	// IUnknown methods

	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IExample methods

	STDMETHOD(IsAvailable)(VOID) PURE;
	STDMETHOD(SetAvailable)(BOOL bAvailable) PURE;
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __PKGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\ogapi.h ===
#ifndef __OGAPI_H__
#define __OGAPI_H__

// Component Gallery interface declarations

// These are all interfaces on an apply context object
interface IApplyContext;
interface IManageValues;
interface IAddFiles;
interface IAddResources;
interface IFindClasses;
interface IWriteCode;

// This interface is used to create a new class.
interface ICreateClasses;

interface IFormStrings;	// handles lists of strings returned from various queries from ICreateClasses


// This is an interface provided by a client of the apply context, in order to
// provide information to the user while editing the value map.
interface IExplainValues;

// These interfaces are used as results from the parser
interface IEnumClasses;
interface IExplainClasses;

interface IEnumMembers;
interface IExplainMembers;

// This interface is used to interact with templates.
interface IExpandTemplates;

// These interfaces are supplied by external Components.
interface IComponentType;
interface IImportComponents;
interface IComponent;
interface IExplainComponents;

// This interface is used by external components to
// interact with the Gallery.
interface IComponentGallery;


// Interface pointer types.
typedef IApplyContext* LPAPPLYCONTEXT;
typedef IManageValues* LPMANAGEVALUES;
typedef IAddFiles* LPADDFILES;
typedef IAddResources* LPADDRESOURCES;
typedef IFindClasses* LPFINDCLASSES;
typedef IWriteCode* LPWRITECODE;
typedef ICreateClasses* LPCREATECLASSES;
typedef IExplainValues* LPEXPLAINVALUES;
typedef IEnumClasses* LPENUMCLASSES;
typedef IExplainClasses* LPEXPLAINCLASSES;
typedef IEnumMembers* LPENUMMEMBERS;
typedef IExplainMembers* LPEXPLAINMEMBERS;
typedef IExpandTemplates* LPEXPANDTEMPLATES;
typedef IComponentType* LPCOMPONENTTYPE;
typedef IImportComponents* LPIMPORTCOMPONENTS;
typedef IComponent* LPCOMPONENT;
typedef IExplainComponents* LPEXPLAINCOMPONENTS;
typedef IComponentGallery* LPCOMPONENTGALLERY;
typedef IFormStrings* LPFORMSTRINGS;


/////////////////////////////////////////////////////////////////////////////
// IApplyContext
//   This is the primary interface on an Apply Context object.

#undef  INTERFACE
#define INTERFACE IApplyContext
DECLARE_INTERFACE_(IApplyContext, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IApplyContext methods
	STDMETHOD(FinishApply)(THIS_ BOOL bRemember) PURE;
	STDMETHOD(AbortApply)(THIS) PURE;

	STDMETHOD(DoModal)(THIS_ IExplainValues FAR* pev) PURE;

	STDMETHOD(GetIComponentGallery)(THIS_ IComponentGallery ** pCG) PURE;

};


/////////////////////////////////////////////////////////////////////////////
// IManageValues
//   This interface allows interaction with the value table.

#undef  INTERFACE
#define INTERFACE IManageValues
DECLARE_INTERFACE_(IManageValues, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Value interaction
	STDMETHOD(AddValue)(THIS_ LPCSTR pszKey, LPCSTR pszValue) PURE;
	STDMETHOD(GetValue)(THIS_ LPCSTR pszKey, LPSTR FAR* ppszValue) PURE;
	STDMETHOD(SetValue)(THIS_ LPCSTR pszKey, LPCSTR pszValue) PURE;
	STDMETHOD(RemoveValue)(THIS_ LPCSTR pszKey) PURE;
	STDMETHOD(ClearValues)(THIS) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IAddFiles
//   This interface on an Apply Context object is used to interact with the
//   project.  i.e. add/enumerate files, etc.

#define DW_FILE_EXIST	0x00000001
#define DW_FILE_IN_PROJECT 0x00000002
#define DW_FILE_INSERT_IFACE 0x00010000
#define DW_FILE_INSERT_COCLASS 0x00020000

#undef  INTERFACE
#define INTERFACE IAddFiles
DECLARE_INTERFACE_(IAddFiles, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Filename methods.
	STDMETHOD(CalculateFilename)(THIS_ LPCSTR pszFilename, LPSTR FAR* ppszNewFilename) PURE;
	STDMETHOD(SaveFilename)(THIS_ LPCSTR pszDesiredFilename, LPCSTR pszActualFilename) PURE;
	STDMETHOD(AddFile)(THIS_ LPCSTR pszFilename) PURE;
	STDMETHOD (CalculateFilenameEx) (THIS_ LPCSTR pszFilename, LPSTR FAR * ppszNewFilename, DWORD * pdwHint) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IAddResources
//   This interface on an Apply Context object is used to interact with
//   the projects resource script.

#undef  INTERFACE
#define INTERFACE IAddResources
DECLARE_INTERFACE_(IAddResources, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Resource methods.
	STDMETHOD(Create)(THIS_ UINT nCreateFlags) PURE;
	STDMETHOD(GetResourceInclude)(THIS_ LPSTR FAR* ppszFilename) PURE;

	STDMETHOD(AttachResourceStream)(THIS_ LPSTREAM lpStream) PURE;
	STDMETHOD(CreateSymbol)(THIS_ LPCSTR pszID, LPSTR FAR* ppszActualID) PURE;
	STDMETHOD(CreateResource)(THIS_ LPCSTR pszType, LPCSTR pszID, int nLangID, LPCSTR szCondition, LPCSTR pszNewID) PURE;
	STDMETHOD(ImportResource)(THIS_ LPCSTR pszType, LPCSTR pszID, LPCSTR pszFileName, int nLangID, LPCSTR szCondition) PURE;
	STDMETHOD(SetResourceID)(THIS_ LPCSTR pszType, LPCSTR pszOldID, int nLangID, LPCSTR szCondition, LPCSTR pszNewID) PURE;
	STDMETHOD(CreateString)(THIS_ LPCSTR pszID, int nLangID, LPCSTR szCondition, LPCSTR pszString) PURE;
	STDMETHOD(Access)(THIS_ UINT nMode) PURE;
};
// Open flags
#define OPEN_ALWAYS_RC   (0)
#define CREATE_NEW_RC    (1)
#define OPEN_EXISTING_RC (2)

// Access mode flags
#ifndef MODE_READ
#define MODE_READ   (0)
#endif
#ifndef MODE_WRITE
#define MODE_WRITE  (1)
#endif

/////////////////////////////////////////////////////////////////////////////
// IFindClasses
//   This interface on an Apply Context object is used to query the parser
//   as to the location and existence of interesting things.

#undef  INTERFACE
#define INTERFACE IFindClasses
DECLARE_INTERFACE_(IFindClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Class interaction methods.
	STDMETHOD(GetClassInfo)(THIS_ LPCSTR pszClass, IExplainClasses FAR** ppec) PURE;
	STDMETHOD(GetDerivedClasses)(THIS_ LPCSTR pszParent, BOOL bImmediateOnly, IEnumClasses FAR** ppec) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IWriteCode
//   This interface on an Apply Context object is used to make code changes
//   to the project.  It allows the addition of new members, and some simple
//   additions to existing members.

#undef  INTERFACE
#define INTERFACE IWriteCode
DECLARE_INTERFACE_(IWriteCode, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Code modification methods
	STDMETHOD(InsertMember)(THIS_ LPCSTR pszMember, UINT nAccess) PURE;
	STDMETHOD(CreateImplementation)(THIS_ LPCSTR pszMember, LPCSTR pszCode, UINT nPlacement, BOOL bCreate) PURE;
	STDMETHOD(InsertMapEntry)(THIS_ LPCSTR pszMap, LPCSTR pszClass, LPCSTR pszEntry) PURE;

	// Helper methods
	STDMETHOD(ValidateSymbol)(THIS_ LPCSTR pszSymbol) PURE;
	STDMETHOD(IsMFCClass)(THIS_ LPCSTR pszClass) PURE;
	STDMETHOD(CreateFilenameDefine)(THIS_ LPCSTR pszFilename, LPSTR FAR *ppszSymbol) PURE;

	// Include directive methods
	STDMETHOD(AddProjectInclude)(THIS_ LPCSTR pszIncludeFile) PURE;
	STDMETHOD(AddClassInclude)(THIS_ LPCSTR pszClass, LPCSTR pszIncludeFile, UINT nFlags) PURE;
	STDMETHOD(AddFileInclude)(THIS_ LPCSTR pszFilename, LPCSTR pszIncludeName) PURE;
	
	// Generic code addition.
	STDMETHOD(AddClassCode)(THIS_ LPCSTR pszClass, LPCSTR pszCode) PURE;
	STDMETHOD(AddFileCode)(THIS_ LPCSTR pszFile, LPCSTR pszCode) PURE;

	// Project query methods.
	STDMETHOD(GetProjectName)(THIS_ LPSTR FAR* ppszProjectName) PURE;

	// Insert file content to file
	STDMETHOD(InsertFileContent)(THIS_ LPCSTR pszFileContent, LPCSTR szLang, DWORD dwHint, LPCSTR pszFileName) PURE;

	//Get name of project include file (99% of time is stdafx.h)
	STDMETHOD(GetProjectIncludeFile)(THIS_ LPSTR FAR* ppszProjectInclude) PURE;

};
// Access flags
#define ACCESS_DONTCARE  (0)
#define ACCESS_PUBLIC    (1)
#define ACCESS_PROTECTED (2)
#define ACCESS_PRIVATE   (3)

// Placement flags
#define PLACEMENT_BEGIN         (1)
#define PLACEMENT_END           (2)
#define PLACEMENT_BEFORE_PARENT (3)
#define PLACEMENT_AFTER_PARENT  (4)

// Include flags
#define CLASS_DEFINITION	(0)
#define CLASS_IMPLEMENTATION	(1)


/////////////////////////////////////////////////////////////////////////////
// ICreateClasses
//   This interface is returned by the IOGCodeMunge interface, and is used to
//   manipulate the attributes of a new class.

#undef  INTERFACE
#define INTERFACE ICreateClasses
DECLARE_INTERFACE_(ICreateClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// INewClass methods
	STDMETHOD(SetName)(THIS_ LPCSTR pszName) PURE;
	STDMETHOD(SetBaseClass)(THIS_ LPCSTR pszName) PURE;
	STDMETHOD(SetFiles)(THIS_ LPCSTR pszHeader, LPCSTR pszImplementation) PURE;

	STDMETHOD(SetOLEOptions)(THIS_ UINT nFlags, LPCSTR pszName) PURE;

	// Only for classes that require a dialog template.
	STDMETHOD(SetDialogTemplate)(THIS_ LPCSTR pszDialogID) PURE;

	// These methods are used to allow the user to change class information.
	STDMETHOD(SetNameFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetBaseClassFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetFilesFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetOLEOptionsFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetDialogTemplateFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetDialogTitle)(THIS_ LPCSTR pszTitle) PURE;
	STDMETHOD(DoModal)(THIS) PURE;

	// This method actually creates the class.
	STDMETHOD(CreateClass)(THIS) PURE;

	// Error handling for during CreateClass.  We may need to call these
	// if we only called into ICreateClasses2 programatically.  (UI path
	// includes checking with the user in these situations and handling
	// problems that way)
	STDMETHOD(SetGuidFlags)(THIS_ UINT nFlags) PURE;
	STDMETHOD(SetResFlags)(THIS_ UINT nFlags) PURE;

	// Information retrieval.
	STDMETHOD(GetName)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetBaseClass)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetFiles)(THIS_ LPSTR FAR* ppszHeader, LPSTR FAR* ppszImplementation) PURE;
	STDMETHOD(GetOLEOptions)(THIS_ UINT FAR* pnFlags, LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetDialogTemplate)(THIS_ LPSTR FAR* ppszDialogID) PURE;

	STDMETHOD(GetFormStrings)(THIS_ UINT nTypeForm, LPFORMSTRINGS *ppFormStrings) PURE;
};

// FORM String interface types (nTypeForm values in GetFormStrings)

#define FS_DIALOG_ID (1)
#define FS_BASE_CLASS (2)


// OLE Option flags
#define NC_OLE_NONE   (0)
#define NC_OLE_AUTO   (1)
#define NC_OLE_CREATE (2)
// UI flags
#define NC_ALLOW_EDIT    (0)
#define NC_DISALLOW_EDIT (1)
// Base class filters
#define NC_BASE_ALL   (0x0000)
#define NC_BASE_DOC   (0x0100)
#define NC_BASE_VIEW  (0x0200)
#define NC_BASE_FRAME (0x0400)
#define NC_BASE_DLG   (0x0800)
#define NC_BASE_CTRL  (0x1000)

// this one causes some classes to be added to the set which "ALL" doesn't include.
// ONLY SET THIS FLAG IF YOU ARE GOING TO BE USING ClassWizard UI WITH ICreateClasses.
// The database source won't get setup properly if you don't let ClassWizard handle
// the UI.
#define NC_BASE_ADD_DB_CLASSES	(0x2000)

// Error response flags
#define NC_USE_EXISTING_GUID   (1)
#define NC_CREATE_NEW_GUID     (2)
#define NC_USE_RES_ASIS        (3)
#define NC_USE_PLACEHOLDER_RES (4)

/////////////////////////////////////////////////////////////////////////////
// IExplainValues
//   This is an interface used by a client of the apply context, in order to
//   provide information to the user while editing the value map.

#undef  INTERFACE
#define INTERFACE IExplainValues
DECLARE_INTERFACE_(IExplainValues, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Validation methods
	STDMETHOD(ValidateValue)(THIS_ LPCSTR pszKey, LPCSTR pszNewValue) PURE;

	// Information methods.  The info returned by these methods
	// is used to populate the grid control in the value editor.
	STDMETHOD(GetValueInfo)(THIS_ LPCSTR pszKey, LPSTR FAR* ppszName, LPSTR FAR* ppszType, LPSTR FAR* ppszExtraInfo) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IEnumClasses
//   This is a simple interface to a list of classes.  It is used as a result
//   from some of the parser queries.

#undef  INTERFACE
#define INTERFACE IEnumClasses
DECLARE_INTERFACE_(IEnumClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnum style methods
	STDMETHOD(Next)(THIS_ ULONG celt, IExplainClasses FAR** rgelt, ULONG* pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumClasses** ppenum) PURE;

	// Custom search method.
	STDMETHOD(Find)(THIS_ LPCSTR pszClass, IExplainClasses FAR** ppec) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IExplainClasses
//   Use this interface to get details on a particular class.

#undef  INTERFACE
#define INTERFACE IExplainClasses
DECLARE_INTERFACE_(IExplainClasses, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Class information methods.
	STDMETHOD(GetName)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetBaseClasses)(THIS_ LPSTR FAR* ppszParent) PURE;
	STDMETHOD(GetMembers)(THIS_ IEnumMembers FAR** ppem) PURE;
	STDMETHOD(Access)(THIS_ UINT nMode) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IEnumMembers
//   This is a simple interface on a list of members

#undef  INTERFACE
#define INTERFACE IEnumMembers
DECLARE_INTERFACE_(IEnumMembers, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEnum style methods
	STDMETHOD(Next)(THIS_ ULONG celt, IExplainMembers FAR** rgelt, ULONG* pceltFetched) PURE;
	STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Clone)(THIS_ IEnumMembers** ppenum) PURE;

	// Custom search method.
	STDMETHOD(Find)(THIS_ LPCSTR pszMember, IExplainMembers FAR** ppem) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IExplainMembers
//   Use this interface to get details on a member

#undef  INTERFACE
#define INTERFACE IExplainMembers
DECLARE_INTERFACE_(IExplainMembers, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Member information methods.
	STDMETHOD(GetName)(THIS_ LPSTR FAR* ppszName) PURE;
	STDMETHOD(GetType)(THIS_ LPSTR FAR* ppszType) PURE;
	STDMETHOD(GetAccess)(THIS_ UINT FAR* pnAccess) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IExpandTemplates
//   This interface is used to interact with templates.

#undef  INTERFACE
#define INTERFACE IExpandTemplates
DECLARE_INTERFACE_(IExpandTemplates, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	STDMETHOD(Render)(THIS_ LPSTREAM lpStm, IApplyContext FAR* lpAC) PURE;
	STDMETHOD (RenderIntoFile) (THIS_ LPCTSTR szFileName, LPCTSTR szLang, DWORD dwHint, IApplyContext FAR * lpAC) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IComponentType
//   This interface is exposed by external components.

#undef  INTERFACE
#define INTERFACE IComponentType
DECLARE_INTERFACE_(IComponentType, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Component type methods.
	STDMETHOD(OnRegister)(THIS_ UINT nTypeID, LPCOMPONENTGALLERY lpcg) PURE;
	STDMETHOD(OnInitialRegister)(THIS) PURE;
	STDMETHOD(BltTypeGlyph)(THIS_ HDC hDC, int x, int y) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IImportComponents
//   This interface is exposed by external components.

#undef  INTERFACE
#define INTERFACE IImportComponents
DECLARE_INTERFACE_(IImportComponents, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Import methods.
	STDMETHOD(ImportFile)(THIS_ LPCSTR pszFilename, BOOL bCopyToGallery) PURE;
	STDMETHOD(GetFilterStrings)(THIS_ LPSTR FAR* ppszFilter) PURE;
	STDMETHOD(CanImportFile)(THIS_ LPCSTR pszFile) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IComponent
//   This interface is exposed by external components.

#undef  INTERFACE
#define INTERFACE IComponent
DECLARE_INTERFACE_(IComponent, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Component methods.
	STDMETHOD(GetTypeID)(THIS_ UINT FAR* pnTypeID) PURE;
	STDMETHOD(OnInsertComponent)(THIS_ LPAPPLYCONTEXT lpac) PURE;
	STDMETHOD(OnComponentHelp)(THIS) PURE;

	STDMETHOD(WriteState)(THIS_ LPSTREAM lpsr) PURE;
	STDMETHOD(ReadState)(THIS_ LPSTREAM lpsr) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IExplainComponents
//   This interface is exposed by external components.

#undef  INTERFACE
#define INTERFACE IExplainComponents
DECLARE_INTERFACE_(IExplainComponents, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Component information methods.
	STDMETHOD(GetCLSID)(THIS_ CLSID FAR* pClsID) PURE;
	STDMETHOD(GetStrings)(THIS_ LPSTR FAR* ppvTitle, LPSTR FAR* ppvDescription) PURE;
	STDMETHOD(GetIcon)(THIS_ HICON FAR* phIcon) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// IComponentGallery
//   This interface is used to interact with the Gallery itself.

#undef  INTERFACE
#define INTERFACE IComponentGallery
DECLARE_INTERFACE_(IComponentGallery, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IComponentGallery methods
	STDMETHOD(GetGalleryLocation)(THIS_ LPSTR FAR* ppszPath) PURE;
	STDMETHOD(AddComponent)(THIS_ IComponent FAR* lpc, UINT nTypeID, LPCSTR pszCategory) PURE;
	STDMETHOD(CreateTemplate)(THIS_ LPSTREAM lpStm, IExpandTemplates FAR** ppvObj) PURE;
	STDMETHOD(CreateNewClass)(THIS_ ICreateClasses FAR** ppvObj) PURE;
	STDMETHOD(CheckVersion)(THIS_ UINT nMajor, UINT nMinor) PURE;
	STDMETHOD(CreateTemplateFromText)(THIS_ LPSTREAM lpStm, IExpandTemplates FAR** ppvObj) PURE;
};


/////////////////////////////////////////////////////////////////////////////
// Version number:
#define GALLERY_VER_MAJ (0x0002)
#define GALLERY_VER_MIN (0x0000)


/////////////////////////////////////////////////////////////////////////////
// Result codes
#define CG_FAC (463)
#define CG_S(code) MAKE_HRESULT(SEVERITY_SUCCESS,CG_FAC,code)
#define CG_E(code) MAKE_HRESULT(SEVERITY_ERROR,CG_FAC,code)

#define CG_E_MEMBER_EXISTS      CG_E(50)
#define CG_E_MEMBER_CONFLICTS   CG_E(51)
#define CG_E_MEMBER_NOT_FOUND   CG_E(52)

#define CG_E_PARSE_MISMATCH_PARENT  CG_E(53)
#define CG_E_PARSE_NO_TEMPLATE_DEFN CG_E(54)
#define CG_E_PARSE_NO_DEFN          CG_E(55)
#define CG_E_PARSE_MULTI_LINE       CG_E(56)
#define CG_E_PARSE_INVALID_TOKEN    CG_E(57)
#define CG_E_PARSE_NO_LEXER         CG_E(58)
#define CG_E_PARSE_EMPTY_STREAM     CG_E(59)
#define CG_E_PARSE_MISMATCH_BRACKET CG_E(60)
#define CG_E_PARSE_UNEXPECTED_EOL   CG_E(61)
#define CG_E_PARSE_EXTRA_TOKEN      CG_E(62)
#define CG_E_PARSE_CTOR_RET_TYPE    CG_E(63)
#define CG_E_PARSE_DUP_ACCESS_SPEC  CG_E(64)
#define CG_E_PARSE_INVALID_MODIFIER CG_E(65)
#define CG_E_PARSE_MACROERROR       CG_E(66)
#define CG_E_PARSE_PARAM_COUNT_MISMATCH CG_E(67)

#define CG_E_NO_FILE						 CG_E(100)

#define CG_E_CREATECLASS_NO_CLASSNAME        CG_E(200)
#define CG_E_CREATECLASS_RESERVED_CLASSNAME  CG_E(201)
#define CG_E_CREATECLASS_EXISTING_CLASSNAME  CG_E(202)
#define CG_E_CREATECLASS_NO_HEADERFILE       CG_E(203)
#define CG_E_CREATECLASS_CREATE_HEADERFILE   CG_E(204)
#define CG_E_CREATECLASS_NO_IMPLFILE         CG_E(205)      
#define CG_E_CREATECLASS_CREATE_IMPLFILE     CG_E(206)
#define CG_E_CREATECLASS_WRITE_FILES         CG_E(207)
#define CG_E_CREATECLASS_INVALID_FILES       CG_E(208)
#define CG_E_CREATECLASS_NO_BASECLASS        CG_E(209)
#define CG_E_CREATECLASS_UNKNOWN_BASECLASS   CG_E(210)
#define CG_E_CREATECLASS_GUID_EXISTS         CG_E(211)
#define CG_E_CREATECLASS_CLASS_EXISTS        CG_E(212)
#define CG_E_CREATECLASS_DUP_RES             CG_E(213)
#define CG_E_CREATECLASS_INVALID_RES         CG_E(214)
#define CG_E_CREATECLASS_BLANK_RES           CG_E(215)
#define CG_E_CREATECLASS_QUOTED_RES          CG_E(216)
#define CG_E_CREATECLASS_NO_CLASSWIZINFO     CG_E(217)
#define CG_E_CREATECLASS_COCREATEGUID_FAILED CG_E(218)
#define CG_E_CREATECLASS_NEED_RECSET         CG_E(219)


/////////////////////////////////////////////////////////////////////////////
// IFormStrings
//   This interface provides access to generic lists of New Form string data.

#undef  INTERFACE
#define INTERFACE IFormStrings
DECLARE_INTERFACE_(IFormStrings, IUnknown)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
 	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

	// IFormStrings methods
	STDMETHOD(_NewEnum)(IEnumVARIANT **ppenum) PURE;
};


#endif // __OGAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\prjapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	PRJAPI.H
//		Project package interface declarations.

#ifndef __PRJAPI_H__
#define __PRJAPI_H__

#ifndef STRICT
typedef DWORD HPACKAGE;
typedef DWORD HSTATESAVER;
typedef DWORD HPROJECT;
#else	// STRICT
DECLARE_HANDLE(HPACKAGE);
DECLARE_HANDLE(HSTATESAVER);
DECLARE_HANDLE(HPROJECT);
#endif	// STRICT

interface IProjectWorkspace;
interface IProjectWorkspaceWindow;
interface IPkgProjectProvider;
interface IPkgProject;
interface ISourceControlStatus;
interface ISourceControl;

typedef IProjectWorkspace* LPPROJECTWORKSPACE;
typedef IProjectWorkspaceWindow* LPPROJECTWORKSPACEWINDOW;
typedef ISourceControlStatus* LPSOURCECONTROLSTATUS;
typedef ISourceControl* LPSOURCECONTROL;

class CDefProvidedNode;

// default extension for the workspace file
#define WORKSPACE_EXT	".dsw"
// default extension for the workspace options file
#define WSOPTIONS_EXT	".opt"

// These interfaces are used by the build system, class view, and information
// presentation to interact with the project and global workspace windows.

/////////////////////////////////////////////////////////////////////////////
// IProjectWorkspace

#undef  INTERFACE
#define INTERFACE IProjectWorkspace
DECLARE_INTERFACE_(IProjectWorkspace, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IProjectWorkspace methods
	STDMETHOD(OpenWorkspace)(CDocument **ppDoc, LPCSTR pchWorkspace, BOOL bTemporary) PURE; 	// Non-standard COM.
	STDMETHOD(CreateDefaultWorkspace)(CDocument **ppDoc, LPCSTR pchFileToAdd) PURE; 	// Non-standard COM.
	STDMETHOD(CreateEmptyWorkspace)(CDocument **ppDoc, LPCSTR pszWorkspace) PURE; 	// Non-standard COM.
	STDMETHOD(CloseWorkspace)(VOID) PURE;
	STDMETHOD(IsWorkspaceDocument)(CDocument * pDoc) PURE;
	STDMETHOD(SetWorkspaceDoc)(LPCSTR pszDocName) PURE;
	STDMETHOD(GetWorkspaceDocTitle)(LPCSTR *ppszDocTitle) PURE;
	STDMETHOD(GetWorkspaceDocPathName)(LPCSTR *ppszDocPathName) PURE;
	STDMETHOD(IsWorkspaceInitialised)(VOID) PURE;
	STDMETHOD(IsWorkspaceDocDirty)(VOID) PURE;
	STDMETHOD(SetWorkspaceDocDirty)(VOID) PURE;
	STDMETHOD(IsWorkspaceTemporary)(VOID) PURE;
	STDMETHOD(AddProjectType)( HANDLE hIcon, LPCTSTR szName, LPCTSTR szDefaultExtension,
								LPCTSTR szTabName, BOOL bSupportProjDependency, BOOL bWantsProjSubdirs,
								DWORD Project_ID, IPkgProjectProvider *pPP) PURE; 	// Non-standard COM.
	STDMETHOD(ReleaseProjectTypeInfo)() PURE;
	STDMETHOD(GetProjectTypes)(CPtrArray *pProjectTypes) PURE; 	// Non-standard COM.
	STDMETHOD(SetActiveProject)(IPkgProject *pProject, BOOL bFailSilently) PURE;
	STDMETHOD(GetActiveProject)(IPkgProject **ppProject) PURE;
	STDMETHOD(CanAddProject)(LPCTSTR szProjName) PURE;
	STDMETHOD(AddProject)(IPkgProject *pProject, BOOL bSaveWorkspaceDocNow) PURE;
	STDMETHOD(DeleteProject)(IPkgProject *pProject, BOOL bUnloading) PURE;
	STDMETHOD(GetLoadedProjects)(CADWORD *pLoadedProjects) PURE;
	STDMETHOD(IsProjectRegistered)(LPCOLESTR pszProjName, LPCOLESTR * pszProjFullPath) PURE;
	STDMETHOD(RegisterProject)(IPkgProject *pProject) PURE;
	STDMETHOD(CloseProject)(IPkgProject *pProject) PURE;
	STDMETHOD(SerializeWorkspaceState)(CStateSaver * pSS) PURE;
	STDMETHOD(OpenProjectFile)(LPCOLESTR pszFileName, IPkgProject ** ppProject) PURE;
};

////////////////////////////////////////////////////////////////////////////
// IProjectWorkspaceWindow

#undef  INTERFACE
#define INTERFACE IProjectWorkspaceWindow
DECLARE_INTERFACE_(IProjectWorkspaceWindow, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IProjectWorkspaceWindow methods
	STDMETHOD(AddRootProvidedNode)(CDefProvidedNode *pProvidedNode,	CSlob* pAddSlob) PURE; 	// Non-standard COM.
	STDMETHOD(RemoveSlob)(CSlob *pRemoveSlob, BOOL fRemovePaneIfEmpty) PURE; 	// Non-standard COM.
	STDMETHOD(ActivateContainingPane)(CSlob *pContainedSlob, BOOL bEnsureVisible, BOOL bSetFocusUpon) PURE; 	// Non-standard COM.
	STDMETHOD(FreezeContainingPane)(CSlob *pContainedSlob) PURE; 	// Non-standard COM.
	STDMETHOD(ThawContainingPane)(CSlob *pContainedSlob) PURE; 	// Non-standard COM.
	STDMETHOD(SelectSlob)(CSlob *pSelectSlob, BOOL bClearSelection) PURE; 	// Non-standard COM.
	STDMETHOD(DeselectSlob)(CSlob *pDeselectSlob) PURE; 	// Non-standard COM.
	STDMETHOD(ExpandSlob)(CSlob *pExpandSlob, BOOL bExpandFully) PURE; 	// Non-standard COM.
	STDMETHOD(CollapseSlob)(CSlob *pCollapseSlob) PURE; 	// Non-standard COM.
	STDMETHOD(RefreshSlob)(CSlob *pRefreshSlob) PURE; 	// Non-standard COM.
	STDMETHOD(ScrollSlobIntoView)(CSlob *pViewSlob, BOOL bScrollToTop) PURE; 	// Non-standard COM.
	STDMETHOD(GetVerbPosition)(UINT *pu) PURE;
	STDMETHOD(GetSelectedSlob)(CMultiSlob **ppSlob) PURE; 	// Non-standard COM.
	STDMETHOD(GetSelectedItems)(CMultiSlob *pSlob) PURE;	// Non-standard COM.
	STDMETHOD(IsWindowActive)(VOID) PURE;
	STDMETHOD(IsContainingPaneActive)(CSlob *pContainedSlob) PURE; 	// Non-standard COM.
	STDMETHOD(IsWindowLocked)(VOID) PURE;
	STDMETHOD(PreModalWindow)(VOID) PURE;
	STDMETHOD(PostModalWindow)(VOID) PURE;
	STDMETHOD(BeginUndo)(UINT nID) PURE;
	STDMETHOD(EndUndo)(VOID) PURE;
	STDMETHOD(FlushUndo)(VOID) PURE;
	STDMETHOD(CreateDragger)(CSlobDraggerEx** ppDragger) PURE; 	// Non-standard COM.
	STDMETHOD(GetSlobFromPoint)(POINT *ppt, CSlob **ppSlob) PURE;
	STDMETHOD(GetCurrentSlobRect)(RECT *prt) PURE;
	STDMETHOD(GetSlobRect)(CSlob * pSlob, RECT * prt) PURE;
};

////////////////////////////////////////////////////////////////////////////
// IPkgProjectProvider interface

#undef  INTERFACE
#define INTERFACE IPkgProjectProvider
DECLARE_INTERFACE_(IPkgProjectProvider, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IPkgProjectProvider methods
	STDMETHOD(AddNewProjectTypes)(IProjectWorkspace *pPW) PURE;
	// ReleaseProjectTypeInfo: This function gets called after the dialog 
	// is dismissed so that the package can delete obsolete data structures.
	STDMETHOD(ReleaseProjectTypeInfo)() PURE;
	STDMETHOD(OpenProject)(LPCOLESTR szFileName, IPkgProject ** ppCreatedProject) PURE;
	STDMETHOD(CanCreateProject)(LPCOLESTR szFileName, DWORD dwProject_ID,
							BOOL *pbCanCreate) PURE;


	// CreateProject: retVal can be CREATE_PROJ_OK, CREATE_PROJ_CANCEL or 
	// CREATE_PROJ_RERUN_PROMPT (when the user chooses Back on the first 
	// step of the project wizard).
	STDMETHOD(CreateProject)(LPCOLESTR szFileName, DWORD dwProject_ID,
							IPkgProject **ppCreatedProject,
							DWORD *pdwRetVal) PURE;

	
	// GetPlatforms: Project_ID is the cookie given in IProjectWorkspace.AddProjectType
	// pConfigNames is an array of platform names.
	// pDefaultSelections is an array of which platforms should be selected by default.
	// count is the number of available platforms.
	STDMETHOD(GetPlatforms)(DWORD dwProject_ID,
							LPCOLESTR **ppszTargetNames,
							BOOL **pDefaultSelections,
							ULONG *pCount) PURE;

	// ChangePlatformSelection: This function is called when the user 
	// changes the selected set of platforms. The project provider 
	// is expected to remember which platforms were selected when the 
	// time comes to create a project.
	STDMETHOD(ChangePlatformSelection)(ULONG TargetIndex, BOOL bSelected) PURE;
};


////////////////////////////////////////////////////////////////////////////
// IPkgProject interface

enum {CREATE_PROJ_OK, CREATE_PROJ_CANCEL, CREATE_PROJ_RERUN_PROMPT };

enum DeletionCause {WorkspaceClose, ProjectDelete, ProjectUnload};

#define GPI_PROJISEXECUTABLE	0x0001
#define GPI_PROJSUPPORTSDEPS	0x0002
#define GPI_PROJSUPPORTSSCC	0x0004
#define GPI_PROJEXPORTMAKEFILE	0x0010
#define GPI_PROJEXPORTDEPS		0x0020

#define GPD_PROJSCCNAME		0x0001
#define GPD_PROJSCCPATH		0x0002
#define GPD_PROJSCCAUX		0x0004

#undef  INTERFACE
#define INTERFACE IPkgProject
DECLARE_INTERFACE_(IPkgProject, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

	// IPkgProject methods
	STDMETHOD(AddFiles)(LPCOLESTR * pszFileNames, ULONG count, 
				LPCOLESTR szDestinationFolder) PURE;
	STDMETHOD(CanAddFile)(LPCOLESTR szFileName, LPCOLESTR szDestinationFolder, BOOL bShowUI) PURE;
	STDMETHOD(DeleteFile)(LPCOLESTR szFileName, LPCOLESTR szDestinationFolder) PURE;
	STDMETHOD(RenameFile)(LPCOLESTR szOldFileName, LPCOLESTR szSourceFolder,
				LPCOLESTR szNewFileName, LPCOLESTR szDestinationFolder) PURE;
	STDMETHOD(CreateFolder)(LPCOLESTR szFolder) PURE;
	STDMETHOD(OnActivate)(BOOL bActivate) PURE;
	STDMETHOD(GetAutomationObject)(LPDISPATCH *ppAutomationProject) PURE;

	// Delete: this method should send a PN_QUERY_CLOSE_PROJECT and a PN_CLOSE_PROJECT
	// notification. The IPkgProject object should be sent as a hint with 
	// the PN_CLOSE_PROJECT notification so that the shell/workspace can remove 
	// this project from its list of projects.
	STDMETHOD(Delete)(DeletionCause dcCause, BOOL * pbSuccess) PURE;

	// SetDependentProject: sets pDependentProject to be dependent on 'this' (i.e., 'this'
	// is a subproject of pDependentProject).
	STDMETHOD(SetDependentProject)(IPkgProject *pDependentProject) PURE;

	// GetClassID: this method is used to differentiate between implementations of IPkgProject
	STDMETHOD(GetClassID)(CLSID * pClsID) PURE;

	// GetProjectInfo: this method is used to populate the Select active project combo box. 
	// pszProjFullPath points to the project file name. It will be stored in 
	// the workspace file as a relative path. It is possible to pass in NULL 
	// in either argument (meaning that the caller is not interested in those).
	// dwFlags is used to return flags specific to the project--see GPI_* above.
	// Note: this method must check for and handle NULL pointers for all arguments
	STDMETHOD(GetProjectInfo)(LPCOLESTR *pszProjName, LPCOLESTR *pszProjFullPath,
                                  DWORD *pdwPackageID, DWORD *pdwFlags) PURE;
                                  
        STDMETHOD(GetProjectTypeName)(CString **ppszType) PURE;
                                  

	// DrawProjectGlyph: this method is called when another package wants the project glyph drawn
	// in the area given (e.g., this is used to get C++/Java/Web project glyphs drawn in DataView).
	STDMETHOD(DrawProjectGlyph)(HDC hDC, LPCRECT pRect) PURE;

	// Save: tells the project to serialize itself.
	STDMETHOD(Save)() PURE;
	// IsDirty: asks if the project needs serialization.
	STDMETHOD(IsDirty)() PURE;

	// GetDefaultFolder: Called by Insert Files into Project when the user changes the project 
	// in the projects drop-down combo box. We use the value returned by this 
	// function to fill in the Destination Folder.
	STDMETHOD(GetDefaultFolder)(LPCOLESTR *pszDefaultFolder) PURE;
	
	// CanBrowseFolders: Indicates whether the project provider can browse its folders. 
	// If not, the Browse button will be disabled in the Insert files 
	// into project dialog.
	STDMETHOD(CanBrowseFolders)(BOOL *pbCanBrowse) PURE;
	
	// BrowseFolders: This function is called from Insert Files into Project when 
	// the user clicks on the Browse button.
	STDMETHOD(BrowseFolders)(LPCOLESTR szStartingFolder ,
						LPCOLESTR *pszFolderChosen) PURE;
	
	// GetAllFolders: This function is reserved for future use: we want to be able 
	// to browse the folders without calling the browse folders function, so 
	// this function will return all available folders, and we will use the 
	// list to provide some UI.
	STDMETHOD(GetAllFolders)(CALPOLESTR *pAllFolders) PURE;

	STDMETHOD(GetAssociatedFiles)(CStringArray& outFiles, BOOL selected) PURE;
	STDMETHOD(SetDirty)(BOOL bDirty) PURE;

	// these get/set arbitrary string data, if supported by the project (GPD_*)
	STDMETHOD(GetProjectData)(DWORD dwProp, CString & strVal) PURE;
	STDMETHOD(SetProjectData)(DWORD dwProp, LPCSTR szVal) PURE;
};



/////////////////////////////////////////////////////////////////////////////
//	ISourceControlStatus interface

#undef  INTERFACE
#define INTERFACE ISourceControlStatus

DECLARE_INTERFACE_(ISourceControlStatus, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ISourceControlStatus methods
	STDMETHOD(IsSccInstalled)(VOID) PURE;
	STDMETHOD(IsSccActive)(VOID) PURE;
	STDMETHOD(IsSccOpInProgress)(VOID) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	ISourceControl interface

#undef  INTERFACE
#define INTERFACE ISourceControl

#ifndef _SCC_STATUS_DEFINED
#define _SCC_STATUS_DEFINED
enum  SccStatus 
{
	SCC_STATUS_INVALID			= -1L,		// Status could not be obtained, don't rely on it
	SCC_STATUS_NOTCONTROLLED	= 0x0000L,	// File is not under source control
	SCC_STATUS_CONTROLLED		= 0x0001L,	// File is under source code control
	SCC_STATUS_CHECKEDOUT		= 0x0002L,	// Checked out to current user at local path
	SCC_STATUS_OUTOTHER			= 0x0004L,	// File is checked out to another user
	SCC_STATUS_OUTEXCLUSIVE		= 0x0008L,	// File is exclusively check out
	SCC_STATUS_OUTMULTIPLE		= 0x0010L,	// File is checked out to multiple people
	SCC_STATUS_OUTOFDATE		= 0x0020L,	// The file is not the most recent
	SCC_STATUS_DELETED			= 0x0040L,	// File has been deleted from the project
	SCC_STATUS_LOCKED			= 0x0080L,	// No more versions allowed
	SCC_STATUS_MERGED			= 0x0100L,	// File has been merged but not yet fixed/verified
	SCC_STATUS_SHARED			= 0x0200L,	// File is shared between projects
	SCC_STATUS_PINNED			= 0x0400L,	// File is shared to an explicit version
	SCC_STATUS_MODIFIED			= 0x0800L,	// File has been modified/broken/violated
	SCC_STATUS_OUTBYUSER		= 0x1000L	// File is checked out by current user someplace
};
#endif

enum SccOps
{
	SccNop = 0,
	SccSyncOp,
	SccOutOp,
	SccInOp,
	SccUnOutOp,
	SccAddOp,
	SccRemoveOp,
	SccDiffOp,
	SccHistoryOp,
	SccRenameOp,
	SccProps,
	SccOptions,
	SccShare,
	SccAdmin,
	SccStatus,
	SccInit,
	SccTerm,
	SccPopOp
};

DECLARE_INTERFACE_(ISourceControl, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ISourceControl methods
	STDMETHOD(Init)(HPACKAGE hPackage) PURE;
	STDMETHOD(Term)(VOID) PURE;
	STDMETHOD(OpenProject)(IPkgProject* pkgProject, BOOL bCreate) PURE;
	STDMETHOD(CloseProject)(VOID) PURE;
	STDMETHOD(OnCloseProject)(VOID) PURE;
	STDMETHOD(OnIdle)(long lCount) PURE;
	STDMETHOD(Sync)(LPCSTR lpszFile, BOOL sleep=FALSE) PURE;
	STDMETHOD(Sync)(CStringArray * pFiles, BOOL sleep=FALSE) PURE; 	// Non-standard COM.
	STDMETHOD(CheckOut)(LPCSTR lpszFile) PURE;
	STDMETHOD(CheckOut)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(CheckIn)(LPCSTR lpszFile) PURE;
	STDMETHOD(CheckIn)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(CheckInAdd)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(UnCheckOut)(LPCSTR lpszFile) PURE;
	STDMETHOD(UnCheckOut)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(Add)(LPCSTR lpszFile) PURE;
	STDMETHOD(Add)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(Remove)(LPCSTR lpszFile) PURE;
	STDMETHOD(Remove)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(Diff)(LPCSTR lpszFile) PURE;
	STDMETHOD(Diff)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(History)(LPCSTR lpszFile) PURE;
	STDMETHOD(History)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(ShowProps)(LPCSTR lpszFile) PURE;
	STDMETHOD(ShowProps)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(Share)(CStringArray * pFiles) PURE;
	STDMETHOD(Admin)(LPCSTR lpszFile) PURE;
	STDMETHOD(Admin)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(IsInstalled)(VOID) PURE;
	STDMETHOD(IsActive)(VOID) PURE;
	STDMETHOD(GetStatusText)(const CStringArray & saFiles, CString & strStatus) PURE; 	// Non-standard COM.
	STDMETHOD(GetStatusText)(LPCSTR pszFileName, CString & strStatus) PURE; 	// Non-standard COM.
	STDMETHOD(GetStatusText)(int status, CString & strStatus) PURE; 	// Non-standard COM.
	STDMETHOD(InitOutputWindow)(VOID) PURE;
	STDMETHOD(CheckOutReadOnly)(LPCSTR lpszFile, BOOL bAlways, BOOL bReloadOk) PURE;
	STDMETHOD(CheckOutReadOnly)(CStringArray & strFiles, BOOL bAlways, BOOL bReloadOk) PURE; 	// Non-standard COM.
	STDMETHOD(GetStatusGlyphIndex)(int *pIndex, const CStringArray & saFiles) PURE; 	// Non-standard COM.
	STDMETHOD(GetStatusGlyphIndex)(int *pIndex, LPCSTR pszFileName) PURE;
	STDMETHOD(GetStatusGlyphIndex)(int *pIndex, int status, BOOL bShowControlled) PURE;
	STDMETHOD(GetStatusIndex)(int *pIndex, const CStringArray & saFiles, int & status) PURE; 	// Non-standard COM.
	STDMETHOD(GetStatusIndex)(int *pIndex, LPCSTR pszFileName, int & status) PURE;
	STDMETHOD(GetStatusIndex)(int *pIndex, int status) PURE;
	STDMETHOD(DrawGlyph)(CDC *pDC, LPCRECT lpRect, const CStringArray & saFiles, BOOL bShowControlled) PURE; 	// Non-standard COM.
	STDMETHOD(DrawGlyph)(CDC *pDC, LPCRECT lpRect, LPCSTR pszFileName, BOOL bShowControlled) PURE;
	STDMETHOD(DrawGlyph)(CDC *pDC, LPCRECT lpRect, int status, BOOL bShowControlled) PURE;
	STDMETHOD(PickOp)(int *piOp, LPCSTR lpszFile) PURE;
	STDMETHOD(PickOp)(int *piOp, const CStringArray & saFiles) PURE; 	// Non-standard COM.
	STDMETHOD(PerformOp)(LPCSTR lpszFile) PURE;
	STDMETHOD(PerformOp)(CStringArray * pFiles) PURE; 	// Non-standard COM.
	STDMETHOD(IsValidOp)(LPCSTR lpszFile, int op) PURE;
	STDMETHOD(IsValidOp)(const CStringArray & saFiles, int op) PURE; 	// Non-standard COM.
	STDMETHOD(GetOpText)(LPCSTR *ppsz, int op) PURE;
	STDMETHOD(CanAdd)(VOID) PURE;
	STDMETHOD(CanRemove)(VOID) PURE;
	STDMETHOD(CanSync)(VOID) PURE;
	STDMETHOD(CanDiff)(VOID) PURE;
	STDMETHOD(CanHistory)(VOID) PURE;
	STDMETHOD(CanHistMultifile)(VOID) PURE;
	STDMETHOD(CanProps)(VOID) PURE;
	STDMETHOD(CanShare)(VOID) PURE;
	STDMETHOD(CanAdmin)(VOID) PURE;
	STDMETHOD(AlwaysPrompt)(VOID) PURE;
	STDMETHOD(AddNewFiles)(VOID) PURE;
	STDMETHOD(AddNewProj)(VOID) PURE;
	STDMETHOD(CheckOutFiles)(VOID) PURE;
	STDMETHOD(RemoveDeletedFiles)(VOID) PURE;
	STDMETHOD(LoadFromOPT)(HSTATESAVER pStateSaver) PURE;
	STDMETHOD(SaveToOPT)(HSTATESAVER pStateSaver) PURE;
	STDMETHOD(GetSccName)(LPCSTR *ppsz) PURE;
	STDMETHOD(GetSccMenuName)(LPCSTR *ppsz) PURE;
	STDMETHOD(SetStatus)(LPCSTR pszFileName, int status, BOOL bNotify) PURE;
	STDMETHOD(GetStatus)(int *piStatus, LPCSTR pszFileName) PURE;
	STDMETHOD(GetStatus)(int *piStatus, const CStringArray & saFiles) PURE; 	// Non-standard COM.
	STDMETHOD(Enable)(BOOL bEnable) PURE;
	STDMETHOD(BrowseProjects)(int *piRet, BOOL bNew) PURE;
	STDMETHOD(BrowseProjects)(int *piRet, CString & strProjName, CString & strLocalPath,
		CString & strAuxPath, BOOL bNew) PURE; 	// Non-standard COM.
	STDMETHOD(CanBrowse)(VOID) PURE;
	STDMETHOD(GetProject)(CString & strProjName, CString & strLocalPath,
		CString & strProjPath, BOOL bCreate) PURE; 	// Non-standard COM.
	STDMETHOD(OnProjSave)(HPROJECT hProject) PURE;
	STDMETHOD(ProjectSpecified)(VOID) PURE;
	STDMETHOD(IsControlled)(LPCSTR pszFileName) PURE;
	STDMETHOD(RegisterProjectFilter)(LPCSTR lpszProjFilter) PURE;
	STDMETHOD(ShouldFileChange)(LPCSTR pszFile) PURE;
	STDMETHOD(IsAddingProject)(VOID) PURE;
	STDMETHOD(CancelGetProject)(const CString& builderfile) PURE;
	STDMETHOD(IsSccActive)(VOID) PURE;
	STDMETHOD(IsSccInstalled)(VOID) PURE;
	STDMETHOD(IsSccOpInProgress)(VOID) PURE;
	STDMETHOD(IsActive)(const CString&) PURE;
	STDMETHOD(IsActive)(IPkgProject*) PURE;
	STDMETHOD(AreAllActive)(const CStringArray&) PURE;
	STDMETHOD(IsBuilderControlled)(HPROJECT hBld) PURE;
	STDMETHOD_(int,IsOpInProgressValue)(THIS) PURE; // nonstandard result
};

/////////////////////////////////////////////////////////////////////////////
//	IPkgDropDataSource interface
//	Use this interface for OLE based project drag drop
#undef  INTERFACE
#define INTERFACE IPkgDropDataSource

DECLARE_INTERFACE_(IPkgDropDataSource, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (void) PURE;
	STDMETHOD_(ULONG,Release) (void) PURE;

	// Data Provider methods for Drop Sources
	STDMETHOD(GetDropInfo) (DWORD *pdwOKEffects, 
							IDataObject **ppDataObject, IDropSource **pDropSource) PURE;
	STDMETHOD(OnDropNotify) (BOOL fDropped, DWORD dwEffects) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IPkgDropDataTarget interface
//	Use this interface for OLE based project drag drop
#undef  INTERFACE
#define INTERFACE IPkgDropDataTarget

DECLARE_INTERFACE_(IPkgDropDataTarget, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (void) PURE;
	STDMETHOD_(ULONG,Release) (void) PURE;

	// Data Provider methods for Drop Target
	STDMETHOD(OnDragEnter)(IDataObject *pDataObj, 
							DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) PURE;
	STDMETHOD(OnDragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) PURE;
	STDMETHOD(OnDragLeave)(void) PURE;
	STDMETHOD(OnDrop)(IDataObject *pDataObj, 
							DWORD grfKeyState, POINTL pt,DWORD *pdwEffect) PURE;
};
/////////////////////////////////////////////////////////////////////////////

#endif	// __PRJAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\prjguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	PRJGUID.H
//		Project package interface ids.


// Interface ID for IProjectWorkspace {AD8B7E81-8DA6-11cf-8FB8-00A0C903494F}
DEFINE_GUID(IID_IProjectWorkspace,
	0xad8b7e81, 0x8da6, 0x11cf, 0x8f, 0xb8, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x4f);

// Interface ID for IProjectWorkspaceWindow {AD8B7E82-8DA6-11cf-8FB8-00A0C903494F}
DEFINE_GUID(IID_IProjectWorkspaceWindow,
	0xad8b7e82, 0x8da6, 0x11cf, 0x8f, 0xb8, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x4f);

// Interface ID for SourceControlStatus {EE8F5FD1-185E-11cf-B24F-00AA0057AFF3}
DEFINE_GUID(IID_ISourceControlStatus,
	0xee8f5fd1, 0x185e, 0x11cf, 0xb2, 0x4f, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for SourceControl {EE8F5FD2-185E-11cf-B24F-00AA0057AFF3}
DEFINE_GUID(IID_ISourceControl,
	0xee8f5fd2, 0x185e, 0x11cf, 0xb2, 0x4f, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Class ID for project document {34866983-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_WorkspaceDocument, 
	0x34866983, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for package drag drop service {6CEFADB1-94BF-11cf-A405-00AA00C00940}
DEFINE_GUID(SID_SPkgDragDrop, 
0x6cefadb1, 0x94bf, 0x11cf, 0xa4, 0x5, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);

// Interface ID for IPkgDropDataSource {6CEFADB2-94BF-11cf-A405-00AA00C00940}
DEFINE_GUID(IID_IPkgDropDataSource,
0x6cefadb2, 0x94bf, 0x11cf, 0xa4, 0x5, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);

// Interface ID for IID_IPkgDropDataTarget {6CEFADB3-94BF-11cf-A405-00AA00C00940}
DEFINE_GUID(IID_IPkgDropDataTarget, 
0x6cefadb3, 0x94bf, 0x11cf, 0xa4, 0x5, 0x0, 0xaa, 0x0, 0xc0, 0x9, 0x40);

// Interface ID for IID_IPkgProject  {7E52B9C0-D13D-11cf-925A-00A0C9138C45}
DEFINE_GUID(IID_IPkgProject, 
0x7e52b9c0, 0xd13d, 0x11cf, 0x92, 0x5a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x45);

// Interface ID for IID_IPkgProjectProvider  {7E52B9D0-D13D-11cf-925A-00A0C9138C45}
DEFINE_GUID(IID_IPkgProjectProvider, 
0x7e52b9d0, 0xd13d, 0x11cf, 0x92, 0x5a, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x45);

// Interface ID for IID_DBGProject {D593BCB0-1C73-11d0-9825-00A0C9034944}
DEFINE_GUID(IID_IDBGProject, 
0xd593bcb0, 0x1c73, 0x11d0, 0x98, 0x25, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x44);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\resguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	RESGUID.H
//		Resource package interface ids.

//	Interface ID for resource I/O.
DEFINE_GUID(IID_IResourceIO,
	0xA89AEB01,0x52E0,0x11CE,0xBF,0x46,0x00,0xAA,0x00,0x4C,0x12,0xE2);

//	Interface ID for control list.
DEFINE_GUID(IID_IControlList, 
	0xb16cd900, 0x632a, 0x11ce, 0x86, 0xcd, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x5c);

#ifdef LOCTOOLS
//	Interface ID for resource localization.
DEFINE_GUID(IID_IResourceIntl,
	0xF52E90A1,0x596D,0x11CE,0xBF,0x46,0x00,0xAA,0x00,0x4C,0x12,0xE2);
#endif

// Class ID for RC file document {34866984-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_RCDocument, 
	0x34866984, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for resource template document {34866985-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_RCTDocument, 
	0x34866985, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for RES file document {34866986-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_RESDocument, 
	0x34866986, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for 16-bit EXE document {34866987-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_EXEDocument, 
	0x34866987, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for 32-bit EXE document {34866988-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_PEDocument, 
	0x34866988, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for binary document {34866989-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_BinaryDocument, 
	0x34866989, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for bitmap document {3486698A-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_BitmapDocument, 
	0x3486698a, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for icon document {3486698B-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_IconDocument, 
	0x3486698b, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for cursor document {3486698C-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_CursorDocument, 
	0x3486698c, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for toolbar document {3BC47C40-6AF8-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_ToolbarDocument, 
	0x3bc47c40, 0x6af8, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for dialog document {474A4B60-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_DialogDocument, 
	0x474a4b60, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for menu document {474A4B61-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_MenuDocument, 
	0x474a4b61, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for accelerator document {474A4B62-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_AccelDocument, 
0x474a4b62, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for stringtable document {474A4B63-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_StringDocument, 
0x474a4b63, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

// Class ID for version document {474A4B64-A9C0-11cf-B254-00AA006C2A9A}
DEFINE_GUID(CLSID_VersionDocument, 
0x474a4b64, 0xa9c0, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);


//	Interface ID for External resources packages
DEFINE_GUID(IID_IExternalResPkg,	// {452EADA1-5BBC-11cf-B254-00AA006C2A9A}
	0x452eada1, 0x5bbc, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for External resources documents
DEFINE_GUID(IID_IExternalResDoc,	// {452EADA2-5BBC-11cf-B254-00AA006C2A9A}
	0x452eada2, 0x5bbc, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for External resources frames
DEFINE_GUID(IID_IExternalResView,	// {452EADA3-5BBC-11cf-B254-00AA006C2A9A}
	0x452eada3, 0x5bbc, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for Internal CResObjects
DEFINE_GUID(IID_IResObject,			// {12068F00-5BBD-11cf-B254-00AA006C2A9A}
	0x12068f00, 0x5bbd, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for Resource View state information
DEFINE_GUID(IID_IResourceEditorState,	// {90125C00-AA58-11cf-B254-00AA006C2A9A}
	0x90125c00, 0xaa58, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for Resource View Item state information
DEFINE_GUID(IID_IItemEditorInfo,	// {90125C01-AA58-11cf-B254-00AA006C2A9A}
	0x90125c01, 0xaa58, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);

//	Interface ID for Resource Browser state information
DEFINE_GUID(IID_IResourceBrowserState,	// {90125C02-AA58-11cf-B254-00AA006C2A9A}
	0x90125c02, 0xaa58, 0x11cf, 0xb2, 0x54, 0x0, 0xaa, 0x0, 0x6c, 0x2a, 0x9a);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\resapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	RESAPI.H
//		Resource package interface declarations.

#ifndef __RESAPI_H__
#define __RESAPI_H__

#include "bldapi.h"

//	GetDocLong enum
//		For use with resource template documents.

enum
{
	GDL_CMP_FIRST						= 1000,
	GDL_CMP_SAVE_AS_FILTER,
	GDL_CMP_SYMBOL_VALIDATION_CALLBACK,
	GDL_CMP_SUPPORT_EXTERNAL_FILES,
	GDL_CMP_USES_EXTERNAL_FILES,
	GDL_CMP_SUPPORT_MFC_MODE,
	GDL_CMP_USE_3D_CONTROLS,
};


#ifndef STRICT
typedef DWORD HCOMPOSITION;
typedef DWORD HCOMPIO;
typedef DWORD HRCIO;
typedef DWORD HRESIO;
typedef DWORD HRESOURCE;
#else	// STRICT
DECLARE_HANDLE(HCOMPOSITION);
DECLARE_HANDLE(HCOMPIO);
DECLARE_HANDLE(HRCIO);
DECLARE_HANDLE(HRESIO);
DECLARE_HANDLE(HRESOURCE);
#endif	// STRICT

interface IResourceIO;
interface IResourceIntl;
interface IControlList;
interface IResObject;
interface IExternalResPkg;
interface IExternalResDoc;
interface IExternalResView;
interface IResourceBrowserState;
interface IResourceEditorState;
interface IItemEditorInfo;

typedef IResourceIO* LPRESOURCEIO;
typedef IResourceIntl* LPRESOURCEINTL;
typedef IControlList* LPCONTROLLIST;
typedef IResObject* LPRESOBJECT;
typedef IExternalResPkg* LPEXTERNALRESPKG;
typedef IExternalResDoc* LPEXTERNALRESDOC;
typedef IExternalResView* LPEXTERNALRESVIEW;
typedef IResourceBrowserState* LPRESOURCEBROWSERSTATE;
typedef IResourceEditorState* LPRESOURCEEDITORSTATE;
typedef IItemEditorInfo* LPITEMEDITORINFO;

#define P_FrameTitle		        128	// For resource editor frames

/////////////////////////////////////////////////////////////////////////////
//	IResourceIO interface
//		Feature gallery access to resource package I/O funtionality.

#undef  INTERFACE
#define INTERFACE IResourceIO

enum { NEWRESTYPE_RC, NEWRESTYPE_RCT, NEWRESTYPE_RES };
typedef BOOL (CALLBACK* SYMBOL_VALIDATION_CALLBACK)(LPCSTR szSymbol);

DECLARE_INTERFACE_(IResourceIO, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IResourceIO methods
	STDMETHOD(LoadCmpIO)(THIS_ CFile* pFile, HCOMPIO* phComp) PURE; 	// Non-standard COM.
	STDMETHOD(LoadRctFile)(THIS_ HFILESET hFileSet, LPCSTR lpszPath, BOOL& bCloseIt, HRCIO* phComp) PURE;
	STDMETHOD(NewCmpIO)(THIS_ HCOMPIO* phComp) PURE;
	STDMETHOD(NewRctFile)(THIS_ HFILESET hFileSet, HRCIO* phComp) PURE;
	STDMETHOD(SaveComp)(THIS_ HCOMPOSITION hComp, CFile* pFile) PURE; 	// Non-standard COM.
	STDMETHOD(SaveRctFile)(THIS_ HCOMPOSITION hComp, LPCSTR lpszPath) PURE;
	STDMETHOD(CloseComp)(THIS_ HCOMPOSITION hComp) PURE;
	STDMETHOD(NewUniqueSymbol)(THIS_ HCOMPOSITION hComp, LPCSTR szName,
		CString& rstrName, CString& rstrValue) PURE; 	// Non-standard COM.
	STDMETHOD(CloneIntoComp)(THIS_ HCOMPOSITION hSrc, HCOMPOSITION hDest,
		LPCSTR lpszType, LPCSTR lpszID, int nLangID, LPCSTR szCondition,
		LPCSTR szNewSymbol, LPCSTR szNewValue, int nNewLangID,
		LPCSTR szNewCondition) PURE;
	STDMETHOD(ImportIntoComp)(THIS_ HCOMPOSITION hDest, LPCTSTR szType, LPCTSTR szID, 
		LPCTSTR szValue, LPCTSTR szContents, int nLangID, LPCTSTR szCondition) PURE;
	STDMETHOD(DeleteItem)(THIS_ HCOMPOSITION hComp,
		LPCSTR lpszType, LPCSTR lpszID, int nLandID, LPCSTR lpszCondition) PURE;
	STDMETHOD(GetSymbolInclude)(THIS_ HRESIO hComp, CString& rStr) PURE; 	// Non-standard COM.
	STDMETHOD(NewString)(THIS_ HCOMPOSITION hComp, LPCSTR pszSymbol,
		LPCSTR szValue, int nLangID, LPCSTR pszString) PURE;
	STDMETHOD(ChangeItemSymbol)(THIS_ HCOMPOSITION hComp,
		LPCSTR lpszType, LPCSTR lpszID, int nLangID, LPCSTR lpszNewID, LPCSTR szValue) PURE;
	STDMETHOD(UpdateClassWizardInfo)(THIS_ LPCSTR lpszPath, BOOL bUpdateScope) PURE;
	STDMETHOD(SetDefaultResTemplate)(THIS_ CDocTemplate* pTemplate) PURE;
	STDMETHOD(RegisterExternalEditor)(THIS_ LPEXTERNALRESPKG pExtRes, 
		REFCLSID clsidEditor, LPCSTR szEditorName, LPCSTR szResType) PURE;
	STDMETHOD(OpenRcFile)(THIS_ HFILESET hFileSet, LPCSTR lpszPath, HCOMPOSITION* phComp) PURE;
	STDMETHOD(OpenResource)(THIS_ HCOMPOSITION hComp, LPCTSTR szResType, 
		LPCTSTR szResName, long nLanguage, LPCTSTR szCondition) PURE;
};

#ifdef LOCTOOLS
/////////////////////////////////////////////////////////////////////////////
//	IResourceIntl interface
//		Espresso access to resource package functionality.

#undef  INTERFACE
#define INTERFACE IResourceIntl

typedef BOOL (__stdcall* CANCLOSE_CALLBACK)(CFrameWnd * pFrame);

DECLARE_INTERFACE_(IResourceIntl, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IResourceIntl methods
	STDMETHOD(IntlSetMode)(THIS_ BOOL bMode) PURE;
	STDMETHOD(IntlEditResource)(THIS_ CFile* pFile, CObArray * pSlobs,
		CSlob** ppSelection, CPartDoc** ppDocument) PURE; 	// Non-standard COM.
};
#endif

/////////////////////////////////////////////////////////////////////////////
//	IControlList interface
//		Feature gallery access to resource package OLE control list.

#undef  INTERFACE
#define INTERFACE IControlList

DECLARE_INTERFACE_(IControlList, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IControlList methods
	STDMETHOD(Clear)(THIS) PURE;
	STDMETHOD(AddControl)(THIS_ REFCLSID rClsID) PURE;
	STDMETHOD(RemoveControl)(THIS_ REFCLSID rClsID) PURE;
	STDMETHOD(GetControl)(THIS_ int iCtl, LPCLSID lpClsID) PURE;
};

/////////////////////////////////////////////////////////////////////////////
/*
struct SResHeader
{
//	SResHeader(): m_clsidEditor(NULL){};
	HCOMPOSITION m_hComp;		// handle for parent res file
	HRESOURCE    m_hRes;		// handle of resource object
	REFCLSID  m_clsidEditor;	// clsid of CPartTemplate to use
};
typedef SResHeader RESHEADER, * LPRESHEADER;
*/

enum	// flags for IResObject::OnUpdateCommandUI
{
	OUCUI_ENABLE = 0x1,
	OUCUI_CHECK = 0x2,
	OUCUI_RADIO = 0x3,
};

/////////////////////////////////////////////////////////////////////////////
//	IResPackage interface
//		Used by external resource editors to initiate communication with RES
//		package.  When RES package wants to initiate, use IExternalRes.

#undef  INTERFACE
#define INTERFACE IResPackage

DECLARE_INTERFACE_(IResPackage, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IMasterRes methods
};

/////////////////////////////////////////////////////////////////////////////
//	IResObject interface
//		Used by external resource editors to initiate communication with RES
//		package.  When RES package wants to initiate, use IExternalRes.

#undef  INTERFACE
#define INTERFACE IResObject

DECLARE_INTERFACE_(IResObject, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IMasterRes methods
	STDMETHOD(UpdateData)(THIS_ CFile* pFile) PURE;	// REVIEW: non-standard COM
	STDMETHOD(EditorClosed)(THIS) PURE;
	STDMETHOD(SetDirty)(THIS) PURE;

	STDMETHOD_(GPT, GetIntProp)(THIS_ int idProp, int& rn) PURE;	// REVIEW: non-standard COM
	STDMETHOD_(GPT, GetStrProp)(THIS_ int idProp, CString& rstr) PURE;	// REVIEW: non-standard COM
	STDMETHOD_(BOOL, SetIntProp)(THIS_ int idProp, int n) PURE;
	STDMETHOD_(BOOL, SetStrProp)(THIS_ int idProp, const CString& rstr) PURE;	// REVIEW: non-standard COM

	STDMETHOD(SetupPropertyPages)(THIS_ BOOL bSetCaption) PURE;

	STDMETHOD(OnCommand)(THIS_ UINT idCmd) PURE;
	STDMETHOD(OnUpdateCommandUI)(THIS_ UINT idCmd, DWORD* pdwFlags) PURE;
	/*
	STDMETHOD(AddDependant)(THIS_ CSlob * pSlob) PURE;
	STDMETHOD(RemoveDependant)(THIS_ CSlob * pSlob) PURE;
	*/
};

/////////////////////////////////////////////////////////////////////////////
//	IExternalResPkg interface
//		Used by CResObjects to create communication with external res
//		packages.

#undef  INTERFACE
#define INTERFACE IExternalResPkg

DECLARE_INTERFACE_(IExternalResPkg, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IExternalResPkg methods
	STDMETHOD_(LPEXTERNALRESDOC, OpenStream)(THIS_ REFCLSID clsidTemplate, 
		CFile* pFile, LPRESOBJECT pResObject) PURE;	// REVIEW: non-standard COM
	STDMETHOD_(LPEXTERNALRESDOC, NewResource)(THIS_ REFCLSID clsidTemplate, 
		LPRESOBJECT pResObject) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IExternalResDoc interface
//		Contained by CExternalResDoc in external resource editors.
//		A CResObject keeps a pointer to it when it is opened externally.

#undef  INTERFACE
#define INTERFACE IExternalResDoc

DECLARE_INTERFACE_(IExternalResDoc, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IExternalResDoc methods
	STDMETHOD(CloseEditor)(THIS_ BOOL bDoSave) PURE;
	STDMETHOD(SaveEditor)(THIS) PURE;
	STDMETHOD(UpdateStream)(THIS_ CFile* pFile) PURE;	// REVIEW: non-standard COM
	STDMETHOD(NotifyPropChange)(THIS_ UINT idProp) PURE;
	STDMETHOD_(HWND,GetEditorView)(THIS) PURE;	// TODO: remove
	STDMETHOD(ActivateEditor)(THIS) PURE;
	STDMETHOD (Reload) (THIS_ CFile * pFile) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IExternalResView interface
//		Used to recognize external resource editors among the various MDI
//		children in the IDE.

#undef  INTERFACE
#define INTERFACE IExternalResView

DECLARE_INTERFACE_(IExternalResView, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IExternalResView methods
	STDMETHOD_(LPEXTERNALRESDOC, GetDocument)(THIS) PURE;
	STDMETHOD_(LPRESOBJECT, GetResObject)(THIS) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IResourceBrowserState interface
//		Used to determine the identity, selection state and other 
//		information about a resource browser.

#undef  INTERFACE
#define INTERFACE IResourceBrowserState

DECLARE_INTERFACE_(IResourceBrowserState, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Resource identification methods
	STDMETHOD_(int, GetFileName)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;

	// Dialog State methods
	STDMETHOD_(int, GetSelectionCount)(THIS) PURE;
	STDMETHOD(GetSelectedItem)(THIS_ int nItem, LPITEMEDITORINFO* ppEditor) PURE;
};


/////////////////////////////////////////////////////////////////////////////
//	IResourceEditorState interface
//		Used to determine the identity, selection state and other 
//		information about a resource editor.

#undef  INTERFACE
#define INTERFACE IResourceEditorState

DECLARE_INTERFACE_(IResourceEditorState, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Resource identification methods
	STDMETHOD_(int, GetFileName)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
	STDMETHOD_(int, GetResourceName)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
	STDMETHOD(GetResourceValue)(THIS_ WORD* pValue) PURE;
	STDMETHOD(GetResourceLanguage)(THIS_ WORD* pLanguage) PURE;
	STDMETHOD_(int, GetResourceCondition)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
	STDMETHOD_(int, GetResourceExternalFilename)(THIS_ 
		LPTSTR szBuffer, int cchBuffer) PURE;

	// Dialog State methods
	STDMETHOD_(int, GetSelectionCount)(THIS) PURE;
	STDMETHOD(GetSelectedItem)(THIS_ int nItem, LPITEMEDITORINFO* ppEditor) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IItemEditorInfo interface
//		Used to retreive information about a specific editor in any of a
//		variety of resource editors.
//		This interface is used for dialog controls (and the dialog itself),
//		menu items and popups, strings table strings, accelerators, 
//		toolbars buttons, resources in the resource browser tree, etc.

#undef  INTERFACE
#define INTERFACE IItemEditorInfo

DECLARE_INTERFACE_(IItemEditorInfo, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Resource identification methods
	STDMETHOD(GetResourceEditor)(THIS_ LPRESOURCEEDITORSTATE* ppResource) PURE;

	// Item info methods
	STDMETHOD_(int, GetClassName)(THIS_ LPTSTR szNameBuffer, int cchBuffer) PURE;
	STDMETHOD_(int, GetItemName)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
	STDMETHOD(GetItemValue)(THIS_ WORD* pValue) PURE;
	STDMETHOD_(int, GetItemCaption)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
	STDMETHOD_(int, GetClassType)(THIS_ LPTSTR szBuffer, int cchBuffer) PURE;
	// IDEA: GetStyleBits and GetExStyleBits might be useful
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __RESAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\shlapi_.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLAPI_.H
//		Private interfaces between shell and devaut1
//		(Other private interfaces implemented by the shell
//		are welcome.  Please, join the party.)

#ifndef __SHLAPI__H__
#define __SHLAPI__H__

/////////////////////////////////////////////////////////////////////////////
//	IAutomationItems interface.  This interface is implemented by
//   the shell, and is called exclusively by devaut1.pkg

// This structure is used to pass information from the shell to
//  devaut1 via IAutomationItems::GetAutomationItems.
#define MAX_LENGTH_NAMED_ITEM 64
struct CAutomationItem
{
	TCHAR m_szName[MAX_LENGTH_NAMED_ITEM];		// Name of named item
	GUID m_tlid;								// GUID of its type library
	GUID m_clsid;								// CLSID of its object
	WORD m_wMajorVersion;						// Major ver.# of typelib
	WORD m_wMinorVersion;						// Minor ver.# of typelib
};

#undef  INTERFACE
#define INTERFACE IAutomationItems

DECLARE_INTERFACE_(IAutomationItems, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IAutomationItems methods

	// The caller (aut1) allocates a *pdwNumItems-count array of CAutomationItem's
	//  in pAutomationItems.  The shell fills in the array with data it gathered
	//  when loading the packages and calling CPackage::GetApplicationExtensions
	//  for each package.  The callee (shell) fills in *pdwNumItems with the number
	//  of elements of the array it filled in.
	// If the caller passes NULL for pAutomationItems, the callee will leave that
	//  alone, and will fill in *pdwNumItems with the total number of items.
	//  The callee can use this to determine how much space to allocate for
	//  the next call to GetAutomationItems.
	STDMETHOD(GetAutomationItems)(CAutomationItem* pAutomationItems, DWORD* pdwNumItems) PURE;

	// Aut1 will call this for each CAutomationItem::m_szName it was passed by the shell
	//  during a previous call to GetAutomationItems.  This is called when VBS requests
	//  of devaut1 an IUnknown for a named item.
	STDMETHOD(GetIDispatch)(LPCTSTR szItemName, IDispatch** ppDispatch) PURE;
};


/////////////////////////////////////////////////////////////////////////////
//	IRecordNotifyShell interface.  This interface is implemented by
//   the shell, and is called exclusively by devaut1.pkg to inform the
//   the shell of state changes with the Macro Recorder.

#undef  INTERFACE
#define INTERFACE IRecordNotifyShell

DECLARE_INTERFACE_(IRecordNotifyShell, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IRecordNotifyShell methods
	STDMETHOD(OnStartRecord)(THIS) PURE;
	STDMETHOD(OnStopRecord)(THIS) PURE;
	STDMETHOD(OnPauseRecord)(THIS) PURE;
	STDMETHOD(OnResumeRecord)(THIS) PURE;
	STDMETHOD(SetShouldRecordText)(THIS_ BOOL bShouldRecordText) PURE;
};


#endif //__SHLAPI__H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\srcapi.h ===
/////////////////////////////////////////////////////////////////////////////
//	SRCAPI.H
//		Source package interface declarations.

#ifndef __SRCAPI_H__
#define __SRCAPI_H__

#ifndef STRICT
typedef DWORD HLEXER;
typedef DWORD HPARSER;
typedef DWORD HBSC;
typedef DWORD HNCB;
#else	// STRICT
DECLARE_HANDLE(HLEXER);
DECLARE_HANDLE(HPARSER);
DECLARE_HANDLE(HBSC);
DECLARE_HANDLE(HNCB);
#endif	// STRICT

interface ISourceEdit;
interface ISourceQuery;
interface IParserDataBase;
interface IEditDebugStatus;
interface IParserAssist;
interface IOutputWindow;
interface IFileAccess;

interface ITextDocument;
interface ITextSelection;

typedef ISourceEdit* LPSOURCEEDIT;
typedef ISourceQuery* LPSOURCEQUERY;
typedef IParserDataBase* LPPARSERDATABASE;
typedef IEditDebugStatus* LPEDITDEBUGSTATUS;
typedef IParserAssist* LPPARSERASSIST;
typedef IOutputWindow* LPOUTPUTWINDOW;
typedef IFileAccess* LPFILEACCESS;

enum EXEFROM	// where did GetExecutableFilename get name from?
{
	exefromNone,	// nowhere (no name found)
	exefromProj,	// from project
	exefromLastDoc,	// from last open src window
	exefromExe,		// from currently active exe window
	exefromPid,		// from PID on command line (just-in-time debugging)
};

////////////////////////////////////////////////////////////////////////////////
//	ISourceEdit interface
//
//	A pointer to this interface can be obtained via the ISourceQuery interface.  (See below)
//
//	To edit a source file via this interface, use the following sequence of steps:
//
//		BeginEdits()
//		<perform edits, queries>
//		EndEdits()
//		CommitChanges()		/* if you want your changes saved to disk */
//
//	The editing methods will fail unless BeginEdit is called first.
//
//	Other notes:
//
//			THIS IS NOT YET THREAD-SAFE!
//			Line numbers are zero-based.

typedef enum { 
	BREAKPOINT,
	CURRENT_DEBUG,    // instruction pointer
	DISABLED_BREAKPOINT,
	MIXED_BREAKPOINT,
	CALLER_DEBUG      // instruction pointer in stack
} LineMark;

typedef enum { SET, CLEAR, TOGGLE } LineMarkAction;

typedef void (*pfnLineChangeCallback)(LPCSTR LPCSTRFileName, ULONG iDocID, ULONG ilineStart, ULONG cLines, BOOL fAdded);	// See RegisterLineChangeCallback (below)

#undef INTERFACE
#define INTERFACE	ISourceEdit

DECLARE_INTERFACE_(ISourceEdit, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ISourceEdit methods : Query
	STDMETHOD(GetLineText)(THIS_ ULONG, LPCSTR *ppstr, ULONG *pcb) PURE;
	STDMETHOD(GetLineTextSansCrLf)(THIS_ ULONG, LPCSTR *ppstr, ULONG *pcb) PURE;
	STDMETHOD(GetTextRunAtFileOffset)(ULONG cpStart, LPCSTR *ppsz, ULONG *pcb) PURE;
	STDMETHOD(GetLanguage)(CString& str) PURE; 	// Non-standard COM.
	STDMETHOD(GetLineColumnFromFileOffset)(ULONG cpOffset, ULONG *pIline, ULONG *pIb) PURE;
	STDMETHOD(GetLineFromFileOffset)(ULONG cpOffset, ULONG *piline) PURE;
	STDMETHOD(FFileOffsetAtBOLN)(ULONG cpOffset) PURE;
	STDMETHOD(GetFileOffsetFromLine)(ULONG iline, ULONG *pcpOffset) PURE;
	STDMETHOD(FUserModified)(VOID) PURE;
	STDMETHOD(FFileWriteable)(VOID) PURE;
	STDMETHOD(GetCaretLine)(ULONG *piLine) PURE;
	STDMETHOD(GetCaretColumn)(ULONG *piColumn) PURE; // column of caret -- view coords, tabs expanded
    STDMETHOD(GetCaretIndex)(ULONG *pib) PURE;       // index to byte at caret -- doc coords, tabs not expanded
	STDMETHOD(GetPath)(CString& str) PURE; 	// Non-standard COM.
	STDMETHOD(CbDoc)(ULONG *pul) PURE;
	STDMETHOD(CLines)(ULONG *pul) PURE;
	STDMETHOD(DocID)(ULONG *pul) PURE;

	// ISourceEdit methods : Edit

	/*
	**	RevertContents	--	Restores the contents of the document back to that which
	**						existed prior to the call to BeginEdits.
	**				**	->	NOTE:  This must be called after BeginEdits, no later than
	**						immediately after EndEdits!  We're just playing back the last
	**						action(s) on the undo stack (if the doc is open in the editor),
	**						so we don't want the user to add to it first.
	*/
	STDMETHOD(BeginEdits)(BOOL fKeepUndoBuffer, BOOL fSuspendUI) PURE;
	STDMETHOD(EndEdits)(VOID) PURE;
	STDMETHOD(RevertContents)(VOID) PURE;
	STDMETHOD(CommitChanges)(VOID) PURE;
	STDMETHOD(InsertTextWithCrLf)(LPCSTR psz, ULONG cbInsert, ULONG ilineInsert, ULONG ibInsert) PURE;
	STDMETHOD(InsertText)(LPCSTR psz, ULONG cbInsert, ULONG ilineInsert, ULONG ibInsert) PURE;
	STDMETHOD(DeleteLine)(ULONG iline) PURE;
	STDMETHOD(DeleteText)(ULONG iline, ULONG ibStart, ULONG ibLim) PURE;
	STDMETHOD(DeleteText)(ULONG ilineStart, ULONG ibStart, ULONG ilineLast, ULONG ibLim) PURE;
	STDMETHOD(EnsureFileEndsWithCrLf)(VOID) PURE;

	// ISourceEdit methods : Search
	STDMETHOD(FindStr)(ULONG cpSearchStart, char *strFind, ULONG *pilineHit, ULONG *pibHit) PURE;

	/*
	**	RegisterLineChangeCallback	--
	**
	**	Register a function to be called from the editor every time lines of
	**	text (cLines) are added or deleted.
	**
	**	If fAdded == TRUE, lines were added, otherwise, lines were deleted.
	**	Insertions are always performed at column 0 (or BEFORE) ilineStart.
	**	Deletions are always performed INCLUDING ilineStart.
	*/
	STDMETHOD(RegisterLineChangeCallback)(pfnLineChangeCallback) PURE;

	// ISourceEdit methods : Misc.

	/*
	**	MarkLine		--	Adds/deletes/toggles a glyph on the line
	**	IsLineMarked	--	Indicates whether or not a glyph is set on the line
	**	FHasOpenView	--	Is there currently UI associated with this interface's doc?
	**	SetCaretPosInActiveView
	**					--	Set the caret position in the view associated with the document.
	**					--	Only sets focus to that view if fSetFocus is TRUE.
	**					--	If fManageBPFocus is true, the function will 1) bring the breakpoint
	**						into view and 2) keep focus in the previously-active window if it
	**						was other than a text window.  ** fSetFocus ** overrides this behavior!
	*/
	STDMETHOD(MarkLine)(ULONG iline, LineMark lm, LineMarkAction lma) PURE;
	STDMETHOD(IsLineMarked)(ULONG iline, LineMark lm) PURE;
	STDMETHOD(FHasOpenView)(VOID) PURE;
	STDMETHOD(SetCaretPosInActiveView)(ULONG iline, ULONG ich, BOOL fSetFocus, BOOL fManageBPFocus) PURE;

	/*
	**	WriteContentsToTempFile	--	Write the current contents of the document to
	**								memory and return a pointer to the beginning of the file.
	**						**	->	NOTE:  THIS MUST BE CALLED FROM THE MAIN THREAD!
	**	ReleaseTempFile			--	Destroy the contents of the temporary file.
	*/
	STDMETHOD(WriteContentsToTempFile)(LPCCH *ppFileContents, ULONG *pcbFile) PURE;
	STDMETHOD(ReleaseTempFile)(VOID) PURE;
	STDMETHOD(SetLexer)(LPCTSTR) PURE;	
	STDMETHOD(GetLXS)(ULONG iLine, ULONG *plxs) PURE;
	STDMETHOD(GetLexer)(LPVOID *plexer) PURE;

	/* Automation interaction */

	STDMETHOD(GetITextDocument)(ITextDocument **pTextDoc) PURE;
	STDMETHOD(GetITextSelection)(ITextSelection **pTextSel) PURE;

	// Debugger will use this function to get a "pseudo-path" for
	// code that doesn't live on the file system (SQL SP's for instance)
	STDMETHOD(GetPseudoPathName)(LPTSTR ppszPathName, ULONG cbBufferSize, ULONG* pcbStrLen) PURE;
	STDMETHOD(SetPseudoPathName)(LPCTSTR pszPathName) PURE;

	// converts a byte index into a line to a view column index (with tabs expanded)
	STDMETHOD(GetIchViewFromIbDoc)(ULONG *plColumn, ULONG ibDoc, ULONG iline) PURE;

	// Is there a selection? S_OK = has active selection : S_FALSE = no selection
	STDMETHOD(FHasSelection)(VOID) PURE;

	// Line # and byte index (Doc coordinates) of selection start/end
	STDMETHOD(GetSelection)(ULONG * pilineStart, ULONG *pulIndexStart, ULONG * pilineEnd, ULONG *pulIndexEnd, BOOL *pbColumnSelection) PURE;

	// converts a view column index (with tabs expanded) into a line to a byte index
	STDMETHOD(GetIbDocFromIchView)(ULONG *plIndex, ULONG ichViewCol, ULONG iline) PURE;

	STDMETHOD(GetSourceBuffer)(THIS_ ULONG iStartLine, ULONG iEndLine, ULONG cbBuffer, LPSTR pBuf, ULONG *pcb) PURE;
};

///////////////////////////////////////////////////////////////////////////////
//	ISourceQuery interface

typedef enum { gbrvUnavailable = -1, gbrvError, gbrvOkay } GetBscRetVal;

#undef INTERFACE
#define INTERFACE	ISourceQuery

typedef enum { CB_FILE_SAVE_AS, CB_FILE_OPEN, CB_FILE_CLOSE, CB_FILE_PRE_SAVE } SOURCE_CALLBACK_TYPE;

typedef void (*pfnFileOpenCallback)(LPCSTR LPCSTRFileName, ULONG iDocID);       // Correspond to the enum above:
typedef void (*pfnFileCloseCallback)(LPCSTR LPCSTRFileName, ULONG iDocID);      // See RegisterEditorCallback
typedef void (*pfnFileSaveAsCallback)(LPCSTR LPCSTRFileName, ULONG iDocID);
typedef void (*pfnFilePreSaveCallback)(LPCTSTR lpctstrFileName, ULONG iDocID, BOOL bSaveAs, int*);

DECLARE_INTERFACE_(ISourceQuery, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	/*
	** ISource methods
	**
	** CreateSourceEditForDoc		-- file may or may not already be open in the editor
	** CreateSourceEditForOpenDoc	-- only succeeds if file is already open in the editor
	** CreateSourceEditForActiveDoc -- returns an interface for the currently active document
	** CreateNewSourceEdit			-- creates a new document with the given name (NULL ok)
	** GotoFileLineCol				-- put the editor at the given file, line, column
	*/

	STDMETHOD(CreateSourceEditForDoc)(THIS_ LPCSTR pctstrFullPath, ISourceEdit **ppISourceEdit, BOOL fWriteable) PURE;
	STDMETHOD(CreateSourceEditForOpenDoc)(THIS_ LPCSTR pctstrFullPath, ISourceEdit **ppISourceEdit, BOOL fWriteable) PURE;
	STDMETHOD(CreateSourceEditForActiveDoc)(THIS_ ISourceEdit **ppISourceEdit, BOOL fWriteable) PURE;
	STDMETHOD(CreateNewSourceEdit)(THIS_ LPCSTR pctstrFullPath, ISourceEdit **ppISourceEdit, BOOL fWriteable) PURE;
	STDMETHOD(GotoFileLineColumn)(THIS_ LPCSTR pctstrFullPath, ULONG iline, ULONG ich) PURE;
	STDMETHOD(GotoFileClassMember)(THIS_ LPCSTR lpszFileName, LPCSTR lpszClassName, LPCSTR lpszMemberName) PURE;
	STDMETHOD(RegisterEditorCallback)(THIS_ void *pfnCallback, SOURCE_CALLBACK_TYPE sct, INT *iHandle) PURE;
	STDMETHOD(UnregisterEditorCallback)(THIS_ INT hCallback, SOURCE_CALLBACK_TYPE sct) PURE;
	STDMETHOD(IsFileOpen)(THIS_ LPCSTR lpstrFullPath) PURE;
	STDMETHOD(IsEmulationVC20)(VOID) PURE;
	STDMETHOD(IsSaveBeforeRunning)(VOID) PURE;
	STDMETHOD(IsPromptBeforeSaving)(VOID) PURE;
	STDMETHOD(FindHeaderFile)(THIS_ LPCSTR lpszFileName, BOOL fUseCurView, LPTSTR pszPathName, ULONG cbPathSize, ULONG* pcbPathLen ) PURE;

	/*
	** FUTURE: This function is used by Test to tell the VC debugger that it is
	** starting or ending a Test debug session. It belongs in an independent interface.
	*/
	STDMETHOD(VTestDebugActive)(THIS_ BOOL *bActive) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IParserDataBase interface

#undef  INTERFACE
#define INTERFACE IParserDataBase

#include <parse.h>
// Non-standard COM.
//////////////////////////////////////////////////////////////////////////////
// CSymbolInfo
//    |_____________________________
//    |             |              |
// CVarInfo   CFunctionInfo   CClassInfo
//
// contains information about a particular info in the database.
// enum, typedef use CSymbolInfo

class CSymbolInfo: public CObject
{
public:
	CString		m_strName;			// name of symbols
	parsetype	m_type;				// type of info: var, function, enum, typedef, class, etc
	BYTE		m_typ;				// parsetype:TYP
	BOOL		m_bConflict;		// used by the CheckForConflictSymbols
public:
	virtual ~CSymbolInfo(){};
};

//////////////////////////////////////////////////////////////////////////////
// CVarSymbol: contains a type as an extra information

class CVarSymbol: public CSymbolInfo
{
public:	
	CString		m_strType;
public:
	virtual ~CVarSymbol(){};
};

//////////////////////////////////////////////////////////////////////////////
// CFunctionSymbol: contains a return type and parameters as info

class CFunctionSymbol: public CSymbolInfo
{
public:
	CStringList 	m_slParams; // parameters
	CString			m_strType;	// return type
public:
	virtual ~CFunctionSymbol(){};
};

//////////////////////////////////////////////////////////////////////////////
// CClassSymbol: contains base classes as an extra info

class CClassSymbol: public CSymbolInfo
{
public:
	CStringList	m_slBaseClasses; // base classes
public:
	virtual ~CClassSymbol(){};
};
	
typedef CList<CSymbolInfo *, CSymbolInfo *&> CSymbolList;

DECLARE_INTERFACE_(IParserDataBase, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IParserDataBase methods
	STDMETHOD(GetGlobalSymbolsFromFiles)(const CStringList &lFileNames, CSymbolList &lSymbols) PURE;
	STDMETHOD(CheckForConflictSymbols)(CSymbolList &lSymbols) PURE;
	STDMETHOD(GetLexer)(const CString &strFileName, HLEXER *phLexer) PURE;
	STDMETHOD(GetLexerAndParser)(const CString &strFileName, HLEXER *phLexer, HPARSER *phParser) PURE;
	STDMETHOD(GetDerivedClass)(CStringList &slClasses, const CString &strBaseClass, UINT hTarget, BOOL bOnlyOne) PURE;
	STDMETHOD(GetInfo)(void *&pSymbolInfo, UINT hTarget) PURE;
	STDMETHOD(GetClassMembers)(CString &strClassName, CStringList &slFunctions, CStringList &slVars, UINT hTarget) PURE;
	STDMETHOD(GetClassList)(CStringList &slClasses, UINT hTarget) PURE;
	STDMETHOD(GetBsc)(int *gbrv, UINT hTarget, HBSC *phBsc) PURE;
	STDMETHOD(IsTerminateThread)() PURE;
	STDMETHOD(GetDBase)(HNCB *phNcbParse) PURE;
	STDMETHOD(IsSuspendThread)() PURE;
	STDMETHOD(NotifyParseDone)(LPCSTR lpszFileName) PURE;
	STDMETHOD(WaitParserSuspended)() PURE;
	STDMETHOD(ReparseTarget)(UINT hTarget) PURE;
	STDMETHOD(ParseFile)(UINT hTarget, CString strFileName) PURE;
	STDMETHOD(GetQSize)(int *piSize) PURE;
	STDMETHOD(GetSuspendHandle)(HANDLE *phSuspend) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IEditDebugStatus interface

#undef  INTERFACE
#define INTERFACE IEditDebugStatus

DECLARE_INTERFACE_(IEditDebugStatus, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IEditDebugStatus methods
	STDMETHOD(GetExecutableFilename)(PSTR executable, UINT size, EXEFROM *piExeFrom) PURE;
	STDMETHOD(GetLastDocWin)(CDocument **ppDocument) PURE; 	// Non-standard COM.
	STDMETHOD(IsSaveBeforeRunningTools)(BOOL *pbQuery) PURE;
	STDMETHOD(ProjectFilesModified)() PURE;
	STDMETHOD(IsGrepRunning)() PURE;
	STDMETHOD(SetLoadNextFileNoPrompt)(BOOL f) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IParser interface

#undef  INTERFACE
#define INTERFACE IParserAssist

DECLARE_INTERFACE_(IParserAssist, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IParserAssist methods
	STDMETHOD(GetLine)(void *pTextDoc, int iLine, LPSTR &pszLine, UINT &uLength, DWORD &lxs) PURE;
	STDMETHOD(RegisterFileToWatch)(CString &strFileName) PURE; 	// Non-standard COM.
	STDMETHOD(UnregisterFileToWatch)(CString &strFileName) PURE; 	// Non-standard COM.
	STDMETHOD(AddToQueue)(const CPath * pPath, HTARGET hTarget, Action action) PURE; // Non-standard COM

	STDMETHOD(SetDynamicParsing) (BOOL fDyParse) PURE;
	STDMETHOD(GetCurrentParseFileBuffer)(LPCCH *ppFileContents, ULONG *pcbFile) PURE;
	STDMETHOD(GetEditorFrame) (HWND *phWndFrame) PURE;
};

/////////////////////////////////////////////////////////////////////////////
//	IOutputWindow interface

#undef  INTERFACE
#define INTERFACE IOutputWindow

DECLARE_INTERFACE_(IOutputWindow, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IOutputWindow methods
	STDMETHOD(ShowOutputWindow)() PURE;
	STDMETHOD(ClearOutputWindow)() PURE;
	STDMETHOD(WriteStringToOutputWindow)(LPCSTR lpszError, BOOL fToolError, BOOL fAppendCrLf) PURE;
	STDMETHOD(OutputWindowQueueHit)(UINT nCommandID, LPCSTR lpszError,
		BOOL fToolError, BOOL fAppendCrLf, BOOL fForceFlush) PURE;
	STDMETHOD(OutputWindowDeleteVwin)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowShowVwin)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowSelectVwin)(UINT nCommandID, BOOL fOnTop) PURE;
	STDMETHOD(OutputWindowAddVwin)(LPSTR szToolName, BOOL fCurrentVwin, UINT *puRet) PURE;
	STDMETHOD(OutputWindowModifyVwin)(UINT nCommandID, LPSTR szToolName, UINT *puRet) PURE;
	STDMETHOD(OutputWindowVwinClear)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowClearWindow)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowClearContents)(UINT nCommandID) PURE;
	STDMETHOD(OutputWindowGetLine)(ULONG iline, ULONG *pcbLine, LPCSTR *ppLine) PURE;
	STDMETHOD(OwinGetBuildCommandID)(UINT *puRet) PURE;
	STDMETHOD(OwinGetDebugCommandID)(UINT *puRet) PURE;
	STDMETHOD(OwinIsBufferFull)(BOOL* fFull) PURE;	
};

/////////////////////////////////////////////////////////////////////////////
//	IFileAccess interface

#undef  INTERFACE
#define INTERFACE IFileAccess

DECLARE_INTERFACE_(IFileAccess, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IFileAccess methods
	STDMETHOD(CreateFile)(LPCTSTR lpszName, DWORD fdwAccess, DWORD fdwShareMode, LPSECURITY_ATTRIBUTES lpsa, DWORD fdwCreate, DWORD fdwAttrsAndFlags, HANDLE hTemplateFile, HANDLE *hRet) PURE;
	STDMETHOD(OpenFile)(const char *pszFileName, const char *pszMode, FILE **ppRet) PURE;
	STDMETHOD(CreateFileForParse)(LPCTSTR lpszName, DWORD fdwAccess, DWORD fdwShareMode, LPSECURITY_ATTRIBUTES lpsa, DWORD fdwCreate, DWORD fdwAttrsAndFlags, HANDLE hTemplateFile, HANDLE *hRet) PURE;
	STDMETHOD(CloseFileForParse)(HANDLE handle) PURE;
	STDMETHOD(Replace)(const char *pszOldName, const char *pszNewName, int *iRet) PURE;
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//	ICustomContextMenu interface
//		Access to custom context menus on a per-language / lexer basis

#undef  INTERFACE
#define INTERFACE ICustomContextMenu

/////////////////////////////////////////////////////////////////////////////
//	forward declaration
struct POPDESC;
typedef POPDESC* LPPOPDESC;


DECLARE_INTERFACE_(ICustomContextMenu, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// ICustomContextMenu methods
	STDMETHOD(GetContextMenu)(THIS_ LPCTSTR, LPPOPDESC*) PURE;
};

#ifdef _SQLDBG
#include "sqlpkapi.h"
#endif // _SQLDBG

#endif	// __SRCAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\shlguid_.h ===
/////////////////////////////////////////////////////////////////////////////
//	SHLGUID_.H
//		Private interface between shell and devaut1

// {2F483CC0-CDE2-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IAutomationItems, 
0x2f483cc0, 0xcde2, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);

// {072169C0-D0FC-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IRecordNotifyShell, 
0x72169c0, 0xd0fc, 0x11cf, 0xad, 0x7, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x65);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\srcguid.h ===
/////////////////////////////////////////////////////////////////////////////
//	SRCGUID.H
//		Source package interface ids.

//	Interface ID for source package
DEFINE_GUID(IID_ISourceQuery, 
	0xA8A111D0,0x54D7,0x11CE,0xA5,0x55,0x00,0xAA,0x00,0x42,0x54,0xC4);

//	Interface ID for source package editing
DEFINE_GUID(IID_ISourceEdit, 
	0xE831F200,0x54DA,0x11CE,0xA5,0x55,0x00,0xAA,0x00,0x42,0x54,0xC4);

// Interface ID for ParserDataBase {CCE64B71-1F6E-11cf-B24F-00AA0057AFF3}
DEFINE_GUID(IID_IParserDataBase,
	0xcce64b71, 0x1f6e, 0x11cf, 0xb2, 0x4f, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for EditDebugStatus {7161AE01-2901-11cf-B250-00AA0057AFF3}
DEFINE_GUID(IID_IEditDebugStatus, 
	0x7161ae01, 0x2901, 0x11cf, 0xb2, 0x50, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for ParserAssist {90D1AE81-29DC-11cf-B250-00AA0057AFF3}
DEFINE_GUID(IID_IParserAssist, 
	0x90d1ae81, 0x29dc, 0x11cf, 0xb2, 0x50, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for OutputWindow {1A26E5E1-2905-11cf-B250-00AA0057AFF3}
DEFINE_GUID(IID_IOutputWindow, 
	0x1a26e5e1, 0x2905, 0x11cf, 0xb2, 0x50, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Interface ID for IFileAccess {51CF0451-4F97-11cf-B257-00AA0057AFF3}
DEFINE_GUID(IID_IFileAccess, 
	0x51cf0451, 0x4f97, 0x11cf, 0xb2, 0x57, 0x0, 0xaa, 0x0, 0x57, 0xaf, 0xf3);

// Class ID for text document {3486698D-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_TextDoc, // was CLSID_TextDocument
	0x3486698d, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Class ID for external text document {EF383AB0-4BF7-11d1-996F-00A0C91BC8E5}
DEFINE_GUID(CLSID_ExtTextDoc, 
0xef383ab0, 0x4bf7, 0x11d1, 0x99, 0x6f, 0x0, 0xa0, 0xc9, 0x1b, 0xc8, 0xe5);

// Class ID for browse document {3486698E-49EB-11cf-BF46-00AA004C12E2}
DEFINE_GUID(CLSID_BrowseDocument, 
	0x3486698e, 0x49eb, 0x11cf, 0xbf, 0x46, 0x0, 0xaa, 0x0, 0x4c, 0x12, 0xe2);

// Interface ID for lang/lexer based custom context menu
DEFINE_GUID(IID_ICustomContextMenu, 
0xe882e260, 0x709c, 0x11cf, 0x89, 0xc0, 0x0, 0xaa, 0x0, 0xbf, 0x5, 0x6);


#ifdef _SQLDBG

// Interface ID for SQL Execution control

DEFINE_GUID(IID_ISqlExec, 
0xfbca3ca2, 0x6abe, 0x11cf, 0x92, 0x81, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x10);

// Interface ID for debugging

DEFINE_GUID(IID_ISrcDebug, 
0x1c3d3480, 0x6ad9, 0x11cf, 0x92, 0x81, 0x0, 0xa0, 0xc9, 0x3, 0x49, 0x10);

#endif // _SQLDBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\tokcpp.h ===
// tokcpp.h - tokens for C++
//
// Include lex.h before including this file.
//

#ifndef __TOKCPP_H__
#define __TOKCPP_H__

enum TOKCPP {	
	tokUNKNOWN = tokclsError,
	tokKEYW_AUTO = tokclsKeyWordMin,
	tokKEYW_BREAK,
	tokKEYW_BOOL,
	tokKEYW_CASE,
	tokKEYW_CATCH,
	tokKEYW_CHAR,
	tokKEYW_CLASS,
	tokKEYW_CONST,
	tokKEYW_CONST_CAST,
	tokKEYW_CONTINUE,
	tokKEYW_DEFAULT,
	tokKEYW_DELETE,
	tokKEYW_DO,
	tokKEYW_DOUBLE,
	tokKEYW_DYNAMIC_CAST,
	tokKEYW_ELSE,
	tokKEYW_ENUM,
	tokKEYW_EXPLICIT,
	tokKEYW_EXTERN,
	tokKEYW_FALSE,
	tokKEYW_FLOAT,
	tokKEYW_FOR,
	tokKEYW_FRIEND,
	tokKEYW_GOTO,
	tokKEYW_IF,
	tokKEYW_INLINE,
	tokKEYW_INT,
	tokKEYW_INTERFACE,
	tokKEYW_LONG,
	tokKEYW_MUTABLE,
	tokKEYW_NAMESPACE,
	tokKEYW_NEW,
	tokKEYW_OPERATOR,
	tokKEYW_PASCAL,
	tokKEYW_PRIVATE,
	tokKEYW_PROTECTED,
	tokKEYW_PUBLIC,
	tokKEYW_REGISTER,
	tokKEYW_REINTERPRET_CAST,
	tokKEYW_RETURN,
	tokKEYW_SHORT,
	tokKEYW_SIGNED,
	tokKEYW_SIZEOF,
	tokKEYW_STATIC,
	tokKEYW_STATIC_CAST,
	tokKEYW_STRUCT,
	tokKEYW_SWITCH,
	tokKEYW_TEMPLATE,
	tokKEYW_THIS,
	tokKEYW_THROW,
	tokKEYW_TRUE,
	tokKEYW_TRY,
	tokKEYW_TYPEDEF,
	tokKEYW_TYPEID,
	tokKEYW_TYPENAME,
	tokKEYW_UNION,
	tokKEYW_UNSIGNED,
	tokKEYW_USING,
	tokKEYW_VIRTUAL,
	tokKEYW_VOID,
	tokKEYW_VOLATILE,
	tokKEYW_WHILE,
	tokKEYW_WMAIN,
	tokKEYW_XALLOC,
	tokKEYW__ASM,
	tokKEYW__ASSUME,
	tokKEYW__BASED,
	tokKEYW__CDECL,
	tokKEYW__DECLSPEC,
	tokKEYW__EXCEPT,
	tokKEYW__FINALLY,
	tokKEYW__FASTCALL,
	tokKEYW__FORCEINLINE,
	tokKEYW__INLINE,
	tokKEYW__INT16,
	tokKEYW__INT32,
	tokKEYW__INT64,
	tokKEYW__INT8,
	tokKEYW__LEAVE,
	tokKEYW__MULTINHERIT,
	tokKEYW__PASCAL,
	tokKEYW__SINGINHERIT,
	tokKEYW__STDCALL,
	tokKEYW__TRY,
	tokKEYW__UNALIGNED,
	tokKEYW__UUIDOF,
	tokKEYW__VIRTINHERIT,
	tokKEYW__MAX,			/* last keyword */

	tokPPKEYW_MIN,			/* min Preprocessor keyword */
	tokPPKEYW_DEFINE,
	tokPPKEYW_ELIF,
	tokPPKEYW_ELSE,
	tokPPKEYW_ENDIF,
	tokPPKEYW_ERROR,
	tokPPKEYW_IF,
	tokPPKEYW_IFDEF,
	tokPPKEYW_IFNDEF,
	tokPPKEYW_IMPORT,
	tokPPKEYW_INCLUDE,
	tokPPKEYW_LINE,
	tokPPKEYW_PRAGMA,
	tokPPKEYW_UNDEF,
	tokPPKEYW_MAX,			/* max Preprocessor keyword */	

	tokDECLKEYW_ALLOCATE,	/* keywords following _declspec */
	tokDECLKEYW_DLLEXPORT,
	tokDECLKEYW_DLLIMPORT,
	tokDECLKEYW_NAKED,
	tokDECLKEYW_NOTHROW,
	tokDECLKEYW_NOVTABLE,
	tokDECLKEYW_PROPERTY,
	tokDECLKEYW_SELECTANY,
	tokDECLKEYW_THREAD,
	tokDECLKEYW_UUID,
	
	tokASSUMEKEYW_EVAL,		// keywords following __assume
	tokASSUMEKEYW_NOEVAL,

	tokPPIFKEYW_DEFINED, 	/* keyword following #if */

	tokPRAGKEYW_ALLOCTEXT,	/* keywords following #pragma */    
	tokPRAGKEYW_AUTOINLINE,
	tokPRAGKEYW_BESTCASE,
	tokPRAGKEYW_CHKPTR,
	tokPRAGKEYW_CHKSTACK,
	tokPRAGKEYW_CODESEG,
	tokPRAGKEYW_COMMENT,
	tokPRAGKEYW_COMPILER,
	tokPRAGKEYW_DATASEG,
	tokPRAGKEYW_DEFAULT,
	tokPRAGKEYW_DISABLE,
	tokPRAGKEYW_ERROR,
	tokPRAGKEYW_EXESTR,
	tokPRAGKEYW_FULLGENERALITY,
	tokPRAGKEYW_FUNCTION,
	tokPRAGKEYW_HDRSTOP,
	tokPRAGKEYW_INITSEG,
	tokPRAGKEYW_INLINEDEPTH,
	tokPRAGKEYW_INLINERECURSE,
	tokPRAGKEYW_INSTRINSIC,
	tokPRAGKEYW_LIB,
	tokPRAGKEYW_LINESIZE,
	tokPRAGKEYW_LOOPOPT,
	tokPRAGKEYW_MESSAGE,
	tokPRAGKEYW_MULINHERIT,
	tokPRAGKEYW_NATIVECALL,
	tokPRAGKEYW_OFF,
	tokPRAGKEYW_ON,
	tokPRAGKEYW_ONCE,
	tokPRAGKEYW_OPTIMIZE,
	tokPRAGKEYW_PACK,
	tokPRAGKEYW_PAGE,
	tokPRAGKEYW_PAGESIZE,
	tokPRAGKEYW_PTRTOMEMBERS,
	tokPRAGKEYW_POP,
	tokPRAGKEYW_PUSH,
	tokPRAGKEYW_SAMESEG,
	tokPRAGKEYW_SETLOCALE,
	tokPRAGKEYW_SINGINHERIT,
	tokPRAGKEYW_SKIP,
	tokPRAGKEYW_STRPOOL,
	tokPRAGKEYW_SUBTITLE,
	tokPRAGKEYW_TITLE,
	tokPRAGKEYW_USER,
	tokPRAGKEYW_VIRTINHERIT,
	tokPRAGKEYW_VTORDISP,
	tokPRAGKEYW_WARNING,
       
	tokDELI_LPAREN = tokclsOpMin,			// ( 
	tokDELI_RPAREN,							// ) 
	tokDELI_LBKT,							// [ 
	tokDELI_RBKT,							// ] 

	tokOP_COMA,								// ,    
	tokOP_DOT,								// .    
	tokOP_DOTSTAR,							// .*    
	tokOP_SCOLON,							// ;    
	tokOP_TILDE	,							// ~    
	tokOP_QUEST,							// ?    

	tokOP_NOT,								// !    
	tokOP_NOTEQ,							// !=   
	tokOP_MOD,								// %    
	tokOP_MODEQ,							// %=   
	tokOP_AND,								// &   
	tokOP_ANDAND,							// &&  
	tokOP_ANDEQ,							// &=  
	tokOP_MUL,								// *   
	tokOP_MULEQ,							// *=  
	tokOP_ENDCOMMENT,						// */  
	tokOP_PLUS,								// +   
	tokOP_INC,								// ++  
	tokOP_PLUSEQ,							// +=  
	tokOP_MINUS,							// -   
	tokOP_DECR,								// --  
	tokOP_MINUSEQ,							// -=  
	tokOP_DIV,								// /   
	tokOP_DIVEQ,							// /=  
	tokOP_BEGINCOMMENT,						// /*  
	tokOP_LT,								// <   
	tokOP_LSHIFT,							// <<  
	tokOP_LEQ,								// <=  
	tokOP_ASGN,								// =   
	tokOP_EQ,								// ==  
	tokOP_GT,								// >   
	tokOP_RSHIFT,							// >>  
	tokOP_GEQ,								// >=  
	tokOP_XOR,								// ^   
	tokOP_XOREQ,							// ^=  
	tokOP_OR,								// |   
	tokOP_OROR,								// ||  
	tokOP_OREQ,								// |=  
	tokOP_COLON,							// :
	tokOP_DCOLON,							// ::    
	tokOP_ARROW,							// ->  
	tokOP_ARROWSTAR,						// ->* 
	tokOP_RSHIFTEQ,							// >>= 
	tokOP_LSHIFTEQ,							// <<= 
	tokDELI_LCBKT = tokclsOpSpecOpenBlock,	// { 
	tokDELI_RCBKT = tokclsOpSpecCloseBlock,	// } 
	tokOP_MAX,								// token op MAX

	tokOP_LINECMT =  tokclsOpSpecLineCmt,	// line comment

	tokIDENTIFIER = tokclsIdentMin,			// identifier
	tokNUMBER = tokclsConstInteger,			// number const
	tokREAL = tokclsConstReal,
	tokSTRING = tokclsConstString,			// string
	tokBEGINSTRING,
	tokCHAR,
	tokSTRINGERR,

	tokCOMMENT = tokclsCommentMin,			// comment

	tokWIZ = tokclsUserMin,					//return this token  if we are in the wizard modified code,
	tokNEWLINE,
	tokFILENAME,							// <filename> after #define
	tokUSERDEFKW,
	tokEOF
};

#endif // __TOKCPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\about.h ===
/////////////////////////////////////////////////////////////////////////////
// About Box and Splash Screen
//

void ShowSplashScreen(BOOL bShow);
CWnd *PwndSplashScreen(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\utilapi.h ===
#ifndef __UTILAPI_H__
#define __UTILAPI_H__

interface ISrcUtil;

typedef ISrcUtil*   PSRCUTIL;

/////////////////////////////////////////////////////////////////////////////
//  ISrcUtil interface
//      Allow the new debugger package access to the general utility routines

#undef INTERFACE
#define INTERFACE ISrcUtil

// Source environment settings.
#define ENV_HSCROLL                     1
#define ENV_VSCROLL                     2
#define ENV_ENABLE_MARGIN_GLYPHS        3
#define ENV_CX_DEFAULT_SELECT_MARGIN    4
#define ENV_PROMPT_BEFORE_SAVE          5
#define ENV_ENABLE_AUTO_COMPLETE		6
#define ENV_ENABLE_AUTO_COMMENTS		7
#define ENV_ENABLE_QUICK_INFO			8
#define ENV_ENABLE_PARAMETER_HELP		9
//#define ENV_AUTO_COMMENTS_TAGS		8

// Source color settings
#define CLR_TEXT                        0
#define CLR_CURRENTLINE                 1
#define CLR_COMMENT                     2
#define CLR_BREAKPT                     3

// CTextDoc Callback values
#define DCB_CLOSE                       1

class CIDEView;

DECLARE_INTERFACE_(ISrcUtil, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	/*
	** ISrcUtil
	**
	*/

    STDMETHOD_(BOOL, RECompare)(LPSTR sz, PSTR szRE) PURE;
    
	STDMETHOD_(BOOL, StatusText)(UINT uID, UINT uType, BOOL fForceUpdate) PURE;

    STDMETHOD_(BOOL, HandleBuildStateChange)(void) PURE;
    STDMETHOD_(BOOL, HandleProjectStateChange)(void) PURE;
    STDMETHOD_(BOOL, DebuggeeStateModified)(void) PURE;
    STDMETHOD_(BOOL, ProjectStateModified)(void) PURE;
    STDMETHOD_(BOOL, ClearAllDocStatus)(UINT state) PURE;
    STDMETHOD_(BOOL, ResetProjectState)(void) PURE;
	STDMETHOD_(BOOL, InitProjectState)(void) PURE;

    STDMETHOD_(FMT_ELEMENT *, GetSourceColor)(UINT) PURE;

    STDMETHOD_(DWORD, GetSrcEnvironParam)(UINT) PURE;

    STDMETHOD_(BOOL, SetLineStatus)(CDocument *, LONG, UINT, UINT, BOOL, BOOL) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, FindLineStatus)(CDocument *, UINT, BOOL, LONG *) PURE; 	// Non-standard COM.
    STDMETHOD_(USHORT, GetLStat)(CDocument *, LONG) PURE; 	// Non-standard COM.

    STDMETHOD_(BOOL, GetCurrentText)(CView *, BOOL *, LPSTR, ULONG, ULONG *, ULONG *) PURE; 	// Non-standard COM.

    STDMETHOD_(BOOL, LoadDocument)(LPCSTR, FARPROC) PURE;
    STDMETHOD_(BOOL, FindDocument)(LPCSTR, CDocument **, BOOL) PURE; 	// Non-standard COM.
    STDMETHOD_(CView *, GetCurTextView)(void) PURE; 	// Non-standard COM.
    STDMETHOD_(CView *, FirstView)(CDocument *) PURE; 	// Non-standard COM.
    STDMETHOD_(CView *, FindTextDocActiveView)(CDocument *) PURE; 	// Non-standard COM.
    STDMETHOD_(CDocument *, GetDocFromHsf)(void *) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, Select)(CView *, INT, INT, BOOL) PURE; 	// Non-standard COM.
    
	STDMETHOD_(BOOL, ResetDocMod)(void) PURE;
    STDMETHOD_(void *, GetHSF)(CDocument *) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, SetHSF)(CDocument *, void *) PURE; 	// Non-standard COM.
    
	STDMETHOD_(BOOL, ViewBelongsToSrc)(CView *) PURE; 	// Non-standard COM.
    STDMETHOD_(INT, GetCurrentLine)(CView *) PURE; 	// Non-standard COM.
    STDMETHOD_(CDocument *, GetDocFromFileName)(PCSTR) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, ThingyForBFHFindDoc)(CDocument **, CPath &) PURE; 	// Non-standard COM.
    STDMETHOD_(BOOL, ActivateTextDoc)(LPCSTR, INT) PURE;
	STDMETHOD(CreateSourceEditForHSF)(THIS_ void * hsf, ISourceEdit **ppISourceEdit) PURE;
	STDMETHOD(SetCallback)(THIS_ CDocument *, FARPROC) PURE;

	// This is used by the debugger to find non-disk based files
	// through the ISourceEdit::GetPseudoPath method
	STDMETHOD(CreateSourceEditFromDoc)(THIS_ CDocument* pDoc, ISourceEdit **ppISourceEdit, BOOL fWriteable) PURE;
	STDMETHOD(LoadNonDiskDocument)(LPCTSTR szName, CDocument** ppDoc) PURE;
#ifdef AUTO_COMPLETE
	// TODO: this method should be replaced by one that is more general. [t-mashra]
    STDMETHOD(GetCurFontDimensions)(UINT &, UINT &) PURE; 	// Non-standard COM.
#endif // AUTO_COMPLETE

    // Edit-n-Continue support
    STDMETHOD_(BOOL, ENCStateModified)(void) PURE;
    STDMETHOD_(BOOL, GetSrcPathsForENC)(CStringList *plstPath) PURE; // Non-standard COM.

	// Identifier info for AutoCompletion/NCB
	STDMETHOD (CreateQuickInfoForIdentifier) (LPCTSTR lpstrIdent) PURE;
};

#endif // __UTILAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\wizapi.h ===
#ifndef _WIZAPI_
#define _WIZAPI_

interface IBuildProject;		// Defined in pkgs\include\auto\bldauto.h, used in
						// IBuildWizard::GetAutoProject.

// Wizard interface declarations for language-independent pieces

// these are all real basic interfaces

interface IWizardNode;		// base for all Wizard nodes
interface IWizardTransaction;	// used for tracking transactions to allow commit & abort
interface IWizardItem;		// base for all Wizard instances
interface IWizardListNode;	// services for Wizard lists
interface IWizardStrings;	// handles lists of strings returned from various queries
interface IWizardIntegers;	// handles lists of integers returned from various queries
interface IWizardEnum;		// handles lists of COM objects returned from various queries
interface IWizardParser;	// all language specific things deal with this

// these interfaces help during the execution of a transaction
interface IWizManageValues;	// used to manage template macros
interface IWizAddFiles;		// used to add files to the project
interface IWizAddResources;	// used to add resources to the project
interface IWizExpandTemplates;	// used to expand templates into the project

// these interfaces are used to communicate between the wizard model and external
// wizards that use this model
interface IVCSimpleWizard;	// external wizards need to expose this interface
interface IVCWizardContext;	// this interface gives external wizards the context from which they're run

// these interfaces are used to handle AppObjects

#ifdef NOT_YET
interface IAppObjectNode;	// use for determining AppObjects in project
interface IAppObject;		// basis for all AppObjects
interface IAppObjectPart;	// all AppObjects consist of a series of these
#endif // NOT_YET

// Language specific interfaces

interface ILanguageNode;
interface ILanguageNodes;
interface ILanguageItem;
interface ILanguageModule;
interface ILanguageClassNode;
interface ILanguageClass;
interface ILanguageFunction;
interface ILanguageVariable;
interface ILanguageEnum;
interface ILanguageTypedef;
interface ILanguageMap;
interface ILanguageMapItem;
interface ILanguageMacro;
interface ILanguageItems;

// use to create a new class

#ifdef NOT_YET
interface ICreateClasses;
#endif // NOT_YET

// interface pointer types (some are left out on purpose)

typedef IWizardNode* LPWIZARDNODE;
typedef IWizardTransaction* LPWIZARDTRANSACTION;
typedef IWizardEnum* LPWIZARDENUM;
typedef IEnumVARIANT* LPENUMVARIANT;
typedef IWizardStrings* LPWIZARDSTRINGS;
typedef LPWIZARDSTRINGS LPFILES;
typedef LPWIZARDSTRINGS LPCLASSNAMES;
typedef IWizardIntegers* LPWIZARDINTEGERS;
typedef ILanguageNode* LPLANGUAGENODE;
typedef ILanguageNodes* LPLANGUAGENODES;
typedef ILanguageItem* LPLANGUAGEITEM;
typedef ILanguageModule* LPLANGUAGEMODULE;
typedef ILanguageClassNode* LPLANGUAGECLASSNODE;
typedef ILanguageClass* LPLANGUAGECLASS;
typedef ILanguageFunction* LPLANGUAGEFUNCTION;
typedef ILanguageVariable* LPLANGUAGEVARIABLE;
typedef ILanguageEnum* LPLANGUAGEENUM;
typedef ILanguageTypedef* LPLANGUAGETYPEDEF;
typedef ILanguageMap* LPLANGUAGEMAP;
typedef ILanguageMapItem* LPLANGUAGEMAPITEM;
typedef ILanguageMacro* LPLANGUAGEMACRO;
typedef ILanguageItems* LPLANGUAGEITEMS;
typedef ILanguageItems ILanguageClasses;
typedef LPLANGUAGEITEMS LPLANGUAGECLASSES;
typedef ILanguageItems ILanguageFunctions;
typedef LPLANGUAGEITEMS LPLANGUAGEFUNCTIONS;
typedef ILanguageItems ILanguageVariables;
typedef LPLANGUAGEITEMS LPLANGUAGEVARIABLES;
typedef LPLANGUAGEITEMS LPLANGUAGEENUMS;
typedef LPLANGUAGEITEMS LPLANGUAGETYPEDEFS;
typedef LPLANGUAGEITEMS LPLANGUAGEMAPS;
typedef ILanguageItems ILanguageMapItems;
typedef LPLANGUAGEITEMS LPLANGUAGEMAPITEMS;
typedef LPLANGUAGEITEMS LPLANGUAGEMACROS;
#ifdef NOT_YET
typedef IAppObjectNode* LPAPPOBJECTNODE;
typedef IAppObject* LPAPPOBJECT;
typedef IAppObjectPart* LPAPPOBJECTPART;
typedef ICreateClasses* LPCREATECLASSES;
#endif // NOT_YET

// name types
#define dxWizFullName			0x0001		// w/ parameters if a function
#define dxWizScoped				0x0002		// name with scoping info
#define dxWizExtendProp			0x0004		// name extends propget or proput

// used for backward compatibility
#define dxWizScopedFullName		(dxWizScoped|dxWizFullName)
#define dxWizScopedShortName	(dxWizScoped)
#define dxWizNoScopeFullName	(dxWizFullName)
#define dxWizNoScopeShortName	0x0000

// access flags
// NOTE: we are expecting the first four elements to be 0 - 4 as these values are being used
// for array indices.  DO NOT ADD THINGS IN THE MIDDLE WITHOUT CHECKING WHAT YOU HAVE AFFECTED.
#define dxWizAccessDontCare         (0)
#define dxWizAccessPublic           (1)
#define dxWizAccessProtected        (2)
#define dxWizAccessPrivate          (3)
#define dxWizAccessJavaProtected    (4)         // protected means something different in Java, we need a different glyph
#define dxWizAccessDefault          (5)

// file types and 'include' variations
#define dxWizDefinition			0x0001
#define dxWizDeclaration		0x0002
#define dxWizMemberDefinitions	0x0004	// file the members of a class are defined in (the .cpp for a class)
#define dxWizMemberDeclarations	0x0008	// file the members of a class are declared in (the .h for a class)
#define dxWizProjectInclude		0x0010	// typically, stdafx.h
#define dxWizGlobalItem			0x0020	// use this to get the #include file for a global func or var 
#define dxWizFileInclude		0x0040	// use this to put an #include in a particular file
#define dxWizInclude			0x0080	// it's an include
#define dxWizImport				0x0100	// it's an import
#define dxWizImportlib			0x0200	// it's an importlib
#define dxWizAllFileTypes		0x0FFF

// these flags are for determining scope for IDL/ODL import/importlib inclusion
// we need to be able to OR them with dxWizImport and dxWizImportlib
#define dxWizFileScope			0x1000	// it's at file scope (matters only for IDL/ODL)
#define dxWizLibraryScope		0x2000	// it's at library scope (matters only for IDL/ODL)
#define dxWizObjectScope		0x4000	// it's at the scope of whatever object we resolved the filename for

// file existence types
#define dxWizFileExist			0x00000001	// the file already exists
#define dxWizFileInProject		0x00000002	// the file is already in the project
#define dxWizFileInsertIface	0x00010000	// insert an interface appropriately into IDL/ODL
#define dxWizFileInsertCoclass	0x00020000	// insert a coclass appropriately into IDL/ODL

// parsing status
#define dxWizNoParseInfo		1	// no parsing info available
#define dxWizParsing			2	// in the middle of parsing
#define dxWizParseDone			3	// finished parsing

// location & hint types
#define dxWizHintNone			0x0000	// no hint
#define dxWizFilePathDontCare	0x0000	// yes, we want this to be default...
#define dxWizStart				0x0001	// start of whatever it is
#define dxWizEnd				0x0002	// end of whatever it is
#define dxWizHintCOM			0x0004	// it's a COM thingie (like STDMETHOD)
#define dxWizHintLineNumber		0x0008	// hint is a line number
#define dxWizFilePathAbsolute	0x0100	// absolute path
#define dxWizFilePathRelative	0x0200	// relative to project directory
#define dxWizFilePathSimple		0x0400	// just the file name, no directories
#define dxWizName				0x0800	// want the name of whatever it is
#define dxWizHintGlobalScope	0x1000	// want the thing at global scope
#define dxWizHintCodeStart		0x2000	// want start of file, below any #includes, etc.
#define dxWizDoIndents			0x4000	// want the code we're inserting to be indented like auto-indent would do
#define dxWizClassWiz			0x8000	// want whatever it is to be compatible with ClassWizard comments

// ActiveX association types
#define dxWizNothing			0x00000	// current item has no association
	// need to be able to OR these types with dxWizFunction and dxWizVariable
#define dxWizProperty			0x00001	// current item, variable or function, is actually a property
#define dxWizPropertyNotify		0x00002	// current item is a property change notification function
#define dxWizMethod				0x00004	// current item is a function

// generic association major types
#define dxWizActiveXMatch		0x00010	// ActiveX assoc present
#define dxWizActiveXMissing		0x00020	// would be present for ActiveX assoc if wasn't missing
#define dxWizActiveXNone		0x00040	// not related to ActiveX assoc

// some basic types
#define dxWizNormal				0x00000	// can be anything
#define dxWizVariable			0x00100	// variable
#define dxWizFunction			0x00200	// function
#define dxWizCoclass			0x00400	// coclass
#define dxWizInterface			0x00800	// interface
#define dxWizClass				0x01000	// class
#define	dxWizTemplate			0x02000	// it is ok for this thing to be a template
#define dxWizDispinterface		0x04000	// dispinterface
#define dxWizLibrary			0x08000	// library
#define dxWizEnum				0x00001	// enum	-- never OR'ed with other type flags
#define dxWizTypedef			0x00002	// typedef -- never OR'ed with other type flags
#define dxWizMap				0x00003	// map -- never OR'ed with other type flags
#define dxWizMacro				0x00004	// macro -- never OR'ed with other type flags

// these are expected to be just barely smaller than the allowable range
#define dxWizDefEndLine			-1					// last line of the definition
#define dxWizModEndLine			dxWizDefEndLine-1	// last line of the module
#define dxWizEndOfLine			-1					// last column of the line
#define dxWizDefBeginLine		dxWizModEndLine-1	// first line of the definition (for func, mostly)

// file access types
#define dxWizModeRead			0	// read access
#define dxWizModeWrite			1	// read/write access

// symbol types
#define dxWizIntrinsic			1	// this is an intrinsic word in the language ('class', 'int', etc.)
#define dxWizMFCName			2	// belongs to MFC (class name, etc.)

// Open flags for working with the rc file
#define dxWizOpenAlwaysRC   (0)
#define dxWizCreateNewRC    (1)
#define dxWizOpenExistingRC (2)

/////////////////////////////////////////////////////////////////////////////
// IWizardNode
//   This is the primary interface on a base Wizard node.

#undef  INTERFACE
#define INTERFACE IWizardNode
DECLARE_INTERFACE_(IWizardNode, IDispatch)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// IWizardNode methods
	STDMETHOD(GetVersion)(THIS_ long FAR* pnMajor, long FAR* pnMinor) PURE;
	STDMETHOD(CheckVersion)(THIS_ long nMajor, long nMinor) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(FindInterfacesOfType)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterfaceCollection) PURE;
	STDMETHOD(StartTransaction)(THIS_ LPWIZARDTRANSACTION FAR* ppvTransaction) PURE;
	STDMETHOD(WaitOnParser)(THIS) PURE;
	STDMETHOD(put_DefaultConfiguration)(THIS_ LPCTSTR lpszConfig) PURE;
	STDMETHOD(get_ProjectName)(THIS_ BSTR FAR* pbstrProjName) PURE;
	STDMETHOD(IsObjectInProject)(THIS_ LPCTSTR lpszObjName, BOOL FAR* pbInProj) PURE;
	STDMETHOD(MakeRelative)(THIS_ LPCTSTR lpszOrigPath, LPCTSTR lpszRelativeWhat, BSTR FAR* pbstrRelativePath) PURE;
	STDMETHOD(GetSelectedProject)(THIS_ HTARGET FAR* phTarget) PURE;
	STDMETHOD(GetBuildProject)(THIS_ HTARGET hTarget, IBuildProject FAR* FAR* pBuildProject) PURE;
	STDMETHOD(GetProjectType)(THIS_ HTARGET hTarget, int FAR* pnProjType) PURE;
	STDMETHOD(GetProjectDirectory)(THIS_ HTARGET hTarget, BSTR FAR* pbstrProjDir) PURE;
	STDMETHOD(GetCodeManagerLocation)(THIS_ BSTR FAR* pbstrCodeMgrLoc) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IVCSimpleWizard
//   This interface is exposed by external wizards that use the wizard model.

#undef  INTERFACE
#define INTERFACE IVCSimpleWizard
DECLARE_INTERFACE_(IVCSimpleWizard, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IVCSimpleWizard methods.
	STDMETHOD(CanRunWizard)(THIS_ IWizardNode* lpWizardNode, IVCWizardContext* lpWizardContext, UINT nMsgID,
		IWizardTransaction* pTransaction, BOOL FAR* pbCanRun) PURE;	// called wizard MUST release both lpWizardNode and lpWizardContext
	STDMETHOD(RunWizard)(THIS_ IWizardNode* lpWizardNode, IVCWizardContext* lpWizardContext, UINT nMsgID,
		IWizardTransaction* pTransaction) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IVCWizardContext
//   This interface provides the means for external wizards that use the wizard model to determine
//	 what their context is.

#undef  INTERFACE
#define INTERFACE IVCWizardContext
DECLARE_INTERFACE_(IVCWizardContext, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IVCWizardContext methods.
	// assumes context is for a single object
	STDMETHOD(GetContextType)(THIS_ long FAR* pnContextType) PURE;
	STDMETHOD(GetContextObject)(THIS_ LPDISPATCH FAR* pvContextObject) PURE;
	STDMETHOD(GetContextProjectName)(THIS_ BSTR FAR* pbstrProjectName) PURE;
	STDMETHOD(GetContextProjectCookie)(THIS_ HTARGET FAR* phTarget) PURE;
	STDMETHOD(GetContextLanguage)(THIS_ BSTR FAR* pbstrLanguage) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IWizardStrings
//   This interface provides access to generic lists of Wizard string data.

#undef  INTERFACE
#define INTERFACE IWizardStrings
DECLARE_INTERFACE_(IWizardStrings, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
 	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// IWizardStrings methods
	STDMETHOD(GetListType)(THIS_ long FAR* pnListType) PURE;
	STDMETHOD(Find)(THIS_ LPCTSTR lpszElement, BOOL bPartialMatch, BSTR FAR* pbstrActualElement) PURE;
	STDMETHOD(_NewEnum)(IEnumVARIANT **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IWizardIntegers
//   This interface provides access to generic lists of Wizard string data.

#undef  INTERFACE
#define INTERFACE IWizardIntegers
DECLARE_INTERFACE_(IWizardIntegers, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// IWizardIntegers methods
	STDMETHOD(GetListType)(THIS_ long FAR* pnListType) PURE;
	STDMETHOD(Next)(THIS_ long FAR* pnElement) PURE;
	STDMETHOD(Skip)(THIS_ long nSkipNumber) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Find)(THIS_ long nElement, BOOL bPartialMatch, long FAR* pnActualElement) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IWizardEnum
//   This interface provides access to generic lists of Wizard objects.

#undef  INTERFACE
#define INTERFACE IWizardEnum
DECLARE_INTERFACE_(IWizardEnum, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// IWizardEnum methods
	STDMETHOD(Next)(THIS_ LPVOID FAR* ppvObj) PURE;
	STDMETHOD(Skip)(THIS_ long nSkipNumber) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(Find)(THIS_ LPCTSTR lpszElementName, BOOL bPartialMatch, LPVOID FAR* ppvObj) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IWizardTransaction
//   This interface handles transaction management for other Wizard APIs (i.e., bail out capability).
//	 'begin transaction' is implicit in creating one of these

#undef  INTERFACE
#define INTERFACE IWizardTransaction
DECLARE_INTERFACE_(IWizardTransaction, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// IWizardTransaction methods
	STDMETHOD(CommitTransaction)(THIS_ BOOL bRemember) PURE;
	STDMETHOD(AbortTransaction)(THIS) PURE;
	STDMETHOD(CreateTemplate)(THIS_ LPSTREAM lpStm, IWizExpandTemplates FAR** ppvObj) PURE;	// similar to Gallery's CreateTemplateFromText
#ifdef NOT_YET
	// very probably V6 work:
	STDMETHOD(SetCheckPoint)(THIS) PURE;
	STDMETHOD(get_CheckPointNumber)(THIS_ long FAR* nCheckPointNumber);
	STDMETHOD(Rollback)(THIS_ long nCheckPointNumber);
#endif	// NOT_YET
};

/////////////////////////////////////////////////////////////////////////////
// IWizManageValues
//   This interface allows interaction with the value table.

#undef  INTERFACE
#define INTERFACE IWizManageValues
DECLARE_INTERFACE_(IWizManageValues, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Value interaction
	STDMETHOD(AddValue)(THIS_ LPCSTR pszKey, LPCSTR pszValue) PURE;
	STDMETHOD(GetValue)(THIS_ LPCSTR pszKey, BSTR FAR* pbstrValue) PURE;
	STDMETHOD(SetValue)(THIS_ LPCSTR pszKey, LPCSTR pszValue) PURE;
	STDMETHOD(RemoveValue)(THIS_ LPCSTR pszKey) PURE;
	STDMETHOD(ClearValues)(THIS) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IWizAddFiles
//   This interface on a transaction object is used to interact with the
//   project.  i.e. add/enumerate files, etc.

#undef  INTERFACE
#define INTERFACE IWizAddFiles
DECLARE_INTERFACE_(IWizAddFiles, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Filename methods.
	STDMETHOD(CalculateFilename)(THIS_ LPCSTR pszFilename, BSTR FAR* pbstrNewFilename) PURE;
	STDMETHOD(SaveFilename)(THIS_ LPCSTR pszDesiredFilename, LPCSTR pszActualFilename) PURE;
	STDMETHOD(AddFile)(THIS_ LPCSTR pszFilename) PURE;
	STDMETHOD(CalculateFilenameEx)(THIS_ LPCSTR pszFilename, BSTR FAR* pbstrNewFilename, 
		long* pnHint) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IWizAddResources
//   This interface on a transaction object is used to interact with
//   the project's resource script.

#undef  INTERFACE
#define INTERFACE IWizAddResources
DECLARE_INTERFACE_(IWizAddResources, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	// Resource methods.
	STDMETHOD(Create)(THIS_ UINT nCreateFlags) PURE;
	STDMETHOD(GetResourceInclude)(THIS_ BSTR FAR* pbstrFilename) PURE;

	STDMETHOD(AttachResourceStream)(THIS_ LPSTREAM lpStream) PURE;
	STDMETHOD(CreateSymbol)(THIS_ LPCSTR pszID, BSTR FAR* pbstrActualID, int FAR* pnIDValue) PURE;
	STDMETHOD(CreateResource)(THIS_ LPCSTR pszType, LPCSTR pszID, int nLangID, LPCSTR szCondition, 
		LPCSTR pszNewID) PURE;
	STDMETHOD(ImportResource)(THIS_ LPCSTR pszType, LPCSTR pszID, LPCSTR pszFileName, int nLangID, 
		LPCSTR szCondition) PURE;
	STDMETHOD(SetResourceID)(THIS_ LPCSTR pszType, LPCSTR pszOldID, int nLangID, LPCSTR szCondition, 
		LPCSTR pszNewID) PURE;
	STDMETHOD(CreateString)(THIS_ LPCSTR pszID, int nLangID, LPCSTR szCondition, LPCSTR pszString) PURE;
	STDMETHOD(Access)(THIS_ UINT nMode) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IWizExpandTemplates
//   This interface is used to interact with templates.

#undef  INTERFACE
#define INTERFACE IWizExpandTemplates
DECLARE_INTERFACE_(IWizExpandTemplates, IUnknown)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;

	STDMETHOD(Render)(THIS_ LPSTREAM lpStm, IWizardTransaction FAR* lpWT) PURE;
	STDMETHOD(RenderIntoFile)(THIS_ LPCTSTR szFileName, long nHint, IWizardTransaction FAR * lpWT) PURE;
};


#ifdef NOT_YET
/////////////////////////////////////////////////////////////////////////////
// IAppObjectNode
//   This interface exposes the application objects present in the current workspace.

#undef  INTERFACE
#define INTERFACE IAppObjectNode
DECLARE_INTERFACE_(IAppObjectNode, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// IAppObjectNode methods
	STDMETHOD(GetOneAppObject)(THIS_ LPCTSTR lpszKind, LPCTSTR lpszAppObjectName, 
		LPAPPOBJECT FAR* ppvAppObject) PURE;
	STDMETHOD(GetAllAppObjectsOfType)(THIS_ LPCTSTR lpszKind, LPWIZARDENUM FAR* ppvWizardEnum) PURE;
	STDMETHOD(GetAllAppObjects)(THIS_ LPCTSTR lpszKind, LPWIZARDENUM FAR* ppvWizardEnum) PURE;
	STDMETHOD(Add)(THIS_ LPCTSTR lpszContext, LPCTSTR lpszKind, LPCTSTR lpszName) PURE;
	STDMETHOD(Delete)(THIS_ LPAPPOBJECT ppvAppObject) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IAppObject
//   This is an interface to an application object present in the current workspace.

#undef  INTERFACE
#define INTERFACE IAppObject
DECLARE_INTERFACE_(IAppObject, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// IAppObject methods
	STDMETHOD(Next)(THIS_ LPVOID FAR* ppvObj) PURE;
	STDMETHOD(Skip)(THIS_ long nSkipNumber) PURE;
	STDMETHOD(Reset)(THIS) PURE;
	STDMETHOD(FindByName)(THIS_ LPCTSTR lpszAppObjectName, LPAPPOBJECTPART FAR* ppvAppObjectPart) PURE;
	STDMETHOD(FindByType)(THIS_ LPCTSTR lpszAppObjectType, LPAPPOBJECTPART FAR* ppvAppObjectPart) PURE;
	STDMETHOD(FindByKind)(THIS_ LPCTSTR lpszAppObjectKind, LPAPPOBJECTPART FAR* ppvAppObjectPart) PURE;
	STDMETHOD(get_Kind)(THIS_ BSTR FAR* pbstrKind) PURE;
	STDMETHOD(get_Context)(THIS_ BSTR FAR* pbstrContext) PURE;
	STDMETHOD(put_Context)(THIS_ LPCTSTR lpszContext) PURE;
	STDMETHOD(Add)(THIS_ LPCTSTR lpszPartType, LPCTSTR lpszPartName, LPCTSTR lpszPartKind) PURE;
	STDMETHOD(Delete)(THIS_ LPAPPOBJECTPART ppvAppObjectPart) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// IAppObjectPart
//   This is an interface to get to a piece of an application object.

#undef  INTERFACE
#define INTERFACE IAppObjectPart
DECLARE_INTERFACE_(IAppObjectPart, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// IAppObjectPart methods
	STDMETHOD(get_Type)(THIS_ BSTR FAR* pbstrAppObjectType) PURE;
	STDMETHOD(put_Type)(THIS_ LPCTSTR lpszAppObjectType) PURE;
	STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrAppObjectName) PURE;
	STDMETHOD(put_Name)(THIS_ LPCTSTR lpszAppObjectName) PURE;
	STDMETHOD(get_Kind)(THIS_ BSTR FAR* pbstrAppObjectKind) PURE;
	STDMETHOD(put_Kind)(THIS_ LPCTSTR lpszAppObjectKind) PURE;
};
#endif	// NOT_YET

/////////////////////////////////////////////////////////////////////////////
// ILanguageNodes
//   This is an interface to get to the set of ILanguageNode interfaces in the workspace

#undef  INTERFACE
#define INTERFACE ILanguageNodes
DECLARE_INTERFACE_(ILanguageNodes, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageNodes methods
	STDMETHOD(get_ParseStatus)(THIS_ short FAR* pnParseStatus) PURE;
	STDMETHOD(get_ParseFilesLeft)(THIS_ int FAR* pnParseFiles) PURE;
	STDMETHOD(put_DefaultConfiguration)(THIS_ LPCTSTR lpszConfig) PURE;
 	STDMETHOD(GetLanguageNode)(THIS_ LPCTSTR lpszName, LPLANGUAGENODE FAR* ppvLangNode) PURE;
 	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(_NewEnum)(IEnumVARIANT **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ILanguageNode
//   This is an interface to get to language specific stuff.  Current focus: C++

#undef  INTERFACE
#define INTERFACE ILanguageNode
DECLARE_INTERFACE_(ILanguageNode, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageNode methods
	STDMETHOD(get_LanguageName)(THIS_ BSTR FAR* bstrLanguageName) PURE;
	STDMETHOD(GetVersion)(THIS_ long FAR* pnMajor, long FAR* pnMinor) PURE;
	STDMETHOD(CheckVersion)(THIS_ long nMajor, long nMinor) PURE;
	STDMETHOD(EnumAllWizardTypes)(THIS_ long nScopeType, LPWIZARDINTEGERS FAR* ppvWizardIntegers) PURE;
	STDMETHOD(GetAllNamesOfType)(THIS_ long nScopeType, LPCTSTR lpszScopeName, long nType, 
		LPWIZARDSTRINGS FAR* ppvWizardStrings) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(get_ParseStatus)(THIS_ short FAR* pnParseStatus) PURE;
	STDMETHOD(get_ParseFilesLeft)(THIS_ int FAR* pnParseFiles) PURE;
	STDMETHOD(GetSelectedProject)(THIS_ HTARGET FAR* phTarget) PURE;
	STDMETHOD(ParseName)(THIS_ long nParseType, LPCTSTR lpszParseString, BSTR FAR* pbstrResponse) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ILanguageItem
//   This is a generic base interface to get to language specific items.  Current focus: C++

#undef  INTERFACE
#define INTERFACE ILanguageItem
DECLARE_INTERFACE_(ILanguageItem, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageItem methods
	STDMETHOD(EnumAllWizardTypes)(THIS_ long nScopeType, LPCTSTR lpszScopeName, 
		LPWIZARDINTEGERS FAR* ppvWizardIntegers) PURE;
	STDMETHOD(GetAllNamesOfType)(THIS_ long nScopeType, LPCTSTR lpszScopeName, 
		long nWizardType, LPWIZARDSTRINGS FAR* ppvWizardStrings) PURE;
	STDMETHOD(GetName)(THIS_ short nNameType, BSTR FAR* bstrName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_AllAttributes)(THIS_ BSTR FAR* bstrName) PURE;
	STDMETHOD(get_FileName)(THIS_ long nFileType, short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(GetAllObjectsOfType)(THIS_ long nWizardMajorType, long nWizardMinorType, LPCTSTR lpszExtra,
		LPDISPATCH FAR* ppvWizardEnum) PURE;
	STDMETHOD(GetObjectOfType)(THIS_ long nWizardMajorType, long nWizardMinorType, LPCTSTR lpszExtra,
		LPCTSTR lpszObjectName, LPDISPATCH FAR* ppvLangItem) PURE;
	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(get_AccessType)(THIS_ short FAR* pnAccessType) PURE;
	STDMETHOD(put_AccessType)(THIS_ short nAccessType) PURE;
	STDMETHOD(get_StartLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(GetOneLine)(THIS_ long nFileType, long nLineNumber, BSTR FAR* pbstrLineContents) PURE;
	STDMETHOD(SetOneLine)(THIS_ long nFileType, long nLineNumber , LPCTSTR lpszText) PURE;
	STDMETHOD(InsertText)(THIS_ long nFileType, LPCTSTR lpszText, long nLineNumber, long nColumn, 
		BOOL bFullLine) PURE;
#ifdef NOT_YET
	STDMETHOD(GetConditions)(THIS_ short nWhichFile, BSTR FAR* pbstrConditions) PURE;
	STDMETHOD(GetContents)(THIS_ BSTR FAR* pbstrContents) PURE;
	STDMETHOD(GetTemplate)(THIS_ long nWizardType, LPCTSTR lpszName, BSTR FAR* pbstrTemplate, 
		BSTR FAR* pbstrTemplateVariables) PURE;
	STDMETHOD(RenderFunctionTemplate)(THIS_ LPCTSTR lpszFunctionName, LPCTSTR lpszTemplateVariables, 
		long nDeclHintType, LPCTSTR lpszHintName, BOOL bDeclAddAfter, long nImplHintType, 
		LPCTSTR lpszImplHintName, BOOL bImplAddAfter) PURE;
	STDMETHOD(RenderMyTemplate)(THIS_ LPCTSTR lpszTemplate, LPCTSTR lpszTemplateVariables, 
		BSTR FAR* pbstrRenderedTemplate) PURE;
	STDMETHOD(FindExactText)(THIS_ long nLineNumberStart, LPCTSTR lpszText, BOOL bCheckNext, 
		BOOL bCheckComments, BSTR FAR* pbstrFoundFile, BSTR FAR* pbstrFoundLocation, 
		long FAR* pnLineNumberFound) PURE;
	STDMETHOD(FindVariable)(THIS_ LPCTSTR lpszVariableType, long nLineNumberStart, BOOL bCheckNext, 
		BSTR FAR* pbstrVariableName, BSTR FAR* pbstrFoundFile, BSTR FAR* pbstrFoundLocation, 
		long FAR* pnLineNumberFound) PURE;
	STDMETHOD(WhatIsThis)(THIS_ LPCTSTR lpszText, LPCTSTR lpszFileFound, long nLineNumber, long FAR* pnTokenType) PURE;
	STDMETHOD(DeleteOneLine)(THIS_ long nFileType, long nLineNumber) PURE;
#endif // NOT_YET
}; 

/////////////////////////////////////////////////////////////////////////////
// ILanguageModuleNode
//   This is an interface for obtaining language-specific modules. Current focus: C++

#undef  INTERFACE
#define INTERFACE ILanguageModuleNode
DECLARE_INTERFACE_(ILanguageModuleNode, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageModuleNode methods
	STDMETHOD(GetAllObjectsOfType)(THIS_ HTARGET hTarget, long nWizardMajorType, long nWizardMinorType, 
		LPCTSTR lpszExtra, LPDISPATCH FAR* ppvWizardEnum) PURE;
	STDMETHOD(GetObjectOfType)(THIS_ HTARGET hTarget, long nWizardMajorType, long nWizardMinorType, 
		LPCTSTR lpszExtra, LPCTSTR lpszObjectName, LPDISPATCH FAR* ppvLangItem) PURE;
	STDMETHOD(AddInclude)(THIS_ long nAddWhere, LPCTSTR lpszClassName, LPCTSTR lpszIncludeName, 
		LPCTSTR lpszAttribs, LPCTSTR lpszConditions, LPCTSTR lpszComments, long nHintType, 
		LPCTSTR lpszHintName, BOOL bAddAfter) PURE;
	STDMETHOD(GetSelectedProject)(THIS_ HTARGET FAR* phTarget) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
}; 

/////////////////////////////////////////////////////////////////////////////
// ILanguageModule
//   This is an interface for manipulating language-specific modules. Current focus: C++

#undef  INTERFACE
#define INTERFACE ILanguageModule
DECLARE_INTERFACE_(ILanguageModule, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 
    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageModule methods
	STDMETHOD(EnumResidentWizardTypes)(THIS_ long nScopeType, LPCTSTR lpszScopeName, 
		LPWIZARDINTEGERS FAR* ppvWizardIntegers) PURE;
	STDMETHOD(GetResidentFunctionNames)(THIS_ long nScopeType, LPCTSTR lpszScopeName, 
		long nWizardType, LPWIZARDSTRINGS FAR* ppvWizardStrings) PURE;
	STDMETHOD(get_FileName)(THIS_ long nFileType, short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(GetAllNamesOfType)(THIS_ long nScopeType, LPCTSTR lpszScopeName, long nWizardType, 
		LPWIZARDSTRINGS FAR* pvWizardStrings) PURE;
	STDMETHOD(GetAllObjectsOfType)(THIS_ long nWizardMajorType, long nWizardMinorType, LPCTSTR lpszExtra, 
		LPDISPATCH FAR* pvWizardEnum) PURE;
	STDMETHOD(GetFileAccess)(THIS_ short nMode, short nFindType, long nHintType, LPCTSTR lpszHintName, 
		BOOL FAR* pbHaveAccess) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
 	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(GetOneLine)(THIS_ long nFileType, long nLineNumber, BSTR FAR* bstrLineContents) PURE;
	STDMETHOD(SetOneLine)(THIS_ long nFileType, long nLineNumber , LPCTSTR lpszText) PURE;
	STDMETHOD(InsertText)(THIS_ long nFileType, LPCTSTR lpszText, long nLineNumber, long nColumn, 
		BOOL bFullLine) PURE;
	STDMETHOD(AddInclude)(THIS_ long nAddWhere, LPCTSTR lpszExtra, LPCTSTR lpszIncludeName, 
		LPCTSTR lpszAttribs, LPCTSTR lpszConditions, LPCTSTR lpszComments, long nHintType, 
		LPCTSTR lpszHintName, BOOL bAddAfter) PURE;
#ifdef NOT_YET
	STDMETHOD(GetIncludeFile)(THIS_ LPCTSTR lpszInclude, long nStartLine, BOOL FAR* pbFoundIt, 
		long FAR* pnFoundLine, BSTR FAR* pbstrActual, BSTR FAR* pbstrConditions, BSTR FAR* pbstrComments) PURE;
	STDMETHOD(GetContext)(THIS_ long FAR* pnLineNumber, BSTR FAR* pbstrContextInfo) PURE;
	STDMETHOD(GetLineNumber)(THIS_ long FAR* pnLineNumber) PURE;
	STDMETHOD(GetStartLineOfContext)(THIS_ LPCTSTR lpszContext, long FAR* pnStartLine) PURE;
	STDMETHOD(GetDefaultCounterpartName)(THIS_ BSTR FAR* pbstrCounterpart) PURE;
	STDMETHOD(ResolveContext)(THIS_ LPCTSTR lpszFullContext, LPCTSTR lpszContextPart, BSTR FAR* pbstrType, 
		BSTR FAR* pbstrName, BSTR FAR* pbstrRemaining) PURE;
	STDMETHOD(AddMember)(THIS_ long nMemberKind, LPCTSTR lpszMemberName, LPCTSTR lpszMemberType, 
		LPCTSTR lpszMemberBody, LPCTSTR lpszConditions, long nHintType, LPCTSTR lpszHintName, 
		BOOL bAddAfter) PURE;
	STDMETHOD(DeleteMember)(THIS_ long nMemberKind, LPCTSTR lpszMemberName) PURE;
	STDMETHOD(DeleteUnnamedMember)(THIS_ long nMemberKind, LPCTSTR lpszMemberContents) PURE;
#endif	// NOT_YET
};
 
/////////////////////////////////////////////////////////////////////////////
// ILanguageClassNode
//   This is an interface for obtaining classes.

#undef  INTERFACE
#define INTERFACE ILanguageClassNode
DECLARE_INTERFACE_(ILanguageClassNode, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageClassNode methods
	STDMETHOD(GetScopeObject)(LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(GetAllObjectsOfType)(THIS_ HTARGET hTarget, long nWizardMajorType, long nWizardMinorType, 
		LPCTSTR lpszExtra, LPDISPATCH FAR* ppvWizardEnum) PURE;
	STDMETHOD(GetObjectOfType)(THIS_ HTARGET hTarget, long nWizardMajorType, long nWizardMinorType, 
		LPCTSTR lpszExtra, LPCTSTR lpszObjectName, LPDISPATCH FAR* ppvLangItem) PURE;
	STDMETHOD(GetDerivedClasses)(THIS_ LPCTSTR lpszBaseClass, BOOL bImmediateOnly, 
		LPLANGUAGECLASSES FAR* ppvClasses) PURE;
	STDMETHOD(HasMembers)(THIS_ HTARGET hTarget, BOOL FAR* bHasMembers) PURE;
	STDMETHOD(HasAssociations)(THIS_ HTARGET hTarget, long nAssociationMajorType, long nAssociationMinorType, 
		LPCTSTR lpszClass, BOOL FAR* bHasAssoc) PURE;
	STDMETHOD(GetAssociations)(THIS_ HTARGET hTarget, long nAssociationMajorType, long nAssociationMinorType,
		LPCTSTR lpszClass, LPDISPATCH FAR* pvWizardEnum) PURE;
	STDMETHOD(GetAssociationName)(THIS_ HTARGET hTarget, long nAssociationMajorType, long nAssociationMinorType, 
		long nPresentHow, long nAssociatedHow, LPCTSTR lpszAssociatedName, BSTR FAR* pbstrName) PURE;
	STDMETHOD(AddInclude)(THIS_ long nAddWhere, LPCTSTR lpszClassName, LPCTSTR lpszIncludeName, 
		LPCTSTR lpszAttribs, LPCTSTR lpszConditions, LPCTSTR lpszComments, long nHintType, 
		LPCTSTR lpszHintName, BOOL bAddAfter) PURE;
	STDMETHOD(GetInclude)(THIS_ long nFileType, LPCTSTR lpszClassName, BOOL bMakeRelative, LPCTSTR lpszRelativeWhere, BSTR FAR* pbstrIncludeFile) PURE;
	STDMETHOD(IsValidSymbol)(THIS_ long nObjectType, LPCTSTR lspzName, BOOL FAR* pbIsValidSymbol) PURE;
	STDMETHOD(IsReservedSymbol)(THIS_ long nObjectType, LPCTSTR lpszName, long FAR* pnSymbolType) PURE;
	STDMETHOD(CreateWrapper)(THIS_ long nHintType, LPCTSTR lpszHintName, LPCTSTR lpszSeed, 
		BSTR FAR* pbstrWrapper) PURE;
	STDMETHOD(GetSelectedProject)(THIS_ HTARGET FAR* phTarget) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
#ifdef NOT_YET
	STDMETHOD(GetOverrideList)(THIS_ LPCTSTR lpszClassName, LPWIZARDLIST FAR* ppvWizardList) PURE;
	STDMETHOD(GetOverrideItem)(THIS_ LPCTSTR lpszClassName, LPCTSTR lpszFunctionName, BSTR FAR* pbstrFullName) PURE;
	STDMETHOD(GetClassTemplate)(THIS_ long nTemplateType, LPCTSTR lpszClassName, BSTR FAR* pbstrTemplate, 
		BSTR FAR* pbstrTemplateVars) PURE;
	STDMETHOD(DeleteClass)(THIS_ LPCTSTR lpszType, LPCTSTR lpszClassName) PURE;
#endif	// NOT_YET
}; 

/////////////////////////////////////////////////////////////////////////////
// IAltLanguageClassNode
//   This is an interface for doing extra stuff.  It probably should be a service from IWizardNode,
//   but it is fastest to put it off the CPP package for V6, so that's where it is going.

#undef  INTERFACE
#define INTERFACE IAltLanguageClassNode
DECLARE_INTERFACE_(IAltLanguageClassNode, IUnknown)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 
	STDMETHOD(GetSelectedProject)(THIS_ HTARGET FAR* phTarget) PURE;
	STDMETHOD(GotoDialogEditorLocation)(THIS_ HTARGET hTarget, LPCTSTR lpszClassName, LPCTSTR lpszDialogID) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ILanguageClass
//   This is an interface for manipulating classes.  Current focus: C++ classes

#undef  INTERFACE
#define INTERFACE ILanguageClass
DECLARE_INTERFACE_(ILanguageClass, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 
    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageClass methods
	STDMETHOD(get_BaseClass)(THIS_ BSTR FAR* pbstrBaseClass) PURE;
	STDMETHOD(get_BaseClassList)(THIS_ LPCLASSNAMES FAR* ppvBaseClassNames) PURE;
	STDMETHOD(HasBaseClass)(THIS_ LPCTSTR lpszBaseClass, BOOL bAsImmediate, BOOL FAR* pbHasBaseClass) PURE;
	STDMETHOD(HasMembers)(THIS_ BOOL FAR* pbHasMembers) PURE;
	STDMETHOD(HasAssociations)(THIS_ long nAssociationMajorType, long nAssociationMinorType, BOOL FAR* pbHasAssoc) PURE;
	STDMETHOD(GetName)(THIS_ short nWizType, BSTR FAR* pbClassName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_Type)(THIS_ BSTR FAR* pbClassType) PURE;
	STDMETHOD(get_AccessType)(THIS_ short FAR* pnAccessType) PURE;
	STDMETHOD(put_AccessType)(THIS_ short nAccessType) PURE;
	STDMETHOD(get_Contents)(THIS_ BSTR FAR* pbstrClassContents) PURE;
	STDMETHOD(put_Contents)(THIS_ LPCTSTR lpszContents) PURE;
	STDMETHOD(get_AllAttributes)(THIS_ BSTR FAR* pbstrAllAttributes) PURE;
	STDMETHOD(put_AllAttributes)(THIS_ LPCTSTR lpszAllAttributes) PURE;
	STDMETHOD(get_NumberOfAttributes)(THIS_ short FAR* pnNumAttrib) PURE;
	STDMETHOD(GetAssociations)(THIS_ long nAssociationMajorType, long nAssociationMinorType, 
		LPDISPATCH FAR* pvAssociations) PURE;
	STDMETHOD(GetScope)(THIS_ long FAR* nScopeType, BSTR FAR* bstrScopeName) PURE;
	STDMETHOD(GetScopeObject)(THIS_ LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(get_FileName)(THIS_ long nFileType, short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(get_StartLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_Conditions)(THIS_ BSTR FAR* bstrConditions) PURE;
	STDMETHOD(put_Conditions)(THIS_ LPCTSTR lpszConditions) PURE;
	STDMETHOD(GetNamedAttribute)(THIS_ LPCTSTR lpszName, BSTR FAR* bstrValue, BOOL FAR* bIsDefined) PURE;
	STDMETHOD(SetNamedAttribute)(THIS_ LPCTSTR lpszName, LPCTSTR lpszValue, BOOL bIsDefined) PURE;
	STDMETHOD(GetIndexedAttribute)(THIS_ short nIndex, BSTR FAR* bstrName, BSTR FAR* bstrValue) PURE;
	STDMETHOD(EnumAllWizardTypes)(THIS_ long nScopeType, LPCTSTR lpszScopeName, 
		LPWIZARDINTEGERS FAR* pvWizardIntegers) PURE;
	STDMETHOD(GetAllNamesOfType)(THIS_ long nScopeType, LPCTSTR lpszScopeName, long nWizardType, 
		LPWIZARDSTRINGS FAR* pvWizardStrings) PURE;
	STDMETHOD(GetAllObjectsOfType)(THIS_ long nWizardMajorType, long nWizardMinorType, LPCTSTR lpszExtra, 
		LPDISPATCH FAR* pvWizardEnum) PURE;
	STDMETHOD(GetObjectOfType)(THIS_ long nWizardMajorType, long nWizardMinorType, LPCTSTR lpszExtra,
		LPCTSTR lpszObjectName, LPDISPATCH FAR* pvLangItem) PURE;
	STDMETHOD(GetFileAccess)(THIS_ short nMode, short nFindType, long nHintType, LPCTSTR lpszHintName, 
		BOOL FAR* pbHaveAccess) PURE;
	STDMETHOD(GetAssociation)(THIS_ long nAssociationMajorType, long nAssociationMinorType, LPCTSTR lpszName, 
		LPDISPATCH FAR* pvLangClass, long FAR* pnType, BSTR FAR* pbstrAttributes) PURE;
	STDMETHOD(GetAssociationName)(THIS_ long nAssociationMajorType, long nAssociationMinorType, long nPresentHow,
		BSTR FAR* pbstrName) PURE;
	STDMETHOD(GetTemplate)(THIS_ long nWizardType, LPCTSTR lpszName, BSTR FAR* pbstrTemplate, 
		BSTR FAR* pbstrTemplateVariables) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(AddMember)(THIS_ long nMemberKind, LPCTSTR lpszMemberName, LPCTSTR lpszMemberType, 
		short nAccessType, LPCTSTR lpszAttributes, LPCTSTR lpszConditions, LPCTSTR lpszBody, 
		long nHintType, LPCTSTR lpszHintName, BOOL bMemberAddAfter) PURE;
	STDMETHOD(AddMemberBody)(THIS_ long nMemberKind, LPCTSTR lpszMemberName, LPCTSTR lpszMemberType, 
		LPCTSTR lpszAttributes, LPCTSTR lpszMemberBody, LPCTSTR lpszConditions, long nHintType, 
		LPCTSTR lpszHintName, BOOL bMemberAddAfter) PURE;
	STDMETHOD(CreateFunctionStubBody)(THIS_  VARTYPE vt, BSTR FAR* pbstrReturn) PURE;
	STDMETHOD(AddBaseClass)(THIS_ LPCTSTR pszBaseClass, short nAccessType, long nHintType, LPCTSTR lpszHintName) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
 	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(GetClassStyle) (THIS_ BSTR FAR* pbstrStyle) PURE;
	STDMETHOD(GetMinorClassStyle)(THIS_ LPCTSTR lpszMajorStyle, BSTR FAR * pbstrStyle) PURE;
	STDMETHOD(GetSpecialIncludes)(THIS_ LPCTSTR lpszParams, BSTR FAR * pbstrIncludes) PURE;
	STDMETHOD(GetOneLine)(THIS_ long nFileType, long nLineNumber, BSTR FAR* bstrLineContents) PURE;
	STDMETHOD(SetOneLine)(THIS_ long nFileType, long nLineNumber , LPCTSTR lpszText) PURE;
	STDMETHOD(InsertText)(THIS_ long nFileType, LPCTSTR lpszText, long nLineNumber, long nColumn, 
		BOOL bFullLine) PURE;
	STDMETHOD(Refresh)(THIS) PURE;
	STDMETHOD(Delete)(THIS_ short nPieceToDelete, short nCommentOrDeletePiece) PURE;
#ifdef NOT_YET
	STDMETHOD(AddActiveXAssociation)(THIS_  LPCTSTR lpszInterfaceName, long nType, LPCTSTR lpszAttributes) PURE;
	STDMETHOD(get_RelatedAppObjects)(THIS_ LPWIZARDENUM FAR* ppvWizardEnum) PURE;
	STDMETHOD(get_OverrideList)(THIS_ LPWIZARDLIST FAR* ppvWizardList) PURE;
	STDMETHOD(GetOverrideItem)(THIS_ LPCTSTR lpszFunctionName, BSTR FAR* pbstrFullName) PURE;
	STDMETHOD(DeleteClass)(THIS_ LPCTSTR lpszClassName, LPCTSTR lpszAttribs) PURE;
	STDMETHOD(DeleteMember)(THIS_ long nMemberKind, LPCTSTR lpszMemberName, LPCTSTR lpszAttribs) PURE;
	STDMETHOD(DeleteActiveXAssociation)(THIS_ LPCTSTR lpszInterfaceName, LPCTSTR lpszAttribs) PURE;
	STDMETHOD(RenderFunctionTemplate)(THIS_ LPCTSTR lpszFunctionName, LPCTSTR lpszTemplateVariables, 
		long nDeclHintType, LPCTSTR lpszDeclHintName, BOOL bDeclAddAfter, long nImplHintType, 
		LPCTSTR lpszImplHintName, BOOL bImplAddAfter) PURE;
	STDMETHOD(RenderMyTemplate)(THIS_ LPCTSTR lpszTemplate, LPCTSTR lpszTemplateVariables, 
		BSTR FAR* bstrRenderedTemplate) PURE;
	STDMETHOD(FindExactText)(THIS_ long nLineNumberStart, LPCTSTR lpszText, BOOL bCheckNext, BOOL bCheckComments, 
		BSTR FAR* pbstrFoundFile, BSTR FAR* pbstrFoundLocation, long FAR* pnLineNumberFound) PURE;
	STDMETHOD(FindVariable)(THIS_ LPCTSTR lpszVariableType, long nLineNumberStart, BOOL bCheckNext, 
		BSTR FAR* pbstrVariableName, BSTR FAR* pbstrFoundFile, BSTR FAR* pbstrFoundLocation, 
		long FAR* nLineNumberFound) PURE;
	STDMETHOD(WhatIsThis)(THIS_ LPCTSTR lpszText, LPCTSTR lpszFileFound, long nLineNumber, long FAR* nTokenType) PURE;
	STDMETHOD(DeleteOneLine)(THIS_ long nFileType, long nLineNumber) PURE;
#endif	// NOT_YET
}; 

/////////////////////////////////////////////////////////////////////////////
// ILanguageItems
//   Collections of lang items ... classes, functions etc.

#undef  INTERFACE
#define INTERFACE ILanguageItems
DECLARE_INTERFACE_(ILanguageItems, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageItems methods
	STDMETHOD(_NewEnum)(THIS_ IEnumVARIANT **ppenum) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ICollectionEvents
// Event source interface for the global classes collection.

#undef  INTERFACE
#define INTERFACE ICollectionEvents
DECLARE_INTERFACE_(ICollectionEvents, IDispatch)
{
	// IUnknown methods
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)(THIS) PURE;
	STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ICollectionEvents methods
	STDMETHOD(AfterAdd)(THIS_ LPDISPATCH pItem) PURE;
	STDMETHOD(BeforeDelete)(THIS_ LPDISPATCH pItem) PURE;
	STDMETHOD(AfterChange)(THIS_ LPDISPATCH pItem) PURE;
	STDMETHOD(BeginAtomic)(THIS) PURE;
	STDMETHOD(EndAtomic)(THIS) PURE;
	STDMETHOD(MemberOp)(LPDISPATCH pItem, DWORD op, DWORD oldIinst, DWORD newIinst) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ILanguageFunction
//   This is an interface for manipulating functions.

#undef  INTERFACE
#define INTERFACE ILanguageFunction
DECLARE_INTERFACE_(ILanguageFunction, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageFunction methods
	STDMETHOD(GetName)(THIS_ short nNameType, BSTR FAR* bstrName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_AccessType)(THIS_ short FAR* pnAccessType) PURE;
	STDMETHOD(put_AccessType)(THIS_ short nAccessType) PURE;
	STDMETHOD(get_Contents)(THIS_ BSTR FAR* pbstrContents) PURE;
	STDMETHOD(put_Contents)(THIS_ LPCTSTR lpszContents) PURE;
	STDMETHOD(get_AllAttributes)(THIS_ BSTR FAR* pbstrAllAttributes) PURE;
	STDMETHOD(put_AllAttributes)(THIS_ LPCTSTR lpszAllAttributes) PURE;
	STDMETHOD(get_NumberOfAttributes)(THIS_ short FAR* pnNumAttrib) PURE;
	STDMETHOD(get_Conditions)(THIS_ short nWhichFile, BSTR FAR* pbstrConditions) PURE;
	STDMETHOD(put_Conditions)(THIS_ short nWhichFile, LPCTSTR lpszConditions) PURE;
	STDMETHOD(GetScope)(THIS_ long FAR* nScopeType, BSTR FAR* bstrScopeName) PURE;
	STDMETHOD(GetScopeObject)(THIS_ LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(GetReturnType)(THIS_ short nWhichOne, BSTR FAR* pbstrReturnType) PURE;
	STDMETHOD(SetReturnType)(THIS_ short nWhichOne, LPCTSTR lpszReturnType) PURE;
	STDMETHOD(GetNamedAttribute)(THIS_ LPCTSTR lpszName, BSTR FAR* bstrValue, BOOL FAR* bIsDefined) PURE;
	STDMETHOD(SetNamedAttribute)(THIS_ LPCTSTR lpszName, LPCTSTR lpszValue, BOOL bIsDefined) PURE;
	STDMETHOD(GetIndexedAttribute)(THIS_ short nAttribNum, BSTR FAR* bstrName, BSTR FAR* bstrValue) PURE;
	STDMETHOD(GetParameters)(THIS_ BOOL bWithAttributes, BSTR FAR* pbstrParameters) PURE;
	STDMETHOD(SetParameters)(THIS_ LPCTSTR lpszParameters) PURE;
	STDMETHOD(get_NumberOfParameters)(THIS_ short FAR* pnNumParams) PURE;
 	STDMETHOD(GetOneParameter)(THIS_ short nParamNum, BSTR FAR* pbstrParam, BSTR FAR* bstrAttribs) PURE;
	STDMETHOD(SetOneParameter)(THIS_ short nParamNum, LPCTSTR lpszParam, LPCTSTR lpszAttribs) PURE;
	STDMETHOD(GetOneParameterAttributes)(THIS_ short nParamNum, BSTR FAR* bstrAttribs) PURE;
	STDMETHOD(GetOneParameterAttributeCount)(THIS_ short nParamNum, short FAR* nAttribCount) PURE;
	STDMETHOD(GetOneParameterNamedAttribute)(THIS_ short nParamNum, LPCTSTR lpszName, BSTR FAR* bstrValue, 
		BOOL FAR* bIsDefined) PURE;
	STDMETHOD(SetOneParameterNamedAttribute)(THIS_ short nParamNum, LPCTSTR lpszName, LPCTSTR lpszValue, 
		BOOL bIsDefined) PURE;
	STDMETHOD(GetOneParameterIndexedAttribute)(THIS_ short nParamNum, short nAttribNum, BSTR FAR* bstrName, 
		BSTR FAR* bstrValue) PURE;
	STDMETHOD(GetAssociationType)(THIS_ long nAssociationType, LPCTSTR lpszInterfaceName, BSTR FAR* bstrInterfaceName, 
		long FAR* nType) PURE;
	STDMETHOD(GetAssociation)(THIS_ long nAssociationMajorType, long nAssociationMinorType, LPCTSTR lpszName, 
		LPDISPATCH FAR* pvLangFunc, long FAR* pnType, BSTR FAR* pbstrName) PURE;
	STDMETHOD(GetAssociationName)(THIS_ long nAssociationMajorType, long nAssociationMinorType, long nPresentHow,
		BSTR FAR* pbstrName) PURE;
	STDMETHOD(IsVirtual)(THIS_ BOOL FAR* pbIsVirtual) PURE;
	STDMETHOD(get_FileName)(THIS_ long nFileType, short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(get_StartLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
	STDMETHOD(Delete)(THIS_ short nPieceToDelete, short nCommentOrDeletePiece) PURE;
	STDMETHOD(GetOneLine)(THIS_ long nFileType, long nLineNumber, BSTR FAR* bstrLineContents) PURE;
	STDMETHOD(SetOneLine)(THIS_ long nFileType, long nLineNumber , LPCTSTR lpszText) PURE;
	STDMETHOD(InsertText)(THIS_ long nFileType, LPCTSTR lpszText, long nLineNumber, long nColumn, 
		BOOL bFullLine) PURE;
#ifdef NOT_YET
	STDMETHOD(GetActiveXMethod)(THIS_ BSTR FAR* bstrInterfaceName, BSTR FAR* bstrMethodName) PURE;
	STDMETHOD(GetActiveXProperty)(THIS_ BSTR FAR* bstrInterfaceName, long FAR* nPart, BSTR FAR* bstrImplGet, 
		BSTR FAR* bstrImplPut, BSTR FAR* bstrPropGet, BSTR FAR* bstrPropPut) PURE;
	STDMETHOD(AddToFunction)(THIS_ long nOffset, int nByNumLines, LPCTSTR lpszText) PURE;
	STDMETHOD(FindExactText)(THIS_ long nLineNumberStart, LPCTSTR lpszText, BOOL bCheckNext, BOOL bCheckComments, 
		BSTR FAR* pbstrFoundFile, BSTR FAR* pbstrFoundLocation, long FAR* nLineNumberFound) PURE;
	STDMETHOD(FindVariable)(THIS_ LPCTSTR lpszVariableType, long nLineNumberStart, BOOL bCheckNext, 
		BSTR FAR* pbstrVariableName, BSTR FAR* pbstrFoundFile, BSTR FAR* pbstrFoundLocation, 
		long FAR* nLineNumberFound) PURE;
	STDMETHOD(WhatIsThis)(THIS_ LPCTSTR lpszText, LPCTSTR lpszFileFound, long nLineNumber, long FAR* nTokenType) PURE;
	STDMETHOD(DeleteOneLine)(THIS_ long nFileType, long nLineNumber) PURE;
#endif	// NOT_YET
}; 

/////////////////////////////////////////////////////////////////////////////
// ILanguageVariable
//   This is an interface for manipulating variables.

#undef  INTERFACE
#define INTERFACE ILanguageVariable
DECLARE_INTERFACE_(ILanguageVariable, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageVariable methods
	STDMETHOD(GetName)(THIS_ short nNameType, BSTR FAR* bstrName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_AccessType)(THIS_ short FAR* pnAccessType) PURE;
	STDMETHOD(put_AccessType)(THIS_ short nAccessType) PURE;
	STDMETHOD(get_Type)(THIS_ BSTR FAR* pbstrType) PURE;
	STDMETHOD(put_Type)(THIS_ LPCTSTR lpszType) PURE;
	STDMETHOD(get_NumberOfAttributes)(THIS_ short FAR* numAttribs) PURE;
	STDMETHOD(get_AllAttributes)(THIS_ BSTR FAR* bstrAttribs) PURE;
	STDMETHOD(put_AllAttributes)(THIS_ LPCTSTR lpszAttribs) PURE;
	STDMETHOD(get_FileName)(THIS_ long nFileType, short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(get_StartLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_Conditions)(THIS_ BSTR FAR* bstrConditions) PURE;
	STDMETHOD(put_Conditions)(THIS_ LPCTSTR lpszConditions) PURE;
	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(GetScope)(THIS_ long FAR* nScopeType, BSTR FAR* bstrScopeName) PURE;
	STDMETHOD(GetScopeObject)(THIS_ LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(GetNamedAttribute)(THIS_ LPCTSTR lpszName, BSTR FAR* bstrValue, BOOL FAR* bIsDefined) PURE;
	STDMETHOD(SetNamedAttribute)(THIS_ LPCTSTR lpszName, LPCTSTR lpszValue, BOOL bIsDefined) PURE;
	STDMETHOD(GetIndexedAttribute)(THIS_ short nAttribNum, BSTR FAR* bstrName, BSTR FAR* bstrValue) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
	STDMETHOD(Delete)(THIS_ short nPieceToDelete, short nCommentOrDeletePiece) PURE;
#ifdef NOT_YET
	STDMETHOD(GetActiveXProperty)(THIS_ BSTR FAR* bstrInterfaceName, long FAR* nPart, BSTR FAR* bstrOne, 
		BSTR FAR* bstrImplNotify, BSTR FAR* bstrProp, BSTR FAR* bstrTwo) PURE;
#endif	// NOT_YET

}; 

/////////////////////////////////////////////////////////////////////////////
// ILanguageEnum
//   This is an interface for manipulating C++ enums.

#undef  INTERFACE
#define INTERFACE ILanguageEnum
DECLARE_INTERFACE_(ILanguageEnum, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
 	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageEnum methods
#ifdef NOT_YET
	STDMETHOD(GetName)(THIS_ short nNameType, BSTR FAR* bstrName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_AccessType)(THIS_ short FAR* pnAccessType) PURE;
	STDMETHOD(put_AccessType)(THIS_ short nAccessType) PURE;
	STDMETHOD(get_Contents)(THIS_ BSTR FAR* pbstrContents) PURE;
	STDMETHOD(put_Contents)(THIS_ LPCTSTR lpszContents) PURE;
	STDMETHOD(get_Conditions)(THIS_ BSTR FAR* bstrConditions) PURE;
	STDMETHOD(put_Conditions)(THIS_ LPCTSTR lpszConditions) PURE;
	STDMETHOD(get_NumberOfAttributes)(THIS_ short FAR* numAttribs) PURE;
	STDMETHOD(get_AllAttributes)(THIS_ BSTR FAR* bstrAttribs) PURE;
	STDMETHOD(put_AllAttributes)(THIS_ LPCTSTR lpszAttribs) PURE;
	STDMETHOD(get_FileName)(THIS_ long nFileType, short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(get_StartLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(GetScope)(THIS_ long FAR* nScopeType, BSTR FAR* bstrScopeName) PURE;
	STDMETHOD(GetScopeObject)(THIS_ LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(GetNamedAttribute)(THIS_ LPCTSTR lpszName, BSTR FAR* bstrValue, BOOL FAR* bIsDefined) PURE;
	STDMETHOD(SetNamedAttribute)(THIS_ LPCTSTR lpszName, LPCTSTR lpszValue, BOOL bIsDefined) PURE;
	STDMETHOD(GetIndexedAttribute)(THIS_ short nAttribNum, BSTR FAR* bstrName, BSTR FAR* bstrValue) PURE;
	STDMETHOD(AppendToContents)(THIS_ LPCTSTR lpszContents) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
#endif	// NOT_YET
}; 

/////////////////////////////////////////////////////////////////////////////
// ILanguageTypedef
//   This is an interface for manipulating C++ typedefs.

#undef  INTERFACE
#define INTERFACE ILanguageTypedef
DECLARE_INTERFACE_(ILanguageTypedef, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
 	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageTypedef methods
#ifdef NOT_YET
	STDMETHOD(GetName)(THIS_ short nNameType, BSTR FAR* bstrName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_Contents)(THIS_ BSTR FAR* pbstrContents) PURE;
	STDMETHOD(put_Contents)(THIS_ LPCTSTR lpszContents) PURE;
	STDMETHOD(get_Conditions)(THIS_ BSTR FAR* bstrConditions) PURE;
	STDMETHOD(put_Conditions)(THIS_ LPCTSTR lpszConditions) PURE;
	STDMETHOD(get_NumberOfAttributes)(THIS_ short FAR* numAttribs) PURE;
	STDMETHOD(get_AllAttributes)(THIS_ BSTR FAR* bstrAttribs) PURE;
	STDMETHOD(put_AllAttributes)(THIS_ LPCTSTR lpszAttribs) PURE;
	STDMETHOD(get_FileName)(THIS_ long nFileType, short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(get_StartLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(GetScopeObject)(THIS_ LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(GetNamedAttribute)(THIS_ LPCTSTR lpszName, BSTR FAR* bstrValue, BOOL FAR* bIsDefined) PURE;
	STDMETHOD(SetNamedAttribute)(THIS_ LPCTSTR lpszName, LPCTSTR lpszValue, BOOL bIsDefined) PURE;
	STDMETHOD(GetIndexedAttribute)(THIS_ short nAttribNum, BSTR FAR* bstrName, BSTR FAR* bstrValue) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
#endif	// NOT_YET
}; 

/////////////////////////////////////////////////////////////////////////////
// ILanguageMap
//   This is an interface for manipulating any particular map (as defined by Microsoft)

#undef  INTERFACE
#define INTERFACE ILanguageMap
DECLARE_INTERFACE_(ILanguageMap, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageMap methods
	STDMETHOD(GetName)(THIS_ short nNameType, BSTR FAR* pbstrName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_FileName)(THIS_ long nFileType, short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(get_StartLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long nFileType, long FAR* pnLineNumber) PURE;
	STDMETHOD(get_Conditions)(THIS_ long nFileType, BSTR FAR* bstrConditions) PURE;
	STDMETHOD(put_Conditions)(THIS_ long nFileType, LPCTSTR lpszConditions) PURE;
	STDMETHOD(GetScopeObject)(THIS_ LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(GetContents)(THIS_ LPLANGUAGEMAPITEMS FAR* ppvMFCMapItems) PURE;
	STDMETHOD(get_MapParameters)(THIS_ short nWhichPart, BSTR FAR* bstrMapParameters) PURE;	
	STDMETHOD(put_MapParameters)(THIS_ short nWhichPart, LPCTSTR lpszMapParameters) PURE;
	STDMETHOD(GetMapItemSet)(THIS_ short nByParam, LPCTSTR lpszName, LPLANGUAGEMAPITEMS FAR* ppvMapItems) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
	STDMETHOD(AddMapItem)(THIS_ LPCTSTR lpszMapItem, BOOL bInsertAtTop) PURE;
	STDMETHOD(InsertMapItem)(THIS_ long nOffsetLocation, LPCTSTR lpszMapItem) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ILanguageMapItem
//   This is an interface for manipulating a generic map item

#undef  INTERFACE
#define INTERFACE ILanguageMapItem
DECLARE_INTERFACE_(ILanguageMapItem, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ILanguageMapItem methods
	STDMETHOD(GetName)(THIS_ short nNameType, BSTR FAR* pbstrName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_NumberOfParameters)(THIS_ short FAR* numParameters) PURE;
	STDMETHOD(get_FileName)(THIS_ short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(get_StartLine)(THIS_ long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long FAR* pnLineNumber) PURE;
	STDMETHOD(get_Conditions)(THIS_ BSTR FAR* bstrConditions) PURE;
	STDMETHOD(put_Conditions)(THIS_ LPCTSTR lpszConditions) PURE;
	STDMETHOD(get_Contents)(THIS_ BSTR FAR* pbstrContents) PURE;
	STDMETHOD(put_Contents)(THIS_ LPCTSTR lpszContents) PURE;
	STDMETHOD(get_Parameter)(THIS_ short nParamNum, BSTR FAR* pbstrParam) PURE;
	STDMETHOD(put_Parameter)(THIS_ short nParamNum, LPCTSTR lpszParameter) PURE;
	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(GetScopeObject)(THIS_ LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
	STDMETHOD(Delete)(THIS_ BOOL bCommentOut) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// ILanguageMacro
//   This is an interface for manipulating macros understood by the Wizard model

#undef  INTERFACE
#define INTERFACE ILanguageMacro
DECLARE_INTERFACE_(ILanguageMacro, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;

    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

#ifdef NOT_YET
	// ILanguageMacro methods
	STDMETHOD(GetName)(THIS_ short nNameType, BSTR FAR* pbstrName) PURE;
	STDMETHOD(SetName)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_NumberOfParameters)(THIS_ short FAR* numParameters) PURE;
	STDMETHOD(get_Parameter)(THIS_ short nParamNum, BSTR FAR* pbstrParam) PURE;
	STDMETHOD(put_Parameter)(THIS_ short nParamNum, LPCTSTR lpszParameters) PURE;
	STDMETHOD(get_Contents)(THIS_ BSTR FAR* pbstrContents) PURE;
	STDMETHOD(put_Contents)(THIS_ LPCTSTR lpszContents) PURE;
	STDMETHOD(get_FileName)(THIS_ short nPathType, BSTR FAR* pbstrFileName) PURE;
	STDMETHOD(get_AllFileNames)(THIS_ long nFileType, short nPathType, LPFILES FAR* ppvFiles) PURE;
	STDMETHOD(get_StartLine)(THIS_ long FAR* pnLineNumber) PURE;
	STDMETHOD(get_EndLine)(THIS_ long FAR* pnLineNumber) PURE;
	STDMETHOD(get_Conditions)(THIS_ BSTR FAR* bstrConditions) PURE;
	STDMETHOD(put_Conditions)(THIS_ LPCTSTR lpszConditions) PURE;
	STDMETHOD(get_Configuration)(THIS_ BSTR FAR* pbstrConfig) PURE;
	STDMETHOD(GetScopeObject)(THIS_ LPCTSTR lpszScopeName, LPDISPATCH FAR* pvScopeObject) PURE;
	STDMETHOD(GotoEditorLocation)(THIS_ long nFileType, short nLocationType) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
#endif	// NOT_YET
};

#ifdef NOT_YET
/////////////////////////////////////////////////////////////////////////////
// ICreateClasses
//   This is an interface for creating classes.  It is currently set up to deal well
//   with C++ classes, but there is nothing that says it cannot be used for classes
//   of other languages.

#undef  INTERFACE
#define INTERFACE ICreateClasses
DECLARE_INTERFACE_(ICreateClasses, IDispatch)
{
	// IUnknown methods
	STDMETHOD_(ULONG,AddRef)(THIS) PURE;
	STDMETHOD_(ULONG,Release)(THIS) PURE;
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
 
    // IDispatch methods
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;
    STDMETHOD(GetTypeInfo)(THIS_ UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) PURE;
    STDMETHOD(GetIDsOfNames)(THIS_ REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
		LCID lcid, DISPID FAR* rgdispid) PURE;
    STDMETHOD(Invoke)(THIS_ DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
		UINT FAR* puArgErr) PURE;

	// ICreateClasses methods
	STDMETHOD(get_WizardType)(THIS_ long FAR* pnWizardType) PURE;
	STDMETHOD(put_WizardType)(THIS_ long nWizardType) PURE;
	STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName) PURE;
	STDMETHOD(put_Name)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(get_BaseClass)(THIS_ BSTR FAR* pbstrName) PURE;
	STDMETHOD(put_BaseClass)(THIS_ LPCTSTR lpszName) PURE;
	STDMETHOD(GetFiles)(THIS_ BSTR FAR* pbstrHeader, BSTR FAR* pbstrImplementation) PURE;
	STDMETHOD(SetFiles)(THIS_ LPCTSTR lpszHeader, LPCTSTR lpszImplementation) PURE;
	STDMETHOD(SetScope)(THIS_ LPCTSTR lpszScopeType, LPCTSTR lpszScopeName) PURE;
	STDMETHOD(GetOLEOptions)(THIS_ long FAR* pnFlags, BSTR FAR* pbstrName) PURE;
	STDMETHOD(SetOLEOptions)(THIS_ long nFlags, LPCTSTR lpszName) PURE;
	STDMETHOD(get_DialogTemplate)(THIS_ BSTR FAR* pbstrDialogID) PURE;
	STDMETHOD(put_DialogTemplate)(THIS_ LPCTSTR lpszDialogID) PURE;
	STDMETHOD(put_NameFlags)(THIS_ long nFlags) PURE;
	STDMETHOD(put_BaseClassNameList)(THIS_ LPCTSTR lpszBaseClassList) PURE;
	STDMETHOD(put_DialogTemplateFlags)(THIS_ long nFlags) PURE;
	STDMETHOD(put_DialogTitle)(THIS_ LPCTSTR lpszTitle) PURE;
	STDMETHOD(DoModal)(THIS) PURE;
	STDMETHOD(CreateClass)(THIS) PURE;
	STDMETHOD(FindInterface)(THIS_ LPCTSTR lpszInterfaceName, LPVOID FAR* ppvInterface) PURE;
};
#endif	// NOT_YET

/////////////////////////////////////////////////////////////////////////////
// Result codes
// WARNING: make sure you don't conflict numerically with errors in ogapi.h
// that mean something different than what we have here.
// Stay out of the 50 - 299 range unless the error really is the same as the
// one in ogapi.h.  (No note there about overlaps since ogapi.h can ship to ISVs.)
#define WIZ_FAC (463)
#define WIZ_S(code) MAKE_HRESULT(SEVERITY_SUCCESS,WIZ_FAC,code)
#define WIZ_E(code) MAKE_HRESULT(SEVERITY_ERROR,WIZ_FAC,code)

#define WIZ_S_PARSE_PARAM_COUNT_MISMATCH WIZ_S(1)

#define WIZ_E_MEMBER_EXISTS      WIZ_E(50)
#define WIZ_E_MEMBER_CONFLICTS   WIZ_E(51)
#define WIZ_E_MEMBER_NOT_FOUND   WIZ_E(52)

#define WIZ_E_PARSE_MISMATCH_PARENT  WIZ_E(53)
#define WIZ_E_PARSE_NO_TEMPLATE_DEFN WIZ_E(54)
#define WIZ_E_PARSE_NO_DEFN          WIZ_E(55)
#define WIZ_E_PARSE_MULTI_LINE       WIZ_E(56)
#define WIZ_E_PARSE_INVALID_TOKEN    WIZ_E(57)
#define WIZ_E_PARSE_NO_LEXER         WIZ_E(58)
#define WIZ_E_PARSE_EMPTY_STREAM     WIZ_E(59)
#define WIZ_E_PARSE_MISMATCH_BRACKET WIZ_E(60)
#define WIZ_E_PARSE_UNEXPECTED_EOL   WIZ_E(61)
#define WIZ_E_PARSE_EXTRA_TOKEN      WIZ_E(62)
#define WIZ_E_PARSE_CTOR_RET_TYPE    WIZ_E(63)
#define WIZ_E_PARSE_DUP_ACCESS_SPEC  WIZ_E(64)
#define WIZ_E_PARSE_INVALID_MODIFIER WIZ_E(65)
#define WIZ_E_PARSE_MACROERROR       WIZ_E(66)

#define WIZ_E_PARAMETER_CONFLICTS    WIZ_E(67)
#define WIZ_E_DUP_BASE_CLASS		 WIZ_E(68)

#define WIZ_E_NO_FILE				 WIZ_E(100)

#define WIZ_E_NO_TRANSACTION         WIZ_E(300)

#endif	// _WIZAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\include\utilguid.h ===
// Interface ID for Source Utility Functions

DEFINE_GUID(IID_ISrcUtil,
	0x83a9f010, 0x60c5, 0x11cf, 0xa8, 0x9, 0x0, 0xaa, 0x0, 0xb6, 0x1, 0x54);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\about.cpp ===
/////////////////////////////////////////////////////////////////////////////
// About Box and Splash Screen
//

#include "stdafx.h"
#include <dos.h>
#include <direct.h>
#include "about.h"
#include "main.h"
#include "version.h"
#include "resource.h"
// #include "vinfoapi.h" --- BUILD LAB UNCOMMENT!
#include "dlgbase.h"
#include "util.h"
// #include "intnl.h" --- BUILD LAB UNCOMMENT!
#include "tchar.h"

#include "shell.h"	// willf: 11/21/96 MyPlaySound() moved to util.cpp

//[multimon] 7 mar 97 - der
#include "mmonitor.h"

#define HIGHLIGHT 0

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// NOTE: This should NOT be localized.
// It will be overwritten by information from a PID resource written by SETUP
PRODUCT_INFO AFX_EXT_DATADEF productInfo =
{
#ifdef _DEBUG
	szVerUser,
	"Team VC++",
#else
	"This is an unauthorized copy",
	"of Microsoft Developer",
#endif
	"xxxxxxxxxxxxxxxxxxxxxxx",
};

BOOL InitProductId( HMODULE hMod )
{
	CProductInfo pid;
	pid.Create(hMod);
	if (pid.IsValid())
		pid.CopyInfo(productInfo.szSerialNumber, productInfo.szLicenseName, productInfo.szLicenseCompany);
	return pid.IsValid();
}

// CWnd for splash screen
static class CSplashScreen* pSplash = NULL;

/////////////////////////////////////////////////////////////////////////////
// Generic Bitmap Drawing Window Class
//

class CBitmapWnd : public CWnd
{
public:
	CBitmapWnd();
	~CBitmapWnd();
	BOOL Create(LPCSTR lpszBitmapName, DWORD dwStyle,
		const RECT& rect = CFrameWnd::rectDefault,
		CWnd* pParentWnd = NULL, UINT nID = 0);

	BOOL Create(UINT nBitmapID, DWORD dwStyle,
		const RECT& rect = CFrameWnd::rectDefault,
		CWnd* pParentWnd = NULL, UINT nID = 0)
			{ return Create(MAKEINTRESOURCE(nBitmapID), dwStyle,
				rect, pParentWnd, nID); }

protected:
	afx_msg void OnPaint();
	afx_msg BOOL OnQueryNewPalette();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);

	virtual void OnDraw(CDC* pDC);
	
	LPSTR m_lpDIB;
	CPalette* m_pPalette;

	DECLARE_MESSAGE_MAP()
};

CBitmapWnd::CBitmapWnd()
{
	m_lpDIB = NULL;
	m_pPalette = NULL;
}

CBitmapWnd::~CBitmapWnd()
{
	if (m_pPalette != NULL)
	{
		delete m_pPalette;
		m_pPalette = NULL;
		ModifyStyle(WS_POPUP, 0);
		SetOwner(NULL);
		SetActiveWindow();
	}
	if (m_hWnd != NULL)
		DestroyWindow();	// Avoid warning in CWnd destructor.
}

BEGIN_MESSAGE_MAP(CBitmapWnd, CWnd)
	ON_WM_PAINT()
	ON_WM_QUERYNEWPALETTE()
	ON_WM_PALETTECHANGED()
END_MESSAGE_MAP()


#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof (BITMAPINFOHEADER))

WORD DIBNumColors(LPSTR lpbi)
{
    WORD wBitCount;

    // If this is a Windows style DIB, the number of colors in the
    // color table can be less than the number of bits per pixel
    // allows for (i.e. lpbi->biClrUsed can be set to some value).
    // If this is the case, return the appropriate value.

    if (IS_WIN30_DIB(lpbi))
    {
        DWORD dwClrUsed = ((LPBITMAPINFOHEADER)lpbi)->biClrUsed;

        if (dwClrUsed != 0)
            return (WORD)dwClrUsed;
    }


    // Calculate the number of colors in the color table based on
    //  the number of bits per pixel for the DIB.

    if (IS_WIN30_DIB(lpbi))
        wBitCount = ((LPBITMAPINFOHEADER)lpbi)->biBitCount;
    else
        wBitCount = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;

    switch (wBitCount)
    {
    case 1:
        return 2;

    case 4:
        return 16;

    case 8:
        return 256;

    default:
        return 0;
    }
}

WORD PaletteSize(LPSTR lpbi)
{
    return DIBNumColors(lpbi) *
        (IS_WIN30_DIB(lpbi) ? sizeof(RGBQUAD) : sizeof(RGBTRIPLE));
}

LPSTR FindDIBBits(LPSTR lpbi)
{
    return (lpbi + *(LPDWORD)lpbi + PaletteSize(lpbi));
}

DWORD DIBWidth(LPSTR lpDIB)
{
    LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER)lpDIB;
    LPBITMAPCOREHEADER lpbmc = (LPBITMAPCOREHEADER)lpDIB;

    if (lpbmi->biSize == sizeof (BITMAPINFOHEADER))
        return lpbmi->biWidth;
    else
        return (DWORD)lpbmc->bcWidth;
}


DWORD DIBHeight(LPSTR lpDIB)
{
    LPBITMAPINFOHEADER lpbmi = (LPBITMAPINFOHEADER)lpDIB;
    LPBITMAPCOREHEADER lpbmc = (LPBITMAPCOREHEADER)lpDIB;

    if (lpbmi->biSize == sizeof (BITMAPINFOHEADER))
        return lpbmi->biHeight;
    else
        return (DWORD)lpbmc->bcHeight;
}

CPalette* CreateDIBPalette(LPSTR lpbi)
{
    LPLOGPALETTE lpPal;
    HGLOBAL hLogPal;
    CPalette* pPal = NULL;
    int i;
	WORD wNumColors;
    LPBITMAPINFO lpbmi;
    LPBITMAPCOREINFO lpbmc;
    BOOL bWinStyleDIB;

    ASSERT(lpbi != NULL);

    lpbmi = (LPBITMAPINFO)lpbi;
    lpbmc = (LPBITMAPCOREINFO)lpbi;
    wNumColors = DIBNumColors(lpbi);
    bWinStyleDIB = IS_WIN30_DIB(lpbi);

    if (wNumColors == 0)
        return NULL;

    hLogPal = GlobalAlloc(GHND, sizeof(LOGPALETTE) +
        sizeof (PALETTEENTRY) * wNumColors);

    if (hLogPal == NULL)
        return NULL;

    lpPal = (LPLOGPALETTE)GlobalLock(hLogPal);

    lpPal->palVersion = 0x300;
    lpPal->palNumEntries = wNumColors;

    for (i = 0; i < wNumColors; i += 1)
    {
        if (bWinStyleDIB)
        {
            lpPal->palPalEntry[i].peRed  = lpbmi->bmiColors[i].rgbRed;
            lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
            lpPal->palPalEntry[i].peBlue = lpbmi->bmiColors[i].rgbBlue;
            lpPal->palPalEntry[i].peFlags = 0;
        }
        else
        {
            lpPal->palPalEntry[i].peRed = lpbmc->bmciColors[i].rgbtRed;
            lpPal->palPalEntry[i].peGreen = lpbmc->bmciColors[i].rgbtGreen;
            lpPal->palPalEntry[i].peBlue = lpbmc->bmciColors[i].rgbtBlue;
            lpPal->palPalEntry[i].peFlags = 0;
        }
    }

    pPal = new CPalette;
    pPal->CreatePalette(lpPal);

    GlobalUnlock(hLogPal);
    GlobalFree(hLogPal);
	
    return pPal;
}

LPSTR LoadDIBResource(LPCSTR lpszBitmapName)
{
	HINSTANCE hDibInst = AfxFindResourceHandle(lpszBitmapName, RT_BITMAP);
	if (hDibInst == NULL)
		return NULL;
	HRSRC hDibRsrc = FindResource(hDibInst, lpszBitmapName, RT_BITMAP);
	if (hDibRsrc == NULL)
		return NULL;
	return (LPSTR)LockResource(LoadResource(hDibInst, hDibRsrc));
}

LPSTR LoadDIBResource(UINT nBitmapID)
{
	return LoadDIBResource(MAKEINTRESOURCE(nBitmapID)); 
}

BOOL CBitmapWnd::Create(LPCSTR lpszBitmapName, DWORD dwStyle,
	const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	int dcRaster = 0;

	{
		CClientDC dc(NULL);
		dcRaster = dc.GetDeviceCaps(RASTERCAPS);
	}

	BOOL bUsePalette = (dcRaster & RC_PALETTE) != 0;

	m_lpDIB = LoadDIBResource(lpszBitmapName);
	if (m_lpDIB == NULL)
		return FALSE;
	
	if (bUsePalette)
	{
		m_pPalette = CreateDIBPalette(m_lpDIB);
		if (m_pPalette == NULL)
			return FALSE;
	}

	int x = rect.left;
	int y = rect.top;
	int cxWidth = rect.right - rect.left;
	int cyHeight = rect.bottom - rect.top;
	if (cxWidth == CW_USEDEFAULT)
	{
		x = 0;
		y = 0;
		cxWidth = DIBWidth(m_lpDIB);
		cyHeight = DIBHeight(m_lpDIB);
	}

	if (rect.left == CW_USEDEFAULT)
	{
		// [multimon] 7 mar 97 - der - this is the splash screen
		//x += GetSystemMetrics(SM_CXSCREEN) / 2 - cxWidth / 2;
		//y += GetSystemMetrics(SM_CYSCREEN) / 2 - cyHeight / 2;		

		// Center on the current monitor.
		CRect rect(x,y,x+cxWidth, y+cyHeight) ;
		CenterRectToMonitor(pParentWnd->GetSafeHwnd(), &rect, TRUE) ;
		x = rect.left ;
		y = rect.top;
	}

	return CreateEx(0,
		AfxRegisterWndClass(0, AfxGetApp()->LoadStandardCursor(IDC_ARROW)),
		NULL, dwStyle, x, y, cxWidth, cyHeight, pParentWnd->GetSafeHwnd(), NULL);
}

void CBitmapWnd::OnPaletteChanged(CWnd* pFocusWnd)
{
	if (pFocusWnd == this)
		return;
	
	OnQueryNewPalette();
}

BOOL CBitmapWnd::OnQueryNewPalette()
{
	if (m_pPalette == NULL)
		return FALSE;
	
	// BLOCK
	{
		CClientDC dc(this);
		CPalette* pOldPalette = dc.SelectPalette(m_pPalette,
			GetCurrentMessage()->message == WM_PALETTECHANGED);
		UINT nChanged = dc.RealizePalette();
		dc.SelectPalette(pOldPalette, TRUE);

		if (nChanged == 0)
			return FALSE;
	}
	
	Invalidate(FALSE);
	
	return TRUE;
}

void CBitmapWnd::OnPaint()
{
	CPaintDC dc(this);
	OnDraw(&dc);
}

void CBitmapWnd::OnDraw(CDC* pDC)
{
	CPalette* pOldPalette = NULL;
	
	if (m_pPalette != NULL)
	{
		pOldPalette = pDC->SelectPalette(m_pPalette, FALSE);
		pDC->RealizePalette();
	}
	
	SetDIBitsToDevice(pDC->m_hDC, 0, 0, DIBWidth(m_lpDIB), DIBHeight(m_lpDIB),
		0, 0, 0, DIBHeight(m_lpDIB), FindDIBBits(m_lpDIB), 
		(LPBITMAPINFO)m_lpDIB, DIB_RGB_COLORS);
	
	if (m_pPalette != NULL)
		pDC->SelectPalette(pOldPalette, TRUE);
}

/////////////////////////////////////////////////////////////////////////////

class CSplashScreen : public CBitmapWnd
{
public:
	CSplashScreen();

protected:
	void OnDraw(CDC* pDC);
#if HIGHLIGHT
	void AddOn(int nImageIndex);
	LPSTR m_lpHighlightDIB;

	DWORD m_grfAddOnImages;
#endif
};

#if HIGHLIGHT
static RECT rgrectProducts [] =
{
	{ 22, 26, 157, 151 },	// Visual C++
	{ 177, 22, 322, 138 },	// FORTRAN PowerStation
	{ 329, 31, 474, 141 },	// Visual Test
	{ 481, 23, 626, 133 },	// Developer Library
};
#endif

CSplashScreen::CSplashScreen()
{
#if HIGHLIGHT
	CClientDC dc(NULL);
	m_lpHighlightDIB = LoadDIBResource((dc.GetDeviceCaps(PLANES) * dc.GetDeviceCaps(BITSPIXEL)) < 8 ? 
		IDB_SPLASH16_GR : IDB_SPLASH_GR);

	m_grfAddOnImages = 0;
#endif
}

#if HIGHLIGHT
void CSplashScreen::AddOn(int nImageIndex)
{
	ASSERT(nImageIndex >= 0 && nImageIndex < 4);
	m_grfAddOnImages |= 1 << nImageIndex;
	InvalidateRect(&rgrectProducts[nImageIndex], FALSE);
	UpdateWindow();
}
#endif

void CSplashScreen::OnDraw(CDC* pDC)
{
	CBitmapWnd::OnDraw(pDC);

	CFont* pOldFont = pDC->SelectObject(GetStdFont(font_Bold));
	pDC->SetBkMode(TRANSPARENT);

	// LOCALIZATION NOTE: This rectangle should be set to the area of the
	// splash screen bitmap that contains the licensing information lines.
	// This information is displayed in the form:
	//
	//     Licensed to:
	//
	//     <name of licensee>
	//     <name of company>
	//
	CString str; str.LoadString(IDS_LICENSEDTO);
	CRect rect;
	rect.SetRect(87, 214, 400, 274);	// Bitmap Specific!


	char chM = 'M';
	int cyEmm = pDC->GetTextExtent(&chM, 1).cy;

	// NOTE: If this assertion fails, the rect is not big enough to
	// hold the licensee text and should be adjusted (which may require
	// adjusting SPLASH.BMP as well)...
	//ASSERT(rect.Height() >= cyEmm * 4);

	int Y = rect.bottom - 3 * cyEmm;

	pDC->ExtTextOut(rect.left, Y, 0, NULL, // [removed] ETO_CLIPPED, rect,
		str, str.GetLength(), NULL);
	Y += cyEmm;


	LPTSTR szUser, szOrg;
#ifdef _DEBUG
	szUser = szVerUser;
	szOrg = "Team VC++";
#else
	szUser = productInfo.szLicenseName;
	szOrg = productInfo.szLicenseCompany;
#endif
	pDC->SelectObject(GetStdFont(font_Normal));
	pDC->ExtTextOut(rect.left, Y, 0, NULL, // [removed] ETO_CLIPPED, rect,
		szUser, lstrlen(szUser), NULL);
	Y += cyEmm;

	pDC->ExtTextOut(rect.left, Y, 0, NULL, // [removed] ETO_CLIPPED, rect,
		szOrg, lstrlen(szOrg), NULL);

	pDC->SelectObject(pOldFont);
	
#if HIGHLIGHT
	if (m_lpHighlightDIB == NULL)
		return;
#endif
	
	CPalette* pOldPalette = NULL;
	
	if (m_pPalette != NULL)
	{
		pOldPalette = pDC->SelectPalette(m_pPalette, FALSE);
		pDC->RealizePalette();
	}

#if HIGHLIGHT
// [mikearn]  This behavior is going away; comment out for now
//	for (int nImageIndex = 0; nImageIndex < 4; nImageIndex += 1)
//	{
//		if ((m_grfAddOnImages & (1 << nImageIndex)) != 0)
//		{
//			rect = rgrectProducts[nImageIndex];
//			SetDIBitsToDevice(pDC->m_hDC, rect.left, rect.top, rect.Width(), rect.Height(),
//				rect.left, DIBHeight(m_lpHighlightDIB) - rect.bottom, 0, DIBHeight(m_lpHighlightDIB), FindDIBBits(m_lpHighlightDIB), 
//				(LPBITMAPINFO)m_lpHighlightDIB, DIB_RGB_COLORS);
//		}
//	}
#endif

	if (m_pPalette != NULL)
		pDC->SelectPalette(pOldPalette, TRUE);
}

void ShowSplashScreen(BOOL bShow)
{
	if (bShow)
	{
		int dcPlanes = 0, dcPix = 0;
		{
			CClientDC dc(NULL);
			dcPlanes = dc.GetDeviceCaps(PLANES);
			dcPix = dc.GetDeviceCaps(BITSPIXEL);
		}
		BOOL bUseLowColor = (dcPlanes * dcPix) < 8;
		BOOL fEntreprise = FALSE;

		ASSERT(pSplash == NULL);
		pSplash = new CSplashScreen;


#if 0	// 23Feb98 FabriceD We now have seperate builds for Std/Pro/Ent
		LPCTSTR lpszExtensionDir = theApp.GetExeString(DefaultExtensionDir);
		if (lstrlen(lpszExtensionDir) > 0)
		{
			TCHAR szIDEDir [_MAX_PATH];
			
			// Get the directory of the IDE executable
			{
				TCHAR szPath [_MAX_PATH];
				TCHAR szDir [_MAX_DIR];
				GetModuleFileName(NULL, szPath, _MAX_PATH);
				_tsplitpath(szPath, szIDEDir, szDir, NULL, NULL);
				_tcscat(szIDEDir, szDir);
			}
			
			_tcscat(szIDEDir, lpszExtensionDir);
#ifndef _DEBUG
			_tcscat(szIDEDir, _TEXT("\\DEVENT.PKG"));
#else
			_tcscat(szIDEDir, _TEXT("\\DEVENTD.PKG"));
#endif
			if(_access(szIDEDir, 00) != -1)
				fEntreprise = TRUE;
		}
#endif
		int IDSplash;
		IDSplash = bUseLowColor ? IDB_VC16 : IDB_VC256;

		if (!pSplash->Create(IDSplash,
			WS_POPUP | WS_VISIBLE,
			CFrameWnd::rectDefault, AfxGetApp()->m_pMainWnd))
		{
			delete pSplash;
			pSplash = NULL;
			return;
		}

		pSplash->UpdateWindow();
	}
	else
	{
		if (pSplash != NULL)
		{
			// Speed 4634 [paulde] 
			// use temp to protect against reentrancy/double destruction
			CSplashScreen *pwnd = pSplash;
			pSplash = NULL;
			pwnd->ShowWindow(SW_HIDE);
			AfxGetApp()->m_pMainWnd->UpdateWindow();
			delete pwnd;
		}
	}
}

CWnd *PwndSplashScreen(void)
{
	return pSplash;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

void Draw3dRect(CDC* pDC, const CRect& rect, BOOL bIn)
{
	pDC->Draw3dRect(rect, GetSysColor(bIn ? COLOR_3DSHADOW : COLOR_3DHILIGHT),
		GetSysColor(bIn ? COLOR_3DHILIGHT : COLOR_3DSHADOW));
}



CPtrList CAddOn::c_addons;

CAddOn::CAddOn()
{
	// Add our object to the global list
	c_addons.AddTail(this);
}

CAddOn::~CAddOn()
{
	// Remove our object from the global list
	POSITION pos = c_addons.Find(this);
	if (pos != NULL)
	{
		c_addons.RemoveAt(pos);
	}
}

CAddOn::CAddOn(int nSplashImageIndex)
{
	c_addons.AddTail(this);

#if HIGHLIGHT
	if (pSplash != NULL)
		pSplash->AddOn(nSplashImageIndex);
#endif
}

const TCHAR* CAddOn::GetAboutString()
{
	return NULL;
}

HICON CAddOn::GetIcon()
{
	return NULL;
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
#ifndef _SHIP
static BOOL GetModuleVersion (LPTSTR szModName, CString& strVer)
{
	// GetFileVersionInfoSize() and GetFileVersionInfo() deal with the version 
	// information buffer size in *characters* (as an abstract concept, in the 
	// sense that UNICODE characters are two bytes each).

	DWORD	dwHandle;
	DWORD	dwVerInfoSize	= GetFileVersionInfoSize(szModName, &dwHandle);
	BOOL	bRet			= FALSE;

	// Check if the module has version info
	if (dwVerInfoSize != 0)
	{
		// Note that while the string block's FileVersion is a string, it could
		// also be retreived as 4 WORDs from the VS_FIXEDFILEINFO block.
		LPVOID	pvVerInfo	= new TCHAR[dwVerInfoSize];
		LPTSTR	szSubBlock	= "\\StringFileInfo\\040904B0\\FileVersion";

		// Get the version info
		if (::GetFileVersionInfo(szModName, dwHandle, dwVerInfoSize, pvVerInfo))
		{
			// Get the file version
			UINT	nValueSize;
			LPVOID	pvValue;
			if (::VerQueryValue(pvVerInfo, szSubBlock, &pvValue, &nValueSize))
			{
				bRet = TRUE;
				strVer.Format("%s", pvValue);
			}
		}

		// Free our buffer
		delete[] pvVerInfo;
	}

	return bRet;
}
#endif	// ifndef _SHIP

class CAboutDlg : public C3dDialog
{
	enum AboutDlg_const
	{
		cPadding	= 3,
		cxMargin	= 8,
		cyMargin	= 8
	};

public:
	CAboutDlg ();
	virtual BOOL	OnInitDialog ();

	void			Draw3dRect (CDC& dc, const CRect& rctSrc);
	CSize			DrawAddInfo (CDC& dc);
	void			PaintAddInfo (CDC& dc);

	CString			m_strTitle;
	CString			m_strCopyright;
	CString			m_strLicenseInfoCaption;
	CString			m_strSerialNumberPrefix;
	CString			m_strSerialNumber;
	CString			m_strAddInfoCaption;
	CString			m_strWarning;
	CString			m_strVer;

	CFont			m_fntTitle;
	CFont			m_fntWarning;

	CBitmap			m_bmpDevStudio;
	CBitmap			m_bmpAddInfo;

	CRect			m_rctLicenseInfo;
	CRect			m_rctAddInfo;
	CRect			m_rctWarning;
	CRect			m_rctVer;

	CPoint			m_ptMouse;
	CPoint			m_ptTitle;
	CPoint			m_ptCopyright;
	CPoint			m_ptLicenseInfoCaption;
	CPoint			m_ptLicenseName;
	CPoint			m_ptLicenseCompany;
	CPoint			m_ptSerialNumberPrefix;
	CPoint			m_ptSerialNumber;
	CPoint			m_ptAddInfoCaption;
	CPoint			m_ptWarningLine;
	
	HINSTANCE		m_hInst;

	int				m_cxWarningLine;
	CPoint			m_ptScroll;
	CSize			m_sizeAddInfoImage;

	afx_msg void	OnPaint ();
	afx_msg LRESULT OnCommandHelp (WPARAM, LPARAM);
	afx_msg void	OnLButtonDblClk (UINT nFlags, CPoint point);
	afx_msg void	OnTimer (UINT nEventID);
	afx_msg void	OnLButtonDown (UINT nFlags, CPoint point);
	afx_msg void	OnMouseMove (UINT nFlags, CPoint point);
	afx_msg void	OnLButtonUp (UINT nFlags, CPoint point);

	DECLARE_MESSAGE_MAP()
};

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
CAboutDlg::CAboutDlg() 
	: C3dDialog(IDD_ABOUTBOX),
	m_hInst(NULL),
	m_ptScroll(0, 0),
	m_sizeAddInfoImage(0, 0)
{
	//TODO: Add any additional construction here
}

BEGIN_MESSAGE_MAP(CAboutDlg, C3dDialog)
	ON_WM_PAINT()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	ON_WM_LBUTTONDBLCLK()
	ON_WM_TIMER()
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
END_MESSAGE_MAP()

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
BOOL CAboutDlg::OnInitDialog ()
{
	/* 
		RAID BUG - DevStudio 96 #5632 
		The Additional Information box was not wide enough to show copyright strings
		for some of the packages. This dialog consists of only a single button. The 
		rest of the dialog is manually painted onto the background. Everything is 
		sized based on the title IDS_ABOUTTITLE. Therefore, I add a padding string
		to the title to get to make it larger and to also center it above the 
		rectangle. See Lines marked TITLE PADDING. The padding string is currently
		5 blanks and is found in IDS_ABOUTTITLEPADDING. NOTE that this dialog is 
		getting large and on my system is about 550x450.
	*/
	CString strPadding;
	VERIFY(strPadding.LoadString(IDS_ABOUTTITLEPADDING));	

	CClientDC	dc(this);

	// REVIEW(ChauV): Check standards for font usage in Dolphin J
	// [olympus 14563 - chauv] check for Japanese codepage and use appropriate font
	int			yLogPixels		= dc.GetDeviceCaps(LOGPIXELSY);
	if (_getmbcp() != 932)
	{
		m_fntTitle.CreateFont(-MulDiv(10, yLogPixels, 72),
			0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
			ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, "MS Sans Serif");

		m_fntWarning.CreateFont(-MulDiv(7, yLogPixels, 72),
			0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
			ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, "Small Fonts");
	}
	else
	{
		m_fntTitle.CreateFont(-MulDiv(10, yLogPixels, 72),
			0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
			SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "lr oSVbN");

		m_fntWarning.CreateFont(-MulDiv(9, yLogPixels, 72),
			0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
			SHIFTJIS_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "lr oSVbN");
	}
	
	// Get the bitmap
	BITMAP		bitmap;
	HINSTANCE	hInstance		= ::AfxGetResourceHandle();
	HRSRC		hResource		= ::FindResource(hInstance, MAKEINTRESOURCE(IDB_ABOUT), RT_BITMAP);
	ASSERT(hResource != NULL);
	m_bmpDevStudio.Attach(::AfxLoadSysColorBitmap(hInstance, hResource));
	m_bmpDevStudio.GetBitmap(&bitmap);

	// Get the dialog title string
	CFont*		pfntOld			= dc.SelectObject(&m_fntTitle);
	VERIFY(m_strTitle.LoadString(IDS_ABOUTTITLE));	
	m_strTitle = strPadding + m_strTitle + strPadding ; // TITLE PADDING
	CSize		sizeTitle		= dc.GetTextExtent(m_strTitle);
	m_ptTitle.x					= cxMargin * 3 + bitmap.bmWidth;
	m_ptTitle.y					= cyMargin;
	
	// Get the copyright string
	dc.SelectObject(::GetStdFont(font_Bold));
	VERIFY(m_strCopyright.LoadString(IDS_COPYRIGHT));
	m_strCopyright = strPadding + m_strCopyright + strPadding ; // TITLE PADDING
	CSize		sizeCopyright	= dc.GetTextExtent(m_strCopyright);
	m_ptCopyright.x				= m_ptTitle.x;
	m_ptCopyright.y				= m_ptTitle.y + sizeTitle.cy + cPadding;

	// Set the location for the LicenseInfo caption
	VERIFY(m_strLicenseInfoCaption.LoadString(IDS_PRODUCTLICENSEDTO));
	m_ptLicenseInfoCaption.x	= m_ptTitle.x;
	m_ptLicenseInfoCaption.y	= m_ptCopyright.y + sizeCopyright.cy + cyMargin;
	// Set the LicenseInfo rect
	CSize		size			= dc.GetTextExtent(m_strLicenseInfoCaption);
	m_rctLicenseInfo.top		= m_ptLicenseInfoCaption.y + size.cy + cPadding;
	m_rctLicenseInfo.left		= m_ptTitle.x;
	m_rctLicenseInfo.right		= m_rctLicenseInfo.left + max(sizeTitle.cx, sizeCopyright.cx);
	// License name
	m_ptLicenseName.x			= m_rctLicenseInfo.left + cPadding;
	m_ptLicenseName.y			= m_rctLicenseInfo.top + cPadding;
	dc.SelectObject(::GetStdFont(font_Normal));
	// License company
	size						= dc.GetTextExtent(productInfo.szLicenseName, _tcslen(productInfo.szLicenseName)); // DevStudio 96 Raid #6051. -1 is invalid.
	m_ptLicenseCompany.x		= m_ptLicenseName.x;
	m_ptLicenseCompany.y		= m_ptLicenseName.y + size.cy;
	size						= dc.GetTextExtent(productInfo.szLicenseCompany, _tcslen(productInfo.szLicenseCompany)); // DevStudio 96 Raid #6051. -1 is invalid.
	// Serial number prefix
	VERIFY(m_strSerialNumberPrefix.LoadString(IDS_SERIALNUMBER));
	m_ptSerialNumberPrefix.x	= m_ptLicenseCompany.x;
	m_ptSerialNumberPrefix.y	= m_ptLicenseCompany.y + size.cy + cPadding;
	// Serial number
	m_strSerialNumber			= productInfo.szSerialNumber;
	dc.SelectObject(::GetStdFont(font_Bold));
	size						= dc.GetTextExtent(m_strSerialNumberPrefix);
	m_ptSerialNumber.x			= m_ptSerialNumberPrefix.x + size.cx + cPadding;
	m_ptSerialNumber.y			= m_ptSerialNumberPrefix.y;
	m_rctLicenseInfo.bottom		= m_ptSerialNumber.y + size.cy + cPadding;

	// Set the AddInfo caption
	VERIFY(m_strAddInfoCaption.LoadString(IDS_ADDITIONS));
	m_ptAddInfoCaption.x		= m_ptLicenseInfoCaption.x;
	m_ptAddInfoCaption.y		= m_rctLicenseInfo.bottom + cyMargin + cPadding;

	// Set the AddInfo rect
	m_rctAddInfo.top			= m_ptAddInfoCaption.y + sizeCopyright.cy + cPadding;
	m_rctAddInfo.left			= m_rctLicenseInfo.left;
	m_rctAddInfo.right			= m_rctLicenseInfo.right;
	m_rctAddInfo.bottom			= m_rctAddInfo.top + (::GetSystemMetrics(SM_CYICON) + 2) * 3;

	// Move the OK button to the upper right corner of the dlg
	CWnd*		pwndOK			= GetDlgItem(IDOK);
	ASSERT_VALID(pwndOK);
	CRect		rect;
	pwndOK->GetWindowRect(rect);
	rect.OffsetRect(m_rctLicenseInfo.right + cxMargin * 2 - rect.left, cyMargin - rect.top);
	pwndOK->MoveWindow(rect);

	// Construct the warning text
	CString		str;
	VERIFY(m_strWarning.LoadString(IDS_WARNING1));
	VERIFY(str.LoadString(IDS_WARNING2));
	m_strWarning += str;
	VERIFY(str.LoadString(IDS_WARNING3));
	m_strWarning += str;
	VERIFY(str.LoadString(IDS_WARNING4));
	m_strWarning += str;
	VERIFY(str.LoadString(IDS_WARNING5));
	m_strWarning += str;
	VERIFY(str.LoadString(IDS_WARNING6));
	m_strWarning += str;
	VERIFY(str.LoadString(IDS_WARNING7));
	m_strWarning += str;

	// Set the position and length of the warning line
	m_ptWarningLine.x			= cxMargin;
	m_ptWarningLine.y			= m_rctAddInfo.bottom + cyMargin * 2;
	m_cxWarningLine				= rect.right - cxMargin;

	// Set the initial warning rect
	m_rctWarning.top			= m_ptWarningLine.y + 2 + cyMargin;
	m_rctWarning.left			= cxMargin;
	m_rctWarning.right			= rect.right;
	m_rctWarning.bottom			= 1000;		// Arbitrary large number

	// Calculate the actual warning rect
	dc.SelectObject(&m_fntWarning);
	dc.DrawText(m_strWarning, m_rctWarning,	DT_CALCRECT | DT_NOPREFIX | DT_WORDBREAK);

	// Set the size and position of the dlg client rect
	// Adjust based on client rect and center the window relative to the screen
	rect.SetRect(0,	0, rect.right + cxMargin, m_rctWarning.bottom + cyMargin);

	// [multimon] 7 mar 97 - der
	//rect.OffsetRect(::GetSystemMetrics(SM_CXSCREEN) / 2 - rect.Width() / 2,
	//	::GetSystemMetrics(SM_CYSCREEN) / 2 - rect.Height() / 2);
	CenterRectToMonitor(GetSafeHwnd(), &rect, TRUE) ;

	::AdjustWindowRectEx(rect, GetStyle(), FALSE, GetExStyle());
	MoveWindow(rect);
		
	MyPlaySound("Media\\The Microsoft Sound.wav", NULL, SND_ASYNC | SND_FILENAME | SND_NODEFAULT);

#if defined(_WIN32) && !defined(_SHIP)
	// Get the minor version number from one of the packages
	TCHAR		szName[_MAX_PATH];
	POSITION	pos				= theApp.m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage*	pPackage	= (CPackage *) theApp.m_packages.GetNext(pos);
		::GetModuleFileName(pPackage->HInstance(), szName, _MAX_PATH);

		if (GetModuleVersion(szName, m_strVer))
		{
#ifdef _DEBUG
			m_strVer += "\n" szVerUser;
#endif
			m_rctVer.left		= cxMargin;
			m_rctVer.top		= cyMargin + bitmap.bmHeight + cPadding;
			m_rctVer.bottom		= m_rctVer.top + cPadding;	// + cyStdChar
			m_rctVer.right		= m_rctVer.left + bitmap.bmWidth;
			dc.DrawText(m_strVer, &m_rctVer, DT_CALCRECT | DT_NOPREFIX | DT_CENTER | DT_WORDBREAK);
			break;
		}
	}
#endif //_WIN32 && !_SHIP
	
	// Restore our device context objects
	dc.SelectObject(pfntOld);

	return TRUE;
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
LRESULT CAboutDlg::OnCommandHelp (WPARAM, LPARAM)
{
	// The About dialog does not have any help.
	return TRUE;
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
void CAboutDlg::OnTimer (UINT nEventID)
{
	// Scroll the image
	m_ptScroll.y += 2;

	// Wrap around if necessary
	if (m_ptScroll.y >= m_sizeAddInfoImage.cy)
	{
		m_ptScroll.y = 0;
	}

	// Paint the scrolling image
	CClientDC dc(this);
	PaintAddInfo(dc);
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
void CAboutDlg::OnLButtonDown (UINT nFlags, CPoint point)
{
	// Let the user drag-scroll if the whole image is not already 
	// visible and the user clicks in the AddInfo rect
	if (m_rctAddInfo.Height() < m_sizeAddInfoImage.cy 
		&& m_rctAddInfo.PtInRect(point))
	{
		KillTimer(0);
		SetCapture();
		ASSERT(GetCapture() == this);
		m_ptMouse = point;
	}
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
void CAboutDlg::OnMouseMove (UINT nFlags, CPoint point)
{
	if (GetCapture() == this)
	{
		// User is manually scrolling image with mouse
		m_ptScroll.y += m_ptMouse.y - point.y;
		m_ptScroll.x += m_ptMouse.x - point.x;
		m_ptMouse = point;

		// Constrain the vertical scrolling to the height of the image
		int cy = m_sizeAddInfoImage.cy - m_rctAddInfo.Height();
		if (cy <= 0 || m_ptScroll.y <= 0)
		{
			m_ptScroll.y = 0;
		}
		else if (m_ptScroll.y > cy)
		{
			m_ptScroll.y = cy;
		}

		// Constrain the horizontal scrolling to the width of the image
		int cx = m_sizeAddInfoImage.cx - m_rctAddInfo.Width();
		if (cx <= 0 || m_ptScroll.x <= 0)
		{
			m_ptScroll.x = 0;
		}
		else if (m_ptScroll.x > cx)
		{
			m_ptScroll.x = cx;
		}
		
		// Paint the image
		CClientDC dc(this);
		PaintAddInfo(dc);
	}
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
void CAboutDlg::OnLButtonUp (UINT nFlags, CPoint point)
{
	// Release the capture and resume normal scrolling
	if (GetCapture() == this)
	{
		ReleaseCapture();
		SetTimer(0, 100, NULL);
	}
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
void CAboutDlg::OnLButtonDblClk (UINT nFlags, CPoint pt)
{
	if (GetKeyState(VK_CONTROL) >= 0)
		return;

	if (m_hInst == NULL)
		m_hInst = ::LoadLibrary( "devcrd.dll" );

	if (m_hInst == NULL)
	{
		TCHAR szDrives[255];
		if (GetLogicalDriveStrings(254, szDrives) > 254)
			return;

		LPCTSTR pDrive = szDrives;
		while (*pDrive != _T('\0'))
		{
			if (GetDriveType(pDrive) == DRIVE_CDROM)
			{
				CString strLib;
				strLib = pDrive;
				strLib += "common\\msdev98\\bin\\devcrd.dll";
				m_hInst = ::LoadLibrary(strLib);
				if (m_hInst != NULL)
					break;
			}
			pDrive = pDrive + lstrlen(pDrive) + 1;
		}
	}

	if (m_hInst != NULL)
	{
		BOOL (*lpProc)(CWnd*);
		lpProc = (BOOL (*)(CWnd*)) ::GetProcAddress(m_hInst, "StartCredits");
		if (lpProc == NULL)
		{
			::FreeLibrary(m_hInst);
			m_hInst = NULL;
			return;
		}

		(*lpProc)(this);
		::FreeLibrary(m_hInst);
		m_hInst = NULL;
	}
}

//-------------------------------------------------------------------------------
// DrawAddInfo:	Renders the whole AddInfo image used to scroll in the 
//		AddInfo	rect.
//-------------------------------------------------------------------------------
CSize CAboutDlg::DrawAddInfo (CDC& dc)
{
	// Set modes and colors
	dc.SetBkMode(TRANSPARENT);
	dc.SetTextColor(::GetSysColor(COLOR_BTNTEXT));
	dc.SetBkColor(::GetSysColor(COLOR_BTNFACE));

	// Constants
	const int	cPadding		= 1;
	const int	cxIcon			= ::GetSystemMetrics(SM_CXICON) + cPadding * 2;
	const int	cyIcon			= ::GetSystemMetrics(SM_CYICON) + cPadding * 2;

	// Total size of our AddInfo image; make sure the image is 
	//	at least as wide as the clipping rectangle so that our
	//	separating lines go all the way across
	CSize	sizeTotal(m_rctAddInfo.Width(), cPadding);

	// Paint the background
	dc.FillSolidRect(0, 0, m_sizeAddInfoImage.cx, m_sizeAddInfoImage.cy, ::GetSysColor(COLOR_BTNFACE));

	// Get the extent of standard character	
	dc.SelectObject(::GetStdFont(font_Normal));
	const TCHAR	chStd			= _T('M');
	int		cyStdChar			= dc.GetTextExtent(&chStd, 1).cy;

	// Loop through AddOns
	POSITION pos = CAddOn::GetHeadPosition();
	while (pos != NULL)
	{
		// Get the AddOn object
		CAddOn *pAddOn	= CAddOn::GetNext(pos);
		if (pAddOn == NULL)
		{
			ASSERT(FALSE);
			continue;
		}

// [mikearn] This feature was cut
//		// Get and draw the icon
//		HICON		hAddIcon	= pAddOn->GetIcon();
//		if (hAddIcon != NULL)
//		{
//			dc.DrawIcon(cPadding, sizeTotal.cy + cPadding, hAddIcon);
//		}

		// Get the About string
		const TCHAR* szAbout	= pAddOn->GetAboutString();
		if (szAbout == NULL)
		{
			ASSERT(FALSE);
			continue;
		}

		// Parse and draw the About string
		BOOL		bBold		= FALSE;
		int			cxLine		= cxIcon;
		int			cyLine		= cPadding;

		while (szAbout[0] != '\0')
		{
			const TCHAR* pch = szAbout; 
			while (*pch != '\0' && *pch != '\n' && *pch != '\b')
			{
				pch = _tcsinc(pch);
			}

			int	cch = (int)(pch - szAbout);
			if (cch > 0)
			{
				dc.SelectObject((bBold) ? ::GetStdFont(font_Bold) : ::GetStdFont(font_Normal));
				dc.TextOut(cxLine, sizeTotal.cy + cyLine, szAbout, cch);
				cxLine += dc.GetTextExtent(szAbout, cch).cx;
				if (cxLine > sizeTotal.cx)
				{
					sizeTotal.cx = cxLine;
				}
			}

			switch (*pch)
			{
			case '\n':
				pch = _tcsinc(pch);
				// FALL THROUGH

			case '\0':
				cyLine += cyStdChar;
				cxLine = cxIcon;
				break;

			case '\b':
				bBold = !bBold;
				pch = _tcsinc(pch);
				break;
			}

			szAbout = pch;
		}

		// Increment the total height value
		sizeTotal.cy += max(cyLine, cyIcon);

		// Draw the separating line
		if (pos != NULL || sizeTotal.cy > m_rctAddInfo.Height())
		{
			CBrush*		pbrOld = dc.SelectObject(::GetSysBrush(COLOR_3DSHADOW));
			int			nWidth = sizeTotal.cx - cPadding * 2;
			dc.PatBlt(cPadding, sizeTotal.cy++, nWidth, 1, PATCOPY);
			dc.SelectObject(::GetSysBrush(COLOR_3DHIGHLIGHT));
			dc.PatBlt(cPadding, sizeTotal.cy++, nWidth, 1, PATCOPY);
			dc.SelectObject(pbrOld);
		}
	}

	// Return the total size of our AddInfo image
	return sizeTotal;
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
void CAboutDlg::PaintAddInfo (CDC& dc)
{
	CDC		dcAddInfo;

	// Create compatible dc and use that
	if (dcAddInfo.CreateCompatibleDC(&dc))
	{
		// Select bitmap
		dcAddInfo.SelectObject(&m_bmpAddInfo);

		// Get the height of the image
		int cyTopHalf = m_sizeAddInfoImage.cy - m_ptScroll.y;
		if (cyTopHalf > m_rctAddInfo.Height())
		{
			cyTopHalf = m_rctAddInfo.Height();
		}

		int cxLeftHalf = m_sizeAddInfoImage.cx - m_ptScroll.x;
		if (cxLeftHalf > m_rctAddInfo.Width())
		{
			cxLeftHalf = m_rctAddInfo.Width();
		}
		
		// Paint the image
		dc.BitBlt(m_rctAddInfo.left, m_rctAddInfo.top, cxLeftHalf,
			cyTopHalf, &dcAddInfo, m_ptScroll.x, m_ptScroll.y, SRCCOPY);

		// If the image is wrapping, paint the beginning
		if (cyTopHalf < m_sizeAddInfoImage.cy)
		{
			dc.BitBlt(m_rctAddInfo.left, m_rctAddInfo.top + cyTopHalf,
				cxLeftHalf, m_rctAddInfo.Height() - cyTopHalf, &dcAddInfo,
				m_ptScroll.x, 0, SRCCOPY);
		}
	}
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
void CAboutDlg::OnPaint ()
{
	// Set the background mode and text color
	CPaintDC	dc(this);
	dc.SetBkMode(TRANSPARENT);
	dc.SetBkColor(::GetSysColor(COLOR_BTNFACE));
	dc.SetTextColor(::GetSysColor(COLOR_BTNTEXT));

	// Draw the DevStudio logo bitmap
	{
		BITMAP		bitmap;
		VERIFY(m_bmpDevStudio.GetBitmap(&bitmap));

		CDC			dcMem;
		dcMem.CreateCompatibleDC(&dc);

		CBitmap*	pbmpOld = dcMem.SelectObject(&m_bmpDevStudio);
		dc.BitBlt(cxMargin, cyMargin, bitmap.bmWidth, bitmap.bmHeight,
			&dcMem, 0, 0, SRCCOPY);
		dcMem.SelectObject(pbmpOld);
	}

	// Draw the title string
	CFont*		pfntOld = dc.SelectObject(&m_fntTitle);
	dc.TextOut(m_ptTitle.x, m_ptTitle.y, m_strTitle);

	// Draw the copyright string
	dc.SelectObject(::GetStdFont(font_Bold));
	dc.TextOut(m_ptCopyright.x, m_ptCopyright.y, m_strCopyright);

	// Draw the license caption string
	dc.TextOut(m_ptLicenseInfoCaption.x, m_ptLicenseInfoCaption.y, m_strLicenseInfoCaption);

	// Draw the license info strings
	// Name
	dc.SelectObject(::GetStdFont(font_Normal));
	dc.TextOut(m_ptLicenseName.x, m_ptLicenseName.y, productInfo.szLicenseName,
		_tcslen(productInfo.szLicenseName));
	// Company
	dc.TextOut(m_ptLicenseCompany.x, m_ptLicenseCompany.y, productInfo.szLicenseCompany,
		_tcslen(productInfo.szLicenseCompany));

	// Serial number prefix
	dc.SelectObject(::GetStdFont(font_Bold));
	dc.TextOut(m_ptSerialNumberPrefix.x, m_ptSerialNumberPrefix.y, m_strSerialNumberPrefix);
	// Serial number itself
	dc.SelectObject(::GetStdFont(font_Normal));
	dc.TextOut(m_ptSerialNumber.x, m_ptSerialNumber.y, m_strSerialNumber);

	// Draw the license rect
	Draw3dRect(dc, m_rctLicenseInfo);

	// Draw AddInfo caption
	dc.SelectObject(::GetStdFont(font_Bold));
	dc.TextOut(m_ptAddInfoCaption.x, m_ptAddInfoCaption.y, m_strAddInfoCaption);

	// Draw AddInfo rect
	Draw3dRect(dc, m_rctAddInfo);

	// Get the AddInfo image
	if (m_bmpAddInfo.m_hObject == NULL)
	{
		CDC			dcAddInfo;
		dcAddInfo.CreateCompatibleDC(&dc);
		m_sizeAddInfoImage = DrawAddInfo(dcAddInfo);
		m_bmpAddInfo.CreateCompatibleBitmap(&dc, m_sizeAddInfoImage.cx,
			m_sizeAddInfoImage.cy);

		CBitmap*	pbmpOld = dcAddInfo.SelectObject(&m_bmpAddInfo);
		DrawAddInfo(dcAddInfo);
		dcAddInfo.SelectObject(pbmpOld);

		// Set the timer to scroll if the image is larger than the rect
		if (m_sizeAddInfoImage.cy > m_rctAddInfo.Height())
		{
			SetTimer(0, 100, NULL);
		}
	}

	// Paint the AddInfo image
	PaintAddInfo(dc);

	// Draw the line above the warning text
	CBrush*		pbrOld	= dc.SelectObject(::GetSysBrush(COLOR_3DSHADOW));
	dc.PatBlt(m_ptWarningLine.x, m_ptWarningLine.y, m_cxWarningLine, 1, PATCOPY);
	dc.SelectObject(::GetSysBrush(COLOR_3DHIGHLIGHT));
	dc.PatBlt(m_ptWarningLine.x, m_ptWarningLine.y + 1, m_cxWarningLine, 1, PATCOPY);

	// Draw the warning text
	dc.SelectObject(&m_fntWarning);
	dc.DrawText(m_strWarning, m_rctWarning, DT_NOPREFIX | DT_CENTER | DT_WORDBREAK);

#if defined(_WIN32) && !defined(_SHIP)
	// Draw the VerUser stuff
	dc.DrawText(m_strVer, &m_rctVer, DT_NOPREFIX | DT_CENTER | DT_WORDBREAK);
#endif

	// Restore device context objects
	dc.SelectObject(pfntOld);
	dc.SelectObject(pbrOld);
}

//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
void CAboutDlg::Draw3dRect (CDC& dc, const CRect& rctSrc)
{
	CRect	rect(rctSrc);
	rect.InflateRect(1, 1);
	dc.Draw3dRect(rect, ::GetSysColor(COLOR_3DDKSHADOW), ::GetSysColor(COLOR_3DLIGHT));
	rect.InflateRect(1, 1);
	dc.Draw3dRect(rect, ::GetSysColor(COLOR_3DSHADOW), ::GetSysColor(COLOR_3DHILIGHT));
}

//-------------------------------------------------------------------------------
// App command to run the dialog
//-------------------------------------------------------------------------------
void CTheApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
	if (aboutDlg.m_hInst != NULL)
		::FreeLibrary(aboutDlg.m_hInst);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\allpage2.h ===
/////////////////////////////////////////////////////////////////////////////
//	ALLPAGE.H
//		Defines all page classes which can be used to display a
//		grid based property page

#ifndef __ALLPAGE_H__
#define __ALLPAGE_H__

#include <proppage.h>

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

#define	TOBEUSED_AFTER_BETA1	1	// new stuff to be used after beta 1

#define	ALLPAGE_GUTTER			3
#define	ALLPAGE_HEADER_HEIGHT	26	// default height if GetDC fails

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
class CPropItem;
class CPropEdit;
class CPropButton;
class CPropList;
class CPropListBox;

enum ControlType {
	ctrl_Unknown,
	ctrl_Edit,
	ctrl_ComboLimitToList,
	ctrl_BuilderPerPropertyBrowsing,
	ctrl_BuilderProvidePropertyBuilder,
	ctrl_BuilderWizardManager,
	ctrl_BuilderWizardManagerIntrinsic,
	ctrl_BuilderInternal,
	ctrl_ComboNotLimitToList
};

enum DataType {
	data_Unknown = 0,
	data_Int2,			// VT_I2
	data_Int4,			// VT_I4
	data_Bool,			// VT_BOOL
	data_Color,			// VT_COLOR
	data_Font,			// VT_DISPATCH
	data_Picture,		// VT_DISPATCH
	data_UInt2,			// VT_UI2
	data_UInt4,			// VT_UI4
	data_Double,		// VT_R8
	data_String,		// VT_BSTR
	data_EnumString,	// VT_BSTR
	data_EnumInt2,		// VT_I2
	data_EnumInt4,		// VT_I4
	data_Path,			// VT_BSTR (url)
	data_Float,			// VT_R4
	data_Date,			// VT_DATE
	data_Currency		// VT_CY
};

/////////////////////////////////////////////////////////////////////////////
// C3dFontDialog - FontDialog which hides the Color Check Box

class C3dFontDialog : public CFontDialog
{
public:
	C3dFontDialog(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);

	virtual BOOL OnInitDialog();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	virtual int DoModal();

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CEnumData

class CEnumData
{
// Construction/Destruction
public:
	CEnumData()
			{
				m_bDirty = TRUE;
			}
	~CEnumData()
			{
				// just remove all the elements in the arrays
				m_straEnumStrings.RemoveAll();
				m_dwaCookies.RemoveAll();
			}

	BOOL	IsDirty()
			{
				return m_bDirty;
			}
	void	SetDirty(BOOL bDirty)
			{
				m_bDirty = bDirty;
			}

public:
	CStringArray	m_straEnumStrings;
	CDWordArray		m_dwaCookies;
	BOOL			m_bDirty;
};

/////////////////////////////////////////////////////////////////////////////
// CPropItem

class CPropItem
{
// Construction
public:
	CPropItem(LPCTSTR pszcText, VARTYPE vt, DataType dt, DISPID dispid);
	~CPropItem();

	void	GetNewEnumData();				// alloc memory for m_pEnumData
	BOOL	IsEnumDataDirty()
			{
				return (NULL == m_pEnumData) ? TRUE : m_pEnumData->IsDirty();
			}
	void	SetEnumDataDirty(BOOL bDirty)
			{
				if (NULL != m_pEnumData)
					m_pEnumData->SetDirty(bDirty);
			}
	void	SetDispid(ULONG ulIndex, DISPID dispid);

// Attributes
public:
	CString		m_strText;			// property label
	CString		m_strProp;			// property value
	ControlType	m_ctrlType;			// type of control required on grid
	DataType	m_dataType;			// type of data to be edited
	VARTYPE		m_vt;				// variant type

	union
	{
		int			m_nValue;
		DWORD		m_dwValue;
		float		m_fValue;
		double		m_dValue;
		DATE		m_date;
		CURRENCY	m_currency;
	} unionValue;

	BOOL		m_fEdit:1;		// in editing mode

	CEnumData*	m_pEnumData;	// data for enumeration

	int			m_iIndex;		// index of item for builder type

	// each ITypeInfo corresponds to one of the controls selected
	// i.e, for single selection, this array will contain 1 item
	CPtrArray	m_TypeInfoArrayEnumInt;	// array of ITypeInfo ptrs stored
								// for enumerated I2 and I4 data types
	ITypeInfo*	m_TypeInfo;		// copy of ITypeInfo interface stored in
								// COleAllPage (this is not addref'ed -- so don't release it)

	// NOTE:
	// of the following one of the pointers will be set to NULL depending upon
	// whether the property description was of type vardesc or funcdesc.
	// Also, only one pointer is stored because, when multiple controls are
	// selected, we would have already intersected the properties to make sure
	// that the property types are the same and when we need to get the property
	// again, we only need to use that for the first control selected
	LPVARDESC	m_pvd;		// pointer to vardesc of the first control selected
	LPFUNCDESC	m_pfd;		// pointer to funcdesc of the first control selected

	// The following members are used to cache DISPID's and will be enabled
	// soon -- till then, they will be populated with values and not used
	DISPID		m_Dispid;			// used for single selection
	DISPID*		m_pDispid;			// used for multiple selection

	// NOTE:
	// if you change the setting of the following value in the code, please
	// make sure that it is done properly since a lot of initialization and
	// termination depends upon this number.  Thanks.
	static ULONG	s_ulCountControls;	// count of controls selected
};

/////////////////////////////////////////////////////////////////////////////
// CPropEdit

class CPropEdit : public CEdit
{
	friend class CPropListBox;

// Construction
public:
	CPropEdit();

// Attributes
public:
	CPropItem*	m_pItem;
	CPropList*	m_pLb;
	CPropButton*	m_pBtn;
	
protected:
	BOOL	SaveProperty();

	// Generated message map functions
protected:
	//{{AFX_MSG(CPropEdit)
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPropButton

class CPropButton : public CButton
{
// Construction
public:
	CPropButton();

// Attributes
public:
	CPropItem*	m_pItem;

private:
	long	m_lBtnWidth;
	long	m_lBtnHeight;

// Operations
public:
	void	SetBtnDimensions();
	long	GetBtnWidth()
			{
				return m_lBtnWidth;
			}
	long	GetBtnHeight()
			{
				return m_lBtnHeight;
			}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropButton)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

protected:
	//{{AFX_MSG(CPropButton)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPropList

class CPropList : public CListBox
{
// Construction
public:
	CPropList();

// Attributes
public:
	CPropEdit *m_pTxt;

// Implementation
public:
	void	FillContents(CPropItem *pItem);
	void	PositionToProperty(CRect *pRect, CPropItem *pItem);
	void	SelectNext();
	void	SelectPrev();
	void	SelectLimitToList(LPCTSTR pszcItem);
	void	SelectNextItemInList();

	void	SetParentListBoxPtr(CPropListBox* pPropListBox)
			{
				m_pPropListBox = pPropListBox;
			}

protected:
	void	UpdateEditControl();


	// Generated message map functions
protected:
	//{{AFX_MSG(CPropList)
	afx_msg void OnSelchange();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

protected:
	CPropListBox*	m_pPropListBox;
	int				m_iItemHeight;
};

/////////////////////////////////////////////////////////////////////////////
// CPropListBox window

class CPropListBox : public CListBox
{
	friend class CPropEdit;

// Construction
public:
	CPropListBox();

// Attributes
public:
	CPropEdit*		m_pTxt;
	CPropButton*	m_pBtn;
	CPropList*		m_pLb;
	C3dPropertyPage*	m_pPage;

	UINT			m_uiIndex;

// Operations
public:
	BOOL	CreateChildren();
	void	ResetContent();
	BOOL	PreTranslateMessage(MSG* pMsg);

	BOOL	UpdateProperty()
			{
				return ((m_pPage) ? m_pPage->Validate() : TRUE);
			}
	void	ShowEditControl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropListBox)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

protected:
	void	SetFocusAndCurSel();

// Implementation
public:
	virtual ~CPropListBox();

protected:

	// Generated message map functions
protected:
	//{{AFX_MSG(CPropListBox)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnDblclk();
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnSelchange();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	afx_msg void OnBtnClick();

	DECLARE_MESSAGE_MAP()

};
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
class COleAllPage : public CSlobPage
{
public:
	DECLARE_DYNAMIC(COleAllPage)

public:
	COleAllPage();
	~COleAllPage();

	virtual BOOL Create(UINT nIDSheet, CWnd* pWndOwner);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	virtual void InitializePage();
	virtual void InitPage();

	virtual BOOL Validate();
	virtual BOOL UndoPendingValidate();

	virtual LRESULT OnPageHelp(WPARAM wParam, LPARAM lParam);

	virtual void GetPageName(CString& strName)
			{
				strName = m_strName;
			}

	virtual void TermPage();
	virtual CSize GetPageSize();

	BOOL	Apply();
	HRESULT	ExecuteBuilder(CPropItem *pItem);
	HRESULT	SetPictureToNone(CPropItem* pItem);

	int		GetColumnWidth(int iCol)
			{
				if (iCol == 0)
					return m_ihcCol0Width;
				else if (iCol == 1)
					return m_ihcCol1Width;
				else
					return 0;
			}

	void	SetHeaderInfo();
	void	UpdateEnumData(CPropItem* pItem);

protected:
	void	FillPropList();
	BOOL	AddToMap(IDispatch *pDisp, CMapStringToPtr *pMap);
	BOOL	IntersectToMap(CMapStringToPtr *pMap, ULONG ulIndex);
	void	DeleteBindPtr(ITypeInfo *pTypeInfo, DESCKIND *pDescKind, BINDPTR *pBindPtr);	
	HRESULT	ApplyProperty(DISPID dispID, CPropItem* pItem, IDispatch *pDisp);
	void	ChangePageSize(CSize const& sizeNew);

	BOOL	IsIntrinsicBuilder(GUID guidBuilder);
	void	DetermineBuilderType(DISPID dispid, CPropItem* pItem);
	BOOL	DoesTypeInfoHasPathProperties(ITypeInfo* srpTypeInfoStart);

	void	GetNotifySinkInfo();
	void	FreeNotifySinkInfo();

	BOOL	CallGeneralPropertyBuilder(IDispatch* pAppDisp, IDispatch* pBuilderDisp,
				HWND hwndOwner, DISPID dispidExecute, VARIANT* pvarValue);
	BOOL	CallURLBuilder(IDispatch* pAppDisp, IDispatch* pControlDisp,
				IDispatch* pBuilderDisp, HWND hwndOwner, DISPID dispidExecute,
				VARIANT* pvarValue);
	HRESULT	SavePropertyForAllControls(VARIANT* pvarValue,
				CPropItem* pItem);

	ControlType GetControlBuilderType(DISPID dispid, IDispatch* pControlDisp);
	BOOL	GetPictureType(IDispatch* pPictDisp, CString& strProp);
	void	ReleaseInterfaces();
	void	ForcePropertyBrowserToshow();

	BOOL	IsPropTypeReadOnly(LPVARDESC pVarDesc, LPFUNCDESC pFuncDesc,
				BOOL bCheckForPutAndPutRef);
	DataType GetPropType(IDispatch* pDisp, LPTYPEINFO pTypeInfo, LPVARDESC pVarDesc,
				LPFUNCDESC pFuncDesc, BOOL bHasPathProperties);
	DataType DataTypeFromVT(TYPEDESC* pTypeDesc, LPTYPEINFO pTypeInfo);
	BOOL	IsPropAPathProperty(LPTYPEINFO pTypeInfo, DISPID dispid);
	DataType MapDataType(VARTYPE vt);
	BOOL	GetPropName(LPTYPEINFO pTypeInfo, DISPID dispid, CString& strPropName);
	BOOL	GetPropValueForEnumString(IDispatch* pDisp, DISPID dispid,
				CPropItem* pItem, VARIANT* pVarValue);
	BOOL	GetPropValueForEnumInt(LPTYPEINFO pTypeInfo, HREFTYPE hrefType,
				long lEnumValue, CPropItem* pItem, BOOL bSetAllDetails);
	BOOL	GetPropValueForOtherTypes(VARIANT* pVarValue, CPropItem* pItem);
	BOOL	GetPropValue(IDispatch* pDisp, DISPID dispid, VARIANT* pVarValue);
	BOOL	GetPropDetails(IDispatch* pDisp, LPTYPEINFO pTypeInfo,
				HREFTYPE hrefType, DISPID dispid, CPropItem* pItem,
				BOOL bSetAllDetails, VARIANT* pVarValue);
	BOOL	UpdateEnumIntData(int iControlIndex, DISPID dispid,
				CPropItem* pItem, long lEnumValue);
	BOOL	UpdateEnumStringData(IDispatch* pDisp, DISPID dispid,
				CPropItem* pItem, BOOL bUpdatePropValue);
	BOOL	IntersectPropEnumString(IDispatch* pDisp, DISPID dispid,
				CPropItem* pItem);
	BOOL	IntersectPropEnumInt(IDispatch* pDisp, DISPID dispid,
				CPropItem* pItem, LPTYPEINFO pTypeInfo, TYPEDESC* pTypeDesc);
	BOOL	IntersectPropItemData(IDispatch* pDisp, DISPID dispid,
				CPropItem* pItem, LPTYPEINFO pTypeInfo, TYPEDESC* pTypeDesc);
	void	UpdateChangedProperties();

	HRESULT	ExecutePPBBuilder(IDispatch* pDisp, DISPID dispid);
	HRESULT	ExecuteInternalBuilder(CPropItem* pItem, VARIANT* pVarValue);
	HRESULT	ExecuteBWMIntrinsicBuilder(CPropItem* pItem, VARIANT* pVarValue);
	HRESULT	ExecuteBWMAndPPBBuilder(CPropItem* pItem,
				DISPID dispid, VARIANT* pVarValue);

protected:
	CDWordArray	m_dwaCookies;	// dword array of cookies for propertynotifysink

// Attributes
protected:
	BOOL		m_bActive:1;
	BOOL		m_bUpdatingProps;	// kind of mutex to prevent
									// IPropertyNotifySink::OnChanged from triggering
									// in the middle of a BeginUndo before we actually start
									// setting the properties
	BOOL		m_bUpdateLater;		// used to optimize a little
									// when saving several properties, the
									// IPropertyNotifySink::OnChanged gets called
									// several times -- so use this flag to
									// to refresh at once later.

	CPropListBox	m_lbProps;
	CHeaderCtrl	m_hcProps;
	int			m_ihcHeight;
	int			m_ihcCol0Width;
	int			m_ihcCol1Width;
	BOOL		m_bSetHeader;

    COleDispatchDriver m_dispDriver;

	CSize		m_sizeMin;

	IDispatch*	m_pSingleDisp;
	IDispatch**	m_pprgDisp;
	ULONG		m_ulCountControls;
	CString		m_strName;

	// stores the number of ITypeInfo's that we get from the control
	// this is used by CPropItem when the property for one of the selected
	// control updates its value
	ITypeInfo*	m_pSingleTypeInfo;	// single typeinfo used in most cases
	ITypeInfo**	m_ppTypeInfo;	// array of ITypeInfo ptrs stored
	ULONG		m_ulTypeInfos;	// count of ITypeinfo's in the above array

// Message map
protected:
	afx_msg void OnEndTrackHeader(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnTrackHeader(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCommandHelp(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnInitDialog();

	DECLARE_MESSAGE_MAP()
	DECLARE_IDE_CONTROL_MAP()

	// Helper functions for PropertyNotifySink
	HRESULT	OnChanged(DISPID dispID);
	HRESULT OnRequestEdit(DISPID dispID);

// Interface Maps
	// IPropertyNotifySink
	BEGIN_INTERFACE_PART(PropertyNotifySink, IPropertyNotifySink)
		INIT_INTERFACE_PART(COleAllPage, PropertyNotifySink)
		STDMETHOD(OnChanged)(DISPID dispID);
		STDMETHOD(OnRequestEdit)(DISPID dispID);
	END_INTERFACE_PART(PropertyNotifySink);

	DECLARE_INTERFACE_MAP()
};

#ifdef _DEBUG
#undef THIS_FILE
#define THIS_FILE __FILE__
#endif

#undef AFX_DATA
#define AFX_DATA NEAR

#endif		// __ALLPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\allpage2.cpp ===
#include "stdafx.h"

#include <multinfo.h>
#include <proppage.h>
#include "resource.h"
#include "allpage2.h"

#include "utilauto.h"
#include <ocdesign.h>
#include <shldocs_.h>

#include <urlpdefs.h>

// IID_IForm needed for ISBug: 7249 - defined in forms3.h which wont compile
// in the devstudio tree
// {04598fc8-866c-11cf-ab7c-00aa00c08fcf}
DEFINE_GUID(IID_IForm, 
0x04598fc8, 0x866c, 0x11cf, 0xab, 0x7c, 0x0, 0xaa, 0x0, 0xc0, 0x8f, 0xcf);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// these two are taken from uuid.lib
EXTERN_C const GUID GUID_PathProperty;
EXTERN_C const GUID GUID_HasPathProperties;

// static data (begins with s_)
static LCID		s_lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
static CString	s_strTrue;
static CString	s_strFalse;
static UINT		s_uiLeadByte;

/////////////////////////////////////////////////////////////////////////////
// C3dFontDialog - FontDialog which hides the Color Check Box

BEGIN_MESSAGE_MAP(C3dFontDialog, CFontDialog)
	ON_WM_CTLCOLOR()
END_MESSAGE_MAP()


C3dFontDialog::C3dFontDialog(
	LPLOGFONT	lplfInitial, 
	DWORD		dwFlags,
	CDC*		pdcPrinter, 
	CWnd*		pParentWnd) : 
CFontDialog( lplfInitial, (dwFlags & CF_ENABLETEMPLATE) ? 
	(dwFlags & ~CF_ENABLETEMPLATE) | CF_ENABLETEMPLATEHANDLE : dwFlags,
	pdcPrinter, pParentWnd )
{
}

BOOL C3dFontDialog::OnInitDialog()
{
	BOOL bRet = CFontDialog::OnInitDialog();

	CenterWindow();
	DWORD dwExStyle = (DWORD)GetWindowLong(m_hWnd, GWL_EXSTYLE);
	dwExStyle &= ~WS_EX_CONTEXTHELP;
	::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwExStyle);

	return bRet;
}

HBRUSH C3dFontDialog::OnCtlColor(
	CDC*	pDC,
	CWnd*	pWnd,
	UINT	nCtlColor)
{
	HBRUSH hbrush = CFontDialog::OnCtlColor(pDC, pWnd, nCtlColor);
	return hbrush;
}

int C3dFontDialog::DoModal()
{
	C3dDialogTemplate	dt;
	//PreModalWindow();
	if (m_cf.Flags & CF_ENABLETEMPLATEHANDLE)
	{
		VERIFY( dt.Load( m_cf.lpTemplateName ) );
		SetStdFont(dt);
		m_cf.hInstance = (HINSTANCE) dt.GetTemplate();
	}
	int		iRet = CFontDialog::DoModal();
	//PostModalWindow();

	return iRet;
}

// ================= static functions ====================================
// Some static functions that are placed here so that when they are used
// repeatedly, it would make sense to have the code in one place.
// Most of these are very small functions and are self-explanatory

static CString FormatEnumIntPropertyValue(long lCurrentValue, BSTR bstrValueDescription)
{
	CString strResult;

	if ((bstrValueDescription == NULL) || (bstrValueDescription[0] == L'\0'))
	{
		LPSTR pstrTemp = strResult.GetBuffer(30); // Should always be enough for a formatted long
		sprintf(pstrTemp, "%d", lCurrentValue);
		strResult.ReleaseBuffer();
	}
	else
	{
		LPSTR pstrTemp = strResult.GetBuffer(wcslen(bstrValueDescription) + 64);
		wsprintf(pstrTemp, _T("%d - %ws"), lCurrentValue, bstrValueDescription);
		strResult.ReleaseBuffer();
	}

	return strResult;
}

static int GetDefaultItemHeight(
	CWnd*	pWnd)
{
	int			iHeight = ALLPAGE_HEADER_HEIGHT;
	CDC*		pDC = pWnd->GetDC();
	TEXTMETRIC	tm;

	if (pDC)
	{
		pDC->GetTextMetrics(&tm);
		iHeight = tm.tmHeight + tm.tmExternalLeading + tm.tmInternalLeading;
		pWnd->ReleaseDC(pDC);
	}

	return iHeight;
}

static void LBAddStringAndSetItemData(
	CListBox*	pListBox,
	LPCTSTR		pszcString,
	DWORD		dwItemData)
{
	int		iIndex;

	iIndex = pListBox->AddString(pszcString);
	ASSERT(iIndex != LB_ERR);
	if (iIndex != LB_ERR)
		pListBox->SetItemData(iIndex, dwItemData);
}

static inline BOOL DoesControlTypeNeedAButton(
	CPropItem*	pItem)
{
	return (pItem &&
		((pItem->m_ctrlType == ctrl_ComboLimitToList) ||
		(pItem->m_ctrlType == ctrl_ComboNotLimitToList) ||
		(pItem->m_ctrlType == ctrl_BuilderPerPropertyBrowsing) ||
		(pItem->m_ctrlType == ctrl_BuilderProvidePropertyBuilder) ||
		(pItem->m_ctrlType == ctrl_BuilderWizardManager) ||
		(pItem->m_ctrlType == ctrl_BuilderWizardManagerIntrinsic) ||
		(pItem->m_ctrlType == ctrl_BuilderInternal)));
}

static inline BOOL IsControlTypeAComboBox(
	CPropItem*	pItem)
{
	return (pItem &&
		((pItem->m_ctrlType == ctrl_ComboLimitToList) ||
		(pItem->m_ctrlType == ctrl_ComboNotLimitToList)));
}

static inline BOOL GetPerPropertyBrowsing(
	IDispatch*				pDisp,
	IPerPropertyBrowsing**	ppPPB)
{

	return (SUCCEEDED(pDisp->QueryInterface(IID_IPerPropertyBrowsing,
		(void**)ppPPB)));
}

static inline long GetLongFromVariant(
	VARIANT*	pVarValue)
{
	return (V_VT(pVarValue) == VT_I4) ?	V_I4(pVarValue) : (long)(short)V_I2(pVarValue);
}

static inline BOOL IsEnumDataType(
	CPropItem*	pItem)
{
	return (pItem && ((pItem->m_dataType == data_EnumInt2) ||
		(pItem->m_dataType == data_EnumInt4) ||
		(pItem->m_dataType == data_EnumString)));
}

// ISBUG: 7249 !!!!!!!!!!!!!!!!!!!!!!!
// THIS CODE IS ASSOCIATED WITH THE CODE IN PROPPAGE.CPP (in LoadPages()).
// This function is provided to fix a bug in ISCTRLS.OCX.  The Stock Font,
// Color and Picture property pages provided by MFC does not work because,
// the ITypeInfos are not merged in ISCTRLS.OCX and so, the enumeration of
// properties does not work with these property pages, but they do work in the
// MS Stock Propperty Pages.    So we remove these property pages and let the user
// use the AllPage to edit those properties.
static inline HRESULT MapPropertyToPage(IPerPropertyBrowsing* pPPB, DISPID dispid, CLSID* pclsid)
{
	HRESULT hr = pPPB->MapPropertyToPage(dispid, pclsid);
	if(SUCCEEDED(hr))
	{
		// Map MFC Stock Prop Page to MS Stock Prop Page if in Layout/ObjEd Doc
		CFrameWnd*	pFrame = ((CFrameWnd*)AfxGetMainWnd())->GetActiveFrame();
		ASSERT(pFrame);
		if(pFrame)
		{
			CDocument*	pDoc = pFrame->GetActiveDocument();
			if(pDoc != NULL && pDoc->IsKindOf(RUNTIME_CLASS(CIPCompDoc)))
			{
				// Only the Layout & Object Editor docs contain forms96==IID_IForm.
				// QI for IForm.  If successful then we know we have a Layout ||
				// Object Editor Doc, since IID_IForm is Forms96 only.
				LPOLEOBJECT pOleObj = ((CIPCompDoc*)pDoc)->GetOleObject(); // Un-AddRefed
				if(pOleObj != NULL)
				{
					COleRef<IUnknown> srpForms96;
					if(SUCCEEDED(pOleObj->QueryInterface(IID_IForm, (void**)&srpForms96)))
					{
						if(IsEqualCLSID(*pclsid, CLSID_CFontPropPage) ||
							IsEqualCLSID(*pclsid, CLSID_CColorPropPage) ||
							IsEqualCLSID(*pclsid, CLSID_CPicturePropPage))
							hr = E_NOTIMPL;
					}
				}
			}
		}
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CPropItem

ULONG CPropItem::s_ulCountControls = 0;	// number of controls selected

CPropItem::CPropItem(
	LPCTSTR		pszcText,	// property name
	VARTYPE		vt,			// variant type
	DataType	dt,			// data type
	DISPID		dispid)		// dispid of the first control selected
{
	m_strText	= pszcText;
	m_ctrlType	= ctrl_Unknown;
	m_dataType	= dt;
	m_vt		= vt;
	m_fEdit		= FALSE;
	m_pEnumData	= NULL;
	m_iIndex	= -1;

	m_Dispid	= dispid;
	m_pDispid	= &m_Dispid;
	m_pvd		= NULL;
	m_pfd		= NULL;
	m_TypeInfo	= NULL;

	ZeroMemory(&unionValue, sizeof(unionValue));
	m_strProp.Empty();
}

// This methos deletes the enumdata, releases any interfaces
// if they are cached and also releases the vardesc and funcdesc pointers.
// Finally, if multiple controls were selected, the m_pDispid array is
// also deleted.
CPropItem::~CPropItem()
{
	if (m_pEnumData)
		delete m_pEnumData;

	int			i;
	int			iCount = m_TypeInfoArrayEnumInt.GetSize();
	ITypeInfo*	pTypeInfo;

	// release the ITypeInfo interfaces for enum int 2 and 4
	if (iCount > 0)
	{
		for (i = 0; i < iCount; ++i)
		{
			pTypeInfo = (ITypeInfo*)m_TypeInfoArrayEnumInt.GetAt(i);
			ASSERT(pTypeInfo);
			pTypeInfo->Release();
		}

		m_TypeInfoArrayEnumInt.RemoveAll();
	}

	// release the ITypeInfo interface (of the first control selected)
	if (m_TypeInfo)
	{
		if (m_pfd)
			m_TypeInfo->ReleaseFuncDesc(m_pfd);
		if (m_pvd)
			m_TypeInfo->ReleaseVarDesc(m_pvd);
		m_TypeInfo->Release();
		m_TypeInfo = NULL;
	}

	// if multiple controls were selected, delete the memory for dispid array
	if ((m_pDispid != &m_Dispid) && (s_ulCountControls > 1))
		delete [] m_pDispid;
}

// This method deletes the existing enum-data if any and allocates memory for
// the new enumdata.
void CPropItem::GetNewEnumData()
{
	// delete any old data if present
	if (m_pEnumData)
	{
		delete m_pEnumData;
		m_pEnumData = NULL;
	}

	m_pEnumData = new CEnumData;
}

// This method stores the DISPID when Multiple controls are selected.  For the
// first control, the m_Dispid member is used and no memory is allocated for the
// m_pDispid.  If multiple-controls are selected, then this method allocates
// memory for an array of dispids and then stores the given dispid at the
// appropriate index supplied by the caller (COleAllPage::IntersectToMap).
void CPropItem::SetDispid(
	ULONG	ulIndex,
	DISPID	dispid)
{
	ASSERT((ulIndex != 0) && (s_ulCountControls > 1) && (ulIndex <= s_ulCountControls));

	// if we have not allocated memory for the array, m_pDispid will be
	// pointing to &m_Dispid
	if (m_pDispid == &m_Dispid)
	{
		m_pDispid = new DISPID[s_ulCountControls];
		m_pDispid[0] = m_Dispid;
	}

	m_pDispid[ulIndex] = dispid;
}

/////////////////////////////////////////////////////////////////////////////
// CPropEdit

CPropEdit::CPropEdit()
{
	m_pItem	= NULL;
	m_pLb	= NULL;
	m_pBtn	= NULL;
}

// Handles the OnKeyDown notification message.
// The up/down arrow keys are passed on to the parent list box.
// When Delete Key is pressed for a picture property, the picture is
// deleted from the property.
// Again, the up/down arrow keys are used to move from one property to
// the next in the main property list box (the edit control's parent) and
// the left/right arrow key is used to select the previous/next item in
// the drop-down box if that is used to edit the currently selected property.
void CPropEdit::OnKeyDown(
	UINT	nChar,
	UINT	nRepCnt,
	UINT	nFlags)
{
	switch(nChar)
	{
		case VK_UP:		// pass these on to the parent list box
		case VK_DOWN:
		{
			CPropListBox*	pPropListBox;
			pPropListBox = (CPropListBox*)GetParent();
			ASSERT(pPropListBox);
			pPropListBox->SetFocus();
			pPropListBox->OnKeyDown(nChar, nRepCnt, nFlags);
		}
			break;
		case VK_LEFT:
			if (m_pLb)
			{
				m_pLb->SelectPrev();	// select previous item in list
				return;
			}
			break;
		case VK_RIGHT:
			if (m_pLb)
			{
				m_pLb->SelectNext();	// select next item in list
				return;
			}
			break;

		default:
		case VK_DELETE:
			if (m_pItem)
			{
				if (m_pItem->m_dataType == data_Font)
				{
					return;	// don't allow any typing for the font property
				}
				else if ((m_pItem->m_ctrlType == ctrl_ComboLimitToList) &&
					(nChar == VK_DELETE))
				{
					return;	// don't allow deleting of the combobox property
				}
				else if (m_pItem->m_dataType == data_Picture)
				{
					if (nChar == VK_DELETE)
					{
						// special processing for just the picture property
						// to set it to nothing when Del key is pressed.
						CPropListBox*	pPropListBox;
						pPropListBox = (CPropListBox*)GetParent();
						ASSERT(pPropListBox);
						if (pPropListBox->m_pPage)
							((COleAllPage*)pPropListBox->m_pPage)->SetPictureToNone(m_pItem);
					}
					return;
				}
			}
			break;
	}

	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

// Handle OnChar notification message.  Prevents the user from typing
// anything if the property is either a font property or a picture property
void CPropEdit::OnChar(
	UINT	nChar,
	UINT	nRepCnt,
	UINT	nFlags) 
{
	if (m_pItem && 
		nChar!=3 /*^C*/ && //copy
		nChar!=24 /*^X*/ && //cut
		nChar !=22 /*^V*/) //paste
	{
		if (m_pLb && m_pItem->m_ctrlType == ctrl_ComboLimitToList)
		{
			// if we get a lead-byte character, just store it and return
			if (_istleadbyte(nChar))
			{
				s_uiLeadByte = nChar;
			}
			else
			{
				CString	strItem;
				LPTSTR	pszItem = strItem.GetBuffer(sizeof(TCHAR) * 3);

				// if we have stored a lead-byte, append the current character
				// to it and send this as a double-byte character to the listbox
				if (s_uiLeadByte)
				{
					*pszItem = (TCHAR)s_uiLeadByte;
					pszItem = _tcsinc(pszItem);

					s_uiLeadByte = NULL;
				}

				*pszItem = (TCHAR)nChar;
				pszItem = _tcsinc(pszItem);

				*pszItem = TCHAR('\0');
				strItem.ReleaseBuffer();

				// depending upon what character was typed, try to select
				// an item from the list
				m_pLb->SelectLimitToList(strItem);
			}

			return;
		}
		else if ((m_pItem->m_dataType == data_Font) ||
			(m_pItem->m_dataType == data_Picture))
		{
			// do not allow the user to type into the edit control for these
			// 2 data types
			return;
		}
	}

	CEdit::OnChar(nChar, nRepCnt, nFlags);
}

UINT CPropEdit::OnGetDlgCode() 
{
	UINT nCodes = CEdit::OnGetDlgCode();
	return (nCodes | DLGC_WANTTAB);
}

// This method saves the property if it is modified
BOOL CPropEdit::SaveProperty()
{
	BOOL	bForceVisible = FALSE;

	if (m_pItem == NULL)
		return bForceVisible;

	BOOL	bModify = GetModify();

	if (bModify)
	{
		GetWindowText(m_pItem->m_strProp);
	}
	else
	{
		CString	strEdit;

		// IStudio  bug # 6021 & 5710
		// this is another HACK to make this work in IME modes
		// sometimes, the Modify flag is not set properly and we are
		// just trying to make sure that the text in the edit control
		// and the buffer are the same, if not, we set the modify flag
		// and save the property
		GetWindowText(strEdit);
		if (0 != m_pItem->m_strProp.Compare(strEdit))
		{
			bModify = TRUE;
			SetModify(bModify);
			m_pItem->m_strProp = strEdit;
		}
	}

	// if we have new text in the edit control, then update the property
	if (bModify)
	{
		CPropListBox*	pPropListBox = (CPropListBox*)GetParent();

		ASSERT(pPropListBox);
		bForceVisible = !(pPropListBox->UpdateProperty());
	}

	return bForceVisible;
}

// Saves the property if it is modified upon killfocus
void CPropEdit::OnKillFocus(
	CWnd*	pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);

	if ((m_pLb && pNewWnd == m_pLb) || (m_pBtn && pNewWnd == m_pBtn))
		return;

	BOOL	bForceVisible = SaveProperty();

	if (!bForceVisible)
		ShowWindow(SW_HIDE);

	if (m_pLb)
		m_pLb->SetWindowPos(&wndBottom, 0, 0, 0, 0,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
}

// To achieve VB-like behavior, when the user double-clicks a row, and if
// that row has a drop-down box to edit its property, this "cycles" through
// the selection and selects the next item in the list.  If the last item
// is selected, then this selects the first item (cycle).
// If the property does not have a drop-down listbox to edit the property,
// the double-click is just passed to the default class (edit).
void CPropEdit::OnLButtonDblClk(
	UINT	nFlags,
	CPoint	point)
{
	// selectnext item in the list (cycle if necessary)
	if (m_pLb && IsControlTypeAComboBox(m_pItem))
		m_pLb->SelectNextItemInList();
	else
		CEdit::OnLButtonDblClk(nFlags, point);
}

BEGIN_MESSAGE_MAP(CPropEdit, CEdit)
	//{{AFX_MSG_MAP(CPropEdit)
	ON_WM_GETDLGCODE()
	ON_WM_KILLFOCUS()
	ON_WM_KEYDOWN()
	ON_WM_CHAR()
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropButton

CPropButton::CPropButton()
{
	m_lBtnWidth	= 0;
	m_lBtnHeight= 0;
	m_pItem		= NULL;
}

void CPropButton::SetBtnDimensions()
{
	if (!m_lBtnWidth && !m_lBtnHeight)
	{
		int		iHeight = GetDefaultItemHeight(this);

		if (iHeight > 0)
		{
			m_lBtnHeight = iHeight;
			m_lBtnWidth = m_lBtnHeight - ALLPAGE_GUTTER;
		}
	}
}

// Draws either a "drop-down" button or a "ellipsis" (...) button
// Uses the standard OBM_COMBO system bitmap for the former button
// and 3 small rectangles to achieve the ellipsis button for the
// latter.
void CPropButton::DrawItem(
	LPDRAWITEMSTRUCT	lpDIS) 
{
	if (!DoesControlTypeNeedAButton(m_pItem))
		return;

	CDC*		pDC = CDC::FromHandle(lpDIS->hDC);
	CRect		rcItem(lpDIS->rcItem);
	BOOL		bPushed = lpDIS->itemState & ODS_SELECTED;

	COLORREF	colorLt = ::GetSysColor(COLOR_3DHILIGHT);
	COLORREF	colorDk = ::GetSysColor(COLOR_3DDKSHADOW);

	// draw the outside rectangle
	if (bPushed)
		pDC->Draw3dRect(rcItem, colorDk, colorLt);
	else
		pDC->Draw3dRect(rcItem, colorLt, colorDk);

	rcItem.InflateRect(-1, -1);
	colorLt = ::GetSysColor(COLOR_3DLIGHT);
	colorDk = ::GetSysColor(COLOR_3DSHADOW);
	// draw the inside rectangle
	if (bPushed)
		pDC->Draw3dRect(rcItem, colorDk, colorLt);
	else
		pDC->Draw3dRect(rcItem, colorLt, colorDk);

	rcItem.InflateRect(-1, -1);
	pDC->FillSolidRect(rcItem, colorLt);	// fill the rectangle

	if (bPushed)
		rcItem.OffsetRect(1, 1);

	CPen	penBtnTxt(PS_SOLID, 1, GetSysColor(COLOR_BTNTEXT));
	CPen*	ppenOld = pDC->SelectObject(&penBtnTxt);

	if (IsControlTypeAComboBox(m_pItem))
	{
		CDC			bmpDC;
		CBitmap		bmp;
		CBitmap*	pbmpOld;
		BITMAP		bmpInfo;
		int			iShrinkW;
		int			iShrinkH;

		// load the combo bitmap from the system 
		bmp.LoadOEMBitmap(OBM_COMBO);
		bmp.GetBitmap(&bmpInfo);

		// center it on the rcItem rect
		iShrinkW = ((rcItem.Width() - bmpInfo.bmWidth) / 2);
		iShrinkH = ((rcItem.Height() - bmpInfo.bmHeight) / 2);
		rcItem.DeflateRect(iShrinkW, iShrinkH);

		// draw the bitmap
		bmpDC.CreateCompatibleDC(pDC);
		pbmpOld = bmpDC.SelectObject(&bmp);
		pDC->BitBlt(rcItem.left, rcItem.top, rcItem.right - rcItem.left,
			rcItem.bottom - rcItem.top, &bmpDC, 0, 0, SRCCOPY);
		bmpDC.SelectObject(pbmpOld);

		// free the gdi objects
		bmpDC.DeleteDC();
		bmp.DeleteObject();
	}
	else	// all the builders
	{
		CRect	rcDotMiddle;
		CRect	rcDotLeftRight;

		// draw the 3 dots (rectangles)
		// since all are on the same top and bottom plane, change only left, right
		// draw the middle dot
		rcDotMiddle.right = rcItem.left + (rcItem.Width() / 2) + 1;
		rcDotMiddle.left = rcDotMiddle.right - 2;
		rcDotMiddle.bottom = rcItem.bottom - (rcItem.Height() / 4) + 1;
		rcDotMiddle.top = rcDotMiddle.bottom - 2;
		colorDk = ::GetSysColor(COLOR_3DDKSHADOW);
		pDC->FillSolidRect(&rcDotMiddle, colorDk);

		rcDotLeftRight = rcDotMiddle;

		// draw the left dot
		rcDotLeftRight.right = rcDotMiddle.left - 2;
		rcDotLeftRight.left = rcDotLeftRight.right - 2;
		pDC->FillSolidRect(&rcDotLeftRight, colorDk);

		// draw the right dot
		rcDotLeftRight.left = rcDotMiddle.right + 2;
		rcDotLeftRight.right = rcDotLeftRight.left + 2;
		pDC->FillSolidRect(&rcDotLeftRight, colorDk);
	}

	pDC->SelectObject(ppenOld);
}

void CPropButton::MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
{
	SetBtnDimensions();
	lpMeasureItemStruct->itemWidth  = m_lBtnWidth;
	lpMeasureItemStruct->itemHeight = m_lBtnHeight;
}

BEGIN_MESSAGE_MAP(CPropButton, CButton)
	//{{AFX_MSG_MAP(CPropButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPropList

CPropList::CPropList()
{
	m_pTxt = NULL;
	m_pPropListBox = NULL;
	m_iItemHeight = LB_ERR;
}

BEGIN_MESSAGE_MAP(CPropList, CListBox)
	//{{AFX_MSG_MAP(CPropList)
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelchange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// Populates the drop-down list box (this list box) with items
void CPropList::FillContents(
	CPropItem*	pItem)
{
	int		iCount;
	int		i;
	int		iIndex;

	ASSERT(pItem);
	ResetContent();
	switch(pItem->m_dataType)
	{
		case data_Bool:
			LBAddStringAndSetItemData(this, s_strTrue, TRUE);
			LBAddStringAndSetItemData(this, s_strFalse, FALSE);
			iCount = GetCount();
			for (i = 0; i < iCount; ++i)
			{
				if (pItem->unionValue.m_nValue == (int)GetItemData(i))
				{
					SetCurSel(i);
					i = iCount;	// break out of the loop
				}
			}
		break;

		case data_EnumInt2:
		case data_EnumInt4:
			ASSERT(pItem->m_pEnumData);
			iCount = pItem->m_pEnumData->m_straEnumStrings.GetSize();
			// just make sure that both the arrays are of same size
			ASSERT(iCount == pItem->m_pEnumData->m_dwaCookies.GetSize());
			for (i = 0; i < iCount; i++)
				LBAddStringAndSetItemData(this,
					pItem->m_pEnumData->m_straEnumStrings[i],
					pItem->m_pEnumData->m_dwaCookies[i]);

			iCount = GetCount();
			for (i = 0; i < iCount; i++)
			{
				if (pItem->unionValue.m_nValue == (int)GetItemData(i))
				{
					GetText(i, pItem->m_strProp);
					SetCurSel(i);
					i = iCount;	// break out of the loop
				}
			}
			break;

		case data_EnumString:
			if (pItem->m_pEnumData)
			{
				iCount = pItem->m_pEnumData->m_straEnumStrings.GetSize();
				// just make sure that both the arrays are of same size
				ASSERT(iCount == pItem->m_pEnumData->m_dwaCookies.GetSize());
				for (i = 0; i < iCount; i++)
					LBAddStringAndSetItemData(this,
						pItem->m_pEnumData->m_straEnumStrings[i],
						pItem->m_pEnumData->m_dwaCookies[i]);

				if (!pItem->m_strProp.IsEmpty())
				{
					i = FindStringExact(-1, pItem->m_strProp);
					if (LB_ERR != i)
						SetCurSel(i);
				}
			}
		break;
	}

	m_iItemHeight = GetItemHeight(0);
}

// This method positions the drop-down list box (this list box) below/above
// the edit control depending upon position of the edit control.
void CPropList::PositionToProperty(
	CRect*		pRect,
	CPropItem*	pItem)
{
	ASSERT(pRect && pItem);

	// calc the builder listbox size
	CRect	rcList;
	int		iHeightOfThisListBox;
	int		iScreenHeight = ::GetSystemMetrics(SM_CYSCREEN);
	int		iYBorder = ::GetSystemMetrics(SM_CYBORDER);

	// should it go above or below the property item
	if (LB_ERR == m_iItemHeight)
		m_iItemHeight = pRect->Height() - 2;

	iHeightOfThisListBox = min((m_iItemHeight * GetCount()) + (2 * iYBorder),
		(iScreenHeight / 2));

	rcList.left	= pRect->left - 1;
	rcList.right = pRect->right - 1;
	if (iScreenHeight > (pRect->bottom + 1 + iHeightOfThisListBox))
	{
		rcList.top  = pRect->bottom + 1;
		rcList.bottom = iHeightOfThisListBox + rcList.top;
	}
	else
	{
		rcList.bottom = pRect->top - 1;
		rcList.top  = rcList.bottom - iHeightOfThisListBox;
	}

	MoveWindow(&rcList, FALSE);
}

// This method hides the drop-down list box (this list box) upon a selection
// change notification and then updates and saves the property change
void CPropList::OnSelchange() 
{
	// hide the drop-down list first
	SetWindowPos(&wndBottom, 0, 0, 0, 0,
		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
	// update the property change
	UpdateEditControl();
}

// This method updates the edit control with the current selection and
// also saves the change (updates the property)
void CPropList::UpdateEditControl()
{
	int		iIndex = GetCurSel();

	if (LB_ERR == iIndex)
		return;

	CString	str;

	GetText(iIndex, str);
	if (str.IsEmpty())
		return;
	
	ASSERT(m_pTxt);
	m_pTxt->SetWindowText(str);	// update edit control
	m_pTxt->m_pItem->m_strProp = str;	// update propitem data structure

	// if the data type happens to be of enumeration type,
	// store the dword value of enumeration in pItem->unionValue.m_dwValue
	// this will be used while setting the property
	if (m_pTxt->m_pItem->m_dataType == data_EnumInt2 ||
		m_pTxt->m_pItem->m_dataType == data_EnumInt4 ||
		m_pTxt->m_pItem->m_dataType == data_Bool)
		m_pTxt->m_pItem->unionValue.m_nValue = GetItemData(iIndex);
	else if (m_pTxt->m_pItem->m_dataType == data_EnumString)
		m_pTxt->m_pItem->unionValue.m_dwValue = GetItemData(iIndex);

	if (!IsControlTypeAComboBox(m_pTxt->m_pItem))
		m_pTxt->SetSel(0, -1);

	// get the parent window (main list box) and call updateproperty on it
	m_pTxt->SetModify(TRUE);	// set the modify flag
	ASSERT(m_pPropListBox);
	m_pPropListBox->UpdateProperty();// save the property
	m_pTxt->SetModify(FALSE);	// reset the modify flag

	m_pTxt->SetFocus();
}

// Selects the next item if one exists.
void CPropList::SelectNext()
{
	int		iIndex = GetCurSel();

	// if nothing is selected, this selects the first item
	if ((iIndex + 1) == GetCount())
		return;

	SetCurSel(++iIndex);
	UpdateEditControl();
}

// Selects the previous item if one exists.
void CPropList::SelectPrev()
{
	int		iIndex = GetCurSel();

	if (LB_ERR == iIndex || 0 == iIndex)
		return;

	SetCurSel(--iIndex);
	UpdateEditControl();
}

// This method selects the "next" item from the currently selected item
// that matches the given string.  This process cycles and selects from the
// beginning if the item is not found.
void CPropList::SelectLimitToList(
	LPCTSTR	pszcItem)
{
	int		iIndex = GetCurSel();
	int		iIndexNext = FindString(iIndex, pszcItem);

	// if we couldn't find an item starting with "nChar", then go back to
	// the previous item that was selected
	SetCurSel((LB_ERR != iIndexNext) ? iIndexNext : iIndex);
	UpdateEditControl();
}

// This method selects the "next" item in the list.  This also cycles and
// the first item if the currently selected item is the last item.
void CPropList::SelectNextItemInList()
{
	int		iIndex = GetCurSel();

	// if nothing is selected, this selects the first item
	if (++iIndex >= GetCount())
		iIndex = 0;

	SetCurSel(iIndex);
	UpdateEditControl();
}

/////////////////////////////////////////////////////////////////////////////
// CPropListBox

CPropListBox::CPropListBox()
{
	m_pTxt	= NULL;
	m_pBtn	= NULL;
	m_pLb	= NULL;
	m_pPage	= NULL;
	m_uiIndex = -1;
}

CPropListBox::~CPropListBox()
{
	delete m_pTxt;
	delete m_pBtn;
	delete m_pLb;
}

BEGIN_MESSAGE_MAP(CPropListBox, CListBox)
	//{{AFX_MSG_MAP(CPropListBox)
	ON_WM_SETFOCUS()
	ON_WM_GETDLGCODE()
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblclk)
	ON_WM_NCLBUTTONDOWN()
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelchange)
	ON_WM_CHAR()
	ON_WM_KEYDOWN()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_PROP_BUTTON, OnBtnClick)
END_MESSAGE_MAP()

void CPropListBox::OnDestroy()
{
	ResetContent();
	CListBox::OnDestroy();
}

// Basically draws the "grid", sets up the state for all the 3 child windows
// (edit, button and listbox).  Draw the selected row in hi-lite color.
// REVIEW: try to reduce the GDI objects (pen/brush) creation/deletion if possible
void CPropListBox::DrawItem(
	LPDRAWITEMSTRUCT lpDIS) 
{
	CPropItem*	pItem = (CPropItem *)(lpDIS->itemData);

	if (NULL == pItem)
		return;

	CDC*	pDC = CDC::FromHandle(lpDIS->hDC);
	CRect	rcItem(lpDIS->rcItem);
	CRect	rcTag(lpDIS->rcItem);
	CRect	rcProp(lpDIS->rcItem);
	int		iMidPoint;
	int		iColumn0Width;

	CWnd*	pWnd = GetParent();

	ASSERT(pWnd->IsKindOf(RUNTIME_CLASS(COleAllPage)));
	iColumn0Width = ((COleAllPage*)pWnd)->GetColumnWidth(0);
	((COleAllPage*)pWnd)->SetHeaderInfo();	// to snap-back if necessary

	iMidPoint = rcItem.left + iColumn0Width - ALLPAGE_GUTTER;

	rcTag.right = rcTag.left + iMidPoint;
	rcProp.left = iMidPoint;
	if (lpDIS->itemState & ODS_SELECTED)
	{
		// output the tag text
		if (!pItem->m_strText.IsEmpty())
		{
			pDC->SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
			pDC->SetBkColor(::GetSysColor(COLOR_HIGHLIGHT));
			pDC->ExtTextOut(rcTag.left + ALLPAGE_GUTTER, rcTag.top,
				ETO_CLIPPED | ETO_OPAQUE, &rcTag, pItem->m_strText, NULL);
		}

		// Make sure that the text in the edit control is not newer than the
		// text in the CPropItem buffer and then update the text.
		// If not, leave the text alone.  Especially in the case of IME mode
		// where the first "Enter" key copies the text from the system buffer
		// into m_pTxt edit control, we get a repaint message and we do not
		// want to erase the new text with the old text.  (IS BuG# 6021)
		if (!m_pTxt->GetModify())
			m_pTxt->SetWindowText(pItem->m_strProp);

		m_uiIndex = lpDIS->itemID;	// store the index of item we are editing

		CRect	rcBtn = rcProp;

		if (!pItem->m_fEdit)
		{
			rcProp.left += ALLPAGE_GUTTER;
			rcProp.bottom -= 1;
			m_pLb->SetWindowPos(&wndBottom, 0, 0, 0, 0,
				SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
			switch (pItem->m_ctrlType)
			{
				case ctrl_Edit:						// just and edit
					rcProp.right -= 1;
					m_pTxt->MoveWindow(&rcProp, FALSE);

					// set the flag indicating that we have not modified the property yet
					m_pTxt->SetModify(FALSE);

					m_pTxt->m_pItem = pItem;
					m_pTxt->m_pLb = NULL;
					m_pTxt->m_pBtn = NULL;
					m_pBtn->m_pItem = NULL;
					m_pLb->m_pTxt = NULL;
					break;
				case ctrl_ComboLimitToList:			// edit and button
				case ctrl_ComboNotLimitToList:
					if (pItem->IsEnumDataDirty() && m_pPage)
						((COleAllPage*)m_pPage)->UpdateEnumData(pItem);

					m_pLb->FillContents(pItem);
					m_pTxt->m_pLb = m_pLb;
					m_pTxt->m_pBtn = m_pBtn;
					m_pLb->m_pTxt = m_pTxt;
					// OK to fall through
				case ctrl_BuilderPerPropertyBrowsing:
				case ctrl_BuilderProvidePropertyBuilder:
				case ctrl_BuilderWizardManager:
				case ctrl_BuilderWizardManagerIntrinsic:
				case ctrl_BuilderInternal:
					rcProp.right -= (m_pBtn->GetBtnWidth() + 1);
					rcBtn.left = rcBtn.right - m_pBtn->GetBtnWidth();
					rcBtn.bottom -= 1;
					m_pTxt->MoveWindow(&rcProp, FALSE);
					
					// set the flag indicating that we have not modified the property yet
					m_pTxt->SetModify(FALSE);

					if (!IsControlTypeAComboBox(pItem))
						m_pTxt->m_pLb = NULL;

					m_pTxt->m_pItem = pItem;
					m_pBtn->m_pItem = pItem;
					m_pBtn->MoveWindow(&rcBtn, FALSE);
					m_pBtn->ShowWindow(SW_SHOW);
					m_pBtn->InvalidateRect(NULL);
					break;
				default:
					ASSERT(FALSE);
			}

			pItem->m_fEdit = TRUE;
		}
		else
		{
			rcProp.left += ALLPAGE_GUTTER;
			rcProp.bottom -= 1;
			switch (pItem->m_ctrlType)
			{
				case ctrl_Edit:						// just and edit
					rcProp.right -= 1;
					m_pTxt->MoveWindow(&rcProp, FALSE);
					break;
				case ctrl_ComboLimitToList:			// edit and button
				case ctrl_ComboNotLimitToList:
					// OK to fall through
				case ctrl_BuilderPerPropertyBrowsing:
				case ctrl_BuilderProvidePropertyBuilder:
				case ctrl_BuilderWizardManager:
				case ctrl_BuilderWizardManagerIntrinsic:
				case ctrl_BuilderInternal:
					rcProp.right -= (m_pBtn->GetBtnWidth() + 1);
					m_pTxt->MoveWindow(&rcProp, FALSE);
					rcBtn.left = rcBtn.right - m_pBtn->GetBtnWidth();
					rcBtn.bottom -= 1;
					m_pBtn->MoveWindow(&rcBtn, FALSE);
					m_pBtn->ShowWindow(SW_SHOW);
					m_pBtn->InvalidateRect(NULL);
					break;
				default:
					ASSERT(FALSE);
			}
		}

		if (!m_pTxt->IsWindowVisible())
		{
			// draw the properties text
			CBrush	brush;

			brush.CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
			pDC->FillRect(&rcProp, &brush);
			brush.DeleteObject();
			if (!pItem->m_strProp.IsEmpty())
			{
				pDC->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
				pDC->SetBkColor(::GetSysColor(COLOR_WINDOW));
				pDC->ExtTextOut(rcProp.left, rcProp.top,
					ETO_CLIPPED | ETO_OPAQUE, &rcProp, pItem->m_strProp, NULL);
			}
		}
	}
	else if (lpDIS->itemState & ODS_DISABLED)
	{
		// output the tag text
		pDC->SetTextColor(::GetSysColor(COLOR_GRAYTEXT));
		pDC->SetBkColor(::GetSysColor(COLOR_WINDOW));
		pDC->ExtTextOut(rcTag.left, rcTag.top, ETO_CLIPPED | ETO_OPAQUE, 
						&rcTag, pItem->m_strText, NULL);
		pItem->m_fEdit = FALSE;
	}
	else
	{
		// output the tag text
		pDC->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
		pDC->SetBkColor(::GetSysColor(COLOR_WINDOW));
		pDC->ExtTextOut(rcTag.left + ALLPAGE_GUTTER, rcTag.top,
			ETO_CLIPPED | ETO_OPAQUE, &rcTag, pItem->m_strText, NULL);

		if (pItem->m_fEdit)
		{
			m_pTxt->ShowWindow(SW_HIDE);
			m_pBtn->ShowWindow(SW_HIDE);
		}
		pItem->m_fEdit = FALSE;

		// draw the properties text
		CBrush brush;
		brush.CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
		pDC->FillRect(&rcProp, &brush);
		brush.DeleteObject();
		pDC->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
		pDC->SetBkColor(::GetSysColor(COLOR_WINDOW));
		pDC->ExtTextOut(rcProp.left + ALLPAGE_GUTTER, rcProp.top,
			ETO_CLIPPED | ETO_OPAQUE, &rcProp, pItem->m_strProp, NULL);
	}
	
    // Create Grey Color Pen
    CPen	pen;
	pen.CreatePen(PS_SOLID, 1, GetSysColor(COLOR_GRAYTEXT));
    CPen*	pPenOld = pDC->SelectObject(&pen);

	// draw the grid lines
	pDC->MoveTo(rcItem.left, rcItem.bottom - 1);
	pDC->LineTo(rcItem.right, rcItem.bottom - 1);
	pDC->MoveTo(iMidPoint, rcItem.bottom - 1);
	pDC->LineTo(iMidPoint, rcItem.top - 1);
	pDC->SelectObject(pPenOld);
	pen.DeleteObject();
}

// to achieve the sorting feature, we just compare the property names
// and the main property list is ordered by the property name.
int CPropListBox::CompareItem(
	LPCOMPAREITEMSTRUCT	lpCIS) 
{
	return _tcscmp(((CPropItem *)lpCIS->itemData1)->m_strText,
		((CPropItem *)lpCIS->itemData2)->m_strText);
}

void CPropListBox::MeasureItem(
	LPMEASUREITEMSTRUCT	lpMIS)
{
	lpMIS->itemHeight = GetDefaultItemHeight(this);
}

// This method creates all the 3 children (edit, button and listbox) that
// we need to achieve the "in-place" editing feature that the AllPage grid
// (main property listbox) provides.  Some sleight of hand is done here to
// achieve the drop-down listbox to function just-like a combobox drop-down.
// That is, this list box must be able to "drop" outside the parent window,
// and to do that this juggling is necessary.  Please read the comments below.
BOOL CPropListBox::CreateChildren()
{
	HWND	hWnd;
	CFont*	pFont = GetFont();

	m_pTxt	= new CPropEdit;
	m_pBtn  = new CPropButton;
	m_pLb	= new CPropList;

	hWnd = ::CreateWindow(_T("edit"), NULL,
		WS_CHILD | ES_LEFT | ES_AUTOHSCROLL | WS_CLIPSIBLINGS | WS_TABSTOP,
		0, 0, 0, 0, m_hWnd, (HMENU)IDC_PROP_EDIT, AfxGetInstanceHandle(), NULL);
	ASSERT(hWnd);
	m_pTxt->SubclassDlgItem(IDC_PROP_EDIT, this);
	m_pTxt->SetFont(pFont);

	hWnd = ::CreateWindow(_T("button"), NULL, WS_CHILD | BS_OWNERDRAW,
		0, 0, 0, 0, m_hWnd, (HMENU)IDC_PROP_BUTTON, AfxGetInstanceHandle(), NULL);
	ASSERT(hWnd);
	m_pBtn->SubclassDlgItem(IDC_PROP_BUTTON, this);
	m_pBtn->SetBtnDimensions();

	hWnd = ::CreateWindowEx(WS_EX_TOOLWINDOW, _T("listbox"), NULL,
		WS_CHILD | LBS_WANTKEYBOARDINPUT | WS_CLIPSIBLINGS | LBS_SORT |
		WS_VSCROLL | WS_BORDER | LBS_NOTIFY | LBS_NOINTEGRALHEIGHT,
		0, 0, 0, 0, m_hWnd, (HMENU)IDC_PROP_LISTBOX, AfxGetInstanceHandle(), NULL);
	ASSERT(hWnd);
	m_pLb->SubclassDlgItem(IDC_PROP_LISTBOX, this);
	m_pLb->SetFont(pFont);
	m_pLb->SetParentListBoxPtr(this);

	// Convert the "drop-down" list box we just created into a pop-up window
	// so that it can extend outside the parent window.  We create this as
	// a child window initially so that the list box sends its notifications
	// to the parent "when it was created" and we want the parent to be
	// THIS main grid-listbox.
	// The ID must be set to zero because the control's ID
	// and the popup window's menu is stored in the same location.
	::SetWindowLong(hWnd, GWL_ID, 0L);
	::SetParent(hWnd, NULL);
	DWORD	dwStyle = ::GetWindowLong(hWnd, GWL_STYLE);
	::SetWindowLong(hWnd, GWL_STYLE, (dwStyle & ~WS_CHILD) | WS_POPUP);

	return TRUE;
}

UINT CPropListBox::OnGetDlgCode() 
{
	UINT nCodes = CListBox::OnGetDlgCode();
	return (nCodes | DLGC_WANTTAB);
}

// To handle the Tab order when the user uses the Tab key to traverse
// through the main property listbox, the edit control and the All property page
BOOL CPropListBox::PreTranslateMessage(
	MSG*	pMsg)
{
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB)
	{
		if (this == GetFocus())
		{
			ShowEditControl();
			return TRUE;
		}
		return FALSE;
	}
	return CListBox::PreTranslateMessage(pMsg);
}

void CPropListBox::SetFocusAndCurSel()
{
	int		iIndex = GetCurSel();

	if (LB_ERR != iIndex)
	{
		m_pTxt->SetFocus();
		if (!IsControlTypeAComboBox((CPropItem*)GetItemData(iIndex)))
			m_pTxt->SetSel(0, -1);
	}
}

// Shows the edit control and displays selects the text
void CPropListBox::ShowEditControl()
{
	m_pTxt->ShowWindow(SW_SHOW);
	SetFocusAndCurSel();
}

// To achieve VB-like behavior, when the user double-clicks a row, and if
// that row has a drop-down box to edit its property, this "cycles" through
// the selection and selects the next item in the list.  If the last item
// is selected, then this selects the first item (cycle).
void CPropListBox::OnDblclk()
{
	int		iIndex = GetCurSel();

	if ((LB_ERR != iIndex) &&
		IsControlTypeAComboBox((CPropItem*)GetItemData(iIndex)))
		m_pLb->SelectNextItemInList();

	ShowEditControl();
}

// Every time the selection changes in the main property listbox, the
// edit control need to be shown in "that" row -- so a call to ShowWindow
// will do exactly that.
void CPropListBox::OnSelchange() 
{
	m_pTxt->ShowWindow(SW_SHOW);
}

// if the user starts typing and the focus in on the main property listbox
// this method passes on that character to the edit control if it is visible
void CPropListBox::OnChar(
	UINT	nChar,
	UINT	nRepCnt,
	UINT	nFlags) 
{
	if (m_pTxt->IsWindowVisible())
	{
		SetFocusAndCurSel();
		m_pTxt->OnChar(nChar, nRepCnt, nFlags);
		return;
	}

	CListBox::OnChar(nChar, nRepCnt, nFlags);
}

// Pass the right-left arrow keys to the edit control if it is visible
void CPropListBox::OnKeyDown(
	UINT	nChar,
	UINT	nRepCnt,
	UINT	nFlags) 
{
	switch (nChar)
	{
		case VK_LEFT:
		case VK_RIGHT:
			if (m_pTxt->IsWindowVisible())
			{
				SetFocusAndCurSel();
				m_pTxt->OnKeyDown(nChar, nRepCnt, nFlags);
				return;
			}
			// okay to fall through...
		case VK_UP:
		case VK_DOWN:
		case VK_HOME:
		case VK_END:
		case VK_PRIOR:	// page up
		case VK_NEXT:	// page down
		default:
			CListBox::OnKeyDown(nChar, nRepCnt, nFlags);
			break;
	}
}

// When the builder (ellipsis) / drop-down (combo-box) is pressed,
// this method either invokes the builder / shows/hides the drop-down list box
void CPropListBox::OnBtnClick()
{
	switch(m_pBtn->m_pItem->m_ctrlType)
	{
		case ctrl_ComboLimitToList:
		case ctrl_ComboNotLimitToList:
			if (m_pLb->IsWindowVisible())
			{
				m_pLb->SetWindowPos(&wndBottom, 0, 0, 0, 0,
					SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
				SetFocus();
			}
			else
			{
				CRect	rcEdit;
				CRect	rcBtn;

				m_pTxt->GetWindowRect(rcEdit);
				m_pBtn->GetWindowRect(rcBtn);

				rcEdit.right = rcBtn.right;

				// bring the "drop-down" list box to the top
				m_pLb->PositionToProperty(&rcEdit, m_pBtn->m_pItem);
				m_pLb->SetWindowPos(&wndTopMost, 0, 0, 0, 0,
					SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
			}
			break;

		case ctrl_BuilderPerPropertyBrowsing:
		case ctrl_BuilderProvidePropertyBuilder:
		case ctrl_BuilderWizardManager:
		case ctrl_BuilderWizardManagerIntrinsic:
		case ctrl_BuilderInternal:
			{
				CWnd*	pWnd = GetParent();

				ASSERT(pWnd->IsKindOf(RUNTIME_CLASS(COleAllPage)));
				((COleAllPage*)pWnd)->ExecuteBuilder(m_pBtn->m_pItem);
			}
			break;

		default:
			ASSERT(FALSE);
			break;
	}
	
	ShowEditControl();
}

// if the non-client area gets a button down, hide the drop-down list box
void CPropListBox::OnNcLButtonDown(
	UINT	nHitTest,
	CPoint	point) 
{
	if (HTVSCROLL == nHitTest)
		SetFocus();
	
	m_pLb->SetWindowPos(&wndBottom, 0, 0, 0, 0,
		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
	CListBox::OnNcLButtonDown(nHitTest, point);
}

// This method is used to release all the cached data for that we have
// stored for every property (== every row in the grid)
void CPropListBox::ResetContent()
{
	// hide the edit, button and list controls first
	m_pTxt->ShowWindow(SW_HIDE);
	m_pBtn->ShowWindow(SW_HIDE);
	m_pLb->SetWindowPos(&wndBottom, 0, 0, 0, 0,
		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);

	// free data associated with the items
	m_pTxt->m_pItem = NULL;
	m_pTxt->m_pLb = NULL;
	m_pBtn->m_pItem = NULL;
	m_pLb->m_pTxt = NULL;

	int			iCount = GetCount();
	CPropItem*	pItem;

	for (int i = 0; i < iCount; ++i)
	{
		pItem = (CPropItem *)GetItemData(i);
		delete pItem;
	}

	CListBox::ResetContent();

	// set the number of items (controls) selected to 0
	// NOTE: THIS IS IMPORTANT, otherwise, caching of dispids will FAIL
	CPropItem::s_ulCountControls = 0;
}

// When the main property list box gets the focus, this method just
// makes sure that if the currently selected row needs a button (for the
// drop-down button or ellipsis) and makes it visible.
void CPropListBox::OnSetFocus(
	CWnd*	pOldWnd) 
{
	CListBox::OnSetFocus(pOldWnd);

	int		iIndex = GetCurSel();

	if (LB_ERR != iIndex)
	{
		if (m_pBtn &&
			DoesControlTypeNeedAButton((CPropItem*)GetItemData(iIndex)))
			m_pBtn->ShowWindow(SW_SHOW);
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// COleAllPage

IMPLEMENT_DYNAMIC(COleAllPage, CSlobPage)

BEGIN_INTERFACE_MAP(COleAllPage, CSlobPage)
	INTERFACE_PART(COleAllPage, IID_IPropertyNotifySink, PropertyNotifySink)
END_INTERFACE_MAP()

BEGIN_IDE_CONTROL_MAP(COleAllPage, IDDP_ALLPROP_NEW, IDS_PROP_GENERAL) // was IDS_OC_ALL
	// All VB Styles Page controls are handled through the message map.
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(COleAllPage, CSlobPage)
	ON_WM_MEASUREITEM()
	ON_WM_DRAWITEM()
	ON_NOTIFY(HDN_ENDTRACK, IDC_PROP_HEADER, OnEndTrackHeader)
	ON_NOTIFY(HDN_TRACK, IDC_PROP_HEADER, OnTrackHeader)
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
END_MESSAGE_MAP()

COleAllPage::COleAllPage()
{
	m_strName.LoadString(IDS_PROP_ALL);

	m_lbProps.m_pPage	= this;
	m_ulCountControls	= 0;
	m_pSingleDisp		= NULL;
	m_pprgDisp			= NULL;
	m_bActive			= FALSE;
	m_bUpdatingProps	= FALSE;
	m_bUpdateLater		= FALSE;
	m_ihcHeight			= ALLPAGE_HEADER_HEIGHT;
	m_ihcCol0Width		= 0;
	m_ihcCol1Width		= 0;
	m_bSetHeader		= 0;
	m_ppTypeInfo		= NULL;
	m_pSingleTypeInfo	= NULL;
	m_ulTypeInfos		= 0;
}

COleAllPage::~COleAllPage()
{
	if (m_bActive)
		DestroyWindow();

	ReleaseInterfaces();		// free cached IDispatch interfaces
}

// This method releases all the cached interfaces and resets the member
// variables.
void COleAllPage::ReleaseInterfaces()
{
	FreeNotifySinkInfo();		// release all property notify sinks

	// release any cached interfaces
	for (ULONG i = 0; i < m_ulCountControls; ++i)
	{
		ASSERT(m_pprgDisp[i]);
		if(m_pprgDisp[i])
			m_pprgDisp[i]->Release();
	}

	// we've special cased the single selection case.  if we have more than
	// one disp, then we need to free up this heap
	if (m_ulCountControls > 1)
		AfxFreeTaskMem(m_pprgDisp);

	m_pprgDisp			= NULL;
	m_pSingleDisp		= NULL;
	m_ulCountControls	= 0;

	for (i = 0; i < m_ulTypeInfos; ++i)
	{
		ASSERT(m_ppTypeInfo[i]);
		if(m_ppTypeInfo[i])
			m_ppTypeInfo[i]->Release();
	}

	// we've special cased the single selection case.  if we have more than
	// one typeinfo, then we need to free up this heap
	if (m_ulTypeInfos > 1)
		AfxFreeTaskMem(m_ppTypeInfo);

	m_ppTypeInfo		= NULL;
	m_pSingleTypeInfo	= NULL;
	m_ulTypeInfos		= 0;
}

BOOL COleAllPage::PreTranslateMessage(MSG* pMsg)
{
#if 0
	// please do not remove this
	// Was here so that enter-key is pased on to edit control
	// so that it transfers the control to the grid-listbox
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_RETURN)
	{
		if (m_lbProps.m_pTxt == GetFocus())
		{
			// this causes the edit control to lose focus
			// and thus save the property and then give
			// focus to the list box
			m_lbProps.SetFocus();
			return TRUE;
		}
		return FALSE;
	}
#endif
	return CSlobPage::PreTranslateMessage(pMsg);
}

void COleAllPage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	TRACE0("WM_COMMANDHELP is being eaten");
	return;
}

// Gets the required TypeInfo from the IProvideMultipleClassInfo interface
static HRESULT GetTypeInfoFromMultipleClassInfo(
	IDispatch*	pDisp,
	DISPID		dispid,
	ITypeInfo**	ppTypeInfo)
{
	ASSERT(pDisp && ppTypeInfo);
	*ppTypeInfo = NULL;
	
	HRESULT	hr;
	
	// see if the object provides multiple class infos
	COleRef<IProvideMultipleClassInfo>	srpPMCI;
	hr = pDisp->QueryInterface(IID_IProvideMultipleClassInfo, (void**)&srpPMCI);
	if (FAILED(hr))
		return hr;
	
	// Get count of Type Infos	
	ULONG	ulCountTypeInfos;
	hr = srpPMCI->GetMultiTypeInfoCount(&ulCountTypeInfos);
	if (FAILED(hr))
		ulCountTypeInfos = 1;

	// Variables used in for loop	
	COleRef<ITypeInfo>	srpTypeInfoStart;
	COleRef<ITypeInfo>	srpTypeInfo;
	LPTYPEATTR	ptaStart;
	LPTYPEATTR	pta;
	int			i;
	int			implTypeFlags;
	ULONG		ulCurTypeInfo;
	HREFTYPE	hrefType;
	
	for (ulCurTypeInfo = 0; ulCurTypeInfo < ulCountTypeInfos; ++ulCurTypeInfo)
	{
		pta = NULL;
		ptaStart = NULL;
		// since we are looping, make sure we release a
		// previously QI's interfaced
		srpTypeInfo.SRelease();
		srpTypeInfoStart.SRelease();

		// Get starting TypeInfo
		hr = srpPMCI->GetInfoOfIndex(ulCurTypeInfo,  MULTICLASSINFO_GETTYPEINFO,	
			&srpTypeInfoStart, NULL, NULL, NULL, NULL);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
			
		ASSERT(srpTypeInfoStart);
		VERIFY(srpTypeInfoStart->GetTypeAttr(&ptaStart) == S_OK);
		if (ptaStart->typekind == TKIND_DISPATCH ||
			ptaStart->typekind == TKIND_INTERFACE)
		{
			// since this is the correct typeinfo, get its interface pointer
			// and release the type attribute.
			srpTypeInfo = srpTypeInfoStart.Disown();
			pta = ptaStart;
		}
		else if (ptaStart->typekind == TKIND_COCLASS)
		{
			// go through and find out if we get a typekind of dispatch
			// if so, continue, otherwise, ignore this
			for (i = 0; i < ptaStart->cImplTypes; i++)
			{
				VERIFY(srpTypeInfoStart->GetImplTypeFlags(i, &implTypeFlags) == S_OK);
				VERIFY(srpTypeInfoStart->GetRefTypeOfImplType(i, &hrefType) == S_OK);
				VERIFY(srpTypeInfoStart->GetRefTypeInfo(hrefType, &srpTypeInfo) == S_OK);

				VERIFY(srpTypeInfo->GetTypeAttr(&pta) ==S_OK);
				if (pta->typekind != TKIND_DISPATCH)
				{
					srpTypeInfo->ReleaseTypeAttr(pta);
					srpTypeInfo.SRelease();
					pta = NULL;
					continue;
				}

				if (implTypeFlags & IMPLTYPEFLAG_FDEFAULT)
				{
					// Got our TypeInfo
					// release the start typeinfo and pta
					srpTypeInfoStart->ReleaseTypeAttr(ptaStart);
					break;
				}

				// release the type attribute since we do not need this
				srpTypeInfo->ReleaseTypeAttr(pta);
				srpTypeInfo.SRelease();
				pta = NULL;
			}
		}

		// new code above
		if (NULL == pta)
		{
			srpTypeInfoStart->ReleaseTypeAttr(ptaStart);
			continue;
		}
		
		// Finally have our TypeInfo
		ASSERT(srpTypeInfo);
		// GetDocumentation for DISPID
		hr = srpTypeInfo->GetDocumentation(dispid, NULL, NULL, NULL, NULL);
		if (SUCCEEDED(hr))
		{
			// Found a TypeInfo that contains the member
			*ppTypeInfo = srpTypeInfo.Disown();
			return hr;
		}
	}

	// didnt find TYPE info
	return E_FAIL;
}

// When the user presses the "F1" key or the "?" button, and if the AllPage
// is the active property page, this method is called.  This method tries
// to get the help file name and help context id from the ITypeInfo, or the
// ITypeLib.  If we get a help file name and not a help context id, the
// help finder dialog is displayed so that the user can select the topic
// himself/herself.
LRESULT COleAllPage::OnPageHelp(
	WPARAM	wParam,
	LPARAM	lParam)		// help context
{
	if (m_lbProps.m_uiIndex == -1)
		return E_UNEXPECTED;

	CPropItem*			pItem;

	pItem = (CPropItem*) m_lbProps.GetItemData(m_lbProps.m_uiIndex);
	if (NULL == pItem)
		return E_UNEXPECTED;

	COleRef<ITypeInfo>	srpTypeInfo;			// the type info we use to get props
	COleRef<ITypeLib>	srpTypeLib;

	UINT		uiIndex;
	BSTR		bstrHelpFile = NULL;
	ULONG		ulHelpContext = 0;
	DISPID		dispid;
	CString		strHelpFile;
	IDispatch*	pDisp;

	USES_CONVERSION;
	ASSERT(m_pprgDisp[0]);

	pDisp = m_pprgDisp[0];
	dispid = pItem->m_pDispid[0];
	// get the typeinfo
	if (SUCCEEDED(pDisp->GetTypeInfo(0, s_lcid, &srpTypeInfo)))
	{
		// try to get the help info from the typeinfo
		if (SUCCEEDED(srpTypeInfo->GetDocumentation(dispid, NULL, NULL,
			&ulHelpContext, &bstrHelpFile)))
			strHelpFile = OLE2T(bstrHelpFile);
		else
		{
			// Get another ITypeInfo from
			COleRef<ITypeInfo> srpOtherTypeInfo;
			if (SUCCEEDED(GetTypeInfoFromMultipleClassInfo(pDisp, 
				dispid, &srpOtherTypeInfo)))
			{
				ASSERT(srpOtherTypeInfo);
				if (SUCCEEDED(srpOtherTypeInfo->GetDocumentation(dispid,
						NULL, NULL, &ulHelpContext, &bstrHelpFile)))
					strHelpFile = OLE2T(bstrHelpFile);
			}
		}

		// if we did not get a help file, use the type library
		if (strHelpFile.IsEmpty() &&
			SUCCEEDED(srpTypeInfo->GetContainingTypeLib(&srpTypeLib, &uiIndex)) &&
			SUCCEEDED(srpTypeLib->GetDocumentation((int)uiIndex, NULL, NULL,
						&ulHelpContext, &bstrHelpFile)))
			strHelpFile = OLE2T(bstrHelpFile);

		// if we get the help info, use it
		if (!strHelpFile.IsEmpty())
		{
			// as suggested by Joseph Givens (from UE) and ScotG,
			// if we do not have proper context, use HELP_FINDER
			// instead of HELP_CONTEXT
			UINT	uiCommand = (ulHelpContext != 0) ? HELP_CONTEXT : HELP_FINDER;
			
			// remap certain control help to istudio help when being invoked
			// from the property browser's help button
			CFrameWnd *pFrame = ((CFrameWnd*)AfxGetMainWnd())->GetActiveFrame();
			if(pFrame)
			{
				CDocument *pDoc = pFrame->GetActiveDocument();
				if(pDoc && pDoc->IsKindOf(RUNTIME_CLASS(CIPCompDoc)))
				{
					//	fm20.hlp	HELPID_FORMSFORM	-> istudio.hlp, HELPID_LAYOUTEDITOR
					//	fm20.hlp	HELPID_FORMSFORM	-> istudio.hlp, HELPID_OBJECTEDITOR
					//	fm20.hlp	id              	-> isfm20.hlp,  id
					//	ped.hlp		HELPID_HOTSPOT		-> isctrls.hlp,	HELPID_HOTSPOT
					//	ped.hlp		HELPID_IMAGE		-> isctrls.hlp,	HELPID_IMAGE
					//	ped.hlp		HELPID_LAYOUT		-> isctrls.hlp,	HELPID_LAYOUT
					//	ped.hlp		id          		-> isctrls.hlp,	id (SHOULD NOT HAPPEN)

					// convert the strings to lower case so that Find works fine
					strHelpFile.MakeLower();
					if(strHelpFile.Find(_T("fm20.hlp")) > -1)
						strHelpFile = _T("isfm20.hlp");
					else if(strHelpFile.Find(_T("ped.hlp")) > -1)
						strHelpFile = _T("isctrls.hlp");
				}
			}

			theApp.HelpOnApplication(ulHelpContext, uiCommand, strHelpFile);
		}
	}

	::SysFreeString(bstrHelpFile);
	return S_OK;
}

// Standard method.  Just calls the main property list box to create its
// children, set the header column widths, etc.,.  Also creates the header
// control.
BOOL COleAllPage::OnInitDialog() 
{
	VERIFY(m_lbProps.SubclassDlgItem(IDC_ALLPROP_PROPLIST, this));
	CSlobPage::OnInitDialog();
	
	m_lbProps.CreateChildren();
	CRect rect;
	m_lbProps.GetClientRect(&rect);
	m_lbProps.SetColumnWidth(rect.Width() / 4);
	m_lbProps.SetFont(GetStdFont(font_Normal));
	m_lbProps.ModifyStyleEx(WS_EX_NOPARENTNOTIFY, 0);	// We need parent notifies.

	CRect	rcHeader = rect;
	int		iHeight = GetDefaultItemHeight(this);

	if (iHeight > 0)
		m_ihcHeight = iHeight;

	rcHeader.bottom = rcHeader.top + m_ihcHeight;
	m_hcProps.Create(HDS_BUTTONS | HDS_HORZ | WS_CHILD | WS_VISIBLE, //CCS_TOP | 
		rcHeader, this, IDC_PROP_HEADER);

	m_hcProps.SetFont(GetStdFont(font_Normal));

	HD_ITEM	hdi;
	CString	strProperty;
	CString	strValue;

	strProperty.LoadString(IDS_PROPERTYBROWSER_PROPERTY);
	strValue.LoadString(IDS_PROPERTYBROWSER_VALUE);

	LPSTR	pszCol1 = strProperty.GetBuffer(strProperty.GetLength() + 1);
	LPSTR	pszCol2 = strValue.GetBuffer(strValue.GetLength() + 1);

	m_ihcCol0Width = m_ihcCol1Width = rect.Width() / 2;

	ZeroMemory(&hdi, sizeof(hdi));
	hdi.mask = HDI_TEXT | HDI_WIDTH;
	hdi.cxy = m_ihcCol0Width;
	hdi.pszText = pszCol1;
	hdi.cchTextMax = _tclen(pszCol1);

	m_hcProps.InsertItem(0, &hdi);

	hdi.pszText = pszCol2;
	hdi.cchTextMax = _tclen(pszCol2);

	m_hcProps.InsertItem(1, &hdi);

	// load these strings once since we use them all over the place
	s_strTrue.LoadString(IDS_PROP_TRUE);
	s_strFalse.LoadString(IDS_PROP_FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL COleAllPage::Create(
	UINT	nIDSheet,
	CWnd*	pWndOwner)
{
	if (!CSlobPage::Create(nIDSheet, pWndOwner))
		return FALSE;

	// Save our minimum size, in case we get bigger.
	CRect	rectT;
	GetWindowRect(rectT);
	m_sizeMin = rectT.Size();

	m_bActive = TRUE;
	return TRUE;
}

// This method implements the "snap-back" effect.  When the m_bSetHeader
// flag is set, the 1st and 2nd columns are set to the previously
// determined sizes (in OnEndTrackHeader).
void COleAllPage::SetHeaderInfo()
{
	// we need to have this so that after the dragging of the divider
	// is done, we need to "snap-back" the divider to the right
	// position if the column 0 or 1 is too small.
	if (m_bSetHeader)
	{
		HD_ITEM	hdi;
		BOOL	bRepaint = FALSE;

		ZeroMemory(&hdi, sizeof(hdi));
		hdi.mask = HDI_WIDTH;

		m_hcProps.GetItem(0, &hdi);
		if (m_ihcCol0Width != hdi.cxy)
		{
			hdi.cxy = m_ihcCol0Width;
			m_hcProps.SetItem(0, &hdi);
			bRepaint = TRUE;
		}

		m_hcProps.GetItem(1, &hdi);
		if (m_ihcCol1Width != hdi.cxy)
		{
			hdi.cxy = m_ihcCol1Width;
			m_hcProps.SetItem(1, &hdi);
			bRepaint = TRUE;
		}

		if (bRepaint)
		{
			m_hcProps.InvalidateRect(NULL);
			m_hcProps.UpdateWindow();
		}

		m_bSetHeader = FALSE;
	}
}

// This handles the notification message when the header separation
// dragging stops.  We need to handle this so that we achieve the "snap-back"
// effect if the user makes the size of the first or second column too small.
// If the size of either column is < 1/5th the width of the header control,
// then the size of that column is set to 1/5th (and the other column is 4/5th).
// m_bSetHeader flag is set so that we can achieve the "snap-back" effect when
// the main property list box is redrawn (which calls SetHeaderInfo above)
void COleAllPage::OnEndTrackHeader(
	NMHDR*		pNMHDR,
	LRESULT*	pResult)
{
	HD_NOTIFY*	phdn = (HD_NOTIFY*) pNMHDR;
	HD_ITEM		hdi;
	CRect		rc;
	int			iFifth;

	*pResult = 0;

	m_hcProps.GetClientRect(&rc);
	iFifth = rc.Width() / 5;	// minimum column (0 or 1) width
	ZeroMemory(&hdi, sizeof(hdi));
	hdi.mask = HDI_WIDTH;

	// store the column widths
	if (phdn->iItem == 0)
	{
		m_ihcCol0Width = phdn->pitem->cxy;
		m_ihcCol1Width = rc.Width() - m_ihcCol0Width;
	}
	else if (phdn->iItem == 1)
	{
		m_ihcCol1Width = phdn->pitem->cxy;
		m_ihcCol0Width = rc.Width() - m_ihcCol1Width;
	}

	// recalculate column widths if either one is less than one fifth
	// the width of the entire header width
	// if so, set the flag so that we can resize ourselves later
	if (m_ihcCol0Width <= iFifth)
	{
		m_ihcCol0Width = iFifth;
		m_ihcCol1Width = rc.Width() - m_ihcCol0Width;
		m_bSetHeader = TRUE;
	}
	else if (m_ihcCol0Width >= (rc.Width() - iFifth))
	{
		m_ihcCol1Width = iFifth;
		m_ihcCol0Width = rc.Width() - m_ihcCol1Width;
		m_bSetHeader = TRUE;
	}

	if (phdn->iItem == 0)
	{
		hdi.cxy = m_ihcCol1Width;
		m_hcProps.SetItem(1, &hdi);	// set the other column width
	}
	else if (phdn->iItem == 1)
	{
		hdi.cxy = m_ihcCol0Width;
		m_hcProps.SetItem(0, &hdi);	// set the other column width
	}

	// repaint grid-listbox so that it can reflect the change in column widths
	m_lbProps.InvalidateRect(NULL);
}

// Handles the notification message when the Header separator is dragged
// There are 2 reasons for why we are handling this message.
// 1. We do not want the separator between the 2nd column and the 3rd (this
// column cannot be seen) to be dragged.
// 2. If the drop-down list box was visible when the dragging started, we
// want that to be hidden immediately.
void COleAllPage::OnTrackHeader(
	NMHDR*		pNMHDR,
	LRESULT*	pResult)
{
	HD_NOTIFY*	phdn = (HD_NOTIFY*) pNMHDR;

	// prevent the sizing of column 1
	// (dragging the divider between column 1 and 2)
	// because columns 0 and 1 can be resized by just dragging the
	// divider between columns 0 and 1
	if (phdn->iItem == 1)
		*pResult = TRUE;
	else
		*pResult = FALSE;

	// if the drop-down list box was visible, hide it
	if (m_lbProps.m_pLb->IsWindowVisible())
		m_lbProps.m_pLb->SetWindowPos(&wndBottom, 0, 0, 0, 0,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
}

// Helper which changes the current size of this property page.
void COleAllPage::ChangePageSize(
	CSize const&	sizeNew)
{
	CRect	rect;
	GetWindowRect(rect);
	CSize sizeOld = rect.Size();

	SetWindowPos(NULL, 0, 0, sizeNew.cx, sizeNew.cy,
				 SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);

	// make the list box fit inside the all-page property page
	HD_ITEM	hdi;

	m_ihcCol0Width = sizeNew.cx / 2;
	m_ihcCol1Width = sizeNew.cx - 1 - m_ihcCol0Width;	// -1 for visual hack

	ZeroMemory(&hdi, sizeof(hdi));
	hdi.mask = HDI_WIDTH;
	hdi.cxy = m_ihcCol0Width;
	m_hcProps.SetItem(0, &hdi);
	hdi.cxy = m_ihcCol1Width;
	m_hcProps.SetItem(1, &hdi);

	m_hcProps.SetWindowPos(NULL, 0, 0, sizeNew.cx - 1,
		m_ihcHeight, SWP_NOACTIVATE | SWP_NOZORDER);

	m_lbProps.SetWindowPos(NULL, 0, m_ihcHeight - 1, sizeNew.cx,
		sizeNew.cy - m_ihcHeight + 1, SWP_NOACTIVATE | SWP_NOZORDER);
}

// If the sheet asks how big we are, we assume that the contents of the sheet are
// changing.  We therefore shrink down to our minimum size ... if we are the current
// page, we will grow again when InitializePage is called.
CSize COleAllPage::GetPageSize()
{
	if (m_hWnd != NULL)		// are we initialized?
	{
		CRect rect;
		GetWindowRect(rect);
		if (rect.Size() != m_sizeMin)
			ChangePageSize(m_sizeMin);
	}
	return C3dPropertyPage::GetPageSize();
}

// When initialized, we grow to the maximum size that will fit on the sheet
// (i.e. the maximum size of any other property page).
void COleAllPage::InitializePage()
{
	ChangePageSize(m_pSheetWnd->m_sizePageMax);
	CSlobPage::InitializePage();	
}

// Initializes the property page and fills the property list (grid)
void COleAllPage::InitPage()
{
	COleRef<IDispatch>	srpDisp;

	ReleaseInterfaces();	// free cached IDispatch and ITypeInfo interfaces
	m_ulCountControls = COlePage::s_nObjectCurrent;
	if (1 == m_ulCountControls)
	{
		// ok, how about IDispatch for an all page
		if (SUCCEEDED(COlePage::s_pObjectCurrent[0]->QueryInterface(
			IID_IDispatch, (void**)&srpDisp)))
		{
			m_pSingleDisp = srpDisp.Disown();
			m_pprgDisp = &m_pSingleDisp;
		}
		else
		{
			m_ulCountControls = 0;
		}
	}
	else
	{
		m_pprgDisp = (IDispatch **)AfxAllocTaskMem(sizeof(IDispatch *) * m_ulCountControls);
		ASSERT(m_pprgDisp);
		if (NULL == m_pprgDisp)
			m_ulCountControls = 0;

		ULONG	j;
		for (ULONG i = 0; i < m_ulCountControls; ++i)
		{
			// ok, how about IDispatch for an all page
			if (SUCCEEDED(COlePage::s_pObjectCurrent[i]->QueryInterface(
				IID_IDispatch, (void**)&srpDisp)))
			{
				m_pprgDisp[i] = srpDisp.Disown();
			}
			else
			{
				// something went wrong, release all interfaces and
				// bail out of here
				for (j = 0; j < i; ++j)
					m_pprgDisp[j]->Release();

				AfxFreeTaskMem(m_pprgDisp);
				m_pprgDisp = NULL;
				m_ulCountControls = 0;			// will also terminate the for()
			}
		}
	}

	GetNotifySinkInfo();	// get all notify sinks
	FillPropList();
}

// This method implements the initializing of the property list (grid)
void COleAllPage::FillPropList()
{
	m_lbProps.SetRedraw(FALSE);	// to avoid flickering
	m_lbProps.ResetContent();	// delete all the items first

	int				iShowAllPropsList;
	int				iShowNoBrowseableStatic;
	BOOL			bRet = FALSE;
	CMapStringToPtr	map;

	// get the properties for the first control
	if (m_ulCountControls > 0)
	{
		// set the number of items (controls) selected
		// NOTE: THIS IS IMPORTANT, otherwise, caching of dispids will FAIL
		CPropItem::s_ulCountControls = m_ulCountControls;

		bRet = AddToMap(m_pprgDisp[0], &map);
	}

	// now intersect those properties with the other controls
	for (ULONG i = 1; bRet && (map.GetCount() > 0) && (i < m_ulCountControls); ++i)
		bRet = IntersectToMap(&map, i);

	// if no properties are in the list box hide the lb, show
	// the "no browseable properties" static
	if (map.GetCount() <= 0)
	{
		iShowAllPropsList = SW_HIDE; 
		iShowNoBrowseableStatic = SW_SHOW;
	}
	else
	{
		int			iIndex;
		CString		str;
		CPropItem*	pItem = NULL;
		POSITION	pos = map.GetStartPosition();

		while(NULL != pos)
		{
			map.GetNextAssoc(pos, str, (void*&)pItem);
			ASSERT(pItem && (str == pItem->m_strText));
			LBAddStringAndSetItemData(&m_lbProps, pItem->m_strText, (DWORD)pItem);
		}

		map.RemoveAll();
		iShowAllPropsList = SW_SHOW;
		iShowNoBrowseableStatic = SW_HIDE;
	}

	GetDlgItem(IDC_ALLPROP_PROPLIST)->ShowWindow(iShowAllPropsList);
	GetDlgItem(IDC_PROP_HEADER)->ShowWindow(iShowAllPropsList);
	GetDlgItem(IDC_ALLPROP_NOBROWSEABLE)->ShowWindow(iShowNoBrowseableStatic);

	m_lbProps.SetCurSel(0);
	m_lbProps.SetRedraw(TRUE);
	m_lbProps.Invalidate();
}

// Returns TRUE ifthe given ITypeInfo interface has GUID_HasPathProperties tag
// attached to it.
BOOL COleAllPage::DoesTypeInfoHasPathProperties(
	ITypeInfo*	srpTypeInfoStart)
{
	BOOL				bHasPathProps = FALSE;
	COleRef<ITypeInfo2>	srpTypeInfo2;

	if (SUCCEEDED(srpTypeInfoStart->QueryInterface(IID_ITypeInfo2, (void**)&srpTypeInfo2)))
	{
		VARIANT	varValue;

		// is the path property supported
		::VariantInit(&varValue);
		if (SUCCEEDED(srpTypeInfo2->GetCustData(GUID_HasPathProperties, &varValue))
			&& (varValue.vt != VT_EMPTY))
		{
			bHasPathProps = TRUE;
		}
		else
		{
			// find out if the top-level typeinfo supports path property
			COleRef<IPersist>	srpPersist;
			COleRef<ITypeInfo>	srpTypeInfo;
			COleRef<ITypeLib>	srpTypeLib;
			CLSID				clsid;
			
			if (SUCCEEDED(m_dispDriver.m_lpDispatch->QueryInterface(IID_IPersist,
					(void**)&srpPersist)) &&
				SUCCEEDED(srpPersist->GetClassID(&clsid)) &&
				SUCCEEDED (srpTypeInfoStart->GetContainingTypeLib(&srpTypeLib, 0)) &&
				SUCCEEDED(srpTypeLib->GetTypeInfoOfGuid(clsid, &srpTypeInfo)))
			{
				// release the current typeinfo2 interface since we are going
				// to reuse the same variable
				srpTypeInfo2.SRelease();
				::VariantInit(&varValue);
				// get the typeinfo2 from the new top-level typeinfo
				// and try to find out if that supports the path properties
				if (SUCCEEDED(srpTypeInfo->QueryInterface(IID_ITypeInfo2, (void**)&srpTypeInfo2)) &&
					SUCCEEDED(srpTypeInfo2->GetCustData(GUID_HasPathProperties, &varValue))
					&& (varValue.vt != VT_EMPTY))
					bHasPathProps = TRUE;
			}
		}
	}

	return bHasPathProps;
}

// This method goes through the ITypeInfo's of the first control selected
// and gathers all the properties that can be modified and stores all the
// necessary information needed to edit any property.  For single selection
// (of controls) this becomes the final set of properties, and for multiple
// selection, this is the initial set of properties which is used to compare
// with the set of properties that we get for the other controls selected
// and get the "common" set of properties for all the controls selected.
// This intersecting of properties is done in IntersectToMap method.
BOOL COleAllPage::AddToMap(
	IDispatch*			pDisp,
	CMapStringToPtr*	pMap)
{
	ASSERT(pDisp && pMap);
	if (NULL == pDisp || NULL == pMap)
		return FALSE;
	
	m_dispDriver.AttachDispatch(pDisp, FALSE);

	COleRef<IProvideMultipleClassInfo>	srpPMCI;

	int			i;
	int			implTypeFlags;
	BOOL		bHasPathProps;
	BOOL		bCacheDesc;
	ULONG		ulCurTypeInfo;
	ULONG		ulCountTypeInfos;
	HREFTYPE	hrefType;
	HREFTYPE	hrtFuncDesc;
	LPVARDESC	pvd;
	LPFUNCDESC	pfd;
	LPTYPEATTR	pta;
	LPTYPEATTR	ptaStart;
	CPropItem*	pItem;
	VARIANT		var;
	DataType	dt;
	CString		strNPropName;
	HRESULT		hr;

	// see if the object provides multiple class infos
	if (FAILED(pDisp->QueryInterface(IID_IProvideMultipleClassInfo, (void**)&srpPMCI)) ||
		FAILED(srpPMCI->GetMultiTypeInfoCount(&ulCountTypeInfos)))
		ulCountTypeInfos = 1;

	// if we have only one type info, do not allocate memory for an array
	m_ulTypeInfos = ulCountTypeInfos;
	if (1 == ulCountTypeInfos)
	{
		m_ppTypeInfo = &m_pSingleTypeInfo;
		m_ppTypeInfo[0] = NULL;
	}
	else
	{
		m_ppTypeInfo = (ITypeInfo**) AfxAllocTaskMem(sizeof(ITypeInfo*) * ulCountTypeInfos);
		ASSERT(m_ppTypeInfo);
		if (NULL == m_ppTypeInfo)
			return E_OUTOFMEMORY;

		// Zero out the array so that we can safely walk through later and release
		// pointers to typeinfos if we have to bail out of this function.
		for (ulCurTypeInfo = 0; ulCurTypeInfo < ulCountTypeInfos; ulCurTypeInfo++)
			m_ppTypeInfo[ulCurTypeInfo] = NULL;
	}

	// go through each typeinfo and get the properties that can be edited
	for (ulCurTypeInfo = 0; ulCurTypeInfo < ulCountTypeInfos; ++ulCurTypeInfo)
	{
		COleRef<ITypeInfo>	srpTypeInfoStart;	// use this to get the correct typeinfo
		COleRef<ITypeInfo>	srpTypeInfo;		// the type info we use to get props

		pta = NULL;
		ptaStart = NULL;
		if (srpPMCI)
		{
			// since we are looping, make sure we release a
			// previously QI's interfaced
			if (srpTypeInfo != NULL)
				srpTypeInfo.SRelease();
			if (srpTypeInfoStart != NULL)
				srpTypeInfoStart.SRelease();

			if (FAILED(srpPMCI->GetInfoOfIndex(ulCurTypeInfo, 
				MULTICLASSINFO_GETTYPEINFO,	&srpTypeInfoStart, 
				NULL, NULL, NULL, NULL)))
			{
				ASSERT(FALSE);

				for (ULONG i=0; i<ulCountTypeInfos; i++)
				{
					ITypeInfo *&rpITypeInfo = m_ppTypeInfo[i];

					if (rpITypeInfo != NULL)
					{
						rpITypeInfo->Release();
						rpITypeInfo = NULL;
					}
				}

				if (ulCountTypeInfos != 1)
					AfxFreeTaskMem(m_ppTypeInfo);

				m_ppTypeInfo = NULL;

				m_ulTypeInfos = 0;

				return FALSE;
			}
		}
		else
		{
			ASSERT(1 == ulCountTypeInfos);
			hr = m_dispDriver.m_lpDispatch->GetTypeInfo(0, s_lcid, &srpTypeInfoStart);
			if (FAILED(hr))
			{
				// Report an error; controls are supposed to be able to yield a
				// typeinfo since they must support IDispatch.  Tell the user to
				// complain to the control's author.
				TCHAR	szBuff[80];
				CString	strMessage;

				wsprintf(szBuff, _T("0x%08lx"), hr);
				AfxFormatString1(strMessage, IDS_NO_CONTROL_TYPEINFO, szBuff);
				AfxMessageBox(strMessage);

				for (ULONG i=0; i<ulCountTypeInfos; i++)
				{
					ITypeInfo *&rpITypeInfo = m_ppTypeInfo[i];

					if (rpITypeInfo != NULL)
					{
						rpITypeInfo->Release();
						rpITypeInfo = NULL;
					}
				}

				if (ulCountTypeInfos != 1)
					AfxFreeTaskMem(m_ppTypeInfo);

				m_ppTypeInfo = NULL;

				m_ulTypeInfos = 0;

				return FALSE;
			}
		}

		ASSERT(srpTypeInfoStart != NULL);

		bHasPathProps = DoesTypeInfoHasPathProperties(srpTypeInfoStart);

		// new code below to interpret sub typeinfo's
		LPTYPEATTR	ptaStart;

		VERIFY(srpTypeInfoStart->GetTypeAttr(&ptaStart) == S_OK);
		if (ptaStart->typekind == TKIND_DISPATCH ||
			ptaStart->typekind == TKIND_INTERFACE)
		{
			// since this is the correct typeinfo, get its interface pointer
			// and release the type attribute.
			srpTypeInfo = srpTypeInfoStart.Disown();
			pta = ptaStart;
		}
		else if (ptaStart->typekind == TKIND_COCLASS)
		{
			// go through and find out if we get a typekind of dispatch
			// if so, continue, otherwise, ignore this
			for (i = 0; i < ptaStart->cImplTypes; i++)
			{
				VERIFY(srpTypeInfoStart->GetImplTypeFlags(i, &implTypeFlags) == S_OK);
				VERIFY(srpTypeInfoStart->GetRefTypeOfImplType(i, &hrefType) == S_OK);
				VERIFY(srpTypeInfoStart->GetRefTypeInfo(hrefType, &srpTypeInfo) == S_OK);

				VERIFY(srpTypeInfo->GetTypeAttr(&pta) ==S_OK);
				if (pta->typekind != TKIND_DISPATCH)
				{
					srpTypeInfo->ReleaseTypeAttr(pta);
					srpTypeInfo.SRelease();
					pta = NULL;
					continue;
			//<=====
				}

				if (implTypeFlags & IMPLTYPEFLAG_FDEFAULT)
				{
					// release the start typeinfo and pta
					srpTypeInfoStart->ReleaseTypeAttr(ptaStart);
					break;
			//<=====
				}

				// release the type attribute since we do not need this
				srpTypeInfo->ReleaseTypeAttr(pta);
				srpTypeInfo.SRelease();
				pta = NULL;
			}
		}

		// new code above
		if (NULL == pta)
		{
			srpTypeInfoStart->ReleaseTypeAttr(ptaStart);
			continue;
		}

		//  Enumerate properties
		pvd = NULL;
		pfd = NULL;
		// handle the vardesc
		for (i = 0; i < pta->cVars; i++)
		{
			if (FAILED(srpTypeInfo->GetVarDesc(i, &pvd)))
				continue;

			ASSERT(pvd);
			dt = data_Unknown;
			bCacheDesc = FALSE;

			// hWnd parameter is not editable
			// make sure that the property is editable
			// also, finally to make sure, get the property value, which
			// fails if property is not editable
			if ((DISPID_HWND != pvd->memid) &&
				!IsPropTypeReadOnly(pvd, NULL, TRUE) &&
				GetPropValue(pDisp, pvd->memid, &var))
			{
				// get the property data type
				dt = GetPropType(pDisp, srpTypeInfo, pvd, NULL, bHasPathProps);
			}

			// do not allow editing of font and picture for multiple selection
			if ((dt != data_Unknown) && (m_ulCountControls > 1) &&
				((dt == data_Font) || (dt == data_Picture)))
				dt = data_Unknown;

			//if we made through to this place, get the property name
			if ((dt != data_Unknown) &&
				GetPropName(srpTypeInfo, pvd->memid, strNPropName))
			{
				pItem = new CPropItem(strNPropName, pvd->elemdescVar.tdesc.vt,
					dt, pvd->memid);
				if (GetPropDetails(pDisp, srpTypeInfo,
					pvd->elemdescVar.tdesc.hreftype, pvd->memid, pItem, TRUE, &var))
				{
					pMap->SetAt(strNPropName, (void*)pItem);
					// just save a copy of ITypeInfo, actuall addref'ed ITypeInfo
					// is stored in m_ppTypeInfo array in COleAllPage.
					// NOTE: <ignatius vc98:2910>
					// we still need to addref it since COleAllPage releases all the
					// m_ppTypeInfo stuff before the pItem is deleted.
					pItem->m_TypeInfo = srpTypeInfo;
					if (pItem->m_TypeInfo)
						pItem->m_TypeInfo->AddRef();
					pItem->m_pvd = pvd;	// cache vardesc for later use
					bCacheDesc = TRUE;	// this is released when pItem is destructed
				}
				else
				{
					delete pItem;
				}
			}

			::VariantClear(&var);
			if (!bCacheDesc)
				srpTypeInfo->ReleaseVarDesc(pvd);
		}

		// handle the funcdesc
		for (i = 0; i < pta->cFuncs; i++)
		{
			if (FAILED(srpTypeInfo->GetFuncDesc(i, &pfd)))
				continue;

			ASSERT(pfd);
			dt = data_Unknown;
			bCacheDesc = FALSE;

			// hWnd parameter is not editable
			// make sure that the property is editable
			// also, finally to make sure, get the property value, which
			// fails if property is not editable
			if ((DISPID_HWND != pfd->memid) &&
				!IsPropTypeReadOnly(NULL, pfd, TRUE) &&
				GetPropValue(pDisp, pfd->memid, &var))
			{
				// get the property data type
				dt = GetPropType(pDisp, srpTypeInfo, NULL, pfd, bHasPathProps);
			}

			// do not allow editing of font and picture for multiple selection
			if ((dt != data_Unknown) && (m_ulCountControls > 1) &&
				((dt == data_Font) || (dt == data_Picture)))
				dt = data_Unknown;

			//if we made through to this place, get the property name
			if ((dt != data_Unknown) &&
				GetPropName(srpTypeInfo, pfd->memid, strNPropName) &&
				!pMap->Lookup(strNPropName, (void*&)pItem))
			{
				pItem = new CPropItem(strNPropName,
					pfd->lprgelemdescParam->tdesc.vt, dt, pfd->memid);
				hrtFuncDesc = pfd->lprgelemdescParam->tdesc.hreftype;
				if ((pfd->lprgelemdescParam->tdesc.vt == VT_PTR) &&
					(pfd->lprgelemdescParam->tdesc.lptdesc->vt == VT_USERDEFINED))
					hrtFuncDesc = pfd->lprgelemdescParam->tdesc.lptdesc->hreftype;

				if (GetPropDetails(pDisp, srpTypeInfo, hrtFuncDesc, pfd->memid,
					pItem, TRUE, &var))
				{
					pMap->SetAt(strNPropName, (void*)pItem);
					// just save a copy of ITypeInfo, actuall addref'ed ITypeInfo
					// is stored in m_ppTypeInfo array in COleAllPage.
					// NOTE: <ignatius vc98:2910>
					// we still need to addref it since COleAllPage releases all the
					// m_ppTypeInfo stuff before the pItem is deleted.
					pItem->m_TypeInfo = srpTypeInfo;
					if (pItem->m_TypeInfo)
						pItem->m_TypeInfo->AddRef();
					pItem->m_pfd = pfd;	// cache funcdesc for later use
					bCacheDesc = TRUE;	// this is released when pItem is destructed
				}
				else
				{
					delete pItem;
				}
			}

			::VariantClear(&var);
			if (!bCacheDesc)
				srpTypeInfo->ReleaseFuncDesc(pfd);
		}

		srpTypeInfo->ReleaseTypeAttr(pta);

		// store the ITypeInfo in the array
		m_ppTypeInfo[ulCurTypeInfo] = srpTypeInfo.Disown();
	}

	return TRUE;
}

// "Intersects" the set of properties that can be edited.  AddToMap method
// gets the first set of properties from the first control -- and for the rest
// of the controls selected, this method, shortens the set of properties
// that are common to all the controls selected.  For example, if the "ForeColor"
// property exists in control A and not in control B, then it is eliminated
// from the set of properties here.
BOOL COleAllPage::IntersectToMap(
	CMapStringToPtr*	pMap,
	ULONG				ulIndex)
{
	IDispatch*	pDisp = m_pprgDisp[ulIndex];

	// we should have more than one control selected to get here
	ASSERT((m_ulCountControls > 1) && pDisp && pMap && pMap->GetCount());
	if (NULL == pDisp || NULL == pMap || m_ulCountControls <= 1 || 0 == pMap->GetCount())
		return FALSE;

	m_dispDriver.AttachDispatch(pDisp, FALSE);

	// see if the object provides multiple class infos
	COleRef<IProvideMultipleClassInfo>	srpPMCI;
    
	COleRef<ITypeInfo>	srpTypeInfo;
	COleRef<ITypeComp>	srpTypeComp;	
	COleRef<ITypeInfo>	srpTypeInfoBind;

	BOOL		bPropExists;
	ULONG		ulCurTypeInfo;
	ULONG		ulCountTypeInfos;
	POSITION	pos;
	CPropItem*	pItem;
	CString		strPropName;
	DESCKIND	descKind;
	BINDPTR		bindPtr;
	VARTYPE		vt;
	DataType	dt;
	CString		strNPropName;

	if (FAILED(pDisp->QueryInterface(
		IID_IProvideMultipleClassInfo, (void**)&srpPMCI)) ||
		FAILED(srpPMCI->GetMultiTypeInfoCount(&ulCountTypeInfos)))
		ulCountTypeInfos = 1;

	// walk the list box and see if these props exits in the
	// object we were given (represented by pDisp)
	USES_CONVERSION;
	pos = pMap->GetStartPosition();
	while(NULL != pos)
	{
		pMap->GetNextAssoc(pos, strPropName, (void*&)pItem);
		ASSERT(pItem && (strPropName == pItem->m_strText));

		bPropExists = FALSE;
		for (ulCurTypeInfo = 0; ulCurTypeInfo < ulCountTypeInfos; ++ulCurTypeInfo)
		{
			if (srpPMCI)
			{
				if (FAILED(srpPMCI->GetInfoOfIndex(ulCurTypeInfo, 
					MULTICLASSINFO_GETTYPEINFO,	&srpTypeInfo, 
					NULL, NULL, NULL, NULL)) ||
					FAILED(srpTypeInfo->GetTypeComp(&srpTypeComp)))
				{
					ASSERT(FALSE);
					return FALSE;
				}
			}
			else
			{
				ASSERT(1 == ulCountTypeInfos);
				if (FAILED(m_dispDriver.m_lpDispatch->GetTypeInfo(
					0, s_lcid, &srpTypeInfo)) ||
					FAILED(srpTypeInfo->GetTypeComp(&srpTypeComp)))
				{
					ASSERT(FALSE);
					return FALSE;
				}
			}

			ASSERT(srpTypeInfo && srpTypeComp);
			if (SUCCEEDED(srpTypeComp->Bind(T2OLE(strPropName), 
				::LHashValOfName(s_lcid, T2OLE(strPropName)),
				INVOKE_PROPERTYPUTREF | INVOKE_PROPERTYPUT, 
				&srpTypeInfoBind, &descKind, &bindPtr)))
			{
				if (DESCKIND_VARDESC == descKind)
				{
					if (!((bindPtr.lpvardesc->wVarFlags & VARFLAG_FREADONLY) ||
						pItem->m_vt != bindPtr.lpvardesc->elemdescVar.tdesc.vt ||
						!IntersectPropItemData(pDisp,
							bindPtr.lpvardesc->memid, pItem,
							srpTypeInfo, &bindPtr.lpvardesc->elemdescVar.tdesc)))
					{
						pItem->SetDispid(ulIndex, bindPtr.lpvardesc->memid);
						bPropExists = TRUE;
						ulCurTypeInfo = ulCountTypeInfos;	// break out of for loop
					}
				}
				else if (DESCKIND_FUNCDESC == descKind)
				{
					ASSERT(bindPtr.lpfuncdesc);
					dt = data_Unknown;
					// if property is not read-only, get the property data type
					if (!IsPropTypeReadOnly(NULL, bindPtr.lpfuncdesc, FALSE))
						dt = GetPropType(pDisp, srpTypeInfo, NULL,
							bindPtr.lpfuncdesc, FALSE);

					if ((dt == data_Unknown) ||
						!(GetPropName(srpTypeInfo, bindPtr.lpfuncdesc->memid,
							strNPropName)))
					{
						ulCurTypeInfo = ulCountTypeInfos;	// break out of for loop
					}
					else
					{
						if ((bindPtr.lpfuncdesc->invkind & 
							(INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF)) &&
							(1 == bindPtr.lpfuncdesc->cParams) &&
							(pItem->m_vt == bindPtr.lpfuncdesc->lprgelemdescParam[0].tdesc.vt) &&
							IntersectPropItemData(pDisp,
								bindPtr.lpfuncdesc->memid, pItem, srpTypeInfo,
								&bindPtr.lpfuncdesc->lprgelemdescParam[0].tdesc))
						{
							pItem->SetDispid(ulIndex, bindPtr.lpfuncdesc->memid);
							bPropExists = TRUE;
							ulCurTypeInfo = ulCountTypeInfos;	// break out of for loop
						}
					}
				}

				DeleteBindPtr(srpTypeInfo, &descKind, &bindPtr);
			}
			
			srpTypeInfo.SRelease();
			srpTypeComp.SRelease();
			srpTypeInfoBind.SRelease();
		}

		if (!bPropExists)
		{
			pMap->RemoveKey(pItem->m_strText);
			delete pItem;
		}
	}

	return TRUE;
}

void COleAllPage::DeleteBindPtr(
	ITypeInfo*	pTypeInfo,
	DESCKIND*	pDescKind,
	BINDPTR*	pBindPtr)
{
	ASSERT(pTypeInfo && pDescKind && pBindPtr);
	if (NULL == pTypeInfo || NULL== pDescKind || NULL == pBindPtr)
		return;

	switch(*pDescKind)
	{
		case DESCKIND_FUNCDESC:
			pTypeInfo->ReleaseFuncDesc(pBindPtr->lpfuncdesc);
			break;
		case DESCKIND_VARDESC:
			pTypeInfo->ReleaseVarDesc(pBindPtr->lpvardesc);
			break;
		case DESCKIND_TYPECOMP:
			pBindPtr->lptcomp->Release();
			break;
		case DESCKIND_IMPLICITAPPOBJ:
		case DESCKIND_NONE:
			break;
		default:
			ASSERT(FALSE);		// Bogus descKind
			break;
	}	
}

// Frees all the data/interfaces stored within the AllPage
// This is the complement function to InitPage
void COleAllPage::TermPage()
{
	m_lbProps.ResetContent();	// remove all items from the list box
	ReleaseInterfaces();		// free cached IDispatch and ITypeInfo interfaces
	CSlobPage::TermPage();		// call base class
}

// Validates and applies the property change to the set of selected controls
BOOL COleAllPage::Validate()
{
	// if the property has changed, then-only call apply
	if ((m_ulCountControls > 0) && m_pprgDisp && m_lbProps.m_pTxt->GetModify())
	{
		CPropItem*	pItem;

		// there is a situation that the modified text is in the edit control
		// but not updated to the pItem->m_strProp yet, so update it here
		if (m_lbProps.m_uiIndex != -1)
		{
			pItem = (CPropItem*) m_lbProps.GetItemData(m_lbProps.m_uiIndex);
			m_lbProps.m_pTxt->GetWindowText(pItem->m_strProp);
			// set the modify flag to false since we do not want to
			// save the same property twice
			m_lbProps.m_pTxt->SetModify(FALSE);
		}

		if (!Apply())
			return FALSE;
	}
		
	m_nValidateID = NULL;
	return TRUE;
}

BOOL COleAllPage::UndoPendingValidate()
{
//	TermPage();
	// for the time being read call this, later we need to change this to
	// load the single property
//	UpdateChangedProperties();
	return FALSE;
}

// The top level method to save the property for all the selected control(s)
BOOL COleAllPage::Apply()
{
	// if we are not displaying any properties (because there are none for one
	// of 2 reasons: 1. there are no properties, 2. there are no common
	// properties among the selected controls)
	// just return TRUE
	// The m_lbProps window will be not visible in this case
	if ((m_lbProps.GetCount() < 0) || (m_lbProps.m_uiIndex == -1))
		return TRUE;

	BOOL		bSet = FALSE;
	BOOL		fSuccess = TRUE;
	CPropItem*	pItem;

	ASSERT(m_pprgDisp);
	
	m_bUpdateLater = FALSE;
	// tell IPropertyNotifySink::OnChanged that we are updating properties
	// so that all refreshing happen later
	m_bUpdatingProps = TRUE;

	m_pSlob->BeginUndo(IDS_UNDO_OLE_PROPS);

	USES_CONVERSION;
	for (int i = 0; i < m_ulCountControls && fSuccess; i++)
	{
		ASSERT(NULL != m_pprgDisp[i]);
		ASSERT(m_lbProps.m_uiIndex != -1);
		if (m_lbProps.m_uiIndex != -1)
		{
			pItem = (CPropItem*) m_lbProps.GetItemData(m_lbProps.m_uiIndex);
			ASSERT(NULL != pItem);
			m_dispDriver.AttachDispatch(m_pprgDisp[i], FALSE);
			fSuccess = SUCCEEDED(ApplyProperty(pItem->m_pDispid[i], pItem,
				m_pprgDisp[i]));
		}
	}

	// check to see if we made it through the array
	bSet = (i == m_ulCountControls && fSuccess);
	// EndUndo takes a flag which is TRUE to abort the Undo Record, & FALSE 
	// to keep the undo record
	m_pSlob->EndUndo(!bSet);

	m_bUpdatingProps = FALSE;

	// just attach the first dispatch ptr
	m_dispDriver.AttachDispatch(m_pprgDisp[0], FALSE);

	if (m_bUpdateLater)
		UpdateChangedProperties();

	return bSet;
}

// Saves the general properties (not font or picture)
// Appropriate conversinos are done from the string that the user types to the
// correct data type.  If the property could not be saved for some reason, an
// error message is displayed (the control specified error message is displayed
// if the control specifies a particuar error message or a default "Invalid Property"
// message is displayed.
HRESULT COleAllPage::ApplyProperty(
	DISPID		dispid,
	CPropItem*	pItem,
	IDispatch*	pDisp)
{
	HRESULT	hr = S_OK;
	CString	strError;

	USES_CONVERSION;

	// Clear ErrorInfo object before we call SetProperty
	::SetErrorInfo(0L, NULL);
	
	// m_dispDriver must be set by the caller so that it can be used here
	try
	{
		switch(pItem->m_dataType)
		{
			default:
			case data_Unknown:
				ASSERT(FALSE);
				break;
			case data_Int2:		// maps to VT_I2
			case data_UInt2:
			{
				short	sValue;

				hr = VarI2FromStr(T2OLE(pItem->m_strProp), s_lcid,
					LOCALE_NOUSEROVERRIDE, &sValue);
				if (S_OK == hr)
					m_dispDriver.SetProperty(dispid, VT_I2, sValue);
			}
				break;
			case data_Int4:		// maps to VT_I4
			case data_UInt4:
			{
				long	lValue;

				hr = VarI4FromStr(T2OLE(pItem->m_strProp), s_lcid,
					LOCALE_NOUSEROVERRIDE, &lValue);
				if (S_OK == hr)
					m_dispDriver.SetProperty(dispid, VT_I4, lValue);
			}
				break;
			case data_Float:		// maps to VT_R4
			{
				float	fValue;

				hr = VarR4FromStr(T2OLE(pItem->m_strProp), s_lcid,
					LOCALE_NOUSEROVERRIDE, &fValue);
				if (S_OK == hr)
					m_dispDriver.SetProperty(dispid, VT_R4, fValue);
			}
				break;
			case data_Double:		// maps to VT_R8
			{
				double	dValue;

				hr = VarR8FromStr(T2OLE(pItem->m_strProp), s_lcid,
					LOCALE_NOUSEROVERRIDE, &dValue);
				if (S_OK == hr)
					m_dispDriver.SetProperty(dispid, VT_R8, dValue);
			}
				break;
			case data_Bool:		// maps to VT_BOOL
				m_dispDriver.SetProperty(dispid, VT_BOOL, (BOOL)pItem->unionValue.m_nValue);
				break;
			case data_Color:
			{
				long	lColor;
				LPTSTR	pszStopString;

				lColor = _tcstol(LPCTSTR(pItem->m_strProp), &pszStopString, 0);
				if ((*pszStopString != _T('\0')) ||
					(LONG_MAX == lColor) || (LONG_MIN == lColor))
					hr = E_FAIL;
				else
					m_dispDriver.SetProperty(dispid, VT_I4, lColor);
			}
				break;
			case data_Font:
			case data_Picture:
				// these things are handled automatically through
				// the builders or proppages
				break;
			case data_Path:		// works with VT_BSTR fine
			case data_String:	// maps to VT_BSTR
				m_dispDriver.SetProperty(dispid, VT_BSTR, pItem->m_strProp);
				break;
			case data_EnumString:
			{
				VARIANT	var;
				BYTE	rgbParams[2];
				WORD	wFlags;

				COleRef<IPerPropertyBrowsing>	srpPPB;
				
				if (!GetPerPropertyBrowsing(m_dispDriver.m_lpDispatch, &srpPPB))
					break;

				ASSERT(srpPPB);
				hr = srpPPB->GetPredefinedValue(dispid, pItem->unionValue.m_dwValue, &var);
				if (FAILED(hr))
					break;

				if (var.vt & VT_BYREF)
				{
					var.vt &= ~VT_BYREF;
					var.vt |= VT_MFCBYREF;
				}

				ASSERT(_tcslen(VTS_VARIANT) == 1);

				rgbParams[0] = *VTS_VARIANT;
				rgbParams[1] = 0;
				wFlags = (WORD)((var.vt == VT_DISPATCH) ?
					DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT);

				try
				{
					m_dispDriver.InvokeHelper(dispid, wFlags, VT_EMPTY, NULL,
						rgbParams, &var);
				}
				catch(COleDispatchException* e)
				{
					hr = e->m_scError;
					strError = e->m_strDescription;
				}
				catch(...)
				{
					hr = E_FAIL;
				}

				::VariantClear(&var);
			}
				break;
			case data_EnumInt2:
				m_dispDriver.SetProperty(dispid, VT_I2, pItem->unionValue.m_nValue);
				break;
			case data_EnumInt4:
				m_dispDriver.SetProperty(dispid, VT_I4, pItem->unionValue.m_nValue);
				break;
			case data_Date:
			{
				DATE	date;

				hr = VarDateFromStr(T2OLE(pItem->m_strProp), s_lcid,
					LOCALE_NOUSEROVERRIDE, &date);
				if (S_OK == hr)
				{
					VARIANT	var;

					m_dispDriver.SetProperty(dispid, VT_DATE, date);
					// we need to get the property again, since
					// the date property is "converted" sometimes
					// i.e., from "13/12/96" to "12/13/96" so we need
					// to display the correct value (just as in VB)
					if (GetPropValue(pDisp, dispid, &var))
						GetPropValueForOtherTypes(&var, pItem);
				}
			}
				break;
			case data_Currency:
			{
				CURRENCY	currency;
				hr = VarCyFromStr(T2OLE(pItem->m_strProp), s_lcid,
					LOCALE_NOUSEROVERRIDE, &currency);
				if (S_OK == hr)
					m_dispDriver.SetProperty(dispid, VT_CY, &currency);
#if 0
				VARIANT	varSrc;
				VARIANT	varDest;
				DISPID	dispidNamed = DISPID_PROPERTYPUT;
				DISPPARAMS	dp = {&varDest, &dispidNamed, 1, 1};

				::VariantInit(&varSrc);
				V_VT(&varSrc) = VT_BSTR;
				V_BSTR(&varSrc) = pItem->m_strProp.AllocSysString();
				hr = ::VariantChangeType(&varDest, &varSrc, VARIANT_NOVALUEPROP,
					VT_CY);
				if (S_OK == hr)
				{
					hr = m_dispDriver.m_lpDispatch->Invoke(dispid, IID_NULL, 0,
						INVOKE_PROPERTYPUT, &dp, NULL, NULL, NULL);

					::VariantClear(&varDest);
				}
#endif
			}
				break;
		}
	}
    catch(COleDispatchException* e)
	{
		hr = e->m_scError;
		strError = e->m_strDescription;
	}
	catch(...)
	{
		hr = E_FAIL;
	}

	if (S_OK != hr)
	{
		if (strError.IsEmpty())
			strError.LoadString(IDS_PROP_ERROR_INVPROP);

		// do not use AfxMessageBox, since specifying the default window
		// as the owner causes a mouse up to be lost (sridharc)
		::MessageBox(AfxGetMainWnd()->GetSafeHwnd(), strError, NULL,
			MB_OK | MB_ICONEXCLAMATION);

		// since we need to revert back, set this flag so that whoever has
		// called this method can call UpdateChangedProperties later (if this
		// flag is set).
		m_bUpdateLater = TRUE;
		ForcePropertyBrowserToshow();
	}

	return hr;
}

void COleAllPage::ForcePropertyBrowserToshow()
{
	// The property browser gets an OnActivate((nState == WA_INACTIVE))
	// when an error messagebox is displayed, which causes the Property
	// Browser to go away when the OK on the MessageBox is pressed
	// Since, we do not need this behavior (as the user might want to correct
	// the situation by typing/selecting the correct value
	// Hence, the following flag (which governs the visibility of the property
	// browser is set to true here.  The ShowEditControl() brings the focus back to
	// the property browser (especially the edit control).
	g_PropSheetVisible = TRUE;
	m_lbProps.ShowEditControl();
}

// This method gets the picture type and displays "(None)", "(Icon)" or one
// of the other picture types based on the picture type.
BOOL COleAllPage::GetPictureType(
	IDispatch*	pPictDisp,
	CString&	strProp)
{
	COleRef<IPicture>	srpPicture;
	SHORT				sType;
	
	ASSERT(pPictDisp);
	if (SUCCEEDED(pPictDisp->QueryInterface(IID_IPicture, (void**)&srpPicture))
		&& SUCCEEDED(srpPicture->get_Type(&sType)))
	{
		// Set appropriate string for the picture type
		switch(sType)
		{
			default:
			case PICTYPE_NONE:
			case PICTYPE_UNINITIALIZED:
				strProp.LoadString(IDS_PICTURETYPENONE);
				break;
				
			case PICTYPE_BITMAP:
				strProp.LoadString(IDS_PICTURETYPEBITMAP);
				break;
				
			case PICTYPE_METAFILE:
				strProp.LoadString(IDS_PICTURETYPEMETAFILE);
				break;
				
			case PICTYPE_ICON:
				strProp.LoadString(IDS_PICTURETYPEICON);
				break;
				
			case PICTYPE_ENHMETAFILE:
				strProp.LoadString(IDS_PICTURETYPEENHMETAFILE);
				break;
		}

		return TRUE;
	}

	return FALSE;
}

// Just a silly method to determine if the builder is an intrinsic builder
BOOL COleAllPage::IsIntrinsicBuilder(
	GUID	guidBuilder)
{
	COleRef<IBuilderWizardManager>	srpBWM;

	return ((S_OK == theApp.GetService(SID_SBuilderWizardManager, 
		IID_IBuilderWizardManager, (void**)&srpBWM)) &&
		(S_OK == srpBWM->DoesBuilderExist(guidBuilder)));
}

// The algorighm for determining the builder type to edit the property for
// the given dispid is given below.
void COleAllPage::DetermineBuilderType(
	DISPID		dispid,
	CPropItem*	pItem)
{
	// ALL THIS IS DONE SO THAT WHEN WE NEED TO INVOKE A BUILDER, WE KNOW
	// WHAT TYPE IT IS.
	// Assume that we do not have a builder for this.
	// Get the IProvidePropertyBuilder interface from the dispatch interface
	// Call MapPropertyToBuilder to get the builder guid.
	// If we have a multiple selection and the above call returns a value
	//  specifying that it edits objects directly, then bail out.
	// Else if we have either a multiple selection or a single selection, but
	//  there is an internal builder which can be used, so set the control type
	//  value to that type and return.
	// Else if a standard builder is supported, just make sure that that builder
	//  exists by querying the BuilderWizardManager and then set its value to
	//  that control type.
	// If all the above fails, try to find out if a PerPropertyBrowsing interface
	//  exists and if so, set the control type to that value
	// If not supported by a standard builder or by PerPropertyBrowsing, and is of type
	//	Color, Font, or Picture, then set control type to Internal Builder which will use
	//  an internal builder for these properties

	HRESULT	hr;
	BOOL	bCtlTypeSet = FALSE;
	GUID	guidBuilder = GUID_NULL;

	pItem->m_ctrlType = ctrl_Unknown;	// initialize return value

	// look for an intrinsic builder first
	if (pItem->m_dataType == data_Color ||
		pItem->m_dataType == data_Font ||
		pItem->m_dataType == data_Picture ||
		pItem->m_dataType == data_Path)
	{
		switch(pItem->m_dataType)
		{
			case data_Color:
				guidBuilder = CATID_ColorBuilder;
				break;
			case data_Font:
				guidBuilder = CATID_FontBuilder;
				break;
			case data_Picture:
				guidBuilder = CATID_PictureBuilder;
				break;
			case data_Path:
				guidBuilder = CATID_URLBuilder;
				break;
		}
		if (IsIntrinsicBuilder(guidBuilder))
		{
			pItem->m_ctrlType = ctrl_BuilderWizardManagerIntrinsic;
			return;
		}
		else if (pItem->m_dataType != data_Path)
		{
			// No support for dataPath properties
			// No builder support so use internal Builder.
			// m_ctrlType will be reset if property can be mapped to a page
			// Internal Builder support should only be used if there are no
			// alternatives
			pItem->m_ctrlType = ctrl_BuilderInternal;
		}
	}

	int			iNumCtlsSupporingInternalBuilder = 0;
	int			iNumCtlsSupporingStandardBuilder = 0;
	int			iIndexInternalBuilder = -1;
	int			iIndexStandardBuilder = -1;
	ControlType	ctrlType;				// type of control required on grid

	ctrlType = ctrl_Unknown;	// this is a different control type

	for (ULONG i = 0; i < m_ulCountControls; i++)
	{
		ASSERT(m_pprgDisp[i]);
		ctrlType = GetControlBuilderType(dispid, m_pprgDisp[i]);
		if (ctrlType == ctrl_BuilderProvidePropertyBuilder)
		{
			// increment the number of controls supporting internal builders
			iNumCtlsSupporingInternalBuilder++;
			// if we don't already have an index (in m_pprgDisp), store it
			if (-1 == iIndexInternalBuilder)
				iIndexInternalBuilder = i;
		}
		else if (ctrlType == ctrl_BuilderWizardManager)
		{
			// increment the number of controls supporting internal builders
			iNumCtlsSupporingStandardBuilder++;
			// if we don't already have an index (in m_pprgDisp), store it
			if (-1 == iIndexStandardBuilder)
				iIndexStandardBuilder = i;
		}
	}

	// if at least one control supports either of the builders proceed
	// else find out if IPerPropertyBrowsing is supported
	if ((iNumCtlsSupporingInternalBuilder > 0) ||
		(iNumCtlsSupporingStandardBuilder > 0))
	{
		if (iNumCtlsSupporingStandardBuilder > 0)
		{
			pItem->m_iIndex = iIndexStandardBuilder;// store this for later use
			pItem->m_ctrlType = ctrl_BuilderWizardManager;
		}
		else
		{
			pItem->m_iIndex = iIndexInternalBuilder;// store this for later use
			pItem->m_ctrlType = ctrl_BuilderProvidePropertyBuilder;
		}

		bCtlTypeSet = TRUE;
	}

	if (!bCtlTypeSet)
	{
		BOOL	bContinue;
		CLSID	clsidFirst;	// clsid of the first control
		CLSID	clsidCurrent;	// clsid of the current control in loop
		COlePage*	pPage;

		// try to find if there is a property page with the properties dialog
		// that supports editing of this property
		// make sure that all the controls maps to the same property page
		// by comparing their CLSIDs

		// first get the clsid of the first control
		ASSERT(m_pprgDisp[0]);
		COleRef<IPerPropertyBrowsing>	srpPPB;

		// if we can't get the IPerPropertyBrowsing interface or if a property
		// page is not found, set continue flag to false
		bContinue = (GetPerPropertyBrowsing(m_pprgDisp[0], &srpPPB) &&
			(S_OK == MapPropertyToPage(srpPPB, dispid, &clsidFirst)));

		if (bContinue)
		{
			// make sure that the page exists
			pPage = (COlePage*)COlePage::GetPropPage(clsidFirst);
			bContinue = (pPage != NULL);
		}

		if (bContinue && (m_ulCountControls > 1))
		{
			for (ULONG i = 1; bContinue && (i < m_ulCountControls); ++i)
			{
				ASSERT(m_pprgDisp[i]);
				COleRef<IPerPropertyBrowsing>	srpPPBInLoop;

				if (GetPerPropertyBrowsing(m_pprgDisp[i], &srpPPBInLoop))
				{
					hr = MapPropertyToPage(srpPPBInLoop, dispid, &clsidCurrent);
					bContinue = (hr == S_OK) &&
						IsEqualCLSID(clsidCurrent, clsidFirst);
					// since we have verified that a prop-page exists for the
					// clsidFirst, and since clsidCurrent is the same as
					// clsidFirst, no need to check here again
				}
				else
				{
					bContinue = FALSE;
				}
			}
		}

		if (bContinue)
			pItem->m_ctrlType = ctrl_BuilderPerPropertyBrowsing;
	}
}

// Gets the builder type for the given control and dispid
// Basically, this method finds out if the control has a builder
// for ediiting this property and if so does it prefers to do it directly.
// Or does this contorl support editing the property via the 
// BuilderWizardManager interface
ControlType COleAllPage::GetControlBuilderType(
	DISPID		dispid,
	IDispatch*	pControlDisp)
{
	ASSERT(pControlDisp);

	HRESULT			hr;
	long			lCtlBldType = 0;
	BSTR			bstrGuidBuilder;
	VARIANT_BOOL	bRetVal;
	ControlType		ctrlType = ctrl_Unknown;

	COleRef<IProvidePropertyBuilder>	srpPPropBldr;

	hr = pControlDisp->QueryInterface(IID_IProvidePropertyBuilder,
		(void**)&srpPPropBldr);
	if (S_OK == hr)
	{
		lCtlBldType = 0;
		bstrGuidBuilder = ::SysAllocString(L"");
		bRetVal = FALSE;
		hr = srpPPropBldr->MapPropertyToBuilder(dispid, &lCtlBldType, &bstrGuidBuilder,
			&bRetVal);
		if (S_OK == hr && bRetVal)
		{
			// if this builder edits objects directly, and if we
			// have a multiple selection, we do not need this builder
			if (!((m_ulCountControls > 1) && (lCtlBldType & CTLBLDTYPE_FEDITSOBJDIRECTLY)))
			{
				if (lCtlBldType & CTLBLDTYPE_FINTERNALBUILDER)
				{
					ctrlType = ctrl_BuilderProvidePropertyBuilder;
				}
				else if (lCtlBldType & CTLBLDTYPE_FSTDPROPBUILDER)
				{
					COleRef<IBuilderWizardManager>	srpBWM;
					
					GUID	guidBuilder = GUID_NULL;

					hr = theApp.GetService(SID_SBuilderWizardManager, 
						IID_IBuilderWizardManager, (void**)&srpBWM);
					if (S_OK == hr &&
						SUCCEEDED(::CLSIDFromString(bstrGuidBuilder, &guidBuilder)))
					{
						hr = srpBWM->DoesBuilderExist(guidBuilder);
						if (S_OK == hr)
							ctrlType = ctrl_BuilderWizardManager;
					}
				}
				else
				{
					ASSERT(FALSE); // should never happen usually!
				}
			}
		}

		::SysFreeString(bstrGuidBuilder);
	}

	return ctrlType;
}

// This method sets up the dispparams and calls the builder
BOOL COleAllPage::CallGeneralPropertyBuilder(
	IDispatch*	pAppDisp,		// application dispatch ptr
	IDispatch*	pBuilderDisp,	// url builder dispatch ptr
	HWND		hwndOwner,		// hwnd of the owner
	DISPID		diExecute,		// dispatch method id
	VARIANT*	pvarValue)		// in/out value
{
	ASSERT(pAppDisp && pBuilderDisp && pvarValue);

#define	NUM_PARAMS_LOCAL_COLOR	4

	BOOL			bMethodReturn = FALSE;
	HRESULT			hr;

	// set up the dispparms.  They are:
	// 1. app object's IDispatch,
	// 2. hwndPromptOwner,
	// 3. IServiceProvider
	// 4. current color value (variant dword)
	// 5. return value (variant bool)

	UINT		cArgs = NUM_PARAMS_LOCAL_COLOR;
	DISPPARAMS	dp;

	dp.rgvarg = new VARIANTARG[cArgs];
	dp.cArgs = cArgs;
	dp.rgdispidNamedArgs = NULL;
	dp.cNamedArgs = 0;

	// since the machine pushes items on stack, store them in reverse order

	// param 1 (app object's IDispatch)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_DISPATCH;
	dp.rgvarg[cArgs].pdispVal = pAppDisp;

	// param 2 (hwndPromptOwner)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_I4;
	dp.rgvarg[cArgs].lVal = (long)hwndOwner;

	// param 3 (IServiceProvider interface)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	IServiceProvider *pSP;
	theApp.m_pAutoApp->ExternalQueryInterface(
			&IID_IServiceProvider, (void**)&pSP);
	dp.rgvarg[cArgs].vt = VT_UNKNOWN;
	dp.rgvarg[cArgs].punkVal = (IUnknown*)(IServiceProvider*)pSP;

	// param 4 (current/new property value) 
	// this is an in/out param, therefore tag VT_BYREF
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_BYREF | VT_VARIANT;
	dp.rgvarg[cArgs].pvarVal = pvarValue;

	VARIANT	varReturn;

	::VariantInit(&varReturn);

	hr = pBuilderDisp->Invoke(diExecute, IID_NULL, s_lcid,
		DISPATCH_METHOD, &dp, &varReturn, NULL, NULL);
	ASSERT(SUCCEEDED(hr));
	if (SUCCEEDED(hr)) 
	{
		// Set return value
		ASSERT(VT_BOOL == V_VT(&varReturn));
		bMethodReturn = V_BOOL(&varReturn);
		::VariantClear(&varReturn);
	}

	// dp.rgvarg array is indexed from 0
	// do not clear the pAppDisp -- the caller needs it!
	::VariantClear(&(dp.rgvarg[1]));	// hwndOwner
	::VariantClear(&(dp.rgvarg[2]));	// IServiceProvider
	// do not clear the pvarValue -- the caller needs it!

	delete [] dp.rgvarg;

	return bMethodReturn;
}

// This method sets up the dispparams and calls the URL Builder
BOOL COleAllPage::CallURLBuilder(
	IDispatch*	pAppDisp,		// application dispatch ptr
	IDispatch*	pControlDisp,	// (first selected) control dispatch ptr
	IDispatch*	pBuilderDisp,	// url builder dispatch ptr
	HWND		hwndOwner,		// hwnd of the owner
	DISPID		diExecute,		// dispatch method id
	VARIANT*	pvarValue)		// in/out value
{
	ASSERT(pAppDisp && pControlDisp && pBuilderDisp && pvarValue);

#define	NUM_PARAMS_LOCAL_URL	10

	BOOL			bMethodReturn = FALSE;
	VARIANT_BOOL	bRet = FALSE;
	HRESULT			hr;

	// set up the dispparms.  They are:
	// 1. app object's IDispatch,
	// 2. hwndPromptOwner,
	// 3. service provider's IUnknown,
	// 4. current url value (variant (bstr))
	// 5. base url (bstr)
	// 6. additional filters (bstr)
	// 7. custom title (bstr)
	// 8. target frame value (variant (bstr))
	// 9. flags
	// 10. return value (variant bool)
	
	USES_CONVERSION;

	UINT		cArgs = NUM_PARAMS_LOCAL_URL;
	DISPPARAMS	dp;
	long		lFlags = URLP_EDITURLTITLE | URLP_ROOTRELATIVEURLTYPE;

	CString		strBaseURL;
	BSTR		bstrBaseURL;

	// get the base url if possible
	COleRef<IOleObject>		srpOleObject;

	// IT IS OKAY IF WE DO NOT GET THE BASE URL, JUST CONTINUE
	// get the client site from the IDispatch of the control
	hr = pControlDisp->QueryInterface(IID_IOleObject, (void**)&srpOleObject);
	if (S_OK == hr)
	{
		COleRef<IOleClientSite>	srpOleClientSite;

		hr = srpOleObject->GetClientSite(&srpOleClientSite);
		if (S_OK == hr)
		{
			COleRef<IMoniker>	srpMoniker;

			// get the moniker from the client site
			hr = srpOleClientSite->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
				OLEWHICHMK_CONTAINER, &srpMoniker);
			if (S_OK == hr)
			{
				COleRef<IBindCtx>	srpbc;

				hr = ::CreateBindCtx(0, &srpbc);
				if (S_OK == hr)
				{
					LPOLESTR	pszName;

					// get the base url from the moniker
					hr = srpMoniker->GetDisplayName(srpbc, 0, &pszName);
					if (S_OK == hr)
					{
						// copy the base url into a temp string
						strBaseURL = OLE2T(pszName);
						// free the memory
						::CoTaskMemFree((void*)pszName);
					}
				}
			}
		}
	}

	dp.rgvarg = new VARIANTARG[cArgs];
	dp.cArgs = cArgs;
	dp.rgdispidNamedArgs = NULL;
	dp.cNamedArgs = 0;

	// since the machine pushes items on stack, store them in reverse order

	// param 1 (app object's IDispatch)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_DISPATCH;
	dp.rgvarg[cArgs].pdispVal = pAppDisp;

	// param 2 (hwndPromptOwner)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_I4;
	dp.rgvarg[cArgs].lVal = (long)hwndOwner;

	// param 3 (service provider) 
	::VariantInit(&(dp.rgvarg[--cArgs]));	
	dp.rgvarg[cArgs].vt = VT_UNKNOWN;	// TODO$
	dp.rgvarg[cArgs].punkVal = NULL;	// for the time being pass NULL

	// param 4 (current/new url value) 
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_BYREF | VT_VARIANT;// in/out param, add tag VT_BYREF
	dp.rgvarg[cArgs].pvarVal = pvarValue;

	// param 5 (base url)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_BSTR;
	if (strBaseURL.IsEmpty())
	{
		dp.rgvarg[cArgs].bstrVal = NULL;
	}
	else
	{
		bstrBaseURL = strBaseURL.AllocSysString();
		dp.rgvarg[cArgs].bstrVal = bstrBaseURL;
	}

	// param 6 (additional filters)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_BSTR;
	dp.rgvarg[cArgs].bstrVal = NULL;

	// param 7 (custom title)
	// no custom title since we are editing the url
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_BSTR;
	dp.rgvarg[cArgs].bstrVal = NULL;

	// param 8 (target frame value) 
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_BYREF | VT_VARIANT;// in/out param, add tag VT_BYREF
	dp.rgvarg[cArgs].pvarVal = NULL;

	// param 9 (flags)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_BYREF | VT_I4;	// in/out param, add tag VT_BYREF
	dp.rgvarg[cArgs].plVal = &lFlags;

	// param 10 (return value)
	::VariantInit(&(dp.rgvarg[--cArgs]));
	dp.rgvarg[cArgs].vt = VT_BYREF | VT_BOOL;// in/out param, add tag VT_BYREF
	dp.rgvarg[cArgs].pboolVal = &bRet;

	VARIANT	varReturn;

	::VariantInit(&varReturn);

	hr = pBuilderDisp->Invoke(diExecute, IID_NULL, s_lcid,
		DISPATCH_METHOD, &dp, &varReturn, NULL, NULL);
	ASSERT(SUCCEEDED(hr));
	if (SUCCEEDED(hr)) {
		// check the return value
		ASSERT(VT_I4 == V_VT(&varReturn));
		if (V_I4(&varReturn) == S_OK) {
			if (bRet)
				bMethodReturn = TRUE;
		}

		::VariantClear(&varReturn);
	}

	// dp.rgvarg array is indexed from 0
	// do not clear the pAppDisp -- the caller needs it!
	::VariantClear(&(dp.rgvarg[1]));	// hwndOwner
	// do not clear the IServiceProvider -- it is NULL for the time being
	// do not clear the pvarValue -- the caller needs it!
	::VariantClear(&(dp.rgvarg[4]));	// bstrBaseURL
	::VariantClear(&(dp.rgvarg[5]));	// additional filters
	::VariantClear(&(dp.rgvarg[6]));	// custom title
	::VariantClear(&(dp.rgvarg[7]));	// target frame value
	::VariantClear(&(dp.rgvarg[8]));	// flags
	::VariantClear(&(dp.rgvarg[9]));	// return value

	delete [] dp.rgvarg;

	return bMethodReturn;
}

// This method saves the modified property for all the selected controls
// It is only called when any of the Builders are executed to modify the property
// REVIEW:  Try to merge this and the Apply() method
HRESULT COleAllPage::SavePropertyForAllControls(
	VARIANT*	pvarValue,
	CPropItem*	pItem)
{
	HRESULT	hr = S_OK;
	WORD	wFlags;
	DISPID	dispid;
	CString	strError;

	COleDispatchDriver	dispDriver;

	m_bUpdateLater = FALSE;

	// tell IPropertyNotifySink::OnChanged that we are updating properties
	// so that all refreshing happen later
	m_bUpdatingProps = TRUE;

	m_pSlob->BeginUndo(IDS_UNDO_OLE_PROPS);

	if (pvarValue->vt & VT_BYREF)
	{
		pvarValue->vt &= ~VT_BYREF;
		pvarValue->vt |= VT_MFCBYREF;
	}
	
	wFlags = (WORD)((pvarValue->vt == VT_DISPATCH) ?
		DISPATCH_PROPERTYPUTREF : DISPATCH_PROPERTYPUT);

	try
	{
		USES_CONVERSION;

		// update the property of each control
		for (ULONG i= 0; i < m_ulCountControls; i++)
		{
			ASSERT(m_pprgDisp[i]);
			dispDriver.AttachDispatch(m_pprgDisp[i], FALSE);
			dispid = pItem->m_pDispid[i];

			switch(pItem->m_dataType)
			{
				case data_Path:
					ASSERT(pvarValue->vt == VT_BSTR);
					pItem->m_strProp = OLE2T(pvarValue->bstrVal);
					// ApplyProperty will clear the ErrorInfo
					ApplyProperty(dispid, pItem, m_pprgDisp[i]);
					break;
				case data_Color:
					// Clear ErrorInfo object before we call SetProperty
					::SetErrorInfo(0L, NULL);

					ASSERT(pvarValue->vt == VT_I4);
					dispDriver.SetProperty(dispid, pvarValue->vt, pvarValue->lVal);
					GetPropValueForOtherTypes(pvarValue, pItem);
					break;
				case data_Picture:
				{
					// Clear ErrorInfo object before we call SetProperty
					::SetErrorInfo(0L, NULL);

					ASSERT(pvarValue->vt == VT_DISPATCH);
					dispDriver.SetProperty(dispid, pvarValue->vt, V_DISPATCH(pvarValue));

					// get the new value and get the picture type
					VARIANT	varNewValue;
					if (GetPropValue(dispDriver.m_lpDispatch, dispid, &varNewValue))
					{
						GetPropValueForOtherTypes(&varNewValue, pItem);
						::VariantClear(&varNewValue);
					}
				}
					break;
				case data_Font:
					break;
				default:
					// ApplyProperty will clear the ErrorInfo
					ApplyProperty(dispid, pItem, m_pprgDisp[i]);
					break;
			}
		}	
	}
	catch(COleDispatchException* e)
	{
		hr = e->m_scError;
		strError = e->m_strDescription;
	}
	catch(...)
	{
		hr = E_FAIL;
	}

	if (S_OK != hr)
	{
		if (strError.IsEmpty())
			strError.LoadString(IDS_PROP_ERROR_INVPROP);

		// do not use AfxMessageBox, since specifying the default window
		// as the owner causes a mouse up to be lost (sridharc)
		::MessageBox(AfxGetMainWnd()->GetSafeHwnd(), strError, NULL, MB_OK);
		ForcePropertyBrowserToshow();
	}

	// EndUndo takes a flag which is TRUE to abort the Undo Record, & FALSE 
	// to keep the undo record
	m_pSlob->EndUndo(!(S_OK == hr));

	m_bUpdatingProps = FALSE;

	// Some property was changed, so we need to update.
	UpdateChangedProperties();

	return hr;
}


//
//	Description:
// 	displays CColorDialog setting initial color to property's current value
//		returns selected color
//		converts from OLE_COLOR to COLORREF and back
//
//	Arguments:
//		OLE_COLOR olecolor - INOUT - in == current color
//									out == selected color
//
//	Return (BOOL): TRUE if color selected, FALSE otherwise
//
static BOOL InternalColorBuilder(OLE_COLOR& olecolor)
{
	COLORREF	clrref;

	// Translate OLE_COLOR to COLORREF
	if (SUCCEEDED(OleTranslateColor(olecolor, NULL, &clrref)))
	{
		// Display Color Dialog
		CColorDialog	colorDlg(clrref, 0, ::AfxGetMainWnd());
		if (colorDlg.DoModal() == IDOK)
		{
			// No translation needed from COLORREF to OLE_COLOR, because
			// COLORREF is a subset of OLE_COLOR.  And the Common Color
			// Dialog does not allow you to choose System Colors.
			// So we will lose system color info since we dont
			// have a way to select them.
			olecolor = colorDlg.GetColor();
			return TRUE;
		}
	}

	return FALSE;
}


//
//	Description:
//		Display CFontDialog setting initial font to property's current value
//		returns selected font.  Modifies IFontDisp properties to contain new
//		font info.
//
//	Arguments:
//		IFontDispatch IN - IDispatch for IFont
//
//	Return (BOOL): TRUE if font selected, FALSE otherwise
//
static BOOL InternalFontBuilder(
	IDispatch*	pIFontDisp)
{
	COleRef<IFont> srpFont;
	HRESULT hr = pIFontDisp->QueryInterface(IID_IFont, (void**)&srpFont);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
		return FALSE;

	HFONT hFont;  // owned by IFont so dont Delete	
	srpFont->get_hFont(&hFont);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
		return FALSE;
	
	// Create CFont from hFont
	// dont delete pFont.  It will be cleaned up during Idel Message processing
	CFont* pFont = CFont::FromHandle(hFont);
	ASSERT(pFont);
	if (pFont == NULL)
		return FALSE;

	// Get LOGFONT from CFont	
	LOGFONT logfont;
	if (!pFont->GetLogFont(&logfont))
	{
		ASSERT(!_T("CFont::CreateIndirect FAILED"));
		return FALSE;
	}
	
	// Display Font Dialog	
	C3dFontDialog FontDlg(&logfont, CF_SCREENFONTS | CF_ENABLETEMPLATE | CF_EFFECTS |
						CF_NOVECTORFONTS | CF_NOOEMFONTS, NULL, ::AfxGetMainWnd());

	FontDlg.m_cf.hInstance = ::AfxGetInstanceHandle();
	FontDlg.m_cf.lpTemplateName = MAKEINTRESOURCE(IDD_DIALOGFONT);
	
	if (FontDlg.DoModal() != IDOK)
		return FALSE;

	// Get Selected Font
	FontDlg.GetCurrentFont(&logfont);
	
	// Set Selected Font
	CString	strFontName = logfont.lfFaceName;
	BSTR	bstrFontName = strFontName.AllocSysString();

	VERIFY(SUCCEEDED(srpFont->put_Name(bstrFontName)));
	VERIFY(SUCCEEDED(srpFont->put_Weight((short)logfont.lfWeight)));
	VERIFY(SUCCEEDED(srpFont->put_Charset(logfont.lfCharSet)));
	VERIFY(SUCCEEDED(srpFont->put_Italic(logfont.lfItalic)));
	VERIFY(SUCCEEDED(srpFont->put_Underline(logfont.lfUnderline)));
	VERIFY(SUCCEEDED(srpFont->put_Strikethrough(logfont.lfStrikeOut)));

	// Get DC so I can get DeviceCaps
	CDC* pDC = ::AfxGetMainWnd()->GetDC();
	ASSERT(pDC);
	if (pDC == NULL)
		return FALSE;
	
	// Get ppi
	int ppi = pDC->GetDeviceCaps(LOGPIXELSY);
	::AfxGetMainWnd()->ReleaseDC(pDC);
	
	// calculate Font Size
	CY cySize;
	cySize.Lo = abs(logfont.lfHeight) * 720000 / ppi;
	cySize.Hi = 0;
	
	// Set new Font Size
	VERIFY(SUCCEEDED(srpFont->put_Size(cySize)));

	return TRUE;
}

//
//	Description:
//		Creates IPictureDisp from chosen file.  Uses OleLoadPicture to create the
//		IPictureDisp.  OleLoadPicture requires an IStream on the file.  Uses
//		CreateStreamOnHGlobal and copies file contents into stream.
//		Gets type from IPicture and sets appropriate Filter in File Open dialog
//
//	Arguments:
//		IPictureDisp** ppIPictureDisp: INOUT - in == IPictureDisp of current Picture
//												out == IPictureDisp of new picture
//
//	Return (BOOL): TRUE on SUCCESS, FALSE otherwise
//
static BOOL InternalPictureBuilder(
	IPictureDisp**	ppIPictureDisp)
{
	ASSERT(ppIPictureDisp);

	HRESULT hr;
	SHORT	sType = PICTYPE_NONE;
	if(NULL != *ppIPictureDisp)
	{
		// Get IPicture
		COleRef<IPicture> srpPicture;
		hr = (*ppIPictureDisp)->QueryInterface(IID_IPicture, (void**)&srpPicture);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return FALSE;

		// GetType
		hr = srpPicture->get_Type(&sType);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return FALSE;
	}
	
	// Set appropriate Filter & Dialog Title
	CString strFilter;
	CString strDialogTitle;
#if 0
	// to fix IS Bug # 7099
	switch(sType)
	{
		default:
		case PICTYPE_NONE:
		case PICTYPE_UNINITIALIZED:
			strFilter.LoadString(IDS_PICTUREFILTER);
			strDialogTitle.LoadString(IDS_PICTURETITLE);
			break;
			
		case PICTYPE_BITMAP:
			strFilter.LoadString(IDS_BITMAPFILTER);
			strDialogTitle.LoadString(IDS_BITMAPTITLE);
			break;
			
		case PICTYPE_METAFILE:
			strFilter.LoadString(IDS_METAFILEFILTER);
			strDialogTitle.LoadString(IDS_METAFILETITLE);
			break;
			
		case PICTYPE_ICON:
			strFilter.LoadString(IDS_ICONFILTER);
			strDialogTitle.LoadString(IDS_ICONTITLE);
			break;
			
		case PICTYPE_ENHMETAFILE:
			strFilter.LoadString(IDS_ENHMETAFILEFILTER);
			strDialogTitle.LoadString(IDS_ENHMETAFILETITLE);
			break;
	}	
#else	// 0
	strFilter.LoadString(IDS_PICTUREFILTER);
	strDialogTitle.LoadString(IDS_PICTURETITLE);
#endif	// 0
	
	// Choose file containing new picture
	CFileDialog fileDlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST, 
						strFilter, ::AfxGetMainWnd());
	fileDlg.m_ofn.lpstrTitle = strDialogTitle; // set title
	if (fileDlg.DoModal() != IDOK)
		return FALSE;
	
	// Need to copy file contents into a Stream
	// Create Stream
	COleRef<IStream> srpStream;
	hr = ::CreateStreamOnHGlobal(NULL, TRUE, &srpStream);
	ASSERT(SUCCEEDED(hr));
	if (FAILED(hr))
		return FALSE;
		
	// Seek to start of stream
	LARGE_INTEGER li;
	LISet32(li, 0);
	srpStream->Seek(li, STREAM_SEEK_SET, NULL);
	// Copy file contents to stream
	try
	{
		BYTE	rgBuf[512];
		UINT	cbRead;
		ULONG	cbWritten;
		CFile 	file(fileDlg.GetPathName(), CFile::modeRead);
		
		// Copy bytes from File to Stream
		while(cbRead = file.Read(rgBuf, 512))
		{
			hr = srpStream->Write(rgBuf, cbRead, &cbWritten);
			ASSERT(SUCCEEDED(hr));
			ASSERT(cbRead == cbWritten);
			if (FAILED(hr) || cbRead != cbWritten)
				return FALSE;
		}
	}
	catch(...) 
	{
		return FALSE;
	}

	// Seek to start of stream before calling OleLoadPicture
	hr = srpStream->Seek(li, STREAM_SEEK_SET, NULL);
	ASSERT(SUCCEEDED(hr));

	IPictureDisp*	pIPictDispTemp;

	// Create IPictureDisp from IStream
	//hr = OleLoadPicture(srpStream, 0, TRUE, IID_IPictureDisp, (void**)ppIPictureDisp);
	hr = OleLoadPicture(srpStream, 0, TRUE, IID_IPictureDisp,
		(void**)&pIPictDispTemp);
	if (SUCCEEDED(hr))
	{
		// Releae the old IPictureDisp and update with the new one
		if(NULL != *ppIPictureDisp)
			(*ppIPictureDisp)->Release();

		// copy the new IPictureDisp in its place
		*ppIPictureDisp = pIPictDispTemp;
	}
	
	return SUCCEEDED(hr);
}

// Executes the PerPropertyBrowsing builder that basically "flips" the user
// to a different property page in the Property Browser so that the user
// can edit the property in that page.
HRESULT COleAllPage::ExecutePPBBuilder(
	IDispatch*	pDisp,
	DISPID		dispid)
{
	CLSID	clsid;

	COleRef<IPerPropertyBrowsing>	srpPPB;

	ASSERT(pDisp);
	if (pDisp && GetPerPropertyBrowsing(pDisp, &srpPPB) &&
		SUCCEEDED(MapPropertyToPage(srpPPB, dispid, &clsid)))
	{
		COlePage* pPage = (COlePage*)COlePage::GetPropPage(clsid);
		if (pPage)
		{
			CString strPage;
			CString	strGeneral;

			pPage->GetPageName(strPage);
			// HACK: Keep OLE controls from using "General" as Tab text.
			//		 Use "Control" instead.
			strGeneral.LoadString(IDS_PROP_GENERAL);
			if (strGeneral.CompareNoCase(strPage) == 0)
				strPage.LoadString(IDS_PROP_CONTROL);

			if (m_pSheetWnd->FlipToPage(strPage))
			{
				pPage->EditProperty(dispid);
			}
			else
			{
				CString	strFmt;
				CString	strError;

				strFmt.LoadString(IDS_E_CANNOTGOTOPAGE);
				strError.Format(strFmt, strPage);
				::MessageBox(AfxGetMainWnd()->GetSafeHwnd(), strError, NULL,
					MB_OK | MB_ICONEXCLAMATION);
			}

			return S_OK;
		}
	}

	return E_FAIL;
}

// Executes the internal builders for color, font and picture
// properties (if not builder is supported)
HRESULT COleAllPage::ExecuteInternalBuilder(
	CPropItem*	pItem,
	VARIANT*	pVarValue)
{
	HRESULT	hr = E_NOINTERFACE;
	BOOL	bSaveProps = FALSE;

	switch(pItem->m_dataType)
	{
		case data_Color:
		{
			// check the return value
			if (V_VT(pVarValue) == VT_UI4)	// some controls use UI4 and
				V_VT(pVarValue) = VT_I4;	// COleDispDriver::SetProperty fails on that

			ASSERT(VT_I4 == V_VT(pVarValue));
			OLE_COLOR olecolor = V_I4(pVarValue);
			// varValue passed by reference
			if (InternalColorBuilder(olecolor))
			{
				V_I4(pVarValue) = olecolor;
				bSaveProps = TRUE;
			}
			break;
		}
		
		case data_Font:
			// check the return value
			ASSERT(VT_DISPATCH == V_VT(pVarValue));
			bSaveProps = InternalFontBuilder(V_DISPATCH(pVarValue));
			break;

		case data_Picture:
		{
			ASSERT(VT_DISPATCH == V_VT(pVarValue));
			IPictureDisp* pPictDisp = (IPictureDisp*)V_DISPATCH(pVarValue);
			if (InternalPictureBuilder(&pPictDisp))	// get new IPictureDisp
			{
				V_DISPATCH(pVarValue) = pPictDisp;	// set new IPictureDisp
				bSaveProps = TRUE;
			}
			break;
		}
		
		default:
			ASSERT(FALSE);	// should never happen!
			break;
	}
	
	if (bSaveProps)
		hr = SavePropertyForAllControls(pVarValue, pItem);

	return hr;
}

// Executes the intrinsic (color, font, picture or path) builders
HRESULT COleAllPage::ExecuteBWMIntrinsicBuilder(
	CPropItem*	pItem,
	VARIANT*	pVarValue)
{
	HRESULT		hr = E_NOINTERFACE;
	GUID		guidBuilder = GUID_NULL;
	DISPID		dispidExecute;
	LPOLESTR	szExecute = (L"Execute");

	switch(pItem->m_dataType)
	{
		case data_Color:
			guidBuilder = CATID_ColorBuilder;
			break;
		case data_Font:
			guidBuilder = CATID_FontBuilder;
			break;
		case data_Picture:
			guidBuilder = CATID_PictureBuilder;
			break;
		case data_Path:
			guidBuilder = CATID_URLBuilder;
			break;
		default:
			ASSERT(FALSE);	// should never happen!
			return hr;
			break;
	}

	COleRef<IDispatch>				srpAppDisp;
	COleRef<IBuilderWizardManager>	srpBWM;
	COleRef<IDispatch>				srpBuilderDisp;

	if (SUCCEEDED(theApp.GetService(SID_SBuilderWizardManager, 
		IID_IBuilderWizardManager, (void**)&srpBWM)) &&

		S_OK == srpBWM->GetBuilder(guidBuilder,
			BLDGETOPT_FAUTOMAPGUID,
			GetSafeHwnd(), &srpAppDisp, NULL, 
			IID_IDispatch, (IUnknown**)&srpBuilderDisp) &&

		SUCCEEDED(srpBuilderDisp->GetIDsOfNames(IID_NULL,
			&szExecute, 1, s_lcid, &dispidExecute)))
	{
		CWnd*	pMainWnd = AfxGetMainWnd();
		ASSERT(pMainWnd);
		HWND	hwndOwner = pMainWnd->GetSafeHwnd();

		// disable the main window
		srpBWM->EnableModeless(FALSE);
		switch(pItem->m_dataType)
		{
			case data_Color:
			case data_Font:
			case data_Picture:
				if (CallGeneralPropertyBuilder(srpAppDisp,
					srpBuilderDisp, hwndOwner, dispidExecute, pVarValue))
					hr = S_OK;
				break;
			case data_Path:
				if (CallURLBuilder(srpAppDisp, m_pprgDisp[0],
					srpBuilderDisp, hwndOwner, dispidExecute, pVarValue))
					hr = S_OK;
				break;
			default:
				ASSERT(FALSE);	// should never happen!
				break;
		}
		// enable the main window
		srpBWM->EnableModeless(TRUE);
	}

	if (S_OK == hr)
		hr = SavePropertyForAllControls(pVarValue, pItem);

	return hr;
}

// Executes the BuilderWizardManager and ProvidePropertyBuilder builders
HRESULT COleAllPage::ExecuteBWMAndPPBBuilder(
	CPropItem*	pItem,
	DISPID		dispid,
	VARIANT*	pVarValue)
{
	HRESULT				hr;
	long				lCtlBldType = 0;
	BSTR				bstrGuidBuilder;
	VARIANT_BOOL		bRetVal;
	COleDispatchDriver	dispDriver;

	COleRef<IProvidePropertyBuilder>	srpPPropBldr;

	dispDriver.m_lpDispatch = NULL;

	ASSERT((pItem->m_iIndex != -1) && (pItem->m_iIndex < m_ulCountControls) &&
		(NULL != m_pprgDisp[pItem->m_iIndex]));
	hr = m_pprgDisp[pItem->m_iIndex]->QueryInterface(
		IID_IProvidePropertyBuilder, (void**)&srpPPropBldr);
	if (S_OK == hr)
	{
		bstrGuidBuilder = ::SysAllocString(L"");
		bRetVal = FALSE;
		hr = srpPPropBldr->MapPropertyToBuilder(dispid, &lCtlBldType,
			&bstrGuidBuilder, &bRetVal);
		if (S_OK == hr && bRetVal)
			dispDriver.AttachDispatch(m_pprgDisp[pItem->m_iIndex], FALSE);
	}

	if (dispDriver.m_lpDispatch)
	{
		COleRef<IDispatch>	srpAppDisp;

		ASSERT(theApp.m_pAutoApp);
		hr = theApp.m_pAutoApp->ExternalQueryInterface(&IID_IDispatch,
			(void**)&srpAppDisp);
		ASSERT(SUCCEEDED(hr));
		if (S_OK == hr)
		{
			hr = E_NOINTERFACE;

			if (pItem->m_ctrlType == ctrl_BuilderProvidePropertyBuilder)
			{
				VARIANT_BOOL	bRetVal = FALSE;
				hr = srpPPropBldr->ExecuteBuilder(dispid, bstrGuidBuilder, srpAppDisp,
					(long)(HWND)GetSafeHwnd(), pVarValue, &bRetVal);
			}
			else if (pItem->m_ctrlType == ctrl_BuilderWizardManager)
			{
				COleRef<IDispatch>				srpAppDisp2;
				COleRef<IBuilderWizardManager>	srpBWM;
				COleRef<IDispatch>				srpBuilderDisp;
				
				GUID		guidBuilder = GUID_NULL;
				DISPID		dispidExecute;
				LPOLESTR	szExecute = (L"Execute");

				if (SUCCEEDED(theApp.GetService(SID_SBuilderWizardManager, 
					IID_IBuilderWizardManager, (void**)&srpBWM)) &&

					SUCCEEDED(::CLSIDFromString(bstrGuidBuilder, &guidBuilder)) &&
					
					S_OK == srpBWM->GetBuilder(guidBuilder,
						BLDGETOPT_FAUTOMAPGUID,
						GetSafeHwnd(), &srpAppDisp2, NULL, 
						IID_IDispatch, (IUnknown**)&srpBuilderDisp) &&

					SUCCEEDED(srpBuilderDisp->GetIDsOfNames(IID_NULL,
						&szExecute, 1, s_lcid, &dispidExecute)))
				{
					// setup the dispparms.  they are:
					// app object's IDispatch, hwndPromptOwner, 
					// current property value
					UINT		cArgs = 3;
					DISPPARAMS	dispparams;
					VARIANT		varReturn;

					dispparams.rgvarg = new VARIANTARG[cArgs];
					dispparams.cArgs = cArgs;

					dispparams.rgdispidNamedArgs = NULL;
					dispparams.cNamedArgs = 0;

					// param 1. app object
					::VariantInit(&(dispparams.rgvarg[--cArgs]));
					dispparams.rgvarg[cArgs].vt = VT_DISPATCH;
					// the srpAppDisp.Disown() transfers the addref'd pointer
					// from srpAppDisp to the variant.  VariantClear will
					// do the necessary release
					dispparams.rgvarg[cArgs].pdispVal = srpAppDisp2.Disown();

					// param 2. hwndPromptOwner
					::VariantInit(&(dispparams.rgvarg[--cArgs]));
					dispparams.rgvarg[cArgs].vt = VT_I4;
					dispparams.rgvarg[cArgs].lVal = (long)(HWND)GetSafeHwnd();

					// param 3. current property value
					::VariantInit(&(dispparams.rgvarg[--cArgs]));
					// since the current property value is an in/out 
					// parameter, it must also be tagged as a VT_BYREF
					dispparams.rgvarg[cArgs].vt = VT_BYREF|VT_VARIANT;
					dispparams.rgvarg[cArgs].pvarVal = pVarValue;

					::VariantInit(&varReturn);
					hr = srpBuilderDisp->Invoke(dispidExecute, IID_NULL, s_lcid, 
						DISPATCH_METHOD, &dispparams, &varReturn, NULL, NULL);
					if (SUCCEEDED(hr))
					{
						//determine the return value
						ASSERT(VT_BOOL == V_VT(&varReturn));
						bRetVal = V_BOOL(&varReturn);
						if (V_BOOL(&varReturn))
							hr = S_OK;
						else
							hr = S_FALSE;
						::VariantClear(&varReturn);
					}

					for (cArgs = 0; cArgs < 3; ++cArgs)
						::VariantClear(&(dispparams.rgvarg[cArgs]));
					delete [] dispparams.rgvarg;
				}
			}
			else
			{
				ASSERT(FALSE); // should never happen usually!
			}

			::SysFreeString(bstrGuidBuilder);

			if (S_OK == hr && !(lCtlBldType & CTLBLDTYPE_FEDITSOBJDIRECTLY))
				hr = SavePropertyForAllControls(pVarValue, pItem);
		}
	}

	return hr;
}

// This method is called when the user presses the ellipsis (...) button
// to execute the appropriate builder (top level method)
HRESULT COleAllPage::ExecuteBuilder(
	CPropItem*	pItem)
{
	ASSERT(pItem);
	if (NULL == pItem)
		return E_INVALIDARG;

	USES_CONVERSION;
	HRESULT		hr = E_FAIL;
	DISPID		dispid;

	m_dispDriver.AttachDispatch(m_pprgDisp[0], FALSE);
	switch (pItem->m_ctrlType)
	{
		case ctrl_BuilderPerPropertyBrowsing:
			hr = ExecutePPBBuilder(m_dispDriver.m_lpDispatch, pItem->m_pDispid[0]);
			break;
		case ctrl_BuilderWizardManager:
		case ctrl_BuilderProvidePropertyBuilder:
			ASSERT((pItem->m_iIndex != -1) && (pItem->m_iIndex < m_ulCountControls) &&
				(NULL != m_pprgDisp[pItem->m_iIndex]));
			if ((pItem->m_iIndex == -1) || (pItem->m_iIndex >= m_ulCountControls) ||
				(NULL == m_pprgDisp[pItem->m_iIndex]))
				return hr;
			// okay to fall through...
		case ctrl_BuilderWizardManagerIntrinsic:
		case ctrl_BuilderInternal:
		{
			VARIANT		varValue;
			IDispatch*	pDisp;
			DISPID		dispidCached;

			if ((pItem->m_ctrlType == ctrl_BuilderWizardManagerIntrinsic) ||
				(pItem->m_ctrlType == ctrl_BuilderInternal))
			{
				pDisp = m_pprgDisp[0];
				dispid = pItem->m_pDispid[0];
			}
			else
			{
				pDisp = m_pprgDisp[pItem->m_iIndex];
				dispid = pItem->m_pDispid[pItem->m_iIndex];
			}

			// get the current value of the property
			if (!GetPropValue(pDisp, dispid, &varValue))
				return hr;

			switch(pItem->m_ctrlType)
			{
				case ctrl_BuilderWizardManager:
				case ctrl_BuilderProvidePropertyBuilder:
					hr = ExecuteBWMAndPPBBuilder(pItem, dispid, &varValue);
					break;
				case ctrl_BuilderInternal:
					hr = ExecuteInternalBuilder(pItem, &varValue);
					break;
				case ctrl_BuilderWizardManagerIntrinsic:
					hr = ExecuteBWMIntrinsicBuilder(pItem, &varValue);
					break;
			}

			::VariantClear(&varValue);
		}
			break;
		default:
			ASSERT(FALSE);
			break;
	}

	return hr;
}

// When the user presses the "Del" key when the Picture property is selected,
// we "delete" the existing picture and set the property to NULL.
HRESULT COleAllPage::SetPictureToNone(
	CPropItem*	pItem)
{
	IDispatch*	pDispatch = m_pprgDisp[0];
	VARIANT		varValue;

	ASSERT(pDispatch && pItem);
	
	// get the current value of the property
	if (GetPropValue(pDispatch, pItem->m_pDispid[0], &varValue))
	{
		IPictureDisp*	pPictDisp;

		ASSERT(VT_DISPATCH == V_VT(&varValue));
		pPictDisp = (IPictureDisp*)V_DISPATCH(&varValue);
		// if we have a dispatch pointer, release it and set it
		// to NULL
		if (pPictDisp)
		{
			// release the current dispatch ptr
			pPictDisp->Release();

			// set the new value to NULL
			V_DISPATCH(&varValue) =	NULL;
			return SavePropertyForAllControls(&varValue, pItem);
		}

		return S_OK;
	}

	return E_FAIL;
}

// Called by the control(s) when a property is modified to indicate
// that the All property page must update/refresh its property values
// REVIEW: Currently, dispID is not used -- use this for optimization purposes
HRESULT COleAllPage::OnChanged(
	DISPID	dispID)
{
	// if we are not in the middle of changing properties for multi-select
	// or setting properties, handle the updating of properties
	if (!m_bUpdatingProps)
		UpdateChangedProperties();
	else
		m_bUpdateLater = TRUE;	// set flag so that we can be updated later

	return S_OK;
}

HRESULT COleAllPage::OnRequestEdit(
	DISPID	dispID)
{
	return S_OK;	// we always give permission to edit
}

STDMETHODIMP COleAllPage::XPropertyNotifySink::OnChanged(
	DISPID	dispID)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(COleAllPage, PropertyNotifySink)
	ASSERT_VALID(pThis);

	return pThis->OnChanged(dispID);
}

STDMETHODIMP COleAllPage::XPropertyNotifySink::OnRequestEdit(
	DISPID	dispID)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(COleAllPage, PropertyNotifySink)
	ASSERT_VALID(pThis);

	return pThis->OnRequestEdit(dispID);
}

STDMETHODIMP_(ULONG) COleAllPage::XPropertyNotifySink::AddRef()
{
	// Delegate to our exported AddRef.

	METHOD_PROLOGUE_EX(COleAllPage, PropertyNotifySink)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleAllPage::XPropertyNotifySink::Release()
{
	// Delegate to our exported Release.

	METHOD_PROLOGUE_EX(COleAllPage, PropertyNotifySink)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP COleAllPage::XPropertyNotifySink::QueryInterface(
	REFIID		riid,
	LPVOID far*	ppvObj)
{
	// Delegate to our exported QueryInterface.

	METHOD_PROLOGUE_EX(COleAllPage, PropertyNotifySink)
	return (HRESULT)pThis->ExternalQueryInterface(&riid, ppvObj);
}

// Cache the IPropertyNotifySink interfaces
void COleAllPage::GetNotifySinkInfo()
{
	DWORD	dwCookie;

	// just check to make sure that we do not have any cookies
	ASSERT(0 == m_dwaCookies.GetSize());
	for (int i = 0; i < m_ulCountControls; ++i)
	{
		COleRef<IConnectionPointContainer>	srpCPC;
		COleRef<IConnectionPoint>			srpCP;

		// get the connectionpointcontainer from the dispatch ptr
		// then, get the connection point
		// and finally, get the propertynotifysink cookie
		ASSERT(m_pprgDisp[i]);
		if (SUCCEEDED(m_pprgDisp[i]->QueryInterface(
				IID_IConnectionPointContainer, (void**)&srpCPC)) &&
			SUCCEEDED(srpCPC->FindConnectionPoint(IID_IPropertyNotifySink,
				&srpCP)) &&
			SUCCEEDED(srpCP->Advise(&m_xPropertyNotifySink, &dwCookie)))
		{
			m_dwaCookies.Add(dwCookie);
		}
		else
		{
			// since we need to keep the cookie array matched with the
			// number of controls, just add a "0" if we failed to get
			// the proper notify sink
			m_dwaCookies.Add(0);
		}
	}
}

// Free the cached IPropertyNotifySink interfaces
void COleAllPage::FreeNotifySinkInfo()
{
	int		iSize = m_dwaCookies.GetSize();

	// the number of cookies must equal the number of dispatch ptrs
	ASSERT(iSize == m_ulCountControls);
	for (int i = 0; i < iSize; i++)
	{
		// if we have don't have a cookie for this, just continue
		if (0 == m_dwaCookies[i])
			continue;

		COleRef<IConnectionPointContainer>	srpCPC;
		COleRef<IConnectionPoint>			srpCP;

		// get the connectionpointcontainer from the dispatch ptr
		// then, get the connection point
		ASSERT(m_pprgDisp[i]);
		if (SUCCEEDED(m_pprgDisp[i]->QueryInterface(
				IID_IConnectionPointContainer, (void**)&srpCPC)) &&
			SUCCEEDED(srpCPC->FindConnectionPoint(IID_IPropertyNotifySink,
				&srpCP)))
		{
			// free the propertynotifysink cookie
			srpCP->Unadvise(m_dwaCookies[i]);
		}
	}

	m_dwaCookies.RemoveAll();
}

// Reads the flags from VarDesc or FuncDesc to see if the property is
// "tagged" as read-only, hidden or non-browseable 
BOOL COleAllPage::IsPropTypeReadOnly(
	LPVARDESC	pVarDesc,
	LPFUNCDESC	pFuncDesc,
	BOOL		bCheckForPutAndPutRef)
{
	BOOL		bReadOnly = TRUE;	// assume that the property is read-only
	
	// find out if the property is hidden/nonbrowsable/readonly
	if (pVarDesc)
	{
		// first find out if the property marked as read-only
		bReadOnly = (pVarDesc->wVarFlags & VARFLAG_FREADONLY) ||
			(pVarDesc->wVarFlags & VARFLAG_FHIDDEN) ||
			(pVarDesc->wVarFlags & VARFLAG_FNONBROWSABLE);
	}
	else //(pFuncDesc)
	{
		ASSERT(pFuncDesc);
		// first find out if the property marked as read-only
		if (bCheckForPutAndPutRef)
		{
			bReadOnly = 
				( !(pFuncDesc->invkind & (INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF))
				|| ((pFuncDesc->wFuncFlags & FUNCFLAG_FHIDDEN) ||
				(pFuncDesc->wFuncFlags & FUNCFLAG_FNONBROWSABLE)) ) ||
				(pFuncDesc->cParams != 1);
		}
		else
		{
			bReadOnly = ( (pFuncDesc->wFuncFlags & FUNCFLAG_FHIDDEN) ||
				(pFuncDesc->wFuncFlags & FUNCFLAG_FNONBROWSABLE) ) ||
				(pFuncDesc->cParams != 1);
		}
	}

	return bReadOnly;
}

// A top level method that determines the property type for a given property
// It is assumed that the property is editable (or IsPropTypeReadOnly method
// is already called and verified that the property can be edited/modified)
DataType COleAllPage::GetPropType(
	IDispatch*	pDisp,
	LPTYPEINFO	pTypeInfo,
	LPVARDESC	pVarDesc,
	LPFUNCDESC	pFuncDesc,
	BOOL		bHasPathProps)
{
	ASSERT(pDisp && pTypeInfo);

	DataType	dt = data_Unknown;
	BOOL		bReadOnly;
	DISPID		dispid;
	TYPEDESC*	pTypeDesc = NULL;
	
	// get the dispid and the typedesc
	if (pVarDesc)
	{
		dispid = pVarDesc->memid;
		pTypeDesc = &pVarDesc->elemdescVar.tdesc;
	}
	else //(pFuncDesc)
	{
		ASSERT(pFuncDesc);
		dispid = pFuncDesc->memid;
		pTypeDesc = &pFuncDesc->lprgelemdescParam->tdesc;
	}

	COleRef<IPerPropertyBrowsing>	srpPPB;

	// first find out if this of kind enum_strings
	if (GetPerPropertyBrowsing(pDisp, &srpPPB))
	{
		CALPOLESTR	calpOleStr;
		CADWORD		cadw;
		HRESULT		hr;

		// Note:
		// passing NULL for caloOleStr and cadw does work for some controls
		// and other controls (especially Forms3 controls returns E_POINTER
		// for such input).  Therefore, we have to get these counted arrays
		// and throw them away here to determine that the data type is of
		// type data_EnumString
		// REVIEW -- try to optimize this later
		try {
			hr = srpPPB->GetPredefinedStrings(dispid, &calpOleStr, &cadw);
		}
		catch(...)
		{
			hr = E_UNEXPECTED;
		}
		if (S_OK == hr)
		{
			ASSERT(calpOleStr.cElems == cadw.cElems);
			for (ULONG i = 0; i < calpOleStr.cElems; ++i)
				AfxFreeTaskMem(calpOleStr.pElems[i]);

			AfxFreeTaskMem(calpOleStr.pElems);
			AfxFreeTaskMem(cadw.pElems);

			return data_EnumString;
		}
	}
	// next find out if this a url path property
	else if (bHasPathProps && IsPropAPathProperty(pTypeInfo, dispid))
	{
		return data_Path;
	}

	return DataTypeFromVT(pTypeDesc, pTypeInfo);
}

// A recursive method used to determine the data type of a given property
DataType COleAllPage::DataTypeFromVT(
	TYPEDESC*	pTypeDesc,
	LPTYPEINFO	pTypeInfo)
{
	HREFTYPE	hRefType;
	DataType	dt = data_Unknown;

	switch (pTypeDesc->vt)
	{
		default:
			return MapDataType(pTypeDesc->vt);
			break;
		case VT_USERDEFINED:
			hRefType = pTypeDesc->hreftype;
			break;
		case VT_PTR:
			if (pTypeDesc->lptdesc->vt == VT_USERDEFINED)
			{
				hRefType = pTypeDesc->lptdesc->hreftype;
				pTypeDesc = pTypeDesc->lptdesc;
			}
			else if (pTypeDesc->lptdesc->vt == VT_VARIANT)
			{
				// TODO$ to be done later
				return dt;
			}
			else
			{
				// may be a ptr to some other type which we don't handle
				// return dt;
				// Note: (sridharc)
				// for the time being call this to handle controls created
				// with VB5 CCE (IS Bug 7371) (approved by ScotG)
				return MapDataType(pTypeDesc->lptdesc->vt);
			}
			break;
	}

	COleRef<ITypeInfo>	srpTypeInfoSub;
	LPTYPEATTR			ptaSub = NULL;
	ITypeInfo*			pTypeInfoSub = NULL;

	// get the reference type info and its type attribute
	if (dt == data_Unknown &&
		SUCCEEDED(pTypeInfo->GetRefTypeInfo(hRefType, &srpTypeInfoSub)) &&
		SUCCEEDED(srpTypeInfoSub->GetTypeAttr(&ptaSub)))
	{
		if (ptaSub->typekind == TKIND_ALIAS && ptaSub->tdescAlias.vt == VT_USERDEFINED)
		{
			// call this recursively to figure out the data type
			pTypeInfoSub = srpTypeInfoSub.Disown();
			dt = DataTypeFromVT(&(ptaSub->tdescAlias), pTypeInfoSub);
			goto PropTypeRecurseEnd;
		}
		else
		{
			switch (ptaSub->typekind)
			{
				case TKIND_ENUM:
					// for the time being set the enum type to enumI4,
					// when we actually fill the values, reset the datatype
					// to the correct data type (enumI2 or enumI4)
					dt = data_EnumInt4;
					break;
				case TKIND_ALIAS:
					ASSERT(ptaSub->tdescAlias.vt != VT_USERDEFINED);
					if (ptaSub->guid == GUID_COLOR)
						dt = data_Color;
					else
						dt = MapDataType(ptaSub->tdescAlias.vt);
					break;
				case TKIND_INTERFACE:
					if (ptaSub->guid == IID_IPicture)
						dt = data_Picture;
					else if (ptaSub->guid == IID_IFont)
						dt = data_Font;
					break;
				case TKIND_DISPATCH:
					if (ptaSub->guid == IID_IPictureDisp)
						dt = data_Picture;
					else if (ptaSub->guid == IID_IFontDisp)
						dt = data_Font;
					break;
				case TKIND_RECORD:
				case TKIND_MODULE:
				case TKIND_COCLASS:
				case TKIND_UNION:
				default:
					break;
			}
		}

PropTypeRecurseEnd:

		if (pTypeInfoSub)
		{
			pTypeInfoSub->ReleaseTypeAttr(ptaSub);
			pTypeInfoSub->Release();
		}
		else
		{
			srpTypeInfoSub->ReleaseTypeAttr(ptaSub);
		}
	}

	return dt;
}

// Checks to make sure if the given property is of type "data_Path" (URL Path)
BOOL COleAllPage::IsPropAPathProperty(
	LPTYPEINFO	pTypeInfo,
	DISPID		dispid)
{
	BOOL		bPathProperty = FALSE;
	LPTYPEATTR	pta;

	COleRef<ITypeInfo2>	srpTypeInfo2;

	if (FAILED(pTypeInfo->QueryInterface(IID_ITypeInfo2, (void**)&srpTypeInfo2)) ||
		FAILED(srpTypeInfo2->GetTypeAttr(&pta)))
		return bPathProperty;

	// the following is done since there is a limitation in
	// GetVarIndexOfMemId and GetFuncIndexOfMemId
	//hr = pTypeInfo2->GetVarIndexOfMemId(memid, &varMemID);
	HRESULT		hr;
	VARIANT		varValue;
	UINT		varMemID;
	LPVARDESC	pVarDesc;
	LPFUNCDESC	pFuncDesc;

	for (int i = 0; i < pta->cVars && !bPathProperty; ++i)
	{
		if (FAILED(srpTypeInfo2->GetVarDesc(i, &pVarDesc)))
			continue;

		if (pVarDesc->memid == dispid)
		{
			::VariantInit(&varValue);
			hr = srpTypeInfo2->GetVarCustData(i, GUID_PathProperty, &varValue);
			if ((S_OK == hr) && (varValue.vt != VT_EMPTY))
				bPathProperty = TRUE;

			::VariantClear(&varValue);
		}

		srpTypeInfo2->ReleaseVarDesc(pVarDesc);
	}

	for (i = 0; i < pta->cFuncs && !bPathProperty; ++i)
	{
		if (FAILED(srpTypeInfo2->GetFuncDesc(i, &pFuncDesc)))
			continue;

		if (pFuncDesc->memid == dispid)
		{
			::VariantInit(&varValue);
			hr = srpTypeInfo2->GetFuncCustData(i, GUID_PathProperty, &varValue);
			if ((S_OK == hr) && (varValue.vt != VT_EMPTY))
				bPathProperty = TRUE;

			::VariantClear(&varValue);
		}

		srpTypeInfo2->ReleaseFuncDesc(pFuncDesc);
	}

	srpTypeInfo2->ReleaseTypeAttr(pta);

	return bPathProperty;
}

// Simply "maps" the VARTYPE from the variant to our data type
DataType COleAllPage::MapDataType(
	VARTYPE	vt)
{
	DataType	dt = data_Unknown;

	switch (vt)
	{
		case VT_I2:
			dt = data_Int2;
			break;
		case VT_I4:
			dt = data_Int4;
			break;
		case VT_R4:
			dt = data_Float;
			break;
		case VT_R8:
			dt = data_Double;
			break;
		case VT_CY:
			dt = data_Currency;
			break;
		case VT_DATE:
			dt = data_Date;
			break;
		case VT_BSTR:
			dt = data_String;
			break;
		case VT_BOOL:
			dt = data_Bool;
			break;
		case VT_UI2:
			dt = data_Int2;
			break;
		case VT_UI4:
			dt = data_Int4;
			break;
		case VT_I8:
		case VT_UI8:
			break;
		case VT_INT:
		case VT_UINT:
			dt = data_Int4;
			break;
		default:
			break;
	}

	return dt;
}

// Gets the property name.  If the property name starts with an '_'
// character, it is assumed to be a read-only property
BOOL COleAllPage::GetPropName(
	LPTYPEINFO	pTypeInfo,
	DISPID		dispid,
	CString&	strPropName)
{
	BSTR	bstrName;
	UINT	cName;

	strPropName.Empty();	// initialize the out value
	if (S_OK != pTypeInfo->GetNames(dispid, &bstrName, 1, &cName))
		return FALSE;

	// if the property name has at least one character and
	// if it doesn't start with an underscore, include it
	USES_CONVERSION;
	if ((::SysStringLen(bstrName) > 0) && (*bstrName != (OLECHAR)_T('_')))
		strPropName = OLE2CT(bstrName);

	::SysFreeString(bstrName);

	return (!strPropName.IsEmpty());
}

// This method gets the "currently selected" enumerated string value
// this value is necessary to show the "existing" value for an enumerated
// int property (also used to select the item when the drop-down list is dropped-down)
BOOL COleAllPage::GetPropValueForEnumString(
	IDispatch*	pDisp,
	DISPID		dispid,
	CPropItem*	pItem,
	VARIANT*	pVarValue)
{
	BOOL	bRet;
	COleRef<IPerPropertyBrowsing>	srpPPB;

	bRet = GetPerPropertyBrowsing(pDisp, &srpPPB);
	if (bRet)
	{
		BSTR	bstr;
		HRESULT	hr;

		hr = srpPPB->GetDisplayString(dispid, &bstr);
		if (S_OK == hr)
		{
			USES_CONVERSION;
			pItem->m_strProp = OLE2CT(bstr);
			::SysFreeString(bstr);
		}
		else if (S_FALSE == hr)
		{
			// select the data from one of the items in the list
			BOOL bProceed = UpdateEnumStringData(pDisp, dispid, pItem, FALSE);
			if (bProceed)
			{
				long	lEnumVal;

				switch(pVarValue->vt)
				{
					case VT_I2:
						lEnumVal = (long)(short)V_I2(pVarValue);
						break;
					case VT_UI2:
						lEnumVal = (long)(unsigned short)V_UI2(pVarValue);
						break;
					case VT_I4:
						lEnumVal = V_I4(pVarValue);
						break;
					case VT_UI4:
						lEnumVal = (long)V_UI4(pVarValue);
						break;
					case VT_BSTR:
						pItem->m_strProp = pVarValue->bstrVal;
						bProceed = FALSE;
						break;
					default:
						bProceed = FALSE;
						break;
				}

				if (bProceed)
				{
					int	iCount = pItem->m_pEnumData->m_dwaCookies.GetSize();
					for (int i = 0; i < iCount; ++i)
					{
						if (pItem->m_pEnumData->m_dwaCookies[i] == lEnumVal)
						{
							pItem->m_strProp = pItem->m_pEnumData->m_straEnumStrings[i];
							i = iCount;	// break out of the loop
						}
					}

				}
			}
		}

		pItem->m_ctrlType = (S_FALSE == hr) ? ctrl_ComboNotLimitToList : ctrl_ComboLimitToList;
	}

	return bRet;
}

// This method gets the "currently selected" enumerated int value
// this value is necessary to show the "existing" value for an enumerated
// int property (also used to select the item when the drop-down list is dropped-down)
BOOL COleAllPage::GetPropValueForEnumInt(
	LPTYPEINFO	pTypeInfo,
	HREFTYPE	hrefType,
	long		lEnumValue,
	CPropItem*	pItem,
	BOOL		bSetAllProps)
{
	COleRef<ITypeInfo>	srpTypeInfoSub;
	LPTYPEATTR			ptaSub;
	BOOL				bRet = FALSE;

	// get the reference type info and its type attribute
	if (SUCCEEDED(pTypeInfo->GetRefTypeInfo(hrefType, &srpTypeInfoSub)) &&
		SUCCEEDED(srpTypeInfoSub->GetTypeAttr(&ptaSub)))
	{
		BSTR		bstrVal;
		LPVARDESC	pvdSub;
		long		lCurrentValue;

		ASSERT(ptaSub->typekind == TKIND_ENUM);	// make sure of the type
		for (int i = 0; i < ptaSub->cVars; ++i)
		{
			// if we do not get the vardesc, just continue
			if (FAILED(srpTypeInfoSub->GetVarDesc(i, &pvdSub)))
				continue;

			ASSERT(pvdSub->varkind == VAR_CONST);
			lCurrentValue = GetLongFromVariant(pvdSub->lpvarValue);
			if (lCurrentValue == lEnumValue)
			{
				if (SUCCEEDED(srpTypeInfoSub->GetDocumentation(
						pvdSub->memid, NULL, &bstrVal, NULL, NULL)))
				{
					pItem->m_strProp = FormatEnumIntPropertyValue(lCurrentValue, bstrVal);
					::SysFreeString(bstrVal);
					bRet = TRUE;
				}

				i = ptaSub->cVars;	// break out of the loop
			}

			srpTypeInfoSub->ReleaseVarDesc(pvdSub);
		}

		srpTypeInfoSub->ReleaseTypeAttr(ptaSub);

		if (bRet)
		{
			pItem->unionValue.m_nValue = lEnumValue;
			if (bSetAllProps)
			{
				// cache the ref type info for later use
				ITypeInfo*	pTypeInfoTemp = srpTypeInfoSub.Disown();
				pItem->m_TypeInfoArrayEnumInt.Add(pTypeInfoTemp);
			}
		}
	}
	
	return bRet;
}

// This method is used to "extract" the appropriate property from the variant
// (usually for regular data types -- not the enumerated int/string ones)
BOOL COleAllPage::GetPropValueForOtherTypes(
	VARIANT*	pVarValue,
	CPropItem*	pItem)
{
	BSTR	bstrVal;
	BOOL	bRet = TRUE;

	USES_CONVERSION;
	pItem->m_strProp.Empty();	// initialize the out value
	switch(pItem->m_dataType)
	{
		default:
			bRet = FALSE;
			break;
		case data_Int2:
		case data_UInt2:
			wsprintf(pItem->m_strProp.GetBuffer(32), "%d", pVarValue->iVal);
			pItem->m_strProp.ReleaseBuffer();
			pItem->unionValue.m_nValue = pVarValue->iVal;
			break;
		case data_Int4:
		case data_UInt4:
			wsprintf(pItem->m_strProp.GetBuffer(32), "%d", pVarValue->lVal);
			pItem->m_strProp.ReleaseBuffer();
			pItem->unionValue.m_nValue = pVarValue->lVal;
			break;
		case data_Color:
		{
			CString	strZero(_T("0x00000000"));

			_ltot(pVarValue->lVal, pItem->m_strProp.GetBuffer(32), 16);
			pItem->m_strProp.ReleaseBuffer();
			pItem->m_strProp.MakeUpper();

			pItem->m_strProp = strZero.Left(strZero.GetLength() -
				pItem->m_strProp.GetLength()) + pItem->m_strProp;
			pItem->unionValue.m_nValue = pVarValue->lVal;
		}
			break;
		case data_Bool:
			pItem->m_strProp = (pVarValue->boolVal) ? s_strTrue : s_strFalse;
			pItem->unionValue.m_nValue = (pVarValue->boolVal) ? TRUE : FALSE;
			break;
		case data_Font:
		{
			LPUNKNOWN	pUnk = V_UNKNOWN(pVarValue);
			if (pUnk)
			{
				COleRef<IFont>	srpFont;

				if (SUCCEEDED(pUnk->QueryInterface(IID_IFont, (void**)&srpFont)))
				{
					srpFont->get_Name(&bstrVal);
					pItem->m_strProp = OLE2CT(bstrVal);
					::SysFreeString(bstrVal);
				}
			}
		}
			break;
		case data_Picture:
		{
			LPUNKNOWN	pUnk = V_UNKNOWN(pVarValue);
			if (pUnk)
			{
				COleRef<IDispatch>	srpDisp;

				if (SUCCEEDED(pUnk->QueryInterface(IID_IDispatch,
					(void**)&srpDisp)) && srpDisp)
					GetPictureType(srpDisp, pItem->m_strProp);
			}

			if (pItem->m_strProp.IsEmpty())
				pItem->m_strProp.LoadString(IDS_PICTURETYPENONE);
		}
			break;
		case data_Double:
			if (S_OK == VarBstrFromR8(pVarValue->dblVal, s_lcid,
				LOCALE_NOUSEROVERRIDE, &bstrVal))
			{
				pItem->m_strProp = OLE2T(bstrVal);
				::SysFreeString(bstrVal);
				pItem->unionValue.m_dValue = pVarValue->dblVal;
			}
			break;
		case data_Path:
		case data_String:
			pItem->m_strProp = OLE2T(pVarValue->bstrVal);
			break;
		case data_EnumString:
			// taken care of elsewhere (call GetPropValueForEnumString)
			ASSERT(FALSE);
			break;
		case data_EnumInt2:
		case data_EnumInt4:
			// taken care of elsewhere (call GetPropValueForEnumInt)
			ASSERT(FALSE);
			break;
		case data_Float:
			if (S_OK == VarBstrFromR4(pVarValue->fltVal, s_lcid,
				LOCALE_NOUSEROVERRIDE, &bstrVal))
			{
				pItem->m_strProp = OLE2T(bstrVal);
				::SysFreeString(bstrVal);
				pItem->unionValue.m_fValue = pVarValue->fltVal;
			}
			break;
		case data_Currency:
			if (S_OK == VarBstrFromCy(pVarValue->cyVal, s_lcid,
				LOCALE_NOUSEROVERRIDE, &bstrVal))
			{
				pItem->m_strProp = OLE2T(bstrVal);
				::SysFreeString(bstrVal);
				pItem->unionValue.m_currency = pVarValue->cyVal;
			}
			break;
		case data_Date:
			if (S_OK == VarBstrFromDate(pVarValue->date, s_lcid,
				LOCALE_NOUSEROVERRIDE, &bstrVal))
			{
				pItem->m_strProp = OLE2T(bstrVal);
				::SysFreeString(bstrVal);
				pItem->unionValue.m_date = pVarValue->date;
			}
			break;
	}

	return bRet;
}

// A silly little method to get the property value
BOOL COleAllPage::GetPropValue(
	IDispatch*	pDisp,
	DISPID		dispid,
	VARIANT*	pVarValue)
{
	DISPPARAMS	dp = {NULL, NULL, 0, 0};
	BOOL bRet = FALSE;
	::VariantInit(pVarValue);	// initialize the return value
	
	try 
	{
		bRet = (S_OK == pDisp->Invoke(dispid, IID_NULL, 0, INVOKE_PROPERTYGET,
			&dp, pVarValue, NULL, NULL));
	}
	catch (...)
	{
	}
	return bRet;
}

// This method gets property value and other details necessary to edit a
// property
BOOL COleAllPage::GetPropDetails(
	IDispatch*	pDisp,
	LPTYPEINFO	pTypeInfo,
	HREFTYPE	hrefType,
	DISPID		dispid,
	CPropItem*	pItem,
	BOOL		bSetAllDetails,
	VARIANT*	pVarValue)
{
	BOOL	bRet = FALSE;

	switch(pItem->m_dataType)
	{
		default:
			bRet = GetPropValueForOtherTypes(pVarValue, pItem);
			break;
		case data_EnumInt2:
		case data_EnumInt4:
		{
			long	lValue = GetLongFromVariant(pVarValue);

			bRet = GetPropValueForEnumInt(pTypeInfo, hrefType, lValue,
				pItem, bSetAllDetails);
			// if we have a multiple selection, we need to get the enumdata now
			if (bRet && m_ulCountControls > 1)
				bRet = UpdateEnumIntData(0, dispid, pItem, lValue);
		}
			break;
		case data_EnumString:
			bRet = GetPropValueForEnumString(pDisp, dispid, pItem, pVarValue);
			// if we have a multiple selection, we need to get the enumdata now
			if (bRet && m_ulCountControls > 1)
				bRet = UpdateEnumStringData(pDisp, dispid, pItem, FALSE);
			break;
	}

	if (bRet && bSetAllDetails)
	{
		// set the builder type for later use
		switch(pItem->m_dataType)
		{
			default:
				bRet = FALSE;
				break;
			case data_Int2:
			case data_Int4:
			case data_UInt2:
			case data_UInt4:
			case data_Path:
			case data_Float:
			case data_Double:
			case data_String:
			case data_Date:
			case data_Currency:
				DetermineBuilderType(dispid, pItem);
				if (pItem->m_ctrlType == ctrl_Unknown)
					pItem->m_ctrlType = ctrl_Edit;
				break;
			case data_Color:
			case data_Font:
			case data_Picture:
				DetermineBuilderType(dispid, pItem);
				bRet = (pItem->m_ctrlType != ctrl_Unknown);
				break;
			case data_EnumString:
				// builder type already set in GetPropValueForEnumString
				bRet = (pItem->m_ctrlType != ctrl_Unknown);
				break;
			case data_Bool:
			case data_EnumInt2:
			case data_EnumInt4:
				pItem->m_ctrlType = ctrl_ComboLimitToList;
				break;
		}
	}

	return bRet;
}

// This method updates the enum int data (frees the old data before
// gathering the new enum int data
BOOL COleAllPage::UpdateEnumIntData(
	int			iControlIndex,
	DISPID		dispid,
	CPropItem*	pItem,
	long		lEnumVal)
{
	// if the enum int data is not "dirty" no need to re-get the data
	if (!pItem->IsEnumDataDirty())
		return TRUE;

	// do not release the following interface here, this is cached and will
	// be released upon the destruction of pItem
	ASSERT(iControlIndex <= pItem->m_TypeInfoArrayEnumInt.GetSize());
	ITypeInfo*	pTypeInfo;	// ref typeinfo
	LPTYPEATTR	ptaSub;

	pTypeInfo = (ITypeInfo*)pItem->m_TypeInfoArrayEnumInt.GetAt(iControlIndex);
	ASSERT(pTypeInfo);
	if (SUCCEEDED(pTypeInfo->GetTypeAttr(&ptaSub)))
	{
		LPVARDESC	pvdSub;
		long		lEnumValInLoop;
		BSTR		bstr;
		CString		strLoop;
		int			iCount;

		// free the old data and get memory for new data
		pItem->GetNewEnumData();

		for (int i = 0; i < ptaSub->cVars; ++i)
		{
			if (FAILED(pTypeInfo->GetVarDesc(i, &pvdSub)))
				continue;

			ASSERT(pvdSub->varkind == VAR_CONST);
			if (V_VT(pvdSub->lpvarValue) == VT_I4)
			{
				pItem->m_dataType = data_EnumInt4;
				lEnumValInLoop = V_I4(pvdSub->lpvarValue);
			}
			else
			{
				ASSERT(V_VT(pvdSub->lpvarValue) == VT_I2);
				pItem->m_dataType = data_EnumInt2;
				lEnumValInLoop = (long)(short)V_I2(pvdSub->lpvarValue);
			}

			if (SUCCEEDED(pTypeInfo->GetDocumentation(
					pvdSub->memid, NULL, &bstr, NULL, NULL)))
			{
				strLoop = FormatEnumIntPropertyValue(lEnumValInLoop, bstr);
				::SysFreeString(bstr);

				// store the enumerated string and the cookie
				// in the enum data structure
				pItem->m_pEnumData->m_straEnumStrings.Add(strLoop);
				pItem->m_pEnumData->m_dwaCookies.Add(lEnumValInLoop);
			}

			pTypeInfo->ReleaseVarDesc(pvdSub);
		}

		pItem->SetEnumDataDirty(FALSE);
		pTypeInfo->ReleaseTypeAttr(ptaSub);

		// select the current value and store it in pItem->mstrProp
		iCount = pItem->m_pEnumData->m_dwaCookies.GetSize();
		for (i = 0; i < iCount; i++)
		{
			if (pItem->m_pEnumData->m_dwaCookies[i] == lEnumVal)
			{
				pItem->m_strProp = pItem->m_pEnumData->m_straEnumStrings[i];
				pItem->unionValue.m_nValue = lEnumVal;
				i = iCount;	// break out of the loop
			}
		}

		return TRUE;
	}

	return FALSE;
}

// This method updates the enum string data (frees the old data before
// gathering the new enum string data
BOOL COleAllPage::UpdateEnumStringData(
	IDispatch*	pDisp,
	DISPID		dispid,
	CPropItem*	pItem,
	BOOL		bUpdatePropValue)
{
	// if the enum string data is not "dirty" no need to re-get the data
	if (!pItem->IsEnumDataDirty())
		return TRUE;

	COleRef<IPerPropertyBrowsing>	srpPPB;

	if (!GetPerPropertyBrowsing(pDisp, &srpPPB))
		return FALSE;

	HRESULT		hr;
	CALPOLESTR	calpOleStr;
	CADWORD		cadw;

	hr = srpPPB->GetPredefinedStrings(dispid, &calpOleStr, &cadw);
	if (hr == S_OK && calpOleStr.cElems > 0) //NOTE: Don't use SUCCEEDED()!
	{
		// free the old data and get memory for new data
		pItem->GetNewEnumData();

		USES_CONVERSION;
		ASSERT(calpOleStr.cElems == cadw.cElems);
		for (ULONG i = 0; i < calpOleStr.cElems; ++i)
		{
			// store the enumerated string and the cookie
			// in the enum data structure
			pItem->m_pEnumData->m_straEnumStrings.Add(OLE2CT(calpOleStr.pElems[i]));
			pItem->m_pEnumData->m_dwaCookies.Add((DWORD)cadw.pElems[i]);

			AfxFreeTaskMem(calpOleStr.pElems[i]);
		}

		AfxFreeTaskMem(calpOleStr.pElems);
		AfxFreeTaskMem(cadw.pElems);

		pItem->SetEnumDataDirty(FALSE);

		if (bUpdatePropValue)
		{
			VARIANT	var;

			if (GetPropValue(pDisp, dispid, &var))
				GetPropValueForEnumString(pDisp, dispid, pItem, &var);

			::VariantClear(&var);
		}
		return TRUE;
	}

	return FALSE;
}

// When more than 1 control is selected, this method verifies that the enum
// string is similar in all the controls.  That is, it makes sure that the
// number of elements enumerated is the same and the enumerated items are also
// the same.  This method assumes that the "order" in the elements are enumerated
// must be the same for 2 controls to edit a property -- if the order is different
// then the user has to select each control separately to edit the enumerated
// string property
BOOL COleAllPage::IntersectPropEnumString(
	IDispatch*	pDisp,
	DISPID		dispid,
	CPropItem*	pItem)
{
	ASSERT(pItem->m_pEnumData);	// this should already be set

	BOOL		bRet = FALSE;
	CALPOLESTR	calpOleStr;
	CADWORD		cadw;
	HRESULT		hr;

	COleRef<IPerPropertyBrowsing>	srpPPB;

	if (!GetPerPropertyBrowsing(pDisp, &srpPPB))
		return bRet;

	// get all the strings
	// make sure that each of the pre-defined string exists in
	// the pItem->m_pEnumData structure.  If not, return FALSE
	// so that that property is removed from the list (map)
	hr = srpPPB->GetPredefinedStrings(dispid, &calpOleStr, &cadw);
	if (hr == S_OK && calpOleStr.cElems > 0) //NOTE: Don't use SUCCEEDED()!
	{
		// if the number of strings we have in pItem->m_pEnumData is not the
		// same as the number we got here, then we have to drop this property
		ASSERT(calpOleStr.cElems == cadw.cElems);
		bRet = (pItem->m_pEnumData->m_straEnumStrings.GetSize() == (int) calpOleStr.cElems);

		USES_CONVERSION;
		// the loop has to go through to free elements
		for (ULONG i = 0; i < calpOleStr.cElems; ++i)
		{
			// assumption:
			// the "order" in which the elements exist must be
			// the same for all the controls selected
			if (bRet)
				bRet = 
					(0 == pItem->m_pEnumData->m_straEnumStrings[i].Compare(OLE2CT(calpOleStr.pElems[i]))) &&
					((DWORD)cadw.pElems[i] == pItem->m_pEnumData->m_dwaCookies[i]);

			AfxFreeTaskMem(calpOleStr.pElems[i]);
		}

		AfxFreeTaskMem(calpOleStr.pElems);
		AfxFreeTaskMem(cadw.pElems);
	}

	return bRet;
}

// When more than 1 control is selected, this method verifies that the enum
// int (2 or 4) is similar in all the controls.  That is, it makes sure that the
// number of elements enumerated is the same and the enumerated items are also
// the same.  This method assumes that the "order" in the elements are enumerated
// must be the same for 2 controls to edit a property -- if the order is different
// then the user has to select each control separately to edit the enumerated
// int property
BOOL COleAllPage::IntersectPropEnumInt(
	IDispatch*	pDisp,
	DISPID		dispid,
	CPropItem*	pItem,
	LPTYPEINFO	pTypeInfo,
	TYPEDESC*	pTypeDesc)
{
	ASSERT(pItem->m_pEnumData);	// this should already be set

	BOOL				bRet = FALSE;
	COleRef<ITypeInfo>	srpTypeInfoSub;
	LPTYPEATTR			ptaSub;

	if (SUCCEEDED(pTypeInfo->GetRefTypeInfo(pTypeDesc->hreftype, &srpTypeInfoSub))
		&& SUCCEEDED(srpTypeInfoSub->GetTypeAttr(&ptaSub)))
	{
		LPVARDESC	pvdSub;
		long		lEnumValInLoop;
		long		lEnumVal;
		BSTR		bstr;
		CString		strLoop;

		// if the number of strings we have in pItem->m_pEnumData
		// is not the same as the number we got here, then
		// we have to drop this property
		bRet = (pItem->m_pEnumData->m_straEnumStrings.GetSize() == ptaSub->cVars);

		// get all the strings
		// make sure that each of the pre-defined string exists in
		// the pItem->m_pEnumData structure.  If not, return FALSE
		// so that that property is removed from the list (map)
		for (int i = 0; bRet && (i < ptaSub->cVars); ++i)
		{
			if (FAILED(srpTypeInfoSub->GetVarDesc(i, &pvdSub)))
				continue;

			ASSERT(pvdSub->varkind == VAR_CONST);
			lEnumValInLoop = GetLongFromVariant(pvdSub->lpvarValue);
			if (SUCCEEDED(srpTypeInfoSub->GetDocumentation(
						pvdSub->memid, NULL, &bstr, NULL, NULL)))
			{
				strLoop = FormatEnumIntPropertyValue(lEnumValInLoop, bstr);
				::SysFreeString(bstr);

				// assumption:
				// the "order" in which the elements exist must be
				// the same for all the controls selected
				if (bRet)
					bRet =
						(0 == pItem->m_pEnumData->m_straEnumStrings[i].Compare(strLoop)) &&
						(lEnumValInLoop == pItem->m_pEnumData->m_dwaCookies[i]);
			}

			srpTypeInfoSub->ReleaseVarDesc(pvdSub);
		}

		srpTypeInfoSub->ReleaseTypeAttr(ptaSub);
		
		if (bRet)
		{
			// cache the ref type info for later use
			ITypeInfo*	pTypeInfoTemp = srpTypeInfoSub.Disown();
			pItem->m_TypeInfoArrayEnumInt.Add(pTypeInfoTemp);
		}
	}

	return bRet;
}

// When more than one control is selected, the AddToMap method is called
// for the first control and for the rest, this method is called.
// This method basically "reduces" the properties' set to the "least common
// denominator" set of properties
BOOL COleAllPage::IntersectPropItemData(
	IDispatch*	pDisp,
	DISPID		dispid,
	CPropItem*	pItem, 
	LPTYPEINFO	pTypeInfo,
	TYPEDESC*	pTypeDesc)
{
	ASSERT(pItem && pTypeInfo && m_dispDriver.m_lpDispatch);

	BOOL	bRet = FALSE;
	VARIANT	var;

	// do not allow editing of font and picture for multiple selection
	if ((pItem->m_dataType == data_Unknown) ||
		(pItem->m_dataType == data_Font) ||
		(pItem->m_dataType == data_Picture))
		return bRet;

	bRet = GetPropValue(pDisp, dispid, &var);
	if (!bRet)
		return bRet;

	// compare the existing property value with the new one
	// if they don't match, set the property value to nothing
	switch(pItem->m_dataType)
	{
		default:
			ASSERT(FALSE);
			bRet = FALSE;
			break;
		case data_EnumString:	// taken care of above
			bRet = IntersectPropEnumString(pDisp, dispid, pItem);
			if (bRet && !(pItem->m_strProp.IsEmpty()))
			{
				ControlType	ct;
				CString		strPropNew;

				strPropNew = pItem->m_strProp;
				ct = pItem->m_ctrlType;
				bRet = GetPropValueForEnumString(pDisp, dispid, pItem, &var);
				if (bRet && (0 != strPropNew.Compare(pItem->m_strProp)))
					pItem->m_strProp.Empty();
			}
			break;
		case data_EnumInt2:
		case data_EnumInt4:
			bRet = IntersectPropEnumInt(pDisp, dispid, pItem, pTypeInfo, pTypeDesc);
			if (bRet && (pItem->unionValue.m_nValue != GetLongFromVariant(&var)))
			{
				pItem->unionValue.m_nValue = -1;
				pItem->m_strProp.Empty();
			}
			break;

		case data_Int2:
		case data_UInt2:
		case data_Int4:
		case data_UInt4:
		case data_Color:
		case data_Float:
		case data_Double:
		case data_Bool:
		case data_Path:
		case data_String:
		case data_Date:
		case data_Currency:
			if (!(pItem->m_strProp.IsEmpty()))
			{
				switch(pItem->m_dataType)
				{
					case data_Int2:		// maps to VT_I2
					case data_UInt2:
						if (pItem->unionValue.m_nValue != var.iVal)
							pItem->m_strProp.Empty();
						break;
					case data_Int4:		// maps to VT_I4
					case data_UInt4:
					case data_Color:
						if (pItem->unionValue.m_nValue != var.lVal)
							pItem->m_strProp.Empty();
						break;
					case data_Float:		// maps to VT_R4
						if (pItem->unionValue.m_fValue != var.fltVal)
							pItem->m_strProp.Empty();
						break;
					case data_Double:		// maps to VT_R8
						if (pItem->unionValue.m_dValue != var.dblVal)
							pItem->m_strProp.Empty();
						break;
					case data_Bool:		// maps to VT_BOOL
						if (pItem->unionValue.m_nValue !=
							((var.boolVal) ? TRUE : FALSE))
							pItem->m_strProp.Empty();
						break;
					case data_Path:
					case data_String:	// maps to VT_BSTR
					{
						USES_CONVERSION;

						// bstrVal can be NULL, CString.Compare does not accept NULL
						if ((NULL == var.bstrVal) ||
							(0 != pItem->m_strProp.Compare(OLE2T(var.bstrVal))))
							pItem->m_strProp.Empty();
					}
						break;
					case data_Date:
						if (pItem->unionValue.m_date!= var.date)
							pItem->m_strProp.Empty();
						break;
					case data_Currency:
					{
						BSTR	bstrVal;

						VarBstrFromCy(var.cyVal, s_lcid, LOCALE_NOUSEROVERRIDE,
							&bstrVal);
						USES_CONVERSION;

						// bstrVal can be NULL, CString.Compare does not accept NULL
						if ((NULL == bstrVal) ||
							(0 != pItem->m_strProp.Compare(OLE2T(bstrVal))))
							pItem->m_strProp.Empty();

						::SysFreeString(bstrVal);
					}
						break;
				}
			}
			break;
	}

	::VariantClear(&var);

	return bRet;
}

// Everytime a property is changed, or whenever an OnChanged notification
// (through IPropertyNotifySink interface) is received, this method is called
// to re-read the data from the control(s)
void COleAllPage::UpdateChangedProperties()
{
	BOOL		bRepaint = FALSE;
	try
	{
		int			iCount = m_lbProps.GetCount();
		HRESULT		hr;
		CPropItem*	pItem;
		BOOL		bNewPropSet;
		BOOL		bEnumIntUpdated;
		BOOL		bEnumStringUpdated;
		DISPID		dispid;
		IDispatch*	pDisp;
		VARIANT		var;
		CString		strPropNew;
		DataType	dt;

		USES_CONVERSION;
		// go through all the properties
		for (int i = 0; i < iCount; ++i)
		{
			pItem = (CPropItem*) m_lbProps.GetItemData(i);
			ASSERT(pItem);
			bNewPropSet = FALSE;
			bEnumIntUpdated = FALSE;
			bEnumStringUpdated = FALSE;

			// re-get the property type again.
			// this is done since some properties can change it property type
			// (for example, from data_String to data_EnumString when a property
			// like the DataSource property is changed).
			dt = GetPropType(m_pprgDisp[0], pItem->m_TypeInfo,
				pItem->m_pvd, pItem->m_pfd, (pItem->m_dataType == data_Path));

			if (dt != pItem->m_dataType)
			{
				// if the new data type is not the same as the old one, just delete
				// the enumeration data if it exists
				if (pItem->m_pEnumData)
				{
					delete pItem->m_pEnumData;
					pItem->m_pEnumData = NULL;
				}
				
				pItem->m_dataType = dt;
			}

			// go through all the controls (for each property)
			for (int j = 0; j < m_ulCountControls; ++j)
			{
				pDisp = m_pprgDisp[j];
				ASSERT(pDisp);
				dispid = pItem->m_pDispid[j];

				switch(pItem->m_dataType)
				{
					default:
						ASSERT(FALSE);
						break;
					case data_EnumString:	// taken care of above
						// refill the property list and property
						// it is easier to do this once instead of comparing
						// and finding out if this property changed
						if (!bEnumStringUpdated)
						{
							pItem->SetEnumDataDirty(TRUE);
							if (UpdateEnumStringData(pDisp, dispid, pItem, TRUE))
							{
								bEnumStringUpdated = TRUE;
								bNewPropSet = TRUE;
							}
						}
						break;
					case data_EnumInt2:
					case data_EnumInt4:
					case data_Int2:
					case data_UInt2:
					case data_Int4:
					case data_UInt4:
					case data_Color:
					case data_Float:
					case data_Font:
					case data_Picture:
					case data_Double:
					case data_Bool:
					case data_Path:
					case data_String:
					case data_Currency:
					case data_Date:
						if (GetPropValue(pDisp, dispid, &var))
						{
							if (pItem->m_dataType == data_EnumInt2 ||
								pItem->m_dataType == data_EnumInt4)
							{
								// refill the property list and property
								// it is easier to do this once instead of comparing
								// and finding out if this property changed
								if (!bEnumIntUpdated)
								{
									pItem->SetEnumDataDirty(TRUE);
									if (UpdateEnumIntData(j, dispid, pItem,
										GetLongFromVariant(&var)))
									{
										bEnumIntUpdated = TRUE;
										bNewPropSet = TRUE;
									}
								}
							}
							else
							{
								// store the current value and get the new value
								strPropNew = pItem->m_strProp;
								GetPropValueForOtherTypes(&var, pItem);
								// if they are not the same, we have the updated value
								if (0 != strPropNew.Compare(pItem->m_strProp))
								{
									bNewPropSet = TRUE;
									// if this happened and we have multiple
									// controls selected, set property to nothing
									if (m_ulCountControls > 1)
									{
										pItem->m_strProp.Empty();
										pItem->unionValue.m_nValue = 0;
										pItem->unionValue.m_dValue = 0.0;
									}
								}
							}
							::VariantClear(&var);
						}
						break;
				}
			}

			if (bNewPropSet && !bRepaint)
				bRepaint = TRUE;
		}
	}
	catch(...)
	{
	}

	if (bRepaint)
		m_lbProps.InvalidateRect(NULL);	// update ui (properties)
}

// This method updates the enum data (string or int2/int4)
// for the drop-down list to display the most recent data
void COleAllPage::UpdateEnumData(
	CPropItem*	pItem)
{
	if (!IsEnumDataType(pItem))
		return;

	IDispatch*	pDisp = m_pprgDisp[0];
	DISPID		dispid = pItem->m_pDispid[0];

	ASSERT(pDisp);

	try 
	{
		if (pItem->m_dataType == data_EnumString)
		{
			UpdateEnumStringData(pDisp, dispid, pItem, FALSE);
		}
		else
		{
			VARIANT	var;

			if (GetPropValue(pDisp, dispid, &var))
			{
				UpdateEnumIntData(0, dispid, pItem, GetLongFromVariant(&var));
				::VariantClear(&var);
			}
		}
	}
	catch (...)
	{}
}

#if 0
void CPropEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if (VK_TAB == nChar)
	{
		CWnd *pWnd = GetParent();
		ASSERT(pWnd);
		CWnd *pDlg = pWnd->GetParent();
		ASSERT(pDlg);
		pDlg->SetFocus();
// #else
		GetParent()->SetFocus();
		return;
	}
	CEdit::OnChar(nChar, nRepCnt, nFlags);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autodocd.cpp ===
// AutoDocD.cpp : implementation file
//

#include "stdafx.h"
#include "vshell.h"
#include "autoguid.h"
#include "AutoDocD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Dual Interface Delegation

// methods
#ifdef _DUAL_

DELEGATE_BOOL_PUT(CAutoDocumentDefault,GenericDocument,Active)
DELEGATE_BOOL_GET(CAutoDocumentDefault,GenericDocument,Active)

DELEGATE_NO_PARAMS_WITH_BOOL_RETVAL(CAutoDocumentDefault, GenericDocument,PrintOut)
DELEGATE_NO_PARAMS_WITH_BOOL_RETVAL(CAutoDocumentDefault, GenericDocument,Undo)
DELEGATE_NO_PARAMS_WITH_BOOL_RETVAL(CAutoDocumentDefault, GenericDocument,Redo)

DELEGATE_NO_PARAMS_WITH_RETVAL(CAutoDocumentDefault, GenericDocument,NewWindow, LPDISPATCH)

DELEGATE_TWO_PARAMS_WITH_RETVAL(CAutoDocumentDefault, GenericDocument, Save, VARIANT, VARIANT, DsSaveStatus)
DELEGATE_ONE_PARAM_WITH_RETVAL(CAutoDocumentDefault, GenericDocument, Close, VARIANT, DsSaveStatus)

// properties

DELEGATE_BSTR_GET(CAutoDocumentDefault, GenericDocument, Name, Name)
DELEGATE_BSTR_GET(CAutoDocumentDefault, GenericDocument, FullName, FullName)

DELEGATE_BSTR_GET(CAutoDocumentDefault, GenericDocument, Path, Path)
DELEGATE_BSTR_GET(CAutoDocumentDefault, GenericDocument, Type, Type)

DELEGATE_GET(CAutoDocumentDefault, GenericDocument,Parent,LPDISPATCH)
DELEGATE_GET(CAutoDocumentDefault, GenericDocument,Application,LPDISPATCH)
DELEGATE_GET(CAutoDocumentDefault, GenericDocument,ActiveWindow,LPDISPATCH)
DELEGATE_GET(CAutoDocumentDefault, GenericDocument,Windows,LPDISPATCH)

DELEGATE_BOOL_GET(CAutoDocumentDefault, GenericDocument,Saved)
DELEGATE_BOOL_GET(CAutoDocumentDefault, GenericDocument,ReadOnly)
DELEGATE_BOOL_PUT(CAutoDocumentDefault, GenericDocument,ReadOnly)

#endif

/////////////////////////////////////////////////////////////////////////////
// CAutoDocumentDefault

IMPLEMENT_DYNAMIC(CAutoDocumentDefault, CAutoObj)

CAutoDocumentDefault::CAutoDocumentDefault(CPartDoc* pDoc)
{
#ifdef _DUAL_
	EnableDualAutomation();
#else
	EnableAutomation() ;
#endif
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	ASSERT( pDoc != NULL) ;
	m_pDoc = pDoc ;
}

CAutoDocumentDefault::~CAutoDocumentDefault()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.

	AfxOleUnlockApp();

	if (m_pDoc != NULL)
	{
		m_pDoc->AutomationObjectReleased() ;
	}
}


//
// CPartFrame and CPartDoc call this function to inform us
// that they are being deleted.
//
void CAutoDocumentDefault::AssociatedObjectReleased()
{
	m_pDoc = NULL ;
}


void CAutoDocumentDefault::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CAutoObj::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CAutoDocumentDefault, CAutoObj)
	//{{AFX_MSG_MAP(CAutoDocumentDefault)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoDocumentDefault, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoDocumentDefault)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "Name", GetName, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "FullName", GetFullName, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "Path", GetPath, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "Saved", GetSaved, SetSaved, VT_BOOL)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "Type", GetType, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "ReadOnly", GetReadOnly, SetReadOnly, VT_BOOL)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "ActiveWindow", GetActiveWindow, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "Windows", GetWindows, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDocumentDefault, "Active", GetActive, SetActive, VT_BOOL)
	DISP_FUNCTION(CAutoDocumentDefault, "Close", Close, VT_I4, VTS_VARIANT)
	DISP_FUNCTION(CAutoDocumentDefault, "Save", Save, VT_I4, VTS_VARIANT)
	DISP_FUNCTION(CAutoDocumentDefault, "Redo", Redo, VT_BOOL, VTS_NONE)
	DISP_FUNCTION(CAutoDocumentDefault, "Undo", Undo, VT_BOOL, VTS_NONE)
	DISP_FUNCTION(CAutoDocumentDefault, "NewWindow", NewWindow, VT_DISPATCH, VTS_NONE)
	DISP_FUNCTION(CAutoDocumentDefault, "PrintOut", PrintOut, VT_BOOL, VTS_NONE)
	DISP_DEFVALUE(CAutoDocumentDefault, "Name")
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IAutoDocumentDefault to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

/* removed per dualimple.doc 
// {E1870221-933A-11CF-9BF9-00A0C90A632C}
static const IID IID_IAutoDocumentDefault =
{ 0xe1870221, 0x933a, 0x11cf, { 0x9b, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c } };
*/

BEGIN_INTERFACE_MAP(CAutoDocumentDefault, CAutoObj)
	INTERFACE_PART(CAutoDocumentDefault, IID_IDispGenericDocument, Dispatch)
	INTERFACE_PART(CAutoDocumentDefault, IID_IGenericDocument, Dispatch) 
#ifdef _DUAL_
	DUAL_ERRORINFO_PART(CAutoDocumentDefault)
#endif
END_INTERFACE_MAP()

#ifdef _DUAL_
IMPLEMENT_DUAL_ERRORINFO(CAutoDocumentDefault, IID_IGenericDocument)
DS_IMPLEMENT_ENABLE_DUAL(CAutoDocumentDefault, GenericDocument)
DS_DELEGATE_DUAL_INTERFACE(CAutoDocumentDefault, GenericDocument)
DS_IMPLEMENT_VTBL_PAD_10(CAutoDocumentDefault, GenericDocument)
#endif

/* Removed see DualImpl.doc
// {E1870222-933A-11CF-9BF9-00A0C90A632C}
IMPLEMENT_OLECREATE(CAutoDocumentDefault, "VSHELL7.AUTODOCUMENTDEFAULT", 0xe1870222, 0x933a, 0x11cf, 0x9b, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c)
*/

/////////////////////////////////////////////////////////////////////////////
// This function checks to see if the associated frame is still alive.
// If it is not alive, it returns TRUE. If it is alive it throws an exception 
// and returns false.
inline void CAutoDocumentDefault::NoDoc() 
{	
	if (m_pDoc == NULL) 
	{
		DsThrowShellOleDispatchException(DS_E_DOC_RELEASED); 
	}
}

/////////////////////////////////////////////////////////////////////////////
// CAutoDocumentDefault message handlers

BSTR CAutoDocumentDefault::GetName() 
{
	NoDoc();
	return m_pDoc->GetName() ;
}


BSTR CAutoDocumentDefault::GetFullName() 
{	
	NoDoc();	
	return m_pDoc->GetFullName() ;
}


LPDISPATCH CAutoDocumentDefault::GetApplication() 
{
	NoDoc();
	return m_pDoc->GetApplication();
}


LPDISPATCH CAutoDocumentDefault::GetParent() 
{
	NoDoc();
	return m_pDoc->GetParent() ;
}


BSTR CAutoDocumentDefault::GetPath() 
{
	NoDoc();
	return m_pDoc->GetPath();
}


BOOL CAutoDocumentDefault::GetSaved() 
{
	NoDoc();
	return m_pDoc->GetSaved();
}

void CAutoDocumentDefault::SetSaved(BOOL bNewValue) 
{
	NoDoc();
	m_pDoc->SetSaved(bNewValue);
}

BOOL CAutoDocumentDefault::GetActive() 
{
	NoDoc();
	return m_pDoc->GetActive() ;
}

void CAutoDocumentDefault::SetActive(BOOL bNewValue) 
{
	NoDoc();
	m_pDoc->SetActive(bNewValue) ;
}


DsSaveStatus CAutoDocumentDefault::Close(const VARIANT FAR& longSaveChanges)
{
	NoDoc();
	return m_pDoc->Close(longSaveChanges); 
}


DsSaveStatus CAutoDocumentDefault::Save(const VARIANT FAR& vtFilename, const VARIANT FAR& longSaveChanges) 
{
	NoDoc();
	return m_pDoc->Save(vtFilename, longSaveChanges) ;
}

BSTR CAutoDocumentDefault::GetType() 
{
	CString strResult("Generic");
	return strResult.AllocSysString();
}


BOOL CAutoDocumentDefault::GetReadOnly() 
{
	NoDoc();
	return m_pDoc->ReadOnly();
}

void CAutoDocumentDefault::SetReadOnly(BOOL bReadOnly) 
{
	NoDoc();
	m_pDoc->SetReadOnly(bReadOnly);
}


LPDISPATCH CAutoDocumentDefault::GetActiveWindow() 
{
	NoDoc();
	return m_pDoc->ActiveWindow();
}

LPDISPATCH CAutoDocumentDefault::GetWindows() 
{
	NoDoc() ;
	return m_pDoc->GetWindows() ;
}


BOOL CAutoDocumentDefault::Redo() 
{
	// This is not and will not be implemented...return error!
	DsThrowCannedOleDispatchException(E_NOTIMPL);
	return FALSE;
}

BOOL CAutoDocumentDefault::Undo() 
{
	// This is not and will not be implemented...return error!
	DsThrowCannedOleDispatchException(E_NOTIMPL);
	return FALSE;
}

LPDISPATCH CAutoDocumentDefault::NewWindow() 
{
	// This is not and will not be implemented...return error!
	DsThrowCannedOleDispatchException(E_NOTIMPL);

	return NULL;
}

BOOL CAutoDocumentDefault::PrintOut() 
{
	// This is not and will not be implemented...return error!
	DsThrowCannedOleDispatchException(E_NOTIMPL);
	
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autodocs.h ===
// AutoDocs.h : header file
//
#ifndef __AUTODOCS_H__
#define __AUTODOCS_H__

#include <utilauto.h>

////////////////////////////////////////////////////////////////////////////////////

class CAutoDocuments : public CAutoObj
{
	friend class CEnumVariantObjs;

	//	DECLARE_DYNACREATE(CAutoDocuments)
	DECLARE_DYNAMIC(CAutoDocuments)


// Attributes
public:
	// The collection will clean up the list. Not the caller.
	CAutoDocuments() ;
	virtual ~CAutoDocuments();

// Operations
public:
    DECLARE_DUAL_ERRORINFO()

	void DeleteCollection(); // Delete the collection and release all of its items. [@sync]
	void Sync() ;			 // Replaved current colleciton with a new up to date collection. [@sync]

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoDocuments)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDispatchList* m_pPtrlData;

	DS_BEGIN_DUAL_INTERFACE_PART(Documents)
		STDMETHOD(get_Count)(THIS_ long FAR* Count);
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppApplication);
		STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent);
		STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum);
		STDMETHOD(Item)(THIS_ VARIANT index, IDispatch * FAR* Item);
		STDMETHOD(SaveAll)(THIS_ VARIANT vtBoolPrompt,  DsSaveStatus FAR* pSaved) ;
		STDMETHOD(CloseAll)(THIS_ VARIANT vtSaveChanges, DsSaveStatus FAR* pSaved) ;
		STDMETHOD(Add)(THIS_ BSTR docType, VARIANT vtReserved, IDispatch * FAR* ppDocument) ;
		STDMETHOD(Open)(THIS_ BSTR filename, VARIANT vtDocType, VARIANT vtBoolReadOnly, IDispatch * FAR* ppDocument) ;
	DS_END_DUAL_INTERFACE_PART(Documents)

	DS_DECLARE_ENABLE_DUAL(CAutoDocuments, Documents)


	// Generated message map functions
	//{{AFX_MSG(CAutoDocuments)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	// Removed See DualImpl.doc | 	DECLARE_OLECREATE(CAutoDocuments)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoDocuments)
	afx_msg long GetCount();
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH Item(const VARIANT FAR& index);
	afx_msg LPDISPATCH Add(LPCTSTR docType, const VARIANT & vtReserved);
	afx_msg LPDISPATCH Open(LPCTSTR filename, const VARIANT FAR& doctype, const VARIANT FAR& readonly);
	//}}AFX_DISPATCH
	afx_msg LPUNKNOWN _NewEnum();
	afx_msg DsSaveStatus SaveAll(const VARIANT FAR& vtBoolPrompt);
	afx_msg DsSaveStatus CloseAll(const VARIANT FAR& vtLongSaveChanges);

	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif //__AUTODOCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autodocs.cpp ===
// AutoDocs.cpp : implementation file
//

#include "stdafx.h"

#include <utilauto.h>
#include "autoguid.h"
#include "AutoDocs.h"
#include "resource.h"

#include "autostat.h" // g_AutomationState - Internal automation code.


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Implementation of CAutoDocuments' dual interface

DELEGATE_GET(CAutoDocuments, Documents, Count, long)
DELEGATE_GET(CAutoDocuments, Documents, Application, IDispatch*)
DELEGATE_GET(CAutoDocuments, Documents, Parent, IDispatch*)

DELEGATE_ONE_PARAM_WITH_RETVAL(CAutoDocuments, Documents, SaveAll,  VARIANT, DsSaveStatus)
DELEGATE_ONE_PARAM_WITH_RETVAL(CAutoDocuments, Documents, CloseAll, VARIANT, DsSaveStatus)

STDMETHODIMP CAutoDocuments::XDocuments::Add(BSTR docType, VARIANT vtReserved, IDispatch ** ppDocument)
{
	METHOD_PROLOGUE(CAutoDocuments, Dispatch)
	
	TRY_DUAL(IID_IDocuments)
	{
		CString strDocType(docType);
		*ppDocument= pThis->Add(strDocType,vtReserved);
		return NOERROR;
	}
	CATCH_ALL_DUAL

}


STDMETHODIMP CAutoDocuments::XDocuments::get__NewEnum(IUnknown** _NewEnum)
{
	METHOD_PROLOGUE(CAutoDocuments, Dispatch)
	
	TRY_DUAL(IID_IDocuments)
	{
		*_NewEnum = pThis->_NewEnum();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


STDMETHODIMP CAutoDocuments::XDocuments::Item(VARIANT index, IDispatch* FAR* Item)
{
	METHOD_PROLOGUE(CAutoDocuments, Dispatch)
	
	TRY_DUAL(IID_IDocuments)
	{
		*Item = pThis->Item(index);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


STDMETHODIMP CAutoDocuments::XDocuments::Open(	BSTR filename, 
												VARIANT vtDocType, 
												VARIANT vtBoolReadOnly, 
												IDispatch** ppDocument) 
{
	METHOD_PROLOGUE(CAutoDocuments, Dispatch)
	
	TRY_DUAL(IID_IDocuments)
	{
		CString strFilename(filename);
		*ppDocument = pThis->Open(strFilename, vtDocType, vtBoolReadOnly);
		return NOERROR;
	}
	CATCH_ALL_DUAL

}




/////////////////////////////////////////////////////////////////////////////
// CAutoDocuments

//IMPLEMENT_DYNCREATE(CAutoDocuments, CAutoObj)
IMPLEMENT_DYNAMIC(CAutoDocuments, CAutoObj)

CAutoDocuments::CAutoDocuments() 
{
	EnableDualAutomation();
//	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	// We do not need to call Sync here, because the first
	// time that someone gets the item we will Sync.
	m_pPtrlData = NULL ;
}

CAutoDocuments::~CAutoDocuments()
{
	DeleteCollection() ; //[@sync]

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}


//
// Delete the contents of the collection. [@sync]
//
void CAutoDocuments::DeleteCollection()
{	
	if (m_pPtrlData != NULL)
	{
		POSITION pos = m_pPtrlData->GetHeadPosition();
		while (pos != NULL)
		{
			IDispatch* pDispatch = m_pPtrlData->GetNext(pos);
			ASSERT (pDispatch != NULL);
			pDispatch->Release() ;
		}

		// The collection is in charge of cleaning this up.
		delete m_pPtrlData ;

		m_pPtrlData = NULL ; 
	}
}

void CAutoDocuments::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CAutoObj::OnFinalRelease();
}

//
// This function is used to keep the internal pointer list in
// sync with the real world.
//
void CAutoDocuments::Sync()
{
	// Fill a pointer list with IDispatch* for each document.
	CDispatchList* pDispatchPtrList = new CDispatchList;

	// Iterate through the Doc Templates.
	POSITION posTemplate = theApp.GetFirstDocTemplatePosition() ;
	while (posTemplate != NULL)
	{
		CDocTemplate* pTemplate = theApp.GetNextDocTemplate(posTemplate);
		ASSERT(pTemplate != NULL) ;

		// Iterate through templates for the current Docs 
		POSITION posDoc = pTemplate->GetFirstDocPosition() ;
		while ( posDoc != NULL)
		{
			CPartDoc* pPartDoc = (CPartDoc*)pTemplate->GetNextDoc(posDoc) ;
			ASSERT(pPartDoc->IsKindOf(RUNTIME_CLASS(CPartDoc))) ;

			// Get the automation object for this document.
			IDispatch* pDispatch = pPartDoc->GetAutomationObject(TRUE) ;
			if (pDispatch != NULL)
			{
				pDispatchPtrList->AddTail(pDispatch);
			}
		}
	}

	// If there is already a collection, delete it.
	DeleteCollection() ;

	// Assign the new pointer.
	m_pPtrlData = pDispatchPtrList ;
}


BEGIN_MESSAGE_MAP(CAutoDocuments, CAutoObj)
	//{{AFX_MSG_MAP(CAutoDocuments)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoDocuments, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoDocuments)
	DISP_PROPERTY_EX(CAutoDocuments, "Count", GetCount, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoDocuments, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoDocuments, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoDocuments, "Item", Item, VT_DISPATCH, VTS_VARIANT)
	DISP_FUNCTION(CAutoDocuments, "SaveAll", SaveAll, VT_I4, VTS_VARIANT)
	DISP_FUNCTION(CAutoDocuments, "CloseAll", CloseAll, VT_I4, VTS_VARIANT)
	DISP_FUNCTION(CAutoDocuments, "Add", Add, VT_DISPATCH, VTS_BSTR VTS_VARIANT)
	DISP_FUNCTION(CAutoDocuments, "Open", Open, VT_DISPATCH, VTS_BSTR VTS_VARIANT VTS_VARIANT)
	DISP_DEFVALUE(CAutoDocuments, "Item")
	//}}AFX_DISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoDocuments, "_NewEnum", DISPID_NEWENUM, _NewEnum, SetNotSupported, VT_UNKNOWN)
END_DISPATCH_MAP()

/* REMOVE per DualImpl.Doc
// Note: we add support for IID_IAutoDocuments to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {E9EB1AE1-89A8-11CF-9BE8-00A0C90A632C}
static const IID IID_IAutoDocuments =
{ 0xe9eb1ae1, 0x89a8, 0x11cf, { 0x9b, 0xe8, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c } };

*/

BEGIN_INTERFACE_MAP(CAutoDocuments, CAutoObj)
	INTERFACE_PART(CAutoDocuments, IID_IDispDocuments, Dispatch)
	INTERFACE_PART(CAutoDocuments, IID_IDocuments, Dispatch)
    DUAL_ERRORINFO_PART(CAutoDocuments)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CAutoDocuments, IID_IDocuments)
DS_IMPLEMENT_ENABLE_DUAL(CAutoDocuments, Documents)
DS_DELEGATE_DUAL_INTERFACE(CAutoDocuments, Documents)


// {E9EB1AE2-89A8-11CF-9BE8-00A0C90A632C}
// Removed See DualImpl.doc | IMPLEMENT_OLECREATE(CAutoDocuments, "SHELL.AUTODOCUMENTS", 0xe9eb1ae2, 0x89a8, 0x11cf, 0x9b, 0xe8, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c)

/////////////////////////////////////////////////////////////////////////////
// CAutoDocuments message handlers

long CAutoDocuments::GetCount() 
{
	Sync() ;
	return m_pPtrlData->GetCount();
}

LPUNKNOWN CAutoDocuments::_NewEnum() 
{
	Sync() ;

	CEnumVariantObjs* pEnumVariant = new CEnumVariantObjs(m_pPtrlData);
	
	if (pEnumVariant == NULL)
		DsThrowCannedOleDispatchException(E_OUTOFMEMORY);

	// We don't QueryInterface, since we don't want the IEnumVARIANT
	//  AddRef'd.  The "new CEnumVariantObjs" above already AddRefs it for
	//  us.
	return &pEnumVariant->m_xEnumVariant;
}

LPDISPATCH CAutoDocuments::Item(const VARIANT FAR& vtIndex) 
{
	Sync() ;

	BOOL bFoundDoc = FALSE ;
	IDispatch* pIDispatch;
	
	IDispatch* pDispatchNoPath = NULL ; // If we compare two filenames and they make by name but not fullname, we set this.

	// Covert the index to a filename.
	CString strFilename;
	CString strDefault("") ;
	HRESULT hr = ::ConvertVariantToCString(vtIndex, strFilename, strDefault, FALSE ) ;
	if (hr == S_FALSE)
	{
		// Parameter is optional and is not supplied, so use the default.
		// Return a pointer to this collection.
		return GetIDispatch(TRUE) ;
	}
	else if (hr == S_OK)
	{

		// We have a filename. There are several possibilities:
		// 1. A fullpath.
		// 2. Just a fileName.
		// 3. A relative path.
		
		// Convert the filename/relative filename into a full pathname.
 		CPath pathname;
		pathname.Create(strFilename); 

		// Get just the filename part.
		CString strName(pathname.GetFileName()) ;

		// Set up for the loop
		IGenericDocument* pIDocument;

		// Cycle through the 
		POSITION pos = m_pPtrlData->GetHeadPosition();
		while ( (pos != NULL) && (bFoundDoc == FALSE))
		{
			// Get a pointer to one of our documents.
			IDispatch* pPosDispatch = m_pPtrlData->GetNext(pos);
			ASSERT (pPosDispatch != NULL);

			// Ask the document for its IDocument interface.			 
			HRESULT hr = pPosDispatch->QueryInterface(IID_IGenericDocument, (void**)&pIDocument) ; 
			ASSERT(SUCCEEDED(hr)) ;

			// Ask for the fullname!
			BSTR bstrPosFullname = SysAllocStringLen(NULL, 256) ;
			hr = pIDocument->get_FullName(&bstrPosFullname);
			ASSERT(SUCCEEDED(hr)) ;

			// 
			if (::SysStringLen(bstrPosFullname) == 0)
			{
				// If there is no title, go to next document.
				// Release the string.
				::SysFreeString(bstrPosFullname) ;
				pIDocument->Release();
				continue ;
			}

			// Put it into a CString.
			CString strPosFullname ;
			strPosFullname = bstrPosFullname ;
			
			// Release the string.
			::SysFreeString(bstrPosFullname) ;
	
			// Release the pointer.
			pIDocument->Release() ;

			// Put it into a path...
			CPath PosPathname;
			PosPathname.Create(strPosFullname); 

			// Are they equal?
			if (pathname == PosPathname)
			{
				// We have found our document.
				pIDispatch = pPosDispatch ;
				bFoundDoc = TRUE;
			}
			else if (pDispatchNoPath == NULL)
			{
				// The two documents do not make by Fullname. However, they may
				// match by name alone. If they do match by name, set pDispatchNoPath.
				// However, keep looking for an exact match.
				if (strName.CompareNoCase(PosPathname.GetFileName()) == 0)
				{
					pDispatchNoPath = pPosDispatch ;
				}
			}			
		}
	}
	if (pDispatchNoPath && !bFoundDoc)
	{
		// So, the fullname didn't match, but a filename did.
		pIDispatch = pDispatchNoPath ;
		bFoundDoc = TRUE;
	}

	if (!bFoundDoc)
	{
		// Converting to a BSTR failed or the filename didn't exist.

		// So attempt converting to an index.
		long lIndex ;
		hr = ::ConvertVariantToLong(vtIndex, lIndex, 0, FALSE) ;
		if ( hr == S_FALSE || lIndex == 0)
		{
			// 0 is an illegal value.
			DsThrowShellOleDispatchException(DS_E_CANNOT_FIND_DOCUMENT) ;
		}


	    // Find the IDispatch pointer in the array.
		POSITION pos = m_pPtrlData->FindIndex(lIndex - 1);
		if (pos == NULL)
		{
			DsThrowShellOleDispatchException(DS_E_CANNOT_FIND_DOCUMENT) ;
		}
		// Get item from array
		pIDispatch = m_pPtrlData->GetAt(pos);
		ASSERT (pIDispatch != NULL);

		bFoundDoc = TRUE ;
	}

	pIDispatch->AddRef();
	return pIDispatch;
}

LPDISPATCH CAutoDocuments::GetApplication() 
{
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}



LPDISPATCH CAutoDocuments::GetParent() 
{
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}


DsSaveStatus CAutoDocuments::SaveAll(const VARIANT FAR& vtBoolPrompt) 
{
	// Set up the automation state.
	g_AutomationState.SetPromptState(vtBoolPrompt) ;

	// Save all of the documents.
	BOOL bResult = theApp.SaveAll(FALSE, FILTER_DEBUG);

	// Return if the save was canceled. (HandleError resets status.)
	DsSaveStatus status = g_AutomationState.SavePromptResult() ;		
	
	// Handle errors caught by the automation state. Cleans up the state.
	g_AutomationState.HandleError() ;
	
	// Handle errors not placed in the automation state.
	if (!bResult && status == dsSaveSucceeded)
	{
		// No error, but no document.
		TRACE0("CAutoDocuments::SaveAll - No Error reported.") ;
		DsThrowShellOleDispatchException(DS_E_UNKNOWN) ;
	}

	return status ;

}

DsSaveStatus CAutoDocuments::CloseAll(const VARIANT FAR& vtLongSaveChanges) 
{
	// Convert the variant into a valid automation state.
	g_AutomationState.SaveChanges(vtLongSaveChanges);
	
	// get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	// Attempt to close all windows
	pMainFrame->OnWindowCloseAll() ;

	// Return if the save was canceled. (HandleError resets status.)
	DsSaveStatus status = g_AutomationState.SavePromptResult() ;		

	// Handle errors caught by the automation state. Cleans up the state.
	g_AutomationState.HandleError() ;

	// Return if the save was canceled.
	return status ;
}

//
// The Add method creates a new file and adds it to the current
// Documents collection.
//
LPDISPATCH CAutoDocuments::Add(LPCTSTR docType, const VARIANT & vtReserved) 
{
	CDocTemplate* pTemplate = theApp.GetTemplate(docType);
	if (pTemplate == NULL)
	{
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}

	// Turn UI off.
	g_AutomationState.Reset() ;
	g_AutomationState.DisableUI();

	// Attempt to create the document.
	CDocument* pDoc = pTemplate->OpenDocumentFile(NULL);	

	// Handle errors caught by the automation state. Cleans up the state.
	g_AutomationState.HandleError() ;

	// Handle silient errors.
	if (pDoc == NULL)
	{
		// No error, but no document.
		TRACE0("CAutoDocuments::Add - No Error reported.") ;
		DsThrowShellOleDispatchException(DS_E_UNKNOWN) ;
	}
	
	// Get the automation object for this doc.  AddRef
	//  once to put it in our list
	ASSERT_KINDOF(CPartDoc, pDoc);
	LPDISPATCH pDispDoc = ((CPartDoc*)pDoc)->GetAutomationObject(TRUE);

	return pDispDoc;
}

//
// The Open member function Opens a file and adds it to the currenct
// Documents collection.
//
LPDISPATCH CAutoDocuments::Open(LPCTSTR filename,			// Filename of file to open.
								const VARIANT FAR& vstrDocType, // String representing the type of document to open.
								const VARIANT FAR& vboolReadonly) // File is opened readonly if True.
{
	// Covert the vstrDoctype to a string.
	CString doctype ;
	CString strDefault("Auto") ;
	ConvertVariantToCString(vstrDocType, doctype, strDefault) ;

	// Covert the varient vboolReadonly to a real bool.
	BOOL readonly;
	::ConvertVariantToBOOL(vboolReadonly, readonly, FALSE) ;

	CDocTemplate* pTemplate = NULL ;
	if (doctype.CompareNoCase(_T("Auto")) != 0)
	{
		// Only get the template if the doctype is NOT "auto".
	 	pTemplate = theApp.GetTemplate(doctype);
		if (pTemplate == NULL)
		{
			DsThrowCannedOleDispatchException(E_INVALIDARG);
		}
	}

	//
	// The start of the real work.
	//
	// Turn UI off.
	g_AutomationState.Reset() ;
	g_AutomationState.DisableUI();

	// We do not use OpenDocumentFile, because pTemplate may be NULL if
	// the user specifies "Auto" for docType.
	CDocument* pDoc = theApp.OpenFile(pTemplate, filename, readonly) ;

	// Handle errors caught by the automation state. Cleans up the state.
	g_AutomationState.HandleError() ;

	if (pDoc == NULL)
	{
		// No error, but no document.
		TRACE0("CAutoDocuments::Open - No Error reported.") ;
		DsThrowShellOleDispatchException(DS_E_UNKNOWN); 
	}

	// Get the automation object for this doc.  AddRef
	//  once to put it in our list
	ASSERT_KINDOF(CPartDoc, pDoc);
	LPDISPATCH pDispDoc = ((CPartDoc*)pDoc)->GetAutomationObject(TRUE);

	return pDispDoc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autocol.cpp ===
// autocol.cpp : implementation file
//

#include "stdafx.h"
#include <utilauto.h>
#include "autoguid.h"
//#include <dualimpl.h>
//#include <autocol.h>
//#include <shlaguid.h>

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// 4 Apr 96 - Changed to iterate a list of IDispatch*'s instead of CAutoObj's pointers
//

/////////////////////////////////////////////////////////////////////////////
// This is provided as an example collection, and can also be used directly
//  if no changes need to be made to the members.
// Please read the usage directions at the top of ide\include\autocol.h
//  before using.

/////////////////////////////////////////////////////////////////////////////
// CEnumVariantObjs

IMPLEMENT_DYNAMIC(CEnumVariantObjs, CCmdTarget)

CEnumVariantObjs::CEnumVariantObjs(CDispatchList* pPtrlData)
{
	ASSERT( pPtrlData != NULL) ;
	//@sync - m_pPtrlData = pPtrlData;
	// In order to support live collections, we need to actually
	// copy the collection here and delete it below in the constructor.

	// Create a new array.
	m_pPtrlData = new CDispatchList;

	// Copy data from external array to internal array.
	POSITION pos = pPtrlData->GetHeadPosition();
	while (pos != NULL)
	{
		IDispatch* pDispatch = pPtrlData->GetNext(pos);
		ASSERT (pDispatch != NULL);
		if (pDispatch != NULL) //Defensive
		{
			// AddRef pointer
			pDispatch->AddRef() ;
			// Put into array.
			m_pPtrlData->AddTail(pDispatch) ;
		}
	}

	m_posCurrent = m_pPtrlData->GetHeadPosition();
	AfxOleLockApp();
}

CEnumVariantObjs::~CEnumVariantObjs()
{
	ASSERT(m_pPtrlData != NULL);

	POSITION pos = m_pPtrlData->GetHeadPosition();
	while (pos != NULL)
	{
		IDispatch* pDispatch = m_pPtrlData->GetNext(pos);
		ASSERT (pDispatch != NULL);
		pDispatch->Release() ;
	}
	// The collection is in charge of cleaning this up.
	delete m_pPtrlData ;
	
	AfxOleUnlockApp();
}

void CEnumVariantObjs::OnFinalRelease()
{
	// When the last reference for an automation object is released
	//	OnFinalRelease is called.  This implementation deletes the 
	//	object.  Add additional cleanup required for your object before
	//	deleting it from memory.
	CCmdTarget::OnFinalRelease();
}

STDMETHODIMP_(ULONG) CEnumVariantObjs::XEnumVariant::AddRef()
{	
	METHOD_PROLOGUE(CEnumVariantObjs, EnumVariant)
	return pThis->ExternalAddRef() ;
}	

STDMETHODIMP_(ULONG) CEnumVariantObjs::XEnumVariant::Release()
{	
	METHOD_PROLOGUE(CEnumVariantObjs, EnumVariant)
	return pThis->ExternalRelease() ;
}	

STDMETHODIMP CEnumVariantObjs::XEnumVariant::QueryInterface
	(REFIID iid, void FAR* FAR* ppvObj)
{	
	METHOD_PROLOGUE(CEnumVariantObjs, EnumVariant)
	return (HRESULT)pThis->ExternalQueryInterface( (void FAR*)&iid, ppvObj) ;
}	

// IEnumVariant::Next
// 
STDMETHODIMP CEnumVariantObjs::XEnumVariant::Next
	(ULONG celt, VARIANT FAR* rgvar, ULONG FAR* pceltFetched)
	// pceltFetched may be NULL!!  We must take cases on whether it's
	//  NULL.
{
	METHOD_PROLOGUE(CEnumVariantObjs, EnumVariant)

	HRESULT hr = S_OK;
	ULONG	l ;

	// pceltFetched can legally be NULL, and if it's not,
	//  *pceltFetched can still be 0!  We must be kind to our caller
	if (pceltFetched != NULL)
		*pceltFetched = 0;

	for (l=0; l < celt; l++)
		VariantInit( &rgvar[l] ) ;

	// Retrieve the next celt elements.
	for (l = 0; pThis->m_posCurrent != NULL && celt != 0; l++, celt--)
	{	
		IDispatch* pObj = (IDispatch*) pThis->m_pPtrlData->GetNext( pThis->m_posCurrent ) ;
		/*DER 12-Apr-96 changed to store IDispatch pointers 
		CAutoObj* pObj = (CAutoObj*) pThis->m_pPtrlData->GetNext( pThis->m_posCurrent ) ;
		ASSERT_KINDOF(CAutoObj, pObj);
		*/
		pObj->AddRef() ;

		rgvar[l].vt = VT_DISPATCH;
		rgvar[l].pdispVal = pObj ; //DER 12-Apr96 - Changed for IDispatch pointers pObj->GetIDispatch(TRUE);
		if (pceltFetched != NULL)
		   (*pceltFetched)++ ;
	}
	
	if (celt != 0)
		hr = S_FALSE ;

	return hr ;
}

// IEnumVariant::Skip
//
STDMETHODIMP CEnumVariantObjs::XEnumVariant::Skip(unsigned long celt) 
{
	METHOD_PROLOGUE(CEnumVariantObjs, EnumVariant)

	while (pThis->m_posCurrent != NULL && celt--)
		pThis->m_pPtrlData->GetNext( pThis->m_posCurrent ) ;
	
	return (celt == 0 ? S_OK : S_FALSE) ;
}

STDMETHODIMP CEnumVariantObjs::XEnumVariant::Reset()
{
	METHOD_PROLOGUE(CEnumVariantObjs, EnumVariant)

	pThis->m_posCurrent = pThis->m_pPtrlData->GetHeadPosition();
	
	return S_OK;
}

STDMETHODIMP CEnumVariantObjs::XEnumVariant::Clone(IEnumVARIANT** ppenum) 
{
	METHOD_PROLOGUE(CEnumVariantObjs, EnumVariant)	 

	CEnumVariantObjs* pEnumVariant = new CEnumVariantObjs(pThis->m_pPtrlData) ;
	if (pEnumVariant)
	{
		pEnumVariant->m_posCurrent = pThis->m_posCurrent ;
		return S_OK;
	}
	else
		return E_OUTOFMEMORY;
}


BEGIN_MESSAGE_MAP(CEnumVariantObjs, CCmdTarget)
	//{{AFX_MSG_MAP(CEnumVariantObjs)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BEGIN_INTERFACE_MAP(CEnumVariantObjs, CCmdTarget)
	INTERFACE_PART(CEnumVariantObjs, IID_IEnumVARIANT, EnumVariant)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Implementation of CAutoCollection's dual interface

STDMETHODIMP CAutoCollection::XDualObjs::get_Count(long* Count)
{
	METHOD_PROLOGUE(CAutoCollection, Dispatch)
	
	TRY_DUAL(IID_IDualObjs)
	{
		*Count = pThis->GetCount();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoCollection::XDualObjs::get__NewEnum(IUnknown** _NewEnum)
{
	METHOD_PROLOGUE(CAutoCollection, Dispatch)
	
	TRY_DUAL(IID_IDualObjs)
	{
		*_NewEnum = pThis->_NewEnum();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


STDMETHODIMP CAutoCollection::XDualObjs::Item(VARIANT index, IDispatch** Item)
{
	METHOD_PROLOGUE(CAutoCollection, Dispatch)
	
	TRY_DUAL(IID_IDualObjs)
	{
		*Item = pThis->Item(index);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

/////////////////////////////////////////////////////////////////////////////
// CAutoCollection


IMPLEMENT_DYNAMIC(CAutoCollection, CAutoObj)

CAutoCollection::CAutoCollection(CDispatchList* pPtrlData)
{
	EnableDualAutomation();
	AfxOleLockApp();
	m_pPtrlData = pPtrlData;
}

CAutoCollection::~CAutoCollection()
{
	// DER 12 Apr 96 - Release the pointers in the collection. (?)
	POSITION pos = m_pPtrlData->GetHeadPosition();
	while (pos != NULL)
	{
		IDispatch* pDispatch = m_pPtrlData->GetNext(pos);
		ASSERT (pDispatch != NULL);
		pDispatch->Release() ;
	}
	// delete the collection itself
	delete m_pPtrlData ;
		
	AfxOleUnlockApp();
}

void CAutoCollection::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.	Add additional cleanup required for your
	// object before calling the base class.

	CAutoObj::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CAutoCollection, CAutoObj)
	//{{AFX_MSG_MAP(CAutoCollection)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoCollection, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoCollection)
	DISP_PROPERTY_EX(CAutoCollection, "Count", GetCount, SetNotSupported, VT_I4)
	DISP_FUNCTION(CAutoCollection, "Item", Item, VT_DISPATCH, VTS_VARIANT)
	DISP_DEFVALUE(CAutoCollection, "Item")
	//}}AFX_D