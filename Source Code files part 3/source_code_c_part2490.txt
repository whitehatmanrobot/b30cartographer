		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_S1SEGS:  return TSTR(GetString(IDS_RB_S1SEGS));
		case PB_S2SEGS:  return TSTR(GetString(IDS_RB_S2SEGS));
		case PB_S3SEGS:  return TSTR(GetString(IDS_RB_S3SEGS));
		case PB_HSEGS:  return TSTR(GetString(IDS_RB_HSEGS));
		default: return TSTR(_T(""));		
		}
	}

RefTargetHandle PrismObject::Clone(RemapDir& remap) 
	{
	PrismObject* newob = new PrismObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\hose.cpp ===
#include "solids.h"
#include "spline3d.h"

#include "interpik.h"
#include "texutil.h"

#define MAX_PATH_LENGTH 257
#define MAX_STRING_LENGTH  256
#define TESTLIMIT 100

#define A_RENDER			A_PLUGIN1

const float PIover2=1.570796327f;
const float QuarterPI=0.785398163f;
static int controlsInit = FALSE;
const Point3 ZAxis=Point3(0.0f,0.0f,1.0f);
#define fourninthPI (4.0f/9.0f)*PI
#define oneeightPI	(1.0f/18.0f)*PI

static Class_ID HOSE_CLASS_ID(0x69f96a5d, 0x235c430a);

#define PBLK		0
#define CUSTNODE 	1
#define CUSTNODE2 	2

const float EPSILON=0.0001f;
const Point3 Ones=Point3(1.0f,1.0f,1.0f);

class HosePickOperand;
class HoseObject;

class HoseObject : public SimpleObject {
	public:
		static IParamMap *pmapParam;
		HoseObject();
		~HoseObject();
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
	
		static HoseObject *editOb;
		INode *custnode2,*custnode,*thisnode;
		TSTR custname,custname2;
		static IObjParam *ip;
		Matrix3 S;
		static HWND hParams;
		ICustButton *iPick,*iPick2;

		static BOOL creating;
		static HosePickOperand pickCB;
		BOOL cancelled;
		int NumRefs() {return 3;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// From BaseObject
		TCHAR *GetObjectName();
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		

		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		
		// Animatable methods		
		Class_ID ClassID() {return HOSE_CLASS_ID;} 
		void DeleteThis() {delete this;}
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void MapKeys(TimeMap *map,DWORD flags);
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		// From SimpleObject
		void MakeSaveVertex(Point3 *SaveVertex,int NvertsPerRing,int nfillets,int nsides,int wtype,TimeValue t);
		void BuildMesh(TimeValue t);

		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);

		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void ShowName();
		void ShowName2();
		void ShowNames();
		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);
};

//--- ClassDescriptor and class vars ---------------------------------

class HoseClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new HoseObject;}
	const TCHAR *	ClassName(); 
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return HOSE_CLASS_ID;}
	const TCHAR* 	Category(); 
	void			ResetClassParams(BOOL fileReset);
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};

static HoseClassDesc HoseDesc;
ClassDesc* GetHoseDesc() {return &HoseDesc;}

class HosePickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		HoseObject *po;
		int dodist,repi;

		HosePickOperand() {po=NULL;dodist=-1;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};

IParamMap *HoseObject::pmapParam;
IObjParam *HoseObject::ip    = NULL;
BOOL HoseObject::creating    = FALSE;
HWND HoseObject::hParams		=NULL;
HosePickOperand HoseObject::pickCB;
HoseObject *HoseObject::editOb	=NULL;

//--- Parameter map/block descriptors -------------------------------

#define SIZEFACTOR (float(TIME_TICKSPERSEC)/120.0f)

#define PB_ENDSMETHOD		0
#define PB_NOREFLENGTH		1
#define PB_SEGMENTS			2
#define PB_SMOOTH			3
#define PB_RENDERABLE		4

#define PB_WIRETYPE			5
#define PB_RNDDIA			6
#define PB_RNDSIDES			7

#define PB_RECTWIDTH		8
#define PB_RECTDEPTH		9
#define PB_RECTFILLET		10
#define PB_RECTFILLETSIDES	11
#define PB_RECTROTANGLE		12

#define PB_DSECWIDTH		13
#define PB_DSECDEPTH		14
#define PB_DSECFILLET		15
#define PB_DSECFILLETSIDES	16
#define PB_DSECRNDSIDES		17
#define PB_DSECROTANGLE		18

#define PB_MAPMEMAPME		19

#define PB_FLEXON			20
#define PB_FLEXSTART		21
#define PB_FLEXSTOP			22
#define PB_FLEXCYCLES		23
#define PB_FLEXDIAMETER		24

#define PB_TENSION1			25
#define PB_TENSION2			26

static int endmethodIDs[] = {IDC_SPRING_REFS,IDC_SPRING_DIMS};

const float WIREMIN = 0.0f;
const float FILLETMIN = 0.0f;

#define ROUND	0
#define RECT	1
#define DSECT	2

static int wiresectionIDs[] = {IDC_SPRING_ROUNDWIRE,IDC_SPRING_RECTWIRE,IDC_SPRING_DSECTIONWIRE};

static int smoothtypeIDs[] = {IDC_SPRING_SMALL,IDC_SPRING_SMNONE,IDC_SPRING_SMSIDES,IDC_SPRING_SMSEGS};

//
// Parameters

static ParamUIDesc descHoseParam1[] = {

	// End Method
	ParamUIDesc(PB_ENDSMETHOD,TYPE_RADIO,endmethodIDs,2),

	// No reference version Length
	ParamUIDesc(
		PB_NOREFLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_LENGTH,IDC_SPRING_LENGTHSPIN,
		0.0f,99999999.0f,
		0.1f),	
		
	// Segments along coils
	ParamUIDesc(
		PB_SEGMENTS,
		EDITTYPE_INT,
		IDC_SPRING_COILSEGS,IDC_SPRING_COILSEGSSPIN,
		3.0f,100000.0f,
		1.0f),	
		
	// Smooth Hose
	ParamUIDesc(PB_SMOOTH,TYPE_RADIO,smoothtypeIDs,4),			

	// IsRenderable?
	ParamUIDesc(PB_RENDERABLE,TYPE_SINGLECHEKBOX,IDC_SPRING_RENDERTHIS),			

	// Wire Type
	ParamUIDesc(PB_WIRETYPE,TYPE_RADIO,wiresectionIDs,3),

	// Wire Diameter
	ParamUIDesc(
		PB_RNDDIA,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_RNDWIREDIA,IDC_SPRING_RNDWIREDIASPIN,
		WIREMIN,99999999.0f,
		0.1f),	

	// Sides around wire
	ParamUIDesc(
		PB_RNDSIDES,
		EDITTYPE_INT,
		IDC_SPRING_RNDWIRESIDES,IDC_SPRING_RNDWIRESIDESSPIN,
		3.0f,100.0f,
		1.0f),	
		
	// Wire Width
	ParamUIDesc(
		PB_RECTWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_RECTWIREWID,IDC_SPRING_RECTWIREWIDSPIN,
		WIREMIN,99999999.0f,
		0.1f),	

	// Wire Depth
	ParamUIDesc(
		PB_RECTDEPTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_RECWIREDEPTH,IDC_SPRING_RECWIREDEPTHSPIN,
		WIREMIN,99999999.0f,
		0.1f),	

	// Fillet Size
	ParamUIDesc(
		PB_RECTFILLET,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_RECWIREFILLET,IDC_SPRING_RECWIREFILLETSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Fillet Sides
	ParamUIDesc(
		PB_RECTFILLETSIDES,
		EDITTYPE_INT,
		IDC_SPRING_RECWIREFILLETSIDES,IDC_SPRING_RECWIREFILLETSIDESSPIN,
		0.0f,100.0f,
		1.0f),	

	// Rect Wire Rotation Angle
	ParamUIDesc(
		PB_RECTROTANGLE,
		EDITTYPE_FLOAT,
		IDC_SPRING_RECTROT,IDC_SPRING_RECTROTSPIN,
		-99999999.0f,99999999.0f,
		1.0f,
		stdAngleDim),	

	// D Wire Width
	ParamUIDesc(
		PB_DSECWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_DWIREWID,IDC_SPRING_DWIREWIDSPIN,
		WIREMIN,99999999.0f,
		0.1f),	

	// D Wire Depth
	ParamUIDesc(
		PB_DSECDEPTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_DWIREDEPTH,IDC_SPRING_DWIREDEPTHSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// D Fillet Size
	ParamUIDesc(PB_DSECFILLET,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_DWIREFILLET,IDC_SPRING_DWIREFILLETSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// D Fillet Sides
	ParamUIDesc(
		PB_DSECFILLETSIDES,
		EDITTYPE_INT,
		IDC_SPRING_DWIREFILLETSIDES,IDC_SPRING_DWIREFILLETSIDESSPIN,
		0.0f,100.0f,
		1.0f),	
		
	// D Round Sides
	ParamUIDesc(
		PB_DSECRNDSIDES,
		EDITTYPE_INT,
		IDC_SPRING_DWIRERNDSIDES,IDC_SPRING_DWIRERNDSIDESSPIN,
		2.0f,100.0f,
		1.0f),	

	// D Wire Rotation Angle
	ParamUIDesc(
		PB_DSECROTANGLE,
		EDITTYPE_FLOAT,
		IDC_SPRING_DROT,IDC_SPRING_DROTSPIN,
		-99999999.0f,99999999.0f,
		1.0f,
		stdAngleDim),	

	// Generate text coords
	ParamUIDesc(PB_MAPMEMAPME,TYPE_SINGLECHEKBOX,IDC_SPRING_MAPME),			

	// Flex On
	ParamUIDesc(PB_FLEXON,TYPE_SINGLECHEKBOX,IDC_HOSE_FLEXON),			

	// Flex Start Position
	ParamUIDesc(
		PB_FLEXSTART,
		EDITTYPE_FLOAT,
		IDC_HOSE_FLEX1,IDC_HOSE_FLEX1SPIN,
		0.0f,50.0f,
		1.0f,
		stdPercentDim),	

	// Flex Stop Position
	ParamUIDesc(
		PB_FLEXSTOP,
		EDITTYPE_FLOAT,
		IDC_HOSE_FLEX2,IDC_HOSE_FLEX2SPIN,
		50.0f,100.0f,
		1.0f,
		stdPercentDim),	

	// Flex Cycles
	ParamUIDesc(
		PB_FLEXCYCLES,
		EDITTYPE_INT,
		IDC_HOSE_FLEXCYCLES,IDC_HOSE_FLEXCYCLESSPIN,
		1.0f,1000.0f,
		1.0f),	

	// Flex Diameter
	ParamUIDesc(
		PB_FLEXDIAMETER,
		EDITTYPE_FLOAT,
		IDC_HOSE_DIACHANGE,IDC_HOSE_DIACHANGESPIN,
		-50.0f,500.0f,
		1.0f,
		stdPercentDim),	

	// Spline Tension 1
	ParamUIDesc(
		PB_TENSION1,
		EDITTYPE_FLOAT,
		IDC_HOSE_TENSION1,IDC_HOSE_TENSION1SPIN,
		0.0f,1000.0f,
		1.0f),	

	// Spline Tension 2
	ParamUIDesc(
		PB_TENSION2,
		EDITTYPE_FLOAT,
		IDC_HOSE_TENSION2,IDC_HOSE_TENSION2SPIN,
		0.0f,1000.0f,
		1.0f),	
};

#define HOSEPARAMSDESC_LENGTH 27

ParamBlockDescID descHoseVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 }, // End Method
	{ TYPE_FLOAT, NULL, TRUE, 1 }, // No Ref Length
	{ TYPE_INT, NULL, TRUE, 2 }, // Coil Seg Count
	{ TYPE_INT, NULL, FALSE, 3 }, // Smooth Control
	{ TYPE_INT, NULL, FALSE, 4 }, // Renderable

	{ TYPE_INT, NULL, FALSE, 5 }, // Wire Section Type
	{ TYPE_FLOAT, NULL, TRUE, 6 }, // Round Wire Dia
	{ TYPE_INT, NULL, TRUE, 7 },  // Wire Sides
	{ TYPE_FLOAT, NULL, TRUE, 8 }, // Rect Wire Width
	{ TYPE_FLOAT, NULL, TRUE, 9 }, // Rect Wire Depth
	{ TYPE_FLOAT, NULL, TRUE, 10 }, // Rect Wire Fillet Size
	{ TYPE_INT, NULL, TRUE, 11 }, // Rect Wire Fillet Sides
	{ TYPE_FLOAT, NULL, TRUE, 12 }, // Rect Wire Rot Angle
	{ TYPE_FLOAT, NULL, TRUE, 13 }, // D Wire Width
	{ TYPE_FLOAT, NULL, TRUE, 14 }, // D Wire Depth
	{ TYPE_FLOAT, NULL, TRUE, 15 }, // D Wire Fillet Size
	{ TYPE_INT, NULL, TRUE, 16 }, // D Wire Fillet Sides
	{ TYPE_INT, NULL, TRUE, 17 }, // D Wire Round Sides
	{ TYPE_FLOAT, NULL, TRUE, 18 }, // D Wire Rotation Angle

	{ TYPE_INT, NULL, FALSE, 19 },  // gen tex coords
	{ TYPE_INT, NULL, FALSE, 20 },  // flex section on
	{ TYPE_FLOAT, NULL, TRUE, 21 },  // flex section start
	{ TYPE_FLOAT, NULL, TRUE, 22 },  // flex section stop
	{ TYPE_INT, NULL, TRUE, 23 },  // flex section cycles
	{ TYPE_FLOAT, NULL, TRUE, 24 },  // flex section diameter change

	{ TYPE_FLOAT, NULL, TRUE, 25 },  // tension 1
	{ TYPE_FLOAT, NULL, TRUE, 26 },  // tension 2
};

#define PBLOCK_HOSE_LENGTH	27

// Array of old versions
// static ParamVersionDesc versions[] = {ParamVersionDesc(descHoseVer0,24,0)};

#define NUM_OLDVERSIONS	0
#define CURRENT_VERSION	0

// Current version
static ParamVersionDesc curVersion(descHoseVer0,PBLOCK_HOSE_LENGTH,CURRENT_VERSION);


class CreateMHoseProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		HoseObject *SSBlizObject;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreateMHoseProc()
			{
			ignoreSelectionChange = FALSE;
			}
//		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


class CreateCPartRestoreNode : public RestoreObj {
	public:   		
		HoseObject *obj;
		TSTR name,namer;
		INode *save,*saver;
		CreateCPartRestoreNode(HoseObject *o) {
			obj = o; name=TSTR(o->custname);
			save=o->custnode;
			}
		void Restore(int isUndo)
		{ if (isUndo) { namer=TSTR(obj->custname);saver=obj->custnode;	}
		  obj->custname = name;
		  obj->custnode=save;
		  if (obj->hParams) obj->ShowName();
			}
		void Redo() 
		{ obj->custname = namer;
		  obj->custnode=saver;
		  if (obj->hParams) obj->ShowName();
		}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};

class CreateCPart2RestoreNode : public RestoreObj {
	public:   		
		HoseObject *obj;
		TSTR name,namer;
		INode *save,*saver;
		CreateCPart2RestoreNode(HoseObject *o) {
			obj = o; name=TSTR(o->custname2);
			save=o->custnode2;
			}
		void Restore(int isUndo)
		{ if (isUndo) { namer=TSTR(obj->custname2);	}
		  obj->custname2 = name;
		  obj->custnode2=save;
		  if (obj->hParams) obj->ShowName2();
			}
		void Redo() 
		{ obj->custname2 = namer;
		  obj->custnode2 = saver;
		  if (obj->hParams) obj->ShowName2();
		}
		TSTR Description() {return GetString(IDS_AP_COMPICK2);}
	};

#define CID_CREATEHOSEMODE	CID_USER +76

class CreateMHoseMode : public CommandMode {		
	public:		
		CreateMHoseProc proc;
		IObjParam *ip;
		HoseObject *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,HoseObject*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEHOSEMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreateMHoseMode theCreateMHoseMode;

void HoseClassDesc::ResetClassParams(BOOL fileReset)
	{
	}

RefResult CreateMHoseProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( SSBlizObject && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (SSBlizObject && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (SSBlizObject->creating) 
						{  theCreateMHoseMode.JumpStart(SSBlizObject->ip,SSBlizObject);
							createInterface->SetCommandMode(&theCreateMHoseMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				SSBlizObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				SSBlizObject  = NULL;				
				CloudNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreateMHoseProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	SSBlizObject       = NULL;
	CreateNewObject();
	}

void CreateMHoseProc::CreateNewObject()
	{
	SSBlizObject = (HoseObject*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
	// Start the edit params process
	if ( SSBlizObject ) {
		SSBlizObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		SSBlizObject->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

void CreateMHoseProc::End()
{ if ( SSBlizObject ) 
	{ 
 #ifdef _OSNAP
		SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		SSBlizObject->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a Hose view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete SSBlizObject;
			SSBlizObject = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		}  else if ( CloudNode ) 
		{	theHold.Suspend();
			DeleteReference(0);  // sets cloudNode = NULL
			theHold.Resume();}
	}
}

void CreateMHoseMode::JumpStart(IObjParam *i,HoseObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

int HoseClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateMHoseMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateMHoseMode);
	return TRUE;
	}

int HoseClassDesc::EndCreate(Interface *i)
	{
	theCreateMHoseMode.End();
	i->RemoveMode(&theCreateMHoseMode);
	return TRUE;
	}

int CreateMHoseProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res=TRUE;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( SSBlizObject );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
#ifdef _OSNAP
						SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				   		SSBlizObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						// Get rid of the reference.
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}
						// new object
						CreateNewObject();   // creates SSBlizObject
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( SSBlizObject);
					SSBlizObject->thisnode=CloudNode;
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = SSBlizObject->GetCreateMouseCallBack();
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();
					mat.IdentityMatrix();
				default:				
					if (createCB) {						
						res = createCB->proc(vpx,msg,point,flag,m,mat);
						createInterface->SetNodeTMRelConstPlane(CloudNode,mat);

						if (res==CREATE_ABORT)
							goto abort;
						if (res==CREATE_STOP)
						    theHold.Accept(GetString(IDS_AP_CREATE));	 
						
						createInterface->RedrawViews(createInterface->GetTime());   //DS
						}

					break;
					
				}			
			break;

		case MOUSE_MOVE:
			if (createCB) {				
				res = createCB->proc(vpx,msg,point,flag,m,mat);
				createInterface->SetNodeTMRelConstPlane(CloudNode,mat);
				if (res==CREATE_ABORT) 
					goto abort;
				if (res==CREATE_STOP)
					theHold.Accept(GetString(IDS_AP_CREATE));	// TH
				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_INTERACTIVE);		//DS		
				}
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: 
	if (createCB)
	{ res = createCB->proc(vpx,msg,point,flag,m,mat);
	  createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
	  if (res==CREATE_ABORT)
	      goto abort;
	  if (res==CREATE_STOP)
	  {
#ifdef _OSNAP
         SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	    theHold.Accept(GetString(IDS_AP_CREATE));	
	  }
	  createInterface->RedrawViews(createInterface->GetTime()); 
		break;
	}
	abort:
		assert( SSBlizObject );
#ifdef _OSNAP
		SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		SSBlizObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);
		SSBlizObject=NULL;
		createInterface->RedrawViews(createInterface->GetTime());
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		break;
	
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		#ifdef _OSNAP  //PREVIEW SNAP
			if(createCB) {
				res = createCB->proc(vpx,msg,point,flag,m,mat);
			}
			else
			{
				assert( SSBlizObject );					
				createCB = SSBlizObject->GetCreateMouseCallBack();
			}
		#endif
		vpx->TrackImplicitGrid(m);
			break;
	}

	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
}
BOOL HoseObject::OKtoDisplay(TimeValue t) 
	{ return (mesh.getNumVerts()>1);
	}

static BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

BOOL HosePickOperand::Filter(INode *node)
{	if (node)
	{	ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
//		if (os.obj->IsParticleSystem() || os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) 
//		{	node = NULL;
//			return FALSE;
//		}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest())
		{	node = NULL;
			return FALSE;
		}
	}

	return node ? TRUE : FALSE;
}

BOOL HosePickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
{	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
//		if ((os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID)||(!IsGEOM(os.obj)))
//		{	node = NULL;
//			return FALSE;
//		}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest())
		{	node = NULL;
			return FALSE;
		}
	}
	return node ? TRUE : FALSE;
}

void HoseObject::ShowName()
{ TSTR name=(custnode ? custname : TSTR(GetString(IDS_AP_NONE)));
  SetWindowText(GetDlgItem(hParams, IDC_SPRING_OBJ1NAME), name);
}
void HoseObject::ShowName2()
{ TSTR name=(custnode2 ? custname2 : TSTR(GetString(IDS_AP_NONE)));
  SetWindowText(GetDlgItem(hParams, IDC_SPRING_OBJ2NAME), name);
}
void HoseObject::ShowNames()
{ ShowName();ShowName2();
}

BOOL HosePickOperand::Pick(IObjParam *ip,ViewExp *vpt)
{	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	nodes.SetCount(1);nodes[0]=node;
	theHold.Begin();
	if (dodist)
	{ theHold.Put(new CreateCPart2RestoreNode(po));
	  if (po->custnode2) po->ReplaceReference(CUSTNODE2,node,TRUE);
	  else po->MakeRefByID(FOREVER,CUSTNODE2,node);	
	  po->custname2 = TSTR(node->GetName());
	  // Automatically check show result and do one update
	  po->ShowName2();	
	}
	else
	{ theHold.Put(new CreateCPartRestoreNode(po));
	  if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	  else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	  po->custname = TSTR(node->GetName());
	  // Automatically check show result and do one update
	  po->ShowName();	
	}
	theHold.Accept(GetString(IDS_AP_COMPICK));
	po->pmapParam->Invalidate();
	ip->FlashNodes(&nodes);
	nodes.Resize(0);
	po->ivalid.SetEmpty();
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	if (po->creating) {
		theCreateMHoseMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreateMHoseMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {return TRUE;}
}

void HosePickOperand::EnterMode(IObjParam *ip)
{	ICustButton *iBut;
	if (dodist) 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT2));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,FALSE);
	}
	else 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT1));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,FALSE);
	}
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
}

void HosePickOperand::ExitMode(IObjParam *ip)
{	ICustButton *iBut;
	if (dodist) 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT2));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,TRUE);
	}
	else 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT1));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,TRUE);
	}
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
	dodist=-1;
    GetCOREInterface()->PopPrompt();
}

//-- ParticleDlgProc ------------------------------------------------

class HoseParamDlg : public ParamMapUserDlgProc {
	public:
		HoseObject *po;

		HoseParamDlg(HoseObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void BoundParams(BOOL ison);
		void FlexParams(BOOL ison);
		void HoseShape(int type);
		void DeleteThis() {delete this;}
	};

void RoundParams(HWND hwnd,BOOL ison)
{ if (ison)
  { SpinnerOn(hwnd,IDC_SPRING_RNDWIREDIASPIN);
    SpinnerOn(hwnd,IDC_SPRING_RNDWIRESIDESSPIN);
  }
  else
  { SpinnerOff(hwnd,IDC_SPRING_RNDWIREDIASPIN);
    SpinnerOff(hwnd,IDC_SPRING_RNDWIRESIDESSPIN);
  }
}
void RectParams(HWND hwnd,BOOL ison)
{ if (ison)
  { SpinnerOn(hwnd,IDC_SPRING_RECTWIREWIDSPIN);
    SpinnerOn(hwnd,IDC_SPRING_RECWIREDEPTHSPIN);
    SpinnerOn(hwnd,IDC_SPRING_RECWIREFILLETSPIN);
    SpinnerOn(hwnd,IDC_SPRING_RECWIREFILLETSIDESSPIN);
    SpinnerOn(hwnd,IDC_SPRING_RECTROTSPIN);
  }
  else
  { SpinnerOff(hwnd,IDC_SPRING_RECTWIREWIDSPIN);
    SpinnerOff(hwnd,IDC_SPRING_RECWIREDEPTHSPIN);
    SpinnerOff(hwnd,IDC_SPRING_RECWIREFILLETSPIN);
    SpinnerOff(hwnd,IDC_SPRING_RECWIREFILLETSIDESSPIN);
    SpinnerOff(hwnd,IDC_SPRING_RECTROTSPIN);
  }
}
void DSectParams(HWND hwnd,BOOL ison)
{ if (ison)
  { SpinnerOn(hwnd,IDC_SPRING_DWIREWIDSPIN);
    SpinnerOn(hwnd,IDC_SPRING_DWIREDEPTHSPIN);
    SpinnerOn(hwnd,IDC_SPRING_DWIRERNDSIDESSPIN);
    SpinnerOn(hwnd,IDC_SPRING_DWIREFILLETSPIN);
    SpinnerOn(hwnd,IDC_SPRING_DWIREFILLETSIDESSPIN);
    SpinnerOn(hwnd,IDC_SPRING_DROTSPIN);
  }
  else
  { SpinnerOff(hwnd,IDC_SPRING_DWIREWIDSPIN);
    SpinnerOff(hwnd,IDC_SPRING_DWIREDEPTHSPIN);
    SpinnerOff(hwnd,IDC_SPRING_DWIRERNDSIDESSPIN);
    SpinnerOff(hwnd,IDC_SPRING_DWIREFILLETSPIN);
    SpinnerOff(hwnd,IDC_SPRING_DWIREFILLETSIDESSPIN);
    SpinnerOff(hwnd,IDC_SPRING_DROTSPIN);
  }
}

void HoseParamDlg::HoseShape(int type)
{
  if (type==ROUND) 
  { RoundParams(po->hParams,TRUE);
    RectParams(po->hParams,FALSE);
    DSectParams(po->hParams,FALSE);
  }
  else if (type==RECT)
  { RoundParams(po->hParams,FALSE);
    RectParams(po->hParams,TRUE);
    DSectParams(po->hParams,FALSE);
  }
  else
  { RoundParams(po->hParams,FALSE);
    RectParams(po->hParams,FALSE);
    DSectParams(po->hParams,TRUE);
  }
}
void HoseParamDlg::FlexParams(BOOL ison)
{ if (ison)
  { SpinnerOn(po->hParams,IDC_HOSE_FLEX1SPIN);
	SpinnerOn(po->hParams,IDC_HOSE_FLEX2SPIN);
	SpinnerOn(po->hParams,IDC_HOSE_FLEXCYCLESSPIN);
	SpinnerOn(po->hParams,IDC_HOSE_DIACHANGESPIN);
  }
  else
  { SpinnerOff(po->hParams,IDC_HOSE_FLEX1SPIN);
	SpinnerOff(po->hParams,IDC_HOSE_FLEX2SPIN);
	SpinnerOff(po->hParams,IDC_HOSE_FLEXCYCLESSPIN);
	SpinnerOff(po->hParams,IDC_HOSE_DIACHANGESPIN);
  }
}
void HoseParamDlg::BoundParams(BOOL ison)
{ BOOL ok=ison;
  if (ison)
  { SpinnerOff(po->hParams,IDC_SPRING_LENGTHSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ2NAME),TRUE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ1NAME),TRUE);
	ok=(po->thisnode!=NULL);
  }
  else
  { SpinnerOn(po->hParams,IDC_SPRING_LENGTHSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ2NAME),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ1NAME),FALSE);
  }
  if ((po->iPick->IsEnabled()!=ok)||(po->iPick2->IsEnabled()!=ok))
  { if ((po->pickCB.dodist<0)||(!ok))
	{ TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,ok);
      TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,ok);
	  if (ok)
	  { SpinnerOn(po->hParams,IDC_HOSE_TENSION1SPIN);
		SpinnerOn(po->hParams,IDC_HOSE_TENSION2SPIN);
	  }
	  else 
	  { SpinnerOff(po->hParams,IDC_HOSE_TENSION1SPIN);
		SpinnerOff(po->hParams,IDC_HOSE_TENSION2SPIN);
	  }
	}
  }
}

void HoseParamDlg::Update(TimeValue t)
{ if (!po->editOb) return;
  po->ShowNames();
  int emethod,flexon,hshape;
  po->pblock->GetValue(PB_ENDSMETHOD,0,emethod,FOREVER);
  BoundParams(!emethod);
  po->pblock->GetValue(PB_FLEXON,0,flexon,FOREVER);
  FlexParams(flexon);
  po->pblock->GetValue(PB_WIRETYPE,0,hshape,FOREVER);
  HoseShape(hshape);
}

BOOL HoseParamDlg::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			po->iPick = GetICustButton(GetDlgItem(hWnd,IDC_SPRING_PICKOBJECT1));
			po->iPick->SetType(CBT_CHECK);
			po->iPick->SetHighlightColor(GREEN_WASH);
			po->iPick2 = GetICustButton(GetDlgItem(hWnd,IDC_SPRING_PICKOBJECT2));
			po->iPick2->SetType(CBT_CHECK);
			po->iPick2->SetHighlightColor(GREEN_WASH);
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(po->iPick);
			ReleaseICustButton(po->iPick2);
			return FALSE;
		case CC_SPINNER_BUTTONUP:
			{ 
/*			  if (HIWORD(wParam)) 
			  { switch ( LOWORD(wParam) ) 
				{
				}
			  }*/
			}
			return TRUE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SPRING_PICKOBJECT1: 
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateMHoseMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateMHoseMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;	
					     po->pickCB.dodist=0;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
					}
			  case IDC_SPRING_PICKOBJECT2: 
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateMHoseMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateMHoseMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;	
					     po->pickCB.dodist=1;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}			   
			  case IDC_HOSE_FLEXON: 
				  { int flexon; po->pblock->GetValue(PB_FLEXON,0,flexon,FOREVER);
					FlexParams(flexon);				  
				  }
				  break;				   
			  case IDC_SPRING_ROUNDWIRE: 
				  { HoseShape(ROUND);				  
				  }
				  break;				   
			  case IDC_SPRING_RECTWIRE: 
				  { HoseShape(RECT);				  
				  }
				  break;				   
			  case IDC_SPRING_DSECTIONWIRE: 
				  { HoseShape(DSECT);				  
				  }
				  break;				   
			  case IDC_SPRING_REFS: 
				  { BoundParams(TRUE);				  
				  }
				  break;				   
			  case IDC_SPRING_DIMS: 
				  { BoundParams(FALSE);
				    if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
					  { theCreateMHoseMode.JumpStart(po->ip,po);
						 po->ip->SetCommandMode(&theCreateMHoseMode);
					  } else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					}
				  }
				  break;
			}
		default:
			return FALSE;
		}
	return TRUE;
}

//--- HoseObject Methods--------------------------------------------

HoseObject::HoseObject()
{	int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	int length = PBLOCK_HOSE_LENGTH;
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descHoseVer0, length, CURRENT_VERSION));
	assert(pblock);

	pblock->SetValue(PB_ENDSMETHOD,0,1);
	pblock->SetValue(PB_NOREFLENGTH,0,1.0f);
	pblock->SetValue(PB_SEGMENTS,0,16);
	pblock->SetValue(PB_SMOOTH,0,0);
	pblock->SetValue(PB_RENDERABLE,0,1);

	pblock->SetValue(PB_WIRETYPE,0,0);
	pblock->SetValue(PB_RNDDIA,0,0.2f);
	pblock->SetValue(PB_RNDSIDES,0,6);
	pblock->SetValue(PB_RECTWIDTH,0,0.2f);
	pblock->SetValue(PB_RECTDEPTH,0,0.2f);
	pblock->SetValue(PB_RECTFILLET,0,0.0f);
	pblock->SetValue(PB_RECTFILLETSIDES,0,0);
	pblock->SetValue(PB_RECTROTANGLE,0,0.0f);
	pblock->SetValue(PB_DSECWIDTH,0,0.2f);
	pblock->SetValue(PB_DSECDEPTH,0,0.2f);
	pblock->SetValue(PB_DSECFILLET,0,0.0f);
	pblock->SetValue(PB_DSECFILLETSIDES,0,0);
	pblock->SetValue(PB_DSECRNDSIDES,0,4);
	pblock->SetValue(PB_DSECROTANGLE,0,0.0f);

	pblock->SetValue(PB_MAPMEMAPME,0,0);

	pblock->SetValue(PB_FLEXON,0,1);
	pblock->SetValue(PB_FLEXSTART,0,0.1f);
	pblock->SetValue(PB_FLEXSTOP,0,0.9f);
	pblock->SetValue(PB_FLEXCYCLES,0,10);
	pblock->SetValue(PB_FLEXDIAMETER,0,-0.2f);

	pblock->SetValue(PB_TENSION1,0,100.0f);
	pblock->SetValue(PB_TENSION2,0,100.0f);

	S.IdentityMatrix();
	iPick=NULL;
	iPick2=NULL;
	thisnode=NULL;
	custnode=NULL;
	custnode2=NULL;
	custname=TSTR(_T(" "));
	custname2=TSTR(_T(" "));
}

HoseObject::~HoseObject()
{	DeleteAllRefsFromMe();
}

void HoseObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
{	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	editOb   = this;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }

	if (pmapParam) 
	{	pmapParam->SetParamBlock(pblock);
	}
	else 
	{	pmapParam = CreateCPParamMap(
		descHoseParam1,HOSEPARAMSDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_HOSED),
		GetString(IDS_AP_HOSEPARAMS),
		0);		
	}
	hParams=pmapParam->GetHWnd();
	if (pmapParam) pmapParam->SetUserDlgProc(new HoseParamDlg(this));
}

void HoseObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
{	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;
	editOb = NULL;
	if (flags&END_EDIT_REMOVEUI) {
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		hParams=NULL;
		}
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
}

void HoseObject::MapKeys(TimeMap *map,DWORD flags)
{
}  

static TriObject *GetTriObject(TimeValue t,Object *obj,Interval &valid,BOOL &needsDel)
	{	
	needsDel = FALSE;
	if (!obj) return NULL;
	ObjectState os = obj->Eval(t);
	valid &= os.Validity(t);
	if (os.obj->IsSubClassOf(triObjectClassID)) {
		return (TriObject*)os.obj;
	} else {
		if (os.obj->CanConvertToType(triObjectClassID)) {
			Object *oldObj = os.obj;
			TriObject *tobj = (TriObject*)os.obj->ConvertToType(t,triObjectClassID);			
			needsDel = (tobj != oldObj);			
			return tobj;
			}
		}
	return NULL;
	}

#define BLVERTS 11
#define BLFACES 9

void HoseObject::GetWorldBoundBox(
		TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
	{	thisnode=inode;    
		SimpleObject::GetWorldBoundBox(t,inode,vpt,box);
	}  

void HoseObject::MakeSaveVertex(Point3 *SaveVertex,int NvertsPerRing, int nfillets, int nsides, int wtype, TimeValue t)
{	if (wtype == ROUND)
	{	float ang = TWOPI/(float)NvertsPerRing,diar;
		pblock->GetValue(PB_RNDDIA,t,diar,ivalid);
		diar *= 0.5f;
		for (int i=0; i<NvertsPerRing; i++)
		{	float u = (float)(i+1)*ang;
			SaveVertex[i] = Point3(diar*(float)cos(u),diar*(float)sin(u),0.0f);
		}
	}
	else if (wtype == RECT)
	{	int savevertcnt = 0;
		int qtrverts = 1 + nfillets;
		int hlfverts = 2*qtrverts;
		int thrverts = qtrverts + hlfverts;
		float Wr, Dr, Zfr;
		pblock->GetValue(PB_RECTWIDTH,t,Wr,ivalid);
		Wr *= 0.5f;
		pblock->GetValue(PB_RECTDEPTH,t,Dr,ivalid);
		Dr *= 0.5f;
		pblock->GetValue(PB_RECTFILLET,t,Zfr,ivalid);
		if (nfillets>0)
		{	float WmZ = Wr-Zfr,
				  DmZ = Dr-Zfr;
			float ZmW = -WmZ,
				  ZmD = -DmZ;
			SaveVertex[0                ] = Point3(Wr , DmZ, 0.0f);
			SaveVertex[nfillets         ] = Point3(WmZ, Dr , 0.0f);
			SaveVertex[qtrverts         ] = Point3(ZmW, Dr , 0.0f);
			SaveVertex[qtrverts+nfillets] = Point3(-Wr, DmZ, 0.0f);
			SaveVertex[hlfverts         ] = Point3(-Wr, ZmD, 0.0f);
			SaveVertex[hlfverts+nfillets] = Point3(ZmW, -Dr, 0.0f);
			SaveVertex[thrverts         ] = Point3(WmZ, -Dr, 0.0f);
			SaveVertex[thrverts+nfillets] = Point3(Wr , ZmD, 0.0f);

			if (nfillets > 1)
			{	float ang = PIover2/(float)nfillets;
				savevertcnt = 1;
				for (int i=0; i<nfillets-1; i++)
				{	float u = (float)(i+1)*ang;
				    float cu = Zfr*(float)cos(u),
						  su = Zfr*(float)sin(u);
					SaveVertex[savevertcnt         ] = Point3(WmZ+cu, DmZ+su, 0.0f);
					SaveVertex[savevertcnt+qtrverts] = Point3(ZmW-su, DmZ+cu, 0.0f);
					SaveVertex[savevertcnt+hlfverts] = Point3(ZmW-cu, ZmD-su, 0.0f);
					SaveVertex[savevertcnt+thrverts] = Point3(WmZ+su, ZmD-cu, 0.0f);
					savevertcnt++;
				}
			}
		}
		else
		{	SaveVertex[savevertcnt]=Point3(Wr,Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt]=Point3(-Wr,Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt]=Point3(-Wr,-Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt]=Point3(Wr,-Dr,0.0f);
			savevertcnt++;
		}
	}
	else
	{	int savevertcnt = 0;
		float Wr, Dr, Zfr;
		float sang = PI/(float)nsides;

		pblock->GetValue(PB_DSECWIDTH,t,Wr,ivalid);
		Wr*=0.5f;
		pblock->GetValue(PB_DSECDEPTH,t,Dr,ivalid);
		Dr*=0.5f;
		pblock->GetValue(PB_DSECFILLET,t,Zfr,ivalid);	

		float LeftCenter = Dr-Wr;

		if (nfillets > 0)
		{	float DmZ = Dr-Zfr,
				  ZmD = -DmZ,
				  WmZ = Wr-Zfr;
			int oneqtrverts = 1+nfillets;
			int threeqtrverts = oneqtrverts+1+nsides;

			SaveVertex[0                     ] = Point3(Wr        , DmZ,0.0f);
			SaveVertex[nfillets              ] = Point3(WmZ       , Dr ,0.0f);
			SaveVertex[oneqtrverts           ] = Point3(LeftCenter, Dr ,0.0f);
			SaveVertex[oneqtrverts+nsides    ] = Point3(LeftCenter,-Dr ,0.0f);
			SaveVertex[threeqtrverts         ] = Point3(WmZ       ,-Dr ,0.0f);
			SaveVertex[threeqtrverts+nfillets] = Point3(Wr        , ZmD,0.0f);

			if (nfillets > 1)
			{	float ang = PIover2/(float)nfillets;
				savevertcnt = 1;
				for (int i=0; i < nfillets-1; i++)
				{	float u = (float)(i+1)*ang;
				    float cu = Zfr*(float)cos(u),
						  su = Zfr*(float)sin(u);
					SaveVertex[savevertcnt              ] = Point3(WmZ+cu, DmZ+su, 0.0f);
					SaveVertex[savevertcnt+threeqtrverts] = Point3(WmZ+su, ZmD-cu, 0.0f);
					savevertcnt++;
				}
			}
			savevertcnt = 1+oneqtrverts;
			for (int i=0; i < nsides-1; i++)
			{	float u = (float)(i+1)*sang;
			    float cu = Dr*(float)cos(u),
					  su = Dr*(float)sin(u);
				SaveVertex[savevertcnt] = Point3(LeftCenter-su,cu,0.0f);
				savevertcnt++;
			}
		}
		else
		{	SaveVertex[savevertcnt]=Point3(Wr,        Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt]=Point3(LeftCenter,Dr,0.0f);
			savevertcnt++;
			for (int i=0; i<nsides-1; i++)
			{	float u = (float)(i+1)*sang;
			    float cu = Dr*(float)cos(u),
					  su = Dr*(float)sin(u);
				SaveVertex[savevertcnt] = Point3(LeftCenter-su, cu, 0.0f);
				savevertcnt++;
			}
			SaveVertex[savevertcnt] = Point3(LeftCenter,-Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt] = Point3(Wr,        -Dr,0.0f);
			savevertcnt++;
		}
	}
	float rotangle, cosu, sinu, tempx, tempy;
	if (wtype == RECT)
	{	pblock->GetValue(PB_RECTROTANGLE,t,rotangle,ivalid);
		if (rotangle != 0.0f)
		{	cosu = (float)cos(rotangle);
			sinu = (float)sin(rotangle);
			for (int m=0; m<NvertsPerRing ; m++)
			{	tempx = SaveVertex[m].x*cosu - SaveVertex[m].y*sinu;
				tempy = SaveVertex[m].x*sinu + SaveVertex[m].y*cosu;
				SaveVertex[m].x = tempx;
				SaveVertex[m].y = tempy;
			}
		}
	}
	else if (wtype == DSECT)
	{	pblock->GetValue(PB_DSECROTANGLE,t,rotangle,ivalid);
		if (rotangle != 0.0f)
		{	cosu = (float)cos(rotangle);
			sinu = (float)sin(rotangle);
			for (int m=0; m<NvertsPerRing ; m++)
			{	tempx = SaveVertex[m].x*cosu - SaveVertex[m].y*sinu;
				tempy = SaveVertex[m].x*sinu + SaveVertex[m].y*cosu;
				SaveVertex[m].x = tempx;
				SaveVertex[m].y = tempy;
			}
		}
	}

}

int HoseObject::RenderBegin(TimeValue t, ULONG flags)
{	SetAFlag(A_RENDER);
	int renderme;
	pblock->GetValue(PB_RENDERABLE,t,renderme,FOREVER);
	if (!renderme) 
	{	MeshInvalid();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	return 0;
}

int HoseObject::RenderEnd(TimeValue t)
{	ClearAFlag(A_RENDER);
	int renderme;
 	pblock->GetValue(PB_RENDERABLE,t,renderme,FOREVER);
	if (!renderme) 
	{	MeshInvalid();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	return 0;
}

#define SMOOTHALL	0
#define SMOOTHNONE	1
#define SMOOTHSIDES	2
#define SMOOTHSEGS	3

BOOL HoseObject::HasUVW() 
{ 	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_MAPMEMAPME, 0, genUVs, v);
	return genUVs; 
}

void HoseObject::SetGenUVW(BOOL sw) 
{  	if (sw==HasUVW()) 
		return;
	pblock->SetValue(PB_MAPMEMAPME,0, sw);
}

void HoseObject::BuildMesh(TimeValue t)
{	if (TestAFlag(A_RENDER))
	{	int renderme;
		pblock->GetValue(PB_RENDERABLE,0,renderme,ivalid);
		if (!renderme)
		{	mesh.setNumVerts(0);
			mesh.setNumFaces(0);
			mesh.setNumTVerts(0);
			mesh.setNumTVFaces(0);
			mesh.InvalidateGeomCache();
			return;
		}
	}
	
	ivalid=FOREVER;
	int createfree;
	pblock->GetValue(PB_ENDSMETHOD,0,createfree,ivalid);

	if ((!createfree)&&((!custnode)||(!custnode2))) 
		createfree = 1;
	if (!createfree) 
		ivalid.SetInstant(t);

	Matrix3 mat1,mat2;
	srand(56576);
	int s1 = rand();
	float Lf = 0.0f;
	Matrix3 Tlocal;

	Point3 startvec, endvec, tweenvec, startpoint, endpoint;

	Spline3D *hosespline=NULL;

	Point3 RV = Zero;

	if (createfree) 
		pblock->GetValue(PB_NOREFLENGTH,t,Lf,ivalid);
	else
	{	RV = Point3(RND11(),RND11(),RND11());

		mat1 = custnode->GetObjTMAfterWSM(t);
		mat2 = (custnode==custnode2?mat1:custnode2->GetObjTMAfterWSM(t));
		Matrix3 mato1(1), mato2(1);

		Point3 pos1 = custnode->GetObjOffsetPos();
		mato1.PreTranslate(pos1);
		Quat quat1 = custnode->GetObjOffsetRot();
		PreRotateMatrix(mato1, quat1);
		ScaleValue scaleValue1 = custnode->GetObjOffsetScale();
		ApplyScaling(mato1, scaleValue1);
		mato1 = Inverse(mato1);

		Point3 pos2 = custnode2->GetObjOffsetPos();
		mato2.PreTranslate(pos2);
		Quat quat2 = custnode2->GetObjOffsetRot();
		PreRotateMatrix(mato2, quat2);
		ScaleValue scaleValue2 = custnode2->GetObjOffsetScale();
		ApplyScaling(mato2, scaleValue2);
		mato2 = Inverse(mato2);

		S = thisnode->GetObjTMBeforeWSM(t);

		Matrix3 mat1NT, mat2NT;

		mat1NT = mat1;
		mat2NT = mat2;
		mat1NT.NoTrans();
		mat2NT.NoTrans();

		Point3 P1 = mat1*mato1.GetRow(3),
			   P2 = mat2*mato2.GetRow(3);
//		Point3 P1 = Omat1.GetRow(3),
//			   P2 = Omat2.GetRow(3);

//		startvec = Omat1.GetRow(2);
//		endvec = Omat2.GetRow(2);
		startvec = mat1NT*mato1.GetRow(2);
		endvec = mat2NT*mato2.GetRow(2);

		Matrix3 SI = Inverse(S);
//		Matrix3 SINT = SI;
//		SINT.NoTrans();

		Point3 P0 = SI*P1;
		Matrix3 T1 = mat1;
		T1.NoTrans();
		Point3 RVw = T1 * RV;
		Lf = Length(P2 - P1);
		Point3 Zw;
		if (Lf < 0.01f)
			Zw = Normalize(P1);
		else
			Zw = Normalize(P2 - P1);
		Point3 Xw = Normalize(RVw ^ Zw),
			   Yw = Normalize(Zw ^ Xw);	
		SI.NoTrans();
		Point3 Xs = SI * Xw,
			   Ys = SI * Yw,
			   Zs = SI * Zw;
		Tlocal.SetRow(0,Xs);
		Tlocal.SetRow(1,Ys);
		Tlocal.SetRow(2,Zs);
		Tlocal.SetRow(3,P0);

// move z-axes of end transforms into local frame
		Matrix3 TlocalInvNT = Tlocal;
		TlocalInvNT.NoTrans();
		TlocalInvNT = Inverse(TlocalInvNT);

		float tenstop, tensbot;
		pblock->GetValue(PB_TENSION1,t,tenstop,ivalid);
		pblock->GetValue(PB_TENSION2,t,tensbot,ivalid);

		startvec = tensbot*(TlocalInvNT*startvec);
		endvec = tenstop*(TlocalInvNT*endvec);

		startpoint = Point3(0.0f, 0.0f, 0.0f);
		endpoint = Point3(0.0f, 0.0f, Lf);

		hosespline = new Spline3D(KTYPE_CORNER, KTYPE_BEZIER, PARM_UNIFORM);
		int test1 = hosespline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,startpoint,startpoint-startvec,startpoint+startvec),-1);
		int test2 = hosespline->AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,endpoint,endpoint+endvec,endpoint-endvec),-1);
		hosespline->ComputeBezPoints();
	}

	int wtype;
	pblock->GetValue(PB_WIRETYPE,0,wtype,ivalid);
	int NvertsPerRing=0,
		nfillets=0,
		nsides=0;
	if (wtype==ROUND)
	{	pblock->GetValue(PB_RNDSIDES,t,NvertsPerRing,ivalid);
	}
	else if (wtype==RECT)
	{	pblock->GetValue(PB_RECTFILLETSIDES,t,nfillets,ivalid);
		NvertsPerRing=(nfillets>0?8+4*(nfillets-1):4);
	}
	else
	{	pblock->GetValue(PB_DSECFILLETSIDES,t,nfillets,ivalid);
		pblock->GetValue(PB_DSECRNDSIDES,t,nsides,ivalid);
		int nsm1 = nsides-1;
		NvertsPerRing=(nfillets>0?6+nsm1+2*(nfillets-1):4+nsm1);
	}

	int Nverts=0,NfacesPerEnd,NfacesPerRing,Nfaces=0,Segs;
	int SMOOTH;
	pblock->GetValue(PB_SMOOTH,0,SMOOTH,FOREVER);
	pblock->GetValue(PB_SEGMENTS,t,Segs,ivalid);

	Nverts = (Segs + 1)*NvertsPerRing + 2;
	NfacesPerEnd = NvertsPerRing;
	NfacesPerRing = 2* NvertsPerRing;
	Nfaces =  Segs*NfacesPerRing + 2*NfacesPerEnd;
	Point3 *SaveVertex = new Point3[NvertsPerRing];
	assert(SaveVertex);
	MakeSaveVertex(SaveVertex, NvertsPerRing, nfillets, nsides, wtype, t);

	mesh.setNumVerts(Nverts);
	mesh.setNumFaces(Nfaces);

	int mapmenow;
	pblock->GetValue(PB_MAPMEMAPME,0,mapmenow,FOREVER);

	if (mapmenow)
	{	mesh.setNumTVerts(Nverts+Segs+1);
		mesh.setNumTVFaces(Nfaces);
	}
	else
	{	mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
	}

	int thisvert = 0,
		last = Nverts-1,
		last2 = last-1;
	int lastvpr = NvertsPerRing-1,
		maxseg = Segs+1;

	int flexon, flexn;
	pblock->GetValue(PB_FLEXON,t,flexon,ivalid);
	float flex1, flex2, flexd, flexhere, flexlen, dadjust;
	pblock->GetValue(PB_FLEXSTART,t,flex1,ivalid);
	pblock->GetValue(PB_FLEXSTOP,t,flex2,ivalid);
	pblock->GetValue(PB_FLEXCYCLES,t,flexn,ivalid);
	pblock->GetValue(PB_FLEXDIAMETER,t,flexd,ivalid);

	Point3 ThisPosition;
	Point3 ThisXAxis, ThisYAxis, ThisZAxis;

	for (int i=0; i < maxseg; i++)
	{	float incr = (float)i/(float)Segs;

		if (createfree)
		{	ThisPosition = Point3(0.0f, 0.0f, Lf*incr);
			ThisXAxis = Point3(1.0f,0.0f,0.0f);
			ThisYAxis = Point3(0.0f,1.0f,0.0f);
			ThisZAxis = Point3(0.0f,0.0f,1.0f);
		}
		else
		{	ThisPosition = hosespline->InterpCurve3D(incr);
			ThisZAxis = hosespline->TangentCurve3D(incr);
			ThisXAxis = Normalize(RV^ThisZAxis);
			ThisYAxis = Normalize(ThisZAxis^ThisXAxis);
		}

		Matrix3 RingTM;
		RingTM.SetRow(0,ThisXAxis);
		RingTM.SetRow(1,ThisYAxis);
		RingTM.SetRow(2,ThisZAxis);
		RingTM.SetRow(3,ThisPosition);

		if (!createfree) 
			RingTM = RingTM * Tlocal;

		if ((incr>flex1)&&(incr<flex2)&&(flexon))
		{	flexlen = flex2 - flex1;
			if (flexlen<0.01f)
				flexlen = 0.01f;
			flexhere = (incr - flex1)/flexlen;
			dadjust = 1.0f+flexd*(1.0f-(float)sin((float)flexn*flexhere*TWOPI+PIover2));
		}
		else
			dadjust = 0.0f;

		for (int j=0; j < NvertsPerRing; j++)
		{	if (mapmenow)
				mesh.tVerts[thisvert] = Point3(0.999999f*incr, (float)j/(float)NvertsPerRing,0.5f);
			if (dadjust != 0.0f)
				mesh.setVert(thisvert, RingTM*(dadjust*SaveVertex[j]));
			else
				mesh.setVert(thisvert, RingTM*SaveVertex[j]);
			thisvert++;
		}

		if (mapmenow)
			mesh.tVerts[Nverts+i] = Point3(0.999999f*incr,0.999f,0.0f);

		if (i == 0)
		{	mesh.setVert(last2,(createfree?ThisPosition:Tlocal*ThisPosition));
			if (mapmenow)
				mesh.tVerts[last2]=Zero;
		}
		else if (i == Segs)
		{	mesh.setVert(last,(createfree?ThisPosition:Tlocal*ThisPosition));
			if (mapmenow)
				mesh.tVerts[last]=Ones;
		}
	}

//	Now, set up the faces
	int thisface = 0, v1, v2, v3, v4, v5, v6;
	v3 = last2;
	for (i=0; i < NvertsPerRing; i++)
	{	v1 = i;
		v2 = (i < lastvpr? v1+1 : v1-lastvpr);
		v5 = (i < lastvpr? v2 : Nverts);
		mesh.faces[thisface].setVerts(v2,v1,v3);
		mesh.faces[thisface].setSmGroup((SMOOTH == 1)?0:1);
		mesh.faces[thisface].setEdgeVisFlags(1,0,0);
		mesh.faces[thisface].setMatID(0);
		if (mapmenow)
			mesh.tvFace[thisface].setTVerts(v5,v1,v3);
		thisface++;
	}

	for (i=0; i < Segs; i++)
		for (int j=0; j < NvertsPerRing; j++)
		{	v1 = i*NvertsPerRing + j;
			v2 = (j < lastvpr? v1+1 : v1 - lastvpr );
			v3 = v1 + NvertsPerRing;
			v4 = v2 + NvertsPerRing;
			v5 = (j < lastvpr? v2 : Nverts+i);
			v6 = (j < lastvpr? v4 : Nverts+i+1);
			mesh.faces[thisface].setVerts(v4,v3,v1);
			switch (SMOOTH)
			{	case SMOOTHALL:		
					mesh.faces[thisface].setSmGroup(2); break;
				case SMOOTHNONE:	
					mesh.faces[thisface].setSmGroup(0); break;
				case SMOOTHSIDES:
					if (j == 0)
					{	mesh.faces[thisface].setSmGroup(2); break;}
					else if ((j % 2) == 0)
					{	mesh.faces[thisface].setSmGroup(4); break;}
					else
					{	mesh.faces[thisface].setSmGroup(8); break;}
				case SMOOTHSEGS:
					if (i == 0)
					{	mesh.faces[thisface].setSmGroup(2); break;}
					else if ((i % 2) == 0)
					{	mesh.faces[thisface].setSmGroup(4); break;}
					else
					{	mesh.faces[thisface].setSmGroup(8); break;}
			}
			mesh.faces[thisface].setEdgeVisFlags(1,1,0);
			mesh.faces[thisface].setMatID(1);\
			if (mapmenow)
				mesh.tvFace[thisface].setTVerts(v6,v3,v1);
			thisface++;
			mesh.faces[thisface].setVerts(v1,v2,v4);
			switch (SMOOTH)
			{	case SMOOTHALL:		
					mesh.faces[thisface].setSmGroup(2); break;
				case SMOOTHNONE:	
					mesh.faces[thisface].setSmGroup(0); break;
				case SMOOTHSIDES:
					if (j == 0)
					{	mesh.faces[thisface].setSmGroup(2); break;}
					else if ((j % 2) == 0)
					{	mesh.faces[thisface].setSmGroup(4); break;}
					else
					{	mesh.faces[thisface].setSmGroup(8); break;}
				case SMOOTHSEGS:
					if (i == 0)
					{	mesh.faces[thisface].setSmGroup(2); break;}
					else if ((i % 2) == 0)
					{	mesh.faces[thisface].setSmGroup(4); break;}
					else
					{	mesh.faces[thisface].setSmGroup(8); break;}
			}
			mesh.faces[thisface].setEdgeVisFlags(1,1,0);
			mesh.faces[thisface].setMatID(1);
			if (mapmenow)
				mesh.tvFace[thisface].setTVerts(v1,v5,v6);
			thisface++;
		}

	int basevert = Segs*NvertsPerRing;

	v3 = Nverts-1;
	for (i = 0; i < NvertsPerRing; i++)
	{	v1 = i + basevert;
		v2 = (i < lastvpr? v1+1 : v1 - lastvpr);
		v5 = (i < lastvpr? v2 : Nverts+Segs);
		mesh.faces[thisface].setVerts(v1,v2,v3);
		mesh.faces[thisface].setSmGroup((SMOOTH == 1)?0:1);
		mesh.faces[thisface].setEdgeVisFlags(1,0,0);
		mesh.faces[thisface].setMatID(2);;
		if (mapmenow)
			mesh.tvFace[thisface].setTVerts(v1,v5,v3);
		thisface++;
	}

	if (SaveVertex) 
		delete[] SaveVertex;

	if (hosespline)
	{	delete hosespline;
	}
	
	mesh.InvalidateGeomCache();
	mesh.InvalidateTopologyCache();mesh.BuildStripsAndEdges();
	srand( (unsigned)time( NULL ) );
}

class HoseEmitterCreateCallback : public CreateMouseCallBack {
	public:
		HoseObject *ob;
		Point3 p[2];
		IPoint2 sp0, sp1;
		BOOL square;
		void Cleanup();
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int HoseEmitterCreateCallback::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{	float r;
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE)
	{ switch(point)
		{ 	case 0:
				ob->suspendSnap = TRUE;				
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS));
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_RNDDIA,0,0.01f);
				ob->pblock->SetValue(PB_RECTWIDTH,0,0.01f);
				ob->pblock->SetValue(PB_RECTDEPTH,0,0.01f);
				ob->pblock->SetValue(PB_DSECWIDTH,0,0.01f);
				ob->pblock->SetValue(PB_DSECDEPTH,0,0.01f);
				ob->pblock->SetValue(PB_NOREFLENGTH,0,0.01f);
				break;
			case 1: 
				{	mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
					p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
					// diameter
					Point3 center = p[0];
					r = Length(p[1]-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
				
				float tempsize = 2.0f*r;
				ob->pblock->SetValue(PB_RNDDIA,0,tempsize);
				ob->pblock->SetValue(PB_RECTWIDTH,0,tempsize);
				ob->pblock->SetValue(PB_RECTDEPTH,0,tempsize);
				ob->pblock->SetValue(PB_DSECWIDTH,0,tempsize);
				ob->pblock->SetValue(PB_DSECDEPTH,0,tempsize);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL)
				{	float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
				}

				if (msg==MOUSE_POINT) 
				{if (Length(m-sp0)<3 ||	Length(p[1]-p[0])<0.1f)
					{return CREATE_ABORT;	}
				}
				break;
				}
			case 2:
				{
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				if (h<0.0f) h*=-1.0f;
				ob->pblock->SetValue(PB_NOREFLENGTH,0,h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				{ ob->suspendSnap = FALSE;
				  if (Length(m-sp0)<3 ) return CREATE_ABORT;	
				  else { TurnButton(ob->hParams,IDC_SPRING_PICKOBJECT1,TRUE);
						TurnButton(ob->hParams,IDC_SPRING_PICKOBJECT2,TRUE);
						return CREATE_STOP;
						SpinnerOn(ob->hParams,IDC_HOSE_TENSION1SPIN);
						SpinnerOn(ob->hParams,IDC_HOSE_TENSION2SPIN);
						}
				}
				}
				break;
			}
	}
	else
	if (msg == MOUSE_ABORT) 
	{ return CREATE_ABORT;}

	return TRUE;
}

static HoseEmitterCreateCallback emitterCallback;

CreateMouseCallBack* HoseObject::GetCreateMouseCallBack() 
	{
	emitterCallback.ob = this;
	return &emitterCallback;
	}

void HoseObject::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *HoseObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_NOREFLENGTH:
		case PB_RNDDIA:
		case PB_RECTWIDTH:
		case PB_RECTDEPTH:
		case PB_RECTFILLET:
		case PB_DSECWIDTH:
		case PB_DSECDEPTH:
		case PB_DSECFILLET:
					return stdWorldDim;
		case PB_RECTROTANGLE:
		case PB_DSECROTANGLE:
					return stdAngleDim;
		case PB_FLEXSTART:
		case PB_FLEXSTOP:
		case PB_FLEXDIAMETER:
					return stdPercentDim;
		default:	
					return defaultDim;
		}
	}

TSTR HoseObject::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ENDSMETHOD:			return GetString(IDS_AP_ENDSMETHOD);break;
		case PB_NOREFLENGTH:		return GetString(IDS_EP_HOSEHEIGHT);break;
		case PB_SEGMENTS:			return GetString(IDS_EP_SEGMENTS);break;
		case PB_SMOOTH:				return GetString(IDS_AP_SMOOTH);break;
		case PB_RENDERABLE:			return GetString(IDS_EP_RENDERHOSE);break;

		case PB_WIRETYPE:			return GetString(IDS_AP_HOSETYPE);break;
		case PB_RNDDIA:				return GetString(IDS_AP_HOSEDIA);break;
		case PB_RNDSIDES:			return GetString(IDS_AP_HOSESIDES);break;

		case PB_RECTWIDTH:			return GetString(IDS_AP_HOSERECTWIDTH);break;
		case PB_RECTDEPTH:			return GetString(IDS_AP_HOSERECTDEPTH);break;
		case PB_RECTFILLET:			return GetString(IDS_AP_HOSERFILLET);break;
		case PB_RECTFILLETSIDES:	return GetString(IDS_AP_HOSERFILLETSIDES);break;
		case PB_RECTROTANGLE:		return GetString(IDS_AP_HOSERECTROT);break;

		case PB_DSECWIDTH:			return GetString(IDS_AP_HOSEDSECWIDTH);break;
		case PB_DSECDEPTH:			return GetString(IDS_AP_HOSEDSECDEPTH);break;
		case PB_DSECFILLET:			return GetString(IDS_AP_HOSEDFILLET);break;
		case PB_DSECFILLETSIDES:	return GetString(IDS_AP_HOSEDFILLETSIDES);break;
		case PB_DSECRNDSIDES:		return GetString(IDS_AP_HOSEDSECRNDSIDES);break;
		case PB_DSECROTANGLE:		return GetString(IDS_AP_HOSEDSECROT);break;

		case PB_MAPMEMAPME:			return GetString(IDS_AP_HOSEMAPME);break;
		default: 					return TSTR(_T(""));
		}
	}

//--- Hose particle -----------------------------------------------

RefTargetHandle HoseObject::Clone(RemapDir& remap) 
	{
	HoseObject* newob = new HoseObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	if (custnode2) newob->ReplaceReference(CUSTNODE2,custnode2);
	newob->custname=custname;
	newob->custname2=custname2;
	newob->ivalid.SetEmpty();	
	int cnt=GetCOREInterface()->GetSelNodeCount();
	if (cnt>0) newob->thisnode=GetCOREInterface()->GetSelNode(0);
	else newob->thisnode=NULL;
	return newob;
	}

static float findmappos(float curpos)
{ float mappos;

  return(mappos=((mappos=curpos)<0.0f?0.0f:(mappos>1.0f?1.0f:mappos)));
}



RefTargetHandle HoseObject::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		case CUSTNODE2: return (RefTargetHandle)custnode2;
		default: return NULL;
		}
	}

void HoseObject::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		case CUSTNODE2: custnode2 = (INode *)rtarg; return;
		}
	}

RefResult HoseObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode)
			  { if (theHold.Holding() && !TestAFlag(A_HELD)) 
					theHold.Put(new CreateCPartRestoreNode(this));
			    DeleteReference(CUSTNODE);
				custnode=NULL;cancelled=FALSE;
				custname=TSTR(_T(" "));				
				}
			  if (hTarget==custnode2) 
			  { if (theHold.Holding() && !TestAFlag(A_HELD)) 
					theHold.Put(new CreateCPart2RestoreNode(this));
			    DeleteReference(CUSTNODE2);
				custnode2=NULL;cancelled=FALSE;
			    custname2=TSTR(_T(" "));
			  }
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				cancelled=FALSE;
				}
			  if (hTarget==custnode2) 
			  { custname2 = TSTR(custnode2->GetName());
			    ShowName2();
				cancelled=FALSE;
				}
			  break;
			}
		case REFMSG_CHANGE:
			{ MeshInvalid();
			  if (editOb==this) InvalidateUI();
			  cancelled=FALSE;
			}
			break;
		default: SimpleObject::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}

/*class HosePostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		HosePostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((HoseObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
				((HoseObject*)targ)->pblock->SetValue(PB_SYMMETRY,0,0);
				}
			delete this;
			}
	};*/

#define COM_CUSTNAME_CHUNK	0x0100
#define COM_CUSTNAME2_CHUNK	0x0101
#define COM_CNODE_CHUNK		0x0102

IOResult HoseObject::Save(ISave *isave)
{ 	ULONG nb;
	int refid;

	isave->BeginChunk(COM_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();

	isave->BeginChunk(COM_CUSTNAME2_CHUNK);		
	isave->WriteWString(custname2);
	isave->EndChunk();

	refid=isave->GetRefID(thisnode);
	isave->BeginChunk(COM_CNODE_CHUNK);		
	isave->Write(&refid,sizeof(int),&nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult HoseObject::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	int cnmtl=0;
	int refid;
	
//	iload->RegisterPostLoadCallback(
			//new HosePostLoadCallback(
				//new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0)));
	// Default names
	custname = TSTR(_T(" "));
	custname2 = TSTR(_T(" "));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case COM_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			case COM_CUSTNAME2_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname2= TSTR(buf);
				break;
				}
			case COM_CNODE_CHUNK: 
			{	res=iload->Read(&refid,sizeof(int),&nb);
			    iload->RecordBackpatch(refid,(void**)&thisnode);
				break; }
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}

const TCHAR *HoseClassDesc::ClassName ()	{return GetString(IDS_AP_HOSE);}
const TCHAR *HoseClassDesc::Category ()	{return GetString(IDS_EP_BONUSPRIMS);}
TCHAR *HoseObject::GetObjectName() {return GetString(IDS_AP_HOSE);}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\lext.cpp ===
/**********************************************************************
 *<
	FILE: lext.cpp	   - builds l-extrusions
	CREATED BY:  Audrey Peterson

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"

static Class_ID LEXT_CLASS_ID(0x9e73a08, 0x8693067);
class LextObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtSideLength,crtBotLength,crtHeight;
		static float crtSideWidth,crtBotWidth;
		static int dlgHSegs, dlgWSegs,dlgBSegs,dlgSSegs;
		static int dlgCreateMeth;
		static Point3 crtPos;	
		BOOL increate;
		
		LextObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_LEXT); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return LEXT_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_SIDES		1

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)

//--- ClassDescriptor and class vars ---------------------------------

class LextClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new LextObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_LEXT_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return LEXT_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static LextClassDesc LextDesc;

ClassDesc* GetLextDesc() { return &LextDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for Lext class.
IObjParam *LextObject::ip         = NULL;
int LextObject::dlgHSegs    = DEF_SEGMENTS;
int LextObject::dlgSSegs       = DEF_SEGMENTS;
int LextObject::dlgWSegs       = DEF_SEGMENTS;
int LextObject::dlgBSegs       = DEF_SEGMENTS;
int LextObject::dlgCreateMeth     = 0; // create_radius
IParamMap *LextObject::pmapCreate = NULL;
IParamMap *LextObject::pmapTypeIn = NULL;
IParamMap *LextObject::pmapParam  = NULL;
Point3 LextObject::crtPos         = Point3(0,0,0);
float LextObject::crtHeight       = 0.0f;
float LextObject::crtSideLength   = 0.0f;
float LextObject::crtBotLength    = 0.0f;
float LextObject::crtBotWidth     = 0.0f;
float LextObject::crtSideWidth     = 0.0f;

void LextClassDesc::ResetClassParams(BOOL fileReset)
	{ LextObject::dlgHSegs			= DEF_SEGMENTS;
	  LextObject::dlgSSegs       = DEF_SEGMENTS;
	  LextObject::dlgWSegs       = DEF_SEGMENTS;
	  LextObject::dlgBSegs       = DEF_SEGMENTS;
	  LextObject::dlgCreateMeth     = 0; // create_radius
	  LextObject::crtHeight       = 0.0f;
	  LextObject::crtSideLength   = 0.0f;
	  LextObject::crtBotLength    = 0.0f;
	  LextObject::crtBotWidth     = 0.0f;
      LextObject::crtSideWidth     = 0.0f;
	  LextObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_SIDELENGTH	0
#define PB_BOTLENGTH	1
#define PB_SIDEWIDTH	2
#define PB_BOTWIDTH		3
#define PB_HEIGHT		4
#define PB_SSEGS		5
#define PB_BSEGS		6
#define PB_WSEGS		7
#define PB_HSEGS		8
#define PB_GENUVS		9

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_SIDELENGTH	2
#define PB_TI_BOTLENGTH		3
#define PB_TI_SIDEWIDTH		4
#define PB_TI_BOTWIDTH		5
#define PB_TI_HEIGHT		6

#define BMIN_HEIGHT		float(0.1)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
#define BMIN_WIDTH		float(0)
#define BMAX_WIDTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_UEXTR_CORNER,IDC_UEXTR_CENTER};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1



//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_POSX,IDC_LEXT_POSXSPIN,
		IDC_LEXT_POSY,IDC_LEXT_POSYSPIN,
		IDC_LEXT_POSZ,IDC_LEXT_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Side Length
	ParamUIDesc(
		PB_TI_SIDELENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_SIDELEN,IDC_LEXT_SIDELENSPIN,
		MIN_HEIGHT,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Bot Length
	ParamUIDesc(
		PB_TI_BOTLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_BOTLEN,IDC_LEXT_BOTLENSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),
	
	// Side Width
	ParamUIDesc(
		PB_TI_SIDEWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_SIDEWID,IDC_LEXT_SIDEWIDSPIN,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Bot Width
	ParamUIDesc(
		PB_TI_BOTWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_BOTWID,IDC_LEXT_BOTWIDSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_HEIGHT,IDC_LEXT_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	};
#define TYPEINDESC_LENGTH 6


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Side Length
	ParamUIDesc(
		PB_SIDELENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_SIDELEN,IDC_LEXT_SIDELENSPIN,
		MIN_HEIGHT,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Bot Length
	ParamUIDesc(
		PB_BOTLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_BOTLEN,IDC_LEXT_BOTLENSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),
	
	// Side Width
	ParamUIDesc(
		PB_SIDEWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_SIDEWID,IDC_LEXT_SIDEWIDSPIN,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Bot Width
	ParamUIDesc(
		PB_BOTWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_BOTWID,IDC_LEXT_BOTWIDSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_LEXT_HEIGHT,IDC_LEXT_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	
	// Side Segments
	ParamUIDesc(
		PB_SSEGS,
		EDITTYPE_INT,
		IDC_LEXT_SIDESEGS,IDC_LEXT_SIDESEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Bot Segments
	ParamUIDesc(
		PB_BSEGS,
		EDITTYPE_INT,
		IDC_LEXT_BOTSEGS,IDC_LEXT_BOTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Width Segments
	ParamUIDesc(
		PB_WSEGS,
		EDITTYPE_INT,
		IDC_LEXT_WIDTHSEGS,IDC_LEXT_WIDTHSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
			
	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_LEXT_HGTSEGS,IDC_LEXT_HGTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGTH 10


// variable type, NULL, animatable, number
ParamBlockDescID LextdescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 }, 
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 }, 
	{ TYPE_INT, NULL, TRUE, 7 }, 
	{ TYPE_INT, NULL, TRUE, 8 }, 
	{ TYPE_INT, NULL, FALSE, 9 }, 
	};

#define PBLOCK_LENGTH	10

#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(LextdescVer0,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

void FixLBotWidth(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float sidelen,botwidth;

	pblock->GetValue(PB_SIDELENGTH,t,sidelen,FOREVER);
	pblock->GetValue(PB_BOTWIDTH,(increate?0:t),botwidth,FOREVER);
	float fmax=(float)fabs(sidelen);
	if (hWnd)
    { ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_LEXT_BOTWIDSPIN));
	  spin2->SetLimits(BMIN_LENGTH,fmax,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (botwidth>fmax) pblock->SetValue(PB_BOTWIDTH,(increate?0:t),fmax);
}
void FixLSideWidth(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float botlen,sidewidth;

	pblock->GetValue(PB_SIDEWIDTH,(increate?0:t),sidewidth,FOREVER);
	pblock->GetValue(PB_BOTLENGTH,t,botlen,FOREVER);
	float fmax=(float)fabs(botlen);										  
	if (hWnd)
    { ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_LEXT_SIDEWIDSPIN));
	  spin2->SetLimits(BMIN_LENGTH,fmax,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (sidewidth>fmax) pblock->SetValue(PB_SIDEWIDTH,(increate?0:t),fmax);
}
//--- TypeInDlgProc --------------------------------
class LextWidthDlgProc : public ParamMapUserDlgProc {
	public:
		LextObject *ob;

		LextWidthDlgProc(LextObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL LextWidthDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ 	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_LEXT_BOTLENSPIN:
					FixLBotWidth(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				case IDC_LEXT_SIDELENSPIN:
					FixLSideWidth(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				}
		}
	return FALSE;
	}
class LextTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		LextObject *ob;

		LextTypeInDlgProc(LextObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL LextTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_LEXT_CREATE: {
					if (ob->crtHeight==0.0f) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_SIDELENGTH,0,ob->crtSideLength);
						ob->pblock->SetValue(PB_BOTLENGTH,0,ob->crtBotLength);
						ob->pblock->SetValue(PB_SIDEWIDTH,0,ob->crtSideWidth);
						ob->pblock->SetValue(PB_BOTWIDTH,0,ob->crtBotWidth);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Lext methods -------------------------------

LextObject::LextObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(LextdescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	
	pblock->SetValue(PB_SSEGS,0,dlgSSegs);
	pblock->SetValue(PB_BSEGS,0,dlgBSegs);	
	pblock->SetValue(PB_WSEGS,0,dlgWSegs);	
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);	

	pblock->SetValue(PB_SIDELENGTH,0,crtSideLength);
	pblock->SetValue(PB_BOTLENGTH,0,crtBotLength);
	pblock->SetValue(PB_SIDEWIDTH,0,crtSideWidth);
	pblock->SetValue(PB_BOTWIDTH,0,crtBotWidth);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	increate=FALSE;
	}

IOResult LextObject::Load(ILoad *iload) 
	{
	return IO_OK;
	}


void LextObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Lext ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_UEXTRUSIONS1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_L_EXTRUSION2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_L_EXTRUSION3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new LextTypeInDlgProc(this));
		}	
	if(pmapParam) {
		// A callback for the type in.
		pmapParam->SetUserDlgProc(new LextWidthDlgProc(this));
		}	
	}
		
void LextObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_SSEGS,ip->GetTime(),dlgSSegs,FOREVER);
	pblock->GetValue(PB_BSEGS,ip->GetTime(),dlgBSegs,FOREVER);	
	pblock->GetValue(PB_WSEGS,ip->GetTime(),dlgWSegs,FOREVER);	
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);		
}

/*void LextObject::SetParams(float rad, float height, int segs, int sides, int capsegs, BOOL smooth, 
	pblock->SetValue(PB_SIDELENGTH,0,sidelength);
	pblock->SetValue(PB_BOTLENGTH,0,botlength);
	pblock->SetValue(PB_SIDEWIDTH,0,sidewidth);
	pblock->SetValue(PB_BOTWIDTH,0,botwidth);
	pblock->SetValue(PB_SSEGS,0,ssegs);
	pblock->SetValue(PB_BSEGS,0,bsegs);
	pblock->SetValue(PB_WSEGS,0,wsegs);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_GENUVS,0, genUV);
*/

void BuildLextMesh(Mesh &mesh,
		int hsegs, int ssegs, int bsegs, int wsegs,
		float height, float sidelen, float botlen,
		float sidewidth, float botwidth,int genUVs,BOOL create)
{	int nf=0;
	int nfaces,ntverts;
	 // sides + top/bot
	BOOL minusx=(botlen<0.0f),minusy=(sidelen<0.0f),minush=(height<0.0f);
	botlen=(float)fabs(botlen);
	sidelen=(float)fabs(sidelen);
	if (minush) height=-height;  	
	int VertexPerLevel=2*(wsegs+ssegs+bsegs);
	int topverts=(wsegs+1)*(1+ssegs+bsegs);
	int nverts=2*topverts+(hsegs+1)*VertexPerLevel;
	nfaces=hsegs*4*(wsegs+bsegs+ssegs)+4*wsegs*(ssegs+bsegs);

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	if (genUVs) 
	{ ntverts=nverts+hsegs+1;
	  mesh.setNumTVerts(ntverts);
	  mesh.setNumTVFaces(nfaces);
	} 
	else 
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	Point3 p;
	p.x=p.y=p.z=0.0f;
	float minx=0.0f,maxx=botlen;
	float xlen=botlen;
	float xincr,xpos=0.0f,yincr;
	float uvdist=2.0f*(botlen+sidelen);
	float ystart,xstart;
	float xtv,ytv,ypos,dx=sidewidth/wsegs,bdy=botwidth/wsegs;
	int i,j,nv=0,fc=0,dlevel=bsegs+ssegs+1,botv=nverts-topverts;
	int tlast,tendcount=ntverts-hsegs-1,tnv=0,bottv=tendcount-topverts;
	tlast=tendcount;
	for (j=0;j<=wsegs;j++)
	{ xstart=0.0f;xincr=(botlen-j*dx)/bsegs;
      yincr=botwidth/wsegs;ystart=j*yincr;
	  for (i=0;i<=bsegs;i++)
	  { mesh.setVert(nv,xpos=xstart+i*xincr,ystart,height);	
	    mesh.setVert(botv,xpos,ystart,0.0f);
	    if (genUVs)
	    { mesh.setTVert(tnv,xtv=(xpos-minx)/xlen,ytv=ystart/sidelen,0.0f);
	      mesh.setTVert(bottv,xtv,1.0f-ytv,0.0f);
	    }
	    nv++;botv++;bottv++;tnv++;
	  }
	  yincr=(sidelen-j*bdy)/ssegs;xpos=mesh.verts[nv-1].x;
	  for (i=1;i<=ssegs;i++)
	  { mesh.setVert(nv,xpos,ypos=ystart+i*yincr,height);	
	    mesh.setVert(botv,xpos,ypos,0.0f);
	    if (genUVs)
	    { mesh.setTVert(tnv,xtv,ytv=ypos/sidelen,0.0f);
	      mesh.setTVert(bottv,xtv,1.0f-ytv,0.0f);
	    }
	   nv++;botv++;bottv++;tnv++;
  	  }
	}
	xstart=0.0f;xpos=0.0f;ypos=0.0f;
	float uval=0.0f;
	int refnv=nv;
	xincr=botlen/bsegs;
	for (i=0;i<=bsegs;i++)
	{  mesh.setVert(nv,xpos=xstart+i*xincr,0.0f,height);	
	   if (genUVs) mesh.setTVert(tnv,xtv=(uval=xpos)/uvdist,1.0f,0.0f);
	   nv++;tnv++;
    }
	yincr=sidelen/ssegs;xpos=mesh.verts[nv-1].x;
	for (i=1;i<=ssegs;i++)
	{ mesh.setVert(nv,xpos,ypos+=yincr,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=yincr)/uvdist,1.0f,0.0f);
	  nv++;tnv++;
  	}
 	xincr=sidewidth/wsegs;
	for (i=1;i<=wsegs;i++)
	{ mesh.setVert(nv,xpos-=xincr,ypos,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=xincr)/uvdist,1.0f,0.0f);
	  nv++;;tnv++;
	}
	yincr=(sidelen-botwidth)/ssegs;
	for (i=1;i<=ssegs;i++)
	{ mesh.setVert(nv,xpos,ypos-=yincr,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=yincr)/uvdist,1.0f,0.0f);
	  nv++;;tnv++;
	}
	xincr=(botlen-sidewidth)/bsegs;
	for (i=1;i<=bsegs;i++)
	{ mesh.setVert(nv,xpos-=xincr,ypos,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=xincr)/uvdist,1.0f,0.0f);
	  nv++;;tnv++;
	}
	yincr=botwidth/wsegs;
	for (i=1;i<wsegs;i++)
	{ mesh.setVert(nv,xpos,ypos-=yincr,height);	
	  if (genUVs) mesh.setTVert(tnv,(uval+=yincr)/uvdist,1.0f,0.0f);
	  nv++;tnv++;
	}
	if (genUVs) mesh.setTVert(tendcount++,1.0f,1.0f,0.0f);
	float zval,hincr=height/hsegs,zv;
	for (j=0;j<VertexPerLevel;j++)
	{ zval=height;
	  for (i=1;i<=hsegs;i++)
	  {	 zval-=hincr;
	     mesh.setVert(refnv+VertexPerLevel*i,mesh.verts[refnv].x,mesh.verts[refnv].y,zval);
		 if (genUVs) 
		 { mesh.setTVert(refnv+VertexPerLevel*i,mesh.tVerts[refnv].x,zv=zval/height,0.0f);
		   if (j==VertexPerLevel-1) mesh.setTVert(tendcount++,1.0f,zv,0.0f);
		 }
	  }
	refnv++;
	}
	int base=0,top=dlevel,alevel=dlevel-1;
	for (i=0;i<wsegs;i++)
	{ for (j=0;j<alevel;j++)
	 { if (genUVs) 
	   { mesh.tvFace[fc].setTVerts(top,base,base+1);
		 mesh.tvFace[fc+1].setTVerts(top,base+1,top+1);
	   }
	   AddFace(&mesh.faces[fc++],top,base,base+1,0,1);
	   AddFace(&mesh.faces[fc++],top,base+1,top+1,1,1);
	   top++;base++;
  	 } top++;base++;
	}
	base=top+VertexPerLevel;
	tendcount=tlast;
    int b1,smgroup=2,s0=bsegs+1,s1=s0+ssegs,s2=s1+wsegs,s3=s2+ssegs,s4=s3+bsegs;
	for (i=0;i<hsegs;i++)
	{ for (j=1;j<=VertexPerLevel;j++)
	{ if (genUVs) 
	   { b1=(j<VertexPerLevel?base+1:tendcount+1);
		 mesh.tvFace[fc].setTVerts(top,base,b1);
		 mesh.tvFace[fc+1].setTVerts(top,b1,(j<VertexPerLevel?top+1:tendcount++));
	   }
	   b1=(j<VertexPerLevel?base+1:base-VertexPerLevel+1);
	   smgroup=(j<s0?2:(j<s1?4:(j<s2?2:(j<s3?4:(j<s4?2:4)))));
	   AddFace(&mesh.faces[fc++],top,base,b1,0,smgroup);
	   AddFace(&mesh.faces[fc++],top,b1,(j<VertexPerLevel?top+1:top-VertexPerLevel+1),1,smgroup);
	   top++;base++;
  	 } 
	}
	top=base;base=top+alevel;
	base=top+dlevel;
	for (i=0;i<wsegs;i++)
	{ for (j=0;j<alevel;j++)
	 { if (genUVs) 
	   { mesh.tvFace[fc].setTVerts(top,base,base+1);
		 mesh.tvFace[fc+1].setTVerts(top,base+1,top+1);
	   }
	   AddFace(&mesh.faces[fc++],top,base,base+1,0,1);
	   AddFace(&mesh.faces[fc++],top,base+1,top+1,1,1);
	   top++;base++;
  	 } top++;base++;
	}
	if (minusx || minusy || minush)
	{  float centerx=(create?botlen:0),centery=(create?sidelen:0);
	   for (i=0;i<nverts;i++)
	   { if (minusx) mesh.verts[i].x=-mesh.verts[i].x+centerx;
	     if (minusy) mesh.verts[i].y=-mesh.verts[i].y+centery;
	     if (minush) mesh.verts[i].z-=height;
	   }
	   DWORD hold;
	   int tedge;
	   if (minusx!=minusy)
	   for (i=0;i<nfaces;i++)
	   { hold=mesh.faces[i].v[0];mesh.faces[i].v[0]=mesh.faces[i].v[2];mesh.faces[i].v[2]=hold;
	     tedge=mesh.faces[i].getEdgeVis(0);mesh.faces[i].setEdgeVis(0,mesh.faces[i].getEdgeVis(1));
		 mesh.faces[i].setEdgeVis(1,tedge);
	     if (genUVs)
         { hold=mesh.tvFace[i].t[0];mesh.tvFace[i].t[0]=mesh.tvFace[i].t[2];mesh.tvFace[i].t[2]=hold;}
	   }
	}
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts); */
	mesh.InvalidateGeomCache();
	mesh.InvalidateTopologyCache();
	mesh.BuildStripsAndEdges();
}

BOOL LextObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void LextObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void LextObject::BuildMesh(TimeValue t)
	{	
	int hsegs,ssegs,bsegs,wsegs;
	float height,sidelen,botlen,sidewidth,botwidth;
	int genUVs;	

	// Start the validity interval at forever and widdle it down.
	FixLBotWidth(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	FixLSideWidth(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	ivalid = FOREVER;
	
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_SSEGS,t,ssegs,ivalid);
	pblock->GetValue(PB_BSEGS,t,bsegs,ivalid);
	pblock->GetValue(PB_WSEGS,t,wsegs,ivalid);
	pblock->GetValue(PB_SIDELENGTH,t,sidelen,ivalid);
	pblock->GetValue(PB_BOTLENGTH,t,botlen,ivalid);
	pblock->GetValue(PB_SIDEWIDTH,t,sidewidth,ivalid);
	pblock->GetValue(PB_BOTWIDTH,t,botwidth,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	LimitValue(height, MIN_HEIGHT, BMAX_HEIGHT);
	LimitValue(sidelen, MIN_HEIGHT, BMAX_WIDTH);
	LimitValue(botlen, MIN_HEIGHT, BMAX_HEIGHT);
	LimitValue(sidewidth, BMIN_WIDTH, BMAX_WIDTH);
	LimitValue(botwidth, BMIN_HEIGHT, BMAX_HEIGHT);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(ssegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(bsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(wsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	
	BuildLextMesh(mesh,hsegs,ssegs,bsegs,wsegs,height,
		sidelen,botlen,sidewidth,botwidth, genUVs,dlgCreateMeth);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}


Object* LextObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
		return SimpleObject::ConvertToType(t,obtype);
	}

int LextObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==triObjectClassID) {
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

class LextObjCreateCallBack: public CreateMouseCallBack {
	LextObject *ob;	
	Point3 p[2],d;
	IPoint2 sp0,sp1,sp2;
	float l,hd,xwid,slen;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(LextObject *obj) { ob = obj; }
	};

int LextObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) 
{

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
		case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_SIDELENGTH,0,0.01f);
				ob->pblock->SetValue(PB_BOTLENGTH,0,0.01f);
				break;
			case 1: 
				mat.IdentityMatrix();
				sp1 = m;
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				d = p[1]-p[0];
				if (flags&MOUSE_CTRL) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = len;}
				if (!ob->dlgCreateMeth)
				{ mat.SetTrans(p[0]);
				if (flags&MOUSE_CTRL) d.x=(d.y*=2.0f);}
				else 
				{ mat.SetTrans(p[0]-Point3(fabs(d.x),fabs(d.y),fabs(d.z))); 
				  d=2.0f*d;	
				}
				slen=(float)fabs(d.y);
				xwid=(float)fabs(d.x);
				ob->pblock->SetValue(PB_BOTLENGTH,0,d.x);
				ob->pblock->SetValue(PB_BOTWIDTH,0,0.2f*(float)fabs(d.x));
				ob->pblock->SetValue(PB_SIDELENGTH,0,d.y);
				ob->pblock->SetValue(PB_SIDEWIDTH,0,0.2f*(float)fabs(d.y));
				ob->pmapParam->Invalidate();
				ob->increate=TRUE;
				if (msg==MOUSE_POINT && (Length(sp1-sp0)<3 || Length(d)<0.1f)) 
				{ ob->increate=FALSE;
				return CREATE_ABORT;	}
				break;
			case 2:
				{sp2=m;
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) {	
					if (Length(m-sp0)<3) 
					{	ob->increate=FALSE; return CREATE_ABORT;}}
				break;}
			case 3: 
				float f=vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,1,0),sp2,m));
				if (f<0.0f) f=0.0f;
				if (f>slen) f=slen;
				ob->pblock->SetValue(PB_SIDEWIDTH,0,(f>xwid?xwid:f));
				ob->pblock->SetValue(PB_BOTWIDTH,0,f);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) 
				{  ob->suspendSnap = FALSE;	
				ob->increate=FALSE;
				   return CREATE_STOP;
				}
				break;

			}
	} else {
		if (msg == MOUSE_ABORT)
		{ ob->increate=FALSE;	return CREATE_ABORT;}
		}
	return 1;
	}

static LextObjCreateCallBack cylCreateCB;

CreateMouseCallBack* LextObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL LextObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_BOTLENGTH,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL LextObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL LextObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_SIDELENGTH: crtSideLength = v; break;
		case PB_TI_BOTLENGTH: crtBotLength = v; break;
		case PB_TI_SIDEWIDTH: crtSideWidth = v; break;
		case PB_TI_BOTWIDTH: crtBotWidth = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL LextObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL LextObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL LextObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_SIDELENGTH: v = crtSideLength; break;
		case PB_TI_BOTLENGTH: v = crtBotLength; break;
		case PB_TI_SIDEWIDTH: v = crtSideWidth; break;
		case PB_TI_BOTWIDTH: v = crtBotWidth; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL LextObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void LextObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *LextObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SIDELENGTH:return stdWorldDim;
		case PB_BOTLENGTH:return stdWorldDim;
		case PB_SIDEWIDTH: return stdWorldDim;
		case PB_BOTWIDTH: return stdWorldDim;
		case PB_HEIGHT:return stdWorldDim;
		case PB_SSEGS: return stdSegmentsDim;
		case PB_BSEGS: return stdSegmentsDim;
		case PB_WSEGS: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;
		default: return defaultDim;
		}
	}

TSTR LextObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SIDELENGTH: return TSTR(GetString(IDS_RB_SIDELENGTH));
		case PB_BOTLENGTH: return TSTR(GetString(IDS_AP_FRONTLENGTH));
		case PB_SIDEWIDTH:  return TSTR(GetString(IDS_RB_SIDEWIDTH));
		case PB_BOTWIDTH:  return TSTR(GetString(IDS_AP_FRONTWIDTH));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_SSEGS:  return TSTR(GetString(IDS_RB_SSEGS));
		case PB_BSEGS:  return TSTR(GetString(IDS_AP_FRONTSEGS));
		case PB_WSEGS:  return TSTR(GetString(IDS_RB_WSEGS));
		case PB_HSEGS:  return TSTR(GetString(IDS_RB_HSEGS));
		default: return TSTR(_T(""));		
		}
	}

RefTargetHandle LextObject::Clone(RemapDir& remap) 
	{
	LextObject* newob = new LextObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\pyramid.cpp ===
/**********************************************************************
 *<
	FILE:pyramid.cpp
	CREATED BY:  Audrey Peterson

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"
#include "surf_api.h"

static Class_ID PYRAMID_CLASS_ID(0x76bf318a, 0x4bf37b10);
class PyramidObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtHeight,crtWidth,crtDepth;
		static int dlgHSegs, dlgDSegs, dlgWSegs;
		static int dlgCreateMeth;
		static Point3 crtPos;		
		
		PyramidObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
		void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_PYRAMID); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return PYRAMID_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_SIDES		1

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)


//--- ClassDescriptor and class vars ---------------------------------

class PyramidClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new PyramidObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_PYRAMID_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return PYRAMID_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_AP_PRIMITIVES);  }
	void			ResetClassParams(BOOL fileReset);
	};

static PyramidClassDesc PyramidDesc;

ClassDesc* GetPyramidDesc() { return &PyramidDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for Pyramid class.
IObjParam *PyramidObject::ip         = NULL;
int PyramidObject::dlgHSegs			= DEF_SEGMENTS;
int PyramidObject::dlgWSegs       = DEF_SIDES;
int PyramidObject::dlgDSegs       = DEF_SIDES;
int PyramidObject::dlgCreateMeth     = 0; // base_apex
IParamMap *PyramidObject::pmapCreate = NULL;
IParamMap *PyramidObject::pmapTypeIn = NULL;
IParamMap *PyramidObject::pmapParam  = NULL;
Point3 PyramidObject::crtPos         = Point3(0,0,0);
float PyramidObject::crtHeight       = 0.0f;
float PyramidObject::crtWidth       = 0.0f;
float PyramidObject::crtDepth       = 0.0f;

void PyramidClassDesc::ResetClassParams(BOOL fileReset)
	{ PyramidObject::dlgHSegs			= DEF_SEGMENTS;
	  PyramidObject::dlgWSegs     = DEF_SIDES;
	  PyramidObject::dlgDSegs     = DEF_SIDES;
	  PyramidObject::dlgCreateMeth     = 0; // base_apex
	  PyramidObject::crtHeight       = 0.0f;
	  PyramidObject::crtWidth       = 0.0f;
	  PyramidObject::crtDepth       = 0.0f;
	  PyramidObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_WIDTH	0
#define PB_DEPTH	1
#define PB_HEIGHT	2
#define PB_WSEGS	3
#define PB_DSEGS	4
#define PB_HSEGS	5
#define PB_GENUVS	6

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_WIDTH			2
#define PB_TI_DEPTH			3
#define PB_TI_HEIGHT		4

#define BMIN_HEIGHT		float(-1.0E30)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
#define BMIN_WIDTH		float(0)
#define BMAX_WIDTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_PYR_CREATEBASE,IDC_PYR_CREATECENTER};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1

//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_PYR_POSX,IDC_PYR_POSXSPIN,
		IDC_PYR_POSY,IDC_PYR_POSYSPIN,
		IDC_PYR_POSZ,IDC_PYR_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Width
	ParamUIDesc(
		PB_TI_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_PYR_WIDTH,IDC_PYR_WIDTHSPIN,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Depth
	ParamUIDesc(
		PB_TI_DEPTH,
		EDITTYPE_UNIVERSE,
		IDC_PYR_DEPTH,IDC_PYR_DEPTHSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_PYR_HEIGHT,IDC_PYR_HEIGHTSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	
	};
#define TYPEINDESC_LENGTH 4


//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_PYR_WIDTH,IDC_PYR_WIDTHSPIN,
		BMIN_WIDTH,BMAX_WIDTH,
		SPIN_AUTOSCALE),	

	// Depth
	ParamUIDesc(
		PB_DEPTH,
		EDITTYPE_UNIVERSE,
		IDC_PYR_DEPTH,IDC_PYR_DEPTHSPIN,
		BMIN_LENGTH,BMAX_LENGTH,
		SPIN_AUTOSCALE),
	
	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_PYR_HEIGHT,IDC_PYR_HEIGHTSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),	

	// Width Segments
	ParamUIDesc(
		PB_WSEGS,
		EDITTYPE_INT,
		IDC_PYR_WIDSEGS,IDC_PYR_WIDSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Depth Segments
	ParamUIDesc(
		PB_DSEGS,
		EDITTYPE_INT,
		IDC_PYR_DEPSEGS,IDC_PYR_DEPSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),
	
	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_PYR_HGTSEGS,IDC_PYR_HGTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			
	};
#define PARAMDESC_LENGTH 7


// variable type, NULL, animatable, number
ParamBlockDescID PyramiddescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 }, 
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, FALSE, 6 }, 
	};

#define PBLOCK_LENGTH	7

#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(PyramiddescVer0,PBLOCK_LENGTH,CURRENT_VERSION);

//--- TypeInDlgProc --------------------------------

class PyramidTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		PyramidObject *ob;

		PyramidTypeInDlgProc(PyramidObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL PyramidTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_PR_CREATE: {
					if (ob->crtHeight==0.0f) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_WIDTH,0,ob->crtWidth);
						ob->pblock->SetValue(PB_DEPTH,0,ob->crtDepth);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}


//--- Pyramid methods -------------------------------

PyramidObject::PyramidObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(PyramiddescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_WSEGS,0,dlgWSegs);
	pblock->SetValue(PB_DSEGS,0,dlgDSegs);	
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);	

	pblock->SetValue(PB_WIDTH,0,crtWidth);
	pblock->SetValue(PB_DEPTH,0,crtDepth);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	}

IOResult PyramidObject::Load(ILoad *iload) 
	{
	return IO_OK;
	}


void PyramidObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Pyramid ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PYRAMID1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_PYRAMID2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_PYRAMID3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}

	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new PyramidTypeInDlgProc(this));
		}	
	}
		
void PyramidObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_WSEGS,ip->GetTime(),dlgWSegs,FOREVER);
	pblock->GetValue(PB_DSEGS,ip->GetTime(),dlgDSegs,FOREVER);
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);	
	}

/*void PyramidObject::SetParams(float rad, float height, int segs, int sides, int capsegs, BOOL smooth, 
	pblock->SetValue(PB_WIDTH,0,width);
	pblock->SetValue(PB_DEPTH,0,depth);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_WSEGS,0,wsegs);
	pblock->SetValue(PB_DSEGS,0,dsegs);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_GENUVS,0, genUV);
*/

void BuildPyramidMesh(Mesh &mesh,
		int hsegs, int wsegs, int dsegs, float height, 
		float width, float depth, int genUVs)
{	int nf=0,ulevel=wsegs+dsegs+2,totalsegs=2*(wsegs+dsegs);
	int nfaces,ntverts;
	nfaces = 2*totalsegs*hsegs;
	int nverts = totalsegs*hsegs+2;

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	if (genUVs) 
	{	ntverts = ulevel*hsegs+2+totalsegs;
		mesh.setNumTVerts(ntverts);
		mesh.setNumTVFaces(nfaces);
	} 
	else 
	{	mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
	}
	
	Point3 CenterPt=Point3(width/2.0f,depth/2.0f,height);
	mesh.setVert(0,0.0f,0.0f,height);
	mesh.setVert(nverts-1,0.0f,0.0f,0.0f);
	if (genUVs) 
	{	mesh.setTVert(0,0.5f,1.0f,0.0f);
		mesh.setTVert(ntverts-1,0.5f,0.5f,0.0f);
	}
	int i,lpt,nv=1,tnv=1,fc=0,t0,tot0=totalsegs+1,tt0;
	float hwid=width/2.0f,hdep=depth/2.0f;
	float lwidth=width/hsegs,wincr,dincr,ldepth=depth/hsegs,hpos;
	float dstart,wstart,wpos,dpos,v,hdelta=height/hsegs;
	t0=tt0=0;int visflag;
	for (i=1;i<=hsegs;i++)
	{	v = (hpos=height-hdelta*i)/height;
		wincr=(wstart=lwidth*i)/wsegs;
		wstart=wstart/-2.0f;
		dincr=(dstart=ldepth*i)/dsegs;
		dstart=dstart/-2.0f;
		mesh.setVert(nv++,wstart,dstart,hpos);
		wpos=wstart;
		visflag=(i==1?ALLF:0);
		if (genUVs) 
			mesh.setTVert(tnv++,(1.0f-(hwid-wstart)/width),v,0.0f);
		for (lpt=1;lpt<=wsegs;lpt++)
		{	mesh.setVert(nv,wpos+=wincr,dstart,hpos);
			if (genUVs) 
			{	tt0 = tnv-ulevel-1;
				mesh.tvFace[fc].setTVerts((i<2?0:tt0),tnv-1,tnv);
				if (i>1)		
					mesh.tvFace[fc+1].setTVerts(tt0,tnv,tt0+1);
				mesh.setTVert(tnv++,(1.0f-(hwid-wpos)/width),v,0.0f);
			}
			AddFace(&mesh.faces[fc++],(i>1?t0:0),nv-1,nv,visflag,4);
			if (i>1) 
			{	AddFace(&mesh.faces[fc++],t0,nv,t0+1,1,4);
				t0++;
			}
			nv++;
		}
		if (genUVs) 
			mesh.setTVert(tnv++,(1.0f-(hwid-dstart)/depth),v,0.0f);
		dpos=dstart;
		for (lpt=1;lpt<=dsegs;lpt++)
		{	mesh.setVert(nv,wpos,dpos+=dincr,hpos);
			if (genUVs) 
			{	tt0=tnv-ulevel-1;
				mesh.tvFace[fc].setTVerts((i<2?0:tt0),tnv-1,tnv);
				if (i>1)		
					mesh.tvFace[fc+1].setTVerts(tt0,tnv,tt0+1);
				mesh.setTVert(tnv++,(1.0f-(hwid-dpos)/depth),v,0.0f);
			}
			AddFace(&mesh.faces[fc++],(i>1?t0:0),nv-1,nv,visflag,2);
			if (i>1) 
			{	AddFace(&mesh.faces[fc++],t0,nv,t0+1,1,2);
				t0++;
			}
			nv++;
		}
		if (genUVs) 
		{	tnv++; 
			tt0=(tnv-=ulevel)-ulevel-1;
		}
		for (lpt=1;lpt<=wsegs;lpt++)
		{	mesh.setVert(nv,wpos-=wincr,dpos,hpos);
			if (genUVs) 
			{	mesh.tvFace[fc].setTVerts((i<2?0:tt0),tnv-1,tnv);
				if (i>1)		
					mesh.tvFace[fc+1].setTVerts(tt0,tnv,tt0+1);
				tnv++;
				tt0++;
			}
			AddFace(&mesh.faces[fc++],(i<2?0:t0),nv-1,nv,visflag,16);
			if (i>1) 
			{	AddFace(&mesh.faces[fc++],t0,nv,t0+1,1,16);
				t0++;
			}
			nv++;
		}
		if (genUVs)
		{	tnv++;
			tt0=tnv-ulevel-1;
		}
		for (lpt=1;lpt<=dsegs;lpt++)
		{	if (lpt<dsegs) 
				mesh.setVert(nv,wpos,dpos-=dincr,hpos);
			if (genUVs) 
			{	mesh.tvFace[fc].setTVerts((i<2?0:tt0),tnv-1,tnv);
				if (i>1)		
					mesh.tvFace[fc+1].setTVerts(tt0,tnv,tt0+1);
				tnv++;tt0++;
			}
			if (lpt==dsegs)
			{	AddFace(&mesh.faces[fc++],t0,nv-1,t0+1,visflag,32);
				if (i>1) 
				{	AddFace(&mesh.faces[fc++],t0,t0+1,t0-totalsegs+1,1,32);
					t0++;
				}
			}
			else
			{	AddFace(&mesh.faces[fc++],(i<2?0:t0),nv-1,nv,visflag,32);
				if (i>1) 
				{	AddFace(&mesh.faces[fc++],t0,nv,t0+1,1,32);
					t0++;
				}
			}
			if (lpt<dsegs) 
				nv++;
		}
		if (i==1) 
			t0=1;
	}
	// Now make faces ---
	int b0 = nverts-1,
		bt = ntverts-1;
	if (genUVs) 
	{	mesh.setTVert(tnv++,(1.0f-(hwid-mesh.verts[t0].x)/(float)width),(hdep-mesh.verts[t0].y)/(float)depth,0.0f);
	}
	t0++;
	for (i=1;i<=totalsegs;i++)
	{	if (genUVs) 
		{	mesh.tvFace[fc].setTVerts(tnv-1,bt,(i<totalsegs?tnv:tnv-totalsegs));
			mesh.setTVert(tnv++,(1.0f-(hwid-mesh.verts[t0].x)/(float)width),(hdep-mesh.verts[t0].y)/(float)depth,0.0f);
		}
		AddFace(&mesh.faces[fc++],t0-1,b0,(i<totalsegs?t0:t0-totalsegs),ALLF,8);
		t0++;
	}
	if (height<0)
	{	DWORD hold;
		int tedge0,tedge1,tedge2;
		for (i=0;i<fc;i++)
		{	tedge0=(mesh.faces[i].getEdgeVis(0)?EDGE_VIS:EDGE_INVIS);
			tedge1=(mesh.faces[i].getEdgeVis(1)?EDGE_VIS:EDGE_INVIS);
			tedge2=(mesh.faces[i].getEdgeVis(2)?EDGE_VIS:EDGE_INVIS);
			hold=mesh.faces[i].v[0];mesh.faces[i].v[0]=mesh.faces[i].v[2];mesh.faces[i].v[2]=hold;
			mesh.faces[i].setEdgeVisFlags(tedge1,tedge0,tedge2);
 			if (genUVs)
			{	hold=mesh.tvFace[i].t[0];mesh.tvFace[i].t[0]=mesh.tvFace[i].t[2];mesh.tvFace[i].t[2]=hold;
			}
		}
	}
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts); 
	mesh.InvalidateGeomCache();
    mesh.InvalidateTopologyCache(); 
    mesh.BuildStripsAndEdges();
}

BOOL PyramidObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void PyramidObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void PyramidObject::BuildMesh(TimeValue t)
	{	
	int hsegs,wsegs,dsegs;
	float height,width,depth;
	int genUVs;	

	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_WSEGS,t,wsegs,ivalid);
	pblock->GetValue(PB_DSEGS,t,dsegs,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_WIDTH,t,width,ivalid);
	pblock->GetValue(PB_DEPTH,t,depth,ivalid);
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(width, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(depth, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(wsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(dsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	
	BuildPyramidMesh(mesh, hsegs, wsegs, dsegs, height, 
		width, depth, genUVs);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}



#ifndef NO_NURBS

Object*
BuildNURBSPyramid(float width, float depth, float height, int genUVs)
{
	int pyramid_faces[5][4] = { {0, 1, 2, 3}, // bottom
							{2, 3, 4, 4}, // back
							{1, 0, 4, 4}, // front
							{3, 1, 4, 4}, // left
							{0, 2, 4, 4}};// right
	Point3 pyramid_verts[5] = { Point3(-0.5, -0.5, 0.0),
							Point3( 0.5, -0.5, 0.0),
							Point3(-0.5,  0.5, 0.0),
							Point3( 0.5,  0.5, 0.0),
							Point3( 0.0,  0.0, 1.0)};

	NURBSSet nset;

	for (int face = 0; face < 5; face++) {
		Point3 bl = pyramid_verts[pyramid_faces[face][0]];
		Point3 br = pyramid_verts[pyramid_faces[face][1]];
		Point3 tl = pyramid_verts[pyramid_faces[face][2]];
		Point3 tr = pyramid_verts[pyramid_faces[face][3]];

		Matrix3 size;
		size.IdentityMatrix();
		Point3 lwh(width, depth, height);
		size.Scale(lwh);

		bl = bl * size;
		br = br * size;
		tl = tl * size;
		tr = tr * size;

		NURBSCVSurface *surf = new NURBSCVSurface();
		nset.AppendObject(surf);
		surf->SetUOrder(4);
		surf->SetVOrder(4);
		surf->SetNumCVs(4, 4);
		surf->SetNumUKnots(8);
		surf->SetNumVKnots(8);

		Point3 top, bot;
		for (int r = 0; r < 4; r++) {
			top = tl + (((float)r/3.0f) * (tr - tl));
			bot = bl + (((float)r/3.0f) * (br - bl));
			for (int c = 0; c < 4; c++) {
				NURBSControlVertex ncv;
				ncv.SetPosition(0, bot + (((float)c/3.0f) * (top - bot)));
				ncv.SetWeight(0, 1.0f);
				surf->SetCV(r, c, ncv);
			}
		}

		for (int k = 0; k < 4; k++) {
			surf->SetUKnot(k, 0.0);
			surf->SetVKnot(k, 0.0);
			surf->SetUKnot(k + 4, 1.0);
			surf->SetVKnot(k + 4, 1.0);
		}

		surf->Renderable(TRUE);
		surf->SetGenerateUVs(genUVs);
		if (height > 0.0f)
			surf->FlipNormals(TRUE);
		else
			surf->FlipNormals(FALSE);

		switch(face) {
		case 0: // bottom
			surf->SetTextureUVs(0, 0, Point2(1.0f, 0.0f));
			surf->SetTextureUVs(0, 1, Point2(0.0f, 0.0f));
			surf->SetTextureUVs(0, 2, Point2(1.0f, 1.0f));
			surf->SetTextureUVs(0, 3, Point2(0.0f, 1.0f));
			break;
		default: // sides
			surf->SetTextureUVs(0, 0, Point2(0.5f, 1.0f));
			surf->SetTextureUVs(0, 1, Point2(0.5f, 1.0f));
			surf->SetTextureUVs(0, 2, Point2(0.0f, 0.0f));
			surf->SetTextureUVs(0, 3, Point2(1.0f, 0.0f));
			break;
		}

		char bname[80];
		sprintf(bname, "%s%02d", GetString(IDS_CT_SURF), face);
		surf->SetName(bname);
	}

#define F(s1, s2, s1r, s1c, s2r, s2c) \
	fuse.mSurf1 = (s1); \
	fuse.mSurf2 = (s2); \
	fuse.mRow1 = (s1r); \
	fuse.mCol1 = (s1c); \
	fuse.mRow2 = (s2r); \
	fuse.mCol2 = (s2c); \
	nset.mSurfFuse.Append(1, &fuse);

	NURBSFuseSurfaceCV fuse;
	// Fuse the degenerate peaks
	for (int i = 1; i < 5; i++) {
		for (int j = 1; j < 4; j++) {
			F(i, i, 0, 3, j, 3);
		}
	}

	// Fuse the peaks together
	F(1, 2, 0, 3, 0, 3);
	F(1, 3, 0, 3, 0, 3);
	F(1, 4, 0, 3, 0, 3);

	// Bottom(0) to Back (1)
	F(0, 1, 3, 3, 3, 0);
	F(0, 1, 2, 3, 2, 0);
	F(0, 1, 1, 3, 1, 0);
	F(0, 1, 0, 3, 0, 0);

	// Bottom(0) to Front (2)
	F(0, 2, 0, 0, 3, 0);
	F(0, 2, 1, 0, 2, 0);
	F(0, 2, 2, 0, 1, 0);
	F(0, 2, 3, 0, 0, 0);

	// Bottom(0) to Left (3)
	F(0, 3, 3, 0, 3, 0);
	F(0, 3, 3, 1, 2, 0);
	F(0, 3, 3, 2, 1, 0);
	F(0, 3, 3, 3, 0, 0);

	// Bottom(0) to Right (4)
	F(0, 4, 0, 0, 0, 0);
	F(0, 4, 0, 1, 1, 0);
	F(0, 4, 0, 2, 2, 0);
	F(0, 4, 0, 3, 3, 0);

	// Front (2)  to Right (4)
	F(2, 4, 3, 1, 0, 1);
	F(2, 4, 3, 2, 0, 2);

	// Right (4) to Back (1)
	F(4, 1, 3, 1, 0, 1);
	F(4, 1, 3, 2, 0, 2);

	// Back (1) to Left (3)
	F(1, 3, 3, 1, 0, 1);
	F(1, 3, 3, 2, 0, 2);

	// Left (3) to Front (2)
	F(3, 2, 3, 1, 0, 1);
	F(3, 2, 3, 2, 0, 2);

	Matrix3 mat;
	mat.IdentityMatrix();
	Object *obj = CreateNURBSObject(NULL, &nset, mat);
	return obj;
}

#endif

Object* PyramidObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID) {
		Interval valid = FOREVER;
		float depth, width, height;
		int genUVs;
		pblock->GetValue(PB_WIDTH,t,width,valid);
		pblock->GetValue(PB_DEPTH,t,depth,valid);
		pblock->GetValue(PB_HEIGHT,t,height,valid);
		pblock->GetValue(PB_GENUVS,t,genUVs,valid);
		Object *ob = BuildNURBSPyramid(width, depth, height, genUVs);
		ob->SetChannelValidity(TOPO_CHAN_NUM,valid);
		ob->SetChannelValidity(GEOM_CHAN_NUM,valid);
		ob->UnlockObject();
		return ob;
	} 
#endif
    return SimpleObject::ConvertToType(t,obtype);
	}

int PyramidObject::CanConvertToType(Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID)
        return 1;
#endif
	if (obtype == triObjectClassID)
		return 1;

    return SimpleObject::CanConvertToType(obtype);
	}


void PyramidObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}


class PyramidObjCreateCallBack: public CreateMouseCallBack {
	PyramidObject *ob;	
	Point3 p[2],d;
	IPoint2 sp0,sp1;
	BOOL square;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(PyramidObject *obj) { ob = obj; }
	};

int PyramidObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) 
{

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
		case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				p[1] = p[0] + Point3(.01,.01,.01);
				mat.SetTrans(float(.5)*(p[0]+p[1]));				
				ob->pblock->SetValue(PB_WIDTH,0,0.01f);
				ob->pblock->SetValue(PB_DEPTH,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				ob->pmapParam->Invalidate();				
				break;
			case 1: 
				sp1 = m;
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				p[1].z = p[0].z +(float).01; 
				if (ob->dlgCreateMeth || (flags&MOUSE_CTRL)) 
				{ mat.SetTrans(p[0]);	} 
				else mat.SetTrans(float(.5)*(p[0]+p[1]));
				d = p[1]-p[0];
				square = FALSE;
				if (flags&MOUSE_CTRL) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;
					square = TRUE;
					}
				ob->pblock->SetValue(PB_WIDTH,0,(float)fabs(d.x));
				ob->pblock->SetValue(PB_DEPTH,0,(float)fabs(d.y));
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT && (Length(sp1-sp0)<3 || Length(d)<0.1f)) 
				{ return CREATE_ABORT;	}
				break;
			case 2:
#ifdef _OSNAP
				p[1].z = vpt->SnapLength(vpt->GetCPDisp(p[0],Point3(0,0,1),sp1,m,TRUE));
#else
				p[1].z = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
//				mat.SetTrans(2,(p[1].z>0?p[0].z:p[1].z));			
				ob->pblock->SetValue(PB_WIDTH,0,(float)fabs(d.x));
				ob->pblock->SetValue(PB_DEPTH,0,(float)fabs(d.y));
				ob->pblock->SetValue(PB_HEIGHT,0,p[1].z);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) {					
					ob->suspendSnap = FALSE;
					return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
					}
				break;

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}
	return 1;
	}

static PyramidObjCreateCallBack cylCreateCB;

CreateMouseCallBack* PyramidObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL PyramidObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_WIDTH,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL PyramidObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		}		
	return TRUE;
	}

BOOL PyramidObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_WIDTH: crtWidth = v; break;
		case PB_TI_DEPTH: crtDepth = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL PyramidObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL PyramidObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		}
	return TRUE;
	}

BOOL PyramidObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_WIDTH: v = crtWidth; break;
		case PB_TI_DEPTH: v = crtDepth; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		}
	return TRUE;
	}

BOOL PyramidObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void PyramidObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *PyramidObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_WIDTH: return stdWorldDim;
		case PB_DEPTH:return stdWorldDim;
		case PB_HEIGHT:return stdWorldDim;
		case PB_WSEGS: return stdSegmentsDim;
		case PB_DSEGS: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;
		default: return defaultDim;
		}
	}

TSTR PyramidObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_WIDTH:  return TSTR(GetString(IDS_RB_WIDTH));
		case PB_DEPTH: return TSTR(GetString(IDS_RB_DEPTH));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_WSEGS:  return TSTR(GetString(IDS_RB_WSEGS));
		case PB_DSEGS:  return TSTR(GetString(IDS_RB_DSEGS));
		case PB_HSEGS:  return TSTR(GetString(IDS_RB_HSEGS));
		default: return TSTR(_T(""));		
		}
	}

RefTargetHandle PyramidObject::Clone(RemapDir& remap) 
	{
	PyramidObject* newob = new PyramidObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\scs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by scs.rc
//
#define IDS_RB_CREATE_DIALOG            1
#define IDS_RB_KEYBOARDENTRY            2
#define IDS_AP_DAMPPARAMETERS           3
#define IDS_RB_LENGTH                   4
#define IDS_RB_WIDTH                    5
#define IDS_RB_HEIGHT                   6
#define IDS_RB_RADIUS                   7
#define IDS_RB_WSEGS                    8
#define IDS_RB_LSEGS                    9
#define IDS_RB_HSEGS                    10
#define IDS_RB_CSEGS                    11
#define IDS_RB_BSEGS                    12
#define IDS_RB_SSEGS                    13
#define IDS_RB_TSEGS                    14
#define IDS_RB_TOPLENGTH                15
#define IDS_RB_SIDELENGTH               16
#define IDS_RB_BOTLENGTH                17
#define IDS_RB_TOPWIDTH                 18
#define IDS_RB_SIDEWIDTH                19
#define IDS_RB_BOTWIDTH                 20
#define IDS_RB_FILLET                   21
#define IDS_RB_FSEGS                    22
#define IDS_RB_SIDES                    23
#define IDS_RB_CAPSEGS                  24
#define IDS_RB_SLICEFROM                25
#define IDS_RB_SLICETO                  26
#define IDS_RB_SIDE1                    27
#define IDS_RB_S2SEGS                   28
#define IDS_RB_S3SEGS                   29
#define IDS_STRING30                    30
#define IDS_AP_CREATE                   30
#define IDS_RB_SIDE2                    31
#define IDS_RB_SIDE3                    32
#define IDS_RB_DEPTH                    33
#define IDS_RB_DSEGS                    34
#define IDS_RB_CAPHEIGHT                35
#define IDS_RB_BLEND                    36
#define IDS_RB_CHBOX                    37
#define IDS_RB_EXTENDED                 38
#define IDS_RB_CHNAME                   39
#define IDS_RB_CHCYLINDER               40
#define IDS_RB_OILTNK                   41
#define IDS_RB_SPINDLE                  42
#define IDS_RB_SCUBA                    43
#define IDS_RB_GENGON                   44
#define IDS_RB_PRISM                    45
#define IDS_RB_S1SEGS                   46
#define IDS_RB_PYRAMID                  47
#define IDS_RB_CEXT                     48
#define IDS_RB_LEXT                     49
#define IDS_RB_SLICEON                  50
#define IDS_RB_SMOOTHON                 51
#define IDS_AP_PRIMITIVES               52
#define IDS_CT_SURF                     53
#define IDS_SM_NURBS_SURFACE            54
#define IDS_AP_FRONTWIDTH               55
#define IDS_AP_FRONTSEGS                56
#define IDS_AP_FRONTLENGTH              57
#define IDS_AP_BACKLENGTH               58
#define IDS_AP_BACKWIDTH                59
#define IDS_AP_BACKSEGS                 60
#define IDS_AP_SCSLIB                   61
#define IDS_AP_OILTNK_CLASS             62
#define IDS_AP_CEXT_CLASS               63
#define IDS_AP_CHBOX_CLASS              64
#define IDS_AP_CHCYLINDER_CLASS         65
#define IDS_AP_GENGON_CLASS             66
#define IDS_AP_LEXT_CLASS               67
#define IDS_AP_PRISM_CLASS              68
#define IDS_AP_PYRAMID_CLASS            69
#define IDS_AP_SCUBA_CLASS              70
#define IDS_AP_SPINDLE_CLASS            71
#define IDS_AP_ENDSMETHOD               72
#define IDS_AP_NOREFLENGTH              73
#define IDS_AP_OD                       74
#define IDS_AP_COILS                    75
#define IDS_AP_SEGMENTS                 76
#define IDS_AP_SMOOTH                   77
#define IDS_AP_WIRETYPE                 78
#define IDS_AP_RNDDIA                   79
#define IDS_AP_RNDSIDES                 80
#define IDS_AP_RECTWIDTH                81
#define IDS_AP_RECTDEPTH                82
#define IDS_AP_FILLET                   83
#define IDS_AP_RFILLET                  83
#define IDS_AP_FILLETSIDES              84
#define IDS_AP_RFILLETSIDES             84
#define IDS_AP_DSECWIDTH                85
#define IDS_AP_DSECDEPTH                86
#define IDS_AP_DSECRNDSIDES             87
#define IDS_AP_FREELENGTH               88
#define IDS_AP_KVALUE                   89
#define IDS_AP_KVALUNITS                90
#define IDS_AP_SPRINGDIR                91
#define IDS_AP_SPRING                   92
#define IDS_AP_COMPICK                  93
#define IDS_AP_COMPICK2                 94
#define IDS_AP_NONE                     95
#define IDS_AP_PARAMS                   96
#define IDS_AP_DAMPER                   97
#define IDS_EP_DYNPRIMS                 98
#define IDS_AP_NOREFDL                  99
#define IDS_AP_MOUNTDIA                 100
#define IDD_CHAMFERCUBE1                101
#define IDS_AP_MOUNTLEN                 101
#define IDD_CHAMFERCYL1                 102
#define IDD_UREVS1                      102
#define IDS_AP_CYLDIA                   102
#define IDS_AP_CYLLEN                   103
#define IDS_AP_CYLSIDES                 104
#define IDS_AP_CYLFILLET1               105
#define IDS_AP_CYLFILLET1SEGS           106
#define IDS_AP_CYLFILLET2               107
#define IDS_AP_CYLFILLET2SEGS           108
#define IDS_AP_INSIDEDIA                109
#define IDS_AP_SMOOTHCYL                110
#define IDS_AP_PISTONDIA                111
#define IDS_AP_PISTONLEN                112
#define IDS_AP_PISTONSIDES              113
#define IDS_AP_SMOOTHPISTON             114
#define IDS_AP_ENABLEBOOT               115
#define IDS_AP_BOOTDIA1                 116
#define IDS_AP_BOOTDIA2                 117
#define IDS_AP_BOOTSIDES                118
#define IDS_AP_BOOTFOLDS                119
#define IDS_AP_BOOTRESOLUTION           120
#define IDS_AP_BOOTSTOPDIA              121
#define IDS_AP_BOOTSTOPLEN              122
#define IDS_AP_BOOTSETBACK              123
#define IDS_AP_BOOTSTOPFILLET           124
#define IDS_AP_BOOTSTOPFILLETSEGS       125
#define IDS_AP_SMOOTHBOOT               126
#define IDS_AP_DYNTYPE                  127
#define IDS_AP_DYNDRAG                  128
#define IDS_AP_DFILLET                  129
#define IDS_AP_DYNFORCE                 130
#define IDS_AP_DYNFORCEUNITS            131
#define IDS_AP_DYNDRAGUNITS             132
#define IDS_AP_COILDIR                  133
#define IDS_AP_SEGMENTMETHOD            134
#define IDS_AP_SEGSPERTURN              135
#define IDS_AP_RENDER                   136
#define IDS_AP_RECTROT                  137
#define IDS_AP_DSECROT                  138
#define IDS_AP_DAMPERDIR                139
#define IDS_AP_MAPME                    140
#define IDS_AP_NL                       141
#define IDS_AP_DFILLETSIDES             142
#define IDS_AP_PARAMETERS               143
#define IDS_AP_CREATEMODE               144
#define IDS_AP_PICKMODE                 145
#define IDD_C_EXTRUSION2                146
#define IDS_AP_HOSE                     146
#define IDD_UEXTRUSIONS1                147
#define IDS_EP_BONUSPRIMS               147
#define IDD_C_EXTRUSION3                148
#define IDS_EP_HOSEHEIGHT               148
#define IDS_EP_SEGMENTS                 149
#define IDD_L_EXTRUSION2                150
#define IDS_EP_RENDERHOSE               150
#define IDD_L_EXTRUSION3                151
#define IDS_AP_HOSETYPE                 151
#define IDD_CHAMFERCUBE2                152
#define IDS_AP_HOSEDIA                  152
#define IDD_CHAMFERCUBE3                153
#define IDS_AP_HOSESIDES                153
#define IDD_CHAMFERCYL2                 154
#define IDS_AP_HOSERECTWIDTH            154
#define IDD_CHAMFERCYL3                 155
#define IDS_AP_HOSERECTDEPTH            155
#define IDC_CROSS_HAIR                  156
#define IDS_AP_HOSERFILLET              156
#define IDS_AP_HOSERFILLETSIDES         157
#define IDD_OILTANK2                    158
#define IDS_AP_HOSERECTROT              158
#define IDS_AP_HOSEDSECWIDTH            159
#define IDS_AP_HOSEDSECDEPTH            160
#define IDS_AP_HOSEDFILLET              161
#define IDS_AP_HOSEDFILLETSIDES         162
#define IDS_AP_HOSEDSECRNDSIDES         163
#define IDS_AP_HOSEDSECROT              164
#define IDS_AP_HOSEMAPME                165
#define IDS_AP_HOSEPARAMS               166
#define IDC_OT_SLICE1SPIN               1001
#define IDC_CC_CREATECUBE               1002
#define IDC_OT_SLICE2SPIN               1002
#define IDC_CC_CREATEBOX                1003
#define IDC_OT_SLICE2                   1003
#define IDC_OT_SLICE1                   1004
#define IDC_OT_POSX                     1013
#define IDC_CEXT_BSEGSPIN               1013
#define IDC_OT_POSXSPIN                 1014
#define IDC_CEXT_BSEGS                  1014
#define IDC_OT_POSY                     1015
#define IDC_CEXT_SSEGSPIN               1015
#define IDC_OT_POSYSPIN                 1016
#define IDC_CEXT_SSEGS                  1016
#define IDC_OT_POSZ                     1017
#define IDC_CEXT_TSEGSPIN               1017
#define IDC_OT_POSZSPIN                 1018
#define IDC_CEXT_TSEGS                  1018
#define IDC_OT_RADIUS                   1019
#define IDC_OT_RADIUSSPIN               1020
#define IDC_OT_HEIGHT                   1021
#define IDC_OT_HEIGHTSPIN               1022
#define IDC_OT_BLEND                    1023
#define IDC_CCY_SMOOTHON                1023
#define IDC_OT_BLENDSPIN                1024
#define IDC_OT_CREATE                   1025
#define IDC_UCYLS_BYDIA                 1026
#define IDC_OT_CAPHGT                   1026
#define IDC_UCYLS_BYRAD                 1027
#define IDC_OT_CAPHGTSPIN               1027
#define IDC_GENTEXTURE                  1028
#define IDC_UEXTR_CORNER                1028
#define IDC_UEXTR_CENTER                1029
#define IDC_CEXT_POSX                   1030
#define IDC_CEXT_POSXSPIN               1031
#define IDC_CEXT_POSY                   1032
#define IDC_CEXT_POSYSPIN               1033
#define IDC_CEXT_POSZ                   1034
#define IDC_CEXT_POSZSPIN               1035
#define IDC_CEXT_TOPLEN                 1036
#define IDC_CEXT_TOPLENSPIN             1037
#define IDC_CEXT_SIDELEN                1038
#define IDC_CEXT_SIDELENSPIN            1039
#define IDC_CEXT_BOTLEN                 1040
#define IDC_CEXT_BOTLENSPIN             1041
#define IDC_CEXT_TOPWID                 1042
#define IDC_CEXT_TOPWIDSPIN             1043
#define IDC_CEXT_SIDEWID                1044
#define IDC_CEXT_SIDEWIDSPIN            1045
#define IDC_CEXT_BOTWID                 1046
#define IDC_CEXT_BOTWIDSPIN             1047
#define IDC_CEXT_HEIGHT                 1048
#define IDC_CEXT_HEIGHTSPIN             1049
#define IDC_CEXT_CREATE                 1050
#define IDC_CEXT_HSEGS                  1051
#define IDC_CEXT_HSEGSSPIN              1052
#define IDC_CC_POSX                     1053
#define IDC_CEXT_WSEGS                  1053
#define IDC_CC_POSXSPIN                 1054
#define IDC_CEXT_WSEGSSPIN              1054
#define IDC_CC_POSY                     1055
#define IDC_CC_POSYSPIN                 1056
#define IDC_CC_POSZ                     1057
#define IDC_CC_POSZSPIN                 1058
#define IDC_CC_LENGTH                   1059
#define IDC_CC_LENGTHSPIN               1060
#define IDC_CC_WIDTH                    1061
#define IDC_CC_WIDTHSPIN                1062
#define IDC_CC_RADIUS                   1065
#define IDC_SPRING_OBJ1NAMECAPTION      1065
#define IDC_CC_RADIUSSPIN               1066
#define IDC_SPRING_PICKOBJECT1          1066
#define IDC_CC_CREATE                   1067
#define IDC_SPRING_OBJ1NAME             1067
#define IDC_CC_LENSEGS                  1068
#define IDC_SPRING_OBJ2NAME2            1068
#define IDC_SPRING_OBJ2NAMECAPTION      1068
#define IDC_CC_WIDSEGS                  1069
#define IDC_SPRING_OBJ2NAME             1069
#define IDC_CC_HGTSEGS                  1070
#define IDC_CC_RADSEGS                  1071
#define IDC_CC_LENSEGSSPIN              1072
#define IDC_CC_WIDSEGSSPIN              1073
#define IDC_CC_HGTSEGSSPIN              1074
#define IDC_CC_RADSEGSSPIN              1075
#define IDC_SPRING_PICKOBJECT2          1075
#define IDC_CCY_POSX                    1076
#define IDC_CCY_POSXSPIN                1077
#define IDC_CCY_POSY                    1078
#define IDC_CCY_POSYSPIN                1079
#define IDC_CCY_POSZ                    1080
#define IDC_CCY_POSZSPIN                1081
#define IDC_CCY_RADIUS                  1082
#define IDC_CCY_RADIUSSPIN              1083
#define IDC_CCY_HEIGHT                  1084
#define IDC_CCY_HEIGHTSPIN              1085
#define IDC_CCY_FILLET                  1086
#define IDC_CCY_FILLETSPIN              1087
#define IDC_CCY_CREATE                  1088
#define IDC_CCY_HGTSEGS                 1089
#define IDC_CCY_HGTSEGSSPIN             1090
#define IDC_CCY_FILLETSEGS              1091
#define IDC_CCY_FILLETSEGSSPIN          1092
#define IDC_CCY_SIDES                   1093
#define IDC_CCY_SIDESSPIN               1094
#define IDC_CCY_CAPSEGS                 1095
#define IDC_CCY_CAPSEGSSPIN             1096
#define IDC_CCY_SLICEON                 1097
#define IDC_CCY_SLICE1                  1098
#define IDC_CCY_SLICE1SPIN              1099
#define IDC_CCY_SLICE2SPIN              1100
#define IDC_CCY_SLICE2                  1101
#define IDC_LEXT_POSX                   1102
#define IDC_LEXT_POSXSPIN               1103
#define IDC_LEXT_POSY                   1104
#define IDC_LEXT_POSYSPIN               1105
#define IDC_LEXT_POSZ                   1106
#define IDC_LEXT_POSZSPIN               1107
#define IDC_LEXT_SIDELEN                1108
#define IDC_LEXT_SIDELENSPIN            1109
#define IDC_LEXT_BOTLEN                 1110
#define IDC_PR_SIDE2LEN                 1110
#define IDC_LEXT_BOTLENSPIN             1111
#define IDC_PR_SIDE2LENSPIN             1111
#define IDC_LEXT_SIDEWID                1112
#define IDC_PR_SIDE3LEN                 1112
#define IDC_LEXT_SIDEWIDSPIN            1113
#define IDC_PR_SIDE3LENSPIN             1113
#define IDC_LEXT_BOTWID                 1114
#define IDC_PR_SIDE2SEGS                1114
#define IDC_LEXT_BOTWIDSPIN             1115
#define IDC_PR_SIDE2SEGSSPIN            1115
#define IDC_LEXT_HEIGHT                 1116
#define IDC_PR_SIDE3SEGS                1116
#define IDC_LEXT_HEIGHTSPIN             1117
#define IDC_PR_SIDE3SEGSSPIN            1117
#define IDC_LEXT_CREATE                 1118
#define IDC_LEXT_SIDESEGS               1119
#define IDC_LEXT_SIDESEGSSPIN           1120
#define IDC_LEXT_BOTSEGS                1121
#define IDC_LEXT_BOTSEGSSPIN            1122
#define IDC_LEXT_HGTSEGS                1123
#define IDC_LEXT_HGTSEGSSPIN            1124
#define IDC_PR_CREATEBASE               1137
#define IDC_PR_CREATEVERTICES           1138
#define IDC_PR_POSX                     1139
#define IDC_PR_POSXSPIN                 1140
#define IDC_PR_POSY                     1141
#define IDC_PR_POSYSPIN                 1142
#define IDC_PR_POSZ                     1143
#define IDC_PR_POSZSPIN                 1144
#define IDC_PR_SIDE1LEN                 1145
#define IDC_PR_SIDE1LENSPIN             1146
#define IDC_PR_HEIGHT                   1147
#define IDC_PR_HEIGHTSPIN               1148
#define IDC_PR_CREATE                   1149
#define IDC_PR_SIDE1SEGS                1149
#define IDC_PR_SIDE1SEGSSPIN            1150
#define IDC_PYR_CREATECENTER            1150
#define IDC_PYR_CREATEBASE              1151
#define IDC_PR_HGTSEGS                  1151
#define IDC_PYR_POSX                    1152
#define IDC_PR_HGTSPIN                  1152
#define IDC_PR_CAPSEGS                  1153
#define IDC_PYR_POSY                    1153
#define IDC_PR_CAPSEGSSPIN              1154
#define IDC_PYR_POSZ                    1154
#define IDC_PYR_POSXSPIN                1155
#define IDC_PYR_POSYSPIN                1156
#define IDC_PYR_POSZSPIN                1157
#define IDC_PYR_WIDTH                   1158
#define IDC_PYR_WIDTHSPIN               1159
#define IDC_PYR_DEPTH                   1160
#define IDC_PYR_DEPTHSPIN               1161
#define IDC_PYR_HEIGHT                  1162
#define IDC_PYR_HEIGHTSPIN              1163
#define IDC_PYR_WIDSEGS                 1164
#define IDC_PYR_WIDSEGSSPIN             1165
#define IDC_PYR_DEPSEGS                 1166
#define IDC_PYR_DEPSEGSSPIN             1167
#define IDC_PYR_HGTSEGS                 1168
#define IDC_PYR_HGTSEGSSPIN             1169
#define IDC_GG_POSX                     1170
#define IDC_GG_POSY                     1171
#define IDC_GG_POSZ                     1172
#define IDC_GG_POSXSPIN                 1173
#define IDC_GG_POSYSPIN                 1174
#define IDC_GG_POSZSPIN                 1175
#define IDC_GG_SIDES                    1176
#define IDC_GG_SIDESSPIN                1177
#define IDC_GG_RADIUS                   1178
#define IDC_GG_RADIUSSPIN               1179
#define IDC_GG_FILLET                   1180
#define IDC_GG_FILLETSPIN               1181
#define IDC_GG_HEIGHT                   1182
#define IDC_GG_HEIGHTSPIN               1183
#define IDC_GG_CREATE                   1184
#define IDC_GG_SIDESEGS                 1184
#define IDC_GG_SIDESEGSSPIN             1185
#define IDC_SP_POSX                     1185
#define IDC_SP_POSY                     1186
#define IDC_GG_HGTSEGS                  1186
#define IDC_SP_POSXSPIN                 1187
#define IDC_GG_HGTSEGSSPIN              1187
#define IDC_GG_CAPSEGS                  1188
#define IDC_SP_POSYSPIN                 1188
#define IDC_GG_CAPSEGSSPIN              1189
#define IDC_SP_POSZ                     1189
#define IDC_SP_POSZSPIN                 1190
#define IDC_GG_FILLETSEGS               1190
#define IDC_SP_RADIUS                   1191
#define IDC_GG_FILLETSEGSSPIN           1191
#define IDC_SP_RADIUSSPIN               1192
#define IDC_SP_CAPHGT                   1193
#define IDC_SP_CAPHGTSPIN               1194
#define IDC_SP_HEIGHT                   1195
#define IDC_SP_HEIGHTSPIN               1196
#define IDC_SP_LENOVERALL               1197
#define IDC_SP_LENCENTERS               1198
#define IDC_SP_ONECAP                   1199
#define IDC_SP_TWOCAPS                  1200
#define IDC_SP_BLEND                    1201
#define IDC_SP_BLENDSPIN                1202
#define IDC_SP_CREATE                   1203
#define IDC_SP_SIDES                    1204
#define IDC_SP_SIDESSPIN                1205
#define IDC_SP_HEIGHTSEGS               1206
#define IDC_SP_HEIGHTSEGSSPIN           1207
#define IDC_SP_SMOOTH                   1208
#define IDC_SP_SLICEON                  1209
#define IDC_SP_SLICE1                   1210
#define IDC_SP_SLICE1SPIN               1211
#define IDC_SP_SLICE2                   1212
#define IDC_SP_SLICE2SPIN               1213
#define IDC_SP_CAPSEGS                  1214
#define IDC_SC_POSX                     1214
#define IDC_SP_CAPSEGSSPIN              1215
#define IDC_SC_POSXSPIN                 1215
#define IDC_SC_POSY                     1216
#define IDC_SC_POSYSPIN                 1217
#define IDC_SC_POSZ                     1218
#define IDC_SC_POSZSPIN                 1219
#define IDC_SC_RADIUS                   1220
#define IDC_SC_RADIUSSPIN               1221
#define IDC_SC_HEIGHT                   1224
#define IDC_SC_HEIGHTSPIN               1225
#define IDC_SC_LENOVERALL               1226
#define IDC_SC_LENCENTERS               1227
#define IDC_SC_ONECAP                   1228
#define IDC_SC_TWOCAPS                  1229
#define IDC_SC_CREATE                   1232
#define IDC_SC_SIDES                    1233
#define IDC_SC_SIDESSPIN                1234
#define IDC_SC_HEIGHTSEGS               1235
#define IDC_SC_HEIGHTSEGSSPIN           1236
#define IDC_SC_SMOOTH                   1237
#define IDC_SC_SLICEON                  1238
#define IDC_SC_SLICE1                   1239
#define IDC_SC_SLICE1SPIN               1240
#define IDC_SC_SLICE2                   1241
#define IDC_SC_SLICE2SPIN               1242
#define IDC_LEXT_WIDTHSEGS              1243
#define IDC_LEXT_WIDTHSEGSSPIN          1244
#define IDC_CC_HEIGHT                   1245
#define IDC_CC_HEIGHTSPIN               1246
#define IDC_SPRING_REFS                 1247
#define IDC_SPRING_DIMS                 1248
#define IDC_SPRING_LENGTH               1249
#define IDC_SPRING_LENGTHSPIN           1250
#define IDC_SPRING_OD                   1251
#define IDC_HOSE_TENSION1               1251
#define IDC_SPRING_ODSPIN               1252
#define IDC_HOSE_TENSION1SPIN           1252
#define IDC_SPRING_COILS                1253
#define IDC_HOSE_TENSION2               1253
#define IDC_SPRING_COILSSPIN            1254
#define IDC_HOSE_TENSION2SPIN           1254
#define IDC_SPRING_COILSEGS             1255
#define IDC_SPRING_COILSEGSSPIN         1256
#define IDC_SPRING_ROUNDWIRE            1257
#define IDC_SPRING_RECTWIRE             1258
#define IDC_SPRING_DSECTIONWIRE         1259
#define IDC_SPRING_RNDWIREDIA           1260
#define IDC_SPRING_RNDWIREDIASPIN       1261
#define IDC_SPRING_RECTWIREWID          1262
#define IDC_SPRING_RECTWIREWIDSPIN      1263
#define IDC_SPRING_RECWIREDEPTH         1264
#define IDC_SPRING_RECWIREDEPTHSPIN     1265
#define IDC_SPRING_RNDWIRESIDES         1266
#define IDC_SPRING_RNDWIRESIDESSPIN     1267
#define IDC_SPRING_RECWIREFILLET        1268
#define IDC_SPRING_RECWIREFILLETSPIN    1269
#define IDC_SPRING_RECWIREFILLETSIDES   1270
#define IDC_SPRING_RECWIREFILLETSIDESSPIN 1271
#define IDC_SPRING_DWIREDEPTH           1272
#define IDC_SPRING_DWIREDEPTHSPIN       1273
#define IDC_SPRING_DWIREWID             1274
#define IDC_SPRING_DWIREWIDSPIN         1275
#define IDC_SPRING_DWIREFILLET          1276
#define IDC_SPRING_DWIREFILLETSPIN      1277
#define IDC_SPRING_DWIREFILLETSIDES     1278
#define IDC_SPRING_DWIREFILLETSIDESSPIN 1279
#define IDC_SPRING_DWIRERNDSIDES        1280
#define IDC_SPRING_DWIRERNDSIDESSPIN    1281
#define IDC_SPRING_K                    1282
#define IDC_HOSE_FLEX1                  1282
#define IDC_SPRING_KSPIN                1283
#define IDC_HOSE_FLEX1SPIN              1283
#define IDC_SPRING_L                    1284
#define IDC_HOSE_FLEX2                  1284
#define IDC_SPRING_LSPIN                1285
#define IDC_HOSE_FLEX2SPIN              1285
#define IDC_SPRING_UNITS_NM             1286
#define IDC_RODLEN                      1286
#define IDC_HOSE_FLEXCYCLES             1286
#define IDC_SPRING_UNITS_LBIN           1287
#define IDC_RODLENSPIN                  1287
#define IDC_HOSE_FLEXCYCLESSPIN         1287
#define IDC_SPRING_EXT                  1288
#define IDC_HOSE_DIACHANGE              1288
#define IDC_SPRING_COMP                 1289
#define IDC_HOSE_DIACHANGESPIN          1289
#define IDC_SPRING_BOTH                 1290
#define IDC_SPRING_SMOOTH               1291
#define IDC_SPRING_AUTOSEGS             1292
#define IDC_STUDDIA                     1292
#define IDC_SPRING_MANUALSEGS           1293
#define IDC_STUDDIASPIN                 1293
#define IDC_SPRING_COILSEGSPERTURN      1294
#define IDC_STUDLEN                     1294
#define IDC_SPRING_COILSEGSPERTURNSPIN  1295
#define IDC_STUDLENSPIN                 1295
#define IDC_SPRING_RENDERTHIS           1296
#define IDC_CYLLEN                      1296
#define IDC_SPRING_DROT                 1297
#define IDC_CYLLENSPIN                  1297
#define IDC_SPRING_DROTSPIN             1298
#define IDC_CYLFILLET1                  1298
#define IDC_SPRING_RECTROT              1299
#define IDC_CYLFILLET1SPIN              1299
#define IDC_SPRING_RECTROTSPIN          1300
#define IDC_FILLET1SEGS                 1300
#define IDC_SPRING_CCWDIR               1301
#define IDC_FILLET1SEGSSPIN             1301
#define IDC_HOSE_FLEXON                 1301
#define IDC_SPRING_CWDIR                1302
#define IDC_CYLFILLET2                  1302
#define IDC_CYLFILLET2SPIN              1303
#define IDC_SPRING_SMALL                1303
#define IDC_FILLET2SEGS                 1304
#define IDC_SPRING_SMSIDES              1304
#define IDC_FILLET2SEGSSPIN             1305
#define IDC_SPRING_SMNONE               1305
#define IDC_DAMPER_LENGTH               1306
#define IDC_SPRING_SMSEGS               1306
#define IDC_DAMPER_LENGTHSPIN           1307
#define IDC_CYLDIA                      1308
#define IDC_CYLDIASPIN                  1309
#define IDC_CYLSIDES                    1310
#define IDC_CYLSIDESSPIN                1311
#define IDC_CYLINSIDEDIA                1312
#define IDC_CYLINSIDEDIASPIN            1313
#define IDC_DAMPERON                    1314
#define IDC_ACTUATORON                  1315
#define IDC_DRAGUNITS_LBINSEC           1316
#define IDC_DRAGUNITS_NEWTMS            1317
#define IDC_FORCEUNITS_LBS              1318
#define IDC_FORCEUNITS_NEWTS            1319
#define IDC_SMOOTHCYL                   1320
#define IDC_RODDIA                      1321
#define IDC_RODDIASPIN                  1322
#define IDC_RODSIDES                    1323
#define IDC_RODSIDESSPIN                1324
#define IDC_SMOOTHROD                   1325
#define IDC_BOOTON                      1326
#define IDC_BOOTDIA1                    1327
#define IDC_BOOTDIA1SPIN                1328
#define IDC_BOOTDIA2                    1329
#define IDC_BOOTDIA2SPIN                1330
#define IDC_FOLDS                       1331
#define IDC_FOLDSSPIN                   1332
#define IDC_FOLDRES                     1333
#define IDC_FOLDRESSPIN                 1334
#define IDC_FOLDSIDES                   1335
#define IDC_FOLDSIDESSPIN               1336
#define IDC_SMOOTHBOOT                  1337
#define IDC_BOOTSTOPDIA                 1338
#define IDC_BOOTSTOPDIASPIN             1339
#define IDC_STOPTHICK                   1340
#define IDC_STOPTHICKSPIN               1341
#define IDC_STOPFILLET                  1342
#define IDC_STOPFILLETSPIN              1343
#define IDC_STOPFILLETSEGS              1344
#define IDC_STOPFILLETSEGSSPIN          1345
#define IDC_DRAG                        1346
#define IDC_DRAGSPIN                    1347
#define IDC_FORCE                       1348
#define IDC_FORCESPIN                   1349
#define IDC_STOPSETBACK                 1350
#define IDC_SPRING_MAPME                1350
#define IDC_STOPSETBACKSPIN             1351
#define IDC_SPRING_NL                   1351
#define IDC_DAMPER_RENDERTHIS           1352
#define IDC_DAMPER_MAPME                1353
#define IDD_OILTANK3                    2004
#define IDC_OT_SLICEON                  2005
#define IDD_PRISM2                      2005
#define IDC_OT_SMOOTH                   2006
#define IDD_PRISM1                      2006
#define IDD_PRISM3                      2007
#define IDD_PYRAMID1                    2008
#define IDD_PYRAMID2                    2009
#define IDC_OT_LENOVERALL               2010
#define IDD_PYRAMID3                    2010
#define IDC_OT_LENCENTERS               2011
#define IDD_GENGON2                     2011
#define IDC_OT_ONECAP                   2012
#define IDD_GENGON3                     2012
#define IDC_OT_TWOCAPS                  2013
#define IDD_SPINDLE2                    2013
#define IDD_SPINDLE3                    2014
#define IDD_SCUBA2                      2015
#define IDD_SCUBA3                      2016
#define IDD_SPRING                      2017
#define IDD_DAMPER                      2018
#define IDD_HOSED                       2019
#define IDC_OT_SIDES                    2052
#define IDC_OT_SIDESSPIN                2053
#define IDC_OT_HGTSEGS                  2060
#define IDC_OT_HEIGHTSEGS               2060
#define IDC_OT_HGTSEGSSPIN              2070
#define IDC_OT_HEIGHTSEGSSPIN           2070

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1351
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\scuba.cpp ===
/**********************************************************************
 *<
	FILE: scuba.cpp	- builds "capsule" objects
	CREATED BY:  Audrey Peterson
 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"

static Class_ID SCUBA_CLASS_ID(0x6d3d77ac, 0x79c939a9);
class ScubaObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtRadius;
		static float crtHeight,crtSliceFrom,crtSliceTo;
		static int dlgHSegs, dlgSides,crtCenters;
		static int dlgCreateMeth;
		static int dlgSmooth, dlgSlice;
		static Point3 crtPos;		
		BOOL increate;

		ScubaObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_SCUBA); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return SCUBA_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)
#define MIN_SLICE	float(-1.0E30)
#define MAX_SLICE	float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_SIDES		12

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0



//--- ClassDescriptor and class vars ---------------------------------

class ScubaClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new ScubaObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_SCUBA_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return SCUBA_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static ScubaClassDesc ScubaDesc;

ClassDesc* GetScubaDesc() { return &ScubaDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for Scuba class.
IObjParam *ScubaObject::ip         = NULL;
int ScubaObject::dlgHSegs			= DEF_SEGMENTS;
int ScubaObject::dlgSides          = DEF_SIDES;
int ScubaObject::dlgCreateMeth     = 1; // create_radius
int ScubaObject::dlgSmooth         = SMOOTH_ON;
int ScubaObject::dlgSlice          = 0;
int ScubaObject::crtCenters          = 0;
IParamMap *ScubaObject::pmapCreate = NULL;
IParamMap *ScubaObject::pmapTypeIn = NULL;
IParamMap *ScubaObject::pmapParam  = NULL;
Point3 ScubaObject::crtPos         = Point3(0,0,0);
float ScubaObject::crtRadius       = 0.0f;
float ScubaObject::crtHeight       = 0.0f;
float ScubaObject::crtSliceFrom    = 0.0f;
float ScubaObject::crtSliceTo    = 0.0f;

void ScubaClassDesc::ResetClassParams(BOOL fileReset)
	{ ScubaObject::dlgHSegs			= DEF_SEGMENTS;
	  ScubaObject::dlgSides          = DEF_SIDES;
	  ScubaObject::dlgCreateMeth     = 1; // create_radius
	  ScubaObject::dlgSmooth         = SMOOTH_ON;
	  ScubaObject::dlgSlice          = 0;
	  ScubaObject::crtCenters          = 0;
	  ScubaObject::crtRadius       = 0.0f;
	  ScubaObject::crtHeight       = 0.0f;
	  ScubaObject::crtSliceFrom    = 0.0f;
	  ScubaObject::crtSliceTo    = 0.0f;
	  ScubaObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_RADIUS		0
#define PB_HEIGHT		1
#define PB_CENTERS		2
#define PB_SIDES		3
#define PB_HSEGS		4
#define PB_SMOOTHON		5
#define PB_SLICEON		6
#define PB_SLICEFROM	7
#define PB_SLICETO		8
#define PB_GENUVS		9

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2
#define PB_TI_HEIGHT		3
#define PB_TI_CENTERS		4

// dont worry about the CREATE button here
#define BMIN_HEIGHT		float(0.1)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_UCYLS_BYDIA,IDC_UCYLS_BYRAD};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1


//
//
// Type in

static int centerIDs[] = {IDC_SC_LENOVERALL,IDC_SC_LENCENTERS};

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_SC_POSX,IDC_SC_POSXSPIN,
		IDC_SC_POSY,IDC_SC_POSYSPIN,
		IDC_SC_POSZ,IDC_SC_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_SC_RADIUS,IDC_SC_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_SC_HEIGHT,IDC_SC_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Radio Buttons - centers
	ParamUIDesc(PB_TI_CENTERS,TYPE_RADIO,centerIDs,2),

	};
#define TYPEINDESC_LENGTH 4

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_SC_RADIUS,IDC_SC_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_SC_HEIGHT,IDC_SC_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Radio Buttons - centers
	ParamUIDesc(PB_CENTERS,TYPE_RADIO,centerIDs,2),

	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_SC_SIDES,IDC_SC_SIDESSPIN,
		(float)MIN_SIDES,(float)MAX_SIDES,
		0.1f),
	
	// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_SC_HEIGHTSEGS,IDC_SC_HEIGHTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen Smoothing
	ParamUIDesc(PB_SMOOTHON,TYPE_SINGLECHEKBOX,IDC_SC_SMOOTH),			

	// Gen Slice
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_SC_SLICEON),			

	// Pie slice from
	ParamUIDesc(
		PB_SLICEFROM,
		EDITTYPE_FLOAT,
		IDC_SC_SLICE1,IDC_SC_SLICE1SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Pie slice to
	ParamUIDesc(
		PB_SLICETO,
		EDITTYPE_FLOAT,
		IDC_SC_SLICE2,IDC_SC_SLICE2SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			

	};
#define PARAMDESC_LENGTH 10


// variable type, NULL, animatable, number
ParamBlockDescID ScubadescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 }, 
	{ TYPE_INT, NULL, TRUE, 3 }, 
	{ TYPE_INT, NULL, TRUE, 4 },
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 } 
	};

#define PBLOCK_LENGTH	10

#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(ScubadescVer0,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TypeInDlgProc --------------------------------

void FixHeight(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float radius,height,r2,minh;
  BOOL con,minush;

	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	pblock->GetValue(PB_CENTERS,t,con,FOREVER);
	pblock->GetValue(PB_HEIGHT,(increate?0:t),height,FOREVER);
	r2=2.0f*radius;
	minh=((minush=height<0.0f)?-r2:r2);
	height=(float)fabs(height);
	if (con) height+=r2;
	if (hWnd)
    { ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_SC_HEIGHTSPIN));
	  if (minush) spin2->SetLimits(MIN_HEIGHT,minh);
	  else spin2->SetLimits(minh,BMAX_HEIGHT,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (height<r2)  pblock->SetValue(PB_HEIGHT,(increate?0:t),minh);
}

class ScubaTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		ScubaObject *ob;

		ScubaTypeInDlgProc(ScubaObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ScubaTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SC_CREATE: {
					if (ob->crtRadius==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_CENTERS,0,ob->crtCenters);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}
class ScubaHeightDlgProc : public ParamMapUserDlgProc {
	public:
		ScubaObject *ob;

		ScubaHeightDlgProc(ScubaObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ScubaHeightDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ 	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_SC_HEIGHTSPIN:
					FixHeight(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				}
		}
	return FALSE;
	}

//--- Scuba methods -------------------------------

ScubaObject::ScubaObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(ScubadescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_TI_RADIUS,0,crtRadius);
	pblock->SetValue(PB_TI_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_CENTERS,0,crtCenters);
	pblock->SetValue(PB_SIDES,0,dlgSides);
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);
	pblock->SetValue(PB_SMOOTHON,0,dlgSmooth);
	pblock->SetValue(PB_SLICEON,0,dlgSlice);
	pblock->SetValue(PB_SLICEFROM,0,crtSliceFrom);
	pblock->SetValue(PB_SLICETO,0,crtSliceTo);
	increate=FALSE;
	}

IOResult ScubaObject::Load(ILoad *iload) 
	{
	return IO_OK;
	}


void ScubaObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Scuba ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_UREVS1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SCUBA2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SCUBA3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}


	if(pmapTypeIn) {
		pmapTypeIn->SetUserDlgProc(new ScubaTypeInDlgProc(this));
		}
	if(pmapParam) {
		pmapParam->SetUserDlgProc(new ScubaHeightDlgProc(this));
		}
	}
		
void ScubaObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);	
	}

/*void BoxObject::SetParams(float radius, float capheight, float height,
						  BOOL centers, BOOL ncaps, float blend,
						  int sides, int hsegs, BOOL smooth, BOOL slice, 
						  float slice1, float slice2, BOOL genUV) {
	pblock->SetValue(PB_RADIUS,0,radius);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_CENTERS,0,centers);
	pblock->SetValue(PB_SIDES,0,sides);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_SMOOTH,0,smooth);
	pblock->SetValue(PB_SLICEON,0,slice);
	pblock->SetValue(PB_SLICEFROM,0,slice1);
	pblock->SetValue(PB_SLICETO,0,slice2);
	pblock->SetValue(PB_GENUVS,0,genUV);
	} 
*/


void BuildScubaMesh(Mesh &mesh,
		int segs, int smooth, int llsegs, int doPie, float radius1,
		float height,float pie1, float pie2, int genUVs)
	{
	Point3 p;
	BOOL minush=(height<0.0f);
	if (minush) height=-height;
	int ix,jx,ic = 1;
	int nf=0,nv=0, lsegs,VertexPerLevel,capsegs=(int)(segs/2.0f),csegs=0;
	float delta,ang;	
	float totalPie, startAng = 0.0f;	

	if (doPie) doPie = 1;
	else doPie = 0; 

	lsegs = llsegs-1 + 2*capsegs;

	// Make pie2 < pie1 and pie1-pie2 < TWOPI
	while (pie1 < pie2) pie1 += TWOPI;
	while (pie1 > pie2+TWOPI) pie1 -= TWOPI;
	if (pie1==pie2) totalPie = TWOPI;
	else totalPie = pie1-pie2;		
	int nfaces,ntverts,levels=csegs*2+(llsegs-1);
	int capv=segs,sideedge=capsegs+csegs,*edgelstr,*edgelstl,totlevels;
    // capv=vertex in one cap layer
	totlevels=levels+capsegs*2+2;
	int	tvinslice=totlevels+totlevels-2;
	if (doPie) {
		delta    = totalPie/(float)(segs);
		startAng = pie2; capv++;
		VertexPerLevel=segs+2;
		nfaces=2*segs*(levels+1)+(sideedge+llsegs)*4;
		ntverts=tvinslice+2*(segs+1);
		// 2 faces between every 2 vertices, with 2 ends, except in central cap)
	} else {
		delta = (float)2.0*PI/(float)segs;
		VertexPerLevel=segs;
		nfaces=2*segs*(levels+1);
		ntverts=2*(segs+1)+llsegs-1;
	}

	edgelstl=new int[totlevels];
	edgelstr=new int[totlevels];
	int lastlevel=totlevels-1,dcapv=capv-1,dvertper=VertexPerLevel-1;
	edgelstr[0]=0;edgelstl[0]=0;
	edgelstr[1]=1;
	edgelstl[1]=capv;
	for (int i=2;i<=sideedge;i++)
	{ edgelstr[i]=edgelstr[i-1]+capv;
	  edgelstl[i]=edgelstr[i]+dcapv;
	}
	while ((i<lastlevel)&&(i<=totlevels-sideedge))
	{ edgelstr[i]=edgelstr[i-1]+VertexPerLevel;
	  edgelstl[i]=edgelstr[i]+dcapv;
	  i++;
	}
	while (i<lastlevel)
	{ edgelstr[i]=edgelstr[i-1]+capv;
	  edgelstl[i]=edgelstr[i]+dcapv;
	  i++;
	}
	edgelstl[lastlevel]=(edgelstr[lastlevel]=edgelstl[i-1]+((doPie &&(sideedge==1))?2:1));
	int nverts=edgelstl[lastlevel]+1;

	nfaces+=2*segs*(2*capsegs-1);
	if (height<0) delta = -delta;

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth != 0);
	if (genUVs) 
	{ ntverts+=nverts;
	  mesh.setNumTVerts(ntverts);
	  mesh.setNumTVFaces(nfaces);
	} 
	else 
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	
	mesh.setSmoothFlags((smooth != 0) | ((doPie != 0) << 1));
	// bottom vertex 
	mesh.setVert(nv, Point3(0.0f,0.0f,height));
	mesh.setVert(nverts-1, Point3(0.0f,0.0f,0.0f));		
	float ru,cang,sang,botz;
	//deltacsegs=PI/(2.0f*csegs);
	int msegs=segs,deltaend=nverts-capv-1;
	// Bottom cap vertices
	ang = startAng;	 
	if (!doPie) msegs--;
	float rincr=PI/(2.0f*capsegs),aincr;
	for (jx = 0; jx<=msegs; jx++) 
	{ cang=(float)cos(ang);
	  sang=(float)sin(ang);
	  for(ix=1; ix<=sideedge; ix++)
	  {	ru=radius1*(float)sin(aincr=(rincr*(float)ix));
		if (jx==0)
		 { p.z = height-radius1*(1.0f-(float)cos(aincr));
		 } else p.z=mesh.verts[edgelstr[ix]].z;
		botz=height-p.z;
		if ((doPie)&&((jx==0)&&(ix==sideedge)))
		{ mesh.setVert(edgelstl[ix]+1,Point3(0.0f,0.0f,p.z));
		  mesh.setVert(edgelstl[lastlevel-ix]+1,Point3(0.0f,0.0f,botz));
		}
		p.x = cang*ru;
		p.y = sang*ru;	
		mesh.setVert(edgelstr[ix]+jx, p);
		mesh.setVert(edgelstr[lastlevel-ix]+jx,Point3(p.x,p.y,botz));
	  }
	  ang += delta;
	}
	//top layer done, now reflect sides down 
	int sidevs,startv=edgelstr[sideedge],deltav;				
	if (llsegs>1)
	{ float topd=mesh.verts[startv].z,sincr=(height-2.0f*(height-topd))/llsegs;
	  for (sidevs=0;sidevs<VertexPerLevel;sidevs++)
	  { p=mesh.verts[startv];
	    deltav=VertexPerLevel;
	    for (ic=1;ic<llsegs;ic++)
	    { p.z =topd-sincr*ic;
	 	  mesh.setVert(startv+deltav, p);
		  deltav+=VertexPerLevel;
	    }
	    startv++;
	  }
	}
	int lasttvl=0,lasttvr=0;
	if (genUVs)
	{ int tvcount=0,nexttv;
	  float udenom=2.0f*radius1;
	  for (i=0;i<=sideedge;i++)
	  {	nexttv=edgelstr[i];
		while (nexttv<=edgelstl[i])
		{ mesh.setTVert(tvcount++,(radius1+mesh.verts[nexttv].x)/udenom,(radius1+mesh.verts[nexttv].y)/udenom,0.0f);
		  nexttv++;
	    }
	  }
	  int iseg,hcount=0,lastedge=(sideedge==1?lastlevel-2:lastlevel-1);
	  float hlevel;
	  for (i=sideedge;i<=lastlevel-sideedge;i++)
	  { hlevel=1.0f-hcount++/(float)llsegs;
		for (iseg=0;iseg<=segs;iseg++)
		 mesh.setTVert(tvcount++,(float)iseg/segs,hlevel,0.0f);
	  }
	  i--;
	  while (i<=lastlevel)
	  {	nexttv=edgelstr[i];
		while (nexttv<=edgelstl[i])
		{ mesh.setTVert(tvcount++,(radius1+mesh.verts[nexttv].x)/udenom,(radius1+mesh.verts[nexttv].y)/udenom,0.0f);
		  nexttv++;
	    }
		i++;
	  }
	  if (doPie)
	  { lasttvl=lasttvr=tvcount;
		float u,v;
		mesh.setTVert(tvcount++,0.0f,1.0f,0.0f);
		for (i=sideedge;i<=sideedge+llsegs;i++)
	    { mesh.setTVert(tvcount++,0.0f,mesh.verts[edgelstl[i]].z/height,0.0f);
		}
		mesh.setTVert(tvcount++,0.0f,0.0f,0.0f);
		for (i=1;i<lastlevel;i++)
		{ u=(float)sqrt(mesh.verts[edgelstl[i]].x*mesh.verts[edgelstl[i]].x+mesh.verts[edgelstl[i]].y*mesh.verts[edgelstl[i]].y)/radius1;
		  v=mesh.verts[edgelstl[i]].z/height;
		  mesh.setTVert(tvcount++,u,v,0.0f);
		  mesh.setTVert(tvcount++,u,v,0.0f);
		}
	  }
	}	
	int lvert=(doPie?segs+1:segs);
    int t0,t1,b0,b1,tvt0=0,tvt1=0,tvb0=1,tvb1=2,fc=0,smoothgr=(smooth?4:0),vseg=segs+1;
	int tvcount=0,lowerside=lastlevel-sideedge,onside=0;
	BOOL ok,wrap;
	// Now make faces ---
	for (int clevel=0;clevel<lastlevel-1;clevel++)
	{ t1=(t0=edgelstr[clevel])+1;
	  b1=(b0=edgelstr[clevel+1])+1;
	  ok=!doPie; wrap=FALSE;
	  if ((clevel>0)&&((doPie)||(onside==1))) {tvt0++;tvt1++;tvb0++,tvb1++;}
	  if (clevel==1) {tvt0=1;tvt1=2;}
	  if (clevel==sideedge)
	    {tvt1+=lvert;tvt0+=lvert;tvb0+=vseg;tvb1+=vseg;onside++;}
	  else if (clevel==lowerside)
	    {tvt1+=vseg;tvt0+=vseg;tvb0+=lvert;tvb1+=lvert;onside++;}
	  while ((b0<edgelstl[clevel+1])||ok)
	  { if (b1==edgelstr[clevel+2]) 
	    { b1=edgelstr[clevel+1]; 
	      t1=edgelstr[clevel];
		  ok=FALSE;wrap=(onside!=1);}
	  if (smooth) smoothgr=4;
	  if (genUVs) mesh.tvFace[fc].setTVerts(tvt0,tvb0,(wrap?tvb1-segs:tvb1));
		AddFace(&mesh.faces[fc++],t0,b0,b1,0,smoothgr);
	    if (clevel>0)
		{ if (genUVs)
		  { if (wrap) mesh.tvFace[fc].setTVerts(tvt0++,tvb1-segs,tvt1-segs);
			else mesh.tvFace[fc].setTVerts(tvt0++,tvb1,tvt1);
			tvt1++;
		  }
		  AddFace(&mesh.faces[fc++],t0,b1,t1,1,smoothgr);
		  t0++;t1++;
		}
		b0++;b1++;tvb0++,tvb1++;
	  }
	}
	smoothgr=(smooth?4:0);
	t1=(t0=edgelstr[lastlevel-1])+1;b0=edgelstr[lastlevel];
	int lastpt=(doPie?lastlevel-1:lastlevel);
	if ((doPie)||(onside==1)) {tvt0++;tvt1++;tvb0++,tvb1++;}
	if (sideedge==1) {tvt1+=vseg;tvt0+=vseg;tvb0+=lvert;tvb1+=lvert;onside++;}
	while (t0<edgelstl[lastpt])
	  { if ((!doPie)&&(t1==edgelstr[lastlevel]))
	    { t1=edgelstr[lastlevel-1];tvt1-=segs;}
		if (genUVs) mesh.tvFace[fc].setTVerts(tvt0++,tvb0,tvt1++);
		AddFace(&mesh.faces[fc++],t0,b0,t1,1,smoothgr);
		t0++;t1++;
	  }
	int chv=edgelstl[sideedge]+1,botcap=lastlevel-sideedge;
	int chb=edgelstl[botcap]+1,chm0,chm1,last=0,sg0=(smooth?2:0),sg1=(smooth?1:0);
	if (doPie)
	{int topctv=lasttvl+1,tvcount=topctv+llsegs+2;
	  for (i=1;i<=lastlevel;i++)
	  { if (i<=sideedge)
		{ if (genUVs)
		  { mesh.tvFace[fc].setTVerts(tvcount,topctv,lasttvl);lasttvl=tvcount++;
		    mesh.tvFace[fc+1].setTVerts(lasttvr,topctv,tvcount);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[i],chv,edgelstl[last],(i==1?1:2),sg0);
		  AddFace(&mesh.faces[fc++],edgelstr[last],chv,edgelstr[i],(i==1?3:2),sg1);
		}
	    else if (i<=botcap)
		{ if (genUVs)
		  { topctv++;
			mesh.tvFace[fc].setTVerts(lasttvl,tvcount,topctv);
			mesh.tvFace[fc+1].setTVerts(lasttvl,topctv,topctv-1);lasttvl=tvcount++;
		    mesh.tvFace[fc+2].setTVerts(topctv-1,topctv,tvcount);
		    mesh.tvFace[fc+3].setTVerts(topctv-1,tvcount,lasttvr);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[last],edgelstl[i],chm1=(edgelstl[i]+1),0,sg0);
	      AddFace(&mesh.faces[fc++],edgelstl[last],chm1,chm0=(edgelstl[last]+1),1,sg0);
		  AddFace(&mesh.faces[fc++],chm0,chm1,edgelstr[i],0,sg1);
	      AddFace(&mesh.faces[fc++],chm0,edgelstr[i],edgelstr[last],1,sg1);
		}
		else
		{if (genUVs)
		  {	if (i==lastlevel) tvcount=topctv+1;
			mesh.tvFace[fc].setTVerts(tvcount,topctv,lasttvl);
			  if (i<lastlevel) lasttvl=tvcount++;
		    mesh.tvFace[fc+1].setTVerts(lasttvr,topctv,tvcount);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[i],chb,edgelstl[last],(i==lastlevel?3:2),sg0);
	      AddFace(&mesh.faces[fc++],edgelstr[last],chb,edgelstr[i],(i==lastlevel?1:2),sg1);
		}
		last++;
	  }
	}

	if (minush)
	for (i=0;i<nverts;i++) mesh.verts[i].z-=height;
	if (edgelstr) delete []edgelstr;
	if (edgelstl) delete []edgelstl;
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts);
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

BOOL ScubaObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void ScubaObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void ScubaObject::BuildMesh(TimeValue t)
	{	
	int segs, smooth, hsegs;
	float radius,height,pie1, pie2,r2;
	int doPie, genUVs,con;	

	// Start the validity interval at forever and widdle it down.
    FixHeight(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	ivalid = FOREVER;
	
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_CENTERS,t,con,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	r2=2.0f*radius;
	if (con) height+=(height<0.0f?-r2:r2);
	pblock->GetValue(PB_SIDES,t,segs,ivalid);
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_SMOOTHON,t,smooth,ivalid);	
	pblock->GetValue(PB_SLICEFROM,t,pie1,ivalid);
	pblock->GetValue(PB_SLICETO,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(segs, MIN_SIDES, MAX_SIDES);
	LimitValue(smooth, 0, 1);	
				//        sides, smooth, 			  cylrad  
	BuildScubaMesh(mesh, segs, smooth, hsegs, doPie,radius, height, pie1, pie2, genUVs);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}

#define CIRCLE_VECTOR_LENGTH 0.5517861843f


Object* ScubaObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
		return SimpleObject::ConvertToType(t,obtype);
	}

int ScubaObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==triObjectClassID) {
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

class ScubaObjCreateCallBack: public CreateMouseCallBack {
	ScubaObject *ob;	
	Point3 p[2];
	IPoint2 sp0,sp1;
	float r,h;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(ScubaObject *obj) { ob = obj; }
	};

int ScubaObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				ob->increate=TRUE;
				break;
			case 1: 
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
				p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p[1]-p[0]);
					mat.SetTrans(p[0]);
				} else {
					// diameter
					Point3 center = (p[0]+p[1])/float(2);
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pblock->SetValue(PB_HEIGHT,0,2.0f*r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 ||
						Length(p[1]-p[0])<0.1f) {	
						ob->increate=FALSE;
						return CREATE_ABORT;
						} h=2.0f*r;
					}
				break;
			case 2:
				{
#ifdef _OSNAP
				float h1 = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h1 = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				float hmin=2.0f*r;
				h1+=(h1<0.0f?-hmin:hmin);
				ob->pblock->SetValue(PB_HEIGHT,0,h1);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {					
					ob->suspendSnap = FALSE;
					ob->increate=FALSE;
					return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
					}
				}
				break; 
			}
		}
	else
	if (msg == MOUSE_ABORT) {	
		ob->increate=FALSE;		
		return CREATE_ABORT;
		}

	return TRUE;
	}

static ScubaObjCreateCallBack cylCreateCB;

CreateMouseCallBack* ScubaObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL ScubaObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL ScubaObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		case PB_TI_CENTERS: crtCenters = v; break;
		}		
	return TRUE;
	}

BOOL ScubaObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		}	
	return TRUE;
	}

BOOL ScubaObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL ScubaObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		case PB_TI_CENTERS: v = crtCenters; break;
		}
	return TRUE;
	}

BOOL ScubaObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v=crtRadius; break;
		case PB_TI_HEIGHT: v=crtHeight; break;
		}
	return TRUE;
	}

BOOL ScubaObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void ScubaObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *ScubaObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS: return stdWorldDim;
		case PB_HEIGHT: return stdWorldDim;
		case PB_SIDES: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;
		case PB_SLICEFROM: return stdAngleDim;
		case PB_SLICETO: return stdAngleDim;
		default: return defaultDim;
		}
	}

TSTR ScubaObject::GetParameterName(int pbIndex) 
	{													   
	switch (pbIndex) {
		case PB_RADIUS: return TSTR(GetString(IDS_RB_RADIUS));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_SIDES: return TSTR(GetString(IDS_RB_SIDES));
		case PB_HSEGS: return TSTR(GetString(IDS_RB_HSEGS));
		case PB_SMOOTHON: return TSTR(GetString(IDS_RB_SMOOTHON));
		case PB_SLICEON: return TSTR(GetString(IDS_RB_SLICEON));
		case PB_SLICEFROM: return TSTR(GetString(IDS_RB_SLICEFROM));
		case PB_SLICETO: return TSTR(GetString(IDS_RB_SLICETO));
		default: return TSTR(_T(""));
		}
	}

RefTargetHandle ScubaObject::Clone(RemapDir& remap) 
	{
	ScubaObject* newob = new ScubaObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\solids.h ===
#ifndef __SOLIDS__H
#define __SOLIDS__H

#include "Max.h"
#include "scs.h"
#include "dynamic.h"

TCHAR *GetString(int id);
void AddFace(Face *f,int a,int b,int c,int evis,int smooth_group);
void TurnButton(HWND hWnd,int SpinNum,BOOL ison);
void SpinnerOff(HWND hWnd,int SpinNum);
void SpinnerOn(HWND hWnd,int SpinNum);

float RND01();
float RND11();
#define ALLF  4
const float IntMax=32767.0f;
const float IntMax1=32768.0f;
const float HalfIntMax=16383.5f;

const int row3size=3*sizeof(float);

typedef float Matrix4By4[4][4];
typedef float Matrix3By3[3][3];
const Point3 Zero=Point3(0.0f,0.0f,0.0f);

float GetMeterMult();
void Mult1X4(float *A,Matrix4By4 B,float *C);
void Mult1X3(float *A,Matrix3By3 B,float *C);
void SetUpRotation(float *Q, float *W,float Theta,Matrix4By4 Rq);
void RotateOnePoint(float *Pin,float *Q, float *W,float Theta);
void FixFSpinnerLimits(HWND hWnd,int SpinNum,float min,float max,BOOL notify=FALSE);

extern ClassDesc* GetChBoxobjDesc();
extern ClassDesc* GetChCylinderDesc();
extern ClassDesc* GetOilTnkDesc();
extern ClassDesc* GetSpindleDesc();
extern ClassDesc* GetScubaDesc();
extern ClassDesc* GetGengonDesc();
extern ClassDesc* GetPrismDesc();
extern ClassDesc* GetPyramidDesc();
extern ClassDesc* GetCExtDesc();
extern ClassDesc* GetLextDesc();
extern ClassDesc* GetSpringDesc();
extern ClassDesc* GetDamperDesc();
//extern ClassDesc* GetHoseDesc();


extern HINSTANCE hInstance;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\solids.cpp ===
/*****************************************************************************
 *<
	FILE: solids.cpp

	DESCRIPTION: Extended Primitives Support Files

	CREATED BY:  Audrey Peterson
	Copyright (c) 1996 All Rights Reserved
 *>
 *****************************************************************************/
#include "solids.h"
#include "buildver.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------
TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_AP_SCSLIB); }

// This function returns the number of plug-in classes this DLL implements
#ifndef DESIGN_VER
__declspec( dllexport ) int 
//LibNumberClasses() { return 13; }
LibNumberClasses() { return 12; }
#else
__declspec( dllexport ) int 
LibNumberClasses() { return 8; }
#endif

// This function return the ith class descriptor. We have one.
__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case 0:return GetChBoxobjDesc();
	case 1:return GetChCylinderDesc();
	case 2:return GetOilTnkDesc();
	case 3:return GetSpindleDesc();
	case 4:return GetScubaDesc();
	case 5:return GetGengonDesc();
	case 6:return GetPrismDesc();
	case 7:return GetPyramidDesc();
#ifndef DESIGN_VER
	case 8:return GetCExtDesc();
	case 9:return GetLextDesc();
	case 10:return GetSpringDesc();
	case 11:return GetDamperDesc();
//	case 12:return GetHoseDesc();
#endif
    default:return 0;}
 }

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

  	if (!controlsInit) {
		controlsInit = TRUE;		

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	}
	
	return(TRUE);
	}


// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

__declspec( dllexport ) ULONG 
CanAutoDefer() { return 1; }


void AddFace(Face *f,int a,int b,int c,int evis,int smooth_group)
{ f[0].setSmGroup(smooth_group);
  f[0].setMatID((MtlID)0); 	 /*default */
  if (evis==0) f[0].setEdgeVisFlags(1,1,0);
  else if (evis==1) f[0].setEdgeVisFlags(0,1,1);
  else if (evis==2) f[0].setEdgeVisFlags(0,0,1);
  else if (evis==ALLF) f[0].setEdgeVisFlags(1,1,1);
  else f[0].setEdgeVisFlags(1,0,1);	
  f[0].setVerts(a,b,c);
}

void TurnButton(HWND hWnd,int SpinNum,BOOL ison)
{	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(hWnd,SpinNum));
	if (iBut) 
	{ if (ison) iBut->Enable(); else iBut->Disable();
	}
	ReleaseICustButton(iBut);
};

float RND01()
{ float num;

  num=(float)rand();
  return(num/IntMax);
}

float RND11()
{ float num;

   num=(float)rand()-HalfIntMax;
   return(num/HalfIntMax);
}

float GetMeterMult()
{	int type;
	float scale;
	GetMasterUnitInfo(&type,&scale);
	switch(type)
	{	case UNITS_INCHES:		return scale*0.0254f;
		case UNITS_FEET:		return scale*0.3048f;
		case UNITS_MILES:		return scale*1609.3f;
		case UNITS_MILLIMETERS:	return scale*0.001f;
		case UNITS_CENTIMETERS:	return scale*0.01f;
		case UNITS_METERS:		return scale;
		case UNITS_KILOMETERS:	return scale*1000.0f;	
		default:				return 0;
	}
}

void Mult1X4(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0]+A[3]*B[3][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1]+A[3]*B[3][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2]+A[3]*B[3][2];
   C[3]=A[0]*B[0][3]+A[1]*B[1][3]+A[2]*B[2][3]+A[3]*B[3][3];
}

void Mult1X3(float *A,Matrix3By3 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2];
}

void SetUpRotation(float *Q, float *W,float Theta,Matrix4By4 Rq)
{ float ww1,ww2,ww3,w12,w13,w23,CosTheta,SinTheta,MinCosTheta;
  Point3 temp;
  Matrix3By3 R;

 ww1=W[0]*W[0];ww2=W[1]*W[1];ww3=W[2]*W[2];
 w12=W[0]*W[1];w13=W[0]*W[2];w23=W[1]*W[2];
 CosTheta=(float)cos(Theta);MinCosTheta=1.0f-CosTheta;SinTheta=(float)sin(Theta);
 R[0][0]=ww1+(1.0f-ww1)*CosTheta;
 R[0][1]=w12*MinCosTheta+W[2]*SinTheta;
 R[0][2]=w13*MinCosTheta-W[1]*SinTheta;
 R[1][0]=w12*MinCosTheta-W[2]*SinTheta;
 R[1][1]=ww2+(1.0f-ww2)*CosTheta;
 R[1][2]=w23*MinCosTheta+W[0]*SinTheta;
 R[2][0]=w13*MinCosTheta+W[1]*SinTheta;
 R[2][1]=w23*MinCosTheta-W[0]*SinTheta;
 R[2][2]=ww3+(1.0f-ww3)*CosTheta;
 Mult1X3(Q,R,&temp.x);
 memcpy(Rq[0],R[0],row3size);
 memcpy(Rq[1],R[1],row3size);
 memcpy(Rq[2],R[2],row3size);
 Rq[3][0]=Q[0]-temp.x;Rq[3][1]=Q[1]-temp.y;Rq[3][2]=Q[2]-temp.z;
 Rq[0][3]=Rq[1][3]=Rq[2][3]=0.0f;Rq[3][3]=1.0f;
}

void RotateOnePoint(float *Pin,float *Q, float *W,float Theta)
{ Matrix4By4 Rq;
  float Pout[4],Pby4[4];

 SetUpRotation(Q,W,Theta,Rq);
 memcpy(Pby4,Pin,row3size);Pby4[3]=1.0f;
 Mult1X4(Pby4,Rq,Pout);
 memcpy(Pin,Pout,row3size);
}
void SpinnerOff(HWND hWnd,int SpinNum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Disable();
	ReleaseISpinner(spin2);
}
void SpinnerOn(HWND hWnd,int SpinNum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Enable();
	ReleaseISpinner(spin2);
}
void FixFSpinnerLimits(HWND hWnd,int SpinNum,float min,float max,BOOL notify)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->SetLimits(min, max, notify);
	ReleaseISpinner(spin2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\spring.cpp ===
#include "solids.h"

#include "interpik.h"
#include "texutil.h"
#include "macrorec.h"

#define MAX_PATH_LENGTH 257
#define MAX_STRING_LENGTH  256
#define TESTLIMIT 100

#define A_RENDER			A_PLUGIN1

const float PIover2=1.570796327f;
const float QuarterPI=0.785398163f;
static int controlsInit = FALSE;
const Point3 ZAxis=Point3(0.0f,0.0f,1.0f);
#define fourninthPI (4.0f/9.0f)*PI
#define oneeightPI	(1.0f/18.0f)*PI

static Class_ID SPRING_CLASS_ID(0x7ba3009a, 0x76b61f8e);

#define PBLK		0
#define CUSTNODE 	1
#define CUSTNODE2 	2

const float EPSILON=0.0001f;
const Point3 Ones=Point3(1.0f,1.0f,1.0f);

class SpringPickOperand;
class SpringObject;

class SpringObject : public DynamHelperObject {
	public:
		static IParamMap *pmapParam;
		SpringObject();
		~SpringObject();
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
	
		static SpringObject *editOb;
		INode *custnode2,*custnode,*thisnode;
		TSTR custname,custname2;
		static IObjParam *ip;
		Matrix3 S;
		static HWND hParams;
		ICustButton *iPick,*iPick2;

		static BOOL creating;
		static SpringPickOperand pickCB;
		BOOL cancelled;
		int NumRefs() {return 3;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// From BaseObject
		TCHAR *GetObjectName();
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		

		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
		
		// Animatable methods		
		Class_ID ClassID() {return SPRING_CLASS_ID;} 
		void DeleteThis() {delete this;}
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void MapKeys(TimeMap *map,DWORD flags);
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		// From SimpleObject
		void MakeSaveVertex(Point3 *SaveVertex,int NvertsPerRing,int nfillets,int nsides,int wtype,TimeValue t);
		void BuildMesh(TimeValue t);

		int RenderBegin(TimeValue t, ULONG flags);
		int RenderEnd(TimeValue t);

		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void ShowName();
		void ShowName2();
		void ShowNames();
		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);

		INode *GetEndNode1();
		INode *GetEndNode2();
		Point3 ApplyAtEnd1(TimeValue t);
		Point3 ApplyAtEnd2(TimeValue t);
		Point3 Force(TimeValue t, TimeValue dt);
};

//--- ClassDescriptor and class vars ---------------------------------

class SpringClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new SpringObject;}
	const TCHAR *	ClassName(); 
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return SPRING_CLASS_ID;}
	const TCHAR* 	Category(); 
	void			ResetClassParams(BOOL fileReset);
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};

static SpringClassDesc SpringDesc;
ClassDesc* GetSpringDesc() {return &SpringDesc;}

class SpringPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		SpringObject *po;
		int dodist,repi;

		SpringPickOperand() {po=NULL;dodist=-1;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};

IParamMap *SpringObject::pmapParam;
IObjParam *SpringObject::ip    = NULL;
BOOL SpringObject::creating    = FALSE;
HWND SpringObject::hParams		=NULL;
SpringPickOperand SpringObject::pickCB;
SpringObject *SpringObject::editOb	=NULL;

//--- Parameter map/block descriptors -------------------------------

#define SIZEFACTOR (float(TIME_TICKSPERSEC)/120.0f)

#define PB_ENDSMETHOD		0
#define PB_NOREFLENGTH		1
#define PB_OD				2
#define PB_COILS			3
#define PB_COILDIR			4
#define PB_MANUALSEGSET		5
#define PB_SEGSPERTURN		6
#define PB_SEGMENTS			7
#define PB_SMOOTH			8
#define PB_RENDERABLE		9

#define PB_WIRETYPE			10
#define PB_RNDDIA			11
#define PB_RNDSIDES			12

#define PB_RECTWIDTH		13
#define PB_RECTDEPTH		14
#define PB_RECTFILLET		15
#define PB_RECTFILLETSIDES	16
#define PB_RECTROTANGLE		17

#define PB_DSECWIDTH		18
#define PB_DSECDEPTH		19
#define PB_DSECFILLET		20
#define PB_DSECFILLETSIDES	21
#define PB_DSECRNDSIDES		22
#define PB_DSECROTANGLE		23

#define PB_FREELENGTH		24
#define PB_KVALUE			25
#define PB_KVALUNITS		26
#define PB_SPRINGDIR		27

#define PB_MAPMEMAPME		28
#define PB_NONLINEAR		29

static int endmethodIDs[] = {IDC_SPRING_REFS,IDC_SPRING_DIMS};

static int coildirIDs[] = {IDC_SPRING_CCWDIR,IDC_SPRING_CWDIR};

static int segmethodIDs[] = {IDC_SPRING_AUTOSEGS,IDC_SPRING_MANUALSEGS};
const float WIREMIN=0.0f;
const float FILLETMIN=0.0f;
#define ROUND	0
#define RECT	1
#define DSECT	2

static int wiresectionIDs[] = {IDC_SPRING_ROUNDWIRE,IDC_SPRING_RECTWIRE,IDC_SPRING_DSECTIONWIRE};

static int kvalunitIDs[] = {IDC_SPRING_UNITS_LBIN,IDC_SPRING_UNITS_NM};

static int springdirIDs[] = {IDC_SPRING_COMP,IDC_SPRING_EXT,IDC_SPRING_BOTH};

static int smoothtypeIDs[] = {IDC_SPRING_SMALL,IDC_SPRING_SMNONE,IDC_SPRING_SMSIDES,IDC_SPRING_SMSEGS};

//
// Parameters

static ParamUIDesc descSpringParam1[] = {

	// End Method
	ParamUIDesc(PB_ENDSMETHOD,TYPE_RADIO,endmethodIDs,2),

	// No reference version Length
	ParamUIDesc(
		PB_NOREFLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_LENGTH,IDC_SPRING_LENGTHSPIN,
		0.0f,99999999.0f,
		0.1f),	
		
	// Outside Diameter
	ParamUIDesc(
		PB_OD,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_OD,IDC_SPRING_ODSPIN,
		0.1f,99999999.0f,
		0.1f),	
		
	// Coils
	ParamUIDesc(
		PB_COILS,
		EDITTYPE_FLOAT,
		IDC_SPRING_COILS,IDC_SPRING_COILSSPIN,
		0.5f,99999999.0f,
		0.25f),	
		
	// Coil Direction
	ParamUIDesc(PB_COILDIR,TYPE_RADIO,coildirIDs,2),

	// Segmentation method
	ParamUIDesc(PB_MANUALSEGSET,TYPE_RADIO,segmethodIDs,2),

	// Segments per turn
	ParamUIDesc(
		PB_SEGSPERTURN,
		EDITTYPE_INT,
		IDC_SPRING_COILSEGSPERTURN,IDC_SPRING_COILSEGSPERTURNSPIN,
		3.0f,100.0f,
		1.0f),	

	// Segments along coils
	ParamUIDesc(
		PB_SEGMENTS,
		EDITTYPE_INT,
		IDC_SPRING_COILSEGS,IDC_SPRING_COILSEGSSPIN,
		3.0f,100000.0f,
		1.0f),	
		
	// Smooth Spring
	ParamUIDesc(PB_SMOOTH,TYPE_RADIO,smoothtypeIDs,4),			

	// IsRenderable?
	ParamUIDesc(PB_RENDERABLE,TYPE_SINGLECHEKBOX,IDC_SPRING_RENDERTHIS),			


	// Wire Type
	ParamUIDesc(PB_WIRETYPE,TYPE_RADIO,wiresectionIDs,3),

	// Wire Diameter
	ParamUIDesc(
		PB_RNDDIA,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_RNDWIREDIA,IDC_SPRING_RNDWIREDIASPIN,
		WIREMIN,99999999.0f,
		0.1f),	

	// Sides around wire
	ParamUIDesc(
		PB_RNDSIDES,
		EDITTYPE_INT,
		IDC_SPRING_RNDWIRESIDES,IDC_SPRING_RNDWIRESIDESSPIN,
		3.0f,100.0f,
		1.0f),	
		
	// Wire Width
	ParamUIDesc(
		PB_RECTWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_RECTWIREWID,IDC_SPRING_RECTWIREWIDSPIN,
		WIREMIN,99999999.0f,
		0.1f),	

	// Wire Depth
	ParamUIDesc(
		PB_RECTDEPTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_RECWIREDEPTH,IDC_SPRING_RECWIREDEPTHSPIN,
		WIREMIN,99999999.0f,
		0.1f),	

	// Fillet Size
	ParamUIDesc(
		PB_RECTFILLET,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_RECWIREFILLET,IDC_SPRING_RECWIREFILLETSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Fillet Sides
	ParamUIDesc(
		PB_RECTFILLETSIDES,
		EDITTYPE_INT,
		IDC_SPRING_RECWIREFILLETSIDES,IDC_SPRING_RECWIREFILLETSIDESSPIN,
		0.0f,100.0f,
		1.0f),	

	// Rect Wire Rotation Angle
	ParamUIDesc(
		PB_RECTROTANGLE,
		EDITTYPE_FLOAT,
		IDC_SPRING_RECTROT,IDC_SPRING_RECTROTSPIN,
		-99999999.0f,99999999.0f,
		1.0f,
		stdAngleDim),	

		
	// D Wire Width
	ParamUIDesc(
		PB_DSECWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_DWIREWID,IDC_SPRING_DWIREWIDSPIN,
		WIREMIN,99999999.0f,
		0.1f),	

	// D Wire Depth
	ParamUIDesc(
		PB_DSECDEPTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_DWIREDEPTH,IDC_SPRING_DWIREDEPTHSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// D Fillet Size
	ParamUIDesc(PB_DSECFILLET,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_DWIREFILLET,IDC_SPRING_DWIREFILLETSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// D Fillet Sides
	ParamUIDesc(
		PB_DSECFILLETSIDES,
		EDITTYPE_INT,
		IDC_SPRING_DWIREFILLETSIDES,IDC_SPRING_DWIREFILLETSIDESSPIN,
		0.0f,100.0f,
		1.0f),	
		
	// D Round Sides
	ParamUIDesc(
		PB_DSECRNDSIDES,
		EDITTYPE_INT,
		IDC_SPRING_DWIRERNDSIDES,IDC_SPRING_DWIRERNDSIDESSPIN,
		2.0f,100.0f,
		1.0f),	

	// D Wire Rotation Angle
	ParamUIDesc(
		PB_DSECROTANGLE,
		EDITTYPE_FLOAT,
		IDC_SPRING_DROT,IDC_SPRING_DROTSPIN,
		-99999999.0f,99999999.0f,
		1.0f,
		stdAngleDim),	


	// Dyn Free Len
	ParamUIDesc(
		PB_FREELENGTH,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_L,IDC_SPRING_LSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Dyn K Value
	ParamUIDesc(
		PB_KVALUE,
		EDITTYPE_UNIVERSE,
		IDC_SPRING_K,IDC_SPRING_KSPIN,
		0.0f,99999999.0f,
		0.1f),	

	// Dyn Spring Constant Units
	ParamUIDesc(PB_KVALUNITS,TYPE_RADIO,kvalunitIDs,2),

	// Dyn Spring Dir
	ParamUIDesc(PB_SPRINGDIR,TYPE_RADIO,springdirIDs,3),

	// Generate text coords
	ParamUIDesc(PB_MAPMEMAPME,TYPE_SINGLECHEKBOX,IDC_SPRING_MAPME),			
			
	// Nonlinear Response
	ParamUIDesc(PB_NONLINEAR,TYPE_SINGLECHEKBOX,IDC_SPRING_NL),			
			
};

#define SPRINGPARAMSDESC_LENGTH 30

ParamBlockDescID descSpringVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 }, // End Method
	{ TYPE_FLOAT, NULL, TRUE, 1 }, // No Ref Length
	{ TYPE_FLOAT, NULL, TRUE, 2 }, // OD
	{ TYPE_FLOAT, NULL, TRUE, 3 }, // Coil Count
	{ TYPE_INT, NULL, FALSE, 4 }, // Coil Dir
	{ TYPE_INT, NULL, FALSE, 5 }, // Segmentation Method
	{ TYPE_INT, NULL, TRUE, 6 }, // Coil Segs per turn Count
	{ TYPE_INT, NULL, TRUE, 7 }, // Coil Seg Count
	{ TYPE_INT, NULL, FALSE, 8 }, // Smooth Control
	{ TYPE_INT, NULL, FALSE, 9 }, // Renderable

	{ TYPE_INT, NULL, FALSE, 10 }, // Wire Section Type
	{ TYPE_FLOAT, NULL, TRUE, 11 }, // Round Wire Dia
	{ TYPE_INT, NULL, TRUE, 12 },  // Wire Sides
	{ TYPE_FLOAT, NULL, TRUE, 13 }, // Rect Wire Width
	{ TYPE_FLOAT, NULL, TRUE, 14 }, // Rect Wire Depth
	{ TYPE_FLOAT, NULL, TRUE, 15 }, // Rect Wire Fillet Size
	{ TYPE_INT, NULL, TRUE, 16 }, // Rect Wire Fillet Sides
	{ TYPE_FLOAT, NULL, TRUE, 17 }, // Rect Wire Rot Angle
	{ TYPE_FLOAT, NULL, TRUE, 18 }, // D Wire Width
	{ TYPE_FLOAT, NULL, TRUE, 19 }, // D Wire Depth
	{ TYPE_FLOAT, NULL, TRUE, 20 }, // D Wire Fillet Size
	{ TYPE_INT, NULL, TRUE, 21 }, // D Wire Fillet Sides
	{ TYPE_INT, NULL, TRUE, 22 }, // D Wire Round Sides
	{ TYPE_FLOAT, NULL, TRUE, 23 }, // D Wire Rotation Angle

	{ TYPE_FLOAT, NULL, TRUE, 24 }, // Free Length
	{ TYPE_FLOAT, NULL, TRUE, 25 },  // K Value
	{ TYPE_INT, NULL, FALSE, 26 }, // K Value Units
	{ TYPE_INT, NULL, FALSE, 27 },  // Spring Direction

	{ TYPE_INT, NULL, FALSE, 28 },  // gen tex coords
	{ TYPE_INT, NULL, FALSE, 29 },  // nonlinear response
};

#define PBLOCK_SPRING_LENGTH	30

// Array of old versions
// static ParamVersionDesc versions[] = {ParamVersionDesc(descSpringVer0,24,0)};

#define NUM_OLDVERSIONS	0
#define CURRENT_VERSION	0

// Current version
static ParamVersionDesc curVersion(descSpringVer0,PBLOCK_SPRING_LENGTH,CURRENT_VERSION);


class CreateMSpringProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		SpringObject *SSBlizObject;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreateMSpringProc()
			{
			ignoreSelectionChange = FALSE;
			}
//		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


class CreateCPartRestoreNode : public RestoreObj {
	public:   		
		SpringObject *obj;
		TSTR name,namer;
		INode *save,*saver;
		CreateCPartRestoreNode(SpringObject *o) {
			obj = o; name=TSTR(o->custname);
			save=o->custnode;
			}
		void Restore(int isUndo)
		{ if (isUndo) { namer=TSTR(obj->custname);saver=obj->custnode;	}
		  obj->custname = name;
		  obj->custnode=save;
		  if (obj->hParams) obj->ShowName();
			}
		void Redo() 
		{ obj->custname = namer;
		  obj->custnode=saver;
		  if (obj->hParams) obj->ShowName();
		}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};

class CreateCPart2RestoreNode : public RestoreObj {
	public:   		
		SpringObject *obj;
		TSTR name,namer;
		INode *save,*saver;
		CreateCPart2RestoreNode(SpringObject *o) {
			obj = o; name=TSTR(o->custname2);
			save=o->custnode2;
			}
		void Restore(int isUndo)
		{ if (isUndo) { namer=TSTR(obj->custname2);	}
		  obj->custname2 = name;
		  obj->custnode2=save;
		  if (obj->hParams) obj->ShowName2();
			}
		void Redo() 
		{ obj->custname2 = namer;
		  obj->custnode2 = saver;
		  if (obj->hParams) obj->ShowName2();
		}
		TSTR Description() {return GetString(IDS_AP_COMPICK2);}
	};

#define CID_CREATESPRINGMODE	CID_USER +75

class CreateMSpringMode : public CommandMode {		
	public:		
		CreateMSpringProc proc;
		IObjParam *ip;
		SpringObject *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,SpringObject*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATESPRINGMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreateMSpringMode theCreateMSpringMode;

void SpringClassDesc::ResetClassParams(BOOL fileReset)
	{
	}

RefResult CreateMSpringProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( SSBlizObject && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (SSBlizObject && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (SSBlizObject->creating) 
						{  theCreateMSpringMode.JumpStart(SSBlizObject->ip,SSBlizObject);
							createInterface->SetCommandMode(&theCreateMSpringMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				SSBlizObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				SSBlizObject  = NULL;				
				CloudNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreateMSpringProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	SSBlizObject       = NULL;
	CreateNewObject();
	}

void CreateMSpringProc::CreateNewObject()
	{
	SSBlizObject = (SpringObject*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
    macroRec->BeginCreate(cDesc);  // JBW 3/30/99

	// Start the edit params process
	if ( SSBlizObject ) {
		SSBlizObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		SSBlizObject->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

void CreateMSpringProc::End()
{ if ( SSBlizObject ) 
	{ 
 #ifdef _OSNAP
		SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		SSBlizObject->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a Spring view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete SSBlizObject;
			SSBlizObject = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
			macroRec->Cancel();  // JBW 3/30/99
		}  else if ( CloudNode ) 
		{	theHold.Suspend();
			DeleteReference(0);  // sets cloudNode = NULL
			theHold.Resume();}
	}
}

void CreateMSpringMode::JumpStart(IObjParam *i,SpringObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

int SpringClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateMSpringMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateMSpringMode);
	return TRUE;
	}

int SpringClassDesc::EndCreate(Interface *i)
	{
	theCreateMSpringMode.End();
	i->RemoveMode(&theCreateMSpringMode);
	macroRec->EmitScript();  // JBW 3/30/99
	return TRUE;
	}

int CreateMSpringProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res=TRUE;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( SSBlizObject );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
#ifdef _OSNAP
						SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				   		SSBlizObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						macroRec->EmitScript();  // JBW 3/30/99

						// Get rid of the reference.
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}
						// new object
						CreateNewObject();   // creates SSBlizObject
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( SSBlizObject);
					SSBlizObject->thisnode=CloudNode;
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = SSBlizObject->GetCreateMouseCallBack();
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();
					mat.IdentityMatrix();
				default:				
					if (createCB) {						
						res = createCB->proc(vpx,msg,point,flag,m,mat);
						createInterface->SetNodeTMRelConstPlane(CloudNode,mat);

						if (res==CREATE_ABORT)
							goto abort;
						if (res==CREATE_STOP)
						    theHold.Accept(GetString(IDS_AP_CREATE));	 
						
						createInterface->RedrawViews(createInterface->GetTime());   //DS
						}

					break;
					
				}			
			break;

		case MOUSE_MOVE:
			if (createCB) {				
				res = createCB->proc(vpx,msg,point,flag,m,mat);
				createInterface->SetNodeTMRelConstPlane(CloudNode,mat);
				if (res==CREATE_ABORT) 
					goto abort;
				if (res==CREATE_STOP)
					theHold.Accept(GetString(IDS_AP_CREATE));	// TH
				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_INTERACTIVE);		//DS		
				}
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: 
	if (createCB)
	{ res = createCB->proc(vpx,msg,point,flag,m,mat);
	  createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
	  if (res==CREATE_ABORT)
	      goto abort;
	  if (res==CREATE_STOP)
	  {
#ifdef _OSNAP
         SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	    theHold.Accept(GetString(IDS_AP_CREATE));	
	  }
	  createInterface->RedrawViews(createInterface->GetTime()); 
		break;
	}
	abort:
		assert( SSBlizObject );
#ifdef _OSNAP
		SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		SSBlizObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
		macroRec->Cancel();  // JBW 3/30/99
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);
		SSBlizObject=NULL;
		createInterface->RedrawViews(createInterface->GetTime());
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		break;
	
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		#ifdef _OSNAP  //PREVIEW SNAP
			if(createCB) {
				res = createCB->proc(vpx,msg,point,flag,m,mat);
			}
			else
			{
				assert( SSBlizObject );					
				createCB = SSBlizObject->GetCreateMouseCallBack();
			}
		#endif
		vpx->TrackImplicitGrid(m);
			break;
	}

	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
}
BOOL SpringObject::OKtoDisplay(TimeValue t) 
	{ return (mesh.getNumVerts()>1);
	}

static BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

BOOL SpringPickOperand::Filter(INode *node)
{	if (node)
	{	ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
//		if (os.obj->IsParticleSystem() || os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) 
//		{	node = NULL;
//			return FALSE;
//		}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest())
		{	node = NULL;
			return FALSE;
		}
	}

	return node ? TRUE : FALSE;
}

BOOL SpringPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
{	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
//		if ((os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID)||(!IsGEOM(os.obj)))
//		{	node = NULL;
//			return FALSE;
//		}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest())
		{	node = NULL;
			return FALSE;
		}
	}
	return node ? TRUE : FALSE;
}

void SpringObject::ShowName()
{ TSTR name=(custnode ? custname : TSTR(GetString(IDS_AP_NONE)));
  SetWindowText(GetDlgItem(hParams, IDC_SPRING_OBJ1NAME), name);
}
void SpringObject::ShowName2()
{ TSTR name=(custnode2 ? custname2 : TSTR(GetString(IDS_AP_NONE)));
  SetWindowText(GetDlgItem(hParams, IDC_SPRING_OBJ2NAME), name);
}
void SpringObject::ShowNames()
{ ShowName();ShowName2();
}

BOOL SpringPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
{	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	nodes.SetCount(1);nodes[0]=node;
	theHold.Begin();
	if (dodist)
	{ theHold.Put(new CreateCPart2RestoreNode(po));
	  if (po->custnode2) po->ReplaceReference(CUSTNODE2,node,TRUE);
	  else po->MakeRefByID(FOREVER,CUSTNODE2,node);	
	  po->custname2 = TSTR(node->GetName());
	  // Automatically check show result and do one update
	  po->ShowName2();	
	}
	else
	{ theHold.Put(new CreateCPartRestoreNode(po));
	  if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	  else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	  po->custname = TSTR(node->GetName());
	  // Automatically check show result and do one update
	  po->ShowName();	
	}
	theHold.Accept(GetString(IDS_AP_COMPICK));
	po->pmapParam->Invalidate();
	ip->FlashNodes(&nodes);
	nodes.Resize(0);
	po->ivalid.SetEmpty();
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	if (po->creating) {
		theCreateMSpringMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreateMSpringMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {return TRUE;}
}

void SpringPickOperand::EnterMode(IObjParam *ip)
{	ICustButton *iBut;
	if (dodist) 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT2));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,FALSE);
	}
	else 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT1));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,FALSE);
	}
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
}

void SpringPickOperand::ExitMode(IObjParam *ip)
{	ICustButton *iBut;
	if (dodist) 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT2));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,TRUE);
	}
	else 
	{ iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SPRING_PICKOBJECT1));
	  TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,TRUE);
	}
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
	dodist=-1;
    GetCOREInterface()->PopPrompt();
}

//-- ParticleDlgProc ------------------------------------------------

class SpringParamDlg : public ParamMapUserDlgProc {
	public:
		SpringObject *po;

		SpringParamDlg(SpringObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void BootParams(BOOL ison);
		void AutoSegs(BOOL ison);
		void WireType(int type,TimeValue t);
		void BoundParams(BOOL ison);
		void DeleteThis() {delete this;}
		void FixSpringDiameter(int type,TimeValue t);
		void CheckFillet(int type,TimeValue t);
	};
void SpringParamDlg::CheckFillet(int type,TimeValue t)
{ float depth,fillet;
  if (type==RECT)
  { float width;
    po->pblock->GetValue(PB_RECTWIDTH,t,width,FOREVER);
    po->pblock->GetValue(PB_RECTDEPTH,t,depth,FOREVER);
	if (width<depth) depth=width;
  }
  else
  { po->pblock->GetValue(PB_DSECDEPTH,t,depth,FOREVER);
  }
  int spinnum=(type==RECT?PB_RECTFILLET:PB_DSECFILLET);
  po->pblock->GetValue(spinnum,t,fillet,FOREVER);
  depth*=0.5f;
  BOOL change;
  if (change=(fillet>depth))
  {	 po->pblock->SetValue(spinnum,t,depth);
  }
  if (po->hParams)
  FixFSpinnerLimits(po->hParams,(type==RECT?IDC_SPRING_RECWIREFILLETSPIN:IDC_SPRING_DWIREFILLETSPIN),FILLETMIN,depth,change);
}
void SpringParamDlg::FixSpringDiameter(int type,TimeValue t)
{ float mdiam,diam;
  po->pblock->GetValue(PB_OD,t,mdiam,FOREVER);
  int spinnum=(type==ROUND?PB_RNDDIA:(type==RECT?PB_RECTWIDTH:PB_DSECWIDTH));
  po->pblock->GetValue(spinnum,t,diam,FOREVER);
  BOOL change;
  if (change=(diam>=mdiam))
  { po->pblock->SetValue(spinnum,t,mdiam);
  }
  FixFSpinnerLimits(po->hParams,(type==ROUND?IDC_SPRING_RNDWIREDIASPIN:(type==RECT?IDC_SPRING_RECTWIREWIDSPIN:IDC_SPRING_DWIREWIDSPIN)),WIREMIN,mdiam,change);
  if (type!=ROUND) CheckFillet(type,t);
}
void SpringParamDlg::BoundParams(BOOL ison)
{ BOOL ok=ison;
  if (ison)
  { SpinnerOff(po->hParams,IDC_SPRING_LENGTHSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ2NAME),TRUE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ1NAME),TRUE);
	SpinnerOn(po->hParams,IDC_SPRING_LSPIN);
	SpinnerOn(po->hParams,IDC_SPRING_KSPIN);
	ok=(po->thisnode!=NULL);
  }
  else
  { SpinnerOn(po->hParams,IDC_SPRING_LENGTHSPIN);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ2NAME),FALSE);
    EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_OBJ1NAME),FALSE);
	SpinnerOff(po->hParams,IDC_SPRING_LSPIN);
	SpinnerOff(po->hParams,IDC_SPRING_KSPIN);
  }
  EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_UNITS_LBIN),ison);
  EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_UNITS_NM),ison);
  EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_COMP),ison);
  EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_EXT),ison);
  EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_BOTH),ison);
  EnableWindow(GetDlgItem(po->hParams,IDC_SPRING_NL),ison);
  if ((po->iPick->IsEnabled()!=ok)||(po->iPick2->IsEnabled()!=ok))
  { if ((po->pickCB.dodist<0)||(!ok))
	{ TurnButton(po->hParams,IDC_SPRING_PICKOBJECT2,ok);
      TurnButton(po->hParams,IDC_SPRING_PICKOBJECT1,ok);
	}
  }
}
void SpringParamDlg::AutoSegs(BOOL ison)
{ if (ison)
  { SpinnerOff(po->hParams,IDC_SPRING_COILSEGSPERTURNSPIN);
    SpinnerOn(po->hParams,IDC_SPRING_COILSEGSSPIN);
  }
  else 
  { SpinnerOn(po->hParams,IDC_SPRING_COILSEGSPERTURNSPIN);
    SpinnerOff(po->hParams,IDC_SPRING_COILSEGSSPIN);
  }
}
void RoundOff(HWND hwnd)
{ SpinnerOff(hwnd,IDC_SPRING_RNDWIREDIASPIN);
  SpinnerOff(hwnd,IDC_SPRING_RNDWIRESIDESSPIN);
}
void RoundOn(HWND hwnd)
{ SpinnerOn(hwnd,IDC_SPRING_RNDWIREDIASPIN);
  SpinnerOn(hwnd,IDC_SPRING_RNDWIRESIDESSPIN);
}
void RectOff(HWND hwnd)
{ SpinnerOff(hwnd,IDC_SPRING_RECTWIREWIDSPIN);
  SpinnerOff(hwnd,IDC_SPRING_RECWIREDEPTHSPIN);
  SpinnerOff(hwnd,IDC_SPRING_RECWIREFILLETSPIN);
  SpinnerOff(hwnd,IDC_SPRING_RECWIREFILLETSIDESSPIN);
  SpinnerOff(hwnd,IDC_SPRING_RECTROTSPIN);
}
void RectOn(HWND hwnd)
{ SpinnerOn(hwnd,IDC_SPRING_RECTWIREWIDSPIN);
  SpinnerOn(hwnd,IDC_SPRING_RECWIREDEPTHSPIN);
  SpinnerOn(hwnd,IDC_SPRING_RECWIREFILLETSPIN);
  SpinnerOn(hwnd,IDC_SPRING_RECWIREFILLETSIDESSPIN);
  SpinnerOn(hwnd,IDC_SPRING_RECTROTSPIN);
}
void DSectOff(HWND hwnd)
{ SpinnerOff(hwnd,IDC_SPRING_DWIREWIDSPIN);
  SpinnerOff(hwnd,IDC_SPRING_DWIREDEPTHSPIN);
  SpinnerOff(hwnd,IDC_SPRING_DWIRERNDSIDESSPIN);
  SpinnerOff(hwnd,IDC_SPRING_DWIREFILLETSPIN);
  SpinnerOff(hwnd,IDC_SPRING_DWIREFILLETSIDESSPIN);
  SpinnerOff(hwnd,IDC_SPRING_DROTSPIN);
}
void DSectOn(HWND hwnd)
{ SpinnerOn(hwnd,IDC_SPRING_DWIREWIDSPIN);
  SpinnerOn(hwnd,IDC_SPRING_DWIREDEPTHSPIN);
  SpinnerOn(hwnd,IDC_SPRING_DWIRERNDSIDESSPIN);
  SpinnerOn(hwnd,IDC_SPRING_DWIREFILLETSPIN);
  SpinnerOn(hwnd,IDC_SPRING_DWIREFILLETSIDESSPIN);
  SpinnerOn(hwnd,IDC_SPRING_DROTSPIN);
}
void SpringParamDlg::WireType(int type,TimeValue t)
{ if (type==ROUND)
  { RoundOn(po->hParams);
	RectOff(po->hParams);
	DSectOff(po->hParams);
  }
  else if (type==RECT)
  { RoundOff(po->hParams);
	RectOn(po->hParams);
	DSectOff(po->hParams);
  }
  else
  { RoundOff(po->hParams);
	RectOff(po->hParams);
	DSectOn(po->hParams);
  }
  FixSpringDiameter(type,t);
}

void SpringParamDlg::Update(TimeValue t)
{ if (!po->editOb) return;
  po->ShowNames();
  int emethod;po->pblock->GetValue(PB_ENDSMETHOD,0,emethod,FOREVER);
  BoundParams(!emethod);
  int manualsegs;po->pblock->GetValue(PB_MANUALSEGSET,0,manualsegs,FOREVER);
  AutoSegs(manualsegs);
  int wire;po->pblock->GetValue(PB_WIRETYPE,0,wire,FOREVER);
  WireType(wire,t);
 /*float length; po->pblock->GetValue(PB_NOREFLENGTH,0,length,FOREVER);
  if (length<0.01f) 
  if ((emethod)||(!po->thisnode))
  { po->iPick->Disable();
    po->iPick2->Disable();
  }
  else if (!po->iPick->IsEnabled())
  { po->iPick->Enable(TRUE);
    po->iPick2->Enable(TRUE);
  }*/
}

BOOL SpringParamDlg::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			po->iPick = GetICustButton(GetDlgItem(hWnd,IDC_SPRING_PICKOBJECT1));
			po->iPick->SetType(CBT_CHECK);
			po->iPick->SetHighlightColor(GREEN_WASH);
			po->iPick2 = GetICustButton(GetDlgItem(hWnd,IDC_SPRING_PICKOBJECT2));
			po->iPick2->SetType(CBT_CHECK);
			po->iPick2->SetHighlightColor(GREEN_WASH);
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(po->iPick);
			ReleaseICustButton(po->iPick2);
			return FALSE;
		case CC_SPINNER_BUTTONUP:
			{ 
			  if (HIWORD(wParam)) 
			  { switch ( LOWORD(wParam) ) 
				{
				 case IDC_SPRING_ODSPIN: 
				  { int wtype;
					po->pblock->GetValue(PB_WIRETYPE,t,wtype,FOREVER);
					FixSpringDiameter(wtype,t);
				  }
					break;
			  case IDC_SPRING_RECTWIREWIDSPIN: 
			  case IDC_SPRING_RECWIREDEPTHSPIN: 
				  { CheckFillet(RECT,t);
				  }
				  break;				  
			  case IDC_SPRING_DWIREWIDSPIN: 
			  case IDC_SPRING_DWIREDEPTHSPIN: 
				  { CheckFillet(DSECT,t);
				  }
				  break;				  			  
				}
			  }
			}
			return TRUE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{
			  case IDC_SPRING_RECTWIREWIDSPIN: 
			  case IDC_SPRING_RECWIREDEPTHSPIN: 
			  case IDC_SPRING_RECTWIREWID: 
			  case IDC_SPRING_RECWIREDEPTH: 		  
				  { CheckFillet(RECT,t);
				  }
				  break;				  
			  case IDC_SPRING_DWIREWIDSPIN: 
			  case IDC_SPRING_DWIREDEPTHSPIN: 
			  case IDC_SPRING_DWIREWID: 
			  case IDC_SPRING_DWIREDEPTH: 
				  { CheckFillet(DSECT,t);
				  }
				  break;				  			  
			  case IDC_SPRING_PICKOBJECT1: 
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateMSpringMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateMSpringMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;	
					     po->pickCB.dodist=0;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
					}
			  case IDC_SPRING_PICKOBJECT2: 
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateMSpringMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateMSpringMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;	
					     po->pickCB.dodist=1;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
					}
			  case IDC_SPRING_REFS: 
				  { BoundParams(TRUE);				  
				  }
				  break;				   
			  case IDC_SPRING_DIMS: 
				  { BoundParams(FALSE);
				    if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
					  { theCreateMSpringMode.JumpStart(po->ip,po);
						 po->ip->SetCommandMode(&theCreateMSpringMode);
					  } else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					}
				  }
				  break;
			  case IDC_SPRING_OD:
				  { int wtype;
					po->pblock->GetValue(PB_WIRETYPE,t,wtype,FOREVER);
					FixSpringDiameter(wtype,t);
				  }
				  break;
			  case IDC_SPRING_AUTOSEGS: 
				  { AutoSegs(FALSE);
				  }
				  break;
			  case IDC_SPRING_MANUALSEGS: 
				  { AutoSegs(TRUE);
				  }
				  break;				  
			  case IDC_SPRING_ROUNDWIRE: 
				  { WireType(ROUND,t);
				  }
				  break;				  
			  case IDC_SPRING_RECTWIRE: 
				  { WireType(RECT,t);
				  }
				  break;				  
			  case IDC_SPRING_DSECTIONWIRE: 
				  { WireType(DSECT,t);
				  }
				  break;				  			  
			}
		default:
			return FALSE;
		}
	return TRUE;
}

//--- SpringObject Methods--------------------------------------------

SpringObject::SpringObject()
{	int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	int length = PBLOCK_SPRING_LENGTH;
	MakeRefByID(FOREVER, 0, CreateParameterBlock(descSpringVer0, length, CURRENT_VERSION));
	assert(pblock);

	pblock->SetValue(PB_ENDSMETHOD,0,1);
	pblock->SetValue(PB_NOREFLENGTH,0,1.0f);
	pblock->SetValue(PB_OD,0,1.0f);	
	pblock->SetValue(PB_COILS,0,1.0f);	
	pblock->SetValue(PB_COILDIR,0,0);	
	pblock->SetValue(PB_MANUALSEGSET,0,0);	
	pblock->SetValue(PB_SEGSPERTURN,0,16);
	pblock->SetValue(PB_SEGMENTS,0,16);
	pblock->SetValue(PB_SMOOTH,0,0);
	pblock->SetValue(PB_RENDERABLE,0,1);

	pblock->SetValue(PB_WIRETYPE,0,0);
	pblock->SetValue(PB_RNDDIA,0,0.2f);
	pblock->SetValue(PB_RNDSIDES,0,6);
	pblock->SetValue(PB_RECTWIDTH,0,0.2f);
	pblock->SetValue(PB_RECTDEPTH,0,0.2f);
	pblock->SetValue(PB_RECTFILLET,0,0.0f);
	pblock->SetValue(PB_RECTFILLETSIDES,0,0);
	pblock->SetValue(PB_RECTROTANGLE,0,0.0f);
	pblock->SetValue(PB_DSECWIDTH,0,0.2f);
	pblock->SetValue(PB_DSECDEPTH,0,0.2f);
	pblock->SetValue(PB_DSECFILLET,0,0.0f);
	pblock->SetValue(PB_DSECFILLETSIDES,0,0);
	pblock->SetValue(PB_DSECRNDSIDES,0,4);
	pblock->SetValue(PB_DSECROTANGLE,0,0.0f);

	pblock->SetValue(PB_FREELENGTH,0,1.0f);
	pblock->SetValue(PB_KVALUE,0,1.0f);
	pblock->SetValue(PB_KVALUNITS,0,0);
	pblock->SetValue(PB_SPRINGDIR,0,0);
	pblock->SetValue(PB_MAPMEMAPME,0,0);
	pblock->SetValue(PB_NONLINEAR,0,0);

	S.IdentityMatrix();
	iPick=NULL;
	iPick2=NULL;
	thisnode=NULL;
	custnode=NULL;
	custnode2=NULL;
	custname=TSTR(_T(" "));
	custname2=TSTR(_T(" "));
}

SpringObject::~SpringObject()
{	DeleteAllRefsFromMe();
}

void SpringObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
{	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	editOb   = this;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }

	if (pmapParam) 
	{	pmapParam->SetParamBlock(pblock);
	}
	else 
	{	pmapParam = CreateCPParamMap(
		descSpringParam1,SPRINGPARAMSDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SPRING),
		GetString(IDS_AP_PARAMS),
		0);		
	}
	hParams=pmapParam->GetHWnd();
	if (pmapParam) pmapParam->SetUserDlgProc(new SpringParamDlg(this));
}

void SpringObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
{	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;
	editOb = NULL;
	if (flags&END_EDIT_REMOVEUI) {
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		hParams=NULL;
		}
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
}

void SpringObject::MapKeys(TimeMap *map,DWORD flags)
{
}  

static TriObject *GetTriObject(TimeValue t,Object *obj,Interval &valid,BOOL &needsDel)
	{	
	needsDel = FALSE;
	if (!obj) return NULL;
	ObjectState os = obj->Eval(t);
	valid &= os.Validity(t);
	if (os.obj->IsSubClassOf(triObjectClassID)) {
		return (TriObject*)os.obj;
	} else {
		if (os.obj->CanConvertToType(triObjectClassID)) {
			Object *oldObj = os.obj;
			TriObject *tobj = (TriObject*)os.obj->ConvertToType(t,triObjectClassID);			
			needsDel = (tobj != oldObj);			
			return tobj;
			}
		}
	return NULL;
	}

#define BLVERTS 11
#define BLFACES 9

void SpringObject::GetWorldBoundBox(
		TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
	{	thisnode=inode;    
		SimpleObject::GetWorldBoundBox(t,inode,vpt,box);
	}  

void SpringObject::MakeSaveVertex(Point3 *SaveVertex,int NvertsPerRing, int nfillets, int nsides, int wtype, TimeValue t)
{	if (wtype == ROUND)
	{	float ang = TWOPI/(float)NvertsPerRing,diar;
		pblock->GetValue(PB_RNDDIA,t,diar,ivalid);
		diar *= 0.5f;
		for (int i=0; i<NvertsPerRing; i++)
		{	float u = (float)(i+1)*ang;
			SaveVertex[i] = Point3(diar*(float)cos(u),diar*(float)sin(u),0.0f);
		}
	}
	else if (wtype == RECT)
	{	int savevertcnt = 0;
		int qtrverts = 1 + nfillets;
		int hlfverts = 2*qtrverts;
		int thrverts = qtrverts + hlfverts;
		float Wr, Dr, Zfr;
		pblock->GetValue(PB_RECTWIDTH,t,Wr,ivalid);
		Wr *= 0.5f;
		pblock->GetValue(PB_RECTDEPTH,t,Dr,ivalid);
		Dr *= 0.5f;
		pblock->GetValue(PB_RECTFILLET,t,Zfr,ivalid);
		if (nfillets>0)
		{	float WmZ = Wr-Zfr,
				  DmZ = Dr-Zfr;
			float ZmW = -WmZ,
				  ZmD = -DmZ;
			SaveVertex[0                ] = Point3(Wr , DmZ, 0.0f);
			SaveVertex[nfillets         ] = Point3(WmZ, Dr , 0.0f);
			SaveVertex[qtrverts         ] = Point3(ZmW, Dr , 0.0f);
			SaveVertex[qtrverts+nfillets] = Point3(-Wr, DmZ, 0.0f);
			SaveVertex[hlfverts         ] = Point3(-Wr, ZmD, 0.0f);
			SaveVertex[hlfverts+nfillets] = Point3(ZmW, -Dr, 0.0f);
			SaveVertex[thrverts         ] = Point3(WmZ, -Dr, 0.0f);
			SaveVertex[thrverts+nfillets] = Point3(Wr , ZmD, 0.0f);

			if (nfillets > 1)
			{	float ang = PIover2/(float)nfillets;
				savevertcnt = 1;
				for (int i=0; i<nfillets-1; i++)
				{	float u = (float)(i+1)*ang;
				    float cu = Zfr*(float)cos(u),
						  su = Zfr*(float)sin(u);
					SaveVertex[savevertcnt         ] = Point3(WmZ+cu, DmZ+su, 0.0f);
					SaveVertex[savevertcnt+qtrverts] = Point3(ZmW-su, DmZ+cu, 0.0f);
					SaveVertex[savevertcnt+hlfverts] = Point3(ZmW-cu, ZmD-su, 0.0f);
					SaveVertex[savevertcnt+thrverts] = Point3(WmZ+su, ZmD-cu, 0.0f);
					savevertcnt++;
				}
			}
		}
		else
		{	SaveVertex[savevertcnt]=Point3(Wr,Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt]=Point3(-Wr,Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt]=Point3(-Wr,-Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt]=Point3(Wr,-Dr,0.0f);
			savevertcnt++;
		}
	}
	else
	{	int savevertcnt = 0;
		float Wr, Dr, Zfr;
		float sang = PI/(float)nsides;

		pblock->GetValue(PB_DSECWIDTH,t,Wr,ivalid);
		Wr*=0.5f;
		pblock->GetValue(PB_DSECDEPTH,t,Dr,ivalid);
		Dr*=0.5f;
		pblock->GetValue(PB_DSECFILLET,t,Zfr,ivalid);	

		float LeftCenter = Dr-Wr;

		if (nfillets > 0)
		{	float DmZ = Dr-Zfr,
				  ZmD = -DmZ,
				  WmZ = Wr-Zfr;
			int oneqtrverts = 1+nfillets;
			int threeqtrverts = oneqtrverts+1+nsides;

			SaveVertex[0                     ] = Point3(Wr        , DmZ,0.0f);
			SaveVertex[nfillets              ] = Point3(WmZ       , Dr ,0.0f);
			SaveVertex[oneqtrverts           ] = Point3(LeftCenter, Dr ,0.0f);
			SaveVertex[oneqtrverts+nsides    ] = Point3(LeftCenter,-Dr ,0.0f);
			SaveVertex[threeqtrverts         ] = Point3(WmZ       ,-Dr ,0.0f);
			SaveVertex[threeqtrverts+nfillets] = Point3(Wr        , ZmD,0.0f);

			if (nfillets > 1)
			{	float ang = PIover2/(float)nfillets;
				savevertcnt = 1;
				for (int i=0; i < nfillets-1; i++)
				{	float u = (float)(i+1)*ang;
				    float cu = Zfr*(float)cos(u),
						  su = Zfr*(float)sin(u);
					SaveVertex[savevertcnt              ] = Point3(WmZ+cu, DmZ+su, 0.0f);
					SaveVertex[savevertcnt+threeqtrverts] = Point3(WmZ+su, ZmD-cu, 0.0f);
					savevertcnt++;
				}
			}
			savevertcnt = 1+oneqtrverts;
			for (int i=0; i < nsides-1; i++)
			{	float u = (float)(i+1)*sang;
			    float cu = Dr*(float)cos(u),
					  su = Dr*(float)sin(u);
				SaveVertex[savevertcnt] = Point3(LeftCenter-su,cu,0.0f);
				savevertcnt++;
			}
		}
		else
		{	SaveVertex[savevertcnt]=Point3(Wr,        Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt]=Point3(LeftCenter,Dr,0.0f);
			savevertcnt++;
			for (int i=0; i<nsides-1; i++)
			{	float u = (float)(i+1)*sang;
			    float cu = Dr*(float)cos(u),
					  su = Dr*(float)sin(u);
				SaveVertex[savevertcnt] = Point3(LeftCenter-su, cu, 0.0f);
				savevertcnt++;
			}
			SaveVertex[savevertcnt] = Point3(LeftCenter,-Dr,0.0f);
			savevertcnt++;
			SaveVertex[savevertcnt] = Point3(Wr,        -Dr,0.0f);
			savevertcnt++;
		}
	}
	float rotangle, cosu, sinu, tempx, tempy;
	if (wtype == RECT)
	{	pblock->GetValue(PB_RECTROTANGLE,t,rotangle,ivalid);
		if (rotangle != 0.0f)
		{	cosu = (float)cos(rotangle);
			sinu = (float)sin(rotangle);
			for (int m=0; m<NvertsPerRing ; m++)
			{	tempx = SaveVertex[m].x*cosu - SaveVertex[m].y*sinu;
				tempy = SaveVertex[m].x*sinu + SaveVertex[m].y*cosu;
				SaveVertex[m].x = tempx;
				SaveVertex[m].y = tempy;
			}
		}
	}
	else if (wtype == DSECT)
	{	pblock->GetValue(PB_DSECROTANGLE,t,rotangle,ivalid);
		if (rotangle != 0.0f)
		{	cosu = (float)cos(rotangle);
			sinu = (float)sin(rotangle);
			for (int m=0; m<NvertsPerRing ; m++)
			{	tempx = SaveVertex[m].x*cosu - SaveVertex[m].y*sinu;
				tempy = SaveVertex[m].x*sinu + SaveVertex[m].y*cosu;
				SaveVertex[m].x = tempx;
				SaveVertex[m].y = tempy;
			}
		}
	}

}

int SpringObject::RenderBegin(TimeValue t, ULONG flags)
{	SetAFlag(A_RENDER);
	int renderme;
	pblock->GetValue(PB_RENDERABLE,t,renderme,FOREVER);
	if (!renderme) 
	{	MeshInvalid();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	return 0;
}

int SpringObject::RenderEnd(TimeValue t)
{	ClearAFlag(A_RENDER);
	int renderme;
 	pblock->GetValue(PB_RENDERABLE,t,renderme,FOREVER);
	if (!renderme) 
	{	MeshInvalid();
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
	return 0;
}

INode *SpringObject::GetEndNode1()
{	if (custnode)
		return (custnode);
	else
		return (NULL);
}

INode *SpringObject::GetEndNode2()
{	if (custnode2) 
		return (custnode2);
	else
		return (NULL);
}

Point3 SpringObject::ApplyAtEnd1(TimeValue t)
{	if (custnode)
	{	Matrix3 mat1 = custnode->GetObjTMAfterWSM(t);
		return (mat1.GetRow(3));
	}
	else
		return (Zero);
}

Point3 SpringObject::ApplyAtEnd2(TimeValue t)
{	if (custnode2)
	{	Matrix3 mat2 = custnode2->GetObjTMAfterWSM(t);
		return (mat2.GetRow(3));
	}
	else
		return (Zero);
}

#define COMPRESSION	0
#define EXTENSION	1
#define	BIDIRECT	2

#define POUNDSPERINCH	0
#define NEWTONPERMETER	1

Point3 SpringObject::Force(TimeValue t, TimeValue dt)
{	if ((custnode)&&(custnode2))
	{	Matrix3 mat1, mat2;
		mat1 = custnode->GetObjTMAfterWSM(t);
		mat2 = custnode2->GetObjTMAfterWSM(t);
		float len;
		Point3 forcedir = (mat1.GetRow(3)-mat2.GetRow(3));
		len = Length(forcedir);
		if (len < 0.01f)
			return (Zero);
		else
		{	forcedir = Normalize(forcedir);
			float freelen, kval, difflen;
			int springtype, kvalunits;
			pblock->GetValue(PB_FREELENGTH,t,freelen,ivalid);
			pblock->GetValue(PB_KVALUE,t,kval,ivalid);
			pblock->GetValue(PB_KVALUNITS,t,kvalunits,ivalid);
			pblock->GetValue(PB_SPRINGDIR,t,springtype,ivalid);
			if ((len < freelen)&&(springtype == EXTENSION))
				return (Zero);
			else if ((len > freelen)&&(springtype == COMPRESSION))
				return (Zero);
			else 
			{	difflen = freelen - len;
				difflen *= GetMeterMult();
				if (kvalunits == POUNDSPERINCH)
					kval *= 175.55441f;
				forcedir *= (kval*difflen);
				int isnonlinear;
				pblock->GetValue(PB_NONLINEAR,0,isnonlinear,FOREVER);
				if (((isnonlinear)&&(springtype == COMPRESSION)&&(len < freelen))||
					((isnonlinear)&&(springtype == BIDIRECT)&&(len < freelen)))
				{	int wiretype;
					float wiresize, coils;
					pblock->GetValue(PB_WIRETYPE,0,wiretype,FOREVER);
					if (wiretype==ROUND)
						pblock->GetValue(PB_RNDDIA,0,wiresize,FOREVER);
					else if (wiretype==RECT)
						pblock->GetValue(PB_RECTDEPTH,t,wiresize,ivalid);
					else
						pblock->GetValue(PB_DSECDEPTH,t,wiresize,ivalid);
					pblock->GetValue(PB_COILS,t,coils,ivalid);
					float solidheight = wiresize * coils;
					if (len > solidheight)
						forcedir += forcedir*(freelen - len)/(len - solidheight);
				}
				else if (((isnonlinear)&&(springtype == BIDIRECT)&&(len > freelen))||
						((isnonlinear)&&(springtype == EXTENSION)&&(len > freelen)))
				{	int wiretype;
					float wirewidth, springdia;
					pblock->GetValue(PB_WIRETYPE,0,wiretype,FOREVER);
					if (wiretype==ROUND)
						pblock->GetValue(PB_RNDDIA,t,wirewidth,ivalid);
					else if (wiretype==RECT)
						pblock->GetValue(PB_RECTWIDTH,t,wirewidth,ivalid);
					else
						pblock->GetValue(PB_DSECWIDTH,t,wirewidth,ivalid);
					pblock->GetValue(PB_OD,t,springdia,ivalid);
					float factor = 0.001f*wirewidth/springdia;
					if (len > freelen)
						forcedir *= (float)exp((len - freelen)*factor);
				}
				return (forcedir);  //returns a force in Newtons!!
			}
		}
	}
	else
		return (Zero);
}

#define SMOOTHALL	0
#define SMOOTHNONE	1
#define SMOOTHSIDES	2
#define SMOOTHSEGS	3

BOOL SpringObject::HasUVW() 
{ 	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_MAPMEMAPME, 0, genUVs, v);
	return genUVs; 
}

void SpringObject::SetGenUVW(BOOL sw) 
{  	if (sw==HasUVW()) 
		return;
	pblock->SetValue(PB_MAPMEMAPME,0, sw);
}

void SpringObject::BuildMesh(TimeValue t)
{	if (TestAFlag(A_RENDER))
	{	int renderme;
		pblock->GetValue(PB_RENDERABLE,0,renderme,ivalid);
		if (!renderme)
		{	mesh.setNumVerts(0);
			mesh.setNumFaces(0);
			mesh.setNumTVerts(0);
			mesh.setNumTVFaces(0);
			mesh.InvalidateGeomCache();
			return;
		}
	}
	
//	if (!ivalid.InInterval(t))
	{	ivalid=FOREVER;
		int createfree;
		pblock->GetValue(PB_ENDSMETHOD,0,createfree,ivalid);
		if ((!createfree)&&((!custnode)||(!custnode2))) 
			createfree = 1;
		if (!createfree) 
			ivalid.SetInstant(t);
		Matrix3 mat1,mat2;
		srand(56576);
		int s1 = rand();
		float Lf = 0.0f;
		Matrix3 Tlocal;
		if (createfree) 
			pblock->GetValue(PB_NOREFLENGTH,t,Lf,ivalid);
		else
		{	Point3 RV = Point3(RND11(),RND11(),RND11());
			mat1 = custnode->GetObjTMAfterWSM(t);
			mat2 = (custnode==custnode2?mat1:custnode2->GetObjTMAfterWSM(t));

			Matrix3 mato1(1), mato2(1);

			Point3 pos1 = custnode->GetObjOffsetPos();
			mato1.PreTranslate(pos1);
			Quat quat1 = custnode->GetObjOffsetRot();
			PreRotateMatrix(mato1, quat1);
			ScaleValue scaleValue1 = custnode->GetObjOffsetScale();
			ApplyScaling(mato1, scaleValue1);
			mato1 = Inverse(mato1);

			Point3 pos2 = custnode2->GetObjOffsetPos();
			mato2.PreTranslate(pos2);
			Quat quat2 = custnode2->GetObjOffsetRot();
			PreRotateMatrix(mato2, quat2);
			ScaleValue scaleValue2 = custnode2->GetObjOffsetScale();
			ApplyScaling(mato2, scaleValue2);
			mato2 = Inverse(mato2);

			S = thisnode->GetObjTMBeforeWSM(t);
//			Point3 P1 = mat1.GetRow(3),
//				   P2 = mat2.GetRow(3);
			Point3 P1 = mat1*mato1.GetRow(3),
				   P2 = mat2*mato2.GetRow(3);
			Matrix3 SI = Inverse(S);
			Point3 P0 = SI*P1;
			Matrix3 T1 = mat1;
			T1.NoTrans();
			Point3 RVw = T1 * RV;
			Lf = Length(P2 - P1);
//			pblock->SetValue(PB_NOREFLENGTH,0,Lf);
			Point3 Zw;
			if (Lf < 0.01f)
				Zw = Normalize(P1);
			else
				Zw = Normalize(P2 - P1);
			Point3 Xw = Normalize(RVw ^ Zw),
				   Yw = Normalize(Zw ^ Xw);	
			SI.NoTrans();
			Point3 Xs = SI * Xw,
				   Ys = SI * Yw,
				   Zs = SI * Zw;
			Tlocal.SetRow(0,Xs);
			Tlocal.SetRow(1,Ys);
			Tlocal.SetRow(2,Zs);
			Tlocal.SetRow(3,P0);
		}
		int wtype;
		pblock->GetValue(PB_WIRETYPE,0,wtype,ivalid);
		int NvertsPerRing=0,
			nfillets=0,
			nsides=0;
		if (wtype==ROUND)
		{	pblock->GetValue(PB_RNDSIDES,t,NvertsPerRing,ivalid);
		}
		else if (wtype==RECT)
		{	pblock->GetValue(PB_RECTFILLETSIDES,t,nfillets,ivalid);
			NvertsPerRing=(nfillets>0?8+4*(nfillets-1):4);
		}
		else
		{	pblock->GetValue(PB_DSECFILLETSIDES,t,nfillets,ivalid);
			pblock->GetValue(PB_DSECRNDSIDES,t,nsides,ivalid);
			int nsm1 = nsides-1;
			NvertsPerRing=(nfillets>0?6+nsm1+2*(nfillets-1):4+nsm1);
		}
		int Nverts=0,NfacesPerEnd,NfacesPerRing,Nfaces=0,Segs;

		float C,OD;
		int SMOOTH;
		pblock->GetValue(PB_OD,t,OD,ivalid);if (OD<0.1f) OD=0.1f;
		pblock->GetValue(PB_COILS,t,C,ivalid);
		pblock->GetValue(PB_SMOOTH,0,SMOOTH,FOREVER);

		int manualsegs;
		pblock->GetValue(PB_MANUALSEGSET,t,manualsegs,ivalid);
		if (manualsegs)
			pblock->GetValue(PB_SEGMENTS,t,Segs,ivalid);
		else
		{	pblock->GetValue(PB_SEGSPERTURN,t,Segs,ivalid);
			Segs = (int)((float)Segs*C);
		}

		Nverts = (Segs + 1)*NvertsPerRing + 2;
		NfacesPerEnd = NvertsPerRing;
		NfacesPerRing = 2* NvertsPerRing;
		Nfaces =  Segs*NfacesPerRing + 2*NfacesPerEnd;
		Point3 *SaveVertex = new Point3[NvertsPerRing];
		assert(SaveVertex);
		MakeSaveVertex(SaveVertex, NvertsPerRing, nfillets, nsides, wtype, t);

		int clockwise;
		pblock->GetValue(PB_COILDIR,t,clockwise,ivalid);

		float HelixAngle = (float)atan(Lf/(C*PI*OD));  
		if (clockwise) HelixAngle = -HelixAngle;

		mesh.setNumVerts(Nverts);
		mesh.setNumFaces(Nfaces);

		int mapmenow;
		pblock->GetValue(PB_MAPMEMAPME,0,mapmenow,FOREVER);

		if (mapmenow)
		{	mesh.setNumTVerts(Nverts+Segs+1);
			mesh.setNumTVFaces(Nfaces);
		}
		else
		{	mesh.setNumTVerts(0);
			mesh.setNumTVFaces(0);
		}

		float hod = 0.5f*OD;
		int thisvert = 0,
			last = Nverts-1,
			last2 = last-1;
		int lastvpr = NvertsPerRing-1,
			maxseg = Segs+1;

		for (int i=0; i < maxseg; i++)
		{	float incr = (float)i/(float)Segs;
			float ThisAngle = C*TWOPI*incr;
			if (clockwise) ThisAngle = -ThisAngle;
			float ThisHeight = Lf*incr;
			float ThisPositionX = hod*(float)cos(ThisAngle);
			float ThisPositionY = hod*(float)sin(ThisAngle);
			Point3 ThisXAxis = Normalize(Point3(ThisPositionX, ThisPositionY, 0.0f));
//			if (clockwise) ThisXAxis = -ThisXAxis;
			Point3 ThisYAxis = ZAxis;
			Point3 pt = Zero;
			RotateOnePoint(&ThisYAxis.x,&pt.x,&ThisXAxis.x,HelixAngle);
			Point3 ThisZAxis = Normalize(ThisXAxis^ThisYAxis);
//			ThisYAxis = Normalize(ThisZAxis^ThisXAxis);
			Matrix3 RingTM;
			RingTM.SetRow(0,ThisXAxis);
			RingTM.SetRow(1,ThisYAxis);
			RingTM.SetRow(2,ThisZAxis);
			Point3 mainpos=Point3(ThisPositionX, ThisPositionY, ThisHeight);
			RingTM.SetRow(3,mainpos);
			if (!createfree) 
				RingTM = RingTM * Tlocal;

			for (int j=0; j < NvertsPerRing; j++)
			{	if (mapmenow)
					mesh.tVerts[thisvert]=Point3(0.999999f*incr, (float)j/(float)NvertsPerRing,0.5f);
				mesh.setVert(thisvert, RingTM*SaveVertex[j]);
				thisvert++;
			}
			if (mapmenow)
				mesh.tVerts[Nverts+i]=Point3(0.999999f*incr,0.999f,0.0f);

			if (i == 0)
			{	mesh.setVert(last2,(createfree?mainpos:Tlocal*mainpos));
				if (mapmenow)
					mesh.tVerts[last2]=Zero;
			}
			else if (i == Segs)
			{	mesh.setVert(last,(createfree?mainpos:Tlocal*mainpos));
				if (mapmenow)
					mesh.tVerts[last]=Ones;
			}
		}

//		Now, set up the faces
		int thisface = 0, v1, v2, v3, v4, v5, v6;
		v3 = last2;
		for (i=0; i < NvertsPerRing; i++)
		{	v1 = i;
			v2 = (i < lastvpr? v1+1 : v1-lastvpr);
			v5 = (i < lastvpr? v2 : Nverts);
			if (clockwise)
				mesh.faces[thisface].setVerts(v2,v1,v3);
			else
				mesh.faces[thisface].setVerts(v1,v2,v3);
			mesh.faces[thisface].setSmGroup((SMOOTH == 1)?0:1);
			mesh.faces[thisface].setEdgeVisFlags(1,0,0);
			mesh.faces[thisface].setMatID(0);
			if (mapmenow)
				if (clockwise)
					mesh.tvFace[thisface].setTVerts(v5,v1,v3);
				else
					mesh.tvFace[thisface].setTVerts(v1,v5,v3);
			thisface++;
		}

		for (i=0; i < Segs; i++)
			for (int j=0; j < NvertsPerRing; j++)
			{	v1 = i*NvertsPerRing + j;
				v2 = (j < lastvpr? v1+1 : v1 - lastvpr );
				v3 = v1 + NvertsPerRing;
				v4 = v2 + NvertsPerRing;
				v5 = (j < lastvpr? v2 : Nverts+i);
				v6 = (j < lastvpr? v4 : Nverts+i+1);
				if (clockwise)
					mesh.faces[thisface].setVerts(v4,v3,v1);
				else
					mesh.faces[thisface].setVerts(v1,v3,v4);
//				mesh.faces[thisface].setSmGroup(SMOOTH?2:0);
				switch (SMOOTH)
				{	case SMOOTHALL:		
						mesh.faces[thisface].setSmGroup(2); break;
					case SMOOTHNONE:	
						mesh.faces[thisface].setSmGroup(0); break;
					case SMOOTHSIDES:
						if (j == 0)
						{	mesh.faces[thisface].setSmGroup(2); break;}
						else if ((j % 2) == 0)
						{	mesh.faces[thisface].setSmGroup(4); break;}
						else
						{	mesh.faces[thisface].setSmGroup(8); break;}
					case SMOOTHSEGS:
						if (i == 0)
						{	mesh.faces[thisface].setSmGroup(2); break;}
						else if ((i % 2) == 0)
						{	mesh.faces[thisface].setSmGroup(4); break;}
						else
						{	mesh.faces[thisface].setSmGroup(8); break;}
				}
				mesh.faces[thisface].setEdgeVisFlags(1,1,0);
				mesh.faces[thisface].setMatID(1);\
				if (mapmenow)
					if (clockwise)
						mesh.tvFace[thisface].setTVerts(v6,v3,v1);
					else
						mesh.tvFace[thisface].setTVerts(v1,v3,v6);
				thisface++;
				if (clockwise)
					mesh.faces[thisface].setVerts(v1,v2,v4);
				else
					mesh.faces[thisface].setVerts(v4,v2,v1);
//				mesh.faces[thisface].setSmGroup(SMOOTH?2:0);
				switch (SMOOTH)
				{	case SMOOTHALL:		
						mesh.faces[thisface].setSmGroup(2); break;
					case SMOOTHNONE:	
						mesh.faces[thisface].setSmGroup(0); break;
					case SMOOTHSIDES:
						if (j == 0)
						{	mesh.faces[thisface].setSmGroup(2); break;}
						else if ((j % 2) == 0)
						{	mesh.faces[thisface].setSmGroup(4); break;}
						else
						{	mesh.faces[thisface].setSmGroup(8); break;}
					case SMOOTHSEGS:
						if (i == 0)
						{	mesh.faces[thisface].setSmGroup(2); break;}
						else if ((i % 2) == 0)
						{	mesh.faces[thisface].setSmGroup(4); break;}
						else
						{	mesh.faces[thisface].setSmGroup(8); break;}
				}
				mesh.faces[thisface].setEdgeVisFlags(1,1,0);
				mesh.faces[thisface].setMatID(1);
				if (mapmenow)
					if (clockwise)
						mesh.tvFace[thisface].setTVerts(v1,v5,v6);
					else
						mesh.tvFace[thisface].setTVerts(v6,v5,v1);
				thisface++;
			}
		int basevert = Segs*NvertsPerRing;

		v3 = Nverts-1;
		for (i = 0; i < NvertsPerRing; i++)
		{	v1 = i + basevert;
			v2 = (i < lastvpr? v1+1 : v1 - lastvpr);
			v5 = (i < lastvpr? v2 : Nverts+Segs);
			if (clockwise)
				mesh.faces[thisface].setVerts(v1,v2,v3);
			else
				mesh.faces[thisface].setVerts(v2,v1,v3);
			mesh.faces[thisface].setSmGroup((SMOOTH == 1)?0:1);
			mesh.faces[thisface].setEdgeVisFlags(1,0,0);
			mesh.faces[thisface].setMatID(2);;
			if (mapmenow)
				if (clockwise)
					mesh.tvFace[thisface].setTVerts(v1,v5,v3);
				else
					mesh.tvFace[thisface].setTVerts(v5,v1,v3);
			thisface++;
		}

		if (SaveVertex) 
			delete[] SaveVertex;
	}
	mesh.InvalidateGeomCache();
	mesh.InvalidateTopologyCache();mesh.BuildStripsAndEdges();
	srand( (unsigned)time( NULL ) );
}

class SpringEmitterCreateCallback : public CreateMouseCallBack {
	public:
		SpringObject *ob;
		Point3 p[2];
		IPoint2 sp0, sp1;
		BOOL square;
		void Cleanup();
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int SpringEmitterCreateCallback::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{	float r;
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE)
	{ switch(point)
		{ 	case 0:
				ob->suspendSnap = TRUE;				
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS));
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->SetValue(PB_OD,0,0.01f);
				ob->pblock->SetValue(PB_NOREFLENGTH,0,0.01f);
				ob->pblock->SetValue(PB_RNDDIA,0,0.01f);
				break;
			case 1: 
				{	mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
					p[1] = vpt->SnapPoint(m,m,NULL,snapdim);
					// diameter
					Point3 center = p[0];
					r = Length(p[1]-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
				
				float tempsize = 0.3f*r;
				ob->pblock->SetValue(PB_OD,0,2.0f*r);
				ob->pblock->SetValue(PB_RNDDIA,0,tempsize);
				ob->pblock->SetValue(PB_RECTWIDTH,0,tempsize);
				ob->pblock->SetValue(PB_RECTDEPTH,0,tempsize);
				ob->pblock->SetValue(PB_DSECWIDTH,0,tempsize);
				ob->pblock->SetValue(PB_DSECDEPTH,0,tempsize);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL)
				{	float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
				}

				if (msg==MOUSE_POINT) 
				{if (Length(m-sp0)<3 ||	Length(p[1]-p[0])<0.1f)
					{return CREATE_ABORT;	}
				}
				break;
				}
			case 2:
				{
#ifdef _OSNAP
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				float h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				if (h<0.0f) h*=-1.0f;
				ob->pblock->SetValue(PB_NOREFLENGTH,0,h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT)
				{ ob->suspendSnap = FALSE;
				  if (Length(m-sp0)<3 ) return CREATE_ABORT;	
				  else { TurnButton(ob->hParams,IDC_SPRING_PICKOBJECT1,TRUE);
						TurnButton(ob->hParams,IDC_SPRING_PICKOBJECT2,TRUE);
						return CREATE_STOP;
						}
				}
				}
				break;
			}
	}
	else
	if (msg == MOUSE_ABORT) 
	{ return CREATE_ABORT;}

	return TRUE;
}

static SpringEmitterCreateCallback emitterCallback;

CreateMouseCallBack* SpringObject::GetCreateMouseCallBack() 
	{
	emitterCallback.ob = this;
	return &emitterCallback;
	}

void SpringObject::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *SpringObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_NOREFLENGTH:
		case PB_OD:
		case PB_RNDDIA:
		case PB_RECTWIDTH:
		case PB_RECTDEPTH:
		case PB_RECTFILLET:
		case PB_DSECWIDTH:
		case PB_DSECDEPTH:
		case PB_DSECFILLET:
		case PB_FREELENGTH:
					return stdWorldDim;
		case PB_RECTROTANGLE:
		case PB_DSECROTANGLE:
					return stdAngleDim;
		default:	
					return defaultDim;
		}
	}

TSTR SpringObject::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ENDSMETHOD:			return GetString(IDS_AP_ENDSMETHOD);break;
		case PB_NOREFLENGTH:		return GetString(IDS_AP_NOREFLENGTH);break;
		case PB_OD:					return GetString(IDS_AP_OD);break;
		case PB_COILS:				return GetString(IDS_AP_COILS);break;
		case PB_COILDIR:			return GetString(IDS_AP_COILDIR);break;
		case PB_MANUALSEGSET:		return GetString(IDS_AP_SEGMENTMETHOD);break;
		case PB_SEGSPERTURN:		return GetString(IDS_AP_SEGSPERTURN);break;
		case PB_SEGMENTS:			return GetString(IDS_AP_SEGMENTS);break;
		case PB_SMOOTH:				return GetString(IDS_AP_SMOOTH);break;
		case PB_RENDERABLE:			return GetString(IDS_AP_RENDER);break;

		case PB_WIRETYPE:			return GetString(IDS_AP_WIRETYPE);break;
		case PB_RNDDIA:				return GetString(IDS_AP_RNDDIA);break;
		case PB_RNDSIDES:			return GetString(IDS_AP_RNDSIDES);break;

		case PB_RECTWIDTH:			return GetString(IDS_AP_RECTWIDTH);break;
		case PB_RECTDEPTH:			return GetString(IDS_AP_RECTDEPTH);break;
		case PB_RECTFILLET:			return GetString(IDS_AP_RFILLET);break;
		case PB_RECTFILLETSIDES:	return GetString(IDS_AP_RFILLETSIDES);break;
		case PB_RECTROTANGLE:		return GetString(IDS_AP_RECTROT);break;

		case PB_DSECWIDTH:			return GetString(IDS_AP_DSECWIDTH);break;
		case PB_DSECDEPTH:			return GetString(IDS_AP_DSECDEPTH);break;
		case PB_DSECFILLET:			return GetString(IDS_AP_DFILLET);break;
		case PB_DSECFILLETSIDES:	return GetString(IDS_AP_DFILLETSIDES);break;
		case PB_DSECRNDSIDES:		return GetString(IDS_AP_DSECRNDSIDES);break;
		case PB_DSECROTANGLE:		return GetString(IDS_AP_DSECROT);break;

		case PB_FREELENGTH:			return GetString(IDS_AP_FREELENGTH);break;
		case PB_KVALUE:				return GetString(IDS_AP_KVALUE);break;
		case PB_KVALUNITS:			return GetString(IDS_AP_KVALUNITS);break;
		case PB_SPRINGDIR:			return GetString(IDS_AP_SPRINGDIR);break;
		case PB_MAPMEMAPME:			return GetString(IDS_AP_MAPME);break;
		case PB_NONLINEAR:			return GetString(IDS_AP_NL);break;
		default: 					return TSTR(_T(""));
		}
	}

//--- Spring particle -----------------------------------------------

RefTargetHandle SpringObject::Clone(RemapDir& remap) 
	{
	SpringObject* newob = new SpringObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	if (custnode2) newob->ReplaceReference(CUSTNODE2,custnode2);
	newob->custname=custname;
	newob->custname2=custname2;
	newob->ivalid.SetEmpty();	
	int cnt=GetCOREInterface()->GetSelNodeCount();
	if (cnt>0) newob->thisnode=GetCOREInterface()->GetSelNode(0);
	else newob->thisnode=NULL;
	return newob;
	}

static float findmappos(float curpos)
{ float mappos;

  return(mappos=((mappos=curpos)<0.0f?0.0f:(mappos>1.0f?1.0f:mappos)));
}



RefTargetHandle SpringObject::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		case CUSTNODE2: return (RefTargetHandle)custnode2;
		default: return NULL;
		}
	}

void SpringObject::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		case CUSTNODE2: custnode2 = (INode *)rtarg; return;
		}
	}

RefResult SpringObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode)
			  { if (theHold.Holding() && !TestAFlag(A_HELD)) 
					theHold.Put(new CreateCPartRestoreNode(this));
			    DeleteReference(CUSTNODE);
				custnode=NULL;cancelled=FALSE;
				custname=TSTR(_T(" "));				
				}
			  if (hTarget==custnode2) 
			  { if (theHold.Holding() && !TestAFlag(A_HELD)) 
					theHold.Put(new CreateCPart2RestoreNode(this));
			    DeleteReference(CUSTNODE2);
				custnode2=NULL;cancelled=FALSE;
			    custname2=TSTR(_T(" "));
			  }
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				cancelled=FALSE;
				}
			  if (hTarget==custnode2) 
			  { custname2 = TSTR(custnode2->GetName());
			    ShowName2();
				cancelled=FALSE;
				}
			  break;
			}
		case REFMSG_CHANGE:
			{ SimpleObject::NotifyRefChanged(changeInt,hTarget,partID,message);
			  cancelled=FALSE;
			}
			break;
		default: SimpleObject::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}

/*class SpringPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		SpringPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((SpringObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
				((SpringObject*)targ)->pblock->SetValue(PB_SYMMETRY,0,0);
				}
			delete this;
			}
	};*/

#define COM_CUSTNAME_CHUNK	0x0100
#define COM_CUSTNAME2_CHUNK	0x0101
#define COM_CNODE_CHUNK		0x0102

IOResult SpringObject::Save(ISave *isave)
{ 	ULONG nb;
	int refid;

	isave->BeginChunk(COM_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();

	isave->BeginChunk(COM_CUSTNAME2_CHUNK);		
	isave->WriteWString(custname2);
	isave->EndChunk();

	refid=isave->GetRefID(thisnode);
	isave->BeginChunk(COM_CNODE_CHUNK);		
	isave->Write(&refid,sizeof(int),&nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult SpringObject::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	int cnmtl=0;
	int refid;
	
//	iload->RegisterPostLoadCallback(
			//new SpringPostLoadCallback(
				//new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0)));
	// Default names
	custname = TSTR(_T(" "));
	custname2 = TSTR(_T(" "));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case COM_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			case COM_CUSTNAME2_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname2= TSTR(buf);
				break;
				}
			case COM_CNODE_CHUNK: 
			{	res=iload->Read(&refid,sizeof(int),&nb);
			    iload->RecordBackpatch(refid,(void**)&thisnode);
				break; }
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}

const TCHAR *SpringClassDesc::ClassName ()	{return GetString(IDS_AP_SPRING);}
const TCHAR *SpringClassDesc::Category ()	{return GetString(IDS_EP_DYNPRIMS);}
TCHAR *SpringObject::GetObjectName() {return GetString(IDS_AP_SPRING);}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\scs\spind.cpp ===
/**********************************************************************
 *<
	FILE: spindle.cpp - builds Spindle Objects
	CREATED BY:  Audrey Peterson
   
 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "solids.h"
#include "iparamm.h"
#include "Simpobj.h"

static Class_ID SPINDLE_CLASS_ID(0x130b141b, 0x4b35afe);
class SpindleObject : public SimpleObject, public IParamArray {
	public:
		// Class vars
		static IParamMap *pmapCreate;
		static IParamMap *pmapTypeIn;
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		static float crtRadius, crtCapHeight,crtBlend;
		static float crtHeight,crtSliceFrom,crtSliceTo;
		static int dlgHSegs, dlgSides,dlgCSegs,crtCenters;
		static int dlgCreateMeth;
		static int dlgSmooth, dlgSlice;
		static Point3 crtPos;		
		BOOL increate;

		SpindleObject();		

		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
				
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_RB_SPINDLE); }
		BOOL HasUVW();
		void SetGenUVW(BOOL sw);
				
		// Animatable methods		
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return SPINDLE_CLASS_ID; }  		
				
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		
		IOResult Load(ILoad *iload);

		// From IParamArray
		BOOL SetValue(int i, TimeValue t, int v);
		BOOL SetValue(int i, TimeValue t, float v);
		BOOL SetValue(int i, TimeValue t, Point3 &v);
		BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
		BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		

	};

#define MIN_SEGMENTS	1
#define MAX_SEGMENTS	200

#define MIN_SIDES		3
#define MAX_SIDES		200

#define MIN_RADIUS		float(0)
#define MAX_RADIUS		float( 1.0E30)
#define MIN_HEIGHT		float(-1.0E30)
#define MAX_HEIGHT		float( 1.0E30)
#define MIN_SLICE	float(-1.0E30)
#define MAX_SLICE	float( 1.0E30)

#define DEF_SEGMENTS 	1
#define DEF_CSEGS		5
#define DEF_SIDES		12

#define DEF_RADIUS		float(0.0)
#define DEF_HEIGHT		float(0.01)
#define DEF_FILLET		float(0.01)

#define SMOOTH_ON		1
#define SMOOTH_OFF		0



//--- ClassDescriptor and class vars ---------------------------------

class SpindleClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SpindleObject; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_SPINDLE_CLASS); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return SPINDLE_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_EXTENDED);  }
	void			ResetClassParams(BOOL fileReset);
	};

static SpindleClassDesc SpindleDesc;

ClassDesc* GetSpindleDesc() { return &SpindleDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

// class variables for Spindle class.
IObjParam *SpindleObject::ip         = NULL;
int SpindleObject::dlgHSegs			= DEF_SEGMENTS;
int SpindleObject::dlgCSegs			= DEF_CSEGS;
int SpindleObject::dlgSides          = DEF_SIDES;
int SpindleObject::dlgCreateMeth     = 1; // create_radius
int SpindleObject::dlgSmooth         = SMOOTH_ON;
int SpindleObject::dlgSlice          = 0;
int SpindleObject::crtCenters          = 0;
IParamMap *SpindleObject::pmapCreate = NULL;
IParamMap *SpindleObject::pmapTypeIn = NULL;
IParamMap *SpindleObject::pmapParam  = NULL;
Point3 SpindleObject::crtPos         = Point3(0,0,0);
float SpindleObject::crtRadius       = 0.0f;
float SpindleObject::crtHeight       = 0.0f;
float SpindleObject::crtCapHeight    = 0.0f;
float SpindleObject::crtSliceFrom    = 0.0f;
float SpindleObject::crtSliceTo    = 0.0f;
float SpindleObject::crtBlend	= 0.0f;

void SpindleClassDesc::ResetClassParams(BOOL fileReset)
	{ SpindleObject::dlgHSegs			= DEF_SEGMENTS;
	  SpindleObject::dlgCSegs			= DEF_CSEGS;
	  SpindleObject::dlgSides          = DEF_SIDES;
	  SpindleObject::crtBlend			=0.0f;
	  SpindleObject::dlgCreateMeth     = 1; // create_radius
	  SpindleObject::dlgSmooth         = SMOOTH_ON;
	  SpindleObject::dlgSlice          = 0;
	  SpindleObject::crtCenters          = 0;
	  SpindleObject::crtRadius       = 0.0f;
	  SpindleObject::crtHeight       = 0.0f;
	  SpindleObject::crtCapHeight    = 0.0f;
	  SpindleObject::crtSliceFrom    = 0.0f;
	  SpindleObject::crtSliceTo    = 0.0f;
	  SpindleObject::crtPos         = Point3(0,0,0);
	}

//--- Parameter map/block descriptors -------------------------------

// Parameter block indices
#define PB_RADIUS		0
#define PB_CAPHEIGHT	1
#define PB_HEIGHT		2
#define PB_CENTERS		3
#define PB_BLEND		4
#define PB_SIDES		5
#define PB_CSEGS		6
#define PB_HSEGS		7
#define PB_SMOOTHON		8
#define PB_SLICEON		9
#define PB_SLICEFROM	10
#define PB_SLICETO		11
#define PB_GENUVS		12

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS		2
#define PB_TI_CAPHEIGHT		3
#define PB_TI_HEIGHT		4
#define PB_TI_CENTERS		5
#define PB_TI_BLEND			6

// dont worry about the CREATE button here
#define BMIN_HEIGHT		float(0.1)
#define BMAX_HEIGHT		float(1.0E30)
#define BMIN_LENGTH		float(0.1)
#define BMAX_LENGTH		float(1.0E30)
//
//
//	Creation method

static int createMethIDs[] = {IDC_UCYLS_BYDIA,IDC_UCYLS_BYRAD};

static ParamUIDesc descCreate[] = {
	// Diameter/radius
	ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
	};
#define CREATEDESC_LENGTH 1


//
//
// Type in

static int centerIDs[] = {IDC_SP_LENOVERALL,IDC_SP_LENCENTERS};

static ParamUIDesc descTypeIn[] = {
	
	// Position
	ParamUIDesc(
		PB_TI_POS,
		EDITTYPE_UNIVERSE,
		IDC_SP_POSX,IDC_SP_POSXSPIN,
		IDC_SP_POSY,IDC_SP_POSYSPIN,
		IDC_SP_POSZ,IDC_SP_POSZSPIN,
		float(-1.0E30),float(1.0E30),
		SPIN_AUTOSCALE),
	
	// Radius
	ParamUIDesc(
		PB_TI_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_SP_RADIUS,IDC_SP_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Cap Height
	ParamUIDesc(
		PB_TI_CAPHEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_SP_CAPHGT,IDC_SP_CAPHGTSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Height
	ParamUIDesc(
		PB_TI_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_SP_HEIGHT,IDC_SP_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Radio Buttons - centers
	ParamUIDesc(PB_TI_CENTERS,TYPE_RADIO,centerIDs,2),
	// Blend
	ParamUIDesc(
		PB_TI_BLEND,
		EDITTYPE_UNIVERSE,
		IDC_SP_BLEND,IDC_SP_BLENDSPIN,
		0.0f,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	};
#define TYPEINDESC_LENGTH 6

//
//
// Parameters


// DANGER DANGER DANGER I THINK THIS IS A REDEF BUT I HAVE NO
//EXAMPLES WITH RADIO BUTTONS APPEARING IN BOTH PARAM AND NONPARAM SCREENS

static ParamUIDesc descParam[] = {
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_SP_RADIUS,IDC_SP_RADIUSSPIN,
		MIN_RADIUS,MAX_RADIUS,
		SPIN_AUTOSCALE),
	
	// Cap Height
	ParamUIDesc(
		PB_CAPHEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_SP_CAPHGT,IDC_SP_CAPHGTSPIN,
		BMIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_SP_HEIGHT,IDC_SP_HEIGHTSPIN,
		MIN_HEIGHT,BMAX_HEIGHT,
		SPIN_AUTOSCALE),

	// Radio Buttons - centers
	ParamUIDesc(PB_CENTERS,TYPE_RADIO,centerIDs,2),

	// Blend
	ParamUIDesc(
		PB_BLEND,
		EDITTYPE_UNIVERSE,
		IDC_SP_BLEND,IDC_SP_BLENDSPIN,
		0.0f,BMAX_LENGTH,
		SPIN_AUTOSCALE),

	// Sides
	ParamUIDesc(
		PB_SIDES,
		EDITTYPE_INT,
		IDC_SP_SIDES,IDC_SP_SIDESSPIN,
		(float)MIN_SIDES,(float)MAX_SIDES,
		0.1f),
	
	// Cap Segments
	ParamUIDesc(
		PB_CSEGS,
		EDITTYPE_INT,
		IDC_SP_CAPSEGS,IDC_SP_CAPSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

		// Height Segments
	ParamUIDesc(
		PB_HSEGS,
		EDITTYPE_INT,
		IDC_SP_HEIGHTSEGS,IDC_SP_HEIGHTSEGSSPIN,
		(float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
		0.1f),

	// Gen Smoothing
	ParamUIDesc(PB_SMOOTHON,TYPE_SINGLECHEKBOX,IDC_SP_SMOOTH),			

	// Gen Slice
	ParamUIDesc(PB_SLICEON,TYPE_SINGLECHEKBOX,IDC_SP_SLICEON),			

	// Pie slice from
	ParamUIDesc(
		PB_SLICEFROM,
		EDITTYPE_FLOAT,
		IDC_SP_SLICE1,IDC_SP_SLICE1SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Pie slice to
	ParamUIDesc(
		PB_SLICETO,
		EDITTYPE_FLOAT,
		IDC_SP_SLICE2,IDC_SP_SLICE2SPIN,
		MIN_SLICE,MAX_SLICE,		
		0.5f,
		stdAngleDim),

	// Gen UVs
	ParamUIDesc(PB_GENUVS,TYPE_SINGLECHEKBOX,IDC_GENTEXTURE),			

	};
#define PARAMDESC_LENGTH 13


// variable type, NULL, animatable, number
ParamBlockDescID SpindledescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 }, 
	{ TYPE_FLOAT, NULL, TRUE, 4},
	{ TYPE_INT, NULL, TRUE, 5 }, 
	{ TYPE_INT, NULL, TRUE, 6 }, 
	{ TYPE_INT, NULL, TRUE, 7 },
	{ TYPE_INT, NULL, TRUE, 8 }, 
	{ TYPE_INT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_INT, NULL, FALSE, 12 } 
	};

#define PBLOCK_LENGTH	13

#define NUM_OLDVERSIONS	0

#define CURRENT_VERSION	0
static ParamVersionDesc curVersion(SpindledescVer0,PBLOCK_LENGTH,CURRENT_VERSION);


//--- TypeInDlgProc --------------------------------

class SpindleTypeInDlgProc : public ParamMapUserDlgProc {
	public:
		SpindleObject *ob;

		SpindleTypeInDlgProc(SpindleObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL SpindleTypeInDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SP_CREATE: {
					if (ob->crtRadius==0.0) return TRUE;
					
					// We only want to set the value if the object is 
					// not in the scene.
					if (ob->TestAFlag(A_OBJ_CREATING)) {
						ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius);
						ob->pblock->SetValue(PB_HEIGHT,0,ob->crtHeight);
						ob->pblock->SetValue(PB_CAPHEIGHT,0,ob->crtCapHeight);
						ob->pblock->SetValue(PB_BLEND,0,ob->crtBlend);
						ob->pblock->SetValue(PB_CENTERS,0,ob->crtCenters);
						}

					Matrix3 tm(1);
					tm.SetTrans(ob->crtPos);
					ob->suspendSnap = FALSE;
					ob->ip->NonMouseCreate(tm);					
					// NOTE that calling NonMouseCreate will cause this
					// object to be deleted. DO NOT DO ANYTHING BUT RETURN.
					return TRUE;	
					}
				}
			break;	
		}
	return FALSE;
	}

void FixSCapLimits(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float height,capheight,hh;
  BOOL con;

	pblock->GetValue(PB_CAPHEIGHT,(increate?0:t),capheight,FOREVER);
	pblock->GetValue(PB_CENTERS,t,con,FOREVER);
	pblock->GetValue(PB_HEIGHT,t,height,FOREVER);
	height=(float)fabs(height);
	if (con) height+=2.0f*capheight;
	hh=height/2.0f;
	if (hWnd)
	{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_SP_CAPHGTSPIN));
	  spin2->SetLimits(BMIN_HEIGHT,hh,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (capheight>hh) pblock->SetValue(PB_CAPHEIGHT,(increate?0:t),hh);
}
void FixSBlendLimits(IParamBlock *pblock,TimeValue t,HWND hWnd,BOOL increate)
{ float maxb,height,capheight,blend;
  BOOL con;

	pblock->GetValue(PB_CAPHEIGHT,t,capheight,FOREVER);
	pblock->GetValue(PB_CENTERS,t,con,FOREVER);
	pblock->GetValue(PB_HEIGHT,t,height,FOREVER);
	pblock->GetValue(PB_BLEND,(increate?0:t),blend,FOREVER);
	height=(float)fabs(height);
	if (con) height+=2.0f*capheight;
	maxb=(height-2.0f*capheight)/2.0f;
	if (hWnd)
	{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_SP_BLENDSPIN));
	  spin2->SetLimits(0.0f,maxb,FALSE);
	  ReleaseISpinner(spin2);
	}
	if (blend>maxb) pblock->SetValue(PB_BLEND,(increate?0:t),maxb);
}
class SpindleCapValsDlgProc : public ParamMapUserDlgProc {
	public:
		SpindleObject *ob;

		SpindleCapValsDlgProc(SpindleObject *o) {ob=o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL SpindleCapValsDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ 	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_SP_CAPHGTSPIN:
					FixSCapLimits(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				case IDC_SP_BLENDSPIN:
					FixSBlendLimits(ob->pblock,t,hWnd,ob->increate);
			return TRUE;
				}
		}
	return FALSE;
	}
//--- Spindle methods -------------------------------

SpindleObject::SpindleObject() 
	{
	MakeRefByID(FOREVER, 0, CreateParameterBlock(SpindledescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_RADIUS,0,crtRadius);
	pblock->SetValue(PB_CAPHEIGHT,0,crtCapHeight);
	pblock->SetValue(PB_HEIGHT,0,crtHeight);
	pblock->SetValue(PB_CENTERS,0,crtCenters);
	pblock->SetValue(PB_BLEND,0,crtBlend);
	pblock->SetValue(PB_SIDES,0,dlgSides);
	pblock->SetValue(PB_HSEGS,0,dlgHSegs);
	pblock->SetValue(PB_CSEGS,0,dlgCSegs);
	pblock->SetValue(PB_SMOOTHON,0,dlgSmooth);
	pblock->SetValue(PB_SLICEON,0,dlgSlice);
	pblock->SetValue(PB_SLICEFROM,0,crtSliceFrom);
	pblock->SetValue(PB_SLICETO,0,crtSliceTo);
	increate=FALSE;
	}

IOResult SpindleObject::Load(ILoad *iload) 
	{
	return IO_OK;
	}


void SpindleObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapCreate && pmapParam) {
		
		// Left over from last Spindle ceated
		pmapCreate->SetParamBlock(this);
		pmapTypeIn->SetParamBlock(this);
		pmapParam->SetParamBlock(pblock);
	} else {
		
		if (flags&BEGIN_EDIT_CREATE) {
			pmapCreate = CreateCPParamMap(
				descCreate,CREATEDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_UREVS1),
				GetString(IDS_RB_CREATE_DIALOG),
				0);

			pmapTypeIn = CreateCPParamMap(
				descTypeIn,TYPEINDESC_LENGTH,
				this,
				ip,
				hInstance,
				MAKEINTRESOURCE(IDD_SPINDLE2),
				GetString(IDS_RB_KEYBOARDENTRY),
				APPENDROLL_CLOSED);			
			}

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SPINDLE3),
			GetString(IDS_AP_PARAMETERS),
			0);
		}


	if(pmapTypeIn) {
		// A callback for the type in.
		pmapTypeIn->SetUserDlgProc(new SpindleTypeInDlgProc(this));
		}
	if(pmapParam) {
		// A callback for the type in.
		pmapParam->SetUserDlgProc(new SpindleCapValsDlgProc(this));
		}
}
		
void SpindleObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{		
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {
		if (pmapCreate) DestroyCPParamMap(pmapCreate);
		if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
		DestroyCPParamMap(pmapParam);
		pmapParam  = NULL;
		pmapTypeIn = NULL;
		pmapCreate = NULL;
		}

	// Save these values in class variables so the next object created will inherit them.
	pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);	
	pblock->GetValue(PB_CSEGS,ip->GetTime(),dlgCSegs,FOREVER);
	pblock->GetValue(PB_HSEGS,ip->GetTime(),dlgHSegs,FOREVER);
	}

/*void BoxObject::SetParams(float radius, float capheight, float height,
						  BOOL centers, BOOL ncaps, float blend,
						  int sides, int hsegs, BOOL smooth, BOOL slice, 
						  float slice1, float slice2, BOOL genUV) {
	pblock->SetValue(PB_RADIUS,0,radius);
	pblock->SetValue(PB_CAPHEIGHT,0,capheight);
	pblock->SetValue(PB_HEIGHT,0,height);
	pblock->SetValue(PB_CENTERS,0,centers);
	pblock->SetValue(PB_BLEND,0,blend);
	pblock->SetValue(PB_SIDES,0,sides);
	pblock->SetValue(PB_HSEGS,0,hsegs);
	pblock->SetValue(PB_CSEGS,0,csegs);
	pblock->SetValue(PB_SMOOTH,0,smooth);
	pblock->SetValue(PB_SLICEON,0,slice);
	pblock->SetValue(PB_SLICEFROM,0,slice1);
	pblock->SetValue(PB_SLICETO,0,slice2);
	pblock->SetValue(PB_GENUVS,0,genUV);
	} 
*/


void BuildSpindleMesh(Mesh &mesh,
		int segs, int capsegs, int smooth, int llsegs, int doPie, float radius1, float blend,
		float height, float capheight, float pie1, float pie2, int genUVs)
	{
	Point3 p;
	BOOL minush=(height<0.0f);
	if (minush) height=-height;
	int ix,jx,ic = 1;
	int nf=0,nv=0, lsegs,VertexPerLevel,csegs=(blend>0?1:0);
	float delta,ang;	
	float totalPie, startAng = 0.0f;	

	if (doPie) doPie = 1;
	else doPie = 0; 
	capsegs++;

	lsegs = llsegs-1 + 2*capsegs;

	// Make pie2 < pie1 and pie1-pie2 < TWOPI
	while (pie1 < pie2) pie1 += TWOPI;
	while (pie1 > pie2+TWOPI) pie1 -= TWOPI;
	if (pie1==pie2) totalPie = TWOPI;
	else totalPie = pie1-pie2;		
	int nfaces,ntverts,levels=csegs*2+(llsegs-1);
	int capv=segs,sideedge=capsegs+csegs,*edgelstr,*edgelstl,totlevels;
    // capv=vertex in one cap layer
	totlevels=levels+capsegs*2+2;
	int	tvinslice=totlevels+totlevels-2;
	if (doPie) {
		delta    = totalPie/(float)(segs);
		startAng = pie2; capv++;
		VertexPerLevel=segs+2;
		nfaces=2*segs*(levels+1)+(sideedge+llsegs)*4;
		ntverts=tvinslice+2*(segs+1);
		// 2 faces between every 2 vertices, with 2 ends, except in central cap)
	} else {
		delta = (float)2.0*PI/(float)segs;
		VertexPerLevel=segs;
		nfaces=2*segs*(levels+1);
		ntverts=2*(segs+1)+llsegs-1;
	}

	edgelstl=new int[totlevels];
	edgelstr=new int[totlevels];
	int lastlevel=totlevels-1,dcapv=capv-1,dvertper=VertexPerLevel-1;
	edgelstr[0]=0;edgelstl[0]=0;
	edgelstr[1]=1;
	edgelstl[1]=capv;
	for (int i=2;i<=sideedge;i++)
	{ edgelstr[i]=edgelstr[i-1]+capv;
	  edgelstl[i]=edgelstr[i]+dcapv;
	}
	while ((i<lastlevel)&&(i<=totlevels-sideedge))
	{ edgelstr[i]=edgelstr[i-1]+VertexPerLevel;
	  edgelstl[i]=edgelstr[i]+dcapv;
	  i++;
	}
	while (i<lastlevel)
	{ edgelstr[i]=edgelstr[i-1]+capv;
	  edgelstl[i]=edgelstr[i]+dcapv;
	  i++;
	}
	edgelstl[lastlevel]=(edgelstr[lastlevel]=edgelstl[i-1]+((doPie &&(sideedge==1))?2:1));
	int nverts=edgelstl[lastlevel]+1;

	nfaces+=2*segs*(2*capsegs-1);
	if (height<0) delta = -delta;

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setSmoothFlags(smooth != 0);
	if (genUVs) 
	{ ntverts+=nverts;
	  mesh.setNumTVerts(ntverts);
	  mesh.setNumTVFaces(nfaces);
	} 
	else 
	{ mesh.setNumTVerts(0);
	  mesh.setNumTVFaces(0);
	}
	
	mesh.setSmoothFlags((smooth != 0) | ((doPie != 0) << 1));
	// bottom vertex 
	mesh.setVert(nv, Point3(0.0f,0.0f,height));
	mesh.setVert(nverts-1, Point3(0.0f,0.0f,0.0f));		
	float ru,cang,sang,botz;
	int msegs=segs,deltaend=nverts-capv-1;
	// Bottom cap vertices
	ang = startAng;	 
	if (!doPie) msegs--;
	float deltah=capheight/(capsegs-1);
	float deltar=(radius1-0.01f)/(capsegs-1),theta=(float)atan(capheight/radius1);
	float chrad=radius1-blend*(float)cos(theta),chz=capheight-blend*(float)sin(theta);
	BOOL incap=TRUE;
	for (jx = 0; jx<=msegs; jx++) 
	{ cang=(float)cos(ang);
	  sang=(float)sin(ang);
	  for(ix=1; ix<=sideedge; ix++)
	  {if (ix<=capsegs)
		{ incap=(capsegs==sideedge||ix<capsegs);
	      if (ix==1) ru=0.01f;
		  else ru=(incap?0.01f+deltar*(float)(ix-1):chrad);
		  if (jx==0)
		  { if (ix==1) p.z=height;
		    else p.z = height-(incap?deltah*(float)(ix-1):chz);
		  } else p.z=mesh.verts[edgelstr[ix]].z;
	    }
		else
		{ ru=radius1;
		  if (jx==0)
		  {	p.z=height-(capheight+blend);
		  } else p.z=mesh.verts[edgelstr[ix]].z;
		}
		botz=height-p.z;
		if ((doPie)&&((jx==0)&&(ix==sideedge)))
		{ mesh.setVert(edgelstl[ix]+1,Point3(0.0f,0.0f,p.z));
		  mesh.setVert(edgelstl[lastlevel-ix]+1,Point3(0.0f,0.0f,botz));
		}
		p.x = cang*ru;
		p.y = sang*ru;	
		mesh.setVert(edgelstr[ix]+jx, p);
		mesh.setVert(edgelstr[lastlevel-ix]+jx,Point3(p.x,p.y,botz));
	  }
	  ang += delta;
	}
	//top layer done, now reflect sides down 
	int sidevs,startv=edgelstr[sideedge],deltav;				
	if (llsegs>1)
	{ float topd=mesh.verts[startv].z,sincr=(height-2.0f*(height-topd))/llsegs;
	  for (sidevs=0;sidevs<VertexPerLevel;sidevs++)
	  { p=mesh.verts[startv];
	    deltav=VertexPerLevel;
	    for (ic=1;ic<llsegs;ic++)
	    { p.z =topd-sincr*ic;
	 	  mesh.setVert(startv+deltav, p);
		  deltav+=VertexPerLevel;
	    }
	    startv++;
	  }
	}
	int lasttvl=0,lasttvr=0;
	if (genUVs)
	{ int tvcount=0,nexttv;
	  float udenom=2.0f*radius1;
	  for (i=0;i<=sideedge;i++)
	  {	nexttv=edgelstr[i];
		while (nexttv<=edgelstl[i])
		{ mesh.setTVert(tvcount++,(radius1+mesh.verts[nexttv].x)/udenom,(radius1+mesh.verts[nexttv].y)/udenom,0.0f);
		  nexttv++;
	    }
	  }
	  int iseg,hcount=0,lastedge=(sideedge==1?lastlevel-2:lastlevel-1);
	  float hlevel;
	  for (i=sideedge;i<=lastlevel-sideedge;i++)
	  { hlevel=1.0f-hcount++/(float)llsegs;
		for (iseg=0;iseg<=segs;iseg++)
		 mesh.setTVert(tvcount++,(float)iseg/segs,hlevel,0.0f);
	  }
	  i--;
	  while (i<=lastlevel)
	  {	nexttv=edgelstr[i];
		while (nexttv<=edgelstl[i])
		{ mesh.setTVert(tvcount++,(radius1+mesh.verts[nexttv].x)/udenom,(radius1+mesh.verts[nexttv].y)/udenom,0.0f);
		  nexttv++;
	    }
		i++;
	  }
	  if (doPie)
	  { lasttvl=lasttvr=tvcount;
		float u,v;
		mesh.setTVert(tvcount++,0.0f,1.0f,0.0f);
		for (i=sideedge;i<=sideedge+llsegs;i++)
	    { mesh.setTVert(tvcount++,0.0f,mesh.verts[edgelstl[i]].z/height,0.0f);
		}
		mesh.setTVert(tvcount++,0.0f,0.0f,0.0f);
		for (i=1;i<lastlevel;i++)
		{ u=(float)sqrt(mesh.verts[edgelstl[i]].x*mesh.verts[edgelstl[i]].x+mesh.verts[edgelstl[i]].y*mesh.verts[edgelstl[i]].y)/radius1;
		  v=mesh.verts[edgelstl[i]].z/height;
		  mesh.setTVert(tvcount++,u,v,0.0f);
		  mesh.setTVert(tvcount++,u,v,0.0f);
		}
	  }
	}	
	int lvert=(doPie?segs+1:segs);
    int t0,t1,b0,b1,tvt0=0,tvt1=0,tvb0=1,tvb1=2,fc=0,smoothgr=(smooth?4:0),vseg=segs+1;
	int tvcount=0,lowerside=lastlevel-sideedge,onside=0;
	BOOL ok,wrap;
	// Now make faces ---
	for (int clevel=0;clevel<lastlevel-1;clevel++)
	{ t1=(t0=edgelstr[clevel])+1;
	  b1=(b0=edgelstr[clevel+1])+1;
	  ok=!doPie; wrap=FALSE;
	  if ((clevel>0)&&((doPie)||(onside==1))) {tvt0++;tvt1++;tvb0++,tvb1++;}
	  if (clevel==1) {tvt0=1;tvt1=2;}
	  if (clevel==sideedge)
	    {tvt1+=lvert;tvt0+=lvert;tvb0+=vseg;tvb1+=vseg;onside++;}
	  else if (clevel==lowerside)
	    {tvt1+=vseg;tvt0+=vseg;tvb0+=lvert;tvb1+=lvert;onside++;}
	  while ((b0<edgelstl[clevel+1])||ok)
	  { if (b1==edgelstr[clevel+2]) 
	    { b1=edgelstr[clevel+1]; 
	      t1=edgelstr[clevel];
		  ok=FALSE;wrap=(onside!=1);}
	  if (smooth)
	  { if (blend>0.0f) smoothgr=4;
	    else
	    { if (clevel==0) smoothgr=16;
	    else if ((clevel<sideedge)||(clevel>=lowerside)) 
		  smoothgr=4;
		else smoothgr=8;
	    }
	  }
	  if (genUVs) mesh.tvFace[fc].setTVerts(tvt0,tvb0,(wrap?tvb1-segs:tvb1));
		AddFace(&mesh.faces[fc++],t0,b0,b1,0,smoothgr);
	    if (clevel>0)
		{ if (genUVs)
		  { if (wrap) mesh.tvFace[fc].setTVerts(tvt0++,tvb1-segs,tvt1-segs);
			else mesh.tvFace[fc].setTVerts(tvt0++,tvb1,tvt1);
			tvt1++;
		  }
		  AddFace(&mesh.faces[fc++],t0,b1,t1,1,smoothgr);
		  t0++;t1++;
		}
		b0++;b1++;tvb0++,tvb1++;
	  }
	}
	smoothgr=(smooth?(blend>0.0f?4:16):0);
	t1=(t0=edgelstr[lastlevel-1])+1;b0=edgelstr[lastlevel];
	int lastpt=(doPie?lastlevel-1:lastlevel);
	if ((doPie)||(onside==1)) {tvt0++;tvt1++;tvb0++,tvb1++;}
	if (sideedge==1) {tvt1+=vseg;tvt0+=vseg;tvb0+=lvert;tvb1+=lvert;onside++;}
	while (t0<edgelstl[lastpt])
	  { if ((!doPie)&&(t1==edgelstr[lastlevel]))
	    { t1=edgelstr[lastlevel-1];tvt1-=segs;}
		if (genUVs) mesh.tvFace[fc].setTVerts(tvt0++,tvb0,tvt1++);
		AddFace(&mesh.faces[fc++],t0,b0,t1,1,smoothgr);
		t0++;t1++;
	  }
	int chv=edgelstl[sideedge]+1,botcap=lastlevel-sideedge;
	int chb=edgelstl[botcap]+1,chm0,chm1,last=0,sg0=(smooth?2:0),sg1=(smooth?1:0);
	if (doPie)
	{int topctv=lasttvl+1,tvcount=topctv+llsegs+2;
	  for (i=1;i<=lastlevel;i++)
	  { if (i<=sideedge)
		{ if (genUVs)
		  { mesh.tvFace[fc].setTVerts(tvcount,topctv,lasttvl);lasttvl=tvcount++;
		    mesh.tvFace[fc+1].setTVerts(lasttvr,topctv,tvcount);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[i],chv,edgelstl[last],(i==1?1:2),sg0);
		  AddFace(&mesh.faces[fc++],edgelstr[last],chv,edgelstr[i],(i==1?3:2),sg1);
		}
	    else if (i<=botcap)
		{ if (genUVs)
		  { topctv++;
			mesh.tvFace[fc].setTVerts(lasttvl,tvcount,topctv);
			mesh.tvFace[fc+1].setTVerts(lasttvl,topctv,topctv-1);lasttvl=tvcount++;
		    mesh.tvFace[fc+2].setTVerts(topctv-1,topctv,tvcount);
		    mesh.tvFace[fc+3].setTVerts(topctv-1,tvcount,lasttvr);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[last],edgelstl[i],chm1=(edgelstl[i]+1),0,sg0);
	      AddFace(&mesh.faces[fc++],edgelstl[last],chm1,chm0=(edgelstl[last]+1),1,sg0);
		  AddFace(&mesh.faces[fc++],chm0,chm1,edgelstr[i],0,sg1);
	      AddFace(&mesh.faces[fc++],chm0,edgelstr[i],edgelstr[last],1,sg1);
		}
		else
		{if (genUVs)
		  {	if (i==lastlevel) tvcount=topctv+1;
			mesh.tvFace[fc].setTVerts(tvcount,topctv,lasttvl);
			  if (i<lastlevel) lasttvl=tvcount++;
		    mesh.tvFace[fc+1].setTVerts(lasttvr,topctv,tvcount);lasttvr=tvcount++;
		  }
		  AddFace(&mesh.faces[fc++],edgelstl[i],chb,edgelstl[last],(i==lastlevel?3:2),sg0);
	      AddFace(&mesh.faces[fc++],edgelstr[last],chb,edgelstr[i],(i==lastlevel?1:2),sg1);
		}
		last++;
	  }
	}
	if (minush)
	for (i=0;i<nverts;i++) mesh.verts[i].z-=height;

	if (edgelstr) delete []edgelstr;
	if (edgelstl) delete []edgelstl;
	assert(fc==mesh.numFaces);
//	assert(nv==mesh.numVerts);
	mesh.InvalidateGeomCache();
	mesh.BuildStripsAndEdges();
	}

BOOL SpindleObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUVS, 0, genUVs, v);
	return genUVs; 
	}

void SpindleObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUVS,0, sw);				
	}

void SpindleObject::BuildMesh(TimeValue t)
	{	
	int segs, smooth, hsegs;
	float radius,height,pie1, pie2,capheight,blend;
	int doPie, genUVs,con,csegs;	

	// Start the validity interval at forever and widdle it down.
    FixSCapLimits(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
    FixSBlendLimits(pblock,t,(pmapParam?pmapParam->GetHWnd():NULL),increate);
	ivalid = FOREVER;
	
	pblock->GetValue(PB_SIDES,t,segs,ivalid);
	pblock->GetValue(PB_CAPHEIGHT,t,capheight,ivalid);
	pblock->GetValue(PB_HSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_CSEGS,t,csegs,ivalid);
	pblock->GetValue(PB_BLEND,t,blend,ivalid);
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_CENTERS,t,con,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	if (con) height+=2.0f*capheight;
	pblock->GetValue(PB_SMOOTHON,t,smooth,ivalid);	
	pblock->GetValue(PB_SLICEFROM,t,pie1,ivalid);
	pblock->GetValue(PB_SLICETO,t,pie2,ivalid);	
	pblock->GetValue(PB_SLICEON,t,doPie,ivalid);	
	pblock->GetValue(PB_GENUVS,t,genUVs,ivalid);	
	LimitValue(radius, MIN_RADIUS, MAX_RADIUS);
	LimitValue(height, MIN_HEIGHT, MAX_HEIGHT);
	LimitValue(csegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(hsegs, MIN_SEGMENTS, MAX_SEGMENTS);
	LimitValue(segs, MIN_SIDES, MAX_SIDES);
	LimitValue(smooth, 0, 1);	
				//        sides,      smooth, 			  cylrad  fsize	 totalh
	BuildSpindleMesh(mesh, segs, csegs,smooth, hsegs, doPie,radius, blend, height, capheight,pie1, pie2, genUVs);
	}

inline Point3 operator+(const PatchVert &pv,const Point3 &p)
	{
	return p+pv.p;
	}

#define CIRCLE_VECTOR_LENGTH 0.5517861843f


Object* SpindleObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
		return SimpleObject::ConvertToType(t,obtype);
	}

int SpindleObject::CanConvertToType(Class_ID obtype)
	{
	if (obtype==triObjectClassID) {
		return 1;
	} else {
		return SimpleObject::CanConvertToType(obtype);
		}
	}

class SpindleObjCreateCallBack: public CreateMouseCallBack {
	SpindleObject *ob;	
	Point3 p[2];
	IPoint2 sp0,sp1,sp2;
	int con;
	float h,r;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(SpindleObject *obj) { ob = obj; }
	};

int SpindleObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;				
				sp0 = m;				
				p[0] = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				mat.SetTrans(p[0]); // Set Node's transform				
				ob->pblock->GetValue(PB_CENTERS,0,con,FOREVER);
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				ob->pblock->SetValue(PB_CAPHEIGHT,0,0.01f);
				ob->increate=TRUE;
				break;
			case 1: 
				mat.IdentityMatrix();
				//mat.PreRotateZ(HALFPI);
				sp1 = m;							   
				p[1] = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				if (ob->dlgCreateMeth) {	
					// radius	
					r = Length(p[1]-p[0]);
					mat.SetTrans(p[0]);
				} else {
					// diameter
					Point3 center = (p[0]+p[1])/float(2);
					r = Length(center-p[0]);
					mat.SetTrans(center);  // Modify Node's transform
					}
				
				ob->pblock->SetValue(PB_RADIUS,0,r);
				ob->pmapParam->Invalidate();

				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p[1].y-p[0].y,p[1].x-p[0].x);
					mat.PreRotateZ(ob->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 ||
						Length(p[1]-p[0])<0.1f) {	
						ob->increate=FALSE;
						return CREATE_ABORT;
						}
					}
				break;
			case 2:
				{ sp2=m;
#ifdef _OSNAP
				h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m,TRUE));
#else
				h = vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,0,1),sp1,m));
#endif
				ob->pblock->SetValue(PB_HEIGHT,0,h);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {					
					if (Length(m-sp0)<3) 
					{ ob->increate=FALSE;
					return CREATE_ABORT;}
					}
				}
				break;
			case 3: 
				float f=vpt->SnapLength(vpt->GetCPDisp(p[1],Point3(0,1,0),sp2,m));
				if (f<0.0f) f=0.0f;
				float chmax=float(fabs(h))/2.0f;
				if ((!con)&&(f>chmax)) f=chmax;
				ob->pblock->SetValue(PB_CAPHEIGHT,0,f);
				ob->pmapParam->Invalidate();				
				if (msg==MOUSE_POINT) 
				{  ob->suspendSnap = FALSE;	
				   ob->increate=FALSE;
				   return CREATE_STOP;
				}
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT) {	
		ob->increate=FALSE;
		return CREATE_ABORT;
		}

	return TRUE;
	}

static SpindleObjCreateCallBack cylCreateCB;

CreateMouseCallBack* SpindleObject::GetCreateMouseCallBack() 
	{
	cylCreateCB.SetObj(this);
	return(&cylCreateCB);
	}

BOOL SpindleObject::OKtoDisplay(TimeValue t) 
	{
	float radius;
	pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	if (radius==0.0f) return FALSE;
	else return TRUE;
	}


// From ParamArray
BOOL SpindleObject::SetValue(int i, TimeValue t, int v) 
	{
	switch (i) {
		case PB_CREATEMETHOD: dlgCreateMeth = v; break;
		case PB_TI_CENTERS: crtCenters = v; break;
		}		
	return TRUE;
	}

BOOL SpindleObject::SetValue(int i, TimeValue t, float v)
	{
	switch (i) {				
		case PB_TI_RADIUS: crtRadius = v; break;
		case PB_TI_CAPHEIGHT: crtCapHeight = v; break;
		case PB_TI_HEIGHT: crtHeight = v; break;
		case PB_TI_BLEND: crtBlend = v; break;
		}	
	return TRUE;
	}

BOOL SpindleObject::SetValue(int i, TimeValue t, Point3 &v) 
	{
	switch (i) {
		case PB_TI_POS: crtPos = v; break;
		}		
	return TRUE;
	}

BOOL SpindleObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
	{
	switch (i) {
		case PB_CREATEMETHOD: v = dlgCreateMeth; break;
		case PB_TI_CENTERS: v = crtCenters; break;
		}
	return TRUE;
	}

BOOL SpindleObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_RADIUS: v = crtRadius; break;
		case PB_TI_CAPHEIGHT: v = crtCapHeight; break;
		case PB_TI_HEIGHT: v = crtHeight; break;
		case PB_TI_BLEND: v = crtBlend; break;
		}
	return TRUE;
	}

BOOL SpindleObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
	{	
	switch (i) {		
		case PB_TI_POS: v = crtPos; break;		
		}
	return TRUE;
	}


void SpindleObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *SpindleObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS: return stdWorldDim;
		case PB_CAPHEIGHT: return stdWorldDim;
		case PB_HEIGHT: return stdWorldDim;
		case PB_BLEND: return stdWorldDim;
		case PB_SIDES: return stdSegmentsDim;
		case PB_CSEGS: return stdSegmentsDim;
		case PB_HSEGS: return stdSegmentsDim;
		case PB_SLICEFROM: return stdAngleDim;
		case PB_SLICETO: return stdAngleDim;
		default: return defaultDim;
		}
	}

TSTR SpindleObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_RADIUS: return TSTR(GetString(IDS_RB_RADIUS));
		case PB_CAPHEIGHT: return TSTR(GetString(IDS_RB_CAPHEIGHT));
		case PB_HEIGHT: return TSTR(GetString(IDS_RB_HEIGHT));
		case PB_BLEND: return TSTR(GetString(IDS_RB_BLEND));
		case PB_SIDES: return TSTR(GetString(IDS_RB_SIDES));
		case PB_HSEGS: return TSTR(GetString(IDS_RB_HSEGS));
		case PB_CSEGS: return TSTR(GetString(IDS_RB_CAPSEGS));
		case PB_SMOOTHON: return TSTR(GetString(IDS_RB_SMOOTHON));
		case PB_SLICEON: return TSTR(GetString(IDS_RB_SLICEON));
		case PB_SLICEFROM: return TSTR(GetString(IDS_RB_SLICEFROM));
		case PB_SLICETO: return TSTR(GetString(IDS_RB_SLICETO));
		default: return TSTR(_T(""));
		}
	}

RefTargetHandle SpindleObject::Clone(RemapDir& remap) 
	{
	SpindleObject* newob = new SpindleObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\pspflect.cpp ===
/**********************************************************************
 *<
	FILE: pspflect.cpp

	DESCRIPTION: Enhanced Deflector

	CREATED BY: Eric Peterson from Rolf Berteig's Deflector

	HISTORY: 7-17-97

 **********************************************************************/
#include "sflectr.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

static Class_ID PLANARSPAWNDEF_CLASS_ID(0x4e94628d, 0x4e437774);
static Class_ID PLANARSPAWNDEFMOD_CLASS_ID(0x7d257b98, 0x439e09de);

class PSpawnDeflObj : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		int lastrnd;
		TimeValue t;
		PSpawnDeflObj();
		BOOL SupportsDynamics() {return FALSE;}

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);
		Class_ID ClassID() {return PLANARSPAWNDEF_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_PLANARSPAWNDEF);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);	
		
		// from ref
		IOResult Load(ILoad *iload);
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *PSpawnDeflObj::ip        = NULL;
IParamMap *PSpawnDeflObj::pmapParam = NULL;
HWND       PSpawnDeflObj::hSot      = NULL;

class PSpawnDeflClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new PSpawnDeflObj;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_PLANARSPAWNDEF);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return PLANARSPAWNDEF_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_PARTICLES);}
	};

static PSpawnDeflClassDesc pspawndeflDesc;
ClassDesc* GetPSpawnDeflObjDesc() {return &pspawndeflDesc;}

//--- DeflectMod -----------------------------------------------------

class PSpawnDeflField : public CollisionObject {
	public:		
		PSpawnDeflObj *obj;
		INode *node;
		Matrix3 tm,invtm,tp;
		Interval tmValid;		
		Point3 Vc,Vcp;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class PSpawnDeflMod : public SimpleWSMMod {
	public:				
		PSpawnDeflField deflect;

		PSpawnDeflMod() {}
		PSpawnDeflMod(INode *node,PSpawnDeflObj *obj);		

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_EP_PLANARSPAWNDEFMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return PLANARSPAWNDEFMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_PLANARSPAWNDEFMODBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class PSpawnDeflModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new PSpawnDeflMod;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_PLANARSPAWNDEFMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return PLANARSPAWNDEFMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static PSpawnDeflModClassDesc pspawndeflModDesc;
ClassDesc* GetPSpawnDeflModDesc() {return &pspawndeflModDesc;}

//--- DeflectObject Parameter map/block descriptors ------------------

#define PB_TIMEON		0
#define PB_TIMEOFF		1
#define PB_AFFECTS		2
#define PB_BOUNCE		3
#define PB_BOUNCEVAR	4
#define PB_CHAOS		5
#define PB_INHERIT		6
#define PB_REFRACTS		7
#define PB_DECEL		8
#define PB_DECELVAR		9
#define PB_REFRACTION	10
#define PB_REFRACTVAR	11
#define PB_DIFFUSION	12
#define PB_DIFFUSIONVAR	13
#define PB_ICONSIZE		14
#define PB_ICONSIZE1	15
#define PB_SPAWN		16
#define PB_PASSVEL		17
#define PB_PASSVELVAR	18


static ParamUIDesc descPSpawnDeflParam[] = {
	// Time On
	ParamUIDesc(
		PB_TIMEON,
		EDITTYPE_TIME,
		IDC_EP_TIMEON,IDC_EP_TIMEONSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Time Off
	ParamUIDesc(
		PB_TIMEOFF,
		EDITTYPE_TIME,
		IDC_EP_TIMEOFF,IDC_EP_TIMEOFFSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Affects Percentage
	ParamUIDesc(
		PB_AFFECTS,
		EDITTYPE_FLOAT,
		IDC_EP_AFFECTS,IDC_EP_AFFECTSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCE,IDC_EP_BOUNCESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// BounceVar
	ParamUIDesc(
		PB_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEVAR,IDC_EP_BOUNCEVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_EP_CHAOS,IDC_EP_CHAOSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Inherit
	ParamUIDesc(
		PB_INHERIT,
		EDITTYPE_FLOAT,
		IDC_EP_INHERIT,IDC_EP_INHERITSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Refracts Percentage
	ParamUIDesc(
		PB_REFRACTS,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTS,IDC_EP_REFRACTSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction Decel
	ParamUIDesc(
		PB_DECEL,
		EDITTYPE_FLOAT,
		IDC_EP_DECEL,IDC_EP_DECELSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Refraction Decel Var
	ParamUIDesc(
		PB_DECELVAR,
		EDITTYPE_FLOAT,
		IDC_EP_DECELVAR,IDC_EP_DECELVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction
	ParamUIDesc(
		PB_REFRACTION,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTION,IDC_EP_REFRACTIONSPIN,
		-100.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction Var
	ParamUIDesc(
		PB_REFRACTVAR,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTVAR,IDC_EP_REFRACTVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Diffusion
	ParamUIDesc(
		PB_DIFFUSION,
		EDITTYPE_FLOAT,
		IDC_EP_DIFFUSION,IDC_EP_DIFFUSIONSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Diffusion Var
	ParamUIDesc(
		PB_DIFFUSIONVAR,
		EDITTYPE_FLOAT,
		IDC_EP_DIFFUSIONVAR,IDC_EP_DIFFUSIONVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Spawns Percentage
	ParamUIDesc(
		PB_SPAWN,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNSONLY,IDC_EP_SPAWNSONLYSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Pass Velocity
	ParamUIDesc(
		PB_PASSVEL,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNONLYDECEL,IDC_EP_SPAWNONLYDECELSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Pass Velocity Var
	ParamUIDesc(
		PB_PASSVELVAR,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNSONLYDECELVAR,IDC_EP_SPAWNSONLYDECELVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_EP_ICONSIZE,IDC_EP_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Icon Size1
	ParamUIDesc(
		PB_ICONSIZE1,
		EDITTYPE_UNIVERSE,
		IDC_EP_ICONSIZE1,IDC_EP_ICONSIZE1SPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE)
};
#define PARAMDESC_LENGTH	19


ParamBlockDescID descPSpawnDeflVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_FLOAT, NULL, TRUE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },
	{ TYPE_FLOAT, NULL, TRUE, 15 }};

ParamBlockDescID descPSpawnDeflVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_FLOAT, NULL, TRUE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },
	{ TYPE_FLOAT, NULL, TRUE, 15 },
	{ TYPE_FLOAT, NULL, TRUE, 16 },
	{ TYPE_FLOAT, NULL, TRUE, 17 },
	{ TYPE_FLOAT, NULL, TRUE, 18 },
};

#define PBLOCK_LENGTH	19

static ParamVersionDesc psversions[] = {
	ParamVersionDesc(descPSpawnDeflVer0,16,0),
	};

#define NUM_OLDVERSIONS	1
#define CURRENT_VERSION	1

static ParamVersionDesc pcurVersion(descPSpawnDeflVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- PSpawnDeflector object methods -----------------------------------------


PSpawnDeflObj::PSpawnDeflObj()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descPSpawnDeflVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_TIMEON,0,0);
	pblock->SetValue(PB_TIMEOFF,0,100*GetTicksPerFrame());
	pblock->SetValue(PB_AFFECTS,0,1.0f);
	pblock->SetValue(PB_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BOUNCEVAR,0,0.0f);
	pblock->SetValue(PB_CHAOS,0,0.0f);
	pblock->SetValue(PB_INHERIT,0,1.0f);
	pblock->SetValue(PB_REFRACTS,0,1.0f);
	pblock->SetValue(PB_DECEL,0,1.0f);
	pblock->SetValue(PB_DECELVAR,0,0.0f);
	pblock->SetValue(PB_REFRACTION,0,0.5f);
	pblock->SetValue(PB_REFRACTVAR,0,0.0f);
	pblock->SetValue(PB_DIFFUSION,0,0.0f);
	pblock->SetValue(PB_DIFFUSIONVAR,0,0.0f);
	pblock->SetValue(PB_SPAWN,0,1.0f);
	pblock->SetValue(PB_PASSVEL,0,1.0f);
	pblock->SetValue(PB_PASSVELVAR,0,0);
	srand(lastrnd=12345);
	t=99999;
	}

Modifier *PSpawnDeflObj::CreateWSMMod(INode *node)
	{
	return new PSpawnDeflMod(node,this);
	}

RefTargetHandle PSpawnDeflObj::Clone(RemapDir& remap) 
	{
	PSpawnDeflObj* newob = new PSpawnDeflObj();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
	}

void PSpawnDeflObj::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC),
			DefaultSOTProc,
			GetString(IDS_EP_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descPSpawnDeflParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_AP_PSPAWNDEFL),
			GetString(IDS_EP_PARAMETERS),
			0);
		}
	}

void PSpawnDeflObj::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}

void PSpawnDeflObj::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_TIMEON,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEON,0,TempTime);
	pblock->GetValue(PB_TIMEOFF,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEOFF,0,TempTime);
}  

void PSpawnDeflObj::BuildMesh(TimeValue t)
{	float width, height;
	float w2,h2,h2p,h2m,h3,h4,h5;
	ivalid = FOREVER;
	pblock->GetValue(PB_ICONSIZE,t,width,ivalid);
	pblock->GetValue(PB_ICONSIZE1,t,height,ivalid);
	width  *= 0.5f;
	w2=width*0.5f;
	height *= 0.5f;
	h2=height*0.5f;
	h2p=h2*1.5f;
	h2m=h2*0.5f;
	h3=h2*0.1f;
	h4=h2*0.07f;
	h5=h2*0.5f;

	mesh.setNumVerts(34);
	mesh.setNumFaces(17);
//square base 
	mesh.setVert(0, Point3(-width,-height, 0.0f));
	mesh.setVert(1, Point3( width,-height, 0.0f));
	mesh.setVert(2, Point3( width, height, 0.0f));
	mesh.setVert(3, Point3(-width, height, 0.0f));

//tripods
	mesh.setVert( 4, Point3( -w2, h2, 0.0f));
	mesh.setVert( 5, Point3( -w2, h2p, -h5));
	mesh.setVert( 6, Point3( -w2, h2 ,h5));
	mesh.setVert( 7, Point3( -w2, h2m, -h5));
	mesh.setVert( 8, Point3(  w2, h2, 0.0f));
	mesh.setVert( 9, Point3(  w2, h2p, -h5));
	mesh.setVert(10, Point3(  w2, h2 ,h5));
	mesh.setVert(11, Point3(  w2, h2m, -h5));
	mesh.setVert(12, Point3(0.0f,-h2, 0.0f));
	mesh.setVert(13, Point3(0.0f,-h2m, -h5));
	mesh.setVert(14, Point3(0.0f,-h2 ,h5));
	mesh.setVert(15, Point3(0.0f,-h2p, -h5));

//each group is a set of three arrowheads for one tripod
	mesh.setVert(16, Point3( -w2, h2p-h3, -h5));
	mesh.setVert(17, Point3( -w2, h2p, -h5+h3));
//	mesh.setVert(18, Point3( -w2, h2+h4 ,-h5-h4));
//	mesh.setVert(19, Point3( -w2, h2-h4 ,-h5-h4));
	mesh.setVert(18, Point3( -w2+h4, h2 ,h4));
	mesh.setVert(19, Point3( -w2-h4, h2 ,h4));
	mesh.setVert(20, Point3( -w2, h2m, -h5+h3));
	mesh.setVert(21, Point3( -w2, h2m+h3, -h5));

	mesh.setVert(22, Point3(  w2, h2p-h3, -h5));
	mesh.setVert(23, Point3(  w2, h2p, -h5+h3));
//	mesh.setVert(24, Point3(  w2, h2+h4 ,-h5-h4));
//	mesh.setVert(25, Point3(  w2, h2-h4 ,-h5-h4));
	mesh.setVert(24, Point3(  w2+h4, h2 ,h4));
	mesh.setVert(25, Point3(  w2-h4, h2 ,h4));
	mesh.setVert(26, Point3(  w2, h2m, -h5+h3));
	mesh.setVert(27, Point3(  w2, h2m+h3, -h5));
	
	mesh.setVert(28, Point3(0.0f,-h2m-h3, -h5));
	mesh.setVert(29, Point3(0.0f,-h2m, -h5+h3));
//	mesh.setVert(30, Point3(0.0f,-h2+h4 ,-h5-h4));
//	mesh.setVert(31, Point3(0.0f,-h2-h4 ,-h5-h4));
	mesh.setVert(30, Point3(0.0f+h4,-h2 ,h4));
	mesh.setVert(31, Point3(0.0f-h4,-h2 ,h4));
	mesh.setVert(32, Point3(0.0f,-h2p, -h5+h3));
	mesh.setVert(33, Point3(0.0f,-h2p+h3, -h5));

	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[0].setSmGroup(0);
	mesh.faces[0].setVerts(0,1,3);

	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(0);
	mesh.faces[1].setVerts(1,2,3);	

	mesh.faces[2].setEdgeVisFlags(1,0,1);
	mesh.faces[2].setSmGroup(0);
	mesh.faces[2].setVerts(4,5,6);	
	mesh.faces[3].setEdgeVisFlags(1,0,1);
	mesh.faces[3].setSmGroup(0);
	mesh.faces[3].setVerts(4,7,6);	
	mesh.faces[4].setEdgeVisFlags(1,0,1);
	mesh.faces[4].setSmGroup(0);
	mesh.faces[4].setVerts(8,9,10);	
	mesh.faces[5].setEdgeVisFlags(1,0,1);
	mesh.faces[5].setSmGroup(0);
	mesh.faces[5].setVerts(8,11,10);	
	mesh.faces[6].setEdgeVisFlags(1,0,1);
	mesh.faces[6].setSmGroup(0);
	mesh.faces[6].setVerts(12,13,14);	
	mesh.faces[7].setEdgeVisFlags(1,0,1);
	mesh.faces[7].setSmGroup(0);
	mesh.faces[7].setVerts(12,15,14);	

	mesh.faces[8].setEdgeVisFlags(1,1,1);
	mesh.faces[8].setSmGroup(0);
	mesh.faces[8].setVerts(5,17,16);	
	mesh.faces[9].setEdgeVisFlags(1,1,1);
	mesh.faces[9].setSmGroup(0);
//	mesh.faces[9].setVerts(6,19,18);	
	mesh.faces[9].setVerts(4,19,18);	
	mesh.faces[10].setEdgeVisFlags(1,1,1);
	mesh.faces[10].setSmGroup(0);
	mesh.faces[10].setVerts(7,21,20);	

	mesh.faces[11].setEdgeVisFlags(1,1,1);
	mesh.faces[11].setSmGroup(0);
	mesh.faces[11].setVerts(9,23,22);	
	mesh.faces[12].setEdgeVisFlags(1,1,1);
	mesh.faces[12].setSmGroup(0);
//	mesh.faces[12].setVerts(10,25,24);	
	mesh.faces[12].setVerts(8,25,24);	
	mesh.faces[13].setEdgeVisFlags(1,1,1);
	mesh.faces[13].setSmGroup(0);
	mesh.faces[13].setVerts(11,27,26);	

	mesh.faces[14].setEdgeVisFlags(1,1,1);
	mesh.faces[14].setSmGroup(0);
	mesh.faces[14].setVerts(13,29,28);	
	mesh.faces[15].setEdgeVisFlags(1,1,1);
	mesh.faces[15].setSmGroup(0);
//	mesh.faces[15].setVerts(14,31,30);	
	mesh.faces[15].setVerts(12,31,30);	
	mesh.faces[16].setEdgeVisFlags(1,1,1);
	mesh.faces[16].setSmGroup(0);
	mesh.faces[16].setVerts(15,33,32);	

	mesh.InvalidateGeomCache();	
	}


class PSpawnDeflObjCreateCallback : public CreateMouseCallBack {
	public:
		PSpawnDeflObj *ob;	
		Point3 p0, p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int PSpawnDeflObjCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				ob->pblock->SetValue(PB_ICONSIZE,0,0.01f);
				ob->pblock->SetValue(PB_ICONSIZE1,0,0.01f);
				ob->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				ob->pblock->SetValue(PB_ICONSIZE,0,(float)fabs(p1.x-p0.x));
				ob->pblock->SetValue(PB_ICONSIZE1,0,(float)fabs(p1.y-p0.y));
				ob->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
	}
static PSpawnDeflObjCreateCallback pspawndeflCreateCB;

CreateMouseCallBack* PSpawnDeflObj::GetCreateMouseCallBack()
	{
	pspawndeflCreateCB.ob = this;
	return &pspawndeflCreateCB;
	}

void PSpawnDeflObj::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *PSpawnDeflObj::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_TIMEON:			return stdTimeDim;
		case PB_TIMEOFF:		return stdTimeDim;
		case PB_AFFECTS:		return stdPercentDim;
		case PB_BOUNCEVAR:		return stdPercentDim;
		case PB_CHAOS:			return stdPercentDim;
		case PB_REFRACTS:		return stdPercentDim;
		case PB_DECELVAR:		return stdPercentDim;
		case PB_REFRACTION:		return stdPercentDim;
		case PB_REFRACTVAR:		return stdPercentDim;
		case PB_DIFFUSION:		return stdPercentDim;
		case PB_DIFFUSIONVAR:	return stdPercentDim;
		case PB_SPAWN:			return stdPercentDim;
		case PB_PASSVELVAR:		return stdPercentDim;
		default:				return defaultDim;
		}
	}

TSTR PSpawnDeflObj::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_TIMEON:			return GetString(IDS_EP_TIMEON);
		case PB_TIMEOFF:		return GetString(IDS_EP_TIMEOFF);
		case PB_AFFECTS:		return GetString(IDS_EP_AFFECTS);
		case PB_BOUNCE:			return GetString(IDS_EP_BOUNCE);
		case PB_BOUNCEVAR:		return GetString(IDS_EP_BOUNCEVAR);
		case PB_CHAOS:			return GetString(IDS_EP_CHAOS);
		case PB_INHERIT:		return GetString(IDS_EP_INHERIT);
		case PB_REFRACTS:		return GetString(IDS_EP_REFRACTS);
		case PB_DECEL:			return GetString(IDS_EP_PASSVEL);
		case PB_DECELVAR:		return GetString(IDS_EP_PASSVELVAR);
		case PB_REFRACTION:		return GetString(IDS_EP_REFRACTION);
		case PB_REFRACTVAR:		return GetString(IDS_EP_REFRACTVAR);
		case PB_DIFFUSION:		return GetString(IDS_EP_DIFFUSION);
		case PB_DIFFUSIONVAR:	return GetString(IDS_EP_DIFFUSIONVAR);
		case PB_SPAWN:			return GetString(IDS_AP_SPAWN);
		case PB_PASSVEL:		return GetString(IDS_AP_PASSVEL);
		case PB_PASSVELVAR:		return GetString(IDS_AP_PASSVELVAR);
		case PB_ICONSIZE:		return GetString(IDS_EP_WIDTH);
		case PB_ICONSIZE1:		return GetString(IDS_EP_HEIGHT);
		default: 				return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

PSpawnDeflMod::PSpawnDeflMod(INode *node,PSpawnDeflObj *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef = NULL;
	}

Interval PSpawnDeflMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;
		PSpawnDeflObj *obj = (PSpawnDeflObj*)GetWSMObject(t);
		TimeValue TempT;
		obj->pblock->GetValue(PB_TIMEOFF,t,TempT,valid);
		obj->pblock->GetValue(PB_AFFECTS,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,f,valid);
		obj->pblock->GetValue(PB_CHAOS,t,f,valid);
		obj->pblock->GetValue(PB_INHERIT,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTS,t,f,valid);
		obj->pblock->GetValue(PB_DECEL,t,f,valid);
		obj->pblock->GetValue(PB_DECELVAR,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTION,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTVAR,t,f,valid);
		obj->pblock->GetValue(PB_DIFFUSION,t,f,valid);
		obj->pblock->GetValue(PB_DIFFUSIONVAR,t,f,valid);
		obj->pblock->GetValue(PB_ICONSIZE,t,f,valid);
		obj->pblock->GetValue(PB_ICONSIZE1,t,f,valid);
		obj->pblock->GetValue(PB_SPAWN,t,f,valid);
		obj->pblock->GetValue(PB_PASSVEL,t,f,valid);
		obj->pblock->GetValue(PB_PASSVELVAR,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class PSpawnDeflDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static PSpawnDeflDeformer pspawndeformer;

Deformer& PSpawnDeflMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return pspawndeformer;
	}

RefTargetHandle PSpawnDeflMod::Clone(RemapDir& remap) 
	{
	PSpawnDeflMod *newob = new PSpawnDeflMod(nodeRef,(PSpawnDeflObj*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}


void PSpawnDeflMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (PSpawnDeflObj*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.tmValid.SetEmpty();		
		if (t<=deflect.obj->t) deflect.obj->lastrnd=12345;
		deflect.obj->t=t;
		obj->ApplyCollisionObject(&deflect);
		}
	}

Object *PSpawnDeflField::GetSWObject()
{ return obj;
}

BOOL PSpawnDeflField::CheckCollision(TimeValue t,Point3 &pos,Point3 &vel,float dt,int index,float *ct,BOOL UpdatePastCollide)
{	if (!tmValid.InInterval(t))
	{	tmValid=FOREVER;
		tm=node->GetObjectTM(t,&tmValid);
		invtm=Inverse(tm);
		Interval tmpValid=FOREVER;
		tp=node->GetObjectTM(t-(int)dt,&tmpValid);
		Vc=Zero;
		Vcp=Zero*tp*invtm;
	}
	float stepsize=dt,intimestep=dt;
	Point3 invel=vel;

// test for time limits
	TimeValue startt,endt;
	obj->pblock->GetValue(PB_TIMEON,t,startt,FOREVER);
	obj->pblock->GetValue(PB_TIMEOFF,t,endt,FOREVER);
	if ((t<startt)||(t>endt))
	{	obj->lastrnd=rand();
		return FALSE;
	}

	srand(obj->lastrnd);
	float width,height,at,inherit,theta;
	Point3 p,v,ph,vdt,vrel;
	Point3 tabs2,tabs1,vabsdefl;
	
//test for reflection
	float affectsthisportion;
	obj->pblock->GetValue(PB_AFFECTS,t,affectsthisportion,FOREVER);

	if (RND01()<affectsthisportion)
	{	obj->pblock->GetValue(PB_ICONSIZE,t,width,FOREVER);
		obj->pblock->GetValue(PB_ICONSIZE1,t,height,FOREVER);
		width *=0.5f;
		height*=0.5f;
		float bounce,bouncevar,chaos;
		obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,bouncevar,FOREVER);
		obj->pblock->GetValue(PB_CHAOS,t,chaos,FOREVER);
		obj->pblock->GetValue(PB_INHERIT,t,inherit,FOREVER);
		p=pos*invtm; 
		v=VectorTransform(invtm,vel);
		vdt=(Vc-Vcp)/dt;
		vrel=v-vdt;
// Compute the point of intersection
		if (fabs(p.z)<0.001f)
		{	//v.z=0.0f;
			at=0.0f;		
		}
		else
		{	if (vrel.z==0.0)
			{	obj->lastrnd=rand();
				return FALSE;
			}
			at= -p.z/vrel.z;
			if ((at<0.0f)||(at>dt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
		}
		ph=p+at*vrel;
// See if the point is within our range
		if ((ph.x<-width)||(ph.x>width)||(ph.y<-height)||(ph.y>height))
		{	obj->lastrnd=rand();
			return FALSE;
		}
// if we're here, we have a collision
// Remove the part of dt we used to get to the collision point
		float holddt = dt;
		dt-=at;
// go back to particle speed to find location of hit
		ph=p+at*v;
// Reflect the velocity about the XY plane and attenuate with the bounce factor
		v.z=-v.z;
// reduce v by bounce parameters
		v*=bounce*(1.0f-bouncevar*RND01());
// rotate velocity vector to give us chaos
		if (!FloatEQ0(chaos))
		{	theta=(float)acos(DotProd(Normalize(v),Point3(0.0f,0.0f,1.0f)));
			theta=(HalfPI-theta)*chaos*RND01();
			Point3 d=Point3(RND11(),RND11(),RND11());
			Point3 c=Normalize(v^d);
			RotateOnePoint(v,&Zero.x,&c.x,theta);
		}
// Tranform back into world space.
		pos = ph*tm;
		vel = VectorTransform(tm,v);
// find absolute motion of deflector and add inheritance
		tabs2 = tm.GetRow(3);
		tabs1 = tp.GetRow(3);
		vabsdefl = (tabs2-tabs1)/intimestep;
		vel += inherit*vabsdefl;
// use up the rest of the time available to find the final position
//		pos += vel*dt;

		if (UpdatePastCollide)
		{	pos += vel*dt;
			if (ct) (*ct) = holddt;
		}
		else
		{	if (ct) (*ct) = at;
		}

		obj->lastrnd=rand();
		return TRUE;
	}

// test for refraction
	float refracts;
	obj->pblock->GetValue(PB_REFRACTS,t,refracts,FOREVER);

	if (RND01()<refracts)
	{	obj->pblock->GetValue(PB_ICONSIZE,t,width,FOREVER);
		obj->pblock->GetValue(PB_ICONSIZE1,t,height,FOREVER);
		width *=0.5f;
		height*=0.5f;
		float refvol,refvar,decel,decelvar;
		obj->pblock->GetValue(PB_REFRACTION,t,refvol,FOREVER);
		obj->pblock->GetValue(PB_REFRACTVAR,t,refvar,FOREVER);
		obj->pblock->GetValue(PB_DECEL,t,decel,FOREVER);
		obj->pblock->GetValue(PB_DECELVAR,t,decelvar,FOREVER);
		obj->pblock->GetValue(PB_INHERIT,t,inherit,FOREVER);
		p=pos*invtm; 
		v=VectorTransform(invtm,vel);
		vdt=(Vc-Vcp)/dt;
		vrel=v-vdt;
// Compute the point of intersection
		if (fabs(p.z)<0.001f)
		{	//v.z=0.0f;
			at=0.0f;		
		}
		else
		{	if (vrel.z==0.0)
			{	obj->lastrnd=rand();
				return FALSE;
			}
			at= -p.z/vrel.z;
			if ((at<0.0f)||(at>dt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
		}
		ph=p+at*vrel;
// See if the point is within our range
		if ((ph.x<-width)||(ph.x>width)||(ph.y<-height)||(ph.y>height))
		{	obj->lastrnd=rand();
			return FALSE;
		}
// if we're here, we have a collision
// Remove the part of dt we used to get to the collision point
		float holddt = dt;
		dt-=at;
// figure out if we're hitting the front or back
		float dirapproach;
		Point3 ZVec=Point3(0.0f,0.0f,1.0f);
		dirapproach=(DotProd(vrel,ZVec)<0.0f?1.0f:-1.0f);
		Point3 MZVec=Point3(0.0f,0.0f,-1.0f); 
// go back to particle speed to find location of hit
		if (dirapproach>0.0f)
			ph=p+at*v-ZVec;
		else
			ph=p+at*v-MZVec;
// reduce v by decel parameters
		v*=decel*(1.0f-decelvar*RND01());
// rotate velocity vector
		float maxref,refangle,maxvarref;
		refangle=0.0f;
		if (!FloatEQ0(refvol))
		{	if (dirapproach>0.0f)
				theta=(float)acos(DotProd(Normalize(-v),ZVec));
			else
				theta=(float)acos(DotProd(Normalize(-v),MZVec));
			if ((refvol>0.0f)==(dirapproach>0.0f))
				maxref=-theta;
			else 
				maxref=HalfPI-theta;
			refangle=maxref*(float)fabs(refvol);
			float frefangle=(float)fabs(refangle);
			if ((refvol>0.0f)==(dirapproach>0.0f))
				maxvarref=HalfPI-theta-frefangle;
			else
				maxvarref=theta-frefangle;
			refangle+=maxvarref*RND11()*refvar;
			Point3 c,d;
			if (theta<0.01f)
			{	d=Point3(RND11(),RND11(),RND11());
				c=Normalize(v^d);
			}
			else
			{	if (dirapproach>0.0f)
				 	c=Normalize(ZVec^(-v));
				else
				 	c=Normalize(MZVec^(-v));
			}
			RotateOnePoint(v,&Zero.x,&c.x,refangle);
			if ((v.z>0.0f)==(dirapproach>0.0f)) v.z=0.0f;
		}
		float maxdiff,diffuse,diffvar,diffangle;
		obj->pblock->GetValue(PB_DIFFUSION,t,diffuse,FOREVER);
		obj->pblock->GetValue(PB_DIFFUSIONVAR,t,diffvar,FOREVER);
//		if ((refvol>0.0f)==(dirapproach>0.0f))
			maxdiff=HalfPI-theta-refangle;
//		else
//			maxdiff=theta-refangle;
		if (!FloatEQ0(diffuse))
		{	Point3 d=Point3(RND11(),RND11(),RND11());
			Point3 c=Normalize(v^d);
			diffangle=0.5f*maxdiff*diffuse*(1.0f+RND11()*diffvar);
			RotateOnePoint(v,&Zero.x,&c.x,diffangle);
			if ((v.z>0.0f)==(dirapproach>0.0f)) v.z=0.0f;
		}
// Transform back into world space.
		pos = ph*tm;
		vel = VectorTransform(tm,v);
// find absolute motion of deflector and add inheritance
		tabs2 = tm.GetRow(3);
		tabs1 = tp.GetRow(3);
		vabsdefl = (tabs2-tabs1)/intimestep;
		vel += inherit*vabsdefl;
// use up the rest of the time available to find the final position
//		pos += vel*dt;

		if (UpdatePastCollide)
		{	pos += vel*dt;
			if (ct) (*ct) = holddt;
		}
		else
		{	if (ct) (*ct) = at;
		}

		obj->lastrnd=rand();
		return TRUE;
	}

// test for spawns only
	float spawnsonly;
	obj->pblock->GetValue(PB_SPAWN,t,spawnsonly,FOREVER);

	if (RND01()<spawnsonly)
	{	obj->pblock->GetValue(PB_ICONSIZE,t,width,FOREVER);
		obj->pblock->GetValue(PB_ICONSIZE1,t,height,FOREVER);
		width *= 0.5f;
		height *= 0.5f;
		p = pos*invtm; 
		v = VectorTransform(invtm,vel);
		vdt = (Vc-Vcp)/dt;
		vrel = v-vdt;
// Compute the point of intersection
		if (fabs(p.z)<0.001f)
		{	//v.z=0.0f;
			at=0.0f;		
		}
		else
		{	if (vrel.z==0.0)
			{	obj->lastrnd=rand();
				return FALSE;
			}
			at= -p.z/vrel.z;
			if ((at<0.0f)||(at>dt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
		}
		ph = p + at*vrel;
// See if the point is within our range
		if ((ph.x<-width)||(ph.x>width)||(ph.y<-height)||(ph.y>height))
		{	obj->lastrnd=rand();
			return FALSE;
		}
// if we're here, we have a collision
		float passvel,passvelvar;
		obj->pblock->GetValue(PB_PASSVEL,t,passvel,FOREVER);
		obj->pblock->GetValue(PB_PASSVELVAR,t,passvelvar,FOREVER);
		pos += vel*at;
		vel *= passvel*(1.0f+passvelvar*RND11());

		if (UpdatePastCollide)
		{	pos += vel*(dt-at);
			if (ct) (*ct) = dt;
		}
		else
		{	if (ct) (*ct) = at;
		}

		return TRUE;
	}

// nothing happened
	obj->lastrnd=rand();
	return FALSE;
}

class PSpawnDeflPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		PSpawnDeflPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((PSpawnDeflObj*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
 				((PSpawnDeflObj*)targ)->pblock->SetValue(PB_SPAWN,0,1.0f);
 				((PSpawnDeflObj*)targ)->pblock->SetValue(PB_PASSVEL,0,1.0f);
 				((PSpawnDeflObj*)targ)->pblock->SetValue(PB_PASSVELVAR,0,0);
				}
			delete this;
			}
	};

IOResult PSpawnDeflObj::Load(ILoad *iload) 
	{	
	// This is the callback that corrects for any older versions
	// of the parameter block structure found in the MAX file 
	// being loaded.
	iload->RegisterPostLoadCallback(
		new PSpawnDeflPostLoadCallback(
		new ParamBlockPLCB(psversions,NUM_OLDVERSIONS,&pcurVersion,this,0)));
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\sdyflect.cpp ===
/**********************************************************************
 *<
	FILE: sdyflect.cpp

	DESCRIPTION: spherical dynamics momentum xfer deflector

	CREATED BY: Eric Peterson from Audrey Peterson's SDeflector code

	HISTORY: 7/97

 **********************************************************************/
#include "sflectr.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

static Class_ID SDYNADEFL_CLASS_ID(0x44692f1c, 0x13ca051a);
static Class_ID SDYNADEFLMOD_CLASS_ID(0x70051444, 0x2bf5270a);

const float dymin=0.0001f;

class SDynaDeflObject : public DynamModObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		int lastrnd;
		TimeValue t;
		SDynaDeflObject();
		BOOL SupportsDynamics() {return TRUE;}

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);
		Class_ID ClassID() {return SDYNADEFL_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_SDYNADEFLECTOR);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		

		// From BaseObject
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}

		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
		FlectForces ForceData(TimeValue t);
		FlectForces ffdata;	
		TimeValue ctime;
};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *SDynaDeflObject::ip        = NULL;
IParamMap *SDynaDeflObject::pmapParam = NULL;
HWND       SDynaDeflObject::hSot      = NULL;

class SDynaDeflClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new SDynaDeflObject;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_SDYNADEFLECTOR);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return SDYNADEFL_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_DYNAMICS);}
	};

static SDynaDeflClassDesc SDynaDeflDesc;
ClassDesc* GetSDynaDeflObjDesc() {return &SDynaDeflDesc;}

//--- DeflectMod -----------------------------------------------------

class SDynaDeflField : public CollisionObject {
	public:		
		SDynaDeflObject *obj;
		INode *node;
		Matrix3 tm, invtm,tp;
		Interval tmValid;
		Point3 totalforce,applyat;
		int totalnumber;
		TimeValue curtime;
		Point3 Vc,Vcp;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class SDynaDeflMod : public SimpleWSMMod {
	public:				
		SDynaDeflField deflect;

		SDynaDeflMod() {deflect.curtime=NoAni;}
		SDynaDeflMod(INode *node,SDynaDeflObject *obj);		

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_EP_SDYNADEFLECTORMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return SDYNADEFLMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_SDYNADEFLECTORBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class SDynaDeflModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new SDynaDeflMod;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_SDYNADEFLECTORMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return SDYNADEFLMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static SDynaDeflModClassDesc SDynaDeflModDesc;
ClassDesc* GetSDynaDeflModDesc() {return &SDynaDeflModDesc;}

//--- SphereFlectorObject Parameter map/block descriptors ------------------

#define PB_TIMEON		0
#define PB_TIMEOFF		1
#define PB_AFFECTS		2
#define PB_BOUNCE		3
#define PB_BOUNCEVAR	4
#define PB_CHAOS		5
#define PB_INHERIT		6
#define PB_RADIUS		7
#define PB_MASS			8
#define PB_MASSUNITS	9
//#define PB_FORCEX		10
//#define PB_FORCEY		11
//#define PB_FORCEZ		12
//#define PB_APPLYX		13
//#define PB_APPLYY		14
//#define PB_APPLYZ		15
//#define PB_NUMBER		16

static int massSunitsIDs[] = {IDC_EP_MASSGM,IDC_EP_MASSKG,IDC_EP_MASSLBM};

static ParamUIDesc descSDynaDeflParam[] = {
	// Start Time
	ParamUIDesc(
		PB_TIMEON,
		EDITTYPE_TIME,
		IDC_EP_TIMEON,IDC_EP_TIMEONSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Stop Time
	ParamUIDesc(
		PB_TIMEOFF,
		EDITTYPE_TIME,
		IDC_EP_TIMEOFF,IDC_EP_TIMEOFFSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Affects
	ParamUIDesc(
		PB_AFFECTS,
		EDITTYPE_FLOAT,
		IDC_EP_AFFECTS,IDC_EP_AFFECTSSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCE,IDC_EP_BOUNCESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// BounceVar
	ParamUIDesc(
		PB_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEVAR,IDC_EP_BOUNCEVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_EP_CHAOS,IDC_EP_CHAOSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Inherit
	ParamUIDesc(
		PB_INHERIT,
		EDITTYPE_FLOAT,
		IDC_EP_INHERIT,IDC_EP_INHERITSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
		
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_EP_ICONSIZE,IDC_EP_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Particle Mass
	ParamUIDesc(
		PB_MASS,
		EDITTYPE_FLOAT,
		IDC_EP_PARTICLEMASS,IDC_EP_PARTICLEMASSSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Particle Mass Units
	ParamUIDesc(PB_MASSUNITS,TYPE_RADIO,massSunitsIDs,3)

	};

#define PARAMDESC_LENGTH	10

ParamBlockDescID SDynaDefldescVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },//time on	
	{ TYPE_INT, NULL, TRUE, 1 },	//time off
	{ TYPE_FLOAT, NULL, TRUE, 2 },	//affects
	{ TYPE_FLOAT, NULL, TRUE, 3 },//bounce
	{ TYPE_FLOAT, NULL, TRUE, 4 },//bounce var
	{ TYPE_FLOAT, NULL, TRUE, 5 },//chaos
	{ TYPE_FLOAT, NULL, TRUE, 6 },//vel inherit
	{ TYPE_FLOAT, NULL, TRUE, 7 },//radius
	{ TYPE_FLOAT, NULL, TRUE, 8 },//mass
	{ TYPE_INT, NULL, FALSE, 9 },//mass units
	{ TYPE_FLOAT, NULL, FALSE, 10 },//forcex
	{ TYPE_FLOAT, NULL, FALSE, 11 },
	{ TYPE_FLOAT, NULL, FALSE, 12 },
	{ TYPE_FLOAT, NULL, FALSE, 13 },//apply at x
	{ TYPE_FLOAT, NULL, FALSE, 14 },
	{ TYPE_FLOAT, NULL, FALSE, 15 },
	{ TYPE_INT, NULL, FALSE, 16 } //total number
};	

#define PBLOCK_LENGTH	17

#define CURRENT_VERSION	0


//--- Deflect object methods -----------------------------------------

SDynaDeflObject::SDynaDeflObject()
{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(SDynaDefldescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_TIMEON,0,0);
	pblock->SetValue(PB_TIMEOFF,0,100*GetTicksPerFrame());
	pblock->SetValue(PB_AFFECTS,0,100.0f);
	pblock->SetValue(PB_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BOUNCEVAR,0,0.0f);
	pblock->SetValue(PB_CHAOS,0,0.0f);
	pblock->SetValue(PB_INHERIT,0,1.0f);
	pblock->SetValue(PB_MASS,0,1.0f);
	pblock->SetValue(PB_MASSUNITS,0,0);
	srand(lastrnd=12345);
	ffdata.FlectForce=Zero;ffdata.ApplyAt=Zero;ffdata.Num=0;
	t=99999;
	ctime=99999;
}

Modifier *SDynaDeflObject::CreateWSMMod(INode *node)
	{
	return new SDynaDeflMod(node,this);
	}

RefTargetHandle SDynaDeflObject::Clone(RemapDir& remap) 
	{
	SDynaDeflObject* newob = new SDynaDeflObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
	}

void SDynaDeflObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC_BOTH),
			DefaultSOTProc,
			GetString(IDS_EP_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descSDynaDeflParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_AP_SDYNADEFL),
			GetString(IDS_EP_PARAMETERS),
			0);
		}
	}

void SDynaDeflObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}

void SDynaDeflObject::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_TIMEON,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEON,0,TempTime);
	pblock->GetValue(PB_TIMEOFF,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEOFF,0,TempTime);
}  

void SDynaDeflObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float r,r2,r3,r4;
	pblock->GetValue(PB_RADIUS,t,r,ivalid);
	float u;
	#define NUM_SEGS	24
	 r2=0.5f*r;
	 r3=0.15f*r2;
	 r4=0.25f*r2;

	mesh.setNumVerts(3*NUM_SEGS+16);
	mesh.setNumFaces(3*NUM_SEGS+9);

	for (int i=0; i<NUM_SEGS; i++)
	{	u=float(i)/float(NUM_SEGS) * TWOPI;
		mesh.setVert(i, Point3((float)cos(u) * r, (float)sin(u) * r, 0.0f));
	}
	for (i=0; i<NUM_SEGS; i++)
	{	u=float(i)/float(NUM_SEGS) * TWOPI;
		mesh.setVert(i+NUM_SEGS, Point3(0.0f, (float)cos(u) * r, (float)sin(u) * r));
	}
	for (i=0; i<NUM_SEGS; i++)
	{	u=float(i)/float(NUM_SEGS) * TWOPI;
		mesh.setVert(i+2*NUM_SEGS, Point3((float)cos(u) * r, 0.0f, (float)sin(u) * r));
	}		

	mesh.setVert(72, Point3(0.0f,0.0f,0.0f));

	mesh.setVert(73, Point3(0.0f,0.0f,  r ));
	mesh.setVert(74, Point3(0.0f, r2 ,r+r2));
	mesh.setVert(75, Point3(0.0f,-r2 ,r+r2));
	mesh.setVert(76, Point3(0.0f, r2+r3,r+r2));
	mesh.setVert(77, Point3(0.0f, r2,r+r2+r3));
	mesh.setVert(78, Point3(0.0f,-r2,r+r2-r3));
	mesh.setVert(79, Point3(0.0f,-r2+r3,r+r2));

	mesh.setVert(80, Point3(0.0f, r4   ,-r ));
	mesh.setVert(81, Point3(0.0f, r4   ,-r-r2));
	mesh.setVert(82, Point3(0.0f, r4+r3,-r-r2));
	mesh.setVert(83, Point3(0.0f,0.0f  ,-r-r2-r3-r3));
	mesh.setVert(84, Point3(0.0f,-r4-r3,-r-r2));
	mesh.setVert(85, Point3(0.0f,-r4   ,-r-r2));
	mesh.setVert(86, Point3(0.0f,-r4   ,-r));
	mesh.setVert(87, Point3(0.0f,0.0f  ,-r-r4));
	
	for (i=0; i<3*NUM_SEGS; i++)
	{	int i1 = i+1;
		if (i1%NUM_SEGS==0) i1 -= NUM_SEGS;
		mesh.faces[i].setEdgeVisFlags(1,0,0);
		mesh.faces[i].setSmGroup(1);
		mesh.faces[i].setVerts(i,i1,3*NUM_SEGS);
	}

	mesh.faces[72].setEdgeVisFlags(1,0,1);
	mesh.faces[72].setSmGroup(1);
	mesh.faces[72].setVerts(73,75,74);	
	mesh.faces[73].setEdgeVisFlags(1,0,1);
	mesh.faces[73].setSmGroup(1);
	mesh.faces[73].setVerts(75,78,79);	
	mesh.faces[74].setEdgeVisFlags(1,0,1);
	mesh.faces[74].setSmGroup(1);
	mesh.faces[74].setVerts(74,77,76);

	mesh.faces[75].setEdgeVisFlags(1,0,1);
	mesh.faces[75].setSmGroup(1);
	mesh.faces[75].setVerts(80,81,87);	
	mesh.faces[76].setEdgeVisFlags(0,0,0);
	mesh.faces[76].setSmGroup(1);
	mesh.faces[76].setVerts(81,85,87);	
	mesh.faces[77].setEdgeVisFlags(1,1,0);
	mesh.faces[77].setSmGroup(1);
	mesh.faces[77].setVerts(85,86,87);	
	mesh.faces[78].setEdgeVisFlags(1,1,0);
	mesh.faces[78].setSmGroup(1);
	mesh.faces[78].setVerts(81,82,83);	
	mesh.faces[79].setEdgeVisFlags(0,0,0);
	mesh.faces[79].setSmGroup(1);
	mesh.faces[79].setVerts(81,83,85);	
	mesh.faces[80].setEdgeVisFlags(1,1,0);
	mesh.faces[80].setSmGroup(1);
	mesh.faces[80].setVerts(83,84,85);	

	mesh.InvalidateGeomCache();
/*	int j;
	for (i=0;i<88;i++)
	{	if ((mesh.verts[i])||(!mesh.verts[i]))
		{	j++;	}
	}*/ //debugging code only
}


class SDynaDeflObjCreateCallback : public CreateMouseCallBack {
	public:
		SDynaDeflObject *ob;	
		Point3 p0, p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int SDynaDeflObjCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{
	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pmapParam->Invalidate();
				break;

			case 1: {
				sp1 = m;
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				ob->pblock->SetValue(PB_RADIUS,0,Length(p1-p0));
				ob->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
}

static SDynaDeflObjCreateCallback SDynaDeflCreateCB;

CreateMouseCallBack* SDynaDeflObject::GetCreateMouseCallBack()
	{
	SDynaDeflCreateCB.ob = this;
	return &SDynaDeflCreateCB;
	}

void SDynaDeflObject::InvalidateUI() 
{	if (pmapParam) pmapParam->Invalidate();
}

ParamDimension *SDynaDeflObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_TIMEON:
				 return stdTimeDim;
		case PB_TIMEOFF:
				 return stdTimeDim;
		case PB_AFFECTS:
				 return stdPercentDim;
		case PB_BOUNCEVAR:
				 return stdPercentDim;
		case PB_CHAOS:
				 return stdPercentDim;
		default: return defaultDim;
		}
	}

TSTR SDynaDeflObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_TIMEON: 	return GetString(IDS_EP_TIMEON);
		case PB_TIMEOFF:	return GetString(IDS_EP_TIMEOFF);
		case PB_AFFECTS:	return GetString(IDS_EP_AFFECTS);
		case PB_BOUNCE:		return GetString(IDS_EP_BOUNCE);
		case PB_BOUNCEVAR:	return GetString(IDS_EP_BOUNCEVAR);
		case PB_CHAOS:		return GetString(IDS_EP_CHAOS);
		case PB_INHERIT:	return GetString(IDS_EP_INHERIT);
		case PB_RADIUS:		return GetString(IDS_EP_RADIUS);
		case PB_MASS:		return GetString(IDS_EP_MASS);
		case PB_MASSUNITS:	return GetString(IDS_EP_MASSUNITS);
		default: 			return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

SDynaDeflMod::SDynaDeflMod(INode *node,SDynaDeflObject *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef = NULL;
	}

Interval SDynaDeflMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		SDynaDeflObject *obj = (SDynaDeflObject*)GetWSMObject(t);
		obj->pblock->GetValue(PB_TIMEOFF,t,f,valid);
		obj->pblock->GetValue(PB_AFFECTS,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,f,valid);
		obj->pblock->GetValue(PB_CHAOS,t,f,valid);
		obj->pblock->GetValue(PB_INHERIT,t,f,valid);
		obj->pblock->GetValue(PB_RADIUS,t,f,valid);
		obj->pblock->GetValue(PB_MASS,t,f,valid);
		tm=nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class SDynaDeflDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static SDynaDeflDeformer SDynaDeflddeformer;

Deformer& SDynaDeflMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return SDynaDeflddeformer;
	}

RefTargetHandle SDynaDeflMod::Clone(RemapDir& remap) 
{	SDynaDeflMod *newob = new SDynaDeflMod(nodeRef,(SDynaDeflObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
}


void SDynaDeflMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (SDynaDeflObject*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.tmValid.SetEmpty();		
		deflect.totalforce=Zero;
		deflect.applyat=Zero;
		deflect.totalnumber=0;
		if (t<=deflect.obj->t) deflect.obj->lastrnd=12345;
		deflect.obj->t=t;
		TimeValue tmpt=GetCOREInterface()->GetTime();
		if (deflect.obj->ctime!=tmpt)
		{ deflect.obj->ctime=tmpt;
		  deflect.obj->ffdata.FlectForce=deflect.totalforce;
		  deflect.obj->ffdata.ApplyAt=deflect.applyat;
		  deflect.obj->ffdata.Num=deflect.totalnumber;
		}
//		deflect.curtime=NoAni;
		obj->ApplyCollisionObject(&deflect);
		}
	}

Object *SDynaDeflField::GetSWObject()
{ return obj;
}

BOOL SDynaDeflField::CheckCollision(TimeValue t,Point3 &pos,Point3 &vel,float dt,int index,float *ct,BOOL UpdatePastCollide)
{	if (!tmValid.InInterval(t))
	{	tmValid=FOREVER;
		tm=node->GetObjectTM(t,&tmValid);
		invtm=Inverse(tm);
		Interval tmpValid=FOREVER;
		tp=node->GetObjectTM(t+(int)dt,&tmpValid);
		Vc=Zero;
		Vcp=Zero*tp*invtm;
	}
	
    if (curtime!=t)
	{	totalforce=Zero;
		applyat=Zero;
		totalnumber=0;
		curtime=t;
//		obj->ffdata.FlectForce=totalforce;
//		obj->ffdata.ApplyAt=applyat;
//		obj->ffdata.Num=totalnumber;
	}
	float K=(float)GetMasterScale(UNITS_CENTIMETERS);
	float stepsize=dt;
	Point3 invel=vel;

	TimeValue startt,endt;
	obj->pblock->GetValue(PB_TIMEON,t,startt,FOREVER);
	obj->pblock->GetValue(PB_TIMEOFF,t,endt,FOREVER);
	if ((t<startt)||(t>endt))
	{	obj->lastrnd=rand();
		return FALSE;
	}

	float affectsthisportion;
	obj->pblock->GetValue(PB_AFFECTS,t,affectsthisportion,FOREVER);
    srand(obj->lastrnd);
	if (RND01()>affectsthisportion)
	{	obj->lastrnd=rand();
		return FALSE;
	}
	
	float bounce,bvar,chaos,vinher;
	obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
	obj->pblock->GetValue(PB_BOUNCEVAR,t,bvar,FOREVER);
	obj->pblock->GetValue(PB_CHAOS,t,chaos,FOREVER);
	obj->pblock->GetValue(PB_INHERIT,t,vinher,FOREVER);

	float radius;
	obj->pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	Point3 p,vr;
	p=pos*invtm; 
	vr=VectorTransform(invtm,vel);
	Point3 Vdt, XI;
	Vdt=(Vcp-Vc)/dt;
	Point3 Vrel=vr-Vdt;
	float rsquare=radius*radius;
	float omega;
	float rplus=radius,rminus=radius;
	Point3 Vreln=Normalize(Vrel);
	if (LengthSquared(p-Vc)>=(rminus*rminus)) //outside
	{	Point3 P1;
		P1=p+dt*Vrel; //second particle position
		if (!(LengthSquared(P1-Vc)<(rplus*rplus)))
		{	float Dist,Dist1;
			Dist=DotProd(Vreln,(Vc-p));
			if (Dist<0.0f)
			{	obj->lastrnd=rand();
				return FALSE;
			}
			Dist1=DotProd(-Vreln,(Vc-P1));
			if (Dist1<0.0f)
			{	obj->lastrnd=rand();
				return FALSE;
			}
			Point3 P10=P1-p,Pc=Vc-p;
			float gamma=(float)acos(DotProd(P10,Pc)/(Length(P10)*Length(Pc)));
			float Dist2=Length(Pc)*(float)cos(HalfPI-gamma);
			if (Dist2>radius)
			{	obj->lastrnd=rand();
				return FALSE;
			}
		}
		float A,B,C,omega1,omegaend,a2,ptmp,c,d;
		A=LengthSquared(Vrel);
		B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
		C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
		omegaend=B*B-4.0f*A*C;
		if (omegaend<0.0f) omegaend=0.0f;
		else omegaend=(float)sqrt(omegaend);
		a2=2.0f*A;
		omega1=(-B+omegaend)/a2;
		omega=(-B-omegaend)/a2;
		if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
		float fdt=1.1f*dt;
		if ((omega>fdt)||(omega<-fdt))
		{	obj->lastrnd=rand();
			return FALSE;
		}
// solve for collision params starts here
		Point3 r,n;
		XI=p+omega*vr;
		Point3 Ci=Vc+omega*Vdt;
		r=Normalize(XI-Ci);
		float q1=DotProd(-Vreln,r);
		float theta=(float)acos(q1);
		if (theta>=HalfPI) theta-=PI;
		float v[4];
		if (theta<FLOAT_EPSILON)
			vr=-vr;
		else 
		{	n=Normalize((-Vreln)^r);
			vr=-vr;
			memcpy(v,vr,row3size);v[3]=1.0f;
			RotateOnePoint(v,&Zero.x,&n.x,2*theta);
			memcpy(vr,v,row3size);
		}
		vr=vr*bounce*(1-bvar*RND01());
		if (!FloatEQ0(chaos))
		{	theta=(HalfPI-theta)*chaos*RND01();
			Point3 d=Point3(RND11(),RND11(),RND11());
			Point3 c=Normalize(vr^d);
			memcpy(v,vr,row3size);v[3]=1.0f;
			RotateOnePoint(v,&Zero.x,&c.x,theta);
			memcpy(vr,v,row3size);
		}
		if ((vinher>0.0f)&&(t>0)){vr=vr+DotProd(Vdt*vinher,r)*r;}
		if (UpdatePastCollide)
		{	pos = XI + (dt-omega)*vr;
		}
		else
			pos = XI;
	}
	else //inside
	{	Point3 P1;
		P1=p+dt*Vrel;
		if (LengthSquared(P1-Vc)<(rplus*rplus))
		{	obj->lastrnd=rand();
			return FALSE;
		}
		float A,B,C,omega1,omegaend,a2,ptmp,c,d;
		A=LengthSquared(Vrel);
		B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
		C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
		omegaend=B*B-4.0f*A*C;
		if (omegaend<0.0f) omegaend=0.0f;
		else omegaend=(float)sqrt(omegaend);
		a2=2.0f*A;
		omega1=(-B+omegaend)/a2;
		omega=(-B-omegaend)/a2;
		if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
		float fdt=1.1f*dt;
		if ((omega>fdt)||(omega<-fdt))
		{	obj->lastrnd=rand();
			return FALSE;
		}
		Point3 r,n;
		XI=p+omega*vr;
		Point3 Ci=Vc+omega*Vdt;
		r=Normalize(XI-Ci);
		float q1=DotProd(Vreln,r);
		float theta=(float)acos(q1);
		float v[4];
		if (theta<FLOAT_EPSILON)
			vr=-vr;
		else 
		{	n=Normalize(Vreln^r);
			vr=-vr;
			memcpy(v,vr,row3size);v[3]=1.0f;
			RotateOnePoint(v,&Zero.x,&n.x,2*theta);
			memcpy(vr,v,row3size);
		}
		vr=vr*bounce*(1-bvar*RND01());
		if (!FloatEQ0(chaos))
		{	theta=(HalfPI-theta)*chaos*RND01();
			Point3 d=Point3(RND11(),RND11(),RND11());
			Point3 c=Normalize(vr^d);
			memcpy(v,vr,row3size);v[3]=1.0f;
			RotateOnePoint(v,&Zero.x,&c.x,theta);
			memcpy(vr,v,row3size);
		}
		if ((vinher>0.0f)&&(t>0)){vr=vr+DotProd(Vdt*vinher,r)*r;}
		if (UpdatePastCollide)
		{	pos = XI + (dt-omega)*vr;
		}
		else
			pos = XI;
	}
	pos = pos*tm;
	applyat = XI*tm;
	vel = VectorTransform(tm,vr);
	if (UpdatePastCollide)
	{ if (ct) (*ct) = dt;}
	else
	{ if (ct) (*ct) = omega;}

// get physical parameters
	float mass;
	int massunits;
	obj->pblock->GetValue(PB_MASS,t,mass,FOREVER);
	obj->pblock->GetValue(PB_MASSUNITS,t,massunits,FOREVER);
// compensate for units of measure
	switch(massunits)
	{	case 0: mass*=0.001f; break;
		case 1: break;
		case 2: mass*=0.454f; break;
	}
// increment physical property params
// put information into parameter block
	if (t==obj->ctime)
	{ totalnumber+=1;
	  totalforce+=(invel-vel)*K*mass/stepsize;
      obj->ffdata.FlectForce+=totalforce;
	  obj->ffdata.ApplyAt+=applyat;
	  obj->ffdata.Num=+totalnumber;
	}
	obj->lastrnd=rand();
	return TRUE;
}

FlectForces SDynaDeflObject::ForceData(TimeValue t)
{ pblock->GetValue(PB_TIMEON,t,ffdata.t1,FOREVER);
  pblock->GetValue(PB_TIMEOFF,t,ffdata.t2,FOREVER);
  return ffdata;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\pdyflect.cpp ===
/**********************************************************************
 *<
	FILE: pdyflect.cpp

	DESCRIPTION: A Dynamics-linked Momentum transfer planar deflector

	CREATED BY: Audrey and Eric Peterson from Rolf Berteig's Deflector

	HISTORY: 7-17-97

 **********************************************************************/
#include "sflectr.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

static Class_ID PDYNADEF_CLASS_ID(0xb46c87, 0x3eee2ac4);
static Class_ID PDYNADEFMOD_CLASS_ID(0x783f281d, 0xade1abe);

const float dymin=0.0001f;

class PDynaDeflObj : public DynamModObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		int lastrnd;
		TimeValue t;
		PDynaDeflObj();
		BOOL SupportsDynamics() {return TRUE;}

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);
		Class_ID ClassID() {return PDYNADEF_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_PDYNADEF);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		

		// From BaseObject
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
		FlectForces ForceData(TimeValue t);
		FlectForces ffdata;	
		TimeValue ctime;
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *PDynaDeflObj::ip        = NULL;
IParamMap *PDynaDeflObj::pmapParam = NULL;
HWND       PDynaDeflObj::hSot      = NULL;

class PDynaDeflClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new PDynaDeflObj;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_PDYNADEF);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return PDYNADEF_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_DYNAMICS);}
	};

static PDynaDeflClassDesc pspawndeflDesc;
ClassDesc* GetPDynaDeflObjDesc() {return &pspawndeflDesc;}

//--- DeflectMod -----------------------------------------------------

class PDynaDeflField : public CollisionObject {
	public:		
		PDynaDeflObj *obj;
		INode *node;
		Matrix3 tm,invtm,tp;
		Interval tmValid;
		Point3 totalforce,applyat;
		int totalnumber;
		TimeValue curtime;
		Point3 Vc,Vcp;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index, float *ct, BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class PDynaDeflMod : public SimpleWSMMod {
	public:				
		PDynaDeflField deflect;

		PDynaDeflMod() {deflect.curtime=NoAni;}
		PDynaDeflMod(INode *node,PDynaDeflObj *obj);		

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_EP_PDYNADEFMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return PDYNADEFMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_PDYNADEFMODBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class PDynaDeflModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new PDynaDeflMod;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_PDYNADEFMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return PDYNADEFMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static PDynaDeflModClassDesc pspawndeflModDesc;
ClassDesc* GetPDynaDeflModDesc() {return &pspawndeflModDesc;}

//--- DeflectObject Parameter map/block descriptors ------------------

#define PB_TIMEON		0
#define PB_TIMEOFF		1
#define PB_AFFECTS		2
#define PB_BOUNCE		3
#define PB_BOUNCEVAR	4
#define PB_CHAOS		5
#define PB_INHERIT		6
#define PB_ICONSIZE		7
#define PB_ICONSIZE1	8
#define PB_MASS			9
#define PB_MASSUNITS	10
#define PB_FORCEX		11
#define PB_FORCEY		12
#define PB_FORCEZ		13
#define PB_APPLYX		14
#define PB_APPLYY		15
#define PB_APPLYZ		16
#define PB_NUMBER		17

static int massunitsIDs[] = {IDC_EP_MASSGM,IDC_EP_MASSKG,IDC_EP_MASSLBM};

static ParamUIDesc descPDynaDeflParam[] = {
	// Time On
	ParamUIDesc(
		PB_TIMEON,
		EDITTYPE_TIME,
		IDC_EP_TIMEON,IDC_EP_TIMEONSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Time Off
	ParamUIDesc(
		PB_TIMEOFF,
		EDITTYPE_TIME,
		IDC_EP_TIMEOFF,IDC_EP_TIMEOFFSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Affects Percentage
	ParamUIDesc(
		PB_AFFECTS,
		EDITTYPE_FLOAT,
		IDC_EP_AFFECTS,IDC_EP_AFFECTSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCE,IDC_EP_BOUNCESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// BounceVar
	ParamUIDesc(
		PB_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEVAR,IDC_EP_BOUNCEVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_EP_CHAOS,IDC_EP_CHAOSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Inherit
	ParamUIDesc(
		PB_INHERIT,
		EDITTYPE_FLOAT,
		IDC_EP_INHERIT,IDC_EP_INHERITSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_EP_ICONSIZE,IDC_EP_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Icon Size1
	ParamUIDesc(
		PB_ICONSIZE1,
		EDITTYPE_UNIVERSE,
		IDC_EP_ICONSIZE1,IDC_EP_ICONSIZE1SPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Particle Mass
	ParamUIDesc(
		PB_MASS,
		EDITTYPE_FLOAT,
		IDC_EP_PARTICLEMASS,IDC_EP_PARTICLEMASSSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Particle Mass Units
	ParamUIDesc(PB_MASSUNITS,TYPE_RADIO,massunitsIDs,3)

	};

#define PARAMDESC_LENGTH	11

ParamBlockDescID descPDynaDeflVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },//time on
	{ TYPE_INT, NULL, TRUE, 1 },//time off
	{ TYPE_FLOAT, NULL, TRUE, 2 },//affects
	{ TYPE_FLOAT, NULL, TRUE, 3 },//bounce
	{ TYPE_FLOAT, NULL, TRUE, 4 },//bounce var
	{ TYPE_FLOAT, NULL, TRUE, 5 },//chaos
	{ TYPE_FLOAT, NULL, TRUE, 6 },//vel inherit
	{ TYPE_FLOAT, NULL, TRUE, 7 },//icon size 1
	{ TYPE_FLOAT, NULL, TRUE, 8 },//icon size 2
	{ TYPE_FLOAT, NULL, TRUE, 9 },//mass
	{ TYPE_INT, NULL, FALSE, 10 },//mass units
	{ TYPE_FLOAT, NULL, FALSE, 11 },
	{ TYPE_FLOAT, NULL, FALSE, 12 },
	{ TYPE_FLOAT, NULL, FALSE, 13 },
	{ TYPE_FLOAT, NULL, FALSE, 14 },
	{ TYPE_FLOAT, NULL, FALSE, 15 },
	{ TYPE_FLOAT, NULL, FALSE, 16 },
	{ TYPE_INT, NULL, FALSE, 17 }//total number
	};
#define PBLOCK_LENGTH	18

#define CURRENT_VERSION	0


//--- PDynaDeflector object methods -----------------------------------------


PDynaDeflObj::PDynaDeflObj()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descPDynaDeflVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_TIMEON,0,0);
	pblock->SetValue(PB_TIMEOFF,0,100*GetTicksPerFrame());
	pblock->SetValue(PB_AFFECTS,0,100.0f);
	pblock->SetValue(PB_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BOUNCEVAR,0,0.0f);
	pblock->SetValue(PB_CHAOS,0,0.0f);
	pblock->SetValue(PB_INHERIT,0,1.0f);
	pblock->SetValue(PB_MASS,0,1.0f);
	pblock->SetValue(PB_MASSUNITS,0,0);
	ffdata.FlectForce=Zero;ffdata.ApplyAt=Zero;ffdata.Num=0;
	srand(lastrnd=12345);
	t=99999;
	ctime=99999;
}

Modifier *PDynaDeflObj::CreateWSMMod(INode *node)
{	return new PDynaDeflMod(node,this);
}

RefTargetHandle PDynaDeflObj::Clone(RemapDir& remap) 
{	PDynaDeflObj* newob = new PDynaDeflObj();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
}

void PDynaDeflObj::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
{	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC_BOTH),
			DefaultSOTProc,
			GetString(IDS_EP_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descPDynaDeflParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_AP_PDYNADEFL),
			GetString(IDS_EP_PARAMETERS),
			0);
		}
	}

void PDynaDeflObj::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}

void PDynaDeflObj::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_TIMEON,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEON,0,TempTime);
	pblock->GetValue(PB_TIMEOFF,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEOFF,0,TempTime);
}  

void PDynaDeflObj::BuildMesh(TimeValue t)
	{
	float w, h;
	float w2,h2,h3,h4;
	ivalid = FOREVER;
	pblock->GetValue(PB_ICONSIZE,t,w,ivalid);
	pblock->GetValue(PB_ICONSIZE1,t,h,ivalid);
	w*=0.5f;
	w2=w*0.5f;
	h*=0.5f;
	h2=h*0.5f;
	h3=h2*0.15f;
	h4=h2*0.25f;

	mesh.setNumVerts(19);
	mesh.setNumFaces(11);
	mesh.setVert(0, Point3(-w,-h, 0.0f));
	mesh.setVert(1, Point3( w,-h, 0.0f));
	mesh.setVert(2, Point3( w, h, 0.0f));
	mesh.setVert(3, Point3(-w, h, 0.0f));

	mesh.setVert( 4, Point3(0.0f,0.0f,0.0f));
	mesh.setVert( 5, Point3(0.0f,  h2,  h2));
	mesh.setVert( 6, Point3(0.0f, -h2,  h2));
	mesh.setVert( 7, Point3(0.0f,  h2+h3,  h2));
	mesh.setVert( 8, Point3(0.0f,  h2,  h2+h3));
	mesh.setVert( 9, Point3(0.0f, -h2,  h2-h3));
	mesh.setVert(10, Point3(0.0f, -h2+h3,  h2));

	mesh.setVert(11, Point3(0.0f, h4, 0.0f));
	mesh.setVert(12, Point3(0.0f, h4, -h2));
	mesh.setVert(13, Point3(0.0f, h4+h3, -h2));
	mesh.setVert(14, Point3(0.0f, 0.0f, -h2-h3-h3));
	mesh.setVert(15, Point3(0.0f,-h4-h3, -h2));
	mesh.setVert(16, Point3(0.0f,-h4, -h2));
	mesh.setVert(17, Point3(0.0f,-h4, 0.0f));
	mesh.setVert(18, Point3(0.0f,0.0f,-h4));
	
	mesh.faces[0].setEdgeVisFlags(1,1,0);
	mesh.faces[0].setSmGroup(1);
	mesh.faces[0].setVerts(0,1,2);
	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(1);
	mesh.faces[1].setVerts(2,3,0);	

	mesh.faces[2].setEdgeVisFlags(1,0,1);
	mesh.faces[2].setSmGroup(1);
	mesh.faces[2].setVerts(4,6,5);	
	mesh.faces[3].setEdgeVisFlags(1,0,1);
	mesh.faces[3].setSmGroup(1);
	mesh.faces[3].setVerts(6,9,10);	
	mesh.faces[4].setEdgeVisFlags(1,0,1);
	mesh.faces[4].setSmGroup(1);
	mesh.faces[4].setVerts(5,8,7);
	mesh.faces[5].setEdgeVisFlags(1,0,1);
	mesh.faces[5].setSmGroup(1);
	mesh.faces[5].setVerts(11,12,18);	
	mesh.faces[6].setEdgeVisFlags(0,0,0);
	mesh.faces[6].setSmGroup(1);
	mesh.faces[6].setVerts(12,16,18);	
	mesh.faces[7].setEdgeVisFlags(1,1,0);
	mesh.faces[7].setSmGroup(1);
	mesh.faces[7].setVerts(16,17,18);	
	mesh.faces[8].setEdgeVisFlags(1,1,0);
	mesh.faces[8].setSmGroup(1);
	mesh.faces[8].setVerts(12,13,14);	
	mesh.faces[9].setEdgeVisFlags(0,0,0);
	mesh.faces[9].setSmGroup(1);
	mesh.faces[9].setVerts(12,14,16);	
	mesh.faces[10].setEdgeVisFlags(1,1,0);
	mesh.faces[10].setSmGroup(1);
	mesh.faces[10].setVerts(14,15,16);	

	mesh.InvalidateGeomCache();	
	}


class PDynaDeflObjCreateCallback : public CreateMouseCallBack {
	public:
		PDynaDeflObj *ob;	
		Point3 p0, p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int PDynaDeflObjCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				ob->pblock->SetValue(PB_ICONSIZE,0,0.01f);
				ob->pblock->SetValue(PB_ICONSIZE1,0,0.01f);
				ob->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				ob->pblock->SetValue(PB_ICONSIZE,0,(float)fabs(p1.x-p0.x));
				ob->pblock->SetValue(PB_ICONSIZE1,0,(float)fabs(p1.y-p0.y));
				ob->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
	}
static PDynaDeflObjCreateCallback pspawndeflCreateCB;

CreateMouseCallBack* PDynaDeflObj::GetCreateMouseCallBack()
	{
	pspawndeflCreateCB.ob = this;
	return &pspawndeflCreateCB;
	}

void PDynaDeflObj::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *PDynaDeflObj::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_TIMEON:		return stdTimeDim;
		case PB_TIMEOFF:	return stdTimeDim;
		case PB_AFFECTS:	return stdPercentDim;
		case PB_BOUNCEVAR:	return stdPercentDim;
		case PB_CHAOS:		return stdPercentDim;
		default:			return defaultDim;
		}
	}

TSTR PDynaDeflObj::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_TIMEON:			return GetString(IDS_EP_TIMEON);
		case PB_TIMEOFF:		return GetString(IDS_EP_TIMEOFF);
		case PB_AFFECTS:		return GetString(IDS_EP_AFFECTS);
		case PB_BOUNCE:			return GetString(IDS_EP_BOUNCE);
		case PB_BOUNCEVAR:		return GetString(IDS_EP_BOUNCEVAR);
		case PB_CHAOS:			return GetString(IDS_EP_CHAOS);
		case PB_INHERIT:		return GetString(IDS_EP_INHERIT);
		case PB_ICONSIZE:		return GetString(IDS_EP_WIDTH);
		case PB_ICONSIZE1:		return GetString(IDS_EP_HEIGHT);
		case PB_MASS:			return GetString(IDS_EP_MASS);
		case PB_MASSUNITS:		return GetString(IDS_EP_MASSUNITS);
		default: 				return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

PDynaDeflMod::PDynaDeflMod(INode *node,PDynaDeflObj *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef = NULL;
	}

Interval PDynaDeflMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		PDynaDeflObj *obj = (PDynaDeflObj*)GetWSMObject(t);
		TimeValue TempT;
		obj->pblock->GetValue(PB_TIMEOFF,t,TempT,valid);
		obj->pblock->GetValue(PB_AFFECTS,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,f,valid);
		obj->pblock->GetValue(PB_CHAOS,t,f,valid);
		obj->pblock->GetValue(PB_INHERIT,t,f,valid);
		obj->pblock->GetValue(PB_ICONSIZE,t,f,valid);
		obj->pblock->GetValue(PB_ICONSIZE1,t,f,valid);
		obj->pblock->GetValue(PB_MASS,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class PDynaDeflDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static PDynaDeflDeformer pspawndeformer;

Deformer& PDynaDeflMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return pspawndeformer;
	}

RefTargetHandle PDynaDeflMod::Clone(RemapDir& remap) 
	{
	PDynaDeflMod *newob = new PDynaDeflMod(nodeRef,(PDynaDeflObj*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}


void PDynaDeflMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (PDynaDeflObj*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.tmValid.SetEmpty();		
		deflect.totalforce=Zero;
		deflect.applyat=Zero;
		deflect.totalnumber=0;
		if (t<=deflect.obj->t) deflect.obj->lastrnd=12345;
		deflect.obj->t=t;
		TimeValue tmpt=GetCOREInterface()->GetTime();
		if (deflect.obj->ctime!=tmpt)
		{ deflect.obj->ctime=tmpt;
		  deflect.obj->ffdata.FlectForce=deflect.totalforce;
		  deflect.obj->ffdata.ApplyAt=deflect.applyat;
		  deflect.obj->ffdata.Num=deflect.totalnumber;
		}
//		deflect.curtime=NoAni;
		obj->ApplyCollisionObject(&deflect);
		}
	}

Object *PDynaDeflField::GetSWObject()
{ return obj;
}

BOOL PDynaDeflField::CheckCollision(TimeValue t,Point3 &pos,Point3 &vel,float dt,int index, float *ct, BOOL UpdatePastCollide)
{	if (!tmValid.InInterval(t))
	{	tmValid=FOREVER;
		tm=node->GetObjectTM(t,&tmValid);
		invtm=Inverse(tm);
		Interval tmpValid=FOREVER;
		tp=node->GetObjectTM(t-(int)dt,&tmpValid);
		Vc=Zero;
		Vcp=Zero*tp*invtm;
	}
    if (curtime!=t)
	{	totalforce=Zero;
		applyat=Zero;
		totalnumber=0;
		curtime=t;	
//		obj->ffdata.FlectForce=totalforce;
//		obj->ffdata.ApplyAt=applyat;
//		obj->ffdata.Num=totalnumber;
	}
	float K=(float)GetMasterScale(UNITS_CENTIMETERS);
	float stepsize=dt,intimestep=dt;
	Point3 invel=vel;
	
	TimeValue startt,endt;
	obj->pblock->GetValue(PB_TIMEON,t,startt,FOREVER);
	obj->pblock->GetValue(PB_TIMEOFF,t,endt,FOREVER);
	if ((t<startt)||(t>endt))
	{	obj->lastrnd=rand();
		return FALSE;
	}

	float affectsthisportion;
	obj->pblock->GetValue(PB_AFFECTS,t,affectsthisportion,FOREVER);
    srand(obj->lastrnd);
	if (RND01()>affectsthisportion)
	{	obj->lastrnd=rand();
		return FALSE;
	}

	float width,height;
	obj->pblock->GetValue(PB_ICONSIZE,t,width,FOREVER);
	obj->pblock->GetValue(PB_ICONSIZE1,t,height,FOREVER);
	width *=0.5f;
	height*=0.5f;

	float bounce,bouncevar,chaos,inherit;
	obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
	obj->pblock->GetValue(PB_BOUNCEVAR,t,bouncevar,FOREVER);
	obj->pblock->GetValue(PB_CHAOS,t,chaos,FOREVER);
	obj->pblock->GetValue(PB_INHERIT,t,inherit,FOREVER);
	float at;
	Point3 p,v,ph;
	p=pos*invtm; 
	v=VectorTransform(invtm,vel);
	Point3 vdt=(Vc-Vcp)/dt;
	Point3 vrel=v-vdt;

// Compute the point of intersection
	if (fabs(p.z)<0.001f)
	{	//v.z=0.0f;
		at=0.0f;		
	}
	else
	{	if (vrel.z==0.0)
		{	obj->lastrnd=rand();
			return FALSE;
		}
		at= -p.z/vrel.z;
		if ((at<0.0f)||(at>dt))
		{	obj->lastrnd=rand();
			return FALSE;
		}
	}
// use relative speeds to check for hit
	ph=p+at*vrel;
// See if the point is within our range
	if ((ph.x<-width)||(ph.x>width)||(ph.y<-height)||(ph.y>height))
	{	obj->lastrnd=rand();
		return FALSE;
	}

// if we're here, we have a collision
// Remove the part of dt we used to get to the collision point
	float holddt = dt;
	dt -= at;
// go back to particle speed to find location of hit
	ph = p + at*v;
// save as the hit location in wcs before allowing for remaining travel
	applyat=ph*tm;
// Reflect the velocity about the XY plane and attenuate with the bounce factor
	BOOL ispos=(v.z>0.0f);
	v.z=-v.z;
// reduce v by bounce parameters
	v*=bounce*(1.0f-bouncevar*RND01());
// rotate velocity vector to give us chaos
	if (!FloatEQ0(chaos))
	{	float theta=(float)acos(DotProd(Normalize(v),Point3(0.0f,0.0f,1.0f)));
		theta=(HalfPI-theta)*chaos*RND01();
		Point3 d=Point3(RND11(),RND11(),RND11());
		Point3 c=Normalize(v^d);
		RotateOnePoint(v,&Zero.x,&c.x,theta);
		if (ispos==(v.z>0.0f)) v.z=-v.z;
	}
// Tranform back into world space.
	pos = ph*tm;
	vel = VectorTransform(tm,v);
// find absolute motion of deflector and add inheritance
	Point3 tabs2,tabs1,vabsdefl;
	tabs2 = tm.GetRow(3);
	tabs1 = tp.GetRow(3);
	vabsdefl = (tabs2-tabs1)/intimestep;
	vel += inherit*vabsdefl;
// use up the rest of the time available to find the final position
//	pos+=vel*dt;

	if (UpdatePastCollide)
	{	pos += vel*dt;
		if (ct) (*ct) = holddt;
	}
	else
	{	if (ct) (*ct) = at;
	}

// get physical parameters
	float mass;
	int massunits;
	obj->pblock->GetValue(PB_MASS,t,mass,FOREVER);
	obj->pblock->GetValue(PB_MASSUNITS,t,massunits,FOREVER);
// compensate for units of measure
	switch(massunits)
	{	case 0: mass*=0.001f; break;
		case 1: break;
		case 2: mass*=0.454f; break;
	}
// increment physical property params
// put information into parameter block
	if (t==obj->ctime)
	{ totalnumber+=1;
	  totalforce+=(invel-vel)*K*mass/stepsize;
      obj->ffdata.FlectForce+=totalforce;
	  obj->ffdata.ApplyAt+=applyat;
	  obj->ffdata.Num=+totalnumber;
	}
	obj->lastrnd=rand();
	return TRUE;
}
FlectForces PDynaDeflObj::ForceData(TimeValue t)
{ pblock->GetValue(PB_TIMEON,t,ffdata.t1,FOREVER);
  pblock->GetValue(PB_TIMEOFF,t,ffdata.t2,FOREVER);
  return ffdata;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\sflectrs.cpp ===
/**********************************************************************
 *<
	FILE: sflectrs.cpp

	DESCRIPTION: SpawnFlectors common source

	CREATED BY: Eric Peterson

	HISTORY: 7/97

 **********************************************************************/
#include "sflectr.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return _T("SpawnFlectors objects (Kinetix)"); }

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int 
LibNumberClasses() { return 12; }

// This function return the ith class descriptor. We have one.
/*__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case  0:return GetPSpawnDeflObjDesc();
	case  1:return GetPSpawnDeflModDesc();
	case  2:return GetSSpawnDeflObjDesc();
	case  3:return GetSSpawnDeflModDesc();
	case  4:return GetUSpawnDeflObjDesc();
	case  5:return GetUSpawnDeflModDesc();
	case  6:return GetPDynaDeflObjDesc();
	case  7:return GetPDynaDeflModDesc();
	case  8:return GetSDynaDeflObjDesc();
	case  9:return GetSDynaDeflModDesc();
	case 10:return GetUDynaDeflObjDesc();
	case 11:return GetUDynaDeflModDesc();

    default:return 0;}
 }*/
__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case  0:return GetPSpawnDeflObjDesc();
	case  1:return GetPSpawnDeflModDesc();
	case  2:return GetPDynaDeflObjDesc();
	case  3:return GetPDynaDeflModDesc();
	case  4:return GetSSpawnDeflObjDesc();
	case  5:return GetSSpawnDeflModDesc();
	case  6:return GetSDynaDeflObjDesc();
	case  7:return GetSDynaDeflModDesc();
	case  8:return GetUSpawnDeflObjDesc();
	case  9:return GetUSpawnDeflModDesc();
	case 10:return GetUDynaDeflObjDesc();
	case 11:return GetUDynaDeflModDesc();

    default:return 0;}
 }
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

  	if (!controlsInit) {
		controlsInit = TRUE;		

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	}
	
	return(TRUE);
	}


// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
/* rand returns a number between 0 and 32767 */
/* number between 0 and 1 */
const float IntMax=32767.0f;
const float IntMax1=32768.0f;
const float HalfIntMax=16383.5f;
typedef float Matrix3By3[3][3];
typedef float Matrix4By3[4][3];
Point3 Zero=Point3(0.0f,0.0f,0.0f); 

int FloatEQ0(float number)
{return((FLOAT_EPSILON>=number)&&(number>=-FLOAT_EPSILON));
}
int SmallerEQ0(float number)
{return((SMALL_EPSILON>=number)&&(SMALL_EPSILON>=-FLOAT_EPSILON));
}
int FGT0(Point3 p1)
{
	return((fabs(p1[0])>SMALL_EPSILON)||(fabs(p1[1])>SMALL_EPSILON)||(fabs(p1[2])>SMALL_EPSILON));
}

#define EPSILON 0.00001f

float sign(float sval)
{	return(sval>=0.0f?1.0f:-1.0f);
}

void VNormal::AddNormal(Point3 &n,DWORD s)
	{
	if (!(s&smooth) && init) {
		if (next) next->AddNormal(n,s);
		else {
			next = new VNormal(n,s);
			}
	} else {
		norm   += n;
		smooth |= s;
		init    = TRUE;
		}
	}

Point3 &VNormal::GetNormal(DWORD s)
	{
	if (smooth&s || !next) return norm;
	else return next->GetNormal(s);	
	}

void VNormal::Normalize()
	{
	VNormal *ptr = next, *prev = this;
	while (ptr) {
		if (ptr->smooth&smooth) {
			norm += ptr->norm;			
			prev->next = ptr->next;
			delete ptr;
			ptr = prev->next;
		} else {
			prev = ptr;
			ptr  = ptr->next;
			}
		}
	norm = ::Normalize(norm);
	if (next) next->Normalize();
	}

void GetVFLst(Mesh* dmesh,VNormal* vnorms,Point3* fnorms)	 
{ int nv=dmesh->getNumVerts();	
  int nf=dmesh->getNumFaces();	
  Face *face = dmesh->faces;
  for (int i=0; i<nv; i++) 
    vnorms[i] = VNormal();
  Point3 v0, v1, v2;
  for (i=0; i<nf; i++,face++) 
  {	// Calculate the surface normal
	v0 = dmesh->verts[face->v[0]];
	v1 = dmesh->verts[face->v[1]];
	v2 = dmesh->verts[face->v[2]];
	fnorms[i] = (v1-v0)^(v2-v1);
	for (int j=0; j<3; j++) 
	   vnorms[face->v[j]].AddNormal(fnorms[i],face->smGroup);
    fnorms[i] = Normalize(fnorms[i]);
  }
  for (i=0; i<nv; i++) 
	vnorms[i].Normalize();
}

int RayIntersectP(Ray& ray, float& at, Point3& norm,Mesh *amesh,VNormal* vnorms,Point3 *fnorms)
	{
	DWORD fi;
	Point3 bary;
	Face *face = amesh->faces;	
	Point3 v0, v1, v2;
	Point3 n, sum, p, bry;
	float d, rn, a;
	Matrix3 vTM(1);
	BOOL first = FALSE;
	fi = 0xFFFFFFFF;

	for (int i=0; i<amesh->getNumFaces(); i++,face++) {
		n = fnorms[i];
		
		// See if the ray intersects the plane (backfaced)
		rn = DotProd(ray.dir,n);
		if (rn > -EPSILON) continue;
		
		// Use a point on the plane to find d
		d = DotProd(amesh->verts[face->v[0]],n);

		// Find the point on the ray that intersects the plane
		a = (d - DotProd(ray.p,n)) / rn;

		// Must be positive...
		if (a < 0.0f) continue;

		// Must be closer than the closest at so far
		if (first) {
			if (a > at) continue;
			}

		// The point on the ray and in the plane.
		p = ray.p + a*ray.dir;

		// Compute barycentric coords.
		bry = amesh->BaryCoords(i,p);

		// barycentric coordinates must sum to 1 and each component must
		// be in the range 0-1
		if (bry.x<0.0f || bry.x>1.0f || bry.y<0.0f || bry.y>1.0f || bry.z<0.0f || bry.z>1.0f) continue;
		if (fabs(bry.x + bry.y + bry.z - 1.0f) > EPSILON) continue;

		// Hit!
		first = TRUE;		
		at    = a;
		fi    = (DWORD)i;		
//		bary.x  = bry.z;
//		bary.y  = bry.x;
//		bary.z  = bry.y;
		bary  = bry;	// DS 3/8/97
		
		// Use interpolated normal instead.
		if (!face->smGroup) {
			norm  = n;
		} else {
			norm = 
				vnorms[face->v[0]].GetNormal(face->smGroup) * bary.x +
				vnorms[face->v[1]].GetNormal(face->smGroup) * bary.y +
				vnorms[face->v[2]].GetNormal(face->smGroup) * bary.z;
			norm = Normalize(norm);
			}
		}

	return first;
	}

void Mult1X4(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0]+A[3]*B[3][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1]+A[3]*B[3][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2]+A[3]*B[3][2];
   C[3]=A[0]*B[0][3]+A[1]*B[1][3]+A[2]*B[2][3]+A[3]*B[3][3];
}

void Mult4X1(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[0][1]+A[2]*B[0][2]+A[3]*B[0][3];
   C[1]=A[0]*B[1][0]+A[1]*B[1][1]+A[2]*B[1][2]+A[3]*B[1][3];
   C[2]=A[0]*B[2][0]+A[1]*B[2][1]+A[2]*B[2][2]+A[3]*B[2][3];
   C[3]=A[0]*B[3][0]+A[1]*B[3][1]+A[2]*B[3][2]+A[3]*B[3][3];
}

void Mult1X3(float *A,Matrix3By3 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2];
}

void Mult3X4(Matrix3By4 A,Matrix4By4 B,Matrix3By4 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
   C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
   C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
   C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
   C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
   C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
   C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
   C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
   C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
   C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
   C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
   C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
}

void Mult4X3(Matrix4By3 A,Matrix4By4 B,Matrix4By3 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[1][0]*B[0][1]+A[2][0]*B[0][2]+A[3][0]*B[0][3];
   C[1][0]=A[0][0]*B[1][0]+A[1][0]*B[1][1]+A[2][0]*B[1][2]+A[3][0]*B[1][3];
   C[2][0]=A[0][0]*B[2][0]+A[1][0]*B[2][1]+A[2][0]*B[2][2]+A[3][0]*B[2][3];
   C[3][0]=A[0][0]*B[3][0]+A[1][0]*B[3][1]+A[2][0]*B[3][2]+A[3][0]*B[3][3];
   C[0][1]=A[0][1]*B[0][0]+A[1][1]*B[0][1]+A[2][1]*B[0][2]+A[3][1]*B[0][3];
   C[1][1]=A[0][1]*B[1][0]+A[1][1]*B[1][1]+A[2][1]*B[1][2]+A[3][1]*B[1][3];
   C[2][1]=A[0][1]*B[2][0]+A[1][1]*B[2][1]+A[2][1]*B[2][2]+A[3][1]*B[2][3];
   C[3][1]=A[0][1]*B[3][0]+A[1][1]*B[3][1]+A[2][1]*B[3][2]+A[3][1]*B[3][3];
   C[0][2]=A[0][2]*B[0][0]+A[1][2]*B[0][1]+A[2][2]*B[0][2]+A[3][2]*B[0][3];
   C[1][2]=A[0][2]*B[1][0]+A[1][2]*B[1][1]+A[2][2]*B[1][2]+A[3][2]*B[1][3];
   C[2][2]=A[0][2]*B[2][0]+A[1][2]*B[2][1]+A[2][2]*B[2][2]+A[3][2]*B[2][3];
   C[3][2]=A[0][2]*B[3][0]+A[1][2]*B[3][1]+A[2][2]*B[3][2]+A[3][2]*B[3][3];
}

void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
   C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
   C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
   C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
   C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
   C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
   C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
   C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
   C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
   C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
   C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
   C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
   C[3][0]=A[3][0]*B[0][0]+A[3][1]*B[1][0]+A[3][2]*B[2][0]+A[3][3]*B[3][0];
   C[3][1]=A[3][0]*B[0][1]+A[3][1]*B[1][1]+A[3][2]*B[2][1]+A[3][3]*B[3][1];
   C[3][2]=A[3][0]*B[0][2]+A[3][1]*B[1][2]+A[3][2]*B[2][2]+A[3][3]*B[3][2];
   C[3][3]=A[3][0]*B[0][3]+A[3][1]*B[1][3]+A[3][2]*B[2][3]+A[3][3]*B[3][3];
}

float det2x2(float a,float b,float c,float d)
{ return(a*d-b*c);
}

float det3x3(float a1,float a2,float a3,float b1,float b2,float b3,float c1,float c2,float c3)
{ return(a1*det2x2(b2,b3,c2,c3)-b1*det2x2(a2,a3,c2,c3)+c1*det2x2(a2,a3,b2,b3));
}

void Adjoint(Matrix4By4 in, Matrix4By4 out,float det)
{float a1,a2,a3,a4,b1,b2,b3,b4;
 float c1,c2,c3,c4,d1,d2,d3,d4;

 a1=in[0][0];b1=in[0][1];c1=in[0][2];d1=in[0][3];
 a2=in[1][0];b2=in[1][1];c2=in[1][2];d2=in[1][3];
 a3=in[2][0];b3=in[2][1];c3=in[2][2];d3=in[2][3];
 a4=in[3][0];b4=in[3][1];c4=in[3][2];d4=in[3][3];
 out[0][0]= det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)/det;
 out[1][0]=-det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)/det;
 out[2][0]= det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)/det;
 out[3][0]=-det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4)/det;
 out[0][1]=-det3x3(b1,b3,b4,c1,c3,c4,d1,d3,d4)/det;
 out[1][1]= det3x3(a1,a3,a4,c1,c3,c4,d1,d3,d4)/det;
 out[2][1]=-det3x3(a1,a3,a4,b1,b3,b4,d1,d3,d4)/det;
 out[3][1]= det3x3(a1,a3,a4,b1,b3,b4,c1,c3,c4)/det;
 out[0][2]= det3x3(b1,b2,b4,c1,c2,c4,d1,d2,d4)/det;
 out[1][2]=-det3x3(a1,a2,a4,c1,c2,c4,d1,d2,d4)/det;
 out[2][2]= det3x3(a1,a2,a4,b1,b2,b4,d1,d2,d4)/det;
 out[3][2]=-det3x3(a1,a2,a4,b1,b2,b4,c1,c2,c4)/det;
 out[0][3]=-det3x3(b1,b2,b3,c1,c2,c3,d1,d2,d3)/det;
 out[1][3]= det3x3(a1,a2,a3,c1,c2,c3,d1,d2,d3)/det;
 out[2][3]=-det3x3(a1,a2,a3,b1,b2,b3,d1,d2,d3)/det;
 out[3][3]= det3x3(a1,a2,a3,b1,b2,b3,c1,c2,c3)/det;
}

float det4x4(Matrix4By4 m)
{float a1,a2,a3,a4,b1,b2,b3,b4;
 float c1,c2,c3,c4,d1,d2,d3,d4,ans;

 a1=m[0][0];b1=m[0][1];c1=m[0][2];d1=m[0][3];
 a2=m[1][0];b2=m[1][1];c2=m[1][2];d2=m[1][3];
 a3=m[2][0];b3=m[2][1];c3=m[2][2];d3=m[2][3];
 a4=m[3][0];b4=m[3][1];c4=m[3][2];d4=m[3][3];
 ans= a1*det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)
     -b1*det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)
     +c1*det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)
     -d1*det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4);
 return(ans);
}

int MatrixInvert(Matrix4By4 in,Matrix4By4 out)
{ float det;

  det=det4x4(in);
  if (fabs(det)<PRECISION_LIMIT)  /* NO INVERSE */
    return(0);
  Adjoint(in,out,det);
  return(1);
}

void SetUpRotation(float *Q, float *W,float Theta,Matrix4By4 Rq)
{ float ww1,ww2,ww3,w12,w13,w23,CosTheta,SinTheta,MinCosTheta;
  Point3 temp;
  Matrix3By3 R;

 ww1=W[0]*W[0];ww2=W[1]*W[1];ww3=W[2]*W[2];
 w12=W[0]*W[1];w13=W[0]*W[2];w23=W[1]*W[2];
 CosTheta=(float)cos(Theta);MinCosTheta=1.0f-CosTheta;SinTheta=(float)sin(Theta);
 R[0][0]=ww1+(1.0f-ww1)*CosTheta;
 R[0][1]=w12*MinCosTheta+W[2]*SinTheta;
 R[0][2]=w13*MinCosTheta-W[1]*SinTheta;
 R[1][0]=w12*MinCosTheta-W[2]*SinTheta;
 R[1][1]=ww2+(1.0f-ww2)*CosTheta;
 R[1][2]=w23*MinCosTheta+W[0]*SinTheta;
 R[2][0]=w13*MinCosTheta+W[1]*SinTheta;
 R[2][1]=w23*MinCosTheta-W[0]*SinTheta;
 R[2][2]=ww3+(1.0f-ww3)*CosTheta;
 Mult1X3(Q,R,&temp.x);
 memcpy(Rq[0],R[0],row3size);memcpy(Rq[1],R[1],row3size);memcpy(Rq[2],R[2],row3size);
 Rq[3][0]=Q[0]-temp.x;Rq[3][1]=Q[1]-temp.y;Rq[3][2]=Q[2]-temp.z;
 Rq[0][3]=Rq[1][3]=Rq[2][3]=0.0f;Rq[3][3]=1.0f;
}

void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta)
{ Matrix3By4 Pout;
  Matrix4By4 Rq;

 SetUpRotation(Q,W,Theta,Rq);
 Mult3X4(Pin,Rq,Pout);
 memcpy(Pin, Pout, sizeof(Matrix3By4));
}

void RotateOnePoint(float *Pin,float *Q, float *W,float Theta)
{ Matrix4By4 Rq;
  float Pout[4],Pby4[4];

 SetUpRotation(Q,W,Theta,Rq);
 memcpy(Pby4,Pin,row3size);Pby4[3]=1.0f;
 Mult1X4(Pby4,Rq,Pout);
 memcpy(Pin,Pout,row3size);
}

float RND01()
{ float num;

  num=(float)rand();
  return(num/IntMax);
}

/* number between -1 and 1 */
float RND11()
{ float num;

   num=(float)rand()-HalfIntMax;
   return(num/HalfIntMax);
}

int RNDSign()
{
  return((RND11()<0?-1:1));
}

float RND55()
{ float num;

  num=RND11();
  return(num/2);
}

int RND0x(int maxnum)
{ float num;
  int newnum;

   num=(float)rand();
   if (maxnum==0) return(0);
   newnum=(int)floor((++maxnum)*num/IntMax1);
   return(newnum>maxnum?maxnum:newnum);
}

BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}

void TurnButton(HWND hWnd,int SpinNum,BOOL ison)
{	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(hWnd,SpinNum));
	if (iBut) 
	{ if (ison) iBut->Enable(); else iBut->Disable();
	}
	ReleaseICustButton(iBut);
};

void SpinnerOn(HWND hWnd,int SpinNum,int Winnum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Enable();
	EnableWindow(GetDlgItem(hWnd,Winnum),TRUE);
	ReleaseISpinner(spin2);

};

void SpinnerOff(HWND hWnd,int SpinNum,int Winnum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Disable();
	EnableWindow(GetDlgItem(hWnd,Winnum),FALSE);
	ReleaseISpinner(spin2);
};

Point3 CalcSpread(float divangle,Point3 oldnorm)
{ float Q[3];
  Point3 r;

  Q[0]=Q[1]=Q[2]=0.0f;
  r=Point3(RND11(),RND11(),RND11());
  r=Normalize(r^oldnorm);
  RotateOnePoint(&oldnorm.x,Q,&r.x,RND01()*divangle);
  return(oldnorm);
}

void VectorVar(Point3 *vel,float R,float MaxAngle)
{ Point3 X=Point3(RND11(),RND11(),RND11());
  Point3 c=Normalize(X^*vel);
  float Theta=MaxAngle*R*RND01();
  RotateOnePoint(&(*vel).x,&Zero.x,&c.x,Theta);
}

float Smallest(Point3 pmin) {return (pmin.x<pmin.y?(pmin.z<pmin.x?pmin.z:pmin.x):(pmin.z<pmin.y?pmin.z:pmin.y));}
float Largest(Point3 pmax) {return (pmax.x>pmax.y?(pmax.z>pmax.x?pmax.z:pmax.x):(pmax.z>pmax.y?pmax.z:pmax.y));}

TriObject *TriIsUseable(Object *pobj,TimeValue t)
{ 
  	if (pobj->IsSubClassOf(triObjectClassID)) 
      return (TriObject*)pobj;
    else 
	{ if (pobj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)pobj->ConvertToType(t,triObjectClassID);			
	}
  return NULL;
}

void MakeNodeList(INode *node,INodeTab *ntab,int subtree,TimeValue t)
{ int nc;
  if (subtree)
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	  MakeNodeList(node->GetChildNode(j),ntab,subtree,t);
  TriObject *triOb=NULL;
  Object *pobj=NULL;
  if ((!node->IsGroupHead())&&((triOb=TriIsUseable(pobj = node->EvalWorldState(t).obj,t))!=NULL))
   (*ntab).Append(1,&node,0);
  if ((triOb) &&(triOb!=pobj)) triOb->DeleteThis();
}

void MakeGroupNodeList(INode *node,INodeTab *ntab,int subtree,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) MakeGroupNodeList(nxtnode,ntab,subtree,t);
	  else if ((subtree)||(nxtnode->IsGroupMember())) MakeNodeList(nxtnode,ntab,subtree,t);
	}
}

void FormatName(TCHAR *name)
{ int len= _tcslen(name);
  if (len>MAXNAME) name[MAXNAME]='\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\sflectr.h ===
#ifndef __SFLECTRS__H
#define __SFLECTRS__H

#include "Max.h"
#include "sflectrs.h"
#include "Simpobj.h"
#include "dynamic.h"

TCHAR *GetString(int id);

extern ClassDesc* GetPSpawnDeflObjDesc();
extern ClassDesc* GetPSpawnDeflModDesc();
extern ClassDesc* GetSSpawnDeflObjDesc();
extern ClassDesc* GetSSpawnDeflModDesc();
extern ClassDesc* GetUSpawnDeflObjDesc();
extern ClassDesc* GetUSpawnDeflModDesc();
extern ClassDesc* GetPDynaDeflObjDesc();
extern ClassDesc* GetPDynaDeflModDesc();
extern ClassDesc* GetSDynaDeflObjDesc();
extern ClassDesc* GetSDynaDeflModDesc();
extern ClassDesc* GetUDynaDeflObjDesc();
extern ClassDesc* GetUDynaDeflModDesc();

extern HINSTANCE hInstance;
extern int RNDSign();
extern float RND01();
extern float RND11();
extern int RND0x(int maxnum);

const float FLOAT_EPSILON=0.005f;
const float HalfPI=1.570796327f;
const float PIOver5=0.62831853f;
const float FTOIEPS=0.000001f;
const float PRECISION_LIMIT=1.0e-15f;
const float SQR2=1.1414f;
const float SMALL_EPSILON=0.005f;
const int row3size=3*sizeof(float);
const Point3 v111=Point3(0.450f,0.218f,0.732f);
extern Point3 Zero;
const Point3 deftex=Point3(0.5f,0.5f,0.0f);
const int NoAni=-9999;

typedef float Matrix4By4[4][4];
typedef float Matrix3By4[3][4];

static Matrix3 ident(1);

class VNormal {
	public:
		Point3 norm;
		DWORD smooth;
		VNormal *next;
		BOOL init;

		VNormal() {smooth=0;next=NULL;init=FALSE;norm=Point3(0,0,0);}
		VNormal(Point3 &n,DWORD s) {next=NULL;init=TRUE;norm=n;smooth=s;}
		~VNormal() {delete next;}
		void AddNormal(Point3 &n,DWORD s);
		Point3 &GetNormal(DWORD s);
		void Normalize();
	};
extern void GetVFLst(Mesh* dmesh,VNormal* vnorms,Point3* fnorms);
extern int RayIntersectP(Ray& ray, float& at, Point3& norm,Mesh *amesh,VNormal* vnorms,Point3 *fnorms);
extern void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C);
extern void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta);
extern void RotateOnePoint(float *Pin,float *Q, float *W,float Theta);
extern int FloatEQ0(float number);
extern int SmallerEQ0(float number);
extern int FGT0(Point3 p1);
extern void Mult4X1(float *A,Matrix4By4 B,float *C);
extern int MatrixInvert(Matrix4By4 in,Matrix4By4 out);
extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
extern void TurnButton(HWND hWnd,int SpinNum,BOOL ison);
extern void SpinnerOn(HWND hWnd,int SpinNum,int Winnum);
extern void SpinnerOff(HWND hWnd,int SpinNum,int Winnum);
extern Point3 CalcSpread(float divangle,Point3 oldnorm);
#define MAXNAME 24
extern void FormatName(TCHAR *name);
extern void ZeroMesh(Mesh *pm);
extern TriObject *TriIsUseable(Object *pobj,TimeValue t);
extern void VectorVar(Point3 *vel,float R,float MaxAngle);
extern void MakeNodeList(INode *node,INodeTab *ntab,int subtree,TimeValue t);
extern void MakeGroupNodeList(INode *node,INodeTab *ntab,int subtree,TimeValue t);
extern void FormatName(TCHAR *name);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__95A68642_FF0A_11D0_85C7_004033B05F60__INCLUDED_)
#define AFX_STDAFX_H__95A68642_FF0A_11D0_85C7_004033B05F60__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__95A68642_FF0A_11D0_85C7_004033B05F60__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\sflectrs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sflectrs.rc
//
#define IDS_EP_PLANARSPAWNDEF           1
#define IDS_EP_PLANARSPAWNDEFMOD        2
#define IDS_EP_PLANARSPAWNDEFMODBINDING 3
#define IDS_EP_PARAMETERS               4
#define IDS_EP_TOP                      5
#define IDS_EP_TIMEON                   6
#define IDS_EP_TIMEOFF                  7
#define IDS_EP_AFFECTS                  8
#define IDS_EP_WIDTH                    9
#define IDS_EP_HEIGHT                   10
#define IDS_EP_SSPAWNDEFLECTOR          11
#define IDS_EP_SSPAWNDEFLECTORMOD       12
#define IDS_EP_SSPAWNDEFLECTORBINDING   13
#define IDS_EP_ICONSIZE                 14
#define IDS_SISYPHUSSWCAT               15
#define IDS_EP_RADIUS                   16
#define IDS_EP_USPAWNDEFLECTOR          17
#define IDS_EP_USPAWNDEFLECTORMOD       18
#define IDS_EP_USPAWNDEFLECTORBINDING   19
#define IDS_EP_OBJECTSTR                20
#define IDS_EP_NONE                     21
#define IDS_EP_USPPICK                  22
#define IDS_EP_CREATE                   23
#define IDS_EP_ITEMSTR                  24
#define IDS_EP_PLANARDYNADEF            25
#define IDS_EP_PDYNADEF                 25
#define IDS_EP_PLANARDYNADEFMOD         26
#define IDS_EP_PDYNADEFMOD              26
#define IDS_EP_PLANARDYNADEFMODBINDING  27
#define IDS_EP_PDYNADEFMODBINDING       27
#define IDS_EP_SDYNADEFLECTOR           28
#define IDS_EP_SDYNADEFLECTORMOD        29
#define IDS_EP_SDYNADEFLECTORBINDING    30
#define IDS_EP_UDYNADEFLECTOR           31
#define IDS_EP_UDYNADEFLECTORMOD        32
#define IDS_EP_UDYNADEFLECTORBINDING    33
#define IDS_EP_BOUNCE                   34
#define IDS_EP_BOUNCEVAR                35
#define IDS_EP_CHAOS                    36
#define IDS_EP_INHERIT                  37
#define IDS_EP_MASS                     38
#define IDS_EP_MASSUNITS                39
#define IDS_EP_FRICTION                 40
#define IDS_EP_REFRACTS                 41
#define IDS_EP_REFRACTION               42
#define IDS_EP_REFRACTVAR               43
#define IDS_EP_PASSVEL                  44
#define IDS_EP_PASSVELVAR               45
#define IDS_EP_DIFFUSION                46
#define IDS_EP_DIFFUSIONVAR             47
#define IDS_AP_SPAWN                    48
#define IDS_AP_PASSVEL                  49
#define IDS_AP_PASSVELVAR               50
#define SPACEWARPS_FOR_DYNAMICS         51
#define SPACEWARPS_FOR_PARTICLES        52
#define SPACEWARPS_FOR_BOTH             53
#define IDS_AP_CREATEMODE               54
#define IDS_AP_PICKMODE                 55
#define IDD_DIALOG1                     101
#define IDC_CROSS_HAIR                  103
#define IDD_AP_USPAWNDEFL               106
#define IDD_AP_PSPAWNDEFL               107
#define IDD_AP_SDYNADEFL                108
#define IDD_SW_DESC                     109
#define IDD_SW_DESC_BOTH                125
#define IDD_AP_PDYNADEFL                126
#define IDD_AP_SSPAWNDEFL_HOSED         127
#define IDD_AP_SSPAWNDEFL               127
#define IDD_AP_UDYNADEFL                128
#define IDC_EP_CHAOS                    1000
#define IDC_EP_CHAOSSPIN                1001
#define IDC_EP_INHERIT                  1002
#define IDC_EP_INHERITSPIN              1003
#define IDC_EP_DECELU                   1004
#define IDC_EP_DECELUVAR                1005
#define IDC_EP_DIFFUSIONU               1006
#define IDC_EP_DIFFUSIONUVAR            1007
#define IDC_EP_SPAWNSONLY               1008
#define IDC_EP_SPAWNSONLYSPIN           1009
#define IDC_EP_SPAWNONLYDECEL           1010
#define IDC_EP_SPAWNONLYDECELSPIN       1011
#define IDC_EP_PICKNAME                 1012
#define IDC_EP_SPAWNSONLYDECELVARSPIN   1014
#define IDC_EP_BOUNCEINHERIT            1021
#define IDC_EP_BOUNCEUINHERIT           1021
#define IDC_EP_PICKBUTTON               1051
#define IDC_EP_TIMEON                   1175
#define IDC_EP_TIMEONSPIN               1176
#define IDC_EP_TIMEOFF                  1177
#define IDC_EP_TIMEOFFSPIN              1178
#define IDC_EP_ICONSIZESPIN             1179
#define IDC_EP_ICONSIZE                 1180
#define IDC_EP_AFFECTS                  1181
#define IDC_EP_AFFECTSSPIN              1182
#define IDC_EP_ICONSIZE1                1183
#define IDC_EP_BOUNCEU                  1183
#define IDC_EP_ICONSIZE1SPIN            1184
#define IDC_EP_BOUNCEUSPIN              1184
#define IDC_EP_BOUNCE                   1185
#define IDC_EP_BOUNCEUVAR               1185
#define IDC_EP_BOUNCESPIN               1186
#define IDC_EP_BOUNCEUVARSPIN           1186
#define IDC_EP_BOUNCEVAR                1187
#define IDC_EP_BOUNCEUCHAOS             1187
#define IDC_EP_BOUNCEVARSPIN            1188
#define IDC_EP_BOUNCEUCHAOSSPIN         1188
#define IDC_EP_BOUNCECHAOS              1189
#define IDC_EP_BOUNCEUFRICTION          1189
#define IDC_EP_PARTICLEMASS             1189
#define IDC_EP_REFRACTION               1189
#define IDC_EP_BOUNCECHAOSSPIN          1190
#define IDC_EP_BOUNCEUFRICTIONSPIN      1190
#define IDC_EP_PARTICLEMASSSPIN         1190
#define IDC_EP_REFRACTIONSPIN           1190
#define IDC_EP_BOUNCEUINHERITSPIN       1191
#define IDC_EP_REFRACTS                 1191
#define IDC_EP_PARTICLEMASSU            1192
#define IDC_EP_REFRACTSSPIN             1192
#define IDC_EP_REFRACTSU                1192
#define IDC_EP_BOUNCEINHERITSPIN        1193
#define IDC_EP_PARTICLEMASSUSPIN        1193
#define IDC_EP_REFRACTVAR               1193
#define IDC_EP_REFRACTIONU              1193
#define IDC_EP_REFRACTVARSPIN           1194
#define IDC_EP_REFRACTUVAR              1194
#define IDC_EP_DECEL                    1195
#define IDC_EP_DECELVAR                 1196
#define IDC_EP_DECELSPIN                1197
#define IDC_EP_REFRACTIONUSPIN          1197
#define IDC_EP_DECELVARSPIN             1198
#define IDC_EP_REFRACTSUSPIN            1198
#define IDC_EP_DIFFUSION                1199
#define IDC_EP_DIFFUSIONVAR             1200
#define IDC_EP_DIFFUSIONSPIN            1201
#define IDC_EP_REFRACTUVARSPIN          1201
#define IDC_EP_DIFFUSIONVARSPIN         1202
#define IDC_EP_DECELUSPIN               1202
#define IDC_EP_DECELUVARSPIN            1203
#define IDC_EP_DIFFUSIONUSPIN           1204
#define IDC_EP_DIFFUSIONUVARSPIN        1205
#define IDC_EP_SPAWNSONLYDECELVAR       1208
#define IDC_EP_MASSGM                   3074
#define IDC_EP_MASSKG                   3075
#define IDC_EP_MASSLBM                  3076

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\sspflect.cpp ===
/**********************************************************************
 *<
	FILE: sspflect.cpp

	DESCRIPTION: Enhanced Deflector

	CREATED BY: Eric Peterson from Audrey Peterson's SDeflector code

	HISTORY: 7/97

 **********************************************************************/
#include "sflectr.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

static Class_ID SSPAWNDEFL_CLASS_ID(0x656107ca, 0x1f284a6f);
static Class_ID SSPAWNDEFLMOD_CLASS_ID(0x72a61178, 0x21b407d9);

class SSpawnDeflObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		int lastrnd;
		TimeValue t;
		SSpawnDeflObject();
		BOOL SupportsDynamics() {return FALSE;}

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);
		Class_ID ClassID() {return SSPAWNDEFL_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_SSPAWNDEFLECTOR);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		

		// from ref
		IOResult Load(ILoad *iload);
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *SSpawnDeflObject::ip        = NULL;
IParamMap *SSpawnDeflObject::pmapParam = NULL;
HWND       SSpawnDeflObject::hSot      = NULL;

class SSpawnDeflClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new SSpawnDeflObject;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_SSPAWNDEFLECTOR);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return SSPAWNDEFL_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_PARTICLES);}
	};

static SSpawnDeflClassDesc SSpawnDeflDesc;
ClassDesc* GetSSpawnDeflObjDesc() {return &SSpawnDeflDesc;}

//--- DeflectMod -----------------------------------------------------

class SSpawnDeflField : public CollisionObject {
	public:		
		SSpawnDeflObject *obj;
		INode *node;
		Matrix3 tm, invtm,tp;
		Interval tmValid;
		Point3 Vc,Vcp;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class SSpawnDeflMod : public SimpleWSMMod {
	public:				
		SSpawnDeflField deflect;

		SSpawnDeflMod() {}
		SSpawnDeflMod(INode *node,SSpawnDeflObject *obj);		

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_EP_SSPAWNDEFLECTORMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return SSPAWNDEFLMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_SSPAWNDEFLECTORBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class SSpawnDeflModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new SSpawnDeflMod;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_SSPAWNDEFLECTORMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return SSPAWNDEFLMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static SSpawnDeflModClassDesc SSpawnDeflModDesc;
ClassDesc* GetSSpawnDeflModDesc() {return &SSpawnDeflModDesc;}

//--- SphereFlectorObject Parameter map/block descriptors ------------------

#define PB_TIMEON		0
#define PB_TIMEOFF		1
#define PB_AFFECTS		2
#define PB_BOUNCE		3
#define PB_BOUNCEVAR	4
#define PB_CHAOS		5
#define PB_INHERIT		6
#define PB_REFRACTS		7
#define PB_DECEL		8
#define PB_DECELVAR		9
#define PB_REFRACTION	10
#define PB_REFRACTVAR	11
#define PB_DIFFUSION	12
#define PB_DIFFUSIONVAR	13
#define PB_RADIUS		14
#define PB_SPAWN		15
#define PB_PASSVEL		16
#define PB_PASSVELVAR	17

static ParamUIDesc descSSpawnDeflParam[] = {
	// Start Time
	ParamUIDesc(
		PB_TIMEON,
		EDITTYPE_TIME,
		IDC_EP_TIMEON,IDC_EP_TIMEONSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Stop Time
	ParamUIDesc(
		PB_TIMEOFF,
		EDITTYPE_TIME,
		IDC_EP_TIMEOFF,IDC_EP_TIMEOFFSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Affects
	ParamUIDesc(
		PB_AFFECTS,
		EDITTYPE_FLOAT,
		IDC_EP_AFFECTS,IDC_EP_AFFECTSSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),
		
	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCE,IDC_EP_BOUNCESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// BounceVar
	ParamUIDesc(
		PB_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEVAR,IDC_EP_BOUNCEVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_EP_CHAOS,IDC_EP_CHAOSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Inherit
	ParamUIDesc(
		PB_INHERIT,
		EDITTYPE_FLOAT,
		IDC_EP_INHERIT,IDC_EP_INHERITSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Refracts Percentage
	ParamUIDesc(
		PB_REFRACTS,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTS,IDC_EP_REFRACTSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction Decel
	ParamUIDesc(
		PB_DECEL,
		EDITTYPE_FLOAT,
		IDC_EP_DECEL,IDC_EP_DECELSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Refraction Decel Var
	ParamUIDesc(
		PB_DECELVAR,
		EDITTYPE_FLOAT,
		IDC_EP_DECELVAR,IDC_EP_DECELVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction
	ParamUIDesc(
		PB_REFRACTION,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTION,IDC_EP_REFRACTIONSPIN,
		-100.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction Var
	ParamUIDesc(
		PB_REFRACTVAR,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTVAR,IDC_EP_REFRACTVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Diffusion
	ParamUIDesc(
		PB_DIFFUSION,
		EDITTYPE_FLOAT,
		IDC_EP_DIFFUSION,IDC_EP_DIFFUSIONSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Diffusion Var
	ParamUIDesc(
		PB_DIFFUSIONVAR,
		EDITTYPE_FLOAT,
		IDC_EP_DIFFUSIONVAR,IDC_EP_DIFFUSIONVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Spawns Percentage
	ParamUIDesc(
		PB_SPAWN,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNSONLY,IDC_EP_SPAWNSONLYSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Pass Velocity
	ParamUIDesc(
		PB_PASSVEL,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNONLYDECEL,IDC_EP_SPAWNONLYDECELSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Pass Velocity Var
	ParamUIDesc(
		PB_PASSVELVAR,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNSONLYDECELVAR,IDC_EP_SPAWNSONLYDECELVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_EP_ICONSIZE,IDC_EP_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	};

#define PARAMDESC_LENGTH	18

ParamBlockDescID SSpawnDefldescVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },	
	{ TYPE_FLOAT, NULL, TRUE, 2 },	
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_FLOAT, NULL, TRUE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 }};
	
ParamBlockDescID SSpawnDefldescVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	
	{ TYPE_INT, NULL, TRUE, 1 },	
	{ TYPE_FLOAT, NULL, TRUE, 2 },	
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_FLOAT, NULL, TRUE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },
	{ TYPE_FLOAT, NULL, TRUE, 15 },
	{ TYPE_FLOAT, NULL, TRUE, 16 },
	{ TYPE_FLOAT, NULL, TRUE, 17 },
};	

#define PBLOCK_LENGTH	18

static ParamVersionDesc ssversions[] = {
	ParamVersionDesc(SSpawnDefldescVer0,15,0),
	};

#define NUM_OLDVERSIONS	1
#define CURRENT_VERSION	1

static ParamVersionDesc scurVersion(SSpawnDefldescVer1,PBLOCK_LENGTH,CURRENT_VERSION);


//--- Deflect object methods -----------------------------------------

SSpawnDeflObject::SSpawnDeflObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(SSpawnDefldescVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_TIMEON,0,0);
	pblock->SetValue(PB_TIMEOFF,0,100*GetTicksPerFrame());
	pblock->SetValue(PB_AFFECTS,0,1.0f);
	pblock->SetValue(PB_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BOUNCEVAR,0,0.0f);
	pblock->SetValue(PB_CHAOS,0,0.0f);
	pblock->SetValue(PB_INHERIT,0,1.0f);
	pblock->SetValue(PB_REFRACTS,0,1.0f);
	pblock->SetValue(PB_DECEL,0,1.0f);
	pblock->SetValue(PB_DECELVAR,0,0.0f);
	pblock->SetValue(PB_REFRACTION,0,0.5f);
	pblock->SetValue(PB_REFRACTVAR,0,0.0f);
	pblock->SetValue(PB_DIFFUSION,0,0.0f);
	pblock->SetValue(PB_DIFFUSIONVAR,0,0.0f);
	pblock->SetValue(PB_SPAWN,0,1.0f);
	pblock->SetValue(PB_PASSVEL,0,1.0f);
	pblock->SetValue(PB_PASSVELVAR,0,0);
	srand(lastrnd=12345);
	t=99999;
	}

Modifier *SSpawnDeflObject::CreateWSMMod(INode *node)
	{
	return new SSpawnDeflMod(node,this);
	}

RefTargetHandle SSpawnDeflObject::Clone(RemapDir& remap) 
	{
	SSpawnDeflObject* newob = new SSpawnDeflObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
	}

void SSpawnDeflObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC),
			DefaultSOTProc,
			GetString(IDS_EP_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descSSpawnDeflParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_AP_SSPAWNDEFL),
			GetString(IDS_EP_PARAMETERS),
			0);
		}
	}

void SSpawnDeflObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}

void SSpawnDeflObject::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_TIMEON,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEON,0,TempTime);
	pblock->GetValue(PB_TIMEOFF,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEOFF,0,TempTime);
}  

void SSpawnDeflObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float length,r2,r3,r,r4;
	pblock->GetValue(PB_RADIUS,t,length,ivalid);
	float u;
	#define NUM_SEGS	24
	 r=length;
	 r2=0.5f*r;
	 r3=0.25f*r2;
	 r4=0.71f*r3;

	mesh.setNumVerts(3*NUM_SEGS+21);
	mesh.setNumFaces(3*NUM_SEGS+10);

	for (int i=0; i<NUM_SEGS; i++)
	{	u=float(i)/float(NUM_SEGS) * TWOPI;
		mesh.setVert(i, Point3((float)cos(u) * length, (float)sin(u) * length, 0.0f));
		mesh.setVert(i+NUM_SEGS, Point3(0.0f, (float)cos(u) * length, (float)sin(u) * length));
		mesh.setVert(i+2*NUM_SEGS, Point3((float)cos(u) * length, 0.0f, (float)sin(u) * length));
	}
//	for (i=0; i<NUM_SEGS; i++)
//	{	u=float(i)/float(NUM_SEGS) * TWOPI;
//	}
//	for (i=0; i<NUM_SEGS; i++)
//	{	u=float(i)/float(NUM_SEGS) * TWOPI;
//	}		
	mesh.setVert(3*NUM_SEGS, Point3(0.0f, 0.0f, 0.0f));

	mesh.setVert(73,Point3(0.0f,0.0f  ,r      ));//a //juncture on sphere
	mesh.setVert(74,Point3(0.0f,0.0f  ,r+r2   ));//b //end third prong
	mesh.setVert(75,Point3(0.0f,-r2   ,r-r2   ));//c // end second prong
	mesh.setVert(76,Point3(0.0f, r2   ,r-r2   ));//d //end second prong
//	mesh.setVert(77,Point3(0.0f, r4   ,r+r2+r4));//b1 //lone arrow head
//	mesh.setVert(78,Point3(0.0f,-r4   ,r+r2+r4));//b2 //lone arrow head
	mesh.setVert(77,Point3(0.0f, r4   ,r+r4   ));//b1 //lone arrow head
	mesh.setVert(78,Point3(0.0f,-r4   ,r+r4   ));//b2 //lone arrow head
	mesh.setVert(79,Point3(0.0f,-r2   ,r-r2+r3));//c1
	mesh.setVert(80,Point3(0.0f,-r2+r3,r-r2   ));//c2
	mesh.setVert(81,Point3(0.0f, r2-r3,r-r2   ));//d1
	mesh.setVert(82,Point3(0.0f, r2   ,r-r2+r3));//d2
	
	mesh.setVert(83,Point3(0.0f,0.0f  ,-r      ));//a //juncture on sphere
	mesh.setVert(84,Point3(0.0f,0.0f  ,-r-r2   ));//b //end third prong
	mesh.setVert(85,Point3(0.0f,-r2   ,-r+r2   ));//c // end second prong
	mesh.setVert(86,Point3(0.0f, r2   ,-r+r2   ));//d //end second prong
//	mesh.setVert(87,Point3(0.0f, r4   ,-r-r2-r4));//b1 //lone arrow head
//	mesh.setVert(88,Point3(0.0f,-r4   ,-r-r2-r4));//b2 //lone arrow head
	mesh.setVert(87,Point3(0.0f, r4   ,-r-r4   ));//b1 //lone arrow head
	mesh.setVert(88,Point3(0.0f,-r4   ,-r-r4   ));//b2 //lone arrow head
	mesh.setVert(89,Point3(0.0f,-r2   ,-r+r2-r3));//c1
	mesh.setVert(90,Point3(0.0f,-r2+r3,-r+r2   ));//c2
	mesh.setVert(91,Point3(0.0f, r2-r3,-r+r2   ));//d1
	mesh.setVert(92,Point3(0.0f, r2   ,-r+r2-r3));//d2
	
	for (i=0; i<3*NUM_SEGS; i++)
	{	int i1 = i+1;
		if (i1%NUM_SEGS==0) i1 -= NUM_SEGS;
		mesh.faces[i].setEdgeVisFlags(1,0,0);
		mesh.faces[i].setSmGroup(0);
		mesh.faces[i].setVerts(i,i1,3*NUM_SEGS);
	}

	mesh.faces[72].setEdgeVisFlags(1,0,1);
	mesh.faces[72].setSmGroup(0);
	mesh.faces[72].setVerts(73,75,76);
	mesh.faces[73].setEdgeVisFlags(1,1,1);
	mesh.faces[73].setSmGroup(0);
	mesh.faces[73].setVerts(73,74,74);
	mesh.faces[74].setEdgeVisFlags(1,1,1);
	mesh.faces[74].setSmGroup(0);
//	mesh.faces[74].setVerts(74,78,77);
	mesh.faces[74].setVerts(73,78,77);
	mesh.faces[75].setEdgeVisFlags(1,1,1);
	mesh.faces[75].setSmGroup(0);
	mesh.faces[75].setVerts(75,79,80);
	mesh.faces[76].setEdgeVisFlags(1,1,1);
	mesh.faces[76].setSmGroup(0);
	mesh.faces[76].setVerts(76,81,82);

	mesh.faces[77].setEdgeVisFlags(1,0,1);
	mesh.faces[77].setSmGroup(0);
	mesh.faces[77].setVerts(83,85,86);
	mesh.faces[78].setEdgeVisFlags(1,0,1);
	mesh.faces[78].setSmGroup(0);
	mesh.faces[78].setVerts(83,84,84);
	mesh.faces[79].setEdgeVisFlags(1,1,1);
	mesh.faces[79].setSmGroup(0);
//	mesh.faces[79].setVerts(84,88,87);
	mesh.faces[79].setVerts(83,88,87);
	mesh.faces[80].setEdgeVisFlags(1,1,1);
	mesh.faces[80].setSmGroup(0);
	mesh.faces[80].setVerts(85,89,90);
	mesh.faces[81].setEdgeVisFlags(1,1,1);
	mesh.faces[81].setSmGroup(0);
	mesh.faces[81].setVerts(86,91,92);

	mesh.InvalidateGeomCache();
}


class SSpawnDeflObjCreateCallback : public CreateMouseCallBack {
	public:
		SSpawnDeflObject *ob;	
		Point3 p0, p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int SSpawnDeflObjCreateCallback::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{
	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif
	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE)
	{	switch(point)
		{	case 0:
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pmapParam->Invalidate();
				break;
			case 1:
			{	sp1 = m;
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				ob->pblock->SetValue(PB_RADIUS,0,Length(p1-p0));
				ob->pmapParam->Invalidate();

				if (msg==MOUSE_POINT)
				{	if (Length(m-sp0)<3) 
						return CREATE_ABORT;
					else
						return CREATE_STOP;
				}
				break;
			}
		}
	}
	else
		if (msg == MOUSE_ABORT)	return CREATE_ABORT;
	return TRUE;
}

static SSpawnDeflObjCreateCallback SSpawnDeflCreateCB;

CreateMouseCallBack* SSpawnDeflObject::GetCreateMouseCallBack()
	{
	SSpawnDeflCreateCB.ob = this;
	return &SSpawnDeflCreateCB;
	}

void SSpawnDeflObject::InvalidateUI() 
{	if (pmapParam) pmapParam->Invalidate();
}

ParamDimension *SSpawnDeflObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_TIMEON:			return stdTimeDim;
		case PB_TIMEOFF:		return stdTimeDim;
		case PB_AFFECTS:		return stdPercentDim;
		case PB_BOUNCEVAR:		return stdPercentDim;
		case PB_CHAOS:			return stdPercentDim;
		case PB_REFRACTS:		return stdPercentDim;
		case PB_DECELVAR:		return stdPercentDim;
		case PB_REFRACTION:		return stdPercentDim;
		case PB_REFRACTVAR:		return stdPercentDim;
		case PB_DIFFUSION:		return stdPercentDim;
		case PB_DIFFUSIONVAR:	return stdPercentDim;
		case PB_SPAWN:			return stdPercentDim;
		case PB_PASSVELVAR:		return stdPercentDim;
		default:				return defaultDim;
		}
	}

TSTR SSpawnDeflObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_TIMEON:			return GetString(IDS_EP_TIMEON);
		case PB_TIMEOFF:		return GetString(IDS_EP_TIMEOFF);
		case PB_AFFECTS:		return GetString(IDS_EP_AFFECTS);
		case PB_BOUNCE:			return GetString(IDS_EP_BOUNCE);
		case PB_BOUNCEVAR:		return GetString(IDS_EP_BOUNCEVAR);
		case PB_CHAOS:			return GetString(IDS_EP_CHAOS);
		case PB_INHERIT:		return GetString(IDS_EP_INHERIT);
		case PB_REFRACTS:		return GetString(IDS_EP_REFRACTS);
		case PB_DECEL:			return GetString(IDS_EP_PASSVEL);
		case PB_DECELVAR:		return GetString(IDS_EP_PASSVELVAR);
		case PB_REFRACTION:		return GetString(IDS_EP_REFRACTION);
		case PB_REFRACTVAR:		return GetString(IDS_EP_REFRACTVAR);
		case PB_DIFFUSION:		return GetString(IDS_EP_DIFFUSION);
		case PB_DIFFUSIONVAR:	return GetString(IDS_EP_DIFFUSIONVAR);
		case PB_RADIUS:			return GetString(IDS_EP_RADIUS);
		case PB_SPAWN:			return GetString(IDS_AP_SPAWN);
		case PB_PASSVEL:		return GetString(IDS_AP_PASSVEL);
		case PB_PASSVELVAR:		return GetString(IDS_AP_PASSVELVAR);
		default: 				return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

SSpawnDeflMod::SSpawnDeflMod(INode *node,SSpawnDeflObject *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef = NULL;
	}

Interval SSpawnDeflMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		SSpawnDeflObject *obj = (SSpawnDeflObject*)GetWSMObject(t);
		obj->pblock->GetValue(PB_TIMEOFF,t,f,valid);
		obj->pblock->GetValue(PB_AFFECTS,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,f,valid);
		obj->pblock->GetValue(PB_CHAOS,t,f,valid);
		obj->pblock->GetValue(PB_INHERIT,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTS,t,f,valid);
		obj->pblock->GetValue(PB_DECEL,t,f,valid);
		obj->pblock->GetValue(PB_DECELVAR,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTION,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTVAR,t,f,valid);
		obj->pblock->GetValue(PB_DIFFUSION,t,f,valid);
		obj->pblock->GetValue(PB_DIFFUSIONVAR,t,f,valid);
		obj->pblock->GetValue(PB_RADIUS,t,f,valid);
		obj->pblock->GetValue(PB_SPAWN,t,f,valid);
		obj->pblock->GetValue(PB_PASSVEL,t,f,valid);
		obj->pblock->GetValue(PB_PASSVELVAR,t,f,valid);
		tm=nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class SSpawnDeflDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static SSpawnDeflDeformer SSpawnDeflddeformer;

Deformer& SSpawnDeflMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return SSpawnDeflddeformer;
	}

RefTargetHandle SSpawnDeflMod::Clone(RemapDir& remap) 
{	SSpawnDeflMod *newob = new SSpawnDeflMod(nodeRef,(SSpawnDeflObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
}


void SSpawnDeflMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (SSpawnDeflObject*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.tmValid.SetEmpty();		
		if (t<=deflect.obj->t) deflect.obj->lastrnd=12345;
		deflect.obj->t=t;
		obj->ApplyCollisionObject(&deflect);
		}
	}

Object *SSpawnDeflField::GetSWObject()
{ return obj;
}

BOOL SSpawnDeflField::CheckCollision(TimeValue t,Point3 &pos,Point3 &vel,float dt,int index,float *ct,BOOL UpdatePastCollide)
{	if (!tmValid.InInterval(t))
	{	tmValid=FOREVER;
		tm=node->GetObjectTM(t,&tmValid);
		invtm=Inverse(tm);
		Interval tmpValid=FOREVER;
		tp=node->GetObjectTM(t+(int)dt,&tmpValid);
		Vc=Zero;
		Vcp=Zero*tp*invtm;
	}
	TimeValue startt,endt;
	obj->pblock->GetValue(PB_TIMEON,t,startt,FOREVER);
	obj->pblock->GetValue(PB_TIMEOFF,t,endt,FOREVER);
	if ((t<startt)||(t>endt))
	{	obj->lastrnd=rand();
		return FALSE;
	}

    srand(obj->lastrnd);

// Main reflection / refraction loop starts here
	float radius,vinher;
	float rsquare,rplus,rminus,TempDP;
	Point3 p,vr,Vdt,Vrel,Vreln;

// test for reflection
	float affectsthisportion;
	obj->pblock->GetValue(PB_AFFECTS,t,affectsthisportion,FOREVER);

	if (RND01()<affectsthisportion) 
	{	float bounce,bvar,chaos;
		obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,bvar,FOREVER);
		obj->pblock->GetValue(PB_CHAOS,t,chaos,FOREVER);
		obj->pblock->GetValue(PB_INHERIT,t,vinher,FOREVER);
		
		obj->pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
		p=pos*invtm; 
		vr=VectorTransform(invtm,vel);
		Vdt=(Vcp-Vc)/dt;
		Vrel=vr-Vdt;
		rsquare=radius*radius;
		rplus=radius;rminus=radius;
		Vreln=Normalize(Vrel);
		if (LengthSquared(p-Vc)>=(rminus*rminus)) //outside
		{	Point3 P1;
			P1=p+dt*Vrel; //second particle position
			if (!(LengthSquared(P1-Vc)<(rplus*rplus)))
			{	float Dist,Dist1;
				Dist=DotProd(Vreln,(Vc-p));
				if (Dist<0.0f)
				{	obj->lastrnd=rand();
					return FALSE;
				}
				Dist1=DotProd(-Vreln,(Vc-P1));
				if (Dist1<0.0f)
				{	obj->lastrnd=rand();
					return FALSE;
				}
				Point3 P10=P1-p,Pc=Vc-p;
				float gamma=(float)acos(DotProd(P10,Pc)/(Length(P10)*Length(Pc)));
				float Dist2=Length(Pc)*(float)cos(HalfPI-gamma);
				if (Dist2>radius)
				{	obj->lastrnd=rand();
					return FALSE;
				}
			}
			float A,B,C,omega,omega1,omegaend,a2,ptmp,c,d;
			A=LengthSquared(Vrel);
			B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
			C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
			omegaend=B*B-4.0f*A*C;
			if (omegaend<0.0f) omegaend=0.0f;
			else omegaend=(float)sqrt(omegaend);
			a2=2.0f*A;
			omega1=(-B+omegaend)/a2;
			omega=(-B-omegaend)/a2;
			if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
			float fdt=1.1f*dt;
			if ((omega>fdt)||(omega<-fdt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
// solve for collision params starts here
			Point3 XI,r,n;
			XI=p+omega*vr;
			Point3 Ci=Vc+omega*Vdt;
			r=Normalize(XI-Ci);
			float q1=DotProd(-Vreln,r);
			float theta=(float)acos(q1);
			if (theta>=HalfPI) theta-=PI;
			float v[4];
			if (theta<FLOAT_EPSILON)
				vr=-vr;
			else 
			{	n=Normalize((-Vreln)^r);
				vr=-vr;
				memcpy(v,vr,row3size);v[3]=1.0f;
				RotateOnePoint(v,&Zero.x,&n.x,2*theta);
				memcpy(vr,v,row3size);
			}
			vr=vr*bounce*(1-bvar*RND01());
			if (!FloatEQ0(chaos))
			{	theta=(HalfPI-theta)*chaos*RND01();
				Point3 d=Point3(RND11(),RND11(),RND11());
				Point3 c=Normalize(vr^d);
				memcpy(v,vr,row3size);v[3]=1.0f;
				RotateOnePoint(v,&Zero.x,&c.x,theta);
				memcpy(vr,v,row3size);
			}
			if ((vinher>0.0f)&&(t>0)){vr=vr+DotProd(Vdt*vinher,r)*r;}
			pos=XI+(dt-omega)*vr;
		}
		else //inside
		{	Point3 P1;
			P1=p+dt*Vrel;
			if (LengthSquared(P1-Vc)<(rplus*rplus))
			{	obj->lastrnd=rand();
				return FALSE;
			}
			float A,B,C,omega,omega1,omegaend,a2,ptmp,c,d;
			A=LengthSquared(Vrel);
			B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
			C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
			omegaend=B*B-4.0f*A*C;
			if (omegaend<0.0f) omegaend=0.0f;
			else omegaend=(float)sqrt(omegaend);
			a2=2.0f*A;
			omega1=(-B+omegaend)/a2;
			omega=(-B-omegaend)/a2;
			if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
			float fdt=1.1f*dt;
			if ((omega>fdt)||(omega<-fdt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
			Point3 XI,r,n;
			XI=p+omega*vr;
			Point3 Ci=Vc+omega*Vdt;
			r=Normalize(XI-Ci);
			float q1=DotProd(Vreln,r);
			float theta=(float)acos(q1);
			float v[4];
			if (theta<FLOAT_EPSILON)
				vr=-vr;
			else 
			{	n=Normalize(Vreln^r);
				vr=-vr;
				memcpy(v,vr,row3size);v[3]=1.0f;
				RotateOnePoint(v,&Zero.x,&n.x,2*theta);
				memcpy(vr,v,row3size);
			}
			vr=vr*bounce*(1-bvar*RND01());
			if (!FloatEQ0(chaos))
			{	theta=(HalfPI-theta)*chaos*RND01();
				Point3 d=Point3(RND11(),RND11(),RND11());
				Point3 c=Normalize(vr^d);
				memcpy(v,vr,row3size);v[3]=1.0f;
				RotateOnePoint(v,&Zero.x,&c.x,theta);
				memcpy(vr,v,row3size);
			}
			if ((vinher>0.0f)&&(t>0)){vr=vr+DotProd(Vdt*vinher,r)*r;}
			if (UpdatePastCollide)
			{	pos = XI + (dt-omega)*vr;
				if (ct) (*ct) = dt;
			}
			else
			{	pos = XI;
				if (ct) (*ct) = omega;
			}
		}
		pos = pos*tm;
		vel = VectorTransform(tm,vr);
		obj->lastrnd=rand();
		return TRUE;
	}

// test for refraction
	float refracts;
	obj->pblock->GetValue(PB_REFRACTS,t,refracts,FOREVER);

	if (RND01()<refracts)
	{	float refvol,refvar,decel,decelvar;
		obj->pblock->GetValue(PB_REFRACTION,t,refvol,FOREVER);
		obj->pblock->GetValue(PB_REFRACTVAR,t,refvar,FOREVER);
		obj->pblock->GetValue(PB_DECEL,t,decel,FOREVER);
		obj->pblock->GetValue(PB_DECELVAR,t,decelvar,FOREVER);
		obj->pblock->GetValue(PB_INHERIT,t,vinher,FOREVER);
		obj->pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
		p=pos*invtm; 
		vr=VectorTransform(invtm,vel);
		Vdt=(Vcp-Vc)/dt;
		Vrel=vr-Vdt;
		rsquare=radius*radius;
		rplus=radius;rminus=radius;
		Vreln=Normalize(Vrel);
		if (LengthSquared(p-Vc)>=(rminus*rminus)) //outside
		{	Point3 P1;
			P1=p+dt*Vrel; //second particle position
			if (!(LengthSquared(P1-Vc)<(rplus*rplus)))
			{	float Dist,Dist1;
				Dist=DotProd(Vreln,(Vc-p));
				if (Dist<0.0f)
				{	obj->lastrnd=rand();
					return FALSE;
				}
				Dist1=DotProd(-Vreln,(Vc-P1));
				if (Dist1<0.0f)
				{	obj->lastrnd=rand();
					return FALSE;
				}
				Point3 P10=P1-p,Pc=Vc-p;
				float gamma=(float)acos(DotProd(P10,Pc)/(Length(P10)*Length(Pc)));
				float Dist2=Length(Pc)*(float)cos(HalfPI-gamma);
				if (Dist2>radius)
				{	obj->lastrnd=rand();
					return FALSE;
				}
			}
			float A,B,C,omega,omega1,omegaend,a2,ptmp,c,d;
			A=LengthSquared(Vrel);
			B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
			C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
			omegaend=B*B-4.0f*A*C;
			if (omegaend<0.0f) omegaend=0.0f;
			else omegaend=(float)sqrt(omegaend);
			a2=2.0f*A;
			omega1=(-B+omegaend)/a2;
			omega=(-B-omegaend)/a2;
			if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
			float fdt=1.1f*dt;
			if ((omega>fdt)||(omega<-fdt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
// solve for collision params starts here
			Point3 XI,r,n;
			XI=p+omega*vr;
			Point3 Ci=Vc+omega*Vdt;
			r=Normalize(XI-Ci);
			float q1=DotProd(-Vreln,r);
			float theta=(float)acos(q1);
			if (theta>=HalfPI) theta-=PI;
// refraction solution
// reduce v by decel parameters
			vr*=decel*(1.0f-decelvar*RND01());
// rotate velocity vector
			float maxref,refangle,maxvarref;
			refangle=0.0f;
			if (!FloatEQ0(refvol))
			{	if (refvol>0.0f)
					maxref=-theta;
				else 
					maxref=HalfPI-theta;
				refangle=maxref*(float)fabs(refvol);
				float frefangle=(float)fabs(refangle);
				if (refvol>0.0f)
					maxvarref=HalfPI-theta-frefangle;
				else
					maxvarref=theta-frefangle;
				refangle+=maxvarref*RND11()*refvar;
				Point3 c,d;
				if (theta<0.01f)
				{	d=Point3(RND11(),RND11(),RND11());
					c=Normalize(vr^d);
				}
				else
				{	c=Normalize(r^(-vr));
				}
				RotateOnePoint(vr,&Zero.x,&c.x,refangle);
				if ((TempDP=DotProd(vr,r))>0.0f) vr=vr-TempDP*r;
			}
			float maxdiff,diffuse,diffvar,diffangle;
			obj->pblock->GetValue(PB_DIFFUSION,t,diffuse,FOREVER);
			obj->pblock->GetValue(PB_DIFFUSIONVAR,t,diffvar,FOREVER);
			maxdiff=HalfPI-theta-refangle;
			if (!FloatEQ0(diffuse))
			{	Point3 d=Point3(RND11(),RND11(),RND11());
				Point3 c=Normalize(vr^d);
				diffangle=0.5f*maxdiff*diffuse*(1.0f+RND11()*diffvar);
				RotateOnePoint(vr,&Zero.x,&c.x,diffangle);
				if (TempDP=(DotProd(vr,r))>0.0f) vr=vr-TempDP*r;
			}
			if ((vinher>0.0f)&&(t>0)){vr=vr+DotProd(Vdt*vinher,r)*r;}
			pos=XI+(dt-omega)*vr;
		}
		else //inside
		{	Point3 P1;
			P1=p+dt*Vrel;
			if (LengthSquared(P1-Vc)<(rplus*rplus))
			{	obj->lastrnd=rand();
				return FALSE;
			}
			float A,B,C,omega,omega1,omegaend,a2,ptmp,c,d;
			A=LengthSquared(Vrel);
			B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
			C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
			omegaend=B*B-4.0f*A*C;
			if (omegaend<0.0f) omegaend=0.0f;
			else omegaend=(float)sqrt(omegaend);
			a2=2.0f*A;
			omega1=(-B+omegaend)/a2;
			omega=(-B-omegaend)/a2;
			if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
			float fdt=1.1f*dt;
			if ((omega>fdt)||(omega<-fdt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
			Point3 XI,r,n;
			XI=p+omega*vr;
			Point3 Ci=Vc+omega*Vdt;
			r=Normalize(XI-Ci);
			float q1=DotProd(Vreln,r);
			if (q1>1.0f) q1=1.0f;
			if (q1<-1.0f) q1=-1.0f;
			float theta=(float)acos(q1);
// refraction solution
// reduce v by decel parameters
			vr *= decel*(1.0f-decelvar*RND01());
// rotate velocity vector
			float maxref,refangle,maxvarref;
			refangle=0.0f;
			if (!FloatEQ0(refvol))
			{	if (refvol>0.0f)
					maxref=HalfPI-theta;
				else 
					maxref=-theta;
				refangle=maxref*(float)fabs(refvol);
				float frefangle=(float)fabs(refangle);
				if (refvol>0.0f)
					maxvarref=theta-frefangle;
				else
					maxvarref=HalfPI-theta-frefangle;
				refangle+=maxvarref*RND11()*refvar;
				Point3 c,d;
				if (theta<0.01f)
				{	d=Point3(RND11(),RND11(),RND11());
					c=Normalize(vr^d);
				}
				else
				{	c=Normalize(r^vr);
				}
				RotateOnePoint(vr,&Zero.x,&c.x,refangle);
				if ((TempDP=DotProd(vr,r))<0.0f) vr=vr-TempDP*r;
			}
			float maxdiff,diffuse,diffvar,diffangle;
			obj->pblock->GetValue(PB_DIFFUSION,t,diffuse,FOREVER);
			obj->pblock->GetValue(PB_DIFFUSIONVAR,t,diffvar,FOREVER);
			maxdiff=HalfPI-theta-refangle;
			if (!FloatEQ0(diffuse))
			{	Point3 d=Point3(RND11(),RND11(),RND11());
				Point3 c=Normalize(vr^d);
				diffangle=0.5f*maxdiff*diffuse*(1.0f+RND11()*diffvar);
				RotateOnePoint(vr,&Zero.x,&c.x,diffangle);
				if (TempDP=(DotProd(vr,r))<0.0f) vr=vr-TempDP*r;
			}
			if ((vinher>0.0f)&&(t>0)){vr=vr+DotProd(Vdt*vinher,r)*r;}
			if (UpdatePastCollide)
			{	pos = XI + (dt-omega)*vr;
				if (ct) (*ct) = dt;
			}
			else
			{	pos = XI;
				if (ct) (*ct) = omega;
			}
		}
		pos = pos*tm;
		vel = VectorTransform(tm,vr);
		obj->lastrnd=rand();
		return TRUE;
	}

// test for spawns only
	float spawnsonly;
	obj->pblock->GetValue(PB_SPAWN,t,spawnsonly,FOREVER);

	if (RND01()<spawnsonly)
	{	obj->pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
		p=pos*invtm; 
		vr=VectorTransform(invtm,vel);
		Vdt=(Vcp-Vc)/dt;
		Vrel=vr-Vdt;
		rsquare=radius*radius;
		rplus=radius;rminus=radius;
		Vreln=Normalize(Vrel);
		if (LengthSquared(p-Vc)>=(rminus*rminus)) //outside
		{	Point3 P1;
			P1=p+dt*Vrel; //second particle position
			if (!(LengthSquared(P1-Vc)<(rplus*rplus)))
			{	float Dist,Dist1;
				Dist=DotProd(Vreln,(Vc-p));
				if (Dist<0.0f)
				{	obj->lastrnd=rand();
					return FALSE;
				}
				Dist1=DotProd(-Vreln,(Vc-P1));
				if (Dist1<0.0f)
				{	obj->lastrnd=rand();
					return FALSE;
				}
				Point3 P10=P1-p,Pc=Vc-p;
				float gamma=(float)acos(DotProd(P10,Pc)/(Length(P10)*Length(Pc)));
				float Dist2=Length(Pc)*(float)cos(HalfPI-gamma);
				if (Dist2>radius)
				{	obj->lastrnd=rand();
					return FALSE;
				}
			}
			float A,B,C,omega,omega1,omegaend,a2,ptmp,c,d;
			A=LengthSquared(Vrel);
			B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
			C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
			omegaend=B*B-4.0f*A*C;
			if (omegaend<0.0f) omegaend=0.0f;
			else omegaend=(float)sqrt(omegaend);
			a2=2.0f*A;
			omega1=(-B+omegaend)/a2;
			omega=(-B-omegaend)/a2;
			if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
			float fdt=1.1f*dt;
			if ((omega>fdt)||(omega<-fdt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
// solve for collision params starts here
			Point3 XI;
			XI=p+omega*vr;
			float passvel,passvelvar;
			obj->pblock->GetValue(PB_PASSVEL,t,passvel,FOREVER);
			obj->pblock->GetValue(PB_PASSVELVAR,t,passvelvar,FOREVER);
			vr*=passvel*(1.0f+passvelvar*RND11());
			pos=XI+(dt-omega)*vr;
		}
		else //inside
		{	Point3 P1;
			P1=p+dt*Vrel;
			if (LengthSquared(P1-Vc)<(rplus*rplus))
			{	obj->lastrnd=rand();
				return FALSE;
			}
			float A,B,C,omega,omega1,omegaend,a2,ptmp,c,d;
			A=LengthSquared(Vrel);
			B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
			C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
			omegaend=B*B-4.0f*A*C;
			if (omegaend<0.0f) omegaend=0.0f;
			else omegaend=(float)sqrt(omegaend);
			a2=2.0f*A;
			omega1=(-B+omegaend)/a2;
			omega=(-B-omegaend)/a2;
			if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
			float fdt=1.1f*dt;
			if ((omega>fdt)||(omega<-fdt))
			{	obj->lastrnd=rand();
				return FALSE;
			}
// solve for collision params starts here
			Point3 XI;
			XI=p+omega*vr;
			float passvel,passvelvar;
			obj->pblock->GetValue(PB_PASSVEL,t,passvel,FOREVER);
			obj->pblock->GetValue(PB_PASSVELVAR,t,passvelvar,FOREVER);
			vr *= passvel*(1.0f+passvelvar*RND11());
			if (UpdatePastCollide)
			{	pos = XI + (dt-omega)*vr;
				if (ct) (*ct) = dt;
			}
			else
			{	pos = XI;
				if (ct) (*ct) = omega;
			}
		}
		pos = pos*tm;
		vel = VectorTransform(tm,vr);
		obj->lastrnd=rand();
		return TRUE;
	}

// nothing happens
	obj->lastrnd=rand();
	return FALSE;
}

class SSpawnDeflPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		SSpawnDeflPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((SSpawnDeflObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
 				((SSpawnDeflObject*)targ)->pblock->SetValue(PB_SPAWN,0,1.0f);
 				((SSpawnDeflObject*)targ)->pblock->SetValue(PB_PASSVEL,0,1.0f);
 				((SSpawnDeflObject*)targ)->pblock->SetValue(PB_PASSVELVAR,0,0);
				}
			delete this;
			}
	};

IOResult SSpawnDeflObject::Load(ILoad *iload) 
	{	
	// This is the callback that corrects for any older versions
	// of the parameter block structure found in the MAX file 
	// being loaded.
	iload->RegisterPostLoadCallback(
		new SSpawnDeflPostLoadCallback(
		new ParamBlockPLCB(ssversions,NUM_OLDVERSIONS,&scurVersion,this,0)));
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\uspflect.cpp ===
/**********************************************************************
 *<
	FILE: uspflect.cpp

	DESCRIPTION: Turns Any Mesh Into a SpawnFlector

	CREATED BY: Eric Peterson from Audrey's UDeflector code

	HISTORY: 7/97

 **********************************************************************/
#include "sflectr.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"
#include "interpik.h"

#define PBLK		0
#define CUSTNODE 	1

static Point3 Zero=Point3(0.0f,0.0f,0.0f);
static Class_ID USPAWNDEFL_CLASS_ID(0x19fd4916,0x557f71d9);
static Class_ID USPAWNDEFLMOD_CLASS_ID(0x36350a51,0x5073041f);

class UniPickOperand;

class USpawnDeflObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		static HWND hParams;
					
		INode *custnode;
		int lastrnd;
		TimeValue t;
		TSTR custname;
		USpawnDeflObject();
		~USpawnDeflObject();
		BOOL SupportsDynamics() {return FALSE;}
		Mesh *dmesh;
		int nv,nf;
		VNormal *vnorms;
		Point3 *fnorms;
		Matrix3 tm,ptm,invtm,tmNoTrans,invtmNoTrans;
		Interval tmValid,mValid;
		Point3 dvel;

		static BOOL creating;
		static UniPickOperand pickCB;

		void ShowName();
		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);
		Class_ID ClassID() {return USPAWNDEFL_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_USPAWNDEFLECTOR);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
	};
class UniPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		USpawnDeflObject *po;
		
		UniPickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};
class CreateUSpawnDeflPickNode : public RestoreObj {
	public:   		
		USpawnDeflObject *obj;
		INode *oldn;
		CreateUSpawnDeflPickNode(USpawnDeflObject *o, INode *n) {
			obj = o; oldn=n;
			}
		void Restore(int isUndo) {
			if (obj->custnode) 
			{ obj->custname = TSTR(obj->custnode->GetName());
			}
			else 
			{ obj->custname=TSTR(_T(""));
			}
			obj->ShowName();
			}
		void Redo() 
		{ obj->custname = TSTR(oldn->GetName());
		if (obj->hParams)
	{TSTR name=TSTR(GetString(IDS_EP_OBJECTSTR)) + (oldn ? obj->custname : TSTR(GetString(IDS_EP_NONE)));
	SetWindowText(GetDlgItem(obj->hParams, IDC_EP_PICKNAME), name);
		}
			}
		TSTR Description() {return GetString(IDS_EP_USPPICK);}
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *USpawnDeflObject::ip        = NULL;
IParamMap *USpawnDeflObject::pmapParam = NULL;
HWND       USpawnDeflObject::hSot      = NULL;
HWND       USpawnDeflObject::hParams      = NULL;
BOOL USpawnDeflObject::creating    = FALSE;
UniPickOperand USpawnDeflObject::pickCB;

class USpawnDeflClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new USpawnDeflObject;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_USPAWNDEFLECTOR);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return USPAWNDEFL_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_PARTICLES);}
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};
static USpawnDeflClassDesc USpawnDeflDesc;
ClassDesc* GetUSpawnDeflObjDesc() {return &USpawnDeflDesc;}

//--- DeflectMod -----------------------------------------------------

class USpawnDeflField : public CollisionObject {
	public:		
		USpawnDeflObject *obj;
		INode *node;
		int badmesh;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class USpawnDeflMod : public SimpleWSMMod {
	public:				
		USpawnDeflField deflect;

		USpawnDeflMod() {}
		USpawnDeflMod(INode *node,USpawnDeflObject *obj);	


		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_EP_USPAWNDEFLECTORMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return USPAWNDEFLMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_USPAWNDEFLECTORBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class USpawnDeflModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new USpawnDeflMod;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_USPAWNDEFLECTORMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return USPAWNDEFLMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static USpawnDeflModClassDesc USpawnDeflModDesc;
ClassDesc* GetUSpawnDeflModDesc() {return &USpawnDeflModDesc;}
//--- UniDefObject Parameter map/block descriptors ------------------

#define PB_TIMEON		0
#define PB_TIMEOFF		1
#define PB_AFFECTS		2
#define PB_BOUNCE		3
#define PB_BOUNCEVAR	4
#define PB_CHAOS		5
#define PB_FRICTION		6
#define PB_INHERIT		7
#define PB_REFRACTS		8
#define PB_DECEL		9
#define PB_DECELVAR		10
#define PB_REFRACTION	11
#define PB_REFRACTVAR	12
#define PB_DIFFUSION	13
#define PB_DIFFUSIONVAR	14
#define PB_ICONSIZE		15
#define PB_SPAWN		16
#define PB_PASSVEL		17
#define PB_PASSVELVAR	18

static ParamUIDesc descUSpawnParam[] = {
	// Time On
	ParamUIDesc(
		PB_TIMEON,
		EDITTYPE_TIME,
		IDC_EP_TIMEON,IDC_EP_TIMEONSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Time Off
	ParamUIDesc(
		PB_TIMEOFF,
		EDITTYPE_TIME,
		IDC_EP_TIMEOFF,IDC_EP_TIMEOFFSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Affects Percentage
	ParamUIDesc(
		PB_AFFECTS,
		EDITTYPE_FLOAT,
		IDC_EP_AFFECTS,IDC_EP_AFFECTSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEU,IDC_EP_BOUNCEUSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// BounceVar
	ParamUIDesc(
		PB_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEUVAR,IDC_EP_BOUNCEUVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEUCHAOS,IDC_EP_BOUNCEUCHAOSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Friction
	ParamUIDesc(
		PB_FRICTION,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEUFRICTION,IDC_EP_BOUNCEUFRICTIONSPIN,
		0.0f, 100.0f,
		0.1f),
	
	// Inherit
	ParamUIDesc(
		PB_INHERIT,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEUINHERIT,IDC_EP_BOUNCEUINHERITSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Refracts Percentage
	ParamUIDesc(
		PB_REFRACTS,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTSU,IDC_EP_REFRACTSUSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction Decel
	ParamUIDesc(
		PB_DECEL,
		EDITTYPE_FLOAT,
		IDC_EP_DECELU,IDC_EP_DECELUSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Refraction Decel Var
	ParamUIDesc(
		PB_DECELVAR,
		EDITTYPE_FLOAT,
		IDC_EP_DECELUVAR,IDC_EP_DECELUVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction
	ParamUIDesc(
		PB_REFRACTION,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTIONU,IDC_EP_REFRACTIONUSPIN,
		-100.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Refraction Var
	ParamUIDesc(
		PB_REFRACTVAR,
		EDITTYPE_FLOAT,
		IDC_EP_REFRACTUVAR,IDC_EP_REFRACTUVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Diffusion
	ParamUIDesc(
		PB_DIFFUSION,
		EDITTYPE_FLOAT,
		IDC_EP_DIFFUSIONU,IDC_EP_DIFFUSIONUSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Diffusion Var
	ParamUIDesc(
		PB_DIFFUSIONVAR,
		EDITTYPE_FLOAT,
		IDC_EP_DIFFUSIONUVAR,IDC_EP_DIFFUSIONUVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Spawns Percentage
	ParamUIDesc(
		PB_SPAWN,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNSONLY,IDC_EP_SPAWNSONLYSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Pass Velocity
	ParamUIDesc(
		PB_PASSVEL,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNONLYDECEL,IDC_EP_SPAWNONLYDECELSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Pass Velocity Var
	ParamUIDesc(
		PB_PASSVELVAR,
		EDITTYPE_FLOAT,
		IDC_EP_SPAWNSONLYDECELVAR,IDC_EP_SPAWNSONLYDECELVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_EP_ICONSIZE,IDC_EP_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	};

#define PARAMDESC_LENGTH	19

ParamBlockDescID descUSpawnVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//timeon
	{ TYPE_INT, NULL, TRUE, 1 },	//timeoff
	{ TYPE_FLOAT, NULL, TRUE, 2 },//affects
	{ TYPE_FLOAT, NULL, TRUE, 3 },//bounce
	{ TYPE_FLOAT, NULL, TRUE, 4 },//bouncevar
	{ TYPE_FLOAT, NULL, TRUE, 5 },//chaos
	{ TYPE_FLOAT, NULL, TRUE, 6 },//friction
	{ TYPE_FLOAT, NULL, TRUE, 7 },//inherit
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_FLOAT, NULL, TRUE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },
	{ TYPE_FLOAT, NULL, FALSE, 15 }};

ParamBlockDescID descUSpawnVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//timeon
	{ TYPE_INT, NULL, TRUE, 1 },	//timeoff
	{ TYPE_FLOAT, NULL, TRUE, 2 },//affects
	{ TYPE_FLOAT, NULL, TRUE, 3 },//bounce
	{ TYPE_FLOAT, NULL, TRUE, 4 },//bouncevar
	{ TYPE_FLOAT, NULL, TRUE, 5 },//chaos
	{ TYPE_FLOAT, NULL, TRUE, 6 },//friction
	{ TYPE_FLOAT, NULL, TRUE, 7 },//inherit
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_FLOAT, NULL, TRUE, 10 },
	{ TYPE_FLOAT, NULL, TRUE, 11 },
	{ TYPE_FLOAT, NULL, TRUE, 12 },
	{ TYPE_FLOAT, NULL, TRUE, 13 },
	{ TYPE_FLOAT, NULL, TRUE, 14 },
	{ TYPE_FLOAT, NULL, FALSE, 15 },
	{ TYPE_FLOAT, NULL, TRUE, 16 },
	{ TYPE_FLOAT, NULL, TRUE, 17 },
	{ TYPE_FLOAT, NULL, TRUE, 18 },
};

#define PBLOCK_LENGTH	19

static ParamVersionDesc usversions[] = {
	ParamVersionDesc(descUSpawnVer1,16,0),
	};

#define NUM_OLDVERSIONS	1
#define CURRENT_VERSION	1

static ParamVersionDesc ucurVersion(descUSpawnVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- Universal Deflect object methods -----------------------------------------
class CreateUSpawnDeflObjectProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		USpawnDeflObject *UspObj;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square,dostuff;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreateUSpawnDeflObjectProc()
			{
			ignoreSelectionChange = FALSE;
			}
		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_CREATEUSpawnDeflObjectMODE	CID_USER + 12

class CreateUSpawnDeflObjectMode : public CommandMode {		
	public:		
		CreateUSpawnDeflObjectProc proc;
		IObjParam *ip;
		USpawnDeflObject *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,USpawnDeflObject*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEUSpawnDeflObjectMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreateUSpawnDeflObjectMode theCreateUSpawnDeflObjectMode;

RefResult CreateUSpawnDeflObjectProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( UspObj && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (UspObj && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (UspObj->creating) 
						{  theCreateUSpawnDeflObjectMode.JumpStart(UspObj->ip,UspObj);
						   createInterface->SetCommandMode(&theCreateUSpawnDeflObjectMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				UspObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				UspObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				UspObj  = NULL;				
				CloudNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreateUSpawnDeflObjectProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	UspObj       = NULL;
	dostuff=0;
	CreateNewObject();
	}
void CreateUSpawnDeflObjectProc::CreateNewObject()
	{
	UspObj = (USpawnDeflObject*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
	// Start the edit params process
	if ( UspObj ) {
		UspObj->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		UspObj->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreateUSpawnDeflObjectProc::End()
{ if ( UspObj ) 
	{
#ifdef _OSNAP
	UspObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	UspObj->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete UspObj;
			UspObj = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		} 
 else if ( CloudNode ) {
			 // Get rid of the reference.
			theHold.Suspend();
			DeleteReference(0);  // sets camNode = NULL
			theHold.Resume();
			}
	}
}

void CreateUSpawnDeflObjectMode::JumpStart(IObjParam *i,USpawnDeflObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int USpawnDeflClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateUSpawnDeflObjectMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateUSpawnDeflObjectMode);
	return TRUE;
	}

int USpawnDeflClassDesc::EndCreate(Interface *i)
	{
	theCreateUSpawnDeflObjectMode.End();
	i->RemoveMode(&theCreateUSpawnDeflObjectMode);
	return TRUE;
	}

int CreateUSpawnDeflObjectProc::createmethod(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{	Point3 d;
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				UspObj->pblock->SetValue(PB_ICONSIZE,0,0.01f);
				UspObj->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				UspObj->pblock->SetValue(PB_ICONSIZE,0,(float)fabs(p1.x-p0.x));
				UspObj->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
	}

int CreateUSpawnDeflObjectProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	if (!dostuff)
	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( UspObj );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
				   		UspObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}

						// new object
						CreateNewObject();   // creates UniObj
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( UspObj);
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = NULL;
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();
					mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));
					createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
					dostuff=1;
					res = TRUE;
					break;
					
				}			
			break;

		case MOUSE_MOVE:
			//mat[3] = vpx->GetPointOnCP(m);
			mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));
			createInterface->RedrawViews(createInterface->GetTime());	   
			res = TRUE;
			break;

		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP  //PREVIEW SNAP
			res = createmethod(vpx,msg,point,flag,m,mat);
#endif
		vpx->TrackImplicitGrid(m);
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: goto abort;
		}
	int result; 
	if (dostuff)
	{ result=createmethod(vpx,msg,point,flag,m,mat);
//	  UspObj->BuildEmitter(createInterface->GetTime(),UspObj->);
	  createInterface->RedrawViews(createInterface->GetTime()); 
	  if (result==CREATE_STOP)
	  { res=FALSE;dostuff=0;				
#ifdef _OSNAP
         UspObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	  theHold.Accept(GetString(IDS_EP_CREATE));	} 
	  else if (result==CREATE_ABORT)
	  { dostuff=0;
	    goto abort;}
	}
	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
	abort:
		assert( UspObj );
#ifdef _OSNAP
		UspObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		UspObj->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);
		CloudNode = NULL;			
		createInterface->RedrawViews(createInterface->GetTime()); 
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		goto done;
	}
static BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

BOOL UniPickOperand::Filter(INode *node)
	{
	if ((node)&&(!node->IsGroupHead())) {
		ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
		if (os.obj->IsParticleSystem() || os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
			node = NULL;
			return FALSE;
			}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
			}
		}

	return node ? TRUE : FALSE;
	}

BOOL UniPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if ((node)&&(node->IsGroupHead())) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		if ((os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID)||(!IsGEOM(os.obj))) {
			node = NULL;
			return FALSE;
			}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
		}
	}
	return node ? TRUE : FALSE;
	}

void USpawnDeflObject::ShowName()
{TSTR name; 
 FormatName(name= TSTR(GetString(IDS_EP_ITEMSTR)) + (custnode ? custname : TSTR(GetString(IDS_EP_NONE))));
SetWindowText(GetDlgItem(hParams, IDC_EP_PICKNAME), name);
}

BOOL UniPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{BOOL groupflag=0;
	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	if (node->IsGroupMember()) 
	{ groupflag=1;
	  while (node->IsGroupMember()) node=node->GetParentNode();
	}
	int subtree=0;
	if (groupflag) MakeGroupNodeList(node,&nodes,subtree,ip->GetTime());
	else{ nodes.SetCount(1);nodes[0]=node;}
	ip->FlashNodes(&nodes);
	theHold.Begin();
	theHold.Put(new CreateUSpawnDeflPickNode(po,node));

//	po->custnode=node;
	if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	theHold.Accept(GetString(IDS_EP_USPPICK));
	po->custname = TSTR(node->GetName());
	// Automatically check show result and do one update
	po->ShowName();	
	if (po->creating) {
		theCreateUSpawnDeflObjectMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreateUSpawnDeflObjectMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void UniPickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_EP_PICKBUTTON));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
	}

void UniPickOperand::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_EP_PICKBUTTON));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
	}
class USpawnDeflObjectDlgProc : public ParamMapUserDlgProc {
	public:
		USpawnDeflObject *po;

		USpawnDeflObjectDlgProc(USpawnDeflObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
		void Update(TimeValue t);
	};
void USpawnDeflObjectDlgProc::Update(TimeValue t)
{	po->ShowName();
	float size;
	po->pblock->GetValue(PB_ICONSIZE,0,size,FOREVER);
	TurnButton(po->hParams,IDC_EP_PICKBUTTON,(size>=0.01f));
}
BOOL USpawnDeflObjectDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	switch (msg) {
		case WM_INITDIALOG: {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_EP_PICKBUTTON));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(iBut);
			po->hParams=hWnd;
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{    case IDC_EP_PICKBUTTON:
				   { if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateUSpawnDeflObjectMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateUSpawnDeflObjectMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;						
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}

			}
			break;	
		}
	return TRUE;
	}

USpawnDeflObject::USpawnDeflObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descUSpawnVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_TIMEON,0,0);
	pblock->SetValue(PB_TIMEOFF,0,100*GetTicksPerFrame());
	pblock->SetValue(PB_AFFECTS,0,1.0f);
	pblock->SetValue(PB_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BOUNCEVAR,0,0.0f);
	pblock->SetValue(PB_CHAOS,0,0.0f);
	pblock->SetValue(PB_FRICTION,0,0.0f);
	pblock->SetValue(PB_INHERIT,0,1.0f);
	pblock->SetValue(PB_REFRACTS,0,1.0f);
	pblock->SetValue(PB_DECEL,0,1.0f);
	pblock->SetValue(PB_DECELVAR,0,0.0f);
	pblock->SetValue(PB_REFRACTION,0,0.5f);
	pblock->SetValue(PB_REFRACTVAR,0,0.0f);
	pblock->SetValue(PB_DIFFUSION,0,0.0f);
	pblock->SetValue(PB_DIFFUSIONVAR,0,0.0f);
	pblock->SetValue(PB_SPAWN,0,1.0f);
	pblock->SetValue(PB_PASSVEL,0,1.0f);
	pblock->SetValue(PB_PASSVELVAR,0,0);
	pblock->SetValue(PB_ICONSIZE,0,0.0f);
	dmesh=NULL;
	vnorms=NULL;
	fnorms=NULL;
	srand(lastrnd=12345);
	t=99999;
	custname=TSTR(_T(" "));
	custnode=NULL;
	nv=0;nf=0;
	}

USpawnDeflObject::~USpawnDeflObject()
{   DeleteAllRefsFromMe();
	if (vnorms) delete[] vnorms;
	if (fnorms) delete[] fnorms;
   if (dmesh) delete dmesh;
}
Modifier *USpawnDeflObject::CreateWSMMod(INode *node)
	{
	return new USpawnDeflMod(node,this);
	}

RefTargetHandle USpawnDeflObject::Clone(RemapDir& remap) 
	{
	USpawnDeflObject* newob = new USpawnDeflObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	newob->custname=custname;
	newob->dmesh=NULL;
	newob->vnorms=NULL;
	newob->fnorms=NULL;
	return newob;
	}

void USpawnDeflObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC),
			DefaultSOTProc,
			GetString(IDS_EP_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descUSpawnParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_AP_USPAWNDEFL),
			GetString(IDS_EP_PARAMETERS),
			0);
		}
		if (pmapParam)
			pmapParam->SetUserDlgProc(new USpawnDeflObjectDlgProc(this));
	}

void USpawnDeflObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
	}

void USpawnDeflObject::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_TIMEON,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEON,0,TempTime);
	pblock->GetValue(PB_TIMEOFF,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEOFF,0,TempTime);
}  

void USpawnDeflObject::BuildMesh(TimeValue t)
	{
	ivalid = FOREVER;
	float length,l,r2,r3,r4;
	pblock->GetValue(PB_ICONSIZE,t,length,ivalid);
	l=length*0.5f;
	r2=0.5f*l;
	r3=0.25f*r2;
	r4=0.71f*r3;

	mesh.setNumVerts(28);
	mesh.setNumFaces(22);

	mesh.setVert(0,Point3( l, l, l));
	mesh.setVert(1,Point3( l, l,-l));
	mesh.setVert(2,Point3( l,-l, l));
	mesh.setVert(3,Point3( l,-l,-l));
	mesh.setVert(4,Point3(-l, l, l));
	mesh.setVert(5,Point3(-l, l,-l));
	mesh.setVert(6,Point3(-l,-l, l));
	mesh.setVert(7,Point3(-l,-l,-l));

	mesh.setVert( 8,Point3(0.0f, 0.0f , l      ));//a
	mesh.setVert( 9,Point3(0.0f, 0.0f , l+r2   ));//b
	mesh.setVert(10,Point3(0.0f, -r2  , l-r2   ));//c
	mesh.setVert(11,Point3(0.0f,  r2  , l-r2   ));//d
	mesh.setVert(12,Point3(0.0f,  r4  , l+r4));//b1
	mesh.setVert(13,Point3(0.0f, -r4  , l+r4));//b2
	mesh.setVert(14,Point3(0.0f, -r2  , l-r2+r3));//c1
	mesh.setVert(15,Point3(0.0f,-r2+r3, l-r2   ));//c2
	mesh.setVert(16,Point3(0.0f, r2-r3, l-r2   ));//d1
	mesh.setVert(17,Point3(0.0f,  r2  , l-r2+r3));//d2
	
	mesh.setVert(18,Point3(0.0f, 0.0f ,-l      ));//a
	mesh.setVert(19,Point3(0.0f, 0.0f ,-l-r2   ));//b
	mesh.setVert(20,Point3(0.0f, -r2  ,-l+r2   ));//c
	mesh.setVert(21,Point3(0.0f,  r2  ,-l+r2   ));//d
	mesh.setVert(22,Point3(0.0f,  r4  ,-l-r4));//b1
	mesh.setVert(23,Point3(0.0f, -r4  ,-l-r4));//b2
	mesh.setVert(24,Point3(0.0f, -r2  ,-l+r2-r3));//c1
	mesh.setVert(25,Point3(0.0f,-r2+r3,-l+r2   ));//c2
	mesh.setVert(26,Point3(0.0f, r2-r3,-l+r2   ));//d1
	mesh.setVert(27,Point3(0.0f,  r2  ,-l+r2-r3));//d2

	mesh.faces[0].setVerts(1,0,2);
	mesh.faces[0].setEdgeVisFlags(1,1,0);
	mesh.faces[0].setSmGroup(0);
	mesh.faces[1].setVerts(2,3,1);
	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(0);
	mesh.faces[2].setVerts(2,0,4);
	mesh.faces[2].setEdgeVisFlags(1,1,0);
	mesh.faces[2].setSmGroup(0);
	mesh.faces[3].setVerts(4,6,2);
	mesh.faces[3].setEdgeVisFlags(1,1,0);
	mesh.faces[3].setSmGroup(0);
	mesh.faces[4].setVerts(3,2,6);
	mesh.faces[4].setEdgeVisFlags(1,1,0);
	mesh.faces[4].setSmGroup(0);
	mesh.faces[5].setVerts(6,7,3);
	mesh.faces[5].setEdgeVisFlags(1,1,0);
	mesh.faces[5].setSmGroup(0);
	mesh.faces[6].setVerts(7,6,4);
	mesh.faces[6].setEdgeVisFlags(1,1,0);
	mesh.faces[6].setSmGroup(0);
	mesh.faces[7].setVerts(4,5,7);
	mesh.faces[7].setEdgeVisFlags(1,1,0);
	mesh.faces[7].setSmGroup(0);
	mesh.faces[8].setVerts(4,0,1);
	mesh.faces[8].setEdgeVisFlags(1,1,0);
	mesh.faces[8].setSmGroup(0);
	mesh.faces[9].setVerts(1,5,4);
	mesh.faces[9].setEdgeVisFlags(1,1,0);
	mesh.faces[9].setSmGroup(0);
	mesh.faces[10].setVerts(1,3,7);
	mesh.faces[10].setEdgeVisFlags(1,1,0);
	mesh.faces[10].setSmGroup(0);
	mesh.faces[11].setVerts(7,5,1);
	mesh.faces[11].setEdgeVisFlags(1,1,0);
	mesh.faces[11].setSmGroup(0);

	mesh.faces[12].setEdgeVisFlags(1,0,1);
	mesh.faces[12].setSmGroup(0);
	mesh.faces[12].setVerts(18,21,19);
	mesh.faces[13].setEdgeVisFlags(1,0,1);
	mesh.faces[13].setSmGroup(0);
	mesh.faces[13].setVerts(18,20,19);
	mesh.faces[14].setEdgeVisFlags(1,1,1);
	mesh.faces[14].setSmGroup(0);
	mesh.faces[14].setVerts(18,23,22);
	mesh.faces[15].setEdgeVisFlags(1,1,1);
	mesh.faces[15].setSmGroup(0);
	mesh.faces[15].setVerts(20,24,25);
	mesh.faces[16].setEdgeVisFlags(1,1,1);
	mesh.faces[16].setSmGroup(0);
	mesh.faces[16].setVerts(21,27,26);

	mesh.faces[17].setEdgeVisFlags(1,0,1);
	mesh.faces[17].setSmGroup(0);
	mesh.faces[17].setVerts(8,11,9);
	mesh.faces[18].setEdgeVisFlags(1,0,1);
	mesh.faces[18].setSmGroup(0);
	mesh.faces[18].setVerts(8,10,9);
	mesh.faces[19].setEdgeVisFlags(1,1,1);
	mesh.faces[19].setSmGroup(0);
	mesh.faces[19].setVerts(8,13,12);
	mesh.faces[20].setEdgeVisFlags(1,1,1);
	mesh.faces[20].setSmGroup(0);
	mesh.faces[20].setVerts(10,14,15);
	mesh.faces[21].setEdgeVisFlags(1,1,1);
	mesh.faces[21].setSmGroup(0);
	mesh.faces[21].setVerts(11,17,16);

	mesh.InvalidateGeomCache();
	}

void USpawnDeflObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *USpawnDeflObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_TIMEON:			return stdTimeDim;
		case PB_TIMEOFF:		return stdTimeDim;
		case PB_AFFECTS:		return stdPercentDim;
		case PB_BOUNCEVAR:		return stdPercentDim;
		case PB_CHAOS:			return stdPercentDim;
		case PB_REFRACTS:		return stdPercentDim;
		case PB_DECELVAR:		return stdPercentDim;
		case PB_REFRACTION:		return stdPercentDim;
		case PB_REFRACTVAR:		return stdPercentDim;
		case PB_DIFFUSION:		return stdPercentDim;
		case PB_DIFFUSIONVAR:	return stdPercentDim;
		case PB_SPAWN:			return stdPercentDim;
		case PB_PASSVELVAR:		return stdPercentDim;
		default: return defaultDim;
		}
	}

TSTR USpawnDeflObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_TIMEON:			return GetString(IDS_EP_TIMEON);
		case PB_TIMEOFF:		return GetString(IDS_EP_TIMEOFF);
		case PB_AFFECTS:		return GetString(IDS_EP_AFFECTS);
		case PB_BOUNCE:			return GetString(IDS_EP_BOUNCE);
		case PB_BOUNCEVAR:		return GetString(IDS_EP_BOUNCEVAR);
		case PB_CHAOS:			return GetString(IDS_EP_CHAOS);
		case PB_FRICTION:		return GetString(IDS_EP_FRICTION);
		case PB_INHERIT:		return GetString(IDS_EP_INHERIT);
		case PB_REFRACTS:		return GetString(IDS_EP_REFRACTS);
		case PB_DECEL:			return GetString(IDS_EP_PASSVEL);
		case PB_DECELVAR:		return GetString(IDS_EP_PASSVELVAR);
		case PB_REFRACTION:		return GetString(IDS_EP_REFRACTION);
		case PB_REFRACTVAR:		return GetString(IDS_EP_REFRACTVAR);
		case PB_DIFFUSION:		return GetString(IDS_EP_DIFFUSION);
		case PB_DIFFUSIONVAR:	return GetString(IDS_EP_DIFFUSIONVAR);
		case PB_ICONSIZE:		return GetString(IDS_EP_ICONSIZE);
		case PB_SPAWN:			return GetString(IDS_AP_SPAWN);
		case PB_PASSVEL:		return GetString(IDS_AP_PASSVEL);
		case PB_PASSVELVAR:		return GetString(IDS_AP_PASSVELVAR);
		default:				return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

USpawnDeflMod::USpawnDeflMod(INode *node,USpawnDeflObject *obj)
	{	
//	MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
		pblock = NULL;
	obRef=NULL;
	}

Interval USpawnDeflMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		USpawnDeflObject *obj = (USpawnDeflObject*)GetWSMObject(t);
		TimeValue TempT;
		obj->pblock->GetValue(PB_TIMEOFF,t,TempT,valid);
		obj->pblock->GetValue(PB_AFFECTS,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,f,valid);
		obj->pblock->GetValue(PB_CHAOS,t,f,valid);
		obj->pblock->GetValue(PB_FRICTION,t,f,valid);
		obj->pblock->GetValue(PB_INHERIT,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTS,t,f,valid);
		obj->pblock->GetValue(PB_DECEL,t,f,valid);
		obj->pblock->GetValue(PB_DECELVAR,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTION,t,f,valid);
		obj->pblock->GetValue(PB_REFRACTVAR,t,f,valid);
		obj->pblock->GetValue(PB_DIFFUSION,t,f,valid);
		obj->pblock->GetValue(PB_DIFFUSIONVAR,t,f,valid);
		obj->pblock->GetValue(PB_ICONSIZE,t,f,valid);
		obj->pblock->GetValue(PB_SPAWN,t,f,valid);
		obj->pblock->GetValue(PB_PASSVEL,t,f,valid);
		obj->pblock->GetValue(PB_PASSVELVAR,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		
		return valid;
	} else {
		return FOREVER;
		}
	}

class USpawnDeflDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static USpawnDeflDeformer USpawnddeformer;

Deformer& USpawnDeflMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return USpawnddeformer;
	}

RefTargetHandle USpawnDeflMod::Clone(RemapDir& remap) 
	{
	USpawnDeflMod *newob = new USpawnDeflMod(nodeRef,(USpawnDeflObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}

void USpawnDeflMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (USpawnDeflObject*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.obj->tmValid.SetEmpty();		
		deflect.obj->mValid.SetEmpty();
		deflect.badmesh=(deflect.obj->custnode==NULL);
		if (t<=deflect.obj->t) deflect.obj->lastrnd=12345;
		deflect.obj->t=t;
/*		if (deflect.obj->dmesh) delete deflect.obj->dmesh;
		deflect.obj->dmesh=NULL;
		deflect.obj->vnorms.ZeroCount();deflect.obj->vnorms.Shrink();
		deflect.obj->fnorms.ZeroCount();deflect.obj->fnorms.Shrink();
		deflect.obj->nv=0;deflect.obj->nf=0;
		*/
		deflect.obj->dvel=Zero;
		obj->ApplyCollisionObject(&deflect);
		}
	}
 static TriObject *IsUseable(Object *pobj,TimeValue t)
{ 
  if (pobj->SuperClassID()==GEOMOBJECT_CLASS_ID)
  {	if (pobj->IsSubClassOf(triObjectClassID)) 
      return (TriObject*)pobj;
    else 
	{ if (pobj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)pobj->ConvertToType(t,triObjectClassID);			
	}
  }
  return NULL;
}

#define EPSILON	0.0001f

void AddMesh(USpawnDeflObject *obj,TriObject *triOb,Matrix3 tm,BOOL nottop)
{ int lastv=obj->nv,lastf=obj->nf;
  obj->nv+=triOb->GetMesh().getNumVerts();
  obj->nf+=triOb->GetMesh().getNumFaces();
  if (!nottop)
    obj->dmesh->DeepCopy(&triOb->GetMesh(),PART_GEOM|PART_TOPO);
  else
  {obj->dmesh->setNumFaces(obj->nf,obj->dmesh->getNumFaces());
   obj->dmesh->setNumVerts(obj->nv,obj->dmesh->getNumVerts());
   tm=tm*obj->invtm;
   for (int vc=0;vc<triOb->GetMesh().getNumFaces();vc++)
   { obj->dmesh->faces[lastf]=triOb->GetMesh().faces[vc];
     for (int vs=0;vs<3;vs++) 
	   obj->dmesh->faces[lastf].v[vs]+=lastv;
     lastf++;}
  }
   for (int vc=0;vc<triOb->GetMesh().getNumVerts();vc++)
   { if (nottop) obj->dmesh->verts[lastv]=triOb->GetMesh().verts[vc]*tm;
	 else obj->dmesh->verts[lastv]=triOb->GetMesh().verts[vc];
     lastv++;}
}  

Object *USpawnDeflField::GetSWObject()
{ return obj;
}

BOOL USpawnDeflField::CheckCollision(TimeValue t,Point3 &inp,Point3 &vel,float dt,int index,float *ct,BOOL UpdatePastCollide)
{ 	if (badmesh) 
		return(0);
	if (!((obj->mValid.InInterval(t))&&(obj->tmValid.InInterval(t))))
	{	obj->tmValid=FOREVER;
		obj->tm=obj->custnode->GetObjectTM(t,&obj->tmValid);
		obj->tmNoTrans=obj->tm;
		obj->tmNoTrans.NoTrans();
//		obj->tm.NoScale();
//		obj->tmNoTrans.NoScale();
		obj->invtm=Inverse(obj->tm);
		obj->invtmNoTrans=Inverse(obj->tmNoTrans);
		if (obj->dmesh) delete obj->dmesh;
		obj->dmesh=new Mesh;obj->dmesh->setNumFaces(0);
		if (obj->vnorms) {delete[] obj->vnorms;obj->vnorms=NULL;}
		if (obj->fnorms) {delete[] obj->fnorms;obj->fnorms=NULL;}
		obj->nv=(obj->nf=0);
		Interval tmpValid=FOREVER;
		obj->ptm=obj->custnode->GetObjectTM(t+(TimeValue)dt,&tmpValid);
		obj->dvel=(Zero*obj->ptm-Zero*obj->tm)/dt;
		Object *pobj; 
		pobj = obj->custnode->EvalWorldState(t).obj;
		obj->mValid=pobj->ObjectValidity(t);
		TriObject *triOb=NULL;
		badmesh=TRUE;
		if ((triOb=IsUseable(pobj,t))!=NULL) AddMesh(obj,triOb,obj->tm,FALSE);
		if (obj->custnode->IsGroupHead())
		{	 for (int ch=0;ch<obj->custnode->NumberOfChildren();ch++)
			{   INode *cnode=obj->custnode->GetChildNode(ch);
				if (cnode->IsGroupMember())
				{	pobj = cnode->EvalWorldState(t).obj;
					if ((triOb=IsUseable(pobj,t))!=NULL)
					{	Matrix3 tm=cnode->GetObjectTM(t,&obj->tmValid);
						obj->mValid=obj->mValid & pobj->ObjectValidity(t);
						AddMesh(obj,triOb,tm,TRUE);
					}
				}
			}
		}
		if (obj->nf>0)
		{	obj->vnorms=new VNormal[obj->nv];
			obj->fnorms=new Point3[obj->nf];
			GetVFLst(obj->dmesh,obj->vnorms,obj->fnorms);
			badmesh=FALSE;
		}
		if ((triOb)&&(triOb!=pobj)) triOb->DeleteThis();
 	}
	if (badmesh) 
		return 0;

// test for time limits
	TimeValue startt,endt;
	obj->pblock->GetValue(PB_TIMEON,t,startt,FOREVER);
	obj->pblock->GetValue(PB_TIMEOFF,t,endt,FOREVER);
	if ((t<startt)||(t>endt))
	{	obj->lastrnd=rand();
		return FALSE;
	}

    srand(obj->lastrnd);
	float pvel,at,vinher,friction,TempDP;
	Point3 NVrelL,Vrel,VrelL,pos,norm;

// test for reflection
	float affectsthisportion;
	obj->pblock->GetValue(PB_AFFECTS,t,affectsthisportion,FOREVER);
	if (RND01()<affectsthisportion)
	{	pos=inp*obj->invtm;
		Vrel=vel-obj->dvel;
		pvel=Length(Vrel);
		VrelL=Vrel*obj->invtmNoTrans;
		NVrelL=Normalize(VrelL);
		Ray ray;
		ray.dir=NVrelL;
		ray.p=pos;
		int kfound=RayIntersectP(ray,at,norm,obj->dmesh,obj->vnorms,obj->fnorms);
		if (!kfound)
		{	obj->lastrnd=rand();
			return FALSE;
		}
		Point3 id,iw=(id=pos+at*NVrelL)*obj->tm;
		float delta=Length(iw-inp);
		if (delta>dt*pvel)
		{	obj->lastrnd=rand();
			return FALSE;
		}
		float bounce,bvar,chaos;
		obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,bvar,FOREVER);
		obj->pblock->GetValue(PB_CHAOS,t,chaos,FOREVER);
		obj->pblock->GetValue(PB_INHERIT,t,vinher,FOREVER);
		obj->pblock->GetValue(PB_FRICTION,t,friction,FOREVER);

		float dti=delta/pvel;
		Point3 wnorm=norm*obj->tmNoTrans;
		Point3 Vt,c2,c1,Vreln=Vrel/pvel;
		Point3 Vdirbase=Normalize(Vreln);
		float q1=DotProd(-Vdirbase,wnorm);
		float theta=(float)acos(q1);
		if (theta>=HalfPI) 
			theta-=PI;
		if (theta<FLOAT_EPSILON)
			vel=-vel;
		else 
		{	c1=Normalize((-vel)^wnorm);
			c2=Normalize(wnorm^c1);
			vel=-vel;
			Vt=c2*DotProd(c2,vel);
			RotateOnePoint(&vel.x,&Zero.x,&c1.x,2*theta);
			vel=vel+friction*Vt;
		}
		vel=vel*bounce*(1-bvar*RND01());
		if (!FloatEQ0(chaos))
		{	theta=(HalfPI-theta)*chaos*RND01();
			Point3 d=Point3(RND11(),RND11(),RND11());
			Point3 c=Normalize(vel^d);
			RotateOnePoint(&vel.x,&Zero.x,&c.x,theta);
		}
		if (vinher>0.0f)
		{	Point3 dvel=obj->dvel*vinher; 
			vel=vel+friction*dvel+(1-friction)*DotProd(dvel,wnorm)*wnorm;
		}
		if (UpdatePastCollide)
		{	inp = iw + (dt-dti)*vel;
			if (ct) (*ct) = dt;
		}
		else
		{	inp = iw;
			if (ct) (*ct) = dti;
		}
		obj->lastrnd=rand();
		return TRUE;
	}

// test for refraction
	float refracts;
	obj->pblock->GetValue(PB_REFRACTS,t,refracts,FOREVER);
	if (RND01()<refracts)
	{	pos=inp*obj->invtm;
		Vrel=vel-obj->dvel;
		pvel=Length(Vrel);
		VrelL=Vrel*obj->invtmNoTrans;
		NVrelL=Normalize(VrelL);
		Ray ray;
		ray.dir=NVrelL;
		ray.p=pos;
		int kfound=RayIntersectP(ray,at,norm,obj->dmesh,obj->vnorms,obj->fnorms);
		if (!kfound)
		{	obj->lastrnd=rand();
			return FALSE;
		}
		Point3 id,iw=(id=pos+at*NVrelL)*obj->tm;
		float delta=Length(iw-inp);
		if (delta>dt*pvel)
		{	obj->lastrnd=rand();
			return FALSE;
		}
// refraction code
		float refvol,refvar,decel,decelvar;
		obj->pblock->GetValue(PB_REFRACTION,t,refvol,FOREVER);
		obj->pblock->GetValue(PB_REFRACTVAR,t,refvar,FOREVER);
		obj->pblock->GetValue(PB_DECEL,t,decel,FOREVER);
		obj->pblock->GetValue(PB_DECELVAR,t,decelvar,FOREVER);
		obj->pblock->GetValue(PB_INHERIT,t,vinher,FOREVER);
		obj->pblock->GetValue(PB_FRICTION,t,friction,FOREVER);

		float dti=delta/pvel;
		Point3 wnorm=norm*obj->tmNoTrans;
		Point3 Vt,c2,c1,Vreln=Vrel/pvel;
		Point3 Vdirbase=Normalize(Vreln);
		float q1=DotProd(-Vdirbase,wnorm);
		float theta=(float)acos(q1);
		if (theta>=HalfPI) theta-=PI;
		Point3 Drag;
		c1=Normalize((-vel)^wnorm);
		c2=Normalize(wnorm^c1);
		Drag=friction*c2*DotProd(c2,-vel);
// reduce v by decel parameters
		vel*=decel*(1.0f-decelvar*RND01());
// rotate velocity vector
		float maxref,refangle,maxvarref;
	refangle=0.0f;
		if (!FloatEQ0(refvol))
		{	if (refvol>0.0f)
				maxref=-theta;
			else 
				maxref=HalfPI-theta;
			refangle=maxref*(float)fabs(refvol);
			float frefangle=(float)fabs(refangle);
			if (refvol>0.0f)
				maxvarref=HalfPI-theta-frefangle;
			else
				maxvarref=theta-frefangle;
			refangle+=maxvarref*RND11()*refvar;
			Point3 c,d;
			if (theta<0.01f)
			{	d=Point3(RND11(),RND11(),RND11());
				c=Normalize(vel^d);
			}
			else
			{	c=Normalize(wnorm^(-vel));
			}
			RotateOnePoint(vel,&Zero.x,&c.x,refangle);
			TempDP=DotProd(vel,wnorm);
			if (TempDP>0.0f) vel=vel-TempDP*wnorm;
		}
		float maxdiff,diffuse,diffvar,diffangle;
		obj->pblock->GetValue(PB_DIFFUSION,t,diffuse,FOREVER);
		obj->pblock->GetValue(PB_DIFFUSIONVAR,t,diffvar,FOREVER);
		maxdiff=HalfPI-theta-refangle;
		if (!FloatEQ0(diffuse))
		{	Point3 d=Point3(RND11(),RND11(),RND11());
			Point3 c=Normalize(vel^d);
			diffangle=0.5f*maxdiff*diffuse*(1.0f+RND11()*diffvar);
			RotateOnePoint(vel,&Zero.x,&c.x,diffangle);
			TempDP=DotProd(vel,wnorm);
			if (TempDP>0.0f) vel=vel-TempDP*wnorm;
		}
		if (vinher>0.0f)
		{	Point3 dvel=obj->dvel*vinher; 
			vel=vel+friction*dvel+(1.0f-friction)*DotProd(dvel,wnorm)*wnorm;
		}
		vel+=Drag;
		if (UpdatePastCollide)
		{	inp = iw + (dt-dti)*vel;
			if (ct) (*ct) = dt;
		}
		else
		{	inp = iw;
			if (ct) (*ct) = dti;
		}
		obj->lastrnd=rand();
		return TRUE;
	}

// test for spawning only
	float spawnonly;
	obj->pblock->GetValue(PB_SPAWN,t,spawnonly,FOREVER);
	if (RND01()<spawnonly)
	{	pos=inp*obj->invtm;
		Vrel=vel-obj->dvel;
		pvel=Length(Vrel);
		VrelL=Vrel*obj->invtmNoTrans;
		NVrelL=Normalize(VrelL);
		Ray ray;
		ray.dir=NVrelL;
		ray.p=pos;
		int kfound=RayIntersectP(ray,at,norm,obj->dmesh,obj->vnorms,obj->fnorms);
		if (!kfound)
		{	obj->lastrnd=rand();
			return FALSE;
		}
		Point3 iw=(pos+at*NVrelL)*obj->tm;
		float delta=Length(iw-inp);
		if (delta>dt*pvel)
		{	obj->lastrnd=rand();
			return FALSE;
		}
		float passvel,passvelvar;
		float dti=delta/pvel;
		obj->pblock->GetValue(PB_PASSVEL,t,passvel,FOREVER);
		obj->pblock->GetValue(PB_PASSVELVAR,t,passvelvar,FOREVER);
		vel *= passvel*(1.0f+passvelvar*RND11());
		if (UpdatePastCollide)
		{	inp = iw + (dt-dti)*vel;
			if (ct) (*ct) = dt;
		}
		else
		{	inp = iw;
			if (ct) (*ct) = dti;
		}
		return TRUE;		
	}

// nothing happens
	obj->lastrnd=rand();
	return FALSE;
}

RefTargetHandle USpawnDeflObject::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		default: return NULL;
		}
	}

void USpawnDeflObject::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		}
	}

RefResult USpawnDeflObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode) custnode=NULL;
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				}
			  break;
			}
		default: SimpleWSMObject::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}

#define USPDEF_CUSTNAME_CHUNK	0x0100

IOResult USpawnDeflObject::Save(ISave *isave)
	{
	isave->BeginChunk(USPDEF_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();
	return IO_OK;
	}

class USpawnDeflPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		USpawnDeflPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((USpawnDeflObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) {	
 				((USpawnDeflObject*)targ)->pblock->SetValue(PB_SPAWN,0,1.0f);
 				((USpawnDeflObject*)targ)->pblock->SetValue(PB_PASSVEL,0,1.0f);
 				((USpawnDeflObject*)targ)->pblock->SetValue(PB_PASSVELVAR,0,0);
				}
			delete this;
			}
	};

IOResult USpawnDeflObject::Load(ILoad *iload)
	{
	IOResult res = IO_OK;
	
	iload->RegisterPostLoadCallback(
		new USpawnDeflPostLoadCallback(
		new ParamBlockPLCB(usversions,NUM_OLDVERSIONS,&ucurVersion,this,0)));

	// Default names
	custname = TSTR(_T(" "));

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case USPDEF_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\sflectrs\udyflect.cpp ===
/**********************************************************************
 *<
	FILE: udyflect.cpp

	DESCRIPTION: Turns Any Mesh Into a DynaFlector

	CREATED BY: Eric Peterson from Audrey's UDeflector code

	HISTORY: 7/97

 **********************************************************************/
#include "sflectr.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"
#include "interpik.h"

#define PBLK		0
#define CUSTNODE 	1

static Point3 Zero=Point3(0.0f,0.0f,0.0f);
static Class_ID UDYNADEFL_CLASS_ID(0x685771aa, 0x678144bd);
static Class_ID UDYNADEFLMOD_CLASS_ID(0xcc400b8, 0x8732e2f);

class UnjPickOperand; 

const float dymin=0.0001f;

class UDynaDeflObject : public DynamModObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		static HWND hParams;

		int lastrnd;
		TimeValue t;
		INode *custnode;
		TSTR custname;
		UDynaDeflObject();
		~UDynaDeflObject();
		BOOL SupportsDynamics() {return TRUE;}
		Mesh *dmesh;
		int nv,nf;
		VNormal *vnorms;
		Point3 *fnorms;
		Matrix3 tm,ptm,invtm,tmNoTrans,invtmNoTrans;
		Interval tmValid,mValid;
		Point3 dvel;

		static BOOL creating;
		static UnjPickOperand pickCB;

		void ShowName();
		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);
		Class_ID ClassID() {return UDYNADEFL_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_UDYNADEFLECTOR);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}

		// From BaseObject
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		FlectForces ForceData(TimeValue t);
		FlectForces ffdata;	
		TimeValue ctime;
	};

class UnjPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		UDynaDeflObject *po;
		
		UnjPickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};

class CreateUDynaDeflPickNode : public RestoreObj {
	public:   		
		UDynaDeflObject *obj;
		INode *oldn;
		CreateUDynaDeflPickNode(UDynaDeflObject *o, INode *n) {
			obj = o; oldn=n;
			}
		void Restore(int isUndo) {
			if (obj->custnode) 
			{ obj->custname = TSTR(obj->custnode->GetName());
			}
			else 
			{ obj->custname=TSTR(_T(""));
			}
			obj->ShowName();
			}
		void Redo() 
		{ obj->custname = TSTR(oldn->GetName());
		if (obj->hParams)
	{TSTR name=TSTR(GetString(IDS_EP_OBJECTSTR)) + (oldn ? obj->custname : TSTR(GetString(IDS_EP_NONE)));
	SetWindowText(GetDlgItem(obj->hParams, IDC_EP_PICKNAME), name);
		}
			}
		TSTR Description() {return GetString(IDS_EP_USPPICK);}
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *UDynaDeflObject::ip        = NULL;
IParamMap *UDynaDeflObject::pmapParam = NULL;
HWND       UDynaDeflObject::hSot      = NULL;
HWND       UDynaDeflObject::hParams      = NULL;
BOOL UDynaDeflObject::creating    = FALSE;
UnjPickOperand UDynaDeflObject::pickCB;

class UDynaDeflClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new UDynaDeflObject;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_UDYNADEFLECTOR);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return UDYNADEFL_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_DYNAMICS);}
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};
static UDynaDeflClassDesc UDynaDeflDesc;
ClassDesc* GetUDynaDeflObjDesc() {return &UDynaDeflDesc;}

//--- DeflectMod -----------------------------------------------------

class UDynaDeflField : public CollisionObject {
	public:		
		UDynaDeflObject *obj;
		INode *node;
		int badmesh;
		Point3 totalforce,applyat;
		int totalnumber;
		TimeValue curtime;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class UDynaDeflMod : public SimpleWSMMod {
	public:				
		UDynaDeflField deflect;

		UDynaDeflMod() {deflect.curtime=NoAni;}
		UDynaDeflMod(INode *node,UDynaDeflObject *obj);	


		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_EP_UDYNADEFLECTORMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return UDYNADEFLMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_EP_UDYNADEFLECTORBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class UDynaDeflModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new UDynaDeflMod;}
	const TCHAR *	ClassName() {return GetString(IDS_EP_UDYNADEFLECTORMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return UDYNADEFLMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static UDynaDeflModClassDesc UDynaDeflModDesc;
ClassDesc* GetUDynaDeflModDesc() {return &UDynaDeflModDesc;}
//--- UnjDefObject Parameter map/block descriptors ------------------

#define PB_TIMEON		0
#define PB_TIMEOFF		1
#define PB_AFFECTS		2
#define PB_BOUNCE		3
#define PB_BOUNCEVAR	4
#define PB_CHAOS		5
#define PB_FRICTION		6
#define PB_INHERIT		7
#define PB_ICONSIZE		8
#define PB_MASS			9
#define PB_MASSUNITS	10
#define PB_FORCEX		11
#define PB_FORCEY		12
#define PB_FORCEZ		13
#define PB_APPLYX		14
#define PB_APPLYY		15
#define PB_APPLYZ		16
#define PB_NUMBER		17

static int massUunitsIDs[] = {IDC_EP_MASSGM,IDC_EP_MASSKG,IDC_EP_MASSLBM};

static ParamUIDesc descUDynaParam[] = {
	// Time On
	ParamUIDesc(
		PB_TIMEON,
		EDITTYPE_TIME,
		IDC_EP_TIMEON,IDC_EP_TIMEONSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Time Off
	ParamUIDesc(
		PB_TIMEOFF,
		EDITTYPE_TIME,
		IDC_EP_TIMEOFF,IDC_EP_TIMEOFFSPIN,
		-999999999.0f, 999999999.0f,
		10.0f),
	
	// Affects Percentage
	ParamUIDesc(
		PB_AFFECTS,
		EDITTYPE_FLOAT,
		IDC_EP_AFFECTS,IDC_EP_AFFECTSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEU,IDC_EP_BOUNCEUSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// BounceVar
	ParamUIDesc(
		PB_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEUVAR,IDC_EP_BOUNCEUVARSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEUCHAOS,IDC_EP_BOUNCEUCHAOSSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),
	
	// Friction
	ParamUIDesc(
		PB_FRICTION,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEUFRICTION,IDC_EP_BOUNCEUFRICTIONSPIN,
		0.0f, 100.0f,
		0.1f),
	
	// Inherit
	ParamUIDesc(
		PB_INHERIT,
		EDITTYPE_FLOAT,
		IDC_EP_BOUNCEUINHERIT,IDC_EP_BOUNCEUINHERITSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_EP_ICONSIZE,IDC_EP_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Particle Mass
	ParamUIDesc(
		PB_MASS,
		EDITTYPE_FLOAT,
		IDC_EP_PARTICLEMASSU,IDC_EP_PARTICLEMASSUSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Particle Mass Units
	ParamUIDesc(PB_MASSUNITS,TYPE_RADIO,massUunitsIDs,3)

	};

#define PARAMDESC_LENGTH	11

ParamBlockDescID descUDynaVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//timeon
	{ TYPE_INT, NULL, TRUE, 1 },	//timeoff
	{ TYPE_FLOAT, NULL, TRUE, 2 },//affects
	{ TYPE_FLOAT, NULL, TRUE, 3 },//bounce
	{ TYPE_FLOAT, NULL, TRUE, 4 },//bouncevar
	{ TYPE_FLOAT, NULL, TRUE, 5 },//chaos
	{ TYPE_FLOAT, NULL, TRUE, 6 },//friction
	{ TYPE_FLOAT, NULL, TRUE, 7 },//inherit
	{ TYPE_FLOAT, NULL, FALSE, 8 },//iconsize
	{ TYPE_FLOAT, NULL, TRUE, 9 },//mass
	{ TYPE_INT, NULL, FALSE, 10 },//massunits
	{ TYPE_FLOAT, NULL, FALSE, 11 },//force
	{ TYPE_FLOAT, NULL, FALSE, 12 },
	{ TYPE_FLOAT, NULL, FALSE, 13 },
	{ TYPE_FLOAT, NULL, FALSE, 14 },//apply
	{ TYPE_FLOAT, NULL, FALSE, 15 },
	{ TYPE_FLOAT, NULL, FALSE, 16 },
	{ TYPE_INT, NULL, FALSE, 17 }//total number
};	

#define PBLOCK_LENGTH	18

#define CURRENT_VERSION	0

//--- Universal Deflect object methods -----------------------------------------
class CreateUDynaDeflObjectProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		UDynaDeflObject *UspObj;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square,dostuff;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreateUDynaDeflObjectProc()
			{
			ignoreSelectionChange = FALSE;
			}
		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_CREATEUDynaDeflObjectMODE	CID_USER + 12

class CreateUDynaDeflObjectMode : public CommandMode {		
	public:		
		CreateUDynaDeflObjectProc proc;
		IObjParam *ip;
		UDynaDeflObject *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,UDynaDeflObject*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEUDynaDeflObjectMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
		BOOL IsSticky() { return FALSE; }
	};
static CreateUDynaDeflObjectMode theCreateUDynaDeflObjectMode;

RefResult CreateUDynaDeflObjectProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( UspObj && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (UspObj && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (UspObj->creating) 
						{  theCreateUDynaDeflObjectMode.JumpStart(UspObj->ip,UspObj);
						   createInterface->SetCommandMode(&theCreateUDynaDeflObjectMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				UspObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				UspObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				UspObj  = NULL;				
				CloudNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreateUDynaDeflObjectProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	UspObj       = NULL;
	dostuff=0;
	CreateNewObject();
	}
void CreateUDynaDeflObjectProc::CreateNewObject()
	{
	UspObj = (UDynaDeflObject*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	// Start the edit params process
	if ( UspObj ) {
		UspObj->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		UspObj->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreateUDynaDeflObjectProc::End()
{ if ( UspObj ) 
	{ 
#ifdef _OSNAP
	UspObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	UspObj->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete UspObj;
			UspObj = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		} 
 else if ( CloudNode ) {
			 // Get rid of the reference.
			theHold.Suspend();
			DeleteReference(0);  // sets camNode = NULL
			theHold.Resume();
			}
	}
}

void CreateUDynaDeflObjectMode::JumpStart(IObjParam *i,UDynaDeflObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int UDynaDeflClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateUDynaDeflObjectMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateUDynaDeflObjectMode);
	return TRUE;
	}

int UDynaDeflClassDesc::EndCreate(Interface *i)
	{
	theCreateUDynaDeflObjectMode.End();
	i->RemoveMode(&theCreateUDynaDeflObjectMode);
	return TRUE;
	}

int CreateUDynaDeflObjectProc::createmethod(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{	Point3 d;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				UspObj->pblock->SetValue(PB_ICONSIZE,0,0.01f);
				UspObj->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				UspObj->pblock->SetValue(PB_ICONSIZE,0,(float)fabs(p1.x-p0.x));
				UspObj->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
	}

static BOOL needToss;

int CreateUDynaDeflObjectProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif
	if (!dostuff)
	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( UspObj );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
				   		UspObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}

						// new object
						CreateNewObject();   // creates UniObj
						}

					needToss = theHold.GetGlobalPutCount()!=lastPutCount;

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( UspObj);
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = NULL;
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();
					mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));
					createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
					dostuff=1;
					res = TRUE;
					break;
					
				}			
			break;

		case MOUSE_MOVE:
			//mat[3] = vpx->GetPointOnCP(m);
			mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));
			createInterface->RedrawViews(createInterface->GetTime());	   
			res = TRUE;
			break;

		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP  //PREVIEW SNAP
			res = createmethod(vpx,msg,point,flag,m,mat);
#endif
		vpx->TrackImplicitGrid(m);
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: goto abort;
		}
	int result; 
	if (dostuff)
	{ result=createmethod(vpx,msg,point,flag,m,mat);
//	  UspObj->BuildEmitter(createInterface->GetTime(),UspObj->);
	  createInterface->RedrawViews(createInterface->GetTime()); 
	  if (result==CREATE_STOP)
	  { res=FALSE;dostuff=0;				
#ifdef _OSNAP
         UspObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	  theHold.Accept(GetString(IDS_EP_CREATE));	} 
	  else if (result==CREATE_ABORT)
	  { dostuff=0;
	    goto abort;}
	}
	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
	abort:
		assert( UspObj );
#ifdef _OSNAP
		UspObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		UspObj->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (needToss) GetSystemSetting(SYSSET_CLEAR_UNDO);
		CloudNode = NULL;			
		createInterface->RedrawViews(createInterface->GetTime()); 
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		goto done;
	}
static BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

BOOL UnjPickOperand::Filter(INode *node)
	{
	if ((node)&&(!node->IsGroupHead())) {
		ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
		if (os.obj->IsParticleSystem() || os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
			node = NULL;
			return FALSE;
			}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
			}
	}
	return node ? TRUE : FALSE;
	}

BOOL UnjPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if ((node)&&(node->IsGroupHead())) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		if ((os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID)||(!IsGEOM(os.obj))) {
			node = NULL;
			return FALSE;
			}
		node->BeginDependencyTest();
		po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if(node->EndDependencyTest()) {
			node = NULL;
			return FALSE;
		}
	}

	return node ? TRUE : FALSE;
	}

void UDynaDeflObject::ShowName()
{TSTR name; 
 FormatName(name= TSTR(GetString(IDS_EP_ITEMSTR)) + (custnode ? custname : TSTR(GetString(IDS_EP_NONE))));
SetWindowText(GetDlgItem(hParams, IDC_EP_PICKNAME), name);
}

BOOL UnjPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{BOOL groupflag=0;
	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	if (node->IsGroupMember()) 
	{ groupflag=1;
	  while (node->IsGroupMember()) node=node->GetParentNode();
	}
	int subtree=0;
	if (groupflag) MakeGroupNodeList(node,&nodes,subtree,ip->GetTime());
	else{ nodes.SetCount(1);nodes[0]=node;}
	ip->FlashNodes(&nodes);
	theHold.Begin();
	theHold.Put(new CreateUDynaDeflPickNode(po,node));

//	po->custnode=node;
	if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	theHold.Accept(GetString(IDS_EP_USPPICK));
	po->custname = TSTR(node->GetName());
	// Automatically check show result and do one update
	po->ShowName();	
	if (po->creating) {
		theCreateUDynaDeflObjectMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreateUDynaDeflObjectMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void UnjPickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_EP_PICKBUTTON));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
	}

void UnjPickOperand::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_EP_PICKBUTTON));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
	}
class UDynaDeflObjectDlgProc : public ParamMapUserDlgProc {
	public:
		UDynaDeflObject *po;

		UDynaDeflObjectDlgProc(UDynaDeflObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
		void Update(TimeValue t);
	};
void UDynaDeflObjectDlgProc::Update(TimeValue t)
{	po->ShowName();
	float size;
	po->pblock->GetValue(PB_ICONSIZE,0,size,FOREVER);
	TurnButton(po->hParams,IDC_EP_PICKBUTTON,(size>=0.01f));
}

BOOL UDynaDeflObjectDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	switch (msg) {
		case WM_INITDIALOG: {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_EP_PICKBUTTON));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(iBut);
			po->hParams=hWnd;
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{    case IDC_EP_PICKBUTTON:
				   { if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateUDynaDeflObjectMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateUDynaDeflObjectMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;						
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}

			}
			break;	
		}
	return TRUE;
	}

UDynaDeflObject::UDynaDeflObject()
{	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descUDynaVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	
	int tpf=GetTicksPerFrame();int timeoff=100*tpf;
	pblock->SetValue(PB_TIMEON,0,0);
	pblock->SetValue(PB_TIMEOFF,0,100*timeoff);
	pblock->SetValue(PB_AFFECTS,0,100.0f);
	pblock->SetValue(PB_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BOUNCEVAR,0,0.0f);
	pblock->SetValue(PB_CHAOS,0,0.0f);
	pblock->SetValue(PB_FRICTION,0,0.0f);
	pblock->SetValue(PB_INHERIT,0,100.0f);
	pblock->SetValue(PB_MASS,0,1.0f);
	pblock->SetValue(PB_MASSUNITS,0,0);
	pblock->SetValue(PB_ICONSIZE,0,0.0f);
	ffdata.FlectForce=Zero;ffdata.ApplyAt=Zero;ffdata.Num=0;	
	dmesh=NULL;
	vnorms=NULL;
	fnorms=NULL;
	srand(lastrnd=12345);
	t=99999;
	custnode=NULL;
	custname=TSTR(_T(" "));
	nv=0;nf=0;
	ctime=99999;
}

UDynaDeflObject::~UDynaDeflObject()
{  DeleteAllRefsFromMe();
   pblock=NULL;
	if (vnorms) delete[] vnorms;
	if (fnorms) delete[] fnorms;
   if (dmesh) delete dmesh;
}
Modifier *UDynaDeflObject::CreateWSMMod(INode *node)
	{
	return new UDynaDeflMod(node,this);
	}

RefTargetHandle UDynaDeflObject::Clone(RemapDir& remap) 
	{
	UDynaDeflObject* newob = new UDynaDeflObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	newob->custname=custname;
	newob->dmesh=NULL;
	newob->vnorms=NULL;
	newob->fnorms=NULL;
	return newob;
	}

void UDynaDeflObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
		SetWindowLong(hSot,GWL_USERDATA,(LONG)this);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC_BOTH),
			DefaultSOTProc,
			GetString(IDS_EP_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descUDynaParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_AP_UDYNADEFL),
			GetString(IDS_EP_PARAMETERS),
			0);
		ip->RegisterDlgWnd(hSot);
		}
		if (pmapParam)
			pmapParam->SetUserDlgProc(new UDynaDeflObjectDlgProc(this));
	}

void UDynaDeflObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->UnRegisterDlgWnd(hSot);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;	
		hSot=NULL;
		}	
	else
		SetWindowLong(hSot,GWL_USERDATA,(LONG)NULL);
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
	}

void UDynaDeflObject::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_TIMEON,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEON,0,TempTime);
	pblock->GetValue(PB_TIMEOFF,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEOFF,0,TempTime);
}  

void UDynaDeflObject::BuildMesh(TimeValue t)
	{
	ivalid = FOREVER;
	float length,l,h2,h3,h4;
	pblock->GetValue(PB_ICONSIZE,t,length,ivalid);
	l=length*0.5f;
	h2=l*0.5f;
	h3=h2*0.15f;
	h4=h2*0.25f;

	mesh.setNumVerts(23);
	mesh.setNumFaces(21);

	mesh.setVert(0,Point3( l, l, l));
	mesh.setVert(1,Point3( l, l,-l));
	mesh.setVert(2,Point3( l,-l, l));
	mesh.setVert(3,Point3( l,-l,-l));
	mesh.setVert(4,Point3(-l, l, l));
	mesh.setVert(5,Point3(-l, l,-l));
	mesh.setVert(6,Point3(-l,-l, l));
	mesh.setVert(7,Point3(-l,-l,-l));

	mesh.setVert( 8, Point3(0.0f,0.0f,l));
	mesh.setVert( 9, Point3(0.0f,  h2,l+h2));
	mesh.setVert(10, Point3(0.0f, -h2,l+h2));
	mesh.setVert(11, Point3(0.0f,  h2+h3,l+h2));
	mesh.setVert(12, Point3(0.0f,  h2,l+h2+h3));
	mesh.setVert(13, Point3(0.0f, -h2,l+h2-h3));
	mesh.setVert(14, Point3(0.0f, -h2+h3,l+h2));

	mesh.setVert(15, Point3(0.0f, h4, -l));
	mesh.setVert(16, Point3(0.0f, h4, -h2-l));
	mesh.setVert(17, Point3(0.0f, h4+h3, -h2-l));
	mesh.setVert(18, Point3(0.0f, 0.0f, -h2-h3-h3-l));
	mesh.setVert(19, Point3(0.0f,-h4-h3, -h2-l));
	mesh.setVert(20, Point3(0.0f,-h4, -h2-l));
	mesh.setVert(21, Point3(0.0f,-h4, -l));
	mesh.setVert(22, Point3(0.0f,0.0f,-h4-l));

	mesh.faces[0].setVerts(1,0,2);
	mesh.faces[0].setEdgeVisFlags(1,1,0);
	mesh.faces[0].setSmGroup(0);
	mesh.faces[1].setVerts(2,3,1);
	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(0);
	mesh.faces[2].setVerts(2,0,4);
	mesh.faces[2].setEdgeVisFlags(1,1,0);
	mesh.faces[2].setSmGroup(1);
	mesh.faces[3].setVerts(4,6,2);
	mesh.faces[3].setEdgeVisFlags(1,1,0);
	mesh.faces[3].setSmGroup(1);
	mesh.faces[4].setVerts(3,2,6);
	mesh.faces[4].setEdgeVisFlags(1,1,0);
	mesh.faces[4].setSmGroup(2);
	mesh.faces[5].setVerts(6,7,3);
	mesh.faces[5].setEdgeVisFlags(1,1,0);
	mesh.faces[5].setSmGroup(2);
	mesh.faces[6].setVerts(7,6,4);
	mesh.faces[6].setEdgeVisFlags(1,1,0);
	mesh.faces[6].setSmGroup(3);
	mesh.faces[7].setVerts(4,5,7);
	mesh.faces[7].setEdgeVisFlags(1,1,0);
	mesh.faces[7].setSmGroup(3);
	mesh.faces[8].setVerts(4,0,1);
	mesh.faces[8].setEdgeVisFlags(1,1,0);
	mesh.faces[8].setSmGroup(4);
	mesh.faces[9].setVerts(1,5,4);
	mesh.faces[9].setEdgeVisFlags(1,1,0);
	mesh.faces[9].setSmGroup(4);
	mesh.faces[10].setVerts(1,3,7);
	mesh.faces[10].setEdgeVisFlags(1,1,0);
	mesh.faces[10].setSmGroup(5);
	mesh.faces[11].setVerts(7,5,1);
	mesh.faces[11].setEdgeVisFlags(1,1,0);
	mesh.faces[11].setSmGroup(5);

	mesh.faces[12].setEdgeVisFlags(1,0,1);
	mesh.faces[12].setSmGroup(1);
	mesh.faces[12].setVerts(8,10,9);	
	mesh.faces[13].setEdgeVisFlags(1,0,1);
	mesh.faces[13].setSmGroup(1);
	mesh.faces[13].setVerts(10,13,14);	
	mesh.faces[14].setEdgeVisFlags(1,0,1);
	mesh.faces[14].setSmGroup(1);
	mesh.faces[14].setVerts(9,12,11);
	mesh.faces[15].setEdgeVisFlags(1,0,1);
	mesh.faces[15].setSmGroup(1);
	mesh.faces[15].setVerts(15,16,22);	
	mesh.faces[16].setEdgeVisFlags(0,0,0);
	mesh.faces[16].setSmGroup(1);
	mesh.faces[16].setVerts(16,20,22);	
	mesh.faces[17].setEdgeVisFlags(1,1,0);
	mesh.faces[17].setSmGroup(1);
	mesh.faces[17].setVerts(20,21,22);	
	mesh.faces[18].setEdgeVisFlags(1,1,0);
	mesh.faces[18].setSmGroup(1);
	mesh.faces[18].setVerts(16,17,18);	
	mesh.faces[19].setEdgeVisFlags(0,0,0);
	mesh.faces[19].setSmGroup(1);
	mesh.faces[19].setVerts(16,18,20);	
	mesh.faces[20].setEdgeVisFlags(1,1,0);
	mesh.faces[20].setSmGroup(1);
	mesh.faces[20].setVerts(18,19,20);	

	mesh.InvalidateGeomCache();
	}

void UDynaDeflObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *UDynaDeflObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_TIMEON:
				 return stdTimeDim;
		case PB_TIMEOFF:
				 return stdTimeDim;
		case PB_AFFECTS:
				 return stdPercentDim;
		case PB_BOUNCEVAR:
				 return stdPercentDim;
		case PB_CHAOS:
				 return stdPercentDim;
		default: return defaultDim;
		}
	}

TSTR UDynaDeflObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_TIMEON:			return GetString(IDS_EP_TIMEON);
		case PB_TIMEOFF:		return GetString(IDS_EP_TIMEOFF);
		case PB_AFFECTS:		return GetString(IDS_EP_AFFECTS);
		case PB_BOUNCE:			return GetString(IDS_EP_BOUNCE);
		case PB_BOUNCEVAR:		return GetString(IDS_EP_BOUNCEVAR);
		case PB_CHAOS:			return GetString(IDS_EP_CHAOS);
		case PB_FRICTION:		return GetString(IDS_EP_FRICTION);
		case PB_INHERIT:		return GetString(IDS_EP_INHERIT);
		case PB_ICONSIZE:		return GetString(IDS_EP_ICONSIZE);
		case PB_MASS:			return GetString(IDS_EP_MASS);
		case PB_MASSUNITS:		return GetString(IDS_EP_MASSUNITS);
		default:				return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

UDynaDeflMod::UDynaDeflMod(INode *node,UDynaDeflObject *obj)
	{	
//	MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
		pblock = NULL;
	obRef=NULL;
	}

Interval UDynaDeflMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		UDynaDeflObject *obj = (UDynaDeflObject*)GetWSMObject(t);
		TimeValue TempT;
		obj->pblock->GetValue(PB_TIMEOFF,t,TempT,valid);
		obj->pblock->GetValue(PB_AFFECTS,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_BOUNCEVAR,t,f,valid);
		obj->pblock->GetValue(PB_CHAOS,t,f,valid);
		obj->pblock->GetValue(PB_FRICTION,t,f,valid);
		obj->pblock->GetValue(PB_INHERIT,t,f,valid);
		obj->pblock->GetValue(PB_MASS,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		
		return valid;
	} else {
		return FOREVER;
		}
	}

class UDynaDeflDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static UDynaDeflDeformer UDynaddeformer;

Deformer& UDynaDeflMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return UDynaddeformer;
	}

RefTargetHandle UDynaDeflMod::Clone(RemapDir& remap) 
	{
	UDynaDeflMod *newob = new UDynaDeflMod(nodeRef,(UDynaDeflObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}

void UDynaDeflMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (UDynaDeflObject*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.obj->tmValid.SetEmpty();		
		deflect.obj->mValid.SetEmpty();
		deflect.badmesh=(deflect.obj->custnode==NULL);
		if (t<=deflect.obj->t) deflect.obj->lastrnd=12345;
		deflect.obj->t=t;
/*		if (deflect.obj->dmesh) delete deflect.obj->dmesh;
		deflect.obj->dmesh=NULL;
		deflect.obj->vnorms.ZeroCount();deflect.obj->vnorms.Shrink();
		deflect.obj->fnorms.ZeroCount();deflect.obj->fnorms.Shrink();
		deflect.obj->nv=0;deflect.obj->nf=0;
		*/
		deflect.obj->dvel=Zero;
		deflect.totalforce=Zero;
		deflect.applyat=Zero;
		deflect.totalnumber=0;
		TimeValue tmpt=GetCOREInterface()->GetTime();
		if (deflect.obj->ctime!=tmpt)
		{ deflect.obj->ctime=tmpt;
//		  if ((deflect.curtime==NoAni)||(deflect.curtime!=t))
		  deflect.obj->ffdata.FlectForce=deflect.totalforce;
		  deflect.obj->ffdata.ApplyAt=deflect.applyat;
		  deflect.obj->ffdata.Num=deflect.totalnumber;
		}
//		deflect.curtime=NoAni;
		obj->ApplyCollisionObject(&deflect);
		}
	}
 static TriObject *IsUseable(Object *pobj,TimeValue t)
{ 
  if (pobj->SuperClassID()==GEOMOBJECT_CLASS_ID)
  {	if (pobj->IsSubClassOf(triObjectClassID)) 
      return (TriObject*)pobj;
    else 
	{ if (pobj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)pobj->ConvertToType(t,triObjectClassID);			
	}
  }
  return NULL;
}

#define EPSILON	0.0001f

void AddMesh(UDynaDeflObject *obj,TriObject *triOb,Matrix3 tm,BOOL nottop)
{ int lastv=obj->nv,lastf=obj->nf;
  obj->nv+=triOb->GetMesh().getNumVerts();
  obj->nf+=triOb->GetMesh().getNumFaces();
  if (!nottop)
    obj->dmesh->DeepCopy(&triOb->GetMesh(),PART_GEOM|PART_TOPO);
  else
  {obj->dmesh->setNumFaces(obj->nf,obj->dmesh->getNumFaces());
   obj->dmesh->setNumVerts(obj->nv,obj->dmesh->getNumVerts());
   tm=tm*obj->invtm;
   for (int vc=0;vc<triOb->GetMesh().getNumFaces();vc++)
   { obj->dmesh->faces[lastf]=triOb->GetMesh().faces[vc];
     for (int vs=0;vs<3;vs++) 
	   obj->dmesh->faces[lastf].v[vs]+=lastv;
     lastf++;}
  }
   for (int vc=0;vc<triOb->GetMesh().getNumVerts();vc++)
   { if (nottop) obj->dmesh->verts[lastv]=triOb->GetMesh().verts[vc]*tm;
	 else obj->dmesh->verts[lastv]=triOb->GetMesh().verts[vc];
     lastv++;}
}  

Object *UDynaDeflField::GetSWObject()
{ return obj;
}

BOOL UDynaDeflField::CheckCollision(TimeValue t,Point3 &inp,Point3 &vel,float dt,int index,float *ct, BOOL UpdatePastCollide)
{ 	if (badmesh) return(0);
	if (!((obj->mValid.InInterval(t))&&(obj->tmValid.InInterval(t))))
	{	obj->tmValid=FOREVER;
		obj->tm=obj->custnode->GetObjectTM(t,&obj->tmValid);
		obj->tmNoTrans=obj->tm;
		obj->tmNoTrans.NoTrans();
		obj->invtm=Inverse(obj->tm);
		obj->invtmNoTrans=Inverse(obj->tmNoTrans);
		if (obj->dmesh) delete obj->dmesh;
		obj->dmesh=new Mesh;obj->dmesh->setNumFaces(0);
		if (obj->vnorms) {delete[] obj->vnorms;obj->vnorms=NULL;}
		if (obj->fnorms) {delete[] obj->fnorms;obj->fnorms=NULL;}
		obj->nv=(obj->nf=0);
		Interval tmpValid=FOREVER;
		obj->ptm=obj->custnode->GetObjectTM(t+(TimeValue)dt,&tmpValid);
		obj->dvel=(Zero*obj->ptm-Zero*obj->tm)/dt;
		Object *pobj; 
		pobj = obj->custnode->EvalWorldState(t).obj;
		obj->mValid=pobj->ObjectValidity(t);
		TriObject *triOb=NULL;
		badmesh=TRUE;
		if ((triOb=IsUseable(pobj,t))!=NULL) AddMesh(obj,triOb,obj->tm,FALSE);
		if (obj->custnode->IsGroupHead())
		{	 for (int ch=0;ch<obj->custnode->NumberOfChildren();ch++)
			{   INode *cnode=obj->custnode->GetChildNode(ch);
				if (cnode->IsGroupMember())
				{	pobj = cnode->EvalWorldState(t).obj;
					if ((triOb=IsUseable(pobj,t))!=NULL)
					{	Matrix3 tm=cnode->GetObjectTM(t,&obj->tmValid);
						obj->mValid=obj->mValid & pobj->ObjectValidity(t);
						AddMesh(obj,triOb,tm,TRUE);
					}
				}
			}
		}
		if (obj->nf>0)
		{	obj->vnorms=new VNormal[obj->nv];
			obj->fnorms=new Point3[obj->nf];
			GetVFLst(obj->dmesh,obj->vnorms,obj->fnorms);
			badmesh=FALSE;
		}
		if ((triOb)&&(triOb!=pobj)) triOb->DeleteThis();
 	}

	if (badmesh) 
		return 0;

    if (curtime!=t)
	{	totalforce=Zero;
		applyat=Zero;
		totalnumber=0;
		curtime=t;
/*		obj->ffdata.FlectForce=totalforce;
		obj->ffdata.ApplyAt=applyat;
		obj->ffdata.Num=totalnumber;*/
	}
	
	float K=(float)GetMasterScale(UNITS_CENTIMETERS);
	float stepsize=dt;
	Point3 invel=vel;

	TimeValue startt,endt;
	obj->pblock->GetValue(PB_TIMEON,t,startt,FOREVER);
	obj->pblock->GetValue(PB_TIMEOFF,t,endt,FOREVER);
	if ((t<startt)||(t>endt))
	{	obj->lastrnd=rand();
		return FALSE;
	}

	float affectsthisportion;
	obj->pblock->GetValue(PB_AFFECTS,t,affectsthisportion,FOREVER);
    srand(obj->lastrnd);
	if (RND01()>affectsthisportion)
	{	obj->lastrnd=rand();
		return FALSE;
	}

	float pvel;
	Point3 NVrelL,Vrel,VrelL,pos;

	pos=inp*obj->invtm;
	Vrel=vel-obj->dvel;
	pvel=Length(Vrel);
	VrelL=Vrel*obj->invtmNoTrans;
	NVrelL=Normalize(VrelL);
	Ray ray;
	ray.dir=NVrelL;
	ray.p=pos;
	float at;Point3 norm;
	int kfound=RayIntersectP(ray,at,norm,obj->dmesh,obj->vnorms,obj->fnorms);
	if (!kfound)
	{	obj->lastrnd=rand();
		return FALSE;
	}

	Point3 id,iw=(id=pos+at*NVrelL)*obj->tm;
	float delta=Length(iw-inp);
	if (delta>dt*pvel)
	{	obj->lastrnd=rand();
		return FALSE;
	}

	float bounce,bvar,chaos,vinher,friction;
	obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
	obj->pblock->GetValue(PB_BOUNCEVAR,t,bvar,FOREVER);
	obj->pblock->GetValue(PB_CHAOS,t,chaos,FOREVER);
	obj->pblock->GetValue(PB_INHERIT,t,vinher,FOREVER);
	obj->pblock->GetValue(PB_FRICTION,t,friction,FOREVER);

	float dti=delta/pvel;
	Point3 wnorm=norm*obj->tmNoTrans;
	Point3 Vt,c2,c1,Vreln=Vrel/pvel;
	Point3 Vdirbase=Normalize(Vreln);
	float q1=DotProd(-Vdirbase,wnorm);
	float theta=(float)acos(q1);
	if (theta>=HalfPI) 
		theta-=PI;
	if (theta<FLOAT_EPSILON)
		vel=-vel;
	else 
	{	c1=Normalize((-vel)^wnorm);
		c2=Normalize(wnorm^c1);
		vel=-vel;
		Vt=c2*DotProd(c2,vel);
		RotateOnePoint(&vel.x,&Zero.x,&c1.x,2*theta);
		vel=vel+friction*Vt;
	}
	vel=vel*bounce*(1-bvar*RND01());
	if (!FloatEQ0(chaos))
	{	theta=(HalfPI-theta)*chaos*RND01();
		Point3 d=Point3(RND11(),RND11(),RND11());
		Point3 c=Normalize(vel^d);
		RotateOnePoint(&vel.x,&Zero.x,&c.x,theta);
	}
	if (vinher>0.0f)
	{	Point3 dvel=obj->dvel*vinher; 
		vel = vel + friction*dvel + (1-friction)*DotProd(dvel,wnorm)*wnorm;
	}

	if (UpdatePastCollide)
	{	inp = iw + (dt-dti)*vel;
		if (ct) (*ct) = dt;
	}
	else
	{	inp = iw;
		if (ct) (*ct) = dti;
	}

	applyat = iw;

// get physical parameters
	float mass;
	int massunits;
	obj->pblock->GetValue(PB_MASS,t,mass,FOREVER);
	obj->pblock->GetValue(PB_MASSUNITS,t,massunits,FOREVER);
// compensate for units of measure
	switch(massunits)
	{	case 0: mass*=0.001f; break;
		case 1: break;
		case 2: mass*=0.454f; break;
	}
// increment physical property params
// put information into parameter block
	if (t==obj->ctime)
	{ totalnumber+=1;
	  totalforce+=(invel-vel)*K*mass/stepsize;
      obj->ffdata.FlectForce+=totalforce;
	  obj->ffdata.ApplyAt+=applyat;
	  obj->ffdata.Num=+totalnumber;
	}
	obj->lastrnd=rand();
	return TRUE;
}

RefTargetHandle UDynaDeflObject::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		default: return NULL;
		}
	}

void UDynaDeflObject::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		}
	}

RefResult UDynaDeflObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode) custnode=NULL;
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				}
			  break;
			}
		default: SimpleWSMObject::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}

#define USPDEF_CUSTNAME_CHUNK	0x0100

IOResult UDynaDeflObject::Save(ISave *isave)
	{
	isave->BeginChunk(USPDEF_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();
	return IO_OK;
	}

IOResult UDynaDeflObject::Load(ILoad *iload)
	{
	IOResult res = IO_OK;
	
	// Default names
	custname = TSTR(_T(" "));

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case USPDEF_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}

FlectForces UDynaDeflObject::ForceData(TimeValue t)
{ pblock->GetValue(PB_TIMEON,t,ffdata.t1,FOREVER);
  pblock->GetValue(PB_TIMEOFF,t,ffdata.t2,FOREVER);
  return ffdata;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shaderMultiLayer.cpp ===
///////////////////////////////////////////////////////////////////
//
//	MultiLayer shader
//
//		Created: 11/23/98 Kells Elmquist
//
#include "shadersPch.h"
#include "shadersRc.h"
#include "gport.h"
#include "shaders.h"
#include "shaderUtil.h"
#include "macrorec.h"

// Class Ids
#define MULTILAYERSHADER_CLASS_ID		0x2857f470

static Class_ID MultiLayerShaderClassID( MULTILAYERSHADER_CLASS_ID, 0);


// paramblock2 block and parameter IDs.
enum { multiLayer_params, };
// shdr_params param IDs
enum 
{ 
	ml_ambient, ml_diffuse, ml_self_illum_color,
	ml_self_illum_amnt, ml_diffuse_level, ml_diffuse_rough, 
	ml_specular1, ml_specular_level1, ml_glossiness1, ml_anisotropy1, ml_orientation1, 
	ml_specular2, ml_specular_level2, ml_glossiness2, ml_anisotropy2, ml_orientation2, 
	ml_map_channel, ml_ad_texlock, ml_ad_lock, ml_use_self_illum_color, 
};



/////////////////////////////////////////////////////////////////////
//
//	Basic Panel UI 
//
#define MULTI_LAYER_NMBUTS 16
#define N_TR_BUT 15

// tex channel number to button IDC
static int texMButtonsIDC[] = {
	IDC_MAPON_AM, IDC_MAPON_DI, IDC_MAPON_DIFFLEV, IDC_MAPON_DIFFROUGH,
	IDC_MAPON_SPECCLR1, IDC_MAPON_SPECLEV1, IDC_MAPON_GL1, IDC_MAPON_AN1, IDC_MAPON_OR1, 
	IDC_MAPON_SPECCLR2, IDC_MAPON_SPECLEV2, IDC_MAPON_GL2, IDC_MAPON_AN2, IDC_MAPON_OR2, 
	IDC_MAPON_SI, IDC_MAPON_TR, 
	-1,  -1, -1, -1, -1, -1, -1, -1
	};
		
// This array gives the texture map number for given MButton number								
static int texmapFromMBut[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };

// Texture Maps
#define MULTI_LAYER_NTEXMAPS	17

// channels ids needed by shader
#define _AMBCLR		0
#define _DIFFCLR	1
#define _DIFFLEV	2
#define _DIFFROUGH	3
#define _SPECCLR1	4
#define _SPECLEV1	5
#define _GL1		6
#define _AN1		7
#define _OR1		8
#define _SPECCLR2	9
#define _SPECLEV2	10
#define _GL2		11
#define _AN2		12
#define _OR2		13
#define _SI			14
#define _TR			15

// channel names
static int texNameIDS[STD2_NMAX_TEXMAPS] = {
	IDS_DS_AMBIENT, IDS_DS_DIFFUSE, IDS_KE_DIFF_LEVEL, IDS_KE_DIFF_ROUGH,
	IDS_KE_SPEC_CLR1, IDS_KE_SPEC_LEVEL1, IDS_KE_GLOSS1, IDS_KE_ANISO1, IDS_KE_ORIENTATION1,
	IDS_KE_SPEC_CLR2, IDS_KE_SPEC_LEVEL2, IDS_KE_GLOSS2, IDS_KE_ANISO2, IDS_KE_ORIENTATION2, 
	IDS_KE_SELFILLUM, IDS_DS_TRANS, IDS_DS_FILTER, 
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,  
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, 
};	

// internal non-local parsable channel map names
static TCHAR* texInternalNames[STD2_NMAX_TEXMAPS] = {
	_T("ambientMap"), _T("diffuseMap"),	_T("diffuseLevelMap"), _T("diffuseRoughnessMap"),
	_T("specularMap"), _T("specularLevelMap"), _T("glossinessMap"), _T("anisotropyMap"), _T("orientationMap"),
	_T("specularMap2"), _T("specularLevelMap2"), _T("glossinessMap2"), _T("anisotropyMap2"), _T("orientationMap2"),
	_T("selfIllumMap"), _T("opacityMap"), _T("filterMap"),	
	_T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""),
};	


// sized for nmax textures
// bump, reflection & refraction maps are ignored....done after shading
static int chanType[STD2_NMAX_TEXMAPS] = {
	CLR_CHANNEL, CLR_CHANNEL, MONO_CHANNEL, MONO_CHANNEL,
	CLR_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, 
	CLR_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, 
	CLR_CHANNEL, MONO_CHANNEL, CLR_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,  
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
};	

// what channel corresponds to the stdMat ID's
static int stdIDToChannel[N_ID_CHANNELS] = { 0, 1, 4, 6, 5, 14, 15, 16, -1, -1, -1, -1 };

//////////////////////////////////////////////////////////////////////////////////////////
//
//		MultiLayer Parameter Block
//
#define CURRENT_MULTI_LAYER_SHADER_VERSION	2
#define MULTI_LAYER_SHADER_NPARAMS			17
#define MULTI_LAYER_SHADER_PB_VERSION		1
#define MULTI_LAYER_NCOLBOX					5

static int colID[MULTI_LAYER_NCOLBOX] = { IDC_AMB_CLR, IDC_DIFF_CLR, IDC_SI_CLR, IDC_SPEC_CLR1, IDC_SPEC_CLR2 };
#define N_SI_CLR		2

#define PB_AMB_CLR			0
#define PB_DIFF_CLR			1
#define PB_DIFF_LEV			2
#define PB_DIFF_ROUGH		3
#define PB_SPEC_CLR1		4
#define PB_SPEC_LEV1		5
#define PB_GLOSS1			6
#define PB_ANISO1			7
#define PB_SPEC_CLR2		8
#define PB_SPEC_LEV2		9
#define PB_GLOSS2			10
#define PB_ANISO2			11
#define PB_SELFILLUM_CLR	12
#define PB_SELFILLUM_LEV	13
#define PB_ORIENTATION1		14
#define PB_ORIENTATION2		15
#define PB_MAP_CHANNEL		16

#define ANIMATE		TRUE
#define NO_ANIMATE	FALSE

//Current Param Block Descriptor
static ParamBlockDescID MultiLayerShaderPB[ MULTI_LAYER_SHADER_NPARAMS ] = {
	{ TYPE_RGBA,  NULL, ANIMATE, ml_ambient },   // ambient color
	{ TYPE_RGBA,  NULL, ANIMATE, ml_diffuse },   // diffuse color
	{ TYPE_FLOAT, NULL, ANIMATE, ml_diffuse_level },  // diffuse level
	{ TYPE_FLOAT, NULL, ANIMATE, ml_diffuse_rough },  // diffuse roughness
	{ TYPE_RGBA,  NULL, ANIMATE, ml_specular1 },   // specular layer 1 color
	{ TYPE_FLOAT, NULL, ANIMATE, ml_specular_level1 },   // layer 1 level
	{ TYPE_FLOAT, NULL, ANIMATE, ml_glossiness1 },   // layer 1 gloss
	{ TYPE_FLOAT, NULL, ANIMATE, ml_anisotropy1 },  // layer 1 anisotropy
	{ TYPE_RGBA,  NULL, ANIMATE, ml_specular2 },   // Specular layer 2 color
	{ TYPE_FLOAT, NULL, ANIMATE, ml_specular_level2 },   // layer 2 level
	{ TYPE_FLOAT, NULL, ANIMATE, ml_glossiness2 },   // layer 2 gloss
	{ TYPE_FLOAT, NULL, ANIMATE, ml_anisotropy2 },  // layer 2 anisotropy
	{ TYPE_RGBA,  NULL, ANIMATE, ml_self_illum_color },	// selfIllumClr 
	{ TYPE_FLOAT, NULL, ANIMATE, ml_self_illum_amnt},	// selfIllumLevel
	{ TYPE_FLOAT, NULL, ANIMATE, ml_orientation1 },	// orientation1
	{ TYPE_FLOAT, NULL, ANIMATE, ml_orientation2 },	// orientation2
	{ TYPE_INT,	  NULL, NO_ANIMATE, ml_map_channel } // map channel
}; 


#define MULTI_LAYER_NUMVER 1

static ParamVersionDesc oldVersions[MULTI_LAYER_NUMVER] = {
	ParamVersionDesc(MultiLayerShaderPB, MULTI_LAYER_SHADER_NPARAMS, 0),
};

//----------------------------------------------------------------------------------------
//---- MultiLayer: A 2 layer physically based anisotropic shader -------------------------------
//----------------------------------------------------------------------------------------

class MultiLayerShaderDlg;

class MultiLayerShader : public Shader {
friend class MultiLayerShaderCB;
friend class MultiLayerShaderDlg;
protected:
	IParamBlock2	*pblock;   // ref 0
	Interval		ivalid;

	MultiLayerShaderDlg*	paramDlg;

	Color			ambColor;
	Color			diffColor;
	float			diffLevel;
	float			diffRough;

	Color			specColor1;
	float			specLevel1;
	float			gloss1;
	float			aniso1;
	float			orientation1;

	Color			specColor2;
	float			specLevel2;
	float			gloss2;
	float			aniso2;
	float			orientation2;

	float			selfIllumLevel;
	Color			selfIllum;
	BOOL			selfIllumClrOn;


	BOOL			lockAD;
	BOOL			lockADTex;

	public:
	MultiLayerShader();
	void DeleteThis(){ delete this; }	
    ULONG SupportStdParams(){ return (STD_MULTILAYER | STD_EXTRA); }

	// copy std params, for switching shaders
    void CopyStdParams( Shader* pFrom );

	// texture maps
	long  nTexChannelsSupported(){ return MULTI_LAYER_NTEXMAPS; }
	TSTR  GetTexChannelName( long nTex ){ return GetString( texNameIDS[ nTex ] ); }
	TSTR  GetTexChannelInternalName( long nTex ){ return texInternalNames[ nTex ]; }
	long  ChannelType( long nChan ) { return chanType[nChan]; }
	long  StdIDToChannel( long stdID ){ return stdIDToChannel[stdID]; }

	BOOL KeyAtTime(int id,TimeValue t) { return pblock->KeyFrameAtTime(id,t); }
	ULONG GetRequirements( int subMtlNum ){ return MTLREQ_PHONG; }

	ShaderParamDlg* CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen );
	ShaderParamDlg* GetParamDlg(){ return (ShaderParamDlg*)paramDlg; }
	void SetParamDlg( ShaderParamDlg* newDlg ){ paramDlg = (MultiLayerShaderDlg*)newDlg; }

	Class_ID ClassID() { return MultiLayerShaderClassID; }
	SClass_ID SuperClassID() { return SHADER_CLASS_ID; }
	TSTR GetName() { return GetString( IDS_KE_MULTI_LAYER ); }
	void GetClassName(TSTR& s) { s = GetName(); }  

	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i){ return (i==0)? pblock : NULL; }
	TSTR SubAnimName(int i){ return TSTR(GetString( IDS_KE_MULTI_LAYER_PARMS )); };
	int SubNumToRefNum(int subNum) { return subNum;	}

	// add direct ParamBlock2 access
	int	NumParamBlocks() { return 1; }
	IParamBlock2* GetParamBlock(int i) { return pblock; }
	IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } 

 	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i){ return (i==0)? pblock : NULL; }
	void SetReference(int i, RefTargetHandle rtarg) 
		{ if (i==0) pblock = (IParamBlock2*)rtarg; else assert(0); }
	void NotifyChanged(){ NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE); }

	void Update(TimeValue t, Interval& valid);
	void Reset();
	RefTargetHandle Clone( RemapDir &remap=NoRemap() );
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	                            PartID& partID, RefMessage message );
	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// cache for mapping of params, mtl fills in ip
	void GetIllumParams( ShadeContext &sc, IllumParams& ip );

	// MultiLayer Shader specific section
	void  Illum(ShadeContext &sc, IllumParams &ip);
	float EvalHiliteCurve2(float x, float y, int layer );	// layer is 1 or 2
	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol);
	void CombineComponents( ShadeContext &sc, IllumParams& ip ){ CombineComponentsComp( ip ); }

	void SetGlossiness(float v, TimeValue t)		
		{ gloss1= v; pblock->SetValue( ml_glossiness1, t, v); }
	void SetGlossiness1(float v, TimeValue t)		
		{ gloss1= v; pblock->SetValue( ml_glossiness1, t, v); }
	void SetAnisotropy1(float v, TimeValue t)		
		{ aniso1 = v; pblock->SetValue( ml_anisotropy1, t, v); }
	void SetSpecLevel1(float v, TimeValue t)		
		{ specLevel1 = v; pblock->SetValue( ml_specular_level1, t, v); }
	void SetOrientation1(float v, TimeValue t)		
		{ orientation1 = v; pblock->SetValue( ml_orientation1, t, v); }
	void SetOrientation2(float v, TimeValue t)		
		{ orientation2 = v; pblock->SetValue( ml_orientation2, t, v); }
	float GetGlossiness(int mtlNum, BOOL backFace){ return gloss1; }	
	float GetGlossiness1(int mtlNum, BOOL backFace){ return gloss1; }	
	float GetAnisotropy1(int mtlNum, BOOL backFace){ return aniso1; }	
	float GetSpecLevel1(int mtlNum, BOOL backFace){ return specLevel1; }	
	float GetOrientation1(int mtlNum, BOOL backFace){ return orientation1; }	
	float GetOrientation2(int mtlNum, BOOL backFace){ return orientation2; }	
	float GetGlossiness( TimeValue t){return pblock->GetFloat(ml_glossiness1,t);  }		
	float GetGlossiness1( TimeValue t){return pblock->GetFloat(ml_glossiness1,t);  }		
	float GetAnisotropy1( TimeValue t){return pblock->GetFloat(ml_anisotropy1,t);  }		
	float GetSpecLevel1( TimeValue t){return pblock->GetFloat(ml_specular_level1,t);  }		
	float GetOrientation1( TimeValue t){return pblock->GetFloat(ml_orientation1,t);  }		
	float GetOrientation2( TimeValue t){return pblock->GetFloat(ml_orientation2,t);  }		

	void SetGlossiness2(float v, TimeValue t)		
		{ gloss2= v; pblock->SetValue( ml_glossiness2, t, v); }
	void SetAnisotropy2(float v, TimeValue t)		
		{ aniso2 = v; pblock->SetValue( ml_anisotropy2, t, v); }
	void SetSpecLevel2(float v, TimeValue t)		
		{ specLevel2 = v; pblock->SetValue( ml_specular_level2, t, v); }
	float GetGlossiness2(int mtlNum, BOOL backFace){ return gloss2; };	
	float GetAnisotropy2(int mtlNum, BOOL backFace){ return aniso2; };	
	float GetSpecLevel2(int mtlNum, BOOL backFace){ return specLevel2; };	
	float GetGlossiness2( TimeValue t){return pblock->GetFloat(ml_glossiness2,t);  }		
	float GetAnisotropy2( TimeValue t){return pblock->GetFloat(ml_anisotropy2,t);  }		
	float GetSpecLevel2( TimeValue t){return pblock->GetFloat(ml_specular_level2,t);  }		

	void SetDiffuseLevel(float v, TimeValue t)		
		{ diffLevel = v; pblock->SetValue( ml_diffuse_level, t, v); }
	float GetDiffuseLevel(int mtlNum, BOOL backFace){ return diffLevel; }	
	float GetDiffuseLevel( TimeValue t ){ return pblock->GetFloat(ml_diffuse_level,t); }		
	void SetDiffuseRough(float v, TimeValue t)		
		{ diffRough = v; pblock->SetValue( ml_diffuse_rough, t, v); }
	float GetDiffuseRough(int mtlNum, BOOL backFace){ return diffRough; }	
	float GetDiffuseRough( TimeValue t ){ return pblock->GetFloat(ml_diffuse_rough,t); }		

	void SetSpecColor1(Color c, TimeValue t)
		{ specColor1 = c; pblock->SetValue( ml_specular1, t, c); }
	void SetSpecColor2(Color c, TimeValue t)		
		{ specColor2 = c; pblock->SetValue( ml_specular2, t, c); }

    Color GetSpecColor1(int mtlNum, BOOL backFace){ return specColor1;}		
	Color GetSpecColor1(TimeValue t){ return pblock->GetColor(ml_specular1,t);	}
	Color GetSpecColor2(int mtlNum, BOOL backFace){ return specColor2; }
	Color GetSpecColor2(TimeValue t){ return pblock->GetColor(ml_specular2,t); }		

	// Std Params, these define the interactive settings for OGL, etc....
	void SetAmbientClr(Color c, TimeValue t)		
		{ ambColor = c; pblock->SetValue( ml_ambient, t, c); }
	void SetDiffuseClr(Color c, TimeValue t)		
		{ diffColor = c; pblock->SetValue( ml_diffuse, t, c); }
	void SetSpecularClr(Color c, TimeValue t)
		{ SetSpecColor1( c, t ); }
	void SetSelfIllumClr(Color c, TimeValue t)
		{ selfIllum = c; pblock->SetValue( ml_self_illum_color, t, c); }
	void SetSpecularLevel(float v, TimeValue t)
		{SetSpecLevel1( v, t ); }	
	void SetSelfIllum(float v, TimeValue t)
		{ selfIllumLevel = v; pblock->SetValue( ml_self_illum_amnt, t, v); }

	Color GetAmbientClr(int mtlNum, BOOL backFace ){ return ambColor;}		
    Color GetDiffuseClr(int mtlNum, BOOL backFace ){ return diffColor;}		
	Color GetSpecularClr(int mtlNum, BOOL backFace ){ return specColor1; }
	Color GetSelfIllumClr(int mtlNum, BOOL backFace ){ return selfIllum; }
	float GetSelfIllum(int mtlNum, BOOL backFace ){ return selfIllumLevel; }
	float GetSpecularLevel(int mtlNum, BOOL backFace ){ return specLevel1; }	

	Color GetAmbientClr(TimeValue t){ return pblock->GetColor(ml_ambient,t); }		
	Color GetDiffuseClr(TimeValue t){ return pblock->GetColor(ml_diffuse,t); }		
	Color GetSpecularClr(TimeValue t){ return GetSpecColor1( t );	}
	Color GetSelfIllumClr(TimeValue t){ return pblock->GetColor(ml_self_illum_color,t);}		
	float GetSelfIllum(TimeValue t){ return  pblock->GetFloat(ml_self_illum_amnt,t);}		
	float GetSpecularLevel( TimeValue t){return GetSpecLevel1( t ); }		

	void SetSelfIllumClrOn( BOOL on ){ selfIllumClrOn = on; pblock->SetValue( ml_use_self_illum_color, 0, on); }
	BOOL IsSelfIllumClrOn(){ return selfIllumClrOn; }
	BOOL IsSelfIllumClrOn(int mtlNum, BOOL backFace){ return selfIllumClrOn; }

	void SetLockAD(BOOL lock){ lockAD = lock; pblock->SetValue( ml_ad_lock, 0, lock);  }
	BOOL GetLockAD(){ return lockAD; }
	void SetLockADTex(BOOL lock){ lockADTex = lock; pblock->SetValue( ml_ad_texlock, 0, lock);  }
	BOOL GetLockADTex(){ return lockADTex; }

	// not supported
	void SetSoftenLevel(float v, TimeValue t) {}
	float GetSoftenLevel(int mtlNum=0, BOOL backFace=FALSE){ return DEFAULT_SOFTEN; }
	float GetSoftenLevel(TimeValue t){ return  DEFAULT_SOFTEN; }
	void SetLockDS(BOOL lock){}
	BOOL GetLockDS(){ return FALSE; }
};

///////////// Class Descriptor ////////////////////////
class MultiLayerShaderClassDesc : public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new MultiLayerShader(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_MULTI_LAYER); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return MultiLayerShaderClassID; }
	const TCHAR* 	Category() { return _T("");  }
	const TCHAR*	InternalName() { return _T("MultiLayer"); } // returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			 // returns owning module handle
};

MultiLayerShaderClassDesc multiLayerCD;
ClassDesc * GetMultiLayerShaderCD(){ return &multiLayerCD; }

// shader parameters
static ParamBlockDesc2 multiLayer_param_blk ( multiLayer_params, _T("shaderParameters"),  0, &multiLayerCD, P_AUTO_CONSTRUCT, 0, 
	// params
	ml_ambient, _T("ambient"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_AMBIENT, 
		p_default, Color(0, 0, 0), 
		end,
	ml_diffuse, _T("diffuse"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_DIFFUSE, 
		p_default, Color(0.5f, 0.5f, 0.5f), 
		end,
	ml_self_illum_color, _T("selfIllumColor"), TYPE_RGBA, P_ANIMATABLE, IDS_KE_SELFILLUM_CLR,	
		p_default,		Color(0, 0, 0), 
		end,
	ml_self_illum_amnt, _T("selfIllumAmount"), TYPE_PCNT_FRAC,	P_ANIMATABLE, IDS_KE_SELFILLUM,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	ml_diffuse_level, _T("diffuseLevel"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_DIFF_LEVEL,
		p_default,		100.0,
		p_range,		0.0, 400.0,
		end,
	ml_diffuse_rough, _T("diffuseRoughness"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_DIFF_ROUGH,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	ml_specular1, _T("specular"), TYPE_RGBA, P_ANIMATABLE, IDS_KE_CLR1, 
		p_default, Color(1.0f, 1.0f, 1.0f), 
		end,
	ml_specular_level1, _T("specularLevel"), TYPE_PCNT_FRAC, P_ANIMATABLE,IDS_KE_LEVEL1,
		p_default,	 	10.0,
		p_range,		0.0, 999.0,
		end,
	ml_glossiness1, _T("glossiness"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_GLOSS1,
		p_default,		25.0,
		p_range,		0.0, 100.0,
		end,
	ml_anisotropy1, _T("anisotropy"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_ANISO1,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	ml_orientation1, _T("orientation"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_ORIENTATION1,
		p_default,		0.0,
		p_range,		MIN_ORIENT*100.0, MAX_ORIENT*100.0,
		end,
	ml_specular2, _T("specular2"), TYPE_RGBA, P_ANIMATABLE, IDS_KE_CLR2, 
		p_default, Color(1.0f, 1.0f, 1.0f), 
		end,
	ml_specular_level2, _T("specularLevel2"), TYPE_PCNT_FRAC, P_ANIMATABLE,IDS_KE_LEVEL2,
		p_default,	 	0.0,
		p_range,		0.0, 999.0,
		end,
	ml_glossiness2, _T("glossiness2"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_GLOSS2,
		p_default,		25.0,
		p_range,		0.0, 100.0,
		end,
	ml_anisotropy2, _T("anisotropy2"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_ANISO2,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	ml_orientation2, _T("orientation2"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_ORIENTATION2,
		p_default,		0.0,
		p_range,		MIN_ORIENT*100.0, MAX_ORIENT*100.0,
		end,
	ml_map_channel, _T("unused"), TYPE_INT, 0, IDS_KE_MAPCHANNEL,
		p_default,		0,
		p_range,		0, 16,
		end,
	ml_ad_texlock, _T("adTextureLock"), TYPE_BOOL,	0, IDS_JW_ADTEXLOCK, 
		p_default, TRUE, 
		end,
	ml_ad_lock, _T("adLock"), TYPE_BOOL, 0, IDS_JW_ADLOCK, 
		p_default, FALSE, 
		end,
	ml_use_self_illum_color, _T("useSelfIllumColor"), TYPE_BOOL, 0, IDS_JW_SELFILLUMCOLORON,
		p_default, TRUE, 
		end,
	end
);



MultiLayerShader::MultiLayerShader() 
{ 
	pblock = NULL; 
	multiLayerCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	paramDlg = NULL; 
 
	lockAD = selfIllumClrOn = 0;
	lockADTex = TRUE;
	ambColor = diffColor = specColor1 = specColor2 = selfIllum = Color(0.0f,0.0f,0.0f);
	gloss1 = orientation1 = aniso1 = specLevel1 
	= gloss2 = orientation2 = aniso2 = specLevel2 
	= diffLevel = diffRough = selfIllumLevel = 0.0f;
	
	ivalid.SetEmpty(); 
}


void MultiLayerShader::CopyStdParams( Shader* pFrom )
{
	macroRecorder->Disable(); 
	// don't want to see this parameter copying in macrorecorder
		long fromParms = pFrom->SupportStdParams();

		if ( fromParms & STD_PARAM_SELFILLUM_CLR_ON )
			SetSelfIllumClrOn( pFrom->IsSelfIllumClrOn() );

		if ( fromParms & STD_PARAM_AMBIENT_CLR )
			SetAmbientClr( pFrom->GetAmbientClr(0,0), 0 );

		if ( fromParms & STD_PARAM_DIFFUSE_CLR )
			SetDiffuseClr( pFrom->GetDiffuseClr(0,0), 0 );
		
		if ( fromParms & STD_PARAM_SPECULAR_CLR )
			SetSpecularClr( pFrom->GetSpecularClr(0,0), 0 );

		if ( fromParms & STD_PARAM_SELFILLUM_CLR )
			SetSelfIllumClr( pFrom->GetSelfIllumClr(0,0), 0 );

		if ( fromParms & STD_PARAM_SPECULAR_LEV )
			SetSpecularLevel( pFrom->GetSpecularLevel(0,0), 0 );

		if ( fromParms & STD_PARAM_GLOSSINESS )
			SetGlossiness( pFrom->GetGlossiness(0,0), 0 );

		if ( fromParms & STD_PARAM_SELFILLUM )
			SetSelfIllum( pFrom->GetSelfIllum(0,0), 0 );

		if ( fromParms & STD_PARAM_LOCKAD )
			SetLockAD( pFrom->GetLockAD() );

		if ( fromParms & STD_PARAM_LOCKADTEX )
			SetLockADTex( pFrom->GetLockADTex() );

	macroRecorder->Enable();
	ivalid.SetEmpty();	
}


RefTargetHandle MultiLayerShader::Clone( RemapDir &remap )
{
	MultiLayerShader* mnew = new MultiLayerShader();
	mnew->ReplaceReference(0, remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	

	mnew->ambColor = ambColor;
	mnew->diffColor = diffColor;

	mnew->diffLevel = diffLevel;
	mnew->diffRough = diffRough;

	mnew->selfIllum = selfIllum;
	mnew->selfIllumLevel = selfIllumLevel;
	mnew->selfIllumClrOn = selfIllumClrOn;

	mnew->specColor1 = specColor1;
	mnew->specLevel1 = specLevel1;
	mnew->gloss1 = gloss1;
	mnew->aniso1 = aniso1;
	mnew->orientation1 = orientation1;

	mnew->specColor2 = specColor2;
	mnew->specLevel2 = specLevel2;
	mnew->gloss2 = gloss2;
	mnew->aniso2 = aniso2;
	mnew->orientation2 = orientation2;

	mnew->lockAD = lockAD;
	mnew->lockADTex = lockADTex;

	return (RefTargetHandle)mnew;
}


void MultiLayerShader::GetIllumParams( ShadeContext &sc, IllumParams& ip )
{
	ip.stdParams = SupportStdParams();
	ip.channels[_AMBCLR] = ambColor;
	ip.channels[_DIFFCLR] = diffColor;
	ip.channels[_DIFFLEV].r = diffLevel;
	ip.channels[_DIFFROUGH].r = diffRough;

	ip.channels[_SPECCLR1] = specColor1;
	ip.channels[_SPECCLR2] = specColor2;

	ip.channels[_SPECLEV1].r = specLevel1;
	ip.channels[_GL1].r = gloss1;
	ip.channels[_AN1].r = aniso1;
	ip.channels[_OR1].r = orientation1 * (1.0f/1.8f); // this range for mono texturing, 0..1

	ip.channels[_SPECLEV2].r = specLevel2;
	ip.channels[_GL2].r = gloss2;
	ip.channels[_AN2].r = aniso2;
	ip.channels[_OR2].r = orientation2 * (1.0f/1.8f);

	if (selfIllumClrOn )
		ip.channels[_SI] = selfIllum;
	else
		ip.channels[_SI].r=ip.channels[_SI].g=ip.channels[_SI].b = selfIllumLevel;
}


void MultiLayerShader::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();

		pblock->GetValue( ml_ambient, t, p, ivalid );
		ambColor = Bound(Color(p.x,p.y,p.z));
		pblock->GetValue( ml_diffuse, t, p, ivalid );
		diffColor = Bound(Color(p.x,p.y,p.z));

		pblock->GetValue( ml_diffuse_level, t, diffLevel, ivalid );
		diffLevel = Bound(diffLevel, 0.0f, 4.0f );
		pblock->GetValue( ml_diffuse_rough, t, diffRough, ivalid );
		diffRough = Bound(diffRough);

		pblock->GetValue( ml_specular1, t, p, ivalid );
		specColor1 = Bound(Color(p.x,p.y,p.z));
		pblock->GetValue( ml_specular_level1, t, specLevel1, ivalid );
		specLevel1 = Bound( specLevel1, 0.0f, 9.99f );
		pblock->GetValue( ml_glossiness1, t, gloss1, ivalid );
		gloss1 = Bound( gloss1 );
		pblock->GetValue( ml_anisotropy1, t, aniso1, ivalid );
		aniso1 = Bound( aniso1 );
		pblock->GetValue( ml_orientation1, t, orientation1, ivalid );
		orientation1 = Bound( orientation1, (float)MIN_ORIENT, (float)MAX_ORIENT );

		pblock->GetValue( ml_specular2, t, p, ivalid );
		specColor2 = Bound(Color(p.x,p.y,p.z));
		pblock->GetValue( ml_specular_level2, t, specLevel2, ivalid );
		specLevel2 = Bound( specLevel2, 0.0f, 9.99f );
		pblock->GetValue( ml_glossiness2, t, gloss2, ivalid );
		gloss2 = Bound( gloss2 );
		pblock->GetValue( ml_anisotropy2, t, aniso2, ivalid );
		aniso2 = Bound( aniso2 );
		pblock->GetValue( ml_orientation2, t, orientation2, ivalid );
		orientation2 = Bound( orientation2, (float)MIN_ORIENT, (float)MAX_ORIENT );

		pblock->GetValue( ml_self_illum_amnt, t, selfIllumLevel, ivalid );
		selfIllumLevel = Bound(selfIllumLevel);
		pblock->GetValue( ml_self_illum_color, t, p, ivalid );
		selfIllum = Bound(Color(p.x,p.y,p.z));

		// also get the non-animatables in case changed from scripter or other pblock accessors
		pblock->GetValue(ml_ad_lock, t, lockAD, ivalid);
		pblock->GetValue(ml_ad_texlock, t, lockADTex, ivalid);
		pblock->GetValue(ml_use_self_illum_color, t, selfIllumClrOn, ivalid);

	}
	valid &= ivalid;
}

void MultiLayerShader::Reset()
{
//	multiLayerCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	ivalid.SetEmpty();

	SetAmbientClr(Color(0.2f,0.2f,0.2f),0);
	SetDiffuseClr(Color(0.5f,0.5f,0.5f),0);
	SetDiffuseLevel( 1.0f,0 );
	SetDiffuseRough( 0.0f,0 );

	SetSpecColor1(Color(0.9f,0.9f,0.9f),0);
	SetSpecLevel1(0.05f,0);   
	SetGlossiness1(.50f,0);   
	SetAnisotropy1(0.0f,0);   
	SetOrientation1(0.0f,0);   

	SetSpecColor2(Color(0.9f,0.9f,0.9f),0);
	SetSpecLevel2(0.0f,0);   
	SetGlossiness2(.25f,0);   
	SetAnisotropy2(0.0f,0);   
	SetOrientation2(0.0f,0);   

	SetSelfIllumClr(Color(0.0f,0.0f,0.0f),0);
	SetSelfIllum( 0.0f,0 );
	SetSelfIllumClrOn( FALSE );

	SetLockADTex( TRUE );
	SetLockAD( FALSE );
}



//////////////////////////////////////////////////////////////////////////////////////////
//
//	IO Routines
//
#define SHADER_HDR_CHUNK 0x4000
#define SHADER_VERS_CHUNK 0x5300
#define SHADER_SELFILLUMCLR_ON_CHUNK	0x5006
#define SHADER_LOCKAD_ON_CHUNK	0x5007
#define SHADER_LOCKADTEX_ON_CHUNK	0x5008

// IO
IOResult MultiLayerShader::Save(ISave *isave) 
{ 
ULONG nb;

	isave->BeginChunk(SHADER_VERS_CHUNK);
	int version = CURRENT_MULTI_LAYER_SHADER_VERSION;
	isave->Write(&version,sizeof(version),&nb);			
	isave->EndChunk();
	return IO_OK;
}		

class MultiLayerShaderCB: public PostLoadCallback {
	public:
		MultiLayerShader *s;
		int loadVersion;
	    MultiLayerShaderCB(MultiLayerShader *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			// convert old v1 ParamBlock to ParamBlock2
			s->ReplaceReference(0,
				UpdateParameterBlock2(MultiLayerShaderPB, MULTI_LAYER_SHADER_NPARAMS, (IParamBlock*)s->pblock, &multiLayer_param_blk));

			// then set values that were previously stored outside the PB
			s->pblock->SetValue(ml_use_self_illum_color, 0, s->selfIllumClrOn);
			s->pblock->SetValue(ml_ad_lock, 0, s->lockAD);
			s->pblock->SetValue(ml_ad_texlock, 0, s->lockADTex);
		}
};


IOResult MultiLayerShader::Load(ILoad *iload)
{ 
	ULONG nb;
	int id;
	int version = 0;

	lockAD = lockADTex = selfIllumClrOn = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SHADER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
			case SHADER_SELFILLUMCLR_ON_CHUNK:
				selfIllumClrOn = TRUE;
				break;
			case SHADER_LOCKAD_ON_CHUNK:
				lockAD = TRUE;
				break;
			case SHADER_LOCKADTEX_ON_CHUNK:
				lockADTex = TRUE;
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < CURRENT_MULTI_LAYER_SHADER_VERSION ) {
		iload->RegisterPostLoadCallback(new MultiLayerShaderCB(this, version));
		iload->SetObsolete();
	}

	return IO_OK;

}

			
///////////////////////////////////////////////////////////////////////////////////////////
// The Shader
//
// defualt gloss squared, for renormalized controls
#define DEFAULT_GLOSS2	0.03f	

float MultiLayerShader::EvalHiliteCurve2( float x, float y, int layer )
{
	float g = (layer == 1)? gloss1 : gloss2;
	float a = (layer == 1)? aniso1 : aniso2;
	float specLevel = (layer == 1)? specLevel1 : specLevel2;

	return GaussHiliteCurve2( x, y, specLevel, g, a);

}


void MultiLayerShader::AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol)
{
	//NB kl,aka NL & g cancel out
//	rcol *= ip.channels[_SPECLEV1].r * ip.channels[_SPECCLR1] * DEFAULT_K_REFL; 
	rcol *= ip.channels[_SPECCLR1] * DEFAULT_K_REFL; 
}



static int stopX = -1;
static int stopY = -1;

void MultiLayerShader::Illum(ShadeContext &sc, IllumParams &ip) {
	LightDesc *l;
	Color lightCol;

#ifdef _DEBUG
	IPoint2 sp = sc.ScreenCoord();
	if ( sp.x == stopX && sp.y == stopY )
		sp.x = stopX;
#endif

	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		float NL, kL;
		Point3 L;
		if (l->Illuminate( sc, ip.N, lightCol, L, NL, kL)) {
			if (l->ambientOnly) {
				ip.ambIllumOut += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;

			// specular  
			Color spec(0.0f, 0.0f, 0.0f);
			if (l->affectSpecular) {
				Point3 T = GetTangent( sc, 0 ); 
				float g1 = GaussHighlight( ip.channels[_GL1].r, ip.channels[_AN1].r,
											ip.channels[_OR1].r, ip.N, ip.V, L, T, &NL );
										
				Color spec1 = g1 * kL * ip.channels[_SPECLEV1].r * ip.channels[_SPECCLR1] * lightCol;
				spec1 = Bound( spec1 );
				Color rem = 1.0f - spec1;

				float g2 = GaussHighlight( ip.channels[_GL2].r, ip.channels[_AN2].r,
							ip.channels[_OR2].r, ip.N, ip.V, L, T, &NL );

				Color spec2 = g2 * kL * ip.channels[_SPECLEV2].r * ip.channels[_SPECCLR2] * lightCol;

				// composite spec1 over spec2
				spec = spec1 + rem * spec2;
				ip.specIllumOut += spec;

			} // end, affect specular

			// diffuse
			if (l->affectDiffuse){
				Color d = OrenNayarIllum( ip.N, L, -ip.V, ip.channels[_DIFFROUGH].r * Pi*0.5f, ip.channels[_DIFFCLR], NL );
				d = d * ip.channels[_DIFFLEV].r; // diff lev
				ip.diffIllumOut += kL * d * lightCol;
			}

		} // end, illuminated
	} // for each light

	// Apply mono self illumination
	if ( ! selfIllumClrOn ){
		float si = 0.3333333f * (ip.channels[_SI].r + ip.channels[_SI].g + ip.channels[_SI].b);
//		float si = ip.channels[_SI].r;
		if ( si > 0.0f ) {
			if ( si >= 1.0f ) {
				ip.selfIllumOut +=  ip.channels[_DIFFCLR];
				ip.diffIllumOut = Color( 0.0f, 0.0f, 0.0f );
			} else {
				ip.selfIllumOut += si * ip.channels[_DIFFCLR];;
				ip.diffIllumOut *= (1.0f - si); // * ip.channels[_DIFFCLR]; 
				// fade the ambient down on si: 5/27/99 ke
				ip.ambIllumOut *= 1.0f-si;
			}
		}
	} else {
		// colored self illum, 
		ip.selfIllumOut += ip.channels[_SI];
	}

	// now we can multiply by the clrs
	ip.ambIllumOut *= ip.channels[_AMBCLR]; 

	// get the diffuse intensity...unscramble the wavelength dependence
	float rho, diffIntens;
	rho = ip.channels[_DIFFCLR].r == 0.0f ? 1.0f : 1.0f / ip.channels[_DIFFCLR].r;
	diffIntens = ip.diffIllumOut.r * rho;
	rho = ip.channels[_DIFFCLR].g == 0.0f ? 1.0f : 1.0f / ip.channels[_DIFFCLR].g;
	diffIntens += ip.diffIllumOut.g * rho;
	rho = ip.channels[_DIFFCLR].b == 0.0f ? 1.0f : 1.0f / ip.channels[_DIFFCLR].b;
	diffIntens += ip.diffIllumOut.b * rho;
	ip.diffIllumIntens = diffIntens * 0.5f;
}



///////////////////////// The dialog class //////////////////////////////////
class MultiLayerShaderDlg : public ShaderParamDlg {
public:
	MultiLayerShader*	pShader;
	StdMat2*	pMtl;
	HPALETTE	hOldPal;
	HWND		hwmEdit;	// window handle of the materials editor dialog
	IMtlParams*	pMtlPar;
	HWND		hwHilite1;   // the hilite windows
	HWND		hwHilite2;
	HWND		hRollup;	// Rollup panel
	TimeValue	curTime;
	BOOL		valid;
	BOOL		isActive;

	IColorSwatch *cs[MULTI_LAYER_NCOLBOX];
	ISpinnerControl *lev1Spin, *gl1Spin, *an1Spin;
	ISpinnerControl *lev2Spin, *gl2Spin, *an2Spin;
	ISpinnerControl *dlevSpin, *droughSpin,*or1Spin, *or2Spin, *trSpin, *siSpin;
	ICustButton* texMBut[MULTI_LAYER_NMBUTS];
	TexDADMgr dadMgr;
	
	MultiLayerShaderDlg( HWND hwMtlEdit, IMtlParams *pParams ); 
	~MultiLayerShaderDlg(); 

	// required for correctly operating map buttons
	int FindSubTexFromHWND(HWND hw) {
		for (long i=0; i < MULTI_LAYER_NMBUTS; i++) {
			if (hw == texMBut[i]->GetHwnd()) 
				return texmapFromMBut[i];
		}	
		return -1;
	}

	// Methods
	BOOL PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ); 
	Class_ID ClassID(){ return MultiLayerShaderClassID; }

	void SetThing(ReferenceTarget *m){ pMtl = (StdMat2*)m; }
	void SetThings( StdMat2* theMtl, Shader* theShader )
	{	if (pShader) pShader->SetParamDlg(NULL);   
		pShader = (MultiLayerShader*)theShader; 
		if(pShader) pShader->SetParamDlg(this);
		pMtl = theMtl;
	}
	ReferenceTarget* GetThing(){ return pMtl; } // mtl is the thing! (for DAD!)
	Shader* GetShader(){ return pShader; }
	
	void SetTime(TimeValue t) {
		//DS 2/26/99: added interval test to prevent redrawing when not necessary
		if (!pShader->ivalid.InInterval(t)) {
			Interval v;
			pShader->Update(t,v);
			LoadDialog(TRUE); 
			}
		curTime = t; 
		}		
	BOOL KeyAtCurTime(int id) { return pShader->KeyAtTime(id,curTime); } 
	void DeleteThis() { delete this; }
	void ActivateDlg( BOOL dlgOn ){ isActive = dlgOn; }
	HWND GetHWnd(){ return hRollup; }
	void NotifyChanged(){ pShader->NotifyChanged(); }
	void LoadDialog(BOOL draw);
	void ReloadDialog(){ Interval v; pShader->Update(pMtlPar->GetTime(), v); LoadDialog(FALSE);}
	void UpdateDialog( ParamID paramId ){ ReloadDialog(); }

	void UpdateMtlDisplay(){ pMtlPar->MtlChanged(); } // redraw viewports
    void UpdateHilite( long nHilite );
	void UpdateColSwatches();
	void UpdateMapButtons();
	void UpdateOpacity();
	void SetLockADTex(BOOL lock);
	void SetLockAD(BOOL lock);
	void UpdateLockADTex( BOOL passOn);	
	
	void SelectEditColor(int i) { cs[ i ]->EditThis(FALSE); }
};

static BOOL CALLBACK  MultiLayerShaderDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	MultiLayerShaderDlg *theDlg;
	if (msg == WM_INITDIALOG) {
		theDlg = (MultiLayerShaderDlg*)lParam;
		SetWindowLong(hwndDlg, GWL_USERDATA, lParam);
	} else {
	    if ( (theDlg = (MultiLayerShaderDlg*)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
	}
	theDlg->isActive = 1;
	BOOL res = theDlg->PanelProc(hwndDlg, msg, wParam, lParam);
	theDlg->isActive = 0;
	return res;
}


ShaderParamDlg* MultiLayerShader::CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen ) 
{
	Interval v;
	Update(imp->GetTime(),v);
	
	paramDlg = new MultiLayerShaderDlg(hwMtlEdit, imp);
	paramDlg->SetThings( theMtl, this  );

	LoadStdShaderResources();
	if ( hOldRollup ) {
		paramDlg->hRollup = imp->ReplaceRollupPage( 
			hOldRollup,
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_MULTILAYER1),
			MultiLayerShaderDlgProc, 
			GetString(IDS_KE_MULTI_LAYER_BASIC),	// your name here
			(LPARAM)paramDlg , 
			rollupOpen
			);
	} else
		paramDlg->hRollup = imp->AddRollupPage( 
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_MULTILAYER1),
			MultiLayerShaderDlgProc, 
			GetString(IDS_KE_MULTI_LAYER_BASIC),	
			(LPARAM)paramDlg , 
			rollupOpen
			);

	return (ShaderParamDlg*)paramDlg;	
}

RefResult MultiLayerShader::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
									  PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock){
				// update UI if paramblock changed, possibly from scripter
				ParamID changingParam = pblock->LastNotifyParamID();
				// reload the dialog if present
				if (paramDlg){
					paramDlg->UpdateDialog( changingParam );
				}
			}
			break;
	}
	return(REF_SUCCEED);
}


MultiLayerShaderDlg::MultiLayerShaderDlg( HWND hwMtlEdit, IMtlParams *pParams)
{
	pMtl = NULL;
	pShader = NULL;
	hwmEdit = hwMtlEdit;
	pMtlPar = pParams;
	dadMgr.Init(this);
	dlevSpin = droughSpin =lev1Spin = lev2Spin = gl1Spin = an1Spin =gl2Spin = an2Spin = NULL;
	or1Spin = or2Spin = trSpin = siSpin = NULL;
	hRollup = hwHilite1 = hwHilite2 =NULL;
	curTime = pMtlPar->GetTime();

	isActive = valid = FALSE;

	for( long i = 0; i < MULTI_LAYER_NCOLBOX; ++i )
		cs[ i ] = NULL;

	for( i = 0; i < MULTI_LAYER_NMBUTS; ++i )
		texMBut[ i ] = NULL;
}

MultiLayerShaderDlg::~MultiLayerShaderDlg()
{
	HDC hdc = GetDC(hRollup);
	GetGPort()->RestorePalette(hdc, hOldPal);
	ReleaseDC(hRollup, hdc);

	if( pShader ) pShader->SetParamDlg(NULL);

	for (long i=0; i < MULTI_LAYER_NMBUTS; i++ ){
		ReleaseICustButton( texMBut[i] );
		texMBut[i] = NULL; 
	}

	for (i=0; i<MULTI_LAYER_NCOLBOX; i++)
		if (cs[i]) ReleaseIColorSwatch(cs[i]); // mjm - 5.10.99

 	ReleaseISpinner(dlevSpin);
 	ReleaseISpinner(droughSpin);
 	ReleaseISpinner(lev1Spin);
	ReleaseISpinner(lev2Spin);
	ReleaseISpinner(gl1Spin);
	ReleaseISpinner(an1Spin);
	ReleaseISpinner(gl2Spin);
	ReleaseISpinner(an2Spin);
	ReleaseISpinner(or1Spin);
	ReleaseISpinner(or2Spin);
	ReleaseISpinner(trSpin);
	ReleaseISpinner(siSpin);

	SetWindowLong(hRollup, GWL_USERDATA, NULL);
	SetWindowLong(hwHilite1, GWL_USERDATA, NULL);
	SetWindowLong(hwHilite2, GWL_USERDATA, NULL);
	hwHilite1 = hwHilite2 = hRollup = NULL;
}


void  MultiLayerShaderDlg::LoadDialog(BOOL draw) 
{
	if (pShader && hRollup) {
		dlevSpin->SetValue(FracToPc(pShader->GetDiffuseLevel(0,0)),FALSE);
		dlevSpin->SetKeyBrackets(KeyAtCurTime(ml_diffuse_level));
		droughSpin->SetValue(FracToPc(pShader->GetDiffuseRough(0,0)),FALSE);
		droughSpin->SetKeyBrackets(KeyAtCurTime(ml_diffuse_rough));
		lev1Spin->SetValue(FracToPc(pShader->GetSpecLevel1(0,0)),FALSE);
		lev1Spin->SetKeyBrackets(KeyAtCurTime(ml_specular_level1));
		lev2Spin->SetValue(FracToPc(pShader->GetSpecLevel2(0,0)),FALSE);
		lev2Spin->SetKeyBrackets(KeyAtCurTime(ml_specular_level2));

		gl1Spin->SetValue( FracToPc(pShader->GetGlossiness1(0,0)), FALSE);
		gl1Spin->SetKeyBrackets(KeyAtCurTime(ml_glossiness1));
		gl2Spin->SetValue( FracToPc(pShader->GetGlossiness2(0,0)), FALSE);
		gl2Spin->SetKeyBrackets(KeyAtCurTime(ml_glossiness2));

		an1Spin->SetValue( FracToPc(pShader->GetAnisotropy1(0,0)), FALSE);
		an1Spin->SetKeyBrackets(KeyAtCurTime(ml_anisotropy1));
		an2Spin->SetValue( FracToPc(pShader->GetAnisotropy2(0,0)), FALSE);
		an2Spin->SetKeyBrackets(KeyAtCurTime(ml_anisotropy2));

		or1Spin->SetValue( FracToPc(pShader->GetOrientation1(0,0)), FALSE);
		or1Spin->SetKeyBrackets(KeyAtCurTime(ml_orientation1));
		or2Spin->SetValue( FracToPc(pShader->GetOrientation2(0,0)), FALSE);
		or2Spin->SetKeyBrackets(KeyAtCurTime(ml_orientation2));

		trSpin->SetValue(FracToPc(pMtl->GetOpacity( curTime )),FALSE);
		trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));

		//  color selfIllum
		BOOL colorSelfIllum = pShader->IsSelfIllumClrOn();
		SetCheckBox(hRollup,IDC_SI_COLORON, colorSelfIllum ); 
		if( colorSelfIllum ) {
//			ShowWindow( siSpin->GetHwnd(), SW_HIDE );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_EDIT), SW_HIDE );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_SPIN), SW_HIDE );
			ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_SHOW );
		} else {
			// disable the color swatch
			ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
			// show self-illum slider
//			ShowWindow( siSpin->GetHwnd(), SW_SHOW );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_EDIT), SW_SHOW );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_SPIN), SW_SHOW );

			siSpin->SetValue(FracToPc(pShader->GetSelfIllum(0,0)), FALSE);
			siSpin->SetKeyBrackets(KeyAtCurTime(ml_self_illum_amnt));
		}
		CheckButton(hRollup, IDC_LOCK_AD, pShader->GetLockAD() );

		UpdateLockADTex( 0 );
		UpdateColSwatches();
		UpdateHilite2( hwHilite1, pShader, 1 );
		UpdateHilite2( hwHilite2, pShader, 2 );
	}
}



static TCHAR* mapStates[] = { _T(" "), _T("m"),  _T("M") };

void MultiLayerShaderDlg::UpdateMapButtons() 
{

	for ( long i = 0; i < MULTI_LAYER_NMBUTS; ++i ) {
		int nMap = texmapFromMBut[ i ];
		int state = pMtl->GetMapState( nMap );
		texMBut[i]->SetText( mapStates[ state ] );

		TSTR nm	 = pMtl->GetMapName( nMap );
		texMBut[i]->SetTooltip(TRUE, nm);
	}
}


void MultiLayerShaderDlg::UpdateOpacity() 
{
	trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
	trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));
}


void MultiLayerShaderDlg::UpdateColSwatches() 
{
	cs[0]->SetColor( pShader->GetAmbientClr( curTime ) );
	cs[0]->SetKeyBrackets( pShader->KeyAtTime(ml_ambient, curTime) );

	cs[1]->SetColor( pShader->GetDiffuseClr( curTime ) );
	cs[1]->SetKeyBrackets( pShader->KeyAtTime(ml_diffuse, curTime) );

	cs[2]->SetColor( pShader->GetSelfIllumClr( curTime ) );
	cs[2]->SetKeyBrackets( pShader->KeyAtTime(ml_self_illum_color, curTime) );

	cs[3]->SetColor( pShader->GetSpecColor1( curTime ) );
	cs[3]->SetKeyBrackets( pShader->KeyAtTime(ml_specular1, curTime) );

	cs[4]->SetColor( pShader->GetSpecColor2( curTime ) );
	cs[4]->SetKeyBrackets( pShader->KeyAtTime(ml_specular2, curTime) );
}

void MultiLayerShaderDlg::SetLockAD(BOOL lock)
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_DS_LOCKAD), GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_AD, FALSE);	
			return;	
		}
		// set ambient color to diffuse
		pShader->SetAmbientClr( pShader->GetDiffuseClr(0,0), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockAD(lock);
}


void MultiLayerShaderDlg::UpdateLockADTex( BOOL passOn)
{
	int lock = 	pShader->GetLockADTex();
	CheckButton(hRollup, IDC_LOCK_ADTEX, lock);

	ShowWindow(GetDlgItem(hRollup, IDC_MAPON_AM), !lock);
	texMBut[ 0 ]->Enable(!lock);

	if ( passOn ) {
		pMtl->SyncADTexLock( lock );
	}
//	UpdateMtlDisplay();
}

void MultiLayerShaderDlg::SetLockADTex(BOOL lock)
{
	pShader->SetLockADTex( lock );
	UpdateLockADTex(TRUE); // passon to mtl
//	UpdateMtlDisplay();
}


static int ColorIDCToIndex(int idc) {
	switch (idc) {
		case IDC_AMB_CLR:   return 0;
		case IDC_DIFF_CLR:  return 1;
		case IDC_SI_CLR:	  return 2;
		case IDC_SPEC_CLR1: return 3;
		case IDC_SPEC_CLR2: return 4;
		default: return 0;
	}
}


BOOL MultiLayerShaderDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG:
			{
			HDC theHDC = GetDC(hwndDlg);
			hOldPal = GetGPort()->PlugPalette(theHDC);
			ReleaseDC(hwndDlg,theHDC);

   			cs[0] = GetIColorSwatch(GetDlgItem(hwndDlg, IDC_AMB_CLR), 
						pShader->GetAmbientClr(0,0), GetString(IDS_DS_AMBIENT) );

   			cs[1] = GetIColorSwatch(GetDlgItem(hwndDlg, IDC_DIFF_CLR), 
						pShader->GetDiffuseClr(0,0), GetString(IDS_DS_DIFFUSE) );

   			cs[2] = GetIColorSwatch(GetDlgItem(hwndDlg, IDC_SI_CLR), 
						pShader->GetSelfIllumClr(0,0), GetString(IDS_KE_SELFILLUM_CLR) );

			cs[3] = GetIColorSwatch(GetDlgItem(hwndDlg, IDC_SPEC_CLR1), 
						pShader->GetSpecColor1(0,0), GetString(IDS_KE_SPEC_CLR1) );

   			cs[4] = GetIColorSwatch(GetDlgItem(hwndDlg, IDC_SPEC_CLR2), 
						pShader->GetSpecColor2(0,0), GetString(IDS_KE_SPEC_CLR2) );


			hwHilite1 = GetDlgItem(hwndDlg, IDC_HIGHLIGHT1 );
			SetWindowLong( hwHilite1, GWL_WNDPROC, (LONG)Hilite2Layer1WndProc);
			hwHilite2 = GetDlgItem(hwndDlg, IDC_HIGHLIGHT2 );
			SetWindowLong( hwHilite2, GWL_WNDPROC, (LONG)Hilite2Layer2WndProc);

			dlevSpin = SetupIntSpinner(hwndDlg, IDC_DIFFLEV_SPIN, IDC_DIFFLEV_EDIT, 0,400, 0);
			droughSpin = SetupIntSpinner(hwndDlg, IDC_DIFFROUGH_SPIN, IDC_DIFFROUGH_EDIT, 0,100, 0);
			lev1Spin = SetupIntSpinner(hwndDlg, IDC_SPEC_LEV1_SPIN, IDC_SPEC_LEV1_EDIT, 0,999, 0);
			gl1Spin = SetupIntSpinner(hwndDlg, IDC_GL1_SPIN, IDC_GL1_EDIT, 0,100, 0);
			an1Spin = SetupIntSpinner(hwndDlg, IDC_AN1_SPIN, IDC_AN1_EDIT, 0,100, 0);

			lev2Spin = SetupIntSpinner(hwndDlg, IDC_SPEC_LEV2_SPIN, IDC_SPEC_LEV2_EDIT, 0, 999, 0);
			gl2Spin = SetupIntSpinner(hwndDlg, IDC_GL2_SPIN, IDC_GL2_EDIT, 0,100, 0);
			an2Spin = SetupIntSpinner(hwndDlg, IDC_AN2_SPIN, IDC_AN2_EDIT, 0,100, 0);
			
			or1Spin = SetupIntSpinner(hwndDlg, IDC_OR1_SPIN, IDC_OR1_EDIT, -9999, 9999, 0);
			or2Spin = SetupIntSpinner(hwndDlg, IDC_OR2_SPIN, IDC_OR2_EDIT, -9999, 9999, 0);
			trSpin = SetupIntSpinner(hwndDlg, IDC_TR_SPIN, IDC_TR_EDIT, 0,100, 0);
			siSpin = SetupIntSpinner(hwndDlg, IDC_SI_SPIN, IDC_SI_EDIT, 0,100, 0);

			if( pShader->IsSelfIllumClrOn() ) {
				// enable the color swatch, disable the spinner
				ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_HIDE );
				ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_HIDE );
			} else {
				// disable the color swatch
				ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
			}
	
			for (int j=0; j < MULTI_LAYER_NMBUTS; j++) {
				texMBut[j] = GetICustButton(GetDlgItem(hwndDlg,texMButtonsIDC[j]));
				assert( texMBut[j] );
				texMBut[j]->SetRightClickNotify(TRUE);
				texMBut[j]->SetDADMgr(&dadMgr);
			}

			SetupLockButton(hwndDlg,IDC_LOCK_AD,FALSE);
			SetupPadLockButton(hwndDlg,IDC_LOCK_ADTEX, TRUE);

			LoadDialog(TRUE);
		}
		break;

		case WM_COMMAND: 
			{
			for ( int i=0; i < MULTI_LAYER_NMBUTS; i++) {
				if (id == texMButtonsIDC[i]) {
					PostMessage(hwmEdit,WM_TEXMAP_BUTTON, texmapFromMBut[i],(LPARAM)pMtl );
					UpdateMapButtons();
					goto exit;
					}
				}
			}
		    switch (id) {

				case IDC_LOCK_AD:
					SetLockAD(IsButtonChecked(hwndDlg, IDC_LOCK_AD));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_ADTEX:{
					BOOL on = IsButtonChecked(hwndDlg, IDC_LOCK_ADTEX);
					SetLockADTex(on);
					UpdateMtlDisplay();
				} break;

				case IDC_SI_COLORON:{
					int isOn = GetCheckBox(hwndDlg, IDC_SI_COLORON );
					pShader->SetSelfIllumClrOn( isOn );			
					if ( isOn ) {
						// enable the color swatch, disable the spinner
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_HIDE );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_HIDE );
						ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_SHOW );
					} else {
						// disable the color swatch
						ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_SHOW );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_SHOW );
					}
				    NotifyChanged();
//					UpdateMtlDisplay();
				}
				break;

			}
			break;
		case CC_COLOR_SEL: {
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
		}			
		break;
		case CC_COLOR_DROP:	{
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
			UpdateMtlDisplay();				
		}
		break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
		 break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			UpdateMtlDisplay();
			break;
		case CC_COLOR_CHANGE: {			
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = ColorIDCToIndex(id);
			if (buttonUp) theHold.Begin();
			DWORD curRGB = cs[n]->GetColor();
			switch ( n ) {
			  case 0:	pShader->SetAmbientClr( curRGB, curTime ); 
						if ( pShader->GetLockAD() )
							pShader->SetDiffuseClr(curRGB, curTime);
				  break;
			  case 1:	pShader->SetDiffuseClr( curRGB, curTime ); 
						if ( pShader->GetLockAD() )
							pShader->SetAmbientClr( curRGB, curTime ); 
				  break;
			  case 2:	pShader->SetSelfIllumClr( curRGB, curTime ); break;
			  case 3:	pShader->SetSpecColor1( curRGB, curTime ); break;
			  case 4:	pShader->SetSpecColor2( curRGB, curTime ); break;
			}
			if (buttonUp) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
				NotifyChanged();
				// DS: 5/11/99-  this was commented out. I put it back in, because
				// it is necessary for the Reset button in the color picker to 
				// update the viewport.				
				UpdateMtlDisplay();  
				}
		} break;
		case WM_PAINT: 
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
		case WM_DESTROY: 
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_DIFFLEV_SPIN: 
					pShader->SetDiffuseLevel( PcToFrac( dlevSpin->GetIVal() ), curTime ); 
					break;
				case IDC_DIFFROUGH_SPIN: 
					pShader->SetDiffuseRough( PcToFrac( droughSpin->GetIVal() ), curTime ); 
					break;
				case IDC_SPEC_LEV1_SPIN: 
					pShader->SetSpecLevel1( PcToFrac( lev1Spin->GetIVal() ), curTime ); 
					UpdateHilite2( hwHilite1, pShader, 1 );
					break;
				case IDC_GL1_SPIN: 
					pShader->SetGlossiness1( PcToFrac( gl1Spin->GetIVal() ), curTime ); 
					UpdateHilite2( hwHilite1, pShader, 1 );
					break;
				case IDC_AN1_SPIN: 
					pShader->SetAnisotropy1( PcToFrac( an1Spin->GetIVal() ), curTime ); 
					UpdateHilite2( hwHilite1, pShader, 1 );
					break;

				case IDC_GL2_SPIN: 
					pShader->SetGlossiness2( PcToFrac( gl2Spin->GetIVal() ), curTime ); 
					UpdateHilite2( hwHilite2, pShader, 2 );
					break;
				case IDC_AN2_SPIN: 
					pShader->SetAnisotropy2( PcToFrac( an2Spin->GetIVal() ), curTime ); 
					UpdateHilite2( hwHilite2, pShader, 2 );
					break;
				case IDC_SPEC_LEV2_SPIN: 
					pShader->SetSpecLevel2( PcToFrac( lev2Spin->GetIVal() ), curTime ); 
					UpdateHilite2( hwHilite2, pShader, 2 );
					break;

				case IDC_OR1_SPIN: 
					pShader->SetOrientation1( PcToFrac(or1Spin->GetIVal()), curTime ); 
					break;
				case IDC_OR2_SPIN: 
					pShader->SetOrientation2( PcToFrac(or2Spin->GetIVal()), curTime ); 
					break;
				case IDC_SI_SPIN: 
					pShader->SetSelfIllum(PcToFrac(siSpin->GetIVal()),curTime); 
					break;
					//***** >>>><<<< required handling for opacity....must be present in all dialogs
				case IDC_TR_SPIN: 
					pMtl->SetOpacity(PcToFrac( trSpin->GetIVal()),curTime); 
					break;
			}
//			UpdateMtlDisplay();
		break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;

    }
	exit:
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shaderAniso.cpp ===
///////////////////////////////////////////////////////////////////
//
//	Aniso2 .. a Ward derivative shader & dlg panel
//
//		Created: 11/3/98 Kells Elmquist
//
#include "shadersPch.h"
#include "shadersRc.h"
#include "gport.h"
#include "shaders.h"
#include "shaderUtil.h"
#include "macrorec.h"


// Class Ids
#define ANISOSHADER_CLASS_ID		0x2857f460

static Class_ID AnisoShaderClassID( ANISOSHADER_CLASS_ID, 0);
static Class_ID AnisoShaderDlgClassID( ANISOSHADER_CLASS_ID, 0);

// paramblock2 block and parameter IDs.
enum { aniso_params, };
// shdr_params param IDs
enum 
{ 
	an_ambient, an_diffuse, an_specular, an_self_illum_color,
	an_diffuse_level, an_specular_level, an_self_illum_amnt, 
	an_glossiness, an_anisotropy, an_orientation, 
	an_map_channel, an_ad_texlock, an_ad_lock, an_ds_lock, an_use_self_illum_color, 
};


/////////////////////////////////////////////////////////////////////
//
//	Basic Panel UI 
//
#define ANISO_NMBUTS 10
#define N_TR_BUT 7

// tex channel number to button IDC
static int texMButtonsIDC[] = {
	IDC_MAPON_AM, IDC_MAPON_DI, IDC_MAPON_SP, 
	IDC_MAPON_DLEV, IDC_MAPON_SLEV, IDC_MAPON_GL, IDC_MAPON_AN,
	IDC_MAPON_OR, IDC_MAPON_SI, IDC_MAPON_TR, 
	};
		
// This array gives the texture map number for given MButton number								
static int texmapFromMBut[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

// Texture Maps
#define ANISO_NTEXMAPS	11

// channels ids needed by shader
#define A_AM	0
#define A_DI	1
#define A_SP	2
#define A_DL	3
#define A_SL	4
#define A_GL	5
#define A_AN	6
#define A_OR	7
#define A_SI	8

// channel names
// sized for nmax  textures
static int texNameIDS[STD2_NMAX_TEXMAPS] = {
	IDS_DS_AMBIENT,	IDS_DS_DIFFUSE,	IDS_DS_SPECULAR, 
	IDS_KE_DIFF_LEVEL, IDS_KE_SPEC_LEVEL, IDS_KE_GLOSSINESS, IDS_KE_ANISOTROPY, 
	IDS_KE_ORIENTATION, IDS_KE_SELFILLUM,
	IDS_DS_TRANS, IDS_DS_FILTER, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
};	

// internal non-local parsable channel map names
static TCHAR* texInternalNames[STD2_NMAX_TEXMAPS] = {
	_T("ambientMap"), _T("diffuseMap"),	_T("specularMap"), _T("diffuseLevelMap"), 
	_T("specularLevelMap"), _T("glossinessMap"), _T("anisotropyMap"), _T("orientationMap"),
	_T("selfIllumMap"), _T("opacityMap"), _T("filterMap"),	
	_T(""), _T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""), _T(""),
};	

// sized for nmax textures
// bump, reflection & refraction maps are ignored....done after shading
static int chanType[] = {
	CLR_CHANNEL, CLR_CHANNEL, CLR_CHANNEL, MONO_CHANNEL, 
	MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL,  
	CLR_CHANNEL, MONO_CHANNEL, CLR_CHANNEL,	UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL,
};	

// what channel corresponds to the stdMat ID's
static int stdIDToChannel[N_ID_CHANNELS] = { 0, 1, 2, 5, 4, 8, 9, 10, -1, -1, -1, -1 };

//////////////////////////////////////////////////////////////////////////////////////////
//
//		Aniso Parameter Block
//
#define CURRENT_ANISO_SHADER_VERSION	2
#define ANISO_SHADER_NPARAMS			10
#define ANISO_SHADER_PB_VERSION			1
#define ANISO_NCOLBOX					4

static int colID[ANISO_NCOLBOX] = { IDC_STD_COLOR1, IDC_STD_COLOR2, IDC_STD_COLOR3, IDC_SI_COLOR };
#define N_AMB_CLR		0
#define N_SI_CLR		3

#define PB_AMBIENT_CLR		0
#define PB_DIFFUSE_CLR		1
#define PB_SPECULAR_CLR		2
#define PB_SELFILLUM_CLR	3
#define PB_DIFFUSE_LEV		4
#define PB_SPECULAR_LEV		5
#define PB_SELFILLUM_LEV	6
#define PB_GLOSSINESS		7
#define PB_ANISOTROPY		8
#define PB_ORIENTATION		9

//v1 Param Block Descriptor
static ParamBlockDescID AnisoShaderPB[ ANISO_SHADER_NPARAMS ] = {
	{ TYPE_RGBA,  NULL, TRUE, an_ambient },   // ambient
	{ TYPE_RGBA,  NULL, TRUE, an_diffuse },   // diffuse
	{ TYPE_RGBA,  NULL, TRUE, an_specular },   // specular
	{ TYPE_RGBA,  NULL, TRUE, an_self_illum_color },   // selfIllumClr 
	{ TYPE_FLOAT, NULL, TRUE, an_diffuse_level },  // diffuse level
	{ TYPE_FLOAT, NULL, TRUE, an_specular_level },   // specularLevel
	{ TYPE_FLOAT, NULL, TRUE, an_self_illum_amnt },   // selfIllumLevel
	{ TYPE_FLOAT, NULL, TRUE, an_glossiness },   // glossiness 
	{ TYPE_FLOAT, NULL, TRUE, an_anisotropy },  // eccentricity or anisotropy
	{ TYPE_FLOAT, NULL, TRUE, an_orientation },  // orientation
}; 


#define ANISO_NUMOLDVER 1

static ParamVersionDesc oldVersions[ANISO_NUMOLDVER] = {
	ParamVersionDesc(AnisoShaderPB, ANISO_SHADER_NPARAMS, 0),
};

//----------------------------------------------------------------------------------------
//---- Ward Derivative Elliptical Gaussian Anisotropic Shader ----------------------------
//----------------------------------------------------------------------------------------

class AnisoShaderDlg;

class AnisoShader : public Shader {
friend class AnisoShaderCB;
friend class AnisoShaderDlg;
protected:
	IParamBlock2	 *pblock;   // ref 0
	Interval		ivalid;

	AnisoShaderDlg*	paramDlg;

	BOOL			selfIllumClrOn;
	BOOL			lockDS;
	BOOL			lockAD;
	BOOL			lockADTex;

	Color			ambient;
	Color			diffuse;
	Color			specular;
	Color			selfIllum;
	float			glossiness;
	float			orientation;
	float			anisotropy;
	float			specLevel;
	float			diffLevel;
	float			selfIllumLevel;

	public:
	AnisoShader();
	void DeleteThis(){ delete this; }		
    ULONG SupportStdParams(){ return STD_ANISO | STD_EXTRA; }
	// copy std params, for switching shaders
    void CopyStdParams( Shader* pFrom );

	// texture maps
	long  nTexChannelsSupported(){ return ANISO_NTEXMAPS; }
	TSTR  GetTexChannelName( long nTex ){ return GetString( texNameIDS[ nTex ] ); }
	TSTR GetTexChannelInternalName( long nTex ){ return texInternalNames[ nTex ]; }
	long ChannelType( long nChan ) { return chanType[nChan]; }
	long StdIDToChannel( long stdID ){ return stdIDToChannel[stdID]; }

	BOOL KeyAtTime(int id,TimeValue t) { return pblock->KeyFrameAtTime(id,t); }
	ULONG GetRequirements( int subMtlNum ){ return MTLREQ_PHONG; }

	ShaderParamDlg* CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen );
	ShaderParamDlg* GetParamDlg(){ return (ShaderParamDlg*)paramDlg; }
	void SetParamDlg( ShaderParamDlg* newDlg ){ paramDlg = (AnisoShaderDlg*)newDlg; }

	Class_ID ClassID() { return AnisoShaderClassID; }
	TSTR GetName() { return GetString( IDS_KE_ANISO ); }
	void GetClassName(TSTR& s) { s = GetName(); }  

	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i){ return (i==0)? pblock : NULL; }
	TSTR SubAnimName(int i){ return TSTR(GetString( IDS_KE_ANISO_PARMS )); };
	int SubNumToRefNum(int subNum) { return subNum;	}

	// add direct ParamBlock2 access
	int	NumParamBlocks() { return 1; }
	IParamBlock2* GetParamBlock(int i) { return pblock; }
	IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } 

 	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i){ return (i==0)? pblock : NULL; }
	void SetReference(int i, RefTargetHandle rtarg) 
		{ if (i==0) pblock = (IParamBlock2*)rtarg; else assert(0); }
	void NotifyChanged(){ NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE); }

	void Update(TimeValue t, Interval& valid);
	void Reset();
	RefTargetHandle Clone( RemapDir &remap=NoRemap() );
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	                            PartID& partID, RefMessage message );
	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);


	// Aniso Shader specific section
	void  Illum(ShadeContext &sc, IllumParams &ip);
	float EvalHiliteCurve2(float x, float y, int layer=0 );
	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol);
	void CombineComponents( ShadeContext &sc, IllumParams& ip ){ CombineComponentsComp( ip ); }
	// cache for mapping of params, mtl fills in ip
	void GetIllumParams( ShadeContext &sc, IllumParams& ip );

	void SetGlossiness(float v, TimeValue t)		
		{ glossiness= v; pblock->SetValue( an_glossiness, t, v); }
	void SetAnisotropy(float v, TimeValue t)		
		{ anisotropy = v; pblock->SetValue( an_anisotropy, t, v); }
	void SetOrientation(float v, TimeValue t)		
		{ orientation = v; pblock->SetValue( an_orientation, t, v); }
	float GetGlossiness(int mtlNum=0, BOOL backFace=FALSE){ return glossiness; };	
	float GetAnisotropy(int mtlNum=0, BOOL backFace=FALSE){ return anisotropy; };	
	float GetOrientation(int mtlNum=0, BOOL backFace=FALSE){ return orientation; };	
	float GetGlossiness( TimeValue t){return pblock->GetFloat(an_glossiness,t);  }		
	float GetAnisotropy( TimeValue t){return pblock->GetFloat(an_anisotropy,t);  }		
	float GetOrientation( TimeValue t){return pblock->GetFloat(an_orientation,t);  }		

	// Std Params
	void SetLockDS(BOOL lock){ lockDS = lock; pblock->SetValue( an_ds_lock, 0, lock); }
	BOOL GetLockDS(){ return lockDS; }
	void SetLockAD(BOOL lock){ lockAD = lock; pblock->SetValue( an_ad_lock, 0, lock);  }
	BOOL GetLockAD(){ return lockAD; }
	void SetLockADTex(BOOL lock){ lockADTex = lock; pblock->SetValue( an_ad_texlock, 0, lock);  }
	BOOL GetLockADTex(){ return lockADTex; }

	void SetAmbientClr(Color c, TimeValue t)		
		{ ambient = c; pblock->SetValue( an_ambient, t, c); }
	void SetDiffuseClr(Color c, TimeValue t)		
		{ diffuse = c; pblock->SetValue( an_diffuse, t, c); }
	void SetSpecularClr(Color c, TimeValue t)
		{ specular = c; pblock->SetValue( an_specular, t, c); }
	void SetSelfIllumClr(Color c, TimeValue t)
		{ selfIllum = c; pblock->SetValue( an_self_illum_color, t, c); }
	void SetDiffuseLevel(float v, TimeValue t)		
		{ diffLevel = v; pblock->SetValue( an_diffuse_level, t, v); }
	void SetSpecularLevel(float v, TimeValue t)		
		{ specLevel = v; pblock->SetValue( an_specular_level, t, v); }
	void SetSelfIllum(float v, TimeValue t)
		{ selfIllumLevel = v; pblock->SetValue( an_self_illum_amnt, t, v); }

	Color GetAmbientClr(int mtlNum=0, BOOL backFace=FALSE){ return ambient;}		
    Color GetDiffuseClr(int mtlNum=0, BOOL backFace=FALSE){ return diffuse;}		
	Color GetSpecularClr(int mtlNum=0, BOOL backFace=FALSE){ return specular; }
	Color GetSelfIllumClr(int mtlNum=0, BOOL backFace=FALSE){ return selfIllum; }
	float GetDiffuseLevel(int mtlNum=0, BOOL backFace=FALSE){ return diffLevel; }
	float GetSpecularLevel(int mtlNum=0, BOOL backFace=FALSE){ return specLevel; }
	float GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE){ return selfIllumLevel; }

	Color GetAmbientClr(TimeValue t){ return pblock->GetColor(an_ambient,t); }		
	Color GetDiffuseClr(TimeValue t){ return pblock->GetColor(an_diffuse,t); }		
	Color GetSpecularClr(TimeValue t){ return pblock->GetColor(an_specular,t);	}
	Color GetSelfIllumClr(TimeValue t){ return pblock->GetColor(an_self_illum_color,t);}		
	float GetSpecularLevel(TimeValue t){ return  pblock->GetFloat(an_specular_level,t); }
	float GetDiffuseLevel(TimeValue t){ return  pblock->GetFloat(an_diffuse_level,t); }
	float GetSelfIllum(TimeValue t){ return  pblock->GetFloat(an_self_illum_amnt,t);}		

	void SetSelfIllumClrOn( BOOL on )
		{ selfIllumClrOn = on; pblock->SetValue( an_use_self_illum_color, 0, on);}
	BOOL IsSelfIllumClrOn(){ return selfIllumClrOn; }
	BOOL IsSelfIllumClrOn(int mtlNum, BOOL backFace){ return selfIllumClrOn; }

	// not supported
	void SetSoftenLevel(float v, TimeValue t) {}
	float GetSoftenLevel(int mtlNum=0, BOOL backFace=FALSE){ return DEFAULT_SOFTEN; }
	float GetSoftenLevel(TimeValue t){ return  DEFAULT_SOFTEN; }
};

///////////// Class Descriptor ////////////////////////
class AnisoShaderClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new AnisoShader(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_ANISO); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return AnisoShaderClassID; }
	const TCHAR* 	Category() { return _T("");  }
	const TCHAR*	InternalName() { return _T("Anisotropic"); } // returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			 // returns owning module handle
};


AnisoShaderClassDesc anisoCD;
ClassDesc * GetAnisoShaderCD(){ return &anisoCD; }

// shader parameters
static ParamBlockDesc2 aniso_param_blk ( aniso_params, _T("shaderParameters"),  0, &anisoCD, P_AUTO_CONSTRUCT, 0, 
	// params
	an_ambient, _T("ambient"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_AMBIENT, 
		p_default, Color(0, 0, 0), 
		end,
	an_diffuse, _T("diffuse"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_DIFFUSE, 
		p_default, Color(0.5f, 0.5f, 0.5f), 
		end,
	an_specular, _T("specular"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_SPECULAR, 
		p_default, Color(1.0f, 1.0f, 1.0f), 
		end,
	an_self_illum_color, _T("selfIllumColor"), TYPE_RGBA, P_ANIMATABLE, IDS_KE_SELFILLUM_CLR,	
		p_default,		Color(0, 0, 0), 
		end,
	an_diffuse_level, _T("diffuseLevel"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_DIFF_LEVEL,
		p_default,		100.0,
		p_range,		0.0, 400.0,
		end,
	an_specular_level, _T("specularLevel"), TYPE_PCNT_FRAC, P_ANIMATABLE,IDS_KE_SPEC_LEVEL,
		p_default,	 	0.0,
		p_range,		0.0, 999.0,
		end,
	an_self_illum_amnt, _T("selfIllumAmount"), TYPE_PCNT_FRAC,	P_ANIMATABLE, IDS_KE_SELFILLUM,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	an_glossiness, _T("glossiness"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_GLOSSINESS,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	an_anisotropy, _T("anisotropy"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_ANISOTROPY,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	an_orientation, _T("orientation"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_ORIENTATION,
		p_default,		0.0,
		p_range,		MIN_ORIENT*100.0, MAX_ORIENT*100.0,
		end,
	an_map_channel, _T("unused"), TYPE_INT, 0, IDS_KE_MAPCHANNEL,
		p_default,		0,
		p_range,		0, 16,
		end,
	an_ad_texlock, _T("adTextureLock"), TYPE_BOOL,	0, IDS_JW_ADTEXLOCK, 
		p_default, TRUE, 
		end,
	an_ad_lock, _T("adLock"), TYPE_BOOL, 0, IDS_JW_ADLOCK, 
		p_default, FALSE, 
		end,
	an_ds_lock, _T("dsLock"), TYPE_BOOL, 0, IDS_JW_DSLOCK, 
		p_default, FALSE, 
		end,
	an_use_self_illum_color, _T("useSelfIllumColor"), TYPE_BOOL, 0, IDS_JW_SELFILLUMCOLORON,
		p_default, TRUE, 
		end,
	end
);


AnisoShader::AnisoShader() 
{ 
	pblock = NULL; 
	anisoCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	paramDlg = NULL; 

	lockDS = lockAD = lockADTex = selfIllumClrOn = 0;
	ambient = diffuse = specular = selfIllum = Color(0.0f,0.0f,0.0f);
	glossiness = orientation = anisotropy = specLevel = diffLevel = selfIllumLevel = 0.0f;
	ivalid.SetEmpty(); 
}

void AnisoShader::CopyStdParams( Shader* pFrom )
{
	macroRecorder->Disable(); 
	// don't want to see this parameter copying in macrorecorder
		SetLockDS( pFrom->GetLockDS() );
		SetLockAD( pFrom->GetLockAD() );
		SetLockADTex( pFrom->GetLockADTex() );
		SetSelfIllumClrOn( pFrom->IsSelfIllumClrOn() );

		SetAmbientClr( pFrom->GetAmbientClr(0,0), 0 );
		SetDiffuseClr( pFrom->GetDiffuseClr(0,0), 0 );
		SetSpecularClr( pFrom->GetSpecularClr(0,0), 0 );
		SetSelfIllumClr( pFrom->GetSelfIllumClr(0,0), 0 );

		SetSpecularLevel( pFrom->GetSpecularLevel(0,0), 0 );
		SetGlossiness( pFrom->GetGlossiness(0,0), 0 );
		SetSelfIllum( pFrom->GetSelfIllum(0,0), 0 );
	macroRecorder->Enable();
	ivalid.SetEmpty();	

}


RefTargetHandle AnisoShader::Clone( RemapDir &remap )
{
	AnisoShader* mnew = new AnisoShader();
	mnew->ReplaceReference(0, remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	
	mnew->ambient = ambient;
	mnew->diffuse = diffuse;
	mnew->specular = specular;
	mnew->selfIllum = selfIllum;
	mnew->selfIllumLevel = selfIllumLevel;
	mnew->glossiness = glossiness;
	mnew->anisotropy = anisotropy;
	mnew->orientation = orientation;
	mnew->specLevel = specLevel;
	mnew->diffLevel = diffLevel;
	mnew->lockDS = lockDS;
	mnew->lockAD = lockAD;
	mnew->lockADTex = lockADTex;
	mnew->selfIllumClrOn = selfIllumClrOn;
	return (RefTargetHandle)mnew;
}

void AnisoShader::GetIllumParams( ShadeContext &sc, IllumParams& ip )
{
	ip.stdParams = SupportStdParams();
	ip.channels[A_AM] = ambient;
	ip.channels[A_DI] = diffuse;
	ip.channels[A_SP] = specular;
	ip.channels[A_GL].r = glossiness;
	ip.channels[A_AN].r = anisotropy;
	ip.channels[A_OR].r = orientation * (1.0f/1.8f);
	ip.channels[A_DL].r = diffLevel;
	ip.channels[A_SL].r = specLevel;
	if (selfIllumClrOn )
		ip.channels[A_SI] = selfIllum;
	else
		ip.channels[A_SI].r = ip.channels[A_SI].g = ip.channels[A_SI].b = selfIllumLevel;

}

void AnisoShader::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();

		pblock->GetValue( an_ambient, t, p, ivalid );
		ambient = Bound(Color(p.x,p.y,p.z));
		pblock->GetValue( an_diffuse, t, p, ivalid );
		diffuse= Bound(Color(p.x,p.y,p.z));
		pblock->GetValue( an_specular, t, p, ivalid );
		specular = Bound(Color(p.x,p.y,p.z));

		pblock->GetValue( an_glossiness, t, glossiness, ivalid );
		glossiness = Bound( glossiness, 0.0001f, 1.0f );
		pblock->GetValue( an_anisotropy, t, anisotropy, ivalid );
		anisotropy = Bound(anisotropy);
		pblock->GetValue( an_orientation, t, orientation, ivalid );
		orientation = Bound( orientation, (float)MIN_ORIENT, (float)MAX_ORIENT );

		pblock->GetValue( an_specular_level, t, specLevel, ivalid );
		specLevel = Bound(specLevel,0.0f,9.99f);
		pblock->GetValue( an_diffuse_level, t, diffLevel, ivalid );
		diffLevel = Bound(diffLevel,0.0f,4.0f);
		pblock->GetValue( an_self_illum_amnt, t, selfIllumLevel, ivalid );
		selfIllumLevel = Bound(selfIllumLevel);
		pblock->GetValue( an_self_illum_color, t, p, ivalid );
		selfIllum = Bound(Color(p.x,p.y,p.z));

		// also get the non-animatables in case changed from scripter or other pblock accessors
		pblock->GetValue(an_ds_lock, t, lockDS, ivalid);
		pblock->GetValue(an_ad_lock, t, lockAD, ivalid);
		pblock->GetValue(an_ad_texlock, t, lockADTex, ivalid);
		pblock->GetValue(an_use_self_illum_color, t, selfIllumClrOn, ivalid);

	}
	valid &= ivalid;
}

void AnisoShader::Reset()
{
//	anisoCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	ivalid.SetEmpty();
	SetAmbientClr(Color(0.1f,0.1f,0.1f),0);
	SetDiffuseClr(Color(0.5f,0.5f,0.5f),0);
	SetSpecularClr(Color(0.9f,0.9f,0.9f),0);
	SetSelfIllumClr(Color(0.0f,0.0f,0.0f),0);
	SetSelfIllum( 0.0f,0 );
	SetGlossiness(.25f,0);   
	SetAnisotropy(0.5f,0);   
	SetOrientation(0.0f,0);   
	SetSpecularLevel(0.05f,0);   
	SetDiffuseLevel(1.0f,0);   

	SetLockADTex( TRUE );
	SetLockAD( FALSE );
	SetLockDS( FALSE );
	SetSelfIllumClrOn( FALSE );
}



//////////////////////////////////////////////////////////////////////////////////////////
//
//	IO Routines
//
#define SHADER_HDR_CHUNK 0x4000
#define SHADER_LOCKDS_ON_CHUNK 0x5001
#define SHADER_LOCKAD_ON_CHUNK 0x5002
#define SHADER_LOCKADTEX_ON_CHUNK 0x5003
#define SHADER_VERS_CHUNK 0x5300
#define SHADER_SELFILLUMCLR_ON_CHUNK	0x5006

// IO
IOResult AnisoShader::Save(ISave *isave) 
{ 
ULONG nb;

	isave->BeginChunk(SHADER_VERS_CHUNK);
	int version = CURRENT_ANISO_SHADER_VERSION;
	isave->Write(&version,sizeof(version), &nb);			
	isave->EndChunk();

	return IO_OK;
}		

class AnisoShaderCB: public PostLoadCallback {
	public:
		AnisoShader *s;
		int loadVersion;
	    AnisoShaderCB(AnisoShader *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			// convert old v1 ParamBlock to ParamBlock2
			s->ReplaceReference(0,
				UpdateParameterBlock2(AnisoShaderPB, ANISO_SHADER_NPARAMS, (IParamBlock*)s->pblock, &aniso_param_blk));

			// then set values that were previously stored outside the PB
			s->pblock->SetValue(an_use_self_illum_color, 0, s->selfIllumClrOn);
			s->pblock->SetValue(an_ds_lock, 0, s->lockDS);
			s->pblock->SetValue(an_ad_lock, 0, s->lockAD);
			s->pblock->SetValue(an_ad_texlock, 0, s->lockADTex);
		}
};


IOResult AnisoShader::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	int version = 0;

	lockAD = lockADTex = lockDS = selfIllumClrOn = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SHADER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
			case SHADER_LOCKDS_ON_CHUNK:
				lockDS = TRUE;
				break;
			case SHADER_LOCKAD_ON_CHUNK:
				lockAD = TRUE;
				break;
			case SHADER_LOCKADTEX_ON_CHUNK:
				lockADTex = TRUE;
				break;
			case SHADER_SELFILLUMCLR_ON_CHUNK:
				selfIllumClrOn = TRUE;
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < CURRENT_ANISO_SHADER_VERSION ) {
		iload->RegisterPostLoadCallback(new AnisoShaderCB(this, version));
		iload->SetObsolete();
	}

	return IO_OK;
}

			
///////////////////////////////////////////////////////////////////////////////////////////
// The Shader
//

float AnisoShader::EvalHiliteCurve2( float x, float y, int )
{
	return GaussHiliteCurve2( x, y, specLevel, glossiness, anisotropy );
}


void AnisoShader::AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol)
{
	//NB kl,aka NL & g cancel out
//	rcol *= ip.channels[A_SL].r * ip.channels[ID_SP] * DEFAULT_K_REFL;
	rcol *= ip.channels[A_SP] * DEFAULT_K_REFL; 
}



static int stopX = -1;
static int stopY = -1;

void AnisoShader::Illum(ShadeContext &sc, IllumParams &ip) {
	LightDesc *l;
	Color lightCol;

#ifdef _DEBUG
	IPoint2 sp = sc.ScreenCoord();
	if ( sp.x == stopX && sp.y == stopY )
		sp.x = stopX;
#endif

	BOOL isShiny= (ip.channels[A_SL].r > 0.0f) ? 1 : 0; 

	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		float NL, kL;
		Point3 L;
		if (l->Illuminate( sc, ip.N, lightCol, L, NL, kL)) {
			if (l->ambientOnly) {
				ip.ambIllumOut += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;

			// specular  
			Color spec( 0.0f, 0.0f, 0.0f );
			if (isShiny && l->affectSpecular) {
				Point3 T = GetTangent( sc, 0 ); 
				float g = GaussHighlight( ip.channels[A_GL].r, ip.channels[A_AN].r,
											ip.channels[A_OR].r, ip.N, ip.V, L, T, &NL );
										
				spec = g * kL * ip.channels[A_SL].r * lightCol;
				ip.specIllumOut += spec;

			} // end, isSpecular

			// diffuse
			if (l->affectDiffuse)
				ip.diffIllumOut += kL * ip.channels[A_DL].r * lightCol;

		} // end, is illuminated
	} // for each light

	// Apply mono self illumination
	if ( ! selfIllumClrOn ){
		float si = 0.3333333f * (ip.channels[A_SI].r + ip.channels[A_SI].g + ip.channels[A_SI].b);
		//float si = ip.channels[A_SI].r;
		if ( si > 0.0f ) {
			si = Bound( si );
			ip.selfIllumOut = si * ip.channels[A_DI];
			ip.diffIllumOut *= (1.0f-si);
			// fade the ambient down on si: 5/27/99 ke
			ip.ambIllumOut *= 1.0f-si;
		}
	} else {
		// colored self illum, 
		ip.selfIllumOut = ip.channels[A_SI];
	}

	// now we can multiply by the clrs,
	ip.ambIllumOut *= ip.channels[A_AM]; 
	ip.diffIllumIntens = Intens(ip.diffIllumOut);
	ip.diffIllumOut *= ip.channels[A_DI]; 
	ip.specIllumOut *= ip.channels[A_SP]; 

}



// The dialog class
class AnisoShaderDlg : public ShaderParamDlg {
public:
	AnisoShader*	pShader;
	StdMat2*	pMtl;
	HPALETTE	hOldPal;
	HWND		hwmEdit;	// window handle of the materials editor dialog
	IMtlParams*	pMtlPar;
	HWND		hwHilite;   // the hilite window
	HWND		hRollup;	// Rollup panel
	TimeValue	curTime;
	BOOL		valid;
	BOOL		isActive;

	IColorSwatch *cs[ANISO_NCOLBOX];
	ISpinnerControl *dlevSpin, *slevSpin, *glSpin, *anSpin, *orSpin, *trSpin, *siSpin;
	ICustButton* texMBut[ANISO_NMBUTS];
	TexDADMgr dadMgr;
	
	AnisoShaderDlg( HWND hwMtlEdit, IMtlParams *pParams ); 
	~AnisoShaderDlg(); 

	// required for correctly operating map buttons
	int FindSubTexFromHWND(HWND hw) {
		for (long i=0; i < ANISO_NMBUTS; i++) {
			if (hw == texMBut[i]->GetHwnd()) 
				return texmapFromMBut[i];
		}	
		return -1;
	}

	// Methods
	BOOL PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ); 
	Class_ID ClassID(){ return AnisoShaderDlgClassID; }

	void SetThing(ReferenceTarget *m){ pMtl = (StdMat2*)m; }
	void SetThings( StdMat2* theMtl, Shader* theShader )
	{	if (pShader) pShader->SetParamDlg(NULL);   
		pShader = (AnisoShader*)theShader; 
		if(pShader) pShader->SetParamDlg(this);
		pMtl = theMtl;
	}
	ReferenceTarget* GetThing(){ return pMtl; } // mtl is the thing! (for DAD!)
	Shader* GetShader(){ return pShader; }
	
	void SetTime(TimeValue t) {
		//DS 2/26/99: added interval test to prevent redrawing when not necessary
		if (!pShader->ivalid.InInterval(t)) {
			Interval v;
			pShader->Update(t,v);
			LoadDialog(TRUE); 
			}
		curTime = t; 
		}		

	BOOL KeyAtCurTime(int id) { return pShader->KeyAtTime(id,curTime); } 
	void DeleteThis() { delete this; }
	void ActivateDlg( BOOL dlgOn ){ isActive = dlgOn; }
	HWND GetHWnd(){ return hRollup; }
	void NotifyChanged(){ pShader->NotifyChanged(); }
	void LoadDialog(BOOL draw);
	void ReloadDialog(){ Interval v; pShader->Update(pMtlPar->GetTime(), v); LoadDialog(FALSE);}
	void UpdateDialog( ParamID paramId ){ ReloadDialog(); }

	void UpdateMtlDisplay(){ pMtlPar->MtlChanged(); } // redraw viewports
    void UpdateHilite( );
	void UpdateColSwatches();
	void UpdateLockADTex(BOOL passOn);
	void UpdateMapButtons();
	void UpdateOpacity();

	void SetLockDS(BOOL lock);
	void SetLockAD(BOOL lock);
	void SetLockADTex(BOOL lock);

	void SelectEditColor(int i) { cs[ i ]->EditThis(FALSE); }
};

static BOOL CALLBACK  AnisoShaderDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	AnisoShaderDlg *theDlg;
	if (msg == WM_INITDIALOG) {
		theDlg = (AnisoShaderDlg*)lParam;
		SetWindowLong(hwndDlg, GWL_USERDATA, lParam);
	} else {
	    if ( (theDlg = (AnisoShaderDlg*)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
	}
	theDlg->isActive = 1;
	BOOL res = theDlg->PanelProc(hwndDlg, msg, wParam, lParam);
	theDlg->isActive = 0;
	return res;
}


ShaderParamDlg* AnisoShader::CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen ) 
{
	Interval v;
	Update(imp->GetTime(),v);
	
	paramDlg = new AnisoShaderDlg(hwMtlEdit, imp);
	paramDlg->SetThings( theMtl, this  );

	LoadStdShaderResources();
	if ( hOldRollup ) {
		paramDlg->hRollup = imp->ReplaceRollupPage( 
			hOldRollup,
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_WARD4),
			AnisoShaderDlgProc, 
			GetString(IDS_KE_ANSIO_BASIC),	// your name here
			(LPARAM)paramDlg , 
			rollupOpen
			);
	} else
		paramDlg->hRollup = imp->AddRollupPage( 
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_WARD4),
			AnisoShaderDlgProc, 
			GetString(IDS_KE_ANSIO_BASIC),	
			(LPARAM)paramDlg , 
			rollupOpen
			);

	return (ShaderParamDlg*)paramDlg;	
}


RefResult AnisoShader::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
									  PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock){
				// update UI if paramblock changed, possibly from scripter
				ParamID changingParam = pblock->LastNotifyParamID();
				// reload the dialog if present
				if (paramDlg){
					paramDlg->UpdateDialog( changingParam );
				}
			}
			break;
	}
	return(REF_SUCCEED);
}



AnisoShaderDlg::AnisoShaderDlg( HWND hwMtlEdit, IMtlParams *pParams)
{
	pMtl = NULL;
	pShader = NULL;
	hwmEdit = hwMtlEdit;
	pMtlPar = pParams;
	dadMgr.Init(this);
	dlevSpin = slevSpin = glSpin = anSpin = orSpin = trSpin = siSpin = NULL;
	hRollup = hwHilite = NULL;
	curTime = pMtlPar->GetTime();

	isActive = valid = FALSE;

	for( long i = 0; i < ANISO_NCOLBOX; ++i )
		cs[ i ] = NULL;

	for( i = 0; i < ANISO_NMBUTS; ++i )
		texMBut[ i ] = NULL;
}

AnisoShaderDlg::~AnisoShaderDlg()
{
	HDC hdc = GetDC(hRollup);
	GetGPort()->RestorePalette(hdc, hOldPal);
	ReleaseDC(hRollup, hdc);

	if( pShader ) pShader->SetParamDlg(NULL);

	for (long i=0; i < ANISO_NMBUTS; i++ ){
		ReleaseICustButton( texMBut[i] );
		texMBut[i] = NULL; 
	}

	for (i=0; i<ANISO_NCOLBOX; i++)
		if (cs[i]) ReleaseIColorSwatch(cs[i]); // mjm - 5.10.99
	
 	ReleaseISpinner(slevSpin);
	ReleaseISpinner(dlevSpin);
	ReleaseISpinner(glSpin);
	ReleaseISpinner(anSpin);
	ReleaseISpinner(orSpin);
	ReleaseISpinner(trSpin);
	ReleaseISpinner(siSpin);

	SetWindowLong(hRollup, GWL_USERDATA, NULL);
	SetWindowLong(hwHilite, GWL_USERDATA, NULL);
	hwHilite = hRollup = NULL;
}


void  AnisoShaderDlg::LoadDialog(BOOL draw) 
{
	if (pShader && hRollup) {
		dlevSpin->SetValue(FracToPc(pShader->GetDiffuseLevel()),FALSE);
		dlevSpin->SetKeyBrackets(KeyAtCurTime(an_diffuse_level));

		slevSpin->SetValue(FracToPc(pShader->GetSpecularLevel()),FALSE);
		slevSpin->SetKeyBrackets(KeyAtCurTime(an_specular_level));

		glSpin->SetValue( FracToPc(pShader->GetGlossiness()), FALSE);
		glSpin->SetKeyBrackets(KeyAtCurTime(an_glossiness));

		anSpin->SetValue( FracToPc(pShader->GetAnisotropy()), FALSE);
		anSpin->SetKeyBrackets(KeyAtCurTime(an_anisotropy));

		orSpin->SetValue( FracToPc(pShader->GetOrientation()), FALSE);
		orSpin->SetKeyBrackets(KeyAtCurTime(an_orientation));

		trSpin->SetValue(FracToPc(pMtl->GetOpacity( curTime )),FALSE);
		trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));

		//  color selfIllum
		BOOL colorSelfIllum = pShader->IsSelfIllumClrOn();
		SetCheckBox(hRollup,IDC_SI_COLORON, colorSelfIllum ); 
		if( colorSelfIllum ) {
//			ShowWindow( siSpin->GetHwnd(), SW_HIDE );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_EDIT), SW_HIDE );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_SPIN), SW_HIDE );
			ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_SHOW );
		} else {
			// disable the color swatch
			ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
			// show self-illum slider
//			ShowWindow( siSpin->GetHwnd(), SW_SHOW );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_EDIT), SW_SHOW );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_SPIN), SW_SHOW );

			siSpin->SetValue(FracToPc(pShader->GetSelfIllum()), FALSE);
			siSpin->SetKeyBrackets(KeyAtCurTime(PB_SELFILLUM_LEV));
		}

		CheckButton(hRollup, IDC_LOCK_AD, pShader->GetLockAD() );
		CheckButton(hRollup, IDC_LOCK_DS, pShader->GetLockDS() );
	 	UpdateLockADTex( FALSE ); //don't send to mtl

		UpdateColSwatches();
		UpdateHilite();
	}
}

static TCHAR* mapStates[] = { _T(" "), _T("m"),  _T("M") };

void AnisoShaderDlg::UpdateMapButtons() 
{

	for ( long i = 0; i < ANISO_NMBUTS; ++i ) {
		int nMap = texmapFromMBut[ i ];
		int state = pMtl->GetMapState( nMap );
		texMBut[i]->SetText( mapStates[ state ] );

		TSTR nm	 = pMtl->GetMapName( nMap );
		texMBut[i]->SetTooltip(TRUE,nm);

	}
}


void AnisoShaderDlg::UpdateOpacity() 
{
	trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
	trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));
}


void AnisoShaderDlg::SetLockAD(BOOL lock)
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_DS_LOCKAD), GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_AD, FALSE);	
			return;	
		}
		// set ambient color to diffuse
		pShader->SetAmbientClr( pShader->GetDiffuseClr(), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockAD(lock);
}


void AnisoShaderDlg::UpdateColSwatches() 
{
	for(int i=0; i < ANISO_NCOLBOX; i++) {
		if ( cs[ i ] ) {
			cs[i]->SetKeyBrackets( pShader->KeyAtTime(PB_AMBIENT_CLR+i,curTime) );
			cs[i]->SetColor( GetMtlColor(i, (Shader*)pShader) );
		}
	}
}


void AnisoShaderDlg::UpdateHilite()
{
	HDC hdc = GetDC(hwHilite);
	Rect r;
	GetClientRect(hwHilite,&r);
	DrawHilite2(hdc, r, pShader );
	ReleaseDC(hwHilite,hdc);
}

void AnisoShaderDlg::UpdateLockADTex( BOOL passOn) {
	int lock = 	pShader->GetLockADTex();
	CheckButton(hRollup, IDC_LOCK_ADTEX, lock);

	ShowWindow(GetDlgItem(hRollup, IDC_MAPON_AM), !lock);
	texMBut[ 0 ]->Enable(!lock);

	if ( passOn ) {
		pMtl->SyncADTexLock( lock );
	}
//	UpdateMtlDisplay();
}

void AnisoShaderDlg::SetLockADTex(BOOL lock) {
	pShader->SetLockADTex( lock );
	UpdateLockADTex(TRUE); // pass on to mtl
}

void AnisoShaderDlg::SetLockDS(BOOL lock) 
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_KE_LOCKDS),GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_DS, FALSE);	
			return;	
		}
		pShader->SetSpecularClr( pShader->GetDiffuseClr(), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockDS( lock );
}

static int ColorIDCToIndex(int idc) {
	switch (idc) {
		case IDC_STD_COLOR1: return 0;
		case IDC_STD_COLOR2: return 1;
		case IDC_STD_COLOR3: return 2;
		case IDC_SI_COLOR: return 3;
		default: return 0;
	}
}


BOOL AnisoShaderDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG:
			{
			int i;
			
			HDC theHDC = GetDC(hwndDlg);
			hOldPal = GetGPort()->PlugPalette(theHDC);
			ReleaseDC(hwndDlg,theHDC);

			for (i=0; i<ANISO_NCOLBOX; i++) {
   				cs[i] = GetIColorSwatch(GetDlgItem(hwndDlg, colID[i]),
   					GetMtlColor(i, pShader), GetColorName(i));
			}

			hwHilite = GetDlgItem(hwndDlg, IDC_HIGHLIGHT);
			SetWindowLong( hwHilite, GWL_WNDPROC, (LONG)Hilite2WndProc);

			slevSpin = SetupIntSpinner(hwndDlg, IDC_SLEV_SPIN, IDC_SLEV_EDIT, 0, 999, 0);
			dlevSpin = SetupIntSpinner(hwndDlg, IDC_DLEV_SPIN, IDC_DLEV_EDIT, 0, 400, 0);
			glSpin = SetupIntSpinner(hwndDlg, IDC_GL_SPIN, IDC_GL_EDIT, 0,100, 0);
			anSpin = SetupIntSpinner(hwndDlg, IDC_AN_SPIN, IDC_AN_EDIT, 0,100, 0);
			orSpin = SetupIntSpinner(hwndDlg, IDC_OR_SPIN, IDC_OR_EDIT, -9999, 9999, 0);
			trSpin = SetupIntSpinner(hwndDlg, IDC_TR_SPIN, IDC_TR_EDIT, 0,100, 0);
			siSpin = SetupIntSpinner(hwndDlg, IDC_SI_SPIN, IDC_SI_EDIT, 0,100, 0);

			if( pShader->IsSelfIllumClrOn() ) {
				// enable the color swatch, disable the spinner
				ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_HIDE );
				ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_HIDE );
			} else {
				// disable the color swatch
				ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
			}
	
			for (int j=0; j<ANISO_NMBUTS; j++) {
				texMBut[j] = GetICustButton(GetDlgItem(hwndDlg,texMButtonsIDC[j]));
				assert( texMBut[j] );
				texMBut[j]->SetRightClickNotify(TRUE);
				texMBut[j]->SetDADMgr(&dadMgr);
			}

			SetupLockButton(hwndDlg,IDC_LOCK_AD,FALSE);
			SetupLockButton(hwndDlg,IDC_LOCK_DS,FALSE);
			SetupPadLockButton(hwndDlg,IDC_LOCK_ADTEX, TRUE);

			LoadDialog(TRUE);
		}
		break;

		case WM_COMMAND: 
			{
			for ( int i=0; i<ANISO_NMBUTS; i++) {
				if (id == texMButtonsIDC[i]) {
					PostMessage(hwmEdit,WM_TEXMAP_BUTTON, texmapFromMBut[i],(LPARAM)pMtl );
					UpdateMapButtons();
					goto exit;
					}
				}
			}
		    switch (id) {

				case IDC_LOCK_AD:
					SetLockAD(IsButtonChecked(hwndDlg, IDC_LOCK_AD));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_DS:
					SetLockDS(IsButtonChecked(hwndDlg, IDC_LOCK_DS));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_ADTEX:{
					BOOL on = IsButtonChecked(hwndDlg, IDC_LOCK_ADTEX);
					SetLockADTex(on);
					UpdateMtlDisplay();
				} break;

				case IDC_SI_COLORON:{
					int isOn = GetCheckBox(hwndDlg, IDC_SI_COLORON );
					pShader->SetSelfIllumClrOn( isOn );			
					if ( isOn ) {
						// enable the color swatch, disable the spinner
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_HIDE );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_HIDE );
						ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_SHOW );
					} else {
						// disable the color swatch
						ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_SHOW );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_SHOW );
					}
				    NotifyChanged();
//					UpdateMtlDisplay();
				}
				break;

			}
			break;
		case CC_COLOR_SEL: {
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
		}			
		break;
		case CC_COLOR_DROP:	{
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
			UpdateMtlDisplay();				
		}
		break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
		 break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			UpdateMtlDisplay();
			break;
		case CC_COLOR_CHANGE: {			
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = ColorIDCToIndex(id);
			if (buttonUp) theHold.Begin();
			DWORD curRGB = cs[n]->GetColor();
			SetMtlColor(n, curRGB, pShader, cs, curTime);
			// >>>>>>>>>< is redundant w/ ln 1189 below?
			if (buttonUp) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
				// DS: 5/3/99-  this was commented out. I put it back in, because
				// it is necessary for the Reset button in the color picker to 
				// update the viewport.				
				UpdateMtlDisplay();  
				}
		} break;
		case WM_PAINT: 
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
		case WM_DESTROY: 
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_GL_SPIN: 
					pShader->SetGlossiness(PcToFrac( glSpin->GetIVal() ), curTime); 
					UpdateHilite();
					break;
				case IDC_AN_SPIN: 
					pShader->SetAnisotropy(PcToFrac( anSpin->GetIVal() ), curTime); 
					UpdateHilite();
					break;
				case IDC_OR_SPIN: 
					pShader->SetOrientation( PcToFrac(orSpin->GetIVal() ), curTime); 
					break;
				case IDC_SLEV_SPIN: 
					pShader->SetSpecularLevel( PcToFrac(slevSpin->GetIVal()),curTime); 
					UpdateHilite();
					break;
				case IDC_DLEV_SPIN: 
					pShader->SetDiffuseLevel(PcToFrac(dlevSpin->GetIVal()),curTime); 
					break;
				case IDC_SI_SPIN: 
					pShader->SetSelfIllum(PcToFrac(siSpin->GetIVal()),curTime); 
					break;

					//******** >>>><<<< required handling for opacity....must be present in all dialogs
				case IDC_TR_SPIN: 
					pMtl->SetOpacity(PcToFrac( trSpin->GetIVal()),curTime); 
					break;
			}
//			UpdateMtlDisplay();
		break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			// >>>>< duplicate?
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;

    }
	exit:
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shaderONB.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//		Oren-Nayar Shader plug-in, implementation
//
//		Created: 9/23/98 Kells Elmquist
//
#include "shadersPch.h"
#include "shadersRc.h"
#include "gport.h"
#include "shaders.h"
#include "shaderUtil.h"
#include "macrorec.h"

#define NEWSHADERS_CLASS_ID		0x2857f420

static Class_ID OrenNayarBlinnShaderClassID( NEWSHADERS_CLASS_ID+1, 0);
static Class_ID OrenNayarShaderDlgClassID( NEWSHADERS_CLASS_ID+2, 0);

// paramblock2 block and parameter IDs.
enum { onb_params, };
// shdr_params param IDs
enum 
{ 
	onb_ambient, onb_diffuse, onb_specular,
	onb_self_illum_color, onb_self_illum_amnt,
	onb_glossiness, onb_specular_level, onb_soften,
	onb_diffuse_level, onb_roughness, 
	onb_ad_texlock, onb_ad_lock, onb_ds_lock, onb_use_self_illum_color, 
};


/////////////////////////////////////////////////////////////////////
//
//	Oren/Nayar/Blinn Basic Panel UI 
//
#define NMBUTS 9
#define N_SI_BUT 5
#define N_TR_BUT 6

static int texMButtonsIDC[] = {
	IDC_MAPON_AM,	IDC_MAPON_DI,	IDC_MAPON_SP,	IDC_MAPON_SH,
	IDC_MAPON_SS,	IDC_MAPON_SI,	IDC_MAPON_TR, 
	IDC_MAPON_DIFF_LEVEL,	IDC_MAPON_DIFF_ROUGH,	IDC_MAPON_DIFF_RHO, 
	};
		
// This array gives the texture map number for given MButton number								
// the ID_s are from stdmat.h
static int texmapFromMBut[] = { 0, 1, 2, 3, 4, 5, 6, 8, 9 };

// channel names
#define ON_NTEXMAPS	10

static int texNameIDS[STD2_NMAX_TEXMAPS] = {
	IDS_DS_AMBIENT,	IDS_DS_DIFFUSE,	IDS_DS_SPECULAR, IDS_DS_SHININESS, IDS_DS_SHIN_STR,
	IDS_KE_SELFILLUM, IDS_DS_TRANS, IDS_DS_FILTER, 
	IDS_KE_DIFF_LEVEL, IDS_KE_DIFF_ROUGH, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
};	

// internal non-local parsable channel map names
static TCHAR* texInternalNames[STD2_NMAX_TEXMAPS] = {
	_T("ambientMap"), _T("diffuseMap"),	_T("specularMap"), _T("glossinessMap"), 
	_T("specularLevelMap"), _T("selfIllumMap"), _T("opacityMap"), _T("filterMap"),
	_T("diffuseLevelMap"), _T("diffuseRoughnessMap"), _T(""), _T(""),	
	_T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""), _T(""),
};	


// sized for nmax textures
static int channelType[] = {
	CLR_CHANNEL, CLR_CHANNEL, CLR_CHANNEL, MONO_CHANNEL, MONO_CHANNEL,
	CLR_CHANNEL, MONO_CHANNEL, CLR_CHANNEL, 
	MONO_CHANNEL, MONO_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
};
	

// what channel corresponds to the stdMat ID's
static int stdIDToChannel[N_ID_CHANNELS] = { 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1 };

//////////////////////////////////////////////////////////////////////////////////////////
//
//		Oren / Nayar / Blinn Parameter Block
//
#define CURRENT_ON_SHADER_VERSION	2
#define ON_SHADER_NPARAMS			11
#define ON_SHADER_PB_VERSION		1

#define NCOLBOX 4
static int colID[NCOLBOX] = { IDC_STD_COLOR1, IDC_STD_COLOR2, IDC_STD_COLOR3, IDC_SI_COLOR };
static int colParamID[NCOLBOX] = { onb_ambient, onb_diffuse, onb_specular, onb_self_illum_color };
#define N_SI_CLR		3
#define N_AMB_CLR		0

#define PB_AMBIENT_CLR		0
#define PB_DIFFUSE_CLR		1
#define PB_SPECULAR_CLR		2
#define PB_SELFILLUM_CLR	3
#define PB_SELFILLUM		4
#define PB_GLOSSINESS 		5
#define PB_SPECULAR_LEV		6
#define PB_SOFTEN_LEV		7
#define PB_DIFFUSE_LEV		8
#define PB_DIFFUSE_ROUGH	9
#define PB_DIFFUSE_RHO		10

// v1 Param Block Descriptor
static ParamBlockDescID ONShaderPB[ ON_SHADER_NPARAMS ] = {
	{ TYPE_RGBA,  NULL, TRUE, onb_ambient },		// ambient
	{ TYPE_RGBA,  NULL, TRUE, onb_diffuse },		// diffuse
	{ TYPE_RGBA,  NULL, TRUE, onb_specular },		// specular
	{ TYPE_RGBA,  NULL, TRUE, onb_self_illum_color }, // self-illum color
	{ TYPE_FLOAT, NULL, TRUE, onb_self_illum_amnt },  // selfIllum
	{ TYPE_FLOAT, NULL, TRUE, onb_glossiness },		// glossiness
	{ TYPE_FLOAT, NULL, TRUE, onb_specular_level },		// specularLevel
	{ TYPE_FLOAT, NULL, TRUE, onb_soften },			// soften
	{ TYPE_FLOAT, NULL, TRUE, onb_roughness },		// diffuse roughness
	{ TYPE_FLOAT, NULL, TRUE, -1 },					// diffuse reflectivity
	{ TYPE_FLOAT, NULL, TRUE, onb_diffuse_level },  // diffuse level
}; 

#define ON_NUMOLDVER 1

static ParamVersionDesc oldVersions[ON_NUMOLDVER] = {
	ParamVersionDesc(ONShaderPB, 8, 0),
};

static ParamVersionDesc curVersion(ONShaderPB, ON_SHADER_NPARAMS, ON_SHADER_PB_VERSION);

//----------------------------------------------------------------------------------------
//---- Oren-Nayar Extended Diffuse Shader, w/ Blinn specular hilite ----------------------
//----------------------------------------------------------------------------------------

class OrenNayarShaderDlg;

class OrenNayarBlinnShader : public Shader {
friend class ONShaderCB;
friend class OrenNayarShaderDlg;
protected:
	IParamBlock2 *pblock;   // ref 0
	Interval ivalid;
	TimeValue	curTime;

	OrenNayarShaderDlg* paramDlg;

	BOOL selfIllumClrOn;
	BOOL lockDS;
	BOOL lockAD;
	BOOL lockADTex;

	Color ambient;
	Color diffuse;
	Color specular;
	Color selfIllumClr;
	float selfIllum;	
	float softThresh;
	float glossiness;
	float specularLevel;

	float diffLevel;
	float diffRough;
	float diffRho;

public:
	OrenNayarBlinnShader();
	void DeleteThis(){ delete this; }		
    ULONG SupportStdParams(){ return STD_ONB | STD_EXTRA; }
    void CopyStdParams( Shader* pFrom );

	// texture maps
	long  nTexChannelsSupported(){ return ON_NTEXMAPS; }
	TSTR  GetTexChannelName( long nTex ) { return GetString( texNameIDS[ nTex ] ); }
	TSTR  GetTexChannelInternalName( long nTex ) { return texInternalNames[ nTex ]; }
	long  ChannelType( long nTex ){ return channelType[nTex]; }
	// map StdMat Channel ID's to the channel number
	long StdIDToChannel( long stdID ){ return stdIDToChannel[ stdID ]; }

	BOOL KeyAtTime(int id,TimeValue t) { return pblock->KeyFrameAtTime((ParamID)id,t); }
	ULONG GetRequirements( int subMtlNum ){ return MTLREQ_PHONG; }

	ShaderParamDlg* CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen );
	ShaderParamDlg* GetParamDlg(){ return (ShaderParamDlg*)paramDlg; }
	void SetParamDlg( ShaderParamDlg* newDlg ){ paramDlg = (OrenNayarShaderDlg*)newDlg; }

	Class_ID ClassID() { return OrenNayarBlinnShaderClassID; }
	TSTR GetName() { return GetString( IDS_KE_OREN_NAYAR_BLINN ); }
	void GetClassName(TSTR& s) { s = GetName(); }  

	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i){ return (i==0)? pblock : NULL; }
	TSTR SubAnimName(int i){ return TSTR(GetString( IDS_KE_OREN_PARMS )); };
	int SubNumToRefNum(int subNum) { return subNum;	}

 	// JBW: add direct ParamBlock access
	int	NumParamBlocks() { return 1; }
	IParamBlock2* GetParamBlock(int i) { return pblock; }
	IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } 

	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i){ return (i == 0) ? pblock : NULL; }
	void SetReference(int i, RefTargetHandle rtarg) 
		{ if (i==0) pblock = (IParamBlock2*)rtarg; else assert(0); }
	void NotifyChanged(){ NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE); }

	void Update(TimeValue t, Interval& valid);
	void Reset();
	RefTargetHandle Clone( RemapDir &remap=NoRemap() );
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	                            PartID& partID, RefMessage message );
	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// Shader specific section
	void  Illum(ShadeContext &sc, IllumParams &ip);
	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol) {
//		rcol *= ip.channels[ID_SS].r * ip.channels[ID_SP] * DEFAULT_K_REFL; 
		rcol *= ip.channels[ID_SP] * DEFAULT_K_REFL; 
	}
	void CombineComponents( ShadeContext &sc, IllumParams& ip ){ CombineComponentsComp( ip ); }
	// cache for mapping of params, mtl fills in ip
	void GetIllumParams( ShadeContext &sc, IllumParams& ip );

	float EvalHiliteCurve(float x) {
		double phExp = pow(2.0, glossiness * 10.0); 
		return specularLevel*(float)pow((double)cos(x*PI), phExp );  
	}

	// OrenNayar Specific 
	void SetDiffuseLevel(float v, TimeValue t)		
			{ diffLevel = v; pblock->SetValue( onb_diffuse_level, t, v); }
	float GetDiffuseLevel(int mtlNum=0, BOOL backFace=FALSE){ return diffLevel; };
	float GetDiffuseLevel(TimeValue t){ return  pblock->GetFloat(onb_diffuse_level,t); }
	void SetDiffuseRoughness(float v, TimeValue t)		
			{ diffRough = v; pblock->SetValue( onb_roughness, t, v); }
	float GetDiffuseRoughness(int mtlNum=0, BOOL backFace=FALSE){ return diffRough; };
	float GetDiffuseRoughness(TimeValue t){ return  pblock->GetFloat(onb_roughness, t); }

	// Std Params
	void SetLockDS(BOOL lock){ lockDS = lock; pblock->SetValue( onb_ds_lock, 0, lock); }
	BOOL GetLockDS(){ return lockDS; }
	void SetLockAD(BOOL lock){ lockAD = lock; pblock->SetValue( onb_ad_lock, 0, lock); }
	BOOL GetLockAD(){ return lockAD; }
	void SetLockADTex(BOOL lock){ lockADTex = lock; pblock->SetValue( onb_ad_texlock, 0, lock); }
	BOOL GetLockADTex(){ return lockADTex; }

	void SetSelfIllum(float v, TimeValue t)
		{ selfIllum = v; pblock->SetValue( onb_self_illum_amnt, t, v); }
	void SetSelfIllumClrOn( BOOL on ){ selfIllumClrOn = on; pblock->SetValue( onb_use_self_illum_color, 0, on); };
	BOOL IsSelfIllumClrOn(){ return selfIllumClrOn; };
	void SetSelfIllumClr(Color c, TimeValue t)
		{ selfIllumClr = c; pblock->SetValue( onb_self_illum_color, t, Point3(c.r,c.g,c.b) ); }

	void SetAmbientClr(Color c, TimeValue t)		
		{ ambient = c; pblock->SetValue( onb_ambient, t, c); }
	void SetDiffuseClr(Color c, TimeValue t)		
		{ diffuse = c; pblock->SetValue( onb_diffuse, t, c); }
	void SetSpecularClr(Color c, TimeValue t)
		{ specular = c; pblock->SetValue( onb_specular, t, c); }
	void SetGlossiness(float v, TimeValue t)		
		{ glossiness= v; pblock->SetValue( onb_glossiness, t, v); }
	void SetSpecularLevel(float v, TimeValue t)		
		{ specularLevel = v; pblock->SetValue( onb_specular_level, t, v); }
	void SetSoftenLevel(float v, TimeValue t) 
		{ softThresh = v; pblock->SetValue( onb_soften, t, v); }

	BOOL IsSelfIllumClrOn(int mtlNum, BOOL backFace){ return selfIllumClrOn; };
	Color GetAmbientClr(int mtlNum=0, BOOL backFace=FALSE){ return ambient;}		
    Color GetDiffuseClr(int mtlNum=0, BOOL backFace=FALSE){ return diffuse;}		
	Color GetSpecularClr(int mtlNum=0, BOOL backFace=FALSE){ return specular; };
	Color GetSelfIllumClr(int mtlNum=0, BOOL backFace=FALSE){ return selfIllumClr; };
	float GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE){ return selfIllum; };
	float GetGlossiness(int mtlNum=0, BOOL backFace=FALSE){ return glossiness; };	
	float GetSpecularLevel(int mtlNum=0, BOOL backFace=FALSE){ return specularLevel; };
	float GetSoftenLevel(int mtlNum=0, BOOL backFace=FALSE){ return softThresh; };

	Color GetAmbientClr(TimeValue t){ return pblock->GetColor(onb_ambient,t); }		
	Color GetDiffuseClr(TimeValue t){ return pblock->GetColor(onb_diffuse,t); }		
	Color GetSpecularClr(TimeValue t){ return pblock->GetColor(onb_specular,t);	}
	float GetGlossiness( TimeValue t){return pblock->GetFloat(onb_glossiness,t);  }		
	float GetSpecularLevel(TimeValue t){ return  pblock->GetFloat(onb_specular_level,t); }
	float GetSoftenLevel(TimeValue t){ return  pblock->GetFloat(onb_soften,t); }
	float GetSelfIllum(TimeValue t){ return  pblock->GetFloat(onb_self_illum_amnt,t); }		
	Color GetSelfIllumClr(TimeValue t){ return  pblock->GetColor(onb_self_illum_color,t); }		
};

///////////// Class Descriptor ////////////////////////
class OrenNayarBlinnShaderClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new OrenNayarBlinnShader(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_OREN_NAYAR_BLINN); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return OrenNayarBlinnShaderClassID; }
	const TCHAR* 	Category() { return _T("");  }
	const TCHAR*	InternalName() { return _T("OrenNayarBlinn"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
};

OrenNayarBlinnShaderClassDesc orenNayarBlinnCD;
ClassDesc * GetOrenNayarBlinnShaderCD(){ return &orenNayarBlinnCD; }

// shader parameters
static ParamBlockDesc2 onb_param_blk ( onb_params, _T("shaderParameters"),  0, &orenNayarBlinnCD, P_AUTO_CONSTRUCT, 0, 
	// params
	onb_ambient, _T("ambient"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_AMBIENT, 
		p_default, Color(0, 0, 0), 
		end,
	onb_diffuse, _T("diffuse"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_DIFFUSE, 
		p_default, Color(0.5f, 0.5f, 0.5f), 
		end,
	onb_specular, _T("specular"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_SPECULAR, 
		p_default, Color(1.0f, 1.0f, 1.0f), 
		end,
	onb_ad_texlock, _T("adTextureLock"), TYPE_BOOL,	0, IDS_JW_ADTEXLOCK, 
		p_default, FALSE, 
		end,
	onb_ad_lock, _T("adLock"), TYPE_BOOL, 0, IDS_JW_ADLOCK, 
		p_default, FALSE, 
		end,
	onb_ds_lock, _T("dsLock"), TYPE_BOOL, 0, IDS_JW_DSLOCK, 
		p_default, FALSE, 
		end,
	onb_use_self_illum_color, _T("useSelfIllumColor"), TYPE_BOOL, 0, IDS_JW_SELFILLUMCOLORON,
		p_default, TRUE, 
		end,
	onb_self_illum_amnt, _T("selfIllumAmount"), TYPE_PCNT_FRAC,	P_ANIMATABLE, IDS_KE_SELFILLUM,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	onb_self_illum_color, _T("selfIllumColor"), TYPE_RGBA, P_ANIMATABLE, IDS_KE_SELFILLUM_CLR,	
		p_default,		Color(0, 0, 0), 
		end,
	onb_specular_level, _T("specularLevel"), TYPE_PCNT_FRAC, P_ANIMATABLE,IDS_KE_SPEC_LEVEL,
		p_default,	 	0.0,
		p_range,		0.0, 999.0,
		end,
	onb_glossiness, _T("glossiness"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_GLOSSINESS,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	onb_soften, _T("soften"), TYPE_FLOAT, P_ANIMATABLE, IDS_DS_SOFTEN,
		p_default,		0.0,
		p_range,		0.0, 1.0,
		end,
	onb_diffuse_level, _T("diffuseLevel"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_DIFF_LEVEL,
		p_default,		100.0,
		p_range,		0.0, 400.0,
		end,
	onb_roughness, _T("diffuseRoughness"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_DIFF_ROUGH,
		p_default,		50.0,
		p_range,		0.0, 100.0,
		end,
	end
	);

OrenNayarBlinnShader::OrenNayarBlinnShader() 
{ 
	pblock = NULL; 
	orenNayarBlinnCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	paramDlg = NULL; 
 
	lockDS = lockAD = lockADTex = selfIllumClrOn = 0;
	ambient = diffuse = specular = selfIllumClr = Color(0.0f,0.0f,0.0f);
	glossiness = specularLevel = softThresh 
		= diffRough = diffRho =  diffLevel = selfIllum = 0.0f;
	curTime = 0;
	ivalid.SetEmpty(); 
}

void OrenNayarBlinnShader::CopyStdParams( Shader* pFrom )
{
	macroRecorder->Disable();  // don't want to see this parameter copying in macrorecorder
		SetLockDS( pFrom->GetLockDS() );
		SetLockAD( pFrom->GetLockAD() );
		SetLockADTex( pFrom->GetLockADTex() );
		SetSelfIllumClrOn( pFrom->IsSelfIllumClrOn() );

		SetAmbientClr( pFrom->GetAmbientClr(0,0), curTime );
		SetDiffuseClr( pFrom->GetDiffuseClr(0,0), curTime );
		SetSpecularClr( pFrom->GetSpecularClr(0,0), curTime );
		SetSelfIllumClr( pFrom->GetSelfIllumClr(0,0), curTime );

		SetSelfIllum( pFrom->GetSelfIllum(0,0), curTime );
		SetSpecularLevel( pFrom->GetSpecularLevel(0,0), curTime );
		SetGlossiness( pFrom->GetGlossiness(0,0), curTime );
		SetSoftenLevel( pFrom->GetSoftenLevel(0,0), curTime );
	macroRecorder->Enable();
	ivalid.SetEmpty();	
}


RefTargetHandle OrenNayarBlinnShader::Clone( RemapDir &remap )
{
	OrenNayarBlinnShader* mnew = new OrenNayarBlinnShader();
	mnew->ReplaceReference(0,remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	
	mnew->ambient = ambient;
	mnew->diffuse = diffuse;
	mnew->specular = specular;
	mnew->glossiness = glossiness;
	mnew->specularLevel = specularLevel;
	mnew->diffLevel = diffLevel;
	mnew->diffRough = diffRough;
	mnew->diffRho = diffRho;
	mnew->softThresh = softThresh;
	mnew->selfIllum = selfIllum;
	mnew->selfIllumClr = selfIllumClr;
	mnew->selfIllumClrOn = selfIllumClrOn;
	mnew->lockDS = lockDS;
	mnew->lockAD = lockAD;
	mnew->lockADTex = lockADTex;
	return (RefTargetHandle)mnew;
}

#define	ID_DIFF_LEV		8
#define	ID_DIFF_ROUGH	9


void OrenNayarBlinnShader::GetIllumParams(ShadeContext &sc, IllumParams& ip )
{
	ip.stdParams = SupportStdParams();
	ip.shFlags = selfIllumClrOn? SELFILLUM_CLR_ON : 0;
	ip.channels[ID_AM] = ambient;
	ip.channels[ID_DI] = diffuse;
	ip.channels[ID_SP] = specular;
	ip.channels[ID_SH].r = glossiness;
	ip.channels[ID_SS].r = specularLevel;
	if( selfIllumClrOn )
		ip.channels[ID_SI] = selfIllumClr;
	else
		ip.channels[ID_SI].r = ip.channels[ID_SI].g = ip.channels[ID_SI].b = selfIllum;
	ip.channels[ID_DIFF_LEV].r = diffLevel;
	ip.channels[ID_DIFF_ROUGH].r = diffRough;
}


#define LIMIT0_1(x) if (x < 0.0f) x = 0.0f; else if (x > 1.0f) x = 1.0f;
#define LIMITMINMAX(x, min, max) if (x < min) x = min; else if (x > max) x = max;

static Color LimitColor(Color c) {
	LIMIT0_1(c.r);
	LIMIT0_1(c.g);
	LIMIT0_1(c.b);
	return c;
}

void OrenNayarBlinnShader::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();

		pblock->GetValue( onb_ambient, t, p, ivalid );
		ambient = LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( onb_diffuse, t, p, ivalid );
		diffuse= LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( onb_specular, t, p, ivalid );
		specular = LimitColor(Color(p.x,p.y,p.z));

		pblock->GetValue( onb_glossiness, t, glossiness, ivalid );
		LIMIT0_1(glossiness);
		pblock->GetValue( onb_specular_level, t, specularLevel, ivalid );
		LIMITMINMAX(specularLevel,0.0f,9.99f);
		pblock->GetValue( onb_soften, t, softThresh, ivalid); 
		LIMIT0_1(softThresh);

		pblock->GetValue( onb_self_illum_amnt, t, selfIllum, ivalid );
		LIMIT0_1(selfIllum);
		pblock->GetValue( onb_self_illum_color, t, p, ivalid );
		selfIllumClr = LimitColor(Color(p.x,p.y,p.z));

		pblock->GetValue( onb_diffuse_level, t, diffLevel, ivalid );
		LIMITMINMAX(diffLevel,0.0f, 4.00f);
		pblock->GetValue( onb_roughness, t, diffRough, ivalid );
		LIMIT0_1(diffRough);

		// also get the non-animatables in case changed from scripter or other pblock accessors
		pblock->GetValue(onb_ds_lock, t, lockDS, ivalid);
		pblock->GetValue(onb_ad_lock, t, lockAD, ivalid);
		pblock->GetValue(onb_ad_texlock, t, lockADTex, ivalid);
		pblock->GetValue(onb_use_self_illum_color, t, selfIllumClrOn, ivalid);

		curTime = t;
	}
	valid &= ivalid;
}

void OrenNayarBlinnShader::Reset()
{
//	orenNayarBlinnCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	ivalid.SetEmpty();
	SetSoftenLevel(0.1f,0);
	SetAmbientClr(Color(0.1f,0.1f,0.1f),0);
	SetDiffuseClr(Color(0.5f,0.5f,0.5f),0);
	SetSpecularClr(Color(0.9f,0.9f,0.9f),0);
	SetGlossiness(.25f,0);   // change from .4, 5-21-97
	SetSpecularLevel(0.0f,0);   
	SetDiffuseLevel(1.0f,0);   
	SetDiffuseRoughness(0.5f,0);   

	SetSelfIllum(.0f,0);
	SetSelfIllumClr( Color(.0f, .0f, .0f), 0 );
	SetSelfIllumClrOn( FALSE );
	SetLockADTex( TRUE );
	SetLockAD( FALSE );
	SetLockDS( FALSE );
}

//////////////////////////////////////////////////////////////////////////////////////////
//
//	IO Routines
//
//#define SHADER_HDR_CHUNK 0x4000
#define SHADER_SELFILLUM_CLR_ON_CHUNK 0x5000
#define SHADER_LOCKDS_ON_CHUNK 0x5001
#define SHADER_LOCKAD_ON_CHUNK 0x5002
#define SHADER_LOCKADTEX_ON_CHUNK 0x5003
#define SHADER_MAPSON_CHUNK 0x5004
#define SHADER_VERS_CHUNK 0x5300

#
// IO
IOResult OrenNayarBlinnShader::Save(ISave *isave) 
{ 
ULONG nb;

	isave->BeginChunk(SHADER_VERS_CHUNK);
	int version = CURRENT_ON_SHADER_VERSION;
	isave->Write(&version, sizeof(version), &nb);			
	isave->EndChunk();

	return IO_OK;
}		

class ONShaderCB: public PostLoadCallback {
	public:
		OrenNayarBlinnShader *s;
		int loadVersion;
	    ONShaderCB(OrenNayarBlinnShader *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {
			// convert old v1 ParamBlock to ParamBlock2
			s->ReplaceReference(0,
				UpdateParameterBlock2(ONShaderPB, ON_SHADER_NPARAMS, (IParamBlock*)s->pblock, &onb_param_blk));

			// then set values that were previously stored outside the PB
			s->pblock->SetValue(onb_use_self_illum_color, 0, s->selfIllumClrOn);
			s->pblock->SetValue(onb_ds_lock, 0, s->lockDS);
			s->pblock->SetValue(onb_ad_lock, 0, s->lockAD);
			s->pblock->SetValue(onb_ad_texlock, 0, s->lockADTex);
		}
};

IOResult OrenNayarBlinnShader::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	int version = 0;

	selfIllumClrOn = lockAD = lockADTex = lockDS = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SHADER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
			case SHADER_SELFILLUM_CLR_ON_CHUNK:
				selfIllumClrOn = TRUE;
				break;
			case SHADER_LOCKDS_ON_CHUNK:
				lockDS = TRUE;
				break;
			case SHADER_LOCKAD_ON_CHUNK:
				lockAD = TRUE;
				break;
			case SHADER_LOCKADTEX_ON_CHUNK:
				lockADTex = TRUE;
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < CURRENT_ON_SHADER_VERSION ) {
		iload->RegisterPostLoadCallback(new ONShaderCB(this, version));
		iload->SetObsolete();
	}

	return IO_OK;

}

			
///////////////////////////////////////////////////////////////////////////////////////////
// The Shader
//

//static BOOL colorDiffuseOn = TRUE;
static int stopX = 520;
static int stopY = 122;

#define RHO_EPSILON		0.001f

void OrenNayarBlinnShader::Illum(ShadeContext &sc, IllumParams &ip) 
{
	LightDesc *l;
	Color lightCol;

#ifdef _DEBUG
	IPoint2 sp = sc.ScreenCoord();
	if ( sp.x == stopX && sp.y == stopY )
		sp.x = stopX;
#endif

	// Blinn style phong
	BOOL isShiny= (ip.channels[ID_SS].r > 0.0f) ? 1 : 0; 
	double phExp = 0.0;
	if (isShiny)
		phExp = pow(2.0, ip.channels[ID_SH].r * 10.0) * 4.0; 

	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		float NL, kL;
		Point3 L;
		if (l->Illuminate( sc, ip.N, lightCol, L, NL, kL)) {
			if (l->ambientOnly) {
				ip.ambIllumOut += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;

			// specular  
			Color spec( 0.0f, 0.0f, 0.0f );
			if (isShiny && l->affectSpecular) {
				Point3 H = Normalize(L-ip.V); // (L + -V)/2
				float c = DotProd(ip.N,H);	 
				if (c>0.0f) {
					if (softThresh != 0.0 && kL < softThresh) {
						c *= Soften(kL/softThresh);
					}
					c = (float)pow((double)c, phExp); // could use table lookup for speed
					spec = c * ip.channels[ID_SS].r * lightCol;
					ip.specIllumOut += spec;
				}
			}

			// diffuse
			if (l->affectDiffuse){
				Color d = OrenNayarIllum( ip.N, L, -ip.V, ip.channels[ID_DIFF_ROUGH].r * Pi*0.5f, ip.channels[ID_DI], NL );
				d = d * ip.channels[ID_DIFF_LEV].r; 
				ip.diffIllumOut += kL * d * lightCol;
			}
 		}
	} // for each light

	// Apply mono self illumination
	if ( ! selfIllumClrOn ){
		float si = 0.3333333f * (ip.channels[ID_SI].r + ip.channels[ID_SI].g + ip.channels[ID_SI].b);
//		float si = ip.channels[ID_SI].r;  //DS: 4/23/99
		if ( si > 0.0f ) {
			si = Bound( si );
			ip.selfIllumOut = si * ip.channels[ID_DI];
			ip.diffIllumOut *= (1.0f - si);
			// fade the ambient down on si: 5/27/99 ke
			ip.ambIllumOut *= 1.0f-si;
			}
		}
	else {
	// colored self illum, 
		ip.selfIllumOut += ip.channels[ID_SI];
	}

	
	// get the diffuse intensity...unscramble the wavelength dependence
	float rho, diffIntens;
	rho = ip.channels[ID_DI].r == 0.0f ? 1.0f : 1.0f / ip.channels[ID_DI].r;
	diffIntens = ip.diffIllumOut.r * rho;
	rho = ip.channels[ID_DI].g == 0.0f ? 1.0f : 1.0f / ip.channels[ID_DI].g;
	diffIntens += ip.diffIllumOut.g * rho;
	rho = ip.channels[ID_DI].b == 0.0f ? 1.0f : 1.0f / ip.channels[ID_DI].b;
	diffIntens += ip.diffIllumOut.b * rho;
	ip.diffIllumIntens = diffIntens * 0.5f;
	// now we can multiply by the clrs
	ip.specIllumOut *= ip.channels[ID_SP]; 
	ip.ambIllumOut *= ip.channels[ID_AM]; 

}

///////////////////////////////////////////////////////////////////
//
//	OrenNayar shader dlg panel
//

// The dialog class
class OrenNayarShaderDlg : public ShaderParamDlg {
public:
	OrenNayarBlinnShader*	pShader;
	StdMat2*	pMtl;
	HPALETTE	hOldPal;
	HWND		hwmEdit;	// window handle of the materials editor dialog
	IMtlParams*	pMtlPar;
	HWND		hwHilite;   // the hilite window
	HWND		hRollup;	// Rollup panel
	TimeValue	curTime;
	BOOL		valid;
	BOOL		isActive;

	IColorSwatch *cs[NCOLBOX];
	ISpinnerControl *softSpin;
	ISpinnerControl *shSpin, *ssSpin, *siSpin, *trSpin;
	ISpinnerControl *dlevSpin, *roughSpin; //, *rhoSpin;
	ICustButton* texMBut[NMBUTS];
	TexDADMgr dadMgr;
	
	OrenNayarShaderDlg( HWND hwMtlEdit, IMtlParams *pParams ); 
	~OrenNayarShaderDlg(); 

	// required for correctly operating map buttons
	int FindSubTexFromHWND(HWND hw) {
		for (long i=0; i<NMBUTS; i++) {
			if (hw == texMBut[i]->GetHwnd()) 
				return texmapFromMBut[i];
		}	
		return -1;
	}

	// Methods
	BOOL PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ); 
	Class_ID ClassID(){ return OrenNayarShaderDlgClassID; }
	void SetThing(ReferenceTarget *m){ pMtl = (StdMat2*)m; }
	void SetThings( StdMat2* theMtl, Shader* theShader )
	{	if (pShader) pShader->SetParamDlg(NULL);   
		pShader = (OrenNayarBlinnShader*)theShader; 
		if(pShader) pShader->SetParamDlg(this);
		pMtl = theMtl;
	}

	ReferenceTarget* GetThing(){ return pMtl; } // mtl is the thing! used by DAD...
	Shader* GetShader(){ return pShader; }
	void SetTime(TimeValue t) {
		//DS 2/26/99: added interval test to prevent redrawing when not necessary
		if (!pShader->ivalid.InInterval(t)) {
			Interval v;
			pShader->Update(t,v);
			LoadDialog(TRUE); 
			}
		curTime = t; 
		}		
	BOOL KeyAtCurTime(int id) { return pShader->KeyAtTime(id,curTime); } 
	void DeleteThis() { delete this; }
	void ActivateDlg( BOOL dlgOn ){ isActive = dlgOn; }
	HWND GetHWnd(){ return hRollup; }
	void NotifyChanged(){ pShader->NotifyChanged(); }
	void LoadDialog(BOOL draw);
	void ReloadDialog(){ Interval v; pShader->Update(pMtlPar->GetTime(), v); LoadDialog(FALSE);}
	void UpdateDialog( ParamID paramId ){ ReloadDialog(); }

	void UpdateMtlDisplay(){ pMtlPar->MtlChanged(); } // redraw viewports
    void UpdateHilite( );
	void UpdateColSwatches();
	void UpdateLockADTex(BOOL passOn);
	void UpdateMapButtons();
	void UpdateOpacity();

	void SetLockDS(BOOL lock);
	void SetLockAD(BOOL lock);
	void SetLockADTex(BOOL lock);

	void SelectEditColor(int i) { cs[ i ]->EditThis(FALSE); }
};

static BOOL CALLBACK  OrenNayarShaderDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	OrenNayarShaderDlg *theDlg;
	if (msg == WM_INITDIALOG) {
		theDlg = (OrenNayarShaderDlg*)lParam;
		SetWindowLong(hwndDlg, GWL_USERDATA, lParam);
	} else {
	    if ( (theDlg = (OrenNayarShaderDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
	}
	theDlg->isActive = 1;
	BOOL res = theDlg->PanelProc(hwndDlg, msg, wParam, lParam);
	theDlg->isActive = 0;
	return res;
}


ShaderParamDlg* OrenNayarBlinnShader::CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen ) 
{
	Interval v;
	Update(imp->GetTime(),v);
	
	OrenNayarShaderDlg *pDlg = new OrenNayarShaderDlg(hwMtlEdit, imp);
	pDlg->SetThings( theMtl, this  );

	LoadStdShaderResources();
	if ( hOldRollup ) {
		pDlg->hRollup = imp->ReplaceRollupPage( 
			hOldRollup,
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_ONB2),
			OrenNayarShaderDlgProc, 
			GetString(IDS_DS_ON_BASIC),	
			(LPARAM)pDlg , 
			rollupOpen
			);
	} else
		pDlg->hRollup = imp->AddRollupPage( 
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_ONB2),
			OrenNayarShaderDlgProc, 
			GetString(IDS_DS_ON_BASIC),	
			(LPARAM)pDlg , 
			rollupOpen
			);

	return (ShaderParamDlg*)pDlg;	
}

RefResult OrenNayarBlinnShader::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
									  PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock){
				// update UI if paramblock changed, possibly from scripter
				ParamID changingParam = pblock->LastNotifyParamID();
				// reload the dialog if present
				if (paramDlg){
					paramDlg->UpdateDialog( changingParam );
				}
			}
			break;
	}
	return(REF_SUCCEED);
}

OrenNayarShaderDlg::OrenNayarShaderDlg( HWND hwMtlEdit, IMtlParams *pParams)
{
	pMtl = NULL;
	pShader = NULL;
	hwmEdit = hwMtlEdit;
	pMtlPar = pParams;
	dadMgr.Init(this);
	shSpin = softSpin = ssSpin = siSpin = trSpin = NULL;
	dlevSpin = roughSpin = NULL; 
	hRollup = hwHilite = NULL;
	curTime = pMtlPar->GetTime();
	isActive = valid = FALSE;

	for( long i = 0; i < NCOLBOX; ++i )
		cs[ i ] = NULL;

	for( i = 0; i < NMBUTS; ++i )
		texMBut[ i ] = NULL;
}

OrenNayarShaderDlg::~OrenNayarShaderDlg()
{
	HDC hdc = GetDC(hRollup);
	GetGPort()->RestorePalette(hdc, hOldPal);
	ReleaseDC(hRollup, hdc);

	if( pShader ) pShader->SetParamDlg(NULL);

	for (long i=0; i < NMBUTS; i++ ){
		ReleaseICustButton( texMBut[i] );
		texMBut[i] = NULL; 
	}

	for (i=0; i<NCOLBOX; i++)
		if (cs[i]) ReleaseIColorSwatch(cs[i]); // mjm - 5.10.99
	
 	ReleaseISpinner(shSpin);
	ReleaseISpinner(ssSpin);
	ReleaseISpinner(softSpin);
	ReleaseISpinner(siSpin);
	ReleaseISpinner(dlevSpin);
	ReleaseISpinner(roughSpin);
	ReleaseISpinner(trSpin);

	SetWindowLong(hRollup, GWL_USERDATA, NULL);
	SetWindowLong(hwHilite, GWL_USERDATA, NULL);
	hwHilite = hRollup = NULL;
}

void  OrenNayarShaderDlg::LoadDialog(BOOL draw) 
{
	if (pShader && hRollup) {
		shSpin->SetValue(FracToPc(pShader->GetGlossiness()),FALSE);
		shSpin->SetKeyBrackets(KeyAtCurTime(onb_glossiness));

		ssSpin->SetValue(FracToPc(pShader->GetSpecularLevel()),FALSE);
		ssSpin->SetKeyBrackets(KeyAtCurTime(onb_specular_level));

		softSpin->SetValue(pShader->GetSoftenLevel(),FALSE);
		softSpin->SetKeyBrackets(KeyAtCurTime(onb_soften));

		trSpin->SetValue(FracToPc(pMtl->GetOpacity( curTime )),FALSE);
		trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));

		dlevSpin->SetValue(FracToPc(pShader->GetDiffuseLevel()),FALSE);
		dlevSpin->SetKeyBrackets(KeyAtCurTime(onb_diffuse_level));

		roughSpin->SetValue(FracToPc(pShader->GetDiffuseRoughness()),FALSE);
		roughSpin->SetKeyBrackets(KeyAtCurTime(onb_roughness));

		CheckButton(hRollup, IDC_LOCK_AD, pShader->GetLockAD() );
		CheckButton(hRollup, IDC_LOCK_DS, pShader->GetLockDS() );
	 	UpdateLockADTex( FALSE ); //don't send to mtl

		BOOL colorSelfIllum = pShader->IsSelfIllumClrOn();
		SetCheckBox(hRollup,IDC_SI_COLORON, colorSelfIllum ); 
		if( colorSelfIllum ) {
//			ShowWindow( siSpin->GetHwnd(), SW_HIDE );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_EDIT), SW_HIDE );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_SPIN), SW_HIDE );

			ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_SHOW );
		} else {
			// disable the color swatch
			ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
			// show self-illum slider
//			ShowWindow( siSpin->GetHwnd(), SW_SHOW );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_EDIT), SW_SHOW );
			ShowWindow( GetDlgItem(hRollup, IDC_SI_SPIN), SW_SHOW );

			siSpin->SetValue(FracToPc(pShader->GetSelfIllum()), FALSE);
			siSpin->SetKeyBrackets(KeyAtCurTime(onb_self_illum_amnt));
		}

		UpdateColSwatches();
		UpdateHilite();
	}
}


void OrenNayarShaderDlg::UpdateOpacity() 
{
	trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
	trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));
}


static TCHAR* mapStates[] = { _T(" "), _T("m"),  _T("M") };

void OrenNayarShaderDlg::UpdateMapButtons() 
{

	for ( long i = 0; i < NMBUTS; ++i ) {
		int nMap = texmapFromMBut[ i ];
		int state = pMtl->GetMapState( nMap );
		texMBut[i]->SetText( mapStates[ state ] );

		TSTR nm	 = pMtl->GetMapName( nMap );
		texMBut[i]->SetTooltip(TRUE,nm);
	}
}



void OrenNayarShaderDlg::SetLockAD(BOOL lock)
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_DS_LOCKAD), GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_AD, FALSE);	
			return;	
		}
		// set ambient color to diffuse
		pShader->SetAmbientClr( pShader->GetDiffuseClr(), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockAD(lock);
}


void OrenNayarShaderDlg::UpdateColSwatches() 
{
	for(int i=0; i < NCOLBOX; i++) {
		if ( cs[ i ] ) {
			cs[i]->SetKeyBrackets( pShader->KeyAtTime(colParamID[i],curTime) );
			cs[i]->SetColor( GetMtlColor(i, (Shader*)pShader) );
		}
	}
}


void OrenNayarShaderDlg::UpdateHilite()
{
	HDC hdc = GetDC(hwHilite);
	Rect r;
	GetClientRect(hwHilite,&r);
	DrawHilite(hdc, r, pShader );
	ReleaseDC(hwHilite,hdc);
}

void OrenNayarShaderDlg::UpdateLockADTex( BOOL passOn) 
{
	int lock = 	pShader->GetLockADTex();
	CheckButton(hRollup, IDC_LOCK_ADTEX, lock);

	ShowWindow(GetDlgItem(hRollup, IDC_MAPON_AM), !lock);
	texMBut[ 0 ]->Enable(!lock);

	if ( passOn ) 
		pMtl->SyncADTexLock( lock );

//	UpdateMtlDisplay();
}

void OrenNayarShaderDlg::SetLockADTex(BOOL lock) 
{
	pShader->SetLockADTex( lock );
	UpdateLockADTex(TRUE); // passon to mtl
//	UpdateMtlDisplay();
	}

void OrenNayarShaderDlg::SetLockDS(BOOL lock) 
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_KE_LOCKDS),GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_DS, FALSE);	
			return;	
		}
		pShader->SetSpecularClr( pShader->GetDiffuseClr(), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockDS( lock );
}

static int ColorIDCToIndex(int id) {
	switch (id) {
		case IDC_STD_COLOR1: return 0;
		case IDC_STD_COLOR2: return 1;
		case IDC_STD_COLOR3: return 2;
		case IDC_SI_COLOR: return 3;
		default: return 0;
	}
}


BOOL OrenNayarShaderDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG:
			{
			int i;
			
			HDC theHDC = GetDC(hwndDlg);
			hOldPal = GetGPort()->PlugPalette(theHDC);
			ReleaseDC(hwndDlg,theHDC);

			for (i=0; i<NCOLBOX; i++) {
   				cs[i] = GetIColorSwatch(GetDlgItem(hwndDlg, colID[i]),
   					GetMtlColor(i, pShader), GetColorName(i));
			}

			hwHilite = GetDlgItem(hwndDlg, IDC_HIGHLIGHT);
			SetWindowLong( hwHilite, GWL_WNDPROC, (LONG)HiliteWndProc);

			shSpin = SetupIntSpinner(hwndDlg, IDC_SH_SPIN, IDC_SH_EDIT, 0,100, 0);
			ssSpin = SetupIntSpinner(hwndDlg, IDC_SS_SPIN, IDC_SS_EDIT, 0,999, 0);
			softSpin = SetupFloatSpinner(hwndDlg, IDC_SOFT_SPIN, IDC_SOFT_EDIT, 0.0f,1.0f,0.0f,.01f);
			trSpin = SetupIntSpinner(hwndDlg, IDC_TR_SPIN, IDC_TR_EDIT, 0,100, 0);
			dlevSpin = SetupIntSpinner(hwndDlg, IDC_DIFFLEV_SPIN, IDC_DIFFLEV_EDIT, 0, 400, 0);
			roughSpin = SetupIntSpinner(hwndDlg, IDC_DIFFROUGH_SPIN, IDC_DIFFROUGH_EDIT, 0, 100, 0);

			for (int j=0; j<NMBUTS; j++) {
				texMBut[j] = GetICustButton(GetDlgItem(hwndDlg,texMButtonsIDC[j]));
				assert( texMBut[j] );
				texMBut[j]->SetRightClickNotify(TRUE);
				texMBut[j]->SetDADMgr(&dadMgr);
			}

			SetupLockButton(hwndDlg,IDC_LOCK_AD,FALSE);
			SetupLockButton(hwndDlg,IDC_LOCK_DS,FALSE);
			SetupPadLockButton(hwndDlg,IDC_LOCK_ADTEX, TRUE);

/* // mjm - 5.10.99 - isn't this already created above when i == N_SI_CLR?
			// create both a self-illum color as well as a spinner
			cs[N_SI_CLR] = GetIColorSwatch(GetDlgItem(hwndDlg, colID[N_SI_CLR] ),
   											GetMtlColor(N_SI_CLR, pShader), GetColorName(N_SI_CLR));
*/
			siSpin = SetupIntSpinner(hwndDlg, IDC_SI_SPIN, IDC_SI_EDIT, 0,100, 0);
			
			if( pShader->IsSelfIllumClrOn() ) {
				// enable the color swatch, disable the spinner
				ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_HIDE );
				ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_HIDE );
			} else {
				// disable the color swatch
				ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
			}
			LoadDialog(TRUE);
		}
		break;

		case WM_COMMAND: 
			{
			for ( int i=0; i<NMBUTS; i++) {
				if (id == texMButtonsIDC[i]) {
					PostMessage(hwmEdit,WM_TEXMAP_BUTTON, texmapFromMBut[i],(LPARAM)pMtl );
					UpdateMapButtons();
					goto exit;
					}
				}
			}
		    switch (id) {

				case IDC_LOCK_AD:
					SetLockAD(IsButtonChecked(hwndDlg, IDC_LOCK_AD));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_DS:
					SetLockDS(IsButtonChecked(hwndDlg, IDC_LOCK_DS));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_ADTEX:{
					BOOL on = IsButtonChecked(hwndDlg, IDC_LOCK_ADTEX);
					SetLockADTex(on);
					UpdateMtlDisplay();
				} break;

				case IDC_SI_COLORON:{
					int isOn = GetCheckBox(hwndDlg, IDC_SI_COLORON );
					pShader->SetSelfIllumClrOn( isOn );			
					if ( isOn ) {
						// enable the color swatch, disable the spinner
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_HIDE );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_HIDE );
						ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_SHOW );
					} else {
						// disable the color swatch
						ShowWindow( cs[N_SI_CLR]->GetHwnd(), SW_HIDE );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_EDIT), SW_SHOW );
						ShowWindow( GetDlgItem(hwndDlg, IDC_SI_SPIN), SW_SHOW );
					}
				    NotifyChanged();
//					UpdateMtlDisplay();
				}
				break;
			}
			break;
		case CC_COLOR_SEL: {
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
		}			
		break;
		case CC_COLOR_DROP:	{
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
			UpdateMtlDisplay();				
		}
		break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
		 break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			UpdateMtlDisplay();				
			break;
		case CC_COLOR_CHANGE: {			
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = ColorIDCToIndex(id);
			if (buttonUp) theHold.Begin();
			DWORD curRGB = cs[n]->GetColor();
			SetMtlColor(n, curRGB, pShader, cs, curTime);
			if (buttonUp) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
				// DS: 5/11/99-  this was commented out. I put it back in, because
				// it is necessary for the Reset button in the color picker to 
				// update the viewport.				
				UpdateMtlDisplay();  
				}
		} break;
		case WM_PAINT: 
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
		case WM_DESTROY: 
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_SH_SPIN: 
					pShader->SetGlossiness(PcToFrac(shSpin->GetIVal()), curTime); 
					UpdateHilite();
					break;
				case IDC_SS_SPIN: 
					pShader->SetSpecularLevel(PcToFrac(ssSpin->GetIVal()),curTime); 
					UpdateHilite();
					break;
				case IDC_SOFT_SPIN: 
					pShader->SetSoftenLevel(softSpin->GetFVal(),curTime); 
					break;
				case IDC_SI_SPIN: 
					pShader->SetSelfIllum(PcToFrac(siSpin->GetIVal()),curTime); 
					break;
				case IDC_DIFFLEV_SPIN: 
					pShader->SetDiffuseLevel(PcToFrac(dlevSpin->GetIVal()),curTime); 
					break;
				case IDC_DIFFROUGH_SPIN: 
					pShader->SetDiffuseRoughness(PcToFrac(roughSpin->GetIVal()),curTime); 
					break;
				//******** >>>><<<< required handling for opacity....must be present in all dialogs
				case IDC_TR_SPIN: 
					pMtl->SetOpacity(PcToFrac( trSpin->GetIVal()),curTime); 
					break;
			}
//			UpdateMtlDisplay();
		break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;

    }
	exit:
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shadersMain.cpp ===
/**********************************************************************
 *<
	FILE: 		shadersMain.cpp

	DESCRIPTION:   	DLL main for shaders

	CREATED BY: 	Kells Elmquist

	HISTORY: 	created 2/6/1999

 *>	Copyright (c) 1999, All Rights Reserved.
 **********************************************************************/

#include "shadersPch.h"
#include "shadersRc.h"
#include "shadersMain.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
	}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}


//------------------------------------------------------
// This is the interface to Max:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR * LibDescription() { return GetString(IDS_KE_SHADERS_DESC); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() 
{
#ifndef DESIGN_VER
	return 4;
#else
	return 4;
#endif // !DESIGN_VER
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i) 
{
	switch(i) {
		// Both versions
//		case 0: return GetPhongShaderCD();
//		case 1: return GetMetalShaderCD();
//		case 2: return GetBlinnShaderCD();
		case 0: return GetOrenNayarBlinnShaderCD();
		case 1: return GetAnisoShaderCD();
		case 2: return GetMultiLayerShaderCD();
		case 3: return GetStraussShaderCD();
//		case 7: return GetOldBlinnShaderCD();

//		case 8: return GetWardShaderCD();
//		case 9: return GetConstantShaderCD();

#ifndef DESIGN_VER	// Not Design version

#else  // DESIGN_VER

#endif // DESIGN_VER

		default: return 0;
	}
}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
	static TCHAR buf[256];
	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shadersPch.cpp ===
////////////////////////////////////////////////////////////////
//	precompiled header for shaders
//
#include	"shadersPch.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shadersRc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shaders.rc
//
#define IDS_DS_RGBAMT                   1
#define IDS_DS_RGBOFF                   2
#define IDS_PW_COMPOSITE_MATERIAL       3
#define IDS_PW_TYPE                     4
#define IDS_PW_AMOUNT                   5
#define IDD_COPYTEXMAP                  104
#define IDD_MULTI_SETNUM                105
#define IDB_BITMAP1                     106
#define IDD_DIALOG1                     107
#define IDD_BRITECON_EFFECT             108
#define IDD_DMTL_BASIC2                 109
#define IDD_DMTL_BASIC3                 110
#define IDD_DMTL_EXTRA3                 111
#define IDD_DMTL_BASIC4                 112
#define IDD_DMTL_EXTRA4                 113
#define IDD_DMTL_BASIC5                 114
#define IDD_DMTL_EXTRA5                 115
#define IDD_DMTL_EXTRA6                 116
#define IDD_DMTL_BASIC6                 117
#define IDD_DMTL_SHADER1                118
#define IDD_DMTL_SAMPLING1              119
#define IDD_DMTL_BASIC7                 120
#define IDD_DMTL_SHADER2                121
#define IDB_DMTL_BUTTONS                122
#define IDD_DMTL_SHADER3                122
#define IDB_DMTL_MASKBUTTONS            123
#define IDD_DMTL_TEXMAP2                123
#define IDD_DMTL_BASIC_ONB              124
#define IDD_DMTL_SHADER4                125
#define IDD_DMTL_BASIC_ONB2             126
#define IDD_DMTL_BASIC_WARD1            127
#define IDI_ICON1                       128
#define IDB_PRESET_RECORD               129
#define IDB_PRESET_DELETE               130
#define IDD_DMTL_BASIC_WARD2            131
#define IDD_DMTL_BASIC_WARD3            134
#define IDD_DMTL_TEXMAP3                136
#define IDD_DMTL_BASIC_WARD4            137
#define IDD_DMTL_SHADER5                138
#define IDD_DMTL_BASIC_STRAUSS1         140
#define IDD_DMTL_BASIC_STRAUSS2         141
#define IDD_DMTL_BASIC_SCHLICK1         142
#define IDD_DMTL_BASIC_SCHLICK2         143
#define IDD_DMTL_BASIC_MULTILAYER       144
#define IDD_DMTL_TEXMAP4                145
#define IDD_DMTL_BASIC_MULTILAYER1      146
#define IDD_DMTL_STRAUSS3               147
#define IDD_DMTL_STRAUSS4               148
#define IDD_DMTL_BASIC_STRAUSS3         149
#define IDD_DMTL_SAMPLING2              150
#define IDD_DMTL_SAMPLING3              151
#define IDD_ATILING                     152
#define IDD_COMP_SETNUM                 192
#define IDC_SH_EDIT                     216
#define IDC_SS_EDIT                     217
#define IDC_TF_EDIT                     218
#define IDC_SOFT_EDIT                   218
#define IDC_SH_EDIT2                    218
#define IDC_SI_EDIT                     219
#define IDC_IOR_EDIT                    219
#define IDC_TR_EDIT                     220
#define IDC_DIM_AMT                     220
#define IDC_WIRE_EDIT                   221
#define IDC_DIFFLEV_EDIT                221
#define IDC_DIM_MULT                    222
#define IDC_DIM_AMT2                    222
#define IDC_DIFFROUGH_EDIT              222
#define IDC_DIFFLEV_EDIT2               222
#define IDC_USCL_EDIT                   223
#define IDC_DIM_MULT2                   223
#define IDC_DIFFREFL_EDIT               223
#define IDC_VSCL_EDIT                   224
#define IDC_DIM_MULT3                   224
#define IDC_UVANG_EDIT                  225
#define IDC_XSCL_EDIT                   225
#define IDC_UVBLUR_EDIT                 226
#define IDC_XANG_EDIT                   226
#define IDC_UVBLUROFF_EDIT              227
#define IDC_UVNOIS_AMT_EDIT             229
#define IDC_MIRNS_AMT_EDIT              229
#define IDC_UVNOIS_PER_EDIT             230
#define IDC_UVNOIS_LEV_EDIT2            231
#define IDC_SH_SPIN                     326
#define IDC_SS_SPIN                     327
#define IDC_TF_SPIN                     328
#define IDC_SOFT_SPIN                   328
#define IDC_SH_SPIN2                    328
#define IDC_SI_SPIN                     329
#define IDC_IOR_SPIN                    329
#define IDC_TR_SPIN                     330
#define IDC_DIM_AMTSPIN                 330
#define IDC_DIM_MULTSPIN                331
#define IDC_DIM_AMTSPIN2                331
#define IDC_DIFFLEV_SPIN                331
#define IDC_WIRE_SPIN                   332
#define IDC_DIFFROUGH_SPIN              332
#define IDC_DIFFLEV_SPIN2               332
#define IDC_DIM_MULTSPIN2               333
#define IDC_DIFFREFL_SPIN               333
#define IDC_USCL_SPIN                   334
#define IDC_DIM_MULTSPIN3               334
#define IDC_VSCL_SPIN                   335
#define IDC_UVANG_SPIN                  336
#define IDC_XSCL_SPIN                   336
#define IDC_UVBLUR_SPIN                 337
#define IDC_XANG_SPIN                   337
#define IDC_UVNOIS_AMT_SPIN             338
#define IDC_UVBLUROFF_SPIN              338
#define IDC_MIRNS_AMT_SPIN              338
#define IDC_UVNOISE_PER_SPIN            339
#define IDC_UVNOISE_LEV_SPIN            340
#define IDC_TOP_MTL                     1000
#define IDC_BOT_MTL                     1001
#define IDC_TR_ADD                      1003
#define IDC_CMTL_Y_EDIT                 1003
#define IDC_TR_SUB                      1004
#define IDC_CMTL_Y_SPIN                 1004
#define IDC_TR_SUB2                     1005
#define IDC_CMTL_SWAP                   1005
#define IDC_TF_IN                       1006
#define IDC_USE_FILTER                  1006
#define IDC_TF_OUT                      1007
#define IDC_UVTYPE                      1008
#define IDC_UV_MIRROR                   1010
#define IDC_U_MIRROR                    1010
#define IDC_UOFFS_EDIT                  1011
#define IDC_UOFFS_SPIN                  1012
#define IDC_VOFFS_EDIT                  1013
#define IDC_VOFFS_SPIN                  1014
#define IDC_UV_NOISE                    1015
#define IDC_V_MIRROR                    1015
#define IDC_UV_TILE                     1016
#define IDC_XOFFS_EDIT                  1016
#define IDC_U_TILE                      1016
#define IDC_SOFTEN                      1017
#define IDC_USEMAP_DI                   1017
#define IDC_UV_AXIS_X                   1017
#define IDC_XOFFS_SPIN                  1017
#define IDC_OLD_SPEC                    1017
#define IDC_USEMAP_AM                   1018
#define IDC_UV_AXIS_Y                   1018
#define IDC_CUBE_PICK                   1018
#define IDC_UV_AXIS_Z                   1019
#define IDC_ACUBE_PICKCAM               1019
#define IDC_CHECK_TEX1                  1020
#define IDC_V_TILE                      1020
#define IDC_GRAD_TEX1                   1020
#define IDC_ATILING_TEX1                1020
#define IDC_CHECK_TEX2                  1021
#define IDC_GRAD_TEX2                   1021
#define IDC_ATILING_TEX2                1021
#define IDC_USEMAP_SI                   1022
#define IDC_CHECK_COL1                  1022
#define IDC_GRAD_COL1                   1022
#define IDC_ATILING_COL1                1022
#define IDC_CHECK_COL2                  1023
#define IDC_GRAD_COL2                   1023
#define IDC_ATILING_COL2                1023
#define IDC_R_EDIT                      1024
#define IDC_BLUR_SPIN                   1024
#define IDC_TINT_B                      1024
#define IDC_GRAD_TEX3                   1024
#define IDC_ATILING_COL3                1024
#define IDC_G_EDIT                      1025
#define IDC_CMTL_W_EDIT                 1025
#define IDC_BMTEX_RATE                  1025
#define IDC_GRAD_COL3                   1025
#define IDC_ATILING_TEX3                1025
#define IDC_B_EDIT                      1026
#define IDC_BLUR_EDIT                   1026
#define IDC_R_SPIN                      1027
#define IDC_MARB_COL1                   1027
#define IDC_G_SPIN                      1028
#define IDC_CMTL_W_SPIN                 1028
#define IDC_MARB_COL2                   1028
#define IDC_BMTEX_RATE_SPIN             1028
#define IDC_B_SPIN                      1029
#define IDC_MARB_TEX1                   1029
#define IDC_MARB_TEX2                   1030
#define IDD_DMTL_BASIC                  1031
#define IDC_WIDTH_SPIN                  1031
#define IDC_WIDTH_EDIT                  1032
#define IDD_DMTL_TEXMAP                 1033
#define IDC_MARBSIZE_EDIT               1033
#define IDC_BMTEX_NAME                  1033
#define IDD_DMTL_EXTRA                  1034
#define IDC_MARBSIZE_SPIN               1034
#define IDC_MTL_COLORS                  1035
#define IDC_AMT_OP                      1035
#define IDD_CMTL_BASIC                  1035
#define IDD_CMTL                        1035
#define IDC_FILTER_PYR                  1035
#define IDC_SPIN_OP                     1036
#define IDD_DMTL_BASIC1                 1036
#define IDC_FILTER_SAT                  1036
#define IDC_AMT_FI                      1037
#define IDD_UVGEN                       1037
#define IDC_FILTER_NADA                 1037
#define IDC_MAPON_TR                    1038
#define IDC_SPIN_BU                     1038
#define IDD_CHECKER                     1038
#define IDC_SPIN_FI                     1039
#define IDD_MARBLE                      1039
#define IDD_BMTEX                       1040
#define IDC_MIX_COL1                    1040
#define IDD_MIX                         1041
#define IDC_MIX_COL2                    1041
#define IDC_MIX_TEX1                    1042
#define IDD_NOISE                       1042
#define IDC_PIXELS                      1043
#define IDC_MIX_TEX2                    1043
#define IDD_MASK                        1043
#define IDC_ALPHA_FILE                  1043
#define IDC_UNITS                       1044
#define IDC_ALPHA_XPCOL                 1044
#define IDC_MIX_TEX3                    1044
#define IDD_TINT                        1044
#define IDC_MIX_SPIN                    1045
#define IDC_ALPHA_RGB                   1045
#define IDD_MULTI                       1045
#define IDC_ALPHA_NONE                  1046
#define IDC_MIX_EDIT                    1046
#define IDD_DOUBLESIDED                 1046
#define IDC_NOISE_COL1                  1047
#define IDD_MIXMAT                      1047
#define IDC_WIRE                        1048
#define IDC_NOISE_COL2                  1048
#define IDD_AUTO_CUBIC                  1048
#define IDC_LOCK_AD                     1049
#define IDC_MAPPAR_SP                   1049
#define IDC_NOISESIZE_SPIN              1049
#define IDD_MIRROR                      1049
#define IDC_LOCK_DS                     1050
#define IDC_MAPPAR_OP                   1050
#define IDC_NOISESIZE_EDIT              1050
#define IDD_MATTE                       1050
#define IDC_H_EDIT                      1051
#define IDC_NOISE_TEX1                  1051
#define IDC_MIXA_EDIT                   1051
#define IDD_BMTEX_TIME                  1051
#define IDC_PRESET_REC                  1051
#define IDC_S_EDIT                      1052
#define IDC_NOISE_TEX2                  1052
#define IDC_MIXA_SPIN                   1052
#define IDD_XYZGEN                      1052
#define IDC_PRESET_DEL                  1052
#define IDC_V_EDIT                      1053
#define IDC_MIXB_EDIT                   1053
#define IDD_UVNOISE                     1053
#define IDC_GRAD_TURB                   1053
#define IDC_PRESET_MORE                 1053
#define IDC_LOCK_ADTEX                  1054
#define IDC_NOISE_SWAP                  1054
#define IDC_MIXB_SPIN                   1054
#define IDD_TEXOUT                      1054
#define IDC_AMB                         1055
#define IDC_MAPPAR_SH                   1055
#define IDC_MIXCURVE                    1055
#define IDC_NOISEPHASE_EDIT             1055
#define IDD_COMPOSITEMAP                1055
#define IDC_DIFF                        1056
#define IDC_MAPPAR_SI                   1056
#define IDC_MIX_USECURVE                1056
#define IDC_NOISEPHASE_SPIN             1056
#define IDD_GRADIENT                    1056
#define IDC_SPEC                        1057
#define IDC_MAPPAR_RL                   1057
#define IDC_CHECK_SWAP                  1057
#define IDC_NOISELEV_EDIT               1057
#define IDD_DMTL_DYNAM                  1057
#define IDC_MAPPAR_SS                   1058
#define IDC_FILT                        1058
#define IDC_MARBLE_SWAP                 1058
#define IDC_NOISELEV_SPIN               1058
#define IDD_BMTEX1                      1058
#define IDD_FALLOFF                     1058
#define IDC_MAP_SS                      1059
#define IDC_COPYMAP                     1059
#define IDC_FACE_MAP                    1059
#define IDD_RGBMULT                     1059
#define IDC_MAPON_SI                    1060
#define IDC_MAP_OP                      1060
#define IDC_INSTMAP                     1060
#define IDC_MIX_SWAP                    1060
#define IDD_OUTPUT                      1060
#define IDC_FACETED                     1060
#define IDC_MAPON_SH                    1061
#define IDC_MAP_FI                      1061
#define IDC_MASK_MAP                    1061
#define IDD_VCOL                        1061
#define IDD_SAMPLE_EFFECT               1061
#define IDC_HIGHLIGHT                   1062
#define IDC_MAP_SH                      1062
#define IDC_MASK_MASK                   1062
#define IDD_PBLUR_PARAMS                1062
#define IDC_H_SPIN                      1063
#define IDC_TINT_MAP                    1063
#define IDD_PLATE                       1063
#define IDC_MAPON_SH2                   1063
#define IDC_HIGHLIGHT2                  1063
#define IDC_S_SPIN                      1064
#define IDC_TINT_R                      1064
#define IDD_RAYMAP                      1064
#define IDD_PARTAGE_PARAMS              1064
#define IDC_V_SPIN                      1065
#define IDC_TINT_G                      1065
#define IDD_VCOL1                       1065
#define IDC_SHADING                     1066
#define IDC_MAP_SI2                     1066
#define IDC_MAP_SI                      1066
#define IDD_COMPOSITE_MAT               1066
#define IDC_2SIDE                       1067
#define IDC_SUPER_SAMP                  1068
#define IDC_ADAPT_ON                    1069
#define IDC_SAMPLE_TEX                  1070
#define IDC_MAP_DI                      1071
#define IDC_MAP_SP                      1072
#define IDC_AMT_DI                      1073
#define IDC_AMT_SP                      1074
#define IDC_AMT_AM                      1075
#define IDC_AMT_BU                      1076
#define IDC_AMT_SH                      1077
#define IDC_AMT_SI                      1078
#define IDC_AMT_RL                      1079
#define IDC_AMT_RR                      1080
#define IDC_USEMAP_RR                   1081
#define IDC_USEMAP_RL                   1082
#define IDC_USEMAP_BU                   1083
#define IDC_USEMAP_OP                   1084
#define IDC_MULTI_NUMMATS               1084
#define IDC_USEMAP_SP                   1085
#define IDC_MULTI_NUMMATSSPIN           1085
#define IDC_SPIN_DI                     1086
#define IDC_MULTI_UP                    1086
#define IDC_SPIN_SP                     1087
#define IDC_MULTI_DOWN                  1087
#define IDC_2SIDE_MAT1                  1087
#define IDC_SPIN_SH                     1088
#define IDC_MULTI_PAGEUP                1088
#define IDC_2SIDE_MAT2                  1088
#define IDC_SPIN_SI                     1089
#define IDC_MULTI_PAGEDOWN              1089
#define IDC_2SIDE_TRANSLUCENCY          1089
#define IDC_SPIN_RL                     1090
#define IDC_2SIDE_TRANSLUCENCYSPIN      1090
#define IDC_MULTI_SETNUM                1090
#define IDC_SPIN_RR                     1091
#define IDC_MIXMAT_MAT1                 1091
#define IDC_MULTI_SETNUM2               1091
#define IDC_MAP_BU                      1092
#define IDC_MIXMAT_MAT2                 1092
#define IDC_MAP_RL                      1093
#define IDC_MIXMAT_MIX                  1093
#define IDC_MAP_RR                      1094
#define IDC_MIXMAT_MIXSPIN              1094
#define IDC_MAPPAR_RR                   1095
#define IDC_USEMAP_FI                   1095
#define IDC_MIXMAT_MAP                  1095
#define IDC_MAPPAR_BU                   1096
#define IDC_MIXMAT_USE1                 1096
#define IDC_USEMAP_DP                   1096
#define IDC_MAPPAR_DI                   1097
#define IDC_MIXMAT_USE2                 1097
#define IDC_ACUBE_SIZE_SPIN             1097
#define IDC_AMT_DP                      1097
#define IDC_USEMAP_SH                   1098
#define IDC_ACUBE_SIZE_EDIT             1098
#define IDC_SPIN_AM                     1099
#define IDC_ACUBE_BLUR_EDIT             1099
#define IDC_MAP_AM                      1100
#define IDC_ACUBE_BLUR_SPIN             1100
#define IDC_MAPPAR_AM                   1101
#define IDC_FIRST_ONLY                  1101
#define IDC_SPIN_DP                     1101
#define IDC_USEMAP_SS                   1102
#define IDC_EVERY_NTH                   1102
#define IDC_MAPON_AM                    1103
#define IDC_AMT_SS                      1103
#define IDC_ACUBE_NTH_EDIT              1103
#define IDC_MAPON_DI                    1104
#define IDC_SPIN_SS                     1104
#define IDC_ACUBE_NTH_SPIN              1104
#define IDC_MAPON_SP                    1105
#define IDC_ACUBE_BLUOFF_EDIT           1105
#define IDC_MAP_DP                      1105
#define IDC_MAPON_SS                    1106
#define IDC_ACUBE_BLUROFF_SPIN          1106
#define IDC_MAPON_FI                    1107
#define IDC_ACUBE_BLUR                  1107
#define IDC_MAPON_DIFF_LEVEL            1107
#define IDC_BMTEX_RELOAD                1108
#define IDC_MIR_APPLY_MTLID             1108
#define IDC_ACUBE_NEAR_EDIT             1108
#define IDC_MAPON_DIFF_ROUGH            1108
#define IDC_MAPON_DIFF_LEVEL2           1108
#define IDC_STD_COLOR1                  1109
#define IDC_ACUBE_NEAR_SPIN             1109
#define IDC_MATTE_FOGBG                 1110
#define IDC_ACUBE_FAR_EDIT              1110
#define IDC_SI_COLOR                    1110
#define IDC_MATTE_SHADOW                1111
#define IDC_ACUBE_FAR_SPIN              1111
#define IDC_MAPON_DIFF_RHO              1111
#define IDC_MATTE_AMB_SPIN              1112
#define IDC_STD_COLOR2                  1113
#define IDC_MATTE_AMB_EDIT              1113
#define IDC_STD_COLOR3                  1114
#define IDC_MATTE_OPAQUE                1114
#define IDC_YOFFS_EDIT                  1114
#define IDC_STD_COLOR4                  1115
#define IDC_MATTE_FOG_BGDEPTH           1115
#define IDC_ZOFFS_EDIT                  1115
#define IDC_MATTE_FOG_OBJDEPTH          1116
#define IDC_YOFFS_SPIN                  1116
#define IDC_GRAD_REGULAR                1116
#define IDC_STD_COLOR5                  1116
#define IDC_ZOFFS_SPIN                  1117
#define IDC_GRAD_FRACT                  1117
#define IDC_MATTE_REFLAMT_EDIT          1117
#define IDC_YSCL_EDIT                   1118
#define IDC_MATTE_REFLAMT_SPIN          1118
#define IDC_BMTEX_LOOP                  1119
#define IDC_YSCL_SPIN                   1119
#define IDC_BMTEX_PINGPONG              1120
#define IDC_ZSCL_EDIT                   1120
#define IDC_BMTEX_HOLD                  1121
#define IDC_ZSCL_SPIN                   1121
#define IDC_BMTEX_START                 1122
#define IDC_YANG_EDIT                   1122
#define IDC_BMTEX_START_SPIN            1123
#define IDC_YANG_SPIN                   1123
#define IDC_BMTEX_RGBOUT                1124
#define IDC_ZANG_EDIT                   1124
#define IDC_BMTEX_ALPHAOUT              1125
#define IDC_ZANG_SPIN                   1125
#define IDC_USE_ENVMAP                  1125
#define IDC_BMTEX_RGBOUT2               1126
#define IDC_MIR_BEHINDCAM               1126
#define IDC_UVNOIS_SIZ_EDIT             1127
#define IDC_BMTEX_ALPHAOUT2             1127
#define IDC_MIRNS_SIZ_EDIT              1127
#define IDC_UVNOIS_SIZ_SPIN             1128
#define IDC_MIRNS_SIZ_SPIN              1128
#define IDC_UVNOIS_ON                   1129
#define IDC_ALPHA_PREMULT               1129
#define IDC_MIRNS_ON                    1129
#define IDC_UVNOIS_LEV_EDIT             1130
#define IDC_CUBESRC_AUTO                1130
#define IDC_MIRNS_LEV_EDIT              1130
#define IDC_UVNOIS_LEV_SPIN             1131
#define IDC_CUBESRC_FILE                1131
#define IDC_MIRNS_LEV_SPIN              1131
#define IDC_UVNOIS_ANI                  1132
#define IDC_CUBE_UP                     1132
#define IDC_MIRNS_ANI                   1132
#define IDC_UVNOIS_ANI_SPIN             1133
#define IDC_CUBE_DN                     1133
#define IDC_MIRNS_ANI_SPIN              1133
#define IDC_UVNOIS_ANI_EDIT             1134
#define IDC_TEXOUT_INVERT               1134
#define IDC_CUBE_LF                     1134
#define IDC_MIRNS_ANI_EDIT              1134
#define IDC_OUTLEV_EDIT                 1135
#define IDC_CUBE_RT                     1135
#define IDC_OUTLEV_SPIN                 1136
#define IDC_CUBE_FR                     1136
#define IDC_OUTOFF_SPIN                 1137
#define IDC_CUBE_BK                     1137
#define IDC_OUTOFF_EDIT                 1138
#define IDC_FILE_UP                     1138
#define IDC_OUTAMT_EDIT                 1139
#define IDC_CUBE_OUTFILE                1139
#define IDC_OUTAMT_SPIN                 1140
#define IDC_FILE_DN                     1140
#define IDC_FILE_LF                     1141
#define IDC_FILE_RT                     1142
#define IDC_FILE_FR                     1143
#define IDC_FILE_BK                     1144
#define IDC_CUBE_BLUR_GRP               1145
#define IDC_CUBE_AUTO_GRP               1146
#define IDC_CUBE_FILE_GRP               1147
#define IDC_CUBE_FILE_GRP2              1148
#define IDC_CUBE_OUTFILE_NAME           1149
#define IDC_CUBE_AUTO_GRP2              1150
#define IDC_CUBE_BLUR_GRP2              1151
#define IDC_USE_UV                      1152
#define IDC_USE_VW                      1153
#define IDC_USE_WU                      1154
#define IDC_UV_MAPPING                  1156
#define IDC_CUBE_RELOAD                 1156
#define IDC_CLIP_X                      1157
#define IDC_TEXMAP                      1158
#define IDC_CLIP_XSPIN                  1158
#define IDC_ENVMAP                      1159
#define IDC_CLIP_Y                      1159
#define IDC_COORD_XYZ                   1160
#define IDC_CLIP_YSPIN                  1160
#define IDC_COORD_UVW                   1161
#define IDC_CLIP_W                      1161
#define IDC_XLABEL                      1162
#define IDC_CLIP_WSPIN                  1162
#define IDC_YLABEL                      1163
#define IDC_CLIP_H                      1163
#define IDC_ZLABEL                      1164
#define IDC_CLIP_HSPIN                  1164
#define IDC_CLIPH_SPIN                  1164
#define IDC_FALL_FAR                    1165
#define IDC_JITTER_EDIT                 1165
#define IDC_BM_CLIP                     1166
#define IDC_FALL_FAR_SPIN               1166
#define IDC_MATTE_SHADALPHA             1167
#define IDC_FALL_NEAR                   1167
#define IDC_JITTER_SPIN                 1167
#define IDC_BM_CROP_IMAGE               1168
#define IDC_FALL_NEAR_SPIN              1168
#define IDC_MATTE_USEREFL               1168
#define IDC_SHAD_COLOR                  1177
#define IDC_MTL_NAME6                   1186
#define IDC_CHKMAP1                     1191
#define IDC_ATILING_MAP1                1191
#define IDC_CHKMAP2                     1192
#define IDC_ATILING_MAP2                1192
#define IDC_BOUNCE_EDIT                 1193
#define IDC_ATILING_MAP3                1193
#define IDC_BOUNCE_SPIN                 1194
#define IDC_STATFRIC_EDIT               1195
#define IDC_STATFRIC_SPIN               1196
#define IDC_SLIDFRIC_EDIT               1197
#define IDC_CMTL_LOCAL                  1197
#define IDC_SLIDFRIC_SPIN               1198
#define IDC_CMTL_WORLD                  1198
#define IDC_INVERT_MASK                 1206
#define IDC_MULT_TEX1                   1214
#define IDC_MULT_TEX2                   1215
#define IDC_MULT_ALPHA1                 1216
#define IDC_MULT_ALPHA2                 1217
#define IDC_OUT_MAP                     1217
#define IDC_MULT_ALPHA3                 1218
#define IDC_FALLDIR_VIEW                1218
#define IDC_FALLDIR_OBJ                 1219
#define IDC_FALLDIR_X                   1220
#define IDC_FALLDIR_Y                   1221
#define IDC_FALLDIR_Z                   1222
#define IDC_FALLDIR_XW                  1223
#define IDC_FALLDIR_YW                  1224
#define IDC_FALLDIR_ZW                  1225
#define IDC_FALL_OBJNAME                1227
#define IDC_MULTI_SCROLL                1229
#define IDC_COMP_SCROLL                 1231
#define IDC_FALL_NEARNAME               1232
#define IDC_FALL_FARNAME                1233
#define IDC_FALL_PP                     1236
#define IDC_FALL_FB                     1237
#define IDC_FALLOFF_PICK                1238
#define IDC_FALL_SWAP                   1239
#define IDC_MIRNS_REG                   1251
#define IDC_MIRNS_FRAC                  1252
#define IDC_DIM_REFL                    1252
#define IDC_MIRNS_TURB                  1253
#define IDC_VC_VC                       1254
#define IDC_VC_UVW                      1255
#define IDC_PBLUR_COLOR1                1256
#define IDC_PBLUR_COLOR2                1257
#define IDC_PBLUR_SHARP                 1258
#define IDC_PBLUR_SHARPSPIN             1259
#define IDC_PLT_AMT_EDIT                1260
#define IDC_PLT_AMT_SPIN                1261
#define IDC_PLT_THK_EDIT                1262
#define IDC_PLT_THK_SPIN                1263
#define IDC_BM_CROP                     1264
#define IDC_BM_PLACE                    1265
#define IDC_BM_JITTER                   1266
#define IDC_MULT_COL1                   1267
#define IDC_MULT_COL2                   1268
#define IDC_RAY_MAXDEPTH                1268
#define IDC_RAY_MAXDEPTH_SPIN           1269
#define IDC_MIRDIST_NONE                1270
#define IDC_MIRDIST_BUMP                1271
#define IDC_MIRDIST_NOISE               1272
#define IDC_MIR_DISTORTION              1273
#define IDC_MIR_MID_EDIT                1274
#define IDC_MIR_MID_SPIN                1275
#define IDC_GRAD_LINEAR                 1494
#define IDC_GRAD_RADIAL                 1495
#define IDC_GRAD_AMOUNT                 1496
#define IDC_GRAD_AMOUNTSPIN             1497
#define IDC_GRAD_SIZE                   1498
#define IDC_COMP_LABEL1                 1499
#define IDC_GRAD_SIZESPIN               1499
#define IDC_COMP_UP                     1500
#define IDC_GRAD_PHASE                  1500
#define IDC_COMP_DOWN                   1501
#define IDC_GRAD_PHASESPIN              1501
#define IDC_COMP_PAGEUP                 1502
#define IDC_GRAD_CENTER                 1502
#define IDC_COMP_PAGEDOWN               1503
#define IDC_GRAD_CENTERSPIN             1503
#define IDC_COMP_NUMMAPS                1504
#define IDC_GRAD_LEVELS                 1504
#define IDC_COMP_SETNUM                 1505
#define IDC_GRAD_LEVELSSPIN             1505
#define IDC_COMP_NUMMAPSSPIN            1505
#define IDC_NOISE_LOWTHRESH             1506
#define IDC_GRAD_LOWTHRESH              1506
#define IDC_NOISE_LOWTHRESHSPIN         1507
#define IDC_COMP_LABEL2                 1507
#define IDC_GRAD_LOWTHRESHSPIN          1507
#define IDC_NOISE_HIGHTHRESH            1508
#define IDC_GRAD_HIGHTHRESH             1508
#define IDC_NOISE_HIGHTHRESHSPIN        1509
#define IDC_COMP_LABEL3                 1509
#define IDC_GRAD_HIGHTHRESHSPIN         1509
#define IDC_GRAD_THRESHSMOOTH           1510
#define IDC_COMP_LABEL4                 1511
#define IDC_GRAD_THRESHSMOOTHSPIN       1511
#define IDC_COMP_LABEL5                 1513
#define IDC_COMP_LABEL6                 1515
#define IDC_NOISE_REGULAR               1516
#define IDC_NOISE_FRACT                 1517
#define IDC_NOISE_TURB                  1518
#define IDC_COMP_TEX1                   1521
#define IDC_COMP_TEX2                   1522
#define IDC_COMP_TEX3                   1523
#define IDC_COMP_TEX4                   1524
#define IDC_COMP_TEX5                   1525
#define IDC_COMP_TEX6                   1526
#define IDC_MULTI_COLOR1                1540
#define IDC_MULTI_COLOR2                1541
#define IDC_MULTI_COLOR3                1542
#define IDC_MULTI_COLOR4                1543
#define IDC_MULTI_COLOR5                1544
#define IDC_MULTI_COLOR6                1545
#define IDC_MULTI_COLOR7                1546
#define IDC_MULTI_COLOR8                1547
#define IDC_MULTI_COLOR9                1548
#define IDC_MULTI_COLOR10               1549
#define IDC_MTL_NAME0                   1580
#define IDC_MTL_NAME1                   1581
#define IDC_MTL_NAME2                   1582
#define IDC_MTL_NAME3                   1583
#define IDC_MTL_NAME4                   1584
#define IDC_MTL_NAME5                   1585
#define IDC_MTL_NAME7                   1587
#define IDC_MTL_NAME8                   1588
#define IDC_MTL_NAME9                   1589
#define IDC_MULTI_MTL0                  1600
#define IDC_MULTI_MTL1                  1601
#define IDC_MULTI_MTL2                  1602
#define IDC_MULTI_MTL3                  1603
#define IDC_MULTI_MTL4                  1604
#define IDC_MULTI_MTL5                  1605
#define IDC_MULTI_MTL6                  1606
#define IDC_MULTI_MTL7                  1607
#define IDC_MULTI_MTL8                  1608
#define IDC_MULTI_MTL9                  1609
#define IDC_MULTI_MATLABEL1             1620
#define IDC_MULTI_MATLABEL2             1621
#define IDC_MULTI_MATLABEL3             1622
#define IDC_MULTI_MATLABEL4             1623
#define IDC_MULTI_MATLABEL5             1624
#define IDC_MULTI_MATLABEL6             1625
#define IDC_MULTI_MATLABEL7             1626
#define IDC_MULTI_MATLABEL8             1627
#define IDC_MULTI_MATLABEL9             1628
#define IDC_MULTI_MATLABEL10            1629
#define IDC_MAPON1                      1640
#define IDC_MAPON2                      1641
#define IDC_MAPON3                      1642
#define IDC_MAPON4                      1643
#define IDC_MAPON5                      1644
#define IDC_MAPON6                      1645
#define IDC_MAPON7                      1646
#define IDC_MAPON8                      1647
#define IDC_MAPON9                      1648
#define IDC_MAPON10                     1649
#define IDC_MULT_NUM1                   1660
#define IDC_MULT_NUM2                   1661
#define IDC_MULT_NUM3                   1662
#define IDC_MULT_NUM4                   1663
#define IDC_MULT_NUM5                   1664
#define IDC_MULT_NUM6                   1665
#define IDC_MULT_NUM7                   1666
#define IDC_MULT_NUM8                   1667
#define IDC_MULT_NUM9                   1668
#define IDC_MULT_NUM10                  1669
#define IDC_MTL_ON1                     1690
#define IDC_MTL_ON2                     1691
#define IDC_PARTAGE_COLOR1              1700
#define IDC_PARTAGE_MAP1                1701
#define IDC_PARTAGE_COLOR2              1702
#define IDC_PARTAGE_MAP2                1703
#define IDC_PARTAGE_COLOR3              1704
#define IDC_PARTAGE_MAP3                1705
#define IDC_PARTAGE_USEMAP1             1706
#define IDC_PARTAGE_USEMAP2             1707
#define IDC_PARTAGE_USEMAP3             1708
#define IDC_PARTAGE_AGE1                1709
#define IDC_PARTAGE_AGE1SPIN            1710
#define IDC_PARTAGE_AGE2                1711
#define IDC_MAPON                       1711
#define IDC_PARTAGE_AGE2SPIN            1712
#define IDC_MATTE_REFL_MAP              1712
#define IDC_PARTAGE_AGE3                1713
#define IDC_SAMP_COLOR                  1713
#define IDC_PARTAGE_AGE3SPIN            1714
#define IDC_BC_BRIGHTNESS               1718
#define IDC_BC_CONTRAST                 1719
#define IDC_BC_BRIGHTNESS_SPIN          1720
#define IDC_BC_CONTRAST_SPIN            1721
#define IDC_COMBO1                      1724
#define IDC_SI_COLORON                  1725
#define IDC_SPEC_PRESETS                1726
#define IDC_SHADER                      1728
#define IDC_SAMPLEQUALITY_SPIN          1729
#define IDC_SAMPLEQUALITY_EDIT          1730
#define IDC_PIX_SAMPLER                 1731
#define IDC_THRESHOLD_EDIT              1732
#define IDC_THRESHOLD_SPIN              1733
#define IDC_FILTER_CS                   1736
#define IDC_USEMAP_0                    1737
#define IDC_AMTEDIT_0                   1738
#define IDC_AMTSPIN_0                   1739
#define IDC_MAP_0                       1740
#define IDC_USEMAP_1                    1741
#define IDC_AMTEDIT_1                   1742
#define IDC_AMTSPIN_1                   1743
#define IDC_MAP_1                       1744
#define IDC_USEMAP_2                    1745
#define IDC_AMTEDIT_2                   1746
#define IDC_AMTSPIN_2                   1747
#define IDC_MAP_2                       1748
#define IDC_USEMAP_3                    1749
#define IDC_AMTEDIT_3                   1750
#define IDC_AMTSPIN_3                   1751
#define IDC_MAP_3                       1752
#define IDC_USEMAP_4                    1753
#define IDC_AMTEDIT_4                   1754
#define IDC_AMTSPIN_4                   1755
#define IDC_MAP_4                       1756
#define IDC_USEMAP_5                    1757
#define IDC_AMTEDIT_5                   1758
#define IDC_AMTSPIN_5                   1759
#define IDC_MAP_5                       1760
#define IDC_USEMAP_6                    1761
#define IDC_AMTEDIT_6                   1762
#define IDC_AMTSPIN_6                   1763
#define IDC_MAP_6                       1764
#define IDC_USEMAP_7                    1765
#define IDC_AMTEDIT_7                   1766
#define IDC_AMTSPIN_7                   1767
#define IDC_MAP_7                       1768
#define IDC_USEMAP_8                    1769
#define IDC_AMTEDIT_8                   1770
#define IDC_AMTSPIN_8                   1771
#define IDC_MAP_8                       1772
#define IDC_USEMAP_9                    1773
#define IDC_AMTEDIT_9                   1774
#define IDC_AMTSPIN_9                   1775
#define IDC_MAP_9                       1776
#define IDC_USEMAP_10                   1777
#define IDC_AMTEDIT_10                  1778
#define IDC_AMTSPIN_10                  1779
#define IDC_MAP_10                      1780
#define IDC_USEMAP_11                   1781
#define IDC_AMTEDIT_11                  1782
#define IDC_AMTSPIN_11                  1783
#define IDC_MAP_11                      1784
#define IDC_LOCK_TEX01                  1785
#define IDC_PRESETS                     1786
#define IDC_USEMAP_12                   1786
#define IDC_PRESET_RECORD               1787
#define IDC_AMTEDIT_12                  1787
#define IDC_PRESET_DELETE               1788
#define IDC_USEMAP_13                   1788
#define IDC_COMPMAT_MAT1                1789
#define IDC_SLEV_EDIT                   1789
#define IDC_AMTEDIT_13                  1789
#define IDC_COMPMAT_MAT2                1790
#define IDC_SLEV_SPIN                   1790
#define IDC_USEMAP_14                   1790
#define IDC_COMPMAT_A1                  1791
#define IDC_MAPON_SLEV                  1791
#define IDC_AMTEDIT_14                  1791
#define IDC_COMPMAT_S1                  1792
#define IDC_GLX_EDIT                    1792
#define IDC_AMTSPIN_12                  1792
#define IDC_COMPMAT_M1                  1793
#define IDC_GLX_SPIN                    1793
#define IDC_AMTSPIN_13                  1793
#define IDC_COMPMAT_A2                  1794
#define IDC_MAPON_GLX                   1794
#define IDC_AMTSPIN_14                  1794
#define IDC_COMPMAT_S2                  1795
#define IDC_GLY_EDIT                    1795
#define IDC_MAP_12                      1795
#define IDC_COMPMAT_M2                  1796
#define IDC_GLY_SPIN                    1796
#define IDC_MAP_13                      1796
#define IDC_COMPMAT_MAT3                1797
#define IDC_MAPON_GLY                   1797
#define IDC_MAP_14                      1797
#define IDC_COMPMAT_A3                  1798
#define IDC_MAPON_DLEV                  1798
#define IDC_USEMAP_15                   1798
#define IDC_COMPMAT_S3                  1799
#define IDC_DLEV_SPIN                   1799
#define IDC_AMTEDIT_15                  1799
#define IDC_COMPMAT_M3                  1800
#define IDC_DLEV_EDIT                   1800
#define IDC_AMTSPIN_15                  1800
#define IDC_COMPMAT_MAT4                1801
#define IDC_NORMALIZE_CHECK             1801
#define IDC_MAP_15                      1801
#define IDC_COMPMAT_A4                  1802
#define IDC_OR_EDIT                     1802
#define IDC_USEMAP_16                   1802
#define IDC_COMPMAT_S4                  1803
#define IDC_OR_SPIN                     1803
#define IDC_AMTEDIT_16                  1803
#define IDC_COMPMAT_M4                  1804
#define IDC_MAPON_OR                    1804
#define IDC_AMTSPIN_16                  1804
#define IDC_COMPMAT_MAT5                1805
#define IDC_CH_EDIT                     1805
#define IDC_MAP_16                      1805
#define IDC_COMPMAT_A5                  1806
#define IDC_CH_SPIN                     1806
#define IDC_USEMAP_17                   1806
#define IDC_COMPMAT_S5                  1807
#define IDC_GL_EDIT                     1807
#define IDC_AMTEDIT_17                  1807
#define IDC_OR1_EDIT                    1807
#define IDC_COMPMAT_M5                  1808
#define IDC_GL_SPIN                     1808
#define IDC_AMTSPIN_17                  1808
#define IDC_OR1_SPIN                    1808
#define IDC_COMPMAT_MAT6                1809
#define IDC_MAPON_GL                    1809
#define IDC_MAP_17                      1809
#define IDC_MAPON_OR1                   1809
#define IDC_COMPMAT_A6                  1810
#define IDC_ALEV_EDIT                   1810
#define IDC_AN_EDIT                     1810
#define IDC_LLEV_EDIT                   1810
#define IDC_USEMAP_18                   1810
#define IDC_COMPMAT_S6                  1811
#define IDC_ALEV_SPIN                   1811
#define IDC_AN_SPIN                     1811
#define IDC_LLEV_SPIN                   1811
#define IDC_AMTEDIT_18                  1811
#define IDC_COMPMAT_M6                  1812
#define IDC_MAPON_ALEV                  1812
#define IDC_MAPON_AN                    1812
#define IDC_MAPON_LLEV                  1812
#define IDC_AMTSPIN_18                  1812
#define IDC_COMPMAT_MAT7                1813
#define IDC_COLOR                       1813
#define IDC_MAP_18                      1813
#define IDC_COMPMAT_A7                  1814
#define IDC_MAPON_CLR                   1814
#define IDC_USEMAP_19                   1814
#define IDC_COMPMAT_S7                  1815
#define IDC_MT_EDIT                     1815
#define IDC_AN_EDIT2                    1815
#define IDC_AMTEDIT_19                  1815
#define IDC_COMPMAT_M7                  1816
#define IDC_MT_SPIN                     1816
#define IDC_AN_SPIN2                    1816
#define IDC_AMTSPIN_19                  1816
#define IDC_COMPMAT_MAT8                1817
#define IDC_MAPON_MT                    1817
#define IDC_MAPON_AN2                   1817
#define IDC_MAP_19                      1817
#define IDC_COMPMAT_A8                  1818
#define IDC_DIM_DIFF_CHECK              1818
#define IDC_COLOR2                      1818
#define IDC_USEMAP_20                   1818
#define IDC_COMPMAT_S8                  1819
#define IDC_LAYER_TABS                  1819
#define IDC_MAPON_CLR2                  1819
#define IDC_AMTEDIT_20                  1819
#define IDC_COMPMAT_M8                  1820
#define IDC_LAYER0_STATICTEXT           1820
#define IDC_AMTSPIN_20                  1820
#define IDC_COMPMAT_MAT9                1821
#define IDC_GL2_EDIT                    1821
#define IDC_MAP_20                      1821
#define IDC_COMPMAT_A9                  1822
#define IDC_GL2_SPIN                    1822
#define IDC_USEMAP_21                   1822
#define IDC_COMPMAT_S9                  1823
#define IDC_MAPON_GL2                   1823
#define IDC_AMTEDIT_21                  1823
#define IDC_COMPMAT_M9                  1824
#define IDC_AN2_EDIT                    1824
#define IDC_AMTSPIN_21                  1824
#define IDC_COMPMAT_MAT10               1825
#define IDC_AN2_SPIN                    1825
#define IDC_MAP_21                      1825
#define IDC_COMPMAT_A10                 1826
#define IDC_USEMAP_22                   1826
#define IDC_COMPMAT_S10                 1827
#define IDC_LLEV2_EDIT                  1827
#define IDC_AMTEDIT_22                  1827
#define IDC_COMPMAT_M10                 1828
#define IDC_LLEV2_SPIN                  1828
#define IDC_AMTSPIN_22                  1828
#define IDC_COMPMAP_AMOUNT1             1829
#define IDC_MAPON_LLEV2                 1829
#define IDC_MAP_22                      1829
#define IDC_COMPMAP_AMOUNTSPIN1         1830
#define IDC_LAYER0_STATICTEXT2          1830
#define IDC_USEMAP_23                   1830
#define IDC_COMPMAP_AMOUNT2             1831
#define IDC_MAPON_AN1                   1831
#define IDC_AMTEDIT_23                  1831
#define IDC_COMPMAP_AMOUNTSPIN2         1832
#define IDC_MAPON_LLEV1                 1832
#define IDC_AMTSPIN_23                  1832
#define IDC_COMPMAP_AMOUNT3             1833
#define IDC_MAPON_GL1                   1833
#define IDC_MAP_23                      1833
#define IDC_COMPMAP_AMOUNTSPIN3         1834
#define IDC_MAPON_CLR1                  1834
#define IDC_COMPMAP_AMOUNT4             1835
#define IDC_GL1_EDIT                    1835
#define IDC_COMPMAP_AMOUNTSPIN4         1836
#define IDC_GL1_SPIN                    1836
#define IDC_COMPMAP_AMOUNT5             1837
#define IDC_AN1_EDIT                    1837
#define IDC_COMPMAP_AMOUNTSPIN5         1838
#define IDC_AN1_SPIN                    1838
#define IDC_COMPMAP_AMOUNT6             1839
#define IDC_LLEV1_EDIT                  1839
#define IDC_COMPMAP_AMOUNTSPIN6         1840
#define IDC_LLEV1_SPIN                  1840
#define IDC_COMPMAP_AMOUNT7             1841
#define IDC_COLOR1                      1841
#define IDC_COMPMAP_AMOUNTSPIN7         1842
#define IDC_HIGHLIGHT1                  1842
#define IDC_COMPMAP_AMOUNT8             1843
#define IDC_SPEC_LEV2_EDIT              1843
#define IDC_COMPMAP_AMOUNTSPIN8         1844
#define IDC_SPEC_LEV2_SPIN              1844
#define IDC_COMPMAP_AMOUNT9             1845
#define IDC_MAPON_SPECLEV2              1845
#define IDC_COMPMAP_AMOUNTSPIN9         1846
#define IDC_SPEC_LEV1_EDIT              1846
#define IDC_COMPMAP_AMOUNT10            1847
#define IDC_SPEC_LEV1_SPIN              1847
#define IDC_COMPMAP_AMOUNTSPIN10        1848
#define IDC_MAPON_SPECLEV1              1848
#define IDC_MAPON_DIFFLEV               1849
#define IDC_MAPON_SPECCLR1              1850
#define IDC_MAPON_SPECCLR2              1851
#define IDC_AMB_CLR                     1852
#define IDC_DIFF_CLR                    1853
#define IDC_SPEC_CLR1                   1854
#define IDC_SPEC_CLR2                   1855
#define IDC_SI_CLR                      1856
#define IDC_MAPON_OR2                   1857
#define IDC_OR2_EDIT                    1858
#define IDC_OR2_SPIN                    1859
#define IDC_MAPON_DIFFROUGH             1860
#define IDC_ADAPT_STATIC                1861
#define IDC_ADVANCED_BUTTON             1862
#define IDC_SPEC_TEXT                   1863
#define IDC_SOFTEN_TEXT                 1864
#define IDC_OPAC_TEXT1                  1865
#define IDC_OPAC_TEXT2                  1866
#define IDC_REFR_TEXT1                  1867
#define IDC_OPAC_TEXT3                  1868
#define IDC_REFL_TEXT1                  1869
#define IDC_REFL_TEXT2                  1870
#define IDC_REFL_BOX                    1871
#define IDC_OPAC_BOX                    1872
#define IDC_FILTER_OVERLAY              1873
#define IDC_COMMENT_BOX                 1874
#define IDC_QUALITY_TEXT                1875
#define IDC_COMMENT_TEXT                1876
#define IDS_DS_PHASE                    10041
#define IDS_DS_AMBIENT                  10045
#define IDS_DS_DIFFUSE                  10046
#define IDS_DS_SPECULAR                 10047
#define IDS_DS_WIREFRAME                10049
#define IDS_DS_SHININESS                10051
#define IDS_DS_SHIN_STR                 10052
#define IDS_DS_OPACITY                  10053
#define IDS_DS_SELFI                    10054
#define IDS_DS_XPFALL                   10055
#define IDS_MAPENABLE                   10056
#define IDS_JW_SHADERTYPE               10057
#define IDS_DS_BASIC                    10058
#define IDS_DS_EXTRA                    10059
#define IDS_DS_TEXMAP                   10060
#define IDS_COLORS                      10061
#define IDS_MAPS                        10062
#define IDS_GRAD_TYPE                   10063
#define IDS_JW_MAPENABLES               10064
#define IDS_DS_THRESH                   10065
#define IDS_DS_BLEND                    10066
#define IDS_DS_BU                       10067
#define IDS_DS_RL                       10068
#define IDS_DS_RR                       10069
#define IDS_DS_TEXMAPS                  10070
#define IDS_DS_FILTER                   10071
#define IDS_DS_CHECKPARMS               10072
#define IDS_DS_COORDINATES              10073
#define IDS_NOISE_TYPE                  10074
#define IDS_DS_UOFFS                    10075
#define IDS_DS_VOFFS                    10076
#define IDS_DS_USCL                     10077
#define IDS_DS_VSCL                     10078
#define IDS_DS_ANGLE                    10079
#define IDS_DS_COLOR1                   10080
#define IDS_DS_COLOR2                   10081
#define IDS_DS_BLUR                     10082
#define IDS_JW_MAP1                     10083
#define IDS_DS_FLAT                     10084
#define IDS_DS_GOURAUD                  10085
#define IDS_DS_PHONG                    10086
#define IDS_DS_METAL                    10087
#define IDS_DS_OFFS                     10088
#define IDS_DS_SCL                      10089
#define IDS_DS_MARBPARMS                10090
#define IDS_DS_MARBWIDTH                10091
#define IDS_DS_MARBSIZE                 10092
#define IDS_DS_COORDNOISE               10093
#define IDS_DS_TEXOUT                   10094
#define IDS_DS_MIXAMT                   10095
#define IDS_DS_NOISEPARMS               10096
#define IDS_DS_MIXPARMS                 10097
#define IDS_DS_NOISESIZE                10098
#define IDS_DS_OUTAMT                   10099
#define IDS_DS_OUTPUT                   10100
#define IDS_DS_NOISEAMT                 10101
#define IDS_DS_NOISELEV                 10102
#define IDS_DS_OUTOFF                   10103
#define IDS_DS_MAP                      10104
#define IDS_DS_MASK                     10105
#define IDS_MASKPARMS                   10106
#define IDS_DS_COLOR3                   10107
#define IDS_DS_TINTPARMS                10108
#define IDS_JW_MAP2                     10108
#define IDS_DS_EXPLICIT                 10109
#define IDS_DS_SPHERE_ENV               10110
#define IDS_DS_CYL_ENV                  10111
#define IDS_DS_SHRINK_ENV               10112
#define IDS_DS_SCREEN                   10113
#define IDS_DS_WIRESZ                   10114
#define IDS_DS_IOR                      10115
#define IDS_DS_MAPSIZE                  10116
#define IDS_DS_ACUBIC_PARAMS            10117
#define IDS_DS_BLUROFFS                 10118
#define IDS_DS_MIRROR_PARAMS            10119
#define IDS_DS_LEVELS                   10120
#define IDS_DS_CONSTANT                 10121
#define IDS_DS_PARAMETERS               10122
#define IDS_JW_MAP3                     10123
#define IDS_JW_MAP1ENABLE               10124
#define IDS_JW_MAP2ENABLE               10125
#define IDS_JW_MAP3ENABLE               10126
#define IDS_JW_MAPS                     10127
#define IDS_JW_MAPAMOUNTS               10128
#define IDS_DS_MATTE_SHADOW_PAR         10129
#define IDS_DS_SHADOW_BRITE             10130
#define IDS_DS_BITMAP_PARAMS            10131
#define IDS_DS_TIME_PARAMS              10132
#define IDS_JW_ENABLE                   10133
#define IDS_JW_AMOUNT                   10134
#define IDS_DS_EFFECTS_CHANNEL          10135
#define IDS_DS_OUTPUT_CDESC             10136
#define IDS_DS_MASK_CDESC               10137
#define IDS_DS_XLABEL                   10163
#define IDS_DS_YLABEL                   10164
#define IDS_DS_ZLABEL                   10165
#define IDS_DS_ULABEL                   10166
#define IDS_DS_VLABEL                   10167
#define IDS_DS_WLABEL                   10168
#define IDS_DS_BITMAP_TEXTURE_ERR       10172
#define IDS_DS_PARAMCHG                 10183
#define IDS_RB_AMOUNT                   30031
#define IDS_RB_CURVITURE                30032
#define IDS_RB_AMPLITUDE                30033
#define IDS_RB_WAVELEN                  30034
#define IDS_RB_PHASE                    30035
#define IDS_RB_DECAY                    30036
#define IDS_RB_LOWTHRESH                30313
#define IDS_RB_HIGHTHRESH               30314
#define IDS_RB_NOISE                    30411
#define IDS_RB_MULTISUBOBJECT           30412
#define IDS_RB_MATERIAL2                30413
#define IDS_RB_BLENDMAT                 30414
#define IDS_RB_BACK                     30415
#define IDS_RB_FACING                   30416
#define IDS_RB_MASK                     30417
#define IDS_RB_MATERIALONE              30418
#define IDS_RB_MATERIALTWO              30419
#define IDS_RB_MIXAMOUNT                30420
#define IDS_RB_UPPER                    30421
#define IDS_RB_LOWER                    30422
#define IDS_RB_GRADIENT                 30423
#define IDS_RB_GRADIENTPARAMS           30424
#define IDS_RB_GRADTEMP                 30425
#define IDS_RB_COLOR1                   30426
#define IDS_RB_COLOR2                   30427
#define IDS_RB_COLOR3                   30428
#define IDS_RB_SIZE                     30429
#define IDS_RB_LEVELS                   30430
#define IDS_RB_CENTER2                  30431
#define IDS_RB_HIGHTHRESHOLD            30432
#define IDS_RB_LOWTHRESHOLD             30433
#define IDS_RB_THRESHOLDSMOOTHING       30434
#define IDS_RB_DOUBLESIDED              30435
#define IDS_RB_FACINGMAT                30436
#define IDS_RB_BACKMATERIAL             30437
#define IDS_RB_TRANSLUECENCY            30438
#define IDS_RB_COMPOSITE                30439
#define IDS_RB_COMPOSITEPARAMS          30440
#define IDS_RB_MAP2                     30441
#define IDS_DS_AMOUNT                   30442
#define IDS_DS_LOCKAD                   30443
#define IDS_DS_LOCKCOL                  30444
#define IDS_DS_TOPBOTTOM                30445
#define IDS_DS_TOP                      30446
#define IDS_DS_BOTTOM                   30447
#define IDS_DS_MARBLE                   30448
#define IDS_DS_MIX                      30449
#define IDS_DS_MATTE_SHADOW             30450
#define IDS_DS_PLACEMENT                30451
#define IDS_DS_BITMAP                   30452
#define IDS_DS_SELECT_BMFILE            30453
#define IDS_DS_ACUBIC_NAME              30454
#define IDS_DS_UP                       30455
#define IDS_DS_DOWN                     30456
#define IDS_DS_LEFT                     30457
#define IDS_DS_RIGHT                    30458
#define IDS_DS_FLATMIRROR               30459
#define IDS_DS_LOCK_DS                  30460
#define IDS_DS_XYZNAME                  30461
#define IDS_DS_RGBTINT                  30462
#define IDS_DS_CHECKER                  30463
#define IDS_DS_NONE                     30464
#define IDS_DS_TRANS                    30465
#define IDS_RB_NONE                     30466
#define IDS_DS_FILE_NOT_FOUND           30467
#define IDS_DS_STANDARD                 30468
#define IDS_DS_CHECK_BLUR               30469
#define IDS_KE_SHADERS_DESC             30470
#define IDS_DS_CLASSTEXMAPS             30471
#define IDS_DS_FRONT                    30472
#define IDS_DS_BACK                     30473
#define IDS_DS_NOT_SQUARE               30474
#define IDS_DS_WRONG_SIZE               30475
#define IDS_DS_REFL_ERROR               30476
#define IDS_DS_SELECT_UPFILE            30477
#define IDS_DS_CLIPU                    30478
#define IDS_DS_CLIPV                    30479
#define IDS_DS_CLIPW                    30480
#define IDS_DS_CLIPH                    30481
#define IDS_DS_CROP_TITLE               30482
#define IDS_DS_SHAD_COLOR               30483
#define IDS_DS_DYNAMICS                 30484
#define IDS_DS_BOUNCE                   30485
#define IDS_DS_STATFRIC                 30486
#define IDS_DS_SLIDFRIC                 30487
#define IDS_DS_RGBMULT                  30488
#define IDS_DS_RGBMULTPARAMS            30489
#define IDS_DS_MASKPARAMS               30490
#define IDS_DS_TINTPARAMS               30491
#define IDS_DS_OUTPUTPARAMS             30492
#define IDS_DS_FALLNEAR                 30493
#define IDS_DS_FALLFAR                  30494
#define IDS_DS_FALLOFF                  30495
#define IDS_DS_FALLOFFPARAMS            30496
#define IDS_DS_PERVAL                   30497
#define IDS_DS_PARVAL                   30498
#define IDS_DS_FVAL                     30499
#define IDS_DS_BVAL                     30500
#define IDS_DS_NSAMT                    30501
#define IDS_DS_NSSIZ                    30502
#define IDS_DS_NSLEV                    30503
#define IDS_DS_NSPHS                    30504
#define IDS_DS_VCOL                     30505
#define IDS_DS_VCOLPARAMS               30506
#define IDS_RB_PARTBLUR                 30507
#define IDS_RB_PBLURPARAMS              30508
#define IDS_RB_SHARP                    30509
#define IDS_DS_FLATPLATE                30510
#define IDS_DS_PLATE_PARAMS             30511
#define IDS_DS_THICKFACT                30512
#define IDS_DS_REFRAMT                  30513
#define IDS_DS_DIMLEV                   30514
#define IDS_DS_DIMMULT                  30515
#define IDS_DS_JITTERAMT                30516
#define IDS_DS_BLINN                    30517
#define IDS_DS_RAYMAP_NAME              30518
#define IDS_DS_NEARRANGE                30518
#define IDS_DS_RAYMAP_PARAMS            30519
#define IDS_DS_FARRANGE                 30519
#define IDS_DS_DISTAMT                  30520
#define IDS_RB_PARTICLEAGE              30521
#define IDS_RB_PARTAGEPARAMS            30522
#define IDS_RB_AGE1                     30523
#define IDS_RB_AGE2                     30524
#define IDS_RB_AGE3                     30525
#define IDS_DS_RED                      30526
#define IDS_DS_GREEN                    30527
#define IDS_DS_BLUE                     30528
#define IDS_DS_SOFTEN                   30529
#define IDS_DS_DP                       30530
#define IDS_DS_REFLAMT                  30531
#define IDS_DS_SAMPEFPARAMS             30532
#define IDS_KE_SELFILLUM_CLR            30532
#define IDS_KE_BRITECON_PARAMS          30533
#define IDS_KE_NOSUCH_CLR               30533
#define IDS_KE_BRIGHTNESS               30534
#define IDS_KE_STANDARD2                30534
#define IDS_KE_CONTRAST                 30535
#define IDS_KE_SHADER                   30535
#define IDS_KE_BRITECON                 30536
#define IDS_KE_SAMPLING                 30536
#define IDS_KE_PHONG                    30537
#define IDS_KE_BLINN                    30538
#define IDS_KE_METAL                    30539
#define IDS_KE_CONSTANT                 30540
#define IDS_KE_STDSHADER                30541
#define IDS_KE_OREN_NAYER               30542
#define IDS_KE_OREN_NAYAR               30542
#define IDS_KE_OREN_NAYER_BLINN         30543
#define IDS_KE_OREN_NAYAR_BLINN         30543
#define IDS_KE_DIFF_LEVEL               30544
#define IDS_KE_DIFF_ROUGH               30545
#define IDS_KE_DIFF_RHO                 30546
#define IDS_KE_NONE                     30547
#define IDS_DS_ON_BASIC                 30548
#define IDS_KE_SPEC_LEVEL               30549
#define IDS_KE_GLOSSINESS_Y             30550
#define IDS_KE_GLOSSINESS_X             30551
#define IDS_KE_WARD_BASIC               30552
#define IDS_KE_WARD                     30553
#define IDS_KE_STRAUSS                  30554
#define IDS_KE_STRAUSS_BASIC            30555
#define IDS_KE_METALNESS                30556
#define IDS_KE_GLOSSINESS               30557
#define IDS_KE_AMBIENT_LEV              30558
#define IDS_KE_COLOR                    30559
#define IDS_KE_ANISOTROPY               30560
#define IDS_KE_ORIENTATION              30561
#define IDS_KE_SELFILLUM                30562
#define IDS_KE_ANISO                    30563
#define IDS_KE_ANSIO_BASIC              30564
#define IDS_KE_CONST_PARMS              30565
#define IDS_KE_PHONG_PARMS              30566
#define IDS_KE_BLINN_PARMS              30567
#define IDS_KE_METAL_PARMS              30568
#define IDS_KE_OREN_PARMS               30569
#define IDS_KE_WARD_PARMS               30570
#define IDS_KE_STRAUSS_PARMS            30571
#define IDS_KE_ANISO_PARMS              30572
#define IDS_KE_CLR1                     30573
#define IDS_KE_CLR2                     30574
#define IDS_KE_GLOSS1                   30575
#define IDS_KE_GLOSS2                   30576
#define IDS_KE_ANISO1                   30577
#define IDS_KE_ANISO2                   30578
#define IDS_KE_LEVEL1                   30579
#define IDS_KE_LEVEL2                   30580
#define IDS_KE_MAPCHANNEL               30581
#define IDS_KE_SCHLICK                  30582
#define IDS_KE_SCHLICK_PARMS            30583
#define IDS_KE_SCHLICK_BASIC            30584
#define IDS_JW_TWOSIDED                 30585
#define IDS_JW_FACEMAP                  30586
#define IDS_JW_OPACITYTYPE              30587
#define IDS_JW_FILTERMAP                30588
#define IDS_JW_FALLOFFTYPE              30589
#define IDS_JW_WIREUNITS                30590
#define IDS_JW_APPLYREFDIM              30591
#define IDS_JW_PIXELSAMPLER             30592
#define IDS_JW_SAMPLERQUAL              30593
#define IDS_JW_SAMPLERENABLE            30594
#define IDS_JW_SHADERPARAMS             30595
#define IDS_PW_ALPHAFROM                30596
#define IDS_DS_VCOL_CDESC               30597
#define IDS_DS_RGBTINT_CDESC            30598
#define IDS_DS_STANDARD_CDESC           30599
#define IDS_KE_STANDARD2_CDESC          30600
#define IDS_DS_RGBMULT_CDESC            30601
#define IDS_DS_FLATPLATE_CDESC          30602
#define IDS_RB_PARTBLUR_CDESC           30603
#define IDS_RB_PARTICLEAGE_CDESC        30604
#define IDS_RB_NOISE_CDESC              30605
#define IDS_RB_MULTISUBOBJECT_CDESC     30606
#define IDS_RB_BLENDMAT_CDESC           30607
#define IDS_DS_MIX_CDESC                30608
#define IDS_DS_FLATMIRROR_CDESC         30609
#define IDS_DS_MATTE_SHADOW_CDESC       30610
#define IDS_DS_MARBLE_CDESC             30611
#define IDS_RB_GRADIENT_CDESC           30612
#define IDS_DS_FALLOFF_CDESC            30613
#define IDS_RB_DOUBLESIDED_CDESC        30614
#define IDS_RB_COMPOSITE_CDESC          30615
#define IDS_DS_TOPBOTTOM_CDESC          30616
#define IDS_DS_CHECKER_CDESC            30617
#define IDS_DS_BITMAP_CDESC             30618
#define IDS_DS_ACUBIC_NAME_CDESC        30619
#define IDS_JW_ADTEXLOCK                30620
#define IDS_JW_ADLOCK                   30625
#define IDS_JW_DSLOCK                   30626
#define IDS_JW_SELFILLUMCOLORON         30627
#define IDS_KE_SPEC_CLR1                30628
#define IDS_KE_SPEC_CLR2                30629
#define IDS_KE_SPEC_LEVEL1              30630
#define IDS_KE_SPEC_LEVEL2              30631
#define IDS_KE_MULTI_LAYER_BASIC        30632
#define IDS_KE_MULTI_LAYER              30633
#define IDS_KE_MULTI_LAYER_PARMS        30634
#define IDS_PW_DIRECTION                30635
#define IDS_PW_NODE                     30636
#define IDS_PW_INVERT                   30637
#define IDS_PW_OALPHA                   30638
#define IDS_PW_APPLYATMOS               30639
#define IDS_PW_ATMOSDEPTH               30640
#define IDS_PW_RECEIVESHADOWS           30641
#define IDS_PW_AFFECTALPHA              30642
#define IDS_PW_SPACE                    30643
#define IDS_PW_USECURVE                 30644
#define IDS_PW_MASKENABLE               30645
#define IDS_PW_INTERACTIVE              30646
#define IDS_PW_USEJITTER                30647
#define IDS_PW_APPLY                    30648
#define IDS_PW_CROPPLACE                30649
#define IDS_PW_FILTERING                30650
#define IDS_PW_MONOOUTPUT               30651
#define IDS_PW_RGBOUTPUT                30652
#define IDS_PW_ALPHASOURCE              30653
#define IDS_PW_PREMULT                  30654
#define IDS_PW_STARTTIME                30655
#define IDS_PW_PLAYBACK                 30656
#define IDS_PW_ENDCONDITION             30657
#define IDS_PW_USENVIROMENT             30658
#define IDS_PW_NTHFRAME                 30659
#define IDS_PW_FRAME                    30660
#define IDS_PW_APPLYTOFACEID            30661
#define IDS_PW_FACEID                   30662
#define IDS_PW_DISTORTIONTYPE           30663
#define IDS_PW_NOISETYPE                30664
#define IDS_PW_COORDINATES              30665
#define IDS_PW_POSITION                 30666
#define IDS_PW_MIXAMOUNT                30667
#define IDS_PW_BLURAMOUNT               30668
#define IDS_PW_DISTORTIONAMOUNT         30669
#define IDS_PW_LEVEL                    30670
#define IDS_PW_APPLYBLUR                30671
#define IDS_KE_FACETED                  30672
#define IDS_KE_ORIENTATION1             30673
#define IDS_KE_ORIENTATION2             30674
#define IDS_KE_SAMPLERADAPTTHRESH       30675
#define IDS_KE_SAMPLERADAPTON           30676
#define IDS_KE_SAMPLERADVANCED          30677
#define IDS_PW_SOURCE                   30678
#define IDS_PW_USEATMOSPHERIC           30679
#define IDS_PW_FRAMETYPE                30680
#define IDS_DS_NTHFRAME                 30681
#define IDS_PW_OUTPUTNAME               30682
#define IDS_KE_SUBSAMPLE_TEX_ON         30683
#define IDS_KE_BASIC_BLINN              30684
#define IDS_KE_BASIC_PHONG              30685
#define IDS_KE_BASIC_METAL              30686
#define IDS_PW_MAT                      30687
#define IDS_KE_LOCKDS                   30687
#define IDS_PW_BASE                     30688
#define IDS_KE_REFR_FILTER              30688
#define IDS_DS_USEREFL                  30689
#define IDS_DS_BLEND_PARAMS             30690
#define IDS_DS_DBLSIDED_PARAMS          30691
#define IDS_DS_MULTI_PARAMS             30692
#define IDS_DS_TB_PARAMS                30693
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        153
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1877
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shadersPch.h ===
/**********************************************************************
 *<
	FILE: shadersPch.h

	DESCRIPTION: Header for shaders DLL

	CREATED BY: Kells Elmquist

	HISTORY:

 *>	Copyright (c) 1999, All Rights Reserved.
 **********************************************************************/

#ifndef SAMPLERS_HDR__H
#define SAMPLERS_HDR__H

#include "max.h"
#include "texutil.h"
#include "imtl.h"

TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shadersMain.h ===
/**********************************************************************
 *<
	FILE: shadersMain.h

	DESCRIPTION:

	CREATED BY: Kells Elmquist

	HISTORY:

 *>	Copyright (c) 1999, All Rights Reserved.
 **********************************************************************/

#ifndef __SHADERS_MAIN__H
#define __SHADERS_MAIN__H

// moved to mtls dll to guarantee a default shader
//extern ClassDesc* GetConstantShaderCD();
//extern ClassDesc* GetPhongShaderCD();
//extern ClassDesc* GetBlinnShaderCD();
//extern ClassDesc* GetOldBlinnShaderCD();
//extern ClassDesc* GetMetalShaderCD();

extern ClassDesc* GetOrenNayarShaderCD();
extern ClassDesc* GetOrenNayarBlinnShaderCD();
extern ClassDesc* GetWardShaderCD();
extern ClassDesc* GetAnisoShaderCD();
extern ClassDesc* GetLaFortuneShaderCD();
extern ClassDesc* GetLayeredBlinnShaderCD();
extern ClassDesc* GetPhysicalBlinnShaderCD();
extern ClassDesc* GetCookShaderCD();
extern ClassDesc* GetStraussShaderCD();
extern ClassDesc* GetCompositeMatDesc();
extern ClassDesc * GetSchlickShaderCD();
extern ClassDesc * GetMultiLayerShaderCD();

TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shaderStrauss.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//		Strauss Shader plug-in, implementation
//
//		Created: 10/26/98 Kells Elmquist
//
#include "shadersPch.h"
#include "shadersRc.h"
#include "gport.h"
#include "shaders.h"
#include "shaderUtil.h"
#include "macrorec.h"



// Class Ids
#define STRAUSS_SHADER_CLASS_ID		0x2857f450

static Class_ID StraussShaderClassID( STRAUSS_SHADER_CLASS_ID, 0);

// paramblock2 block and parameter IDs.
enum { strauss_params, };
// shdr_params param IDs
enum 
{ 
	st_diffuse, st_glossiness, st_metalness, 
};

/////////////////////////////////////////////////////////////////////
//
//	Basic Panel UI 
//
#define NMBUTS 4

// tex channel number to button IDC
static int texMButtonsIDC[] = {
	IDC_MAPON_CLR, IDC_MAPON_GL, IDC_MAPON_MT, IDC_MAPON_TR, 
};
		
// This array gives the texture map number for given MButton number								
static int texmapFromMBut[] = { 0, 1, 2, 3 };

// Texture Maps
#define STRAUSS_NTEXMAPS	5

// channels ids used by shader
#define S_DI	0
#define S_GL	1
#define S_MT	2
#define S_TR	3

// channel names
static int texNameIDS[STD2_NMAX_TEXMAPS] = {
	IDS_KE_COLOR,	IDS_KE_GLOSSINESS, IDS_KE_METALNESS, IDS_DS_TRANS, 
	IDS_KE_REFR_FILTER, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
};	

// internal non-local parsable channel map names
static TCHAR* texInternalNames[STD2_NMAX_TEXMAPS] = {
	_T("diffuseMap"),_T("glossinessMap"), _T("metalnessMap"), _T("opacityMap"), 	
	_T("filterMap"), _T(""), _T(""), _T(""), 
	_T(""), _T(""), _T(""), _T(""), 
	_T(""), _T(""), _T(""), _T(""),
	_T(""), _T(""), _T(""), _T(""), 
	_T(""), _T(""), _T(""), _T(""),
};	

// sized for nmax textures
// bump, reflection & refraction maps are ignored....done after shading
static int chanType[STD2_NMAX_TEXMAPS] = {
	CLR_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, 
	CLR_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, 
};	

// what channel corresponds to the stdMat ID's
static int stdIDToChannel[N_ID_CHANNELS] = { -1, 0, -1, 1, -1, -1, 3, 4, -1, -1, -1, -1 };


//////////////////////////////////////////////////////////////////////////////////////////
//
//		Strauss Parameter Block
//
#define CURRENT_STRAUSS_SHADER_VERSION	2
#define STRAUSS_SHADER_NPARAMS			4
#define STRAUSS_SHADER_PB_VERSION		1

#define STRAUSS_NCOLBOX 1
static int colID[STRAUSS_NCOLBOX] = { IDC_STD_COLOR2  };

//Current Param Block Descriptor
static ParamBlockDescID StraussShaderPB[ STRAUSS_SHADER_NPARAMS ] = {
	{ TYPE_RGBA,  NULL, TRUE,st_diffuse },   // diffuse
	{ TYPE_FLOAT, NULL, TRUE,-1 },  // ambient level
	{ TYPE_FLOAT, NULL, TRUE,st_glossiness },   // glossiness 
	{ TYPE_FLOAT, NULL, TRUE,st_metalness },  // metalness
}; 

#define STRAUSS_NUMOLDVER 1

static ParamVersionDesc oldVersions[STRAUSS_NUMOLDVER] = {
	ParamVersionDesc(StraussShaderPB, STRAUSS_SHADER_NPARAMS, 0),
};


//----------------------------------------------------------------------------------------
// Straus Shader, from CGA Nov 1990, "Realistic lighting model for computer animators"
//----------------------------------------------------------------------------------------
// note: We replace std opacity & std reflection, these are automatic in the strauss model
#define STRAUSS_PARAMS (STD_PARAM_DIFFUSE_CLR+STD_PARAM_GLOSSINESS\
						+STD_PARAM_SPECULAR_LEV+STD_EXTRA_DLG+STD_EXTRA_REFRACTION)

class StraussShaderDlg;

class StraussShader : public Shader {
friend class StraussShaderCB;
friend class StraussShaderDlg;
protected:
	IParamBlock2		*pblock;   // ref 0
	Interval		ivalid;

	StraussShaderDlg*	paramDlg;

	Color			diffuse;
	float			glossiness;
	float			metalness;

	public:
	StraussShader();
	void DeleteThis(){ delete this; }		
    ULONG SupportStdParams(){ return STRAUSS_PARAMS; }

	// copy std params, for switching shaders
    void CopyStdParams( Shader* pFrom );

	// texture maps
	long nTexChannelsSupported(){ return STRAUSS_NTEXMAPS; }
	TSTR GetTexChannelName( long nChan ){ return GetString( texNameIDS[ nChan ] ); }
	TSTR GetTexChannelInternalName( long nChan ) { return texInternalNames[ nChan ]; }
	long ChannelType( long nChan ) { return chanType[nChan]; }
	long StdIDToChannel( long stdID ){ return stdIDToChannel[stdID]; }

	BOOL KeyAtTime(int id,TimeValue t) { return pblock->KeyFrameAtTime(id,t); }
	ULONG GetRequirements( int subMtlNum ){ return MTLREQ_PHONG; }

	ShaderParamDlg* CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen );
	ShaderParamDlg* GetParamDlg(){ return (ShaderParamDlg*)paramDlg; }
	void SetParamDlg( ShaderParamDlg* newDlg ){ paramDlg = (StraussShaderDlg*)newDlg; }

	Class_ID ClassID() { return StraussShaderClassID; }
	SClass_ID SuperClassID() { return SHADER_CLASS_ID; }
	TSTR GetName() { return GetString( IDS_KE_STRAUSS ); }
	void GetClassName(TSTR& s) { s = GetName(); }  

	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i){ return (i==0)? pblock : NULL; }
	TSTR SubAnimName(int i){ return TSTR(GetString( IDS_KE_STRAUSS_PARMS )); };
	int SubNumToRefNum(int subNum) { return subNum;	}

	// add direct ParamBlock2 access
	int	NumParamBlocks() { return 1; }
	IParamBlock2* GetParamBlock(int i) { return pblock; }
	IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } 

 	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i){ return (i==0)? pblock : NULL; }
	void SetReference(int i, RefTargetHandle rtarg) 
		{ if (i==0) pblock = (IParamBlock2*)rtarg; else assert(0); }
	void NotifyChanged(){ NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE); }

	void Update(TimeValue t, Interval& valid);
	void Reset();
	RefTargetHandle Clone( RemapDir &remap=NoRemap() );
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	                            PartID& partID, RefMessage message );
	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	void GetIllumParams( ShadeContext &sc, IllumParams& ip );

	// Strauss Shader specific section
	void  Illum(ShadeContext &sc, IllumParams &ip);
	float EvalHiliteCurve(float x);

	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol);
	void CombineComponents( ShadeContext &sc, IllumParams& ip );

	void SetGlossiness(float v, TimeValue t){ glossiness= v; pblock->SetValue( st_glossiness, t, v); }
	float GetGlossiness(int mtlNum=0, BOOL backFace=FALSE){ return glossiness; };	
	float GetGlossiness( TimeValue t){return pblock->GetFloat(st_glossiness,t);  }		

	void SetMetalness(float v, TimeValue t){ metalness = v; pblock->SetValue( st_metalness, t, v); }
	float GetMetalness(int mtlNum=0, BOOL backFace=FALSE){ return metalness; };	
	float GetMetalness( TimeValue t){return pblock->GetFloat(st_metalness,t);  }		

	// Std Params
	void SetDiffuseClr(Color c, TimeValue t)		
		{ diffuse = c; pblock->SetValue( st_diffuse, t, c); }

    Color GetDiffuseClr(int mtlNum=0, BOOL backFace=FALSE){ return diffuse;}		
	Color GetDiffuseClr(TimeValue t){ return pblock->GetColor(st_diffuse,t); }		

	// std params not supported
	void SetLockDS(BOOL lock){ }
	BOOL GetLockDS(){ return FALSE; }
	void SetLockAD(BOOL lock){ }
	BOOL GetLockAD(){ return FALSE; }
	void SetLockADTex(BOOL lock){ }
	BOOL GetLockADTex(){ return FALSE; }
	void SetAmbientClr(Color c, TimeValue t){}
	Color GetAmbientClr(int mtlNum=0, BOOL backFace=FALSE){ return diffuse * 0.5f;}		
	Color GetAmbientClr(TimeValue t){ return diffuse * 0.5f; }		
		
	void SetSpecularClr(Color c, TimeValue t){}
	void SetSpecularLevel(float v, TimeValue t){}		
	Color GetSpecularClr(int mtlNum=0, BOOL backFace=FALSE){ return Color(0.9f, 0.9f,0.9f); };
	float GetSpecularLevel(TimeValue t);
	float GetSpecularLevel(int mtlNum, BOOL backFace){ return GetSpecularLevel(0); };
	Color GetSpecularClr(TimeValue t){ return Color(0.9f,0.9f,0.9f);}
	void SetSelfIllum(float v, TimeValue t)	{}
	float GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE){ return 0.0f; };
	void SetSelfIllumClrOn( BOOL on ){};
	BOOL IsSelfIllumClrOn(){ return TRUE; };
	BOOL IsSelfIllumClrOn(int mtlNum, BOOL backFace){ return TRUE; }
	void SetSelfIllumClr(Color c, TimeValue t){}
	Color GetSelfIllumClr(int mtlNum=0, BOOL backFace=FALSE){ return Color(0,0,0); }
	void SetSoftenLevel(float v, TimeValue t) {}
	float GetSoftenLevel(int mtlNum=0, BOOL backFace=FALSE){ return DEFAULT_SOFTEN; }
	float GetSoftenLevel(TimeValue t){ return  DEFAULT_SOFTEN; }
	float GetSelfIllum(TimeValue t){ return 0.0f;}		
	Color GetSelfIllumClr(TimeValue t){ return Color(0,0,0);}		

};

///////////// Class Descriptor ////////////////////////
class StraussShaderClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new StraussShader(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_STRAUSS); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return StraussShaderClassID; }
	const TCHAR* 	Category() { return _T("");  }
	const TCHAR*	InternalName() { return _T("Strauss"); } // returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			 // returns owning module handle
};

StraussShaderClassDesc StraussCD;
ClassDesc * GetStraussShaderCD(){ return &StraussCD; }

// shader parameters
static ParamBlockDesc2 strauss_param_blk ( strauss_params, _T("shaderParameters"),  0, &StraussCD, P_AUTO_CONSTRUCT, 0, 
	// params
	st_diffuse, _T("diffuse"), TYPE_RGBA, P_ANIMATABLE, IDS_DS_DIFFUSE, 
		p_default, Color(0.5f, 0.5f, 0.5f), 
		end,
	st_glossiness, _T("glossiness"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_GLOSSINESS,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	st_metalness, _T("metalness"), TYPE_PCNT_FRAC, P_ANIMATABLE, IDS_KE_METALNESS,
		p_default,		0.0,
		p_range,		0.0, 100.0,
		end,
	end
);


StraussShader::StraussShader() 
{ 
	pblock = NULL; 
	StraussCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	paramDlg = NULL; 
	diffuse = Color(0.0f,0.0f,0.0f);
	glossiness = metalness = 0.0f;
	ivalid.SetEmpty(); 
}

void StraussShader::CopyStdParams( Shader* pFrom )
{
	macroRecorder->Disable(); 
	// don't want to see this parameter copying in macrorecorder

		SetAmbientClr( pFrom->GetAmbientClr(0,0), 0 );
		SetDiffuseClr( pFrom->GetDiffuseClr(0,0), 0 );
		SetGlossiness( pFrom->GetGlossiness(0,0), 0 );

	macroRecorder->Enable();
	ivalid.SetEmpty();	
}


RefTargetHandle StraussShader::Clone( RemapDir &remap )
{
	StraussShader* mnew = new StraussShader();
	mnew->ReplaceReference(0, remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	
	mnew->diffuse = diffuse;
	mnew->glossiness = glossiness;
	mnew->metalness = metalness;
	return (RefTargetHandle)mnew;
}

void StraussShader::GetIllumParams( ShadeContext &sc, IllumParams& ip )
{
	ip.stdParams = SupportStdParams();
	ip.channels[S_DI] = diffuse;
	ip.channels[S_GL].r = glossiness;
	ip.channels[S_MT].r = metalness;
}



void StraussShader::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();

		pblock->GetValue( st_diffuse, t, p, ivalid );
		diffuse= Bound(Color(p.x,p.y,p.z));
		pblock->GetValue( st_glossiness, t, glossiness, ivalid );
		glossiness = Bound(glossiness );
		pblock->GetValue( st_metalness, t, metalness, ivalid );
		metalness = Bound(metalness );
	}
	valid &= ivalid;
}

void StraussShader::Reset()
{
//	StraussCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2

	ivalid.SetEmpty();
	SetDiffuseClr( Color(0.5f,0.5f,0.5f), 0 );
	SetGlossiness( 0.2f,0);   
	SetMetalness( 0.0f,0);   
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//	IO Routines
//
#define SHADER_HDR_CHUNK 0x4000
#define SHADER_MAPSON_CHUNK 0x5004
#define SHADER_VERS_CHUNK 0x5300
#define SHADER_DIMDIFFON_CHUNK 0x5400

// IO
IOResult StraussShader::Save(ISave *isave) 
{ 
ULONG nb;

	isave->BeginChunk(SHADER_VERS_CHUNK);
	int version = CURRENT_STRAUSS_SHADER_VERSION;
	isave->Write(&version,sizeof(version),&nb);			
	isave->EndChunk();

	return IO_OK;
}		

class StraussShaderCB: public PostLoadCallback {
	public:
		StraussShader *s;
		int loadVersion;
	    StraussShaderCB(StraussShader *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) 
		{
			s->ReplaceReference(0,
				UpdateParameterBlock2(StraussShaderPB, STRAUSS_SHADER_NPARAMS, (IParamBlock*)s->pblock, &strauss_param_blk));
		}
};


IOResult StraussShader::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	int version = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SHADER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
			case SHADER_DIMDIFFON_CHUNK:
				BOOL dim;
				res = iload->Read(&dim,sizeof(dim), &nb);
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < CURRENT_STRAUSS_SHADER_VERSION ) {
		iload->RegisterPostLoadCallback(new StraussShaderCB(this, version));
		iload->SetObsolete();
	}
	return IO_OK;
}

			
///////////////////////////////////////////////////////////////////////////////////////////
// The Shader
//

// my magic constants
static float SpecBoost = 1.3f;

// Strauss's Magic Constants
static float kf = 1.12f;
static float kf2 = 1.0f / (kf * kf);
static float kf3 = 1.0f / ((1.0f - kf) * (1.0f - kf));
static float kg = 1.01f;
static float kg2 = 1.0f / (kg * kg);
static float kg3 = 1.0f / ((1.0f - kg) * (1.0f - kg));
static float kj = 0.1f;	//.1 strauss

static float OneOverHalfPi = 1.0f / (0.5f * Pi);

inline float F( float x ){ 
	float xb = Bound( x );
	float xkf = 1.0f / ((xb - kf)*(xb - kf));
	return (xkf - kf2) / (kf3 - kf2);
}

inline float G( float x ){ 
	float xb = Bound( x );
	float xkg = 1.0f / ((xb - kg)*(xb - kg));
	return (kg3 - xkg) / (kg3 - kg2);
}

#define REFL_BRIGHTNESS_ADJUST	3.0f;

void StraussShader::AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rClr ) 
{
	float opac = ip.channels[ S_TR ].r;
	float g = ip.channels[ S_GL ].r;
	float m = ip.channels[ S_MT ].r;
	Color Cd = ip.channels[ S_DI ];

	float rn = opac - (1.0f - g * g * g) * opac;

	// the reflection of the reflection vector is just the view vector
	// so dot(v, r) is 1, to any power is still 1
	float a, b;
//	NB: this has been transformed for existing in-pointing v
	float NV = Dot( ip.V, ip.N );
	Point3 R = ip.V - 2.0f * NV * ip.N;
	float NR = Dot( ip.N, R );
		a = (float)acos( NR ) * OneOverHalfPi;
		b = (float)acos( NV ) * OneOverHalfPi;
				
	float fa = F( a );
	float j = fa * G( a ) * G( b );
	float rj = Bound( rn + (rn+kj)*j );
	Color white( 1.0f, 1.0f, 1.0f );

	Color Cs = white + m * (1.0f - fa) * (Cd - white);
	rClr *= Cs * rj * REFL_BRIGHTNESS_ADJUST;
}

static int stopX = -1;
static int stopY = -1;

static float	greyVal = 0.3f;
static float	clrVal = 0.3f;

static float	softThresh = 0.15f;

void StraussShader::Illum(ShadeContext &sc, IllumParams &ip) 
{
	LightDesc *l;
	Color lightClr;

#ifdef _DEBUG
	IPoint2 sp = sc.ScreenCoord();
	if ( sp.x == stopX && sp.y == stopY )
		sp.x = stopX;
#endif

	float opac = ip.channels[ S_TR ].r;
	float g = ip.channels[ S_GL ].r;
	float m = ip.channels[ S_MT ].r;
	Color Cd = ip.channels[ S_DI ];
//	BOOL dimDiffuse = ip.hasComponents & HAS_REFLECT;
 	BOOL dimDiffuse = ip.hasComponents & HAS_REFLECT_MAP;

	float rd;
 	float g3 = Cube( g );
	if ( dimDiffuse )
		rd = (1.0f - g3) * opac;
	else
		rd = (1.0f - m * g3) * opac;	//ke 10/28/98

	float rn = opac - (1.0f - g3) * opac;

	float h = (g == 1.0f ) ? 600.0f : 3.0f / (1.0f - g );
	float d = 1.0f - m * g;

	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		float NL, Kl;
		Point3 L;
		if (l->Illuminate( sc, ip.N, lightClr, L, NL, Kl)) {
			if (l->ambientOnly) {
				ip.ambIllumOut += lightClr;
				continue;
			}
			if (NL<=0.0f) 
				continue;

			// diffuse
			if (l->affectDiffuse){
				ip.diffIllumOut += Kl * d * rd * lightClr;
			}

			// specular  
			if (l->affectSpecular) {
				// strauss uses the reflected LIGHT vector
				Point3 R = L - 2.0f * NL * ip.N;
				R = Normalize( R );

				float RV = -Dot(R, ip.V);
				
				float s;
				if (RV < 0.0f) {
					// soften
					if ( NL < softThresh )
						RV *= SoftSpline2( NL / softThresh );
					// specular function
					s = SpecBoost * (float)pow( -RV, h);
				} else
					continue;

				float a, b;
				a = (float)acos( NL ) * OneOverHalfPi;
				b = (float)acos( -Dot(ip.N, ip.V) ) * OneOverHalfPi;
				
				float fa = F( a );
				float j = fa * G( a ) * G( b );
				float rj = rn > 0.0f ? Bound( rn + (rn+kj)*j ) : rn;
				Color Cl = lightClr;
				// normalize the light color in case it's really bright
				float I = NormClr( Cl );
				Color Cs = Cl + m * (1.0f - fa) * (Cd - Cl);

				ip.specIllumOut += s * rj * I * Cs;

			} // end, if specular
 		}	// end, illuminate

	} // for each light

	// now we can multiply by the clrs, except specular, which is already done
	ip.ambIllumOut *= 0.5f * rd * Cd; 
	ip.diffIllumIntens = Intens(ip.diffIllumOut);
	ip.diffIllumOut *= Cd; 

	// next due reflection
	if ( ip.hasComponents & HAS_REFLECT ){
		Color rc = ip.channels[ ip.stdIDToChannel[ ID_RL ] ];
		AffectReflection(sc, ip, rc);
		ip.reflIllumOut = rc * ip.kR;
	}

	// last do opacity
	ip.finalOpac = opac;
//	if ( opac < 1.0f ) {
	if (ip.hasComponents & HAS_OPACITY)	{
		//	ip.finalT = Cd * (1.0f-opac);
		Cd = greyVal * Color( 1.0f, 1.0f, 1.0f ) + clrVal * Cd;
		ip.finalT = transpColor( TRANSP_FILTER, opac, Cd, Cd );
	}
}

float StraussShader::GetSpecularLevel(TimeValue t)
{
	float g3 = Cube( glossiness );

//	float j = F( 0.0f ) * G( 0.0f ) * G( 0.0f );
//	float j = G( 0.0f ) * G( 0.0f );
//	float rj = Bound( g3 + (g3+kj)*j );
//	return rj;
	return g3;
}

void StraussShader::CombineComponents( ShadeContext &sc, IllumParams& ip )
{
	float o = (ip.hasComponents & HAS_REFRACT) ? ip.finalOpac : 1.0f;

	ip.finalC = o * (ip.ambIllumOut + ip.diffIllumOut) + ip.specIllumOut 
				+ ip.reflIllumOut + ip.transIllumOut; 
}

///////////////////////////////////////////////////////////////////////////////////
//
//	Strauss shader dlg panel
//
class StraussShaderDlg : public ShaderParamDlg {
public:
	StraussShader*	pShader;
	StdMat2*	pMtl;
	HPALETTE	hOldPal;
	HWND		hwmEdit;	// window handle of the materials editor dialog
	IMtlParams*	pMtlPar;
	HWND		hwHilite;   // the hilite window
	HWND		hRollup;	// Rollup panel
	TimeValue	curTime;
	BOOL		valid;
	BOOL		isActive;

	IColorSwatch *cs[STRAUSS_NCOLBOX];
	ISpinnerControl *glSpin, *mtSpin, *trSpin;
	ICustButton* texMBut[NMBUTS];
	TexDADMgr dadMgr;
	
	StraussShaderDlg( HWND hwMtlEdit, IMtlParams *pParams ); 
	~StraussShaderDlg(); 

	// required for correctly operating map buttons
	int FindSubTexFromHWND(HWND hw) {
		for (long i=0; i<NMBUTS; i++) {
			if (hw == texMBut[i]->GetHwnd()) 
				return texmapFromMBut[i];
		}	
		return -1;
	}

	// Methods
	BOOL PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ); 
	Class_ID ClassID(){ return StraussShaderClassID; }

	void SetThing(ReferenceTarget *m){ pMtl = (StdMat2*)m; }
	void SetThings( StdMat2* theMtl, Shader* theShader )
	{	if (pShader) pShader->SetParamDlg(NULL);   
		pShader = (StraussShader*)theShader; 
		if (pShader)pShader->SetParamDlg(this); 
		pMtl = theMtl; 
	}
	ReferenceTarget* GetThing(){ return pMtl; } // mtl is the thing! (for DAD!)
	Shader* GetShader(){ return pShader; }
	
	void SetTime(TimeValue t) {
		//DS 2/26/99: added interval test to prevent redrawing when not necessary
		if (!pShader->ivalid.InInterval(t)) {
			Interval v;
			pShader->Update(t,v);
			LoadDialog(TRUE); 
			}
		curTime = t; 
		}		
	BOOL KeyAtCurTime(int id) { return pShader->KeyAtTime(id,curTime); } 
	void DeleteThis() { delete this; }
	void ActivateDlg( BOOL dlgOn ){ isActive = dlgOn; }
	HWND GetHWnd(){ return hRollup; }
	void NotifyChanged(){ pShader->NotifyChanged(); }
	void LoadDialog(BOOL draw);
	void ReloadDialog(){ Interval v; pShader->Update(pMtlPar->GetTime(), v); LoadDialog(FALSE);}
	void UpdateDialog( ParamID paramId ){ ReloadDialog(); }

	void UpdateMtlDisplay(){ pMtlPar->MtlChanged(); } // redraw viewports
    void UpdateHilite( );
	void UpdateColSwatches();
	void UpdateMapButtons();
	void UpdateOpacity();

	void SelectEditColor(int i) { cs[ i ]->EditThis(FALSE); }
};

static BOOL CALLBACK  StraussShaderDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	StraussShaderDlg *theDlg;
	if (msg == WM_INITDIALOG) {
		theDlg = (StraussShaderDlg*)lParam;
		SetWindowLong(hwndDlg, GWL_USERDATA, lParam);
	} else {
	    if ( (theDlg = (StraussShaderDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
	}
	theDlg->isActive = 1;
	BOOL res = theDlg->PanelProc(hwndDlg, msg, wParam, lParam);
	theDlg->isActive = 0;
	return res;
}


ShaderParamDlg* StraussShader::CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen ) 
{
	Interval v;
	Update(imp->GetTime(),v);
	
	StraussShaderDlg *pDlg = new StraussShaderDlg(hwMtlEdit, imp);
	pDlg->SetThings( theMtl, this  );

	LoadStdShaderResources();
	if ( hOldRollup ) {
		pDlg->hRollup = imp->ReplaceRollupPage( 
			hOldRollup,
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_STRAUSS3),
			StraussShaderDlgProc, 
			GetString(IDS_KE_STRAUSS_BASIC),	// your name here
			(LPARAM)pDlg , 
			rollupOpen
			);
	} else
		pDlg->hRollup = imp->AddRollupPage( 
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_STRAUSS3),
			StraussShaderDlgProc, 
			GetString(IDS_KE_STRAUSS_BASIC),	
			(LPARAM)pDlg , 
			rollupOpen
			);

	return (ShaderParamDlg*)pDlg;	
}

RefResult StraussShader::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
									  PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock){
				// update UI if paramblock changed, possibly from scripter
				ParamID changingParam = pblock->LastNotifyParamID();
				// reload the dialog if present
				if (paramDlg){
					paramDlg->UpdateDialog( changingParam );
				}
			}
			break;
	}
	return(REF_SUCCEED);
}


float StraussShader::EvalHiliteCurve( float x )
{
	float op = ( paramDlg )? paramDlg->pMtl->GetOpacity(0) : 1.0f;
	float rn = op - (1.0f - glossiness * glossiness * glossiness) * op;

	float h = (glossiness == 1.0f)? 600.0f : 3.0f / (1.0f - glossiness );
	float s = (float)pow( cos(x*PI), h);

	float a = 0.5f;
	float b = x;

	float fa = F( a );
	float j = fa * G( a ) * G( b );
	float rj = Min( 1.0f, rn + (rn+kj)*j );
	float IllumOut = SpecBoost * s * rj;

	return IllumOut;
}


StraussShaderDlg::StraussShaderDlg( HWND hwMtlEdit, IMtlParams *pParams)
{
	pMtl = NULL;
	pShader = NULL;
	hwmEdit = hwMtlEdit;
	pMtlPar = pParams;
	dadMgr.Init(this);
	glSpin = mtSpin = trSpin = NULL;
	hRollup = hwHilite = NULL;
	curTime = pMtlPar->GetTime();
	isActive = valid = FALSE;

	for( long i = 0; i < STRAUSS_NCOLBOX; ++i )
		cs[ i ] = NULL;

	for( i = 0; i < NMBUTS; ++i )
		texMBut[ i ] = NULL;
}

StraussShaderDlg::~StraussShaderDlg()
{
	HDC hdc = GetDC(hRollup);
	GetGPort()->RestorePalette(hdc, hOldPal);
	ReleaseDC(hRollup, hdc);

	if( pShader ) pShader->SetParamDlg(NULL);

	for (long i=0; i < NMBUTS; i++ ){
		ReleaseICustButton( texMBut[i] );
		texMBut[i] = NULL; 
	}

	for (i=0; i<STRAUSS_NCOLBOX; i++)
		if (cs[i]) ReleaseIColorSwatch(cs[i]); // mjm - 5.10.99
	
	ReleaseISpinner(glSpin);
	ReleaseISpinner(mtSpin);
	ReleaseISpinner(trSpin);

	SetWindowLong(hRollup, GWL_USERDATA, NULL);
	SetWindowLong(hwHilite, GWL_USERDATA, NULL);
	hwHilite = hRollup = NULL;
}


void  StraussShaderDlg::LoadDialog(BOOL draw) 
{
	if (pShader && hRollup) {
		glSpin->SetValue( FracToPc( pShader->GetGlossiness() ),FALSE);
		glSpin->SetKeyBrackets(KeyAtCurTime(st_glossiness));
		
		mtSpin->SetValue( FracToPc( pShader->GetMetalness() ), FALSE);
		mtSpin->SetKeyBrackets(KeyAtCurTime(st_metalness));

		trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
		trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));

		UpdateColSwatches();
		UpdateHilite();
	}
}


static TCHAR* mapStates[] = { _T(" "), _T("m"),  _T("M") };

void StraussShaderDlg::UpdateMapButtons() 
{

	for ( long i = 0; i < NMBUTS; ++i ) {
		int nMap = texmapFromMBut[ i ];
		int state = pMtl->GetMapState( nMap );
		texMBut[i]->SetText( mapStates[ state ] );

		TSTR nm = pMtl->GetMapName( nMap );
		texMBut[i]->SetTooltip(TRUE,nm);
	}
}


void StraussShaderDlg::UpdateOpacity() 
{
	trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
	trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));
}

void StraussShaderDlg::UpdateColSwatches() 
{
	cs[0]->SetKeyBrackets( pShader->KeyAtTime(st_diffuse,curTime) );
	cs[0]->SetColor( pShader->GetDiffuseClr() );
}


void StraussShaderDlg::UpdateHilite()
{
	HDC hdc = GetDC(hwHilite);
	Rect r;
	GetClientRect(hwHilite,&r);
	DrawHilite(hdc, r, pShader );
	ReleaseDC(hwHilite,hdc);
}



static int ColorIDCToIndex(int idc) {
	switch (idc) {
		case IDC_COLOR: return 0;
		default: return 0;
	}
}


BOOL StraussShaderDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG:
			{
			HDC theHDC = GetDC(hwndDlg);
			hOldPal = GetGPort()->PlugPalette(theHDC);
			ReleaseDC(hwndDlg,theHDC);

			HWND hwndCS = GetDlgItem(hwndDlg, IDC_COLOR);
			cs[0] = GetIColorSwatch( hwndCS, pShader->GetDiffuseClr(), GetString(IDS_KE_COLOR) );

			hwHilite = GetDlgItem(hwndDlg, IDC_HIGHLIGHT);
			SetWindowLong( hwHilite, GWL_WNDPROC, (LONG)HiliteWndProc);

			glSpin = SetupIntSpinner(hwndDlg, IDC_GL_SPIN, IDC_GL_EDIT, 0,100, 0);
			mtSpin = SetupIntSpinner(hwndDlg, IDC_MT_SPIN, IDC_MT_EDIT, 0,100, 0);
			trSpin = SetupIntSpinner(hwndDlg, IDC_TR_SPIN, IDC_TR_EDIT, 0,100, 0);

			for (int j=0; j<NMBUTS; j++) {
				texMBut[j] = GetICustButton(GetDlgItem(hwndDlg,texMButtonsIDC[j]));
				assert( texMBut[j] );
				texMBut[j]->SetRightClickNotify(TRUE);
				texMBut[j]->SetDADMgr(&dadMgr);
			}
			LoadDialog(TRUE);
		}
		break;

		case WM_COMMAND: 
			{
			for ( int i=0; i<NMBUTS; i++) {
				if (id == texMButtonsIDC[i]) {
					PostMessage(hwmEdit,WM_TEXMAP_BUTTON, texmapFromMBut[i],(LPARAM)pMtl );
					UpdateMapButtons();
					goto exit;
					}
				}
			}

			break; // WM_COMMAND

		case CC_COLOR_SEL: {
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
		}			
		break;
		case CC_COLOR_DROP:	{
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
			UpdateMtlDisplay();				
		}
		break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
		 break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			UpdateMtlDisplay();				
			break;
		case CC_COLOR_CHANGE: {			
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = ColorIDCToIndex(id);
			if (buttonUp) theHold.Begin();
			DWORD curRGB = cs[n]->GetColor();
			pShader->SetDiffuseClr(curRGB, curTime); 
			if (buttonUp) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
				// DS: 5/11/99-  this was commented out. I put it back in, because
				// it is necessary for the Reset button in the color picker to 
				// update the viewport.				
				UpdateMtlDisplay();  
				}
		} break;
		case WM_PAINT: 
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
		case WM_DESTROY: 
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_GL_SPIN: 
					pShader->SetGlossiness(PcToFrac( glSpin->GetIVal() ), curTime); 
					UpdateHilite();
					break;
				case IDC_MT_SPIN: 
					pShader->SetMetalness(PcToFrac(mtSpin->GetIVal()), curTime); 
					break;
				//******** >>>><<<< required handling for opacity....must be present in all dialogs
				case IDC_TR_SPIN: 
					pMtl->SetOpacity(PcToFrac( trSpin->GetIVal()),curTime); 
					break;
			}
//			UpdateMtlDisplay();
		break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;

    }
	exit:
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shaderUtil.h ===
////////////////////////////////////////////////////////////
//
//	Shader UI Utility routines
//

#ifndef SHADERUTIL_H
#define SHADERUTIL_H

#define ALPHA_MIN	0.015f
#define ALPHA_MAX	0.5f
#define SPEC_MAX	0.5f

#define ALPHA_SZ	(ALPHA_MAX - ALPHA_MIN)

#define DEFAULT_GLOSS2	0.03f	
#define DEFAULT_K_REFL	1.0f	

#define MIN_ORIENT		-999.99	
#define MAX_ORIENT		999.99	


void CombineComponentsComp( IllumParams& ip );
void CombineComponentsAdd( IllumParams& ip );

#define TRANSP_SUB		0
#define TRANSP_ADD		1
#define TRANSP_FILTER	2

Color transpColor( ULONG flags, float opac, Color filt, Color diff );

Color OrenNayarIllum( Point3 N, Point3 L, Point3 V, float rough, Color rho, float NL = -2.0f );

float GaussHighlight( float gloss, float aniso, float orient,  
					  Point3& N, Point3& V, Point3& L, Point3& U, float* pNL );

Point3 GetTangent( ShadeContext &sc, int uvChan );

float GaussHiliteCurve2( float x, float y, float sLevel, float gloss, float aniso );

BOOL IsButtonChecked(HWND hWnd,int id);
void CheckButton(HWND hWnd,int id, BOOL check);

void SetupLockButton(HWND hWnd,int id, BOOL check);
void SetupPadLockButton(HWND hWnd,int id, BOOL check);
void LoadStdShaderResources();

// 2D version
void DrawHilite(HDC hdc, Rect& rect, Shader* pShader );
LRESULT CALLBACK HiliteWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );

// anisotropic version, w layers: layer 0= ignore layers, 1=layer1, 2=layer2
void DrawHilite2(HDC hdc, Rect& rect, Shader* pShader, int layer=0 );
LRESULT CALLBACK Hilite2WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK Hilite2Layer1WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
LRESULT CALLBACK Hilite2Layer2WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
void UpdateHilite( HWND hwHilite, Shader* pShader, int layer=0 );
void UpdateHilite2( HWND hwHilite, Shader* pShader, int layer=0 );


Color GetMtlColor( int i, Shader* pShader ) ;
TCHAR *GetColorName( int i );
//void SetMtlColor(int i, Color c, StdShader* pShader, ColorSwatch* cs);
void SetMtlColor(int i, Color c, Shader* pShader, IColorSwatch** cs, TimeValue t);

inline float PcToFrac(int pc) { return (float)pc/100.0f; }

inline int FracToPc(float f) {
	if (f<0.0) return (int)(100.0f*f - .5f);
	else return (int) (100.0f*f + .5f);
}

// Soften polynomials
#define Soften	 SoftSpline2

// Quadratic
static inline float SoftSpline2(float r) {
	return r*(2.0f-r);
	}

// Cubic
static inline float SoftSpline3(float r) {
	return r*r*(3.0f-2.0f*r);
	}

extern float const Pi;
extern float const Pi2;

// General math inlines
inline float Sqr( float x ) { return x * x; }
inline float Cube( float x ) { return x * x * x; }
inline float Abs( float a ) { return (a < 0.0f) ? -a : a; }
inline void  MinMax( float& a, float& b ) { if (a > b){ float tmp=a; a=b; b=tmp;} }
inline float Dot( Point3& a, Point3& b ) { return a.x * b.x + a.y * b.y + a.z * b.z; }
inline float Len2( Point3& a ) { return Dot(a,a); }
inline float Len( Point3& a ) { return float( sqrt( Len2(a))); }
inline Point3 Normalize( Point3& a ) { float d = Len(a); return d==0.0f ? a : a*(1.0f/d); }
inline float AngleBetween( Point3& a, Point3& b ) { 
	return float( acos( Dot(a,b)/(Len(a)*Len(b)) ));
}
inline float Min( float a, float b ) { return (a < b) ? a : b; }
inline float Min( float a, float b, float c ) { return (a < b) ? Min(a,c) : Min(b,c); }
inline float Min( Color& c ){ return Min( c.r, c.g, c.b ); }
inline float Max( float a, float b ) { return (a < b) ? b : a; }
inline float Max( float a, float b, float c ) { return (a < b) ? Max( b, c ) : Max(a,c); }
inline float Max( Color& c ){ return Max( c.r, c.g, c.b ); }

inline float NormClr( Color& a ){ float m = Max( a ); if(m !=0.0f) a /= m; return m; }

inline float Bound0_1( float x ){ return x < 0.0f ? 0.0f : ( x > 1.0f ? 1.0f : x); }
inline float Bound( float x, float min = 0.0f, float max = 1.0f ){ return x < min? min:( x > max? max : x); }
inline float UBound( float x, float max = 1.0f ){ return x > max ? max : x; }
inline float LBound( float x, float min = 0.0f ){ return x < min ? min : x; }
inline Color Bound( Color& c )
	{ return Color( Bound(c.r), Bound(c.g), Bound(c.b) ); }

inline Color UBound( Color& c, float max = 1.0f )
	{ return Color( UBound(c.r,max), UBound(c.g,max), UBound(c.b,max) ); }
inline Color LBound( Color& c, float min = 0.0f )
	{ return Color( LBound(c.r, min), LBound(c.g, min), LBound(c.b, min) ); }

//inline Point3 Cross( Point3 v0, Point3 v1 ){ return CrossProd( v0, v1 ); }


inline float DegToRdn( float d ){ return d * (1.0f/180.0f) * Pi; } // d/360*2*pi
inline float RdnToDeg( float r ){ return r * 180.0f * (1.0f/Pi); } // r/2pi*360

Point3 RotateVec( Point3& p, Point3& axis, float rdn );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shaderWard.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//		Ward Anisotropic Shader plug-in, implementation
//
//		Created: 10/13/98 Kells Elmquist
//
#include "shadersPch.h"
#include "shadersRc.h"
#include "gport.h"
#include "shaders.h"
#include "shaderUtil.h"

// these control the range of vals presented to the user
#define ALPHA_MIN	0.015f
#define ALPHA_MAX	0.5f
#define SPEC_MAX	0.5f

#define ALPHA_SZ	(ALPHA_MAX - ALPHA_MIN)

// Class Ids
#define WARDSHADER_CLASS_ID		0x2857f440

static Class_ID WardShaderClassID( WARDSHADER_CLASS_ID, 0);
static Class_ID WardShaderDlgClassID( WARDSHADER_CLASS_ID, 0);


/////////////////////////////////////////////////////////////////////
//
//	Basic Panel UI 
//
#define NMBUTS 8
#define N_TR_BUT 7

// tex channel number to button IDC
static int texMButtonsIDC[] = {
	IDC_MAPON_AM, IDC_MAPON_DI, IDC_MAPON_SP, 
	IDC_MAPON_DLEV, IDC_MAPON_SLEV, IDC_MAPON_GLX, IDC_MAPON_GLY,
	IDC_MAPON_TR, 
	-1, -1, -1, -1,  -1, -1, -1, -1 
	};
		
// This array gives the texture map number for given MButton number								
static int texmapFromMBut[] = { 0, 1, 2, 3, 4, 5, 6, 7 };

// Texture Maps
#define WARD_NTEXMAPS	11

// channels ids
#define W_AM	0
#define W_DI	1
#define W_SP	2
#define W_DL	3
#define W_SL	4
#define W_GX	5
#define W_GY	6

// channel names
// sized for nmax  textures
static int texNameIDS[] = {
	IDS_DS_AMBIENT,	IDS_DS_DIFFUSE,	IDS_DS_SPECULAR, 
	IDS_KE_DIFF_LEVEL, IDS_KE_SPEC_LEVEL, IDS_KE_GLOSSINESS_X, IDS_KE_GLOSSINESS_Y,
	IDS_DS_TRANS, IDS_DS_FILTER, IDS_DS_RL, IDS_DS_RR, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
	IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE, IDS_KE_NONE,
};	

// sized for nmax  textures
// bump, reflection & refraction maps are ignored....done after shading
static int chanType[] = {
	CLR_CHANNEL, CLR_CHANNEL, CLR_CHANNEL, MONO_CHANNEL, 
	MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL, MONO_CHANNEL,  
	CLR_CHANNEL, REFL_CHANNEL, REFR_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
	UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL, UNSUPPORTED_CHANNEL,
};	


// what channel corresponds to the stdMat ID's
static int stdIDToChannel[N_ID_CHANNELS] = { 0, 1, 2, 5, 4, -1, 7, 8, -1, 10, 11, -1 };

// Param block parameter names
static int paramNameIDS[] = {
	IDS_DS_AMBIENT,	IDS_DS_DIFFUSE,	IDS_DS_SPECULAR, 
	IDS_KE_DIFF_LEVEL, IDS_KE_SPEC_LEVEL, IDS_KE_GLOSSINESS_X, IDS_KE_GLOSSINESS_Y, 
};


//////////////////////////////////////////////////////////////////////////////////////////
//
//		Ward Parameter Block
//
#define CURRENT_WARD_SHADER_VERSION	1
#define WARD_SHADER_NPARAMS			7
#define WARD_SHADER_PB_VERSION		1

#define WARD_NCOLBOX 3
static int colID[WARD_NCOLBOX] = { IDC_STD_COLOR1, IDC_STD_COLOR2, IDC_STD_COLOR3  };
#define N_AMB_CLR		0

#define PB_AMBIENT_CLR		0
#define PB_DIFFUSE_CLR		1
#define PB_SPECULAR_CLR		2
#define PB_DIFFUSE_LEV		3
#define PB_SPECULAR_LEV		4
#define PB_GLOSSINESS_X		5
#define PB_GLOSSINESS_Y		6

//Current Param Block Descriptor
static ParamBlockDescID WardShaderPB[ WARD_SHADER_NPARAMS ] = {
	{ TYPE_RGBA,  NULL, TRUE,1 },   // ambient
	{ TYPE_RGBA,  NULL, TRUE,2 },   // diffuse
	{ TYPE_RGBA,  NULL, TRUE,3 },   // specular
	{ TYPE_FLOAT, NULL, TRUE,21 },  // diffuse level
	{ TYPE_FLOAT, NULL, TRUE,5 },   // specularLevel
	{ TYPE_FLOAT, NULL, TRUE,4 },   // glossiness x
	{ TYPE_FLOAT, NULL, TRUE,22 },  // glossiness y
}; 

#define WARD_NUMOLDVER 1

static ParamVersionDesc oldVersions[WARD_NUMOLDVER] = {
	ParamVersionDesc(WardShaderPB, WARD_SHADER_NPARAMS, 0),
};


//----------------------------------------------------------------------------------------
//---- Ward Elliptical Gaussian Anisotropic Shader ---------------------------------------
//----------------------------------------------------------------------------------------

class WardShaderDlg;

class WardShader : public Shader {
friend class WardShaderDlg;
protected:
	IParamBlock		*pblock;   // ref 0
	Interval		ivalid;
	TimeValue		curTime;

	WardShaderDlg*	paramDlg;

	BOOL			normalizeOn;
	BOOL			lockDS;
	BOOL			lockAD;
	BOOL			lockADTex;

	Color			ambient;
	Color			diffuse;
	Color			specular;
	float glossinessX;
	float glossinessY;
	float specLevel;
	float diffLevel;

	public:
	WardShader();
	void DeleteThis(){ delete this; }		
    ULONG SupportStdParams(){ return (STD_WARD | STD_EXTRA); }
	// copy std params, for switching shaders
    void CopyStdParams( Shader* pFrom );

	// texture maps
	long  nTexChannelsSupported(){ return WARD_NTEXMAPS; }
	TSTR  GetTexChannelName( long nTex ){ return GetString( texNameIDS[ nTex ] ); }
	long ChannelType( long nChan ) { return chanType[nChan]; }
	long StdIDToChannel( long stdID ){ return stdIDToChannel[stdID]; }

	BOOL KeyAtTime(int id,TimeValue t) { return pblock->KeyFrameAtTime(id,t); }
	ULONG GetRequirements( int subMtlNum ){ return MTLREQ_PHONG+MTLREQ_UV+MTLREQ_BUMPUV; }

	ShaderParamDlg* CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen );
	ShaderParamDlg* GetParamDlg(){ return (ShaderParamDlg*)paramDlg; }
	void SetParamDlg( ShaderParamDlg* newDlg ){ paramDlg = (WardShaderDlg*)newDlg; }

	Class_ID ClassID() { return WardShaderClassID; }
	SClass_ID SuperClassID() { return SHADER_CLASS_ID; }
	TSTR GetName() { return GetString( IDS_KE_WARD ); }
	void GetClassName(TSTR& s) { s = GetName(); }  

	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i){ return (i==0)? pblock : NULL; }
	TSTR SubAnimName(int i){ return TSTR(GetString( IDS_KE_WARD_PARMS )); };
	int SubNumToRefNum(int subNum) { return subNum;	}

 	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i){ return (i==0)? pblock : NULL; }
	void SetReference(int i, RefTargetHandle rtarg) 
		{ if (i==0) pblock = (IParamBlock*)rtarg; else assert(0); }
	void NotifyChanged(){ NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE); }

	void Update(TimeValue t, Interval& valid);
	void Reset();
	RefTargetHandle Clone( RemapDir &remap=NoRemap() );
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	                            PartID& partID, RefMessage message );
	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	// cache for mapping of params, mtl fills in ip
	void GetIllumParams( ShadeContext& sc, IllumParams& ip );

	// Ward Shader specific section
	void  Illum(ShadeContext &sc, IllumParams &ip);
	void CombineComponents( ShadeContext &sc, IllumParams& ip ){ CombineComponentsAdd( ip ); }
	float EvalHiliteCurve2(float x, float y, int layer=0 );

	void AffectReflection(ShadeContext &sc, IllumParams &ip, Color &rcol) { 
		rcol *= ip.channels[W_SP] * DEFAULT_K_REFL; 
	}

	void SetGlossiness(float v, TimeValue t)		
		{ if( v<=ALPHA_MIN) v = ALPHA_MIN; glossinessX= v; pblock->SetValue( PB_GLOSSINESS_X, t, v); }
	void SetGlossinessY(float v, TimeValue t)		
		{ if( v<=ALPHA_MIN) v = ALPHA_MIN; glossinessY= v; pblock->SetValue( PB_GLOSSINESS_Y, t, v); }
	float GetGlossiness(int mtlNum=0, BOOL backFace=FALSE){ return glossinessX; };	
	float GetGlossinessY(int mtlNum=0, BOOL backFace=FALSE){ return glossinessY; };	
	float GetGlossiness( TimeValue t){return pblock->GetFloat(PB_GLOSSINESS_X,t);  }		
	float GetGlossinessY( TimeValue t){return pblock->GetFloat(PB_GLOSSINESS_Y,t);  }		
	void  SetNormalizeOn( BOOL normOn ) { normalizeOn = normOn; }
	BOOL  GetNormalizeOn(){ return normalizeOn; }

	// Std Params
	BOOL IsFaceted() { return FALSE; }
	void SetLockDS(BOOL lock){ lockDS = lock;  }
	BOOL GetLockDS(){ return lockDS; }
	void SetLockAD(BOOL lock){ lockAD = lock;  }
	BOOL GetLockAD(){ return lockAD; }
	void SetLockADTex(BOOL lock){ lockADTex = lock;  }
	BOOL GetLockADTex(){ return lockADTex; }

	void SetAmbientClr(Color c, TimeValue t)		
		{ ambient = c; pblock->SetValue( PB_AMBIENT_CLR, t, c); }
	void SetDiffuseClr(Color c, TimeValue t)		
		{ diffuse = c; pblock->SetValue( PB_DIFFUSE_CLR, t, c); }
	void SetSpecularClr(Color c, TimeValue t)
		{ specular = c; pblock->SetValue( PB_SPECULAR_CLR, t, c); }
	void SetDiffuseLevel(float v, TimeValue t)		
			{ diffLevel = v; pblock->SetValue( PB_DIFFUSE_LEV, t, v); }
	void SetSpecularLevel(float v, TimeValue t)		
		{ specLevel = v; pblock->SetValue( PB_SPECULAR_LEV, t, v); }

	Color GetAmbientClr(int mtlNum=0, BOOL backFace=FALSE){ return ambient;}		
    Color GetDiffuseClr(int mtlNum=0, BOOL backFace=FALSE){ return diffuse;}		
	Color GetSpecularClr(int mtlNum=0, BOOL backFace=FALSE){ return specular; };
	float GetDiffuseLevel(int mtlNum=0, BOOL backFace=FALSE){ return diffLevel; };
	float GetSpecularLevel(int mtlNum=0, BOOL backFace=FALSE){ return specLevel; };
	Color GetAmbientClr(TimeValue t){ return pblock->GetColor(PB_AMBIENT_CLR,t); }		
	Color GetDiffuseClr(TimeValue t){ return pblock->GetColor(PB_DIFFUSE_CLR,t); }		
	Color GetSpecularClr(TimeValue t){ return pblock->GetColor(PB_SPECULAR_CLR,t);	}
	float GetSpecularLevel(TimeValue t){ return  pblock->GetFloat(PB_SPECULAR_LEV,t); }
	float GetDiffuseLevel(TimeValue t){ return  pblock->GetFloat(PB_DIFFUSE_LEV,t); }

	// not supported
	void SetSelfIllum(float v, TimeValue t)	{}
	float GetSelfIllum(int mtlNum=0, BOOL backFace=FALSE){ return 0.0f; };
	void SetSelfIllumClrOn( BOOL on ){};
	BOOL IsSelfIllumClrOn(){ return FALSE; };
	BOOL IsSelfIllumClrOn(int mtlNum, BOOL backFace){ return FALSE; }
	void SetSelfIllumClr(Color c, TimeValue t){}
	Color GetSelfIllumClr(int mtlNum=0, BOOL backFace=FALSE){ return Color(0,0,0); }
	void SetSoftenLevel(float v, TimeValue t) {}
	float GetSoftenLevel(int mtlNum=0, BOOL backFace=FALSE){ return DEFAULT_SOFTEN; }
	float GetSoftenLevel(TimeValue t){ return  DEFAULT_SOFTEN; }
	float GetSelfIllum(TimeValue t){ return 0.0f;}		
	Color GetSelfIllumClr(TimeValue t){ return Color(0,0,0);}		

};

///////////// Class Descriptor ////////////////////////
class WardShaderClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { 	return new WardShader(); }
	const TCHAR *	ClassName() { return GetString(IDS_KE_WARD); }
	SClass_ID		SuperClassID() { return SHADER_CLASS_ID; }
	Class_ID 		ClassID() { return WardShaderClassID; }
	const TCHAR* 	Category() { return _T("");  }
};

WardShaderClassDesc wardCD;
ClassDesc * GetWardShaderCD(){ return &wardCD; }

WardShader::WardShader() 
{ 
	lockDS = lockAD = lockADTex = normalizeOn = 0;
	ambient = diffuse = specular = Color(0.0f,0.0f,0.0f);
	glossinessX = glossinessY = specLevel = diffLevel = 0.0f;
	pblock = NULL; 
	paramDlg = NULL; 
	ivalid.SetEmpty(); 
}

void WardShader::CopyStdParams( Shader* pFrom )
{
	SetLockDS( pFrom->GetLockDS() );
	SetLockAD( pFrom->GetLockAD() );
	SetLockADTex( pFrom->GetLockADTex() );

	SetAmbientClr( pFrom->GetAmbientClr(0,0), curTime );
	SetDiffuseClr( pFrom->GetDiffuseClr(0,0), curTime );
	SetSpecularClr( pFrom->GetSpecularClr(0,0), curTime );

	SetDiffuseLevel( 1.0f, curTime );
	SetSpecularLevel( pFrom->GetSpecularLevel(0,0), curTime );
	SetGlossiness( pFrom->GetGlossiness(0,0), curTime );
	SetGlossinessY( pFrom->GetGlossiness(0,0), curTime ); // both the same
	ivalid.SetEmpty();	
}


RefTargetHandle WardShader::Clone( RemapDir &remap )
{
	WardShader* mnew = new WardShader();
	mnew->ReplaceReference(0, remap.CloneRef(pblock));
	mnew->ivalid.SetEmpty();	
	mnew->ambient = ambient;
	mnew->diffuse = diffuse;
	mnew->specular = specular;
	mnew->glossinessX = glossinessX;
	mnew->glossinessY = glossinessY;
	mnew->specLevel = specLevel;
	mnew->diffLevel = diffLevel;
	mnew->lockDS = lockDS;
	mnew->lockAD = lockAD;
	mnew->lockADTex = lockADTex;
	mnew->normalizeOn = normalizeOn;
	return (RefTargetHandle)mnew;
}

void WardShader::GetIllumParams( ShadeContext &sc, IllumParams& ip )
{
	ip.stdParams = SupportStdParams();
	ip.channels[W_AM] = ambient;
	ip.channels[W_DI] = diffuse;
	ip.channels[W_SP] = specular;
	ip.channels[W_GX].r = glossinessX;
	ip.channels[W_GY].r = glossinessY;
	ip.channels[W_DL].r = diffLevel;
	ip.channels[W_SL].r = specLevel;
}


#define LIMIT0_1(x) if (x < 0.0f) x = 0.0f; else if (x > 1.0f) x = 1.0f;
#define LIMITMINMAX(x, min, max) if (x < min) x = min; else if (x > max) x = max;

static Color LimitColor(Color c) {
	LIMIT0_1(c.r);
	LIMIT0_1(c.g);
	LIMIT0_1(c.b);
	return c;
}

void WardShader::Update(TimeValue t, Interval &valid) {
	Point3 p;
	if (!ivalid.InInterval(t)) {
		ivalid.SetInfinite();

		pblock->GetValue( PB_AMBIENT_CLR, t, p, ivalid );
		ambient = LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( PB_DIFFUSE_CLR, t, p, ivalid );
		diffuse= LimitColor(Color(p.x,p.y,p.z));
		pblock->GetValue( PB_SPECULAR_CLR, t, p, ivalid );
		specular = LimitColor(Color(p.x,p.y,p.z));

		pblock->GetValue( PB_GLOSSINESS_X, t, glossinessX, ivalid );
		LIMITMINMAX(glossinessX, 0.0001f, 1.0f );
		pblock->GetValue( PB_GLOSSINESS_Y, t, glossinessY, ivalid );
		LIMITMINMAX(glossinessY, 0.0001f, 1.0f );

		pblock->GetValue( PB_SPECULAR_LEV, t, specLevel, ivalid );
		LIMITMINMAX(specLevel,0.0f,4.00f);
		pblock->GetValue( PB_DIFFUSE_LEV, t, diffLevel, ivalid );
		LIMITMINMAX(diffLevel,0.0f,2.0f);
		curTime = t;
	}
	valid &= ivalid;
}

void WardShader::Reset()
{
	ReplaceReference( 0, CreateParameterBlock( WardShaderPB, WARD_SHADER_NPARAMS, WARD_SHADER_PB_VERSION ) );	
	ivalid.SetEmpty();
	SetAmbientClr(Color(0.1f,0.1f,0.1f),0);
	SetDiffuseClr(Color(0.5f,0.5f,0.5f),0);
	SetSpecularClr(Color(0.9f,0.9f,0.9f),0);
	SetGlossiness(.25f,0);   // change from .4, 5-21-97
	SetGlossinessY(.25f,0);   
	SetSpecularLevel(0.05f,0);   
	SetDiffuseLevel(0.8f,0);   

	SetLockADTex( TRUE );
	SetLockAD( FALSE );
	SetLockDS( FALSE );
	SetNormalizeOn( TRUE );
}



//////////////////////////////////////////////////////////////////////////////////////////
//
//	IO Routines
//
#define SHADER_HDR_CHUNK 0x4000
#define SHADER_LOCKDS_ON_CHUNK 0x5001
#define SHADER_LOCKAD_ON_CHUNK 0x5002
#define SHADER_LOCKADTEX_ON_CHUNK 0x5003
#define SHADER_MAPSON_CHUNK 0x5004
#define SHADER_NORMALIZE_ON_CHUNK 0x5005
#define SHADER_VERS_CHUNK 0x5300

#define WARD_SHADER_VERSION  1 

// IO
IOResult WardShader::Save(ISave *isave) 
{ 
ULONG nb;

	isave->BeginChunk(SHADER_VERS_CHUNK);
	int version = WARD_SHADER_VERSION;
	isave->Write(&version,sizeof(version),&nb);			
	isave->EndChunk();

	if (lockDS) {
		isave->BeginChunk(SHADER_LOCKDS_ON_CHUNK);
		isave->EndChunk();
	}
	if (lockAD) {
		isave->BeginChunk(SHADER_LOCKAD_ON_CHUNK);
		isave->EndChunk();
	}

	if (lockADTex) {
		isave->BeginChunk(SHADER_LOCKADTEX_ON_CHUNK);
		isave->EndChunk();
	}
	if (normalizeOn) {
		isave->BeginChunk(SHADER_NORMALIZE_ON_CHUNK);
		isave->EndChunk();
	}

	return IO_OK;
}		

class WardShaderCB: public PostLoadCallback {
	public:
		WardShader *s;
		int loadVersion;
	    WardShaderCB(WardShader *newS, int loadVers) { s = newS; loadVersion = loadVers; }
		void proc(ILoad *iload) {}
};


IOResult WardShader::Load(ILoad *iload) { 
	ULONG nb;
	int id;
	int version = 0;

	lockAD = lockADTex = lockDS = normalizeOn = 0;

	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id = iload->CurChunkID())  {
			case SHADER_VERS_CHUNK:
				res = iload->Read(&version,sizeof(version), &nb);
				break;
			case SHADER_LOCKDS_ON_CHUNK:
				lockDS = TRUE;
				break;
			case SHADER_LOCKAD_ON_CHUNK:
				lockAD = TRUE;
				break;
			case SHADER_LOCKADTEX_ON_CHUNK:
				lockADTex = TRUE;
				break;
			case SHADER_NORMALIZE_ON_CHUNK:
				normalizeOn = TRUE;
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	if (version < CURRENT_WARD_SHADER_VERSION ) {
		iload->RegisterPostLoadCallback(new WardShaderCB(this, version));
		iload->SetObsolete();
	}

	return IO_OK;

}

			
///////////////////////////////////////////////////////////////////////////////////////////
// The Shader
//

// defualt gloss squared, for renormalized controls
#define DEFAULT_GLOSS2	0.03f	

float WardShader::EvalHiliteCurve2( float x, float y, int )
{
	double g2 = normalizeOn ? glossinessX * glossinessY : DEFAULT_GLOSS2; 
	double gx2 = glossinessX * glossinessX; 
	double gy2 = glossinessY * glossinessY; 
	
	double t, a;
	double l = sqrt( x*x + y*y );
	if ( l == 0.0 ) {
		a = t = 0.0;
	} else {
		x /= float(l);	y /= float(l);
		t = tan( l*PI*0.5 );
		a = x*x/gx2 + y*y/gy2;
	}
	return specLevel*(float)(exp( -(t * t) * a ) / (4.0 * PI * g2));  
}


static int stopX = -1;
static int stopY = -1;
static int uvChan = 0;

void WardShader::Illum(ShadeContext &sc, IllumParams &ip) {
	LightDesc *l;
	Color lightCol;

#ifdef _DEBUG
	IPoint2 sp = sc.ScreenCoord();
	if ( sp.x == stopX && sp.y == stopY )
		sp.x = stopX;
#endif

	BOOL isShiny= (ip.channels[W_SL].r > 0.0f) ? 1 : 0; 

	for (int i=0; i<sc.nLights; i++) {
		l = sc.Light(i);
		float NL, Kl;
		Point3 L;
		if (l->Illuminate( sc, ip.N, lightCol, L, NL, Kl)) {
			if (l->ambientOnly) {
				ip.ambIllumOut += lightCol;
				continue;
				}
			if (NL<=0.0f) 
				continue;

			// diffuse
			if (l->affectDiffuse){
				ip.diffIllumOut += Kl / Pi * ip.channels[W_DL].r * lightCol;
			}

			// specular  
			if (isShiny && l->affectSpecular) {
				float gx = ip.channels[W_GX].r;
				float gy = ip.channels[W_GY].r;
				assert( gx >= 0.0f && gy >= 0.0f );
				Point3 H = Normalize(L-ip.V); // (L + -V)/2
				float NH = DotProd(ip.N,H);	 
				if (NH > 0.0f) {
					float g2 = normalizeOn ? gx * gy : DEFAULT_GLOSS2;
					float norm = 1.0f / (4.0f * PI * g2);
					float NV = -DotProd(ip.N, ip.V );
					if ( NV <= 0.001f)
						NV = 0.001f;
  
					float g = 1.0f / (float)sqrt( NL * NV );
					if ( g > 6.0f ) g = 6.0f;

					Point3 basisVecs[ 3 ];
					sc.DPdUVW( basisVecs, uvChan ); // 0 is vtxclr, 1..n is uv channels, max_meshmaps in mesh.h
					basisVecs[0] = Normalize( basisVecs[0] );

					// the line between the tip of vec[0] and its projection on N is tangent
					Point3 T = basisVecs[0] - ip.N * Dot( basisVecs[0], ip.N );
					Point3 B = CrossProd( ip.N, T );
					float x = DotProd( H, T ) / gx;
					float y = DotProd( H, B ) / gy;
					float e = (float)exp( -2.0 * (x*x + y*y) / (1.0+NH) );
					ip.specIllumOut += Kl * ip.channels[W_SL].r * norm * g * e * lightCol;
				}
			}
 		}
	} // for each light

	// now we can multiply by the clrs, 
	ip.ambIllumOut *= ip.channels[W_AM]; 
	ip.diffIllumIntens = Intens(ip.diffIllumOut);
	ip.diffIllumOut *= ip.channels[W_DI]; 
	ip.specIllumOut *= ip.channels[W_SP]; 
}


///////////////////////////////////////////////////////////////////
//
//	Ward shader dlg panel
//


// The dialog class
class WardShaderDlg : public ShaderParamDlg {
public:
	WardShader*	pShader;
	StdMat2*	pMtl;
	HPALETTE	hOldPal;
	HWND		hwmEdit;	// window handle of the materials editor dialog
	IMtlParams*	pMtlPar;
	HWND		hwHilite;   // the hilite window
	HWND		hRollup;	// Rollup panel
	TimeValue	curTime;
	BOOL		valid;
	BOOL		isActive;

	IColorSwatch *cs[WARD_NCOLBOX];
	ISpinnerControl *dlevSpin, *slevSpin, *glxSpin, *glySpin, *trSpin;
	ICustButton* texMBut[NMBUTS];
	TexDADMgr dadMgr;
	
	WardShaderDlg( HWND hwMtlEdit, IMtlParams *pParams ); 
	~WardShaderDlg(); 

	// required for correctly operating map buttons
	int FindSubTexFromHWND(HWND hw) {
		for (long i=0; i<NMBUTS; i++) {
			if (hw == texMBut[i]->GetHwnd()) 
				return texmapFromMBut[i];
		}	
		return -1;
	}

	// Methods
	BOOL PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ); 
	Class_ID ClassID(){ return WardShaderDlgClassID; }

	void SetThing(ReferenceTarget *m){ pMtl = (StdMat2*)m; }
	void SetThings( StdMat2* theMtl, Shader* theShader )
	{	if (pShader) pShader->SetParamDlg(NULL);   
		pShader = (WardShader*)theShader; 
		if(pShader) pShader->SetParamDlg(this);
		pMtl = theMtl;
	}
	ReferenceTarget* GetThing(){ return pMtl; } // mtl is the thing! (for DAD!)
	Shader* GetShader(){ return pShader; }
	
	void SetTime(TimeValue t) {
		//DS 2/26/99: added interval test to prevent redrawing when not necessary
		if (!pShader->ivalid.InInterval(t)) {
			Interval v;
			pShader->Update(t,v);
			LoadDialog(TRUE); 
			}
		curTime = t; 
		}		
	BOOL KeyAtCurTime(int id) { return pShader->KeyAtTime(id,curTime); } 
	void DeleteThis() { delete this; }
	void ActivateDlg( BOOL dlgOn ){ isActive = dlgOn; }
	HWND GetHWnd(){ return hRollup; }
	void NotifyChanged(){ pShader->NotifyChanged(); }
	void LoadDialog(BOOL draw);
	void ReloadDialog(){ Interval v; pShader->Update(pMtlPar->GetTime(), v); LoadDialog(FALSE);}
	void UpdateDialog( ParamID paramId ){ ReloadDialog(); }

	void UpdateMtlDisplay(){ pMtlPar->MtlChanged(); } // redraw viewports
    void UpdateHilite( );
	void UpdateColSwatches();
	void UpdateLockADTex(BOOL passOn);
	void UpdateMapButtons();
	void UpdateOpacity();

	void SetLockDS(BOOL lock);
	void SetLockAD(BOOL lock);
	void SetLockADTex(BOOL lock);

	void SelectEditColor(int i) { cs[ i ]->EditThis(FALSE); }
};

static BOOL CALLBACK  WardShaderDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	WardShaderDlg *theDlg;
	if (msg == WM_INITDIALOG) {
		theDlg = (WardShaderDlg*)lParam;
		SetWindowLong(hwndDlg, GWL_USERDATA, lParam);
	} else {
	    if ( (theDlg = (WardShaderDlg *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
	}
	theDlg->isActive = 1;
	BOOL res = theDlg->PanelProc(hwndDlg, msg, wParam, lParam);
	theDlg->isActive = 0;
	return res;
}


ShaderParamDlg* WardShader::CreateParamDialog(HWND hOldRollup, HWND hwMtlEdit, IMtlParams *imp, StdMat2* theMtl, int rollupOpen ) 
{
	Interval v;
	Update(imp->GetTime(),v);
	
	WardShaderDlg *pDlg = new WardShaderDlg(hwMtlEdit, imp);
	pDlg->SetThings( theMtl, this  );

	LoadStdShaderResources();
	if ( hOldRollup ) {
		pDlg->hRollup = imp->ReplaceRollupPage( 
			hOldRollup,
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_WARD3),
			WardShaderDlgProc, 
			GetString(IDS_KE_WARD_BASIC),	// your name here
			(LPARAM)pDlg , 
			rollupOpen
			);
	} else
		pDlg->hRollup = imp->AddRollupPage( 
			hInstance,
			MAKEINTRESOURCE(IDD_DMTL_BASIC_WARD3),
			WardShaderDlgProc, 
			GetString(IDS_KE_WARD_BASIC),	
			(LPARAM)pDlg , 
			rollupOpen
			);

	return (ShaderParamDlg*)pDlg;	
}

RefResult WardShader::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
									  PartID& partID, RefMessage message ) 
{
	switch (message) {
		case REFMSG_WANT_SHOWPARAMLEVEL:
			{
			BOOL *pb = (BOOL *)(partID);
			*pb = TRUE;
			return REF_STOP;
			}
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (paramDlg) {
				if (hTarget==pblock) {
					int np =pblock->LastNotifyParamNum();
					paramDlg->UpdateDialog( np );
				}
			}
			break;
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_AMBIENT_CLR: 
				case PB_DIFFUSE_CLR: 
				case PB_SPECULAR_CLR: 
					gpd->dim = stdColor255Dim; 
					break;
				case PB_GLOSSINESS_X:
				case PB_GLOSSINESS_Y:
				case PB_SPECULAR_LEV:
				case PB_DIFFUSE_LEV:
				default:
					gpd->dim = stdPercentDim; 
					break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name =  GetString(paramNameIDS[gpn->index]);
			return REF_STOP; 
			}
	}
	return(REF_SUCCEED);
}

WardShaderDlg::WardShaderDlg( HWND hwMtlEdit, IMtlParams *pParams)
{
	pMtl = NULL;
	pShader = NULL;
	hwmEdit = hwMtlEdit;
	pMtlPar = pParams;
	dadMgr.Init(this);
	dlevSpin = slevSpin = glxSpin = glySpin = trSpin = NULL;
	hRollup = hwHilite = NULL;
	curTime = pMtlPar->GetTime();
	isActive = valid = FALSE;

	for( long i = 0; i < WARD_NCOLBOX; ++i )
		cs[ i ] = NULL;

	for( i = 0; i < NMBUTS; ++i )
		texMBut[ i ] = NULL;
}

WardShaderDlg::~WardShaderDlg()
{
	HDC hdc = GetDC(hRollup);
	GetGPort()->RestorePalette(hdc, hOldPal);
	ReleaseDC(hRollup, hdc);

	if( pShader ) pShader->SetParamDlg(NULL);

	for (long i=0; i < NMBUTS; i++ ){
		ReleaseICustButton( texMBut[i] );
		texMBut[i] = NULL; 
	}

	for (i=0; i<WARD_NCOLBOX; i++)
		if (cs[i]) ReleaseIColorSwatch(cs[i]); // mjm - 5.10.99

 	ReleaseISpinner(slevSpin);
	ReleaseISpinner(dlevSpin);
	ReleaseISpinner(glxSpin);
	ReleaseISpinner(glySpin);
	ReleaseISpinner(trSpin);

	SetWindowLong(hRollup, GWL_USERDATA, NULL);
	SetWindowLong(hwHilite, GWL_USERDATA, NULL);
	hwHilite = hRollup = NULL;
}


void  WardShaderDlg::LoadDialog(BOOL draw) 
{
	if (pShader && hRollup) {
		dlevSpin->SetValue(FracToPc(pShader->GetDiffuseLevel()),FALSE);
		dlevSpin->SetKeyBrackets(KeyAtCurTime(PB_DIFFUSE_LEV));

		slevSpin->SetValue(FracToPc(pShader->GetSpecularLevel()/SPEC_MAX),FALSE);
		slevSpin->SetKeyBrackets(KeyAtCurTime(PB_SPECULAR_LEV));

		glxSpin->SetValue( 100.0f * ((ALPHA_MAX - pShader->GetGlossiness())/ALPHA_SZ),FALSE);
		glxSpin->SetKeyBrackets(KeyAtCurTime(PB_GLOSSINESS_X));
		glySpin->SetValue(100.0f * ((ALPHA_MAX - pShader->GetGlossinessY())/ALPHA_SZ),FALSE);
		glySpin->SetKeyBrackets(KeyAtCurTime(PB_GLOSSINESS_Y));

		trSpin->SetValue(FracToPc(pMtl->GetOpacity( curTime )),FALSE);
		trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));

		CheckButton(hRollup, IDC_LOCK_AD, pShader->GetLockAD() );
		CheckButton(hRollup, IDC_LOCK_DS, pShader->GetLockDS() );
		SetCheckBox(hRollup, IDC_NORMALIZE_CHECK, !pShader->GetNormalizeOn() ); 
	 	UpdateLockADTex( FALSE ); //don't send to mtl

		UpdateColSwatches();
		UpdateHilite();
	}
}


static TCHAR* mapStates[] = { _T(" "), _T("m"),  _T("M") };

void WardShaderDlg::UpdateMapButtons() 
{

	for ( long i = 0; i < NMBUTS; ++i ) {
		int nMap = texmapFromMBut[ i ];
		int state = pMtl->GetMapState( nMap );
		texMBut[i]->SetText( mapStates[ state ] );

		TSTR nm	 = pMtl->GetMapName( nMap );
		texMBut[i]->SetTooltip(TRUE,nm);
	}
}


void WardShaderDlg::SetLockAD(BOOL lock)
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_DS_LOCKAD), GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_AD, FALSE);	
			return;	
		}
		// set ambient color to diffuse
		pShader->SetAmbientClr( pShader->GetDiffuseClr(), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockAD(lock);
}

void WardShaderDlg::UpdateOpacity() 
{
	trSpin->SetValue(FracToPc(pMtl->GetOpacity(curTime)),FALSE);
	trSpin->SetKeyBrackets(pMtl->KeyAtTime(OPACITY_PARAM, curTime));
}


void WardShaderDlg::UpdateColSwatches() 
{
	for(int i=0; i < WARD_NCOLBOX; i++) {
		if ( cs[ i ] ) {
			cs[i]->SetKeyBrackets( pShader->KeyAtTime(PB_AMBIENT_CLR+i,curTime) );
			cs[i]->SetColor( GetMtlColor(i, (Shader*)pShader) );
		}
	}
}


void WardShaderDlg::UpdateHilite()
{
	HDC hdc = GetDC(hwHilite);
	Rect r;
	GetClientRect(hwHilite,&r);
	DrawHilite2(hdc, r, pShader );
	ReleaseDC(hwHilite,hdc);
}

void WardShaderDlg::UpdateLockADTex( BOOL passOn) {
	int lock = 	pShader->GetLockADTex();
	CheckButton(hRollup, IDC_LOCK_ADTEX, lock);

	ShowWindow(GetDlgItem(hRollup, IDC_MAPON_AM), !lock);
	texMBut[ 0 ]->Enable(!lock);

	if ( passOn ) 
		pMtl->SyncADTexLock( lock );
	
//	UpdateMtlDisplay();
}

void WardShaderDlg::SetLockADTex(BOOL lock) {
	pShader->SetLockADTex( lock );
	UpdateLockADTex(TRUE); // passon to mtl
//	UpdateMtlDisplay();
}

void WardShaderDlg::SetLockDS(BOOL lock) 
{
	if (lock) {
		if (IDYES!=MessageBox(hwmEdit, GetString(IDS_KE_LOCKDS),GetString(IDS_DS_LOCKCOL), MB_YESNO)) {
			CheckButton(hRollup, IDC_LOCK_DS, FALSE);	
			return;	
		}
		pShader->SetSpecularClr( pShader->GetDiffuseClr(), 0 );
		UpdateColSwatches();
	}
	pShader->SetLockDS( lock );
}

static int ColorIDCToIndex(int idc) {
	switch (idc) {
		case IDC_STD_COLOR1: return 0;
		case IDC_STD_COLOR2: return 1;
		case IDC_STD_COLOR3: return 2;
		default: return 0;
	}
}


BOOL WardShaderDlg::PanelProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = LOWORD(wParam);
	int code = HIWORD(wParam);
    switch (msg) {
		case WM_INITDIALOG:
			{
			int i;
			
			HDC theHDC = GetDC(hwndDlg);
			hOldPal = GetGPort()->PlugPalette(theHDC);
			ReleaseDC(hwndDlg,theHDC);

			for (i=0; i<WARD_NCOLBOX; i++) {
   				cs[i] = GetIColorSwatch(GetDlgItem(hwndDlg, colID[i]),
   					GetMtlColor(i, pShader), GetColorName(i));
			}

			hwHilite = GetDlgItem(hwndDlg, IDC_HIGHLIGHT);
			SetWindowLong( hwHilite, GWL_WNDPROC, (LONG)Hilite2WndProc);

			slevSpin = SetupIntSpinner(hwndDlg, IDC_SLEV_SPIN, IDC_SLEV_EDIT, 0,400, 0);
			dlevSpin = SetupIntSpinner(hwndDlg, IDC_DLEV_SPIN, IDC_DLEV_EDIT, 0, 400, 0);
			glxSpin = SetupIntSpinner(hwndDlg, IDC_GLX_SPIN, IDC_GLX_EDIT, 0,100, 0);
			glySpin = SetupIntSpinner(hwndDlg, IDC_GLY_SPIN, IDC_GLY_EDIT, 0,100, 0);
			trSpin = SetupIntSpinner(hwndDlg, IDC_TR_SPIN, IDC_TR_EDIT, 0,100, 0);

			for (int j=0; j<NMBUTS; j++) {
				texMBut[j] = GetICustButton(GetDlgItem(hwndDlg,texMButtonsIDC[j]));
				assert( texMBut[j] );
				texMBut[j]->SetRightClickNotify(TRUE);
				texMBut[j]->SetDADMgr(&dadMgr);
			}

			SetupLockButton(hwndDlg,IDC_LOCK_AD,FALSE);
			SetupLockButton(hwndDlg,IDC_LOCK_DS,FALSE);
			SetupPadLockButton(hwndDlg,IDC_LOCK_ADTEX, TRUE);

			LoadDialog(TRUE);
		}
		break;

		case WM_COMMAND: 
			{
			for ( int i=0; i<NMBUTS; i++) {
				if (id == texMButtonsIDC[i]) {
					PostMessage(hwmEdit,WM_TEXMAP_BUTTON, texmapFromMBut[i],(LPARAM)pMtl );
					UpdateMapButtons();
					goto exit;
					}
				}
			}
		    switch (id) {

				case IDC_NORMALIZE_CHECK:
					pShader->SetNormalizeOn( ! GetCheckBox(hwndDlg, IDC_NORMALIZE_CHECK) );
					UpdateHilite();
					NotifyChanged();
					UpdateMtlDisplay();
					break;
				case IDC_LOCK_AD:
					SetLockAD(IsButtonChecked(hwndDlg, IDC_LOCK_AD));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_DS:
					SetLockDS(IsButtonChecked(hwndDlg, IDC_LOCK_DS));
					UpdateMtlDisplay();
					break;
				
				case IDC_LOCK_ADTEX:{
					BOOL on = IsButtonChecked(hwndDlg, IDC_LOCK_ADTEX);
					SetLockADTex(on);
					UpdateMtlDisplay();
				} break;

			}
			break;
		case CC_COLOR_SEL: {
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
		}			
		break;
		case CC_COLOR_DROP:	{
			int id = LOWORD(wParam);
			SelectEditColor(ColorIDCToIndex(id));
			UpdateMtlDisplay();				
		}
		break;
		case CC_COLOR_BUTTONDOWN:
			theHold.Begin();
		 break;
		case CC_COLOR_BUTTONUP:
			if (HIWORD(wParam)) theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else theHold.Cancel();
			UpdateMtlDisplay();				
			break;
		case CC_COLOR_CHANGE: {			
			int id = LOWORD(wParam);
			int buttonUp = HIWORD(wParam); 
			int n = ColorIDCToIndex(id);
			if (buttonUp) theHold.Begin();
			DWORD curRGB = cs[n]->GetColor();
			SetMtlColor(n, curRGB, pShader, cs, curTime);
			if (buttonUp) {
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
				// DS: 5/11/99-  this was commented out. I put it back in, because
				// it is necessary for the Reset button in the color picker to 
				// update the viewport.				
				UpdateMtlDisplay();  
				}
		} break;
		case WM_PAINT: 
			if (!valid) {
				valid = TRUE;
				ReloadDialog();
				}
			return FALSE;
		case WM_CLOSE:
		case WM_DESTROY: 
			break;
		case CC_SPINNER_CHANGE: 
			if (!theHold.Holding()) theHold.Begin();
			switch (id) {
				case IDC_GLX_SPIN: 
					pShader->SetGlossiness(ALPHA_MAX - PcToFrac( glxSpin->GetIVal() ) * ALPHA_SZ, curTime); 
					UpdateHilite();
					break;
				case IDC_GLY_SPIN: 
					pShader->SetGlossinessY(ALPHA_MAX - PcToFrac(glySpin->GetIVal()) * ALPHA_SZ, curTime); 
					UpdateHilite();
					break;
				case IDC_SLEV_SPIN: 
					pShader->SetSpecularLevel(SPEC_MAX * PcToFrac(slevSpin->GetIVal()),curTime); 
					UpdateHilite();
					break;
				case IDC_DLEV_SPIN: 
					pShader->SetDiffuseLevel(PcToFrac(dlevSpin->GetIVal()),curTime); 
					break;
				//******** >>>><<<< required handling for opacity....must be present in all dialogs
				case IDC_TR_SPIN: 
					pMtl->SetOpacity(PcToFrac( trSpin->GetIVal()),curTime); 
					break;
			}
//			UpdateMtlDisplay();
		break;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			break;

		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP: 
			if (HIWORD(wParam) || msg==WM_CUSTEDIT_ENTER) 
				theHold.Accept(GetString(IDS_DS_PARAMCHG));
			else 
				theHold.Cancel();
			UpdateMtlDisplay();
			break;

    }
	exit:
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Spherify\spherify.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SPHERIFY.RC
//
#define IDS_SPHERIFY                    1
#define IDS_SPHERIFYMOD                 2
#define IDS_MAXADDITIONAL               3
#define IDS_PARAMETERS                  4
#define IDS_PERCENT                     5
#define IDS_SPHERIFYTITLE               6
#define IDD_SPHERIFY                    101
#define IDC_PERCENT_SPIN                1027
#define IDC_PERCENT                     1028

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Shaders\shaderUtil.cpp ===
//////////////////////////////////////////////////////////////////////
//
//	Shader UI Utilities
//
#include "shadersPch.h"
#include "shadersRc.h"
#include "shaders.h"
#include "shaderUtil.h"

static const float Pi = 3.1415926f;
static const float Pi2 = Pi * Pi;
static const float Pi2Ivr = 1.0f / Pi2;
static const float PiIvr = 1.0f / Pi;


Color OrenNayarIllum( Point3 N, Point3 L, Point3 V, float rough, Color rho, float NL )
{
//	float a = NL >= -1.0f ? float( acos( NL / Len(L) )) : AngleBetween( N, L );
	// use the non-uniform scale corrected NL
	if ( NL < -1.0f )
		NL = Dot( N, L );
	float a = float( acos( NL / Len(L) )) ;
	a = Bound( a, -Pi*0.49f, Pi*0.49f );
	float b = AngleBetween( N, V );
	MinMax( b, a ); // b gets min, a gets max

	float NV = Dot( N, V );

	//N.V is the length of the projection of v onto n; times N is a vector along N of that length
	// V - that pt gives a tangent vector in the plane of N, for measuring phi
	Point3 tanV = V - N * NV;
	Point3 tanL = L - N * NL;
	float w = Len( tanV ) * Len( tanL );
	float cosDPhi = (Abs(w) < 1e-4) ? 1.0f : Dot( tanV, tanL ) / w;
	if ( cosDPhi > 1.0f ) cosDPhi = 1.0f;
	else if ( cosDPhi < -1.0f ) cosDPhi = -1.0f;

	float bCube = (cosDPhi >= 0.0f) ? 0.0f : Cube( 2.0f * b * PiIvr );

	float sigma2 = Sqr( rough );
	float sigma3 = sigma2 / (sigma2 + 0.09f);
	float c1 = 1.0f - 0.5f * (sigma2 / (sigma2 + 0.33f));
	float c2 = 0.45f * sigma3 * (float(sin(a)) - bCube);
	float c3 = 0.125f * sigma3 * Sqr( 4.0f * a * b * Pi2Ivr );
	float tanB = float( tan(b) );
	float tanAB = float( tan( (a+b) * 0.5f ));
	tanB = Bound( tanB, -100, 100 );
	tanAB = Bound( tanAB, -100, 100 );

	Color o;
	float l1 = ( c1 + c2 * cosDPhi * tanB  + c3 * (1.0f - Abs( cosDPhi )) * tanAB );
	float l2 = 0.17f * (sigma2 / (sigma2 + 0.13f)) * ( 1.0f - cosDPhi * Sqr( 2.0f * b * PiIvr ));
	o.r =  l1 * rho.r + l2 * Sqr( rho.r ); 
	o.g =  l1 * rho.g + l2 * Sqr( rho.g ); 
	o.b =  l1 * rho.b + l2 * Sqr( rho.b ); 
	return UBound( o );

}

// perpendicular to N, in the U (reference) direction
Point3 GetTangent( ShadeContext &sc, int uvChan )
{
//	Point3 basisVecs[ 3 ];
//	sc.DPdUVW( basisVecs, uvChan ); // 0 is vtxclr, 1..n is uv channels, max_meshmaps in mesh.h
//	Point3 U = Normalize( basisVecs[0] );
	
	Point3 U = sc.VectorFrom( Point3( 0.01f, 0.0f, 1.0f ), REF_OBJECT );
Retry:
	U = Normalize( U );

	Point3 N = sc.Normal();			//assumed normalized

	// the line between the tip of vec[0] and its projection on N is tangent
	float UN = Dot( U, N );
	if ( Abs(UN) > 0.9995f ){
		U = sc.VectorFrom( Point3( 0.01f, 1.0f, 0.0f ), REF_OBJECT ); 
		goto Retry;
	}
	Point3 T = U - N * UN;
	T = Normalize( T );
	return T;
}


// specular reflectivity, no colors yet, all vectors assumed normalized 
float GaussHighlight( float gloss, float aniso, float orient,  
					  Point3& N, Point3& V, Point3& L, Point3& T, float* pNL )
{
	float out = 0.0f;

	float asz = (1.0f - gloss) * ALPHA_SZ;
	float ax = ALPHA_MIN + asz;
	float ay = ALPHA_MIN + asz * (1.0f-aniso);
//	DbgAssert( ax >= 0.0f && ay >= 0.0f );
	LBound( ax ); LBound( ay );

	Point3 H = Normalize(L - V); // (L + -V)/2
	float NH = DotProd(N, H);	 
	if (NH > 0.0f) {
		float axy = /* normalizeOn ? ax * ay : */ DEFAULT_GLOSS2;
		float norm = 1.0f / (4.0f * PI * axy );
		float NV = -DotProd(N, V );
		if ( NV <= 0.001f)
			NV = 0.001f;

		float NL = pNL ? *pNL : DotProd( N, L );
		float g = 1.0f / (float)sqrt( NL * NV );
		if ( g > 3.0f ) g = 3.0f;

		// Apply Orientation rotation here
		float or = orient * 180.0f;
		Point3 T1 = T;
		if ( or != 0.0f )
			T1 = RotateVec( T, N, DegToRdn(or));

		// get binormal
		Point3 B = CrossProd( T1, N );

		float x = Dot( H, T1 ) / ax;
		float y = Dot( H, B ) / ay;
		float e = (float)exp( -2.0 * (x*x + y*y) / (1.0+NH) );

		out = norm * g * e;
	}
	return SPEC_MAX * out;	// does not have speclev or light color or kL
}

float GaussHiliteCurve2( float x, float y, float sLevel, float gloss, float aniso )
{
	double axy = DEFAULT_GLOSS2; 
	double asz = (1.0f - gloss) * ALPHA_SZ; 
	double ax = ALPHA_MIN + asz;
	double ay = ALPHA_MIN + asz * (1.0f - aniso) ;
	double ax2 = ax * ax; 
	double ay2 = ay * ay; 
	
	double t, a;
	double l = sqrt( x*x + y*y );
	if ( l == 0.0 ) {
		a = t = 0.0;
	} else {
		x /= float(l);	y /= float(l);
		t = tan( l*PI*0.5 );
		a = x*x/ax2 + y*y/ay2;
	}
	return SPEC_MAX * sLevel*(float)(exp( -(t * t) * a ) / (4.0 * PI * axy));  
}

//////////////////////////////////////////////////////////////////////////////
//
//	Combine Components....Adding & compositing
//
void CombineComponentsAdd( IllumParams& ip )
{
	ip.finalC = ip.finalOpac * (ip.ambIllumOut + ip.diffIllumOut  + ip.selfIllumOut)
			+ ip.specIllumOut + ip.reflIllumOut + ip.transIllumOut; 
}

void CombineComponentsComp( IllumParams& ip )
{
	Color spec, diff, rem;
	spec = ip.specIllumOut + ip.reflIllumOut;
	rem = 1.0f - spec;
	rem = Bound( rem );
	diff = ip.ambIllumOut + ip.diffIllumOut  + ip.selfIllumOut;
	ip.finalC = spec + ip.finalOpac * rem * diff +  rem * ip.transIllumOut; 
}

//////////////////////////////////////////////////////////////////////////////
//
//	transpColor utility
//
Color transpColor( ULONG type, float opac, Color filt, Color diff )
{
	// Compute the color of the transparent filter color
	if ( type == TRANSP_ADD ) { // flags & STDMTL_ADD_TRANSP) {
		float f = 1.0f - opac;
		return Color(f, f, f);   

	} else if ( type == TRANSP_FILTER ) { //flags & STDMTL_FILT_TRANSP ){
		// Transparent Filter color mapping
		if (opac>0.5f) {
			// darken as opac goes ( 0.5--> 1.0)
			// so that max component reaches 0.0f when opac reaches 1.0
			// find max component of filt
			float m = Max(filt);
			float d = 2.0f*(opac-.5f)*m;
			Color fc = filt-d;
			fc = LBound( fc );
			return fc;
		} else {
			// lighten as opac goes ( 0.5--> 0.0)
			// so that min component reaches 1.0f when opac reaches 1.0
			// find min component of filt
			float m = Min(filt);
			float d = (1.0f-2.0f*opac)*(1.0f-m);
			Color fc = filt+d;
			fc = UBound( fc );
			return fc;
		}

	} else {
		// original 3DS transparency 
		Color f = (1.0f-diff);  
		return  (1.0f-opac)*f;
	}

}

//////////////////////////////////////////////////////////////////////////////
//
//	UI utilities
//
static HIMAGELIST hLockButtons = NULL;
extern HINSTANCE hInstance;

// mjm - begin - 5.10.99
class ResourceDelete
{
public:
	ResourceDelete() {}
	~ResourceDelete() { if (hLockButtons) ImageList_Destroy(hLockButtons); }
};

static ResourceDelete theResourceDelete;
// mjm - end

BOOL IsButtonChecked(HWND hWnd,int id)
	{
	ICustButton *iBut;
	BOOL res;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	res = iBut->IsChecked();
	ReleaseICustButton(iBut);
	return res;
	}

void CheckButton(HWND hWnd,int id, BOOL check) {
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetCheck(check);
	ReleaseICustButton(iBut);
	}

void SetupLockButton(HWND hWnd,int id, BOOL check)
	{
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetImage(hLockButtons,0,1,0,1,16,15);
	iBut->SetType(CBT_CHECK);
	ReleaseICustButton(iBut);
	}

void SetupPadLockButton(HWND hWnd,int id, BOOL check) {
	ICustButton *iBut;
	iBut = GetICustButton(GetDlgItem(hWnd,id));
	iBut->SetImage(hLockButtons,2,2,2,2,16,15);
	iBut->SetType(CBT_CHECK);
	ReleaseICustButton(iBut);
	}
 
void LoadStdShaderResources()
	{
	static BOOL loaded=FALSE;
	if (loaded) return;
	loaded = TRUE;	
	HBITMAP hBitmap, hMask;

	hLockButtons = ImageList_Create(16, 15, TRUE, 2, 0);
	hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DMTL_BUTTONS));
	hMask   = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DMTL_MASKBUTTONS));
	ImageList_Add(hLockButtons,hBitmap,hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	}


//-HiLite Curve Control------------------------------------------------------

static void VertLine(HDC hdc,int x, int ystart, int yend) 
{
	MoveToEx(hdc, x, ystart, NULL); 
	if (ystart <= yend)
		LineTo(hdc, x, yend+1);
	else 
		LineTo(hdc, x, yend-1);
}

void DrawHilite(HDC hdc, Rect& rect, Shader* pShader )
{
int w,h,npts,xcen,ybot,ytop,ylast,i,iy;

	HPEN linePen = (HPEN)GetStockObject(WHITE_PEN);
	HPEN fgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNFACE));
	HPEN bgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNSHADOW));

	w = rect.w();
	h = rect.h()-3;
	npts = (w-2)/2;
	xcen = rect.left+npts;
	ybot = rect.top+h;
	ytop = rect.top+2;
	ylast = -1;
	for (i=0; i<npts; i++) {
		float v = pShader->EvalHiliteCurve( (float)i/((float)npts*2.0f) );
		if (v>2.0f) v = 2.0f; // keep iy from wrapping
		iy = ybot-(int)(v*((float)h-2.0f));

		if (iy<ytop) iy = ytop;

		SelectPen(hdc, fgPen);
		VertLine(hdc,xcen+i,ybot,iy);
		VertLine(hdc,xcen-i,ybot,iy);

		if (iy-1>ytop) {
			// Fill in above curve
			SelectPen(hdc,bgPen);
			VertLine(hdc,xcen+i, ytop, iy-1);
			VertLine(hdc,xcen-i, ytop, iy-1);
			}
		if (ylast>=0) {
			SelectPen(hdc,linePen);
			VertLine(hdc,xcen+i-1,iy-1,ylast);
			VertLine(hdc,xcen-i+1,iy-1,ylast);
			}

		ylast = iy;
	}

	SelectObject( hdc, linePen );
	DeleteObject(fgPen);
	DeleteObject(bgPen);
	WhiteRect3D(hdc, rect, 1);
}

LRESULT CALLBACK HiliteWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = GetWindowLong(hwnd,GWL_ID);
	HWND hwParent = GetParent(hwnd);
	ShaderParamDlg *theDlg = (ShaderParamDlg *)GetWindowLong(hwParent, GWL_USERDATA);
	if (theDlg==NULL) return FALSE;

    switch (msg) {
		case WM_COMMAND: 	
		case WM_MOUSEMOVE: 	
		case WM_LBUTTONUP: 
		case WM_CREATE:
		case WM_DESTROY: 
		break;

		case WM_PAINT: 	
		{
			PAINTSTRUCT ps;
			Rect rect;
			HDC hdc = BeginPaint( hwnd, &ps );
			if (!IsRectEmpty(&ps.rcPaint)) {
				GetClientRect( hwnd, &rect );
				Shader* pShader = theDlg->GetShader();
				DrawHilite(hdc, rect, pShader );
			}
			EndPaint( hwnd, &ps );
		}													
		break;
	}
	return DefWindowProc(hwnd,msg,wParam,lParam);
} 

// iso projection of 2 orthogonal highlight curves
void DrawHilite2(HDC hdc, Rect& rect, Shader* pShader, int layer )
{
int w,h,npts,xcen,ybot,ytop,ylast,i,iy, off, vals[200];
float ybr, ybl;

	HPEN linePen = (HPEN)GetStockObject(WHITE_PEN);
	HPEN fgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNFACE));
	HPEN fg2Pen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNHILIGHT));
	HPEN bgPen = CreatePen(PS_SOLID,0,GetSysColor(COLOR_BTNSHADOW));

	w = rect.w();
	assert( w/2 < 200 );	// 200 vals saved for visibility
	h = rect.h()-3;
	npts = (w-2)/2;
	off = h / 6;
	float slope = float(h-off-off)/w;
	ybot = rect.top+h;
	ytop = rect.top+2;

	// first the X curve
	ybr = ybl = float(rect.top+h - 2.5* off);
	xcen = rect.left+npts;
	ylast = -1;
	for (i=0; i<npts; i++) {
		float v = pShader->EvalHiliteCurve2( (float)i/((float)npts*2.0f), 0.0f, layer );
		if (v>2.0f) v = 2.0f; // keep iy from wrapping
		iy = (int)(v* 0.6f * ((float)h-2.0f));

		int r = int( ybr + 0.5f );
		if ( r > ybot ) r = ybot;
		int l = int( ybl + 0.5f  );
		if ( l > ybot ) l = ybot;

		int ry = r - iy;
		if (ry<ytop) ry = ytop;
		if (ry>ybot) ry = ybot;
		vals[i] = ry;	// save for visibility

		int ly = l - iy;
		if (ly<ytop) ly = ytop;
		if (ly>ybot) ly = ybot;

		SelectPen(hdc, fgPen);
		VertLine(hdc,xcen+i, r, ry); // start at center & spread out on both sides
		VertLine(hdc,xcen-i, l, ly);

		SelectPen(hdc,bgPen);	  		   // Fill in below baseline
		VertLine(hdc,xcen+i, ybot, r+1);
		VertLine(hdc,xcen-i, ybot, l+1);

		VertLine(hdc,xcen+i, ytop, ry-1);
		VertLine(hdc,xcen-i, ytop, ly-1);	// fill in above curve

//		if (ylast>=0) {
//			SelectPen(hdc,linePen);
//			VertLine(hdc, xcen+i-1, iy-1, ylast); // white dot marks curve
//			VertLine(hdc, xcen-i+1, iy-1, ylast);
//		}

		ylast = iy;
		ybr += slope;
		ybl += -slope;
	}

	// now do the Y curve
	ybr = ybl = float(rect.top+h - 2.5* off);
	xcen = rect.left+npts - 1;
	ylast = -1;
	for (i=0; i < npts; i++) {
		float v = pShader->EvalHiliteCurve2( 0.0f, (float)i/((float)npts*2.0f), layer );
		if (v>2.0f) v = 2.0f; // keep iy from wrapping
		iy = (int)(v* 0.6f * ((float)h-2.0f));

		int r = int( ybr + 0.5f );
		if ( r > ybot ) r = ybot;
		int l = int( ybl + 0.5f  );
		if ( l > ybot ) l = ybot;
		
		int ry = r - iy;
		if (ry<ytop) ry = ytop;
		if (ry>ybot) ry = ybot;

		int ly = l - iy;
		if (ly<ytop) ly = ytop;
		if (ly>ybot) ly = ybot;

		SelectPen(hdc, fg2Pen);
		VertLine(hdc,xcen-i, l, ly);	// left side always visible..in front

		if ( r <= vals[i] )
			VertLine(hdc,xcen+i, r, ry); // start at center & spread out on both sides
		else if ( ry <= vals[i] )
			VertLine(hdc,xcen+i, vals[i]-1, ry); // start at center & spread out on both sides

//		if (ylast>=0) {
//			SelectPen(hdc,linePen);
//			VertLine(hdc, xcen+i-1, iy-1, ylast); // white dot marks curve
//			VertLine(hdc, xcen-i+1, iy-1, ylast);
//		}

		ylast = iy;
		ybr += -slope;
		ybl += slope;
	}

	SelectObject( hdc, linePen );
	DeleteObject(fgPen);
	DeleteObject(fg2Pen);
	DeleteObject(bgPen);
	WhiteRect3D(hdc, rect, 1);
}

LRESULT CALLBACK Hilite2WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = GetWindowLong(hwnd,GWL_ID);
	HWND hwParent = GetParent(hwnd);
	ShaderParamDlg *theDlg = (ShaderParamDlg *)GetWindowLong(hwParent, GWL_USERDATA);
	if (theDlg==NULL) return FALSE;

    switch (msg) {
		case WM_COMMAND: 	
		case WM_MOUSEMOVE: 	
		case WM_LBUTTONUP: 
		case WM_CREATE:
		case WM_DESTROY: 
		break;

		case WM_PAINT: 	
		{
			PAINTSTRUCT ps;
			Rect rect;
			HDC hdc = BeginPaint( hwnd, &ps );
			if (!IsRectEmpty(&ps.rcPaint)) {
				GetClientRect( hwnd, &rect );
				Shader* pShader = theDlg->GetShader();
				DrawHilite2(hdc, rect, pShader );
			}
			EndPaint( hwnd, &ps );
		}													
		break;
	}
	return DefWindowProc(hwnd,msg,wParam,lParam);
} 

LRESULT CALLBACK Hilite2Layer1WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = GetWindowLong(hwnd,GWL_ID);
	HWND hwParent = GetParent(hwnd);
	ShaderParamDlg *theDlg = (ShaderParamDlg *)GetWindowLong(hwParent, GWL_USERDATA);
	if (theDlg==NULL) return FALSE;

    switch (msg) {
		case WM_PAINT: 	
		{
			PAINTSTRUCT ps;
			Rect rect;
			HDC hdc = BeginPaint( hwnd, &ps );
			if (!IsRectEmpty(&ps.rcPaint)) {
				GetClientRect( hwnd, &rect );
				Shader* pShader = theDlg->GetShader();
				DrawHilite2(hdc, rect, pShader, 1 );
			}
			EndPaint( hwnd, &ps );
		}													
		break;
	}
	return DefWindowProc(hwnd,msg,wParam,lParam);
} 

LRESULT CALLBACK Hilite2Layer2WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) 
{
	int id = GetWindowLong(hwnd,GWL_ID);
	HWND hwParent = GetParent(hwnd);
	ShaderParamDlg *theDlg = (ShaderParamDlg *)GetWindowLong(hwParent, GWL_USERDATA);
	if (theDlg==NULL) return FALSE;

    switch (msg) {
		case WM_PAINT: 	
		{
			PAINTSTRUCT ps;
			Rect rect;
			HDC hdc = BeginPaint( hwnd, &ps );
			if (!IsRectEmpty(&ps.rcPaint)) {
				GetClientRect( hwnd, &rect );
				Shader* pShader = theDlg->GetShader();
				DrawHilite2(hdc, rect, pShader, 2 );
			}
			EndPaint( hwnd, &ps );
		}													
		break;
	}
	return DefWindowProc(hwnd,msg,wParam,lParam);
} 

void UpdateHilite( HWND hwHilite, Shader* pShader, int layer  )
{
Rect r;

		HDC hdc = GetDC( hwHilite );
		GetClientRect( hwHilite, &r );
		DrawHilite( hdc, r, pShader );
		ReleaseDC( hwHilite, hdc );
}


void UpdateHilite2( HWND hwHilite, Shader* pShader, int layer )
{
Rect r;

		HDC hdc = GetDC( hwHilite );
		GetClientRect( hwHilite, &r );
		DrawHilite2( hdc, r, pShader, layer );
		ReleaseDC( hwHilite, hdc );
}


////////////////////////////////////////////////////////////////////////

Color GetMtlColor( int i, Shader* pShader ) 
{
	switch(i) {
		case 0:  return pShader->GetAmbientClr(0,0); 
		case 1:  return pShader->GetDiffuseClr(0,0);
		case 2:  return pShader->GetSpecularClr(0,0);
		case 3:  return pShader->GetSelfIllumClr(0,0);
		default: return Color(0,0,0);
	}
}

TCHAR *GetColorName( int i )
{
	switch(i) {
		case 0:  return GetString(IDS_DS_AMBIENT);	 
		case 1:  return GetString(IDS_DS_DIFFUSE);	 
		case 2:  return GetString(IDS_DS_SPECULAR);	 
		case 3:  return GetString(IDS_KE_SELFILLUM_CLR);	 
		default: return GetString(IDS_KE_NOSUCH_CLR);	 
	}
}

void SetMtlColor(int i, Color c, Shader* pShader, IColorSwatch** cs, TimeValue t)
{
	switch(i) {
		case 0: //ambient
			pShader->SetAmbientClr(c,t); 
			if ( pShader->GetLockAD() ){
				pShader->SetDiffuseClr(c, t);
				cs[1]->SetColor( c );
				if (pShader->GetLockDS() ){
					pShader->SetSpecularClr(c,t);
					cs[2]->SetColor(c);
				}
			}
			break;
		case 1: //diffuse
			pShader->SetDiffuseClr(c,t); 
			if (pShader->GetLockAD() ){
				pShader->SetAmbientClr(c,t);
				cs[0]->SetColor(c);
			}
			if ( pShader->GetLockDS() ){
				pShader->SetSpecularClr(c,t);
				cs[2]->SetColor(c);
				}
			break;
		case 2: // specular
			pShader->SetSpecularClr(c,t); 
			if (pShader->GetLockDS() ){
				pShader->SetDiffuseClr(c,t);
				cs[1]->SetColor(c);
				if (pShader->GetLockAD() ){
					pShader->SetAmbientClr(c,t);
					cs[0]->SetColor(c);
					}
				}
			break;
		case 3: 
			pShader->SetSelfIllumClr(c,t); 
			break;
	}
}

///////////////////////////////////////////////////////////////////////////
// utility math routines
//
Point3 RotateVec( Point3& p, Point3& a, float rdn )
{
	float c = float( cos( rdn ));
	float t = 1 - c;
	float s = float( sin( rdn ));
	float txy = t * a.x * a.y;
	float tyz = t * a.y * a.z;
	float txz = t * a.x * a.z;
	float sx = s * a.x;
	float sy = s * a.y;
	float sz = s * a.z;

	Point3 out;
	out.x = p.x *(t* a.x * a.x + c) + p.y * (txy - sz) + p.z * (txz + sy);
	out.y = p.x *(txy + sz) + p.y * (t* a.y * a.y + c) + p.z * (tyz - sx);
	out.z = p.x *(txz - sy) + p.y * (tyz + sx) + p.z * (t* a.z * a.z + c);

	return out;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Spherify\spherify.cpp ===
/*===========================================================================*\
 |    File: spherify.cpp
 |
 | Purpose: Project the verticies of an object onto the surface of a sphere.
 |			Note this modifier does not support sub-object selection.
 |
 | History: Mark Meier, Begun 09/25/95, Last change 09/26/95.
 |          MM, 12/19/96, Brought it into the modern era...
\*===========================================================================*/
#include "max.h"			// Main MAX include file
#include "iparamm.h"		// Parameter Map include file
#include "spherify.h"		// Resource editor include file

/*===========================================================================*\
 | Misc Defines
\*===========================================================================*/
// The unique ClassID
#define SPHERIFY_CLASS_ID	Class_ID(0xDE17A34E, 0x8A41E2A0)

// This is the name that will appear in the Modifier stack
#define INIT_MOD_NAME			GetString(IDS_SPHERIFY)

// Name used for debugging
#define CLASSNAME				GetString(IDS_SPHERIFYMOD)

// This is the name on the creation button
#define SPHERIFY_CLASSNAME		GetString(IDS_SPHERIFY)

// This is the category the button goes into
#define CATEGORY_NAME			GetString(IDS_MAXADDITIONAL)

// The name of the parameter block sub-anim
#define PARAMETERS_NAME			GetString(IDS_PARAMETERS)

// The text string for track view for the percentage parameter
#define PERCENT_PARAM_NAME		GetString(IDS_PERCENT)

// Parameter block indicies
#define PB_PERCENT 0

// The DLL instance handle
HINSTANCE hInstance;

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

/*===========================================================================*\
 | Class Definitions:
\*===========================================================================*/
class SpherifyMod : public Modifier {
  public:
	SpherifyMod();

	// Class vars
	static Interface *ip;
	static ICustEdit *percentEdit;
	static ISpinnerControl *percentSpin;	
	static IParamMap *pmap;

	// The parameter block for the percentage parameter
	IParamBlock *pblock;

	// ---- Methods from Animatable ----
	void DeleteThis() { delete this; }
	void GetClassName(TSTR& s) { s= CLASSNAME; }  
	virtual Class_ID ClassID() { return SPHERIFY_CLASS_ID;}
	SClass_ID SuperClassID() { return OSM_CLASS_ID; }
	void BeginEditParams(IObjParam *ip, ULONG flags, Animatable *prev);
	void EndEditParams(IObjParam *ip,ULONG flags, Animatable *next);
	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i) { return pblock; }
	TSTR SubAnimName(int i) { return PARAMETERS_NAME;}		

	// ---- Methods from ReferenceMaker ----
	RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget,
	   PartID& partID, RefMessage message );
	int NumRefs() { return 1; }
	RefTargetHandle GetReference(int i) { return pblock; }
	void SetReference(int i, RefTargetHandle rtarg) {
		pblock = (IParamBlock*)rtarg;
	}

	// ---- Methods from ReferenceTarget ----
	RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// ---- Inherited virtual methods from BaseObject ----
	// This is the name that appears in the history list (modifier stack).
	TCHAR *GetObjectName() { return INIT_MOD_NAME; }
	CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 
 	BOOL ChangeTopology() {return FALSE;}

	// ---- Methods from Modifier ----
	ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO;}
	ChannelMask ChannelsChanged() {return PART_GEOM;}
	Class_ID InputType() { return defObjectClassID; }
	void ModifyObject(TimeValue t, ModContext &mc, 
		ObjectState *os, INode *node);

	// ---- Local methods ----
	float GetPercent(TimeValue t);
	Deformer& GetDeformer(TimeValue t, ModContext &mc, Matrix3 mat, 
		Matrix3 invmat);
	Interval SpherifyValidity(TimeValue t);
};

// This class is our deformer.  It provides some variables to store 
// data associated with the deformation, and a single method, Map, 
// which is called to deform each point.
class SpherifyDeformer : public Deformer {
  public:
	float cx, cy, cz, xsize, ysize, zsize, size, percent;
	Matrix3 tm, invtm;
	Box3 bbox;

	SpherifyDeformer();
	SpherifyDeformer(TimeValue t, ModContext &mc, Matrix3 mat,
		Matrix3 invmat, float per);

	// This is the method called by the Deform method one point at a time.
	Point3 Map(int i, Point3 p);
};

/*===========================================================================*\
 | Parameter Map and Parameter Block User Interface Stuff
\*===========================================================================*/
static ParamUIDesc descParam[] = {
	ParamUIDesc(PB_PERCENT, EDITTYPE_FLOAT, IDC_PERCENT, IDC_PERCENT_SPIN,
		0.0f, 100.0f, 1.0f),
};
#define DESC_LENGTH 1

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 }
};
#define PBLOCK_LENGTH		1
#define CURRENT_VERSION		0

/*===========================================================================*\
 | User Interface stuff...
\*===========================================================================*/
void SpherifyMod::BeginEditParams(IObjParam *ip, 
	ULONG flags, Animatable *prev) {
	this->ip = ip;
	// Create and add the Alter rollup to the command panel...
	pmap = CreateCPParamMap(descParam, DESC_LENGTH,
		pblock, ip, hInstance, MAKEINTRESOURCE(IDD_SPHERIFY), 
		GetString(IDS_PARAMETERS), 0);
}

void SpherifyMod::EndEditParams( IObjParam *ip, ULONG flags, 
	Animatable *next) {
	// Delete the parameter map
	if (pmap) { DestroyCPParamMap(pmap); }
	this->ip = NULL;
	this->pmap = NULL;
}

SpherifyMod::SpherifyMod() {
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));	
	pblock->SetValue(PB_PERCENT, 0, 100.0f);
}

// Initialize the class variables.
Interface *SpherifyMod::ip = NULL;
ICustEdit *SpherifyMod::percentEdit;
ISpinnerControl *SpherifyMod::percentSpin = NULL;
IParamMap *SpherifyMod::pmap = NULL;

/*===========================================================================*\
 | Modification stuff...
\*===========================================================================*/
float sign(float x) { return (x < 0.0f ? -1.0f : 1.0f); }

// This method, called by the system, modifies the items...
void SpherifyMod::ModifyObject(TimeValue t, ModContext &mc, 
	ObjectState *os, INode *node) {	

	Matrix3 mat, invmat;

	// Get the deformation space tm from the ModContext.  We use this to
	// transform our points in and out of deformation space.
	if (mc.tm)
		mat = *mc.tm;		
	else
		mat.IdentityMatrix();	
	
	// Compute the tm's inverse
	invmat = Inverse(mat);
 
	// Call the Deform method of the object passing it our deformer.
	// The Deform method of the object calls the Map method of the 
	// deformer we pass one point at a time.
	os->obj->Deform(&GetDeformer(t, mc, mat, invmat), TRUE);

	// This informs the system that the object may need to be re-evaluated
	// if the user moves to a new time.  We pass the channel we have 
	// modified, and the interval of our modification.
	os->obj->UpdateValidity(GEOM_CHAN_NUM, SpherifyValidity(t));
}

Interval SpherifyMod::SpherifyValidity(TimeValue t) {
	float p;
	Interval valid = FOREVER;
	pblock->GetValue(PB_PERCENT, t, p, valid);
	return valid;
}

RefTargetHandle SpherifyMod::Clone(RemapDir& remap) {
	SpherifyMod* newmod = new SpherifyMod();	
	newmod->ReplaceReference(0, pblock->Clone(remap));
	return(newmod);
}

RefResult SpherifyMod::NotifyRefChanged(Interval changeInt,
	RefTargetHandle hTarget, PartID& partID, RefMessage message) {

	switch (message) {
		case REFMSG_CHANGE:
			if (pmap && pmap->GetParamBlock()==pblock) {
				pmap->Invalidate();
				}
			break;

		case REFMSG_GET_PARAM_DIM: { 
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_PERCENT:
					gpd->dim = defaultDim;
					break;
			};
			return REF_STOP; 
		}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_PERCENT:
					gpn->name = PERCENT_PARAM_NAME;
					break;
			};
			return REF_STOP; 
		}
	}
	return REF_SUCCEED;
}

float SpherifyMod::GetPercent(TimeValue t) {
	float f;
	Interval valid;
	pblock->GetValue(PB_PERCENT, t, f, valid);
	return f;
}


SpherifyDeformer::SpherifyDeformer() {
	tm.IdentityMatrix();
	invtm = Inverse(tm);
};

// This method returns our deformer object
Deformer& SpherifyMod::GetDeformer(TimeValue t, ModContext &mc, 
	Matrix3 mat, Matrix3 invmat) {
	static SpherifyDeformer deformer;
	deformer = SpherifyDeformer(t, mc, mat, invmat, GetPercent(t));
	return deformer;
};

// This constructor stores some data we get from the 
// ModContext which we use during the deformation.
SpherifyDeformer::SpherifyDeformer(TimeValue t, ModContext &mc, 
	Matrix3 mat, Matrix3 invmat, float per) {

	// Save the tm and inverse tm
	tm = mat; invtm = invmat;

	// Save the bounding box
	assert(mc.box);
	bbox = *mc.box;

	// Compute the size and center
	xsize = bbox.pmax.x - bbox.pmin.x;
	ysize = bbox.pmax.y - bbox.pmin.y;
	zsize = bbox.pmax.z - bbox.pmin.z;
	size=(xsize>ysize) ? xsize:ysize;
	size=(zsize>size) ? zsize:size;
	size /= 2.0f;
	cx = bbox.Center().x;
	cy = bbox.Center().y;
	cz = bbox.Center().z;

	// Get the percentage to spherify at this time
	percent = per/100.0f;
};

// This is the method which deforms a single point.
Point3 SpherifyDeformer::Map(int i, Point3 p) {
	float x, y, z;
	float xw,yw,zw,vdist,mfac;
	float dx, dy, dz;
	
	// Multiply by the ModContext tm
	p = p*tm;

	// Spherify the point
	x = p.x; y = p.y; z = p.z;
	xw= x-cx; yw= y-cy; zw= z-cz;
	if(xw==0.0 && yw==0.0 && zw==0.0)
		xw=yw=zw=1.0f;
	vdist=(float) sqrt(xw*xw+yw*yw+zw*zw);
	mfac=size/vdist;
	dx = xw+sign(xw)*((float) (fabs(xw*mfac)-fabs(xw))*percent);
	dy = yw+sign(yw)*((float) (fabs(yw*mfac)-fabs(yw))*percent);
	dz = zw+sign(zw)*((float) (fabs(zw*mfac)-fabs(zw))*percent);
	x=dx+cx; y=dy+cy; z=dz+cz;

	// Mutiliply the point by the inverse of the ModContext tm and 
	// return the point.
	p.x = x; p.y = y; p.z = z;
	p = p*invtm;
	return p;
}

/*===========================================================================*\
 | Class Descriptor
\*===========================================================================*/
class SpherifyClassDesc : public ClassDesc {
  public:
	int				IsPublic() { return 1; }
	void			*Create(BOOL loading=FALSE) { return new SpherifyMod(); }
	const TCHAR		*ClassName() { return SPHERIFY_CLASSNAME; }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return SPHERIFY_CLASS_ID; }
	const TCHAR		*Category() { return CATEGORY_NAME;  }
};
static SpherifyClassDesc SpherifyCD;

/*===========================================================================*\
 | DLL/Lib Functions
\*===========================================================================*/
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
	
	return(TRUE);
}

__declspec( dllexport ) int LibNumberClasses() { 
	return 1; 
}

__declspec( dllexport ) ClassDesc *LibClassDesc(int i) { 
	return &SpherifyCD; 
}

__declspec( dllexport ) const TCHAR *LibDescription() {
	return GetString(IDS_SPHERIFYTITLE); 
}

__declspec( dllexport ) ULONG LibVersion() { 
	return VERSION_3DSMAX; 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Stretch\stretch.h ===
/**********************************************************************
 *<
	FILE: stretch.h

	DESCRIPTION:

	CREATED BY: Keith Trummel

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __STRETCH__H
#define __STRETCH__H

#define STRETCHOSM_CLASS_ID 			0x100B0

extern ClassDesc* GetStretchModDesc();
extern ClassDesc* GetStretchWSMDesc();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\autovis.H ===
/*===========================================================================*\
	FILE: autovis.h

	DESCRIPTION: Code from Autovision.

	HISTORY: Adapted by John Hutchinson 10/08/97 
			

	Copyright (c) 1996, All Rights Reserved.
 \*==========================================================================*/

#define TWO_PI 6.283185307
#define FTWO_PI 6.283185307f
#define EPOCH 1721424.5f
#define SECS_PER_DAY 86400

///////////////////////////////////////////////////////////////////
// Sun locator code from AutoVision
//////////////////////////////////////////////////////////////////
static double dtr(double dang){return TWO_PI * dang/360.0;}
static double rtd(double rang){return 360.0 * rang/TWO_PI;}
static float fdtr(float dang){return FTWO_PI * dang/360.0f;}
static float frtd(float rang){return 360.0f * rang/FTWO_PI;}
static double kepler(double m, double ecc);
static double gregorian2julian(unsigned short month, unsigned short day, unsigned short year);
static void altaz(double *az, double *alt, double *s_time, double sunra,
                  double sundec, double longitude, double latitude,
                  double jdate, double jtime);
static void rotate(double pt[3], double matrix[3][3]);
static double distance(double pt1[3], double pt2[3]);
static void precession(double p[3][3], double jdate);
static void ecliptic(double planet[3], double v_planet[3], double jdate);
static void barycentric(double earth[3], double v_earth[3], double jdate);
static void topocentric(double earth[3], double v_earth[3], double lon,
                        double lat, double jdate, double jtime);
static void nutation(double *ra, double *dec, double jdate);
static int sunloc(void);
static void julian2gregorian(double jdate, unsigned short* month, unsigned short* day, unsigned short* year);
static BOOL isleap( long year);
/* Date and time of creation September 23, 1991 */

/* Date of epoch for the orbital elements */
double edate[2] = {2447920.5, 2448120.5};
double ee = 23.439291; /* Obliquity for date of epoch J2000.0 */

#define fixangle(x)  ((x) - 360.0 * (floor ((x) / 360.0)))
#define angle(x,y) (atan((x)/(y))+((y)<=0.0?PI:(x)<=0.0?2*PI:0.0))
#define sqr(x) ((x)*(x))
#define ER2AU (6378160.0/149600.0e6) /* A.U per earth radii */


static int mdays[2][12] = {
    {0,31,59,90,120,151,181,212,243,273,304,334},
    {0,31,60,91,121,152,182,213,244,274,305,335}
};

/***************************************************************************/
static double
gregorian2julian(long month, long day, long year)
{


   long ydays, ydays1;

   ydays1 = 365*year+year/4-year/100+year/400;
   year--;
   ydays = 365*year+year/4-year/100+year/400;
   return ydays+mdays[(ydays1-ydays)==366?1:0][month-1]+day+1721424.5f;
}

BOOL isleap( long year){
	long ydays, ydays1;

   ydays1 = 365*year+year/4-year/100+year/400;
   year--;
   ydays = 365*year+year/4-year/100+year/400;
   return (ydays1-ydays)==366?TRUE:FALSE;
}



void
julian2gregorian(double jdate, int* month, int* day, int* year){
	long ijd, a, b, c, d, e, g;
	double fjd;

	jdate += 0.5f;
	ijd = (long) jdate;	 //whole part
	fjd = jdate-ijd;	  //decimal part
	if(ijd>2299160){
		a = (long) ((ijd- 1867216.25) / 36524.25);
		b = ijd+ 1 + a - (int)(a/4);
	} else {
		b=ijd;
	}

	c=b+1524;
	d= (long) ((c-122.1)/365.25);
	e= (long) (365.25*d);
	g= (long) ((c-e)/30.6001);

	//round off to closest day
	*day = (int)(c-e+fjd-(int) (30.6001*g)+0.5f);

	
	if(g<13.5)
		*month = g-1;
	else
		*month= g-13;
	
	
	if(*month>2.5)
		*year = d-4716;
	else
		*year = d-4715;

}



/***************************************************************************/
static void
altaz(double *az, double *alt, double *s_time, double sunra, double sundec,
      double longitude, double latitude, double jdate, double jtime)
{
   double gmt,h, a,b,c;
   double hours, minutes;

   /* Calculate gmt sidereal time */
   gmt = 6.6265313+0.0657098243*(jdate-jtime-2447891.5)+1.00273791*24.0*jtime;
   gmt = dtr(gmt * 360.0 / 24.0);
   h = gmt - longitude - sunra;

   /* Calculate azimuth and altitude */
   a = -cos(sundec)*sin(h);
   b = sin(sundec)*cos(latitude)-cos(sundec)*cos(h)*sin(latitude);
   c = sin(sundec)*sin(latitude)+cos(sundec)*cos(h)*cos(latitude);

   *alt = asin(c);
   *az = angle(a,b);

   h = rtd(h);  /* now in degrees */
   h = h * (24.0 / 360.0); /* convert to hours */
   hours = (12 + (int)floor(h)) % 24;  /* nuke the extra days */
   minutes = h - floor(h);  /* get the hour fractions back */
   *s_time = hours + minutes;
}

/***************************************************************************/
static void
rotate(double pt[3], double matrix[3][3])
{
   double newpt[3];
   int i,j;

   for(i=0; i<3; i++) {
      newpt[i] = 0;
      for(j=0;j<3;j++)
         newpt[i] = newpt[i] + pt[i]*matrix[j][i];
   }
   for(i=0;i<3;i++)
      pt[i] = newpt[i];
}

/**************************************************************************/
static double
distance(double pt1[3], double pt2[3])
{
   return sqrt(sqr(pt1[0]-pt2[0]) + sqr(pt1[1]-pt2[1]) + sqr(pt1[2]-pt2[2]));
}

/***************************************************************************/
static void
precession(double p[3][3], double jdate)
{
   double t,zeta,z,theta;

   t = (jdate-2451545.0)/36525.0;
   zeta = ((0.0000050*t+0.0000839)*t+0.6406161)*t;
   z = ((0.0000051*t+0.0003041)*t+0.6406161)*t;
   theta = ((-0.0000116*t-0.0001185)*t+0.5567530)*t;

   zeta = dtr(zeta); z = dtr(z); theta = dtr(theta);
   
   p[0][0] = cos(zeta)*cos(theta)*cos(z) - sin(zeta)*sin(z);
   p[0][1] = cos(zeta)*cos(theta)*sin(z) + sin(zeta)*cos(z);
   p[0][2] = cos(zeta)*sin(theta);
   p[1][0] = -sin(zeta)*cos(theta)*cos(z) - cos(zeta)*sin(z);
   p[1][1] = -sin(zeta)*cos(theta)*sin(z) + cos(zeta)*cos(z);
   p[1][2] = -sin(zeta)*sin(theta);
   p[2][0] = -sin(theta)*cos(z);
   p[2][1] = -sin(theta)*sin(z);
   p[2][2] = cos(theta);
}

/***************************************************************************/
static void
ecliptic(double planet[3], double v_planet[3], double jdate)
{
   double i, ohm, nw, a, n, e, l, m,
            u, f, r, dm, du, df, dr,
            ldate, aa, bb, cc, dd, ee, ff;

   if (jdate <= edate[0]+100) {
/* Orbital elements for JD 2447920.5 and JD 2448120.5 referred to the
    mean ecliptic and equinox of J2000.0 */
      i = dtr(0.00132);  /* Inclination */
      ohm = dtr(352.4);  /* Longitude of ascending node */
      nw = dtr(102.90260);  /* Longitude of perhelion */
      n = dtr(0.9856049);  /* Daily motion */
      l = dtr(128.12283);  /* Mean longitude */
      a = 1.0000029;   /* Eccentricity */
      e = 0.0167006;   /* Mean distance */
      ldate = edate[0];
   }
   else {  /* See above for descriptions */
      i = dtr(0.00126);
      ohm = dtr(353.7);
      nw = dtr(103.0005);
      n = dtr(0.9856094);
      l = dtr(325.24544);
      a = 0.9999998;
      e = 0.0166744;
      ldate = edate[1];
   }

/* Calculate mean anamoly and its derivative */
   m = (jdate - ldate)*n+l-nw; dm = n;

/* Calculate eccentric anamoly and its derivative */
   u = m;
   u = (sin(u)*e+m-u)/(1-e*cos(u)) + u;
   u = (sin(u)*e+m-u)/(1-e*cos(u)) + u;
   u = (sin(u)*e+m-u)/(1-e*cos(u)) + u;
   u = (sin(u)*e+m-u)/(1-e*cos(u)) + u;
   du = dm/(1-e*cos(u));
/* Calculate tru anamoly and its derivative */
   f = 2*atan(sqrt((1+e)/(1-e))*tan(u/2));
   df =sqrt((1+e)/(1-e))/(1+sqr(sqrt((1+e)/(1-e))*tan(u/2)))/sqr(cos(u/2))*du;

/* Calculate radius vector and its derivative */
   r = a*(1-e*e)/(1+e*cos(f));
   dr = a*(1-e*e)*e*sin(f)/sqr(1+e*cos(f))*df;

/* Calculate ecliptic coordinates and velocity */
   aa = cos(f+nw-ohm);
   bb = sin(f+nw-ohm);
   cc = cos(ohm);
   dd = sin(ohm);
   ee = cos(i);
   ff = sin(i);

   planet[0] = r*(aa*cc-bb*ee*dd);
   planet[1] = r*(aa*dd+bb*ee*cc);
   planet[2] = r*bb*ff;

   v_planet[0] = dr*(aa*cc-bb*ee*dd)-r*(bb*cc+aa*ee*dd)*df;
   v_planet[1] = dr*(aa*dd+bb*ee*cc)-r*(bb*dd-aa*ee*cc)*df;
   v_planet[2] = dr*bb*ff+r*aa*ff*df;
}

/***************************************************************************/
static void
barycentric(double earth[3], double v_earth[3], double jdate)
{
   double t,l,dt,dl;

   t = (jdate-2451545.0)/36525.0;
   dt = 1/36525.0;
   l = dtr(218.0 + 481268.0*t);
   dl = dtr(481268.0*dt);

   earth[0] -= 0.0000312*cos(l);
   earth[1] -= 0.0000312*sin(l);

   v_earth[0] += 0.0000312*sin(l)*dl;
   v_earth[1] -= 0.0000312*cos(l)*dl;
}

/****************************************************************************/
static void
topocentric(double earth[3], double v_earth[3], double lon, double lat,
            double jdate, double jtime)
{
   double gmt, dgmt, lst, dlst, x, y, z, dx, dy, dz;

/* Compute gmt and its derivative */
   gmt = 6.6265313+0.0657098243*(jdate-jtime-2447891.5)+
         1.00273791*24.0*jtime;
   gmt = dtr(gmt*15.0);
   dgmt = 1.00273791*24.0;
   dgmt = dtr(dgmt*15.0);

/* Calculate local sidereal time and its derivative */
   lst = gmt-lon;
   dlst = dgmt;

/* Calculate geocentric coordinates and velocity */
   x = ER2AU*cos(lat)*cos(lst);
   y = ER2AU*cos(lat)*sin(lst);
   z = ER2AU*sin(lat);

   dx = -ER2AU*cos(lat)*sin(lst)*dlst;
   dy = ER2AU*cos(lat)*cos(lst)*dlst;
   dz = 0;

/* Calculate new ecliptic coordinates and velocity */
   earth[0] += x;
   earth[1] += y*cos(dtr(ee))+z*sin(dtr(ee));
   earth[2] += z*cos(dtr(ee))-y*sin(dtr(ee));

   v_earth[0] += dx;
   v_earth[1] += dy*cos(dtr(ee))+dz*sin(dtr(ee));
   v_earth[2] += dz*cos(dtr(ee))-dy*sin(dtr(ee));
}

/****************************************************************************/
static void
nutation(double *ra, double *dec, double jdate)
{
   double a,b,d,gamma,epsilon,e;

   d = jdate-2447891.5;
   gamma = -0.0048*sin(dtr(318.5-0.053*d))
           -0.0004*sin(dtr(198.8+1.971*d));
   epsilon = 0.0026*cos(dtr(318.5-0.053*d))
             +0.0002*cos(dtr(198.8+1.971*d));

   e = dtr(ee);
   a = (cos(e)+sin(e)*sin(*ra)*tan(*dec))*gamma-cos(*ra)*tan(*dec)*epsilon;
   b = sin(e)*cos(*ra)*gamma+sin(*ra)*epsilon;

   *ra = *ra + dtr(a);
   *ra = angle(sin(*ra), cos(*ra));
   *dec = *dec + dtr(b);
}


/***************************************************************************/
void
sunLocator(double latitude, double longitude, long month, long day,
           long year, long hour, long mins, long sec, int zone,
           double *altitude, double *azimuth, double *solar_time)
{
   double jdate, jtime;
   double sunra, sundec, sunrv;
   double p[3][3]; /* Precession matrix */
   double earth[3]; /* Earthly ecliptic coordinates */
   double v_earth[3]; /* Earthly ecliptic velocity */
   double h_earth[3]; /* Earthly Heliocentric coordinates */
   double object[3];  /* Solar ecliptic coordinates */
   double v_object[3]; /* Solar ecliptic velocity */
   double h_object[3]; /* Solar heliocentric coordinates */
   double tau;

   jtime = (hour+mins/60.0+sec/3600.0)/24.0;
   jdate = gregorian2julian(month,day,year) + jtime;
   ecliptic(earth,v_earth,jdate);
   barycentric(earth,v_earth,jdate);
   topocentric(earth, v_earth, longitude, latitude, jdate, jtime);

 /* Compute the heliocentric coordinates */
   h_earth[0] = earth[0];
   h_earth[1] = earth[1]*cos(dtr(ee))-earth[2]*sin(dtr(ee));
   h_earth[2] = earth[2]*cos(dtr(ee))+earth[1]*sin(dtr(ee));
   precession(p, jdate);
   rotate(h_earth,p);
   object[0] = object[1] = object[2] = 0.0;
   v_object[0] = v_object[1] = v_object[2] = 0.0;
   sunrv = distance(earth,object); /* distance between earth and Sun */

  /* Correction for aberration */
   tau = sunrv / 173.1421288; /* A.U per julian day (speed of light) */
   object[0] = (v_earth[0] - v_object[0])*tau + object[0];
   object[1] = (v_earth[1] - v_object[1])*tau + object[1];
   object[2] = (v_earth[2] - v_object[2])*tau + object[2];

 /* Compute heliocentric coordinates for the sun */
   h_object[0] = object[0];
   h_object[1] = object[1]*cos(dtr(ee))-object[2]*sin(dtr(ee));
   h_object[2] = object[2]*cos(dtr(ee))+object[1]*sin(dtr(ee));
   rotate(h_object, p);

  /* Compute right ascension and declination */
   sundec = asin((h_object[2]-h_earth[2])/distance(h_object,h_earth));
   sunra = angle(h_object[1]-h_earth[1],h_object[0]-h_earth[0]);
   nutation(&sunra, &sundec, jdate);
   altaz(azimuth, altitude, solar_time, sunra, sundec, longitude, latitude,
         jdate,jtime);
}

//////////////////////////////////////////////////////////////////////////////
//JH additions for sun locator system
//////////////////////////////////////////////////////////////////////////////

static interpJulianStruct fusetime(SYSTEMTIME& tstruct);
static double date_to_days(SYSTEMTIME& t);
static double time_to_days(SYSTEMTIME& t);
static void fracturetime(interpJulianStruct time, SYSTEMTIME& t);
static void splittime( double fod, SYSTEMTIME& t);
static int time_to_secs(SYSTEMTIME& t);
static uTimevect secs_to_hms( int secs);
static uTimevect decday_to_hms( double fod);
static uTimevect addvect(uTimevect v1, uTimevect v2);

interpJulianStruct fusetime(SYSTEMTIME& tstruct){
	interpJulianStruct result;
	result.days =  date_to_days(tstruct) ;
	result.subday =  time_to_secs(tstruct);
	return result;
}

uTimevect addvect(uTimevect v1 ,uTimevect v2){
	uTimevect result;
	result.i = v1.i + v2.i;
	result.j = v1.j + v2.j;
	result.k = v1.k + v2.k;
	return result;
}



double date_to_days(SYSTEMTIME& t){
	long month, day, year;
	month = t.wMonth;
	day = t.wDay;
	year = t.wYear;
	double d = gregorian2julian(month,day,year) - EPOCH;
	assert(floor(d)==ceil(d));// no decimal part
	return d;
}

double time_to_days(SYSTEMTIME& t){
	double dec = (t.wHour + t.wMinute/60.0 + t.wSecond/3600.0)/24.0;
	assert(dec>=0.0 && dec<1.0); // 0.0<= dec <1.0
	return dec;
}

int time_to_secs(SYSTEMTIME& t){
	int secs = (t.wHour * 3600 + t.wMinute*60 + t.wSecond);
	assert(secs>=0 && secs<86401); 
	return secs;
}


void fracturetime(interpJulianStruct time, SYSTEMTIME& t){
	int month,day,year,xtradays,xtramin,xtrahrs;
	long wholepart ;
	double decpart = 0.0;

	wholepart = (long) floor(time.days);
	decpart = time.days - wholepart;
	assert(time.days == wholepart + decpart);
	
	double jdate = wholepart + EPOCH + time.epoch;
	
	julian2gregorian(jdate, &month, &day, &year);
	
	uTimevect hms = decday_to_hms(decpart);
	hms.k = 0; //don't trust the low order bits
	uTimevect hms2 = addvect(hms, secs_to_hms(time.subday));

	xtramin = hms2.k/60;
	if(xtramin > 0) {
		hms2.k -= xtramin*60;
		hms2.j += xtramin;
	}

	xtrahrs = hms2.j/60;
	if(xtrahrs > 0) {
		hms2.j -= xtrahrs*60;
		hms2.i += xtrahrs;
	}

	xtradays = hms2.i/24;
	if(xtradays > 0) hms2.i -= xtradays*24;
		
	t.wHour = hms2.i;
	t.wMinute = hms2.j;
	t.wSecond = hms2.k;

	// bug fix
	day += xtradays;

		//how many days in this month
	int modays;
	int leap = isleap(year);
	if (month == 12) modays = 31;
	else modays = mdays[leap][month]-mdays[leap][month-1];

	if (day> modays) {
		day = day - modays;
		month ++;
	}
	if (month> 12) {
		month = month - 12;
		year ++;
	}
	t.wDay = (unsigned short) day;
	//end fix

	t.wMonth = (unsigned short) month;
//	t.wDay = (unsigned short) day + xtradays; uncomment to back out fix
	t.wYear	= (unsigned short) year;

}

uTimevect decday_to_hms( double fod){
//convert decimal days to hours minutes seconds
	uTimevect result;

	assert(fod>=0.0 && fod<1.0); // 0.0<= fod <1.0 fraction of day
	result.i = (unsigned short) floor(24.0 * fod);

	fod -= result.i / 24.0f; //fraction of hour remains
	result.j = (unsigned short) floor(24.0f * 60.0f * fod);

	fod -= result.j / (24.0f * 60.0f); //fraction of minute
	result.k = (unsigned short) floor(24.0f * 3600.0f * fod);


#ifdef DEBUG
	FILE *stream;
	stream=fopen("round.log","a");
  	fprintf(stream, "fod: %f\n", fod );
	fprintf(stream, "Hour: %d\tMin: %d\tSec: %d\n\n\n", result.i,result.j, result.k );
	fclose(stream);
#endif


	return result;
}

uTimevect secs_to_hms( int secs){
//convert seconds to hours minutes seconds
	uTimevect result;

//	assert(secs >= 0 && secs <= SECS_PER_DAY); 
	result.i =  secs / 3600;

	secs -= result.i*3600; //hours removed
	result.j = secs/60;

	secs -= result.j*60; //mins removed
	result.k = secs;

	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\CITYLIST.CPP ===
#include "citylist.h"

// This list has English embedded strings only for the programmer's
//  convenience.  At run time, the these strings are replaced with strings
// from the resource file.  To add or delete cities, do so here AND IN
// THE RESOURCE FILE.
CityList cityList[] = {
  {+39.5117f, +076.1617f, "Aberdeen MD"},
  {+05.2000f, +004.5000f, "+Abidjan Ivory Coast"},
  {+32.4650f, +099.7133f, "Abilene TX"},
  {+17.5000f, +099.8000f, "+Acapulco Mexico"},
  {+06.0000f, +000.2000f, "+Accra Ghana"},
  {+09.0000f, -038.0000f, "+Addis Ababa Ethiopia"},
  {-34.9333f, -138.6000f, "+Adelaide Australia"},
  {+12.6000f, -045.0000f, "+Aden Yemen"},
  {+23.0400f, -072.3800f, "Ahmadabad India"},
  {+41.0833f, +081.5122f, "Akron OH"},
  {+29.0000f, -048.0000f, "+Al Kuwait Kuwait"},
  {+37.7633f, +122.2433f, "Alameda CA"},
  {+32.9000f, +105.9567f, "Alamogordo NM"},
  {+31.5750f, +084.1583f, "Albany GA"},
  {+42.6503f, +073.7503f, "+Albany NY"},
  {+44.6333f, +123.0983f, "Albany OR"},
  {+35.0836f, +106.6514f, "+Albuquerque NM"},
  {+31.1200f, -029.5800f, "Alexandria Egypt"},
  {+31.3017f, +092.4533f, "Alexandria LA"},
  {+38.8033f, +077.0500f, "Alexandria VA"},
  {+36.7000f, -003.0000f, "+Algiers Algeria"},
  {+34.1400f, +118.1067f, "Alhambra CA"},
  {-23.7000f, -133.8667f, "Alice Springs Australia"},
  {+33.0117f, +081.2917f, "Allendale SC"},
  {+40.6030f, +075.4683f, "Allentown PA"},
  {+47.0000f, -002.0000f, "Allouis France"},
  {+31.5367f, +082.5083f, "Alma  GA"},
  {+43.1900f, -077.0800f, "Alma-Ata Kazakhstan"},
  {+40.5153f, +078.4008f, "Altoona PA"},
  {+35.2075f, +101.8344f, "Amarillo TX"},
  {+42.0317f, +093.6167f, "+Ames IA"},
  {+31.9000f, -035.9000f, "+Amman Jordan"},
  {+52.4000f, -005.0000f, "+Amsterdam Netherlands"},
  {+46.1283f, +112.9533f, "Anaconda MT"},
  {+33.8350f, +117.9133f, "Anaheim CA"},
  {+61.1667f, +149.9833f, "+Anchorage AK"},
  {+40.1667f, +085.6850f, "Anderson IN"},
  {+34.5100f, +082.6550f, "Anderson SC"},
  {+42.6000f, -001.5000f, "Andorra Andorra"},
  {-12.2000f, -044.3000f, "+Anjouan Island"},
  {+40.0000f, -033.0000f, "+Ankara Turkey"},
  {+42.2831f, +083.7478f, "Ann Arbor MI"},
  {+38.9733f, +076.4950f, "Annapolis MD"},
  {-19.0000f, -047.5000f, "+Antananarivo Madagascar"},
  {+17.1420f, +061.7930f, "+Antigua Island"},
  {+51.1300f, -004.2400f, "Antwerp Belgium"},
  {+44.2617f, +088.4200f, "Appleton WI"},
  {+42.0883f, +087.9800f, "Arlington Heights IL"},
  {+42.4150f, +071.1517f, "Arlington MA"},
  {+32.7367f, +097.1133f, "Arlington TX"},
  {+39.8000f, +105.0783f, "Arvada CO"},
  {-06.0920f, +014.4020f, "+Ascension Island"},
  {+35.5950f, +082.5572f, "+Asheville NC"},
  {+38.4767f, +082.6397f, "Ashland KY"},
  {+46.1617f, +123.8783f, "Astoria  OR"},
  {-25.2000f, +057.4000f, "+Asuncion Paraguay"},
  {+33.9567f, +083.3833f, "Athens GA"},
  {+37.9666f, -023.7333f, "+Athens Greece"},
  {+33.7528f, +084.3936f, "+Atlanta GA"},
  {+39.3589f, +074.4314f, "Atlantic City NJ"},
  {+44.4467f, +083.4017f, "Au Sable  MI"},
  {+32.6067f, +085.4833f, "Auburn AL"},
  {+44.0967f, +070.2283f, "Auburn ME"},
  {-36.8500f, -174.7667f, "+Auckland New Zealand"},
  {+33.4722f, +081.9667f, "Augusta GA"},
  {+44.3147f, +069.7747f, "+Augusta ME"},
  {+39.7400f, +104.8683f, "Aurora CO"},
  {+41.7550f, +088.3133f, "Aurora IL"},
  {+43.6700f, +092.9333f, "Austin  MN"},
  {+30.2692f, +097.7436f, "+Austin TX"},
  {+43.7833f, +082.9833f, "Bad Axe  MI"},
  {+33.2000f, -044.2000f, "+Baghdad Iraq"},
  {+44.8400f, +117.8067f, "Baker  OR"},
  {+35.3750f, +119.0217f, "Bakersfield CA"},
  {+34.0700f, +117.9583f, "Baldwin Park CA"},
  {-37.5667f, -143.8500f, "Ballarat Australia"},
  {+39.2905f, +076.6125f, "+Baltimore MD"},
  {+13.0000f, +008.0000f, "+Bamako Mali"},
  {+13.0300f, -077.3900f, "Bangalore India"},
  {+13.2000f, -100.5000f, "+Bangkok Thailand"},
  {+44.8036f, +068.7717f, "+Bangor ME"},
  {+04.0000f, -018.0000f, "+Bangui Central African Rep."},
  {+13.0000f, +017.0000f, "+Banjul Gambia"},
  {+41.2500f, -002.0800f, "+Barcelona Spain"},
  {+44.1983f, +072.5017f, "Barre VT"},
  {+44.2500f, +079.4500f, "Barrie ON Canada"},
  {+36.7450f, +095.9767f, "Bartlesville OK"},
  {+30.4494f, +091.1833f, "+Baton Rouge LA"},
  {+42.3161f, +085.1800f, "Battle Creek MI"},
  {+52.1700f, +055.3300f, "Battle Harbour NF Canada"},
  {+43.6011f, +083.8875f, "Bay City MI"},
  {+40.6667f, +074.1200f, "Bayonne NJ"},
  {+29.7183f, +094.9767f, "Baytown TX"},
  {+30.0889f, +094.1025f, "Beaumont TX"},
  {+45.4883f, +122.8067f, "Beaverton OR"},
  {+37.7767f, +081.1900f, "Beckley WV"},
  {+39.9000f, -116.0000f, "+Beijing China"},
  {+33.9000f, -035.5000f, "+Beirut Lebanon"},
  {+54.6000f, +006.0000f, "+Belfast N. Ireland"},
  {+44.8000f, -020.6000f, "+Belgrade Yugoslavia"},
  {+17.5000f, +088.0000f, "+Belize City Belize"},
  {+47.6167f, +122.2000f, "Bellevue WA"},
  {+33.8900f, +118.1417f, "Bellflower CA"},
  {+48.7505f, +122.4767f, "Bellingham WA"},
  {-19.5400f, +043.5600f, "Belo Horizonte Brazil"},
  {+47.5767f, +095.0250f, "Bemidji  MN"},
  {+42.8800f, +073.1967f, "Bennington VT"},
  {+34.5650f, +092.5867f, "Benton AR"},
  {+42.1283f, +086.4283f, "Benton Harbor  MI"},
  {+37.8694f, +122.2714f, "Berkeley CA"},
  {+52.5300f, -013.4200f, "+Berlin Germany"},
  {+46.9000f, -007.5000f, "+Bern Switzerland"},
  {+60.7917f, +161.7500f, "Bethel AK"},
  {+40.6211f, +075.3761f, "Bethlehem PA"},
  {+43.4917f, +070.4633f, "Biddeford ME"},
  {+45.7833f, +108.5011f, "+Billings MT"},
  {+30.3967f, +088.8833f, "Biloxi MS"},
  {+42.1008f, +075.9131f, "Binghamton NY"},
  {+33.5169f, +086.8100f, "+Birmingham AL"},
  {+52.2900f, +001.5300f, "Birmingham UK"},
  {+25.6717f, +080.1783f, "Biscayne Bay  FL"},
  {+37.3833f, +118.3667f, "Bishop  CA"},
  {+46.8064f, +100.7881f, "+Bismarck ND"},
  {+12.0000f, +016.0000f, "+Bissau Guinea-Bissau"},
  {+40.7950f, +074.2000f, "Bloomfield NJ"},
  {+40.4817f, +088.9933f, "Bloomington IL"},
  {+39.1650f, +086.5317f, "Bloomington IN"},
  {+44.8250f, +093.2750f, "Bloomington MN"},
  {+33.2833f, +096.3650f, "Blue Ridge  TX"},
  {+37.2667f, +081.2233f, "Bluefield WV"},
  {+33.5967f, +114.7433f, "Blythe  CA"},
  {+26.3500f, +080.0867f, "+Boca Raton FL"},
  {+04.6000f, +074.0000f, "+Bogota Colombia"},
  {+43.6186f, +116.1994f, "+Boise ID"},
  {+18.5800f, -072.5000f, "+Bombay India"},
  {+50.8000f, -007.1000f, "+Bonn Germany"},
  {+40.7267f, +113.7567f, "Bonneville  UT"},
  {+35.8067f, +101.3817f, "Borger  TX"},
  {+42.3567f, +071.0569f, "+Boston MA"},
  {+40.0133f, +105.2800f, "+Boulder CO"},
  {+40.8850f, +111.8800f, "Bountiful UT"},
  {+39.0067f, +076.7817f, "Bowie MD"},
  {+36.9883f, +086.4508f, "Bowling Green KY"},
  {+38.2300f, +085.6650f, "Bowman  KY"},
  {+45.6817f, +111.0383f, "+Bozeman MT"},
  {+46.3483f, +094.0250f, "Brainerd  MN"},
  {+49.5000f, +099.5700f, "Brandon MB Canada"},
  {+43.1000f, +080.2666f, "+Brantford ON Canada"},
  {-16.0000f, +048.0000f, "+Brasilia Brazil"},
  {-04.0000f, -015.0000f, "+Brazzaville Congo"},
  {+33.2383f, +097.7667f, "Bridgeport  TX"},
  {+41.1803f, +073.1894f, "+Bridgeport CT"},
  {+13.1000f, +059.0000f, "+Bridgetown Barbados"},
  {-27.4667f, -153.0167f, "+Brisbane Australia"},
  {+41.6733f, +072.9500f, "Bristol CT"},
  {+36.5933f, +082.1767f, "Bristol TN"},
  {+42.0839f, +071.0236f, "Brockton MA"},
  {+36.0500f, +095.7950f, "Broken Arrow OK"},
  {+44.3100f, +096.7933f, "Brookings SD"},
  {+42.3317f, +071.1217f, "Brookline MA"},
  {+45.1000f, +093.3750f, "Brooklyn Park MN"},
  {+39.6733f, +075.7200f, "Brookside Park DE"},
  {+33.2400f, +087.2500f, "Brookwood  AL"},
  {-17.9667f, -122.2333f, "Broome Australia"},
  {+25.9019f, +097.4994f, "Brownsville TX"},
  {+43.9067f, +069.9633f, "Brunswick ME"},
  {+50.5100f, -004.2100f, "+Brussels Belgium"},
  {+37.6900f, +112.3033f, "Bryce Canyon  UT"},
  {+44.4000f, -026.1000f, "+Bucharest Romania"},
  {+40.6167f, +083.0633f, "Buckeye  OH"},
  {+47.7000f, -019.0000f, "+Budapest Hungary"},
  {+33.8717f, +117.9967f, "Buena Park CA"},
  {-34.8000f, +058.0000f, "+Buenos Aires Argentina"},
  {+42.8811f, +078.8725f, "+Buffalo NY"},
  {-03.0000f, -029.5000f, "+Bujumbura Burundi"},
  {+34.1817f, +118.3117f, "Burbank CA"},
  {+42.6900f, +088.3017f, "Burbun  WI"},
  {+42.5800f, +113.8650f, "Burley  ID"},
  {+43.3166f, +079.8000f, "+Burlington ON Canada"},
  {+40.8100f, +091.2333f, "Burlington IA"},
  {+36.0967f, +079.4333f, "Burlington NC"},
  {+44.4786f, +073.2128f, "Burlington VT"},
  {+38.2717f, +094.4883f, "Butler  MO"},
  {+46.0183f, +112.5364f, "Butte MT"},
  {+22.1000f, +110.0000f, "+Cabo San Lucas Mexico"},
  {+39.1600f, -009.0800f, "+Cagliari Italy"},
  {+32.3450f, +086.9917f, "Cahaba  AL"},
  {+31.2683f, +085.7267f, "Cairns  AL"},
  {-16.9167f, -145.7667f, "Cairns Australia"},
  {+30.0000f, -032.0000f, "+Cairo Egypt"},
  {+22.3200f, -088.2200f, "+Calcutta India"},
  {+43.6650f, +116.6867f, "Caldwell ID"},
  {+51.0333f, +114.0500f, "+Calgary AB Canada"},
  {+03.2600f, +076.3000f, "+Cali Colombia"},
  {+34.2133f, +119.0933f, "Camarillo  CA"},
  {+42.3669f, +071.1061f, "Cambridge MA"},
  {+38.5700f, +076.0783f, "Cambridge MD"},
  {+69.1500f, +105.0000f, "Cambridge Bay NT Canada"},
  {+39.9447f, +075.1205f, "Camden NJ"},
  {+27.9000f, +015.7000f, "+Canary Islands"},
  {-35.2833f, -149.2167f, "+Canberra Australia"},
  {+40.7972f, +081.3769f, "Canton OH"},
  {+49.0000f, +067.0000f, "Cap Chat QB Canada"},
  {+37.3100f, +089.5333f, "Cape Girardeau MO"},
  {+11.0000f, +067.0000f, "+Caracas Venezuela"},
  {+39.6033f, +110.7533f, "Carbon(Price)  UT"},
  {+32.2567f, +104.2250f, "Carlsbad  NM"},
  {-24.8833f, -113.6667f, "Carnarvon Australia"},
  {+33.8067f, +118.2833f, "Carson CA"},
  {+39.1600f, +119.7600f, "Carson City NV"},
  {+10.3000f, +075.4000f, "+Cartagena Colombia"},
  {+32.8800f, +111.7483f, "Casa Grande AZ"},
  {+33.3200f, +007.4100f, "+Casablanca Morocco"},
  {+42.8467f, +106.3133f, "Casper WY"},
  {+04.8000f, +052.5000f, "+Cayenne French Guiana"},
  {+30.2133f, +081.8917f, "Cecil  FL"},
  {+37.7867f, +113.0667f, "Cedar City  UT"},
  {+42.5250f, +092.4517f, "Cedar Falls IA"},
  {+41.9669f, +091.6647f, "Cedar Rapids IA"},
  {+29.9217f, +099.2133f, "Center Point  TX"},
  {+37.4983f, +087.2633f, "Central City  KY"},
  {+40.7900f, +073.2000f, "Central Islip NY"},
  {+33.8350f, +118.0833f, "Cerritos CA"},
  {+42.5583f, +103.3117f, "Chadron  NE"},
  {+40.1180f, +088.2467f, "Champaign IL"},
  {+43.5500f, -125.2500f, "+Changchun China"},
  {+37.6267f, +095.5933f, "Chanute  KS"},
  {+35.9347f, +079.0672f, "+Chapel Hill NC"},
  {+41.5167f, +081.1633f, "Chardon  OH"},
  {+32.7764f, +079.9314f, "+Charleston SC"},
  {+38.3503f, +081.6311f, "+Charleston WV"},
  {+35.2289f, +080.8458f, "+Charlotte NC"},
  {+46.1400f, +063.0800f, "Charlottetown PE Canada"},
  {+35.0447f, +085.3089f, "+Chattanooga TN"},
  {+30.3000f, -104.1000f, "+Chengdu China"},
  {+41.7550f, +107.5817f, "Cherokee  WY"},
  {+36.8250f, +076.2833f, "Chesapeake VA"},
  {+34.6500f, +080.2750f, "Chesterfield  SC"},
  {+63.1900f, +091.1100f, "Chesterfield Inlet NT Canada"},
  {+41.1358f, +104.8186f, "+Cheyenne WY"},
  {+41.8744f, +087.6394f, "+Chicago IL"},
  {+39.7833f, +121.8500f, "Chico  CA"},
  {+42.1400f, +072.6117f, "Chicopee MA"},
  {+34.3683f, +100.2883f, "Childress  TX"},
  {+53.4000f, +078.5800f, "Chisasibi PQ Canada"},
  {+29.3800f, -107.3000f, "+Chongging China"},
  {-42.5333f, -172.6333f, "+Christchurch New Zealand"},
  {+32.6433f, +117.0833f, "Chula Vista CA"},
  {+58.7500f, +094.1666f, "+Churchill MB Canada"},
  {+41.8500f, +087.7450f, "Cicero IL"},
  {+39.1019f, +084.5097f, "+Cincinnati OH"},
  {+43.3750f, +072.3367f, "Claremont NH"},
  {+39.2800f, +080.3483f, "Clarksburg WV"},
  {+34.1983f, +090.5750f, "Clarksdale MS"},
  {+36.5267f, +087.3483f, "Clarksville TN"},
  {+39.8050f, +075.4533f, "Claymont DE"},
  {+27.9667f, +082.7983f, "Clearwater FL"},
  {+41.4975f, +081.6972f, "+Cleveland OH"},
  {+35.1583f, +084.8767f, "Cleveland TN"},
  {+40.8833f, +074.1467f, "Clifton NJ"},
  {+41.8433f, +090.1933f, "Clinton IA"},
  {+34.4017f, +103.2050f, "Clovis NM"},
  {+32.0333f, +109.7583f, "Cochise  AZ"},
  {+44.6200f, +108.9633f, "+Cody  WY"},
  {+47.7733f, +116.8200f, "+Coeur D'Alene  ID"},
  {+38.9867f, +076.9350f, "College Park MD"},
  {+30.6050f, +096.4200f, "College Station  TX"},
  {+26.1533f, +081.7783f, "Collier County  FL"},
  {+45.3200f, -009.1700f, "+Cologne Germany"},
  {+07.0000f, -079.9000f, "+Colombo Sri Lanka"},
  {+38.8353f, +104.8211f, "Colorado Springs CO"},
  {+38.9508f, +092.3294f, "Columbia MO"},
  {+34.0005f, +081.0333f, "Columbia SC"},
  {+35.6150f, +087.0367f, "Columbia TN"},
  {+31.8183f, +107.5733f, "Columbus NM"},
  {+32.4686f, +084.9900f, "Columbus GA"},
  {+33.4983f, +088.4167f, "Columbus MS"},
  {+42.4250f, +097.3600f, "Columbus NE"},
  {+39.9630f, +083.0047f, "+Columbus OH"},
  {-12.2000f, -044.3000f, "+Comoros Islands"},
  {+33.8950f, +118.2258f, "Compton CA"},
  {+09.5000f, +013.5000f, "+Conakry Guinea"},
  {+37.9750f, +122.0300f, "Concord CA"},
  {+43.2061f, +071.5403f, "+Concord NH"},
  {+56.0000f, -010.8000f, "+Copenhagen Denmark"},
  {+46.0333f, +112.7467f, "Coppertown  MT"},
  {+48.5700f, +057.5700f, "Corner Brook NF Canada"},
  {+27.7975f, +097.3958f, "+Corpus Christi TX"},
  {+44.5667f, +123.2700f, "Corvallis OR"},
  {+33.6400f, +117.9183f, "Costa Mesa CA"},
  {+28.4617f, +099.1183f, "Cotulla  TX"},
  {+41.2617f, +095.8650f, "+Council Bluffs IA"},
  {+39.0867f, +084.5117f, "Covington KY"},
  {+41.7833f, +071.4383f, "Cranston RI"},
  {+44.0000f, +106.4350f, "Crazy Woman  WY"},
  {+41.7833f, +124.2333f, "+Crescent City  CA"},
  {+30.8267f, +086.6800f, "Crestview  FL"},
  {+29.5983f, +083.0483f, "Cross City  FL"},
  {+39.6500f, +078.7633f, "Cumberland MD"},
  {+41.4833f, +099.6900f, "Custer County  NE"},
  {+48.5650f, +112.3417f, "Cut Bank  MT"},
  {+23.3000f, -090.5000f, "+Dacca Bengladesh"},
  {+30.1900f, +094.6450f, "Daisetta  TX"},
  {+14.5000f, +017.0000f, "+Dakar Senegal"},
  {+32.7858f, +096.7936f, "+Dallas TX"},
  {+37.7017f, +122.4617f, "Daly City CA"},
  {+33.5000f, -036.3000f, "+Damascus Syria"},
  {+41.3933f, +073.4572f, "Danbury CT"},
  {+36.5917f, +079.3842f, "Danville VA"},
  {-07.5000f, -039.0000f, "+Dar Es Salaam Tanzania"},
  {+45.0883f, +094.4533f, "Darwin  MN"},
  {-12.4500f, -130.8333f, "+Darwin Australia"},
  {+41.5219f, +090.5758f, "Davenport IA"},
  {+35.6633f, +095.3683f, "Davis  OK"},
  {+32.1600f, +110.8800f, "Davis-Monthan AFB AZ"},
  {+64.0500f, +129.4333f, "+Dawson YT Canada"},
  {+39.7589f, +084.1953f, "Dayton OH"},
  {+29.2122f, +081.0194f, "Daytona Beach FL"},
  {+42.3250f, +083.2917f, "Dearborn Heights MI"},
  {+42.3233f, +083.1750f, "Dearborn MI"},
  {+39.8450f, +088.9464f, "Decataur IL"},
  {+34.6483f, +086.9400f, "Decatur  AL"},
  {+29.3600f, +100.8200f, "Del Rio TX"},
  {+43.5517f, +089.7633f, "Dells  WI"},
  {+39.3017f, +112.5050f, "Delta  UT"},
  {+32.2767f, +107.6050f, "Deming  NM"},
  {+33.2200f, +097.1367f, "Denton TX"},
  {+39.7494f, +104.9894f, "+Denver CO"},
  {+42.8817f, +071.3233f, "Derry NH"},
  {+41.5872f, +093.6167f, "+Des Moines IA"},
  {+42.0433f, +087.8700f, "Des Plaines IL"},
  {+61.0000f, +139.0000f, "Destruction Bay YT Canada"},
  {+46.8250f, +095.8817f, "Detroit Lakes  MN"},
  {+42.3300f, +083.0492f, "+Detroit MI"},
  {+48.1100f, +098.8633f, "Devils Lake ND"},
  {+46.8800f, +102.7883f, "Dickinson ND"},
  {+29.4700f, +095.0400f, "Dickinson TX"},
  {+45.2483f, +112.5467f, "Dillon  MT"},
  {+11.5000f, -043.0000f, "+Djibouti Djibouti"},
  {+37.7547f, +100.0192f, "+Dodge City KS"},
  {+37.0233f, +092.8767f, "Dogwood  MO"},
  {+42.6767f, +105.2250f, "Douglas  WY"},
  {+37.8083f, +108.9300f, "Dove Creek  CO"},
  {+39.1333f, +075.5500f, "+Dover DE"},
  {+43.1917f, +070.8800f, "Dover NH"},
  {+33.9350f, +118.1250f, "Downey CA"},
  {+32.5400f, +093.7417f, "Downtown  LA"},
  {+36.0433f, +094.1967f, "Drake  AR"},
  {+34.7033f, +112.4800f, "Drake Prescott  AZ"},
  {+46.6367f, +113.1850f, "Drummond  MT"},
  {+32.5600f, +082.8333f, "Dublin  GA"},
  {+53.2000f, +006.1000f, "+Dublin Ireland"},
  {+44.0883f, +112.2083f, "Dubois  ID"},
  {+42.5033f, +090.6750f, "Dubuque IA"},
  {+46.7822f, +092.1067f, "+Duluth MN"},
  {-66.8000f, -140.0000f, "+Dumont D'Urville"},
  {+34.3850f, +097.9167f, "Duncan  OK"},
  {-45.8833f, -170.5000f, "Dunedin New Zealand"},
  {+43.8283f, +110.3350f, "Dunoir  WY"},
  {+45.0783f, +101.7150f, "Dupree  SD"},
  {+36.0000f, +078.9125f, "Durham NC"},
  {+29.6633f, +096.3167f, "Eagle Lake  TX"},
  {+61.3217f, +149.5667f, "Eagle River AK"},
  {+42.7350f, +084.4833f, "East Lansing MI"},
  {+40.7633f, +074.2100f, "East Orange NJ"},
  {+33.6767f, +084.4433f, "East Point GA"},
  {+38.6217f, +090.1550f, "East St. Louis IL"},
  {+31.4183f, +089.3383f, "Eaton  MS"},
  {+44.8133f, +091.4950f, "+Eau Claire WI"},
  {+44.8833f, +093.3500f, "Edina MN"},
  {+55.9500f, +003.1000f, "+Edinburgh Scotland"},
  {+33.4567f, +080.8600f, "Edisto  SC"},
  {+35.6533f, +097.4817f, "Edmond OK"},
  {+53.5500f, +113.4833f, "+Edmonton AB Canada"},
  {+39.0717f, +088.5383f, "Effingham  IL"},
  {+30.3933f, +086.5383f, "Eglin AFB  FL"},
  {+32.7950f, +116.9600f, "El Cajon CA"},
  {+33.2067f, +092.6667f, "El Dorado AR"},
  {+34.0667f, +118.0250f, "El Monte CA"},
  {+31.7600f, +106.4864f, "+El Paso TX"},
  {+33.6833f, +117.7333f, "El Toro  CA"},
  {+34.4183f, +082.7850f, "Electric City  SC"},
  {+42.0383f, +088.2900f, "Elgin IL"},
  {+40.6619f, +074.2164f, "Elizabeth NJ"},
  {+40.8300f, +115.7600f, "+Elko NV"},
  {+47.0250f, +120.4567f, "Ellensburg  WA"},
  {+29.6067f, +095.1600f, "Ellington  TX"},
  {+32.4000f, +093.5950f, "Elm Grove  LA"},
  {+42.1117f, +092.9100f, "Elmwood  IA"},
  {+39.7400f, +075.5900f, "Elsmere DE"},
  {+47.8217f, +091.8300f, "Ely  MN"},
  {+41.3650f, +082.1100f, "Elyria OH"},
  {+38.2917f, +096.1383f, "Emporia  KS"},
  {+39.6533f, +104.9850f, "Englewood CO"},
  {+36.3950f, +097.8750f, "Enid OK"},
  {+31.2967f, +085.9033f, "Enterprize  AL"},
  {+47.3783f, +119.4233f, "Ephrata  WA"},
  {+42.1208f, +080.0825f, "Erie PA"},
  {+45.7233f, +087.0900f, "Escanaba  MI"},
  {+33.1167f, +117.0850f, "Escondido CA"},
  {+66.5000f, +094.0000f, "+Eskimo Point NT Canada"},
  {+31.4467f, +092.3217f, "Esler  LA"},
  {+44.4883f, +073.1117f, "Essex Junction VT"},
  {+43.4100f, +094.7383f, "Estherville  IA"},
  {+41.5700f, +081.5367f, "Euclid OH"},
  {+31.9500f, +085.1300f, "Eufaula  AL"},
  {+44.0544f, +123.0917f, "+Eugene OR"},
  {+42.0433f, +087.6767f, "Evanston IL"},
  {+37.9722f, +087.5725f, "Evansville IN"},
  {+47.4250f, +092.5017f, "Eveleth  MN"},
  {+47.9800f, +122.2000f, "Everett WA"},
  {+21.3350f, +158.0433f, "Ewa HI"},
  {+64.8000f, +147.8500f, "+Fairbanks AK"},
  {+38.2500f, +122.0417f, "Fairfield CA"},
  {+41.1417f, +073.2633f, "Fairfield CT"},
  {+43.6467f, +094.4217f, "Fairmont  MN"},
  {+39.4833f, +080.1433f, "Fairmont WV"},
  {+41.7017f, +071.1550f, "Fall River MA"},
  {+43.7683f, +087.8483f, "Falls  WI"},
  {+46.8750f, +096.7883f, "+Fargo ND"},
  {+44.6317f, +093.1817f, "Farmington  MN"},
  {+37.6733f, +090.2333f, "Farmington  MO"},
  {+36.7333f, +108.2033f, "Farmington NM"},
  {+36.0667f, +094.1600f, "Fayetteville AR"},
  {+35.0550f, +078.8767f, "Fayetteville NC"},
  {+46.2900f, +096.1567f, "Fergus Falls  MN"},
  {+35.1933f, +111.6517f, "Flagstaff AZ"},
  {+54.4600f, +101.5300f, "Flin Flon MB Canada"},
  {+43.0217f, +083.6833f, "Flint MI"},
  {+36.3000f, +092.4583f, "Flippin  AR"},
  {+34.1967f, +079.7683f, "Florence SC"},
  {+38.7967f, +090.4900f, "Florissant MO"},
  {+44.8250f, +093.4567f, "Flying Cloud  MN"},
  {+38.6950f, +090.9717f, "Foristell  MO"},
  {+37.7417f, +092.1383f, "Forney  MO"},
  {+41.3783f, +110.4233f, "Fort Bridger  WY"},
  {+40.5800f, +105.0833f, "Fort Collins CO"},
  {+14.5400f, +061.0000f, "+Fort-de-France Martinique"},
  {+42.6117f, +094.2950f, "Fort Dodge  IA"},
  {+41.4500f, +122.8000f, "Fort Jones  CA"},
  {+37.9067f, +085.9733f, "+Fort Knox  KY"},
  {+26.1200f, +080.1367f, "+Fort Lauderdale FL"},
  {+34.9883f, +080.9550f, "Fort Mill  SC"},
  {+26.5883f, +081.8667f, "Fort Myers  FL"},
  {+38.9700f, +096.8600f, "Fort Riley  KS"},
  {+55.5800f, +087.5000f, "Fort Severn ON Canada"},
  {+35.3850f, +094.4183f, "Fort Smith AR"},
  {+30.8100f, +102.8600f, "Fort Stockton TX"},
  {+41.0725f, +085.1405f, "+Fort Wayne IN"},
  {+32.7486f, +097.3289f, "+Fort Worth TX"},
  {+40.6667f, +124.2333f, "Fortuna  CA"},
  {+33.7000f, +117.9600f, "Fountain Valley CA"},
  {+42.2733f, +071.4150f, "Framingham MA"},
  {+38.2000f, +084.8617f, "Frankfort KY"},
  {+50.0700f, -008.4000f, "+Frankfurt Germany"},
  {+32.0750f, +095.5300f, "Frankston  TX"},
  {+39.4150f, +077.4167f, "Frederick MD"},
  {+08.1000f, +012.8000f, "+Freetown Sierra Leone"},
  {+37.5350f, +121.9567f, "Fremont CA"},
  {+41.4400f, +096.4950f, "Fremont NE"},
  {+36.7367f, +119.7697f, "+Fresno CA"},
  {+37.1000f, +119.6000f, "Friant  CA"},
  {+33.8750f, +117.9250f, "Fullerton CA"},
  {-23.0000f, -025.5000f, "+Gaborone Botswana"},
  {+34.0158f, +086.0114f, "Gadsden AL"},
  {+36.3433f, +099.8800f, "Gage  OK"},
  {+29.6420f, +082.3200f, "Gainesville FL"},
  {+39.1400f, +077.1983f, "Gaithersburg MD"},
  {+35.5250f, +108.7417f, "Gallup NM"},
  {+29.3028f, +094.7953f, "+Galveston TX"},
  {+37.9183f, +100.7250f, "Garden City  KS"},
  {+33.7750f, +117.9133f, "Garden Grove CA"},
  {+42.5467f, +072.0583f, "Gardner  MA"},
  {+32.9083f, +096.6367f, "Garland TX"},
  {+41.6033f, +087.3386f, "Gary IN"},
  {+35.2650f, +081.1817f, "Gastonia NC"},
  {+34.5317f, +120.0900f, "Gaviota  CA"},
  {+45.0133f, +084.7033f, "Gaylord  MI"},
  {-38.1667f, -144.3500f, "Geelong Australia"},
  {+06.0000f, +058.0000f, "+Georgetown Guyana"},
  {-28.7667f, -114.6167f, "Geraldton Australia"},
  {+44.2933f, +105.5017f, "Gillette WY"},
  {+48.2150f, +106.6250f, "Glasgow  MT"},
  {+55.5400f, +004.2500f, "+Glasgow UK"},
  {+33.5383f, +112.1817f, "Glendale AZ"},
  {+34.1417f, +118.2467f, "Glendale CA"},
  {+35.9217f, +095.9683f, "Glenpool  OK"},
  {+64.0000f, +051.0000f, "+Godthab Greenland"},
  {+39.3883f, +101.6917f, "Goodland  KS"},
  {+53.0000f, +060.0000f, "Goose Bay NF Canada"},
  {+45.1450f, +093.3733f, "Gopher  MN"},
  {+43.6667f, +070.4667f, "Gorham ME"},
  {+35.9517f, +089.9400f, "Gosnell  AR"},
  {+35.8333f, +087.4517f, "Graham  TN"},
  {+34.1833f, +118.5000f, "Granada Hills CA"},
  {+26.6540f, +078.9330f, "+Grand Bahama Island"},
  {+35.9600f, +112.1450f, "Grand Canyon  AZ"},
  {+47.9200f, +097.0450f, "+Grand Forks ND"},
  {+40.9217f, +098.3533f, "Grand Island NE"},
  {+39.0600f, +108.7917f, "Grand Junction  CO"},
  {+32.7483f, +096.9950f, "Grand Prairie TX"},
  {+47.1633f, +093.4900f, "Grand Rapids  MN"},
  {+42.9675f, +085.6703f, "+Grand Rapids MI"},
  {+33.8133f, +078.7250f, "Grand Strand  SC"},
  {+21.4330f, +071.1460f, "+Grand Turk Island"},
  {-11.8000f, -043.2000f, "+Grande Comore"},
  {+45.7700f, +092.6750f, "Grantsburg  WI"},
  {+31.0333f, +097.8133f, "Gray  TX"},
  {+47.5017f, +111.2850f, "Great Falls MT"},
  {+40.4183f, +104.6933f, "Greeley CO"},
  {+44.5133f, +088.0139f, "+Green Bay WI"},
  {+41.5267f, +109.4683f, "Green River WY"},
  {+31.0983f, +088.4867f, "Greene County  MS"},
  {+36.0714f, +079.7903f, "Greensboro NC"},
  {+30.5517f, +083.7833f, "Greenville  FL"},
  {+33.4067f, +091.0600f, "Greenville MS"},
  {+34.8472f, +082.4003f, "Greenville SC"},
  {+41.0283f, +073.6250f, "Greenwich CT"},
  {+34.2517f, +082.1550f, "Greenwood  SC"},
  {+33.5167f, +090.1817f, "Greenwood MS"},
  {+34.1933f, +082.1650f, "Greenwood SC"},
  {+32.4183f, +094.7533f, "Gregg County  TX"},
  {+45.5000f, +122.4300f, "Gresham OR"},
  {+40.6450f, +086.1517f, "Grissom  IN"},
  {+41.3300f, +072.0467f, "Groton CT"},
  {+35.9533f, +120.5200f, "Guadalupe  CA"},
  {+20.4100f, +103.2100f, "+Guadalajara Mexico"},
  {+14.9000f, +090.9000f, "+Guatemala Guatemala"},
  {+43.5500f, +080.2500f, "+Guelph ON Canada"},
  {+30.3678f, +089.0933f, "Gulfport MS"},
  {+38.4517f, +107.0383f, "Gunnison County  CO"},
  {+33.7783f, +100.3350f, "Guthrie  TX"},
  {+39.6450f, +077.7200f, "Hagerstown MD"},
  {+44.2050f, +093.3700f, "Halfway  MN"},
  {+44.6500f, +063.5666f, "+Halifax NS Canada"},
  {+39.1133f, +092.1283f, "Hallsville  MO"},
  {+41.3850f, +072.9033f, "Hamden CT"},
  {+34.1950f, +088.0133f, "Hamilton  AL"},
  {+32.2800f, +064.7600f, "+Hamilton Bermuda"},
  {+43.2600f, +079.8666f, "+Hamilton ON Canada"},
  {-37.7833f, -175.2833f, "Hamilton New Zealand"},
  {+39.3997f, +084.5630f, "Hamilton OH"},
  {+30.5200f, +090.4167f, "Hammond  LA"},
  {+41.6300f, +087.5050f, "Hammond IN"},
  {+37.0250f, +076.3417f, "Hampton VA"},
  {+31.3733f, +085.6533f, "Hanchey  AL"},
  {+38.7167f, +120.7500f, "Hangtown  CA"},
  {+38.4167f, +110.6983f, "Hanksville  UT"},
  {+21.0000f, -106.0000f, "+Hanoi Vietnam"},
  {-18.0000f, -031.0000f, "+Harare Zimbabwe"},
  {+26.2917f, +097.7933f, "Harlingen  TX"},
  {+34.9433f, +083.9150f, "Harris  GA"},
  {+40.2619f, +076.8830f, "Harrisburg PA"},
  {+36.3183f, +093.2133f, "Harrison  AR"},
  {+41.7700f, +072.6803f, "Hartford CT"},
  {+29.8500f, +090.0033f, "Harvey  LA"},
  {+40.5900f, +098.3867f, "Hastings NE"},
  {+31.3267f, +089.2883f, "Hattiesburg MS"},
  {+23.0800f, +082.2300f, "+Havana Cuba"},
  {+48.5500f, +109.6850f, "Havre MT"},
  {+33.9167f, +118.3517f, "Hawthorne CA"},
  {+40.4533f, +100.9233f, "Hayes Center  NE"},
  {+38.8483f, +099.2767f, "Hays  KS"},
  {+46.0183f, +091.4467f, "Hayward  WI"},
  {+37.6650f, +122.0767f, "Hayward CA"},
  {+46.5925f, +112.0400f, "+Helena MT"},
  {+60.5000f, -024.9000f, "+Helsinki Finland"},
  {+37.8367f, +087.5867f, "Henderson KY"},
  {+36.0367f, +114.9800f, "Henderson NV"},
  {+36.3050f, +086.6200f, "Hendersonville TN"},
  {+25.8283f, +080.2833f, "Hialeah FL"},
  {+47.3017f, +092.7033f, "Hibbing  MN"},
  {+39.0733f, +093.6783f, "Higginsville  MO"},
  {+35.9517f, +080.0050f, "High Point NC"},
  {+39.2583f, +100.2250f, "Hill City  KS"},
  {+45.5200f, +122.9867f, "Hillsboro OR"},
  {+19.7250f, +155.0900f, "Hilo HI"},
  {+35.7817f, +084.9783f, "Hinch Mountain  TN"},
  {-42.8833f, -147.3167f, "+Hobart Australia"},
  {+34.8667f, +099.0633f, "Hobart  OK"},
  {+32.7000f, +103.1317f, "Hobbs NM"},
  {+11.0000f, -107.0000f, "+Ho-Chi-Minh (Saigon) Vietnam"},
  {+32.8617f, +106.1083f, "Holloman AFB  NM"},
  {+34.1250f, +118.3367f, "Hollywood CA"},
  {+26.0100f, +080.1500f, "Hollywood FL"},
  {+42.2081f, +072.6100f, "Holyoke MA"},
  {+33.7767f, +117.1850f, "Homeland  March  CA"},
  {+21.3061f, +157.8597f, "+Honolulu HI"},
  {+45.5933f, +122.6050f, "Hood  OR"},
  {+36.8617f, +087.4717f, "Hopkinsville KY"},
  {+46.9467f, +124.1483f, "Hoquiam  WA"},
  {+34.4783f, +093.0900f, "Hot Springs  AR"},
  {+47.1667f, +088.4817f, "+Houghton  MI"},
  {+44.3583f, +084.6650f, "Houghton Lake  MI"},
  {+29.7572f, +095.3603f, "Houston TX"},
  {+31.5683f, +105.3750f, "Hudspeth  TX"},
  {+29.9567f, +095.3450f, "Humble  TX"},
  {+34.5200f, +099.2750f, "Humphreys  OK"},
  {+32.0117f, +081.1417f, "Hunter  GA"},
  {+38.2500f, +086.9567f, "Huntingburg  IN"},
  {+33.6683f, +118.0833f, "Huntington Beach CA"},
  {+38.4200f, +082.4425f, "Huntington WV"},
  {+34.7317f, +086.5867f, "Huntsville AL"},
  {+44.3600f, +098.2183f, "Huron SD"},
  {+38.0817f, +097.9283f, "Hutchinson KS"},
  {+32.1400f, +101.1233f, "Hyman  TX"},
  {+43.4917f, +112.0333f, "+Idaho Falls ID"},
  {-20.1000f, -057.7000f, "+Ile Maurice"},
  {+39.0933f, +094.4167f, "Independence MO"},
  {+39.7686f, +086.1628f, "+Indianapolis IN"},
  {+29.9567f, +096.5617f, "Industry  TX"},
  {+33.9600f, +118.3500f, "Inglewood CA"},
  {+48.5667f, +093.4050f, "+International Falls  MN"},
  {+68.4000f, +134.1000f, "Inuvik NT Canada"},
  {+41.6603f, +091.5314f, "Iowa City IA"},
  {+45.8167f, +088.1117f, "Iron Mountain  MI"},
  {+46.5317f, +090.1250f, "Ironwood  MI"},
  {+33.6750f, +117.7600f, "Irvine CA"},
  {+32.8133f, +096.9367f, "Irving TX"},
  {+40.7267f, +074.2250f, "Irvington NJ"},
  {+34.0000f, -073.0000f, "+Islamabad Pakistan"},
  {+41.0200f, -029.0000f, "Istanbul Turkey"},
  {+35.5983f, +088.3583f, "Jacks Creek  TN"},
  {+43.6083f, +110.7333f, "+Jackson  WY"},
  {+42.2453f, +084.4061f, "Jackson MI"},
  {+32.2989f, +090.1850f, "+Jackson MS"},
  {+35.6167f, +088.8133f, "Jackson TN"},
  {+34.8650f, +092.1117f, "Jacksonville AR"},
  {+30.3289f, +081.6617f, "+Jacksonville FL"},
  {-06.0000f, -107.0000f, "+Jakarta Indonesia"},
  {+46.9050f, +098.7050f, "Jamestown ND"},
  {+42.6817f, +089.0200f, "Janesville WI"},
  {+41.7600f, +080.7483f, "Jefferson  OH"},
  {+38.5167f, +092.2167f, "Jefferson City MO"},
  {+40.7305f, +074.0656f, "Jersey City NJ"},
  {+31.7800f, -035.2200f, "+Jerusalem Israel"},
  {-26.1666f, -028.0333f, "+Johannesburg South Africa"},
  {+36.3183f, +082.3533f, "Johnson City TN"},
  {+38.8400f, +094.7367f, "Johnson County  KS"},
  {+40.3264f, +078.9175f, "Johnstown PA"},
  {+41.5267f, +088.0800f, "Joliet IL"},
  {+35.8367f, +090.7067f, "Jonesboro AR"},
  {+37.0933f, +094.5117f, "Joplin MO"},
  {+30.5983f, +099.8167f, "Junction  TX"},
  {+58.3033f, +134.4083f, "+Juneau AK"},
  {+46.3650f, +087.3900f, "K.I.Sawyer AFB  MI"},
  {+34.5000f, -069.0000f, "+Kabul Afganistan"},
  {+42.2914f, +085.5872f, "Kalamazoo MI"},
  {+48.1950f, +114.3133f, "Kalispell MT"},
  {+00.2000f, -033.0000f, "+Kampala Uganda"},
  {+20.0017f, +155.6733f, "Kamuela  HI"},
  {+41.0750f, +087.8500f, "Kankakee  IL"},
  {+26.3000f, -080.1000f, "+Kanpur India"},
  {+39.1178f, +094.6400f, "Kansas City KS"},
  {+39.0822f, +094.5889f, "+Kansas City MO"},
  {+48.5000f, -046.2500f, "+Kapustin Yar  Russia"},
  {+24.5900f, -068.5600f, "+Karachi Pakistan"},
  {+27.5000f, -085.5000f, "+Katmandu Nepal"},
  {+19.6583f, +156.0283f, "Keahole  HI"},
  {+40.6983f, +099.0833f, "Kearney NE"},
  {+42.9333f, +071.2800f, "Keene NH"},
  {+29.5567f, +098.6467f, "Kelly  TX"},
  {+60.5500f, +151.2667f, "+Kenai AK"},
  {+43.4250f, +070.6133f, "Kennebunkport  ME"},
  {+28.6100f, +080.6920f, "Kennedy Space Center"},
  {+29.9833f, +090.2417f, "Kenner LA"},
  {+42.5953f, +087.8364f, "Kenosha WI"},
  {-49.0000f, -069.0000f, "+Kerguelen Islands"},
  {+55.3417f, +131.6467f, "+Ketchikan AK"},
  {+39.6867f, +084.1700f, "Kettering OH"},
  {+32.3667f, +088.4583f, "Kewanee  MS"},
  {+24.5850f, +081.8000f, "+Key West  FL"},
  {+15.5000f, -032.5000f, "+Khartoum Sudan"},
  {+50.2700f, -030.4000f, "+Kiev Ukraine"},
  {-02.0000f, -030.2000f, "+Kigali Rwanda"},
  {+44.6483f, +119.7100f, "Kimberly  OR"},
  {+35.8050f, +098.0033f, "Kingfisher  OK"},
  {+36.5450f, +082.5433f, "Kingsport TN"},
  {+18.0000f, +076.9000f, "+Kingston Jamaica"},
  {+44.1500f, +076.3000f, "Kingston ON Canada"},
  {-05.5000f, -015.5000f, "+Kinshasa Zaire"},
  {+40.1350f, +092.5917f, "Kirksville  MO"},
  {+43.2500f, +080.3500f, "Kitchener ON Canada"},
  {+42.1533f, +121.7267f, "Klamath Falls  OR"},
  {+35.7967f, +078.4392f, "Knightdale NC"},
  {+35.9608f, +083.9186f, "Knoxville TN"},
  {+57.7883f, +152.4033f, "+Kodiak AK"},
  {+21.2683f, +157.7050f, "Koko Head  HI"},
  {+40.5283f, +086.0583f, "Kokomo  IN"},
  {+03.0000f, -102.0000f, "+Kuala Lumpur Malaysia"},
  {+35.0000f, -135.4600f, "+Kyoto Japan"},
  {+43.8000f, +091.2450f, "La Crosse WI"},
  {+33.0483f, +085.2067f, "La Grange  GA"},
  {+32.7683f, +117.0417f, "La Mesa CA"},
  {-16.5000f, +068.0000f, "+La Paz Bolivia"},
  {+26.8283f, +081.3917f, "LaBelle  FL"},
  {+43.5267f, +071.4700f, "Laconia NH"},
  {+40.4197f, +086.8942f, "Lafayette IN"},
  {+30.2250f, +092.0200f, "Lafayette LA"},
  {+07.0000f, -003.0000f, "+Lagos Nigeria"},
  {+32.0000f, -074.1800f, "+Lahore Pakistan"},
  {+30.2283f, +093.2167f, "Lake Charles LA"},
  {+27.9867f, +082.0133f, "Lakeland  FL"},
  {+42.4933f, +120.5067f, "Lakeview  OR"},
  {+33.9500f, +118.1367f, "Lakewood CA"},
  {+39.7400f, +105.0783f, "Lakewood CO"},
  {+41.4867f, +081.8033f, "Lakewood OH"},
  {+40.5967f, +093.9667f, "Lamoni  IA"},
  {+31.1850f, +098.1417f, "Lampasas  TX"},
  {+20.7683f, +156.9717f, "Lanai  HI"},
  {+40.0403f, +076.3080f, "Lancaster PA"},
  {+42.8350f, +108.7333f, "Lander WY"},
  {+42.7336f, +084.5542f, "Lansing MI"},
  {+41.3117f, +105.5850f, "Laramie WY"},
  {+27.5061f, +099.5083f, "Laredo TX"},
  {+27.9183f, +082.7900f, "Largo FL"},
  {+32.3117f, +106.7783f, "Las Cruces NM"},
  {+27.9000f, +015.7000f, "+Las Palmas Spain"},
  {+36.1722f, +115.1436f, "+Las Vegas NV"},
  {+29.3600f, +100.7717f, "Laughlin  TX"},
  {+31.6883f, +089.1333f, "Laurel MS"},
  {+38.9633f, +095.2383f, "Lawrence KS"},
  {+42.7044f, +071.1689f, "Lawrence MA"},
  {+34.6117f, +098.4117f, "Lawton OK"},
  {+41.0617f, +111.9633f, "Layton UT"},
  {+39.3117f, +094.9133f, "Leavenworth KS"},
  {+43.6283f, +072.3050f, "Lebanon  NH"},
  {+29.1750f, +090.1033f, "Leeville  LA"},
  {+31.1233f, +095.9683f, "Leona  TX"},
  {+49.4200f, +112.5000f, "Lethbridge AB Canada"},
  {+49.1500f, +055.0400f, "Lewisporte NF Canada"},
  {+46.4117f, +117.0200f, "Lewiston ID"},
  {+44.0967f, +070.2183f, "Lewiston ME"},
  {+47.0533f, +109.6050f, "Lewistown  MT"},
  {+38.0472f, +084.4961f, "Lexington KY"},
  {+37.0450f, +100.9700f, "Liberal  KS"},
  {+00.5000f, -009.5000f, "+Libreville Gabon"},
  {+21.9800f, +159.3750f, "Lihue HI"},
  {-14.0000f, -034.0000f, "+Lilongwe Malawi"},
  {+40.7430f, +084.1055f, "Lima OH"},
  {-12.0000f, +077.0000f, "+Lima Peru"},
  {+40.8164f, +096.7042f, "Lincoln NE"},
  {+38.8000f, +009.1000f, "+Lisbon Portugal"},
  {+34.7450f, +092.2769f, "+Little Rock AR"},
  {+53.2500f, +002.5200f, "+Liverpool UK"},
  {+36.5850f, +085.1667f, "Livingston  TN"},
  {+45.6633f, +110.5633f, "Livingston MT"},
  {+42.3833f, +083.3750f, "Livonia MI"},
  {+30.7967f, +098.7867f, "Llano  TX"},
  {+41.7400f, +111.8283f, "Logan UT"},
  {+06.5000f, -001.5000f, "+Lome Togo"},
  {+37.0333f, +084.1100f, "London  KY"},
  {+51.5000f, +000.0000f, "+London UK"},
  {+43.2950f, +090.1333f, "Lone Rock  WI"},
  {+33.7706f, +118.1883f, "Long Beach CA"},
  {+32.4917f, +094.7333f, "Longview TX"},
  {+41.4680f, +082.1803f, "Lorain OH"},
  {+34.0542f, +118.2411f, "+Los Angeles CA"},
  {+41.6833f, +081.3950f, "Lost Nation  OH"},
  {+38.2464f, +085.7636f, "Louisville KY"},
  {+32.8483f, +096.8617f, "Love  TX"},
  {+34.7033f, +112.4800f, "Love Field  AZ"},
  {+42.6403f, +071.3205f, "Lowell MA"},
  {-08.4800f, -013.1400f, "+Luanda Angola"},
  {+33.5847f, +101.8425f, "+Lubbock TX"},
  {+41.3633f, +113.8400f, "Lucin  UT"},
  {+31.1617f, +094.7167f, "Lufkin  TX"},
  {-15.0000f, -029.0000f, "+Lusaka Zambia"},
  {+49.6000f, -006.2000f, "+Luxembourg Luxembourg"},
  {+37.4150f, +079.1433f, "Lynchburg VA"},
  {+42.4633f, +070.9483f, "Lynn MA"},
  {+39.6533f, +092.4817f, "Macon  MO"},
  {+32.8367f, +083.6267f, "Macon GA"},
  {+44.0067f, +097.1133f, "Madison SD"},
  {+43.0730f, +089.3819f, "+Madison WI"},
  {+13.0800f, -080.1500f, "+Madras India"},
  {+40.5000f, +003.8000f, "+Madrid Spain"},
  {+03.0000f, -008.4000f, "+Malabo Equatorial Guinea"},
  {+42.2000f, +112.4500f, "Malad City  ID"},
  {+36.5550f, +089.9117f, "Malden  MO"},
  {+42.4233f, +071.0667f, "Malden MA"},
  {+04.5000f, -073.0000f, "+Male Maldive Islands"},
  {+12.0000f, +086.5000f, "+Managua Nicaragua"},
  {+26.0000f, -051.0000f, "+Manama Bahrain"},
  {+41.7833f, +072.5233f, "Manchester CT"},
  {+42.9911f, +071.4614f, "Manchester NH"},
  {+53.2800f, +002.1400f, "+Manchester UK"},
  {+46.8267f, +100.8950f, "Mandan ND"},
  {+39.1833f, +096.5750f, "Manhattan KS"},
  {+14.3400f, -121.0000f, "+Manila Philippines"},
  {+44.2717f, +086.2300f, "Manistee  MI"},
  {+44.1283f, +087.6800f, "Manitowoc  WI"},
  {+39.8067f, +098.2600f, "Mankato  KS"},
  {+44.2200f, +093.9117f, "Mankato  MN"},
  {+49.3000f, -008.3100f, "+Mannheim Germany"},
  {+40.7567f, +082.5167f, "Mansfield OH"},
  {+37.8333f, +121.1700f, "Manteca  CA"},
  {+37.5900f, +091.7883f, "Maples  MO"},
  {-26.0000f, -032.0000f, "+Maputo Mozambique"},
  {+41.0150f, +083.6650f, "Marathon  OH"},
  {+30.2983f, +103.9550f, "Marfa  TX"},
  {+30.7867f, +085.1250f, "Marianna  FL"},
  {+33.9500f, +084.5467f, "Marietta GA"},
  {+40.4933f, +085.6800f, "Marion  IN"},
  {+46.5283f, +087.5850f, "+Marquette  MI"},
  {+43.1800f, -005.2500f, "+Marseille France"},
  {+44.4483f, +095.8250f, "Marshall  MN"},
  {+32.5500f, +094.3833f, "Marshall TX"},
  {+41.3933f, +070.6167f, "Martha's Vineyard MA"},
  {+14.5400f, +061.0000f, "Martinique"},
  {+39.1000f, +121.5667f, "Marysville  CA"},
  {+43.0950f, +093.3300f, "Mason City  IA"},
  {+20.9017f, +156.4350f, "Maui  HI"},
  {-26.0000f, -032.5000f, "+Mbabane Swaziland"},
  {+34.8500f, +095.7817f, "McAlester  OK"},
  {+26.2033f, +098.2300f, "Mcallen TX"},
  {+44.7667f, +116.2050f, "McCall  ID"},
  {+47.1483f, +122.4733f, "McChord  WA"},
  {+40.2033f, +100.5933f, "McCook  NE"},
  {+39.5950f, +084.2233f, "McGuire  OH"},
  {+35.6033f, +088.9100f, "McKellar  TN"},
  {-77.8000f, -167.0000f, "+McMurdo Station Antarctica"},
  {+35.4850f, +119.0967f, "Meadows Field  CA"},
  {+21.2700f, -039.4500f, "+Mecca Saudi Arabia"},
  {+03.3500f, -098.3500f, "+Medan Indonesia"},
  {-06.1500f, +075.3400f, "+Medellin Colombia"},
  {+42.4183f, +071.1067f, "Medford MA"},
  {+42.3233f, +122.8667f, "Medford OR"},
  {+41.8450f, +106.0033f, "Medicine Bow  WY"},
  {+50.0000f, +111.0000f, "Medicine Hat AB Canada"},
  {+28.1050f, +080.6350f, "Melbourne  FL"},
  {-37.8167f, -144.9667f, "+Melbourne Australia"},
  {+35.1461f, +090.0536f, "+Memphis TN"},
  {+39.0500f, +123.2667f, "Mendocino  CA"},
  {+45.1800f, +087.6467f, "Menominee  MI"},
  {+37.2167f, +120.4000f, "Merced  CA"},
  {+41.5350f, +072.7917f, "Meriden CT"},
  {+32.3667f, +088.7000f, "Meridian MS"},
  {+42.8183f, +070.8117f, "Merrimack NH"},
  {+28.4300f, +080.7500f, "Merritt Island FL"},
  {+33.4150f, +111.8283f, "Mesa AZ"},
  {+32.7650f, +096.5967f, "Mesquite TX"},
  {+19.4333f, +099.1166f, "+Mexico City Mexico"},
  {-26.5800f, -028.2000f, "Meyerton South Africa"},
  {+25.7883f, +080.1300f, "Miami Beach FL"},
  {+25.7769f, +080.1922f, "+Miami FL"},
  {+31.9950f, +102.0783f, "Midland TX"},
  {+39.4300f, +083.8017f, "Midwest  OH"},
  {+35.4500f, +097.3917f, "Midwest City OK"},
  {+45.2900f, -009.1200f, "+Milan Italy"},
  {+46.3817f, +105.9533f, "Miles City  MT"},
  {+38.3600f, +113.0117f, "Milford  UT"},
  {+41.2250f, +073.0600f, "Milford CT"},
  {+32.7267f, +097.9967f, "Millsap  TX"},
  {+43.0386f, +087.9042f, "+Milwaukee WI"},
  {+44.9825f, +093.2619f, "+Minneapolis MN"},
  {+44.9400f, +093.4433f, "Minnetonka MN"},
  {+48.2383f, +101.2967f, "Minot ND"},
  {+53.5400f, -027.3500f, "+Minsk Belarus"},
  {+43.3400f, +079.3900f, "Mississauga ON Canada"},
  {+46.8617f, +114.0083f, "Missoula MT"},
  {+43.5433f, +098.0250f, "Mitchell SD"},
  {+38.7567f, +109.7483f, "Moab  UT"},
  {+30.6933f, +088.0425f, "Mobile AL"},
  {+37.6433f, +121.0017f, "Modesto CA"},
  {+02.0000f, -045.0000f, "+Mogadiscio Somalia"},
  {+41.5086f, +090.5136f, "Moline IL"},
  {+21.1417f, +157.1700f, "Molokai  HI"},
  {+32.5000f, +092.1167f, "Monroe LA"},
  {+31.4600f, +087.3533f, "Monroeville  AL"},
  {+06.7000f, +010.8000f, "+Monrovia Liberia"},
  {+43.8000f, -007.5000f, "Monte Carlo Monaco"},
  {+34.0000f, +118.1000f, "Montebello CA"},
  {+34.0617f, +118.1267f, "Monterey Park CA"},
  {+44.9733f, +095.7117f, "Montevideo  MN"},
  {-34.9000f, +056.2000f, "+Montevideo Uruguay"},
  {+32.3758f, +086.3086f, "Montgomery AL"},
  {+33.5617f, +091.7150f, "Monticello  AR"},
  {+44.2600f, +072.5780f, "Montpelier VT"},
  {+45.5000f, +073.6000f, "+Montreal QB Canada"},
  {+35.3367f, +097.4883f, "Moore OK"},
  {+50.5000f, +106.0000f, "Moose Jaw SK Canada"},
  {+29.6983f, +091.2067f, "Morgan City LA"},
  {+39.6317f, +079.9533f, "Morgantown WV"},
  {-11.8000f, -043.2000f, "+Moroni Comoros Islands"},
  {+45.5667f, +095.9683f, "Morris  MN"},
  {+35.2517f, +120.7583f, "Morro Bay  CA"},
  {+46.7333f, +117.0000f, "Moscow ID"},
  {+55.7500f, -037.7000f, "+Moscow Russia"},
  {+47.2117f, +119.3150f, "Moses Lake  WA"},
  {+31.0817f, +083.8050f, "Moultrie  GA"},
  {+43.6233f, +084.7450f, "Mount Pleasant  MI"},
  {+40.9100f, +073.8250f, "Mount Vernon NY"},
  {+33.4983f, +086.7533f, "Mountain Brook AL"},
  {+42.9817f, +115.7733f, "Mountain Home  ID"},
  {+37.3883f, +122.0800f, "Mountain View CA"},
  {+47.4567f, +115.6450f, "Mullan Pass  ID"},
  {+40.1911f, +085.3878f, "Muncie IN"},
  {+35.8483f, +086.3917f, "Murfreesboro TN"},
  {+69.0000f, -033.2000f, "+Murmansk"},
  {+40.6600f, +111.8867f, "Murray UT"},
  {+34.7067f, +087.4917f, "Muscle Shoals  AL"},
  {+43.1700f, +086.0400f, "Muskegon  MI"},
  {+35.7450f, +095.3667f, "Muskogee OK"},
  {+33.7166f, +078.9000f, "Myrtle Beach SC"},
  {+37.8933f, +086.2450f, "Mystic  KY"},
  {+40.1450f, +110.1267f, "Myton  UT"},
  {+12.0000f, -016.0000f, "+N'Djamena Chad"},
  {+56.2900f, +061.5200f, "Nain NF Canada"},
  {-02.0000f, -036.0000f, "+Nairobi Kenya"},
  {+43.5733f, +116.5619f, "Nampa ID"},
  {+32.0400f, -118.4600f, "+Nanjing China"},
  {+38.3000f, +122.2900f, "Napa CA"},
  {+40.3700f, -014.1200f, "+Naples Italy"},
  {+39.0950f, +094.1283f, "Napoleon  MO"},
  {+36.1592f, +086.7819f, "+Nashville TN"},
  {+31.5633f, +091.3917f, "Natchez MS"},
  {+38.9206f, +077.0657f, "Naval Observatory USA"},
  {+30.2883f, +096.0583f, "Navasota  TX"},
  {+34.7667f, +114.4667f, "Needles  CA"},
  {+36.8417f, +094.4350f, "Neosho  MO"},
  {+46.5900f, -006.5600f, "Neuchatel Switzerland"},
  {+41.6369f, +070.9281f, "New Bedford MA"},
  {+41.6689f, +072.7831f, "New Britain CT"},
  {+39.6633f, +075.5617f, "New Castle DE"},
  {+28.6333f, -077.2000f, "+New Delhi India"},
  {+41.3069f, +072.9250f, "New Haven CT"},
  {+37.6317f, +085.6767f, "New Hope  KY"},
  {+30.0117f, +091.8233f, "New Iberia LA"},
  {+29.9480f, +090.0694f, "+New Orleans LA"},
  {+40.9083f, +073.7817f, "New Rochelle NY"},
  {+40.7517f, +073.9942f, "+New York NY"},
  {+39.6833f, +075.7583f, "Newark DE"},
  {+40.7372f, +074.1719f, "Newark NJ"},
  {+45.3533f, +122.9767f, "Newberg  OR"},
  {+46.3133f, +085.4650f, "Newberry  MI"},
  {-32.9333f, -151.7667f, "Newcastle Australia"},
  {+55.0000f, +001.4500f, "+Newcastle UK"},
  {+43.8800f, +104.3083f, "Newcastle  WY"},
  {+38.1583f, +082.9100f, "Newcombe  KY"},
  {+40.2300f, +081.4767f, "Newcomerstown  OH"},
  {+31.9517f, +106.2717f, "Newman  TX"},
  {+44.5750f, +124.0600f, "Newport  OR"},
  {+33.6200f, +117.9267f, "Newport Beach CA"},
  {+39.0883f, +084.4950f, "Newport KY"},
  {+36.9767f, +076.4183f, "Newport News VA"},
  {+41.4817f, +071.3167f, "Newport RI"},
  {+41.7833f, +093.1083f, "Newton  IA"},
  {+42.3483f, +071.1900f, "Newton MA"},
  {+43.0928f, +079.0572f, "Niagara Falls NY"},
  {+14.0000f, -003.0000f, "+Niamey Niger"},
  {+43.4200f, -007.2100f, "+Nice France"},
  {+35.0000f, -033.2000f, "+Nicosia Cyprus"},
  {+43.9117f, +091.4667f, "Nodine  MN"},
  {+31.4150f, +110.8483f, "Nogales Tucson  AZ"},
  {+64.5000f, +165.4167f, "+Nome AK"},
  {+42.0283f, +097.4167f, "Norfolk NE"},
  {+36.8528f, +076.2892f, "+Norfolk VA"},
  {+35.2167f, +097.4400f, "Norman OK"},
  {+52.4700f, +108.1700f, "North Battleford SK Canada"},
  {+46.1300f, +079.2600f, "North Bay ON Canada"},
  {+43.4150f, +124.1667f, "North Bend  OR"},
  {+32.8850f, +080.0000f, "North Charleston SC"},
  {+34.1333f, +118.4167f, "North Hollywood CA"},
  {+36.2033f, +115.1117f, "North Las Vegas NV"},
  {+34.7550f, +092.2667f, "North Little Rock AR"},
  {+77.0000f, +102.5000f, "+North Magnetic Pole"},
  {+90.0000f, +000.0000f, "+North Pole"},
  {+41.1383f, +100.7617f, "North Platte NE"},
  {+33.9017f, +118.0800f, "Norwalk CA"},
  {+41.1233f, +073.3650f, "Norwalk CT"},
  {+18.0000f, +015.7000f, "+Nouakchott Mauritania"},
  {-21.8000f, -166.9000f, "+Noumea New Caledonia"},
  {+55.0900f, -082.5800f, "+Novosibirsk Russia"},
  {+42.4700f, +098.6867f, "O'Neill  NE"},
  {+41.8817f, +087.7750f, "Oak Park IL"},
  {+36.0117f, +084.2667f, "Oak Ridge TN"},
  {+37.8008f, +122.2650f, "Oakland CA"},
  {+29.1767f, +082.2267f, "Ocala  FL"},
  {+33.1983f, +117.3767f, "Oceanside CA"},
  {+31.8583f, +102.3750f, "Odessa TX"},
  {+46.2800f, -030.4400f, "+Odessa Ukraine"},
  {+41.2253f, +111.9725f, "Ogden UT"},
  {+35.4739f, +097.5178f, "+Oklahoma City OK"},
  {+35.6933f, +095.8650f, "Okmulgee  OK"},
  {+38.8850f, +094.8217f, "Olathe KS"},
  {+47.0333f, +122.9667f, "+Olympia WA"},
  {+41.2617f, +095.9372f, "Omaha NE"},
  {+34.0617f, +117.6500f, "Ontario CA"},
  {+32.6483f, +085.3850f, "Opelika AL"},
  {+33.7867f, +117.8500f, "Orange CA"},
  {+40.3117f, +111.7000f, "Orem UT"},
  {+28.5450f, +081.3772f, "Orlando FL"},
  {+29.3033f, +081.1133f, "Ormond Beach  FL"},
  {+34.4000f, -135.2700f, "+Osaka Japan"},
  {+43.5000f, +078.5000f, "Oshawa ON Canada"},
  {+44.0217f, +088.5450f, "Oshkosh WI"},
  {+59.9000f, -011.0000f, "+Oslo Norway"},
  {+37.1567f, +095.2033f, "Oswego  KS"},
  {+45.4000f, +075.7500f, "+Ottawa ON Canada"},
  {+41.0283f, +092.3250f, "Ottumwa  IA"},
  {+12.5000f, +002.0000f, "+Ouagadougou Burkina Faso"},
  {+38.9700f, +094.6667f, "Overland Park KS"},
  {+37.7683f, +087.1133f, "Owensboro KY"},
  {+49.1200f, +102.1100f, "Oxbow SK Canada"},
  {+34.2050f, +119.1750f, "Oxnard CA"},
  {+32.7333f, +117.1667f, "Pacific Beach CA"},
  {+37.0869f, +088.5989f, "Paducah KY"},
  {-14.0000f, +170.5000f, "+Pago Pago American Samoa"},
  {+26.7817f, +080.6917f, "Pahokee  FL"},
  {+47.9033f, +122.2867f, "Paine  WA"},
  {+28.7633f, +096.3067f, "Palacios  TX"},
  {+26.6800f, +080.0867f, "Palm Beach  FL"},
  {+37.4417f, +122.1633f, "Palo Alto CA"},
  {+30.2167f, +085.6817f, "Panama City  FL"},
  {+09.0000f, +079.0000f, "+Panama City Panama"},
  {-17.5000f, +149.5000f, "Papeete French Polynesia"},
  {+36.1000f, +115.1167f, "Paradise NV"},
  {+05.5000f, +055.5000f, "+Paramaribo Surinam"},
  {+33.5417f, +095.4483f, "Paris  TX"},
  {+48.8400f, -002.3400f, "+Paris France"},
  {+46.8983f, +095.0700f, "Park Rapids  MN"},
  {+39.2667f, +081.5583f, "Parkersburg WV"},
  {+41.3850f, +081.7117f, "Parma OH"},
  {+34.1456f, +118.1447f, "Pasadena CA"},
  {+29.7133f, +095.2117f, "Pasadena TX"},
  {+30.3533f, +088.5467f, "Pascagoula MS"},
  {+46.2633f, +119.1150f, "Pasco  WA"},
  {+35.6733f, +120.6267f, "Paso Robles  CA"},
  {+40.9169f, +074.1725f, "Paterson NJ"},
  {+40.2000f, +096.2067f, "Pawnee City  NE"},
  {+41.8783f, +071.3833f, "Pawtucket RI"},
  {+35.6250f, +113.5433f, "Peach Springs  AZ"},
  {+43.2567f, +082.7183f, "Peck  MI"},
  {+31.4700f, +103.5750f, "Pecos  TX"},
  {+45.6300f, +084.6633f, "Pellston  MI"},
  {+48.8700f, +097.1167f, "Pembina  ND"},
  {+45.6983f, +118.9383f, "Pendleton  OR"},
  {+30.4142f, +087.2155f, "Pensacola FL"},
  {+40.6950f, +089.5925f, "Peoria IL"},
  {-31.9500f, -115.8500f, "+Perth Australia"},
  {+44.2000f, +078.2000f, "Peterborough ON Canada"},
  {+32.4633f, +085.0033f, "Phenix City AL"},
  {+39.9494f, +075.1558f, "+Philadelphia PA"},
  {+44.0583f, +101.6633f, "Philip  SD"},
  {+11.5000f, -105.0000f, "+Phnom Penh Cambodia"},
  {+33.4500f, +112.0600f, "Phoenix AZ"},
  {+30.5250f, +089.6783f, "Picayune MS"},
  {+34.0000f, +118.0833f, "Pico Rivera CA"},
  {+44.3717f, +100.3483f, "+Pierre SD"},
  {+34.2233f, +092.0167f, "Pine Bluff AR"},
  {+32.5283f, +105.3050f, "Pinon  NM"},
  {+36.7467f, +097.1600f, "Pioneer  OK"},
  {+40.4386f, +080.0000f, "+Pittsburgh PA"},
  {+42.4480f, +073.2539f, "Pittsfield MA"},
  {+34.0867f, +101.7900f, "Plainview  TX"},
  {+33.0200f, +096.7000f, "Plano TX"},
  {+63.0000f, -040.2500f, "+Plesetsk Russia"},
  {+42.8733f, +112.4500f, "Pocatello ID"},
  {+37.9283f, +087.7617f, "Pocket City  IN"},
  {+32.6167f, +116.9833f, "Poggi  CA"},
  {+34.0617f, +117.7500f, "Pomona CA"},
  {+26.2333f, +080.1250f, "Pompano Beach FL"},
  {+42.6367f, +083.2917f, "Pontiac MI"},
  {+29.8750f, +093.9375f, "Port Arthur TX"},
  {+18.4000f, +072.3000f, "+Port Au Prince Haiti"},
  {+41.3700f, +091.1433f, "Port City  IA"},
  {-20.1000f, -057.7000f, "+Port Louis Mauritius"},
  {-09.5000f, -147.4000f, "+Port Moresby Papua New Guinea"},
  {+66.5000f, +118.0000f, "+Port Radium NT Canada"},
  {+35.9133f, +119.0200f, "Porterville  CA"},
  {+43.6592f, +070.2553f, "Portland ME"},
  {+45.5183f, +122.6764f, "+Portland OR"},
  {-29.5800f, +051.1100f, "+Porto Alegre Brazil"},
  {+07.0000f, -002.5000f, "+Porto Novo Benin"},
  {+43.0750f, +070.7567f, "Portsmouth NH"},
  {+36.8353f, +076.3039f, "Portsmouth VA"},
  {+50.1000f, -014.5000f, "+Prague Czechia"},
  {+34.5467f, +112.4717f, "Prescott AZ"},
  {-25.0000f, -028.0000f, "Pretoria South Africa"},
  {+53.1200f, +105.4600f, "Prince Albert SK Canada"},
  {+54.0000f, +130.5000f, "Prince Rupert BC Canada"},
  {+49.2700f, +120.3100f, "Princeton BC Canada"},
  {+41.8255f, +071.4114f, "+Providence RI"},
  {+40.2350f, +111.6567f, "Provo UT"},
  {+38.2714f, +104.6092f, "Pueblo CO"},
  {+46.6750f, +117.2233f, "Pullman  WA"},
  {+26.9167f, +081.9917f, "Punta Gorda  FL"},
  {+35.0800f, -129.0500f, "+Pusan South Korea"},
  {+39.0000f, -125.8000f, "+Pyongyang North Korea"},
  {+46.8166f, +071.2000f, "+Quebec QB Canada"},
  {+14.8000f, -121.0000f, "+Quezon Philippines"},
  {+42.2517f, +071.0017f, "Quincy MA"},
  {+32.8800f, +095.3667f, "Quitman  TX"},
  {-00.5000f, +078.5000f, "+Quito Ecuador"},
  {+34.0000f, +006.8000f, "+Rabat Morocco"},
  {+42.7303f, +087.7867f, "Racine WI"},
  {+37.9750f, +080.8067f, "Rainelle  WV"},
  {+35.7772f, +078.6392f, "+Raleigh NC"},
  {+33.7675f, +118.4033f, "Rancho Palos Verdes CA"},
  {+17.0000f, -096.0000f, "+Rangoon Burma"},
  {+44.0800f, +103.2283f, "+Rapid City SD"},
  {+61.5000f, +112.5000f, "Rat River NT Canada"},
  {+41.7900f, +107.2383f, "Rawlins WY"},
  {+36.2467f, +094.1217f, "Razorback  AR"},
  {+39.4400f, +106.8950f, "Read Table(Eagle) CO"},
  {+40.3358f, +075.9278f, "Reading PA"},
  {+40.1000f, +122.2333f, "Red Bluff  CA"},
  {+52.1600f, +113.4800f, "Red Deer AB Canada"},
  {+40.5050f, +122.2900f, "+Redding  CA"},
  {+44.2533f, +121.3017f, "Redmond  OR"},
  {+33.8267f, +118.3867f, "Redondo Beach CA"},
  {+37.4667f, +122.2500f, "Redwood City CA"},
  {+44.4667f, +095.1283f, "Redwood Falls  MN"},
  {+50.2500f, +104.3900f, "Regina SK Canada"},
  {+68.5000f, +134.0000f, "+Reindeer Depot NT Canada"},
  {+39.5242f, +119.8111f, "+Reno NV"},
  {+34.2000f, +118.5333f, "Reseda CA"},
  {-21.0000f, -055.6000f, "+Reunion Island"},
  {+43.8233f, +111.7850f, "Rexburg ID"},
  {+64.0900f, +021.3900f, "+Reykjavik Iceland"},
  {+45.6333f, +089.4583f, "Rhinelander  WI"},
  {+34.6800f, +094.6083f, "Rich Mountain  OK"},
  {+32.9533f, +096.7250f, "Richardson TX"},
  {+39.7550f, +084.8383f, "Richmond IN"},
  {+37.9367f, +122.3467f, "Richmond CA"},
  {+37.5375f, +077.4358f, "Richmond VA"},
  {-22.8953f, +043.2228f, "+Rio De Janeiro Brazil"},
  {+39.1200f, +094.5967f, "Riverside  MO"},
  {+33.9800f, +117.3650f, "Riverside CA"},
  {+43.0250f, +108.3850f, "Riverton WY"},
  {+24.8000f, -047.0000f, "+Riyadh Saudi Arabia"},
  {+37.2703f, +079.9455f, "Roanoke VA"},
  {+39.0183f, +087.6483f, "Robinson  IL"},
  {+44.0225f, +092.4675f, "Rochester MN"},
  {+43.3033f, +070.9750f, "Rochester NH"},
  {+43.1614f, +077.6058f, "Rochester NY"},
  {+34.9283f, +081.0233f, "Rock Hill SC"},
  {+41.5850f, +109.2250f, "Rock Springs WY"},
  {+34.7967f, +086.6333f, "Rocket  AL"},
  {+42.2686f, +089.0967f, "Rockford IL"},
  {-23.3667f, -150.5333f, "Rockhampton Australia"},
  {+30.0150f, +100.3000f, "Rocksprings  TX"},
  {+39.0833f, +077.1433f, "Rockville MD"},
  {+34.1617f, +085.1200f, "Rome  GA"},
  {+42.5900f, +117.8667f, "Rome  OR"},
  {+41.8833f, -012.5000f, "+Rome Italy"},
  {+48.8550f, +095.6950f, "Roseau  MN"},
  {+43.1833f, +123.3517f, "Roseburg  OR"},
  {+42.5033f, +082.9367f, "Roseville MI"},
  {+33.3950f, +104.5267f, "Roswell NM"},
  {+51.5500f, -004.2700f, "+Rotterdam Netherlands"},
  {+42.5067f, +083.1467f, "Royal Oak MI"},
  {+32.5250f, +092.6383f, "Ruston LA"},
  {+43.6083f, +072.9717f, "Rutland VT"},
  {+29.6867f, +094.0383f, "Sabine Pass  TX"},
  {+45.9000f, +064.3000f, "Sackville PE Canada"},
  {+43.5000f, +070.4433f, "Saco ME"},
  {+38.5825f, +121.4947f, "+Sacramento CA"},
  {+43.4311f, +083.9347f, "Saginaw MI"},
  {+43.1000f, +079.1400f, "Saint Catharine's ON Canada"},
  {+37.0917f, +113.5967f, "Saint George  UT"},
  {+45.1600f, +066.0300f, "Saint John NB Canada"},
  {+47.3400f, +052.4300f, "Saint John's NF Canada"},
  {+42.4083f, +083.5950f, "Salem  MI"},
  {+42.7000f, +071.2500f, "Salem NH"},
  {+44.9300f, +123.0200f, "Salem OR"},
  {+38.8350f, +097.6083f, "Salina KS"},
  {+36.6700f, +121.6517f, "Salinas CA"},
  {+45.0217f, +114.0833f, "Salmon  ID"},
  {+31.7483f, +105.0867f, "Salt Flat  TX"},
  {+40.7564f, +111.8905f, "+Salt Lake City UT"},
  {-12.5900f, +038.2700f, "+Salvador Brazil"},
  {+38.4850f, +088.0850f, "Samsville  IL"},
  {+31.4608f, +100.4342f, "San Angelo TX"},
  {+29.4269f, +098.4850f, "+San Antonio TX"},
  {+34.1083f, +117.2911f, "San Bernardino CA"},
  {+32.7147f, +117.1558f, "San Diego CA"},
  {+37.6183f, +122.3733f, "+San Francisco CA"},
  {+37.3378f, +121.8900f, "San Jose CA"},
  {+10.0000f, +084.4000f, "+San Jose Costa Rica"},
  {+18.4500f, +066.0666f, "+San Juan Puerto Rico"},
  {+37.7250f, +122.1550f, "San Leandro CA"},
  {+37.5633f, +122.3233f, "San Mateo CA"},
  {+37.5933f, +122.5183f, "San Pedro CA"},
  {+13.5000f, +089.0000f, "+San Salvador El Salvador"},
  {+15.5000f, -044.0000f, "+San'a Yemen"},
  {+30.1600f, +102.4100f, "Sanderson TX"},
  {+41.4350f, +082.6550f, "Sandusky  OH"},
  {+43.4417f, +070.7767f, "Sanford ME"},
  {+35.2517f, +120.7583f, "San Luis Obispo  CA"},
  {+33.7633f, +117.8650f, "Santa Ana CA"},
  {+34.4217f, +119.6986f, "Santa Barbara CA"},
  {+37.3450f, +121.9467f, "Santa Clara CA"},
  {+35.6864f, +105.9361f, "+Santa Fe NM"},
  {+34.0133f, +118.4850f, "Santa Monica CA"},
  {+38.4400f, +122.7150f, "Santa Rosa CA"},
  {-33.2000f, +072.0000f, "+Santiago Chile"},
  {+18.4000f, +069.9000f, "+Santo Domingo Dominican Republic"},
  {-23.3400f, +046.3800f, "+Sao Paulo Brazil"},
  {+43.5000f, -018.2600f, "+Sarajevo Bosnia"},
  {+27.3367f, +082.5317f, "Sarasota FL"},
  {+52.0700f, +106.3800f, "Saskatoon SK Canada"},
  {+30.4717f, +087.3367f, "Saufley  FL"},
  {+46.4117f, +084.3150f, "+Sault Sainte Marie ON Canada"},
  {+32.0783f, +081.0936f, "+Savannah GA"},
  {+35.3450f, +099.6350f, "Sayre  OK"},
  {+43.4500f, +079.1200f, "Scarborough ON Canada"},
  {+42.0400f, +088.0800f, "Schaumburg IL"},
  {+42.8117f, +073.9283f, "Schenectady NY"},
  {+29.2683f, +094.8683f, "Scholes  TX"},
  {+45.9767f, +086.1733f, "Schoolcraft Co  MI"},
  {+41.8950f, +103.4817f, "Scottsbluff  NE"},
  {+33.4883f, +111.9267f, "Scottsdale AZ"},
  {+41.4089f, +075.6628f, "Scranton PA"},
  {+32.4650f, +096.3367f, "Scurry  TX"},
  {+38.6417f, +075.6117f, "Seaford DE"},
  {+41.1200f, +101.7767f, "Searle  NE"},
  {+47.6089f, +122.3367f, "+Seattle WA"},
  {+32.4167f, +087.0233f, "Selma AL"},
  {+37.6000f, -127.5000f, "+Seoul South Korea"},
  {+39.0133f, +094.7150f, "Shawnee KS"},
  {+43.7600f, +087.7483f, "Sheboygan WI"},
  {+40.8817f, +082.6617f, "Shelby OH"},
  {+35.5617f, +086.4400f, "Shelbyville  TN"},
  {-36.3833f, -145.4000f, "Shepparton Australia"},
  {+45.2400f, +071.5400f, "Sherbrooke QB Canada"},
  {+44.7967f, +106.9617f, "Sheridan WY"},
  {+32.5128f, +093.7494f, "Shreveport LA"},
  {+41.0967f, +102.9833f, "Sidney  NE"},
  {+32.6383f, +108.1600f, "Silver City  NM"},
  {+34.2683f, +118.7783f, "Simi Valley CA"},
  {+02.0000f, -104.0000f, "+Singapore Singapore"},
  {+42.4961f, +096.4083f, "Sioux City IA"},
  {+43.5430f, +096.7264f, "Sioux Falls SD"},
  {+41.7867f, +122.4633f, "Siskiyou County  CA"},
  {+42.0433f, +087.7467f, "Skokie IL"},
  {+30.2750f, +089.8017f, "Slidell LA"},
  {+39.3028f, +075.6067f, "Smyrna DE"},
  {+35.7900f, +083.0533f, "Snowbird  TN"},
  {+34.3383f, +106.8200f, "Socorro  NM"},
  {+42.8000f, -023.3000f, "+Sofia Bulgaria"},
  {+42.3875f, +071.1019f, "Somerville MA"},
  {+41.6758f, +086.2503f, "South Bend IN"},
  {+33.9550f, +118.2050f, "South Gate CA"},
  {+21.9033f, +159.5317f, "South Kauai  HI"},
  {-69.0000f, -143.0000f, "+South Magnetic Pole"},
  {-90.0000f, +000.0000f, "+South Pole"},
  {+43.6350f, +070.2500f, "South Portland ME"},
  {+42.4750f, +083.2767f, "Southfield MI"},
  {+49.5000f, -069.5000f, "+Soyuz Landing Zone Kazakhstan"},
  {+39.5383f, +119.7533f, "Sparks NV"},
  {+34.9508f, +081.9350f, "Spartanburg SC"},
  {+61.1883f, +149.9167f, "Spenard AK"},
  {+43.1633f, +095.1933f, "Spencer  IA"},
  {+47.6589f, +117.4258f, "+Spokane WA"},
  {+39.8917f, +089.6250f, "Springfield IL"},
  {+42.1058f, +072.5922f, "Springfield MA"},
  {+37.2175f, +093.2922f, "Springfield MO"},
  {+39.9272f, +083.8080f, "Springfield OH"},
  {+44.0500f, +123.0200f, "Springfield OR"},
  {+43.2967f, +072.4817f, "Springfield VT"},
  {+44.9500f, +093.1000f, "St. Paul MN"},
  {+38.7867f, +090.4800f, "St. Charles MO"},
  {+42.4967f, +082.8867f, "St. Clair Shores MI"},
  {+45.5667f, +094.1733f, "St. Cloud MN"},
  {+39.7658f, +094.8506f, "St. Joseph MO"},
  {+38.6292f, +090.2061f, "St. Louis MO"},
  {+44.9433f, +093.3500f, "St. Louis Park MN"},
  {+44.9553f, +093.1019f, "St. Paul MN"},
  {+27.7717f, +082.6386f, "+St. Petersburg FL"},
  {+59.5700f, -030.2000f, "+Saint Petersburg Russia"},
  {+29.9583f, +081.3383f, "+St. Augustine  FL"},
  {+41.0525f, +073.5400f, "Stamford CT"},
  {-52.0000f, +058.0000f, "+Stanley Falkland Islands"},
  {+40.5833f, +074.1500f, "Staten Island NY"},
  {+42.5833f, +083.0167f, "Sterling Heights MI"},
  {+40.3617f, +080.6147f, "Steubenville OH"},
  {+44.5433f, +089.5300f, "Stevens Point  WI"},
  {+36.2250f, +097.0817f, "Stillwater  OK"},
  {+29.2583f, +098.4433f, "Stinson  TX"},
  {+59.0000f, -018.0000f, "+Stockholm Sweden"},
  {+37.9583f, +121.2878f, "Stockton CA"},
  {+30.2067f, +098.7050f, "Stonewall  TX"},
  {+41.2000f, +073.1333f, "Stratford CT"},
  {+37.1700f, +097.0400f, "Strother  KS"},
  {+48.4800f, -009.1500f, "+Stuttgart Germany"},
  {+36.7283f, +076.5800f, "Suffolk VA"},
  {+46.2500f, +081.0000f, "Sudbury ON Canada"},
  {+33.1983f, +095.5417f, "Sulphur Springs  TX"},
  {+33.9183f, +080.3467f, "Sumter SC"},
  {+37.3767f, +122.0333f, "Sunnyvale CA"},
  {+38.0400f, +092.6033f, "Sunshine  MO"},
  {+46.7206f, +092.1019f, "Superior WI"},
  {-18.0000f, -178.0000f, "+Suva Fiji"},
  {+32.6050f, +082.3667f, "Swainsboro  GA"},
  {+50.5000f, +108.0000f, "Swift Current SK Canada"},
  {-33.8833f, -151.2167f, "+Sydney Australia"},
  {+46.0900f, +060.1100f, "Sydney NS Canada"},
  {+43.0511f, +076.1539f, "Syracuse NY"},
  {+47.2497f, +122.4375f, "Tacoma WA"},
  {-17.5000f, +149.5000f, "+Tahiti"},
  {+24.9000f, -122.0000f, "+Taipei Taiwan"},
  {+33.5750f, +086.0433f, "Talladega  AL"},
  {+30.4450f, +084.2817f, "+Tallahassee FL"},
  {+27.9494f, +082.4569f, "Tampa FL"},
  {+36.6083f, +105.9050f, "Taos  NM"},
  {+48.3000f, +124.6250f, "Tatoosh  WA"},
  {+30.5050f, +082.5533f, "Taylor  FL"},
  {+42.2250f, +083.2683f, "Taylor MI"},
  {+14.0000f, +087.5000f, "+Tegucigalpa Honduras"},
  {+35.5000f, -052.0000f, "+Tehran Iran"},
  {+41.7600f, +096.1783f, "Tekamah  NE"},
  {+32.0300f, -034.4600f, "+Tel Aviv-Yafo Israel"},
  {+33.4150f, +111.9283f, "Tempe AZ"},
  {+31.2100f, +097.4250f, "Temple  TX"},
  {+28.4000f, +016.6000f, "+Teneriffe Island"},
  {-55.0000f, +070.0000f, "+Tierra Del Fuego S. America"},
  {+39.4675f, +087.4072f, "Terre Haute IN"},
  {+33.4300f, +094.0417f, "Texarkana AR"},
  {+33.4300f, +094.0417f, "Texarkana TX"},
  {+34.4933f, +102.8317f, "Texico  NM"},
  {+45.7133f, +121.1000f, "The Dalles  OR"},
  {+41.9817f, +100.7183f, "Thedford  NE"},
  {+33.6283f, +116.1600f, "Thermal  CA"},
  {+40.3800f, -022.5900f, "+Thessaloniki Greece"},
  {+29.7950f, +090.8067f, "Thibodaux LA"},
  {+48.0700f, +096.1867f, "Thief River Falls  MN"},
  {+27.5000f, -089.5000f, "+Thimbu Bhutan"},
  {+55.4800f, +097.5900f, "Thompson MB Canada"},
  {+39.8633f, +104.9650f, "Thornton CO"},
  {+34.1717f, +118.8400f, "Thousand Oaks CA"},
  {+28.5050f, +098.1517f, "Three Rivers  TX"},
  {+77.5000f, +065.5000f, "+Thule Greenland"},
  {+48.2800f, +089.1200f, "Thunder Bay ON Canada"},
  {+29.6633f, +090.8283f, "Tibby  LA"},
  {+38.9717f, +092.3650f, "Tiger  MO"},
  {+48.2500f, +081.2200f, "Timmins ON Canada"},
  {+35.4000f, +097.3783f, "Tinker  OK"},
  {+41.2000f, -019.9000f, "+Tirana Albania"},
  {+34.6950f, +083.2983f, "Toccoa  GA"},
  {+35.7500f, -139.5833f, "+Tokyo Japan"},
  {+41.6539f, +083.5442f, "Toledo OH"},
  {+38.0300f, +117.0333f, "Tonopah NV"},
  {+39.0544f, +095.6730f, "+Topeka KS"},
  {+43.7000f, +079.4000f, "+Toronto ON Canada"},
  {+33.8250f, +118.3083f, "Torrance CA"},
  {-19.2667f, -146.8167f, "Townsville Australia"},
  {+44.6683f, +085.5500f, "Traverse City  MI"},
  {+38.3500f, +121.8167f, "Travis  CA"},
  {+40.2206f, +074.7703f, "Trenton NJ"},
  {+29.5467f, +094.7467f, "Trinity  TX"},
  {+33.0000f, -013.0000f, "+Tripoli Libya"},
  {+46.2100f, +072.3500f, "Trois-Rivieres PQ Canada"},
  {+31.8633f, +086.0117f, "Troy  AL"},
  {+42.6100f, +083.1500f, "Troy MI"},
  {+42.7292f, +073.6828f, "Troy NY"},
  {+33.2817f, +107.2800f, "+Truth or Consequences NM"},
  {+36.1217f, +111.2683f, "Tuba City AZ"},
  {+32.2208f, +110.9689f, "Tucson AZ"},
  {+35.1817f, +103.5983f, "Tucumcari  NM"},
  {+36.1533f, +095.9928f, "+Tulsa OK"},
  {+37.0000f, -010.0000f, "+Tunis Tunisia"},
  {+34.2233f, +088.7967f, "Tupelo  MS"},
  {+45.0500f, -007.4400f, "+Turin Italy"},
  {+33.2050f, +087.5667f, "Tuscaloosa AL"},
  {+32.2350f, +099.8167f, "Tuscola  TX"},
  {+32.4850f, +085.6700f, "Tuskegee  AL"},
  {+34.1117f, +115.7700f, "Twentynine Palms  CA"},
  {+42.5617f, +114.4700f, "Twin Falls ID"},
  {+32.3450f, +095.3017f, "Tyler TX"},
  {+46.1090f, -063.9580f, "Tyuratam (Proton) Kazakhstan"},
  {+46.0160f, -063.5730f, "+Tyuratam (Soyuz) Kazakhstan"},
  {+47.0000f, -106.0000f, "+Ulan Bator Mongolia"},
  {+40.7533f, +074.0383f, "Union City NJ"},
  {+38.6600f, +090.3333f, "University City MO"},
  {+20.2033f, +155.8467f, "Upolu Point  HI"},
  {+40.1117f, +088.2017f, "Urbana IL"},
  {+43.1033f, +075.2258f, "Utica NY"},
  {+61.1000f, +146.1800f, "+Valdez AK"},
  {+30.8317f, +083.2783f, "Valdosta GA"},
  {+38.1100f, +122.2500f, "Vallejo CA"},
  {+35.9000f, -014.5000f, "+Valletta Malta"},
  {+34.1833f, +118.3667f, "Van Nuys CA"},
  {+33.4750f, +080.4483f, "Vance  SC"},
  {+45.6250f, +122.6700f, "Vancouver WA"},
  {+33.9000f, +118.4417f, "Venice CA"},
  {+45.2500f, -012.1800f, "+Venice Italy"},
  {+34.2833f, +119.3000f, "Ventura CA"},
  {+42.7800f, +096.9283f, "Vermillion SD"},
  {+40.3783f, +109.4933f, "Vernal  UT"},
  {+27.6783f, +080.4900f, "Vero Beach  FL"},
  {+38.1533f, +091.7067f, "Vichy  MO"},
  {+32.3483f, +090.8783f, "Vicksburg MS"},
  {+46.2600f, +123.2300f, "+Victoria BC Canada"},
  {+22.5000f, -114.0000f, "+Victoria Hong Kong"},
  {-06.0000f, -052.0000f, "+Victoria Seychelles"},
  {+28.8050f, +097.0050f, "Victoria TX"},
  {+32.2133f, +083.4967f, "Vienna  GA"},
  {+48.2000f, -016.2000f, "+Vienna Austria"},
  {+19.0000f, -103.0000f, "+Vientiane Laos"},
  {+39.4867f, +075.0267f, "Vineland NJ"},
  {+36.8467f, +075.9750f, "Virginia Beach VA"},
  {+36.3350f, +119.2967f, "Visalia CA"},
  {+43.0600f, -131.4700f, "+Vladivostok Russia"},
  {+33.6700f, +086.9000f, "Vulcan  AL"},
  {+31.5533f, +097.1333f, "+Waco TX"},
  {+21.5000f, +158.0333f, "Wahiawa HI"},
  {+46.0689f, +118.3400f, "+Walla Walla WA"},
  {+38.4300f, +075.3600f, "Wallops Island VA"},
  {+37.9017f, +122.0583f, "Walnut Creek CA"},
  {+42.3733f, +071.2367f, "Waltham MA"},
  {+32.6167f, +083.6017f, "Warner Robins GA"},
  {+42.5083f, +083.0267f, "Warren MI"},
  {+41.2367f, +080.8083f, "Warren OH"},
  {+52.2500f, -021.0000f, "+Warsaw Poland"},
  {+41.7017f, +071.4583f, "Warwick RI"},
  {+38.8975f, +077.0092f, "Washington DC"},
  {+41.5536f, +073.0419f, "Waterbury CT"},
  {+42.4944f, +092.3389f, "Waterloo IA"},
  {+44.9017f, +097.1133f, "Watertown SD"},
  {+42.3583f, +087.8333f, "Waukegan IL"},
  {+43.0022f, +088.2367f, "Waukesha WI"},
  {+43.2800f, +091.5367f, "Waukon  IA"},
  {+44.8467f, +089.5867f, "Wausau  WI"},
  {+43.0517f, +088.0067f, "Wauwatasa WI"},
  {+31.2700f, +082.5567f, "Waycross  GA"},
  {+40.4050f, +080.5883f, "Weirton WV"},
  {-41.2833f, -174.7667f, "+Wellington New Zealand"},
  {+47.4000f, +120.2100f, "Wenatchee  WA"},
  {+43.0083f, +088.0067f, "West Allis WI"},
  {+43.4217f, +088.1250f, "West Bend WI"},
  {+34.0717f, +117.9094f, "West Corina CA"},
  {+46.8717f, +096.9033f, "West Fargo ND"},
  {+41.7500f, +072.7400f, "West Hartford CT"},
  {+41.2833f, +072.9533f, "West Haven CT"},
  {+35.1467f, +090.1767f, "West Memphis AR"},
  {+26.7167f, +080.0533f, "West Palm Beach FL"},
  {+41.7083f, +071.5250f, "West Warwick RI"},
  {+43.6767f, +070.3633f, "Westbrook ME"},
  {+42.2967f, +083.3867f, "Westland MI"},
  {+33.7750f, +117.9933f, "Westminster CA"},
  {+39.8300f, +105.0333f, "Westminster CO"},
  {+42.2217f, +070.9650f, "Weymouth MA"},
  {+40.0675f, +080.7222f, "Wheeling WV"},
  {+43.5750f, +085.7167f, "White Cloud  MI"},
  {+29.6633f, +092.3733f, "White Lake  LA"},
  {+41.0333f, +073.7633f, "White Plains NY"},
  {+45.8617f, +112.1683f, "Whitehall  MT"},
  {+60.3900f, +135.0100f, "+Whitehorse YT Canada "},
  {+37.7633f, +080.3017f, "White Sulphur Springs WV"},
  {+33.9667f, +118.0417f, "Whittier CA"},
  {+33.9094f, +098.4911f, "Wichita Falls TX"},
  {+37.6917f, +097.3378f, "+Wichita KS"},
  {+43.5933f, +118.9533f, "Wildhorse  OR"},
  {+35.5333f, +097.6467f, "Wiley Post  OK"},
  {+41.2422f, +075.8880f, "Wilkes-Barre PA"},
  {+35.3583f, +097.6083f, "Will Rogers  OK"},
  {+39.0667f, +122.0333f, "Williams  CA"},
  {+37.7550f, +089.0117f, "Williamson-Marion IL"},
  {+48.1483f, +103.6217f, "Williston ND"},
  {+45.1183f, +095.0900f, "Willmar  MN"},
  {+42.2367f, +083.5250f, "Willow Run  MI"},
  {+39.7461f, +075.5475f, "+Wilmington DE"},
  {+34.2300f, +077.9400f, "Wilmington NC"},
  {-22.0000f, -018.0000f, "+Windhoek Namibia"},
  {+31.8750f, +103.2433f, "Wink  TX"},
  {+43.4883f, +099.7617f, "Winner  SD"},
  {+49.5300f, +097.0900f, "+Winnipeg MB Canada"},
  {+44.0767f, +091.7050f, "Winona  MN"},
  {+35.0617f, +110.7950f, "Winslow Prescott  AZ"},
  {+36.0978f, +080.2450f, "+Winston-Salem NC"},
  {+31.2850f, +085.4317f, "Wiregrass  AL"},
  {+41.3750f, +098.3533f, "Wolbach  NE"},
  {+41.2467f, +085.4967f, "Wolf Lake  IN"},
  {+36.3733f, +097.7883f, "Woodring  OK"},
  {+42.2603f, +071.8047f, "Worcester MA"},
  {+43.9650f, +107.9500f, "Worland  WY"},
  {+43.6467f, +095.5817f, "Worthington  MN"},
  {+30.3000f, -114.1500f, "+Wuhan China"},
  {+42.8967f, +085.7067f, "Wyoming MI"},
  {+34.2000f, -109.0000f, "+Xi'an China"},
  {+46.5950f, +120.5133f, "+Yakima WA"},
  {+42.8750f, +097.3900f, "Yankton SD"},
  {+39.5267f, +082.9783f, "Yellow Bud  OH"},
  {+62.2900f, +114.3800f, "+Yellowknife NT Canada"},
  {+35.3700f, -139.4000f, "+Yokohama Japan"},
  {+40.9319f, +073.8983f, "Yonkers NY"},
  {+38.6433f, +082.9783f, "York  KY"},
  {+39.9597f, +076.7267f, "York PA"},
  {+41.0992f, +080.6505f, "Youngstown OH"},
  {+32.7150f, +114.6233f, "+Yuma AZ"},
  {+39.9383f, +082.0083f, "Zanesville OH"},
  {+34.4600f, -113.4200f, "+Zhengzhou China"},
  {+34.9650f, +109.1533f, "Zuni  NM"},
  {+47.2200f, -008.3200f, "+Zurich Switzerland"}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Stretch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stretch.rc
//
#define IDD_STRETCHPARAM                104
#define IDC_ANGLE                       1000
#define IDC_STRETCH                     1001
#define IDC_AMPLIFY                     1002
#define IDC_X                           1003
#define IDC_Y                           1004
#define IDC_Z                           1005
#define IDC_X2                          1006
#define IDC_STRETCHSPINNER              1008
#define IDC_AMPLIFYSPINNER              1009
#define IDC_STRETCH_LABEL               1014
#define IDC_AMPLIFY_LABEL               1015
#define IDC_STRETCH_BOX                 1016
#define IDC_STRETCH_AFFECTREGION        1022
#define IDC_STRETCH_TO                  1023
#define IDC_STRETCH_TOSPIN              1024
#define IDC_STRETCH_FROM                1025
#define IDC_STRETCH_FROMSPIN            1026
#define IDS_KT_PARAMETERS               60001
#define IDS_PARAMETERS                  60001
#define IDS_KT_STRETCH                  60002
#define IDS_STRETCH                     60002
#define IDS_KT_AMPLIFY                  60003
#define IDS_AMPLIFY                     60003
#define IDS_KT_AXIS                     60004
#define IDS_AXIS                        60004
#define IDS_KT_TO                       60005
#define IDS_TO                          60005
#define IDS_KT_FROM                     60006
#define IDS_FROM                        60006
#define IDS_LIB_DESCRIPTION             60007
#define IDS_OBJECT_NAME                 60008
#define IDS_CLASS_NAME                  60009
#define IDS_CATEGORY                    60010
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         60004
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\CITYLIST.H ===
typedef struct {
  float latitude;
  float longitude;
  char name[50];
} CityList;

#define NumCities 1496
extern CityList cityList[NumCities];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Stretch\stretch.cpp ===
/**********************************************************************
 *
 *  FILE: stretch.cpp
 *
 *  DESCRIPTION:   DLL implementation of stretch modifier
 *
 *  CREATED BY: Keith Trummel (modified bend.cpp)
 *
 *  (C) Copyright 1995-1996 by Autodesk, Inc.
 *
 *  This program is copyrighted by Autodesk, Inc. and is licensed to you under
 *  the following conditions.  You may not distribute or publish the source
 *  code of this program in any form.  You may incorporate this code in object
 *  form in derivative works provided such derivative works are (i.) are de-
 *  signed and intended to work solely with Autodesk, Inc. products, and (ii.)
 *  contain Autodesk's copyright notice "(C) Copyright 1994 by Autodesk, Inc."
 *
 *  AUTODESK PROVIDES THIS PROGRAM "AS IS" AND WITH ALL FAULTS.  AUTODESK SPE-
 *  CIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR FITNESS FOR
 *  A PARTICULAR USE.  AUTODESK, INC.  DOES NOT WARRANT THAT THE OPERATION OF
 *  THE PROGRAM WILL BE UNINTERRUPTED OR ERROR FREE.
 *
 **********************************************************************/
//
// RB 1/14/97 -- Added WSM version
//

#include "max.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "stretch.h"
#include "resource.h"

#define MAX_PATH_LENGTH 257
#define MAX_STRING_LENGTH  256

#define BIGFLOAT        float(999999)

#define PB_STRETCH      0
#define PB_AMPLIFY      1
#define PB_AXIS         2
#define PB_DOREGION     3
#define PB_FROM         4
#define PB_TO           5

HINSTANCE hInstance;
HINSTANCE hResource;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
{
    hInstance = hinstDLL;
    hResource = hinstDLL;

    if ( !controlsInit ) {
        controlsInit = TRUE;
                
        // initialize Chicago controls
        InitCommonControls();
        
        InitCustomControls (hResource);
    }

    switch(fdwReason) {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return(TRUE);
}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() 
{ 
    static int loaded = 0;
    static TCHAR stringBuf[MAX_STRING_LENGTH];

    if (! loaded) {
        LoadString (hResource, IDS_LIB_DESCRIPTION, stringBuf, 
                    MAX_STRING_LENGTH);
        #if 0
            static TCHAR tmpBuf[25];
            float vernum = 1.0f;
            char filename[MAX_PATH_LENGTH];
            DWORD size, dummy;

        	GetModuleFileName(hResource, filename, MAX_PATH);
        	size = GetFileVersionInfoSize(filename, &dummy);
        	if (size) {
        	    char *buf = (char *)malloc(size);
        	    GetFileVersionInfo(filename, NULL, size, buf);
        	    VS_FIXEDFILEINFO *qbuf;
        	    UINT len;
        	    if (VerQueryValue(buf, "\\", (void **)&qbuf, &len)) {
            		// got the version information
            		DWORD ms = qbuf->dwProductVersionMS;
            		// DWORD ls = qbuf->dwProductVersionLS;
            		vernum = HIWORD(ms) + (LOWORD(ms) / 100.0f);
        	    }
        	    free(buf);
        	}
        	sprintf (tmpBuf, "%.2f", vernum);
        	_tcscat (stringBuf, _T(tmpBuf));
        #endif
	
        loaded = 1;
    }

    return stringBuf;
}

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() 
{ 
    return 2; 
}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) 
{
    switch(i) {
    case 0: return GetStretchModDesc();
	case 1: return GetStretchWSMDesc();
    default: return 0;
    }
}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() 
{ 
    return VERSION_3DSMAX; 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

class StretchMod: public SimpleMod {
    friend BOOL CALLBACK StretchParamDialogProc (HWND hDlg, UINT message, 
                                                 WPARAM wParam, LPARAM lParam);

public:
    static IParamMap *pmapParam;
    
    StretchMod();

    //  inherited virtual methods:

    // From Animatable
    void DeleteThis() { delete this; }
    void GetClassName(TSTR& s);
    virtual Class_ID ClassID() {return Class_ID(STRETCHOSM_CLASS_ID,12332321);}
    void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    RefTargetHandle Clone(RemapDir& remap = NoRemap());
    TCHAR *GetObjectName ();

    // From simple mod
    Deformer& GetDeformer(TimeValue t, ModContext &mc, Matrix3& mat,
                          Matrix3& invmat);
    Interval GetValidity(TimeValue t);
    ParamDimension *GetParameterDim(int pbIndex);
    TSTR GetParameterName (int pbIndex);
    BOOL GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis);
    void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
};


class StretchDeformer: public Deformer {
        public:
                Matrix3 tm,invtm;
                Box3 bbox;
                TimeValue time;
                float from, to;
                float amount;
                float amplifier;
                int theAxis;
                float heightMin;
                float heightMax;
                int doRegion;
                StretchDeformer();
                StretchDeformer(TimeValue t, ModContext &mc,float stretch, 
                                float amplify, int naxis, float from, 
                                float to, int doRegion, Matrix3& modmat, 
                                Matrix3& modinv);
                void SetAxis(Matrix3 &tmAxis);
                void CalcBulge(int axis, float stretch, float amplify);
                Point3 Map(int i, Point3 p); 
        };

#define STRETCHWSM_CLASSID	Class_ID(STRETCHOSM_CLASS_ID,0x98fe71a2)

class StretchWSM : public SimpleOSMToWSMObject {
	public:
		StretchWSM() {}
		StretchWSM(StretchMod *m) : SimpleOSMToWSMObject(m) {}
		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return STRETCHWSM_CLASSID;} 
		TCHAR *GetObjectName();
		RefTargetHandle Clone(RemapDir& remap)
			{return (new StretchWSM((StretchMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);}
	};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap *StretchMod::pmapParam = NULL;

class StretchClassDesc:public ClassDesc 
{
public:
    int                 IsPublic() { return 1; }
    void *              Create(BOOL loading = FALSE) { return new StretchMod; }
    const TCHAR *       ClassName();
    SClass_ID           SuperClassID() { return OSM_CLASS_ID; }
    Class_ID            ClassID() { return Class_ID(STRETCHOSM_CLASS_ID,12332321); }
    const TCHAR*        Category();
};

static StretchClassDesc stretchDesc;
extern ClassDesc* GetStretchModDesc() { return &stretchDesc; }

class StretchWSMClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) 
		{if (loading) return new StretchWSM; else return new StretchWSM(new StretchMod);}
	const TCHAR *	ClassName();
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return STRETCHWSM_CLASSID; }
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_MODBASED);}
	};

static StretchWSMClassDesc stretchWSMDesc;
extern ClassDesc* GetStretchWSMDesc() { return &stretchWSMDesc; }

//
//
// Parameters

static int axisIDs[] = {IDC_X,IDC_Y,IDC_Z};

static ParamUIDesc descParam[] = {
        // Stretch
        ParamUIDesc(
                PB_STRETCH,
                EDITTYPE_FLOAT,
                IDC_STRETCH,IDC_STRETCHSPINNER,
                -BIGFLOAT,BIGFLOAT,
                0.1f),

        // Amplify
        ParamUIDesc(
                PB_AMPLIFY,
                EDITTYPE_FLOAT,
                IDC_AMPLIFY,IDC_AMPLIFYSPINNER,
                -BIGFLOAT,BIGFLOAT,
                0.1f),

        // Axis
        ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),

        // Affect region
        ParamUIDesc(PB_DOREGION,TYPE_SINGLECHEKBOX,IDC_STRETCH_AFFECTREGION),

        // From
        ParamUIDesc(
                PB_FROM,
                EDITTYPE_UNIVERSE,
                IDC_STRETCH_FROM,IDC_STRETCH_FROMSPIN,
                -BIGFLOAT,0.0f,
                SPIN_AUTOSCALE),

        // To
        ParamUIDesc(
                PB_TO,
                EDITTYPE_UNIVERSE,
                IDC_STRETCH_TO,IDC_STRETCH_TOSPIN,
                0.0f,BIGFLOAT,          
                SPIN_AUTOSCALE),        
        };
#define PARAMDESC_LENGH 6


static ParamBlockDescID descVer[] = {
        { TYPE_FLOAT, NULL, TRUE, 0 },
        { TYPE_FLOAT, NULL, TRUE, 1 },  
        { TYPE_INT, NULL, FALSE, 2 },
        { TYPE_INT, NULL, FALSE, 3 },
        { TYPE_FLOAT, NULL, TRUE, 4 },
        { TYPE_FLOAT, NULL, TRUE, 5 } };

#define PBLOCK_LENGTH   6

class StretchDlgProc : public ParamMapUserDlgProc 
{
public:
    BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,
                 LPARAM lParam);
    void DeleteThis() {}
};
static StretchDlgProc theStretchProc;

BOOL StretchDlgProc::DlgProc(TimeValue t, IParamMap *map,
                             HWND hWnd, UINT msg, WPARAM wParam, 
                             LPARAM lParam )
{
    switch (msg) {
    case CC_SPINNER_CHANGE:
        switch (LOWORD(wParam)) {
        case IDC_STRETCH_FROMSPIN: {
            float from, to;
            map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
            map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
            if (from>to) {
                map->GetParamBlock()->SetValue(PB_TO,t,from);
                map->Invalidate();
            }
            break;
        }
            
        case IDC_STRETCH_TOSPIN: {
            float from, to;
            map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
            map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
            if (from>to) {
                map->GetParamBlock()->SetValue(PB_FROM,t,to);
                map->Invalidate();
            }
            break;
        }
        }
        break;
    }
    return FALSE;
}


const TCHAR * StretchClassDesc::ClassName() 
{ 
    static int loaded = 0;
    static TCHAR stringBuf[MAX_STRING_LENGTH];

    if (! loaded) {
        LoadString (hResource, IDS_CLASS_NAME, stringBuf, MAX_STRING_LENGTH);
        loaded = 1;
    }
    return stringBuf;
}

const TCHAR * StretchWSMClassDesc::ClassName() 
{ 
    static int loaded = 0;
    static TCHAR stringBuf[MAX_STRING_LENGTH];

    if (! loaded) {
        LoadString (hResource, IDS_CLASS_NAME, stringBuf, MAX_STRING_LENGTH);
        loaded = 1;
    }
    return stringBuf;
}

const TCHAR * StretchClassDesc::Category() 
{ 
    static int loaded = 0;
    static TCHAR stringBuf[MAX_STRING_LENGTH];

    if (! loaded) {
        LoadString (hResource, IDS_CATEGORY, stringBuf, MAX_STRING_LENGTH);
        loaded = 1;
    }
    return stringBuf;
}

StretchMod::StretchMod() : SimpleMod()
{
    MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
                CreateParameterBlock(descVer, PBLOCK_LENGTH, 0));
        
    pblock->SetValue(PB_AXIS, TimeValue(0), 2/*Z*/);
}

void StretchMod::GetClassName (TSTR& s) 
{ 
    static int loaded = 0;
    static TCHAR stringBuf[MAX_STRING_LENGTH];

    if (! loaded) {
        LoadString (hResource, IDS_CLASS_NAME, stringBuf, MAX_STRING_LENGTH);
        loaded = 1;
    }
    s = stringBuf;
}  

void StretchMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
    SimpleMod::BeginEditParams(ip,flags,prev);
        
    static int loaded = 0;
    static TCHAR stringBuf[MAX_STRING_LENGTH];
    if (! loaded) {
        LoadString (hResource, IDS_PARAMETERS, stringBuf, 
                    MAX_STRING_LENGTH);
        loaded = 1;
    }

    pmapParam = 
        CreateCPParamMap (descParam, PARAMDESC_LENGH,
                          pblock, ip, hResource,
                          MAKEINTRESOURCE(IDD_STRETCHPARAM),
                          stringBuf, 0);        
    pmapParam->SetUserDlgProc(&theStretchProc);
}

                

void StretchMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
    SimpleMod::EndEditParams(ip,flags,next);
    DestroyCPParamMap(pmapParam);
}


RefTargetHandle StretchMod::Clone(RemapDir& remap) {
        StretchMod* newmod = new StretchMod();
        newmod->ReplaceReference(SIMPMOD_PBLOCKREF, pblock->Clone(remap));
        newmod->SimpleModClone(this);
        return(newmod);
        }

TCHAR * StretchMod::GetObjectName()
{ 
    static int loaded = 0;
    static TCHAR stringBuf[MAX_STRING_LENGTH];

    if (! loaded) {
        LoadString (hResource, IDS_OBJECT_NAME, stringBuf, MAX_STRING_LENGTH);
        loaded = 1;
    }
    return stringBuf;
}

TCHAR * StretchWSM::GetObjectName()
{ 
    static int loaded = 0;
    static TCHAR stringBuf[MAX_STRING_LENGTH];

    if (! loaded) {
        LoadString (hResource, IDS_OBJECT_NAME, stringBuf, MAX_STRING_LENGTH);
        loaded = 1;
    }
    return stringBuf;
}


Deformer& StretchMod::GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,
                                  Matrix3& invmat)
{
    float angle, dir, from, to;
    int axis;   
    int doRegion;
    pblock->GetValue(PB_STRETCH,t,angle,FOREVER);
    pblock->GetValue(PB_AMPLIFY,t,dir,FOREVER);
    pblock->GetValue(PB_AXIS,t,axis,FOREVER);
    pblock->GetValue(PB_FROM,t,from,FOREVER);
    pblock->GetValue(PB_TO,t,to,FOREVER);
    pblock->GetValue(PB_DOREGION,t,doRegion,FOREVER);
    static StretchDeformer deformer;
    deformer = StretchDeformer(t,mc,angle,dir,axis,from,to,doRegion,
                               mat,invmat);
    return deformer;
}
Interval StretchMod::GetValidity(TimeValue t)
{
    float f;
    Interval valid = FOREVER;
    pblock->GetValue(PB_STRETCH, t, f, valid);
    pblock->GetValue(PB_AMPLIFY, t, f, valid);
    pblock->GetValue(PB_AXIS, t, f, valid);
    pblock->GetValue(PB_FROM, t, f, valid);
    pblock->GetValue(PB_TO, t, f, valid);
    return valid;
}




ParamDimension *
StretchMod::GetParameterDim(int pbIndex)
{
    switch (pbIndex) {
    case PB_STRETCH:    return defaultDim;
    case PB_AMPLIFY:    return defaultDim;
    case PB_FROM:       return stdWorldDim;
    case PB_TO:         return stdWorldDim;
    default:            return defaultDim;
    }
}

TSTR StretchMod::GetParameterName(int pbIndex)
{
    static TCHAR buf[1024];
    int bufLen = 1024;

    switch (pbIndex) {
    case PB_STRETCH:
        LoadString (hResource, IDS_STRETCH, buf, bufLen);
        return TSTR (buf);
    case PB_AMPLIFY:
        LoadString (hResource, IDS_AMPLIFY, buf, bufLen);
        return TSTR (buf);
    case PB_AXIS:
        LoadString (hResource, IDS_AXIS, buf, bufLen);
        return TSTR (buf);
    case PB_FROM:
        LoadString (hResource, IDS_FROM, buf, bufLen);
        return TSTR (buf);
    case PB_TO:
        LoadString (hResource, IDS_TO, buf, bufLen);
        return TSTR (buf);
    default:
        return TSTR(_T(""));
    }
}

BOOL StretchMod::GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis)
{
    int limit;
    pblock->GetValue(PB_DOREGION,t,limit,FOREVER);
    pblock->GetValue(PB_FROM,t,zmin,FOREVER);
    pblock->GetValue(PB_TO,t,zmax,FOREVER);
    pblock->GetValue(PB_AXIS,t,axis,FOREVER);
    return limit?TRUE:FALSE;
}

StretchDeformer::StretchDeformer() 
{ 
    tm.IdentityMatrix();
    time = 0;   
}

StretchDeformer::StretchDeformer(TimeValue t, ModContext &mc,
                                 float stretch, float amplify, int naxis, 
                                 float from, float to, int doRegion,
                                 Matrix3& modmat, Matrix3& modinv) 
{
    Matrix3 mat;
    Interval valid;     
    if (from==to) doRegion = FALSE;
    this->doRegion = doRegion;
    this->from = from;
    this->to   = to;
    time   = t; 

    tm = modmat;
    invtm = modinv;
    mat.IdentityMatrix();
        
    switch ( naxis ) {
    case 0: mat.RotateY( -HALFPI );      break; //X
    case 1: mat.RotateX( HALFPI );  break; //Y
    case 2: break;  //Z
    }
    SetAxis( mat );     
    assert (mc.box);
    bbox = *mc.box;
    CalcBulge(naxis, stretch, amplify);
} 

void StretchDeformer::SetAxis(Matrix3 &tmAxis)
{
    Matrix3 itm = Inverse(tmAxis);
    tm    = tm*tmAxis;
    invtm =     itm*invtm;
}

// This calculates some values that are then stored to reduce computations
void StretchDeformer::CalcBulge(int axis, float stretch, float amplify)
{
    theAxis = axis;
    amount = stretch;
    amplifier = (amplify >= 0) ? amplify + 1 : 1.0F / (-amplify + 1.0F);
    if (! doRegion) {
        switch ( axis ) {
        case 0:
            heightMin = bbox.pmin.x;
            heightMax = bbox.pmax.x;
            break;
        case 1:
            heightMin = bbox.pmin.y;
            heightMax = bbox.pmax.y;
            break;
        case 2:
            heightMin = bbox.pmin.z;
            heightMax = bbox.pmax.z;
            break;
        }
    } else {
        heightMin = from;
        heightMax = to;
    }
}

// This mapper does the following.  
// It scales the Z value by 1 + amount, if amount is greater than 0 and by
// -1 / (amount - 1) if amount is less than 0.
// In the x and y it scales by a quadratic in the height.
// The quadratic is determined by the conditions that its value is 1 at
// both the minimum and maximum height and halfway in between is the maximum
// bulge (inward or outward depending upon whether stretch or squash)
Point3 StretchDeformer::Map(int i, Point3 p)
{
    float fraction, normHeight;
    float xyScale, zScale, a, b, c;
    
    if (amount == 0 || (heightMax - heightMin == 0))
        return p;
    
    p = p * tm;
    
    if (doRegion && p.z > to)
        normHeight = (to - heightMin) / (heightMax - heightMin);
    else if (doRegion && p.z < from)
        normHeight = (from - heightMin) / (heightMax - heightMin);
    else
        normHeight = (p.z - heightMin) / (heightMax - heightMin);

    if (amount < 0) {   // Squash
        xyScale = (amplifier * -amount + 1.0F);
        zScale = (-1.0F / (amount - 1.0F));
    } else {           // Stretch
        xyScale = 1.0F / (amplifier * amount + 1.0F);
        zScale = amount + 1.0F;
    }

    // a, b, and c are the coefficients of the quadratic function f(x)
    // such that f(0) = 1, f(1) = 1, and f(0.5) = xyScale
    a = 4.0F * (1.0F - xyScale);
    b = -4.0F * (1.0F - xyScale);
    c = 1.0F;
    fraction = (((a * normHeight) + b) * normHeight) + c;
    p.x *= fraction;
    p.y *= fraction;

    if (doRegion && p.z < from)
	p.z += (zScale - 1.0F) * from;
    else if (doRegion && p.z <= to)
	p.z *= zScale;
    else if (doRegion && p.z > to)
	p.z += (zScale - 1.0F) * to;
    else
	p.z *= zScale;

    p = p * invtm;
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\compass.h ===
/**********************************************************************
 *<
	FILE: helpers.h

	DESCRIPTION: Helper object header file

	CREATED BY: Tom Hudson

	HISTORY: Created 31 January 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __COMPASS__H
#define __COMPASS__H

#include "Max.h"
#include "sunlight.h"

TCHAR *GetString(int id);

#define COMPASS_CLASS_ID Class_ID(0x69011e82, 0x5622b0d)


class CompassRoseObject: public HelperObject {
	public:			
		// Class vars
		static HWND hParams;
		static IObjParam *iObjParams;
		static int dlgShowAxis;
		static float dlgAxisLength;

		// Snap suspension flag (TRUE during creation only)
		BOOL suspendSnap;
					
		// Params
		BOOL showAxis;
		float axisLength;
 		int extDispFlags;

		//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );		
	
		CompassRoseObject();
		~CompassRoseObject();
		
		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		void SetExtendedDisplay(int flags);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = GetString(IDS_DB_COMPASS); }
		ObjectHandle ApplyTransform(Matrix3& matrix) {return this;}
		Interval ObjectValidity(TimeValue t) {return FOREVER;}
		int CanConvertToType(Class_ID obtype) {return FALSE;}
		Object* ConvertToType(TimeValue t, Class_ID obtype) {assert(0);return NULL;}		
		void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		int DoOwnSelectHilite()	{ return 1; }

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return COMPASS_CLASS_ID; }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_COMPASS_CLASS)); }
		int IsKeyable(){ return 0;}
		
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
	};				


extern ClassDesc* GetCompassRoseDesc();

#endif // __HELPERS__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\GEOLOC.CPP ===
/**********************************************************************
 *<
	FILE: geoloc.cpp

	DESCRIPTION:  Geographic Locator Dialog

	CREATED BY: Jack Lieberman

	HISTORY: created 9 January, 1996

 *>	Copyright (c) 19945, 1996, All Rights Reserved.
 **********************************************************************/

#include "max.h"
#include "simpmod.h"
#include "sunlight.h"
#include "citylist.h"

extern HINSTANCE hInstance;

// Geographic locator dialog stuff.
struct MapTable {
	int index;
	char *filename;
};

static MapTable mapTable[] = {
	IDS_AFRICA,				"africa.map",
	IDS_ASIA,				"asia.map",
	IDS_ASIAN_SUBCONTINENT,	"india.map",
	IDS_AUSTRALIA,			"aust.map",
	IDS_CANADA,				"canada.map",
	IDS_EUROPE,				"europe.map",
	IDS_NORTH_AMERICA,		"namer.map",
	IDS_SOUTH_AMERICA,		"samer.map",
	IDS_WORLD,				"world.map"
};

#define AFRICA				0
#define ASIA				1
#define ASIAN_SUBCONTINENT	2
#define AUSTRALIA			3
#define CANADA				4
#define EUROPE				5
#define NORTH_AMERICA		6
#define SOUTH_AMERICA		7
#define WORLD				8

#define LAST_MAP_NAME  8

static int lastMap = -1;
/*static*/ int lastCity = -1;	// reset to -1 if param spinners are used
char lastCityName[64] = "";

// Forward declarations.
class LocationDialog;


// Subclass proc for map owner draw button.
LRESULT CALLBACK MapProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

// The dialog proc.
BOOL CALLBACK GetLocationDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

class LocationDialog
{
	friend BOOL CALLBACK GetLocationDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    public:
        LocationDialog();
        void initMapList(HWND h);
        void initCityList();                
        void chooseCity(HWND hDlg, int index);
        void displayMap(HWND hDlg, HWND hButton);
        void changeMap(HWND hDlg, HWND mapWnd);
		int mapClick(HWND hDlg, HWND hButton);

		int mapIndex;       // Index of current map in list.
		double updatedLatitude, updatedLongitude;

		LocationDialog* theDlg;				// THE dialog.
		IObjParam* theInterface;			// Interface pointer to MAX.
		float theLatitude;					// Incoming data.
		float theLongitude;					// Incoming data.
		WNDPROC oldMapProc;
        
    private:

        void displayCross(HWND hDlg, double latitude, double longitude);
        BOOL loadCityList(HWND hDlg);
        void imageToLatLong(double x, double y, double *latitude, double *longitude);
        HANDLE openMapFile(char* mapName);
        
        int isBig[2000];	// Note this must be increased for more cities.
        int cityIndex;      // Index of city in list box.
        double minLatitude, minLongitude, maxLatitude, maxLongitude;
        double crossLatitude, crossLongitude;
        BOOL crossVisible;
        short mapWidth, mapHeight;
        double mapLongWidth, mapLatHeight;
        double scale, xBias, yBias;
};

BOOL doLocationDialog(HWND hParent, IObjParam* ip, float* latitude, float* longitude,
						char* cityName)
// Do the dialog.
{
    LocationDialog dlg;
    dlg.theInterface = ip;
    dlg.theLatitude = *latitude;
    dlg.theLongitude = *longitude;
    
    if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_GEOGRAPHIC_LOCATION),
			hParent, GetLocationDlgProc, (LPARAM)&dlg) == 1) {
        *latitude = (float)dlg.updatedLatitude;
        *longitude = (float)dlg.updatedLongitude;
		if (lastCity >= 0)
			strcpy(cityName, lastCityName);
        return TRUE;
    }

    return FALSE;
}

LocationDialog::LocationDialog()
{
    cityIndex = -1;
    mapIndex = -1;
    crossVisible = FALSE;
    scale = 100.;
    xBias = -2.6;
    yBias = .5;
}


#define IDS_FIRST_CITY_NAME IDS_CITY20
void LocationDialog::initCityList()
// Load city names from resource file.
{
    CityList* cl;    
    for (int i=0; i<NumCities; i++) {
        cl = &cityList[i];
        LoadString(hInstance, IDS_FIRST_CITY_NAME + i, cl->name, 50);
    }
}

void LocationDialog::initMapList(HWND h)
// Add map names to combo box.
{
    for (UINT i=0; i<=LAST_MAP_NAME; i++) {
		char mapName[256];
        if (LoadString(hInstance, mapTable[i].index, mapName, 256) != 0)
            SendMessage(h, CB_ADDSTRING, 0, (LPARAM)mapName);
    }

    // Set current map;
	if (lastMap < 0)
		mapIndex = NORTH_AMERICA;
	else
		mapIndex = lastMap;
    SendMessage(h, CB_SETCURSEL, (WPARAM)mapIndex, 0);
}

#define CROSS_SIZE 10
#define CROSS_COLOR (RGB(0, 255, 0))
void LocationDialog::displayCross(HWND hDlg, double latitude, double longitude)
{
    short xImage, yImage;
    HWND hMap = GetDlgItem(hDlg, IDC_MAP_PICTURE);

    HDC hDC = GetDC(hMap);
    if (hDC == NULL)
        return;
    int oRop = SetROP2(hDC, R2_XORPEN);
    HPEN pen = CreatePen(PS_SOLID, 3, CROSS_COLOR);
    HPEN oPen = (HPEN)SelectObject(hDC, pen);

    HRGN hrgn = CreateRectRgn(1, 1, mapWidth, mapHeight - 1);
    if (hrgn != NULL) {
        SelectClipRgn(hDC, hrgn);
        DeleteObject(hrgn);
    }
                                 
    // calculation of x-coordinate differs in sign from original map,
    //   which uses different convention for longitude.
    xImage = (int)((-longitude-minLongitude)*mapWidth/mapLongWidth);
    yImage = (int)((latitude-minLatitude)*mapHeight/mapLatHeight);
    if (crossVisible) {
        short xOld, yOld;
        
        xOld = (int) ((-crossLongitude-minLongitude)*mapWidth/mapLongWidth);
        yOld = (int) ((crossLatitude-minLatitude)*mapHeight/mapLatHeight);

        // erase.
        MoveToEx(hDC, xOld-CROSS_SIZE, mapHeight-yOld, NULL);
        LineTo(hDC, xOld+CROSS_SIZE, mapHeight-yOld);
        MoveToEx(hDC, xOld, mapHeight-yOld-CROSS_SIZE, NULL);
        LineTo(hDC, xOld,mapHeight-yOld+CROSS_SIZE);
    }
    MoveToEx(hDC, xImage-CROSS_SIZE, mapHeight-yImage, NULL);
    LineTo(hDC, xImage+CROSS_SIZE, mapHeight-yImage);
    MoveToEx(hDC, xImage, mapHeight-yImage-CROSS_SIZE, NULL);
    LineTo(hDC, xImage, mapHeight-yImage+CROSS_SIZE);
    crossVisible = TRUE;
    
    crossLatitude = latitude;
    crossLongitude = longitude;
    
    SetROP2(hDC, oRop);
    SelectObject(hDC, oPen);
    DeleteObject(pen);
    
    ReleaseDC(hMap, hDC);    
}

void LocationDialog::chooseCity(HWND hDlg, int index)
// Handle a change of city.
{
    double latitude, longitude;

    // Get the cityList index of the city chosen.
    int itemIndex = SendMessage(GetDlgItem(hDlg, IDC_CITYLIST),
								LB_GETITEMDATA, index, 0);

    // Find that city's lat and long.
    latitude = cityList[itemIndex].latitude;
    longitude = cityList[itemIndex].longitude;

	// Get that city's name, too.
	strcpy(lastCityName, cityList[itemIndex].name);
    
    updatedLatitude = latitude;
    updatedLongitude = longitude;
    displayCross(hDlg, latitude, longitude);
    lastCity = cityIndex = index;
}

#define SGEOLOC _T("\\GeoLoc\\")
#define GEOLOC _T("GeoLoc\\")

// Fetch the map file full path name.
HANDLE LocationDialog::openMapFile(char* mapName)
{
	HANDLE hMap;
	TCHAR fileName[MAX_PATH];
	int len;

	// Get subdir containing this plugin.
	GetModuleFileName(hInstance, fileName, MAX_PATH);

	// Append subdir string containing maps.
	TCHAR *slash = _tcsrchr(fileName, '\\');
	if (slash) {
		_tcscpy(slash, SGEOLOC);
	} else {
		// If the plugin filename contains no path information, look in plugcfg.
		_tcscpy(fileName,theInterface->GetDir(APP_PLUGCFG_DIR));
		len = _tcslen(fileName);
		if (len) {
			if (_tcscmp(&fileName[len-1],_T("\\")))
				_tcscat(fileName,_T("\\"));
		}
	}

	_tcscat(fileName,mapName);
	hMap = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	if (hMap == INVALID_HANDLE_VALUE) {
		// If that fails, look in the MaxStart dir.
		_tcscpy(fileName,theInterface->GetDir(APP_MAXSTART_DIR));
		len = _tcslen(fileName);
		if (len) {
			if (_tcscmp(&fileName[len-1],_T("\\")))
				_tcscat(fileName,_T("\\"));
			_tcscat(fileName, GEOLOC);
		}   
		_tcscat(fileName,mapName);
		hMap = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
							OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
		if (hMap == INVALID_HANDLE_VALUE) {
			// If THAT fails, look beneath the main exe dir.
			_tcscpy(fileName,theInterface->GetDir(APP_MAXROOT_DIR));
			len = _tcslen(fileName);
			if (len) {
				if (_tcscmp(&fileName[len-1],_T("\\")))
					_tcscat(fileName,_T("\\"));
			}
			_tcscat(fileName, GEOLOC);
			_tcscat(fileName,mapName);
			hMap = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
							OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
			if (hMap == INVALID_HANDLE_VALUE) {
				// Last try: If THAT fails, look IN the main exe dir.
				_tcscpy(fileName,theInterface->GetDir(APP_MAXROOT_DIR));
				len = _tcslen(fileName);
				if (len) {
					if (_tcscmp(&fileName[len-1],_T("\\")))
						_tcscat(fileName,_T("\\"));
				}
				_tcscat(fileName,mapName);
				hMap = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL,
								OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
			}
		}
	}

	return hMap;
}



void LocationDialog::displayMap(HWND hDlg, HWND hButton)
// Draw the current map.
{
    double latitude, longitude, width, height;
    double aspectRatio;
    double x1, x2, y1, y2;
    
    minLongitude = -180.;
    minLatitude = -90.;
    maxLongitude = 180.;
    maxLatitude = 90.;

    // Get the map file name.
    char mapName[32];
	lstrcpy(mapName, mapTable[mapIndex].filename);
   
    HANDLE hMap = openMapFile(mapName);
    if (hMap == INVALID_HANDLE_VALUE)
        return;

    // Get the control dimensions.
    RECT mapRect;
    GetWindowRect(GetDlgItem(hDlg, IDC_MAP_PICTURE), &mapRect);
    mapWidth = (short)(mapRect.right - mapRect.left);
    mapHeight = (short)(mapRect.bottom - mapRect.top);    

    // Read the map file header and record values.
    DWORD bytesRead;
    if (ReadFile(hMap, &latitude, sizeof(double), &bytesRead, NULL) == FALSE
        || bytesRead == 0) {
        CloseHandle(hMap);
        return;
    }
    if (ReadFile(hMap, &longitude, sizeof(double), &bytesRead, NULL) == FALSE
        || bytesRead == 0) {
        CloseHandle(hMap);
        return;
    }
    if (ReadFile(hMap, &width, sizeof(double), &bytesRead, NULL) == FALSE
        || bytesRead == 0) {
        CloseHandle(hMap);
        return;
    }
    aspectRatio = ((double)mapHeight)/((double)mapWidth);
    height = width * aspectRatio;
    minLongitude = longitude - width / 2.;
    minLatitude = latitude - height / 2.;
    maxLongitude = longitude + width / 2.;
    maxLatitude = latitude + height / 2.;

    crossVisible = FALSE;

    HDC hDC = GetDC(hDlg);
    COLORREF bkColor = GetPixel(hDC, 2, 2);
    ReleaseDC(hDlg, hDC);
    
    // Read the rest of the file and draw.
    hDC = GetDC(hButton);    
    if (hDC != NULL) {
        RECT rect;
        rect.left = rect.top = 0;
        rect.right = mapWidth;
        rect.bottom = mapHeight;        
        HBRUSH bkBrush = CreateSolidBrush(bkColor);
        HBRUSH oBrush = (HBRUSH)SelectObject(hDC, bkBrush);
        GetClientRect(hButton, &mapRect);
        Rectangle(hDC, mapRect.left - 1, mapRect.top, mapRect.right + 2
            , mapRect.bottom);
        while (TRUE) {
            if (ReadFile(hMap, &x1, sizeof(double), &bytesRead, NULL) == FALSE
                || bytesRead == 0)
                break;
            if (ReadFile(hMap, &y1, sizeof(double), &bytesRead, NULL) == FALSE
                || bytesRead == 0)
                break;
            if (ReadFile(hMap, &x2, sizeof(double), &bytesRead, NULL) == FALSE
                || bytesRead == 0)
                break;
            if (ReadFile(hMap, &y2, sizeof(double), &bytesRead, NULL) == FALSE
                || bytesRead == 0)
                break;
            if (x1 * x2 > 0.0) {   // only if they have the same sign
				short mx, my, lx, ly;
				mx = (short)((x1 - minLongitude) * mapWidth / width);
				my = (short)(mapHeight - ((y1 - minLatitude) * mapHeight / height));
#ifdef DEBUG
				if (mx > mapWidth)
					break;//mx = mapWidth;
				if (mx < 0)
					break;//mx = 0;
				if (my > mapHeight)
					break;//my = mapHeight;
				if (my < 0)
					break;//my = 0;
#endif

 				lx = (short)((x2 - minLongitude) * mapWidth / width);
				ly = (short)(mapHeight - ((y2 - minLatitude) * mapHeight / height));
#ifdef DEBUG
				if (lx > mapWidth)
					break;//lx = mapWidth;
				if (lx < 0)
					break;//lx = 0;
				if (ly > mapHeight)
					break;//ly = mapHeight;
				if (ly < 0)
					break;//ly = 0;
#endif

                MoveToEx(hDC, mx, my, NULL);
				LineTo(hDC, lx, ly);
            }
        }
        SelectObject(hDC, oBrush);
        DeleteObject(bkBrush);
        ReleaseDC(hButton, hDC);
    }
    CloseHandle(hMap);

    // calculate for imageToLatLong.
    xBias = longitude - (width/2.);
    yBias = latitude - ((width/2.)*((double)mapHeight/(double)mapWidth));
    scale = (double) mapWidth / width;
        
    mapLongWidth = width;
    mapLatHeight = height;
}

BOOL LocationDialog::loadCityList(HWND hDlg)
// Update the list of cities.
{
    CityList* cl;    
    HWND h = GetDlgItem(hDlg, IDC_CITYLIST);
    int index;

    // Empty the list box and add only those cities in the current map.
    SendMessage(h, LB_RESETCONTENT, 0, 0);
    for (int i=0; i<NumCities; i++) {
        cl = &cityList[i];
        if ((double)cl->latitude > minLatitude && 
            (double)cl->latitude < maxLatitude &&
            (double)cl->longitude < -minLongitude && /* signs are */
            (double)cl->longitude > -maxLongitude) { /* reversed  */

            if (cl->name[0] == '+') {
                isBig[i] = TRUE;
                index = SendMessage(h, LB_ADDSTRING, 0, (LPARAM)(cl->name+1));
            } else {
                isBig[i] = FALSE;                
                index = SendMessage(h, LB_ADDSTRING, 0, (LPARAM)(cl->name));
            }

            // Store city list index in item data.
            SendMessage(h, LB_SETITEMDATA, index, (LPARAM)i);
            
//            if (fabs(cl->latitude-updatedLatitude) < .01 &&
//                fabs(cl->longitude-updatedLongitude) < .01)
        }
    }

	if (lastCity < 0) {
		// Select first city.
		//SendMessage(h, LB_SETCURSEL, (WPARAM)0, 0);    
		//chooseCity(hDlg, 0);
	} else {
		// Select first city.
		SendMessage(h, LB_SETCURSEL, (WPARAM)lastCity, 0);    
		chooseCity(hDlg, lastCity);
	}

    return TRUE;
}

void LocationDialog::changeMap(HWND hDlg, HWND mapWnd)
// Draw a new map and change the cities list to accomodate.
{
    displayMap(hDlg, mapWnd);
    loadCityList(hDlg);
}

void LocationDialog::imageToLatLong(double x, double y, double *latitude
    , double *longitude)
{
    *longitude = x / scale + xBias;
    *latitude = (mapHeight - y) / scale + yBias;
}

int LocationDialog::mapClick(HWND hDlg, HWND hButton)
{
    CityList* cl;
    
    // Get the cursor position in client coordinates.
    POINT curPos;    
    GetCursorPos(&curPos);
    ScreenToClient(hButton, &curPos);

    double latitude, longitude;
    imageToLatLong((double)curPos.x, (double)curPos.y, &latitude, &longitude);
    longitude = -longitude;   // from map's convention to ours.
    if (latitude<minLatitude ||
        latitude>maxLatitude ||
        longitude>-minLongitude || /* signs are */
        longitude<-maxLongitude ) /* reversed  */
        return 0;

    HWND list = GetDlgItem(hDlg, IDC_CITYLIST);
    if (IsDlgButtonChecked(hDlg, IDC_NEAREST) != 0) { // get nearest big city.
        double distance = 360.0/* large value */, tempDistance; 
        int i, closestCity = -1; 
        for (i=0; i<NumCities; ++i) {
            cl = &cityList[i];            
            if (cl->latitude>minLatitude &&
                cl->latitude<maxLatitude &&
                cl->longitude<-minLongitude && /* signs are */
                cl->longitude>-maxLongitude && /* reversed  */
                isBig[i]) {
                tempDistance = sqrt(
                 (cl->latitude-latitude)*
                 (cl->latitude-latitude)+
                 (cl->longitude-longitude)*
                 (cl->longitude-longitude));
                if (tempDistance < distance) {
                    distance = tempDistance;
                    closestCity = i;
                }
            }
        }
        if (closestCity != -1) {
            updatedLatitude = (double)cityList[closestCity].latitude;
            updatedLongitude = (double)cityList[closestCity].longitude;
			strcpy(lastCityName, cityList[closestCity].name);

            // Select the city in the list box.
            int count = SendMessage(list, LB_GETCOUNT, 0, 0);
            for (int j = 0; j<count; j++) {
                if (SendMessage(list, LB_GETITEMDATA, j, 0) == closestCity) {
                    SendMessage(list, LB_SETCURSEL, (WPARAM)j, 0);
                    lastCity = cityIndex = j;
                }
            }
            
            displayCross(hDlg,
                (double)updatedLatitude, (double)updatedLongitude);
        }
    } else {
        updatedLatitude = latitude;
        updatedLongitude = longitude;
		*lastCityName = '\0';

        // Select no city in the list box.
        SendMessage(list, LB_SETCURSEL, (WPARAM)-1, 0);
        lastCity = cityIndex = -1;
        displayCross(hDlg, latitude, longitude);
    }
	return 0;
}

static BOOL CALLBACK GetLocationDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LocationDialog *theDlg = (LocationDialog *)GetWindowLong( hWnd, GWL_USERDATA );

	Interval valid = FOREVER;
	HWND hMap = GetDlgItem(hWnd, IDC_MAP_PICTURE);

    
    switch (msg) {
    case WM_INITDIALOG:
		theDlg = (LocationDialog *)lParam;
		SetWindowLong( hWnd, GWL_USERDATA, (LONG)theDlg );

        // Set the initial lat and long.
        theDlg->updatedLatitude = (double)theDlg->theLatitude;
        theDlg->updatedLongitude = (double)theDlg->theLongitude;

        // Subclass the map owner draw button.
        theDlg->oldMapProc = (WNDPROC)GetWindowLong(hMap, GWL_WNDPROC);
        SetWindowLong(hMap, GWL_WNDPROC, (LONG)MapProc);
		SetWindowLong(hMap, GWL_USERDATA, (LONG)theDlg );

        // Initialize items.
        theDlg->initCityList();
        theDlg->initMapList(GetDlgItem(hWnd, IDC_MAP_NAME));
        theDlg->changeMap(hWnd, hMap);
		CenterWindow(hWnd,GetParent(hWnd));
		break;

    case WM_DRAWITEM:
        theDlg->displayMap(hWnd, ((LPDRAWITEMSTRUCT)lParam)->hwndItem);
	    theDlg->displayCross(hWnd, theDlg->theLatitude, theDlg->theLongitude);
        break;
        
	case WM_COMMAND:

        // First check for ok or cancel.
	    switch (LOWORD(wParam)) {
		case IDOK:
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
    		EndDialog(hWnd,0);
			break;
		}

        // Then check for notifications.
        switch(HIWORD(wParam)) {
        case LBN_SELCHANGE:
             // User chose a city from the list box or map from combo box.
            if (GetDlgItem(hWnd, IDC_CITYLIST) == (HWND)lParam) 
                theDlg->chooseCity(hWnd, SendMessage((HWND)lParam, LB_GETCURSEL,0,0));
            else {
                int sel = SendMessage((HWND)lParam, CB_GETCURSEL, 0, 0);
                if (theDlg->mapIndex != sel) {
                    lastMap = theDlg->mapIndex = sel;
					lastCity = 0;
                    theDlg->changeMap(hWnd, GetDlgItem(hWnd, IDC_MAP_PICTURE));
                }
            }
            break;

        case LBN_DBLCLK:
            // User may have double-clicked a city; if so, accept it and end dialog.
            if (GetDlgItem(hWnd, IDC_CITYLIST) == (HWND)lParam) {
                theDlg->chooseCity(hWnd, SendMessage((HWND)lParam, LB_GETCURSEL,0,0));
				EndDialog(hWnd,1);
			}
            break;
        default:
    		break;
        }
        break;
        
	default:
    	return 0;
    }
    
    return 1;
}

LRESULT CALLBACK MapProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
// Handle a message for map window.
{
 	LocationDialog *theDlg = (LocationDialog *)GetWindowLong( hwnd, GWL_USERDATA );
   // These are the messages we handle specially.
    switch (msg) {
    case WM_LBUTTONDOWN:
    case WM_MOUSEMOVE:

        // Eat these messages.
        return TRUE;
    case WM_LBUTTONUP:
        theDlg->mapClick(GetParent(hwnd), hwnd);
        return TRUE;
    }

    // Pass it on.
    return (CallWindowProc(theDlg->oldMapProc, hwnd, msg, wparam, lparam));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\light.h ===
/**********************************************************************
 *<
	FILE: light.h

	DESCRIPTION:  Defines lights

	CREATED BY: Dan Silva

	HISTORY: created 2 January 1995
			 added directional and spot lights, Feb 95

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#ifndef __LIGHT__H__ 

#define __LIGHT__H__

// reference #s
#define PBLOCK_REF 0
#define PROJMAP_REF 1

class GeneralLightCreateCallBack;
class TSpotLightClassDesc;

class GeneralLight: public GenLight {			   
	friend class GeneralLightCreateCallBack;
	friend class LightPostLoad;
	friend class TSpotLightClassDesc;
	friend BOOL CALLBACK GeneralLightParamDialogProc( HWND hDlg, UINT message,
		 WPARAM wParam, LPARAM lParam );
	friend void resetLightParams();

	// Class vars
	static Mesh staticMesh[2];
	static short meshBuilt;
	static HWND hGeneralLight;
	static HWND hSpotLight;
	static HWND hShadow;
	static IObjParam* iObjParams;
	static int dlgRed;
	static int dlgGreen;
	static int dlgBlue;
	static int dlgH;
	static int dlgS;
	static int dlgV;
	static float dlgIntensity;
	static float dlgHotsize;
	static float dlgFallsize;
	static float dlgTDist;
	static short dlgShowCone;
	static short dlgCrossover;
	static short dlgUseAtten;
	static float dlgAttenStart;
	static float dlgAttenEnd;
	static short dlgShowAtten;
	static short dlgShape;
	static float dlgAspect;
	static float dlgMapBias;
	static float dlgMapRange;
	static float dlgRayBias;
	static int dlgMapSize;

	static short globShadowType; 
	static short globAbsMapBias;
	static float globMapRange;
	static float globMapBias;
	static int   globMapSize;
	static float globRayBias;

	static ISpinnerControl *redSpin;
	static ISpinnerControl *greenSpin;
	static ISpinnerControl *blueSpin;
	static ISpinnerControl *hSpin;
	static ISpinnerControl *sSpin;
	static ISpinnerControl *vSpin;
	static ISpinnerControl *intensitySpin;
	static ISpinnerControl *hotsizeSpin;
	static ISpinnerControl *fallsizeSpin;
	static ISpinnerControl *tDistSpin;
	static ISpinnerControl *attenStartSpin;
	static ISpinnerControl *attenEndSpin;
	static ISpinnerControl *aspectSpin;
	static ISpinnerControl *mapBiasSpin;
	static ISpinnerControl *mapSizeSpin;
	static ISpinnerControl *mapRangeSpin;
	static ISpinnerControl *rayBiasSpin;
	static IColorSwatch *colorSwatch;
	
	// Object parameters
	IParamBlock *pblock;
	Texmap *projMap;   // a reference
	short updateHSVSpin;
	short type;
	short enable;
	short useLight;		// on/off toggle
	short useAtten;
	short attenDisplay;
	short coneDisplay;
	short shape;
	short shadow;
	short useGlobalShadowParams;
	short shadowType;  // 0: ShadowMap   1: RayTrace
	short absMapBias;
	short overshoot;
	short projector;
	int extDispFlags;
	Mesh spotMesh;
	Mesh *mesh;
	NameTab exclList;
	void BuildStaticMeshes();
	void BuildSpotMesh(float coneSize);
	void UpdateUI(TimeValue t);

	//  inherited virtual methods for Reference-management
	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message );

	void GetMat(TimeValue t, INode* inode, ViewExp *vpt, Matrix3& mat);
	
public:
	GeneralLight(int type);
	~GeneralLight();

	//  inherited virtual methods:

	// From GenLight
	GenLight *NewLight(int type) { return new GeneralLight(type); }

	// From BaseObject
	int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
	void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
	void SetExtendedDisplay(int flags);
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CreateMouseCallBack* GetCreateMouseCallBack();
	void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
	void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	TCHAR *GetObjectName();

	void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp* vpt, Box3& box );
	void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp* vpt,  Box3& box );
	void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );

	// From Object
	ObjectState Eval(TimeValue time);
	void InitNodeName(TSTR& s);
	Interval ObjectValidity(TimeValue t);
	BOOL UsesWireColor()	{ return 1; }
	int DoOwnSelectHilite() { return 1; }		

	// From Light
	RefResult EvalLightState(TimeValue t, Interval& valid, LightState* cs);
#ifdef SIMPLEDIR
	BOOL IsSpot()	{ return type == FSPOT_LIGHT || type == TSPOT_LIGHT; }
#else
	BOOL IsSpot()	{ return type == FSPOT_LIGHT || type == TSPOT_LIGHT || type == DIR_LIGHT; }
#endif
	BOOL IsDir()	{ return type == DIR_LIGHT; }
	void SetUseLight(int onOff);
	BOOL GetUseLight(void)		{ return useLight; }
	void SetSpotShape(int s);
	int GetSpotShape(void)	{ return shape; }
	void SetHotspot(TimeValue time, float f);
	float GetHotspot(TimeValue t, Interval& valid = Interval(0,0));
	void SetFallsize(TimeValue time, float f);
	float GetFallsize(TimeValue t, Interval& valid = Interval(0,0));
	void SetAtten(TimeValue time, int which, float f);
	float GetAtten(TimeValue t, int which, Interval& valid = Interval(0,0));
	void SetTDist(TimeValue time, float f);
	float GetTDist(TimeValue t, Interval& valid = Interval(0,0));
	int GetShadowMethod() {return shadow?(shadowType==0?LIGHTSHADOW_MAPPED:LIGHTSHADOW_RAYTRACED):LIGHTSHADOW_NONE;}
	void ReloadShadCtrls(HWND hDlg, TimeValue t);	

	ObjLightDesc *CreateLightDesc(INode *n);
	
	// internal set/get routines
	void SetRGBColor(TimeValue t, Point3& rgb);
	Point3 GetRGBColor(TimeValue t, Interval &valid = Interval(0,0));
	void SetHSVColor(TimeValue t, Point3& hsv);
	Point3 GetHSVColor(TimeValue t, Interval &valid = Interval(0,0));
	void SetUpdateHSVSpin(int b)	{ updateHSVSpin = b; }
	void SetIntensity(TimeValue time, float f);
	float GetIntensity(TimeValue t, Interval& valid = Interval(0,0));
	void SetAspect(TimeValue t, float f);
	float GetAspect(TimeValue t, Interval& valid = Interval(0,0));
	void SetConeDisplay(int s, int notify=TRUE);
	BOOL GetConeDisplay(void)		{ return coneDisplay; }
	void GetConePoints(TimeValue t, float aspect, float angle, float dist, Point3 *q);
	void DrawCone(TimeValue t, GraphicsWindow *gw, float dist);
	int DrawConeAndLine(TimeValue t, INode* inode, GraphicsWindow *gw, int drawing );
	void SetUseAtten(int s);
	BOOL GetUseAtten(void)			{ return useAtten; }
	void SetAttenDisplay(int s);
	BOOL GetAttenDisplay(void)		{ return attenDisplay; }
	void GetAttenPoints(TimeValue t, float rad, Point3 *q);
	int DrawAtten(TimeValue t, INode *inode, GraphicsWindow *gw);
	void Enable(int enab) { enable = enab; }

	void FixHotFallConstraint();
	int GetUseGlobal() { return useGlobalShadowParams; }
	void SetUseGlobal(int a) {useGlobalShadowParams =a; }
	int GetShadow() { return shadow; }
	void SetShadow(int a) { shadow = a; }
	int GetShadowType() { return useGlobalShadowParams?globShadowType:shadowType; }
	void SetShadowType(int a) { 
		if (useGlobalShadowParams) 	globShadowType = a; 
		else shadowType = a;
		}
	void SetMapBias(TimeValue t, float f);
	float GetMapBias(TimeValue t, Interval& valid = Interval(0,0));
	void SetMapRange(TimeValue t, float f);
	float GetMapRange(TimeValue t, Interval& valid = Interval(0,0));
	void SetMapSize(TimeValue t, int f);
	int GetMapSize(TimeValue t, Interval& valid = Interval(0,0));
	void SetRayBias(TimeValue t, float f);
	float GetRayBias(TimeValue t, Interval& valid = Interval(0,0));
	int GetAbsMapBias() { return useGlobalShadowParams ? globAbsMapBias : absMapBias; }
	void SetAbsMapBias(int a) {
		if (useGlobalShadowParams) 	globAbsMapBias = a; 
		else absMapBias = a; 
		}
	int GetOvershoot() { return overshoot; }
	void SetOvershoot(int a);
	int GetProjector() { return projector; }
	void SetProjector(int a) { projector = a; }
	void DoBitmapFit(HWND hwnd, TimeValue t);
	NameTab* GetExclList() {return &exclList; }
	BOOL Include() {return exclList.TestFlag(NT_INCLUDE); }
	Texmap* GetProjMap() { return projMap;  }
	void SetProjMap(Texmap* pmap);
	void AssignProjectorMap(HWND hWnd);

	NameTab& GetExclusionList() {return exclList;}
	void SetExclusionList(NameTab &list) {exclList = list;}

	BOOL SetHotSpotControl(Control *c);
	BOOL SetFalloffControl(Control *c);
	BOOL SetColorControl(Control *c);
	Control* GetHotSpotControl();
	Control* GetFalloffControl();
	Control* GetColorControl();

	// Animatable methods
	void DeleteThis() { delete this; }
	Class_ID ClassID() { return  Class_ID(OMNI_LIGHT_CLASS_ID+type,0); }  
	void GetClassName(TSTR& s) { s = TSTR(_T("FOO")); }

	void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags); 
	
	int NumSubs() { return 1; }  
	Animatable* SubAnim(int i) { return pblock; }
	TSTR SubAnimName(int i) { return TSTR(_T("FOO"));}

	// From ref
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	int NumRefs() {return 2;}
	RefTargetHandle GetReference(int i) {
		 return (i==0)?(RefTargetHandle)pblock: (RefTargetHandle)projMap;
		 }
	void SetReference(int i, RefTargetHandle rtarg) {
		if (i==0)pblock=(IParamBlock*)rtarg; 
		else projMap = (Texmap *)rtarg;
		}

	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);

	LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
            WPARAM wParam,   LPARAM lParam ){return(0);}

	/*New call required by Athena*/

	//void SetAspect(TimeValue t, float f){if(!IsSpot()) return; pblock->SetValue( PB_ASPECT, t, f );
	//NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);}

	//float GetAspect(TimeValue t, Interval& valid = Interval(0,0)){if(!IsSpot()) return -1.0f; float f;
	//pblock->GetValue( PB_ASPECT, t, f, valid ); return f;}

	void SetUseAttenNear(int s) {NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);}
	BOOL GetUseAttenNear(void) {return FALSE;}
	void SetAttenNearDisplay(int s) {NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);}
	BOOL GetAttenNearDisplay(void) {return FALSE;}

	int Type();  // OMNI_LIGHT, TSPOT_LIGHT, DIR_LIGHT, FSPOT_LIGHT, TDIR_LIGHT
	void SetContrast(TimeValue t, float f){pblock->SetValue( 2, t, f ); NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);}
	float GetContrast(TimeValue t, Interval& valid = Interval(0,0)){float f; pblock->GetValue( 2, t, f, valid ); return f;}
	void SetAffectDiffuse(BOOL onOff){;}
	BOOL GetAffectDiffuse() {return FALSE;}
	void SetAffectSpecular(BOOL onOff){;}
	BOOL GetAffectSpecular() {return FALSE;}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\COMPASS.CPP ===
/**********************************************************************
 *<
	FILE: compass.cpp

	DESCRIPTION:  A compass rose helper implementation

	CREATED BY: John  Hutchinson Derived from the point helper

	HISTORY: Oct 22, 1996

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/

#include "compass.h"
#include "verts.h"
//------------------------------------------------------

//#define AXIS_LENGTH 0.01f //used to be 25.0 before creation proc changed
#define AXIS_LENGTH 10.0f //used to be 25.0 before creation proc changed
#define BASESCALE 5.0f
#define ICONSCALE 5.0f
#define MIN_ZOOM 0.0001f
#define RU_UPDATE WM_USER + 666
extern ClassDesc* GetCompassRoseDesc();
void AxisViewportRect(ViewExp *vpt, const Matrix3 &tm, float length, Rect *rect);
void DrawAxis(ViewExp *vpt, const Matrix3 &tm, float length, BOOL sel=FALSE, BOOL frozen=FALSE);
Box3 GetAxisBox(ViewExp *vpt, const Matrix3 &tm,float length,int resetTM);


// class variable for point class.
HWND CompassRoseObject::hParams = NULL;
IObjParam *CompassRoseObject::iObjParams;

int CompassRoseObject::dlgShowAxis = TRUE;
float CompassRoseObject::dlgAxisLength = AXIS_LENGTH;

void resetPointParams() 
{
	CompassRoseObject::dlgShowAxis = TRUE;
	CompassRoseObject::dlgAxisLength = AXIS_LENGTH;
}


class CompassRoseObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new CompassRoseObject; }
	const TCHAR *	ClassName() { return GetString(IDS_DB_COMPASS_CDESC); }
	SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
	Class_ID		ClassID() { return COMPASS_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");  }
	void			ResetClassParams(BOOL fileReset) { if(fileReset) resetPointParams(); }
	};

static CompassRoseObjClassDesc compassRoseObjDesc;

ClassDesc* GetCompassRoseDesc() { return &compassRoseObjDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;


BOOL CALLBACK PointParamProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	CompassRoseObject *po = (CompassRoseObject*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!po && msg!=WM_INITDIALOG) return FALSE;

	switch (msg) {
		case WM_INITDIALOG: {
			po = (CompassRoseObject*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			CheckDlgButton(hWnd,IDC_SHOWAXIS,po->showAxis);
			
			ISpinnerControl *spin = 
				GetISpinner(GetDlgItem(hWnd,IDC_AXISLENGHSPIN));
//			spin->SetLimits(0,1000,FALSE);
			spin->SetLimits(AXIS_LENGTH,1000.0f,FALSE);
			spin->SetScale(0.1f);
			spin->SetValue(po->axisLength,FALSE);
			spin->LinkToEdit(GetDlgItem(hWnd,IDC_AXISLENGTH),EDITTYPE_FLOAT);
			ReleaseISpinner(spin);
			return FALSE;
			}

		case CC_SPINNER_CHANGE: {
			ISpinnerControl *spin = (ISpinnerControl*)lParam;
			po->axisLength = spin->GetFVal();
			po->NotifyDependents(FOREVER,PART_OBJ,REFMSG_CHANGE);
			po->iObjParams->RedrawViews(po->iObjParams->GetTime());
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SHOWAXIS:
					po->showAxis = IsDlgButtonChecked(hWnd,IDC_SHOWAXIS);
					po->NotifyDependents(FOREVER,PART_OBJ,REFMSG_CHANGE);
					po->iObjParams->RedrawViews(po->iObjParams->GetTime());
					break;
				}
			break;

		case RU_UPDATE:{
			ISpinnerControl *spin = 
				GetISpinner(GetDlgItem(hWnd,IDC_AXISLENGHSPIN));
			if(spin)
			{
				spin->SetValue(po->axisLength,FALSE);
				ReleaseISpinner(spin);
			}
			}
			break;
		
		default:
			return FALSE;
		}
	
	return TRUE;
	} 

void CompassRoseObject::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{	
	iObjParams = ip;
	if (!hParams) {
		hParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_COMPASSPARAM),
				PointParamProc, 
				GetString(IDS_DB_PARAMETERS), 
				(LPARAM)this );
		ip->RegisterDlgWnd(hParams);
	} else {
		SetWindowLong(hParams,GWL_USERDATA,(LONG)this);
		CheckDlgButton(hParams,IDC_SHOWAXIS,showAxis);
		ISpinnerControl *spin = 
			GetISpinner(GetDlgItem(hParams,IDC_AXISLENGHSPIN));
		spin->SetValue(axisLength,FALSE);
		ReleaseISpinner(spin);
		}
	}
		
void CompassRoseObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{	
	dlgShowAxis = IsDlgButtonChecked(hParams, IDC_SHOWAXIS );
	ISpinnerControl *spin = GetISpinner(GetDlgItem(hParams,IDC_AXISLENGHSPIN));
	dlgAxisLength = spin->GetFVal();
	ReleaseISpinner(spin);
	if (flags&END_EDIT_REMOVEUI) {
		ip->UnRegisterDlgWnd(hParams);
		ip->DeleteRollupPage(hParams);
		hParams = NULL;
	} else {
		SetWindowLong(hParams,GWL_USERDATA,0);
		}
	iObjParams = NULL;
	}


CompassRoseObject::CompassRoseObject()
	{	
	showAxis = dlgShowAxis;
	axisLength = dlgAxisLength;
	suspendSnap = FALSE;
	}

CompassRoseObject::~CompassRoseObject()
	{	
	}

class CompassRoseObjCreateCallBack: public CreateMouseCallBack {
	Point3 p0, p1;
	CompassRoseObject *ob;
	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat );
		void SetObj(CompassRoseObject *obj) { ob = obj; }
	};

int CompassRoseObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				ob->suspendSnap = TRUE;
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				mat.SetTrans(p0);
				break;
			case 1:
//				mat.SetTrans(vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
				p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
//				ob->axisLength = (Length(p1-p0));
				ob->axisLength = max(AXIS_LENGTH, Length(p1-p0));
				PostMessage(ob->hParams, RU_UPDATE, 0, 0);
				if (msg==MOUSE_POINT) {
					ob->suspendSnap = FALSE;
					return 0;
					}
				break;			
			}
	} else 
	if (msg == MOUSE_ABORT) {		
		return CREATE_ABORT;
		}
	return 1;
	}

static CompassRoseObjCreateCallBack compassRoseCreateCB;

CreateMouseCallBack* CompassRoseObject::GetCreateMouseCallBack() {
	compassRoseCreateCB.SetObj(this);
	return(&compassRoseCreateCB);
	}

void CompassRoseObject::SetExtendedDisplay(int flags)
	{
	extDispFlags = flags;
	}

void CompassRoseObject::GetLocalBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box ) 
	{
	Matrix3 tm(1);
	tm.SetTrans(inode->GetObjectTM(t).GetTrans());
	box = GetAxisBox(vpt,tm,showAxis?axisLength:0.0f, TRUE);
	}

void CompassRoseObject::GetWorldBoundBox(
		TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	Matrix3 tm;
	tm = inode->GetObjectTM(t);
	if(!(extDispFlags & EXT_DISP_ZOOM_EXT))
		box = GetAxisBox(vpt,tm,showAxis?axisLength:0.0f, FALSE);
	else
		box = Box3(tm.GetTrans(), tm.GetTrans());
	assert(!box.IsEmpty());
	}


// From BaseObject
int CompassRoseObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt) {
	Matrix3 tm(1);	
	HitRegion hitRegion;
	DWORD	savedLimits;
	Point3 pt(0,0,0);

	GraphicsWindow *gw = vpt->getGW();	
   	tm = inode->GetObjectTM(t);		
	MakeHitRegion(hitRegion, type, crossing, 4, p);

	gw->setRndLimits(((savedLimits = gw->getRndLimits())|GW_PICK)&~GW_ILLUM);
	gw->setHitRegion(&hitRegion);
	gw->clearHitCode();

	if (showAxis) {
		DrawAxis(vpt,tm,axisLength);
		}
	vpt->getGW()->setTransform(tm);
	vpt->getGW()->marker(&pt,X_MRKR);

	gw->setRndLimits(savedLimits);
	
	if((hitRegion.type != POINT_RGN) && !hitRegion.crossing)
		return TRUE;
	return gw->checkHitCode();
	}

void CompassRoseObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt)
	{

	if(suspendSnap)
		return;

	Matrix3 tm = inode->GetObjectTM(t);	
	GraphicsWindow *gw = vpt->getGW();	
	gw->setTransform(tm);

	Matrix3 invPlane = Inverse(snap->plane);
	// Check for upside-down coordinate system in viewport
	float ybias = (float)gw->getWinSizeY() - 1.0f;

	// Make sure the vertex priority is active and at least as important as the best snap so far
	if(snap->vertPriority > 0 && snap->vertPriority <= snap->priority) {
		Point2 fp = Point2((float)p->x, (float)p->y);
		Point3 screen3;
		Point2 screen2;

		Point3 thePoint(0,0,0);
		// If constrained to the plane, make sure this point is in it!
		if(snap->snapType == SNAP_2D || snap->flags & SNAP_IN_PLANE) {
			Point3 test = thePoint * tm * invPlane;
			if(fabs(test.z) > 0.0001)	// Is it in the plane (within reason)?
				return;
			}
		//gw->transPointFWin(&thePoint,&screen3);  //this is for MAX 1.2
		gw->transPoint(&thePoint, &screen3);
		screen3.y = ybias - screen3.y;
		screen2.x = screen3.x;
		screen2.y = screen3.y;

		// Are we within the snap radius?
		int len = (int)Length(screen2 - fp);
		if(len <= snap->strength) {
			// Is this priority better than the best so far?
			if(snap->vertPriority < snap->priority) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = thePoint * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			else
			if(len < snap->bestDist) {
				snap->priority = snap->vertPriority;
				snap->bestWorld = thePoint * tm;
				snap->bestScreen = screen2;
				snap->bestDist = len;
				}
			}
		}

  }


int CompassRoseObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) {
	Matrix3 tm = inode->GetObjectTM(t);
	Point3 pt(0,0,0);
	vpt->getGW()->setTransform(tm);
	if (showAxis) {
		DrawAxis(vpt,tm,axisLength,inode->Selected(),inode->IsFrozen());
		}
	if(!inode->IsFrozen())
		vpt->getGW()->setColor(LINE_COLOR,1.0f,0.9f,0.0f);
	vpt->getGW()->marker(&pt,X_MRKR);
	return(0);
	}



//
// Reference Managment:
//

// This is only called if the object MAKES references to other things.
RefResult CompassRoseObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
    {
	return(REF_SUCCEED);
	}

ObjectState CompassRoseObject::Eval(TimeValue time){
	return ObjectState(this);
	}

RefTargetHandle CompassRoseObject::Clone(RemapDir& remap) {
	CompassRoseObject* newob = new CompassRoseObject();	
	newob->showAxis = showAxis;
	newob->axisLength = axisLength;
	return(newob);
	}


#define SHOW_AXIS_CHUNK		0x0100
#define AXIS_LENGTH_CHUNK	0x0110

IOResult CompassRoseObject::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case SHOW_AXIS_CHUNK:
				res = iload->Read(&showAxis,sizeof(showAxis),&nb);
				break;
			case AXIS_LENGTH_CHUNK:
				res = iload->Read(&axisLength,sizeof(axisLength),&nb);
				break;
			}

		res = iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	
	return IO_OK;
	}

IOResult CompassRoseObject::Save(ISave *isave)
	{
	ULONG nb;

	isave->BeginChunk(SHOW_AXIS_CHUNK);
	isave->Write(&showAxis,sizeof(showAxis),&nb);
	isave->EndChunk();

	isave->BeginChunk(AXIS_LENGTH_CHUNK);
	isave->Write(&axisLength,sizeof(axisLength),&nb);
	isave->EndChunk();
	
	return IO_OK;
	}


/*--------------------------------------------------------------------*/
// 
// Stole this from scene.cpp
// Probably couldn't hurt to make an API...
//
//


void Text( ViewExp *vpt, TCHAR *str, Point3 &pt )
	{	
	vpt->getGW()->text( &pt, str );	
	}

static void DrawAStar( ViewExp *vpt, float len )
	{
	Point3 v[NUMVERTS+1];
	//we'll scale the points to fill out the dlg size, almost
	float mult = (len/ICONSCALE)*(float)0.8;
/*
	for(int i= 0; i < NUMVERTS-1;i++){ 
		v[0] = mult * roseverts[i];
		v[1] = mult * roseverts[i+1];
		vpt->getGW()->polyline( 2, v, NULL, NULL, FALSE, NULL );
		}

	//close up the polyline
	v[0] = mult * roseverts[0];
	v[1] = mult * roseverts[NUMVERTS-1];
	vpt->getGW()->polyline( 2, v, NULL, NULL, FALSE, NULL );
*/
	for (int k= 0; k<NUMVERTS;k++){
		v[k]=roseverts[k]*mult;}
 	vpt->getGW()->polyline( NUMVERTS, v, NULL, NULL, TRUE, NULL );


	//draw an extra line in the north driection
	v[0] = Point3(0.0f,0.0f,0.0f);
	v[1] = mult * roseverts[3];
	vpt->getGW()->polyline( 2, v, NULL, NULL, FALSE, NULL );
	}

#define ZFACT (float).005;
#define AXIS_COLOR		0.4f,0.4f,0.4f
#define SELAXIS_COLOR	1.0f,1.0f,1.0f

void DrawAxis( ViewExp *vpt, const Matrix3 &tm, float length, BOOL sel, BOOL frozen )
	{
	Matrix3 tmn = tm;
	float zoom;
	int limits;	

	// Get width of viewport in world units:  --DS
	zoom = vpt->GetScreenScaleFactor(tmn.GetTrans())*ZFACT;
	
	tmn.Scale( Point3(zoom,zoom,zoom) );
	vpt->getGW()->setTransform( tmn );

	limits = vpt->getGW()->getRndLimits();
//	vpt->getGW()->setRndLimits( limits & ~GW_Z_BUFFER );  JH

	if (sel) {
		vpt->getGW()->setColor( TEXT_COLOR, SELAXIS_COLOR );
		vpt->getGW()->setColor( LINE_COLOR, SELAXIS_COLOR );
	} else if (!frozen) {
		vpt->getGW()->setColor( TEXT_COLOR, AXIS_COLOR );
		vpt->getGW()->setColor( LINE_COLOR, AXIS_COLOR );
		}
	float corners = .9f * length;
	Text( vpt, GetString(IDS_EAST_MARK), Point3(corners,0.0f,0.0f) ); 
	Text( vpt, GetString(IDS_WEST_MARK), Point3(-corners,0.0f,0.0f) ); 
	Text( vpt, GetString(IDS_NORTH_MARK), Point3(0.0f,corners,0.0f) ); 
	Text( vpt, GetString(IDS_SOUTH_MARK), Point3(0.0f,-corners,0.0f) ); 
	
	DrawAStar( vpt, length);	
	
	vpt->getGW()->setRndLimits( limits );
	}

Box3 GetAxisBox(ViewExp *vpt, const Matrix3 &tm,float length,int resetTM)
	{
	Matrix3 tmn = tm;
	Box3 box;
	float zoom;

	// Get width of viewport in world units:  --DS
	zoom = vpt->GetScreenScaleFactor(tmn.GetTrans())*ZFACT;
	if (zoom < MIN_ZOOM) zoom = 1.0f;
//	tmn.Scale(Point3(zoom,zoom,zoom));
	length *= zoom;
	if(resetTM)
		tmn.IdentityMatrix();

	box += Point3(0.0f,0.0f,0.0f) * tmn;
	box += Point3(length,0.0f,0.0f) * tmn;
	box += Point3(0.0f,length,0.0f) * tmn;
	box += Point3(0.0f,0.0f,length) * tmn;	
	box += Point3(-length,0.0f,0.0f) * tmn;
	box += Point3(0.0f,-length,0.0f) * tmn;
	box += Point3(0.0f,0.0f,-length) * tmn;
	box.EnlargeBy(10.0f/zoom);
	return box;
	}


inline void EnlargeRectIPoint3( RECT *rect, IPoint3& pt )
	{
	if ( pt.x < rect->left )   rect->left   = pt.x;
	if ( pt.x > rect->right )  rect->right  = pt.x;
	if ( pt.y < rect->top )    rect->top    = pt.y;
	if ( pt.y > rect->bottom ) rect->bottom = pt.y;
	}

// This is a guess - need to find real w/h.
#define FONT_HEIGHT	11
#define FONT_WIDTH  9	


static void AxisRect( GraphicsWindow *gw, Point3 axis, Rect *rect )
	{
	Point3 v1, v2, v;	
	IPoint3 iv;
	v1 = axis * (float)0.9;
	if ( axis.x != 0.0 || axis.y != 0.0 ) {
		v2 = Point3( axis.y, -axis.x, axis.z ) * (float)0.1;
	} else {
		v2 = Point3( axis.x, axis.z, -axis.y ) * (float)0.1;
		}
	v = axis;
	//gw->transPointIWin( &v, &iv );		//MAX 1.2
	gw->wTransPoint(&v, &iv);
	EnlargeRectIPoint3( rect, iv);

	iv.x += FONT_WIDTH;
	iv.y -= FONT_HEIGHT;
	EnlargeRectIPoint3( rect, iv);

	v = v1+v2;
	//gw->transPointIWin( &v, &iv );		//MAX 1.2
	gw->wTransPoint(&v, &iv);
	EnlargeRectIPoint3( rect, iv);
	v = v1-v2;
	//gw->transPointIWin( &v, &iv );		//MAX 1.2
	gw->wTransPoint(&v, &iv);
	EnlargeRectIPoint3( rect, iv);
	}


void AxisViewportRect(ViewExp *vpt, const Matrix3 &tm, float length, Rect *rect)
	{
	Matrix3 tmn = tm;
	float zoom;
	IPoint3 wpt;
	Point3 pt;
	GraphicsWindow *gw = vpt->getGW();

	// Get width of viewport in world units:  --DS
	zoom = vpt->GetScreenScaleFactor(tmn.GetTrans())*ZFACT;
	
	tmn.Scale( Point3(zoom,zoom,zoom) );
	gw->setTransform( tmn );	
	pt = Point3(0.0f, 0.0f, 0.0f);
	//gw->transPointIWin( &pt, &wpt );		//MAX 1.2
	gw->wTransPoint(&pt, &wpt);
	rect->left = rect->right  = wpt.x;
	rect->top  = rect->bottom = wpt.y;

	AxisRect( gw, Point3(length,0.0f,0.0f),rect );	
	AxisRect( gw, Point3(0.0f,length,0.0f),rect );	
	AxisRect( gw, Point3(0.0f,0.0f,length),rect );	

	rect->right  += 2;
	rect->bottom += 2;
	rect->left   -= 2;
	rect->top    -= 2;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\sunclass.h ===
#ifndef SUNCLASS_H
#define SUNCLASS_H

/*===========================================================================*\
	FILE: sunclass.h

	DESCRIPTION: Sunlight system classes.

	HISTORY: Created Oct.15 by John Hutchinson
			Derived from the ringarray

	Copyright (c) 1996, All Rights Reserved.
 \*==========================================================================*/


extern TCHAR* GetString(int id);


/*===========================================================================*\
 | Sun Master Class:
\*===========================================================================*/

// The unique 32-bit Class IDs of the ring array
#define SUNLIGHT_CID1 0x5897670e
#define SUNLIGHT_CID2 0x61b5008d


class SunMaster: public ReferenceTarget{ 
	friend class SunMasterPostLoad;

	// Object parameters
	IParamBlock *pblock;


	//Local epoch scheme when animating time
	float timeref;
	long dateref;
	BOOL refset;

	//Don't want to process msgs which we induce 
	BOOL ignore_point_msgs;

	//The dependent variables
	double alt, az;
	char city[64];
		


	public:

		// thePoint is the helper object about which the light rotates
		INode* thePoint;
		INode* theLight;

		SYSTEMTIME theTime;
		Interval tvalid;// here we maintain the validity of theTime; 



		// Constructor.
		SunMaster();

		// method to rotate the helper object around its z axis. This is done by spinning
		// a spinner on the parameters rollout which seems a bit convoluted.
		void align_north(TimeValue t, float r);
		
		// calculates the azimuth and altitude from the independent vars
		void calculate(TimeValue t, Interval& valid);

		//access to the private dependent vars
		double Getalt(){return alt;}
		double Getaz(){return az;}
		// Note: I would _like_ to be able to return a const char*, but
		// the ICustStatus::SetText() method requires a char*, even though
		// it doesn't change the text!
		char* GetCity() { return city; }
		void SetCity(const char* nam);

		// The following methods set and get values from the parameter block
		void SetRad(TimeValue t, float r);
		void SetLat(TimeValue t, float r);
		void SetLong(TimeValue t, float r);
		void SetNorth(TimeValue t, float r);
		void SetTime(TimeValue t, interpJulianStruct jd);
		void SetZone(TimeValue t, int h);
		void SetDst(TimeValue t, BOOL h);

		float GetRad(TimeValue t, Interval& valid = Interval(0,0) );
		float GetLat(TimeValue t, Interval& valid = Interval(0,0) );
		float GetLong(TimeValue t, Interval& valid = Interval(0,0) );
		float GetNorth(TimeValue t, Interval& valid = Interval(0,0) );
		void GetTime(TimeValue t, Interval& valid = Interval(0,0) );
		int GetZone(TimeValue t, Interval& valid = Interval(0,0) );
		int GetDst(TimeValue t, Interval& valid = Interval(0,0) );
		Point2 GetAzAlt(TimeValue t, Interval& valid );

		//The controller needs to interpolate time as if it were a single float. However
		//the user will be changing the hours, mins, secs independently. I've created set
		//and get methods for each of the date/time fields as if there were parameter block
		//entries for each of them. These methods just call settime and gettime respectively.
		//The set methods actually place their values into a local structure theTime, and then
		// call SetTime which converts the contents of the struct into something which can be
		//stuck in the parameter block. GetTime pulls the interpolated time from the pblock 
		// and explodes it into the local stucture. Therefore GetHour for example calls GetTime
		// and then returns the appropriate field of the structure.
		
		// the next methods are pseudo PBLOCK methods which call SetTime
		void SetHour(TimeValue t, int h);
		void SetMin(TimeValue t, int m);
		void SetSec(TimeValue t, int s);
		void SetMon(TimeValue t, int m);
		void SetDay(TimeValue t, int d);
		void SetYr(TimeValue t, int y);


		// the next methods are pseudo PBLOCK methods which call GetTime
		int GetHour(TimeValue t, Interval& valid = Interval(0,0));
		int GetMin(TimeValue t, Interval& valid = Interval(0,0));
		int GetSec(TimeValue t, Interval& valid = Interval(0,0));
		int GetMon(TimeValue t, Interval& valid = Interval(0,0));
		int GetDay(TimeValue t, Interval& valid = Interval(0,0));
		int GetYr(TimeValue t, Interval& valid = Interval(0,0));

		
		// The slave controllers call this method to retrieve their
		// value.  This allows the master object to control the entire
		// system.
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method, int id);
		// This makes sure that the spinner controls track when animating 
		// and in Motion Panel.
		void UpdateUI(TimeValue t);

		HWND hMasterParams;

		// The following static variables are 'class variables'.   

		// The window handle of the rollup page
		//static HWND hMasterParams;
		//This won't work if you have multiple animated systems trying to update the same
		//UI controls

		// The interface pointer for calling functions provided by MAX.
		static IObjParam *iObjParams;


		// The spinner controls...
		static ISpinnerControl *radSpin;
		static ISpinnerControl *latSpin;
		static ISpinnerControl *longSpin;
		static ISpinnerControl *hourSpin;
		static ISpinnerControl *minSpin;
		static ISpinnerControl *secSpin;
		static ISpinnerControl *yearSpin;
		static ISpinnerControl *monthSpin;
		static ISpinnerControl *daySpin;
		static ISpinnerControl *northSpin;
		static ISpinnerControl *zoneSpin;
		static ICustStatus *altEdit;	
		static ICustStatus	*azEdit;	
		static ICustStatus	*cityDisplay;	
		
		// --- Inherited virtual methods from Animatable ---

		// This method returns the number of sub-anims this plug-in
		// has.  Is has one, the parameter block.
		int NumSubs()  { return 1; }
		// This methods returns the ith sub-anim (parameter)
		Animatable* SubAnim(int i) { return pblock; }
		// This method returns the name of the ith sub-anim.
		TSTR SubAnimName(int i);

		

		// This method returns the unique class ID of the plug-in
		Class_ID ClassID() { return Class_ID(SUNLIGHT_CID1,SUNLIGHT_CID2); }  
		// This method returns the super class ID of the plug-in.  This
		// describes the type of plug-in this is.  The list of possible
		// values is defined by the system.
		SClass_ID SuperClassID() { return SYSTEM_CLASS_ID; }  

		// This method returns the name of the plug-in class.  This is 
		// just used in debugging.
		void GetClassName(TSTR& s);
		void DeleteThis() { delete this; }
		int IsKeyable(){ return 1;}
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt);

		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );

		// The master controller of a system plug-in should implement this 
		// method to give MAX a list of nodes that are part of the system.   
		void GetSystemNodes(INodeTab &nodes);

		// --- Inherited virtual methods from from ReferenceMaker/Target ---

		// reference the parameter block and the helper
		int NumRefs() { return 2;};
		// This method returns the ith reference.
		RefTargetHandle GetReference(int i);
		// This method sets the ith reference to the target passed.
		void SetReference(int i, RefTargetHandle rtarg);
		// This method is called to copy the plug-in class.
		RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// This method recieves the change notification methods
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, 
			RefMessage);
		// These methods handle the loading and saving of the plug-ins
		// data.  See the Advanced Topics section on Loading and Saving
		// for more details.
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};


 /*===========================================================================*\
 | Slave Controller Class:
\*===========================================================================*/

	
// The unique 32-bit Class IDs of the slave controller
#define SLAVE_CONTROL_CID1 0x77e3272e
#define SLAVE_CONTROL_CID2 0x13747060
extern TCHAR* GetString(int id);

 
class SlaveControl : public Control {
	public:		
		// This controller maintains a reference to the master.
		SunMaster *master;
		// This is the id of the slave controller. Passed to the master.
		ULONG id;

		// Constructors, destructor, assignment operator.
		SlaveControl(BOOL loading=FALSE) { master = NULL; id = 0; }
		SlaveControl(const SlaveControl& ctrl);
		SlaveControl(const SunMaster* m, int i);
		void SetID( ULONG i) { id = i;}
		virtual ~SlaveControl() {}	
		SlaveControl& operator=(const SlaveControl& ctrl);

		// --- Inherited virtual methods from Control ---
		void Copy(Control *from) {}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}
		// If a controller has sub-controllers or references it is not
		// a leaf controller. 
		virtual BOOL IsLeaf() {return FALSE;}
		// This method is used to retrieve the value of the controller
		// at the specified time.
		void GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		// This method is used to set the value of the controller
		// at the specified time.
		void SetValue(TimeValue t, void *val, int commit=1, GetSetMethod method=CTRL_ABSOLUTE);

		BOOL IsReplaceable() {return FALSE;}

		// --- Inherited virtual methods from Animatable ---
		void* GetInterface(ULONG id);
		int NumSubs()  { return master->NumSubs(); }
		Animatable* SubAnim(int i) { return master->SubAnim(i); }
		TSTR SubAnimName(int i) { return master->SubAnimName(i); }
		BOOL BypassTreeView(){return TRUE;}

		// If an anim doesn't want to be copied in track view it can implement
		// this method to return FALSE.
		BOOL CanCopyAnim() {return FALSE;}

		Class_ID ClassID()
			{ return Class_ID(SLAVE_CONTROL_CID1,SLAVE_CONTROL_CID2); }  
		SClass_ID SuperClassID() { return CTRL_POSITION_CLASS_ID; }  
		void GetClassName(TSTR& s);
		void DeleteThis() { delete this; }		
		int IsKeyable(){ return 1;}
		BOOL GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt){return master->GetNextKeyTime(t,flags,nt);};

		//  This implementation simply calls the same method of the SunMaster
		// object.  This is done because the UI controls managed by
		// the ring master control the entire system.
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev) { assert(master); master->BeginEditParams(ip,flags,prev); } 
		// This is called to end the parameter editing.  Again, the 
		// sun master method is called.
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next) { assert(master); master->EndEditParams(ip,flags,next); } 

		// --- Inherited virtual methods from ReferenceMaker and Target ---
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		// The slave controller has a single reference to the sun master.
		int NumRefs() { return 1; };	
		RefTargetHandle GetReference(int i)  
			{ assert(i==0); return master; }
		void SetReference(int i, RefTargetHandle rtarg) 
			{ assert(i==0); master = (SunMaster *)rtarg; }		

		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, 
			RefMessage) {return REF_SUCCEED;}
		// These methods load and save the controller data from/to the MAX file
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		////////////////////////////////////////////////////////////////////////////
		// API METHODS
		////////////////////////////////////////////////////////////////////////////
		/*
		| Other applications might like to get some info from a (the) sun. 
		| The following methods can be called.
		|
		| void GetSunTime( TimeValue t, SYSTEMTIME&	sunt )
		|
		| This method provides access to the solar time (GMT) at the time requested.
		|
		| void GetSunLoc(TimeValue t, Point2& origin, Point2& orient)
		|
		| This method provides access to the latitude and longitude as well as the 
		| azimuth and altitude at the requested time.
		| After the call:
		| 
		| origin.x = latitude
		| origin.y = longitude
		| orient.x = azimuth
		| orient.y = altitude
		|
		////////////////////////////////////////////////////////////////////////////
		*/
		__declspec(dllexport) virtual void GetSunTime( TimeValue t, SYSTEMTIME&	sunt );
		__declspec(dllexport) virtual void GetSunLoc(TimeValue t, Point2& origin, Point2& orient);
	};


#endif //SUNCLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\suntypes.h ===
/*===========================================================================*\
	FILE: suntypes.h

	DESCRIPTION: Some type defineitions for the sunlight system.

	HISTORY: Adapted by John Hutchinson 10/08/97 
			

	Copyright (c) 1996, All Rights Reserved.
 \*==========================================================================*/

typedef struct _interpJulianStruct { 
    double days; 
    int subday;
	long epoch;
} interpJulianStruct; 

typedef struct _uTimevect { 
    unsigned short i; 
    unsigned short j;
	unsigned short k;
} uTimevect;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\sunlight.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sunlight.RC
//
#define IDS_RADIUS                      1
#define IDS_DB_POINT                    1
#define IDS_DB_COMPASS                  1
#define IDS_CYCLES                      2
#define IDS_DB_POINTHELPER              2
#define IDS_DB_COMPASS_CLASS            2
#define IDS_AMPLITUDE                   3
#define IDS_DB_GENERAL                  3
#define IDS_PHASE                       4
#define IDS_DB_PARAMETERS               4
#define IDS_CREATE                      5
#define IDS_SUN_CREATE_PROMPT           5
#define IDS_RINGARRAYPAR                6
#define IDS_SUN_COMPLETE_PROMPT         6
#define IDS_SLAVE_CLASS                 7
#define IDS_SOL_DATE                    8
#define IDS_SOL_TIME                    9
#define IDS_SUN_DLG_NAM                 10
#define IDS_SUN_CLASS                   11
#define IDS_SUN_CATEGORY                12
#define IDS_AFRICA                      13
#define IDS_ASIA                        14
#define IDS_ASIAN_SUBCONTINENT          15
#define IDS_AUSTRALIA                   16
#define IDS_CANADA                      17
#define IDS_EUROPE                      18
#define IDS_NORTH_AMERICA               19
#define IDS_SOUTH_AMERICA               20
#define IDS_WORLD                       21
#define IDS_LIB_DESCRIPTION             22
#define IDS_LIGHT_NAME                  22
#define IDS_DIALOG_TITLE                23
#define IDS_CAM_NAME                    23
#define IDS_SUN_CLASS_NAME              24
#define IDS_EAST_MARK                   24
#define IDS_CITY20                      25
#define IDS_CITY21                      26
#define IDS_CITY22                      27
#define IDS_CITY23                      28
#define IDS_CITY24                      29
#define IDS_CITY25                      30
#define IDS_CITY26                      31
#define IDS_CITY27                      32
#define IDS_CITY28                      33
#define IDS_CITY29                      34
#define IDS_CITY30                      35
#define IDS_CITY31                      36
#define IDS_CITY32                      37
#define IDS_CITY33                      38
#define IDS_CITY34                      39
#define IDS_CITY35                      40
#define IDS_CITY36                      41
#define IDS_CITY37                      42
#define IDS_CITY38                      43
#define IDS_CITY39                      44
#define IDS_CITY40                      45
#define IDS_CITY41                      46
#define IDS_CITY42                      47
#define IDS_CITY43                      48
#define IDS_CITY44                      49
#define IDS_CITY45                      50
#define IDS_CITY46                      51
#define IDS_CITY47                      52
#define IDS_CITY48                      53
#define IDS_CITY49                      54
#define IDS_CITY50                      55
#define IDS_CITY51                      56
#define IDS_CITY52                      57
#define IDS_CITY53                      58
#define IDS_CITY54                      59
#define IDS_CITY55                      60
#define IDS_CITY56                      61
#define IDS_CITY57                      62
#define IDS_CITY58                      63
#define IDS_CITY59                      64
#define IDS_CITY60                      65
#define IDS_CITY61                      66
#define IDS_CITY62                      67
#define IDS_CITY63                      68
#define IDS_CITY64                      69
#define IDS_CITY65                      70
#define IDS_CITY66                      71
#define IDS_CITY67                      72
#define IDS_CITY68                      73
#define IDS_CITY69                      74
#define IDS_CITY70                      75
#define IDS_CITY71                      76
#define IDS_CITY72                      77
#define IDS_CITY73                      78
#define IDS_CITY74                      79
#define IDS_CITY75                      80
#define IDS_CITY76                      81
#define IDS_CITY77                      82
#define IDS_CITY78                      83
#define IDS_CITY79                      84
#define IDS_CITY80                      85
#define IDS_CITY81                      86
#define IDS_CITY82                      87
#define IDS_CITY83                      88
#define IDS_CITY84                      89
#define IDS_CITY85                      90
#define IDS_CITY86                      91
#define IDS_CITY87                      92
#define IDS_CITY88                      93
#define IDS_CITY89                      94
#define IDS_CITY90                      95
#define IDS_CITY91                      96
#define IDS_CITY92                      97
#define IDS_CITY93                      98
#define IDS_CITY94                      99
#define IDS_CITY95                      100
#define IDS_CITY96                      101
#define IDS_CITY97                      102
#define IDS_CITY98                      103
#define IDS_CITY99                      104
#define IDS_CITY100                     105
#define IDS_CITY101                     106
#define IDS_CITY102                     107
#define IDS_CITY103                     108
#define IDS_CITY104                     109
#define IDD_COMPASSPARAM                110
#define IDS_CITY105                     110
#define IDS_CITY106                     111
#define IDS_CITY107                     112
#define IDS_CITY108                     113
#define IDS_CITY109                     114
#define IDS_CITY110                     115
#define IDS_CITY111                     116
#define IDS_CITY112                     117
#define IDS_CITY113                     118
#define IDS_CITY114                     119
#define IDS_CITY115                     120
#define IDS_CITY116                     121
#define IDD_SAMPLEPARAM                 122
#define IDD_SUNPARAM                    122
#define IDS_CITY117                     122
#define IDS_CITY118                     123
#define IDS_CITY119                     124
#define IDS_CITY120                     125
#define IDS_CITY121                     126
#define IDS_CITY122                     127
#define IDS_CITY123                     128
#define IDS_CITY124                     129
#define IDS_CITY125                     130
#define IDS_CITY126                     131
#define IDS_CITY127                     132
#define IDS_CITY128                     133
#define IDS_CITY129                     134
#define IDS_CITY130                     135
#define IDS_CITY131                     136
#define IDS_CITY132                     137
#define IDS_CITY133                     138
#define IDS_CITY134                     139
#define IDS_CITY135                     140
#define IDS_CITY136                     141
#define IDS_CITY137                     142
#define IDS_CITY138                     143
#define IDD_GEOGRAPHIC_LOCATION         144
#define IDS_CITY139                     144
#define IDS_CITY140                     145
#define IDS_CITY141                     146
#define IDS_CITY142                     147
#define IDS_CITY143                     148
#define IDS_CITY144                     149
#define IDS_CITY145                     150
#define IDS_CITY146                     151
#define IDS_CITY147                     152
#define IDS_CITY148                     153
#define IDS_CITY149                     154
#define IDS_CITY150                     155
#define IDS_CITY151                     156
#define IDS_CITY152                     157
#define IDS_CITY153                     158
#define IDS_CITY154                     159
#define IDS_CITY155                     160
#define IDS_CITY156                     161
#define IDS_CITY157                     162
#define IDS_CITY158                     163
#define IDS_CITY159                     164
#define IDS_CITY160                     165
#define IDS_CITY161                     166
#define IDS_CITY162                     167
#define IDS_CITY163                     168
#define IDS_CITY164                     169
#define IDS_CITY165                     170
#define IDS_CITY166                     171
#define IDS_CITY167                     172
#define IDS_CITY168                     173
#define IDS_CITY169                     174
#define IDS_CITY170                     175
#define IDS_CITY171                     176
#define IDS_CITY172                     177
#define IDS_CITY173                     178
#define IDS_CITY174                     179
#define IDS_CITY175                     180
#define IDS_CITY176                     181
#define IDS_CITY177                     182
#define IDS_CITY178                     183
#define IDC_CURSOR1                     183
#define IDS_CITY179                     184
#define IDS_CITY180                     185
#define IDS_CITY181                     186
#define IDS_CITY182                     187
#define IDS_CITY183                     188
#define IDS_CITY184                     189
#define IDS_CITY185                     190
#define IDS_CITY186                     191
#define IDS_CITY187                     192
#define IDS_CITY188                     193
#define IDS_CITY189                     194
#define IDS_CITY190                     195
#define IDS_CITY191                     196
#define IDS_CITY192                     197
#define IDS_CITY193                     198
#define IDS_CITY194                     199
#define IDS_CITY195                     200
#define IDS_CITY196                     201
#define IDS_CITY197                     202
#define IDS_CITY198                     203
#define IDS_CITY199                     204
#define IDS_CITY200                     205
#define IDS_CITY201                     206
#define IDS_CITY202                     207
#define IDS_CITY203                     208
#define IDS_CITY204                     209
#define IDS_CITY205                     210
#define IDS_CITY206                     211
#define IDS_CITY207                     212
#define IDS_CITY208                     213
#define IDS_CITY209                     214
#define IDS_CITY210                     215
#define IDS_CITY211                     216
#define IDS_CITY212                     217
#define IDS_CITY213                     218
#define IDS_CITY214                     219
#define IDS_CITY215                     220
#define IDS_CITY216                     221
#define IDS_CITY217                     222
#define IDS_CITY218                     223
#define IDS_CITY219                     224
#define IDS_CITY220                     225
#define IDS_CITY221                     226
#define IDS_CITY222                     227
#define IDS_CITY223                     228
#define IDS_CITY224                     229
#define IDS_CITY225                     230
#define IDS_CITY226                     231
#define IDS_CITY227                     232
#define IDS_CITY228                     233
#define IDS_CITY229                     234
#define IDS_CITY230                     235
#define IDS_CITY231                     236
#define IDS_CITY232                     237
#define IDS_CITY233                     238
#define IDS_CITY234                     239
#define IDS_CITY235                     240
#define IDS_CITY236                     241
#define IDS_CITY237                     242
#define IDS_CITY238                     243
#define IDS_CITY239                     244
#define IDS_CITY240                     245
#define IDS_CITY241                     246
#define IDS_CITY242                     247
#define IDS_CITY243                     248
#define IDS_CITY244                     249
#define IDS_CITY245                     250
#define IDS_CITY246                     251
#define IDS_CITY247                     252
#define IDS_CITY248                     253
#define IDS_CITY249                     254
#define IDS_CITY250                     255
#define IDS_CITY251                     256
#define IDS_CITY252                     257
#define IDS_CITY253                     258
#define IDS_CITY254                     259
#define IDS_CITY255                     260
#define IDS_CITY256                     261
#define IDS_CITY257                     262
#define IDS_CITY258                     263
#define IDS_CITY259                     264
#define IDS_CITY260                     265
#define IDS_CITY261                     266
#define IDS_CITY262                     267
#define IDS_CITY263                     268
#define IDS_CITY264                     269
#define IDS_CITY265                     270
#define IDS_CITY266                     271
#define IDS_CITY267                     272
#define IDS_CITY268                     273
#define IDS_CITY269                     274
#define IDS_CITY270                     275
#define IDS_CITY271                     276
#define IDS_CITY272                     277
#define IDS_CITY273                     278
#define IDS_CITY274                     279
#define IDS_CITY275                     280
#define IDS_CITY276                     281
#define IDS_CITY277                     282
#define IDS_CITY278                     283
#define IDS_CITY279                     284
#define IDS_CITY280                     285
#define IDS_CITY281                     286
#define IDS_CITY282                     287
#define IDS_CITY283                     288
#define IDS_CITY284                     289
#define IDS_CITY285                     290
#define IDS_CITY286                     291
#define IDS_CITY287                     292
#define IDS_CITY288                     293
#define IDS_CITY289                     294
#define IDS_CITY290                     295
#define IDS_CITY291                     296
#define IDS_CITY292                     297
#define IDS_CITY293                     298
#define IDS_CITY294                     299
#define IDS_CITY295                     300
#define IDS_CITY296                     301
#define IDS_CITY297                     302
#define IDS_CITY298                     303
#define IDS_CITY299                     304
#define IDS_CITY300                     305
#define IDS_CITY301                     306
#define IDS_CITY302                     307
#define IDS_CITY303                     308
#define IDS_CITY304                     309
#define IDS_CITY305                     310
#define IDS_CITY306                     311
#define IDS_CITY307                     312
#define IDS_CITY308                     313
#define IDS_CITY309                     314
#define IDS_CITY310                     315
#define IDS_CITY311                     316
#define IDS_CITY312                     317
#define IDS_CITY313                     318
#define IDS_CITY314                     319
#define IDS_CITY315                     320
#define IDS_CITY316                     321
#define IDS_CITY317                     322
#define IDS_CITY318                     323
#define IDS_CITY319                     324
#define IDS_CITY320                     325
#define IDS_CITY321                     326
#define IDS_CITY322                     327
#define IDS_CITY323                     328
#define IDS_CITY324                     329
#define IDS_CITY325                     330
#define IDS_CITY326                     331
#define IDS_CITY327                     332
#define IDS_CITY328                     333
#define IDS_CITY329                     334
#define IDS_CITY330                     335
#define IDS_CITY331                     336
#define IDS_CITY332                     337
#define IDS_CITY333                     338
#define IDS_CITY334                     339
#define IDS_CITY335                     340
#define IDS_CITY336                     341
#define IDS_CITY337                     342
#define IDS_CITY338                     343
#define IDS_CITY339                     344
#define IDS_CITY340                     345
#define IDS_CITY341                     346
#define IDS_CITY342                     347
#define IDS_CITY343                     348
#define IDS_CITY344                     349
#define IDS_CITY345                     350
#define IDS_CITY346                     351
#define IDS_CITY347                     352
#define IDS_CITY348                     353
#define IDS_CITY349                     354
#define IDS_CITY350                     355
#define IDS_CITY351                     356
#define IDS_CITY352                     357
#define IDS_CITY353                     358
#define IDS_CITY354                     359
#define IDS_CITY355                     360
#define IDS_CITY356                     361
#define IDS_CITY357                     362
#define IDS_CITY358                     363
#define IDS_CITY359                     364
#define IDS_CITY360                     365
#define IDS_CITY361                     366
#define IDS_CITY362                     367
#define IDS_CITY363                     368
#define IDS_CITY364                     369
#define IDS_CITY365                     370
#define IDS_CITY366                     371
#define IDS_CITY367                     372
#define IDS_CITY368                     373
#define IDS_CITY369                     374
#define IDS_CITY370                     375
#define IDS_CITY371                     376
#define IDS_CITY372                     377
#define IDS_CITY373                     378
#define IDS_CITY374                     379
#define IDS_CITY375                     380
#define IDS_CITY376                     381
#define IDS_CITY377                     382
#define IDS_CITY378                     383
#define IDS_CITY379                     384
#define IDS_CITY380                     385
#define IDS_CITY381                     386
#define IDS_CITY382                     387
#define IDS_CITY383                     388
#define IDS_CITY384                     389
#define IDS_CITY385                     390
#define IDS_CITY386                     391
#define IDS_CITY387                     392
#define IDS_CITY388                     393
#define IDS_CITY389                     394
#define IDS_CITY390                     395
#define IDS_CITY391                     396
#define IDS_CITY392                     397
#define IDS_CITY393                     398
#define IDS_CITY394                     399
#define IDS_CITY395                     400
#define IDS_CITY396                     401
#define IDS_CITY397                     402
#define IDS_CITY398                     403
#define IDS_CITY399                     404
#define IDS_CITY400                     405
#define IDS_CITY401                     406
#define IDS_CITY402                     407
#define IDS_CITY403                     408
#define IDS_CITY404                     409
#define IDS_CITY405                     410
#define IDS_CITY406                     411
#define IDS_CITY407                     412
#define IDS_CITY408                     413
#define IDS_CITY409                     414
#define IDS_CITY410                     415
#define IDS_CITY411                     416
#define IDS_CITY412                     417
#define IDS_CITY413                     418
#define IDS_CITY414                     419
#define IDS_CITY415                     420
#define IDS_CITY416                     421
#define IDS_CITY417                     422
#define IDS_CITY418                     423
#define IDS_CITY419                     424
#define IDS_CITY420                     425
#define IDS_CITY421                     426
#define IDS_CITY422                     427
#define IDS_CITY423                     428
#define IDS_CITY424                     429
#define IDS_CITY425                     430
#define IDS_CITY426                     431
#define IDS_CITY427                     432
#define IDS_CITY428                     433
#define IDS_CITY429                     434
#define IDS_CITY430                     435
#define IDS_CITY431                     436
#define IDS_CITY432                     437
#define IDS_CITY433                     438
#define IDS_CITY434                     439
#define IDS_CITY435                     440
#define IDS_CITY436                     441
#define IDS_CITY437                     442
#define IDS_CITY438                     443
#define IDS_CITY439                     444
#define IDS_CITY440                     445
#define IDS_CITY441                     446
#define IDS_CITY442                     447
#define IDS_CITY443                     448
#define IDS_CITY444                     449
#define IDS_CITY445                     450
#define IDS_CITY446                     451
#define IDS_CITY447                     452
#define IDS_CITY448                     453
#define IDS_CITY449                     454
#define IDS_CITY450                     455
#define IDS_CITY451                     456
#define IDS_CITY452                     457
#define IDS_CITY453                     458
#define IDS_CITY454                     459
#define IDS_CITY455                     460
#define IDS_CITY456                     461
#define IDS_CITY457                     462
#define IDS_CITY458                     463
#define IDS_CITY459                     464
#define IDS_CITY460                     465
#define IDS_CITY461                     466
#define IDS_CITY462                     467
#define IDS_CITY463                     468
#define IDS_CITY464                     469
#define IDS_CITY465                     470
#define IDS_CITY466                     471
#define IDS_CITY467                     472
#define IDS_CITY468                     473
#define IDS_CITY469                     474
#define IDS_CITY470                     475
#define IDS_CITY471                     476
#define IDS_CITY472                     477
#define IDS_CITY473                     478
#define IDS_CITY474                     479
#define IDS_CITY475                     480
#define IDS_CITY476                     481
#define IDS_CITY477                     482
#define IDS_CITY478                     483
#define IDS_CITY479                     484
#define IDS_CITY480                     485
#define IDS_CITY481                     486
#define IDS_CITY482                     487
#define IDS_CITY483                     488
#define IDS_CITY484                     489
#define IDS_CITY485                     490
#define IDS_CITY486                     491
#define IDS_CITY487                     492
#define IDS_CITY488                     493
#define IDS_CITY489                     494
#define IDS_CITY490                     495
#define IDS_CITY491                     496
#define IDS_CITY492                     497
#define IDS_CITY493                     498
#define IDS_CITY494                     499
#define IDS_CITY495                     500
#define IDS_CITY496                     501
#define IDS_CITY497                     502
#define IDS_CITY498                     503
#define IDS_CITY499                     504
#define IDS_CITY500                     505
#define IDS_CITY501                     506
#define IDS_CITY502                     507
#define IDS_CITY503                     508
#define IDS_CITY504                     509
#define IDS_CITY505                     510
#define IDS_CITY506                     511
#define IDS_CITY507                     512
#define IDS_CITY508                     513
#define IDS_CITY509                     514
#define IDS_CITY510                     515
#define IDS_CITY511                     516
#define IDS_CITY512                     517
#define IDS_CITY513                     518
#define IDS_CITY514                     519
#define IDS_CITY515                     520
#define IDS_CITY516                     521
#define IDS_CITY517                     522
#define IDS_CITY518                     523
#define IDS_CITY519                     524
#define IDS_CITY520                     525
#define IDS_CITY521                     526
#define IDS_CITY522                     527
#define IDS_CITY523                     528
#define IDS_CITY524                     529
#define IDS_CITY525                     530
#define IDS_CITY526                     531
#define IDS_CITY527                     532
#define IDS_CITY528                     533
#define IDS_CITY529                     534
#define IDS_CITY530                     535
#define IDS_CITY531                     536
#define IDS_CITY532                     537
#define IDS_CITY533                     538
#define IDS_CITY534                     539
#define IDS_CITY535                     540
#define IDS_CITY536                     541
#define IDS_CITY537                     542
#define IDS_CITY538                     543
#define IDS_CITY539                     544
#define IDS_CITY540                     545
#define IDS_CITY541                     546
#define IDS_CITY542                     547
#define IDS_CITY543                     548
#define IDS_CITY544                     549
#define IDS_CITY545                     550
#define IDS_CITY546                     551
#define IDS_CITY547                     552
#define IDS_CITY548                     553
#define IDS_CITY549                     554
#define IDS_CITY550                     555
#define IDS_CITY551                     556
#define IDS_CITY552                     557
#define IDS_CITY553                     558
#define IDS_CITY554                     559
#define IDS_CITY555                     560
#define IDS_CITY556                     561
#define IDS_CITY557                     562
#define IDS_CITY558                     563
#define IDS_CITY559                     564
#define IDS_CITY560                     565
#define IDS_CITY561                     566
#define IDS_CITY562                     567
#define IDS_CITY563                     568
#define IDS_CITY564                     569
#define IDS_CITY565                     570
#define IDS_CITY566                     571
#define IDS_CITY567                     572
#define IDS_CITY568                     573
#define IDS_CITY569                     574
#define IDS_CITY570                     575
#define IDS_CITY571                     576
#define IDS_CITY572                     577
#define IDS_CITY573                     578
#define IDS_CITY574                     579
#define IDS_CITY575                     580
#define IDS_CITY576                     581
#define IDS_CITY577                     582
#define IDS_CITY578                     583
#define IDS_CITY579                     584
#define IDS_CITY580                     585
#define IDS_CITY581                     586
#define IDS_CITY582                     587
#define IDS_CITY583                     588
#define IDS_CITY584                     589
#define IDS_CITY585                     590
#define IDS_CITY586                     591
#define IDS_CITY587                     592
#define IDS_CITY588                     593
#define IDS_CITY589                     594
#define IDS_CITY590                     595
#define IDS_CITY591                     596
#define IDS_CITY592                     597
#define IDS_CITY593                     598
#define IDS_CITY594                     599
#define IDS_CITY595                     600
#define IDS_CITY596                     601
#define IDS_CITY597                     602
#define IDS_CITY598                     603
#define IDS_CITY599                     604
#define IDS_CITY600                     605
#define IDS_CITY601                     606
#define IDS_CITY602                     607
#define IDS_CITY603                     608
#define IDS_CITY604                     609
#define IDS_CITY605                     610
#define IDS_CITY606                     611
#define IDS_CITY607                     612
#define IDS_CITY608                     613
#define IDS_CITY609                     614
#define IDS_CITY610                     615
#define IDS_CITY611                     616
#define IDS_CITY612                     617
#define IDS_CITY613                     618
#define IDS_CITY614                     619
#define IDS_CITY615                     620
#define IDS_CITY616                     621
#define IDS_CITY617                     622
#define IDS_CITY618                     623
#define IDS_CITY619                     624
#define IDS_CITY620                     625
#define IDS_CITY621                     626
#define IDS_CITY622                     627
#define IDS_CITY623                     628
#define IDS_CITY624                     629
#define IDS_CITY625                     630
#define IDS_CITY626                     631
#define IDS_CITY627                     632
#define IDS_CITY628                     633
#define IDS_CITY629                     634
#define IDS_CITY630                     635
#define IDS_CITY631                     636
#define IDS_CITY632                     637
#define IDS_CITY633                     638
#define IDS_CITY634                     639
#define IDS_CITY635                     640
#define IDS_CITY636                     641
#define IDS_CITY637                     642
#define IDS_CITY638                     643
#define IDS_CITY639                     644
#define IDS_CITY640                     645
#define IDS_CITY641                     646
#define IDS_CITY642                     647
#define IDS_CITY643                     648
#define IDS_CITY644                     649
#define IDS_CITY645                     650
#define IDS_CITY646                     651
#define IDS_CITY647                     652
#define IDS_CITY648                     653
#define IDS_CITY649                     654
#define IDS_CITY650                     655
#define IDS_CITY651                     656
#define IDS_CITY652                     657
#define IDS_CITY653                     658
#define IDS_CITY654                     659
#define IDS_CITY655                     660
#define IDS_CITY656                     661
#define IDS_CITY657                     662
#define IDS_CITY658                     663
#define IDS_CITY659                     664
#define IDS_CITY660                     665
#define IDS_CITY661                     666
#define IDS_CITY662                     667
#define IDS_CITY663                     668
#define IDS_CITY664                     669
#define IDS_CITY665                     670
#define IDS_CITY666                     671
#define IDS_CITY667                     672
#define IDS_CITY668                     673
#define IDS_CITY669                     674
#define IDS_CITY670                     675
#define IDS_CITY671                     676
#define IDS_CITY672                     677
#define IDS_CITY673                     678
#define IDS_CITY674                     679
#define IDS_CITY675                     680
#define IDS_CITY676                     681
#define IDS_CITY677                     682
#define IDS_CITY678                     683
#define IDS_CITY679                     684
#define IDS_CITY680                     685
#define IDS_CITY681                     686
#define IDS_CITY682                     687
#define IDS_CITY683                     688
#define IDS_CITY684                     689
#define IDS_CITY685                     690
#define IDS_CITY686                     691
#define IDS_CITY687                     692
#define IDS_CITY688                     693
#define IDS_CITY689                     694
#define IDS_CITY690                     695
#define IDS_CITY691                     696
#define IDS_CITY692                     697
#define IDS_CITY693                     698
#define IDS_CITY694                     699
#define IDS_CITY695                     700
#define IDS_CITY696                     701
#define IDS_CITY697                     702
#define IDS_CITY698                     703
#define IDS_CITY699                     704
#define IDS_CITY700                     705
#define IDS_CITY701                     706
#define IDS_CITY702                     707
#define IDS_CITY703                     708
#define IDS_CITY704                     709
#define IDS_CITY705                     710
#define IDS_CITY706                     711
#define IDS_CITY707                     712
#define IDS_CITY708                     713
#define IDS_CITY709                     714
#define IDS_CITY710                     715
#define IDS_CITY711                     716
#define IDS_CITY712                     717
#define IDS_CITY713                     718
#define IDS_CITY714                     719
#define IDS_CITY715                     720
#define IDS_CITY716                     721
#define IDS_CITY717                     722
#define IDS_CITY718                     723
#define IDS_CITY719                     724
#define IDS_CITY720                     725
#define IDS_CITY721                     726
#define IDS_CITY722                     727
#define IDS_CITY723                     728
#define IDS_CITY724                     729
#define IDS_CITY725                     730
#define IDS_CITY726                     731
#define IDS_CITY727                     732
#define IDS_CITY728                     733
#define IDS_CITY729                     734
#define IDS_CITY730                     735
#define IDS_CITY731                     736
#define IDS_CITY732                     737
#define IDS_CITY733                     738
#define IDS_CITY734                     739
#define IDS_CITY735                     740
#define IDS_CITY736                     741
#define IDS_CITY737                     742
#define IDS_CITY738                     743
#define IDS_CITY739                     744
#define IDS_CITY740                     745
#define IDS_CITY741                     746
#define IDS_CITY742                     747
#define IDS_CITY743                     748
#define IDS_CITY744                     749
#define IDS_CITY745                     750
#define IDS_CITY746                     751
#define IDS_CITY747                     752
#define IDS_CITY748                     753
#define IDS_CITY749                     754
#define IDS_CITY750                     755
#define IDS_CITY751                     756
#define IDS_CITY752                     757
#define IDS_CITY753                     758
#define IDS_CITY754                     759
#define IDS_CITY755                     760
#define IDS_CITY756                     761
#define IDS_CITY757                     762
#define IDS_CITY758                     763
#define IDS_CITY759                     764
#define IDS_CITY760                     765
#define IDS_CITY761                     766
#define IDS_CITY762                     767
#define IDS_CITY763                     768
#define IDS_CITY764                     769
#define IDS_CITY765                     770
#define IDS_CITY766                     771
#define IDS_CITY767                     772
#define IDS_CITY768                     773
#define IDS_CITY769                     774
#define IDS_CITY770                     775
#define IDS_CITY771                     776
#define IDS_CITY772                     777
#define IDS_CITY773                     778
#define IDS_CITY774                     779
#define IDS_CITY775                     780
#define IDS_CITY776                     781
#define IDS_CITY777                     782
#define IDS_CITY778                     783
#define IDS_CITY779                     784
#define IDS_CITY780                     785
#define IDS_CITY781                     786
#define IDS_CITY782                     787
#define IDS_CITY783                     788
#define IDS_CITY784                     789
#define IDS_CITY785                     790
#define IDS_CITY786                     791
#define IDS_CITY787                     792
#define IDS_CITY788                     793
#define IDS_CITY789                     794
#define IDS_CITY790                     795
#define IDS_CITY791                     796
#define IDS_CITY792                     797
#define IDS_CITY793                     798
#define IDS_CITY794                     799
#define IDS_CITY795                     800
#define IDS_CITY796                     801
#define IDS_CITY797                     802
#define IDS_CITY798                     803
#define IDS_CITY799                     804
#define IDS_CITY800                     805
#define IDS_CITY801                     806
#define IDS_CITY802                     807
#define IDS_CITY803                     808
#define IDS_CITY804                     809
#define IDS_CITY805                     810
#define IDS_CITY806                     811
#define IDS_CITY807                     812
#define IDS_CITY808                     813
#define IDS_CITY809                     814
#define IDS_CITY810                     815
#define IDS_CITY811                     816
#define IDS_CITY812                     817
#define IDS_CITY813                     818
#define IDS_CITY814                     819
#define IDS_CITY815                     820
#define IDS_CITY816                     821
#define IDS_CITY817                     822
#define IDS_CITY818                     823
#define IDS_CITY819                     824
#define IDS_CITY820                     825
#define IDS_CITY821                     826
#define IDS_CITY822                     827
#define IDS_CITY823                     828
#define IDS_CITY824                     829
#define IDS_CITY825                     830
#define IDS_CITY826                     831
#define IDS_CITY827                     832
#define IDS_CITY828                     833
#define IDS_CITY829                     834
#define IDS_CITY830                     835
#define IDS_CITY831                     836
#define IDS_CITY832                     837
#define IDS_CITY833                     838
#define IDS_CITY834                     839
#define IDS_CITY835                     840
#define IDS_CITY836                     841
#define IDS_CITY837                     842
#define IDS_CITY838                     843
#define IDS_CITY839                     844
#define IDS_CITY840                     845
#define IDS_CITY841                     846
#define IDS_CITY842                     847
#define IDS_CITY843                     848
#define IDS_CITY844                     849
#define IDS_CITY845                     850
#define IDS_CITY846                     851
#define IDS_CITY847                     852
#define IDS_CITY848                     853
#define IDS_CITY849                     854
#define IDS_CITY850                     855
#define IDS_CITY851                     856
#define IDS_CITY852                     857
#define IDS_CITY853                     858
#define IDS_CITY854                     859
#define IDS_CITY855                     860
#define IDS_CITY856                     861
#define IDS_CITY857                     862
#define IDS_CITY858                     863
#define IDS_CITY859                     864
#define IDS_CITY860                     865
#define IDS_CITY861                     866
#define IDS_CITY862                     867
#define IDS_CITY863                     868
#define IDS_CITY864                     869
#define IDS_CITY865                     870
#define IDS_CITY866                     871
#define IDS_CITY867                     872
#define IDS_CITY868                     873
#define IDS_CITY869                     874
#define IDS_CITY870                     875
#define IDS_CITY871                     876
#define IDS_CITY872                     877
#define IDS_CITY873                     878
#define IDS_CITY874                     879
#define IDS_CITY875                     880
#define IDS_CITY876                     881
#define IDS_CITY877                     882
#define IDS_CITY878                     883
#define IDS_CITY879                     884
#define IDS_CITY880                     885
#define IDS_CITY881                     886
#define IDS_CITY882                     887
#define IDS_CITY883                     888
#define IDS_CITY884                     889
#define IDS_CITY885                     890
#define IDS_CITY886                     891
#define IDS_CITY887                     892
#define IDS_CITY888                     893
#define IDS_CITY889                     894
#define IDS_CITY890                     895
#define IDS_CITY891                     896
#define IDS_CITY892                     897
#define IDS_CITY893                     898
#define IDS_CITY894                     899
#define IDS_CITY895                     900
#define IDS_CITY896                     901
#define IDS_CITY897                     902
#define IDS_CITY898                     903
#define IDS_CITY899                     904
#define IDS_CITY900                     905
#define IDS_CITY901                     906
#define IDS_CITY902                     907
#define IDS_CITY903                     908
#define IDS_CITY904                     909
#define IDS_CITY905                     910
#define IDS_CITY906                     911
#define IDS_CITY907                     912
#define IDS_CITY908                     913
#define IDS_CITY909                     914
#define IDS_CITY910                     915
#define IDS_CITY911                     916
#define IDS_CITY912                     917
#define IDS_CITY913                     918
#define IDS_CITY914                     919
#define IDS_CITY915                     920
#define IDS_CITY916                     921
#define IDS_CITY917                     922
#define IDS_CITY918                     923
#define IDS_CITY919                     924
#define IDS_CITY920                     925
#define IDS_CITY921                     926
#define IDS_CITY922                     927
#define IDS_CITY923                     928
#define IDS_CITY924                     929
#define IDS_CITY925                     930
#define IDS_CITY926                     931
#define IDS_CITY927                     932
#define IDS_CITY928                     933
#define IDS_CITY929                     934
#define IDS_CITY930                     935
#define IDS_CITY931                     936
#define IDS_CITY932                     937
#define IDS_CITY933                     938
#define IDS_CITY934                     939
#define IDS_CITY935                     940
#define IDS_CITY936                     941
#define IDS_CITY937                     942
#define IDS_CITY938                     943
#define IDS_CITY939                     944
#define IDS_CITY940                     945
#define IDS_CITY941                     946
#define IDS_CITY942                     947
#define IDS_CITY943                     948
#define IDS_CITY944                     949
#define IDS_CITY945                     950
#define IDS_CITY946                     951
#define IDS_CITY947                     952
#define IDS_CITY948                     953
#define IDS_CITY949                     954
#define IDS_CITY950                     955
#define IDS_CITY951                     956
#define IDS_CITY952                     957
#define IDS_CITY953                     958
#define IDS_CITY954                     959
#define IDS_CITY955                     960
#define IDS_CITY956                     961
#define IDS_CITY957                     962
#define IDS_CITY958                     963
#define IDS_CITY959                     964
#define IDS_CITY960                     965
#define IDS_CITY961                     966
#define IDS_CITY962                     967
#define IDS_CITY963                     968
#define IDS_CITY964                     969
#define IDS_CITY965                     970
#define IDS_CITY966                     971
#define IDS_CITY967                     972
#define IDS_CITY968                     973
#define IDS_CITY969                     974
#define IDS_CITY970                     975
#define IDS_CITY971                     976
#define IDS_CITY972                     977
#define IDS_CITY973                     978
#define IDS_CITY974                     979
#define IDS_CITY975                     980
#define IDS_CITY976                     981
#define IDS_CITY977                     982
#define IDS_CITY978                     983
#define IDS_CITY979                     984
#define IDS_CITY980                     985
#define IDS_CITY981                     986
#define IDS_CITY982                     987
#define IDS_CITY983                     988
#define IDS_CITY984                     989
#define IDS_CITY985                     990
#define IDS_CITY986                     991
#define IDS_CITY987                     992
#define IDS_CITY988                     993
#define IDS_CITY989                     994
#define IDS_CITY990                     995
#define IDS_CITY991                     996
#define IDS_CITY992                     997
#define IDS_CITY993                     998
#define IDS_CITY994                     999
#define IDC_RADIUS                      1000
#define IDS_CITY995                     1000
#define IDC_AMPLITUDE                   1001
#define IDC_LAT                         1001
#define IDS_CITY996                     1001
#define IDC_CYCLES                      1002
#define IDC_LONG                        1002
#define IDS_CITY997                     1002
#define IDC_PHASE                       1003
#define IDC_YEAR                        1003
#define IDS_CITY998                     1003
#define IDC_NUMNODES                    1004
#define IDC_MONTH                       1004
#define IDS_CITY999                     1004
#define IDC_RADSPINNER                  1005
#define IDS_CITY1000                    1005
#define IDC_AMPSPINNER                  1006
#define IDC_LATSPINNER                  1006
#define IDS_CITY1001                    1006
#define IDC_CYCSPINNER                  1007
#define IDC_LONGSPINNER                 1007
#define IDS_CITY1002                    1007
#define IDC_PHSSPINNER                  1008
#define IDC_YEARSPINNER                 1008
#define IDS_CITY1003                    1008
#define IDC_NUMSPINNER                  1009
#define IDC_MONTHSPINNER                1009
#define IDS_CITY1004                    1009
#define IDC_DAYSPINNER                  1010
#define IDC_AXISLENGTH                  1010
#define IDS_CITY1005                    1010
#define IDC_DAY                         1011
#define IDS_CITY1006                    1011
#define IDC_MINSPINNER                  1012
#define IDS_CITY1007                    1012
#define IDC_MIN                         1013
#define IDS_CITY1008                    1013
#define IDC_HOURSPINNER                 1014
#define IDS_CITY1009                    1014
#define IDC_HOUR                        1015
#define IDS_CITY1010                    1015
#define IDC_NORTHSPINNER                1016
#define IDS_CITY1011                    1016
#define IDC_NORTH                       1017
#define IDS_CITY1012                    1017
#define IDC_AZ                          1018
#define IDS_CITY1013                    1018
#define IDC_ALT                         1019
#define IDS_CITY1014                    1019
#define IDC_ZONESPINNER                 1020
#define IDS_CITY1015                    1020
#define IDC_ZONE                        1021
#define IDS_CITY1016                    1021
#define IDC_SECSPINNER                  1022
#define IDS_CITY1017                    1022
#define IDC_SEC                         1023
#define IDS_CITY1018                    1023
#define IDS_CITY1019                    1024
#define IDC_CITY                        1024
#define IDS_CITY1020                    1025
#define IDS_CITY1021                    1026
#define IDS_CITY1022                    1027
#define IDS_CITY1023                    1028
#define IDS_CITY1024                    1029
#define IDS_CITY1025                    1030
#define IDS_CITY1026                    1031
#define IDS_CITY1027                    1032
#define IDS_CITY1028                    1033
#define IDS_CITY1029                    1034
#define IDS_CITY1030                    1035
#define IDS_CITY1031                    1036
#define IDS_CITY1032                    1037
#define IDS_CITY1033                    1038
#define IDS_CITY1034                    1039
#define IDS_CITY1035                    1040
#define IDS_CITY1036                    1041
#define IDS_CITY1037                    1042
#define IDS_CITY1038                    1043
#define IDC_AXISLENGHSPIN               1044
#define IDS_CITY1039                    1044
#define IDS_CITY1040                    1045
#define IDC_SHOWAXIS                    1046
#define IDS_CITY1041                    1046
#define IDS_CITY1042                    1047
#define IDS_CITY1043                    1048
#define IDS_CITY1044                    1049
#define IDS_CITY1045                    1050
#define IDS_CITY1046                    1051
#define IDS_CITY1047                    1052
#define IDS_CITY1048                    1053
#define IDS_CITY1049                    1054
#define IDS_CITY1050                    1055
#define IDS_CITY1051                    1056
#define IDS_CITY1052                    1057
#define IDS_CITY1053                    1058
#define IDS_CITY1054                    1059
#define IDS_CITY1055                    1060
#define IDS_CITY1056                    1061
#define IDS_CITY1057                    1062
#define IDS_CITY1058                    1063
#define IDS_CITY1059                    1064
#define IDS_CITY1060                    1065
#define IDS_CITY1061                    1066
#define IDS_CITY1062                    1067
#define IDS_CITY1063                    1068
#define IDS_CITY1064                    1069
#define IDS_CITY1065                    1070
#define IDS_CITY1066                    1071
#define IDS_CITY1067                    1072
#define IDS_CITY1068                    1073
#define IDS_CITY1069                    1074
#define IDS_CITY1070                    1075
#define IDS_CITY1071                    1076
#define IDS_CITY1072                    1077
#define IDS_CITY1073                    1078
#define IDS_CITY1074                    1079
#define IDS_CITY1075                    1080
#define IDS_CITY1076                    1081
#define IDS_CITY1077                    1082
#define IDS_CITY1078                    1083
#define IDS_CITY1079                    1084
#define IDS_CITY1080                    1085
#define IDS_CITY1081                    1086
#define IDS_CITY1082                    1087
#define IDS_CITY1083                    1088
#define IDS_CITY1084                    1089
#define IDS_CITY1085                    1090
#define IDS_CITY1086                    1091
#define IDS_CITY1087                    1092
#define IDS_CITY1088                    1093
#define IDS_CITY1089                    1094
#define IDS_CITY1090                    1095
#define IDS_CITY1091                    1096
#define IDS_CITY1092                    1097
#define IDS_CITY1093                    1098
#define IDS_CITY1094                    1099
#define IDS_CITY1095                    1100
#define IDS_CITY1096                    1101
#define IDS_CITY1097                    1102
#define IDS_CITY1098                    1103
#define IDS_CITY1099                    1104
#define IDS_CITY1100                    1105
#define IDS_CITY1101                    1106
#define IDS_CITY1102                    1107
#define IDS_CITY1103                    1108
#define IDS_CITY1104                    1109
#define IDS_CITY1105                    1110
#define IDS_CITY1106                    1111
#define IDS_CITY1107                    1112
#define IDS_CITY1108                    1113
#define IDS_CITY1109                    1114
#define IDS_CITY1110                    1115
#define IDS_CITY1111                    1116
#define IDS_CITY1112                    1117
#define IDS_CITY1113                    1118
#define IDS_CITY1114                    1119
#define IDS_CITY1115                    1120
#define IDS_CITY1116                    1121
#define IDS_CITY1117                    1122
#define IDS_CITY1118                    1123
#define IDS_CITY1119                    1124
#define IDS_CITY1120                    1125
#define IDS_CITY1121                    1126
#define IDS_CITY1122                    1127
#define IDS_CITY1123                    1128
#define IDS_CITY1124                    1129
#define IDS_CITY1125                    1130
#define IDS_CITY1126                    1131
#define IDS_CITY1127                    1132
#define IDS_CITY1128                    1133
#define IDS_CITY1129                    1134
#define IDS_CITY1130                    1135
#define IDS_CITY1131                    1136
#define IDS_CITY1132                    1137
#define IDS_CITY1133                    1138
#define IDS_CITY1134                    1139
#define IDS_CITY1135                    1140
#define IDS_CITY1136                    1141
#define IDS_CITY1137                    1142
#define IDS_CITY1138                    1143
#define IDS_CITY1139                    1144
#define IDS_CITY1140                    1145
#define IDS_CITY1141                    1146
#define IDS_CITY1142                    1147
#define IDS_CITY1143                    1148
#define IDS_CITY1144                    1149
#define IDS_CITY1145                    1150
#define IDS_CITY1146                    1151
#define IDS_CITY1147                    1152
#define IDS_CITY1148                    1153
#define IDS_CITY1149                    1154
#define IDS_CITY1150                    1155
#define IDS_CITY1151                    1156
#define IDS_CITY1152                    1157
#define IDS_CITY1153                    1158
#define IDS_CITY1154                    1159
#define IDS_CITY1155                    1160
#define IDS_CITY1156                    1161
#define IDS_CITY1157                    1162
#define IDS_CITY1158                    1163
#define IDS_CITY1159                    1164
#define IDS_CITY1160                    1165
#define IDS_CITY1161                    1166
#define IDS_CITY1162                    1167
#define IDS_CITY1163                    1168
#define IDS_CITY1164                    1169
#define IDS_CITY1165                    1170
#define IDS_CITY1166                    1171
#define IDS_CITY1167                    1172
#define IDS_CITY1168                    1173
#define IDS_CITY1169                    1174
#define IDS_CITY1170                    1175
#define IDS_CITY1171                    1176
#define IDS_CITY1172                    1177
#define IDS_CITY1173                    1178
#define IDS_CITY1174                    1179
#define IDS_CITY1175                    1180
#define IDS_CITY1176                    1181
#define IDS_CITY1177                    1182
#define IDS_CITY1178                    1183
#define IDS_CITY1179                    1184
#define IDS_CITY1180                    1185
#define IDS_CITY1181                    1186
#define IDS_CITY1182                    1187
#define IDS_CITY1183                    1188
#define IDS_CITY1184                    1189
#define IDS_CITY1185                    1190
#define IDS_CITY1186                    1191
#define IDS_CITY1187                    1192
#define IDS_CITY1188                    1193
#define IDS_CITY1189                    1194
#define IDS_CITY1190                    1195
#define IDS_CITY1191                    1196
#define IDS_CITY1192                    1197
#define IDS_CITY1193                    1198
#define IDS_CITY1194                    1199
#define IDS_CITY1195                    1200
#define IDS_CITY1196                    1201
#define IDS_CITY1197                    1202
#define IDS_CITY1198                    1203
#define IDS_CITY1199                    1204
#define IDS_CITY1200                    1205
#define IDS_CITY1201                    1206
#define IDS_CITY1202                    1207
#define IDS_CITY1203                    1208
#define IDS_CITY1204                    1209
#define IDS_CITY1205                    1210
#define IDS_CITY1206                    1211
#define IDS_CITY1207                    1212
#define IDS_CITY1208                    1213
#define IDS_CITY1209                    1214
#define IDS_CITY1210                    1215
#define IDS_CITY1211                    1216
#define IDS_CITY1212                    1217
#define IDS_CITY1213                    1218
#define IDS_CITY1214                    1219
#define IDS_CITY1215                    1220
#define IDS_CITY1216                    1221
#define IDS_CITY1217                    1222
#define IDS_CITY1218                    1223
#define IDS_CITY1219                    1224
#define IDS_CITY1220                    1225
#define IDS_CITY1221                    1226
#define IDS_CITY1222                    1227
#define IDS_CITY1223                    1228
#define IDS_CITY1224                    1229
#define IDS_CITY1225                    1230
#define IDS_CITY1226                    1231
#define IDS_CITY1227                    1232
#define IDS_CITY1228                    1233
#define IDS_CITY1229                    1234
#define IDS_CITY1230                    1235
#define IDS_CITY1231                    1236
#define IDS_CITY1232                    1237
#define IDS_CITY1233                    1238
#define IDS_CITY1234                    1239
#define IDS_CITY1235                    1240
#define IDS_CITY1236                    1241
#define IDS_CITY1237                    1242
#define IDS_CITY1238                    1243
#define IDS_CITY1239                    1244
#define IDS_CITY1240                    1245
#define IDS_CITY1241                    1246
#define IDS_CITY1242                    1247
#define IDS_CITY1243                    1248
#define IDS_CITY1244                    1249
#define IDS_CITY1245                    1250
#define IDS_CITY1246                    1251
#define IDS_CITY1247                    1252
#define IDS_CITY1248                    1253
#define IDS_CITY1249                    1254
#define IDS_CITY1250                    1255
#define IDS_CITY1251                    1256
#define IDS_CITY1252                    1257
#define IDS_CITY1253                    1258
#define IDS_CITY1254                    1259
#define IDC_CITYLIST                    1260
#define IDS_CITY1255                    1260
#define IDS_CITY1256                    1261
#define IDC_MAP_NAME                    1262
#define IDS_CITY1257                    1262
#define IDC_NEAREST                     1263
#define IDS_CITY1258                    1263
#define IDC_MAP_PICTURE                 1264
#define IDS_CITY1259                    1264
#define IDS_CITY1260                    1265
#define IDS_CITY1261                    1266
#define IDS_CITY1262                    1267
#define IDS_CITY1263                    1268
#define IDS_CITY1264                    1269
#define IDS_CITY1265                    1270
#define IDS_CITY1266                    1271
#define IDS_CITY1267                    1272
#define IDS_CITY1268                    1273
#define IDS_CITY1269                    1274
#define IDS_CITY1270                    1275
#define IDS_CITY1271                    1276
#define IDS_CITY1272                    1277
#define IDS_CITY1273                    1278
#define IDS_CITY1274                    1279
#define IDS_CITY1275                    1280
#define IDS_CITY1276                    1281
#define IDS_CITY1277                    1282
#define IDS_CITY1278                    1283
#define IDS_CITY1279                    1284
#define IDS_CITY1280                    1285
#define IDS_CITY1281                    1286
#define IDS_CITY1282                    1287
#define IDS_CITY1283                    1288
#define IDS_CITY1284                    1289
#define IDS_CITY1285                    1290
#define IDS_CITY1286                    1291
#define IDS_CITY1287                    1292
#define IDS_CITY1288                    1293
#define IDS_CITY1289                    1294
#define IDS_CITY1290                    1295
#define IDS_CITY1291                    1296
#define IDS_CITY1292                    1297
#define IDS_CITY1293                    1298
#define IDS_CITY1294                    1299
#define IDS_CITY1295                    1300
#define IDS_CITY1296                    1301
#define IDS_CITY1297                    1302
#define IDS_CITY1298                    1303
#define IDS_CITY1299                    1304
#define IDS_CITY1300                    1305
#define IDS_CITY1301                    1306
#define IDS_CITY1302                    1307
#define IDS_CITY1303                    1308
#define IDS_CITY1304                    1309
#define IDS_CITY1305                    1310
#define IDS_CITY1306                    1311
#define IDS_CITY1307                    1312
#define IDS_CITY1308                    1313
#define IDS_CITY1309                    1314
#define IDS_CITY1310                    1315
#define IDS_CITY1311                    1316
#define IDS_CITY1312                    1317
#define IDS_CITY1313                    1318
#define IDS_CITY1314                    1319
#define IDS_CITY1315                    1320
#define IDS_CITY1316                    1321
#define IDS_CITY1317                    1322
#define IDS_CITY1318                    1323
#define IDS_CITY1319                    1324
#define IDS_CITY1320                    1325
#define IDS_CITY1321                    1326
#define IDS_CITY1322                    1327
#define IDS_CITY1323                    1328
#define IDS_CITY1324                    1329
#define IDS_CITY1325                    1330
#define IDS_CITY1326                    1331
#define IDS_CITY1327                    1332
#define IDS_CITY1328                    1333
#define IDS_CITY1329                    1334
#define IDS_CITY1330                    1335
#define IDS_CITY1331                    1336
#define IDS_CITY1332                    1337
#define IDS_CITY1333                    1338
#define IDS_CITY1334                    1339
#define IDS_CITY1335                    1340
#define IDS_CITY1336                    1341
#define IDS_CITY1337                    1342
#define IDS_CITY1338                    1343
#define IDS_CITY1339                    1344
#define IDS_CITY1340                    1345
#define IDS_CITY1341                    1346
#define IDS_CITY1342                    1347
#define IDS_CITY1343                    1348
#define IDS_CITY1344                    1349
#define IDS_CITY1345                    1350
#define IDS_CITY1346                    1351
#define IDS_CITY1347                    1352
#define IDS_CITY1348                    1353
#define IDS_CITY1349                    1354
#define IDS_CITY1350                    1355
#define IDS_CITY1351                    1356
#define IDS_CITY1352                    1357
#define IDS_CITY1353                    1358
#define IDS_CITY1354                    1359
#define IDS_CITY1355                    1360
#define IDS_CITY1356                    1361
#define IDS_CITY1357                    1362
#define IDS_CITY1358                    1363
#define IDS_CITY1359                    1364
#define IDS_CITY1360                    1365
#define IDS_CITY1361                    1366
#define IDS_CITY1362                    1367
#define IDS_CITY1363                    1368
#define IDS_CITY1364                    1369
#define IDS_CITY1365                    1370
#define IDS_CITY1366                    1371
#define IDS_CITY1367                    1372
#define IDS_CITY1368                    1373
#define IDS_CITY1369                    1374
#define IDS_CITY1370                    1375
#define IDS_CITY1371                    1376
#define IDS_CITY1372                    1377
#define IDS_CITY1373                    1378
#define IDS_CITY1374                    1379
#define IDS_CITY1375                    1380
#define IDS_CITY1376                    1381
#define IDS_CITY1377                    1382
#define IDS_CITY1378                    1383
#define IDS_CITY1379                    1384
#define IDS_CITY1380                    1385
#define IDS_CITY1381                    1386
#define IDS_CITY1382                    1387
#define IDS_CITY1383                    1388
#define IDS_CITY1384                    1389
#define IDS_CITY1385                    1390
#define IDS_CITY1386                    1391
#define IDS_CITY1387                    1392
#define IDS_CITY1388                    1393
#define IDS_CITY1389                    1394
#define IDS_CITY1390                    1395
#define IDS_CITY1391                    1396
#define IDS_CITY1392                    1397
#define IDS_CITY1393                    1398
#define IDS_CITY1394                    1399
#define IDS_CITY1395                    1400
#define IDS_CITY1396                    1401
#define IDS_CITY1397                    1402
#define IDS_CITY1398                    1403
#define IDS_CITY1399                    1404
#define IDS_CITY1400                    1405
#define IDS_CITY1401                    1406
#define IDS_CITY1402                    1407
#define IDS_CITY1403                    1408
#define IDS_CITY1404                    1409
#define IDS_CITY1405                    1410
#define IDS_CITY1406                    1411
#define IDS_CITY1407                    1412
#define IDS_CITY1408                    1413
#define IDS_CITY1409                    1414
#define IDS_CITY1410                    1415
#define IDS_CITY1411                    1416
#define IDS_CITY1412                    1417
#define IDS_CITY1413                    1418
#define IDS_CITY1414                    1419
#define IDS_CITY1415                    1420
#define IDS_CITY1416                    1421
#define IDS_CITY1417                    1422
#define IDS_CITY1418                    1423
#define IDS_CITY1419                    1424
#define IDS_CITY1420                    1425
#define IDS_CITY1421                    1426
#define IDS_CITY1422                    1427
#define IDS_CITY1423                    1428
#define IDS_CITY1424                    1429
#define IDS_CITY1425                    1430
#define IDS_CITY1426                    1431
#define IDS_CITY1427                    1432
#define IDS_CITY1428                    1433
#define IDS_CITY1429                    1434
#define IDS_CITY1430                    1435
#define IDS_CITY1431                    1436
#define IDS_CITY1432                    1437
#define IDS_CITY1433                    1438
#define IDS_CITY1434                    1439
#define IDS_CITY1435                    1440
#define IDS_CITY1436                    1441
#define IDS_CITY1437                    1442
#define IDS_CITY1438                    1443
#define IDS_CITY1439                    1444
#define IDS_CITY1440                    1445
#define IDS_CITY1441                    1446
#define IDS_CITY1442                    1447
#define IDS_CITY1443                    1448
#define IDS_CITY1444                    1449
#define IDS_CITY1445                    1450
#define IDS_CITY1446                    1451
#define IDS_CITY1447                    1452
#define IDS_CITY1448                    1453
#define IDS_CITY1449                    1454
#define IDS_CITY1450                    1455
#define IDS_CITY1451                    1456
#define IDS_CITY1452                    1457
#define IDS_CITY1453                    1458
#define IDS_CITY1454                    1459
#define IDS_CITY1455                    1460
#define IDS_CITY1456                    1461
#define IDS_CITY1457                    1462
#define IDS_CITY1458                    1463
#define IDS_CITY1459                    1464
#define IDS_CITY1460                    1465
#define IDS_CITY1461                    1466
#define IDS_CITY1462                    1467
#define IDS_CITY1463                    1468
#define IDS_CITY1464                    1469
#define IDS_CITY1465                    1470
#define IDS_CITY1466                    1471
#define IDS_CITY1467                    1472
#define IDS_CITY1468                    1473
#define IDS_CITY1469                    1474
#define IDS_CITY1470                    1475
#define IDS_CITY1471                    1476
#define IDS_CITY1472                    1477
#define IDS_CITY1473                    1478
#define IDS_CITY1474                    1479
#define IDS_CITY1475                    1480
#define IDS_CITY1476                    1481
#define IDS_CITY1477                    1482
#define IDS_CITY1478                    1483
#define IDS_CITY1479                    1484
#define IDS_CITY1480                    1485
#define IDS_CITY1481                    1486
#define IDS_CITY1482                    1487
#define IDS_CITY1483                    1488
#define IDS_CITY1484                    1489
#define IDS_CITY1485                    1490
#define IDS_CITY1486                    1491
#define IDS_CITY1487                    1492
#define IDS_CITY1488                    1493
#define IDS_CITY1489                    1494
#define IDS_CITY1490                    1495
#define IDS_CITY1491                    1496
#define IDS_CITY1492                    1497
#define IDS_CITY1493                    1498
#define IDS_CITY1494                    1499
#define IDS_CITY1495                    1500
#define IDS_CITY1496                    1501
#define IDS_CITY1497                    1502
#define IDS_CITY1498                    1503
#define IDS_CITY1499                    1504
#define IDS_CITY1500                    1505
#define IDS_CITY1501                    1506
#define IDS_CITY1502                    1507
#define IDS_CITY1503                    1508
#define IDS_CITY1504                    1509
#define IDS_CITY1505                    1510
#define IDS_CITY1506                    1511
#define IDS_CITY1507                    1512
#define IDS_CITY1508                    1513
#define IDS_CITY1509                    1514
#define IDS_CITY1510                    1515
#define IDS_CITY1511                    1516
#define IDS_CITY1512                    1517
#define IDS_CITY1513                    1518
#define IDS_CITY1514                    1519
#define IDS_CITY1515                    1520
#define IDS_AFRICA2                     1521
#define IDS_ASIA2                       1522
#define IDS_ASIAN_SUBCONTINENT2         1523
#define IDS_AUSTRALIA2                  1524
#define IDS_CANADA2                     1525
#define IDS_EUROPE2                     1526
#define IDS_NORTH_AMERICA2              1527
#define IDS_SOUTH_AMERICA2              1528
#define IDS_WORLD2                      1529
#define IDS_LIB_DESCRIPTION2            1530
#define IDS_WEST_MARK                   1530
#define IDS_DIALOG_TITLE2               1531
#define IDS_NORTH_MARK                  1531
#define IDS_SUN_CLASS_NAME2             1532
#define IDS_SOUTH_MARK                  1532
#define IDS_UNDO                        1533
#define IDS_LIB_DESC                    1534
#define IDS_CAM_CREATE                  1535
#define IDS_CAM_DEL                     1536
#define IDS_LAT                         1537
#define IDS_LONG                        1538
#define IDS_ZONE                        1539
#define IDS_DST                         1540
#define IDS_RAD                         1541
#define IDS_UNDO_PARAM                  1542
#define IDS_DB_COMPASS_CDESC            1543
#define IDC_GETLOC                      3075
#define IDC_DST                         3077
#define IDC_TIME_GROUP                  3078
#define IDC_CAM                         3079
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        184
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         3079
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\sunlight.cpp ===
/*===========================================================================*\
	FILE: sunlight.cpp

	DESCRIPTION: Sunlight system plugin.

	HISTORY: Created Oct.15 by John Hutchinson
			Derived from the ringarray

	Copyright (c) 1996, All Rights Reserved.
 \*==========================================================================*/
/*===========================================================================*\
 | Include Files:
\*===========================================================================*/
#include <max.h>
#include "sunlight.h"
#include "suntypes.h"
#include "autovis.h"
#include "sunclass.h"
#include "light.h"
#include "decomp.h"
#include "matrix3.h"
#include "compass.h"
#include "iparamb.h"
#include "macrorec.h"

#ifdef _DEBUG
	#include <stdio.h>
#endif
#ifdef DESIGN_VER
#include <ICoordSys.h>
#include <ICoordSys_i.c>
#endif
// The DLL instance handle
HINSTANCE hInstance;

/*===========================================================================*\
 | Definitions:
\*===========================================================================*/
#define LIGHT_TM	0
#define LIGHT_MULT	1

// Parameter block indices
//#define PB_RAD	0
//#define PB_LAT	1
//#define PB_LONG	2
//#define PB_DATE	4
//#define PB_TIME 3
//#define PB_ZONE 5
//#define PB_DST 6

#define PB_RAD	4
#define PB_LAT	2
#define PB_LONG	3
#define PB_DATE	1
#define PB_TIME 0
#define PB_ZONE 5
#define PB_DST 6

//default data
#define SF_LAT 37.618f
#define SF_LONG 122.373f
static char *defcityname ="San Francisco, CA";
#define SF_ZONE -8
#define OVERSHOOT TRUE
#define MINYEAR 1583
#define MAXYEAR 3000
#define MINRADIUS 0.0f
#define MAXRADIUS 100000000.0f
#define SUN_RGB Point3(0.88235294f, 0.88235294f, 0.88235294f)  // 225

// functions from GEOLOC.CPP
extern BOOL doLocationDialog(HWND hParent, IObjParam* ip, float* latitude,
							 float* longitude, char* cityName);

// externals from GEOLOC.CPP
extern int lastCity;
extern char* lastCityName;

static int getTimeZone(float longi);
static float stdang_to_compass(float stdang);
float compass_to_stdang(float compass);
static float getZRot(TimeValue t, INode* node);

/*===========================================================================*\
 | Sun Master Methods:
\*===========================================================================*/

// This method returns a new instance of the slave controller.
Control* GetNewSlaveControl(SunMaster *master, int i);

// Initialize the class variables...
//HWND SunMaster::hMasterParams = NULL;
IObjParam *SunMaster::iObjParams;


ISpinnerControl *SunMaster::radSpin;
ISpinnerControl *SunMaster::latSpin;
ISpinnerControl *SunMaster::longSpin;
ISpinnerControl *SunMaster::hourSpin;
ISpinnerControl *SunMaster::minSpin;
ISpinnerControl *SunMaster::secSpin;
ISpinnerControl *SunMaster::yearSpin;
ISpinnerControl *SunMaster::monthSpin;
ISpinnerControl *SunMaster::daySpin;
ISpinnerControl *SunMaster::northSpin;
ISpinnerControl *SunMaster::zoneSpin;
ICustStatus	*SunMaster::altEdit;
ICustStatus	*SunMaster::azEdit;
ICustStatus	*SunMaster::cityDisplay;
// no longer static 
// SYSTEMTIME SunMaster::theTime;


void SunMaster::GetClassName(TSTR& s) { s = GetString(IDS_SUN_CLASS); }
TSTR SunMaster::SubAnimName(int i) { return GetString(IDS_DB_PARAMETERS); }	

#define SUNMASTER_VERSION 1	

/* here's what it looked like in VIZ
	ParamBlockDesc desc[] = {
		{ TYPE_FLOAT, NULL, FALSE },//radius
		{ TYPE_FLOAT, NULL, FALSE },//lat
		{ TYPE_FLOAT, NULL, FALSE },//long
		{ TYPE_FLOAT, NULL, TRUE }, //date
		{ TYPE_INT, NULL, TRUE },//time
		{ TYPE_INT, NULL, FALSE },//zone
		{ TYPE_BOOL, NULL, FALSE },//dst
		};

*/

static ParamBlockDescID desc[] = {
		{ TYPE_FLOAT, NULL, TRUE, PB_RAD },//radius
		{ TYPE_FLOAT, NULL, TRUE, PB_LAT },//lat
		{ TYPE_FLOAT, NULL, TRUE, PB_LONG },//long
		{ TYPE_FLOAT, NULL, TRUE, PB_DATE}, //date
		{ TYPE_INT, NULL, TRUE , PB_TIME},//time
		{ TYPE_INT, NULL, FALSE, PB_ZONE },//zone
		{ TYPE_BOOL, NULL, FALSE, PB_DST},//dst
		};

	//Paramneters for MAX 2.0 version
/*
static ParamBlockDescID desc1[] = {
		{ TYPE_FLOAT, NULL, TRUE, PB_RAD },//radius
		{ TYPE_FLOAT, NULL, TRUE, PB_LAT },//lat
		{ TYPE_FLOAT, NULL, TRUE, PB_LONG },//long
		{ TYPE_INT, NULL, TRUE, PB_TIME },//time
		{ TYPE_FLOAT, NULL, TRUE , PB_DATE}, //date
		{ TYPE_INT, NULL, FALSE, PB_ZONE },//zone
		{ TYPE_BOOL, NULL, FALSE, PB_DST},//dst
		};*/
static ParamBlockDescID desc1[] = {
		{ TYPE_INT, NULL, TRUE, PB_TIME },//time
		{ TYPE_FLOAT, NULL, TRUE , PB_DATE}, //date
		{ TYPE_FLOAT, NULL, TRUE, PB_LAT },//lat
		{ TYPE_FLOAT, NULL, TRUE, PB_LONG },//long
		{ TYPE_FLOAT, NULL, TRUE, PB_RAD },//radius
		{ TYPE_INT, NULL, FALSE, PB_ZONE },//zone
		{ TYPE_BOOL, NULL, FALSE, PB_DST},//dst
		};

// Constructor.
SunMaster::SunMaster() {

	thePoint = NULL;
	theLight = NULL;
	ignore_point_msgs = FALSE;
	hMasterParams = NULL;



	// Create a parameter block and make a reference to it.
	MakeRefByID( FOREVER, 0, CreateParameterBlock( desc1, 7, SUNMASTER_VERSION ) );

	//Make the controllers linear
	
	Control *c = (Control *) CreateInstance(CTRL_FLOAT_CLASS_ID,Class_ID(LININTERP_FLOAT_CLASS_ID,0)); 
	pblock->SetController(PB_DATE, c, TRUE);
	c = (Control *) CreateInstance(CTRL_FLOAT_CLASS_ID,Class_ID(LININTERP_FLOAT_CLASS_ID,0)); 
	pblock->SetController(PB_TIME, c, TRUE);
	
	// Set the initial values at time 0.
	GetLocalTime(&theTime);
	tvalid = NEVER;
	TIME_ZONE_INFORMATION tzi;
	DWORD result = GetTimeZoneInformation(&tzi);
	int zone = SF_ZONE;
	if (result == TIME_ZONE_ID_DAYLIGHT || result ==TIME_ZONE_ID_STANDARD)
		if(tzi.Bias != 0) zone=-tzi.Bias/60;

	SetLat( TimeValue(0), SF_LAT);
	SetLong( TimeValue(0), SF_LONG );
//	SetCity(NULL);
	SetCity(defcityname);
	SetNorth( TimeValue(0), 0.0f);
	SetZone(TimeValue(0), zone);
	SetDst(TimeValue(0), result == TIME_ZONE_ID_DAYLIGHT ? TRUE : FALSE);
	refset=FALSE;
	timeref=0.0f;
	dateref=0;


	
	// since we know that theTime is valid we can do this
	SetTime( TimeValue(0),  fusetime(theTime));
	// now that the parmeter block is up to date we can calculate
	// the dependent vars
	calculate(TimeValue(0),FOREVER);

	}

// This method is called to return a copy of the ring master.
RefTargetHandle SunMaster::Clone(RemapDir& remap) {
    SunMaster* newm = new SunMaster();	
	newm->ReplaceReference(0,pblock->Clone(remap));
	newm->ReplaceReference(1,NULL);
	newm->thePoint = NULL;
	newm->theLight = NULL;
	newm->dateref = dateref;
	remap.PatchPointer((RefTargetHandle*)&newm->thePoint,(RefTargetHandle)thePoint);
	remap.PatchPointer((RefTargetHandle*)&newm->theLight,(RefTargetHandle)theLight);

	return(newm);
	}

// This method is called to update the UI parameters to reflect the
// correct values at the time passed.  Note that FALSE is passed as
// the notify parameter.  This ensure that notification message are
// not sent when the values are updated.
void SunMaster::UpdateUI(TimeValue t)
	{
	if ( hMasterParams ) {


		radSpin->SetValue( GetRad(t), FALSE );
		latSpin->SetValue( GetLat(t), FALSE );
		longSpin->SetValue( GetLong(t), FALSE );

		radSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_RAD,t));
		latSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_LAT,t));
		longSpin->SetKeyBrackets(pblock->KeyFrameAtTime(PB_LONG,t));

		BOOL timekey = pblock->KeyFrameAtTime(PB_TIME,t) || pblock->KeyFrameAtTime(PB_DATE,t);

		hourSpin->SetValue( GetHour(t), FALSE );
		minSpin->SetValue( GetMin(t), FALSE );
		secSpin->SetValue( GetSec(t),FALSE);
		monthSpin->SetValue( GetMon(t), FALSE );
		daySpin->SetValue( GetDay(t), FALSE );
		yearSpin->SetValue( GetYr(t), FALSE );

		hourSpin->SetKeyBrackets(timekey);
		minSpin->SetKeyBrackets(timekey);
		secSpin->SetKeyBrackets(timekey);
		monthSpin->SetKeyBrackets(timekey);
		daySpin->SetKeyBrackets(timekey);
		yearSpin->SetKeyBrackets(timekey);

		northSpin->SetValue( GetNorth(t), FALSE);
		zoneSpin->SetValue( GetZone(t), FALSE);
		CheckDlgButton(hMasterParams,IDC_DST, GetDst(t));
		char buf[3];
		if(azEdit) azEdit->SetText(itoa((int)rtd(az),buf,10));
		if(altEdit) altEdit->SetText(itoa((int)rtd(alt),buf,10));
		if(cityDisplay) cityDisplay->SetText(city);
		}
	}


// The master controller of a system plug-in should implement this 
// method to give MAX a list of nodes that are part of the system.   
// The master controller should fill in the given table with the 
// INode pointers of the nodes that are part of the system. This 
// will ensure that operations like cloning and deleting affect 
// the whole system.  MAX will use GetInterface() in the 
// tmController of each selected node to retrieve the master 
// controller and then call GetSystemNodes() on the master 
// controller to get the list of nodes.
void SunMaster::GetSystemNodes(INodeTab &nodes)
	{
			if(thePoint)nodes.Append(1,&thePoint);
			if(theLight)nodes.Append(1,&theLight);

	}

// This methods returns the ith reference - there are two: the 
// parameter block and the light (helper, actually).
RefTargetHandle SunMaster::GetReference(int i)  { 
	if (i==0) return pblock;
	else if (i==1) return thePoint;
	return NULL;
	}

// This methods sets the ith reference - there are two.
void SunMaster::SetReference(int i, RefTargetHandle rtarg) {
	if (i==0)
		pblock = (IParamBlock *)rtarg;
	else if(i==1)
		thePoint = (INode *)rtarg;
	}		

BOOL SunMaster::GetNextKeyTime(TimeValue t,DWORD flags,TimeValue &nt)
	{
	TimeValue at,tnear = 0;
	BOOL tnearInit = FALSE;
	Control *ct, *cd;
	ct = cd = NULL;
	ct = pblock->GetController(PB_TIME);
	cd = pblock->GetController(PB_DATE);

	
	if (cd && cd->GetNextKeyTime(t,flags,at)) {
		if (!tnearInit) {
			tnear = at;
			tnearInit = TRUE;
		} else 
		if (ABS(at-t) < ABS(tnear-t)) tnear = at;
		}

	if (ct && ct->GetNextKeyTime(t,flags,at)) {
		if (!tnearInit) {
			tnear = at;
			tnearInit = TRUE;
		} else 
		if (ABS(at-t) < ABS(tnear-t)) tnear = at;
		}

	
	if (tnearInit) {
		nt = tnear;
		return TRUE;
	} else {
		return FALSE;
		}
	}

// This function converts a position on the unit sphere,
// given in azimuth altitude, to xyz coordinates
Point3 az_to_xyz(float az, float alt){
	double x,y,z;
	x = cos(alt)*sin(az);
	y = cos(alt)*cos(az);
	z =	sin(alt);
	Point3 xyzp(x,y,z);
	return Normalize(xyzp);
}


// ======= This method is the crux of the system plug-in ==========
// This method gets called by each slave controller and based on the slaves
// ID, it is free to do whatever it wants. In the current system there is only 
// the slave controller of the light.
void SunMaster::GetValue(TimeValue t, void *val, Interval &valid, GetSetMethod method,
 int id) {
	Matrix3 tmat;
	Matrix3 *mat;
	tmat.IdentityMatrix();
	Point3 unitdir;
	float* mult;
	float radius = GetRad(t,valid);

	// calculate the controllers dependent variables: the azimuth and altitude
	calculate(t,valid);

	switch(id){
		case LIGHT_TM:
			// Calculate the translation and rotation of the node 
			//CAUTION slop data types
			mat = (Matrix3*)val;
			tmat.RotateX(PI/2.0f - float(alt));
			tmat.RotateZ(PI - float(az));
			unitdir = az_to_xyz(float(az), float(alt));
			tmat.SetTrans(radius*unitdir);
			(*mat) = (method==CTRL_RELATIVE) ? tmat*(*mat) : tmat;

			// Make sure spinners track when animating and in Motion Panel
			// the limits on the day spinner may be wrong
			if ( hMasterParams ) {
				int year, month, day ,leap, modays;
				month = GetMon(t);
				year = GetYr(t);
				day = GetDay(t);
				leap = isleap(year);
				if (month == 12) modays = 31;
				else modays = mdays[leap][month]-mdays[leap][month-1];
				daySpin->SetLimits(1,modays,FALSE);
			}

			UpdateUI(t);
			break;

		case LIGHT_MULT:
			mult=(float*)val;
			if(alt<-5.0) *mult=0.0f;
			else *mult=1.0f;
			break;
	}
}

class TimeDimension : public ParamDimension {
	public:
		DimType DimensionType() {return DIM_CUSTOM;}
		// Enforce range limits. Out-of-range values are reset to valid limits.
		float Convert(float value)
		{
			// Convert seconds to hours.
			if (value < 0.0f)
				return 0.0f;
			else if (value >= SECS_PER_DAY)
				value = SECS_PER_DAY - 1;
			return value/3600.0f;
		}
		float UnConvert(float value)
		{
			// Convert hours to seconds.
			if (value < 0.0f)
				return 0.0f;
			else if (value >= 24.0f)
				return SECS_PER_DAY - 1;
			return value*3600.0f;
		}
	};
static TimeDimension theTimeDim;


// This is the method that recieves change notification messages
RefResult SunMaster::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
    {
	switch (message) {
		case REFMSG_GET_PARAM_DIM: { 
			// The ParamBlock needs info to display in the track view.
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_DATE: gpd->dim = stdWorldDim;break;
				case PB_TIME: gpd->dim = &theTimeDim;break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_DATE: gpn->name = GetString(IDS_SOL_DATE);break;
				case PB_TIME: gpn->name = GetString(IDS_SOL_TIME);break;
				case PB_RAD: gpn->name = GetString(IDS_RAD);break;
				case PB_LAT: gpn->name = GetString(IDS_LAT);break;
				case PB_LONG: gpn->name = GetString(IDS_LONG);break;
//				case PB_ZONE: gpn->name = GetString(IDS_ZONE);break;
				}
			return REF_STOP; 
			}

		case REFMSG_TARGET_DELETED:
			if (hTarget==thePoint) {
				thePoint = NULL;
				break;
				}
			return REF_STOP;

		case REFMSG_CHANGE:
			if ( hTarget==thePoint && !ignore_point_msgs ) {
				if (hMasterParams) 
					UpdateUI(iObjParams->GetTime());
				break;
				}
			else if (hTarget == pblock){
				if (hMasterParams) 
					UpdateUI(iObjParams->GetTime());
				break;
				}
			return REF_STOP;
		}
	return(REF_SUCCEED);
	}

// Sets the city name.
void SunMaster::SetCity(const char* name)
{
	const char* nm = name;
	if (nm != NULL)
	{
		if (*nm == '+')
			++nm;
		strcpy(city, nm);
	}
	else
	{
		*city = '\0';
		lastCity = -1;
	}
}

// The following methods set and get the radius value in the parameter block.
void SunMaster::SetRad(TimeValue t, float r) { 
	pblock->SetValue( PB_RAD, t, r );
	}

float SunMaster::GetRad(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_RAD, t, f, valid );
	return f;
	}

// The following methods set and get the lat/long in the parameter block.
void SunMaster::SetLat(TimeValue t, float r) { 
	pblock->SetValue( PB_LAT, t, r );
	}

float SunMaster::GetLat(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_LAT, t, f, valid );
	return f;
	}

void SunMaster::SetLong(TimeValue t, float r) { 
	pblock->SetValue( PB_LONG, t, r );
	}

float SunMaster::GetLong(TimeValue t, Interval& valid ) { 	
	float f;
	pblock->GetValue( PB_LONG, t, f, valid );
	return f;
	}

// Other pblock access methods

void SunMaster::SetZone(TimeValue t, int h) { 
	pblock->SetValue( PB_ZONE, t, h );
	}

int SunMaster::GetZone(TimeValue t, Interval& valid ) { 	
	int i;
	pblock->GetValue( PB_ZONE, t, i, valid );
	return i;
	}

void SunMaster::SetDst(TimeValue t, BOOL h) { 
	pblock->SetValue( PB_DST, t, h );
	}

BOOL  SunMaster::GetDst(TimeValue t, Interval& valid ) { 	
	BOOL b;
	pblock->GetValue( PB_DST, t, b, valid );
	return b;
	}

void SunMaster::SetNorth(TimeValue t, float r) { 
	if (thePoint) align_north(t,r);
	}

float SunMaster::GetNorth(TimeValue t, Interval& valid ) { 	
	return getZRot(t, thePoint);
	}


// This method actually places a representation of the current Julian date
// into the parameter block where it is interpolated. Because pblocks
// can only handle floats, two values are interpolated separately.
// The number of days goes into PB_DATE and is interpolated as a float.
// The number of seconds in the currwnt day goes into PB_TIME and
// is interpolated as an int.
//
// Furthermore because the number of JulianDays can be such a large number,
// prior to sticking it in the pblock we save a local epoch and measure date
// changes relative to this benchmark
//
void SunMaster::SetTime(TimeValue t, interpJulianStruct jd) { 
	double t1;
	int t2;

	// if were not animating we save a local epoch and measure relative to it
//	if(!Animating()){
	if(!refset){
		dateref=(long)jd.days;
		refset = TRUE;
		t1=0.0;
	}
	else {
		tvalid.SetEmpty();
		t1 = jd.days - dateref;
	}

	t2 = jd.subday;
	pblock->SetValue( PB_DATE, t, (float) t1 ); //caution possible data loss
	pblock->SetValue( PB_TIME, t, t2 );
	}

// GetTime pulls the interpolated parameter block values out and passes them through
// fracturetime which adds the local epoch back in and explodes the value into a gregorian
// representation in the static var theTime.

// We implement a validity mechanism for the local time representation

void SunMaster::GetTime(TimeValue t, Interval& valid ) {
	if(0){
//	if(tvalid.InInterval(t)){
		valid &= tvalid;
		return;
	}
	else{
		tvalid = FOREVER;
		interpJulianStruct jd;
		float date;
		int time;
		pblock->GetValue( PB_DATE, t, date, tvalid );
		pblock->GetValue( PB_TIME, t, time, tvalid );
		valid &= tvalid;
		jd.days=date;
		jd.subday=time;
		jd.epoch=dateref;
		fracturetime(jd,theTime);
	}
	}

//////////////////////////////////////////////////////////////
// The Pseudo pblock methods for getting time and setting time
//////////////////////////////////////////////////////////////

void SunMaster::SetHour(TimeValue t, int h) { 
	theTime.wHour = h;
	SetTime(t,fusetime(theTime));
	}

int SunMaster::GetHour(TimeValue t, Interval& valid ) { 	
	GetTime(t,valid);//throw away return, we want side-effect
	return theTime.wHour;
	}

void SunMaster::SetMin(TimeValue t, int h) { 
	theTime.wMinute = h;
	SetTime(t,fusetime(theTime));
	}

int SunMaster::GetMin(TimeValue t, Interval& valid ) { 	
	GetTime(t,valid);//throw away return, we want side-effect
	return theTime.wMinute;
	}

void SunMaster::SetSec(TimeValue t, int h) { 
	theTime.wSecond = h;
	SetTime(t,fusetime(theTime));
	}

int SunMaster::GetSec(TimeValue t, Interval& valid ) { 	
	GetTime(t,valid);//throw away return, we want side-effect
	return theTime.wSecond;
	}

void SunMaster::SetMon(TimeValue t, int h) { 
	theTime.wMonth = h;
	SetTime(t,fusetime(theTime));
	}

int SunMaster::GetMon(TimeValue t, Interval& valid ) { 	
	GetTime(t,valid);//throw away return, we want side-effect
	return theTime.wMonth;
	}

void SunMaster::SetDay(TimeValue t, int h) { 
	theTime.wDay = h;
	SetTime(t,fusetime(theTime));
	}

int SunMaster::GetDay(TimeValue t, Interval& valid ) { 	
	GetTime(t,valid);//throw away return, we want side-effect
	return theTime.wDay;
	}

void SunMaster::SetYr(TimeValue t, int h) { 
	theTime.wYear = h;
	SetTime(t,fusetime(theTime));
	}

int SunMaster::GetYr(TimeValue t, Interval& valid ) { 	
	GetTime(t,valid);//throw away return, we want side-effect
	return theTime.wYear;
	}

/////////////////////////////////////////////////////////////
//Methods for getting the private, dependent variables
///////////////////////////////////////////////////////////////

Point2 SunMaster::GetAzAlt(TimeValue t, Interval& valid ) {
	Point2 result;
	GetTime(t,valid);
	calculate(t,FOREVER);
	result.x = (float) az;
	result.y = (float) alt;
	return result;
}

// calculate the dependent variables at the given time
void SunMaster::calculate(TimeValue t, Interval& valid){
	double latitude,longitude;
	long hour,min,sec,month,day,year,zone;
	BOOL dst;

	// Retrieve the values of the UI parameters at the time passed in.
	zone = GetZone(t,valid);
	dst = GetDst(t,valid);
	latitude = GetLat(t,valid);
	longitude = GetLong(t,valid);
	hour = GetHour(t,valid);
	min = GetMin(t,valid);
	sec = GetSec(t,valid);
	month = GetMon(t,valid);
	day = GetDay(t,valid);
	year = GetYr(t,valid);

	double st;
	long zonedst = zone;
	if(dst) zonedst++;
	sunLocator(dtr(latitude), dtr(longitude), month, day,
		year, hour - zonedst, min,sec, 0,
		   &alt, &az, &st);

	

#ifdef _DEBUG
	FILE *stream;
	stream=fopen("round.log","a");
	float date;
	pblock->GetValue( PB_DATE, t, date, valid );
	float time;
	pblock->GetValue( PB_TIME, t, time, valid );
	fprintf(stream, "Yr: %d\tMon: %d\tDay: %d\tHr: %d\tMin: %d\tSec: %d\n", year, month, day, hour, min, sec );
/*	printf( "UYr: %d\tUMon: %d\tUDay: %d\tUHr: %d\tUMin: %d\tUSec: %d\n", hourSpin->GetIVal(),\
		monthSpin->GetIVal(), daySpin->GetIVal(), hourSpin->GetIVal(),\
		minSpin->GetIVal(), secSpin->GetIVal() );*/
	fprintf(stream, "Date: %f\tOffset: %d\tTime: %f\tOffset: %f\n", date, dateref, time, timeref );
  	fprintf(stream, "Lat: %f\tLong: %f\tZone: %ld\n\n", latitude, longitude, zone );
	fprintf(stream, "Az: %f\tAlt: %f\tSt: %f\n\n\n", az, alt, st );
	fclose(stream);
#endif

}


//method to rotate the helper object from the UI of the master controller
void SunMaster::align_north(TimeValue now, float north){
	assert(thePoint);

	// animate off and suspend msg processing
	ignore_point_msgs = TRUE;
	SuspendAnimate();
	AnimateOff();

	AffineParts lparts;
	float ang[3];
	INode *parent;
	Matrix3 nodeTM, parentTM, localTM, newTM;
  	parent = thePoint->GetParentNode();
	nodeTM = thePoint->GetNodeTM(now);
	parentTM = parent->GetNodeTM(now);
	localTM = nodeTM * Inverse(parentTM);
	decomp_affine(localTM, &lparts);
	QuatToEuler(lparts.q, ang);

	int turns = (int) (ang[2]/FTWO_PI);
	float subturn = ang[2] - turns;//we only affect the scrap
	ang[2]= turns + fdtr(compass_to_stdang(north));
	
	// build a new matrix
	EulerToQuat(ang, lparts.q);
	lparts.q.MakeMatrix(newTM);
	newTM.SetTrans(lparts.t);

	// animate back on and msg processing back to normal
	thePoint->SetNodeTM(now, newTM);
	ResumeAnimate();
	ignore_point_msgs = FALSE;
}

float stdang_to_compass(float stdang){
	float rel =  - stdang;
	if (rel >=0.0f) 
		return rel;
	else 
		return FTWO_PI - (float)fabs(rel);
}

float compass_to_stdang(float compass){
		return  - compass;
}

// Returns the local Zrotation of the node less any winding number
// measured relative to the local z axis 
// positive values are clockwise

float getZRot(TimeValue t,INode *node){

	AffineParts lparts;
	float ang[3];
	INode *parent;
	Matrix3 nodeTM, parentTM, localTM, newTM;
	if (node ){
		nodeTM = node->GetNodeTM(t);
		parent = node->GetParentNode();
		if(parent){
			parentTM = parent->GetNodeTM(t);
			localTM = nodeTM * Inverse(parentTM);
			decomp_affine(localTM, &lparts);
			QuatToEuler(lparts.q, ang);
			float test1 = (ang[2]/FTWO_PI);
			int test2 = (int) test1;
			float temp = (float) test1-test2;
			return frtd(stdang_to_compass(temp*FTWO_PI));
		} else
			return 0.0f;
	}  else
		return 0.0f;
}




// Get the APPROXIMATE time zone from the longitude.
int getTimeZone(float longi)
{
    int tz;
    if (longi >= 0)
        tz = -(int)((longi + 7.5) / 15);
    else
        tz = (int)((-longi + 7.5) / 15);

    return tz;
}



// The Dialog Proc

BOOL CALLBACK MasterParamDialogProc( HWND hDlg, UINT message, 
	WPARAM wParam, LPARAM lParam )
	{
	char buf[3];
	SunMaster *mc = (SunMaster *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !mc && message != WM_INITDIALOG ) return FALSE;
	TimeValue now = mc->iObjParams->GetTime();

	static int holdLastCity;
	static char holdLastName[64];
	
	assert(mc->iObjParams);
	switch ( message ) {
		int year, month,day,leap,modays;// locals for handling date changes
		case WM_INITDIALOG:
			mc = (SunMaster *)lParam;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)mc );
			SetDlgFont( hDlg, mc->iObjParams->GetAppHFont() );

			// set up the date locals based on the current UI
			year = mc->GetYr(now);
			month = mc->GetMon(now);
			day = mc->GetDay(now);
			leap = isleap(year);
			if (month == 12) modays = 31;
			else modays = mdays[leap][month]-mdays[leap][month-1];

			// reset these copies
			holdLastCity = -1;
			*holdLastName = '\0';
			
			mc->radSpin  = GetISpinner(GetDlgItem(hDlg,IDC_RADSPINNER));
			mc->latSpin  = GetISpinner(GetDlgItem(hDlg,IDC_LATSPINNER));
			mc->longSpin  = GetISpinner(GetDlgItem(hDlg,IDC_LONGSPINNER));
			mc->yearSpin  = GetISpinner(GetDlgItem(hDlg,IDC_YEARSPINNER));
			mc->monthSpin  = GetISpinner(GetDlgItem(hDlg,IDC_MONTHSPINNER));
			mc->daySpin  = GetISpinner(GetDlgItem(hDlg,IDC_DAYSPINNER));
			mc->secSpin  = GetISpinner(GetDlgItem(hDlg,IDC_SECSPINNER));
			mc->hourSpin  = GetISpinner(GetDlgItem(hDlg,IDC_HOURSPINNER));
			mc->minSpin  = GetISpinner(GetDlgItem(hDlg,IDC_MINSPINNER));
			mc->northSpin  = GetISpinner(GetDlgItem(hDlg,IDC_NORTHSPINNER));
			mc->zoneSpin  = GetISpinner(GetDlgItem(hDlg,IDC_ZONESPINNER));
			mc->azEdit  = GetICustStatus(GetDlgItem(hDlg,IDC_AZ));
			mc->altEdit  = GetICustStatus(GetDlgItem(hDlg,IDC_ALT));
			mc->cityDisplay  = GetICustStatus(GetDlgItem(hDlg,IDC_CITY));

			mc->radSpin->SetLimits( MINRADIUS,MAXRADIUS, FALSE );
			mc->latSpin->SetLimits( -90.0f, 90.0f, FALSE );
			mc->longSpin->SetLimits( -180.0f, 180.0f, FALSE );
			mc->yearSpin->SetLimits(MINYEAR,MAXYEAR, FALSE );
			mc->zoneSpin->SetLimits(-12,12, FALSE );
			mc->monthSpin->SetLimits(1,12, FALSE );
			mc->daySpin->SetLimits( 1, modays, FALSE );
			mc->hourSpin->SetLimits(0,23, FALSE );
			mc->minSpin->SetLimits( 0, 59, FALSE );
			mc->secSpin->SetLimits( 0, 59, FALSE );
			mc->northSpin->SetLimits(0.0f, 359.99f, FALSE );

			mc->radSpin->SetAutoScale( TRUE );
			mc->latSpin->SetScale(float(0.1) );
			mc->longSpin->SetScale(float(0.1) );
			mc->yearSpin->SetScale(float(1.0) );
			mc->monthSpin->SetScale(float(1.0) );
			mc->daySpin->SetScale(float(1.0) );
			mc->hourSpin->SetScale(float(1.0) );
			mc->minSpin->SetScale(float(1.0) );
			mc->secSpin->SetScale(float(1.0) );
			mc->northSpin->SetScale(float(1.0) );
			mc->zoneSpin->SetScale(float(1.0) );

			mc->latSpin->SetValue( mc->GetLat(now), FALSE );
			mc->longSpin->SetValue( mc->GetLong(now), FALSE );
			mc->radSpin->SetValue( mc->GetRad(now), FALSE );
			mc->hourSpin->SetValue( mc->GetHour(now), FALSE );
			mc->minSpin->SetValue( mc->GetMin(now), FALSE );
			mc->secSpin->SetValue( mc->GetSec(now), FALSE );
			mc->monthSpin->SetValue( month, FALSE );
			mc->daySpin->SetValue( mc->GetDay(now), FALSE );
			mc->yearSpin->SetValue( year , FALSE );
			mc->northSpin->SetValue( mc->GetNorth(now), FALSE );
			mc->zoneSpin->SetValue( mc->GetZone(now), FALSE );
			CheckDlgButton(hDlg,IDC_DST, mc->GetDst(now));
			mc->azEdit->SetText(itoa((int)rtd(mc->Getaz()),buf,10));
			mc->altEdit->SetText(itoa((int)rtd(mc->Getalt()),buf,10));
			mc->cityDisplay->SetText(mc->GetCity());

			mc->radSpin->LinkToEdit( GetDlgItem(hDlg,IDC_RADIUS), EDITTYPE_POS_UNIVERSE );			
			mc->latSpin->LinkToEdit( GetDlgItem(hDlg,IDC_LAT), EDITTYPE_FLOAT );			
			mc->longSpin->LinkToEdit( GetDlgItem(hDlg,IDC_LONG), EDITTYPE_FLOAT );			
			mc->yearSpin->LinkToEdit( GetDlgItem(hDlg,IDC_YEAR), EDITTYPE_INT );			
			mc->monthSpin->LinkToEdit( GetDlgItem(hDlg,IDC_MONTH), EDITTYPE_INT );			
			mc->daySpin->LinkToEdit( GetDlgItem(hDlg,IDC_DAY), EDITTYPE_INT );			
			mc->hourSpin->LinkToEdit( GetDlgItem(hDlg,IDC_HOUR), EDITTYPE_INT );			
			mc->minSpin->LinkToEdit( GetDlgItem(hDlg,IDC_MIN), EDITTYPE_INT );			
			mc->secSpin->LinkToEdit( GetDlgItem(hDlg,IDC_SEC), EDITTYPE_INT );			
			mc->northSpin->LinkToEdit( GetDlgItem(hDlg,IDC_NORTH), EDITTYPE_FLOAT );			
 			mc->zoneSpin->LinkToEdit( GetDlgItem(hDlg,IDC_ZONE), EDITTYPE_INT );			

			mc->iObjParams->RedrawViews(now, REDRAW_INTERACTIVE, mc);

			return FALSE;	// DB 2/27

		case WM_DESTROY:
			ReleaseISpinner( mc->radSpin );
			ReleaseISpinner( mc->latSpin );
			ReleaseISpinner( mc->longSpin );
			ReleaseISpinner( mc->daySpin );
			ReleaseISpinner( mc->monthSpin );
			ReleaseISpinner( mc->yearSpin );
			ReleaseISpinner( mc->hourSpin );
			ReleaseISpinner( mc->minSpin );
			ReleaseISpinner( mc->secSpin );
			ReleaseISpinner( mc->northSpin );
			ReleaseISpinner( mc->zoneSpin );
			ReleaseICustStatus( mc->azEdit);
			ReleaseICustStatus( mc->altEdit);
			ReleaseICustStatus( mc->cityDisplay);
			mc->radSpin  = NULL;
			mc->latSpin  = NULL;
			mc->longSpin  = NULL;
			mc->yearSpin  = NULL;
			mc->monthSpin  = NULL;
			mc->daySpin  = NULL;
			mc->hourSpin  = NULL;
			mc->minSpin  = NULL;
			mc->secSpin  = NULL;
			mc->azEdit  = NULL;
			mc->altEdit  =NULL;
			mc->cityDisplay  = NULL;
			mc->northSpin  =NULL;
			mc->zoneSpin  =NULL;


			return FALSE;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			return TRUE;


		case CC_SPINNER_CHANGE:

			year = mc->GetYr(now);
			month = mc->GetMon(now);
			day = mc->GetDay(now);
			leap = isleap(year);
			if (month == 12) modays = 31;
			else modays = mdays[leap][month]-mdays[leap][month-1];


			switch ( LOWORD(wParam) ) {
				case IDC_RADSPINNER: mc->SetRad(now,  mc->radSpin->GetFVal() );  break;
				case IDC_LATSPINNER:
					mc->SetLat(now,  mc->latSpin->GetFVal() );
					mc->SetCity(NULL);
					break;
				case IDC_LONGSPINNER:
					mc->SetLong(now,  mc->longSpin->GetFVal() );
					mc->SetCity(NULL);
					break;
				case IDC_HOURSPINNER: mc->SetHour(now,  mc->hourSpin->GetIVal() );  break;
				case IDC_MINSPINNER: mc->SetMin(now,  mc->minSpin->GetIVal() );  break;
				case IDC_SECSPINNER: mc->SetSec(now,  mc->secSpin->GetIVal() );  break;
				case IDC_MONTHSPINNER:
					month =  mc->monthSpin->GetIVal();
					if (month == 12) modays = 31;
					else modays = mdays[leap][month]-mdays[leap][month-1];
					if (day > modays){
						day=modays;
						mc->SetDay(now,  day );}
					mc->daySpin->SetLimits(1,modays,FALSE);
					mc->SetMon(now,  month );
					break;
				case IDC_DAYSPINNER: mc->SetDay(now,  mc->daySpin->GetIVal() );  break;
				case IDC_YEARSPINNER: 
					year =  mc->yearSpin->GetIVal();
					leap = isleap(year);
					if (month == 12) modays = 31;
					else modays = mdays[leap][month]-mdays[leap][month-1];
					if (day > modays){
						day=modays;
						mc->SetDay(now,  day );}
					mc->daySpin->SetLimits(1,modays,FALSE);
					mc->SetYr(now,  year );
					break;
				case IDC_NORTHSPINNER:mc->SetNorth(now,  mc->northSpin->GetFVal() );  break;
				case IDC_ZONESPINNER: mc->SetZone(now,  mc->zoneSpin->GetIVal() );  break;
				}
			//Notify dependents: they will call getvalue which will update UI
			//else : calculate and Update UI directly
			if (mc->theLight) mc->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
			else {
				mc->calculate(now,FOREVER);
				mc->UpdateUI(now);
			}

			assert(mc->iObjParams);
			mc->iObjParams->RedrawViews(now, REDRAW_INTERACTIVE, mc);
			return TRUE;

		case CC_SPINNER_BUTTONUP:
			if (! HIWORD(wParam))
			{
				switch (LOWORD(wParam))
				{
					case IDC_LATSPINNER:
					case IDC_LONGSPINNER:
						// reset if spinner operation is cancelled
						lastCity = holdLastCity;
						mc->SetCity(holdLastName);
						mc->calculate(now,FOREVER);
						mc->UpdateUI(now);
						break;
				}
			}
//			mc->iObjParams->RedrawViews(now, REDRAW_END, mc);
			theHold.Accept(GetString(IDS_UNDO_PARAM));
			return TRUE;

		case WM_MOUSEACTIVATE:
			mc->iObjParams->RealizeParamPanel();
			return FALSE;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			mc->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;

		case WM_COMMAND:
				switch(LOWORD(wParam)) { // Switch on ID
				// The user clicked the daylight savings checkbox.
				case IDC_DST:
					mc->SetDst(now,IsDlgButtonChecked(mc->hMasterParams,IDC_DST));
					break;
				case IDC_GETLOC: 
					float lat = mc->GetLat(now);
					float longi = mc->GetLong(now);
					char city[256] = "";
					if (doLocationDialog(hDlg, mc->iObjParams, &lat, &longi, city)) {
						int tz = getTimeZone(longi);
						mc->SetLat(now,lat);
						mc->SetLong(now,longi);
						mc->SetZone(now,tz);
						mc->SetCity(city);
						// set these copies
						holdLastCity = lastCity;
						strcpy(holdLastName, city);
					}
					break;
				}
			if (mc->theLight) mc->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
			else {
				mc->calculate(now,FOREVER);
				mc->UpdateUI(now);
			}
			mc->iObjParams->RedrawViews(now, REDRAW_INTERACTIVE, mc);
			return TRUE;

		default:
			return FALSE;
		}
	}



// This method is called when the sun masters parameters may be edited
// in the motion branch of the command panel.  
void SunMaster::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	// Save the interface pointer passed in.  This pointer is only valid
	// between BeginEditParams() and EndEditParams().
	iObjParams = ip;
	if ( !hMasterParams  ) {
		// Add the rollup page to the command panel. This method sets the
		// dialog proc used to manage the user interaction with the dialog
		// controls.


		hMasterParams = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SUNPARAM),
				MasterParamDialogProc,
				GetString(IDS_SUN_DLG_NAM), 
				(LPARAM)this );		
		
	} else {
		SetWindowLong( hMasterParams, GWL_USERDATA, (LONG)this );		

		// Init the dialog to our values.
		radSpin->SetValue(GetRad(ip->GetTime()),FALSE);
		latSpin->SetValue(GetLat(ip->GetTime()),FALSE);
		longSpin->SetValue(GetLong(ip->GetTime()),FALSE);
		hourSpin->SetValue(GetHour(ip->GetTime()),FALSE);
		minSpin->SetValue(GetMin(ip->GetTime()),FALSE);
		secSpin->SetValue(GetSec(ip->GetTime()),FALSE);
		monthSpin->SetValue(GetMon(ip->GetTime()),FALSE);
		daySpin->SetValue(GetDay(ip->GetTime()),FALSE);
		yearSpin->SetValue(GetYr(ip->GetTime()),FALSE);
		BOOL temp = GetDst(ip->GetTime());
		CheckDlgButton(hMasterParams,IDC_DST,temp );
		}
	}
		
// This method is called when the user is finished editing the sun masters
// parameters in the command panel.		
void SunMaster::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next ){

	if (hMasterParams==NULL) 
		return;

	// Check if the rollup page should be removed.
/*	if ( flags&END_EDIT_REMOVEUI ){ 		

		BOOL keepit = FALSE;
		if(next){
			Class_ID ncid = next->ClassID();
			keepit = (Class_ID(SLAVE_CONTROL_CID1,SLAVE_CONTROL_CID2) == ncid)?TRUE:FALSE;
		}
		if (keepit){
	//		SetWindowLong( hMasterParams, GWL_USERDATA, 0 );
			SlaveControl* sc = (SlaveControl *)next;
			SetWindowLong( hMasterParams, GWL_USERDATA, (LONG)(sc->master) );
			SunMaster* nextsun =(SunMaster*) sc->master;
			nextsun->hMasterParams = hMasterParams;
		}else if(hMasterParams)
			ip->DeleteRollupPage(hMasterParams);
	}*/

	if ( flags&END_EDIT_REMOVEUI ) {		
		ip->UnRegisterDlgWnd(hMasterParams);
		ip->DeleteRollupPage(hMasterParams);
		hMasterParams = NULL;
		}
	else {		
		SetWindowLong( hMasterParams, GWL_USERDATA, 0 );
		}


	hMasterParams = NULL;
	iObjParams = NULL;
}

#define NODE_ID_CHUNK 0x110
#define EPOCH_CHUNK 0x100

IOResult SunMaster::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(NODE_ID_CHUNK);
		ULONG id;
		id = isave->GetRefID(theLight);
		isave->Write(&id,sizeof(ULONG), &nb);
	isave->EndChunk();
	isave->BeginChunk(EPOCH_CHUNK);
		isave->Write(&dateref,sizeof(ULONG), &nb);
	isave->EndChunk();

	return IO_OK;
	}

IParamBlock *SpecialUpdateParameterBlock(
		ParamBlockDescID *pdescOld, int oldCount, IParamBlock *oldPB,
		ParamBlockDescID *pdescNew, int newCount, DWORD newVersion)
	{
	IParamBlock *opb = oldPB;
	IParamBlock *npb = CreateParameterBlock(pdescNew,newCount,newVersion);

	theHold.Suspend();

	for (int i=0; i<oldCount; i++) {
//		int index = FindParam(pdescOld,oldCount,pdescNew[i].id);
		//since the old decsriptor didn't have any ID's we'll just remap them
		// in the naive way, i.e. in the natural order.
		int index = i;
		Control *c = opb->GetController(index);
		if (index>=0) {			
			BOOL oldC, newC;
			oldC = c==NULL;
			newC = TRUE ;//npb->params[i].flags & CONSTANT;

			if (newC) {				
				npb->SetController(i, NULL);	
			} else {
				assert(0); // this should never happen 'cause we just made this parameter block!
				}

			if (oldC) {
//				npb->SetValue(i, TimeValue(0), opb->GetValue(index));
				Interval ivalid = FOREVER;
				Point3 pt;
				int k;
				float f;

				switch (opb->GetParameterType(index)) {
					case TYPE_RGBA:
					case TYPE_POINT3:
						opb->GetValue(index, TimeValue(0), pt, ivalid);
						npb->SetValue(i, TimeValue(0), pt);
						break;

					case TYPE_BOOL:
					case TYPE_INT:
						opb->GetValue(index, TimeValue(0), k, ivalid);
						npb->SetValue(i, TimeValue(0), k);
						break;

					case TYPE_FLOAT:
						opb->GetValue(index, TimeValue(0), f, ivalid);
						npb->SetValue(i, TimeValue(0), f);
						break;

					default:
						assert(0);
						break;
					}
					
			} else {
				npb->SetController(i,c); 
				c->MakeReference(FOREVER,npb);
				}
//			npb->params[i].flags = opb->params[index].flags;			
			}
		}
	
	theHold.Resume();
	return npb;
	}


class SunMasterPostLoad : public PostLoadCallback {
public:
    SunMaster *bo;
    SunMasterPostLoad(SunMaster *b) {bo=b;}
    void proc(ILoad *iload) {           
        if (bo->pblock->GetVersion()!=SUNMASTER_VERSION) {
            switch (bo->pblock->GetVersion()) {
            case 0:
                bo->ReplaceReference(0,
                                     UpdateParameterBlock(
                                         desc, 7, bo->pblock,
                                         desc1, 7, SUNMASTER_VERSION));
				bo->SetZone(TimeValue(0),-1 * bo->GetZone(TimeValue(0)));
                iload->SetObsolete();
                break;

            default:
                assert(0);
                break;
            }
        }
//        waitPostLoad--;
        delete this;
    }
};


IOResult SunMaster::Load(ILoad *iload) {
	ULONG nb;
	IOResult res;
	iload->RegisterPostLoadCallback(new SunMasterPostLoad(this));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case NODE_ID_CHUNK:
					ULONG id;
					iload->Read(&id,sizeof(ULONG), &nb);
					if (id!=0xffffffff)
						iload->RecordBackpatch(id,(void**)&theLight);
				break;
			case EPOCH_CHUNK:
					iload->Read(&dateref,sizeof(LONG), &nb);
					if(dateref != 0)
						refset = TRUE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	tvalid = NEVER;

	return IO_OK;
	}

/*===========================================================================*\
 | Sun Slave Controller  Methods:
\*===========================================================================*/


// This method returns a new instance of the slave controller.
Control* GetNewSlaveControl(SunMaster *master, int i) {
	return new SlaveControl(master,i);
	}

// Constructor.  
SlaveControl::SlaveControl(const SlaveControl& ctrl) {
	master = ctrl.master;
	id = ctrl.id;
	}

void SlaveControl::GetClassName(TSTR& s) { s = GetString(IDS_SLAVE_CLASS); }


// This constructor creates a reference from the slave controller to 
// the sun master object.
SlaveControl::SlaveControl(const SunMaster* m, int i) {
	id = i;
    MakeRefByID( FOREVER, 0, (ReferenceTarget *)m);
	}

// This method is called to create a copy of the slave controller.
RefTargetHandle SlaveControl::Clone(RemapDir& remap) {
	SlaveControl *sl = new SlaveControl;
	sl->id = id;
	sl->ReplaceReference(0, remap.CloneRef(master));
	return sl;
	}

SlaveControl& SlaveControl::operator=(const SlaveControl& ctrl) {
	master = ctrl.master;
	id = ctrl.id;
	return (*this);
	}

// ========= This method is used to retrieve the value of the 
// controller at the specified time. =========

// This is a important aspect of the system plug-in - this method 
// calls the master object to get the value.

void SlaveControl::GetValue(TimeValue t, void *val, Interval &valid, 
	GetSetMethod method) {
	// Ensure the ring master exists.
	assert(master);
	master->GetValue(t,val,valid,method,id);	
	}

void SlaveControl::SetValue(TimeValue t, void *val, int commit, 
	GetSetMethod method) { }

void* SlaveControl::GetInterface(ULONG id) {
	if (id==I_MASTER) 
		return (void *)master;
	else 
		return NULL;
	}

IOResult SlaveControl::Save(ISave *isave) {
	return IO_OK;
	}

IOResult SlaveControl::Load(ILoad *iload) {
	return IO_OK;
	}

// These are the API methods
void SlaveControl::GetSunTime( TimeValue t, SYSTEMTIME&	sunt ){
	master->GetTime(t,FOREVER);
	int hours = master->GetZone(t,FOREVER);
	if(master->GetDst(t,FOREVER)) hours--;

	
	sunt.wYear = master->theTime.wYear;
	sunt.wMonth = master->theTime.wMonth;
	sunt.wDay = master->theTime.wDay;

	sunt.wHour = (master->theTime.wHour + hours)%24;
	sunt.wMinute = master->theTime.wMinute;
	sunt.wSecond = master->theTime.wSecond;
}


 void SlaveControl::GetSunLoc(TimeValue t, Point2& origin, Point2& orient){

//	master.GetTime(t, FOREVER);
//	master.Calculate(t,FOREVER);
	
	origin.x = master->GetLat(t, FOREVER);
	origin.y = master->GetLong(t, FOREVER);
	Point2 temp =master->GetAzAlt(t,FOREVER); 
	orient.x = temp.x;
	orient.y = temp.y;
}


/*===========================================================================*\
 | SunMasterCreationManager Class:
\*===========================================================================*/
// This is the class used to manage the creation process of the ring array
// in the 3D viewports.
class SunMasterCreationManager : public MouseCallBack, ReferenceMaker {
	private:
		CreateMouseCallBack *createCB;	
		INode *node0;
		// This holds a pointer to the SunMaster object.  This is used
		// to call methods on the sun  master such as BeginEditParams() and
		// EndEditParams() which bracket the editing of the UI parameters.
		SunMaster *theMaster;
		// This holds the interface pointer for calling methods provided
		// by MAX.
		IObjCreate *createInterface;

		ClassDesc *cDesc;
		// This holds the nodes TM relative to the CP
		Matrix3 mat;
		// This holds the initial mouse point the user clicked when
		// creating the ring array.
		IPoint2 pt0;
		// This holds the center point of the ring array
		Point3 center;
		// This flag indicates the dummy nodes have been hooked up to
		// the master node and the entire system has been created.
		BOOL attachedToNode;

		// This method is called to create a new SunMaster object (theMaster)
		// and begin the editing of the systems user interface parameters.
		void CreateNewMaster(HWND rollup);
			
		// This flag is used to catch the reference message that is sent
		// when the system plug-in itself selects a node in the scene.
		// When the user does this, the plug-in recieves a reference message
		// that it needs to respond to.
		int ignoreSelectionChange;

		// --- Inherited virtual methods of ReferenceMaker ---
		// This returns the number of references this item has.
		// It has a single reference to the first created node in the scene.
		int NumRefs() { return 1; }
		// This methods retrieves the ith reference.
		RefTargetHandle GetReference(int i);
		// This methods stores the ith reference.
		void SetReference(int i, RefTargetHandle rtarg);

		// This method recieves the change notification messages sent
		// when the the reference target changes.
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);

	public:
		// This method is called just before the creation command mode is
		// pushed on the command stack.
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		// This method is called after the creation command mode is finished 
		// and is about to be popped from the command stack.
		void End();
		
		// Constructor.
		SunMasterCreationManager()
			{
			ignoreSelectionChange = FALSE;
			}
		// --- Inherited virtual methods from MouseCallBack
		// This is the method that handles the user / mouse interaction
		// when the system plug-in is being created in the viewports.
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};

/*===========================================================================*\
 | SunMasterCreateMode Class:
\*===========================================================================*/
#define CID_RINGCREATE	CID_USER + 0x509C2DF4
// This is the command mode that manages the overall process when 
// the system is created.  
// See the Advanced Topics section on Command Modes and Mouse Procs for 
// more details on these methods.
class SunMasterCreateMode : public CommandMode {
	// This instance of SunMasterCreationMangaer handles the user/mouse
	// interaction as the sun array is created.
	IObjCreate *ip;
	SunMasterCreationManager proc;
	public:
		// These two methods just call the creation proc method of the same
		// name. 
		// This creates a new sun master object and starts the editing
		// of the objects parameters.  This is called just before the 
		// command mode is pushed on the stack to begin the creation
		// process.
		void Begin( IObjCreate *ioc, ClassDesc *desc ) 
			{ 
			ip=ioc;
			proc.Begin( ioc, desc ); }
		// This terminates the editing of the sun masters parameters.
		// This is called just before the command mode is removed from
		// the command stack.
		void End() { proc.End(); }
		// This returns the type of command mode this is.  See the online
		// help under this method for a list of the available choices.
		// In this case we are a creation command mode.
		int Class() { return CREATE_COMMAND; }
		// Returns the ID of the command mode. This value should be the 
		// constant CID_USER plus some random value chosen by the developer.
		int ID() { return CID_RINGCREATE; }
		// This method returns a pointer to the mouse proc that will
		// handle the user/mouse interaction.  It also establishes the number 
		// of points that may be accepted by the mouse proc.  In this case
		// we set the number of points to 100000.  The user process will 
		// terminate before this (!) after the mouse proc returns FALSE.
		// The mouse proc returned from this method is an instance of
		// SunMasterCreationManager.  Note that that class is derived
		// from MouseCallBack.
		MouseCallBack *MouseProc(int *numPoints) 
			{ *numPoints = 100000; return &proc; }
		// This method is called to flag nodes in the foreground plane.
		// We just return the standard CHANGE_FG_SELECTED value to indicate
		// that selected nodes will go into the foreground.  This allows
		// the system to speed up screen redraws.  See the Advanced Topics
		// section on Foreground / Background planes for more details.
		ChangeForegroundCallback *ChangeFGProc() 
			{ return CHANGE_FG_SELECTED; }
		// This method returns TRUE if the command mode needs to change the
		// foreground proc (using ChangeFGProc()) and FALSE if it does not. 
		BOOL ChangeFG( CommandMode *oldMode ) 
			{ return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		// This method is called when a command mode becomes active.  We
		// don't need to do anything at this time so our implementation is NULL
		void EnterMode() {
			SetCursor(LoadCursor(NULL, IDC_CROSS));
			ip->PushPrompt( GetString(IDS_SUN_CREATE_PROMPT));
		}
		// This method is called when the command mode is replaced by 
		// another mode.  Again, we don't need to do anything.
		void ExitMode() {
			ip->PopPrompt();
			SetCursor(LoadCursor(NULL, IDC_ARROW));
		}
		BOOL IsSticky() { return FALSE; }
		};

// A static instance of the command mode.
static SunMasterCreateMode theSunMasterCreateMode;

// This initializes a few variables, creates a new sun master object and 
// starts the editing of the objects parameters.
void SunMasterCreationManager::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	// This just initializes the variables.
	createInterface = ioc;
	cDesc           = desc;	 //class descriptor of the master controller
	createCB        = NULL;
	node0			= NULL;
	theMaster 		= NULL;
	attachedToNode = FALSE;
	// This creates a new sun master object and starts the editing
	// of the objects parameters.
	CreateNewMaster(NULL);
	}

// This method sets the ith reference.  We have only one - to the first
// node created in the sun system.
void SunMasterCreationManager::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case 0: node0 = (INode *)rtarg; break;
		default: assert(0); 
		}
	}

// This method returns the ith node.  We have only one - to the first node
// created in the ring array.
RefTargetHandle SunMasterCreationManager::GetReference(int i) { 
	switch(i) {
		case 0: return (RefTargetHandle)node0;
		default: assert(0); 
		}
	return NULL;
	}

//SunMasterCreationManager::~SunMasterCreationManager
void SunMasterCreationManager::End()
	{
	if (theMaster) {
		theMaster->EndEditParams( (IObjParam*)createInterface, 
	                    	          TRUE/*destroy*/, NULL );
		if ( !attachedToNode ) {
			delete theMaster;
			theMaster = NULL;
		} else if ( node0 ) {
			 // Get rid of the references.
			DeleteAllRefsFromMe();
			}
		}
	theMaster = NULL;
	}

// This method is used to recieve change notification messages from the 
// item that is referenced - the first created node in the system.
RefResult SunMasterCreationManager::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_TARGET_SELECTIONCHANGE:
			// This method is sent if the reference target (node0) is
			// selected or deselected.
			// This is used so that if the user deselects this slave node
			// the creation process will begin with a new item (and not 
			// continue to edit the existing item if the UI contorls are 
			// adjusted)
		 	if ( ignoreSelectionChange ) {
				// We select a node ourseleves when the creation process
				// is finished - this just lets us ignore this message
				// in that case.
				break;
				}
		 	if (theMaster) {
				// This will set node0 ==NULL;
				DeleteAllRefsFromMe();
				goto endEdit;
				}
			else 
				return REF_SUCCEED;
			// Fall through

		case REFMSG_TARGET_DELETED:
			if (theMaster) {
				endEdit:
				// This ends the parameter editing process.
				HWND temp = theMaster->hMasterParams;
				theMaster->EndEditParams( (IObjParam*)createInterface, FALSE/*destroy*/,NULL );
				theMaster = NULL;
				node0 = NULL;
				// This creates a new SunMaster object and starts
				// the parameter editing process.
				CreateNewMaster(temp);	
				// Indicate that no nodes have been attached yet - 
				// no system created...
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

// This method is called to create a new sun master object and 
// begin the parameter editing process.
void SunMasterCreationManager::CreateNewMaster(HWND rollup)
	{
	// Allocate a new instance of the SunMaster object.
	theMaster = new SunMaster();

	//Possibly point to an existing dialog rollup
	theMaster->hMasterParams = rollup;

#ifdef DESIGN_VER
	if (GetAppID() == kAPP_VIZ)
	{
		IGcsSession * pSession = NULL;
		HRESULT hr = ::CoCreateInstance(CLSID_GcsSession,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IGcsSession,
			reinterpret_cast<void **>(&pSession));
		DbgAssert(SUCCEEDED(hr));
		if (SUCCEEDED(hr))
		{
			double lat, log;
			ICsCoordsysDef * pSys = NULL;
			pSession->GetGlobalCoordSystem(&pSys);
			if (pSys)
			{
				theMaster->iObjParams = (IObjParam*)createInterface;
				pSys->GetOriginLatitude(&lat);
				pSys->GetOriginLongitude(&log);
				if (!(lat == 0.0 && log == 0.0))
				{
					theMaster->SetLat(TimeValue(0), lat);
					theMaster->SetLong(TimeValue(0), -log);
				}
				if (theMaster->GetLat(0) != SF_LAT || theMaster->GetLong(0) != SF_LONG)
				{
					theMaster->SetCity("");
					theMaster->SetZone(TimeValue(0), -(theMaster->GetLong(0) / 15));
				}
				theMaster->iObjParams = NULL;
				pSys->Release();
			}
		}
	}
#endif
	
	// Start the edit parameters process
	theMaster->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE,NULL );
	}


// This is the method of MouseCallBack that is used to handle the user/mouse
// interaction during the creation process of the system plug-in.
int SunMasterCreationManager::proc( 
				HWND hwnd,
				int msg,
				int point,
				int flag,
				IPoint2 m )
	{
	// This is set to TRUE if we should keep processing and FALSE
	// if the message processing should end.
	int res;
	INode *newNode = NULL;
	// This is the helper object at the center of the system.
	static INode *dummyNode = NULL;
	// This is the radius of the sun system.
	float r;

	// The two objects we create here.
	//static HelperObject* compassObj = NULL;
	static CompassRoseObject* compassObj = NULL;
	static GeneralLight* lightObj = NULL;

	createInterface->GetMacroRecorder()->Disable();  // JBW, disable for now; systems not creatable in MAXScript

	// Attempt to get the viewport interface from the window
	// handle passed
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );
	TimeValue t = createInterface->GetTime();
	// Set the cursor
	SetCursor(LoadCursor(NULL, IDC_CROSS));


	// Process the mouse message sent...
	switch ( msg ) {
		case MOUSE_POINT:
		case MOUSE_MOVE: {
			switch (point) {
				case 0: {
					// Mouse Down: This point defines the center of the sun system.
					pt0 = m;
					// Make sure the master object exists
					assert(theMaster);

					// Reset our pointers.
					compassObj = NULL;
					lightObj = NULL;
					dummyNode = NULL;

					mat.IdentityMatrix();
					if ( createInterface->SetActiveViewport(hwnd) ) {
						createInterface->GetMacroRecorder()->Enable();  
						return FALSE;
						}

					// Make sure the view in the viewport is not parallel
					// to the creation plane - if it is the mouse points
					// clicked by the user cannot be converted to 3D points.
					if (createInterface->IsCPEdgeOnInView()) {
						createInterface->GetMacroRecorder()->Enable();  
						return FALSE;
						}

					if ( attachedToNode) {

						// As an experiment we won't allow any other to be created.
						//createInterface->PushPrompt( GetString(IDS_SUN_COMPLETE_PROMPT));
						//return FALSE;

						// A previous sun system exists - terminate the editing
						// of it's parameters and send it on it's way...
						// Hang on to the last one's handle to the rollup
						HWND temp = theMaster->hMasterParams;

				   		theMaster->EndEditParams( (IObjParam*)createInterface,0,NULL );
						// Get rid of the references.  This sets node0 = NULL.
						DeleteAllRefsFromMe();

						// This creates a new SunMaster object (theMaster)
						// and starts the parameter editing process.
						CreateNewMaster(temp);
						}

					// Begin hold for undo
				   	theHold.Begin();

	 				createInterface->RedrawViews(t, REDRAW_BEGIN);

					// Snap the inital mouse point
					//mat.IdentityMatrix();
					center = vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
					mat.SetTrans(center);

					// Create the compass (a helper).
					compassObj = (CompassRoseObject*)createInterface->
							CreateInstance(HELPER_CLASS_ID, COMPASS_CLASS_ID); 			
					assert(compassObj);
					dummyNode = createInterface->CreateObjectNode(compassObj);
					createInterface->SetNodeTMRelConstPlane(dummyNode, mat);
					createInterface->RedrawViews(t, REDRAW_INTERACTIVE);

					res = TRUE;
					break;
					}

				case 1: {
					// Mouse Drag: Set on-screen size of the compass
					Point3 p1 = vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
					compassObj->axisLength = Length(p1 - center);
					compassObj->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);

					if (msg == MOUSE_POINT) {

						// Create the Light
						lightObj = (GeneralLight *)createInterface->
								CreateInstance(LIGHT_CLASS_ID,Class_ID(DIR_LIGHT_CLASS_ID,0));
						assert(lightObj);
						lightObj->Enable(1);
						lightObj->SetShadow(1);
						lightObj->SetShadowType(1);
						lightObj->SetOvershoot(OVERSHOOT);
						lightObj->SetRGBColor(t, SUN_RGB);

						// Here we'd like to assign a controller to the intensity 
						// parameter, but the pblock is not exposed, so we set the 
						// color controller.
						//SlaveControl* multslave = new SlaveControl(theMaster,LIGHT_MULT);
						//lightObj->pblock->SetController(1,multslave);

						// Create a new node given the instance.
						newNode = createInterface->CreateObjectNode(lightObj);
						assert (newNode);
						createInterface->AddLightToScene(newNode);
						TSTR nodename = GetString(IDS_LIGHT_NAME);
						createInterface->MakeNameUnique(nodename);
						newNode->SetName(nodename);

						// We are no longer creating a camera at the light location.
						//
						//// Create a Camera and attach it to the light 
						//GenCamera *cob = (GenCamera *)createInterface->
						//	CreateInstance(CAMERA_CLASS_ID,Class_ID(SIMPLE_CAM_CLASS_ID,0));
						//assert(cob);
						//cob->Enable(1);
						//// Create a new node given the instance.
						//INode *camNode = createInterface->CreateObjectNode(cob);
						//camNode->Hide(TRUE);
						//newNode->AttachChild(camNode);
						//nodename = GetString(IDS_CAM_NAME);
						//createInterface->MakeNameUnique(nodename);
						//camNode->SetName(nodename);

						// Create a new slave controller of the master control.
						SlaveControl* slave = new SlaveControl(theMaster,LIGHT_TM);
						// Set the transform controller used by the node.
						newNode->SetTMController(slave);
						// Attach the new node as a child of the central node.
						dummyNode->AttachChild(newNode);
						theMaster->theLight=newNode;
						theMaster->thePoint=dummyNode;
						//the master references the point so it can get
						//notified when the	user rotates it
						theMaster->MakeRefByID(FOREVER, 1, dummyNode );
						// Indicate that the system is attached
						attachedToNode = TRUE;

						// Reference the node so we'll get notifications.
						// This is done so when the node is selected or 
						// deselected the parameter editing process can 
						// be started and stopped.
					    MakeRefByID( FOREVER, 0, theMaster->theLight );
						// Set the initial radius of the system to one
						theMaster->SetRad(TimeValue(0),1.0f);
						//mat.SetTrans(vpx->SnapPoint(m,m,NULL,SNAP_IN_PLANE));
						// construction plane.  This is used during creating
						// so you can set the position of the node in terms of 
						// the construction plane and not in world units.
						createInterface->SetNodeTMRelConstPlane(dummyNode, mat);
						//theMaster->align_north();
						}

	 				createInterface->RedrawViews(t, REDRAW_INTERACTIVE);
					// This indicates the mouse proc should continue to recieve
					// messages.
					res = TRUE;
					break;
					}

				case 2: {
					// Mouse Pick and release: 
					// The user is dragging the mouse to set the radius
					// (i.e. the distance of the light from the compass center)
					if (node0) {
						// Calculate the radius as the distance from the initial
						// point to the current point
						r = (float)fabs(vpx->SnapLength(vpx->GetCPDisp(center,Point3(0,1,0),pt0,m)));
						// Set the radius at time 0.
						theMaster->SetRad(0, r);
						lightObj->SetTDist(t, r);
						theMaster->NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
						// Update the UI spinner to reflect the current value.
						theMaster->radSpin->SetValue(r, FALSE );
						}

					res = TRUE;
					if (msg == MOUSE_POINT) {
						// The mouse has been released - finish the creation 
						// process.  Select the first node so if we go into 
						// the motion branch we'll see it's parameters.

						// We set the flag to ignore the selection change
						// because the NotifyRefChanged() method recieves
						// a message when the node is selected or deselected
						// and terminates the parameter editing process.  This
						// flag causes it to ignore the selection change.
						ignoreSelectionChange = TRUE;
					   	createInterface->SelectNode( theMaster->theLight );
						ignoreSelectionChange = FALSE;
						// This registers the undo object with the system so
						// the user may undo the creation.
						theHold.Accept(GetString(IDS_UNDO));
						// Set the return value to FALSE to indicate the 
						// creation process is finished.  This mouse proc will
						// no longer be called until the user creates another
						// system.
						res = FALSE;
						}
	 				createInterface->RedrawViews(t, res ? REDRAW_INTERACTIVE : REDRAW_END);
					break;
					}
				}
			}
			break;

	    case MOUSE_PROPCLICK:
			// right click while between creations
			createInterface->RemoveMode(NULL);
			break;
		
		case MOUSE_ABORT:
			// The user has right-clicked the mouse to abort the 
			// creation process.
			assert(theMaster);
			// End the parameter editing process
			HWND temp = theMaster->hMasterParams;
			theMaster->EndEditParams( (IObjParam*)createInterface, 0,NULL );
			theHold.Cancel();  // undo the changes
			// Update the viewports
			createInterface->RedrawViews(t, REDRAW_NORMAL);
			DeleteAllRefsFromMe();
			// This creates a new SunMaster object and starts
			// the parameter editing process.
			CreateNewMaster(temp);	
			// Indicate the nodes have not been
			// hooked up to the system yet.
			attachedToNode = FALSE;
			// Sets the return value to indicate that mouse processing
			// should be stopped.
			res = FALSE;						
			break;
		}
	
	createInterface->ReleaseViewport(vpx); 
	// Returns TRUE if processing should continue and false if it
	// has been aborted.
	createInterface->GetMacroRecorder()->Enable();  
	return res;
	}

/*===========================================================================*\
 | The Class Descriptors
\*===========================================================================*/
class SunMasterClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SunMaster(); }
	// This method returns the name of the class.  This name appears 
	// in the button for the plug-in in the MAX user interface.
	const TCHAR *	ClassName() { return GetString(IDS_SUN_CLASS); }
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	SClass_ID		SuperClassID() { return SYSTEM_CLASS_ID; } 
	Class_ID		ClassID() 
		{ return Class_ID(SUNLIGHT_CID1,SUNLIGHT_CID2); }
	const TCHAR* 	Category() { return _T("");  }
	};
// A single instance of the class descriptor.
static SunMasterClassDesc mcDesc;
// This returns a pointer to the instance.
ClassDesc* GetSunMasterDesc() { return &mcDesc; }

class SlaveControlClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new SlaveControl(); }
	const TCHAR *	ClassName() { return GetString(IDS_SLAVE_CLASS); }
	SClass_ID		SuperClassID() { return CTRL_POSITION_CLASS_ID; }
	Class_ID		ClassID() 
		{ return Class_ID(SLAVE_CONTROL_CID1,SLAVE_CONTROL_CID2); }
	// The slave controllers don't appear in any of the drop down lists, 
	// so they just return a null string.
	const TCHAR* 	Category() { return _T("");  }
	};

// A single instance of the class descriptor.
static SlaveControlClassDesc slvDesc;
// This returns a pointer to the instance.
ClassDesc* GetSlaveControlDesc() { return &slvDesc; }

// This is the method of the class descriptor that actually begins the 
// creation process in the viewports.
int SunMasterClassDesc::BeginCreate(Interface *i)
	{
	// Save the interface pointer passed in.  This is used to call 
	// methods provided by MAX itself.
	IObjCreate *iob = i->GetIObjCreate();
	
	theSunMasterCreateMode.Begin( iob, this );
	// Set the current command mode to the SunMasterCreateMode.
	iob->PushCommandMode( &theSunMasterCreateMode );
	
	return TRUE;
	}

// This is the method of the class descriptor that terminates the 
// creation process.
int SunMasterClassDesc::EndCreate(Interface *i)
	{
	theSunMasterCreateMode.End();
	// Remove the command mode from the command stack.
	i->RemoveMode( &theSunMasterCreateMode );
	return TRUE;
	}

// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.
int controlsInit = FALSE;
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		// Initialize MAX's custom controls
		InitCustomControls(hInstance);
		
		// Initialize Win95 controls
		InitCommonControls();
	}
	
	return(TRUE);
	}

__declspec(dllexport) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESC); 
	}

__declspec( dllexport ) int 
LibNumberClasses()
{
if (Get3DSMAXVersion() < 120)
return 0;

return 3;
}



__declspec(dllexport) ClassDesc* 
LibClassDesc(int i) { 
	switch(i) {
		case 0:	return GetSunMasterDesc();
		case 1:	return GetSlaveControlDesc();
		case 2:	return GetCompassRoseDesc();
		default: return 0;
	};
}

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }


TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Sunlight\verts.h ===
#define NUMVERTS 16
static Point3 roseverts[NUMVERTS]={ 
 Point3(1.154849,      0.478355,      0.000000),
 Point3(1.636821,      1.636822,      0.000000),
 Point3(0.478354,      1.154850,      0.000000),
 Point3(-0.000002,      5.000001,      0.000000),
 Point3(-0.478355,      1.154849,      0.000000),
 Point3(-1.636822,      1.636821,      0.000000),
 Point3(-1.154850,      0.478354,      0.000000),
 Point3(-5.000000,      -0.000002,      0.000000),
 Point3(-1.154849,      -0.478355,      0.000000),
 Point3(-1.636821,      -1.636822,      0.000000),
 Point3(-0.478354,     -1.154850,      0.000000),
 Point3(0.000002,      -5.000001,      0.000000),
 Point3(0.478355,      -1.154849,      0.000000),
 Point3(1.636822,      -1.636821,      0.000000),
 Point3(1.154850,      -0.478354,      0.000000),
 Point3(5.000001,      0.000002,      0.000000)};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\pbomb.cpp ===
/**********************************************************************
 *<
	FILE: pbomb.cpp

	DESCRIPTION: Particle Bomb

	CREATED BY: Audrey Peterson

	HISTORY: 12/11/96

 *>	Copyright (c) 1996, All Rights Reserved.  For Yost Group Inc.
 **********************************************************************/
#include "SuprPrts.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

class BombMtl: public Material {
	public:
	BombMtl();
	};
static BombMtl swMtl;

#define BOMB_R	float(1)
#define BOMB_G	float(1)
#define BOMB_B	float(0)
const Point3 HOOPCOLOR(1.0f,1.0f,0.0f);

BombMtl::BombMtl():Material() 
{	Kd[0] = BOMB_R;
	Kd[1] = BOMB_G;
	Kd[2] = BOMB_B;
	Ks[0] = BOMB_R;
	Ks[1] = BOMB_G;
	Ks[2] = BOMB_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME;
	selfIllum = (float)1.0;
}

static Class_ID PBOMB_CLASS_ID(0x4c200df3, 0x1a347a77);
static Class_ID PBOMBMOD_CLASS_ID(0xc0609ea, 0x1300b3d);
class PBombObject : public SimpleWSMObject {	
	public:									
		PBombObject();		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		ForceField *GetForceField(INode *node);
		BOOL SupportsDynamics() {return TRUE;}
		IOResult Load(ILoad *iload);

		// From Animatable		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void MapKeys(TimeMap *map,DWORD flags);
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		// From Animatable		
		void DeleteThis() {delete this;}		
		Class_ID ClassID() {return PBOMB_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_PBOMB);}
						
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);
		
		// From SimpleWSMObject				
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void BuildMesh(TimeValue t);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);

		int DialogID() {return IDD_SW_PARTICLEBOMB;}
		ParamUIDesc *UIDesc();
		int UIDescLength();
		TSTR UIStrName();
		void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
	};

IObjParam *PBombObject::ip        = NULL;
IParamMap *PBombObject::pmapParam = NULL;
HWND       PBombObject::hSot      = NULL;

class PBombClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new PBombObject;}
	const TCHAR *	ClassName() {return GetString(IDS_AP_PBOMB_CLASS);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return PBOMB_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_BOTH);}
	};

static PBombClassDesc PBombDesc;
ClassDesc* GetPBombObjDesc() {return &PBombDesc;}

class PBombMod;

class PBombField : public ForceField {
	public:
		PBombObject *obj;
		TimeValue dtsq,dt;
		INode *node;
		int count;
		Matrix3 tm,invtm;
		Interval tmValid;
		Point3 force;
		Interval fValid;
		Point3 Force(TimeValue t,const Point3 &pos, const Point3 &vel, int index);
	};

class PBombMod : public SimpleWSMMod {
	public:				
		PBombField force;
		int seed;

		PBombMod() {}
		PBombMod(INode *node,PBombObject *obj);		
		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_RB_PBOMBMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return PBOMBMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_PBOMBBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};
class PBombModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) {return new PBombMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_PBOMBMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID;}
	Class_ID		ClassID() {return PBOMBMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static PBombModClassDesc PBombModDesc;
ClassDesc* GetPBombModDesc() {return &PBombModDesc;}

class BombModData : public LocalModData {
public:
	int seed;
	LocalModData *Clone ();
};

LocalModData *BombModData::Clone () {
	BombModData *clone;
	clone = new BombModData ();
	clone->seed=seed;
	return(clone);
}

//--- BombObject Parameter map/block descriptors ------------------
#define PB_SYMMETRY			0
#define PB_CHAOS			1
#define PB_STARTTIME		2
#define PB_LASTSFOR			3
#define PB_DELTA_V			4 
#define PB_DECAY			5
#define PB_DECAYTYPE		6
#define PB_ICONSIZE			7
#define PB_RANGEON			8

static int symIDs[] = {IDC_SP_BLASTSPHR,IDC_SP_BLASTCYL,IDC_SP_BLASTPLAN};
static int decayIDs[] = {IDC_SP_DECAYOFF,IDC_SP_DECAYLIN,IDC_SP_DECAYEXP};
#define SPHERE 0
#define PLANAR 2
#define CYLIND 1

static ParamUIDesc descParamBomb[] = {

	// Blast Symmetry
	ParamUIDesc(PB_SYMMETRY,TYPE_RADIO,symIDs,3),

	// Direction Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_SP_BLASTCHAOS,IDC_SP_BLASTCHAOSSPIN,
		0.0f, 100.0f,
		0.01f,
		stdPercentDim),
	
	// Start Time for Impulse
	ParamUIDesc(
		PB_STARTTIME,
		EDITTYPE_TIME,
		IDC_SP_BLASTSTRT,IDC_SP_BLASTSTRTSPIN,
		-999999999.0f,999999999.0f,
		10.0f),
	
	// Lasts For Time
	ParamUIDesc(
		PB_LASTSFOR,
		EDITTYPE_TIME,
		IDC_SP_BLASTSTOP,IDC_SP_BLASTSTOPSPIN,
		0.0f,999999999.0f,
		10.0f),
	
	// DeltaV
	ParamUIDesc(
		PB_DELTA_V,
		EDITTYPE_FLOAT,
		IDC_SP_BLASTDV,IDC_SP_BLASTDVSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),
	
	// Decay Range
	ParamUIDesc(
		PB_DECAY,
		EDITTYPE_UNIVERSE,
		IDC_SP_BLASTDECAY,IDC_SP_BLASTDECAYSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Decay Type
	ParamUIDesc(PB_DECAYTYPE,TYPE_RADIO,decayIDs,3),

	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_SP_BLAST_ICONSIZE,IDC_SP_BLAST_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Enable Range Indicator
	ParamUIDesc(PB_RANGEON,TYPE_SINGLECHEKBOX,IDC_PBOMB_RANGEON),
	};

#define BOMBPARAMDESC_LENGTH	9

ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//PB_SYMMETRY
	{ TYPE_FLOAT, NULL, FALSE, 1 },	//PB_CHAOS
	{ TYPE_INT, NULL, FALSE, 2 },	//PB_STARTTIME
	{ TYPE_INT, NULL, FALSE, 3 },	//PB_LASTSFOR
	{ TYPE_FLOAT, NULL, TRUE, 4 },	//PB_DELTA_V
	{ TYPE_FLOAT, NULL, TRUE, 5 },	// PB_DECAY
	{ TYPE_INT, NULL, FALSE, 6 },	// PB_DECAYTYPE
	{ TYPE_FLOAT, NULL, FALSE, 7 }};	// PB_ICONSIZE

ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//PB_SYMMETRY
	{ TYPE_FLOAT, NULL, FALSE, 1 },	//PB_CHAOS
	{ TYPE_INT, NULL, FALSE, 2 },	//PB_STARTTIME
	{ TYPE_INT, NULL, FALSE, 3 },	//PB_LASTSFOR
	{ TYPE_FLOAT, NULL, TRUE, 4 },	//PB_DELTA_V
	{ TYPE_FLOAT, NULL, TRUE, 5 },	// PB_DECAY
	{ TYPE_INT, NULL, FALSE, 6 },	// PB_DECAYTYPE
	{ TYPE_FLOAT, NULL, FALSE, 7 },	// PB_ICONSIZE
	{ TYPE_INT, NULL, FALSE, 8 }	// Range Indicator
};	

#define PBLOCK_LENGTH	9

static ParamVersionDesc pbombversions[] = {
	ParamVersionDesc(descVer0,8,0),
	ParamVersionDesc(descVer1,9,1),
	};

#define NUM_OLDVERSIONS	1

#define CURRENT_VERSION	1
static ParamVersionDesc curVersionPBomb(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);


//--- Deflect object methods -----------------------------------------

class PBombPostLoadCallback : public PostLoadCallback 
{	public:
		ParamBlockPLCB *cb;
		PBombPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) 
		{	DWORD oldVer = ((PBombObject*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) 
				((PBombObject*)targ)->pblock->SetValue(PB_RANGEON,0,0);
			delete this;
		}
};

IOResult PBombObject::Load(ILoad *iload)
{	IOResult res = IO_OK;
	iload->RegisterPostLoadCallback(
			new PBombPostLoadCallback(
				new ParamBlockPLCB(pbombversions,NUM_OLDVERSIONS,&curVersionPBomb,this,0)));
	return IO_OK;
}

PBombObject::PBombObject()
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_SYMMETRY,0,0);
	pblock->SetValue(PB_CHAOS,0,0.10f);
	pblock->SetValue(PB_STARTTIME,0,FToTick*30);
	pblock->SetValue(PB_LASTSFOR,0,FToTick);
	pblock->SetValue(PB_DELTA_V,0,1.0f);
	pblock->SetValue(PB_DECAY,0,1000.0f);
	pblock->SetValue(PB_DECAYTYPE,0,1);
	srand(12345);
	}

class PBombDlgProc : public ParamMapUserDlgProc {
	public:
		PBombObject *po;

		PBombDlgProc(PBombObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};
void PBombDlgProc::Update(TimeValue t)
{ int decay;
  po->pblock->GetValue(PB_DECAYTYPE,0,decay,FOREVER);
  HWND hWnd=po->pmapParam->GetHWnd();
  if (decay==0)
	 SpinnerOff(hWnd,IDC_SP_BLASTDECAYSPIN,IDC_SP_BLASTDECAY);
  else
	 SpinnerOn(hWnd,IDC_SP_BLASTDECAYSPIN,IDC_SP_BLASTDECAY);
}

BOOL PBombDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{ switch (msg) 
	  {case WM_INITDIALOG: 
		{ Update(t);
		 break;
		}
	   case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SP_DECAYOFF:
				{ SpinnerOff(hWnd,IDC_SP_BLASTDECAYSPIN,IDC_SP_BLASTDECAY);
				 return TRUE;
				}
			  case IDC_SP_DECAYLIN:
			  case IDC_SP_DECAYEXP:
				{ SpinnerOn(hWnd,IDC_SP_BLASTDECAYSPIN,IDC_SP_BLASTDECAY);
				  return TRUE;
				}
			}
	  }
	return FALSE;
	}

void PBombObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC_BOTH),
			DefaultSOTProc,
			GetString(IDS_RB_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descParamBomb,BOMBPARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SW_PARTICLEBOMB),
			GetString(IDS_RB_PARAMETERS),
			0);
		}
		if (pmapParam) pmapParam->SetUserDlgProc(new PBombDlgProc(this));
	}

void PBombObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}
ForceField *PBombObject::GetForceField(INode *node)
	{
	PBombField *pb = new PBombField;	
	pb->obj  = this;
	pb->node = node;
	pb->tmValid.SetEmpty();
	pb->fValid.SetEmpty();
	pb->dt=GetTicksPerFrame();
	pb->dtsq=pb->dt*pb->dt;
	return pb;
	}

void PBombObject::MapKeys(TimeMap *map,DWORD flags)
{	TimeValue TempTime;
	pblock->GetValue(PB_STARTTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_STARTTIME,0,TempTime);
	pblock->GetValue(PB_LASTSFOR,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_LASTSFOR,0,TempTime);
}

void PBombObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float length;
	pblock->GetValue(PB_ICONSIZE,t,length,ivalid);
	float u,zval;
	#define NUM_SEGS 12
	#define NUM_SEGS2 24
	int btype, norvs, norfs, rangeverts=0, rangefaces=0;
	pblock->GetValue(PB_SYMMETRY,0,btype,FOREVER);
//	int dorange,hoops;
//	pblock->GetValue(PB_RANGEON,0,hoops,FOREVER);
//	pblock->GetValue(PB_DECAYTYPE,0,dorange,FOREVER);
//	if (dorange && hoops){ rangeverts=73;rangefaces=72;}
	if (btype<2)
	{ length/=2.0f;
	  if (btype==0)
	  { mesh.setNumVerts((norvs=58)+rangeverts);
	    mesh.setNumFaces((norfs=58)+rangefaces);
		int fbase=22,vbase=21,newv;
	    for (int i=0; i<NUM_SEGS; i++)
	    { u = float(i)/float(NUM_SEGS) * TWOPI;
		  mesh.setVert(i+vbase, Point3((float)cos(u) * length, (float)sin(u) * length, 0.0f));
	    }
		newv=NUM_SEGS+vbase;
	    for (i=0; i<NUM_SEGS; i++) 
	    { u = float(i)/float(NUM_SEGS) * TWOPI;
		  mesh.setVert(i+newv, Point3(0.0f, (float)cos(u) * length, (float)sin(u) * length));
	    } newv+=NUM_SEGS;
	    for (i=0; i<NUM_SEGS; i++)
	    { u = float(i)/float(NUM_SEGS) * TWOPI;
		  mesh.setVert(i+newv, Point3((float)cos(u) * length, 0.0f, (float)sin(u) * length));
	    }		
		newv+=NUM_SEGS;
	    mesh.setVert(newv, Point3(0.0f, 0.0f, 0.0f));
		int vi=vbase;
	    for (i=fbase; i<newv+1; i++) 
	    { int i1 = vi+1;
	      if ((i1-vbase)%NUM_SEGS==0) i1 -= NUM_SEGS;
	      mesh.faces[i].setEdgeVisFlags(1,0,0);
	      mesh.faces[i].setSmGroup(0);
	      mesh.faces[i].setVerts(vi,i1,newv);
		  vi++;
	    }
		zval=0.85f*length;
	  }
	  else 
	  { mesh.setNumVerts((norvs=21)+rangeverts);
	    mesh.setNumFaces((norfs=22)+rangefaces);
		zval=-0.85f*length;	
	  }
	  float hlen=0.4f*length;
	  mesh.setVert(0,Point3(0.0f,0.0f,zval));
	  for (int i=1;i<9;i++)
	  { u= TWOPI*float(i-1)/8.0f;
	    mesh.setVert(i, Point3((float)cos(u) * hlen,(float)sin(u) * hlen, zval));
	  }
	  zval=1.25f*length;
	  mesh.setVert(9,Point3(0.0f,0.0f,zval));
	  for (i=10;i<18;i++)
	  { u= TWOPI*float(i-10)/8.0f;
	    mesh.setVert(i, Point3((float)cos(u) * hlen,(float)sin(u) * hlen, zval));
	  }
	  int fcount=1;
	  for (i=0;i<8;i++)
	  { mesh.faces[i].setEdgeVisFlags(0,1,0);
	    mesh.faces[i].setSmGroup(0);
	    mesh.faces[i].setVerts(0,fcount,fcount+1);
	    fcount++;
	  }
	  mesh.faces[7].setVerts(0,8,1);
	  fcount=10;
	  for (i=8;i<16;i++)
	  { mesh.faces[i].setEdgeVisFlags(0,1,0);
	    mesh.faces[i].setSmGroup(0);
	    mesh.faces[i].setVerts(9,fcount,fcount+1);
	    fcount++;
	  }
	  mesh.faces[15].setVerts(9,17,10);
	  for (i=16;i<22;i++)
	  { mesh.faces[i].setSmGroup(0);
        mesh.faces[i].setEdgeVisFlags(0,1,0);
	  }
	  mesh.faces[16].setVerts(1,10,14);
      mesh.faces[16].setEdgeVisFlags(1,0,0);
	  mesh.faces[17].setVerts(1,14,5);
	  mesh.faces[18].setVerts(3,12,16);
      mesh.faces[18].setEdgeVisFlags(1,0,0);
	  mesh.faces[19].setVerts(3,16,7);
	  mesh.setVert(18,Point3(0.0f,0.0f,1.5f*length));
	  mesh.setVert(19,Point3(0.25f*length,0.0f,1.75f*length));
	  mesh.setVert(20,Point3(0.75f*length,0.0f,2.0f*length));
      mesh.faces[20].setVerts(9,19,18);
      mesh.faces[20].setEdgeVisFlags(0,1,1);
	  mesh.faces[21].setVerts(9,20,19);
	}
	else
	{ mesh.setNumVerts((norvs=45)+rangeverts);
	  mesh.setNumFaces((norfs=22)+rangefaces);
	  mesh.setVert(0,Point3(length,length,0.0f));
	  mesh.setVert(1,Point3(-length,length,0.0f));
	  mesh.setVert(2,Point3(-length,-length,0.0f));
	  mesh.setVert(3,Point3(length,-length,0.0f));
	  mesh.faces[0].setVerts(0,1,2);
      mesh.faces[0].setEdgeVisFlags(1,1,0);
	  mesh.faces[0].setSmGroup(0);
	  mesh.faces[1].setVerts(0,2,3);
      mesh.faces[1].setEdgeVisFlags(0,1,1);
	  mesh.faces[1].setSmGroup(0);
	  int i,vnum;
	  float r=0.1f*length;
	  Point3 basept=Point3(0.3f*length,0.3f*length,0.5f*length);
	  mesh.setVert(4,basept);
	  mesh.setVert(5,basept+Point3(0.0f,-r,-r));
	  mesh.setVert(6,basept+Point3(0.0f,r,-r));
	  mesh.setVert(7,basept+Point3(r,0.0f,-r));
	  mesh.setVert(8,basept+Point3(-r,0.0f,-r));
	  vnum=9;
	  for (i=4;i<9;i++)
	  { mesh.setVert(vnum,Point3(mesh.verts[i].x,mesh.verts[i].y,-mesh.verts[i].z));
		mesh.setVert(vnum+5,Point3(-mesh.verts[i].x,mesh.verts[i].y,mesh.verts[i].z));
		mesh.setVert(vnum+10,Point3(-mesh.verts[i].x,mesh.verts[i].y,-mesh.verts[i].z));
		mesh.setVert(vnum+15,Point3(mesh.verts[i].x,-mesh.verts[i].y,mesh.verts[i].z));
		mesh.setVert(vnum+20,Point3(mesh.verts[i].x,-mesh.verts[i].y,-mesh.verts[i].z));
		mesh.setVert(vnum+25,Point3(-mesh.verts[i].x,-mesh.verts[i].y,mesh.verts[i].z));
		mesh.setVert(vnum+30,Point3(-mesh.verts[i].x,-mesh.verts[i].y,-mesh.verts[i].z));
		vnum++;
	  }
	  mesh.setVert(44,Point3(0.0f,0.0f,0.0f));
	  int fnum=2;
	  vnum=4;
	  for (i=1;i<9;i++)
	  {	mesh.faces[fnum++].setVerts(vnum,vnum+1,vnum+2);
	    mesh.faces[fnum++].setVerts(vnum,vnum+3,vnum+4);
		vnum+=5;
	  }
	  for (i=2;i<18;i++)
	  { mesh.faces[i].setSmGroup(0);
        mesh.faces[i].setEdgeVisFlags(1,1,1);
	  }
	  for (i=18;i<22;i++)
	  { mesh.faces[i].setSmGroup(0);
        mesh.faces[i].setEdgeVisFlags(0,0,1);
	  }
	  mesh.faces[18].setVerts(4,44,9);
	  mesh.faces[19].setVerts(14,44,19);
	  mesh.faces[20].setVerts(24,44,29);
	  mesh.faces[21].setVerts(34,44,39);
	}
/*	if (dorange && hoops)
	{   int newv;
		pblock->GetValue(PB_DECAY,t,length,ivalid);
		for (int i=0; i<NUM_SEGS2; i++)
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+norvs, Point3((float)cos(u) * length, (float)sin(u) * length, 0.0f));
	    }
		newv=NUM_SEGS2+norvs;
	    for (i=0; i<NUM_SEGS2; i++) 
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+newv, Point3(0.0f, (float)cos(u) * length, (float)sin(u) * length));
	    } newv+=NUM_SEGS2;
	    for (i=0; i<NUM_SEGS2; i++)
	    { u = float(i)/float(NUM_SEGS2) * TWOPI;
		  mesh.setVert(i+newv, Point3((float)cos(u) * length, 0.0f, (float)sin(u) * length));
	    }	
		newv+=NUM_SEGS2;
	    mesh.setVert(newv, Point3(0.0f, 0.0f, 0.0f));
		int vi=norvs;
	    for (i=norfs; i<norfs+rangefaces; i++) 
	    { int i1 = vi+1;
	      if ((i1-norvs)%NUM_SEGS2==0) i1 -= NUM_SEGS2;
	      mesh.faces[i].setEdgeVisFlags(1,0,0);
	      mesh.faces[i].setSmGroup(0);
	      mesh.faces[i].setVerts(vi,i1,newv);
		  vi++;
		}
	}*/

	mesh.InvalidateGeomCache();
}

class PBombObjCreateCallback : public CreateMouseCallBack {
	public:
		PBombObject *ob;	
		Point3 p0, p1;
		IPoint2 sp0;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int PBombObjCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:								
				// if hidden by category, re-display particles and objects
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				break;
			case 1:
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				float x=Length(p1-p0);
				ob->pblock->SetValue(PB_ICONSIZE,0,x);
				ob->pmapParam->Invalidate();
				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) return CREATE_ABORT;
					else return CREATE_STOP;
					}
				break;
			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}
	
	return TRUE;
	}

static PBombObjCreateCallback pbombCreateCB;

CreateMouseCallBack* PBombObject::GetCreateMouseCallBack()
	{
	pbombCreateCB.ob = this;
	return &pbombCreateCB;
	}

void PBombObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

Modifier *PBombObject::CreateWSMMod(INode *node)
	{
	return new PBombMod(node,this);
	}

RefTargetHandle PBombObject::Clone(RemapDir& remap) 
	{
	PBombObject* newob = new PBombObject();
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
	}

ParamDimension *PBombObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_CHAOS:	 return stdPercentDim;
		case PB_ICONSIZE:
		case PB_DECAY:
						return stdWorldDim;
		case PB_STARTTIME:
		case PB_LASTSFOR:
						return stdTimeDim;
		default: return defaultDim;
		}
	}
TSTR PBombObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_SYMMETRY: 	return GetString(IDS_RB_SYMMETRY);
		case PB_CHAOS:		return GetString(IDS_RB_CHAOS);
		case PB_STARTTIME:	return GetString(IDS_RB_STARTTIME);
		case PB_LASTSFOR:	return GetString(IDS_RB_LASTSFOR);
		case PB_DELTA_V:	return GetString(IDS_AP_STRENGTH);
		case PB_DECAY:		return GetString(IDS_RB_DECAY);
		case PB_DECAYTYPE:	return GetString(IDS_RB_DECAYTYPE);
		case PB_ICONSIZE:	return GetString(IDS_RB_ICONSIZE);
		default: 			return TSTR(_T(""));
		}
	}

ParamUIDesc *PBombObject::UIDesc()
	{
	return descParamBomb;
	}

int PBombObject::UIDescLength()
	{
	return BOMBPARAMDESC_LENGTH;
	}

TSTR PBombObject::UIStrName()
	{
	   return GetString(IDS_RB_BOMBPARAM);
	}


PBombMod::PBombMod(INode *node,PBombObject *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);
	seed=12345;
	pblock = NULL;
	obRef = NULL;
	}

Interval PBombMod::GetValidity(TimeValue t) 
	{
	if (nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		((PBombObject*)GetWSMObject(t))->pblock->GetValue(PB_DELTA_V,t,f,valid);
		((PBombObject*)GetWSMObject(t))->pblock->GetValue(PB_DECAY,t,f,valid);
		((PBombObject*)GetWSMObject(t))->pblock->GetValue(PB_ICONSIZE,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class PBombDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static PBombDeformer gdeformer;

Deformer& PBombMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return gdeformer;
	}

RefTargetHandle PBombMod::Clone(RemapDir& remap) 
	{
	PBombMod *newob = new PBombMod(nodeRef,(PBombObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}

void PBombMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
/*		if (!mc.localdata)
		{ mc.localdata=seed; seed+=5;}	  */
		force.obj  = (PBombObject*)GetWSMObject(t);
		force.node = nodeRef;
		force.tmValid.SetEmpty();
		force.fValid.SetEmpty();
		force.dt=GetTicksPerFrame();
		force.dtsq=force.dt*force.dt;
		obj->ApplyForceField(&force);
		}
	}
class BombDrawLineProc:public PolyLineProc {
	GraphicsWindow *gw;
	public:
		BombDrawLineProc() { gw = NULL; }
		BombDrawLineProc(GraphicsWindow *g) { gw = g; }
		int proc(Point3 *p, int n) { gw->polyline(n, p, NULL, NULL, 0, NULL); return 0; }
		int Closed(Point3 *p, int n) { gw->polyline(n, p, NULL, NULL, TRUE, NULL); return 0; }
		void SetLineColor(float r, float g, float b) {gw->setColor(LINE_COLOR,r,g,b);}
		void SetLineColor(Point3 c) {gw->setColor(LINE_COLOR,c);}
		void Marker(Point3 *p,MarkerType type) {gw->marker(p,type);}
	};

static void DrawFalloffSphere(float range, BombDrawLineProc& lp)
{	float u;
	Point3 pt[3],pty[3],ptz[3],first,firsty;
	int nsegs=16;
	
	lp.SetLineColor(GetUIColor(COLOR_END_RANGE));	
	pt[0]=(first= Point3(range,0.0f,0.0f));
	pty[0] =(firsty=Point3(0.0f,range,0.0f));
	ptz[0] = pt[0];
	for (int i=0; i<nsegs; i++)
	{	u = float(i)/float(nsegs) * TWOPI;
		float crange=(float)cos(u)*range,srange=(float)sin(u)*range;
		pt[1]=Point3(crange, srange, 0.0f);
		lp.proc(pt,2); pt[0]=pt[1];
		pty[1]=Point3(0.0f, crange, srange);
		lp.proc(pty,2); pty[0]=pty[1];
		ptz[1]=Point3(crange, 0.0f, srange);
		lp.proc(ptz,2); ptz[0]=ptz[1];
	}
	pt[1]=first;lp.proc(pt,2); 
	pty[1]=firsty;lp.proc(pty,2); 
	ptz[1]=first;lp.proc(ptz,2); 
}
void PBombObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{	Box3 meshBox;
	Matrix3 mat = inode->GetObjectTM(t);
	box.Init();
	int hoopson,dorange;
	pblock->GetValue(PB_RANGEON,t,hoopson,FOREVER);
	pblock->GetValue(PB_DECAYTYPE,0,dorange,FOREVER);
	if ((hoopson)&&(dorange))
	{ float decay; pblock->GetValue(PB_DECAY,t,decay,FOREVER);
	  if (decay>0.0f)
	  {	float range; range=2.0f*decay;
	    Box3 rangeBox(Point3(-range,-range,-range),Point3(range,range,range)); 
		for(int i = 0; i < 8; i++)	box += mat * rangeBox[i];
	  }
	}
	GetLocalBoundBox(t,inode,vpt,meshBox);	
	for(int i = 0; i < 8; i++)
		box += mat * meshBox[i];
}

int PBombObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = &swMtl;
	Matrix3 mat = inode->GetObjectTM(t);
//	UpdateMesh(t);		
 	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER?GW_Z_BUFFER:0) );//removed BC 2/16/99 DB
	gw->setTransform(mat);

	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SPACE_WARPS));
	mesh.render(gw, mtl, NULL, COMP_ALL);
	int dorange,hoopson;
	pblock->GetValue(PB_RANGEON,0,hoopson,FOREVER);
	pblock->GetValue(PB_DECAYTYPE,0,dorange,FOREVER);
	float length;
	if (hoopson && dorange)
	{ pblock->GetValue(PB_DECAY,t,length,FOREVER);
	  float range;
	  range=length;
	  BombDrawLineProc lp(gw);
	  DrawFalloffSphere(range,lp);
	}
	gw->setRndLimits(rlim);
	return(0);
}

Point3 PBombField::Force(TimeValue t,const Point3 &pos, const Point3 &vel,int index)
{	float d,chaos,dv;
	Point3 dlta,xb,yb,zb,center,expv;
	int decaytype,symm;
	Point3 zero=Zero;
		fValid = FOREVER;		
		if (!tmValid.InInterval(t)) 
		{	tmValid = FOREVER;
			tm = node->GetObjectTM(t,&tmValid);
			invtm = Inverse(tm);
		}
		xb=tm.GetRow(0);
		yb=tm.GetRow(1);
		zb=tm.GetRow(2);
		center=tm.GetTrans();
		fValid &= tmValid;
		TimeValue t0,t2,lastsfor;
		obj->pblock->GetValue(PB_STARTTIME,t,t0,fValid);
		obj->pblock->GetValue(PB_LASTSFOR,t,lastsfor,fValid);
		t2=t0+lastsfor;
		dlta=Zero;
		if ((t>=t0)&&(t<=t2))
		{ float L=Length(dlta=pos-center);
		  obj->pblock->GetValue(PB_DECAY,t,d,fValid);
		  obj->pblock->GetValue(PB_DECAYTYPE,t,decaytype,fValid);
		  if ((decaytype==0)||(L<=d))
		  { obj->pblock->GetValue(PB_DELTA_V,t,dv,fValid);
		    obj->pblock->GetValue(PB_CHAOS,t,chaos,fValid);
		    obj->pblock->GetValue(PB_SYMMETRY,t,symm,fValid);
		    Point3 r;
		    if (symm==SPHERE)
		      expv=(r=dlta/L);
	        else if (symm==PLANAR)
		    { L=DotProd(dlta,zb);
			  expv=(L<0.0f?L=-L,-zb:zb);
		    }
		    else
		    { Point3 E;
		      E=DotProd(dlta,xb)*xb+DotProd(dlta,yb)*yb;
		      L=Length(E);
		      expv=E/L;
		    }
		    dlta=(dv*expv)/(float)dtsq;
			if (decaytype==1)
			 dlta*=(d-L)/d;
			else if (decaytype==2)
			 dlta*=(1/(float)exp(L/d));
			if ((!FloatEQ0(chaos))&&(lastsfor==0.0f))
			{ float theta;
			  theta=HalfPI*chaos*RND01();
			  Point3 d=Point3(RND11(),RND11(),RND11());
			  Point3 c=Normalize(dlta^d);
			  RotateOnePoint(&dlta.x,&zero.x,&c.x,theta);
			}
		  }	else dlta=Zero; 
		}
	return dlta;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\pfollow.cpp ===
/**********************************************************************
 *<
	FILE: pathfollow.cpp

	DESCRIPTION: A simple path follow object for particles

	CREATED BY: Audrey Peterson

	HISTORY: 12/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "suprprts.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"
#include "spline3d.h"

#define PBLK		0
#define CUSTNODE 		1
#define DU 0.001f
static Class_ID PFOLLOW_CLASS_ID(0x7ab83ab5, 0x5e1d34bd);
static Class_ID PFOLLOWMOD_CLASS_ID(0x263e723d, 0x132724e5);

class PFollowPickOperand;

typedef struct {
  BOOL found;
  BOOL FoundOnceAlready;
  Point3 StartPoint;
  Point3 TraverseVector;

//  BOOL donewith;
  TimeValue Tc,Tt;
  Point3 R,TTT1;
  float TChaos,SChaos;
} pathplist;

class PFollowData : public LocalModData {
public:
	Tab<pathplist> psaved;
	int lastseed;
	TimeValue lasttime;
	PFollowData();
	~PFollowData();
	LocalModData *Clone();
};

PFollowData::PFollowData() 
{	psaved.SetCount(0);
//	psaved[0].found=FALSE;
}

PFollowData::~PFollowData() 
{	psaved.Resize(0);
}

LocalModData *PFollowData::Clone () 
{	PFollowData *clone;
	clone = new PFollowData();
	clone->lastseed=lastseed;
	clone->psaved.SetCount(psaved.Count());
	for (int i=0;i<psaved.Count();i++)
	{ clone->psaved=psaved;}
	return(clone);
}

class PFollowObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		static HWND hParams;
		BOOL reset;
					
		INode *custnode;
		TSTR custname;
		PFollowObject();
		~PFollowObject();
		static BOOL creating;
		static PFollowPickOperand pickCB;

		void ShowName();
		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		Class_ID ClassID() {return PFOLLOW_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_PFOLLOWOBJ);}
		void MapKeys(TimeMap *map,DWORD flags);
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
	};
class PFollowPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		PFollowObject *po;
		
		PFollowPickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *PFollowObject::ip        = NULL;
IParamMap *PFollowObject::pmapParam = NULL;
HWND       PFollowObject::hSot      = NULL;
HWND       PFollowObject::hParams      = NULL;
BOOL PFollowObject::creating    = FALSE;
PFollowPickOperand PFollowObject::pickCB;

class PFollowClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new PFollowObject;}
	const TCHAR *	ClassName() {return GetString(IDS_AP_PFOLLOW);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return PFOLLOW_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_PARTICLES);}
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};
static PFollowClassDesc PFollowDesc;
ClassDesc* GetPFollowDesc() {return &PFollowDesc;}

//--- DeflectMod -----------------------------------------------------

class PFollowField : public CollisionObject {
	public:		
		PFollowObject *obj;
		ParticleObject *partobj;
		INode *node,*pnode;
		Object *pobj;
		Matrix3 tm,ptm;
		Interval tmValid,mValid;
		PFollowData *pd;
		ShapeObject *pathOb;
		int badmesh;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt,int index,float *ct,BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class PFollowMod : public SimpleWSMMod {
	public:				
		PFollowField deflect;

		PFollowMod() {}
		PFollowMod(INode *node,PFollowObject *obj);	


		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_AP_PFOLLOWMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return PFOLLOWMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_PATHFOLLOWBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class PFollowModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new PFollowMod;}
	const TCHAR *	ClassName() {return GetString(IDS_AP_PFOLLOWMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return PFOLLOWMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static PFollowModClassDesc PFollowModDesc;
ClassDesc* GetPFollowModDesc() {return &PFollowModDesc;}
//--- SphereDefObject Parameter map/block descriptors ------------------

#define PB_LIMITRANGE	0
#define PB_RANGEDIST	1
#define PB_SPLINETYPE	2
#define PB_TANGCHAOS	3
#define PB_TANGCHAOSVAR	4
#define PB_TANGDIR		5
#define PB_SPIRCHAOS	6
#define PB_SPIRCHAOSVAR	7
#define PB_SPIRALDIR	8
#define PB_TIMESTART	9
#define PB_TIMETRAVEL	10
#define PB_TIMETRAVVAR	11
#define PB_TIMESTOP		12
#define PB_ICONSIZE		13
#define PB_SEED			14
#define PB_KSPEED		15

//Radio buttons
static int splinetypeIDs[] = {IDC_AP_SPLINEOFFSET,IDC_AP_SPLINEPARALLEL};
#define OFFSET 0
#define PARALLEL 1
static int tangenttypeIDs[] = {IDC_AP_PATHTANIN,IDC_AP_PATHTANOUT,IDC_AP_PATHTANBOTH};
#define CONTRACT 0
#define BOTH 2
static int spiraltypeIDs[] = {IDC_AP_PATHCW,IDC_AP_PATHCCW,IDC_AP_PATHBIDIR};
#define CCW 1
#define BIDIR 2

//Dialogs
static ParamUIDesc descParam[] = {

	// Range Limit On
	ParamUIDesc(PB_LIMITRANGE,TYPE_SINGLECHEKBOX,IDC_AP_RANGELIMITON),

	// Range Distance	
	ParamUIDesc(
		PB_RANGEDIST,
		EDITTYPE_UNIVERSE,
		IDC_AP_RANGELIMIT,IDC_AP_RANGELIMITSPIN,
		0.0f, 9999999.0f,
		0.01f),
	
	// Spline type radio buttons
	ParamUIDesc(PB_SPLINETYPE,TYPE_RADIO,splinetypeIDs,2),
	
	// Range Limit On
	ParamUIDesc(PB_KSPEED,TYPE_SINGLECHEKBOX,IDC_AP_CONSTSPEED),

	// Tangent Chaos
	ParamUIDesc(
		PB_TANGCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSTAN,IDC_AP_CHAOSTANSPIN,
		0.0f,99.0f,
		1.0f,
		stdPercentDim),

	// Tangent Chaos Var
	ParamUIDesc(
		PB_TANGCHAOSVAR,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSTANVAR,IDC_AP_CHAOSTANVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Tangent type radio buttons
	ParamUIDesc(PB_TANGDIR,TYPE_RADIO,tangenttypeIDs,3),

	// Spiral Chaos
	ParamUIDesc(
		PB_SPIRCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSPIRAL,IDC_AP_CHAOSSPIRALSPIN,
		0.0f,99999.0f,
		0.01f),

	// Spiral Chaos Var
	ParamUIDesc(
		PB_SPIRCHAOSVAR,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSPIRALVAR,IDC_AP_CHAOSSPIRALVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Spiral type radio buttons
	ParamUIDesc(PB_SPIRALDIR,TYPE_RADIO,spiraltypeIDs,3),

	// Start time
	ParamUIDesc(
		PB_TIMESTART,
		EDITTYPE_TIME,
		IDC_AP_CAPTURETIME,IDC_AP_CAPTURETIMESPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Travel time
	ParamUIDesc(
		PB_TIMETRAVEL,
		EDITTYPE_TIME,
		IDC_AP_TRAVELTIME,IDC_AP_TRAVELTIMESPIN,
		0.0f,999999999.0f,
		10.0f),

	// Travel Time Var
	ParamUIDesc(
		PB_TIMETRAVVAR,
		EDITTYPE_FLOAT,
		IDC_AP_SPEEDVAR,IDC_AP_SPEEDVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Last Frame
	ParamUIDesc(
		PB_TIMESTOP,
		EDITTYPE_TIME,
		IDC_AP_LASTFRAME,IDC_AP_LASTFRAMESPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Seed
	ParamUIDesc(
		PB_SEED,
		EDITTYPE_INT,
		IDC_AP_SEED,IDC_AP_SEEDSPIN,
		0.0f,25000.0f,
		1.0f),

	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_UNIVERSE,
		IDC_AP_ICONSIZE,IDC_AP_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	};

#define PARAMDESC_LENGTH	16

#define CURRENT_VERSION	0

ParamBlockDescID PFollowdescVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//Limit Range
	{ TYPE_FLOAT, NULL, TRUE, 1 },	//Range Dist
	{ TYPE_INT, NULL, FALSE, 2 },	//Spline Type
	{ TYPE_FLOAT, NULL, FALSE, 3 },	//Tang Chaos
	{ TYPE_FLOAT, NULL, FALSE, 4 },	//Tang Chaos Var
	{ TYPE_INT, NULL, FALSE, 5 },	//Tang Dir
	{ TYPE_FLOAT, NULL, FALSE, 6 },	//Spiral Chaos
	{ TYPE_FLOAT, NULL, FALSE, 7 },	//Spiral Chaos Var
	{ TYPE_INT, NULL, FALSE, 8 },	//Spiral Dir
	{ TYPE_INT, NULL, FALSE, 9 },	//Time Start
	{ TYPE_INT, NULL, FALSE, 10 },	//Time Travel
	{ TYPE_FLOAT, NULL, FALSE, 11 }, //Time Travel Var
	{ TYPE_INT, NULL, FALSE, 12 },  //Last Frame
	{ TYPE_FLOAT, NULL, FALSE, 13 },  //Icon Size
	{ TYPE_INT, NULL, FALSE, 14 },  //Seed
	{ TYPE_INT, NULL, FALSE, 15 },  //Speed flag
};

#define PBLOCK_PFLENGTH	16

#define CURRENT_VERSION	0

class CreatePFollowObjectProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *PFollowNode;
		PFollowObject *PFollowObj;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square,dostuff;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)PFollowNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { PFollowNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreatePFollowObjectProc()
			{
			ignoreSelectionChange = FALSE;
			}
		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_CREATEPFollowObjectMODE	CID_USER + 15

class CreatePFollowObjectMode : public CommandMode {		
	public:		
		CreatePFollowObjectProc proc;
		IObjParam *ip;
		PFollowObject *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,PFollowObject*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEPFollowObjectMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreatePFollowObjectMode theCreatePFollowObjectMode;

RefResult CreatePFollowObjectProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( PFollowObj && PFollowNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (PFollowObj && PFollowNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (PFollowObj->creating) 
						{  theCreatePFollowObjectMode.JumpStart(PFollowObj->ip,PFollowObj);
							createInterface->SetCommandMode(&theCreatePFollowObjectMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				PFollowObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				PFollowObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				PFollowObj  = NULL;				
				PFollowNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreatePFollowObjectProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	PFollowNode         = NULL;
	PFollowObj       = NULL;
	dostuff=0;
	CreateNewObject();
	}
void CreatePFollowObjectProc::CreateNewObject()
	{
	PFollowObj = (PFollowObject*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
	// Start the edit params process
	if ( PFollowObj ) {
		PFollowObj->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		PFollowObj->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreatePFollowObjectProc::End()
{ if ( PFollowObj ) 
	{
 #ifdef _OSNAP
		PFollowObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif

	PFollowObj->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete PFollowObj;
			PFollowObj = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		} 
 else if ( PFollowNode ) {
			 // Get rid of the reference.
			theHold.Suspend();
			DeleteReference(0);  // sets camNode = NULL
			theHold.Resume();
			}
	}
}

void CreatePFollowObjectMode::JumpStart(IObjParam *i,PFollowObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int PFollowClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreatePFollowObjectMode.Begin(iob,this);
	iob->PushCommandMode(&theCreatePFollowObjectMode);
	return TRUE;
	}

int PFollowClassDesc::EndCreate(Interface *i)
	{
	theCreatePFollowObjectMode.End();
	i->RemoveMode(&theCreatePFollowObjectMode);
	return TRUE;
	}

int CreatePFollowObjectProc::createmethod(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{	Point3 d;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				PFollowObj->pblock->SetValue(PB_ICONSIZE,0,0.01f);
				PFollowObj->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				PFollowObj->pblock->SetValue(PB_ICONSIZE,0,Length(p1-p0));
				PFollowObj->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
	}

int CreatePFollowObjectProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif
	if (!dostuff)
	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( PFollowObj );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
#ifdef _OSNAP
						PFollowObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				   		// send this one on its way
				   		PFollowObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						if (PFollowNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}

						// new object
						CreateNewObject();   // creates PFollowObj
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					PFollowNode = createInterface->CreateObjectNode( PFollowObj);
					attachedToNode = TRUE;
					assert( PFollowNode );					
					createCB = NULL;
					createInterface->SelectNode( PFollowNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, PFollowNode);
					theHold.Resume();
					mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));
					createInterface->SetNodeTMRelConstPlane(PFollowNode, mat);
					dostuff=1;
					res = TRUE;
					break;
					
				}			
			break;

		case MOUSE_MOVE:
			//mat[3] = vpx->GetPointOnCP(m);
			mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));
			createInterface->RedrawViews(createInterface->GetTime());	   
			res = TRUE;
			break;

		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP  //PREVIEW SNAP
				res = createmethod(vpx,msg,point,flag,m,mat);
#endif
		vpx->TrackImplicitGrid(m);
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: goto abort;
		}
	int result; 
	if (dostuff)
	{ result=createmethod(vpx,msg,point,flag,m,mat);
	  createInterface->RedrawViews(createInterface->GetTime()); 
	  if (result==CREATE_STOP)
	  { res=FALSE;dostuff=0;				
#ifdef _OSNAP
         PFollowObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	  theHold.Accept(GetString(IDS_DS_CREATE));	} 
	  else if (result==CREATE_ABORT)
	  { dostuff=0;
	    goto abort;}
	}
	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
	abort:
		assert( PFollowObj );
#ifdef _OSNAP
		PFollowObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		PFollowObj->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the object and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);
		PFollowNode = NULL;			
		createInterface->RedrawViews(createInterface->GetTime()); 
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		goto done;
	}
static BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

BOOL PFollowPickOperand::Filter(INode *node)
	{
	if (node)
	{ ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
	  if (os.obj->SuperClassID() != SHAPE_CLASS_ID) 
	  {		node = NULL;
			return FALSE;
	  }
	node->BeginDependencyTest();
	po->NotifyDependents (FOREVER, 0, REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) return FALSE;

	}
	return node ? TRUE : FALSE;
	}

BOOL PFollowPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		if (os.obj->SuperClassID() != SHAPE_CLASS_ID)
		{	node = NULL;
			return FALSE;
			}
	node->BeginDependencyTest();
	po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) return FALSE;
	}
	return node ? TRUE : FALSE;
	}

void PFollowObject::ShowName()
{TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (custnode ? custname : TSTR(GetString(IDS_AP_NONE)));
SetWindowText(GetDlgItem(hParams, IDC_SP_PATHNAME), name);
}

BOOL PFollowPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	nodes.SetCount(1);nodes[0]=node;
	ip->FlashNodes(&nodes);
	if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	po->custname = TSTR(node->GetName());
	// Automatically check show result and do one update
	po->ShowName();	
	if (po->creating) {
		theCreatePFollowObjectMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreatePFollowObjectMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void PFollowPickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SP_PATHNAMEPICK));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
	}

void PFollowPickOperand::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_SP_PATHNAMEPICK));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
	}
class PFollowObjectDlgProc : public ParamMapUserDlgProc {
	public:
		PFollowObject *po;

		PFollowObjectDlgProc(PFollowObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};
void PFollowObjectDlgProc::Update(TimeValue t)
{	po->ShowName();
	int ron;
	po->pblock->GetValue(PB_LIMITRANGE,0,ron,FOREVER);
	if (ron) SpinnerOff(po->hParams,IDC_AP_RANGELIMITSPIN,IDC_AP_RANGELIMIT);
	else SpinnerOn(po->hParams,IDC_AP_RANGELIMITSPIN,IDC_AP_RANGELIMIT);
	float size;
	po->pblock->GetValue(PB_ICONSIZE,0,size,FOREVER);
	TurnButton(po->hParams,IDC_SP_PATHNAMEPICK,(size>=0.01f));
}

BOOL PFollowObjectDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_SP_PATHNAMEPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(iBut);
			po->hParams=hWnd;
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SP_PATHNAMEPICK:
				   { if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreatePFollowObjectMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePFollowObjectMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;						
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
			case IDC_AP_RANGELIMITON:
				int ron;
				po->pblock->GetValue(PB_LIMITRANGE,0,ron,FOREVER);
				if (ron) SpinnerOff(hWnd,IDC_AP_RANGELIMITSPIN,IDC_AP_RANGELIMIT);
				else SpinnerOn(hWnd,IDC_AP_RANGELIMITSPIN,IDC_AP_RANGELIMIT);
				break;
			}
			break;	
		}
	return TRUE;
	}

PFollowObject::PFollowObject()
	{ TimeValue tpf=GetTicksPerFrame();
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(PFollowdescVer0, PBLOCK_PFLENGTH, CURRENT_VERSION));
	assert(pblock);	
	reset=FALSE;

	pblock->SetValue(PB_LIMITRANGE,0,1);
	pblock->SetValue(PB_RANGEDIST,0,100.0f);
	pblock->SetValue(PB_SPLINETYPE,0,1);
	pblock->SetValue(PB_TANGCHAOS,0,0.0f);
	pblock->SetValue(PB_TANGCHAOSVAR,0,0.0f);
	pblock->SetValue(PB_TANGDIR,0,0);
	pblock->SetValue(PB_SPIRCHAOS,0,0.0f);
	pblock->SetValue(PB_SPIRCHAOSVAR,0,0.0f);
	pblock->SetValue(PB_SPIRALDIR,0,0);
	pblock->SetValue(PB_TIMESTART,0,0);
	pblock->SetValue(PB_TIMETRAVEL,0,30*tpf);
	pblock->SetValue(PB_TIMETRAVVAR,0,0.0f);
	pblock->SetValue(PB_TIMESTOP,0,100*tpf);
	pblock->SetValue(PB_ICONSIZE,0,0.0f);
	pblock->SetValue(PB_SEED,0,12345);
	pblock->SetValue(PB_KSPEED,0,0);
	srand(12345);
	custname=TSTR(_T(" "));
	custnode=NULL;
	}

PFollowObject::~PFollowObject()
{  DeleteAllRefsFromMe();
	pblock=NULL;
}
Modifier *PFollowObject::CreateWSMMod(INode *node)
	{
	return new PFollowMod(node,this);
	}

RefTargetHandle PFollowObject::Clone(RemapDir& remap) 
	{
	PFollowObject* newob = new PFollowObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	newob->custname=custname;
	return newob;
	}

void PFollowObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
{	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC),
			DefaultSOTProc,
			GetString(IDS_RB_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SW_PATHFOLLOW),
			GetString(IDS_RB_PARAMETERS),
			0);
		}
		if (pmapParam)
			pmapParam->SetUserDlgProc(new PFollowObjectDlgProc(this));
	}

void PFollowObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
	}

void PFollowObject::MapKeys(TimeMap *map,DWORD flags)
{	TimeValue TempTime;
	pblock->GetValue(PB_TIMESTART,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMESTART,0,TempTime);
	pblock->GetValue(PB_TIMETRAVEL,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMETRAVEL,0,TempTime);
	pblock->GetValue(PB_TIMESTOP,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMESTOP,0,TempTime);
}

void PFollowObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float width;
	pblock->GetValue(PB_ICONSIZE,t,width,ivalid);
//	width  *= 0.5f;

	mesh.setNumVerts(45); //9+9*4
	mesh.setNumFaces(28); //12+16
	mesh.setVert(0, Point3(-width,-width, width));
	mesh.setVert(1, Point3( width,-width, width));
	mesh.setVert(2, Point3( width, width, width));
	mesh.setVert(3, Point3(-width, width, width));
	mesh.setVert(4, Point3(-width,-width, -width));
	mesh.setVert(5, Point3( width,-width, -width));
	mesh.setVert(6, Point3( width, width, -width));
	mesh.setVert(7, Point3(-width, width, -width));
	mesh.setVert(8, Point3(0,0,0));

	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[0].setSmGroup(0);
	mesh.faces[0].setVerts(0,1,3);

	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(0);
	mesh.faces[1].setVerts(1,2,3);

	mesh.faces[2].setEdgeVisFlags(1,1,0);
	mesh.faces[2].setSmGroup(0);
	mesh.faces[2].setVerts(1,0,4);

	mesh.faces[3].setEdgeVisFlags(1,0,1);
	mesh.faces[3].setSmGroup(0);
	mesh.faces[3].setVerts(5,1,4);

	mesh.faces[4].setEdgeVisFlags(0,1,1);
	mesh.faces[4].setSmGroup(0);
	mesh.faces[4].setVerts(5,2,1);

	mesh.faces[5].setEdgeVisFlags(1,1,0);
	mesh.faces[5].setSmGroup(0);
	mesh.faces[5].setVerts(5,6,2);

	mesh.faces[6].setEdgeVisFlags(1,0,1);
	mesh.faces[6].setSmGroup(0);
	mesh.faces[6].setVerts(2,6,3);

	mesh.faces[7].setEdgeVisFlags(1,1,0);
	mesh.faces[7].setSmGroup(0);
	mesh.faces[7].setVerts(6,7,3);

	mesh.faces[8].setEdgeVisFlags(1,1,0);
	mesh.faces[8].setSmGroup(0);
	mesh.faces[8].setVerts(0,3,7);

	mesh.faces[9].setEdgeVisFlags(1,0,1);
	mesh.faces[9].setSmGroup(0);
	mesh.faces[9].setVerts(4,0,7);

	mesh.faces[10].setEdgeVisFlags(0,1,1);
	mesh.faces[10].setSmGroup(0);
	mesh.faces[10].setVerts(6,4,7);

	mesh.faces[11].setEdgeVisFlags(1,1,0);
	mesh.faces[11].setSmGroup(0);
	mesh.faces[11].setVerts(6,5,4);
	Point3 basept[4];
	basept[0]=Point3(0.0f,0.0f,0.0f);
	basept[1]=Point3(0.0f,-0.8f*width,-0.8f*width);
	basept[2]=Point3(0.0f,-0.5f*width,0.4f*width);
	basept[3]=Point3(0.0f,0.6f*width,0.1f*width);
	float r1=0.1f*width,r2=0.2f*width,r3=0.3f*width,r4=0.4f*width;
	float r6=0.6f*width,r8=0.8f*width,r25=0.25f*width;
	int nv=9,fc=12,bnv;
	for (int i=0;i<4;i++)
	{ bnv=nv;
	  mesh.setVert(nv++, Point3(-width,0.0f,0.0f)+basept[i]);
	  mesh.setVert(nv++, Point3(-r8,r1,0.0f)+basept[i]);
	  mesh.setVert(nv++, Point3(-r6,r1,0.0f)+basept[i]);
	  mesh.setVert(nv++, Point3(-r2,r3,r2)+basept[i]);
	  mesh.setVert(nv++, Point3(0.0f,r3,r2)+basept[i]);
	  mesh.setVert(nv++, Point3(r4,r1,r3)+basept[i]);
	  mesh.setVert(nv++, Point3(r6,r1,r3)+basept[i]);
	  mesh.setVert(nv++, Point3(r8,r2,r25)+basept[i]);
	  mesh.setVert(nv++, Point3(width,r3,r2)+basept[i]);
	  mesh.faces[fc].setVerts(bnv,bnv+2,bnv+1);
	  mesh.faces[fc].setEdgeVisFlags(0,1,1);
	  mesh.faces[fc++].setSmGroup(0);
	  mesh.faces[fc].setVerts(bnv+2,bnv+4,bnv+3);
	  mesh.faces[fc].setEdgeVisFlags(0,1,1);
	  mesh.faces[fc++].setSmGroup(0);
	  mesh.faces[fc].setVerts(bnv+4,bnv+5,bnv+6);
	  mesh.faces[fc].setEdgeVisFlags(1,1,0);
	  mesh.faces[fc++].setSmGroup(0);
	  mesh.faces[fc].setVerts(bnv+6,bnv+7,bnv+8);
	  mesh.faces[fc].setEdgeVisFlags(1,1,0);
	  mesh.faces[fc++].setSmGroup(0);
	}
	mesh.InvalidateGeomCache();
}

void PFollowObject::InvalidateUI() 
{
	if (pmapParam) pmapParam->Invalidate();

}

ParamDimension *PFollowObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_TANGCHAOS:
		case PB_TIMETRAVVAR:
				 return stdPercentDim;
		case PB_TIMESTART:
		case PB_TIMETRAVEL:
		case PB_TIMESTOP:
				 return stdTimeDim;
		case PB_ICONSIZE:
		case PB_RANGEDIST:
				return stdWorldDim;
		default: return defaultDim;
		}
	}

TSTR PFollowObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_KSPEED		: 	return GetString(IDS_AP_KSPEED);
		case PB_LIMITRANGE: 	return GetString(IDS_AP_RANGEON);
		case PB_RANGEDIST:		return GetString(IDS_AP_RANGE);
		case PB_SPLINETYPE:		return GetString(IDS_AP_SPLINETYPE);
		case PB_TANGCHAOS:		return GetString(IDS_AP_TANGCHAOS);
		case PB_TANGCHAOSVAR:	return GetString(IDS_AP_TANGCHAOSVAR);
		case PB_TANGDIR:		return GetString(IDS_AP_TANGENTDIR);
		case PB_SPIRCHAOS:		return GetString(IDS_AP_SPIRCHAOS);
		case PB_SPIRCHAOSVAR:	return GetString(IDS_AP_SPIRCHAOSVAR);
		case PB_SPIRALDIR:		return GetString(IDS_AP_SPIRALDIR);
		case PB_TIMESTART:		return GetString(IDS_AP_TIMESTART);
		case PB_TIMETRAVEL:		return GetString(IDS_AP_TIMETRAVEL);
		case PB_TIMETRAVVAR:	return GetString(IDS_AP_TRAVELVAR);
		case PB_TIMESTOP:		return GetString(IDS_AP_TIMESTOP);
		case PB_ICONSIZE:		return GetString(IDS_AP_ICONSIZE);
		default: 			return TSTR(_T(""));
		}
	}

//--- DeflectMod methods -----------------------------------------------

PFollowMod::PFollowMod(INode *node,PFollowObject *obj)
	{	
//	MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef=NULL;
	}

Interval PFollowMod::GetValidity(TimeValue t) 
{ 	if (obRef && nodeRef)
	{	Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		PFollowObject *obj = (PFollowObject*)GetWSMObject(t);
		obj->pblock->GetValue(PB_RANGEDIST,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {return FOREVER;	}
}

class PFollowDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static PFollowDeformer PFollowdeformer;

Deformer& PFollowMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return PFollowdeformer;
	}

RefTargetHandle PFollowMod::Clone(RemapDir& remap) 
	{
	PFollowMod *newob = new PFollowMod(nodeRef,(PFollowObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}

void PFollowMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (deflect.partobj=obj) {
		deflect.obj  = (PFollowObject*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.pnode=deflect.obj->custnode;
		deflect.tmValid.SetEmpty();		
		deflect.mValid.SetEmpty();
		deflect.badmesh=(deflect.obj->custnode==NULL);
		deflect.pobj=NULL;
//		if ((t==0)&&(mc.localData!= NULL))	
//		{  delete mc.localData;mc.localData=NULL;	}
		int starttime;
		deflect.obj->pblock->GetValue(PB_TIMESTART,t,starttime,FOREVER);
		if ( ((t==starttime)||(deflect.obj->reset)) && (mc.localData!=NULL)) 
		{  delete mc.localData;mc.localData=NULL;	}
		if (mc.localData == NULL)
		{ mc.localData = new PFollowData;
		  int seed;
		  deflect.obj->pblock->GetValue(PB_SEED,t,seed,FOREVER);
		  deflect.pd = (PFollowData *) mc.localData;
		  deflect.pd->lastseed=seed;
		  deflect.pd->lasttime=t;
		} else 
		 deflect.pd = (PFollowData *) mc.localData;
		obj->ApplyCollisionObject(&deflect);
		}
	}
static ShapeObject *IsUseable(Object *pobj,TimeValue t)
{ 
  if (pobj->IsShapeObject())
    return (ShapeObject*)pobj;
  else return NULL;
}

Object *PFollowField::GetSWObject()
{ return obj;
}

BOOL PFollowField::CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt,int index,float *ct,BOOL UpdatePastCollide)
{	Point3 invel = vel;
	int achange = 0; // what does this do??

	int starttime,stoptime;
	obj->pblock->GetValue(PB_TIMESTART,t,starttime,FOREVER);
	obj->pblock->GetValue(PB_TIMESTOP,t,stoptime,FOREVER);

// if we're backing up and have particles saved, nuke database
	if ((pd->psaved.Count()>0)&&(pd->lasttime>t))
	{	pd->psaved.Resize(0);
	    if (obj->reset) obj->reset=FALSE;
	}

	pd->lasttime=t; // set the last time to this time

	if ((badmesh)||(t<starttime))
		return FALSE; // if there's no spline, or this is too early, do squat

// if we've changed the controls, start over
	if (obj->reset)
	{	pd->psaved.SetCount(0);
		obj->reset=FALSE;
	}

// if we're here for the first time init randomizer
	if (pd->psaved.Count()<1)
	{	int seed;
		obj->pblock->GetValue(PB_SEED,t,seed,FOREVER);
		pd->lastseed = seed;
	}

/*
// this was the old attempt to save the random number
	if (pd->lasttime>t) 
	{	int seed;
		obj->pblock->GetValue(PB_SEED,t,seed,FOREVER);
		pd->lastseed=seed;
	}
*/

	if (!((mValid.InInterval(t))&&(tmValid.InInterval(t))))
	{	tmValid = FOREVER;
		tm = pnode->GetObjectTM(t,&tmValid);
		pobj = pnode->EvalWorldState(t).obj;
		mValid = pobj->ObjectValidity(t);
		badmesh = (badmesh||((pathOb=IsUseable(pobj,t))==NULL));
//		srand(pd->lastseed);
 	}

	if (badmesh) 
		return FALSE;

	if (pd->psaved.Count()>index)
		if (pd->psaved[index].found)
			if (pd->psaved[index].Tc>t)
				return FALSE;

	int splinetype;
 	obj->pblock->GetValue(PB_SPLINETYPE,t,splinetype,FOREVER);

	int limitr;
	obj->pblock->GetValue(PB_LIMITRANGE,t,limitr,FOREVER);

	if (t<=stoptime) // we're in the window

// do this if we haven't seen the particle yet, if the particle is out of range, or if the particle is new
	{	if ((pd->psaved.Count()<=index)||(!pd->psaved[index].found)||(partobj->ParticleAge(t,index)==0))
		{	
		
			Point3 firstpt = pathOb->InterpCurve3D(t,0,0.0f)*tm;
			Point3 R = pos - firstpt;
			float maxrange;
			int traveltime;
			obj->pblock->GetValue(PB_RANGEDIST,t,maxrange,FOREVER);
			if (!limitr && (Length(R)>maxrange)) // if the particle is out of range, abort
				return FALSE;

			int anum = pd->psaved.Count();

			if (anum>index)
				if (!pd->psaved[index].FoundOnceAlready)
					pd->psaved[index].StartPoint = pos;

			if (anum<=index)
			{	pd->psaved.Resize(index+1);
				pd->psaved.SetCount(index+1);
				for (int newnum=anum;newnum<=index;newnum++)  // this sets notfound for all unknown but presupposed particles
				{	pd->psaved[newnum].found = FALSE;
					pd->psaved[newnum].FoundOnceAlready = FALSE;
				}
				pd->psaved[index].StartPoint = pos;
			}

			pd->psaved[index].found = TRUE;

			if (!pd->psaved[index].FoundOnceAlready)
			{	
				float traveltimevar,tangchaos,tangchaosvar,spiralchaos,spiralchaosvar;
				int tdir,sdir;
				obj->pblock->GetValue(PB_TANGCHAOS,t,tangchaos,FOREVER);
				obj->pblock->GetValue(PB_TANGCHAOSVAR,t,tangchaosvar,FOREVER);
				obj->pblock->GetValue(PB_TANGDIR,t,tdir,FOREVER);
				obj->pblock->GetValue(PB_SPIRCHAOS,t,spiralchaos,FOREVER);
				obj->pblock->GetValue(PB_SPIRCHAOSVAR,t,spiralchaosvar,FOREVER);
				obj->pblock->GetValue(PB_SPIRALDIR,t,sdir,FOREVER);
				obj->pblock->GetValue(PB_TIMETRAVEL,t,traveltime,FOREVER);
 				obj->pblock->GetValue(PB_TIMETRAVVAR,t,traveltimevar,FOREVER);

				if (splinetype==OFFSET) 
				{	Point3 TT1,TTT1,T1 = Normalize(pathOb->InterpCurve3D(t, 0, DU)*tm-firstpt);
					pd->psaved[index].TTT1 = (TTT1=Normalize(T1^R));
					TT1 = Normalize(TTT1^T1);
					Matrix4By4 weyw,invweyw;
					weyw[0][0] = T1.x;
					weyw[1][0] = T1.y;
					weyw[2][0] = T1.z;
					weyw[3][0] = 0.0f;
					weyw[0][1] = TT1.x;
					weyw[1][1] = TT1.y;
					weyw[2][1] = TT1.z;
					weyw[3][1] = 0.0f;
					weyw[0][2] = TTT1.x;
					weyw[1][2] = TTT1.y;
					weyw[2][2] = TTT1.z;
					weyw[3][2] = 0.0f;
					weyw[0][3] = firstpt.x;
					weyw[1][3] = firstpt.y;
					weyw[2][3] = firstpt.z;
					weyw[3][3] = 1.0f;
					float aR[4],pout[4];
					MatrixInvert(weyw,invweyw);
					aR[0] = pos.x;
					aR[1] = pos.y;
					aR[2] = pos.z;
					aR[3] = 1.0f;
					Mult4X1(aR,invweyw,pout);
					R.x = pout[0];
					R.y = pout[1];
					R.z = pout[2];
				}

				pd->psaved[index].R = R;
				pd->psaved[index].Tc = t;

				srand(pd->lastseed); // encapsulated around all the RNDs is the save/restore of the randomizer

				if (tdir==CONTRACT) 
					tangchaos = -tangchaos;
				else if (tdir==BOTH) 
					tangchaos *= RNDSign();
				pd->psaved[index].TChaos = tangchaos*(1.0f-RND01()*tangchaosvar);
				if (sdir==CCW) 
					spiralchaos = -spiralchaos;
				else if (sdir==BIDIR) 
					spiralchaos *= RNDSign();
				pd->psaved[index].SChaos = spiralchaos*(1.0f-RND01()*spiralchaosvar);
				pd->psaved[index].Tt = (int)(traveltime*(1.0f+RND11()*traveltimevar));

				pd->lastseed = rand(); // this saves the random sequence for capturing particles
			}
		}
	}
	else // do this if the particle is nonfound and we're too late to capture it
	{	if ((pd->psaved.Count()<=index)||(!pd->psaved[index].found)) 
			return FALSE;
	}

	TimeValue	intime = t,
				endtime = pd->psaved[index].Tc + pd->psaved[index].Tt,
				difftime;

	int timeloops = 0;

	if ((pd->psaved[index].FoundOnceAlready)&&(t>endtime))
	{	timeloops++;
		difftime = t - endtime;
		while (difftime > pd->psaved[index].Tt)
		{	timeloops++;
			difftime -= pd->psaved[index].Tt;
		}
	}

	if (t>stoptime) 
		endtime = stoptime;

	BOOL lettinggo = (t>=endtime),
		 done=FALSE;
	int tpf=GetTicksPerFrame();
	if (lettinggo) 
		t = endtime - tpf;

	float u;
	int KeepSpeedAlongSpline;

// here begins the maintenance update loop
	while (!done)
	{	if (timeloops < 1)
			u = (float)(tpf + t - pd->psaved[index].Tc) / (float)pd->psaved[index].Tt;
		else
			u = (float)(tpf + difftime) / (float)pd->psaved[index].Tt;

		if (u>1.0f) 
			u = 1.0f;

 		obj->pblock->GetValue(PB_KSPEED,t,KeepSpeedAlongSpline,FOREVER);
		Point3 Sut = pathOb->InterpCurve3D(t,0,u,KeepSpeedAlongSpline)*tm;

//for parallel splines we go here
		if (splinetype==PARALLEL)
		{	Point3 Rnow = pd->psaved[index].R*(1.0f+u*pd->psaved[index].TChaos);
			Point3 PTemp = Sut + Rnow;
			if (pd->psaved[index].SChaos!=0.0f)
			{	Point3 T1 = Normalize(pathOb->InterpCurve3D(t, 0, DU)*tm-pathOb->InterpCurve3D(t,0,0.0f,KeepSpeedAlongSpline)*tm);
				float Thetanow = TWOPI*pd->psaved[index].SChaos*u;
				RotateOnePoint(&PTemp.x,&Sut.x,&T1.x,Thetanow);
			}
			pos = PTemp;
		}
//for offset splines we go here
		else 
		{	float cu;
			Point3 Tt = Normalize(pathOb->InterpCurve3D(t,0,((cu=u+DU)>1.0f?1.0f:cu),KeepSpeedAlongSpline)*tm-pathOb->InterpCurve3D(t, 0, ((cu=u-DU)<0.0f?0.0f:cu))*tm);
			Point3 TTt = Normalize(pd->psaved[index].TTT1^Tt);
			Point3 TTTt = Normalize(Tt^TTt);
			Matrix4By4 mx;
			float aR[4],pout[4];
			Point3 Rnow = pd->psaved[index].R*(1.0f+u*pd->psaved[index].TChaos);
			mx[0][0] = Tt.x;
			mx[1][0] = Tt.y;
			mx[2][0] = Tt.z;
			mx[3][0] = 0.0f;
			mx[0][1] = TTt.x;
			mx[1][1] = TTt.y;
			mx[2][1] = TTt.z;
			mx[3][1] = 0.0f;
			mx[0][2] = TTTt.x;
			mx[1][2] = TTTt.y;
			mx[2][2] = TTTt.z;
			mx[3][2] = 0.0f;
			mx[0][3] = Sut.x;
			mx[1][3] = Sut.y;
			mx[2][3] = Sut.z;
			mx[3][3] = 1.0f;
			aR[0] = Rnow.x;
			aR[1] = Rnow.y;
			aR[2] = Rnow.z;
			aR[3] = 1.0f;
			if (pd->psaved[index].SChaos!=0.0f)
			{	Matrix4By4 mrot,mres;
				float Thetanow = TWOPI*pd->psaved[index].SChaos*u;
				mrot[0][0]=mrot[3][3]=1.0f;
				mrot[0][1]=mrot[0][2]=mrot[0][3]=mrot[1][0]=mrot[1][3]=mrot[2][0]=mrot[2][3]=0.0f;
				mrot[3][0]=mrot[3][1]=mrot[3][2]=0.0f;
				mrot[2][2]=mrot[1][1]=(float)cos(Thetanow);mrot[1][2]=-(mrot[2][1]=(float)sin(Thetanow));
				Mult4X4(mx,mrot,mres);
				Mult4X1(aR,mres,pout);
			}
			else 
				Mult4X1(aR,mx,pout);
			pos.x = pout[0];
			pos.y = pout[1];
			pos.z = pout[2];
		}

		if ((lettinggo)&&(t<endtime)) 
			t = endtime;
		else 
			done = TRUE;
	}

	if (timeloops>0)
		pos += (float)(timeloops)*pd->psaved[index].TraverseVector;

// new velocity calculation HERE

	float splinelen = pathOb->LengthOfCurve(t,0);
	Point3 tanVector = pathOb->TangentCurve3D(t,0,u);
	float baseSpeed = splinelen/(float)pd->psaved[index].Tt;
	
	float u1,u2,u3;
	if (u<0.01f)
	{	u1 = 0.0f;
		u2 = 0.01f;
		u3 = 0.02f;
	}
	else if (u>0.99f)
	{	u1 = 0.98f;
		u2 = 0.99f;
		u3 = 1.0f;
	}
	else
	{	u1 = u - 0.01f;
		u2 = u;
		u3 = u + 0.01f;
	}

	Point3 S1, S2, S3;
	S1 = pathOb->InterpCurve3D(t,0,u1,KeepSpeedAlongSpline)*tm;
	S2 = pathOb->InterpCurve3D(t,0,u2,KeepSpeedAlongSpline)*tm;
	S3 = pathOb->InterpCurve3D(t,0,u3,KeepSpeedAlongSpline)*tm;
	Point3 R1, R2;
	R1 = S2 - S1;
	R2 = S3 - S2;
	float lr1, lr2;
	lr1 = Length(R1);
	lr2 = Length(R2);

	if (lr1<0.001f)
	{	S1 = S2 - 0.001f*tanVector;
		R1 = S2 - S1;
		lr1 = Length(R1);
	}
	if (lr2<0.001f)
	{	S3 = S2 + 0.001f*tanVector;
		R2 = S3 - S2;
		lr2 = Length(R2);
	}

	float theta = (float)acos(DotProd(R1,R2)/(lr1*lr2));
	if (theta < 0.001f)
		vel = baseSpeed * tanVector;
	else
	{	Point3 SpinAxis = Normalize(R1^R2);
		Point3 Rad1 = Normalize(SpinAxis^R1);
		Point3 Rad2 = Normalize(SpinAxis^R2);
		Point3 P1 = 0.5f*(S1+S2);
		Point3 P2 = 0.5f*(S2+S3);

		float denom, paramT;
		denom = Rad2.x - Rad1.x;
		if ((float)fabs(denom)>0.001f)
			paramT = (P1.x - P2.x)/denom;
		else 
		{	denom = Rad2.y - Rad1.y;
			if ((float)fabs(denom)>0.001f)
				paramT = (P1.y - P2.y)/denom;
			else
			{	denom = Rad2.z - Rad1.z;
				if ((float)fabs(denom)>0.001f)
					paramT = (P1.z - P2.z)/denom;
			}
		}
		Point3 omega = (baseSpeed/paramT)*SpinAxis;
		Point3 ArcCenter = P1 + paramT*Rad1;
		Point3 EffectiveArc = pos - ArcCenter;
		vel = omega^EffectiveArc;
	}

	if ((lettinggo)&&(!pd->psaved[index].FoundOnceAlready))
	{	pd->psaved[index].TraverseVector = pos - pd->psaved[index].StartPoint;
		pd->psaved[index].FoundOnceAlready = TRUE;
	}

	if (lettinggo)
	{	vel = invel;
		pd->psaved[index].found = FALSE;
	}

	return TRUE;
}

RefTargetHandle PFollowObject::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		default: return NULL;
		}
	}

void PFollowObject::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		}
	}

RefResult PFollowObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode) custnode=NULL;
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				}
			  break;
		case REFMSG_CHANGE:
			{ if (pblock && (pblock==hTarget))
			  { reset=TRUE;
			  }
			  SimpleWSMObject::NotifyRefChanged(changeInt,hTarget,partID,message);
			}
			break;
			}
		default: SimpleWSMObject::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}
#define PFollow_CUSTNAME_CHUNK	0x0100

IOResult PFollowObject::Save(ISave *isave)
	{
	isave->BeginChunk(PFollow_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();
	return IO_OK;
	}

IOResult PFollowObject::Load(ILoad *iload)
	{
	IOResult res = IO_OK;
	
	// Default names
	custname = TSTR(_T(" "));

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case PFollow_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\sphered.cpp ===
/**********************************************************************
 *<
	FILE: sphered.cpp

	DESCRIPTION: A simple spherical deflector object for particles

	CREATED BY: Audrey Peterson

	HISTORY: 19November 96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "suprprts.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

static Class_ID SPHEREDEF_CLASS_ID(0x6cbd289d, 0x3fef6656);
static Class_ID SPHEREDEFMOD_CLASS_ID(0x5cdf4181, 0x4c5b42f9);

class SphereDefObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		int lastrnd;
		TimeValue t;
					
		SphereDefObject();

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		Class_ID ClassID() {return SPHEREDEF_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_SPHDEFLECTOR);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *SphereDefObject::ip        = NULL;
IParamMap *SphereDefObject::pmapParam = NULL;
HWND       SphereDefObject::hSot      = NULL;

class SphereDeflectorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new SphereDefObject;}
	const TCHAR *	ClassName() {return GetString(IDS_AP_SPHDEFLECTOR_CLASS);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return SPHEREDEF_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_PARTICLES);}
	};

static SphereDeflectorClassDesc SpheredeflectDesc;
ClassDesc* GetSphereDefDesc() {return &SpheredeflectDesc;}

//--- DeflectMod -----------------------------------------------------

class SphereDeflectorField : public CollisionObject {
	public:		
		SphereDefObject *obj;
		INode *node;
		Matrix3 tm, invtm,tp;
		Interval tmValid;
		Point3 Vc,Vcp;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class SphereDeflectMod : public SimpleWSMMod {
	public:				
		SphereDeflectorField deflect;

		SphereDeflectMod() {}
		SphereDeflectMod(INode *node,SphereDefObject *obj);		

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_RB_SPHDEFLECTMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return SPHEREDEFMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_SPHDEFBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class SphereDeflectorModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new SphereDeflectMod;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_SPHDEFLECTMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return SPHEREDEFMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static SphereDeflectorModClassDesc SpheredeflectModDesc;
ClassDesc* GetSphereDefModDesc() {return &SpheredeflectModDesc;}

//--- SphereDefObject Parameter map/block descriptors ------------------

#define PB_BOUNCE	 0
#define PB_BVAR		 1
#define PB_CHAOS	 2
#define PB_RADIUS	 3
#define PB_VELOCITY	 4

static ParamUIDesc descParam[] = {
	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_UDEFL_MULT,IDC_UDEFL_MULTSPIN,
		0.0f, 9999999.0f,
		0.01f),
	
	// Bounce Var
	ParamUIDesc(
		PB_BVAR,
		EDITTYPE_FLOAT,
		IDC_UDEFL_MULTVAR,IDC_UDEFL_MULTVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),
	
	// Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_UDEFL_CHAOS,IDC_UDEFL_CHAOSSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),
		
	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_SP_UDEFL_ICONSIZE,IDC_SP_UDEFL_ICONSIZESPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Velocity Inheritance
	ParamUIDesc(
		PB_VELOCITY,
		EDITTYPE_FLOAT,
		IDC_SP_UDEFL_VELINH,IDC_SP_UDEFL_VELINHSPIN,
		0.0f,1000.0f,SPIN_AUTOSCALE),

	};

#define PARAMDESC_LENGTH	5

ParamBlockDescID SphDefdescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	//Bounce
	{ TYPE_FLOAT, NULL, FALSE, 1 },	//Bounce Var
	{ TYPE_FLOAT, NULL, TRUE, 2 },	//Chaos
	{ TYPE_FLOAT, NULL, FALSE, 3 },	//Radius
	{ TYPE_FLOAT, NULL, TRUE, 4 }};	//Velocity Inheritance

#define PBLOCK_LENGTH	5

#define CURRENT_VERSION	0


//--- Deflect object methods -----------------------------------------

SphereDefObject::SphereDefObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(SphDefdescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BVAR,0,0.0f);
	pblock->SetValue(PB_CHAOS,0,0.0f);
	pblock->SetValue(PB_VELOCITY,0,0.0f);
	srand(lastrnd=12345);
	t=99999;
	}

Modifier *SphereDefObject::CreateWSMMod(INode *node)
	{
	return new SphereDeflectMod(node,this);
	}

RefTargetHandle SphereDefObject::Clone(RemapDir& remap) 
	{
	SphereDefObject* newob = new SphereDefObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
	}

void SphereDefObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC),
			DefaultSOTProc,
			GetString(IDS_RB_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SW_SPHEREDEFL),
			GetString(IDS_RB_PARAMETERS),
			0);
		}
	}

void SphereDefObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}

void SphereDefObject::BuildMesh(TimeValue t)
	{
	ivalid = FOREVER;
	float length;
	pblock->GetValue(PB_RADIUS,t,length,ivalid);
	float u;
	#define NUM_SEGS	16
	length/=2.0f;

	mesh.setNumVerts(3*NUM_SEGS+1);
	mesh.setNumFaces(3*NUM_SEGS);

	for (int i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i, Point3((float)cos(u) * length, (float)sin(u) * length, 0.0f));
			}
	for (i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i+NUM_SEGS, Point3(0.0f, (float)cos(u) * length, (float)sin(u) * length));
			}
	for (i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i+2*NUM_SEGS, Point3((float)cos(u) * length, 0.0f, (float)sin(u) * length));
			}		
	mesh.setVert(3*NUM_SEGS, Point3(0.0f, 0.0f, 0.0f));
		
	for (i=0; i<3*NUM_SEGS; i++) {
			int i1 = i+1;
			if (i1%NUM_SEGS==0) i1 -= NUM_SEGS;
			mesh.faces[i].setEdgeVisFlags(1,0,0);
			mesh.faces[i].setSmGroup(0);
			mesh.faces[i].setVerts(i,i1,3*NUM_SEGS);
			}
	mesh.InvalidateGeomCache();
	}


class SphereDeflectObjCreateCallback : public CreateMouseCallBack {
	public:
		SphereDefObject *ob;	
		Point3 p0, p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int SphereDeflectObjCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{

	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				ob->pblock->SetValue(PB_RADIUS,0,0.01f);
				ob->pmapParam->Invalidate();
				break;

			case 1: {
				sp1 = m;
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				ob->pblock->SetValue(PB_RADIUS,0,2.0f*Length(p1-p0));
				ob->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
	}
static SphereDeflectObjCreateCallback SpheredeflectCreateCB;

CreateMouseCallBack* SphereDefObject::GetCreateMouseCallBack()
	{
	SpheredeflectCreateCB.ob = this;
	return &SpheredeflectCreateCB;
	}

void SphereDefObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *SphereDefObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_BVAR:
		case PB_CHAOS:
				 return stdPercentDim;
		case PB_RADIUS:
				return stdWorldDim;
		default: return defaultDim;
		}
	}

TSTR SphereDefObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_BOUNCE: 	return GetString(IDS_RB_BOUNCE);
		case PB_BVAR:		return GetString(IDS_RB_BVAR);
		case PB_CHAOS:		return GetString(IDS_RB_CHAOS);
		case PB_RADIUS:		return GetString(IDS_AP_ICONSIZE);
		case PB_VELOCITY:	return GetString(IDS_AP_VELOCITY);
		default: 			return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

SphereDeflectMod::SphereDeflectMod(INode *node,SphereDefObject *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef = NULL;
	}

Interval SphereDeflectMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		SphereDefObject *obj = (SphereDefObject*)GetWSMObject(t);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_CHAOS,t,f,valid);
		obj->pblock->GetValue(PB_RADIUS,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class SphereDeflectDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static SphereDeflectDeformer Sphereddeformer;

Deformer& SphereDeflectMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return Sphereddeformer;
	}

RefTargetHandle SphereDeflectMod::Clone(RemapDir& remap) 
	{
	SphereDeflectMod *newob = new SphereDeflectMod(nodeRef,(SphereDefObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}


void SphereDeflectMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (SphereDefObject*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.tmValid.SetEmpty();	
		if (t<=deflect.obj->t) deflect.obj->lastrnd=12345;
		deflect.obj->t=t;
		obj->ApplyCollisionObject(&deflect);
		}
	}

Object *SphereDeflectorField::GetSWObject()
{ return obj;
}

BOOL SphereDeflectorField::CheckCollision(
		TimeValue t,Point3 &pos, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide)
{ Point3 zero=Zero;
	if (!tmValid.InInterval(t)) {
		tmValid = FOREVER;
		tm    = node->GetObjectTM(t,&tmValid);
		invtm = Inverse(tm);
		Interval tmpValid=FOREVER;
		tp=node->GetObjectTM(t+(int)dt,&tmpValid);
		Vc=zero;
		Vcp=zero*tp*invtm;
	}
	
	float radius, chaos, bounce,bvar,vinher;
	Point3 p, vr;
    srand(obj->lastrnd);
	p=pos*invtm; 
	vr=VectorTransform(invtm,vel);
	obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
	if (bounce<0.001f) bounce+=0.001f;
	obj->pblock->GetValue(PB_BVAR,t,bvar,FOREVER);
	obj->pblock->GetValue(PB_CHAOS,t,chaos,FOREVER);
	obj->pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
	obj->pblock->GetValue(PB_VELOCITY,t,vinher,FOREVER);
	vinher/=100.0f;
	radius*=0.5f;
	Point3 Vdt;
	Vdt=(Vcp-Vc)/dt;
	Point3 Vrel=vr-Vdt;
	//if (!FGT0(Vrel))return(0);
	float rsquare=radius*radius;
	float rplus=radius,rminus=radius;
	Point3 Vreln=Normalize(Vrel);
	if (LengthSquared(p-Vc)>=(rminus*rminus)) //outside
	{	Point3 P1;
		P1=p+dt*Vrel; //second particle position
		if (!(LengthSquared(P1-Vc)<(rplus*rplus)))
		{	float Dist,Dist1;
			Dist=DotProd(Vreln,(Vc-p));
			if (Dist<0.0f) 
				return(0);
			Dist1=DotProd(-Vreln,(Vc-P1));
			if (Dist1<0.0f)	
				return(0);
			Point3 P10=P1-p,Pc=Vc-p;
			float gamma=(float)acos(DotProd(P10,Pc)/(Length(P10)*Length(Pc)));
			float Dist2=Length(Pc)*(float)cos(HalfPI-gamma);
			if (Dist2>radius) 
				return(0);
		}
		float A,B,C,omega,omega1,omegaend,a2,ptmp,c,d;
		A=LengthSquared(Vrel);
		B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
		C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
		omegaend=B*B-4.0f*A*C;
		if (omegaend<0.0f) omegaend=0.0f;
		else omegaend=(float)sqrt(omegaend);
		a2=2.0f*A;
		omega1=(-B+omegaend)/a2;
		omega=(-B-omegaend)/a2;
		if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
		float fdt=1.1f*dt;
		if ((omega>fdt)||(omega<-fdt)) 
			return(0);
		Point3 XI,r,n;
		XI=p+omega*vr;
		Point3 Ci=Vc+omega*Vdt;
		r=Normalize(XI-Ci);
		float q1=DotProd(-Vreln,r);
		float theta=(float)acos(q1);
		if (theta>=HalfPI) theta-=PI;
		float v[4];
		if (theta<FLOAT_EPSILON) vr=-vr;
		else 
		{	n=Normalize((-Vreln)^r);
			vr=-vr;
			memcpy(v,vr,row3size);v[3]=1.0f;
			RotateOnePoint(v,&zero.x,&n.x,2*theta);
			memcpy(vr,v,row3size);
		}
		vr=vr*bounce*(1-bvar*RND01());
		if (!FloatEQ0(chaos))
		{	theta=(HalfPI-theta)*chaos*RND01();
			Point3 d=Point3(RND11(),RND11(),RND11());
			Point3 c=Normalize(vr^d);
			memcpy(v,vr,row3size);v[3]=1.0f;
			RotateOnePoint(v,&zero.x,&c.x,theta);
			memcpy(vr,v,row3size);
		}
		if ((vinher>0.0f)&&(t>0))
		{	vr = vr+DotProd(Vdt*vinher,r)*r;
		}
		if (UpdatePastCollide)
		{	pos = XI + (dt-omega)*vr;
			if (ct) (*ct) = dt;
		}
		else
		{	pos = XI;
			if (ct) (*ct) = omega;
		}
		pos=pos*tm;
		vel=VectorTransform(tm,vr);
		obj->lastrnd=rand();
		return TRUE;
	}
	else //inside
	{	Point3 P1;
		P1=p+dt*Vrel;
		if (LengthSquared(P1-Vc)<(rplus*rplus)) 
			return(0);
		float A,B,C,omega,omega1,omegaend,a2,ptmp,c,d;
		A=LengthSquared(Vrel);
		B=2.0f*DotProd(p,Vrel)-2.0f*DotProd(Vrel,Vc);
		C=(ptmp=LengthSquared(p))+(c=LengthSquared(Vc))-(d=2.0f*DotProd(p,Vc))-rsquare;
		omegaend=B*B-4.0f*A*C;
		if (omegaend<0.0f) omegaend=0.0f;
		else omegaend=(float)sqrt(omegaend);
		a2=2.0f*A;
		omega1=(-B+omegaend)/a2;
		omega=(-B-omegaend)/a2;
		if (((omega1>0.0f)&&(omega1<omega))||((omega<0.0f)&&(omega1>omega))) omega=omega1;
		float fdt=1.1f*dt;
		if ((omega>fdt)||(omega<-fdt)) 
			return(0);
		Point3 XI,r,n;
		XI=p+omega*vr;
		Point3 Ci=Vc+omega*Vdt;
		r=Normalize(XI-Ci);
		float q1=DotProd(Vreln,r);
		float theta=(float)acos(q1);
		float v[4];
		if (theta<FLOAT_EPSILON) vr=-vr;
		else 
		{	n=Normalize(Vreln^r);
			vr=-vr;
			memcpy(v,vr,row3size);v[3]=1.0f;
			RotateOnePoint(v,&zero.x,&n.x,2*theta);
			memcpy(vr,v,row3size);
		}
		vr=vr*bounce*(1-bvar*RND01());
		if (!FloatEQ0(chaos))
		{	theta=(HalfPI-theta)*chaos*RND01();
			Point3 d=Point3(RND11(),RND11(),RND11());
			Point3 c=Normalize(vr^d);
			memcpy(v,vr,row3size);v[3]=1.0f;
			RotateOnePoint(v,&zero.x,&c.x,theta);
			memcpy(vr,v,row3size);
		}
		if ((vinher>0.0f)&&(t>0)){vr=vr+DotProd(Vdt*vinher,r)*r;}
		if (UpdatePastCollide)
		{	pos = XI + (dt-omega)*vr;
			if (ct) (*ct) = dt;
		}
		else
		{	pos = XI;
			if (ct) (*ct) = omega;
		}
		pos=pos*tm;
		vel=VectorTransform(tm,vr);
		obj->lastrnd=rand();
		return TRUE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\blizzard.cpp ===
/**********************************************************************
 *<									  

	FILE: Blizzard.CPP
	DESCRIPTION: SuperSpray and Blizzard main code

	CREATED BY: Audrey Peterson	

	HISTORY: created November 1996
	Instancing Geometry 1/97
	IPC 8/98

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include <io.h>
#include "SuprPrts.h"
#include "iparamm.h"
#include "interpik.h"
#include "texutil.h"
#include "stdmat.h"

#define EPSILON 0.0001f
#define MAX_PATH_LENGTH 257
#define MAX_STRING_LENGTH  256
#define PARTICLE_SEED	0x8d6a65bc
#define PBLK		0
#define CUSTNODE 		1

#define BASER 2

typedef struct {
 float Vsz,Ts,Ts0,LamTs,A,LamA,To;
 float M,Dis,Fo,Mltvar,pvar;
 int themtl,gennum,SpVar;
 TimeValue L,showframe,DL,persist;
 Point3	V,W,RV;
} CSavePt;

typedef struct {
 float Size,VSz,VSpin,Phase,VPhase,Speed,VSpeed;
 float width,bstr,bstrvar,ToAmp,VToAmp,axisvar;
 float ToPhase,VToPhase,VToPeriod,Av180,Ah180,VAv,VAh,pvar;
 int axisentered;
 Point3 Ve,Axis;
 TimeValue Spin,ToPeriod,Life,Vl,persist;
} VelDir;

static Class_ID SUPRSPRAY_CLASS_ID(0x74f811e3, 0x21fb7b57);
static Class_ID BLIZZARD_CLASS_ID(0x5835054d, 0x564b40ed);

class CPickOperand;
class CommonParticle;
class CommonParticleDraw : public CustomParticleDisplay {
	public:
		float tumble,scale;
		BOOL firstpart;
		CommonParticle *obj;
		int disptype,ptype,bb,anifr,anioff;
		boxlst *bboxpt;
		TimeValue t;
		InDirInfo indir;

		CommonParticleDraw() {obj=NULL;}
		BOOL DrawParticle(GraphicsWindow *gw,ParticleSys &parts,int i);
	};

class CommonParticle : public SimpleParticle, IParamArray {
	public:
		CommonParticleDraw theSuprSprayDraw;
		static IParamMap *pmapParam;
		static IParamMap *pmapPGen;
		static IParamMap *pmapPType;
		static IParamMap *pmapPSpin;
		static IParamMap *pmapEmitV;
		static IParamMap *pmapSpawn;
		int stepSize,size;
		static custsettings;
		ULONG dflags;
		Mesh *cmesh,*dispmesh;
		INode *custnode,*cnode;
		TSTR custname;
		DWORD flags;
		BOOL cancelled,wasmulti;
		static BOOL creating;
		static CPickOperand pickCB;
		Mtl *origmtl;

		Point3 boxcenter;
		int CustMtls;
		TimeLst times;
		void GetTimes(TimeLst &times,TimeValue t,int anifr,int ltype);
		void TreeDoGroup(INode *node,Matrix3 tspace,Mesh *cmesh,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl);
		void CheckTree(INode *node,Matrix3 tspace,Mesh *cmesh,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl);
		void GetMesh(TimeValue t,int subtree,int custmtl);
		void GetNextBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode);
		void DoGroupBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode);
		void GetallBB(INode *custnode,int subtree,TimeValue t);

		Tab<int> nmtls;
		void DoSpawn(int j,int spmult,SpawnVars spvars,TimeValue lvar,BOOL emit);
		void SetUpList();
		void AddToList(INode *newnode,int i,BOOL add);
		void DeleteFromList(int nnum,BOOL all);
		Tab<INode*> nlist;
		Tab<int> llist;
		int deftime;
		int maincount,rseed;
		int NumRefs() {return BASER+nlist.Count();}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		void SetUpLifeList();
		void AddToLifeList(int newlife);
		void DeleteFromLifeList(int nnum);
		void ShowName();
		static AName *NameLst;
		static HWND hParams2,hptype,hgen,hparam,hrot,spawn;
		static ICustEdit *custCtrlEdit;
		void ResetSystem(TimeValue t,BOOL full=TRUE);

		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);
		int CountLive();
		int rcounter,vcounter;
		oldipc lc;
		static IObjParam *ip;
		// Animatable methods		
		void DeleteThis() {delete this;}
		void MapKeys(TimeMap *map,DWORD flags);
		int RenderBegin(TimeValue t, ULONG flags);		
		int RenderEnd(TimeValue t);

		// From SimpleParticle
		Interval GetValidity(TimeValue t);		
		BOOL EmitterVisible();		
		MarkerType GetMarkerType();	
		CSavePt *sdata;

		// From BaseObject
		int IsInstanceDependent() {return 1;}
		Matrix3 TumbleMat(int index,float amount, float scale);
		void GetFilename(TCHAR *filename);
		void SetupTargetList();
		int SaveSettings(int overwrite,TCHAR *newname);
		int GetSettings(int setnum,TCHAR *newname);
		int RemSettings(int setnum,TCHAR *newname);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void AssignMtl(INode *node,INode *topnode,int subtree,TimeValue t);
		void DoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void RetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void GetSubs(INode *node,INode *topnode,int subtree,TimeValue t);
		void CntDoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void CntRetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		BOOL backpatch;
		Mtllst mttab;
		TimeValue ParticleLife(TimeValue t, int i);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		int HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt);
		TimeValue dispt;
	};

class SuprSprayParticle : public CommonParticle {
	public:
		SuprSprayParticle();
		~SuprSprayParticle();
		static IParamMap *pmapBubl;
		static HWND hbubl;
		CreateMouseCallBack* GetCreateMouseCallBack();

		TCHAR *GetObjectName();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void BuildEmitter(TimeValue t, Mesh& amesh);
		void BirthParticle(INode *node,TimeValue bt,int num,VelDir* ptvel,Matrix3 tmnxt);
		BOOL ComputeParticleStart(TimeValue t0,int c);
		// From GeomObject
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		// Animatable methods		
		Class_ID ClassID() {return SUPRSPRAY_CLASS_ID;} 
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From Simple Particle
		void UpdateParticles(TimeValue t,INode *node);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI();
		float ParticleSize(TimeValue t,int i);
		int ParticleCenter(TimeValue t,int i);
		Point3 ParticlePosition(TimeValue t,int i);
		Point3 ParticleVelocity(TimeValue t,int i);		
		void MovePart(int j,TimeValue dt,BOOL fullframe,int tpf);
	};
//--- ClassDescriptor and class vars ---------------------------------

class SuprSprayClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new SuprSprayParticle;}
	const TCHAR *	ClassName(); 
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return SUPRSPRAY_CLASS_ID;}
	const TCHAR* 	Category(); 
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};

static SuprSprayClassDesc SuprSprayDesc;
ClassDesc* GetSuprSprayDesc() {return &SuprSprayDesc;}

class CPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		CommonParticle *po;
		int dodist,repi;

		CPickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};
//--- ClassDescriptor and class vars ---------------------------------
IParamMap *CommonParticle::pmapParam;
IParamMap *CommonParticle::pmapPGen;
IParamMap *CommonParticle::pmapPType;
IParamMap *CommonParticle::pmapPSpin;
IParamMap *CommonParticle::pmapEmitV;
IParamMap *CommonParticle::pmapSpawn;
IObjParam *CommonParticle::ip    = NULL;
BOOL CommonParticle::creating    = FALSE;
CPickOperand CommonParticle::pickCB;
ICustEdit *CommonParticle::custCtrlEdit=NULL;
int CommonParticle::custsettings=0;
AName *CommonParticle::NameLst=NULL;
HWND CommonParticle::hParams2;
HWND CommonParticle::hgen;
HWND CommonParticle::hptype;
HWND CommonParticle::hparam;
HWND CommonParticle::hrot;
HWND CommonParticle::spawn;

IParamMap *SuprSprayParticle::pmapBubl;
HWND SuprSprayParticle::hbubl;

class BlizzardParticle : public CommonParticle {
	public:
		BlizzardParticle();
		~BlizzardParticle();
		CreateMouseCallBack* GetCreateMouseCallBack();

		TCHAR *GetObjectName();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void BuildEmitter(TimeValue t, Mesh& amesh);
		void BirthParticle(INode *node,TimeValue bt,int num,VelDir* ptvel,Matrix3 tmnxt);
		BOOL ComputeParticleStart(TimeValue t0,int c);
		// From GeomObject
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		// Animatable methods		
		Class_ID ClassID() {return BLIZZARD_CLASS_ID;} 
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From Simple Particle
		void UpdateParticles(TimeValue t,INode *node);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI();
		float ParticleSize(TimeValue t,int i);
		int ParticleCenter(TimeValue t,int i);
		Point3 ParticlePosition(TimeValue t,int i);
		Point3 ParticleVelocity(TimeValue t,int i);		
	};
//--- ClassDescriptor and class vars ---------------------------------

class BlizzardClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new BlizzardParticle();}
	const TCHAR *	ClassName(); 
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return BLIZZARD_CLASS_ID;}
	const TCHAR* 	Category(); 
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};

static BlizzardClassDesc BlizzardDesc;
ClassDesc* GetBlizzardDesc() {return &BlizzardDesc;}

#define SIZEFACTOR (float(TIME_TICKSPERSEC)/120.0f)

//--- Parameter map/block descriptors -------------------------------

#define PB_OFFAXIS				0
#define PB_AXISSPREAD			1
#define PB_OFFPLANE				2
#define PB_PLANESPREAD			3
#define PB_SPEED				4
#define PB_SPEEDVAR				5

#define PB_BIRTHMETHOD			6
#define PB_PBIRTHRATE			7
#define PB_PTOTALNUMBER			8
#define PB_EMITSTART			9
#define PB_EMITSTOP				10
#define PB_DISPUNTIL			11
#define PB_LIFE					12
#define PB_LIFEVAR				13
#define PB_SUBFRAMEMOVE			14
#define PB_SUBFRAMETIME			15
#define PB_SIZE					16
#define PB_SIZEVAR				17
#define PB_GROWTIME				18
#define PB_FADETIME				19
#define PB_RNDSEED				20
#define PB_EMITRWID				21
#define PB_EMITRHID				22

#define PB_PARTICLECLASS		23
#define PB_PARTICLETYPE			24
#define PB_METATENSION			25
#define PB_METATENSIONVAR		26
#define PB_METACOURSE			27
#define PB_METAAUTOCOARSE		28
#define PB_USESUBTREE			29
#define PB_ANIMATIONOFFSET		30
#define PB_OFFSETAMOUNT			31
#define PB_VIEWPORTSHOWS		32
#define PB_DISPLAYPORTION		33
#define PB_MAPPINGTYPE			34
#define PB_MAPPINGTIME			35
#define PB_MAPPINGDIST			36
						
#define PB_SPINTIME				37
#define PB_SPINTIMEVAR			38
#define PB_SPINPHASE			39
#define PB_SPINPHASEVAR			40
#define PB_SPINAXISTYPE			41
#define PB_SPINAXISX			42
#define PB_SPINAXISY			43
#define PB_SPINAXISZ			44
#define PB_SPINAXISVAR			45

#define PB_EMITVINFL			46
#define PB_EMITVMULT			47
#define PB_EMITVMULTVAR			48

#define PB_SPAWNTYPE			49
#define PB_SPAWNGENS			50
#define PB_SPAWNCOUNT			51
#define PB_SPAWNDIRCHAOS		52
#define PB_SPAWNSPEEDCHAOS		53
#define PB_SPAWNSPEEDSIGN		54
#define PB_SPAWNINHERITV		55
#define PB_SPAWNSCALECHAOS		56
#define PB_SPAWNSCALESIGN		57
#define PB_SPAWNLIFEVLUE		58
#define PB_SPAWNSPEEDFIXED		59
#define PB_SPAWNSCALEFIXED		60	

#define PB_BUBLAMP				61
#define PB_BUBLAMPVAR			62
#define PB_BUBLPER				63
#define PB_BUBLPERVAR			64
#define PB_BUBLPHAS				65
#define PB_BUBLPHASVAR			66

#define PB_STRETCH				67
#define PB_CUSTOMMTL			68
#define PB_METACOURSEV			69
#define PB_SUBFRAMEROT			70
#define PB_SPAWNPERCENT			71
#define PB_SPAWNMULTVAR			72
#define PB_SSNOTDRAFT			73
#define PB_SSSPAWNDIEAFTER		74
#define PB_SSSPAWNDIEAFTERVAR	75

#define PB_IPCOLLIDE_ON			76
#define PB_IPCOLLIDE_STEPS		77
#define PB_IPCOLLIDE_BOUNCE		78
#define PB_IPCOLLIDE_BOUNCEVAR	79

// render types
#define RENDMETA    8
#define RENDGEOM	9

// Parameters
#define ISSTD 0
#define METABALLS 1
#define INSTGEOM 2

static int countIDs[] = {IDC_SP_GENUSERATE,IDC_SP_GENUSETTL};

static int particleclassIDs[] = {IDC_SP_TYPESTD,IDC_SP_TYPEMET,IDC_SP_TYPEINSTANCE};

static int particletypeIDs[] = {IDC_SP_TYPETRI,IDC_SP_TYPECUB,IDC_SP_TYPESPC,IDC_SP_TYPEFAC,
								IDC_SP_TYPEPIX,IDC_SP_TYPETET,IDC_SP_TYPE6PNT,IDC_SP_TYPESPHERE};

static int viewportoptionIDs[] = {IDC_SP_VIEWDISPDOT,IDC_SP_VIEWDISPTIK,IDC_SP_VIEWDISPMESH,IDC_SP_VIEWDISPBOX};

static int mappingIDs[] = {IDC_SP_MAPTIME,IDC_SP_MAPDIST};

static int spindirectionIDs[] = {IDC_AP_PARTICLEDIRRND,IDC_AP_PARTICLEDIRTRAVL,IDC_AP_PARTICLEDIRUSER};
static int bspindirectionIDs[] = {IDC_AP_PARTICLEDIRRND,IDC_AP_PARTICLEDIRUSER};

#define DIRTRAVEL 1

static int animateoffsetIDs[] = {IDC_AP_NOANIOFF,IDC_AP_ANIOFFBIRTH,IDC_AP_ANIOFFRND};
static int custmtlIDs[] = {IDC_SP_MAPCUSTOMEMIT,IDC_SP_MAPCUSTOMINST};

// Dialog Unique to SuperSpray
static ParamUIDesc descParamSuprSpray[] = {

	// Particle Off Axis 
	ParamUIDesc(
		PB_OFFAXIS,
		EDITTYPE_FLOAT,
		IDC_SP_OFFAXIS,IDC_SP_OFFAXISSPIN,
		-180.0f,180.0f,
		1.0f,
		stdAngleDim),

	// Particle Off Axis Spread
	ParamUIDesc(
		PB_AXISSPREAD,
		EDITTYPE_FLOAT,
		IDC_SP_OFFAXISVAR,IDC_SP_OFFAXISVARSPIN,
		0.0f,180.0f,
		1.0f,
		stdAngleDim),

	// Particle Off Plane 
	ParamUIDesc(
		PB_OFFPLANE,
		EDITTYPE_FLOAT,
		IDC_SP_OFFPLANE,IDC_SP_OFFPLANESPIN,
		-180.0f,180.0f,
		1.0f,
		stdAngleDim),

	// Particle Off Plane Spread
	ParamUIDesc(
		PB_PLANESPREAD,
		EDITTYPE_FLOAT,
		IDC_SP_OFFPLANEVAR,IDC_SP_OFFPLANEVARSPIN,
		0.0f,180.0f,
		1.0f,
		stdAngleDim),

	// Emitter Width
	ParamUIDesc(
		PB_EMITRWID,
		EDITTYPE_UNIVERSE,
		IDC_SP_EMITWID,IDC_SP_EMITWIDSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Hide Emitter
	ParamUIDesc(PB_EMITRHID,TYPE_SINGLECHEKBOX,IDC_SP_EMITHID),

	// Viewport Shows
	ParamUIDesc(PB_VIEWPORTSHOWS,TYPE_RADIO,viewportoptionIDs,4),

	// Particle Display Portion
	ParamUIDesc(
		PB_DISPLAYPORTION,
		EDITTYPE_FLOAT,
		IDC_SP_GENDISP,IDC_SP_GENDISPSPIN,
		0.0f,100.0f,
		0.1f,
		stdPercentDim),
};

#define PARAMSuprSpray_LENGTH 8

// Common Dialog for Particle Generation
static ParamUIDesc descParamPGen[] = {

	// Distribution Method
	ParamUIDesc(PB_BIRTHMETHOD,TYPE_RADIO,countIDs,2),

	// Particle Birth Rate
	ParamUIDesc(
		PB_PBIRTHRATE,
		EDITTYPE_INT,
		IDC_SP_GENRATE,IDC_SP_GENRATESPIN,
		0.0f,65000.0f,
		1.0f),

	// Particle Total Count
	ParamUIDesc(
		PB_PTOTALNUMBER,
		EDITTYPE_INT,
		IDC_SP_GENTTL,IDC_SP_GENTTLSPIN,
		0.0f,65000.0f,
		1.0f),

	// Particle Speed
	ParamUIDesc(
		PB_SPEED,
		EDITTYPE_UNIVERSE,
		IDC_SP_SPEED,IDC_SP_SPEEDSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Speed Var
	ParamUIDesc(
		PB_SPEEDVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPEEDVAR2,IDC_SP_SPEEDVARSPIN2,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Emitter Start Time
	ParamUIDesc(
		PB_EMITSTART,
		EDITTYPE_TIME,
		IDC_SP_GENEMIT1,IDC_SP_GENEMIT1SPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Emitter Stop Time
	ParamUIDesc(
		PB_EMITSTOP,
		EDITTYPE_TIME,
		IDC_SP_GENEMIT2,IDC_SP_GENEMIT2SPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Particle Time Limit
	ParamUIDesc(
		PB_DISPUNTIL,
		EDITTYPE_TIME,
		IDC_SP_DISPUNTIL,IDC_SP_DISPUNTILSPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Particle Life
	ParamUIDesc(
		PB_LIFE,	
		EDITTYPE_TIME,
		IDC_SP_GENLIFE,IDC_SP_GENLIFESPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Life Var
	ParamUIDesc(
		PB_LIFEVAR,
		EDITTYPE_TIME,
		IDC_SP_GENLIFEVAR,IDC_SP_GENLIFEVARSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Subframe Time and Motion Sampling
	ParamUIDesc(PB_SUBFRAMEMOVE,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLMOVE),
	ParamUIDesc(PB_SUBFRAMETIME,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLTIME),
	ParamUIDesc(PB_SUBFRAMEROT,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLROT),

	// Particle Size
	ParamUIDesc(
		PB_SIZE,
		EDITTYPE_UNIVERSE,
		IDC_SP_GENSIZE,IDC_SP_GENSIZESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Size Var
	ParamUIDesc(
		PB_SIZEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_GENSIZEVAR,IDC_SP_GENSIZEVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Particle Grow Time
	ParamUIDesc(
		PB_GROWTIME,
		EDITTYPE_TIME,
		IDC_SP_GENGRO,IDC_SP_GENGROSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Fade Time
	ParamUIDesc(
		PB_FADETIME,
		EDITTYPE_TIME,
		IDC_SP_GENFAD,IDC_SP_GENFADSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Random Number Seed
	ParamUIDesc(
		PB_RNDSEED,
		EDITTYPE_INT,
		IDC_SP_GENSEED,IDC_SP_GENSEEDSPIN,
		0.0f,25000.0f,
		1.0f),
};

#define PARAMPGEN_LENGTH 18

// Particle Type for SuprSpray
static ParamUIDesc descParamPType[] = {

	// Particle Class
	ParamUIDesc(PB_PARTICLECLASS,TYPE_RADIO,particleclassIDs,3),

	// Particle Type
	ParamUIDesc(PB_PARTICLETYPE,TYPE_RADIO,particletypeIDs,8),

	// Metaball Tension
	ParamUIDesc(
		PB_METATENSION,
		EDITTYPE_FLOAT,
		IDC_SP_METTENS,IDC_SP_METTENSSPIN,
		0.1f,10.0f,
		SPIN_AUTOSCALE),

	// Metaball Tension Variation
	ParamUIDesc(
		PB_METATENSIONVAR,
		EDITTYPE_FLOAT,
		IDC_SP_METTENSVAR,IDC_SP_METTENSVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Metaball Courseness
	ParamUIDesc(
		PB_METACOURSE,
		EDITTYPE_UNIVERSE,
		IDC_SP_METCOURSE,IDC_SP_METCOURSESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Metaball Courseness ViewPort
	ParamUIDesc(
		PB_METACOURSEV,
		EDITTYPE_UNIVERSE,
		IDC_SP_METCOURSEV,IDC_SP_METCOURSEVSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Metaball Auto Coarseness
	ParamUIDesc(PB_METAAUTOCOARSE,TYPE_SINGLECHEKBOX,IDC_SP_AUTOCOARSE),

	// Display type
	ParamUIDesc(PB_SSNOTDRAFT,TYPE_SINGLECHEKBOX,IDC_SP_DRAFTMODE),

	// Use Subtree Checkbox
	ParamUIDesc(PB_USESUBTREE,TYPE_SINGLECHEKBOX,IDC_AP_USESUBTREE),

	// Display type
	ParamUIDesc(PB_ANIMATIONOFFSET,TYPE_RADIO,animateoffsetIDs,3),

	// Animation Offset Amount
	ParamUIDesc(
		PB_OFFSETAMOUNT,
		EDITTYPE_TIME,
		IDC_AP_ANIRNDFR,IDC_AP_ANIRNDFRSPIN,
		1.0f,999999999.0f,
		10.0f),

	// Mapping Across
	ParamUIDesc(PB_MAPPINGTYPE,TYPE_RADIO,mappingIDs,2),

	// Time Mapping Option
	ParamUIDesc(
		PB_MAPPINGTIME,
		EDITTYPE_TIME,
		IDC_SP_MAPTIMEVAL,IDC_SP_MAPTIMEVALSPIN,
		1.0f,999999999.0f,
		10.0f),

	// Distance Mapping Option
	ParamUIDesc(
		PB_MAPPINGDIST,
		EDITTYPE_UNIVERSE,
		IDC_SP_MAPDISTVAL,IDC_SP_MAPDISTVALSPIN,
		0.1f,999999999.0f,
		SPIN_AUTOSCALE),

	// Use Custom Mtl
	ParamUIDesc(PB_CUSTOMMTL,TYPE_RADIO,custmtlIDs,2),
};

#define PARAMPTYPE_LENGTH 15

// SS Dialog for Particle Spin
static ParamUIDesc descParamPSpin[] = {

	// Spin Time
	ParamUIDesc(
		PB_SPINTIME,
		EDITTYPE_TIME,
		IDC_SP_SPIN,IDC_SP_SPINSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Spin Time Var
	ParamUIDesc(
		PB_SPINTIMEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINVAR,IDC_SP_SPINVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Spin Phase
	ParamUIDesc(
		PB_SPINPHASE,
		EDITTYPE_FLOAT,
		IDC_SP_SPINPHA,IDC_SP_SPINPHASPIN,
		-360.0f,360.0f,
		0.01f,
		stdAngleDim),

	// Spin Phase Variation
	ParamUIDesc(
		PB_SPINPHASEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINPHAVAR,IDC_SP_SPINPHAVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Enter Axis Control
	ParamUIDesc(PB_SPINAXISTYPE,TYPE_RADIO,spindirectionIDs,3),

	// X-Axis
	ParamUIDesc(
		PB_SPINAXISX,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISX,IDC_SP_SPINAXISXSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Y-Axis
	ParamUIDesc(
		PB_SPINAXISY,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISY,IDC_SP_SPINAXISYSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Z-Axis
	ParamUIDesc(
		PB_SPINAXISZ,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISZ,IDC_SP_SPINAXISZSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Spin Direction Variation
	ParamUIDesc(
		PB_SPINAXISVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISVAR,IDC_SP_SPINAXISVARSPIN,
		-180.0f,180.0f,
		0.01f,
		stdAngleDim),

	// Stretch
	ParamUIDesc(
		PB_STRETCH,
		EDITTYPE_INT,
		IDC_AP_STRETCH,IDC_AP_STRETCHSPIN,
		-1000.0f,1000.0f,
		1.0f),

	// IPC Enable
	ParamUIDesc(PB_IPCOLLIDE_ON,TYPE_SINGLECHEKBOX,IDC_INTERP_BOUNCEON),

	// IPC Steps
	ParamUIDesc(
		PB_IPCOLLIDE_STEPS,
		EDITTYPE_INT,
		IDC_INTERP_NSTEPS,IDC_INTERP_NSTEPSSPIN,
		1.0f,1000.0f,
		1.0f),

	// IPC Bounce
	ParamUIDesc(
		PB_IPCOLLIDE_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_INTERP_BOUNCE,IDC_INTERP_BOUNCESPIN,
		0.0f,10000.0f,
		1.0f,
		stdPercentDim),

	// IPC Bounce
	ParamUIDesc(
		PB_IPCOLLIDE_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_INTERP_BOUNCEVAR,IDC_INTERP_BOUNCEVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

};

#define PARAMPSPIN_LENGTH 14

// Common Dialog for Secondary Motion Data
static ParamUIDesc descParamEmitV[] = {

	// Emitter Velocity Inheritance Influence Portion
	ParamUIDesc(
		PB_EMITVINFL,
		EDITTYPE_FLOAT,
		IDC_SP_EMVI,IDC_SP_EMVISPIN,
		0.0f,100.0f,
		0.01f),

	// Secondary Motion Multiplier
	ParamUIDesc(
		PB_EMITVMULT,
		EDITTYPE_FLOAT,
		IDC_SP_EMVIMULT,IDC_SP_EMVIMULTSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Multiplier Variation
	ParamUIDesc(
		PB_EMITVMULTVAR,
		EDITTYPE_FLOAT,
		IDC_SP_EMVIMULTVAR,IDC_SP_EMVIMULTVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),
	};
#define PARAMEMITV_LENGTH 3

// Common Dialog for Bubble Motion
static ParamUIDesc descParamBubl[] = {

	// Bubble Amplitude
	ParamUIDesc(
		PB_BUBLAMP,
		EDITTYPE_UNIVERSE,
		IDC_SP_BUBL_AMP,IDC_SP_BUBL_AMPSPIN,
		-.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Bubble Amp Var
	ParamUIDesc(
		PB_BUBLAMPVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_AMPVAR,IDC_SP_BUBL_AMPVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Bubble Period
	ParamUIDesc(
		PB_BUBLPER,
		EDITTYPE_TIME,
		IDC_SP_BUBL_PER,IDC_SP_BUBL_PERSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Bubble Period Var
	ParamUIDesc(
		PB_BUBLPERVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERVAR,IDC_SP_BUBL_PERVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Bubble Phase
	ParamUIDesc(
		PB_BUBLPHAS,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERPHA,IDC_SP_BUBL_PERPHASPIN,
		-360.0f,360.0f,
		0.01f,
		stdAngleDim),

	// Bubble Phase Var
	ParamUIDesc(
		PB_BUBLPHASVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERPHAVAR,IDC_SP_BUBL_PERPHAVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),
};
#define PARAMBUBL_LENGTH 6


static int SpawnTypeIDs[] = {IDC_AP_NOSPAWN,IDC_AP_COLLIDEDIE,IDC_AP_COLLIDESPAWN,IDC_AP_DEATHSPAWN,IDC_AP_SPAWNTRAILS};
static int SpeedChaosIDs[] = {IDC_AP_SPEEDLESS,IDC_AP_SPEEDMORE,IDC_AP_SPEEDBOTH};
static int ScaleChaosIDs[] = {IDC_AP_SCALEDOWN,IDC_AP_SCALEUP,IDC_AP_SCALEBOTH};

// Dialog for Particle Spawning
static ParamUIDesc descPSpawning[] = {
	
	// Spawing Effects Type
	ParamUIDesc(PB_SPAWNTYPE,TYPE_RADIO,SpawnTypeIDs,5),

	// Die after X
	ParamUIDesc(
		PB_SSSPAWNDIEAFTER,
		EDITTYPE_TIME,
		IDC_AP_MAXSPAWNDIEAFTER,IDC_AP_MAXSPAWNDIEAFTERSPIN,
		0.0f,999999999.0f,
		10.0f),

	ParamUIDesc(
		PB_SSSPAWNDIEAFTERVAR,
		EDITTYPE_FLOAT,
		IDC_AP_MAXSPAWNDIEAFTERVAR,IDC_AP_MAXSPAWNDIEAFTERVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Spawn Generations
	ParamUIDesc(
		PB_SPAWNGENS,
		EDITTYPE_INT,
		IDC_AP_MAXSPAWNGENS,IDC_AP_MAXSPAWNGENSSPIN,
		1.0f,65000.0f,
		1.0f),

	// Spawn Generations
	ParamUIDesc(
		PB_SPAWNPERCENT,
		EDITTYPE_INT,
		IDC_AP_PARENTPERCENT,IDC_AP_PARENTPERCENTSPIN,
		1.0f,100.0f,
		1.0f),

	// Spawn Spawncount
	ParamUIDesc(
		PB_SPAWNCOUNT,
		EDITTYPE_INT,
		IDC_AP_NUMBERVAR,IDC_AP_NUMBERVARSPIN,
		1.0f,65000.0f,
		1.0f),

	// Spawn Mult Percent
	ParamUIDesc(
		PB_SPAWNMULTVAR,
		EDITTYPE_FLOAT,
		IDC_AP_NUMBERVARVAR,IDC_AP_NUMBERVARVARSPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Spawn Direction Chaos
	ParamUIDesc(
		PB_SPAWNDIRCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSANGLE,IDC_AP_CHAOSANGLESPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Spawn Speed Chaos
	ParamUIDesc(
		PB_SPAWNSPEEDCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSPEED,IDC_AP_CHAOSSPEEDSPIN,
		0.0f,100.0f,
		0.1f),

	// Spawing Speed Sign
	ParamUIDesc(PB_SPAWNSPEEDSIGN,TYPE_RADIO,SpeedChaosIDs,3),

	// Spawning Inherit Parent V
	ParamUIDesc(PB_SPAWNINHERITV,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSUMV),

	// Spawning Speed Fixed
	ParamUIDesc(PB_SPAWNSPEEDFIXED,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSPEEDFIXED),

	// Spawn Scale Chaos
	ParamUIDesc(
		PB_SPAWNSCALECHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSCALE,IDC_AP_CHAOSSCALESPIN,
		0.0f,100.0f,
		0.1f),

	// Spawning Scale Sign
	ParamUIDesc(PB_SPAWNSCALESIGN,TYPE_RADIO,ScaleChaosIDs,3),

	// Spawning Speed Fixed
	ParamUIDesc(PB_SPAWNSCALEFIXED,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSCALEFIXED),

	// Spawn Lifespan Entry Field
	ParamUIDesc(
		PB_SPAWNLIFEVLUE,
		EDITTYPE_INT,
		IDC_AP_QUEUELIFESPAN,IDC_AP_QUEUELIFESPANSPIN,
		0.0f,65000.0f,
		SPIN_AUTOSCALE),
};
#define PSPAWNINGPARAMS_LENGTH 16

static ParamBlockDescID spdescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // off axis
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // axis apread
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // off plane
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // plane spread
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
    { TYPE_INT, NULL, FALSE, 29 }, // use subtree
    { TYPE_INT, NULL, FALSE, 30 }, // animation offset
    { TYPE_INT, NULL, FALSE, 31 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble amp61
	{ TYPE_FLOAT, NULL, TRUE, 62 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 63 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 64 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 65 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 66 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 67 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 68 },  // Custom Mtl
};

static ParamBlockDescID spdescVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // off axis
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // axis apread
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // off plane
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // plane spread
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
    { TYPE_INT, NULL, FALSE, 29 }, // use subtree
    { TYPE_INT, NULL, FALSE, 30 }, // animation offset
    { TYPE_INT, NULL, FALSE, 31 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble amp61
	{ TYPE_FLOAT, NULL, TRUE, 62 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 63 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 64 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 65 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 66 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 67 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 68 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, FALSE, 69 },  // ViewPort Courseness
};

static ParamBlockDescID spdescVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // off axis
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // axis apread
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // off plane
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // plane spread
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
    { TYPE_INT, NULL, FALSE, 29 }, // use subtree
    { TYPE_INT, NULL, FALSE, 30 }, // animation offset
    { TYPE_INT, NULL, FALSE, 31 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble amp61
	{ TYPE_FLOAT, NULL, TRUE, 62 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 63 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 64 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 65 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 66 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 67 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 68 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, FALSE, 69 },  // ViewPort Courseness
	{ TYPE_INT, NULL, FALSE, 70 },  // Subframe rot
};

static ParamBlockDescID spdescVer3[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // off axis
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // axis apread
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // off plane
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // plane spread
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
    { TYPE_INT, NULL, FALSE, 29 }, // use subtree
    { TYPE_INT, NULL, FALSE, 30 }, // animation offset
    { TYPE_INT, NULL, FALSE, 31 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble amp61
	{ TYPE_FLOAT, NULL, TRUE, 62 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 63 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 64 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 65 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 66 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 67 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 68 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, FALSE, 69 },  // ViewPort Courseness
	{ TYPE_INT, NULL, FALSE, 70 },  // Subframe rot
	{ TYPE_INT, NULL, FALSE, 71 },  // Spawn Percent
	{ TYPE_FLOAT, NULL, FALSE, 72 },  // Spawn Mult var
};

static ParamBlockDescID spdescVer4[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // off axis
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // axis apread
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // off plane
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // plane spread
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
    { TYPE_INT, NULL, FALSE, 29 }, // use subtree
    { TYPE_INT, NULL, FALSE, 30 }, // animation offset
    { TYPE_INT, NULL, FALSE, 31 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble amp61
	{ TYPE_FLOAT, NULL, TRUE, 62 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 63 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 64 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 65 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 66 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 67 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 68 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, FALSE, 69 },  // ViewPort Courseness
	{ TYPE_INT, NULL, FALSE, 70 },  // Subframe rot
	{ TYPE_INT, NULL, FALSE, 71 },  // Spawn Percent
	{ TYPE_FLOAT, NULL, FALSE, 72 },  // Spawn Mult var
	{ TYPE_INT, NULL, FALSE, 73 },  // Surface Tracking
};

static ParamBlockDescID spdescVer5[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // off axis
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // axis apread
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // off plane
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // plane spread
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
    { TYPE_INT, NULL, FALSE, 29 }, // use subtree
    { TYPE_INT, NULL, FALSE, 30 }, // animation offset
    { TYPE_INT, NULL, FALSE, 31 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble amp61
	{ TYPE_FLOAT, NULL, TRUE, 62 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 63 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 64 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 65 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 66 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 67 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 68 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, FALSE, 69 },  // ViewPort Courseness
	{ TYPE_INT, NULL, FALSE, 70 },  // Subframe rot
	{ TYPE_INT, NULL, FALSE, 71 },  // Spawn Percent
	{ TYPE_FLOAT, NULL, FALSE, 72 },  // Spawn Mult var
	{ TYPE_INT, NULL, FALSE, 73 },  // Surface Tracking
	{ TYPE_INT, NULL, TRUE, 74 },  // dies after X
	{ TYPE_FLOAT, NULL, TRUE, 75 },  // dies after X var
};

static ParamBlockDescID spdescVer6[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // off axis
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // axis apread
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // off plane
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // plane spread
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
    { TYPE_INT, NULL, FALSE, 29 }, // use subtree
    { TYPE_INT, NULL, FALSE, 30 }, // animation offset
    { TYPE_INT, NULL, FALSE, 31 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble amp61
	{ TYPE_FLOAT, NULL, TRUE, 62 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 63 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 64 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 65 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 66 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 67 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 68 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, FALSE, 69 },  // ViewPort Courseness
	{ TYPE_INT, NULL, FALSE, 70 },  // Subframe rot
	{ TYPE_INT, NULL, FALSE, 71 },  // Spawn Percent
	{ TYPE_FLOAT, NULL, FALSE, 72 },  // Spawn Mult var
	{ TYPE_INT, NULL, FALSE, 73 },  // Surface Tracking
	{ TYPE_INT, NULL, TRUE, 74 },  // dies after X
	{ TYPE_FLOAT, NULL, TRUE, 75 },  // dies after X var

	{ TYPE_INT, NULL, FALSE, 76 },  // IPC Enable
	{ TYPE_INT, NULL, FALSE, 77 },  // IPC Steps
	{ TYPE_FLOAT, NULL, TRUE, 78 },  // IPC Bounce
	{ TYPE_FLOAT, NULL, TRUE, 79 },  // IPC Bounce Var
};

#define PBLOCK_LENGTH_SUPRSPRAY 80

static ParamVersionDesc spversions[] = {
	ParamVersionDesc(spdescVer0,69,0),
	ParamVersionDesc(spdescVer1,70,1),
	ParamVersionDesc(spdescVer2,71,2),
	ParamVersionDesc(spdescVer3,73,3),
	ParamVersionDesc(spdescVer4,74,4),
	ParamVersionDesc(spdescVer5,76,5),
	};
#define NUM_OLDVERSIONS	6

// Current version
#define CURRENT_VERSION	6

#define PB_TUMBLE					0
#define PB_TUMBLERATE				1
#define PB_EMITMAP					2
#define PB_EMITRLENGTH				3
#define PB_CUSTOMMTL2				61
#define PB_METACOURSEVB				62
#define PB_SUBFRAMEROT2				63
#define PB_SPAWNPERCENT2			64
#define PB_SPAWNMULTVAR2			65
#define PB_BLNOTDRAFT				66
#define PB_BLSPAWNDIEAFTER			67
#define PB_BLSPAWNDIEAFTERVAR		68
#define PB_BLIPCOLLIDE_ON			69
#define PB_BLIPCOLLIDE_STEPS		70
#define PB_BLIPCOLLIDE_BOUNCE		71
#define PB_BLIPCOLLIDE_BOUNCEVAR	72

static int bmappingIDs[] = {IDC_SP_MAPTIME,IDC_SP_MAPDIST,IDC_SP_MAPPLANAR};

// Spin Dialog for Blizzard
static ParamUIDesc descBParamPSpin[] = {

	// Spin Time
	ParamUIDesc(
		PB_SPINTIME,
		EDITTYPE_TIME,
		IDC_SP_SPIN,IDC_SP_SPINSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Spin Time Var
	ParamUIDesc(
		PB_SPINTIMEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINVAR,IDC_SP_SPINVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Spin Phase
	ParamUIDesc(
		PB_SPINPHASE,
		EDITTYPE_FLOAT,
		IDC_SP_SPINPHA,IDC_SP_SPINPHASPIN,
		-360.0f,360.0f,
		0.01f,
		stdAngleDim),

	// Spin Phase Variation
	ParamUIDesc(
		PB_SPINPHASEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINPHAVAR,IDC_SP_SPINPHAVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Enter Axis Control
	ParamUIDesc(PB_SPINAXISTYPE,TYPE_RADIO,bspindirectionIDs,2),

	// X-Axis
	ParamUIDesc(
		PB_SPINAXISX,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISX,IDC_SP_SPINAXISXSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Y-Axis
	ParamUIDesc(
		PB_SPINAXISY,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISY,IDC_SP_SPINAXISYSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Z-Axis
	ParamUIDesc(
		PB_SPINAXISZ,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISZ,IDC_SP_SPINAXISZSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Spin Direction Variation
	ParamUIDesc(
		PB_SPINAXISVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISVAR,IDC_SP_SPINAXISVARSPIN,
		-180.0f,180.0f,
		0.01f,
		stdAngleDim),

	// IPC Enable
	ParamUIDesc(PB_BLIPCOLLIDE_ON,TYPE_SINGLECHEKBOX,IDC_INTERP_BOUNCEON),

	// IPC Steps
	ParamUIDesc(
		PB_BLIPCOLLIDE_STEPS,
		EDITTYPE_INT,
		IDC_INTERP_NSTEPS,IDC_INTERP_NSTEPSSPIN,
		1.0f,1000.0f,
		1.0f),

	// IPC Bounce
	ParamUIDesc(
		PB_BLIPCOLLIDE_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_INTERP_BOUNCE,IDC_INTERP_BOUNCESPIN,
		0.0f,10000.0f,
		1.0f,
		stdPercentDim),

	// IPC Bounce
	ParamUIDesc(
		PB_BLIPCOLLIDE_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_INTERP_BOUNCEVAR,IDC_INTERP_BOUNCEVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),
};

#define BPARAMPSPIN_LENGTH 13

static ParamUIDesc BdescParamPType[] = {

	// Particle Class
	ParamUIDesc(PB_PARTICLECLASS,TYPE_RADIO,particleclassIDs,3),

	// Particle Type
	ParamUIDesc(PB_PARTICLETYPE,TYPE_RADIO,particletypeIDs,8),

	// Metaball Tension
	ParamUIDesc(
		PB_METATENSION,
		EDITTYPE_UNIVERSE,
		IDC_SP_METTENS,IDC_SP_METTENSSPIN,
		0.1f,10.0f,
		SPIN_AUTOSCALE),

	// Metaball Tension Variation
	ParamUIDesc(
		PB_METATENSIONVAR,
		EDITTYPE_FLOAT,
		IDC_SP_METTENSVAR,IDC_SP_METTENSVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Metaball Courseness
	ParamUIDesc(
		PB_METACOURSE,
		EDITTYPE_UNIVERSE,
		IDC_SP_METCOURSE,IDC_SP_METCOURSESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Metaball Courseness ViewPort
	ParamUIDesc(
		PB_METACOURSEVB,
		EDITTYPE_UNIVERSE,
		IDC_SP_METCOURSEV,IDC_SP_METCOURSEVSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Metaball Auto Coarseness
	ParamUIDesc(PB_METAAUTOCOARSE,TYPE_SINGLECHEKBOX,IDC_SP_AUTOCOARSE),
     
	// Display type
	ParamUIDesc(PB_BLNOTDRAFT,TYPE_SINGLECHEKBOX,IDC_SP_DRAFTMODE),

	// Use Subtree Checkbox
	ParamUIDesc(PB_USESUBTREE,TYPE_SINGLECHEKBOX,IDC_AP_USESUBTREE),

	// Display type
	ParamUIDesc(PB_ANIMATIONOFFSET,TYPE_RADIO,animateoffsetIDs,3),

	// Animation Offset Amount
	ParamUIDesc(
		PB_OFFSETAMOUNT,
		EDITTYPE_TIME,
		IDC_AP_ANIRNDFR,IDC_AP_ANIRNDFRSPIN,
		1.0f,999999999.0f,
		10.0f),

	// Mapping Across
	ParamUIDesc(PB_MAPPINGTYPE,TYPE_RADIO,bmappingIDs,3),

	// Time Mapping Option
	ParamUIDesc(
		PB_MAPPINGTIME,
		EDITTYPE_TIME,
		IDC_SP_MAPTIMEVAL,IDC_SP_MAPTIMEVALSPIN,
		1.0f,999999999.0f,
		10.0f),

	// Distance Mapping Option
	ParamUIDesc(
		PB_MAPPINGDIST,
		EDITTYPE_UNIVERSE,
		IDC_SP_MAPDISTVAL,IDC_SP_MAPDISTVALSPIN,
		0.1f,999999999.0f,
		SPIN_AUTOSCALE),

	// Use Custom Mtl
	ParamUIDesc(PB_CUSTOMMTL2,TYPE_RADIO,custmtlIDs,2),
};
#define BPARAMPTYPE_LENGTH 15

// Dialog Unique to Particle Array
static ParamUIDesc BdescParam[] = {

	// Emitter Width
	ParamUIDesc(
		PB_EMITRWID,
		EDITTYPE_UNIVERSE,
		IDC_SP_EMITWID,IDC_SP_EMITWIDSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Emitter Length
	ParamUIDesc(
		PB_EMITRLENGTH,
		EDITTYPE_UNIVERSE,
		IDC_SP_EMITLEN,IDC_SP_EMITLENSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Hide Emitter
	ParamUIDesc(PB_EMITRHID,TYPE_SINGLECHEKBOX,IDC_SP_EMITHID),

	// Animation Offset Type
	ParamUIDesc(PB_VIEWPORTSHOWS,TYPE_RADIO,viewportoptionIDs,4),

	// Particle Display Portion
	ParamUIDesc(
		PB_DISPLAYPORTION,
		EDITTYPE_FLOAT,
		IDC_SP_GENDISP,IDC_SP_GENDISPSPIN,
		0.0f,100.0f,
		0.1f,
		stdPercentDim),
};
#define PARAMBLIZZARD_LENGTH 5

// Common Dialog for Particle Generation
static ParamUIDesc BdescParamPGen[] = {

	// Distribution Method
	ParamUIDesc(PB_BIRTHMETHOD,TYPE_RADIO,countIDs,2),

	// Particle Birth Rate
	ParamUIDesc(
		PB_PBIRTHRATE,
		EDITTYPE_INT,
		IDC_SP_GENRATE,IDC_SP_GENRATESPIN,
		0.0f,65000.0f,
		1.0f),

	// Particle Total Count
	ParamUIDesc(
		PB_PTOTALNUMBER,
		EDITTYPE_INT,
		IDC_SP_GENTTL,IDC_SP_GENTTLSPIN,
		0.0f,65000.0f,
		1.0f),

	// Particle Speed
	ParamUIDesc(
		PB_SPEED,
		EDITTYPE_UNIVERSE,
		IDC_SP_BLIZSPEED,IDC_SP_BLIZSPEEDSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Speed Var
	ParamUIDesc(
		PB_SPEEDVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BLIZSPEEDVAR,IDC_SP_BLIZSPEEDVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Particle Tumble 
	ParamUIDesc(
		PB_TUMBLE,
		EDITTYPE_FLOAT,
		IDC_SP_BLIZTUMBL,IDC_SP_BLIZTUMBLSPIN,
		0.0f,1.0f,
		0.005f),

	// Particle Tumble Rate
	ParamUIDesc(
		PB_TUMBLERATE,
		EDITTYPE_UNIVERSE,
		IDC_SP_BLIZTUMBLRATE,IDC_SP_BLIZTUMBLRATESPIN,
		0.0f,999999999.0f,
		0.01f),

	// Emitter Start Time
	ParamUIDesc(
		PB_EMITSTART,
		EDITTYPE_TIME,
		IDC_SP_GENEMIT1,IDC_SP_GENEMIT1SPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Emitter Stop Time
	ParamUIDesc(
		PB_EMITSTOP,
		EDITTYPE_TIME,
		IDC_SP_GENEMIT2,IDC_SP_GENEMIT2SPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Particle Time Limit
	ParamUIDesc(
		PB_DISPUNTIL,
		EDITTYPE_TIME,
		IDC_SP_DISPUNTIL,IDC_SP_DISPUNTILSPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Particle Life
	ParamUIDesc(
		PB_LIFE,	
		EDITTYPE_TIME,
		IDC_SP_GENLIFE,IDC_SP_GENLIFESPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Life Var
	ParamUIDesc(
		PB_LIFEVAR,
		EDITTYPE_TIME,
		IDC_SP_GENLIFEVAR,IDC_SP_GENLIFEVARSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Subframe Time and Motion Sampling
	ParamUIDesc(PB_SUBFRAMEMOVE,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLMOVE),
	ParamUIDesc(PB_SUBFRAMETIME,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLTIME),
	ParamUIDesc(PB_SUBFRAMEROT2,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLROT),

	// Particle Size
	ParamUIDesc(
		PB_SIZE,
		EDITTYPE_UNIVERSE,
		IDC_SP_GENSIZE,IDC_SP_GENSIZESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Size Var
	ParamUIDesc(
		PB_SIZEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_GENSIZEVAR,IDC_SP_GENSIZEVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Particle Grow Time
	ParamUIDesc(
		PB_GROWTIME,
		EDITTYPE_TIME,
		IDC_SP_GENGRO,IDC_SP_GENGROSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Fade Time
	ParamUIDesc(
		PB_FADETIME,
		EDITTYPE_TIME,
		IDC_SP_GENFAD,IDC_SP_GENFADSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Random Number Seed
	ParamUIDesc(
		PB_RNDSEED,
		EDITTYPE_INT,
		IDC_SP_GENSEED,IDC_SP_GENSEEDSPIN,
		0.0f,25000.0f,
		1.0f),
	};

#define BPARAMPGEN_LENGTH 20

static ParamUIDesc descBPSpawning[] = {
	
	// Spawing Effects Type
	ParamUIDesc(PB_SPAWNTYPE,TYPE_RADIO,SpawnTypeIDs,5),

	// Die after X
	ParamUIDesc(
		PB_BLSPAWNDIEAFTER,
		EDITTYPE_TIME,
		IDC_AP_MAXSPAWNDIEAFTER,IDC_AP_MAXSPAWNDIEAFTERSPIN,
		0.0f,999999999.0f,
		10.0f),

	ParamUIDesc(
		PB_BLSPAWNDIEAFTERVAR,
		EDITTYPE_FLOAT,
		IDC_AP_MAXSPAWNDIEAFTERVAR,IDC_AP_MAXSPAWNDIEAFTERVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Spawn Generations
	ParamUIDesc(
		PB_SPAWNGENS,
		EDITTYPE_INT,
		IDC_AP_MAXSPAWNGENS,IDC_AP_MAXSPAWNGENSSPIN,
		1.0f,65000.0f,
		1.0f),

	// Spawn Generations
	ParamUIDesc(
		PB_SPAWNPERCENT2,
		EDITTYPE_INT,
		IDC_AP_PARENTPERCENT,IDC_AP_PARENTPERCENTSPIN,
		1.0f,100.0f,
		1.0f),

	// Spawn Spawncount
	ParamUIDesc(
		PB_SPAWNCOUNT,
		EDITTYPE_INT,
		IDC_AP_NUMBERVAR,IDC_AP_NUMBERVARSPIN,
		1.0f,65000.0f,
		1.0f),

	// Spawn Mult Percent
	ParamUIDesc(
		PB_SPAWNMULTVAR2,
		EDITTYPE_FLOAT,
		IDC_AP_NUMBERVARVAR,IDC_AP_NUMBERVARVARSPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Spawn Direction Chaos
	ParamUIDesc(
		PB_SPAWNDIRCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSANGLE,IDC_AP_CHAOSANGLESPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Spawn Speed Chaos
	ParamUIDesc(
		PB_SPAWNSPEEDCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSPEED,IDC_AP_CHAOSSPEEDSPIN,
		0.0f,100.0f,
		0.1f),

	// Spawing Speed Sign
	ParamUIDesc(PB_SPAWNSPEEDSIGN,TYPE_RADIO,SpeedChaosIDs,3),

	// Spawning Inherit Parent V
	ParamUIDesc(PB_SPAWNINHERITV,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSUMV),

	// Spawning Speed Fixed
	ParamUIDesc(PB_SPAWNSPEEDFIXED,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSPEEDFIXED),

	// Spawn Scale Chaos
	ParamUIDesc(
		PB_SPAWNSCALECHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSCALE,IDC_AP_CHAOSSCALESPIN,
		0.0f,100.0f,
		0.1f),

	// Spawning Scale Sign
	ParamUIDesc(PB_SPAWNSCALESIGN,TYPE_RADIO,ScaleChaosIDs,3),

	// Spawning Speed Fixed
	ParamUIDesc(PB_SPAWNSCALEFIXED,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSCALEFIXED),

	// Spawn Lifespan Entry Field
	ParamUIDesc(
		PB_SPAWNLIFEVLUE,
		EDITTYPE_INT,
		IDC_AP_QUEUELIFESPAN,IDC_AP_QUEUELIFESPANSPIN,
		0.0f,65000.0f,
		SPIN_AUTOSCALE),
};

#define PBSPAWNINGPARAMS_LENGTH 16

// Particle Type for Blizzard

static ParamBlockDescID BdescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // tumble
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // tumblerate
	{ TYPE_FLOAT, NULL, FALSE, 2 },	 // emit map
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // emitter length
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 },    // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
	{ TYPE_INT, NULL, FALSE, 29 }, // use subtree
	{ TYPE_INT, NULL, FALSE, 30 }, // animation offset 
	{ TYPE_INT, NULL, FALSE, 31 }, // animation offset time

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choose
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_INT, NULL, FALSE, 61 },  // custmlt
};

static ParamBlockDescID BdescVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // tumble
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // tumblerate
	{ TYPE_FLOAT, NULL, FALSE, 2 },	 // emit map
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // emitter length
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 },    // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
	{ TYPE_INT, NULL, FALSE, 29 }, // use subtree
	{ TYPE_INT, NULL, FALSE, 30 }, // animation offset 
	{ TYPE_INT, NULL, FALSE, 31 }, // animation offset time

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choose
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_INT, NULL, FALSE, 61 },  // custmlt
	{ TYPE_FLOAT, NULL, FALSE, 62 }, // meta course Viewport
};
static ParamBlockDescID BdescVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // tumble
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // tumblerate
	{ TYPE_FLOAT, NULL, FALSE, 2 },	 // emit map
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // emitter length
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 },    // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
	{ TYPE_INT, NULL, FALSE, 29 }, // use subtree
	{ TYPE_INT, NULL, FALSE, 30 }, // animation offset 
	{ TYPE_INT, NULL, FALSE, 31 }, // animation offset time

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choose
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_INT, NULL, FALSE, 61 },  // custmlt
	{ TYPE_FLOAT, NULL, FALSE, 62 }, // meta course Viewport
	{ TYPE_INT, NULL, FALSE, 63},  // subframe rot
};
static ParamBlockDescID BdescVer3[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // tumble
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // tumblerate
	{ TYPE_FLOAT, NULL, FALSE, 2 },	 // emit map
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // emitter length
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 },    // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
	{ TYPE_INT, NULL, FALSE, 29 }, // use subtree
	{ TYPE_INT, NULL, FALSE, 30 }, // animation offset 
	{ TYPE_INT, NULL, FALSE, 31 }, // animation offset time

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choose
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_INT, NULL, FALSE, 61 },  // custmlt
	{ TYPE_FLOAT, NULL, FALSE, 62 }, // meta course Viewport
	{ TYPE_INT, NULL, FALSE, 63},  // subframe rot
	{ TYPE_INT, NULL, FALSE, 64 }, // Spawn PErcent
	{ TYPE_FLOAT, NULL, FALSE, 65},  // spawn mult var
};
static ParamBlockDescID BdescVer4[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // tumble
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // tumblerate
	{ TYPE_FLOAT, NULL, FALSE, 2 },	 // emit map
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // emitter length
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 },    // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
	{ TYPE_INT, NULL, FALSE, 29 }, // use subtree
	{ TYPE_INT, NULL, FALSE, 30 }, // animation offset 
	{ TYPE_INT, NULL, FALSE, 31 }, // animation offset time

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choose
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_INT, NULL, FALSE, 61 },  // custmlt
	{ TYPE_FLOAT, NULL, FALSE, 62 }, // meta course Viewport
	{ TYPE_INT, NULL, FALSE, 63},  // subframe rot
	{ TYPE_INT, NULL, FALSE, 64 }, // Spawn PErcent
	{ TYPE_FLOAT, NULL, FALSE, 65},  // spawn mult var
	{ TYPE_INT, NULL, TRUE, 66 }, // Draft
};

static ParamBlockDescID BdescVer5[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // tumble
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // tumblerate
	{ TYPE_FLOAT, NULL, FALSE, 2 },	 // emit map
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // emitter length
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 },    // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
	{ TYPE_INT, NULL, FALSE, 29 }, // use subtree
	{ TYPE_INT, NULL, FALSE, 30 }, // animation offset 
	{ TYPE_INT, NULL, FALSE, 31 }, // animation offset time

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choose
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_INT, NULL, FALSE, 61 },  // custmlt
	{ TYPE_FLOAT, NULL, FALSE, 62 }, // meta course Viewport
	{ TYPE_INT, NULL, FALSE, 63},  // subframe rot
	{ TYPE_INT, NULL, FALSE, 64 }, // Spawn PErcent
	{ TYPE_FLOAT, NULL, FALSE, 65},  // spawn mult var
	{ TYPE_INT, NULL, TRUE, 66 }, // Draft
	{ TYPE_INT, NULL, TRUE, 67 }, // Dies after X
	{ TYPE_FLOAT, NULL, TRUE, 68 }, // Dies after X var
};

static ParamBlockDescID BdescVer6[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	 // tumble
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // tumblerate
	{ TYPE_FLOAT, NULL, FALSE, 2 },	 // emit map
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // emitter length
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // speed var

	{ TYPE_INT, NULL, FALSE, 6 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 7 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 8 },    // total number
	{ TYPE_INT, NULL, FALSE, 9 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 10 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 11 },   // display until
	{ TYPE_INT, NULL, TRUE, 12 },	 // life
	{ TYPE_INT, NULL, TRUE, 13 },	 // life var
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 15 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size var
	{ TYPE_INT, NULL, FALSE, 18 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 19 },    // fade time
	{ TYPE_INT, NULL, FALSE, 20 },    // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 21 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 22 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 23 },  // particle class
	{ TYPE_INT, NULL, FALSE, 24 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 26 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 27 }, // meta course
	{ TYPE_INT, NULL, FALSE, 28 }, // auto coarseness
	{ TYPE_INT, NULL, FALSE, 29 }, // use subtree
	{ TYPE_INT, NULL, FALSE, 30 }, // animation offset 
	{ TYPE_INT, NULL, FALSE, 31 }, // animation offset time

	{ TYPE_INT, NULL, FALSE, 32 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 33 }, // display portion
	{ TYPE_INT, NULL, FALSE, 34 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 35 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 36 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 37 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 38 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 39 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 40 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 41 },  // spin axis choose
	{ TYPE_FLOAT, NULL, TRUE, 42 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 43 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 44 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 46 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 48 },  // emit mult var

	{ TYPE_INT, NULL, FALSE, 49 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 50 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 51 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 53 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 54 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 55 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 56 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 57 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 58 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 59 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 60 }, // constant spawn scale

	{ TYPE_INT, NULL, FALSE, 61 },  // custmlt
	{ TYPE_FLOAT, NULL, FALSE, 62 }, // meta course Viewport
	{ TYPE_INT, NULL, FALSE, 63},  // subframe rot
	{ TYPE_INT, NULL, FALSE, 64 }, // Spawn PErcent
	{ TYPE_FLOAT, NULL, FALSE, 65},  // spawn mult var
	{ TYPE_INT, NULL, TRUE, 66 }, // Draft
	{ TYPE_INT, NULL, TRUE, 67 }, // Dies after X
	{ TYPE_FLOAT, NULL, TRUE, 68 }, // Dies after X var

	{ TYPE_INT, NULL, FALSE, 69 }, // IPC Enable
	{ TYPE_INT, NULL, FALSE, 70 }, // IPC Steps
	{ TYPE_FLOAT, NULL, TRUE, 71 }, // IPC Bounce
	{ TYPE_FLOAT, NULL, TRUE, 72 }, // IPC Bounce Var
};

static ParamVersionDesc Bversions[] = {
	ParamVersionDesc(BdescVer0,62,0),
	ParamVersionDesc(BdescVer1,63,1),
	ParamVersionDesc(BdescVer2,64,2),
	ParamVersionDesc(BdescVer3,66,3),
	ParamVersionDesc(BdescVer4,67,4),
	ParamVersionDesc(BdescVer5,69,5),
	};
#define PBLOCK_LENGTH_BLIZZARD 73

static ParamVersionDesc curVersionBL(BdescVer6,PBLOCK_LENGTH_BLIZZARD,CURRENT_VERSION);
static ParamVersionDesc curVersionSp(spdescVer6,PBLOCK_LENGTH_SUPRSPRAY,CURRENT_VERSION);

//-- ParticleDlgProc ------------------------------------------------

class CreateSSBlizProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		CommonParticle *SSBlizObject;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreateSSBlizProc()
			{
			ignoreSelectionChange = FALSE;
			}
//		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};
class ComObjectListRestore : public RestoreObj {
	public:   		
		CommonParticle *po;
		Tab<INode*> unodes;
		Tab<INode*> rnodes;
		int lnum,lnum2;
		ComObjectListRestore(CommonParticle *p) 
		{  po=p;
		   unodes=p->nlist;
		}
		void Restore(int isUndo)
		{	if (isUndo) {
				rnodes = po->nlist;
				}
			po->nlist = unodes;
			po->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		}
		void Redo() 
		{	po->nlist = rnodes;
			po->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		}
	};

class LifeListRestore : public RestoreObj {
	public:   		
		CommonParticle *po;
		Tab<int> utimes;
		Tab<int> rtimes;
		LifeListRestore(CommonParticle *p) 
		{ po=p;
		  utimes=p->llist;
		}
		void Restore(int isUndo)
		{ if (isUndo) { rtimes = po->llist;	}
		  po->llist=utimes;
		  if (po->ip) po->SetUpLifeList();
		}
		void Redo() 
		{ po->llist = rtimes;
		  if (po->ip) po->SetUpLifeList();
		}
	};

class CreateCPartPickNode : public RestoreObj {
	public:   		
		CommonParticle *obj;
		TSTR name,name2;
		CreateCPartPickNode(CommonParticle *o, TSTR n,TSTR n1) {
			obj = o; name=TSTR(n);name2=TSTR(n1);
			}
		void Restore(int isUndo) {
			if (obj->custnode) 
			 obj->custname = name;
			else 
			  obj->custname=TSTR(_T(""));
			obj->ShowName();
			}
		void Redo() 
		{ obj->custname = name2;
		if (obj->hptype)
	{TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (_tcslen(name2)>0? obj->custname : TSTR(GetString(IDS_AP_NONE)));
	SetWindowText(GetDlgItem(obj->hptype, IDC_AP_INSTANCESRCNAME), name);}
			}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};
class CreateCPartDelNode : public RestoreObj {
	public:   		
		CommonParticle *obj;
		TSTR name;
		CreateCPartDelNode(CommonParticle *o, TSTR n) {
			obj = o; name=TSTR(n);
			}
		void Restore(int isUndo)
		{obj->custname = name;
		 obj->ShowName();
			}
		void Redo() 
			{  obj->custname=TSTR(_T(""));
		if (obj->hptype)
	{TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + TSTR(GetString(IDS_AP_NONE));
	SetWindowText(GetDlgItem(obj->hptype, IDC_AP_INSTANCESRCNAME), name);}
			}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};

#define CID_CREATESSBlizMODE	CID_USER +15

class CreateSSBlizMode : public CommandMode {		
	public:		
		CreateSSBlizProc proc;
		IObjParam *ip;
		CommonParticle *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,CommonParticle*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATESSBlizMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreateSSBlizMode theCreateSSBlizMode;

RefResult CreateSSBlizProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( SSBlizObject && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (SSBlizObject && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (SSBlizObject->creating) 
						{  theCreateSSBlizMode.JumpStart(SSBlizObject->ip,SSBlizObject);
							createInterface->SetCommandMode(&theCreateSSBlizMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				SSBlizObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				SSBlizObject  = NULL;				
				CloudNode    = NULL;
/*				if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);*/
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreateSSBlizProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	SSBlizObject       = NULL;
	CreateNewObject();
	}
void CreateSSBlizProc::CreateNewObject()
	{
	SSBlizObject = (CommonParticle*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
	// Start the edit params process
	if ( SSBlizObject ) {
		SSBlizObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		SSBlizObject->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreateSSBlizProc::End()
{ if ( SSBlizObject ) 
	{ 
#ifdef _OSNAP
		SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	
	SSBlizObject->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete SSBlizObject;
			SSBlizObject = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		}  else if ( CloudNode ) 
		{	theHold.Suspend();
			DeleteReference(0);  // sets cloudNode = NULL
			theHold.Resume();}
	}
}

void CreateSSBlizMode::JumpStart(IObjParam *i,CommonParticle *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

int BlizzardClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateSSBlizMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateSSBlizMode);
	return TRUE;
	}

int BlizzardClassDesc::EndCreate(Interface *i)
	{
	theCreateSSBlizMode.End();
	i->RemoveMode(&theCreateSSBlizMode);
	return TRUE;
	}
int SuprSprayClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateSSBlizMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateSSBlizMode);
	return TRUE;
	}

int SuprSprayClassDesc::EndCreate(Interface *i)
	{
	theCreateSSBlizMode.End();
	i->RemoveMode(&theCreateSSBlizMode);
	return TRUE;
	}

int CreateSSBlizProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res=TRUE;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( SSBlizObject );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
#ifdef _OSNAP
						SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				   		SSBlizObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						// Get rid of the reference.
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}
						// new object
						CreateNewObject();   // creates SSBlizObject
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( SSBlizObject);
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = SSBlizObject->GetCreateMouseCallBack();
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();
					mat.IdentityMatrix();
				default:				
					if (createCB) {						
						res = createCB->proc(vpx,msg,point,flag,m,mat);
						createInterface->SetNodeTMRelConstPlane(CloudNode,mat);

						if (res==CREATE_ABORT)
							goto abort;
						if (res==CREATE_STOP)
						{
#ifdef _OSNAP
                         SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
						 theHold.Accept(GetString(IDS_DS_CREATE));	
						}
						
						createInterface->RedrawViews(createInterface->GetTime());   //DS
						}

					break;
					
				}			
			break;

		case MOUSE_MOVE:
			if (createCB) {				
				res = createCB->proc(vpx,msg,point,flag,m,mat);
				createInterface->SetNodeTMRelConstPlane(CloudNode,mat);
				if (res==CREATE_ABORT) 
					goto abort;
				if (res==CREATE_STOP){
#ifdef _OSNAP
         SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
					theHold.Accept(GetString(IDS_DS_CREATE));	// TH
				}
				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_INTERACTIVE);		//DS		
				}
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: 
	if (createCB)
	{ res = createCB->proc(vpx,msg,point,flag,m,mat);
	  createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
	  if (res==CREATE_ABORT)
	      goto abort;
	  if (res==CREATE_STOP)
	  {
#ifdef _OSNAP
         SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	    theHold.Accept(GetString(IDS_DS_CREATE));	
	  }
		break;
	}
	abort:
		assert( SSBlizObject );
#ifdef _OSNAP
		SSBlizObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		SSBlizObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);
		SSBlizObject=NULL;
		createInterface->RedrawViews(createInterface->GetTime());
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		break;
	
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP  //PREVIEW SNAP
			if (createCB) res =createCB->proc(vpx,msg,point,flag,m,mat);
#endif
		vpx->TrackImplicitGrid(m);
			break;
	}

	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
}

void CheckInstButtons(IParamBlock *pblock,HWND hptype)
{ int isinst;
  pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
  if (isinst==INSTGEOM)
  { TurnButton(hptype,IDC_AP_OBJECTPICK,TRUE);
  }
}
void CheckLifeButtons(int stype,HWND spawn)
{ int rep;
  rep = SendMessage(GetDlgItem(spawn,IDC_AP_LIFEQUEUE),LB_GETCURSEL,0,0);
  TurnButton(spawn,IDC_AP_LIFEQUEUEADD,(stype>1));
  TurnButton(spawn,IDC_AP_LIFEQUEUEREPL,(stype>1)&&(rep>-1));
  TurnButton(spawn,IDC_AP_LIFEQUEUEDEL,(stype>1)&&(rep>-1));
}

void CheckSpawnButtons(IParamBlock *pblock,HWND spawn,int repi)
{ int stype;
  pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
  EnableWindow(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),(stype>1));
  TurnButton(spawn,IDC_AP_OBJECTQUEUEPICK,(stype>1));
  TurnButton(spawn,IDC_AP_OBJQUEUEREPLACE,(stype>1)&&(repi>-1));
  TurnButton(spawn,IDC_AP_OBJQUEUEDELETE,(stype>1)&&(repi>-1));
  CheckLifeButtons(stype,spawn);
}

void CheckPickButtons(IParamBlock *pblock,HWND hptype,HWND spawn,int repi)
{ CheckInstButtons(pblock,hptype);
  CheckSpawnButtons(pblock,spawn,repi);
}

class EmitterCreateCallback : public CreateMouseCallBack {
	public:
		SuprSprayParticle *po;
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int EmitterCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point)  {
			case 0:
				// if hidden by category, re-display particles and objects
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				sp0 = m;
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				po->pblock->SetValue(PB_EMITRWID,0,0.01f);
				po->pmapParam->Invalidate();
				break;

			case 1: {
//				mat.IdentityMatrix();
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,snapdim);
				po->pblock->SetValue(PB_EMITRWID,0,Length(p1-p0));
				po->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 || Length(p1-p0)<0.1f) {						
						return CREATE_ABORT;
					} else { CheckPickButtons(po->pblock,po->hptype,po->spawn,po->pickCB.repi);
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}
	return 1;
	}

static EmitterCreateCallback emitterCallback;

CreateMouseCallBack* SuprSprayParticle::GetCreateMouseCallBack() 
	{
	emitterCallback.po = this;
	return &emitterCallback;
	}

class SSParticleGenDlgProc : public ParamMapUserDlgProc {
	public:
		CommonParticle *po;

		SSParticleGenDlgProc(CommonParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};
void SSParticleGenDlgProc::Update(TimeValue t)
{ if (!po->editOb) return;
  int birthmeth;
  po->pblock->GetValue(PB_BIRTHMETHOD,0,birthmeth,FOREVER);
  if (birthmeth)
  { SpinnerOff(po->hgen,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
    SpinnerOn(po->hgen,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
  }else 
  { SpinnerOn(po->hgen,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
    SpinnerOff(po->hgen,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
  }
}

BOOL SSParticleGenDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{  int acourse;
       float size;
      switch (msg) 
	  { case WM_INITDIALOG: {
		    Update(t);
			break;
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SP_GENUSERATE:
				{ SpinnerOn(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
				  SpinnerOff(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
				 return TRUE;
				}
			  case IDC_SP_GENUSETTL:
				{ SpinnerOff(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
				  SpinnerOn(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
				 return TRUE;
				}
			}
			case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) 
			{ case IDC_SP_GENSIZESPIN:
				   { po->pblock->GetValue(PB_METAAUTOCOARSE,t,acourse,FOREVER);
					int mpart;
				    po->pblock->GetValue(PB_PARTICLECLASS,t,mpart,FOREVER);
				    if ((mpart==METABALLS)&&(acourse) )
					 { po->pblock->GetValue(PB_SIZE,t,size,FOREVER);
					   po->pblock->SetValue(PB_METACOURSE,t,size/coursedivider);
					   BOOL bliz=(po->ClassID()==BLIZZARD_CLASS_ID);
					   if (bliz) po->pblock->SetValue(PB_METACOURSEVB,t,size/3.0f);
					   else po->pblock->SetValue(PB_METACOURSEV,t,size/3.0f);
					   po->pmapPType->Invalidate();
					 }
					break;
				   }
				case IDC_AP_NEWSEED:
					{ srand( (unsigned)time( NULL ) );
					  int newseed=rand() % 25001;
					  po->pblock->SetValue(PB_RNDSEED,0,newseed);
					  po->pmapPGen->Invalidate();
					}
			        return TRUE;
				case IDC_SP_GENEMIT1SPIN:
				case IDC_SP_GENEMIT2SPIN:
					{ int sstop,sstart;
					  po->pblock->GetValue(PB_EMITSTOP,t,sstop,FOREVER);
					  po->pblock->GetValue(PB_EMITSTART,t,sstart,FOREVER);
					  if (sstop<sstart) 
					     po->pblock->SetValue(PB_EMITSTOP,t,sstart);
					  return TRUE;
					}
			}
	  }
	return FALSE;
	}
void CourseCheck(CommonParticle *po,HWND hWnd,TimeValue t)
{ int acourse;
  float size;
  po->pblock->GetValue(PB_METAAUTOCOARSE,t,acourse,FOREVER);
  BOOL bliz=(po->ClassID()==BLIZZARD_CLASS_ID);
  if (acourse) 
  { float mc1,mc2,mc,mcv;
	po->pblock->GetValue(PB_SIZE,t,size,FOREVER);mc=size/coursedivider;mcv=size/3.0f;
	po->pblock->GetValue(PB_METACOURSE,t,mc1,FOREVER);
	if (bliz) po->pblock->GetValue(PB_METACOURSEVB,t,mc2,FOREVER);
	else po->pblock->GetValue(PB_METACOURSEV,t,mc2,FOREVER);
	if ((mc1!=mc)||(mc2!=mcv))
	{ po->pblock->SetValue(PB_METACOURSE,t,mc);
	  if (bliz) po->pblock->SetValue(PB_METACOURSEVB,t,mcv);
	  else po->pblock->SetValue(PB_METACOURSEV,t,mcv);
	  po->pmapPType->Invalidate();
	}
	SpinnerOff(hWnd,IDC_SP_METCOURSESPIN,IDC_SP_METCOURSE);
	SpinnerOff(hWnd,IDC_SP_METCOURSEVSPIN,IDC_SP_METCOURSEV);
  }
  else 
  { SpinnerOn(hWnd,IDC_SP_METCOURSESPIN,IDC_SP_METCOURSE);
 	SpinnerOn(hWnd,IDC_SP_METCOURSEVSPIN,IDC_SP_METCOURSEV);
	}
};
void SetMapVals(IParamBlock *pblock,HWND hWnd,TimeValue t)
{ int type,maptype;
  pblock->GetValue(PB_PARTICLETYPE,t,type,FOREVER);
  if (type==RENDTET)
  { SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
  }
  else
  { pblock->GetValue(PB_MAPPINGTYPE,t,maptype,FOREVER);
    if (maptype==2)
	{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
	}
    else if (maptype)
	{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	  SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
	}
	else
	{ SpinnerOn(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
	}
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
  }
}

void MappingStuff(IParamBlock *pblock,HWND hWnd,TimeValue t,BOOL isbliz)
{ int maptype;
  pblock->GetValue((isbliz?PB_CUSTOMMTL2:PB_CUSTOMMTL),t,maptype,FOREVER);
  if (isbliz)
  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPPLANAR),!maptype);
  if (maptype)
  { SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
    SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
  }
  else SetMapVals(pblock,hWnd,t);
}
void CheckStretchBox(HWND hWnd,CommonParticle *po)
{ int enon=0;
  if (IsStdMtl(po->cnode))
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),TRUE);
  } else EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
  SpinnerOn(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
  po->pmapPSpin->Invalidate();
}

void StretchStuff(int dir,int isphase,HWND hWnd,CommonParticle *po)
{ if (dir==0)
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
	SpinnerOff(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
	SpinStuff(hWnd,FALSE,isphase);
  }
  else if (dir==1)
  {	CheckStretchBox(hWnd,po);
	SpinStuff(hWnd,FALSE,isphase);
  }  
  else if (dir==2)
  {	EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
	SpinnerOff(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
	SpinStuff(hWnd,TRUE,isphase);
  }
}

void AniFr(HWND hWnd,IParamBlock *pblock)
{ int anitype;
  pblock->GetValue(PB_ANIMATIONOFFSET,0,anitype,FOREVER);
  if (anitype>1)
	  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
  else	SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
}
void InstIn(CommonParticle *po,HWND hWnd, TimeValue t)
{ int ison;
  BOOL isbliz;
  MetaOff(hWnd);
  StdStuff(hWnd,FALSE);
  InstStuff(hWnd,TRUE,po->spawn,po->hparam);
  AniFr(hWnd,po->pblock);
  TurnButton(hWnd,IDC_AP_OBJECTPICK,TRUE);
  isbliz=(po->ClassID()==BLIZZARD_CLASS_ID);
  po->pblock->GetValue(PB_SPINAXISTYPE,0,ison,FOREVER);
  if (isbliz) SpinStuff(po->hrot,ison,TRUE);
  else StretchStuff(ison,TRUE,po->hrot,po);
  SpinMainStuff(po->hrot,TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_AUTOCOARSE),FALSE);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_DRAFTMODE),FALSE);
  MappingStuff(po->pblock,hWnd,t,isbliz);
  int stype;po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
  ObjectMutQueOn(stype,po->spawn,po->pickCB.repi);
  if (!isbliz)
    EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),TRUE);
  po->pmapPSpin->Invalidate();
}

void MetaIn(CommonParticle *po,HWND hWnd,TimeValue t)
{ BOOL isbliz;
  isbliz=(po->ClassID()==BLIZZARD_CLASS_ID);
  int mon,pname=(isbliz?PB_CUSTOMMTL2:PB_CUSTOMMTL);
  po->pblock->GetValue(pname,t,mon,FOREVER);
  if (mon>0) po->pblock->SetValue(pname,t,0);
  SpinnerOn(hWnd,IDC_SP_METTENSSPIN,IDC_SP_METTENS);
  SpinnerOn(hWnd,IDC_SP_METTENSVARSPIN,IDC_SP_METTENSVAR);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_AUTOCOARSE),TRUE);
  CourseCheck(po,hWnd,t);
  if (isbliz) SpinStuff(po->hrot,FALSE,FALSE);
  else StretchStuff(0,FALSE,po->hrot,po);
  SpinMainStuff(po->hrot,FALSE);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
  int showtype;
  po->pblock->GetValue(PB_VIEWPORTSHOWS,0,showtype,FOREVER);
  if (showtype==3) po->pblock->SetValue(PB_VIEWPORTSHOWS,0,0);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),FALSE);
  TurnButton(hWnd,IDC_AP_OBJECTPICK,FALSE);
  StdStuff(hWnd,FALSE);
  InstStuff(hWnd,FALSE,po->spawn,po->hparam);
  isbliz=(po->ClassID()==BLIZZARD_CLASS_ID);
  MappingStuff(po->pblock,hWnd,t,isbliz);
  ObjectMutQueOff(po->spawn);
  if (!isbliz) EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_DRAFTMODE),TRUE);
  int stype;
  po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
//  if (stype>1) po->pblock->SetValue(PB_SPAWNTYPE,0,0);  AllSpawnBad(po->spawn,0,FALSE);
  int ison; po->pblock->GetValue((isbliz?PB_BLIPCOLLIDE_ON:PB_IPCOLLIDE_ON),t,ison,FOREVER);
  if (ison) stype=0;
  SpawnStuff(po->spawn,stype);
  po->pmapPSpin->Invalidate();
}

void StdOn(CommonParticle *po,HWND hWnd,TimeValue t)
{ int ison,mon;
  BOOL isbliz;
  StdStuff(hWnd,TRUE);
  isbliz=(po->ClassID()==BLIZZARD_CLASS_ID);
  int pname=(isbliz?PB_CUSTOMMTL2:PB_CUSTOMMTL);
  po->pblock->GetValue(pname,t,mon,FOREVER);
  if (mon>0) po->pblock->SetValue(pname,t,0);
  po->pblock->GetValue(PB_SPINAXISTYPE,0,ison,FOREVER);
  if (isbliz) SpinStuff(po->hrot,ison,TRUE);
  else StretchStuff(ison,TRUE,po->hrot,po);
  SpinMainStuff(po->hrot,TRUE);
  int facing;
  po->pblock->GetValue(PB_PARTICLETYPE,t,facing,FOREVER);
  if ((facing==RENDTYPE5)||(facing==RENDTYPE6))
  { po->pblock->GetValue(PB_VIEWPORTSHOWS,t,facing,FOREVER);
	if (facing==2) po->pblock->SetValue(PB_VIEWPORTSHOWS,t,1);
   EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),FALSE);
  }
  else  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
  TurnButton(hWnd,IDC_AP_OBJECTPICK,FALSE);
  int showtype;
  po->pblock->GetValue(PB_VIEWPORTSHOWS,0,showtype,FOREVER);
  if (showtype==3) po->pblock->SetValue(PB_VIEWPORTSHOWS,0,0);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),FALSE);
 // SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
  MetaOff(hWnd);
  InstStuff(hWnd,FALSE,po->spawn,po->hparam);
  MappingStuff(po->pblock,hWnd,t,isbliz);
  ObjectMutQueOff(po->spawn);
  if (!isbliz)
    EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),TRUE);
  po->pmapPSpin->Invalidate();
}

class BLParticleDlgProc : public ParamMapUserDlgProc {
	public:
		BlizzardParticle *po;

		BLParticleDlgProc(BlizzardParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL BLParticleDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			break;
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SP_VIEWDISPMESH:
				  {po->valid=FALSE;
				   int subtree,custmtl;
					po->pblock->GetValue(PB_CUSTOMMTL2,0,custmtl,FOREVER);
					po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
					int anioff;
	  				po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					po->theSuprSprayDraw.t=t;
					po->theSuprSprayDraw.anioff=anioff;
					TimeValue aniend=GetAnimEnd();
					int anifr;
					anifr=aniend+GetTicksPerFrame();
					po->theSuprSprayDraw.anifr=anifr;
					po->GetTimes(po->times,t,anifr,anioff);
				    po->GetMesh(t,subtree,custmtl);
				   break;
				  }
			  case IDC_SP_VIEWDISPBOX:			  
				  { po->valid=FALSE;
					int subtree;
					po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
					int anioff;
	  				po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					po->theSuprSprayDraw.t=t;
					po->theSuprSprayDraw.anioff=anioff;
					TimeValue aniend=GetAnimEnd();
					int anifr;
					anifr=aniend+GetTicksPerFrame();
					po->theSuprSprayDraw.anifr=anifr;
					po->GetTimes(po->times,t,anifr,anioff);
					po->GetallBB(po->custnode,subtree,t);
				  break;
				  }
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
	}
class SSParticleDlgProc : public ParamMapUserDlgProc {
	public:
		SuprSprayParticle *po;

		SSParticleDlgProc(SuprSprayParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL SSParticleDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			break;
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SP_VIEWDISPMESH:
				  {po->valid=FALSE;
				   int subtree,custmtl;
					po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
					po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
					int anioff;
	  				po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					po->theSuprSprayDraw.t=t;
					po->theSuprSprayDraw.anioff=anioff;
					TimeValue aniend=GetAnimEnd();
					int anifr;
					anifr=aniend+GetTicksPerFrame();
					po->theSuprSprayDraw.anifr=anifr;
					po->GetTimes(po->times,t,anifr,anioff);
				    po->GetMesh(t,subtree,custmtl);
				   break;
				  }
			  case IDC_SP_VIEWDISPBOX:			  
				  { po->valid=FALSE;
					int subtree;
					po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
					int anioff;
	  				po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					po->theSuprSprayDraw.t=t;
					po->theSuprSprayDraw.anioff=anioff;
					TimeValue aniend=GetAnimEnd();
					int anifr;
					anifr=aniend+GetTicksPerFrame();
					po->theSuprSprayDraw.anifr=anifr;
					po->GetTimes(po->times,t,anifr,anioff);
					po->GetallBB(po->custnode,subtree,t);
				  break;
				  }
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
	}
void AddMtl(CommonParticle *po,TimeValue t,int custmtl)
{ if (po->cnode)
	{ int subtree,frag,submtl=0;
    po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
    po->pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	if ((po->custnode)&&(frag==INSTGEOM)&& custmtl) 
		po->AssignMtl(po->cnode,po->custnode,subtree,t);
	po->valid=FALSE;
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
 }


class SSParticleDisableDlgProc : public ParamMapUserDlgProc {
	public:
		SuprSprayParticle *po;
		ICustButton *iBut;

		SSParticleDisableDlgProc(SuprSprayParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};
void SSParticleDisableDlgProc::Update(TimeValue t)
{ if (!po->editOb) return;
  SetMapVals(po->pblock,po->hptype,t);
  float width;
  po->pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
  if (width<0.01f) iBut->Disable();
  po->ShowName();
  int chunky;
  po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
  if (chunky==METABALLS) MetaIn(po,po->hptype,t);
  else if (chunky==ISSTD) StdOn(po,po->hptype,t);
  else InstIn(po,po->hptype,t);
}

BOOL SSParticleDisableDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJECTPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			Update(t);
			break;
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_OBJECTPICK:
				   { po->flags=0;
					if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateSSBlizMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateSSBlizMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;	
					     po->pickCB.dodist=0;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
			case IDC_AP_UPDATEMTL:
				{ int custmtl;
				  po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
				  AddMtl(po,t,custmtl);
				  if ((custmtl) &&(po->cnode))
				  { EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPCUSTOMEMIT),FALSE);
				    po->origmtl=po->cnode->GetMtl();
				  }
				  break;
				}
			   case IDC_SP_TYPESTD:
				{ StdOn(po,hWnd,t);
				  po->valid=FALSE;
				  if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
				  { if (po->creating) 
					{  theCreateSSBlizMode.JumpStart(po->ip,po);
						po->ip->SetCommandMode(&theCreateSSBlizMode);
					} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
				  }
				 break;
				}
			  case IDC_AP_NOANIOFF:
			  case IDC_AP_ANIOFFBIRTH:
				  	SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
				  break;
			  case IDC_AP_ANIOFFRND:
			  	  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
				  break;
			  case IDC_SP_TYPEFAC:
			  case IDC_SP_TYPEPIX:
				{ SetMapVals(po->pblock,hWnd,t);
				  int facing;
				  po->pblock->GetValue(PB_VIEWPORTSHOWS,t,facing,FOREVER);
				  if (facing==2) po->pblock->SetValue(PB_VIEWPORTSHOWS,t,1);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),FALSE);
				  po->pmapParam->Invalidate();
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				 break;
				}
			  case IDC_SP_TYPETRI:
			  case IDC_SP_TYPECUB:
			  case IDC_SP_TYPESPC:
			  case IDC_SP_TYPE6PNT:
			  case IDC_SP_TYPESPHERE:
				{ SetMapVals(po->pblock,hWnd,t);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
				 break;
				}
			  case IDC_SP_TYPETET:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
 				 break;
				}
			  case IDC_SP_MAPTIME:
				{ SpinnerOn(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			  case IDC_SP_MAPDIST:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			  case IDC_SP_TYPEMET:
				  { MetaIn(po,hWnd,t);
				    po->valid=FALSE;
				  if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
				  { if (po->creating) 
					{  theCreateSSBlizMode.JumpStart(po->ip,po);
						po->ip->SetCommandMode(&theCreateSSBlizMode);
					} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
				  }
				  break;
				  }
			  case IDC_SP_MAPCUSTOMEMIT:
			  case IDC_SP_MAPCUSTOMINST:
				{ MappingStuff(po->pblock,hWnd,t,FALSE);
				  int dir;
				  po->pblock->GetValue(PB_SPINAXISTYPE,0,dir,FOREVER);
				  if (dir==1)
				  { int subtree,frag,custmtl=0;
				    po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
				    po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
				    po->pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
				    CheckStretchBox(po->hrot,po);
				  }
				  break;}
			  case IDC_SP_TYPEINSTANCE:
				  { int custmtl,vshow,anioff;
					po->pblock->GetValue(PB_VIEWPORTSHOWS,0,vshow,FOREVER);
				    po->pblock->SetValue(PB_CUSTOMMTL,0,1);
					InstIn(po,hWnd,t);
					if (vshow>1)
					{int subtree;
					 po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  				 po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					 po->theSuprSprayDraw.t=t;
					 po->theSuprSprayDraw.anioff=anioff;
					 TimeValue aniend=GetAnimEnd();
					 int anifr;
					 anifr=aniend+GetTicksPerFrame();
					 po->theSuprSprayDraw.anifr=anifr;
					 po->GetTimes(po->times,t,anifr,anioff);
					 if (vshow==2)
					 { po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
				       po->GetMesh(t,subtree,custmtl);
					 }
					else po->GetallBB(po->custnode,subtree,t);
					}
				    po->valid=FALSE;
				  break;
				  }
			  case IDC_SP_AUTOCOARSE:
				{ int chunky;
				  po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
				  if (chunky==METABALLS)
					 CourseCheck(po,hWnd,t);
				  break;
				}
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
	}
class BLParticleDisableDlgProc : public ParamMapUserDlgProc {
	public:
		BlizzardParticle *po;
		ICustButton *iBut;

		BLParticleDisableDlgProc(BlizzardParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};
void BLParticleDisableDlgProc::Update(TimeValue t)
{	if (!po->editOb) return;
	float width;
	po->pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
	int chunky;
	po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
	if (chunky==METABALLS) MetaIn(po,po->hptype,t);
	else if (chunky==ISSTD) StdOn(po,po->hptype,t);
	else InstIn(po,po->hptype,t);
	if (width<0.01f)
	{ iBut->Disable();
	}
	po->ShowName();
}

BOOL BLParticleDisableDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJECTPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			Update(t);
			break;
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{  case IDC_AP_OBJECTPICK:
				   { po->flags=0;
					if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateSSBlizMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateSSBlizMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;	
					      po->pickCB.dodist = 0;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
			case IDC_AP_UPDATEMTL:
				{ int custmtl;
				  po->pblock->GetValue(PB_CUSTOMMTL2,0,custmtl,FOREVER);
				  AddMtl(po,t,custmtl);
				  if ((po->cnode)&&(custmtl))
				  { EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPCUSTOMEMIT),FALSE);
				  	po->origmtl=po->cnode->GetMtl();
				  }
				  break;
				}
			  case IDC_AP_NOANIOFF:
			  case IDC_AP_ANIOFFBIRTH:
				  	SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
				  break;
			  case IDC_AP_ANIOFFRND:
			  	  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
				  break;
			  case IDC_SP_TYPEFAC:
			  case IDC_SP_TYPEPIX:
				{ SetMapVals(po->pblock,hWnd,t);
				  int facing;
				  po->pblock->GetValue(PB_VIEWPORTSHOWS,t,facing,FOREVER);
				  if (facing==2) po->pblock->SetValue(PB_VIEWPORTSHOWS,t,1);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),FALSE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				  po->pmapParam->Invalidate();
				 break;
				}
			  case IDC_SP_TYPETRI:
			  case IDC_SP_TYPECUB:
			  case IDC_SP_TYPESPC:
			  case IDC_SP_TYPE6PNT:
			  case IDC_SP_TYPESPHERE:
				{ SetMapVals(po->pblock,hWnd,t);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				 break;
				}
			  case IDC_SP_TYPETET:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
 				 break;
				}
			  case IDC_SP_MAPTIME:
				{ SpinnerOn(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			  case IDC_SP_MAPDIST:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			  case IDC_SP_MAPPLANAR:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			   case IDC_SP_TYPESTD:
				{ StdOn(po,hWnd,t);
				  po->valid=FALSE;
				  if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
				  { if (po->creating) 
					{  theCreateSSBlizMode.JumpStart(po->ip,po);
						po->ip->SetCommandMode(&theCreateSSBlizMode);
					} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
				  }
				 break;
				}
			  case IDC_SP_TYPEMET:
				  { MetaIn(po,hWnd,t);
				    po->valid=FALSE;
				  if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
				  { if (po->creating) 
					{  theCreateSSBlizMode.JumpStart(po->ip,po);
						po->ip->SetCommandMode(&theCreateSSBlizMode);
					} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
				  }
				  break;
				  }
			  case IDC_SP_MAPCUSTOMEMIT:
			  case IDC_SP_MAPCUSTOMINST:
				  MappingStuff(po->pblock,hWnd,t,TRUE);
				  break;
			  case IDC_SP_TYPEINSTANCE:
				  { int custmtl,vshow;
				     po->pblock->SetValue(PB_CUSTOMMTL2,0,1);
				    InstIn(po,hWnd,t);
					po->pblock->GetValue(PB_VIEWPORTSHOWS,0,vshow,FOREVER);
					if (vshow>1)
					{int subtree,anioff;
					 po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  				 po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					 po->theSuprSprayDraw.t=t;
					 po->theSuprSprayDraw.anioff=anioff;
					 TimeValue aniend=GetAnimEnd();
					 int anifr;
					 anifr=aniend+GetTicksPerFrame();
					 po->theSuprSprayDraw.anifr=anifr;
					 po->GetTimes(po->times,t,anifr,anioff);
					 if (vshow==2)
					 { po->pblock->GetValue(PB_CUSTOMMTL2,0,custmtl,FOREVER);
				       po->GetMesh(t,subtree,custmtl);
					 }
					else po->GetallBB(po->custnode,subtree,t);
					}
				    po->valid=FALSE;
				  break;
				  }
			  case IDC_SP_AUTOCOARSE:
				{ int chunky;
				  po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
				  if (chunky==METABALLS)
					 CourseCheck(po,hWnd,t);
				  break;
				}
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
	}

void CommonParticle::GetFilename(TCHAR *filename)
{   _tcscpy(filename,ip->GetDir(APP_PLUGCFG_DIR));
  int len= _tcslen(filename);
  if (len)
  {  if (filename[len-1]!=_T('\\'))
		  _tcscat(filename,_T("\\"));
  }
  if (ClassID()==BLIZZARD_CLASS_ID)
    _tcscat(filename,GetString(IDS_AP_BLIZZARDCST));
  else  _tcscat(filename,GetString(IDS_AP_SSPRAYCST));
}

void CommonParticle::SetupTargetList()		
	{TCHAR filename[MAX_PATH];
     FILE *f;
	 int vers,i,future,osize;
	custsettings=0;
    GetFilename(filename);
	BOOL fileok=TRUE;
	if ((f = _tfopen(filename, _T("rb"))) == NULL) return;
	if((ReadInt(&custsettings,f))&&(ReadInt(&vers,f))&&(ReadInt(&osize,f))&&(ReadInt(&future,f)))
	{ if ((vers!=CURRENT_VERSION)&&(fileok=GenNewSaveFile(osize,size,custsettings,f,filename,CURRENT_VERSION)))
		{fileok=((ReadInt(&custsettings,f))&&(ReadInt(&vers,f))&&(ReadInt(&osize,f))&&(ReadInt(&future,f)));
		}
	if (fileok&&(vers==CURRENT_VERSION))
	{ NameLst=new AName[custsettings]; 
	  for (i=0;i<custsettings;i++)
	  if (fread(NameLst[i],NLEN,1,f)==1)
	    fseek(f,size,SEEK_CUR);
	  else goto onerr;
	}
	}
	onerr:if (i<custsettings) 
	{ custsettings=0;
	MessageBox (NULL,GetString(IDS_RB_BADFILE),
            "", MB_ICONINFORMATION);
	}
	if (fileok) fclose(f);
	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
	for (i=0; i<custsettings; i++) {
		SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);
		}
	}
int CommonParticle::RemSettings(int overwrite,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  long startpt;
  int vers,newsets,future=0,baselen=size+NLEN;
  GetFilename(filename);
  vers=CURRENT_VERSION;
  newsets=custsettings-1;
  if ((f = _tfopen(filename,_T("r+b"))) == NULL) 
  { MessageBox(NULL,GetString(IDS_AP_WRITEPRO),"", MB_ICONINFORMATION);
	return 0;
  }
  if (custsettings==1) 
  {fclose(f);remove(filename);custsettings=0;
    delete[] NameLst;NameLst=NULL;
    SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
   return (1);}
 if (!WriteInt(&newsets,f)) {fclose(f);return 0;}
  startpt=overwrite*(baselen)+HLEN;
  fseek(f,startpt,SEEK_SET); 
  int i;
  BYTE *buf;
  buf=new BYTE[baselen];
  assert(buf);
  long cpos=startpt;
  for (i=overwrite+1;i<custsettings;i++)
  {	fseek(f,cpos+baselen,SEEK_SET);
	if (fread(buf,baselen,1,f)!=1) {delete[] buf;fclose(f);return 0;}
	fseek(f,cpos,SEEK_SET);
	if (fwrite(buf,baselen,1,f)!=1) {delete[] buf;fclose(f);return 0;}
	cpos+=baselen;
  }
  delete[] buf;
  _chsize(_fileno(f),ftell(f));
  fclose(f);								  
  AName *Tmp=new AName[custsettings-1];
  int newi=0;
  for (i=0;i<custsettings;i++)
  { if (i!=overwrite) 
      _tcscpy(Tmp[newi++],NameLst[i]);}
  delete []NameLst;NameLst=Tmp;
  custsettings--;
  SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
  for (i=0; i<custsettings; i++) 
  {	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);	}
  return(1);
}
int CommonParticle::SaveSettings(int overwrite,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  int vers,newsets,future=0;

  if ((overwrite>-1)&&(MessageBox (NULL,GetString(IDS_AP_SETEXISTS),GetString(IDS_AP_WARNING), MB_ICONQUESTION | MB_YESNO ) == IDNO))
	 return 0;
  GetFilename(filename);
  vers=CURRENT_VERSION;
  newsets=custsettings+1;
  if ((f = _tfopen(filename,(custsettings==0?_T("wb"):_T("r+b")))) == NULL) 
  { MessageBox(NULL,GetString(IDS_AP_WRITEPRO),"", MB_ICONINFORMATION);
	return 0;
  }
 // longest one
  ParamBlockDescID *descVer=((ClassID()==BLIZZARD_CLASS_ID)?BdescVer6:spdescVer6);
  int plength=((ClassID()==BLIZZARD_CLASS_ID)?PBLOCK_LENGTH_BLIZZARD:PBLOCK_LENGTH_SUPRSPRAY);
  if (custsettings==0)
  { if (!(WriteInt(&newsets,f)&&WriteInt(&vers,f)&&WriteInt(&size,f)&&WriteInt(&future,f))) goto errend;
  } 
  else 
  { if (overwrite>=0) 
    { overwrite=overwrite*(size+NLEN)+HLEN;
      fseek(f,overwrite,SEEK_SET); }
    else 
	{ if (!WriteInt(&newsets,f)) goto errend;
	  fseek(f,0,SEEK_END);
	}
  }	 
  int ival,i;
  float fval;
  if (fwrite(newname,1,NLEN,f)!=NLEN) goto errend;
  for (i=0;i<plength;i++)
  {	if (descVer[i].type==TYPE_INT) 
    { pblock->GetValue(i,0,ival,FOREVER);
      if (fwrite(&ival,isize,1,f)!=1) goto errend;
	}
    else
    { pblock->GetValue(i,0,fval,FOREVER);
      if (fwrite(&fval,fsize,1,f)!=1) goto errend;
	}
  }
  fclose(f);
  if (overwrite<0) 
  { AName *Tmp=new AName[custsettings+1];
    memcpy(Tmp,NameLst,sizeof(AName)*custsettings);
	delete []NameLst;NameLst=Tmp;
    _tcscpy(NameLst[custsettings],newname);
	custsettings++;
	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
	for (int i=0; i<custsettings; i++) {
		SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);
		}
  }  
  return(1);
errend: fclose(f);return(0);
}
int CommonParticle::GetSettings(int setnum,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  GetFilename(filename);
  if ((f = _tfopen(filename,_T("rb"))) == NULL) return 0;
  { setnum=setnum*(size+NLEN)+HLEN;
    fseek(f,setnum,SEEK_SET); 
  }	 
  int ival,i;
  float fval;
  // longest one
  ParamBlockDescID *descVer=((ClassID()==BLIZZARD_CLASS_ID)?BdescVer6:spdescVer6);
 int plength=((ClassID()==BLIZZARD_CLASS_ID)?PBLOCK_LENGTH_BLIZZARD:PBLOCK_LENGTH_SUPRSPRAY);
  if (fread(newname,1,NLEN,f)!=NLEN) goto errend;
  for (i=0;i<plength;i++)
  {	if (descVer[i].type==TYPE_INT) 
    { if (fread(&ival,isize,1,f)!=1) goto errend;
	  pblock->SetValue(i,0,ival);
	}
    else
    { if (fread(&fval,fsize,1,f)!=1) goto errend;
//	  if (i!=PB_EMITRWID) 
		  pblock->SetValue(i,0,fval);
	}
  }
  fclose(f);
  InvalidateUI();							
  return(1);
  errend: fclose(f);return(0);
}
static BOOL CALLBACK CustomSettingParamDlgProc( 
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{ TCHAR newname[NLEN];
  int i,save=0;
  CommonParticle *po = (CommonParticle*)GetWindowLong(hWnd,GWL_USERDATA);
  if (!po && message!=WM_INITDIALOG) return FALSE;

  switch (message) {
		case WM_INITDIALOG: {
			po = (SuprSprayParticle*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			po->custCtrlEdit = GetICustEdit(GetDlgItem(hWnd,IDC_SP_SETEDIT));
			po->custCtrlEdit->SetText(_T(""));
			po->hParams2 = hWnd;
			po->SetupTargetList();
			break;
			}
		case WM_COMMAND:
			{ switch(LOWORD(wParam)) {
				case IDC_SP_SETLIST:  
					if (HIWORD(wParam)==LBN_DBLCLK)
					  goto doload;
					break;
				case IDC_SP_DELETE:  
					i = SendMessage(GetDlgItem(po->hParams2,IDC_SP_SETLIST),
							LB_GETCURSEL,0,0);
					   if ((i>-1)&&(po->custsettings>0))
					   { po->custCtrlEdit->GetText(newname,NLEN);
						 if (_tcscmp(newname,po->NameLst[i])==0)
						   po->custCtrlEdit->SetText(_T(""));
					     po->RemSettings(i,po->NameLst[i]);
					   }
					break;
				case IDC_SP_SAVE:
				   save=1;
				case IDC_SP_LOAD:
					doload:
					if (!save)
					{ i = SendMessage(GetDlgItem(po->hParams2,IDC_SP_SETLIST),
							LB_GETCURSEL,0,0);
					   if ((i>-1)&&(po->custsettings>0))
					     po->custCtrlEdit->SetText(po->NameLst[i]);
					}
				    po->custCtrlEdit->GetText(newname,NLEN);
					if (save) 
					{int tstblk=0,tstlen=_tcslen(newname);
					  while ((tstblk<tstlen)&&(newname[tstblk]==' ')) tstblk++;
					  if (tstblk>=tstlen) 
						MessageBox (NULL,GetString(IDS_RB_NONAME),
            "", MB_ICONINFORMATION);
					  else 
					  { i=0;
					    while ((i<po->custsettings)&&(_tcscmp(newname,po->NameLst[i])))
					     i++;
						if (i>=po->custsettings) i=-1;
					    po->SaveSettings(i,newname);
					  }
					}
					else if ((i>-1)&&(i<po->custsettings)) 
					{ po->GetSettings(i,newname);
					  int stype;
					  po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
					  int chunky;
			          po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
					  if (chunky==METABALLS) MetaIn(po,po->hptype,po->ip->GetTime());
				      else 
					  {// AllSpawnBad(po->spawn,stype,TRUE);
						int ison; po->pblock->GetValue((po->ClassID()==BLIZZARD_CLASS_ID?PB_BLIPCOLLIDE_ON:PB_IPCOLLIDE_ON),0,ison,FOREVER);
						if (ison) stype=0;
						SpawnStuff(po->spawn,stype);
						if (chunky==ISSTD) StdOn(po,po->hptype,po->ip->GetTime());
					    else InstIn(po,po->hptype,po->ip->GetTime());
					  }
				 if (chunky==INSTGEOM)
				 { CheckSpawnButtons(po->pblock,po->spawn,po->pickCB.repi);
				   int onscreen;
				   po->pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
				   if (onscreen>1)
				   {int subtree,anioff;
					 po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  				 po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					TimeValue t=po->ip->GetTime();
					 po->theSuprSprayDraw.t=t;
					 po->theSuprSprayDraw.anioff=anioff;
					 TimeValue aniend=GetAnimEnd();
					 int anifr,custmtl;
					 anifr=aniend+GetTicksPerFrame();
					 po->theSuprSprayDraw.anifr=anifr;
					 po->GetTimes(po->times,t,anifr,anioff);
					 po->pblock->GetValue((po->ClassID()==BLIZZARD_CLASS_ID?PB_CUSTOMMTL2:PB_CUSTOMMTL),0,custmtl,FOREVER);
					 if (onscreen==2)
						 po->GetMesh(po->ip->GetTime(),subtree,custmtl);
						else po->GetallBB(po->custnode,subtree,po->ip->GetTime());
				   }
				 }
				 else ObjectMutQueOff(po->spawn);
					  if (stype==EMIT) SpinnerOff(po->spawn,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);
					  po->pmapParam->Invalidate(); 
					  po->ip->RedrawViews(po->ip->GetTime()); 
					}
					else MessageBox (NULL,GetString(IDS_RB_BADNAME),
            "", MB_ICONINFORMATION);
					break;
				}
			break;
			}

		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustEdit(po->custCtrlEdit);
			if (po->NameLst) {delete []po->NameLst;po->NameLst=NULL;}
			return FALSE;
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			po->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;
		
		default:	return FALSE;		
		}
	return TRUE;
	}	

class ComParticleSpawnDlgProc : public ParamMapUserDlgProc {
	public:
		CommonParticle *po;
		ICustButton *iBut,*iButrep;

		ComParticleSpawnDlgProc(CommonParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void ComParticleSpawnDlgProc::Update(TimeValue t)
{ if (!po->editOb) return;
	po->SetUpList();
	float width;
	po->pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
	if (width<0.01f) iBut->Disable();
	po->SetUpLifeList();
	po->pickCB.repi= SendMessage(GetDlgItem(po->spawn,IDC_AP_OBJECTQUEUE),
					LB_GETCURSEL,0,0);
	if (width<0.01f) iButrep->Disable();
	else
	{ if (po->pickCB.repi<0) iButrep->Disable(); else iButrep->Enable();
	}
	int chunky,stype;
	po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
	po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
//	AllSpawnBad(po->spawn,stype,chunky!=METABALLS);
	int ison; po->pblock->GetValue((po->ClassID()==BLIZZARD_CLASS_ID?PB_BLIPCOLLIDE_ON:PB_IPCOLLIDE_ON),t,ison,FOREVER);
	if (ison) stype=0;
    SpawnStuff(po->spawn,stype);
	if (chunky==INSTGEOM)
		    CheckSpawnButtons(po->pblock,po->spawn,po->pickCB.repi);
	else 
	{ ObjectMutQueOff(po->spawn);
	  CheckLifeButtons(stype,po->spawn);
	}
	if (stype==EMIT) SpinnerOff(po->spawn,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);
}

BOOL ComParticleSpawnDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{ int dtype=2,stype,rep;	
	switch (msg) {
		case WM_INITDIALOG: 
		{ iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUEPICK));
		  iBut->SetType(CBT_CHECK);
		  iBut->SetHighlightColor(GREEN_WASH);
		  iButrep = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJQUEUEREPLACE));
		  iButrep->SetType(CBT_CHECK);
		  iButrep->SetHighlightColor(GREEN_WASH);
		  Update(t);
		  break;
		}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			ReleaseICustButton(iButrep);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_NOSPAWN:stype=0;goto spawnradio;
			  case IDC_AP_COLLIDEDIE:
				  stype=1;goto spawnradio;
			  case IDC_AP_SPAWNTRAILS:stype=EMIT;goto spawnradio;
			  case IDC_AP_COLLIDESPAWN:
			  case IDC_AP_DEATHSPAWN: stype=2;
			spawnradio:	
				int chunky;
			po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
//				AllSpawnBad(po->spawn,stype,chunky!=METABALLS);
				int ison; po->pblock->GetValue((po->ClassID()==BLIZZARD_CLASS_ID?PB_BLIPCOLLIDE_ON:PB_IPCOLLIDE_ON),t,ison,FOREVER);
				if (ison) stype=0;
				SpawnStuff(po->spawn,stype);
				 if (chunky==INSTGEOM)
				    CheckSpawnButtons(po->pblock,hWnd,po->pickCB.repi);
				 else 
				 { ObjectMutQueOff(po->spawn);
				   CheckLifeButtons(stype,po->spawn);
				 }
				 if (stype==EMIT) SpinnerOff(po->spawn,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);
			   break;
			  case IDC_AP_OBJECTQUEUE:
				{ po->pickCB.repi= SendMessage(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUE),
							LB_GETCURSEL,0,0);
			    TurnButton(hWnd,IDC_AP_OBJQUEUEREPLACE,po->pickCB.repi>-1);
			    TurnButton(hWnd,IDC_AP_OBJQUEUEDELETE,po->pickCB.repi>-1);
				break;
				}
			   case IDC_AP_OBJECTQUEUEPICK:
			      dtype=1;goto dopick;
			   case IDC_AP_OBJQUEUEREPLACE:
				  dtype=2;
				  dopick:
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateSSBlizMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateSSBlizMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;
					      po->pickCB.dodist=dtype;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
				case IDC_AP_OBJQUEUEDELETE:
				{  int i = SendMessage(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUE),
							LB_GETCURSEL,0,0);
						TurnButton(hWnd,IDC_AP_OBJQUEUEREPLACE,0);
						TurnButton(hWnd,IDC_AP_OBJQUEUEDELETE,0);
					if ((po->nlist.Count()>0)&&(i>-1))
					{	theHold.Begin();
						po->DeleteFromList(i,0);
						theHold.Accept(GetString(IDS_AP_OBJDEL));
					}
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				break;
				}
				case IDC_AP_LIFEQUEUEDEL:
				{  int i = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),
							LB_GETCURSEL,0,0);
					int Lcnt=po->llist.Count();
					if ((Lcnt>0)&&(i>-1)&&(i<Lcnt))
					{	theHold.Begin();
						theHold.Put(new LifeListRestore(po));
						po->DeleteFromLifeList(i);
						TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
						TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,0);
						theHold.Accept(GetString(IDS_AP_LIFEDEL));
					}
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					break;
				}
				case IDC_AP_LIFEQUEUEADD:
				{   int i;
					po->pblock->GetValue(PB_SPAWNLIFEVLUE,t,i,FOREVER);
					theHold.Begin();
					theHold.Put(new LifeListRestore(po));
					po->AddToLifeList(i);
					TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
					TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,0);
					theHold.Accept(GetString(IDS_AP_LIFEADD));
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					break;
				}
				case IDC_AP_LIFEQUEUE:
				{ rep = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),LB_GETCURSEL,0,0);
				  TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,rep>-1);
				  TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,rep>-1);
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				  break;
				}
				case IDC_AP_LIFEQUEUEREPL:
				{ int i;
				 rep = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),
							LB_GETCURSEL,0,0);
				  if (rep>-1)
				  {	po->pblock->GetValue(PB_SPAWNLIFEVLUE,t,i,FOREVER);
					theHold.Begin();
					theHold.Put(new LifeListRestore(po));
					po->llist[rep]=i;
					po->SetUpLifeList();
					TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
					TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,0);
					theHold.Accept(GetString(IDS_AP_LIFEREP));
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				  }
					break;
				}
		}
		default:
			return FALSE;
	}
	return TRUE;
}
class BParticleSpinDlgProc : public ParamMapUserDlgProc {
	public:
		CommonParticle *po;

		BParticleSpinDlgProc(CommonParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void BParticleSpinDlgProc::Update(TimeValue t)
{   int axis;
	po->pblock->GetValue(PB_SPINAXISTYPE,t,axis,FOREVER);
	SpinStuff(po->hrot,axis==1,TRUE);
	int ison; po->pblock->GetValue(PB_BLIPCOLLIDE_ON,t,ison,FOREVER);
	int stype; po->pblock->GetValue(PB_SPAWNTYPE,t,stype,FOREVER);
	IPCControls(po->hrot,po->spawn,stype,ison);
}

BOOL BParticleSpinDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: 
		{ Update(t);
		  break;
		}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_PARTICLEDIRRND:
			  { SpinStuff(hWnd,FALSE,TRUE);
			  }
			  break;
			  case IDC_AP_PARTICLEDIRUSER:
				   SpinStuff(hWnd,TRUE,TRUE);
				break;
			  case IDC_INTERP_BOUNCEON:
				{  int ison; po->pblock->GetValue(PB_BLIPCOLLIDE_ON,t,ison,FOREVER);
				   int stype; po->pblock->GetValue(PB_SPAWNTYPE,t,stype,FOREVER);
				   IPCControls(hWnd,po->spawn,stype,ison);
				}
				break;
			}
		default:
			return FALSE;
	}
	return TRUE;
}
class SSParticleSpinDlgProc : public ParamMapUserDlgProc {
	public:
		CommonParticle *po;

		SSParticleSpinDlgProc(CommonParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void SSParticleSpinDlgProc::Update(TimeValue t)
{   int axis;
	po->pblock->GetValue(PB_SPINAXISTYPE,t,axis,FOREVER);
	StretchStuff(axis,TRUE,po->hrot,po);
	int ison; po->pblock->GetValue(PB_IPCOLLIDE_ON,t,ison,FOREVER);
	int stype; po->pblock->GetValue(PB_SPAWNTYPE,t,stype,FOREVER);
	IPCControls(po->hrot,po->spawn,stype,ison);
}

BOOL SSParticleSpinDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: 
		{ Update(t);
			break;
		}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_PARTICLEDIRTRAVL:
			    StretchStuff(1,TRUE,hWnd,po);
			  break;
			  case IDC_AP_PARTICLEDIRRND:
				StretchStuff(0,TRUE,hWnd,po);
			  break;
			  case IDC_AP_PARTICLEDIRUSER:
				StretchStuff(2,TRUE,hWnd,po);
				break;
			  case IDC_INTERP_BOUNCEON:
				{  int ison; po->pblock->GetValue(PB_IPCOLLIDE_ON,t,ison,FOREVER);
				   int stype; po->pblock->GetValue(PB_SPAWNTYPE,t,stype,FOREVER);
				   IPCControls(hWnd,po->spawn,stype,ison);
				}
				break;
			}
		default:
			return FALSE;
	}
	return TRUE;
}

void CommonParticle::ResetSystem(TimeValue t,BOOL full)
{	lc.lastmin=-1;lc.lastcollide=-1;
	rcounter=0;
	vcounter=0;
	if (full)
	{ tvalid = t;
	  valid  = TRUE;
	}
}

//--- SuprSprayParticle Methods--------------------------------------------

SuprSprayParticle::SuprSprayParticle()
{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
     int tpf=GetTicksPerFrame();

	MakeRefByID(FOREVER, PBLK, CreateParameterBlock(spdescVer6, PBLOCK_LENGTH_SUPRSPRAY, CURRENT_VERSION));
	pblock->SetValue(PB_SPEED,0,10.0f);
	pblock->SetValue(PB_SPEEDVAR,0,0.0f);
	pblock->SetValue(PB_OFFAXIS,0,0.0f);
	pblock->SetValue(PB_AXISSPREAD,0,0.0f);
	pblock->SetValue(PB_OFFPLANE,0,0.0f);
	pblock->SetValue(PB_PLANESPREAD,0,0.0f);
	pblock->SetValue(PB_PBIRTHRATE,0,10);
	pblock->SetValue(PB_PTOTALNUMBER,0,100);
	pblock->SetValue(PB_BIRTHMETHOD,0,0);
	pblock->SetValue(PB_DISPLAYPORTION,0,0.1f);
	pblock->SetValue(PB_EMITSTART,0,TimeValue(0));
	pblock->SetValue(PB_EMITSTOP,0,(TimeValue)30*FToTick);// correct constant?
	pblock->SetValue(PB_DISPUNTIL,0,100*FToTick);// correct constant?
	pblock->SetValue(PB_LIFE,0,30*FToTick);// correct constant?
	pblock->SetValue(PB_LIFEVAR,0,0.0f);
	pblock->SetValue(PB_SUBFRAMEMOVE,0,1);
	pblock->SetValue(PB_SUBFRAMETIME,0,1);
	pblock->SetValue(PB_SUBFRAMEROT,0,0);
	pblock->SetValue(PB_SIZE,0,1.0f);
	pblock->SetValue(PB_SIZEVAR,0,0.0f);
	pblock->SetValue(PB_GROWTIME,0,10*FToTick);
	pblock->SetValue(PB_FADETIME,0,10*FToTick);
	pblock->SetValue(PB_RNDSEED,0,12345);

	pblock->SetValue(PB_PARTICLETYPE,0,0);
	pblock->SetValue(PB_METATENSION,0,1.0f);
	pblock->SetValue(PB_METATENSIONVAR,0,0.0f);
	pblock->SetValue(PB_METAAUTOCOARSE,0,1);
	pblock->SetValue(PB_METACOURSE,0,0.5f);
	pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
	pblock->SetValue(PB_MAPPINGTYPE,0,0);
	pblock->SetValue(PB_MAPPINGTIME,0,30*FToTick);
	pblock->SetValue(PB_MAPPINGDIST,0,100.0f);

	pblock->SetValue(PB_SPINTIME,0,30*FToTick);
	pblock->SetValue(PB_SPINTIMEVAR,0,0.0f);
	pblock->SetValue(PB_SPINPHASE,0,0.0f);
	pblock->SetValue(PB_SPINPHASEVAR,0,0.0f);
	pblock->SetValue(PB_SPINAXISTYPE,0,0);
	pblock->SetValue(PB_SPINAXISX,0,1.0f);
	pblock->SetValue(PB_SPINAXISY,0,0.0f);
	pblock->SetValue(PB_SPINAXISZ,0,0.0f);
	pblock->SetValue(PB_SPINAXISVAR,0,0.0f);

	pblock->SetValue(PB_EMITVINFL,0,100.0f);
	pblock->SetValue(PB_EMITVMULT,0,1.0f);
	pblock->SetValue(PB_EMITVMULTVAR,0,0.0f);

	pblock->SetValue(PB_BUBLAMP,0,0.0f);
	pblock->SetValue(PB_BUBLAMPVAR,0,0.0f);
	pblock->SetValue(PB_BUBLPER,0,100000*FToTick);
	pblock->SetValue(PB_BUBLPERVAR,0,0.0f);
	pblock->SetValue(PB_BUBLPHAS,0,0.0f);
	pblock->SetValue(PB_BUBLPHASVAR,0,0.0f);

	pblock->SetValue(PB_EMITRWID,0,0.0f);
	pblock->SetValue(PB_EMITRHID,0,0);
	pblock->SetValue(PB_SPAWNGENS,0,1);
	pblock->SetValue(PB_SPAWNCOUNT,0,1);
	pblock->SetValue(PB_METACOURSEV,0,1.0f);
	pblock->SetValue(PB_SPAWNPERCENT,0,100);
	pblock->SetValue(PB_SPAWNMULTVAR,0,0.0f);
	pblock->SetValue(PB_SSNOTDRAFT,0,0);
	pblock->SetValue(PB_SSSPAWNDIEAFTER,0,0);
	pblock->SetValue(PB_IPCOLLIDE_ON,0,0);
	pblock->SetValue(PB_IPCOLLIDE_STEPS,0,2);
	pblock->SetValue(PB_IPCOLLIDE_BOUNCE,0,1.0f);
	pblock->SetValue(PB_IPCOLLIDE_BOUNCEVAR,0,0.0f);
	sdata=NULL;
	cnode=NULL;
	custnode=NULL;
	custname=TSTR(_T(" "));
	ResetSystem(0,FALSE);
	size=43*isize+fsize*37;
	times.tl.SetCount(0);
	cmesh=NULL;
	dispmesh=NULL;
	dispt=-99999;
	theSuprSprayDraw.bboxpt=NULL;
	nmtls.ZeroCount();
	deftime=0;
	parts.points.ZeroCount();
	maincount=0;
	cancelled=FALSE;
	wasmulti=FALSE;
	nlist.ZeroCount();
	llist.ZeroCount();
	dflags=APRTS_ROLLUP_FLAGS;
	backpatch=TRUE;
	origmtl=NULL;
	ClearAFlag(A_NOTREND);
    stepSize=GetTicksPerFrame();
}

SuprSprayParticle::~SuprSprayParticle()
{	if (sdata) {delete[] sdata;sdata=NULL;}
//	SetFlag(dflags,STDMTL_ROLLUP1_OPEN,ip->IsRollupPanelOpen(hPanelBasic));
	DeleteAllRefsFromMe();
	pblock=NULL;
	parts.FreeAll();
	times.tl.SetCount(0);
	times.tl.Shrink();
	nmtls.ZeroCount();nmtls.Shrink();
	llist.ZeroCount();llist.Shrink();
	nlist.ZeroCount();nlist.Shrink();
	if (cmesh) delete[] cmesh;
	if (theSuprSprayDraw.bboxpt) delete[] theSuprSprayDraw.bboxpt;
	if (dispmesh) delete dispmesh;
}

Matrix3 CommonParticle::TumbleMat(int index,float amount, float scale)
	{
	Matrix3 mat;
	Quat q;
	float ang[3];

	srand(int(PARTICLE_SEED) * Perm(index) + int(PARTICLE_SEED));
	
	for (int i=0; i<3; i++) {
		ang[i] = (float(2*rand())/float(RAND_MAX) - 1.0f);
		if (amount>0.0f) {
			float off = 8725.0f*i;
			ang[i] += noise3((parts[index]+Point3(off,off,off))*scale)*amount;
			}
		ang[i] *= TWOPI;
		}
	
	EulerToQuat(ang,q);
	q.MakeMatrix(mat);
	return mat;
	}

TimeValue CommonParticle::ParticleLife(TimeValue t, int i)
{   int pcount=parts.Count();
	if (!(i<pcount)) return 0.0f;
	return sdata[i].L;
}

Point3 BlizzardParticle::ParticlePosition(TimeValue t,int i)
{	int pcount=parts.points.Count();
	if (!(i<pcount)) return Zero;
	Point3 retpt=parts.points[i];
	return retpt;
}

Point3 SuprSprayParticle::ParticlePosition(TimeValue t,int i)
{	int pcount=parts.points.Count();
	if (!(i<pcount)) return Zero;
	Point3 FinalP=parts.points[i];
// figure out particle class
	int isinst;
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
// if we have custom geometry, find the center of the bounding box and velocity normal
	if ((isinst==INSTGEOM)&&(custnode))
	{	int anioff;
		float dlgsize;
		dlgsize=parts.radius[i];
		float zoffset=0.0f;
		Point3 OffsetV=Zero;;
		TimeValue aniend=GetAnimEnd();
		int anifr=aniend+GetTicksPerFrame();
		pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
		TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nlist.Count()?nlist.Count():sdata[i].gennum));
		if (mnum>=0) zoffset=cmesh[mnum].getBoundingBox().Center().z;
// if we're using DoT/MBlur, account for scaling due to stretch
		int axisentered;
		pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
		if (axisentered==DIRTRAVEL)
		{	int K;
			pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			float strlen=GetLen(parts.vels[i],K);
			zoffset*=strlen;
		}
		float lenV=Length(parts.vels[i]);
		if (lenV>EPSILON) OffsetV=parts.vels[i]/lenV;
		FinalP+=zoffset*dlgsize*OffsetV;
	}
	return FinalP;
}

Point3 SuprSprayParticle::ParticleVelocity(TimeValue t,int i)
{	Point3 retvel=Zero;
	int pcount=parts.vels.Count();
	if (i<pcount)
		retvel=parts.vels[i];
	return retvel;
}

float SuprSprayParticle::ParticleSize(TimeValue t,int i)
{	float strlen=1.0f;
	float boxlen=1.0f;
	float dlgsize;
	int pcount=parts.radius.Count();
	if (!(i<pcount)) return 0.0f;
	int axisentered,K,isinst,ptype;
// get the size/scale from the dialog box processed for this particle...
	dlgsize=parts.radius[i];
// figure out particle type and class
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
// if there are custom particles, find bounding box params...
	if ((isinst==INSTGEOM)&&(custnode))
	{	int anioff;
		TimeValue aniend=GetAnimEnd();
		int anifr=aniend+GetTicksPerFrame();
		pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
		TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nlist.Count()?nlist.Count():sdata[i].gennum));
		if (mnum>=0) boxlen=cmesh[mnum].getBoundingBox().Width().z;
	}
// if we're using MBlur and DoT then account for scaling along DoT
	pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	if (axisentered==DIRTRAVEL)
	{	pblock->GetValue(PB_STRETCH,t,K,FOREVER);
		strlen=GetLen(parts.vels[i],K);
	}
	float templen=boxlen*strlen;
	if ((isinst!=PB_PARTICLECLASS)&&(ptype==RENDTET)) templen*=1.3f;
	return templen*dlgsize;	
}

int SuprSprayParticle::ParticleCenter(TimeValue t,int i)
{	int ptype,isinst;
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	if (isinst==INSTGEOM) return PARTCENTER_CENTER;
	if (ptype==RENDTET) return PARTCENTER_HEAD;
	return PARTCENTER_CENTER;	
}

Point3 BlizzardParticle::ParticleVelocity(TimeValue t,int i)
{	Point3 retvel=Zero;
	int pcount=parts.vels.Count();
	if (i<pcount)
		retvel=parts.vels[i];
	return retvel;
}

float BlizzardParticle::ParticleSize(TimeValue t,int i)
{	int isinst;
	int pcount=parts.radius.Count();
	if (!(i<pcount)) return 0.0f;
	float radius=1.0f,size=parts.radius[i];
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
	if ((isinst==INSTGEOM) &&(custnode))
	{	int anioff;
		TimeValue aniend=GetAnimEnd();
		int anifr=aniend+GetTicksPerFrame();
		pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
		TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nlist.Count()?nlist.Count():sdata[i].gennum));
		if (mnum>=0) 
		radius=(cmesh[mnum].getBoundingBox().Width()).z;
	}
	return radius*size;	
}

int BlizzardParticle::ParticleCenter(TimeValue t,int i)
{	return PARTCENTER_CENTER;	
}

int CommonParticle::RenderBegin(TimeValue t, ULONG flags)
	{ 	SetAFlag(A_RENDER);
  		ParticleInvalid();		
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		cancelled=FALSE;
		int isinst;
		pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
		if ((isinst==INSTGEOM) &&(custnode))
			custnode->SetProperty(PROPID_FORCE_RENDER_MESH_COPY,(void *)1);
	return 0;
	}

int CommonParticle::RenderEnd(TimeValue t)
	{
		ClearAFlag(A_RENDER);
		ParticleInvalid();		
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		int isinst;
		pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
		if ((isinst==INSTGEOM) &&(custnode))
			custnode->SetProperty(PROPID_FORCE_RENDER_MESH_COPY,(void *)0);
	return 0;
	}

void SuprSprayParticle::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{ 
	SimpleParticle::BeginEditParams(ip,flags,prev);
	editOb = this;
	this->ip = ip;

	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }
	if (pmapParam && pmapPGen && pmapPType && pmapPSpin && pmapEmitV && pmapBubl && pmapSpawn) 
	{	pmapParam->SetParamBlock(pblock);
		pmapPGen->SetParamBlock(pblock);
		pmapPType->SetParamBlock(pblock);
		pmapPSpin->SetParamBlock(pblock);
		pmapEmitV->SetParamBlock(pblock);
		pmapBubl->SetParamBlock(pblock);
		pmapSpawn->SetParamBlock(pblock);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)this);
	} else 
	{ 	pmapParam = CreateCPParamMap(
			descParamSuprSpray,PARAMSuprSpray_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_SUPERSPRAY),
			GetString(IDS_RB_PARAMETERS),
			dflags&APRTS_ROLLUP1_OPEN?0:APPENDROLL_CLOSED);

		pmapPGen = CreateCPParamMap(
			descParamPGen,PARAMPGEN_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_GEN_SS),
			GetString(IDS_RB_PGEN),
			dflags&APRTS_ROLLUP2_OPEN?0:APPENDROLL_CLOSED);
		
		pmapPType = CreateCPParamMap(
			descParamPType,PARAMPTYPE_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_PARTTYPE_SS),
			GetString(IDS_RB_PTYPE),
			dflags&APRTS_ROLLUP3_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapPSpin = CreateCPParamMap(
			descParamPSpin,PARAMPSPIN_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_ROT),
			GetString(IDS_RB_SPIN),
			dflags&APRTS_ROLLUP4_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapEmitV = CreateCPParamMap(
			descParamEmitV,PARAMEMITV_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_EMITV),
			GetString(IDS_RB_EMITV),
			dflags&APRTS_ROLLUP5_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapBubl = CreateCPParamMap(
			descParamBubl,PARAMBUBL_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_BUBL),
			GetString(IDS_RB_BUBL),
			dflags&APRTS_ROLLUP6_OPEN?0:APPENDROLL_CLOSED);		
		pmapSpawn = CreateCPParamMap(
			descPSpawning,PSPAWNINGPARAMS_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_SPAWNING),
			GetString(IDS_AP_PSPAWN),
			dflags&APRTS_ROLLUP7_OPEN?0:APPENDROLL_CLOSED);		

		hParams2 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SUPRPRTS_SAVE),
				CustomSettingParamDlgProc, 
				GetString(IDS_RB_LOADSAVE), 
				(LPARAM)this,dflags&APRTS_ROLLUP8_OPEN?0:APPENDROLL_CLOSED);		
		ip->RegisterDlgWnd(hParams2);

		}
	spawn=pmapSpawn->GetHWnd();
	hparam=pmapParam->GetHWnd();
	hgen=pmapPGen->GetHWnd();
	hptype=pmapPType->GetHWnd();
	hrot=pmapPSpin->GetHWnd();
	hbubl=pmapBubl->GetHWnd();
	if (pmapPType) pmapPType->SetUserDlgProc(new SSParticleDisableDlgProc(this));
	if (pmapPGen) pmapPGen->SetUserDlgProc(new SSParticleGenDlgProc(this));
	if (pmapParam) pmapParam->SetUserDlgProc(new SSParticleDlgProc(this));
	if (pmapSpawn) pmapSpawn->SetUserDlgProc(new ComParticleSpawnDlgProc(this));
	if (pmapPSpin) pmapPSpin->SetUserDlgProc(new SSParticleSpinDlgProc(this));
}	

void SuprSprayParticle::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{TimeValue t0,t2;
	SetFlag(dflags,APRTS_ROLLUP1_OPEN,IsRollupPanelOpen(hparam));
	SetFlag(dflags,APRTS_ROLLUP2_OPEN,IsRollupPanelOpen(hgen));
	SetFlag(dflags,APRTS_ROLLUP3_OPEN,IsRollupPanelOpen(hptype));
	SetFlag(dflags,APRTS_ROLLUP4_OPEN,IsRollupPanelOpen(hrot));
	SetFlag(dflags,APRTS_ROLLUP5_OPEN,IsRollupPanelOpen(pmapEmitV->GetHWnd()));
	SetFlag(dflags,APRTS_ROLLUP6_OPEN,IsRollupPanelOpen(hbubl));
	SetFlag(dflags,APRTS_ROLLUP7_OPEN,IsRollupPanelOpen(spawn));
	SetFlag(dflags,APRTS_ROLLUP8_OPEN,IsRollupPanelOpen(hParams2));
	SimpleParticle::EndEditParams(ip,flags,next);

	if (flags&END_EDIT_REMOVEUI) {
		pblock->GetValue(PB_EMITSTART,0,t0,FOREVER);
		pblock->GetValue(PB_EMITSTOP,0,t2,FOREVER);
		if (t2<t0) pblock->SetValue(PB_EMITSTOP,0,t0);
		DestroyCPParamMap(pmapParam);
		DestroyCPParamMap(pmapPGen);
		DestroyCPParamMap(pmapPType);
		DestroyCPParamMap(pmapPSpin);
		DestroyCPParamMap(pmapEmitV);
		DestroyCPParamMap(pmapBubl);
		DestroyCPParamMap(pmapSpawn);

		ip->UnRegisterDlgWnd(hParams2);
		ip->DeleteRollupPage(hParams2);
		hParams2 = NULL;

		pmapParam  = NULL;
		pmapPGen = NULL;
		pmapPType = NULL;
		pmapPSpin = NULL;
		pmapEmitV = NULL;
		pmapBubl = NULL;
		pmapSpawn = NULL;
	}else
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)NULL);
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
	}

void CommonParticle::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_EMITSTART,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_EMITSTART,0,TempTime);
	pblock->GetValue(PB_EMITSTOP,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_EMITSTOP,0,TempTime);
	pblock->GetValue(PB_DISPUNTIL,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_DISPUNTIL,0,TempTime);
// scaled values
	pblock->GetValue(PB_LIFE,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_LIFE,0,TempTime);
	pblock->GetValue(PB_LIFEVAR,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_LIFEVAR,0,TempTime);
	pblock->GetValue(PB_GROWTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_GROWTIME,0,TempTime);
	pblock->GetValue(PB_FADETIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_FADETIME,0,TempTime);
	pblock->GetValue(PB_MAPPINGTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_MAPPINGTIME,0,TempTime);
	pblock->GetValue(PB_SPINTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_SPINTIME,0,TempTime);
//	pblock->GetValue(PB_OFFSETAMOUNT,0,TempTime,FOREVER);
//	TempTime=map->map(TempTime);
//	pblock->SetValue(PB_OFFSETAMOUNT,0,TempTime);
	if (ClassID()==SUPRSPRAY_CLASS_ID)
	{	pblock->GetValue(PB_BUBLPER,0,TempTime,FOREVER);
		TempTime=map->map(TempTime);
		pblock->SetValue(PB_BUBLPER,0,TempTime);
	} 
}  

Interval CommonParticle::GetValidity(TimeValue t)
	{
	// For now...
	return Interval(t,t);
	}

void SuprSprayParticle::BuildEmitter(TimeValue t, Mesh& amesh)
	{
	float width,hwidth,u;
	mvalid = FOREVER;
	pblock->GetValue(PB_EMITRWID,t,width,mvalid);
//	width  *= 0.5f;
	hwidth =width*0.5f;

	mesh.setNumVerts(23);
	mesh.setNumFaces(18);
	for (int i=0; i<12; i++) {
		u = float(i)/12.0f * TWOPI;
		mesh.setVert(i, Point3((float)cos(u) * width, (float)sin(u) * width, 0.0f));
	}
	for (i=0; i<12; i++) 
	{ int i1 = i+1;
	  if (i1==12) i1 = 0;
	  mesh.faces[i].setEdgeVisFlags(1,0,0);
	  mesh.faces[i].setSmGroup(0);
	  mesh.faces[i].setVerts(i,i1,12);
	}
	mesh.setVert(12, Point3(0.0f, 0.0f, 0.0f));
	mesh.setVert(13, Point3(width,0.0f, width));
	mesh.setVert(14, Point3(0.0f, 0.0f, width));
	mesh.setVert(15, Point3(-width, 0.0f, width));
	mesh.setVert(16, Point3( width, 0.0f,-width));
	mesh.setVert(17, Point3( 0.0f, 0.0f, -width));
	mesh.setVert(18, Point3(-width, 0.0f, -width));
	mesh.setVert(19, Point3(hwidth, 0.0f,hwidth));
	mesh.setVert(20, Point3(-hwidth, 0.0f,hwidth));
	mesh.setVert(21, Point3(0.0f,hwidth,hwidth));
	mesh.setVert(22, Point3(0.0f,-hwidth,hwidth));

	mesh.faces[12].setVerts(13,14,17);
	mesh.faces[12].setEdgeVisFlags(1,1,0);
	mesh.faces[12].setSmGroup(0);

	mesh.faces[13].setEdgeVisFlags(0,1,1);
	mesh.faces[13].setSmGroup(0);
	mesh.faces[13].setVerts(13,17,16);

	mesh.faces[14].setEdgeVisFlags(1,1,0);
	mesh.faces[14].setSmGroup(0);
	mesh.faces[14].setVerts(14,15,18);

	mesh.faces[15].setEdgeVisFlags(0,1,1);
	mesh.faces[15].setSmGroup(0);
	mesh.faces[15].setVerts(14,18,17);

	mesh.faces[16].setEdgeVisFlags(1,1,1);
	mesh.faces[16].setSmGroup(0);
	mesh.faces[16].setVerts(19,14,20);

	mesh.faces[17].setEdgeVisFlags(1,1,1);
	mesh.faces[17].setSmGroup(0);
	mesh.faces[17].setVerts(21,14,22);

	mesh.InvalidateGeomCache();
	}

int CommonParticle::CountLive()
{	int c=0;
	for (int i=0; i<parts.Count(); i++)
	  {if (parts.Alive(i)) c++;}
	return c;
}

void CommonParticle::RetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc,i;
  Mtl *submtl=node->GetMtl();
  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  RetrieveMtls(node->GetChildNode(i),subtree,numsubs,numtabs,tabmax,t);
  }
  if (IsGEOM(node->EvalWorldState(t).obj)!=NULL)
  { if (*numtabs>=*tabmax)
	{ mttab.Resize((*tabmax)+=256);}
	if (submtl!=NULL)
	{ mttab[(*numtabs)++]=submtl;
	  int subs;
	  if ((subs=submtl->NumSubMtls())>0)
	    (*numsubs)+=subs;
	  else (*numsubs)++;
	}
	else 
	{DWORD tc=node->GetWireColor();
	StdMat *m = NewDefaultStdMat();
	m->SetName(TSTR(_T("C"))+node->GetName());
	Color bcolor=Color(tc);
	m->SetDiffuse(bcolor,0);
	mttab[(*numtabs)++]=(Mtl*)m;
	(*numsubs)++;
	}
  }
}

void CommonParticle::DoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
   for (int i=0;i<nc;i++)
   { INode *nxtnode=node->GetChildNode(i);
	  if (nxtnode->IsGroupHead()) DoGroupMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
	  else if((subtree)||(nxtnode->IsGroupMember())) RetrieveMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
  }
}

void CommonParticle::AssignMtl(INode *node,INode *topnode,int subtree,TimeValue t) 
{	Mtl *submtl;
	MultiMtl *newmat=NULL;
	Mtl *nmtl=NULL;
	TSTR newname;
	MtlBaseLib glib;
	int tabmax=256;
	newname=TSTR(_T("CMat"))+node->GetName();
	if (_tcslen(newname)>16) newname[16]='\0';
	int numsubs=0,numtabs=0,nCount=nlist.Count();
	nmtls.SetCount(nCount);
    mttab.SetCount(tabmax);
    submtl=custnode->GetMtl();
	INode *tmpnode=custnode;
	backpatch=FALSE;
	for (int mut=0;mut<=nCount;mut++)
	{ if (tmpnode->IsGroupHead())
	    DoGroupMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  else
	  RetrieveMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  if (mut!=nCount)
	  {nmtls[mut]=numsubs;
	   tmpnode=nlist[mut];
	  }
	}
	mttab.Shrink();
	if (!((numtabs==1)&&(submtl!=NULL)))
	{ TSTR oldname=TSTR(_T(" "));
	  if (nmtl=node->GetMtl())
		  oldname=nmtl->GetName();
	  if (_tcscmp(oldname,newname)!=0) 
	  { newmat=NewDefaultMultiMtl();
	    newmat->SetName(newname); }
	  else newmat=(MultiMtl*)nmtl;
//	  nmtl->FindMtl(nmtl);
	  newmat->SetNumSubMtls(numsubs);
	  int k=0,nt=0,j;
	  for (int i=0;i<numtabs;i++)
	  {	if ((nt=mttab[i]->NumSubMtls())>0)
	     for (j=0;j<nt;j++) 
		 { newmat->SetSubMtl(k,mttab[i]->GetSubMtl(j));
	       k++;
	     }
	     else 
		 { newmat->SetSubMtl(k,mttab[i]);
		   k++;
		 }
	  }
	}
    mttab.SetCount(0); mttab.Shrink();
	node->SetMtl(newmat!=NULL?newmat:submtl);  
}
void CommonParticle::CntRetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc,i;
  Mtl *submtl=node->GetMtl();
  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  CntRetrieveMtls(node->GetChildNode(i),subtree,numsubs,numtabs,tabmax,t);
  }
  if (IsGEOM(node->EvalWorldState(t).obj)!=NULL)
  { if (submtl!=NULL)
	{ int subs;
	  if ((subs=submtl->NumSubMtls())>0)
	    (*numsubs)+=subs;
	  else (*numsubs)++;
	}
	else 
	(*numsubs)++;
  }
}

void CommonParticle::CntDoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
   for (int i=0;i<nc;i++)
   { INode *nxtnode=node->GetChildNode(i);
	  if (nxtnode->IsGroupHead()) CntDoGroupMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
	  else if ((subtree)||(nxtnode->IsGroupMember())) CntRetrieveMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
  }
}

void CommonParticle::GetSubs(INode *node,INode *topnode,int subtree,TimeValue t) 
{	Mtl *submtl;
	int tabmax=256;
	int numsubs=0,numtabs=0;
	int mstart=0,mcnt=nlist.Count();INode *onode;
	onode=custnode;
	nmtls.SetCount(mcnt);
    submtl=onode->GetMtl();
	INode *tmpnode=onode;
	for (int mut=mstart;mut<=mcnt;mut++)
	{ if (tmpnode->IsGroupHead())
	    CntDoGroupMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  else
	  CntRetrieveMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  if (mut!=mcnt)
	  {nmtls[mut]=numsubs;
	   tmpnode=nlist[mut];
	  }
	}
}

void CommonParticle::GetNextBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode)
{int i,nc;
	if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  GetNextBB(node->GetChildNode(i),subtree,count,tabmax,boxcenter,t,tcount,onode);
  }
  Object *cobj=node->EvalWorldState(t).obj;
  TriObject *triOb=TriIsUseable(cobj,t);
  if (triOb)
  {	 if (*count>=*tabmax)
	{ theSuprSprayDraw.bboxpt[tcount].bpts.Resize((*tabmax)+=256);}
    Matrix3 ctm = node->GetObjTMAfterWSM(t);
	if (node!=custnode)
  { theSuprSprayDraw.bboxpt[tcount].bpts[*count].Suboffset=Point3(0.0f,0.0f,0.0f)*ctm-boxcenter;
  }	
  else theSuprSprayDraw.bboxpt[tcount].bpts[*count].Suboffset=Point3(0.0f,0.0f,0.0f);
	ctm.NoTrans();
  Box3 bbox=triOb->GetMesh().getBoundingBox();
  theSuprSprayDraw.bboxpt[tcount].bpts[*count].pts[0]=Point3(bbox.pmax[0],bbox.pmax[1],bbox.pmax[2])*ctm;
  theSuprSprayDraw.bboxpt[tcount].bpts[*count].pts[1]=Point3(bbox.pmax[0],bbox.pmax[1],bbox.pmin[2])*ctm;
  theSuprSprayDraw.bboxpt[tcount].bpts[*count].pts[2]=Point3(bbox.pmax[0],bbox.pmin[1],bbox.pmin[2])*ctm;
  theSuprSprayDraw.bboxpt[tcount].bpts[*count].pts[3]=Point3(bbox.pmax[0],bbox.pmin[1],bbox.pmax[2])*ctm;
  theSuprSprayDraw.bboxpt[tcount].bpts[*count].pts[4]=Point3(bbox.pmin[0],bbox.pmax[1],bbox.pmax[2])*ctm;
  theSuprSprayDraw.bboxpt[tcount].bpts[*count].pts[5]=Point3(bbox.pmin[0],bbox.pmax[1],bbox.pmin[2])*ctm;
  theSuprSprayDraw.bboxpt[tcount].bpts[*count].pts[6]=Point3(bbox.pmin[0],bbox.pmin[1],bbox.pmin[2])*ctm;
  theSuprSprayDraw.bboxpt[tcount].bpts[*count].pts[7]=Point3(bbox.pmin[0],bbox.pmin[1],bbox.pmax[2])*ctm;
  (*count)++;
  if (triOb!=cobj) triOb->DeleteThis();
  }
}

void CommonParticle::DoGroupBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) DoGroupBB(nxtnode,subtree,count,tabmax,boxcenter,t,tcount,onode);
	  else if ((subtree)||(nxtnode->IsGroupMember())) GetNextBB(nxtnode,subtree,count,tabmax,boxcenter,t,tcount,onode);
	}
}

void CommonParticle::GetallBB(INode *custnode,int subtree,TimeValue t)
{ int tabmax=256;
  int count=1,ocount=times.tl.Count();
  if (ocount>0) count=ocount;
  if (theSuprSprayDraw.bboxpt) delete[] theSuprSprayDraw.bboxpt;
  theSuprSprayDraw.bboxpt=NULL;
  INode *tmpnode;
  if (custnode!=NULL)
  { theSuprSprayDraw.bboxpt=new boxlst[count];
    int cgen;
    for (int tcount=0;tcount<count;tcount++)
    { TimeValue tofs=(ocount>0?times.tl[tcount].tl:t);
	  cgen=(times.tl.Count()>0?times.tl[tcount].gennum-1:-1);
	  if ((cgen>-1)&&(cgen<nlist.Count()))
	  { if (!(tmpnode=nlist[cgen])) tmpnode=custnode;
	  } else tmpnode=custnode;
	  theSuprSprayDraw.bboxpt[tcount].bpts.SetCount(tabmax);
      theSuprSprayDraw.bboxpt[tcount].numboxes=0;
      Matrix3 ctm = tmpnode->GetObjTMAfterWSM(tofs);
      boxcenter=Zero*ctm;
	  if (tmpnode->IsGroupHead())
	    DoGroupBB(tmpnode,subtree,&(theSuprSprayDraw.bboxpt[tcount].numboxes),&tabmax,boxcenter,tofs,tcount,tmpnode);
	  else
      GetNextBB(tmpnode,subtree,&(theSuprSprayDraw.bboxpt[tcount].numboxes),&tabmax,boxcenter,tofs,tcount,tmpnode);
	  theSuprSprayDraw.bboxpt[tcount].bpts.SetCount(theSuprSprayDraw.bboxpt[tcount].numboxes);
	 theSuprSprayDraw.bboxpt[tcount].bpts.Shrink();
    }
  }
}

void CommonParticle::CheckTree(INode *node,Matrix3 tspace,Mesh *cmesh,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl)
{ Object *pobj;	  
  TriObject *triOb;
  Point3 deftex=Point3(0.5f,0.5f,0.0f);
  TVFace Zerod;
  Zerod.t[0]=0;Zerod.t[1]=0;Zerod.t[2]=0;
  int nc,i,j,subv=0,subf=0,subtvnum=0,tface,tvert;

  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  CheckTree(node->GetChildNode(i),tspace,cmesh,numV,numF,tvnum,ismapped,t,subtree,custmtl);
  }
  if ((triOb=TriIsUseable(pobj = node->EvalWorldState(t).obj,t))!=NULL)
  {	Point3 Suboffset;
    Matrix3 ctm = node->GetObjTMAfterWSM(t);
/*	if (node!=custnode)
     Suboffset=Point3(0.0f,0.0f,0.0f)*ctm-boxcenter;
	else 
		Suboffset=Point3(0.0f,0.0f,0.0f);
	ctm.NoTrans();*/
	int submtls=0;
	Mtl* m=node->GetMtl();
	if (!((m!=NULL)&&(submtls=m->NumSubMtls()))) 
	  submtls=-1;
	int tottv;
	subv=triOb->GetMesh().getNumVerts();
    subf=triOb->GetMesh().getNumFaces();
    subtvnum=triOb->GetMesh().getNumTVerts();
    cmesh->setNumFaces(tface=(*numF+subf),(*numF>0?TRUE:FALSE));
    cmesh->setNumVerts(tvert=(*numV+subv),(*numV>0?TRUE:FALSE));
    cmesh->setNumTVerts(tottv=(*tvnum+subtvnum),(*tvnum>0?TRUE:FALSE));
    if ((subtvnum>0)||(*ismapped))
    { if ((!(*ismapped))&&(*numF>0))
	  { cmesh->setNumTVFaces(tface);
	    *tvnum=1;
		cmesh->setNumTVerts(tottv+1);
		cmesh->tVerts[0]=deftex;
		for (int k=0;k<*numF;k++)
		  memcpy(&(cmesh->tvFace[k]),&Zerod,sizeof(TVFace));
	   }
	  else 
	   cmesh->setNumTVFaces(tface,(*numF>0?TRUE:FALSE),*numF);
	  *ismapped=1;
	}
	if (subf>0) 
	{ memcpy(&(cmesh->faces[*numF]),triOb->GetMesh().faces,sizeof(Face)*subf);
	  if (subtvnum>0)
	    memcpy(&(cmesh->tvFace[*numF]),triOb->GetMesh().tvFace,sizeof(TVFace)*subf);
	}
	j=(*numF);
	BOOL mirror=DotProd(ctm.GetRow(0)^ctm.GetRow(1),ctm.GetRow(2))<0.0f;
	for (j=(*numF);j<tface;j++)
	{ cmesh->faces[j].v[0]+=*numV;
	  cmesh->faces[j].v[1]+=*numV;
	  cmesh->faces[j].v[2]+=*numV;
	  if (mirror) MirrorFace(&cmesh->faces[j]);
	  if (custmtl)
	  { if (submtls<0) cmesh->faces[j].setMatID(CustMtls);
	  else cmesh->faces[j].setMatID(cmesh->faces[j].getMatID()+CustMtls);
	  }
	  if (subtvnum>0)
	  { cmesh->tvFace[j].t[0]+=*tvnum;
	    cmesh->tvFace[j].t[1]+=*tvnum;
	    cmesh->tvFace[j].t[2]+=*tvnum;
		if (mirror) MirrorTVs(&cmesh->tvFace[j]);
	  }
	  else if (*ismapped)
	    memcpy(&(cmesh->tvFace[j]),&Zerod,sizeof(TVFace));
	}
	if (subtvnum>0) 
      memcpy(&(cmesh->tVerts[*tvnum]),triOb->GetMesh().tVerts,sizeof(UVVert)*subtvnum);
//	if (subv) memcpy(&(clst->v[*numV]),triOb->mesh.verts,sizeof(Point3)*subv);
	int k=0;
	ctm=ctm*tspace;
/*	Matrix3 objoff(1);
	Point3 pos = node->GetObjOffsetPos();objoff.PreTranslate(pos);
	Quat quat = node->GetObjOffsetRot();PreRotateMatrix(objoff, quat);
	ScaleValue scaleValue = node->GetObjOffsetScale();ApplyScaling(objoff, scaleValue);*/
	for (j=*numV;j<tvert;j++)
	{ cmesh->verts[j]=(triOb->GetMesh().verts[k]*ctm);//+Suboffset;
	  k++;
	}
	*numV+=subv;
	*numF+=subf;
	*tvnum+=subtvnum;
	if (submtls>0)
	CustMtls+=submtls;
	else CustMtls++;
   if (triOb!=pobj) triOb->DeleteThis();
  }
}

void CommonParticle::TreeDoGroup(INode *node,Matrix3 tspace,Mesh *cmesh,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) TreeDoGroup(nxtnode,tspace,cmesh,numV,numF,tvnum,ismapped,t,subtree,custmtl);
	  else if ((subtree)||(nxtnode->IsGroupMember())) CheckTree(nxtnode,tspace,cmesh,numV,numF,tvnum,ismapped,t,subtree,custmtl);
	}
}

void CommonParticle::GetMesh(TimeValue t,int subtree,int custmtl)
{	int tnums,numV,numF,tvnum,ismapped;
    INode *tmpnode;
	tnums=times.tl.Count();
	if (tnums==0) tnums=1;
	if (cmesh) delete[] cmesh;cmesh=NULL;
	if (custnode!=NULL)
	{ cmesh=new Mesh[tnums];
	  int cgen;
	 for (int i=0;i<tnums;i++)
	{ TimeValue tofs=(tnums>1?times.tl[i].tl:t);
	  cgen=(times.tl.Count()>0?times.tl[i].gennum-1:-1);
	  if ((cgen>-1)&&(cgen<nlist.Count()))
	  { if (!(tmpnode=nlist[cgen])) tmpnode=custnode;
	  } else tmpnode=custnode;
	  Matrix3 ptm = tmpnode->GetObjTMAfterWSM(tofs);
	  Matrix3 topspace=Inverse(ptm);
	  numV=numF=tvnum=CustMtls=ismapped=0;
	  if (tmpnode->IsGroupHead())
	   TreeDoGroup(tmpnode,topspace,&cmesh[i],&numV,&numF,&tvnum,&ismapped,tofs,subtree,custmtl);
	  else
	   CheckTree(tmpnode,topspace,&cmesh[i],&numV,&numF,&tvnum,&ismapped,tofs,subtree,custmtl);
	}
	}
}
/*void ResizeAllParts(ParticleSys &parts,int c)
{ parts.points.Resize(c);parts.points.SetCount(c);
  parts.vels.Resize(c);parts.vels.SetCount(c);
  parts.ages.Resize(c);parts.ages.SetCount(c);
  parts.radius.Resize(c);parts.radius.SetCount(c);
  parts.tension.Resize(c);parts.tension.SetCount(c);
}*/

void CommonParticle::DoSpawn(int j,int spmult,SpawnVars spvars,TimeValue lvar,BOOL emit)
{ if (!emit) spmult--;
  int oldcount,newcount=((oldcount=parts.Count())+spmult); 
  srand(rseed);
  if (spmult)
  {	parts.SetCount(newcount,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
	CSavePt *tmp=sdata;
	sdata=new CSavePt[newcount];
	if (tmp)
	{ for (int j=0;j<oldcount;j++) sdata[j]=tmp[j];
	  delete[] tmp;
	}
  }
  int Lcnt=llist.Count();
  int baselife=(Lcnt==0?deftime:(sdata[j].gennum<Lcnt?llist[sdata[j].gennum]:llist[Lcnt-1]))*GetTicksPerFrame();
  if (!emit)
  { sdata[j].gennum++;
	parts.ages[j]=0;}
  Point3 holdv=(emit?-parts.vels[j]:parts.vels[j]);
  for (int i=oldcount;i<newcount;i++)
  { parts.points[i]=parts.points[j];
    parts.vels[i]=holdv;
	parts.radius[i]=parts.radius[j];
	parts.tension[i]=parts.tension[j];
	parts.ages[i]=0;
	memcpy(&sdata[i],&sdata[j],sizeof(CSavePt));
	if (emit) sdata[i].gennum++;
    parts.vels[i]=DoSpawnVars(spvars,parts.vels[j],holdv,&parts.radius[i],&sdata[i].W);
	sdata[i].Vsz=parts.radius[i];
	sdata[i].L=baselife+(int)RND11()*lvar;
 	sdata[i].Mltvar=RND11();
	sdata[i].SpVar=RND0x(99);
	sdata[i].DL=-1;
 }
  if (!emit)
  { parts.vels[j]=DoSpawnVars(spvars,parts.vels[j],holdv,&parts.radius[j],&sdata[j].W);
    sdata[j].Vsz=parts.radius[j];
    sdata[j].L=baselife+(int)RND11()*lvar;
		sdata[j].Mltvar=RND11();
		sdata[j].SpVar=RND0x(99);
		sdata[j].DL=-1;
  }
  int tmprseed=rand();
  rseed=(tmprseed==rseed?rand():tmprseed);
}

#define VEL_SCALE	(0.01f*1200.0f/float(TIME_TICKSPERSEC))
#define VAR_SCALE	(0.01f*1200.0f/float(TIME_TICKSPERSEC))

BOOL SuprSprayParticle::ComputeParticleStart(TimeValue t0,int c)
	{
	int seed,anioff,tani;
	TimeValue anifr;
	pblock->GetValue(PB_RNDSEED,t0,seed,FOREVER);
    pblock->GetValue(PB_OFFSETAMOUNT,t0,anifr,FOREVER);
    pblock->GetValue(PB_ANIMATIONOFFSET,t0,anioff,FOREVER);
	srand(seed);					
	parts.SetCount(c,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
 	int pcount=parts.Count();
    if (sdata){delete[] sdata;sdata=NULL;} if (pcount) sdata=new CSavePt[pcount];
	if ((pcount<c)||(c>0 && (!sdata)))
	{   parts.FreeAll();if (sdata) delete sdata;sdata=NULL;maincount=0;
		BOOL playing=GetCOREInterface()->IsAnimPlaying();
		if (playing) GetCOREInterface()->EndAnimPlayback();
	    TSTR name;name=(cnode ? cnode->GetName() : TSTR(GetString(IDS_AP_SUPRSPRAY)));
		TSTR buf; buf=TSTR(GetString(IDS_OFM_PART));
		GetCOREInterface()->Log()->LogEntry(SYSLOG_ERROR,DISPLAY_DIALOG,
			GetString(IDS_OFM_ERROR),_T("%s: \n\n%s\n"),buf,name);
	  return (0);
	}
	float tmp;
	int oneframe=GetTicksPerFrame();
	for (int i=0; i<parts.Count(); i++) {
		parts.ages[i] = -1;
		sdata[i].themtl=0;
  		sdata[i].L=RND0x(99);sdata[i].DL=-1;sdata[i].pvar=RND11();
		tmp=RND01();sdata[i].Fo=tmp;
		tani=RND0x(anifr/oneframe);
		sdata[i].showframe=(anioff==2?tani*oneframe:0);
		sdata[i].gennum=0;
		sdata[i].V.x=RND11();
		sdata[i].V.y=RND11();
		sdata[i].V.z=RND11();
		sdata[i].Ts0=RND11();
		sdata[i].Ts=0.0f;
		sdata[i].LamTs=RND11();
		sdata[i].A=RND11();
		sdata[i].LamA=RND11();
		tmp=RND11();sdata[i].M=tmp;
		parts.vels[i]=Point3(RND11(),RND11(),RND11());
		sdata[i].To=RND11();
		sdata[i].Vsz=RND11();
		sdata[i].W=Point3(RND11(),RND11(),RND11());
		sdata[i].RV=Point3(RND11(),RND11(),RND11());
		tmp=RND11();sdata[i].Dis=tmp;
		parts.radius[i]=0.0f;
		parts.tension[i]=RND11();
		sdata[i].Mltvar=RND11();
		sdata[i].SpVar=RND0x(99);
		}
	tvalid = t0-1;
	valid  = TRUE;
	rseed=rand();
	return (1);
	}

void SuprSprayParticle::BirthParticle(INode *node,TimeValue bt,int num,VelDir* ptvel,Matrix3 tmnxt)
{	Matrix3 tm = node->GetObjTMBeforeWSM(bt);
	Matrix3 atm = node->GetObjTMAfterWSM(bt);
	tm.SetRow(3,atm.GetRow(3));
	Point3 vel;
	float Ie,Em,Vm;
	int RotSampleOn;
	srand(rseed);
	pblock->GetValue(PB_EMITVINFL,bt,Ie,FOREVER);
	pblock->GetValue(PB_EMITVMULT,bt,Em,FOREVER);
	pblock->GetValue(PB_EMITVMULTVAR,bt,Vm,FOREVER);
	pblock->GetValue(PB_SUBFRAMEROT,bt,RotSampleOn,FOREVER);
	int MotionOffset,EmitOffset;
	pblock->GetValue(PB_SUBFRAMEMOVE,bt,MotionOffset,FOREVER);
	pblock->GetValue(PB_SUBFRAMETIME,bt,EmitOffset,FOREVER);
	sdata[num].Ts0=(1+sdata[num].Ts0*ptvel->VSpin)/TWOPI;
	sdata[num].Ts=(float)ptvel->Spin*sdata[num].Ts0;
	parts.tension[num]=ptvel->bstr*(1+parts.tension[num]*ptvel->bstrvar);
	sdata[num].persist=(TimeValue)(ptvel->persist*(1.0f+sdata[num].pvar*ptvel->pvar));
// ok, so I'm using L for M and .z for L.  They were unused float and ints
	sdata[num].M=(sdata[num].L<Ie?Em*(1+sdata[num].M*Vm):0);  
	sdata[num].L=ptvel->Life+(int)(parts.vels[num].z*ptvel->Vl);
	sdata[num].Vsz*=ptvel->VSz;
	sdata[num].LamTs=ptvel->Phase*(1+sdata[num].LamTs*ptvel->VPhase);
	sdata[num].A=ptvel->ToAmp*(1+sdata[num].A*ptvel->VToAmp);
	sdata[num].LamA=ptvel->ToPhase*(1+sdata[num].LamA*ptvel->VToPhase);
	sdata[num].To=ptvel->ToPeriod*(1+sdata[num].To*ptvel->VToPeriod);
	if (ptvel->axisentered==2)
	{	sdata[num].W=Normalize(ptvel->Axis);
		if (ptvel->axisvar>0.0f)
		VectorVar(&sdata[num].W,ptvel->axisvar,180.0f);
	}
	else sdata[num].W=Normalize(sdata[num].W);
	parts.ages[num]=0;
	float Thetav,Thetah,SSv,SCv;
	Thetav=ptvel->Av180+ptvel->VAv*parts.vels[num].x;
	Thetah=ptvel->Ah180+ptvel->VAh*parts.vels[num].y;
	SSv=(float)sin(Thetav);
	SCv=(float)cos(Thetav);
	vel.y=(float)(SSv*sin(Thetah));
	vel.x=(float)(SSv*cos(Thetah));
	vel.z=SCv;
	Matrix3 OffRotTm;
	if (RotSampleOn) MakeInterpRotXform(tm,tmnxt,(1.0f-sdata[num].Fo),OffRotTm);
	else OffRotTm=tm;
	vel=VectorTransform(OffRotTm,vel);

	vel=vel*ptvel->Speed*(1+sdata[num].V.z*ptvel->VSpeed);
//	vel.y*=ptvel->Speed*(1+sdata[num].V.z*ptvel->VSpeed);
//	vel.z*=ptvel->Speed*(1+sdata[num].V.z*ptvel->VSpeed);

	if (sdata[num].M!=0.0f) vel+=ptvel->Ve*sdata[num].M;
	parts[num]=tm.GetRow(3);
	if (MotionOffset) parts[num]+=(ptvel->Ve)*(1.0f-sdata[num].Fo);
	if (EmitOffset) parts[num]+=(sdata[num].Fo)*vel;
	vel/=(float)GetTicksPerFrame();
	parts.vels[num]=vel;
	sdata[num].V=parts[num];
	rseed=rand();
}

void SuprSprayParticle::MovePart(int j,TimeValue dt,BOOL fullframe,int tpf)
{	parts[j] = sdata[j].V+parts.vels[j] * (float)dt;
	// add transverse oscillation
	if (fullframe) sdata[j].V=parts[j];
	Point3 DotPt=(FGT0(parts.vels[j]*(float)tpf)?parts.vels[j]:sdata[j].W);
	DotPt=sdata[j].RV^DotPt;				// Cross Product 
	DotPt=Normalize(DotPt);	       
	float oscil=(sdata[j].To>0.0f?parts.ages[j]*TWOPI/sdata[j].To:0.0f);
	oscil=sdata[j].A*(float)sin(oscil+sdata[j].LamA);
	parts[j] +=DotPt*oscil;
}


void SuprSprayParticle::UpdateParticles(TimeValue t,INode *node)
{	TimeValue t0,dt,t2,grow,fade;
	int i, j, birth,counter,tpf=GetTicksPerFrame(),count=0,anioff;
	VelDir ptvel;
	int isrend=TestAFlag(A_RENDER),bmethod,onscreen,oneframe;
	TimeValue c;
	cancelled=FALSE;

	// The size of steps we take to integrate will be frame size steps.
	oneframe=GetTicksPerFrame();
	if (stepSize!=oneframe) 
	{	stepSize = oneframe;
		valid = FALSE;
	}
	float FperT = GetFrameRate()/(float)TIME_TICKSPERSEC;
    pblock->GetValue(PB_ANIMATIONOFFSET,t,anioff,FOREVER);
	pblock->GetValue(PB_EMITSTART,t,t0,FOREVER);
	pblock->GetValue(PB_SIZE,t,parts.size,FOREVER);	
	pblock->GetValue(PB_BIRTHMETHOD,0,bmethod,FOREVER);
	pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	pblock->GetValue(PB_EMITSTOP,0,t2,FOREVER);
	if (bmethod)
		pblock->GetValue(PB_PTOTALNUMBER,0,c,FOREVER);
	int subtree,frag,custmtl=0;
    pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
	pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);

	// Before the start time, nothing is happening
	if (t < t0)
	{	parts.FreeAll();
		if (sdata)
		{	delete[] sdata;
			sdata=NULL;
		}
		ResetSystem(t);
		return;
	}
	int pkind;
	float dpercent;
	pblock->GetValue(PB_DISPLAYPORTION,0,dpercent,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,pkind,FOREVER);

	// Set the particle system to the initial condition
	if ((!valid || t<tvalid) || tvalid<t0) 
	{   int cincr;	
		if (!bmethod)
		{	c=0;
			for (TimeValue ti=t0;ti<=t2;ti+=oneframe)
			{	pblock->GetValue(PB_PBIRTHRATE,ti,cincr,FOREVER);
				if (cincr<0) cincr=0;
				c += cincr;
			}
		}
		if (!isrend) 
			c=(int)(dpercent*(float)c+FTOIEPS);
		if (!ComputeParticleStart(t0,c))
		{ ResetSystem(t);
		  return;
		}
		dispt=t-1;
		maincount=parts.Count();
		ResetSystem(t,FALSE);
	}
	int total;
	total=maincount;
	valid = TRUE;
	int stype,maxgens,spmultb;
	float spawnbvar;
    pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
    pblock->GetValue(PB_SPAWNGENS,0,maxgens,FOREVER);
    pblock->GetValue(PB_SPAWNCOUNT,0,spmultb,FOREVER);
    pblock->GetValue(PB_SPINAXISTYPE,0,ptvel.axisentered,FOREVER);
	SpawnVars spawnvars;
 	spawnvars.axisentered=ptvel.axisentered;
	TimeValue dis;
    pblock->GetValue(PB_DISPUNTIL,0,dis,FOREVER);

	if (t2<t0) 
		t2 = t0;
	TimeValue fstep=oneframe;

//	t2+=fstep;
	TimeValue createover;
	createover = t2-t0+oneframe;
	counter = (isrend?rcounter:vcounter);
	float frate,grate;
	pblock->GetValue(PB_GROWTIME,0,grow,FOREVER);
    pblock->GetValue(PB_FADETIME,0,fade,FOREVER);
	frate=(fade>0.0f?(1-M)/fade:0.0f);
	grate=(grow>0.0f?(1-M)/grow:0.0f);
	float basesize;
	BOOL fullframe;
	if (!isrend)
	{	int offby=t%oneframe;
		if (offby!=0) 
			t-=offby;
	}
	pblock->GetValue(PB_SPAWNSCALESIGN,0,spawnvars.scsign,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDSIGN,0,spawnvars.spsign,FOREVER);
    pblock->GetValue(PB_SPAWNINHERITV,0,spawnvars.invel,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDFIXED,0,spawnvars.spconst,FOREVER);
    pblock->GetValue(PB_SPAWNSCALEFIXED,0,spawnvars.scconst,FOREVER);
	int sper,spmult;
	float smper;BOOL first=(tvalid<t0);
	while ((tvalid < t)&&(tvalid<=dis))
	{	int born = 0;
	    count=0;
		if (first) 
			tvalid=t0;
		// Compute our step size
		if (tvalid%stepSize !=0) 
		{	dt = stepSize - abs(tvalid)%stepSize;
		} 
		else 
		{	dt = stepSize;
		}
		if (tvalid + dt > t) 
		{	dt = t-tvalid;
		}

  		// Increment time
		if (!first) 
			tvalid += dt;
		if (tvalid>dis)
		{	for (j=0; j<parts.Count(); j++)
			{	parts.ages[j] = -1;  
			}
			tvalid=t;
			continue;
		}
		// Compute the number of particles that should be born!
		birth=0;
		fullframe=(tvalid%tpf==0);
		if (fullframe)
		{	if (bmethod)
			{	int tdelta;
				if (tvalid>=t2) 
					birth=total-counter;
				else
				{	tdelta=int((float)total*(tvalid-t0+oneframe)/createover);
					birth=tdelta-counter;
				}
			}
			else if (tvalid<=t2)
			{	pblock->GetValue(PB_PBIRTHRATE,tvalid,total,FOREVER);
				if (!isrend) 
					total = (int)(dpercent*(float)total+FTOIEPS);
				birth=total;
				if (birth+counter>maincount) 
					birth=0;
			}
		}
	    pblock->GetValue(PB_SSSPAWNDIEAFTER,tvalid,ptvel.persist,FOREVER);
	    pblock->GetValue(PB_SSSPAWNDIEAFTERVAR,tvalid,ptvel.pvar,FOREVER);
	    pblock->GetValue(PB_SPEED,tvalid,ptvel.Speed,FOREVER);
    	pblock->GetValue(PB_SPEEDVAR,tvalid,ptvel.VSpeed,FOREVER);
		pblock->GetValue(PB_SIZE,tvalid,ptvel.Size,FOREVER);
		pblock->GetValue(PB_OFFAXIS,tvalid,ptvel.Av180,FOREVER);
		pblock->GetValue(PB_AXISSPREAD,tvalid,ptvel.VAv,FOREVER);
		pblock->GetValue(PB_OFFPLANE,tvalid,ptvel.Ah180,FOREVER);
		pblock->GetValue(PB_PLANESPREAD,tvalid,ptvel.VAh,FOREVER);
		pblock->GetValue(PB_LIFE,tvalid,ptvel.Life,FOREVER);
		pblock->GetValue(PB_LIFEVAR,tvalid,ptvel.Vl,FOREVER);
		pblock->GetValue(PB_SPINTIME,tvalid,ptvel.Spin,FOREVER);
		pblock->GetValue(PB_SPINTIMEVAR,tvalid,ptvel.VSpin,FOREVER);
		pblock->GetValue(PB_SPINPHASE,tvalid,ptvel.Phase,FOREVER);
		pblock->GetValue(PB_SPINPHASEVAR,tvalid,ptvel.VPhase,FOREVER);
		pblock->GetValue(PB_SIZEVAR,tvalid,ptvel.VSz,FOREVER);
	    pblock->GetValue(PB_METATENSION,tvalid,ptvel.bstr,FOREVER);
		pblock->GetValue(PB_METATENSIONVAR,tvalid,ptvel.bstrvar,FOREVER);
		pblock->GetValue(PB_BUBLAMP,tvalid,ptvel.ToAmp,FOREVER);
		pblock->GetValue(PB_BUBLAMPVAR,tvalid,ptvel.VToAmp,FOREVER);
		pblock->GetValue(PB_BUBLPHAS,tvalid,ptvel.ToPhase,FOREVER);
		pblock->GetValue(PB_BUBLPHASVAR,tvalid,ptvel.VToPhase,FOREVER);
		pblock->GetValue(PB_BUBLPER,tvalid,ptvel.ToPeriod,FOREVER);
		pblock->GetValue(PB_BUBLPERVAR,tvalid,ptvel.VToPeriod,FOREVER);
	    pblock->GetValue(PB_SPAWNDIRCHAOS,tvalid,spawnvars.dirchaos,FOREVER);
	    pblock->GetValue(PB_SPAWNSPEEDCHAOS,tvalid,spawnvars.spchaos,FOREVER);
		spawnvars.spchaos/=100.0f;
	    pblock->GetValue(PB_SPAWNSCALECHAOS,tvalid,spawnvars.scchaos,FOREVER);
		spawnvars.scchaos/=100.0f;
	    pblock->GetValue(PB_SPAWNPERCENT,tvalid,sper,FOREVER);	
		pblock->GetValue(PB_SPAWNMULTVAR,tvalid,smper,FOREVER);	
		spawnbvar=smper*spmultb;
  		pblock->GetValue(PB_SPINAXISX,tvalid,ptvel.Axis.x,FOREVER);
		pblock->GetValue(PB_SPINAXISY,tvalid,ptvel.Axis.y,FOREVER);
		pblock->GetValue(PB_SPINAXISZ,tvalid,ptvel.Axis.z,FOREVER);
		if (Length(ptvel.Axis)==0.0f) 
			ptvel.Axis.x=0.001f;
		pblock->GetValue(PB_SPINAXISVAR,tvalid,ptvel.axisvar,FOREVER);
		spawnvars.Axis=ptvel.Axis;
		spawnvars.axisvar=ptvel.axisvar;
		if (llist.Count()==0) 
			deftime=ptvel.Life/oneframe;
		basesize=M*ptvel.Size;
		// First increment age and kill off old particles
		for (j=0;j<parts.Count();j++)
		{	if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
			{	valid=FALSE;
				tvalid=t;
				cancelled=TRUE;
				parts.FreeAll();
				return;
			}
			if (!parts.Alive(j)) 
				continue;
			parts.ages[j] += dt;
			if (parts.ages[j] >= sdata[j].L) 
			{	if ((stype!=ONDEATH)||(sdata[j].gennum>=maxgens)||(sdata[j].SpVar>=sper)) 
					parts.ages[j] = -1;	
				else if (fullframe)
				{	spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
					if (spmult!=0) 
						DoSpawn(j,spmult,spawnvars,ptvel.Vl,FALSE);
					else 
						parts.ages[j] = -1;
				}
			} 
			else if (sdata[j].DL>-1) 
			{	sdata[j].DL+=dt;
				if (sdata[j].DL>sdata[j].persist) 
					parts.ages[j]=-1;	
			}
			if (parts.ages[j]>-1)
			{	if (fullframe && ((stype==EMIT)&&(sdata[j].gennum==0)&&(sdata[j].SpVar<sper)))
				{	spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
					if (spmult!=0) 
						DoSpawn(j,spmult,spawnvars,ptvel.Vl,TRUE);
				}
//			if (pkind==RENDTYPE6)
//		    parts.radius[j]=ptvel.Size; else 
				if ((stype<2)||(maxgens==0))
		 			parts.radius[j]=FigureOutSize(parts.ages[j],ptvel.Size,grow,fade,sdata[j].L,grate,frate)*(1+sdata[j].Vsz);
				else 
				{	if (sdata[j].gennum==0)
						parts.radius[j]=FigureOutSize(parts.ages[j],ptvel.Size,grow,0,sdata[j].L,grate,frate)*(1+sdata[j].Vsz);
					else if (sdata[j].gennum==maxgens)
						parts.radius[j]=FigureOutSize(parts.ages[j],sdata[j].Vsz,0,fade,sdata[j].L,grate,frate);
				}
			}
		}
		// Apply forces to modify velocity
//		if (fullframe)
		if (birth>0)
		{	Matrix3 tm;	
			Point3 LastCenter,NextCenter;
			TimeValue checkone=tvalid-t0;
			tm = node->GetObjTMBeforeWSM(checkone<stepSize?0:(tvalid-stepSize));
			LastCenter=Zero*tm;
			tm = node->GetObjTMBeforeWSM(tvalid+stepSize);
			NextCenter = Zero*tm;
			ptvel.Ve=(NextCenter-LastCenter)/(checkone<stepSize?(1.0f+checkone/stepSize):2.0f);

		// Next, birth particles at the birth rate
			for (j=counter; j<maincount; j++) 
			{	if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
				{	valid=FALSE;
					tvalid=t;cancelled=TRUE;
					parts.FreeAll();
					return;
				}
				if (born>=birth) 
					break;
				BirthParticle(node,tvalid,j,&ptvel,tm);
//				if ((pkind==RENDTYPE5)||(pkind==RENDTYPE6))
//					parts.radius[j]=ptvel.Size;	else 
				parts.radius[j]=(grow>0?basesize:ptvel.Size)*(1+sdata[j].Vsz);
				sdata[j].themtl=int((tvalid-t0)*FperT);
				sdata[j].showframe=(anioff==1?0:sdata[j].showframe);
				born++;
				counter++;
			}
		}
		int fc=fields.Count();

		if (fc>0)
			for (j=0; j<parts.Count(); j++) 
			{	Point3 force,tvel=Zero;
				for (i=0; i<fc; i++) 
				{	if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) ) 
					{	valid=FALSE;
						tvalid=t;
						cancelled=TRUE;
						parts.FreeAll();
						return;
					}
					if (!parts.Alive(j)) 
						continue;
					parts[j]=sdata[j].V;
					force = fields[i]->Force(tvalid,parts[j],parts.vels[j],j);
					float curdt = (float)dt;
					if ((parts.ages[j]==0)&&(sdata[j].gennum==0)) 
						curdt=tpf*sdata[j].Fo;
					tvel += 10.0f*force * curdt;
				}
				parts.vels[j]+=tvel;
			}

// IPC IPC IPC IPC ss

		int IPC,ipcsteps;float B,Vb;
  		pblock->GetValue(PB_IPCOLLIDE_ON,tvalid,IPC,FOREVER);
  		pblock->GetValue(PB_IPCOLLIDE_STEPS,tvalid,ipcsteps,FOREVER);
  		pblock->GetValue(PB_IPCOLLIDE_BOUNCE,tvalid,B,FOREVER);
  		pblock->GetValue(PB_IPCOLLIDE_BOUNCEVAR,tvalid,Vb,FOREVER);
		if (IPC)
		{	CollideParticle cp;
			int ddt=dt/ipcsteps,remtime=0,snum=0;
			TimeValue curt=tvalid;
			if (dt > 0)
			{	while (snum < ipcsteps)
				{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
				  {	valid=FALSE;
					tvalid=t;
					cancelled=TRUE;
					parts.FreeAll();
					return;
				  }
				  if (remtime==0) remtime=ddt;
				  mindata md=cp.InterPartCollide(parts,cobjs,remtime,snum,B,Vb,curt,lc);
				  for (j=0; j<parts.Count(); j++)
				  {	if (parts.ages[j]>0) 
					{ if ((j!=md.min)&&(j!=md.min2)) 
					  { if (fullframe) 
						  MovePart(j,md.mintime,fullframe,tpf);
						else 
						  parts[j]+=parts.vels[j]*(float)md.mintime;
					  }
					  else if (fullframe) sdata[j].V=parts[j];
					}
				  }
				}
			}
		}
		else
			for (j=0; j<parts.Count(); j++)
			{	if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) ) 
				{	valid=FALSE;
					tvalid=t;
					cancelled=TRUE;
					parts.FreeAll();
					return;
				}
				if ((!parts.Alive(j))||(parts.ages[j]==0)) 
					continue;
				count++;

			// Check for collisions
				BOOL collide = FALSE;
				float meaninglesstime;
				for (int i=0; i<cobjs.Count(); i++)
				{	if (cobjs[i]->CheckCollision(tvalid,parts[j],parts.vels[j], (float)dt, j,&meaninglesstime,TRUE)) 
					{	collide = TRUE;
						if (stype==1)
						{	if (sdata[j].persist==0) 
							{	parts.ages[j] = -1;
								count--;
							}
							else 
								sdata[j].DL=0;
						}
						else if (fullframe &&((stype==COLLIDE)&&(sdata[j].gennum<maxgens)&&(sdata[j].SpVar<sper)))
						{	int spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
							if (spmult!=0) 
								DoSpawn(j,spmult,spawnvars,ptvel.Vl,FALSE);
							else 
								break;
						}
						else 
							break;
					}
				}

			// If we didn't collide, then increment.
				if (!collide) 
					MovePart(j,dt,fullframe,tpf);
				else if (fullframe) 
					sdata[j].V=parts[j];
			}

// end of code that will change to support IPC

		if (first) 
			first=FALSE;
		for (j=0; j<parts.Count(); j++)
		{	sdata[j].Ts = (float)ptvel.Spin*sdata[j].Ts0;
			sdata[j].LamTs += (FloatEQ0(sdata[j].Ts)?0.0f:dt/sdata[j].Ts);
		}
	}	

/*	if ((frag==METABALLS)&&((!isrend)&&(onscreen==2)))
	{	float res,bstr,thres=0.6f;
		pblock->GetValue(PB_METATENSION,t,bstr,FOREVER);
		pblock->GetValue(PB_METACOURSE,0,res,FOREVER);
		if (cmesh) delete[] cmesh;cmesh=new Mesh;
		metap.CreateMetas(parts,cmesh,thres,res,bstr);
	}
	else*/
	if ((frag==INSTGEOM)&&(onscreen>1)&&(custnode))
	{	TimeValue anist=GetAnimStart(),aniend=GetAnimEnd();
		theSuprSprayDraw.anifr=aniend+stepSize;
		theSuprSprayDraw.t=t;
		theSuprSprayDraw.anioff=anioff;
		if (count>0)
			GetTimes(times,t,theSuprSprayDraw.anifr,anioff);
		else 
			times.tl.ZeroCount();
		if (onscreen==2)
			GetMesh(t,subtree,custmtl);
		else 
			GetallBB(custnode,subtree,t);
	}  
	if (isrend) 
		rcounter=counter;
	else 
		vcounter=counter;
	if (tvalid<t) 
		tvalid=t;
	valid=TRUE;
//	ssert(tvalid==t);
}


void SuprSprayParticle::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	if (pmapPGen) pmapPGen->Invalidate();
	if (pmapPType) pmapPType->Invalidate();
	if (pmapPSpin) pmapPSpin->Invalidate();
	if (pmapEmitV) pmapEmitV->Invalidate();
	if (pmapBubl) pmapBubl->Invalidate();
	if (pmapSpawn) pmapSpawn->Invalidate();
	}

BOOL CommonParticle::EmitterVisible()
	{
	int hide;
	pblock->GetValue(PB_EMITRHID,0,hide,FOREVER);
	return !hide;
	}

ParamDimension *SuprSprayParticle::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SPEED:
		case PB_SIZE:
		case PB_METATENSION:
		case PB_METACOURSE:
		case PB_MAPPINGDIST:
		case PB_SPINAXISX:
		case PB_SPINAXISY:
		case PB_SPINAXISZ:
		case PB_EMITVMULT:
		case PB_BUBLAMP:
		case PB_EMITRWID:  			return stdWorldDim;

		case PB_RNDSEED:
		case PB_PBIRTHRATE:
		case PB_PTOTALNUMBER:
									return defaultDim;

		case PB_OFFAXIS:
		case PB_AXISSPREAD:
		case PB_OFFPLANE:
		case PB_PLANESPREAD:
		case PB_SPINPHASE:
		case PB_SPINAXISVAR:
		case PB_BUBLPHAS:			return stdAngleDim;

		case PB_DISPLAYPORTION:
		case PB_SIZEVAR:
		case PB_SPEEDVAR:
		case PB_SPAWNDIRCHAOS:
		case PB_METATENSIONVAR:
		case PB_SPINTIMEVAR:
		case PB_SPINPHASEVAR:
		case PB_EMITVMULTVAR:
		case PB_BUBLAMPVAR:
		case PB_BUBLPERVAR:
		case PB_BUBLPHASVAR:
		case PB_SPAWNMULTVAR:
		case PB_SSSPAWNDIEAFTERVAR:			
		case PB_IPCOLLIDE_BOUNCE:			
		case PB_IPCOLLIDE_BOUNCEVAR:			
							return stdPercentDim;

		case PB_EMITSTART:
		case PB_EMITSTOP:
		case PB_DISPUNTIL:
		case PB_LIFE:
		case PB_LIFEVAR:
		case PB_GROWTIME:
		case PB_FADETIME:
		case PB_MAPPINGTIME:
		case PB_SPINTIME:
		case PB_BUBLPER:
		case PB_OFFSETAMOUNT:
		case PB_SSSPAWNDIEAFTER:
								return stdTimeDim;
		
		default: return defaultDim;
		}
	}

TSTR SuprSprayParticle::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_OFFAXIS:			return GetString(IDS_AP_OFFAXIS);
		case PB_AXISSPREAD:			return GetString(IDS_AP_AXISSPREAD);
		case PB_OFFPLANE:			return GetString(IDS_AP_OFFPLANE);
		case PB_PLANESPREAD:		return GetString(IDS_AP_PLANESPREAD);
		case PB_SPEED:				return GetString(IDS_RB_SPEED);
		case PB_SPEEDVAR:			return GetString(IDS_RB_SPEEDVAR);
		case PB_PBIRTHRATE:			return GetString(IDS_RB_PBIRTHRATE);
		case PB_PTOTALNUMBER:		return GetString(IDS_RB_PTOTALNUMBER);
		case PB_DISPLAYPORTION:		return GetString(IDS_RB_DISPLAYPORTION);
		case PB_EMITSTART:			return GetString(IDS_RB_EMITSTART);
		case PB_EMITSTOP:			return GetString(IDS_RB_EMITSTOP);
		case PB_DISPUNTIL:			return GetString(IDS_RB_DISPUNTIL);
		case PB_LIFE:				return GetString(IDS_RB_LIFE);
		case PB_LIFEVAR:			return GetString(IDS_RB_LIFEVAR);
		case PB_SIZE:				return GetString(IDS_RB_SIZE);
		case PB_SIZEVAR:			return GetString(IDS_RB_SIZEVAR);
		case PB_GROWTIME:			return GetString(IDS_RB_GROWTIME);
		case PB_FADETIME:			return GetString(IDS_RB_FADETIME);
		case PB_RNDSEED:			return GetString(IDS_RB_RNDSEED);
		case PB_METATENSION:		return GetString(IDS_RB_METATENSION);
		case PB_METATENSIONVAR:		return GetString(IDS_RB_METATENSIONVAR);
		case PB_METACOURSE:			return GetString(IDS_RB_METACOURSE);
		case PB_MAPPINGTIME:		return GetString(IDS_RB_MAPPINGTIME);
		case PB_MAPPINGDIST:		return GetString(IDS_RB_MAPPINGDIST);
		case PB_SPINTIME:			return GetString(IDS_RB_SPINTIME);
		case PB_SPINTIMEVAR:		return GetString(IDS_RB_SPINTIMEVAR);
		case PB_SPINPHASE:			return GetString(IDS_RB_SPINPHASE);
		case PB_SPINPHASEVAR:		return GetString(IDS_RB_SPINPHASEVAR);
		case PB_SPINAXISX:			return GetString(IDS_RB_SPINAXISX);
		case PB_SPINAXISY:			return GetString(IDS_RB_SPINAXISY);
		case PB_SPINAXISZ:			return GetString(IDS_RB_SPINAXISZ);
		case PB_SPINAXISVAR:		return GetString(IDS_RB_SPINAXISVAR);
		case PB_EMITVINFL:			return GetString(IDS_RB_EMITVINFL);
		case PB_EMITVMULT:			return GetString(IDS_RB_EMITVMULT);
		case PB_EMITVMULTVAR:		return GetString(IDS_RB_EMITVMULTVAR);
		case PB_BUBLAMP:			return GetString(IDS_RB_BUBLAMP);
		case PB_BUBLAMPVAR:			return GetString(IDS_RB_BUBLAMPVAR);
		case PB_BUBLPER:			return GetString(IDS_RB_BUBLPER);
		case PB_BUBLPERVAR:			return GetString(IDS_RB_BUBLPERVAR);
		case PB_BUBLPHAS:			return GetString(IDS_RB_BUBLPHAS);
		case PB_BUBLPHASVAR:		return GetString(IDS_RB_BUBLPHASVAR);
		case PB_EMITRWID:			return GetString(IDS_RB_EMITRWID);
		case PB_STRETCH:			return GetString(IDS_AP_STRETCH);
		case PB_OFFSETAMOUNT:		return GetString(IDS_AP_OFFSETAMT);
		case PB_SPAWNDIRCHAOS:		return GetString(IDS_AP_SPAWNDIRCHAOS);
		case PB_SPAWNSPEEDCHAOS:		return GetString(IDS_AP_SPAWNSPEEDCHAOS);
		case PB_SPAWNSCALECHAOS:		return GetString(IDS_AP_SPAWNSCALECHAOS);
		case PB_SPAWNMULTVAR:			return GetString(IDS_EP_SPAWNMULTVAR);
		case PB_SPAWNPERCENT:			return GetString(IDS_EP_SPAWNAFFECTS);
		case PB_SSSPAWNDIEAFTER:		return GetString(IDS_AP_SPAWNDIEAFTER);
		case PB_SSSPAWNDIEAFTERVAR:		return GetString(IDS_AP_SPAWNDIEAFTERVAR);
		case PB_IPCOLLIDE_ON:			return GetString(IDS_AP_IPCOLLIDE_ON);
		case PB_IPCOLLIDE_STEPS:		return GetString(IDS_AP_IPCOLLIDE_STEPS);
		case PB_IPCOLLIDE_BOUNCE:		return GetString(IDS_AP_IPCOLLIDE_BOUNCE);
		case PB_IPCOLLIDE_BOUNCEVAR:	return GetString(IDS_AP_IPCOLLIDE_BOUNCEVAR);
		default: 						return TSTR(_T(""));
		}
	}	


void CommonParticle::GetWorldBoundBox(
		TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
	{
	cnode=inode;
	int type,ptype,disptype;
	pblock->GetValue(PB_VIEWPORTSHOWS,0,type,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,disptype,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	if ((type>2)&&((ptype==RENDTYPE5)||(ptype==RENDTYPE6)||((disptype>0)&&(!custnode))  )) type=1;
	if ((type==3)&&((disptype!=INSTGEOM)||(!custnode))) type=1;
	if (type==2) 
	{ Box3 pbox;
		Matrix3 mat = inode->GetObjTMBeforeWSM(t);
		UpdateMesh(t);
		box  = mesh.getBoundingBox();
		box  = box * mat;
		for (int i=0; i<parts.points.Count(); i++) {
			if (!parts.Alive(i)) {continue;	}
			Point3 pt = parts.points[i];
			float r=parts.radius[i]*SQR2,strlen=1.0f;
			int axisentered,K;
			pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
			 if ((ptype!=RENDTYPE5)&&(ptype!=RENDTYPE6))
			 {if ((ClassID()!=BLIZZARD_CLASS_ID)&&(axisentered==DIRTRAVEL))
			{ pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			  strlen=GetLen(parts.vels[i],K);
			  r*=strlen;
			 }}
			if ((disptype==INSTGEOM)&&(custnode))
			{ int tlst=times.tl.Count();if (tlst==0) tlst=1;
			  pbox += pt;
			  for (int level=0;level<tlst;level++)
			  {	Box3 cbb=cmesh[level].getBoundingBox();
			    Point3 dist=cbb.pmax-cbb.pmin;
				float pdist=Largest(dist)*r;
			  pbox += pt + Point3( pdist, 0.0f, 0.0f);
			  pbox += pt + Point3(-pdist, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, pdist, 0.0f);
			  pbox += pt + Point3( 0.0f,-pdist, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, pdist);
			  pbox += pt + Point3( 0.0f, 0.0f,-pdist);
			  }
			}
			else
			{ if (ptype==RENDTET) r*=8.0f;
			  pbox += pt;
			  pbox += pt + Point3( r, 0.0f, 0.0f);
			  pbox += pt + Point3(-r, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, r, 0.0f);
			  pbox += pt + Point3( 0.0f,-r, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, r);
			  pbox += pt + Point3( 0.0f, 0.0f,-r);
			}
		}
		if (!pbox.IsEmpty()) box += pbox;
	  }
	else if (type==3) 
	{ Box3 pbox;
		Matrix3 mat = inode->GetObjTMBeforeWSM(t);
		UpdateMesh(t);
		box  = mesh.getBoundingBox();
		box  = box * mat;
		for (int i=0; i<parts.points.Count(); i++) 
		{	if (!parts.Alive(i)) {continue;	}
			Point3 pt;
			float radius=parts.radius[i]*SQR2;
			int axisentered,K;
			pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
			 if ((ptype!=RENDTYPE5)&&(ptype!=RENDTYPE6))
			 {if ((ClassID()!=BLIZZARD_CLASS_ID)&&(axisentered==DIRTRAVEL))
			{ pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			  float strlen=GetLen(parts.vels[i],K);
			  radius*=strlen;
			 }}
			int n=0,found=0;
			TimeValue Ctime=(theSuprSprayDraw.anioff?GetCurTime(sdata[i].showframe,(theSuprSprayDraw.anioff>1?theSuprSprayDraw.t:parts.ages[i]),theSuprSprayDraw.anifr):theSuprSprayDraw.t);
			found=((n=TimeFound(times,Ctime,(sdata[i].gennum>nlist.Count()?nlist.Count():sdata[i].gennum)))>-1);
			for (int nb=0;nb<theSuprSprayDraw.bboxpt[n].numboxes;nb++)
			{ pt=theSuprSprayDraw.bboxpt[n].bpts[nb].Suboffset+parts[i];
			  float pdist=Largest(theSuprSprayDraw.bboxpt[n].bpts[nb].pts[0]-theSuprSprayDraw.bboxpt[n].bpts[nb].pts[6])*radius;
			  pbox += pt + Point3( pdist, 0.0f, 0.0f);
			  pbox += pt + Point3(-pdist, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, pdist, 0.0f);
			  pbox += pt + Point3( 0.0f,-pdist, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, pdist);
			  pbox += pt + Point3( 0.0f, 0.0f,-pdist);
			}
		  }
		if (!pbox.IsEmpty()) box += pbox;
	  }
	else {SimpleParticle::GetWorldBoundBox(t,inode,vpt,box);}
	}



int GetDrawType(CommonParticle *po, int &ptype,int &disptype)
{	int type;
	po->pblock->GetValue(PB_VIEWPORTSHOWS,0,type,FOREVER);
	po->pblock->GetValue(PB_PARTICLECLASS,0,disptype,FOREVER);
	po->pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	TimeValue aniend;

	if ((type>2)&&((ptype==RENDTYPE5)||(ptype==RENDTYPE6)||((disptype>0)&&(!po->custnode))  )) type=1;
	if ((type==3)&&((disptype!=INSTGEOM)||(!po->custnode))) type=1;
	if (type>1)
	{ aniend=GetAnimEnd();
	  int oneframe=GetTicksPerFrame();
      po->theSuprSprayDraw.anifr=aniend+oneframe;
	  if (po->ClassID()==BLIZZARD_CLASS_ID) po->theSuprSprayDraw.indir.inaxis=0;
	  else
	  { int axisentered;
		po->pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	    if (po->theSuprSprayDraw.indir.inaxis=(axisentered==DIRTRAVEL))
	    { po->pblock->GetValue(PB_STRETCH,po->theSuprSprayDraw.t,po->theSuprSprayDraw.indir.K,FOREVER);
		  po->theSuprSprayDraw.indir.oneframe=oneframe;
	    }
	  }
	}
	return type;
}

/*BOOL CommonParticleDraw::DrawParticle(GraphicsWindow *gw,ParticleSys &parts,int i)
{ HCURSOR hCur;
  BOOL chcur=FALSE;
if (disptype==METABALLS)
{ if (firstpart)
  { Point3 pt[4]; 
    int nfaces=obj->metamesh->getNumFaces();
    if (nfaces>LOTSOFACES)
	{ hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	  chcur=TRUE;
	}
    for (int j=0;j<nfaces;j++)
    { pt[0]=obj->metamesh->verts[obj->metamesh->faces[j].v[0]];
      pt[1]=obj->metamesh->verts[obj->metamesh->faces[j].v[1]];
	  pt[2]=obj->metamesh->verts[obj->metamesh->faces[j].v[2]];
      gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
	  if (GetAsyncKeyState (VK_ESCAPE)) 
	  { if (chcur) SetCursor(hCur);	return TRUE;}
    }
    firstpart=FALSE;
  }
}
else if (disptype==INSTGEOM)
{ Point3 pt[4];  
 if (obj->custnode)
  {int n=0,found=0;
    TimeValue Ctime=(anioff?GetCurTime(obj->sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
	found=((n=TimeFound(obj->times,Ctime,(obj->sdata[i].gennum>obj->nCount?obj->nCount:obj->sdata[i].gennum)))>-1);
	float radius=parts.radius[i];
	float elapsedtime=(float)parts.ages[i];
    float Angle=(FloatEQ0(obj->sdata[i].Ts)?0.0f:elapsedtime/obj->sdata[i].Ts)+obj->sdata[i].LamTs;
	if (indir.inaxis)
	  indir.vel=parts.vels[i];
	Point3 nextpt;
	if (found) 
	{ BOOL dotumble=((obj->ClassID()==BLIZZARD_CLASS_ID)&&(tumble>0.0f));
	  Matrix3 mat; if (dotumble) mat= obj->TumbleMat(i,tumble,scale);
	if (bb)
    { Point3 pt[9];
	  for (int nb=0;nb<bboxpt[n].numboxes;nb++)
	  { for (int j=0;j<8;j++)
	    {if (indir.inaxis)
	    pt[j]=RotateAboutAxis(Angle,parts.points[i],radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset),obj->sdata[i].W,indir);
	    else
		{ nextpt=(radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset))+parts[i];
		  RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		  if (dotumble) pt[j]=parts.points[i]+(nextpt-parts.points[i])*mat;
		  else pt[j]=nextpt;
		}
	  }
		gw->polyline(4,pt,NULL,NULL,TRUE,NULL);
		Point3 tmppt[5]; for (int k=0;k<4;k++) tmppt[k]=pt[4+k];
		gw->polyline(4,tmppt,NULL,NULL,TRUE,NULL);
		tmppt[0]=pt[0];tmppt[1]=pt[4];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[1];tmppt[1]=pt[5];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[2];tmppt[1]=pt[6];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[3];tmppt[1]=pt[7];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		 if (GetAsyncKeyState (VK_ESCAPE)) return TRUE;
	  }
	}
    else
    { Mesh *mp;
	  mp=&obj->cmesh[n];
	  int nfaces=mp->getNumFaces();
	  if (nfaces>LOTSOFACES)
	  {  hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
		 chcur=TRUE;
	  }
		for (int j=0;j<nfaces;j++)
		{ for (int pnum=0;pnum<3;pnum++)
		{if (indir.inaxis)
	    pt[pnum]=RotateAboutAxis(Angle,parts.points[i],radius*(mp->verts[mp->faces[j].v[pnum]]),obj->sdata[i].W,indir);
		else
		  { nextpt=(radius*(mp->verts[mp->faces[j].v[pnum]]))+parts[i];
		    RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		    if (dotumble) pt[pnum]=parts.points[i]+(nextpt-parts.points[i])*mat;
			else pt[pnum]=nextpt;
		  }}
		  gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
		  if (GetAsyncKeyState (VK_ESCAPE))  
		  { if (chcur) SetCursor(hCur);	return TRUE;}
		}
	}
	}
  }
}
else
{  Mesh *pm = new Mesh;
    Point3 pt[4],W;  
	int numF,numV;	
    GetMeshInfo(ptype,1,pm,&numF,&numV);
	if (indir.inaxis)
	    indir.vel=parts.vels[i];
    float elapsedtime=(float)parts.ages[i];
    float Angle=(FloatEQ0(obj->sdata[i].Ts)?0.0f:elapsedtime/obj->sdata[i].Ts)+obj->sdata[i].LamTs;
	W=obj->sdata[i].W;
	if (ptype==RENDTYPE1) PlotTriangle(parts.radius[i],0,0,pm,Angle,&W.x,0,&parts.points[i],indir);
	else if (ptype==RENDTYPE2) PlotCube8(parts.radius[i],0,0,pm,Angle,&W.x,0,&parts.points[i],indir);
	else if (ptype==RENDTYPE3) PlotSpecial(parts.radius[i],0,0,pm,Angle,&W.x,0,&parts.points[i],indir);
	else if (ptype==RENDTET) PlotTet(parts.radius[i],0,0,pm,Angle,W,0,&parts.points[i],indir);
	else if (ptype==REND6PT) Plot6PT(parts.radius[i],0,0,pm,Angle,&W.x,0,&parts.points[i],indir);
   int nfaces=pm->getNumFaces();
	if (nfaces>LOTSOFACES)
	{  hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	   chcur=TRUE;
	}
	if ((obj->ClassID()==BLIZZARD_CLASS_ID)&&(tumble>0.0f))
	{ Matrix3 mat = obj->TumbleMat(i,tumble,scale);
	  for (int j=0;j<numV;j++) 
		  pm->verts[j]=obj->parts.points[i]+(pm->verts[j]-obj->parts.points[i])*mat;
	}
	for (int j=0;j<nfaces;j++)
	{ pt[0]=pm->verts[pm->faces[j].v[0]];
      pt[1]=pm->verts[pm->faces[j].v[1]];
	  pt[2]=pm->verts[pm->faces[j].v[2]];
      gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
    }
    if (pm) delete pm;
	if (GetAsyncKeyState (VK_ESCAPE)) 
	{ if (chcur) SetCursor(hCur);	return TRUE;}
}
return 0;
}	*/

BOOL CommonParticleDraw::DrawParticle(
		GraphicsWindow *gw,ParticleSys &parts,int i)
{ HCURSOR hCur;
  BOOL chcur=FALSE;
  if (!((disptype==INSTGEOM)&&(bb))) return TRUE;
  Point3 pt[4];  
  if (obj->custnode)
  { int n=0,found=0;
    TimeValue Ctime=(anioff?GetCurTime(obj->sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
	found=((n=TimeFound(obj->times,Ctime,(obj->sdata[i].gennum>obj->nlist.Count()?obj->nlist.Count():obj->sdata[i].gennum)))>-1);
	float radius=parts.radius[i];
	float elapsedtime=(float)parts.ages[i];
    float Angle=obj->sdata[i].LamTs;
 	if (indir.inaxis)
	  indir.vel=parts.vels[i];
	Point3 nextpt;
	if (found) 
	{ Point3 pt[9];
	  if (bboxpt[n].numboxes*8>LOTSOFACES)
	  { hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	    chcur=TRUE;
	  }
	  for (int nb=0;nb<bboxpt[n].numboxes;nb++)
	  { for (int j=0;j<8;j++)
	    {if (indir.inaxis)
	       pt[j]=RotateAboutAxis(Angle,parts.points[i],radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset),obj->sdata[i].W,indir);
	     else
		 { nextpt=(radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset))+parts[i];
		   RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		   pt[j]=nextpt;
		 }
	    }
	    gw->polyline(4,pt,NULL,NULL,TRUE,NULL);
		Point3 tmppt[5]; for (int k=0;k<4;k++) tmppt[k]=pt[4+k];
		gw->polyline(4,tmppt,NULL,NULL,TRUE,NULL);
		tmppt[0]=pt[0];tmppt[1]=pt[4];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[1];tmppt[1]=pt[5];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[2];tmppt[1]=pt[6];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[3];tmppt[1]=pt[7];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		if (GetAsyncKeyState (VK_ESCAPE))  { return TRUE;}
	  }
	}
  }
  if (GetAsyncKeyState (VK_ESCAPE)) 
  { if (chcur) SetCursor(hCur);	return TRUE;}
return 0;
}

MarkerType CommonParticle::GetMarkerType() 
	{int ptype,disptype,type=GetDrawType(this,ptype,disptype);
	  switch (type) {
		case 0:
			parts.SetCustomDraw(NULL);
			return POINT_MRKR;			
		case 1:
			parts.SetCustomDraw(NULL);
			return PLUS_SIGN_MRKR;
		case 2:	{			
			theSuprSprayDraw.obj = this;
			theSuprSprayDraw.firstpart=TRUE;
			theSuprSprayDraw.disptype=disptype;
			theSuprSprayDraw.ptype=ptype;
			parts.SetCustomDraw(&theSuprSprayDraw);			
			theSuprSprayDraw.bb=FALSE;
			return POINT_MRKR;
			}	 
		case 3:{theSuprSprayDraw.obj = this;
			theSuprSprayDraw.firstpart=TRUE;
			theSuprSprayDraw.disptype=disptype;
			theSuprSprayDraw.ptype=ptype;
			theSuprSprayDraw.bb=TRUE;
			parts.SetCustomDraw(&theSuprSprayDraw);			
			return POINT_MRKR;
		   }
		default:
			return PLUS_SIGN_MRKR;
		}
	}


void CacheSpin(float *holddata,CSavePt *sdata,int pcount,BOOL issave)
{ for (int i=0;i<pcount;i++)
	if (issave) holddata[i]=sdata[i].LamTs;
	else sdata[i].LamTs=holddata[i];
}

//--- SuprSpray particle -----------------------------------------------

RefTargetHandle SuprSprayParticle::Clone(RemapDir& remap) 
	{
	SuprSprayParticle* newob = new SuprSprayParticle();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	newob->custname=custname;
	newob->mvalid.SetEmpty();	
	newob->tvalid = FALSE;
	newob->nlist.SetCount(nlist.Count());
	newob->llist.SetCount(llist.Count());
	for (int ix=0;ix<nlist.Count();ix++) 
	{ newob->nlist[ix]=NULL;
	  newob->ReplaceReference(ix+BASER,nlist[ix]);
	}
	for (ix=0;ix<llist.Count();ix++) newob->llist[ix]=llist[ix];
	newob->dflags=dflags;
	newob->dispmesh=NULL;
	newob->times.tl.SetCount(0);
	newob->nmtls.ZeroCount();
	newob->cancelled=FALSE;
	newob->wasmulti=FALSE;
	newob->stepSize=stepSize;
	int vshow;
	pblock->GetValue(PB_VIEWPORTSHOWS,0,vshow,FOREVER);
	if (vshow>1)
	{int subtree,anioff,custmtl;
	 pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	 pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	 TimeValue aniend=GetAnimEnd();
	 int anifr=aniend+GetTicksPerFrame();
	 TimeValue t=GetCOREInterface()->GetTime();
	 newob->GetTimes(newob->times,t,anifr,anioff);
	 if (vshow==2)
	 { pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
	   newob->GetMesh(t,subtree,custmtl);
	 }
	 else newob->GetallBB(custnode,subtree,t);
	}
	return newob;
	}

static float findmappos(float curpos)
{ float mappos;

  return(mappos=((mappos=curpos)<0?0:(mappos>1?1:mappos)));
}

Mesh *SuprSprayParticle::GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete)
{	float Mval, Uval, Vval,Wval,Angle,elapsedtime;
	int type, count,maptype,anifr;
	float width;
	Point3 Center;
	BOOL mirror=FALSE;
	TVFace defface;
	Mesh *pm = new Mesh;
	if (cancelled) 
	{ZeroMesh(pm);mesh.InvalidateGeomCache();
	needDelete = TRUE;
	return pm;}
	TimeValue mt,aniend=GetAnimEnd();
	dispt=t;
    anifr=aniend+GetTicksPerFrame();
	int nummtls=0,curmtl=0,multi=0,pc=0,custmtl=0;
	pblock->GetValue(PB_PARTICLETYPE,0,type,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,pc,FOREVER);
	if (pc==METABALLS) type=RENDMETA;
	else if (pc==INSTGEOM)
	{if (custnode==NULL) {type=0;pc=ISSTD;} else type=RENDGEOM;
	pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
	}
	float FperT=GetFrameRate()/(float)TIME_TICKSPERSEC;
	pblock->GetValue(PB_EMITRWID,t,width,FOREVER);
	pblock->GetValue(PB_MAPPINGTYPE,t,maptype,FOREVER);
	if (maptype)
	 pblock->GetValue(PB_MAPPINGDIST,t,Mval,FOREVER);
	else 
	 pblock->GetValue(PB_MAPPINGTIME,0,mt,FOREVER);
	int isrend=!TestAFlag(A_NOTREND);
	if ((!isrend)&&((type==RENDTYPE5)||(type==RENDTYPE6))) type=RENDTYPE1;
	Matrix3 wcam,cam=ident;
	Point3 v, v0,v1, otherV=Zero,camV=Zero;
	if (isrend)
	{ cam= Inverse(wcam=view.worldToView);
	otherV=cam.GetRow(2),camV = cam.GetRow(3);}
	Matrix3 tm = inode->GetObjTMAfterWSM(t);
	Matrix3 itm = Inverse(tm);
	int vertexnum=0, face=0,numV=0,numF=0,j=0,tvnum=0,ismapped=0;
	ParticleSys lastparts;
	TimeValue offtime=t%GetTicksPerFrame();
	BOOL midframe;
	midframe=offtime>0;
	float *holddata=NULL;int pcount=0;
	if (isrend)
	{if (midframe) 
	{ Update(t-offtime,inode);
	  if ((pcount=parts.Count())>0)
	  { CacheData(&parts,&lastparts);
	    holddata=new float[pcount];
        CacheSpin(holddata,sdata,pcount,TRUE);
	  }
	}
	Update(t,inode);
	}
	count = CountLive();
	Center = Zero* tm;
	float Thetah;
	Point3 r1;
	if (count==0)
	{ ZeroMesh(pm);	goto quit;}
	else
	{mirror=DotProd(tm.GetRow(0)^tm.GetRow(1),tm.GetRow(2))<0.0f;
	if (type==RENDTYPE6)
	{ if (view.projType) type=RENDTYPE5;
	  else
	  { Thetah=view.fov;
	    r1=cam.GetRow(1);
	  }
	}
/*	{ if (cview==NULL) type=RENDTYPE5;
	   else
	  { Thetah=(cview!=NULL?((CameraObject *)cview->GetObjectRef())->GetFOV(t):0);
	    r1=cam.GetRow(1);
	  }
	}*/
	int gtvnum=0,anioff=0;
	if (pc<METABALLS) GetMeshInfo(type,count,pm,&numF,&numV);
	else if (type==RENDGEOM)
	{ int subtree,onscreen;
	  pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	  pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
//	  if (onscreen!=2) { 
	  theSuprSprayDraw.t=t;
	  GetTimes(times,t,anifr,anioff);
	  GetMesh(t,subtree,custmtl);
//	  }
	  int custmtl,frag;
      pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
      pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	  if ((custnode)&&(frag==INSTGEOM)&& custmtl) 
		GetSubs(inode,custnode,subtree,t);
	  TimeValue Ctime;
	  int mnum,tmptvs=0;
	  numV=0;numF=0;
	  BOOL alltex=TRUE;
	  for (int pcnt=0;pcnt<parts.Count();pcnt++)
	  { if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		if (!parts.Alive(pcnt)) continue;
		Ctime=(anioff?GetCurTime(sdata[pcnt].showframe,(anioff>1?t:parts.ages[pcnt]),anifr):t);
		mnum=TimeFound(times,Ctime,(sdata[pcnt].gennum>nlist.Count()?nlist.Count():sdata[pcnt].gennum));
		numV+=cmesh[mnum].getNumVerts();
		numF+=cmesh[mnum].getNumFaces();
	  }
	  pm->setNumFaces(numF);
	  pm->setNumVerts(numV);
	  int mcnt=0;
      if (!custmtl) gtvnum=count;
	  else 
	  {	mcnt=times.tl.Count();if (mcnt==0) mcnt=1;
		for (int mc=0;mc<mcnt;mc++)
		{ tmptvs=cmesh[mc].getNumTVerts();
		  if (tmptvs==0) alltex=FALSE;
		  else gtvnum+=tmptvs;
		}
        if ((!alltex)&&(gtvnum>0))
		{ defface.setTVerts(gtvnum,gtvnum,gtvnum);gtvnum++;}
	  }
	  int gtv;
//	  pm->setNumTVerts(gtv=(custmtl?gtvnum:count*numV));
	  pm->setNumTVerts(gtv=gtvnum);
	  if ((custmtl)&&(gtvnum>0))
	  { int tvs=0,mtvs=0,imtv;
		 for (int mc=0;mc<mcnt;mc++)
	     { mtvs=cmesh[mc].getNumTVerts();
		   if (mtvs>0)
		   { for (imtv=0;imtv<mtvs;imtv++)
			   pm->tVerts[tvs++]=cmesh[mc].tVerts[imtv];
		   } 
		 }
		 if (!alltex) pm->tVerts[tvs]=deftex;
	  }
	  pm->setNumTVFaces(gtv>0?numF:0);
	}
	Uval=0.5f;Wval=0.5f;
	Point3 ipt;
	int i;
	if (count>0)
	{
	if (type==RENDMETA)
	{ float res,bstr,thres=0.6f;int notdraft;
      pblock->GetValue(PB_METATENSION,t,bstr,FOREVER);
      pblock->GetValue(PB_SSNOTDRAFT,t,notdraft,FOREVER);
	  notdraft = (notdraft?0:1);
	  if (isrend)
		pblock->GetValue(PB_METACOURSE,0,res,FOREVER);
	  else pblock->GetValue(PB_METACOURSEV,0,res,FOREVER);
	  metap.CreateMetas(parts,pm,thres,res,bstr,notdraft);	
	  for (int j=0;j<pm->getNumVerts();j++)
         pm->verts[j] = itm * pm->verts[j];
 	}
	else
	{ Mtl *mtl;
	  mtl=inode->GetMtl();
	  if (mtl)
	  { Class_ID mc=Class_ID(MULTI_CLASS_ID,0);
	    Class_ID oc=mtl->ClassID();
	    if (multi=(oc==mc))
	    { nummtls=mtl->NumSubMtls();
		  if (nummtls==0) multi=0;
		}
	  }
	  wasmulti=multi;
	InDirInfo indir; indir.oneframe=GetTicksPerFrame();
	int axisentered;indir.vel=Zero;indir.K=0;
    pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	if (indir.inaxis=(axisentered==DIRTRAVEL))
	{  pblock->GetValue(PB_STRETCH,t,indir.K,FOREVER);
	}
  MtlID cm;
    for (i=0; i<parts.Count(); i++) 
	{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		if (!parts.Alive(i)) continue;
	    if (multi) 
		{ curmtl=sdata[i].themtl;
	      if (curmtl>=nummtls) 
		    curmtl=curmtl % nummtls;
	    } else curmtl=i;
	  if (indir.inaxis)
	    indir.vel=parts.vels[i];
		float x;
	    elapsedtime=(float)parts.ages[i];
		if (maptype) Vval=(x=Length(parts[i]-Center))/Mval;
		else Vval=(float)elapsedtime/mt;
        Angle=sdata[i].LamTs;
	    if (type==RENDTYPE1) PlotTriangle(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTYPE2) PlotCube8(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTYPE3) PlotSpecial(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTET) PlotTet(parts.radius[i],vertexnum,face,pm,Angle,sdata[i].W,curmtl,&parts.points[i],indir);
	    else if (type==REND6PT) Plot6PT(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
		else if (type==RENDSPHERE) PlotSphere(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
		else if (type==RENDTYPE5)
		{ 	v  = (view.projType?otherV:Normalize(camV-parts[i]));
			v0 = Normalize(v111^v) * parts.radius[i];
		    v1 = Normalize(v0^v) * parts.radius[i];
		    pm->verts[vertexnum] = (parts[i]+v0+v1);
		    pm->verts[vertexnum+1] = (parts[i]-v0+v1);
		    pm->verts[vertexnum+2] = (parts[i]-v0-v1);
		    pm->verts[vertexnum+3] = (parts[i]+v0-v1);
		    for (int l=0;l<4;l++)
		      RotateOnePoint(pm->verts[vertexnum+l],&parts.points[i].x,&v.x,Angle);
		    AddFace(vertexnum+3,vertexnum+2,vertexnum+1,face,pm,curmtl);
		    AddFace(vertexnum+1,vertexnum,vertexnum+3,face+1,pm,curmtl);
		 }
		 else if (type==RENDTYPE6)
		 { 	Point3 a,b,Rv;
			float Theta,R=Length(Rv=(parts[i]-camV)),angle=parts.radius[i]*R*Thetah/view.screenW;
			a=angle*Normalize(r1^Rv);
			b=angle*Normalize(a^Rv);
			pm->verts[vertexnum]=parts[i];
			for (int l=0;l<numV;l++)
			{ Theta=(l-1)*PIOver5;
			  pm->verts[vertexnum+l]=parts[i]+(float)cos(Theta)*a+(float)sin(Theta)*b;
			}
			for (l=0;l<numF-1;l++)
			  AddFace(vertexnum,vertexnum+1+l,vertexnum+2+l,face+l,pm,curmtl);
		    AddFace(vertexnum,vertexnum+1+l,vertexnum+1,face+l,pm,curmtl);
		 }
		 else if (type==RENDGEOM)
		 { TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		   int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nlist.Count()?nlist.Count():sdata[i].gennum));
		   if (mnum<0) continue;
		   numF=cmesh[mnum].getNumFaces();
		   numV=cmesh[mnum].getNumVerts();
			if ((gtvnum>0)&&(custmtl))
			{ for (j=0;j<numF;j++)
			   if (cmesh[mnum].getNumTVerts()>0)
				  pm->tvFace[j+face].setTVerts(cmesh[mnum].tvFace[j].t[0],cmesh[mnum].tvFace[j].t[1],cmesh[mnum].tvFace[j].t[2]);
			   else pm->tvFace[j+face]=defface;
			}
			int jf=face;
		  for (j=0;j<numF;j++)
		  { Face cface=cmesh[mnum].faces[j];
		    pm->faces[jf].flags=cface.flags;
		    pm->faces[jf].setSmGroup(cface.smGroup);
		    pm->faces[jf].setVerts(vertexnum+cface.v[0],vertexnum+cface.v[1],vertexnum+cface.v[2]);
		    if (!custmtl)
		      pm->faces[jf].setMatID((MtlID)curmtl); 
		    else
			{cm=cmesh[mnum].faces[j].getMatID();
			 int mtlgen=times.tl[mnum].gennum-1,maxmtl=nmtls.Count();
			 if (mtlgen>=maxmtl) mtlgen=maxmtl-1;
			 if ((mtlgen>-1)&&((times.tl.Count()>0)&&(times.tl[mnum].gennum>0)))
				cm+=nmtls[mtlgen];
			 pm->faces[jf].setMatID(cm);
			}
			pm->faces[jf].setEdgeVisFlags(cface.getEdgeVis(0),cface.getEdgeVis(1),cface.getEdgeVis(2));
			jf++;
		  }
		  PlotCustom(parts.radius[i],i,vertexnum,pm,Angle,&sdata[i].W.x,&cmesh[mnum],&parts.points[i],numV,indir);
		 }
	  // Convert to object coords
        for (j=0;j<numV;j++)
        { pm->verts[vertexnum] = itm * pm->verts[vertexnum];
          vertexnum++;
        }
		if ((type!=RENDTET)&&(!custmtl))
		{ pm->tVerts[tvnum]=Point3(findmappos(Uval),findmappos(Vval),findmappos(Wval));
	      for (j=0;j<numF;j++)
          { pm->tvFace[face++].setTVerts(tvnum,tvnum,tvnum); }	
	      tvnum++;
		} else face+=numF;
	  }
	}
}
}
  if (mirror) SwitchVerts(pm);
quit:mesh.InvalidateGeomCache();
  if ((isrend)&&(midframe) )
  { if (pcount>0)
	{CacheData(&lastparts,&parts);
    CacheSpin(holddata,sdata,pcount,FALSE);
	delete[] holddata;}
    tvalid=t-offtime;
  }
	needDelete = TRUE;
	return pm;
}

const TCHAR *SuprSprayClassDesc::ClassName ()	{return GetString(IDS_AP_SUPRSPRAY);}
const TCHAR *SuprSprayClassDesc::Category ()	{return GetString(IDS_RB_PARTICLESYSTEMS);}
TCHAR *SuprSprayParticle::GetObjectName() {return GetString(IDS_AP_SUPRSPRAYGC);}

class BEmitterCreateCallback : public CreateMouseCallBack {
	public:
		BlizzardParticle *blizzard;
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int BEmitterCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point)  {
			case 0:
				// if hidden by category, re-display particles and objects
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				sp0 = m;
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				blizzard->pblock->SetValue(PB_EMITRWID,0,0.01f);
				blizzard->pblock->SetValue(PB_EMITRLENGTH,0,0.01f);
				blizzard->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,snapdim);
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				blizzard->pblock->SetValue(PB_EMITRWID,0,
					(float)fabs(p1.x-p0.x));
				blizzard->pblock->SetValue(PB_EMITRLENGTH,0,
					(float)fabs(p1.y-p0.y));
				blizzard->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3 || Length(p1-p0)<0.1f) {						
						return CREATE_ABORT;
					} else { CheckPickButtons(blizzard->pblock,blizzard->hptype,blizzard->spawn,blizzard->pickCB.repi);
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}
	return 1;
	}

static BEmitterCreateCallback BemitterCallback;

CreateMouseCallBack* BlizzardParticle::GetCreateMouseCallBack() 
	{
	BemitterCallback.blizzard = this;
	return &BemitterCallback;
	}
BlizzardParticle::BlizzardParticle()
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
     int tpf=GetTicksPerFrame();

	MakeRefByID(FOREVER, PBLK, CreateParameterBlock(BdescVer6, PBLOCK_LENGTH_BLIZZARD, CURRENT_VERSION));
	pblock->SetValue(PB_SPEED,0,10.0f);
	pblock->SetValue(PB_SPEEDVAR,0,0.0f);
	pblock->SetValue(PB_PBIRTHRATE,0,10);
	pblock->SetValue(PB_PTOTALNUMBER,0,100);
	pblock->SetValue(PB_BIRTHMETHOD,0,0);
	pblock->SetValue(PB_DISPLAYPORTION,0,0.1f);
	pblock->SetValue(PB_EMITSTART,0,TimeValue(0));
	pblock->SetValue(PB_EMITSTOP,0,(TimeValue)30*FToTick);// correct constant?
	pblock->SetValue(PB_DISPUNTIL,0,100*FToTick);// correct constant?
	pblock->SetValue(PB_LIFE,0,30*FToTick);// correct constant?
	pblock->SetValue(PB_LIFEVAR,0,0.0f);
	pblock->SetValue(PB_SUBFRAMEMOVE,0,1);
	pblock->SetValue(PB_SUBFRAMETIME,0,1);
	pblock->SetValue(PB_SUBFRAMEROT2,0,0);
	pblock->SetValue(PB_SIZE,0,1.0f);
	pblock->SetValue(PB_SIZEVAR,0,0.0f);
	pblock->SetValue(PB_GROWTIME,0,10*FToTick);
	pblock->SetValue(PB_FADETIME,0,10*FToTick);
	pblock->SetValue(PB_RNDSEED,0,12345);

	pblock->SetValue(PB_PARTICLETYPE,0,0);
	pblock->SetValue(PB_METATENSION,0,1.0f);
	pblock->SetValue(PB_METATENSIONVAR,0,0.0f);
	pblock->SetValue(PB_METAAUTOCOARSE,0,1);
	pblock->SetValue(PB_METACOURSE,0,0.5f);
	pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
	pblock->SetValue(PB_MAPPINGTYPE,0,0);
	pblock->SetValue(PB_MAPPINGTIME,0,30*FToTick);
	pblock->SetValue(PB_MAPPINGDIST,0,100.0f);

	pblock->SetValue(PB_SPINTIME,0,30*FToTick);
	pblock->SetValue(PB_SPINTIMEVAR,0,0.0f);
	pblock->SetValue(PB_SPINPHASE,0,0.0f);
	pblock->SetValue(PB_SPINPHASEVAR,0,0.0f);
	pblock->SetValue(PB_SPINAXISTYPE,0,0);
	pblock->SetValue(PB_SPINAXISX,0,1.0f);
	pblock->SetValue(PB_SPINAXISY,0,0.0f);
	pblock->SetValue(PB_SPINAXISZ,0,0.0f);
	pblock->SetValue(PB_SPINAXISVAR,0,0.0f);

	pblock->SetValue(PB_EMITVINFL,0,100.0f);
	pblock->SetValue(PB_EMITVMULT,0,1.0f);
	pblock->SetValue(PB_EMITVMULTVAR,0,0.0f);

	pblock->SetValue(PB_EMITRWID,0,0.0f);
	pblock->SetValue(PB_EMITRLENGTH,0,0.0f);

	pblock->SetValue(PB_EMITRHID,0,0);
	pblock->SetValue(PB_SPAWNGENS,0,1);
	pblock->SetValue(PB_SPAWNCOUNT,0,1);
	pblock->SetValue(PB_METACOURSEVB,0,1.0f);
	pblock->SetValue(PB_SPAWNPERCENT2,0,100);
	pblock->SetValue(PB_SPAWNMULTVAR2,0,0);

	pblock->SetValue(PB_BLNOTDRAFT,0,0);
	pblock->SetValue(PB_BLSPAWNDIEAFTER,0,0);

	pblock->SetValue(PB_BLIPCOLLIDE_ON,0,0);
	pblock->SetValue(PB_BLIPCOLLIDE_STEPS,0,2);
	pblock->SetValue(PB_BLIPCOLLIDE_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BLIPCOLLIDE_BOUNCEVAR,0,0.0f);
	
	sdata=NULL;
	cnode=NULL;
	custnode=NULL;
	custname=TSTR(_T(" "));
	ResetSystem(0,FALSE);
	int plength=PBLOCK_LENGTH_BLIZZARD;
	size=0;
	for (int i=0;i<plength;i++)
	  size+=(BdescVer6[i].type==TYPE_INT?isize:fsize); 
//	size=40*isize+fsize*32;
	cmesh=NULL;
	dispmesh=NULL;
	dispt=-99999;
	theSuprSprayDraw.bboxpt=NULL;
	nmtls.ZeroCount();
	parts.points.ZeroCount();
	nlist.ZeroCount();
	llist.ZeroCount();
	maincount=0;
	deftime=0;
	cancelled=FALSE;
	dflags=APRTS_ROLLUP_FLAGS;
	backpatch=TRUE;
	origmtl=NULL;
	ClearAFlag(A_NOTREND);
    stepSize=GetTicksPerFrame();
}

BlizzardParticle::~BlizzardParticle()
{
	if (sdata) {delete[] sdata;sdata=NULL;}
	DeleteAllRefsFromMe();
	pblock=NULL;
	parts.FreeAll();
	times.tl.SetCount(0);
	times.tl.Shrink();
	nmtls.ZeroCount();nmtls.Shrink();
	llist.ZeroCount();llist.Shrink();
	nlist.ZeroCount();nlist.Shrink();
	if (cmesh) delete[] cmesh;
	if (theSuprSprayDraw.bboxpt) delete[] theSuprSprayDraw.bboxpt;
	if (dispmesh) delete dispmesh;
}

void BlizzardParticle::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{ 	SimpleParticle::BeginEditParams(ip,flags,prev);
	editOb = this;
	this->ip = ip;

	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }
	if (pmapParam && pmapPGen && pmapPType && pmapPSpin && pmapEmitV && pmapSpawn) 
	{	pmapParam->SetParamBlock(pblock);
		pmapPGen->SetParamBlock(pblock);
		pmapPType->SetParamBlock(pblock);
		pmapPSpin->SetParamBlock(pblock);
		pmapEmitV->SetParamBlock(pblock);
		pmapSpawn->SetParamBlock(pblock);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)this);
	} else 
	{ 	pmapParam = CreateCPParamMap(
			BdescParam,PARAMBLIZZARD_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_BLIZZARD),
			GetString(IDS_RB_PARAMETERS),
			dflags&APRTS_ROLLUP1_OPEN?0:APPENDROLL_CLOSED);

		pmapPGen = CreateCPParamMap(
			BdescParamPGen,BPARAMPGEN_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_GEN_BL),
			GetString(IDS_RB_PGEN),
			dflags&APRTS_ROLLUP2_OPEN?0:APPENDROLL_CLOSED);
		
		pmapPType = CreateCPParamMap(
			BdescParamPType,BPARAMPTYPE_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_PARTTYPE_BL),
			GetString(IDS_RB_PTYPE),
			dflags&APRTS_ROLLUP3_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapPSpin = CreateCPParamMap(
			descBParamPSpin,BPARAMPSPIN_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_ROT_BL),
			GetString(IDS_RB_SPIN),
			dflags&APRTS_ROLLUP4_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapEmitV = CreateCPParamMap(
			descParamEmitV,PARAMEMITV_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_EMITV),
			GetString(IDS_RB_EMITV),
			dflags&APRTS_ROLLUP5_OPEN?0:APPENDROLL_CLOSED);		

		pmapSpawn = CreateCPParamMap(
			descBPSpawning,PBSPAWNINGPARAMS_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_SPAWNINGB),
			GetString(IDS_AP_PSPAWN),
			dflags&APRTS_ROLLUP6_OPEN?0:APPENDROLL_CLOSED);		
	
		hParams2 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SUPRPRTS_SAVE),
				CustomSettingParamDlgProc, 
				GetString(IDS_RB_LOADSAVE), 
				(LPARAM)this,dflags&APRTS_ROLLUP7_OPEN?0:APPENDROLL_CLOSED);		
		ip->RegisterDlgWnd(hParams2);

		}
	spawn=pmapSpawn->GetHWnd();
	hparam=pmapParam->GetHWnd();
	hgen=pmapPGen->GetHWnd();
	hptype=pmapPType->GetHWnd();
	hrot=pmapPSpin->GetHWnd();
	if (pmapParam) pmapParam->SetUserDlgProc(new BLParticleDlgProc(this));
	if (pmapPType) pmapPType->SetUserDlgProc(new BLParticleDisableDlgProc(this));
	if (pmapPGen) pmapPGen->SetUserDlgProc(new SSParticleGenDlgProc(this));
	if (pmapSpawn) pmapSpawn->SetUserDlgProc(new ComParticleSpawnDlgProc(this));
	if (pmapPSpin) pmapPSpin->SetUserDlgProc(new BParticleSpinDlgProc(this));
}	

void BlizzardParticle::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
{   TimeValue t0,t2;
	SetFlag(dflags,APRTS_ROLLUP1_OPEN,IsRollupPanelOpen(hparam));
	SetFlag(dflags,APRTS_ROLLUP2_OPEN,IsRollupPanelOpen(hgen));
	SetFlag(dflags,APRTS_ROLLUP3_OPEN,IsRollupPanelOpen(hptype));
	SetFlag(dflags,APRTS_ROLLUP4_OPEN,IsRollupPanelOpen(hrot));
	SetFlag(dflags,APRTS_ROLLUP5_OPEN,IsRollupPanelOpen(pmapEmitV->GetHWnd()));
	SetFlag(dflags,APRTS_ROLLUP6_OPEN,IsRollupPanelOpen(spawn));
	SetFlag(dflags,APRTS_ROLLUP7_OPEN,IsRollupPanelOpen(hParams2));
	SimpleParticle::EndEditParams(ip,flags,next);

	if (flags&END_EDIT_REMOVEUI) {
		pblock->GetValue(PB_EMITSTART,0,t0,FOREVER);
		pblock->GetValue(PB_EMITSTOP,0,t2,FOREVER);
		if (t2<t0) pblock->SetValue(PB_EMITSTOP,0,t0);
		DestroyCPParamMap(pmapParam);
		DestroyCPParamMap(pmapPGen);
		DestroyCPParamMap(pmapPType);
		DestroyCPParamMap(pmapPSpin);
		DestroyCPParamMap(pmapEmitV);
		DestroyCPParamMap(pmapSpawn);

		ip->UnRegisterDlgWnd(hParams2);
		ip->DeleteRollupPage(hParams2);
		hParams2 = NULL;

		pmapParam  = NULL;
		pmapPGen = NULL;
		pmapPType = NULL;
		pmapPSpin = NULL;
		pmapEmitV = NULL;
		pmapSpawn = NULL;
	}else
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)NULL);
		ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
	}

void BlizzardParticle::BuildEmitter(TimeValue t, Mesh& amesh)
	{
	float width, height;
	mvalid = FOREVER;
	pblock->GetValue(PB_EMITRWID,t,width,mvalid);
	pblock->GetValue(PB_EMITRLENGTH,t,height,mvalid);
	width  *= 0.5f;
	height *= 0.5f;

	mesh.setNumVerts(7);
	mesh.setNumFaces(6);
	mesh.setVert(0, Point3(-width,-height, 0.0f));
	mesh.setVert(1, Point3( width,-height, 0.0f));
	mesh.setVert(2, Point3( width, height, 0.0f));
	mesh.setVert(3, Point3(-width, height, 0.0f));
	mesh.setVert(4, Point3(  0.0f,   0.0f, 0.0f));
	mesh.setVert(5, Point3(  0.0f,   0.0f, -(width+height)/2.0f));
	mesh.setVert(6, Point3(  0.0f,   0.0f, 0.0f));

	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[0].setSmGroup(0);
	mesh.faces[0].setVerts(0,1,3);

	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(0);
	mesh.faces[1].setVerts(1,2,3);

	mesh.faces[2].setEdgeVisFlags(1,1,0);
	mesh.faces[2].setSmGroup(0);
	mesh.faces[2].setVerts(4,5,6);

	mesh.faces[3].setEdgeVisFlags(1,0,1);
	mesh.faces[3].setSmGroup(0);
	mesh.faces[3].setVerts(0,3,1);

	mesh.faces[4].setEdgeVisFlags(0,1,1);
	mesh.faces[4].setSmGroup(0);
	mesh.faces[4].setVerts(1,3,2);

	mesh.faces[5].setEdgeVisFlags(1,0,0);
	mesh.faces[5].setSmGroup(0);
	mesh.faces[5].setVerts(5,4,6);

	mesh.InvalidateGeomCache();
	}

BOOL BlizzardParticle::ComputeParticleStart(TimeValue t0,int c)
	{
	int seed,anifr,anioff,tani;
	pblock->GetValue(PB_RNDSEED,t0,seed,FOREVER);
    pblock->GetValue(PB_OFFSETAMOUNT,t0,anifr,FOREVER);
    pblock->GetValue(PB_ANIMATIONOFFSET,t0,anioff,FOREVER);
	srand(seed);					
	parts.SetCount(c,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
	int pcount=parts.Count();
    if (sdata){delete[] sdata;sdata=NULL;} if (pcount) sdata=new CSavePt[pcount];
	if ((pcount<c)||(c>0 && (!sdata)))
	{   parts.FreeAll();if (sdata) delete sdata;sdata=NULL;	maincount=0;
		BOOL playing=GetCOREInterface()->IsAnimPlaying();
		if (playing) GetCOREInterface()->EndAnimPlayback();
	    TSTR name;name=(cnode ? cnode->GetName() : TSTR(GetString(IDS_AP_BLIZZARD)));
		TSTR buf; buf=TSTR(GetString(IDS_OFM_PART));
		GetCOREInterface()->Log()->LogEntry(SYSLOG_ERROR,DISPLAY_DIALOG,
			GetString(IDS_OFM_ERROR),_T("%s: \n\n%s\n"),buf,name);
	  return(0);
	}
	float tmp;
	int oneframe=GetTicksPerFrame();
	for (int i=0; i<parts.Count(); i++) {
		parts.ages[i] = -1;
		sdata[i].themtl=0;
		sdata[i].gennum=0;
  		sdata[i].L=RND0x(99);sdata[i].DL=-1;sdata[i].pvar=RND11();
		tani=RND0x(anifr/oneframe);
		sdata[i].showframe=(anioff==2?tani*oneframe:0);
		tmp=RND01();sdata[i].Fo=tmp;
		sdata[i].V.x=RND01();
		sdata[i].V.y=RND01();
		sdata[i].V.z=RND11();
		sdata[i].Ts0=RND11();
		sdata[i].Ts=0.0f;
		sdata[i].LamTs=RND11();
		tmp=RND11();sdata[i].M=tmp;
		parts.vels[i]=Point3(RND11(),RND11(),RND11());
		sdata[i].Vsz=RND11();
		sdata[i].W=Point3(RND11(),RND11(),RND11());
		tmp=RND11();sdata[i].Dis=tmp;
		parts.radius[i]=0.0f;
		parts.tension[i]=RND11();
		sdata[i].Mltvar=RND11();
		sdata[i].SpVar=RND0x(99);
		}
	tvalid = t0-1;
	valid  = TRUE;
	rseed=rand();
	return (1);
	}

void BlizzardParticle::BirthParticle(INode *node,TimeValue bt,int num,VelDir* ptvel,Matrix3 tmnxt)
{	Matrix3 tm = node->GetObjTMBeforeWSM(bt);
	Matrix3 atm = node->GetObjTMAfterWSM(bt);
//	tm.SetRow(3,atm.GetRow(3));
	Point3 vel;
	float Ie,Em,Vm,width,height;
	int RotSampleOn;
	srand(rseed);
	pblock->GetValue(PB_EMITRWID,bt,width,FOREVER);
	pblock->GetValue(PB_EMITRLENGTH,bt,height,FOREVER);
	pblock->GetValue(PB_EMITVINFL,bt,Ie,FOREVER);
	pblock->GetValue(PB_EMITVMULT,bt,Em,FOREVER);
	pblock->GetValue(PB_EMITVMULTVAR,bt,Vm,FOREVER);
	pblock->GetValue(PB_SUBFRAMEROT2,bt,RotSampleOn,FOREVER);
	int MotionOffset,EmitOffset;
	pblock->GetValue(PB_SUBFRAMEMOVE,bt,MotionOffset,FOREVER);
	pblock->GetValue(PB_SUBFRAMETIME,bt,EmitOffset,FOREVER);
	sdata[num].Ts0=(1+sdata[num].Ts0*ptvel->VSpin)/TWOPI;
	sdata[num].Ts=(float)ptvel->Spin*sdata[num].Ts0;
	parts.tension[num]=ptvel->bstr*(1+parts.tension[num]*ptvel->bstrvar);
	sdata[num].persist=(TimeValue)(ptvel->persist*(1.0f+sdata[num].pvar*ptvel->pvar));
// ok, so I'm using L for M and .z for L.  They were unused float and ints
	sdata[num].M=(sdata[num].L<Ie?Em*(1+sdata[num].M*Vm):0);  
	sdata[num].L=ptvel->Life+(int)(parts.vels[num].z*ptvel->Vl);
	sdata[num].Vsz*=ptvel->VSz;
	sdata[num].LamTs=ptvel->Phase*(1+sdata[num].LamTs*ptvel->VPhase);
	if (ptvel->axisentered==1)
	{	sdata[num].W=Normalize(ptvel->Axis);
		if (ptvel->axisvar>0.0f)
		VectorVar(&sdata[num].W,ptvel->axisvar,180.0f);
	}
	else sdata[num].W=Normalize(sdata[num].W);
	parts.ages[num] = 0;
	vel=Point3(0.0f,0.0f,-ptvel->Speed*(1+sdata[num].V.z*ptvel->VSpeed));
	Matrix3 OffRotTm;
	if (RotSampleOn) MakeInterpRotXform(tm,tmnxt,(1.0f-sdata[num].Fo),OffRotTm);
	else OffRotTm=tm;
	vel=VectorTransform(OffRotTm,vel);
	if (sdata[num].M!=0.0f)	vel+=ptvel->Ve*sdata[num].M;
	parts.points[num].x = -width/2.0f + sdata[num].V.x * width;
	parts.points[num].y = -height/2.0f + sdata[num].V.y * height;
	parts.points[num].z = 0.0f;
	parts[num]=parts[num]*tm;
	if (MotionOffset) parts[num]+=(ptvel->Ve)*(1.0f-sdata[num].Fo);
	if (EmitOffset) parts[num]+=(sdata[num].Fo)*vel;
	vel/=(float)GetTicksPerFrame();
	parts.vels[num]=vel;
	sdata[num].V=parts[num];
	rseed=rand();
}

void CommonParticle::GetTimes(TimeLst &times,TimeValue t,int anifr,int ltype)
{ int m,n,found,tmax,tnums=0,tgen;
  TimeValue tframe;
  times.tl.SetCount(0);times.tl.Shrink();
  times.tl.Resize(100);tmax=100;times.tl.SetCount(tmax);
  for (m=0;m<parts.Count();m++)
  { if (!parts.Alive(m)) continue;
    if (ltype)
	{ if (ltype==1) tframe=sdata[m].showframe+parts.ages[m];
	  else tframe=sdata[m].showframe+t;
     // if ((tframe>=anifr)&&(anifr!=0)) tframe=tframe % anifr;
	} else tframe=t;
	found=n=0;
	tgen=(sdata[m].gennum>nlist.Count()?nlist.Count():sdata[m].gennum);
	while ((n<tnums)&&(!found))
	{ found=((times.tl[n].gennum==tgen)&&(tframe==times.tl[n].tl));
	  n++;
	}
	if (!found) 
	{ if (tnums>=tmax) 
	  { times.tl.Resize(tmax+=100);times.tl.SetCount(tmax);}
	  times.tl[tnums].gennum=tgen;times.tl[tnums++].tl=tframe;
	}
  }
  times.tl.SetCount(tnums);
  times.tl.Shrink();
}

void BlizzardParticle::UpdateParticles(TimeValue t,INode *node)
	{
	TimeValue t0,dt,t2,grow,fade;
	int i, j, c, birth,counter,tpf=GetTicksPerFrame(),count=0,anioff;
	VelDir ptvel;
	int isrend=TestAFlag(A_RENDER),bmethod,onscreen,oneframe;
	cancelled=FALSE;
	// The size of steps we take to integrate will be frame size steps.
	oneframe=GetTicksPerFrame();
	if (stepSize!=oneframe) 
	{	stepSize = oneframe;
		valid = FALSE;
	}
	float FperT=GetFrameRate()/(float)TIME_TICKSPERSEC;
    pblock->GetValue(PB_ANIMATIONOFFSET,t,anioff,FOREVER);
	pblock->GetValue(PB_EMITSTART,t,t0,FOREVER);
	pblock->GetValue(PB_SIZE,t,parts.size,FOREVER);	
	pblock->GetValue(PB_BIRTHMETHOD,0,bmethod,FOREVER);
	pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	pblock->GetValue(PB_EMITSTOP,0,t2,FOREVER);
	pblock->GetValue(PB_TUMBLE,t,theSuprSprayDraw.tumble,FOREVER);
	pblock->GetValue(PB_TUMBLERATE,t,theSuprSprayDraw.scale,FOREVER);	
	int subtree,frag,custmtl=0;
    pblock->GetValue(PB_CUSTOMMTL2,0,custmtl,FOREVER);
	pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	theSuprSprayDraw.scale /= 50.0f;
	if (bmethod)
	  pblock->GetValue(PB_PTOTALNUMBER,0,c,FOREVER);
	if (t < t0) {
		// Before the start time, nothing is happening
		parts.FreeAll();
		if (sdata) {delete[] sdata;sdata=NULL;}
		ResetSystem(t);
		return;
		}
	int pkind;
	float dpercent;
	pblock->GetValue(PB_DISPLAYPORTION,0,dpercent,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,pkind,FOREVER);

	if ((!valid || t<tvalid)|| tvalid<t0) 
	{	// Set the particle system to the initial condition
	    int cincr;
		if (!bmethod)
		{ c=0;
		  for (TimeValue ti=t0;ti<=t2;ti+=oneframe)
		  { pblock->GetValue(PB_PBIRTHRATE,ti,cincr,FOREVER);
		    if (cincr<0) cincr=0;
			c+=cincr;
		  }
		}
		if (!isrend) c=(int)(dpercent*(float)c+FTOIEPS);
		if (!ComputeParticleStart(t0,c))
		{ ResetSystem(t);
		  return;
		}
		dispt=t-1;
		maincount=parts.Count();
		ResetSystem(t,FALSE);
	}
	int total;
	total=maincount;
	valid = TRUE;
	int stype,maxgens,spmultb,sper;float spawnbvar;
    pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
    pblock->GetValue(PB_SPAWNGENS,0,maxgens,FOREVER);
    pblock->GetValue(PB_SPAWNCOUNT,0,spmultb,FOREVER);
    pblock->GetValue(PB_SPINAXISTYPE,0,ptvel.axisentered,FOREVER);
	SpawnVars spawnvars;
	spawnvars.axisentered=ptvel.axisentered;
	TimeValue dis;
    pblock->GetValue(PB_DISPUNTIL,0,dis,FOREVER);

	if (t2<t0) t2=t0;
//	TimeValue fstep=oneframe;

//	t2+=fstep;
	TimeValue createover;
	createover=t2-t0+oneframe;
	counter=(isrend?rcounter:vcounter);
	float frate,grate;
	pblock->GetValue(PB_GROWTIME,0,grow,FOREVER);
    pblock->GetValue(PB_FADETIME,0,fade,FOREVER);
	frate=(fade>0.0f?(1-M)/fade:0.0f);
	grate=(grow>0.0f?(1-M)/grow:0.0f);
	float basesize,smper;
	BOOL fullframe;
	if (!isrend)
	{ int offby=t%oneframe;
	  if (offby!=0) t-=offby;
	}
    pblock->GetValue(PB_SPAWNSCALESIGN,0,spawnvars.scsign,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDSIGN,0,spawnvars.spsign,FOREVER);
    pblock->GetValue(PB_SPAWNINHERITV,0,spawnvars.invel,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDFIXED,0,spawnvars.spconst,FOREVER);
    pblock->GetValue(PB_SPAWNSCALEFIXED,0,spawnvars.scconst,FOREVER);
	BOOL first=(tvalid<t0);
	while ((tvalid < t)&&(tvalid<=dis))
	{	int born = 0;		
		if (first) tvalid=t0;
			// Compute our step size
		 if (tvalid%stepSize !=0) 
		  { dt = stepSize - abs(tvalid)%stepSize;} 
		  else { dt = stepSize;	}
		  if (tvalid + dt > t) {dt = t-tvalid;}

  		  // Increment time
		if (!first) tvalid +=dt;
		if (tvalid>dis)
		{ for (j=0; j<parts.Count(); j++)
		  { parts.ages[j] = -1;  }
		  tvalid=t;
		  continue;
		}
	    pblock->GetValue(PB_BLSPAWNDIEAFTER,tvalid,ptvel.persist,FOREVER);
	    pblock->GetValue(PB_BLSPAWNDIEAFTERVAR,tvalid,ptvel.pvar,FOREVER);
	    pblock->GetValue(PB_SPEED,tvalid,ptvel.Speed,FOREVER);
    	pblock->GetValue(PB_SPEEDVAR,tvalid,ptvel.VSpeed,FOREVER);
		pblock->GetValue(PB_SIZE,tvalid,ptvel.Size,FOREVER);
		pblock->GetValue(PB_LIFE,tvalid,ptvel.Life,FOREVER);
		pblock->GetValue(PB_LIFEVAR,tvalid,ptvel.Vl,FOREVER);
		pblock->GetValue(PB_SPINTIME,tvalid,ptvel.Spin,FOREVER);
		pblock->GetValue(PB_SPINTIMEVAR,tvalid,ptvel.VSpin,FOREVER);
		pblock->GetValue(PB_SPINPHASE,tvalid,ptvel.Phase,FOREVER);
		pblock->GetValue(PB_SPINPHASEVAR,tvalid,ptvel.VPhase,FOREVER);
		pblock->GetValue(PB_SIZEVAR,tvalid,ptvel.VSz,FOREVER);
		pblock->GetValue(PB_METATENSION,tvalid,ptvel.bstr,FOREVER);
		pblock->GetValue(PB_METATENSIONVAR,tvalid,ptvel.bstrvar,FOREVER);
		pblock->GetValue(PB_SPAWNDIRCHAOS,tvalid,spawnvars.dirchaos,FOREVER);
		pblock->GetValue(PB_SPAWNSPEEDCHAOS,tvalid,spawnvars.spchaos,FOREVER);
		spawnvars.spchaos/=100.0f;
		pblock->GetValue(PB_SPAWNPERCENT2,tvalid,sper,FOREVER);	
		pblock->GetValue(PB_SPAWNMULTVAR2,tvalid,smper,FOREVER);	
		spawnbvar=smper*(float)spmultb;
		pblock->GetValue(PB_SPAWNSCALECHAOS,tvalid,spawnvars.scchaos,FOREVER);
		pblock->GetValue(PB_SPINAXISX,tvalid,ptvel.Axis.x,FOREVER);
		pblock->GetValue(PB_SPINAXISY,tvalid,ptvel.Axis.y,FOREVER);
		pblock->GetValue(PB_SPINAXISZ,tvalid,ptvel.Axis.z,FOREVER);
		if (Length(ptvel.Axis)==0.0f) ptvel.Axis.x=0.001f;
		pblock->GetValue(PB_SPINAXISVAR,tvalid,ptvel.axisvar,FOREVER);
		spawnvars.scchaos/=100.0f;
		spawnvars.Axis=ptvel.Axis;spawnvars.axisvar=ptvel.axisvar;
		if (llist.Count()==0) deftime=ptvel.Life/oneframe;
		basesize=M*ptvel.Size;
		// Compute the number of particles that should be born 
		birth=0;
		fullframe=(tvalid%tpf==0);
		if (fullframe)
		{ if (bmethod)
		  { int tdelta;
		    if (tvalid>=t2) birth=total-counter;
		    else
		    { tdelta=int((float)total*(tvalid-t0+oneframe)/createover);
		      birth=tdelta-counter;
		    }
	      }
		  else if (tvalid<=t2)
		  { pblock->GetValue(PB_PBIRTHRATE,tvalid,total,FOREVER);
		    if (!isrend) total=(int)(dpercent*(float)total+FTOIEPS);
		    birth=total;
			if (birth+counter>maincount) birth=0;
		  }
		}
		// First increment age and kill off old particles
		for (j=0;j<parts.Count();j++)
		{  if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
			if (!parts.Alive(j)) continue;
			int spmult;
		  parts.ages[j] += dt;
		  if (parts.ages[j] >= sdata[j].L) 
		  {  spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
			 if ((stype!=ONDEATH)||(sdata[j].gennum>=maxgens)||(sdata[j].SpVar>=sper)) parts.ages[j] = -1;	
		     else if (fullframe){  spmult=(int)(sdata[j].Mltvar*(float)spawnbvar)+spmultb;
			  if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,FALSE);
			  else parts.ages[j]=-1;
			 }
		  } else if (sdata[j].DL>-1) {sdata[j].DL+=dt;if (sdata[j].DL>sdata[j].persist) parts.ages[j]=-1;}
		  if (parts.ages[j]>-1)
		  {  if (fullframe && ((stype==EMIT)&&(sdata[j].gennum==0)&&(sdata[j].SpVar<sper)))
		  {  spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
			  if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,TRUE);
		  }
//			if ((pkind==RENDTYPE5)||(pkind==RENDTYPE6))
//		     parts.radius[j]=ptvel.Size;  else 
			   if ((stype<2)||(maxgens==0))
		 	 parts.radius[j]=FigureOutSize(parts.ages[j],ptvel.Size,grow,fade,sdata[j].L,grate,frate)*(1+sdata[j].Vsz);
		   else 
		   { if (sdata[j].gennum==0)
			   parts.radius[j]=FigureOutSize(parts.ages[j],ptvel.Size,grow,0,sdata[j].L,grate,frate)*(1+sdata[j].Vsz);
		     else if (sdata[j].gennum==maxgens)
			   parts.radius[j]=FigureOutSize(parts.ages[j],sdata[j].Vsz,0,fade,sdata[j].L,grate,frate);
		   }
		  }
		}
		if (birth>0)
		{ Matrix3 tm;	
		Point3 LastCenter,NextCenter;
		TimeValue checkone=tvalid-t0;
		tm= node->GetObjTMBeforeWSM(checkone<stepSize?0:(tvalid-stepSize));
		LastCenter=Zero*tm;
		tm= node->GetObjTMBeforeWSM(tvalid+stepSize);
		NextCenter=Zero*tm;
		ptvel.Ve=(NextCenter-LastCenter)/((checkone<stepSize)?(1.0f+checkone/stepSize):2.0f);

		// Next, birth particles at the birth rate
		for (j=counter; j<maincount; j++) {
			if (born>=birth) break;
			BirthParticle(node,tvalid,j,&ptvel,tm);
//		    if ((pkind==RENDTYPE5)||(pkind==RENDTYPE6))
//			  parts.radius[j]=ptvel.Size;	else 
				parts.radius[j]=(grow>0?basesize:ptvel.Size)*(1+sdata[j].Vsz);
			sdata[j].themtl=int((tvalid-t0)*FperT);
//			sdata[j].showframe=(anioff==1?tlast:tlast+sdata[j].showframe);
			sdata[j].showframe=(anioff==1?0:sdata[j].showframe);
			born++;counter++;
			}
		}
		// Apply forces to modify velocity
		int fc=fields.Count();
		if (fc>0)
		  for (j=0; j<parts.Count(); j++) 
		  { Point3 force,tvel=Zero;
		    for (i=0; i<fc; i++) 
			{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
			if (!parts.Alive(j)) continue;
			 force = fields[i]->Force(tvalid,parts[j],parts.vels[j],j);
			 float curdt=(float)dt;
			 if ((parts.ages[j]==0)&&(sdata[j].gennum==0)) curdt=tpf*sdata[j].Fo;
			 tvel += 10.0f*force * curdt;
			}
		    parts.vels[j]+=tvel;
		}
		count=0;
		int IPC,ipcsteps;float B,Vb;
  		pblock->GetValue(PB_BLIPCOLLIDE_ON,tvalid,IPC,FOREVER);
  		pblock->GetValue(PB_BLIPCOLLIDE_STEPS,tvalid,ipcsteps,FOREVER);
  		pblock->GetValue(PB_BLIPCOLLIDE_BOUNCE,tvalid,B,FOREVER);
  		pblock->GetValue(PB_BLIPCOLLIDE_BOUNCEVAR,tvalid,Vb,FOREVER);
		if (IPC)
		{	CollideParticle cp;
			int ddt=dt/ipcsteps,remtime=0,snum=0;
			TimeValue curt=t;
			if (dt > 0)
			  while (snum < ipcsteps)
				{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) ) 
				  {	valid=FALSE;
					tvalid=t;
					cancelled=TRUE;
					parts.FreeAll();
					return;
				  }
					if (remtime==0) remtime=ddt;
					mindata md=cp.InterPartCollide(parts,cobjs,remtime,snum,B,Vb,curt,lc);
					for (j=0; j<parts.Count(); j++)
					{	if (parts.ages[j]>0) 
						{	if ((j!=md.min)&&(j!=md.min2)) 
							  parts[j]+=parts.vels[j]*(float)md.mintime;
						}
					}
				}
			// If we didn't collide, then increment.
		}
		else
		// Increment the positions
		for (j=0; j<parts.Count(); j++)
		{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
			if ((!parts.Alive(j))||(parts.ages[j]==0)) continue;
		  count++;
			// Check for collisions
			BOOL collide = FALSE;
			float meaninglesstime;
			for (int i=0; i<cobjs.Count(); i++) {
				if (cobjs[i]->CheckCollision(
						tvalid,parts[j],parts.vels[j], (float)dt, j,&meaninglesstime,TRUE)) {
					collide = TRUE;
					if (stype==1)
					{ if (sdata[j].persist==0) {parts.ages[j] = -1;count--;}else sdata[j].DL=0;}
					else if (fullframe &&((stype==COLLIDE)&&(sdata[j].gennum<maxgens)&&(sdata[j].SpVar<sper)))
					{ int spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
					  if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,FALSE);
					  else break;
					}
					else break;
					}
				}
			
			if (!collide) parts[j] += parts.vels[j] * (float)dt;
		}
		if (first) first=FALSE;
		for (j=0; j<parts.Count(); j++)
		{ if ((!parts.Alive(j))||(parts.ages[j]==0)) continue;
		  sdata[j].Ts = (float)ptvel.Spin*sdata[j].Ts0;
		  sdata[j].LamTs += (FloatEQ0(sdata[j].Ts)?0.0f:dt/sdata[j].Ts);
		}
	}
/*	if ((frag==METABALLS)&&(onscreen==2))
	{ float res,bstr,thres=0.6f;
      pblock->GetValue(PB_METATENSION,t,bstr,FOREVER);
      pblock->GetValue(PB_METACOURSE,0,res,FOREVER);
	  if (cmesh) delete[] cmesh;cmesh=new Mesh;
      metap.CreateMetas(parts,cmesh,thres,res,bstr);
	}
	else */if ((frag==INSTGEOM)&&(onscreen>1)&&(custnode))
	{ TimeValue anist=GetAnimStart(),aniend=GetAnimEnd();
      theSuprSprayDraw.anifr=aniend+stepSize;
	  theSuprSprayDraw.t=t;
	  theSuprSprayDraw.anioff=anioff;
	if (count>0)
	   GetTimes(times,t,theSuprSprayDraw.anifr,anioff);
	else times.tl.ZeroCount();
	if (onscreen==2)
	  GetMesh(t,subtree,custmtl);
	else  GetallBB(custnode,subtree,t);
	}  
	if (isrend) rcounter=counter;
	else
	{ vcounter=counter;
	}
	if (tvalid<t) tvalid=t;
	valid=TRUE;
//	assert(tvalid==t);
	}

Mesh *BlizzardParticle::GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete)
{	float Mval=1.0f, Uval, Vval,Wval,Angle,elapsedtime,tumble,scale;
	int type, count,maptype,anifr;
	float height;
	Point3 Center;
	TVFace defface;
	BOOL mirror=FALSE;
	TimeValue mt,aniend=GetAnimEnd();
	Mesh *pm = new Mesh;		
	if (cancelled) 
	{ZeroMesh(pm);mesh.InvalidateGeomCache();
	needDelete = TRUE;
	return pm;}
	dispt=t;
    anifr=aniend+GetTicksPerFrame();
	int nummtls=0,curmtl=0,multi=0,pc=0,custmtl=0;
	pblock->GetValue(PB_PARTICLETYPE,0,type,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,pc,FOREVER);
	if (pc==METABALLS) type=RENDMETA;
	else if (pc==INSTGEOM)
	{if (custnode==NULL) {type=0;pc=ISSTD;} else type=RENDGEOM;
	 pblock->GetValue(PB_CUSTOMMTL2,0,custmtl,FOREVER);
	}
	float FperT=GetFrameRate()/(float)TIME_TICKSPERSEC;
	pblock->GetValue(PB_MAPPINGTYPE,t,maptype,FOREVER);
	if (maptype==2)
	{ pblock->GetValue(PB_EMITRWID,t,Mval,FOREVER);
      pblock->GetValue(PB_EMITRLENGTH,t,height,FOREVER);
	  if (height==0.0f) height=0.01f;
	}
    else if (maptype==1)
	 pblock->GetValue(PB_MAPPINGDIST,t,Mval,FOREVER);
	else 
	 pblock->GetValue(PB_MAPPINGTIME,0,mt,FOREVER);
    if (Mval==0.0f) Mval=0.01f;
	pblock->GetValue(PB_TUMBLE,t,tumble,FOREVER);
	pblock->GetValue(PB_TUMBLERATE,t,scale,FOREVER);
	Matrix3 wcam,cam=ident;
	Point3 v, v0,v1, otherV,camV;
	int isrend=!TestAFlag(A_NOTREND);
	if ((!isrend)&&((type==RENDTYPE5)||(type==RENDTYPE6))) type=RENDTYPE1;
	if (isrend)
	{ cam= Inverse(wcam=view.worldToView);
	otherV=cam.GetRow(2),camV = cam.GetRow(3);}
	Matrix3 tm = inode->GetObjTMAfterWSM(t);
	Matrix3 itm = Inverse(tm);
	int vertexnum=0, face=0,numV=0,numF=0,j=0,tvnum=0,ismapped=0;
	ParticleSys lastparts;
	TimeValue offtime=t%GetTicksPerFrame();
	BOOL midframe;
	midframe=offtime>0;
	float *holddata=NULL;int pcount=0;
	if (isrend)
	{ if (midframe) 
	{ Update(t-offtime,inode);
	  if ((pcount=parts.Count())>0)
	  {	CacheData(&parts,&lastparts);
		holddata=new float[pcount];
		CacheSpin(holddata,sdata,pcount,TRUE);
	  }
	}
	  Update(t,inode);
	}
	count = CountLive();
	Center = Zero * tm;
	float Thetah;
	Point3 r1;
	if (count==0)
	{ ZeroMesh(pm);goto quit;}
	else
	{ mirror=DotProd(tm.GetRow(0)^tm.GetRow(1),tm.GetRow(2))<0.0f;
	if (type==RENDTYPE6)
	{ if (view.projType) type=RENDTYPE5;
	  else
	  { Thetah=view.fov;
	    r1=cam.GetRow(1);
	  }
	}
	int i,gtvnum=0,anioff=0;
	if (pc<METABALLS) GetMeshInfo(type,count,pm,&numF,&numV);
	else if (type==RENDGEOM)
	{ int subtree,onscreen;
	  pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	  pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
//	  if (onscreen!=2) {
	  theSuprSprayDraw.t=t;
	  GetTimes(times,t,anifr,anioff);
	  GetMesh(t,subtree,custmtl);
//	  }
	  if (backpatch)
	  { int custmtl,frag;
        pblock->GetValue(PB_CUSTOMMTL2,0,custmtl,FOREVER);
        pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	    if ((custnode)&&(frag==INSTGEOM)&& custmtl) 
		  GetSubs(inode,custnode,subtree,t);
	  }
	  TimeValue Ctime;
	  int mnum,tmptvs=0;
	  numV=0;numF=0;
	  BOOL alltex=TRUE;
	  for (int pcnt=0;pcnt<parts.Count();pcnt++)
	  { if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		 if (!parts.Alive(pcnt)) continue;
		Ctime=(anioff?GetCurTime(sdata[pcnt].showframe,(anioff>1?t:parts.ages[pcnt]),anifr):t);
		mnum=TimeFound(times,Ctime,(sdata[pcnt].gennum>nlist.Count()?nlist.Count():sdata[pcnt].gennum));
		numV+=cmesh[mnum].getNumVerts();
		numF+=cmesh[mnum].getNumFaces();
	  }
	  pm->setNumFaces(numF);
	  pm->setNumVerts(numV);
	  int mcnt=0;
      if (!custmtl) gtvnum=count;
	  else 
	  {	mcnt=times.tl.Count();if (mcnt==0) mcnt=1;
		for (int mc=0;mc<mcnt;mc++)
		{ tmptvs=cmesh[mc].getNumTVerts();
		  if (tmptvs==0) alltex=FALSE;
		  else gtvnum+=tmptvs;
		}
        if ((!alltex)&&(gtvnum>0))
		{ defface.setTVerts(gtvnum,gtvnum,gtvnum);gtvnum++;}
	  }
	  int gtv;
	  pm->setNumTVerts(gtv=gtvnum);
	  if ((custmtl)&&(gtvnum>0))
	  { int tvs=0,mtvs=0,imtv;
		 for (int mc=0;mc<mcnt;mc++)
	     { mtvs=cmesh[mc].getNumTVerts();
		   if (mtvs>0)
		   { for (imtv=0;imtv<mtvs;imtv++)
			   pm->tVerts[tvs++]=cmesh[mc].tVerts[imtv];
		   } 
		 }
		 if (!alltex) pm->tVerts[tvs]=deftex;
	  }
	  pm->setNumTVFaces(gtv>0?numF:0);
	}
	Uval=0.5f;Wval=0.5f;
	Point3 ipt;
	if (count>0)
	{
	if (type==RENDMETA)
	{ float res,bstr,thres=0.6f;int notdraft;
      pblock->GetValue(PB_METATENSION,t,bstr,FOREVER);
      pblock->GetValue(PB_BLNOTDRAFT,t,notdraft,FOREVER);
	  notdraft = (notdraft?0:1);
	  if (isrend) pblock->GetValue(PB_METACOURSE,0,res,FOREVER);
	  else pblock->GetValue(PB_METACOURSEVB,0,res,FOREVER);
	  metap.CreateMetas(parts,pm,thres,res,bstr,notdraft);
	  for (int j=0;j<pm->getNumVerts();j++)
         pm->verts[j] = itm * pm->verts[j];
 	}
	else
	{ Mtl *mtl;
	  mtl=inode->GetMtl();
	  if (mtl)
	  { Class_ID mc=Class_ID(MULTI_CLASS_ID,0);
	    Class_ID oc=mtl->ClassID();
	    if (multi=(oc==mc))
	    { nummtls=mtl->NumSubMtls();
		  if (nummtls==0) multi=0;
		}
	  }
	  wasmulti=multi;
	InDirInfo indir;
	indir.vel=Zero;
	indir.inaxis=0;
	indir.K = 0;
	indir.oneframe = GetTicksPerFrame();
	MtlID cm;
    for (i=0; i<parts.Count(); i++) 
	{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		if (!parts.Alive(i)) continue;
	    if (multi) 
		{ curmtl=sdata[i].themtl;
	      if (curmtl>=nummtls) 
		    curmtl=curmtl % nummtls;
	    } else curmtl=i;
		float x;
	    elapsedtime=(float)parts.ages[i];
		if (maptype==2)
		{ Uval=(parts.points[i].x-(Center.x-Mval/2.0f))/Mval;
		  Vval=(parts.points[i].y-(Center.y-height/2.0f))/height;
		}
		else if (maptype) Vval=(x=Length(parts[i]-Center))/Mval;
		else Vval=(float)elapsedtime/mt;
        Angle=sdata[i].LamTs;
	    if (type==RENDTYPE1) PlotTriangle(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTYPE2) PlotCube8(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTYPE3) PlotSpecial(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTET) PlotTet(parts.radius[i],vertexnum,face,pm,Angle,sdata[i].W,curmtl,&parts.points[i],indir);
	    else if (type==REND6PT) Plot6PT(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
		else if (type==RENDSPHERE) PlotSphere(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
		else if (type==RENDTYPE5)
	    {   v  = (view.projType?otherV:Normalize(camV-parts[i]));
			v0 = Normalize(v111^v) * parts.radius[i];
		    v1 = Normalize(v0^v) * parts.radius[i];
		    pm->verts[vertexnum] = (parts[i]+v0+v1);
		    pm->verts[vertexnum+1] = (parts[i]-v0+v1);
		    pm->verts[vertexnum+2] = (parts[i]-v0-v1);
		    pm->verts[vertexnum+3] = (parts[i]+v0-v1);
		    for (int l=0;l<4;l++)
		      RotateOnePoint(pm->verts[vertexnum+l],&parts.points[i].x,&v.x,Angle);
		    AddFace(vertexnum+3,vertexnum+2,vertexnum+1,face,pm,curmtl);
		    AddFace(vertexnum+1,vertexnum,vertexnum+3,face+1,pm,curmtl);
		 }
		 else if (type==RENDTYPE6)
		 { 	Point3 a,b,Rv;
			float Theta,R=Length(Rv=(parts[i]-camV)),angle=parts.radius[i]*R*Thetah/view.screenW;
			a=angle*Normalize(r1^Rv);
			b=angle*Normalize(a^Rv);
			pm->verts[vertexnum]=parts[i];
			for (int l=0;l<numV;l++)
			{ Theta=(l-1)*PIOver5;
			  pm->verts[vertexnum+l]=parts[i]+(float)cos(Theta)*a+(float)sin(Theta)*b;
			}
			for (l=0;l<numF-1;l++)
			  AddFace(vertexnum,vertexnum+1+l,vertexnum+2+l,face+l,pm,curmtl);
		    AddFace(vertexnum,vertexnum+1+l,vertexnum+1,face+l,pm,curmtl);
		 }
		 else if (type==RENDGEOM)
		 {TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		 int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nlist.Count()?nlist.Count():sdata[i].gennum));
		   if (mnum<0) continue;
		   numF=cmesh[mnum].getNumFaces();
		   numV=cmesh[mnum].getNumVerts();
			if ((gtvnum>0)&&(custmtl))
			{ if (cmesh[mnum].getNumTVerts()>0)
			  { for (j=0;j<numF;j++)
				  pm->tvFace[j+face].setTVerts(cmesh[mnum].tvFace[j].t[0],cmesh[mnum].tvFace[j].t[1],cmesh[mnum].tvFace[j].t[2]);
			  } else pm->tvFace[j+face]=defface;
			}
			int jf=face;
		  for (j=0;j<numF;j++)
		  { Face cface=cmesh[mnum].faces[j];
		    pm->faces[jf].flags=cface.flags;
		    pm->faces[jf].setSmGroup(cface.smGroup);
		    pm->faces[jf].setVerts(vertexnum+cface.v[0],vertexnum+cface.v[1],vertexnum+cface.v[2]);
		    if (!custmtl)
		      pm->faces[jf].setMatID((MtlID)curmtl); 
		    else
			{cm=cmesh[mnum].faces[j].getMatID();
			 int mtlgen=times.tl[mnum].gennum-1,maxmtl=nmtls.Count();
			 if (mtlgen>=maxmtl) mtlgen=maxmtl-1;
			 if ((mtlgen>-1)&&((times.tl.Count()>0)&&(times.tl[mnum].gennum>0)))
				cm+=nmtls[mtlgen];
			 pm->faces[jf].setMatID(cm);
			}
			pm->faces[jf].setEdgeVisFlags(cface.getEdgeVis(0),cface.getEdgeVis(1),cface.getEdgeVis(2));
			jf++;
		  }
		  PlotCustom(parts.radius[i],i,vertexnum,pm,Angle,&sdata[i].W.x,&cmesh[mnum],&parts.points[i],numV,indir);
		 }
		if (((type<RENDTYPE5)||(type>RENDTYPE6))&&(tumble>0.0f))
	    { Matrix3 mat = TumbleMat(i,tumble,scale);
	     for (int j=vertexnum;j<vertexnum+numV;j++) 
		  pm->verts[j]=parts.points[i]+(pm->verts[j]-parts.points[i])*mat;}

	  // Convert to object coords
        for (j=0;j<numV;j++)
        { pm->verts[vertexnum] = itm * pm->verts[vertexnum];
          vertexnum++;
        }
		if ((type!=RENDTET)&&(!custmtl))
		{ pm->tVerts[tvnum]=Point3(findmappos(Uval),findmappos(Vval),findmappos(Wval));
	      for (j=0;j<numF;j++)
          { pm->tvFace[face++].setTVerts(tvnum,tvnum,tvnum); }	
	      tvnum++;
		} else face+=numF;
	  }
	}
}
}
  if ((isrend)&&(midframe) )
  { if (pcount>0)
	{CacheData(&lastparts,&parts);
    CacheSpin(holddata,sdata,pcount,FALSE);
	delete[] holddata;}
    tvalid=t-offtime;
  }
  if (mirror) SwitchVerts(pm);
	quit:	mesh.InvalidateGeomCache();
	needDelete = TRUE;
	return pm;
}


void BlizzardParticle::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	if (pmapPGen) pmapPGen->Invalidate();
	if (pmapPType) pmapPType->Invalidate();
	if (pmapPSpin) pmapPSpin->Invalidate();
	if (pmapEmitV) pmapEmitV->Invalidate();
	if (pmapSpawn) pmapSpawn->Invalidate();
	}

RefTargetHandle BlizzardParticle::Clone(RemapDir& remap) 
	{
	BlizzardParticle* newob = new BlizzardParticle();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	newob->custname=custname;
	newob->mvalid.SetEmpty();	
	newob->tvalid = FALSE;
	newob->dflags=dflags;
	newob->nlist.SetCount(nlist.Count());
	newob->llist.SetCount(llist.Count());
	for (int ix=0;ix<nlist.Count();ix++) 
	{ newob->nlist[ix]=NULL;
	  newob->ReplaceReference(ix+BASER,nlist[ix]);
	}
	for (ix=0;ix<llist.Count();ix++)
	  newob->llist[ix]=llist[ix];
	newob->dispmesh=NULL;
	newob->times.tl.SetCount(0);
	newob->nmtls.ZeroCount();
	newob->cancelled=FALSE;
	newob->wasmulti=FALSE;
    newob->stepSize=stepSize;
	int vshow;
	pblock->GetValue(PB_VIEWPORTSHOWS,0,vshow,FOREVER);
	if (vshow>1)
	{int subtree,anioff,custmtl;
	 pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	 pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	 TimeValue aniend=GetAnimEnd();
	 int anifr=aniend+GetTicksPerFrame();
	 TimeValue t=GetCOREInterface()->GetTime();
	 newob->GetTimes(newob->times,t,anifr,anioff);
	 if (vshow==2)
	 { pblock->GetValue(PB_CUSTOMMTL2,0,custmtl,FOREVER);
	   newob->GetMesh(t,subtree,custmtl);
	 }
	 else newob->GetallBB(custnode,subtree,t);
	}
	return newob;
	}

ParamDimension *BlizzardParticle::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SPEED:
		case PB_SIZE:
		case PB_METATENSION:
		case PB_METACOURSE:
		case PB_MAPPINGDIST:
		case PB_SPINAXISX:
		case PB_SPINAXISY:
		case PB_SPINAXISZ:
		case PB_EMITVMULT:
		case PB_TUMBLE:
		case PB_TUMBLERATE:
		case PB_EMITRWID:  		
		case PB_EMITRLENGTH:  		return stdWorldDim;
		
		case PB_RNDSEED:
		case PB_PBIRTHRATE:
		case PB_PTOTALNUMBER:
			return defaultDim;

		case PB_SPINPHASE:
		case PB_SPINAXISVAR:	return stdAngleDim;

		case PB_DISPLAYPORTION:
		case PB_SIZEVAR:
		case PB_SPEEDVAR:
		case PB_METATENSIONVAR:
		case PB_SPINTIMEVAR:
		case PB_SPINPHASEVAR:
		case PB_EMITVMULTVAR:	
		case PB_SPAWNMULTVAR2:
		case PB_BLSPAWNDIEAFTERVAR:		
		case PB_BLIPCOLLIDE_BOUNCE:		
		case PB_BLIPCOLLIDE_BOUNCEVAR:		
								return stdPercentDim;

		case PB_EMITSTART:
		case PB_EMITSTOP:
		case PB_DISPUNTIL:
		case PB_LIFE:
		case PB_LIFEVAR:
		case PB_GROWTIME:
		case PB_FADETIME:
		case PB_MAPPINGTIME:
		case PB_SPINTIME:		
		case PB_BLSPAWNDIEAFTER:		
								return stdTimeDim;
		
		default: return defaultDim;
		}
	}

TSTR BlizzardParticle::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_TUMBLE:			return GetString(IDS_AP_TUMBLE);
		case PB_TUMBLERATE:		return GetString(IDS_AP_TUMBLERATE);
		case PB_EMITRLENGTH:	return GetString(IDS_AP_EMITRLENGTH);
		case PB_SPEED:			return GetString(IDS_RB_SPEED);
		case PB_SPEEDVAR:		return GetString(IDS_RB_SPEEDVAR);
		case PB_PBIRTHRATE:		return GetString(IDS_RB_PBIRTHRATE);
		case PB_PTOTALNUMBER:	return GetString(IDS_RB_PTOTALNUMBER);
		case PB_DISPLAYPORTION:	return GetString(IDS_RB_DISPLAYPORTION);
		case PB_EMITSTART:		return GetString(IDS_RB_EMITSTART);
		case PB_EMITSTOP:		return GetString(IDS_RB_EMITSTOP);
		case PB_DISPUNTIL:		return GetString(IDS_RB_DISPUNTIL);
		case PB_LIFE:			return GetString(IDS_RB_LIFE);
		case PB_LIFEVAR:		return GetString(IDS_RB_LIFEVAR);
		case PB_SIZE:			return GetString(IDS_RB_SIZE);
		case PB_SIZEVAR:		return GetString(IDS_RB_SIZEVAR);
		case PB_GROWTIME:		return GetString(IDS_RB_GROWTIME);
		case PB_FADETIME:		return GetString(IDS_RB_FADETIME);
		case PB_RNDSEED:		return GetString(IDS_RB_RNDSEED);
		case PB_METATENSION:	return GetString(IDS_RB_METATENSION);
		case PB_METATENSIONVAR:	return GetString(IDS_RB_METATENSIONVAR);
		case PB_METACOURSE:		return GetString(IDS_RB_METACOURSE);
		case PB_MAPPINGTIME:	return GetString(IDS_RB_MAPPINGTIME);
		case PB_MAPPINGDIST:	return GetString(IDS_RB_MAPPINGDIST);
		case PB_SPINTIME:		return GetString(IDS_RB_SPINTIME);
		case PB_SPINTIMEVAR:	return GetString(IDS_RB_SPINTIMEVAR);
		case PB_SPINPHASE:		return GetString(IDS_RB_SPINPHASE);
		case PB_SPINPHASEVAR:	return GetString(IDS_RB_SPINPHASEVAR);
		case PB_SPINAXISX:		return GetString(IDS_RB_SPINAXISX);
		case PB_SPINAXISY:		return GetString(IDS_RB_SPINAXISY);
		case PB_SPINAXISZ:		return GetString(IDS_RB_SPINAXISZ);
		case PB_SPINAXISVAR:	return GetString(IDS_RB_SPINAXISVAR);
		case PB_EMITVINFL:		return GetString(IDS_RB_EMITVINFL);
		case PB_EMITVMULT:		return GetString(IDS_RB_EMITVMULT);
		case PB_EMITVMULTVAR:	return GetString(IDS_RB_EMITVMULTVAR);
		case PB_BUBLAMP:		return GetString(IDS_RB_BUBLAMP);
		case PB_BUBLAMPVAR:		return GetString(IDS_RB_BUBLAMPVAR);
		case PB_BUBLPER:		return GetString(IDS_RB_BUBLPER);
		case PB_BUBLPERVAR:		return GetString(IDS_EP_SPAWNAFFECTS);
		case PB_BUBLPHAS:		return GetString(IDS_EP_SPAWNMULTVAR);
		case PB_BUBLPHASVAR:	return GetString(IDS_RB_BUBLPHASVAR);
		case PB_EMITRWID:		return GetString(IDS_RB_EMITRWID);
		case PB_OFFSETAMOUNT:	return GetString(IDS_AP_OFFSETAMT);
		case PB_SPAWNDIRCHAOS:	return GetString(IDS_AP_SPAWNDIRCHAOS);
		case PB_SPAWNSPEEDCHAOS:		return GetString(IDS_AP_SPAWNSPEEDCHAOS);
		case PB_SPAWNSCALECHAOS:		return GetString(IDS_AP_SPAWNSCALECHAOS);
		case PB_BLSPAWNDIEAFTER:		return GetString(IDS_AP_SPAWNDIEAFTER);
		case PB_BLSPAWNDIEAFTERVAR:		return GetString(IDS_AP_SPAWNDIEAFTERVAR);
		case PB_BLIPCOLLIDE_ON:			return GetString(IDS_AP_IPCOLLIDE_ON);
		case PB_BLIPCOLLIDE_STEPS:		return GetString(IDS_AP_IPCOLLIDE_STEPS);
		case PB_BLIPCOLLIDE_BOUNCE:		return GetString(IDS_AP_IPCOLLIDE_BOUNCE);
		case PB_BLIPCOLLIDE_BOUNCEVAR:	return GetString(IDS_AP_IPCOLLIDE_BOUNCEVAR);
			
		default: 				return TSTR(_T(""));
		}
	}	

BOOL CPickOperand::Filter(INode *node)
	{
	if ((node)&&(!node->IsGroupHead())) {
		ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
		if (!IsGEOM(os.obj))
		{	node = NULL;
			return FALSE;
		}
	}

	return node ? TRUE : FALSE;
}

BOOL CPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if ((node)&&(!node->IsGroupHead())) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		if (!IsGEOM(os.obj)) 
		{	node = NULL;
			return FALSE;
			}
	}

	return node ? TRUE : FALSE;
	}

void CommonParticle::ShowName()
{ TSTR name;
if (hptype)
{FormatName(name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (custnode ? custname : TSTR(GetString(IDS_AP_NONE))));
 SetWindowText(GetDlgItem(hptype, IDC_AP_INSTANCESRCNAME), name);}
}

BOOL CPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);

	INodeTab nodes;
//	if ((dodist==1)||(dodist==2)) {nodes.SetCount(1);nodes[0]=node;}
	int subtree;
	  if (node->IsGroupMember()) 
	    while (node->IsGroupMember()) node=node->GetParentNode();
	  po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  nodes.SetCount(0);
	if (dodist==1)
	 {  theHold.Begin();
		ComObjectListRestore *padd;
		theHold.Put(padd=(new ComObjectListRestore(po)));
		po->AddToList(node,po->nlist.Count(),TRUE);
		theHold.Accept(GetString(IDS_AP_OBJADD));
	  }
	else if (dodist==2)
	  { theHold.Begin();
		ComObjectListRestore *padd;
		theHold.Put(padd=(new ComObjectListRestore(po)));
	    po->AddToList(node,repi,FALSE);
		theHold.Accept(GetString(IDS_AP_OBJADD));
	  }
	else
	{
	theHold.Begin();
	theHold.Put(new CreateCPartPickNode(po,po->custname,node->GetName()));
	if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	theHold.Accept(GetString(IDS_AP_COMPICK));
	po->custname = TSTR(node->GetName());
	// Automatically check show result and do one update
	po->ShowName();	
}
	if (po->flags=(node->IsGroupHead()?1:0))
	 MakeGroupNodeList(node,&nodes,subtree,ip->GetTime());
	else MakeNodeList(node,&nodes,subtree,ip->GetTime());
	int frag,custmtl,onscreen;
	po->pblock->GetValue((po->ClassID()==BLIZZARD_CLASS_ID?PB_CUSTOMMTL2:PB_CUSTOMMTL),0,custmtl,FOREVER);
	po->pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	po->pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	if ((frag==INSTGEOM)&&(onscreen>1))
	{  if (onscreen==2)
	   po->GetMesh(ip->GetTime(),subtree,custmtl);
	  else po->GetallBB(node,subtree,ip->GetTime());}
	po->pmapParam->Invalidate();
	ip->FlashNodes(&nodes);
	nodes.Resize(0);
	po->valid=FALSE;
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	if (po->creating) {
		theCreateSSBlizMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreateSSBlizMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {	
		return TRUE;
		}
	}

void CPickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut;
	if (dodist)
	{iBut=GetICustButton(GetDlgItem(po->spawn,(dodist==2?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK)));
	  TurnButton(po->spawn,(dodist==1?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK),FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEDELETE,FALSE);
		TurnButton(po->hptype,IDC_AP_OBJECTPICK,FALSE);
	}
	else
	{ iBut=GetICustButton(GetDlgItem(po->hptype,IDC_AP_OBJECTPICK));
	  TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
	}
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
}

void CPickOperand::ExitMode(IObjParam *ip)
	{if (!po->ip) return;
	ICustButton *iBut;
	if (dodist)
	{	iBut=GetICustButton(GetDlgItem(po->spawn,(dodist==2?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK)));
		CheckInstButtons(po->pblock,po->hptype);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
	  if (dodist==2)
	   TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,TRUE);
//	  TurnButton(po->spawn,IDC_AP_OBJQUEUEDELETE,TRUE);
	}
	else
	{iBut=GetICustButton(GetDlgItem(po->hptype,IDC_AP_OBJECTPICK));
	  CheckSpawnButtons(po->pblock,po->spawn,repi);
	}
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
	}
RefTargetHandle CommonParticle::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		default: return (RefTargetHandle)nlist[i-BASER];
		}
	}

void CommonParticle::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		default: nlist[i-BASER]= (INode *)rtarg;return;
		}
	}

RefResult CommonParticle::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode) 
				{if (theHold.Holding())
					theHold.Put(new CreateCPartDelNode(this,custnode->GetName()));
 				DeleteReference(CUSTNODE);
				custnode=NULL;
				custname=TSTR(_T(" "));cancelled=FALSE;
			}
			  BOOL notfound=TRUE;
			  for (int i=0;(i<nlist.Count())&&(notfound);i++)
				if (hTarget==nlist[i]) 
				{ DeleteFromList(i,TRUE);
				   notfound=FALSE;cancelled=FALSE;
				}
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				cancelled=FALSE;
				}
			  BOOL notfound=TRUE;
			  for (int i=0;(i<nlist.Count())&&(notfound);i++)
				if (hTarget==nlist[i]) 
			      {notfound=FALSE;SetUpList();cancelled=FALSE;}
			  break;
			}
		case REFMSG_NODE_LINK:		
		case REFMSG_CHANGE:
			{int pblst=0;
			  if (pblock && (pblock==hTarget))
			  { pblst=pblock->LastNotifyParamNum();
			    if (pblst==PB_METACOURSE)
			  	  return REF_STOP;
			  }
			  MeshInvalid();
			  ParticleInvalid();
			  if (editOb==this) InvalidateUI();
			  cancelled=FALSE;
			}
			break;
/*		case REFMSG_SUBANIM_STRUCTURE_CHANGED:
			EnableWindow(GetDlgItem(hptype,IDC_SP_MAPCUSTOMEMIT),TRUE);
			if (editOb==this) InvalidateUI();
			break;*/
		default: SimpleParticle::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}
class CommonPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		CommonPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((CommonParticle*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			int mc;
			if (oldVer<6)
			{  if (((CommonParticle*)targ)->ClassID()==BLIZZARD_CLASS_ID)
				{ ((CommonParticle*)targ)->pblock->SetValue(PB_BLIPCOLLIDE_ON,0,0);
				  ((CommonParticle*)targ)->pblock->SetValue(PB_BLIPCOLLIDE_STEPS,0,2);
				  ((CommonParticle*)targ)->pblock->SetValue(PB_BLIPCOLLIDE_BOUNCE,0,1.0f);
				  ((CommonParticle*)targ)->pblock->SetValue(PB_BLIPCOLLIDE_BOUNCEVAR,0,0.0f);
				}
				else 
				{ ((CommonParticle*)targ)->pblock->SetValue(PB_IPCOLLIDE_ON,0,0);
				  ((CommonParticle*)targ)->pblock->SetValue(PB_IPCOLLIDE_STEPS,0,2);
				  ((CommonParticle*)targ)->pblock->SetValue(PB_IPCOLLIDE_BOUNCE,0,1.0f);
				  ((CommonParticle*)targ)->pblock->SetValue(PB_IPCOLLIDE_BOUNCEVAR,0,0.0f);
				}
			}
			if (oldVer<5)
			{  if (((CommonParticle*)targ)->ClassID()==BLIZZARD_CLASS_ID)
				{((CommonParticle*)targ)->pblock->SetValue(PB_BLSPAWNDIEAFTER,0,0);
				 ((CommonParticle*)targ)->pblock->SetValue(PB_BLSPAWNDIEAFTERVAR,0,0.0f);}
				else 
				{ ((CommonParticle*)targ)->pblock->SetValue(PB_SSSPAWNDIEAFTER,0,0);
				  ((CommonParticle*)targ)->pblock->SetValue(PB_SSSPAWNDIEAFTERVAR,0,0.0f);
				}
			}
			if (oldVer<4)
			{  if (((CommonParticle*)targ)->ClassID()==BLIZZARD_CLASS_ID)
 				((CommonParticle*)targ)->pblock->SetValue(PB_BLNOTDRAFT,0,0);
				else ((CommonParticle*)targ)->pblock->SetValue(PB_SSNOTDRAFT,0,0);
			}
			if (oldVer<3)
			{  if (((CommonParticle*)targ)->ClassID()==BLIZZARD_CLASS_ID)
 				((CommonParticle*)targ)->pblock->SetValue(PB_SPAWNPERCENT2,0,100);
				else ((CommonParticle*)targ)->pblock->SetValue(PB_SPAWNPERCENT,0,100);
			}
			if (oldVer<2)
			{  if (((CommonParticle*)targ)->ClassID()==BLIZZARD_CLASS_ID)
 				((CommonParticle*)targ)->pblock->SetValue(PB_SUBFRAMEROT2,0,0);
				else ((CommonParticle*)targ)->pblock->SetValue(PB_SUBFRAMEROT,0,0);
			}
			if (oldVer<1) {	
				((CommonParticle*)targ)->pblock->GetValue(PB_METACOURSE,0,mc,FOREVER);
				 if (((CommonParticle*)targ)->ClassID()==BLIZZARD_CLASS_ID)
 				((CommonParticle*)targ)->pblock->SetValue(PB_METACOURSEVB,0,mc);
				else ((CommonParticle*)targ)->pblock->SetValue(PB_METACOURSEV,0,mc);
				}
			delete this;
			}
	};

#define COM_CUSTNAME_CHUNK	0x0100
#define COM_CUSTFLAGS_CHUNK	0x0101
#define COM_SPAWNC_CHUNK	0x0102
#define COM_LCNT_CHUNK		0x0103
#define COM_LIFE_CHUNK		0x0104

IOResult CommonParticle::Save(ISave *isave)
	{ 	ULONG nb;
	isave->BeginChunk(COM_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();

	isave->BeginChunk(COM_CUSTFLAGS_CHUNK);		
	isave->Write(&flags,sizeof(flags),&nb);
	isave->EndChunk();

	int nCount=nlist.Count();
	isave->BeginChunk(COM_SPAWNC_CHUNK);		
	isave->Write(&nCount,sizeof(nCount),&nb);
	isave->EndChunk();
	
	int Lcnt=llist.Count();
	isave->BeginChunk(COM_LCNT_CHUNK);		
	isave->Write(&Lcnt,sizeof(Lcnt),&nb);
	isave->EndChunk();

	isave->BeginChunk(COM_LIFE_CHUNK);
	for (int i=0;i<llist.Count();i++)
	{ isave->Write(&llist[i],sizeof(int),&nb);
	}
	isave->EndChunk();

	return IO_OK;
	}

IOResult CommonParticle::Load(ILoad *iload)
	{
	if (ClassID()==BLIZZARD_CLASS_ID) {
		iload->RegisterPostLoadCallback(
			new CommonPostLoadCallback(
				new ParamBlockPLCB(Bversions,NUM_OLDVERSIONS,&curVersionBL,this,0)));
	} else {
		iload->RegisterPostLoadCallback(
			new CommonPostLoadCallback(
				new ParamBlockPLCB(spversions,NUM_OLDVERSIONS,&curVersionSp,this,0)));
		}
	ULONG nb;
	IOResult res = IO_OK;
	int cnmtl=0,nCount;
	
	// Default names
	custname = TSTR(_T(" "));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case COM_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			case COM_CUSTFLAGS_CHUNK:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;
			case COM_SPAWNC_CHUNK:
				{	res=iload->Read(&nCount,sizeof(nCount),&nb);
					nlist.SetCount(nCount);
					for (int i=0; i<nCount; i++) nlist[i] = NULL;
				}
				break;
			case COM_LCNT_CHUNK:
				{	int Lcnt;
					res=iload->Read(&Lcnt,sizeof(Lcnt),&nb);
					llist.SetCount(Lcnt);
					for (int i=0; i<Lcnt; i++) llist[i] = NULL;
				}
				break;
			case COM_LIFE_CHUNK:
				{	for (int i=0;i<llist.Count();i++)
					res=iload->Read(&llist[i],sizeof(int),&nb);}
				break;
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}

const TCHAR *BlizzardClassDesc::ClassName ()	{return GetString(IDS_AP_BLIZZARD);}
const TCHAR *BlizzardClassDesc::Category ()	{return GetString(IDS_RB_PARTICLESYSTEMS);}
TCHAR *BlizzardParticle::GetObjectName() {return GetString(IDS_AP_BLIZZARDGC);}
void CommonParticle::SetUpList()
{ SendMessage(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),LB_RESETCONTENT,0,0);
  for (int i=0;i<nlist.Count(); i++) 
		SendMessage(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)(nlist[i]->GetName()));
}

void CommonParticle::AddToList(INode *newnode,int i,BOOL add)
{	if (add)
	{ nlist.Insert(i,1,&newnode);
	  MakeRefByID(FOREVER,BASER+i,newnode);
	}	  
	else ReplaceReference(i+BASER,newnode);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	SetUpList();
}

void CommonParticle::DeleteFromList(int nnum,BOOL all)
{ int nCount=nlist.Count();
  INode *cnode=nlist[nnum];
  DeleteReference(nnum+BASER);
  if (theHold.Holding() && !TestAFlag(A_HELD)) 
	  theHold.Put(new ComObjectListRestore(this));
  nlist.Delete(nnum,1);
  if (all) 
  { for (int di=nnum;di<nlist.Count();di++)
     if (nlist[di]==cnode)
	 { DeleteReference(di+BASER);
	   nlist.Delete(di,1);
	 }
  }
  NotifyDependents(FOREVER,0,REFMSG_CHANGE);
  if (ip) SetUpList();
  valid=FALSE;
}

void CommonParticle::SetUpLifeList()
{ TCHAR buffer[20];
  SendMessage(GetDlgItem(spawn,IDC_AP_LIFEQUEUE),LB_RESETCONTENT,0,0);
  for (int i=0;i<llist.Count(); i++) 
  {	_itoa(llist[i], buffer, 10 );
	SendMessage(GetDlgItem(spawn,IDC_AP_LIFEQUEUE),LB_ADDSTRING,0,(LPARAM)(TCHAR*)buffer);
  }
} 

void CommonParticle::AddToLifeList(int newlife)
{	llist.Insert(llist.Count(),1,&newlife);
	SetUpLifeList();
}

void CommonParticle::DeleteFromLifeList(int nnum)
{ 	llist.Delete(nnum,1);
    if (ip) SetUpLifeList();
}
int CommonParticle::HitTest(
		TimeValue t, INode *inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt) 
{ 	BOOL doupdate=((!cancelled)&&((t!=tvalid)||!valid));
	if (doupdate) Update(t,inode);
	Point2 pt( (float)p[0].x, (float)p[0].y );
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion, type, crossing, 4, p);
	DWORD rlim  = gw->getRndLimits();
	int res;

	gw->setTransform(ident);
	int ptype,disptype,dtype=GetDrawType(this,ptype,disptype);
	if ((dtype<2)||(dtype==3))
	{  if (parts.HitTest(gw,&hitRegion,flags&HIT_ABORTONHIT,GetMarkerType()))
		{return TRUE;}
	}
	else
	{ if ((t!=dispt)||doupdate||!dispmesh)
	  {	NullView nullView;
		BOOL needdel;
		if (dispmesh) delete dispmesh;
		SetAFlag(A_NOTREND);
	    dispmesh=GetRenderMesh(t,inode,nullView,needdel);}
		ClearAFlag(A_NOTREND);
		gw->setRndLimits(rlim);
		gw->setTransform(inode->GetObjTMBeforeWSM(t));
		res = dispmesh->select(gw, &particleMtl, &hitRegion, flags & HIT_ABORTONHIT);
		if (res) return TRUE;
	}
	
	if (EmitterVisible()) {
		gw->setRndLimits((rlim|GW_PICK|GW_WIREFRAME) 
			& ~(GW_ILLUM|GW_BACKCULL|GW_FLAT|GW_SPECULAR));
		gw->setTransform(inode->GetObjTMBeforeWSM(t));
		res = mesh.select(gw, &particleMtl, &hitRegion, flags & HIT_ABORTONHIT);

		gw->setRndLimits(rlim);
	} else {
		res = 0;
		}
	return res;
	}

int CommonParticle::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
{   if (!OKtoDisplay(t)) return 0;
	if (t!=tvalid) cancelled=FALSE;
	if ((ip && origmtl) &&(origmtl!=inode->GetMtl()))
	{ EnableWindow(GetDlgItem(hptype,IDC_SP_MAPCUSTOMEMIT),TRUE);
	  origmtl=NULL;
	}
	BOOL doupdate=((!cancelled)&&((t!=tvalid)||!valid));
	if (!doupdate) doupdate=CheckMtlChange(inode->GetMtl(),wasmulti);
	if (doupdate) Update(t,inode);
	GraphicsWindow *gw = vpt->getGW();
	DWORD rlim  = gw->getRndLimits();

	// Draw emitter
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER) );	//removed BC on 4/29/99 DB
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_PARTICLE_EM));

	if (EmitterVisible()) {
		gw->setTransform(inode->GetObjTMBeforeWSM(t));	
		mesh.render(gw, &particleMtl, 
			(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, COMP_ALL);
		}
		
	  Material *mtl = gw->getMaterial();	
	  if (!inode->Selected() && !inode->IsFrozen())
		gw->setColor( LINE_COLOR, mtl->Kd[0], mtl->Kd[1], mtl->Kd[2]);
	int ptype,disptype,type=GetDrawType(this,ptype,disptype);
	if (type==3)
	{ theSuprSprayDraw.obj = this;
		theSuprSprayDraw.firstpart=TRUE;
		theSuprSprayDraw.disptype=disptype;
		theSuprSprayDraw.ptype=ptype;
		theSuprSprayDraw.bb=TRUE;
		parts.SetCustomDraw(&theSuprSprayDraw);			
	}
	if ((type<2)||(type==3)) // Draw particles
	{ if (type<2) parts.SetCustomDraw(NULL);
	  MarkerType mt=(type==0?POINT_MRKR:PLUS_SIGN_MRKR);
	  gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL| (rlim&(GW_Z_BUFFER|GW_BOX_MODE)) );
	  gw->setTransform(ident);
	  parts.Render(gw,mt);
	  gw->setRndLimits(rlim);
	}
	else
	{ parts.SetCustomDraw(&theSuprSprayDraw);			
	  NullView nullView;
	  BOOL needdel;
      gw->setRndLimits(rlim);
	  if ((t!=dispt)||doupdate)
	  {if (dispmesh) delete dispmesh;
		SetAFlag(A_NOTREND);
	  dispmesh=GetRenderMesh(t,inode,nullView,needdel);	
	  ClearAFlag(A_NOTREND);}
	  Matrix3 mat = inode->GetObjTMAfterWSM(t);
	  gw->setTransform(mat);
	  dispmesh->render(gw, inode->Mtls(),
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL,
		COMP_ALL, inode->NumMtls());
	}
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\pcloud.cpp ===
/**********************************************************************
 *<									  

	FILE: PCloud.CPP
	DESCRIPTION: Pcloud main code


	CREATED BY: Audrey Peterson	

	HISTORY: created February 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include <io.h>
#include "SuprPrts.h"
#include "iparamm.h"
#include "interpik.h"
#include "texutil.h"
#include "stdmat.h"

#define EPSILON 0.0001f
#define MAX_PATH_LENGTH 257
#define MAX_STRING_LENGTH  256
#define PARTICLE_SEED	0x8d6a65bc
#define PBLK		0
#define CUSTNODE 		1
#define DISTNODE 		2
#define MBASE	 		3

#define BASER			4

#define shownormname 6

typedef struct {
 float Ts,Ts0,LamTs,Mltvar;
 TimeValue L,showframe,DL,persist;
 Point3	V,W,RV;
 int themtl,gennum,SpVar;
 float Vsz,A,LamA,To,pvar;
} PCSavePt;
typedef struct{
} VelDir2;
typedef struct {
 float Size,VSz,VSpin,Phase,VPhase,Speed,VSpeed;
 float bstr,bstrvar,ToAmp,VToAmp;
 float ToPhase,VToPhase,VToPeriod,DirVar;
 int axisentered,direntered,sym;
 TimeValue Spin,ToPeriod,Life,Vl,persist;
float len,width,depth,axisvar,pvar;
 Point3 Ve,Dir,Axis;
} VelDir;

static Class_ID PCLOUD_CLASS_ID(0x1c0f3d2f, 0x30310af9);

class PCPickOperand;
class PCPickNorm;
class PCloudParticle;
class PCloudParticleDraw : public CustomParticleDisplay {
	public:
		BOOL firstpart;
		PCloudParticle *obj;
		int disptype,ptype,bb,anifr,anioff;
		boxlst *bboxpt;
		TimeValue t;
		InDirInfo indir;

		PCloudParticleDraw() {obj=NULL;}
		BOOL DrawParticle(GraphicsWindow *gw,ParticleSys &parts,int i);
	};

class PCloudParticle : public SimpleParticle, IParamArray {
	public:
		PCloudParticleDraw thePCloudDraw;
		PCloudParticle();
		~PCloudParticle();
		static IParamMap *pmapParam;
		static IParamMap *pmapPGen;
		static IParamMap *pmapPType;
		static IParamMap *pmapPSpin;
		static IParamMap *pmapEmitV;
		static IParamMap *pmapBubl;
		static IParamMap *pmapSpawn;
		static int createmeth;
		static HWND hbubl;
		int stepSize,size,maincount,fragflags;
		static custsettings;
		Mesh *cmesh,*dispmesh;
		Box3 *cmbb;
		TimeValue dispt;
		INode *custnode,*distnode,*cnode,*mbase;
		TSTR custname,distname,normname;
		DWORD flags;
		ULONG dflags;
		BOOL cancelled,wasmulti;
		static BOOL creating;
		static PCPickOperand pickCB;
		static PCPickNorm pickNorm;
		Mtl *origmtl;

		Point3 boxcenter;
		int CustMtls;
		Tab<int> nmtls;
		TimeLst times;
		void GetTimes(TimeLst &times,TimeValue t,int anifr,int ltype);
		void TreeDoGroup(INode *node,Matrix3 tspace,Mesh *cmesh,Box3 *cmbb,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl);
		void CheckTree(INode *node,Matrix3 tspace,Mesh *cmesh,Box3 *cmbb,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl);
		void GetMesh(TimeValue t,int subtree,int custmtl);
		void GetNextBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode);
		void DoGroupBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode);
		void GetallBB(INode *custnode,int subtree,TimeValue t);

		void SetUpList();
		void AddToList(INode *newnode,int i,BOOL add);
		void DeleteFromList(int nnum,BOOL all);
		Tab<INode*> nlist;
		Tab<int> llist;
		int deftime;
		int NumRefs() {return BASER+nlist.Count();}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		void SetUpLifeList();
		void AddToLifeList(int newlife);
		void DeleteFromLifeList(int nnum);
		void ShowName(int dist);
		static AName *NameLst;
		static HWND hexts,hParams2,hptype,hgen,hparam,hrot,spawn;
		static ICustEdit *custCtrlEdit;

		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);
		int CountLive();
		int rcounter,vcounter;
		oldipc lc;
		static IObjParam *ip;
		// Animatable methods		
		void DeleteThis() {delete this;}
		void MapKeys(TimeMap *map,DWORD flags);
		int RenderBegin(TimeValue t, ULONG flags);		
		int RenderEnd(TimeValue t);

		// From SimpleParticle
		Interval GetValidity(TimeValue t);		
		BOOL EmitterVisible();		
		MarkerType GetMarkerType();	
		PCSavePt *sdata;
		unsigned int rseed;

		// From BaseObject
		int IsInstanceDependent() {return 1;}
		void GetFilename(TCHAR *filename);
		void SetupTargetList();
		int SaveSettings(int overwrite,TCHAR *newname);
		int GetSettings(int setnum,TCHAR *newname);
		int RemSettings(int setnum,TCHAR *newname);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void AssignMtl(INode *node,INode *topnode,int subtree,TimeValue t);
		void DoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void RetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void GetSubs(INode *node,INode *topnode,int subtree,TimeValue t);
		void CntDoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void CntRetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		BOOL backpatch;
		Mtllst mttab;
		TimeValue ParticleLife(TimeValue t, int i);
		Point3 ParticlePosition(TimeValue t,int i);
		Point3 ParticleVelocity(TimeValue t,int i);		
		float ParticleSize(TimeValue t,int i);
		int ParticleCenter(TimeValue t,int i);
		void DoSpawn(int j,int spmult,SpawnVars spvars,TimeValue lvar,BOOL emits);

		CreateMouseCallBack* GetCreateMouseCallBack();

		TCHAR *GetObjectName();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		void BuildEmitter(TimeValue t, Mesh& amesh);
		void BirthParticle(INode *node,TimeValue bt,int num,VelDir *ptvel,Mesh* amesh,Point3* fnorms,Matrix3 disttm);
		BOOL ComputeParticleStart(TimeValue t0,int c);
		// From GeomObject
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);
		// Animatable methods		
		Class_ID ClassID() {return PCLOUD_CLASS_ID;} 
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From Simple Particle
		void UpdateParticles(TimeValue t,INode *node);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI();
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		int HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt);
		void MovePart(int j,TimeValue dt,BOOL fullframe,int tpf);
		void ResetSystem(TimeValue t,BOOL full=TRUE);
	};
//--- ClassDescriptor and class vars ---------------------------------

class PCloudClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new PCloudParticle;}
	const TCHAR *	ClassName(); 
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return PCLOUD_CLASS_ID;}
	const TCHAR* 	Category(); 
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	void			ResetClassParams(BOOL fileReset);
	};

static PCloudClassDesc PCloudDesc;
ClassDesc* GetPCloudDesc() {return &PCloudDesc;}

void PCloudClassDesc::ResetClassParams(BOOL fileReset)
	{
	PCloudParticle::createmeth=0;
	}

class PCPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		PCloudParticle *po;
		int dodist,repi;
		
		PCPickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};
class PCPickNorm : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		PCloudParticle *po;
		
		PCPickNorm() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};
class PCObjectListRestore : public RestoreObj {
	public:   		
		PCloudParticle *po;
		Tab<INode*> unodes;
		Tab<INode*> rnodes;
		int lnum,lnum2;
		PCObjectListRestore(PCloudParticle *p) 
		{  po=p;
		   unodes=p->nlist;
		}
		void Restore(int isUndo)
		{	if (isUndo) {
				rnodes = po->nlist;
				}
			po->nlist = unodes;
			po->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		}
		void Redo() 
		{	po->nlist = rnodes;
			po->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		}
	};

class PCLifeListRestore : public RestoreObj {
	public:   		
		PCloudParticle *po;
		Tab<int> utimes;
		Tab<int> rtimes;
		PCLifeListRestore(PCloudParticle *p) 
		{ po=p;
		  utimes=p->llist;
		}
		void Restore(int isUndo)
		{ if (isUndo) { rtimes = po->llist;	}
		  po->llist=utimes;
		  if (po->ip) po->SetUpLifeList();
		}
		void Redo() 
		{ po->llist = rtimes;
		  if (po->ip) po->SetUpLifeList();
		}
	};


class CreatePCPartDelNode : public RestoreObj {
	public:   		
		PCloudParticle *obj;
		TSTR name;
		int dist;
		CreatePCPartDelNode(PCloudParticle *o, TSTR n,int d) {
			obj = o; name=TSTR(n); dist=d;
			}
		void Restore(int isUndo)
		{if (dist==shownormname) obj->normname=name;
		else if (dist) obj->distname=name;
		else obj->custname = name;
		 obj->ShowName(dist);
			}
		void Redo() 
			{ if (dist==shownormname) obj->normname=TSTR(_T(""));
			  else if (dist) obj->distname=TSTR(_T(""));
			  else obj->custname = TSTR(_T(""));
		 TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + TSTR(GetString(IDS_AP_NONE));
		  if (dist==shownormname)
		  { if (obj->hgen) SetWindowText(GetDlgItem(obj->hgen, IDC_AP_PCLOUDOBJDIRNAME), name);}
		  if (dist)
		  { if (obj->hparam)SetWindowText(GetDlgItem(obj->hparam, IDC_AP_FILLPICKOBJECT), name);}
		  else
		  { if (obj->hptype) SetWindowText(GetDlgItem(obj->hptype, IDC_AP_INSTANCESRCNAME), name);}
		}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};
class CreatePCPartPickNode : public RestoreObj {
	public:   		
		PCloudParticle *obj;
		TSTR name,name2;int dist;
		CreatePCPartPickNode(PCloudParticle *o, TSTR n,TSTR n1,int d) {
			obj = o; name=TSTR(n);name2=TSTR(n1);dist=d;
			}
		void Restore(int isUndo) {
		   if (dist==shownormname)
		   { if (obj->normname) obj->normname=name;
		   else obj->normname=TSTR(_T(""));}
			else if (dist)
			{ if (obj->distnode) obj->distname = name;
			else  obj->distname=TSTR(_T(""));}
			else
			{ if (obj->custnode) obj->custname = name;
			else  obj->custname=TSTR(_T(""));}
			obj->ShowName(dist);
			}
		void Redo() 
		{ if (((dist)&&(obj->hptype))||((!dist)&&(obj->hparam)))
		{ TSTR name;
		  if (dist==shownormname) obj->normname=name2;
		  else if (dist) obj->distname=name2;
		  else  obj->custname = name2;
		  name=TSTR(GetString(IDS_AP_OBJECTSTR))+(_tcslen(name2)>0 ? name2 : TSTR(GetString(IDS_AP_NONE)));
		  if (dist==shownormname)
		  {if (obj->hgen) SetWindowText(GetDlgItem(obj->hgen, IDC_AP_PCLOUDOBJDIRNAME), name);}
		  else if (dist)
		  {  if (obj->hparam) SetWindowText(GetDlgItem(obj->hparam, IDC_AP_FILLPICKOBJECT), name);}
		  else
		    if (obj->hptype) SetWindowText(GetDlgItem(obj->hptype, IDC_AP_INSTANCESRCNAME), name);
		}
			}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};


//--- ClassDescriptor and class vars ---------------------------------
IParamMap *PCloudParticle::pmapParam;
IParamMap *PCloudParticle::pmapPGen;
IParamMap *PCloudParticle::pmapPType;
IParamMap *PCloudParticle::pmapPSpin;
IParamMap *PCloudParticle::pmapEmitV;
IParamMap *PCloudParticle::pmapBubl;
IParamMap *PCloudParticle::pmapSpawn;
IObjParam *PCloudParticle::ip    = NULL;
BOOL PCloudParticle::creating    = FALSE;
PCPickOperand PCloudParticle::pickCB;
PCPickNorm PCloudParticle::pickNorm;
ICustEdit *PCloudParticle::custCtrlEdit=NULL;
int PCloudParticle::custsettings=0;
AName *PCloudParticle::NameLst=NULL;
HWND PCloudParticle::hexts;
HWND PCloudParticle::hParams2;
HWND PCloudParticle::hgen;
HWND PCloudParticle::hptype;
HWND PCloudParticle::hparam;
HWND PCloudParticle::hrot;
HWND PCloudParticle::hbubl;
HWND PCloudParticle::spawn;
int PCloudParticle::createmeth=0;


#define SIZEFACTOR (float(TIME_TICKSPERSEC)/120.0f)

//--- Parameter map/block descriptors -------------------------------

#define PB_CREATEIN			0
#define PB_SPEED			1
#define PB_SPEEDVAR			2
#define PB_SPEEDDIR			3
#define PB_DIRX				4
#define PB_DIRY				5
#define PB_DIRZ				6
#define PB_DIRVAR			7

#define PB_BIRTHMETHOD		8
#define PB_PBIRTHRATE		9
#define PB_PTOTALNUMBER		10
#define PB_EMITSTART		11
#define PB_EMITSTOP			12
#define PB_DISPUNTIL		13
#define PB_LIFE				14
#define PB_LIFEVAR			15
#define PB_CUSTOMMTL		16
#define PB_SIZE				17
#define PB_SIZEVAR			18
#define PB_GROWTIME			19
#define PB_FADETIME			20
#define PB_RNDSEED			21
#define PB_EMITRWID			22
#define PB_EMITRHEIGHT		23
#define PB_EMITRDEPTH		24

#define PB_EMITRHID			25

#define PB_PARTICLECLASS	26
#define PB_PARTICLETYPE		27
#define PB_METATENSION		28
#define PB_METATENSIONVAR	29
#define PB_METACOURSE		30
#define PB_METAAUTOCOARSE	31
#define PB_USESUBTREE		32
#define PB_ANIMATIONOFFSET  33
#define PB_OFFSETAMOUNT     34
#define PB_VIEWPORTSHOWS	35
#define PB_DISPLAYPORTION	36
#define PB_MAPPINGTYPE		37
#define PB_MAPPINGTIME		38
#define PB_MAPPINGDIST		39
						
#define PB_SPINTIME			40
#define PB_SPINTIMEVAR		41
#define PB_SPINPHASE		42
#define PB_SPINPHASEVAR		43
#define PB_SPINAXISTYPE		44
#define PB_SPINAXISX		45
#define PB_SPINAXISY		46
#define PB_SPINAXISZ		47
#define PB_SPINAXISVAR		48

#define PB_EMITVINFL		49
#define PB_EMITVMULT		50
#define PB_EMITVMULTVAR		51

#define PB_BUBLAMP			52
#define PB_BUBLAMPVAR		53
#define PB_BUBLPER			54
#define PB_BUBLPERVAR		55
#define PB_BUBLPHAS			56
#define PB_BUBLPHASVAR		57

#define PB_STRETCH			58

#define PB_SPAWNTYPE		59
#define PB_SPAWNGENS		60
#define PB_SPAWNCOUNT		61
#define PB_SPAWNDIRCHAOS	62
#define PB_SPAWNSPEEDCHAOS	63
#define PB_SPAWNSPEEDSIGN	64
#define PB_SPAWNINHERITV	65
#define PB_SPAWNSCALECHAOS	66
#define PB_SPAWNSCALESIGN	67
#define PB_SPAWNLIFEVLUE	68
#define PB_SPAWNSPEEDFIXED	69
#define PB_SPAWNSCALEFIXED	70
#define PB_METACOURSEV		71
#define PB_SPAWNPERCENT		72
#define PB_SPAWNMULTVAR		73
#define PB_PCNOTDRAFT		74
#define PB_SPAWNDIEAFTER	75
#define PB_SPAWNDIEAFTERVAR	76

#define PB_PCIPCOLLIDE_ON		77
#define PB_PCIPCOLLIDE_STEPS	78
#define PB_PCIPCOLLIDE_BOUNCE	79
#define PB_PCIPCOLLIDE_BOUNCEVAR 80


// render types
#define RENDMETA    8
#define RENDGEOM	9

//
//
// Parameters

#define ISSTD 0
#define METABALLS 1
#define INSTGEOM 2

static int countIDs[] = {IDC_SP_GENUSERATE,IDC_SP_GENUSETTL};
static int createIDs[] = {IDC_AP_FILLBOX,IDC_AP_FILLSPHERE,IDC_AP_FILLCYLINDER,IDC_AP_FILLOBJECT};

static int particleclassIDs[] = {IDC_SP_TYPESTD,IDC_SP_TYPEMET,IDC_SP_TYPEINSTANCE};

static int particletypeIDs[] = {IDC_SP_TYPETRI,IDC_SP_TYPECUB,IDC_SP_TYPESPC,IDC_SP_TYPEFAC,
								IDC_SP_TYPEPIX,IDC_SP_TYPETET,IDC_SP_TYPE6PNT,IDC_SP_TYPESPHERE};

static int viewportoptionIDs[] = {IDC_SP_VIEWDISPDOT,IDC_SP_VIEWDISPTIK,IDC_SP_VIEWDISPMESH,IDC_SP_VIEWDISPBOX};

static int mappingIDs[] = {IDC_SP_MAPTIME,IDC_SP_MAPDIST};

static int spindirectionIDs[] = {IDC_AP_PARTICLEDIRRND,IDC_AP_PARTICLEDIRTRAVL,IDC_AP_PARTICLEDIRUSER};
static int particleaxisIDs[] = {IDC_AP_PCLOUDDIRRND,IDC_AP_PCLOUDDIRENTER,IDC_AP_PCLOUDDIROBJ};

#define DIRTRAVEL 1

static int animateoffsetIDs[] = {IDC_AP_NOANIOFF,IDC_AP_ANIOFFBIRTH,IDC_AP_ANIOFFRND};
static int custmtlIDs[] = {IDC_SP_MAPCUSTOMEMIT,IDC_SP_MAPCUSTOMINST};

// Dialog Unique to Particle Array
static ParamUIDesc descParamPCloud[] = {

	// Distribution Method
	ParamUIDesc(PB_CREATEIN,TYPE_RADIO,createIDs,4),

	// Emitter Width
	ParamUIDesc(
		PB_EMITRWID,
		EDITTYPE_UNIVERSE,
		IDC_AP_EMITRADWID,IDC_AP_EMITRADWIDSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Emitter Height
	ParamUIDesc(
		PB_EMITRHEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_AP_EMITHGT,IDC_AP_EMITHGTSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Emitter Depth
	ParamUIDesc(
		PB_EMITRDEPTH,
		EDITTYPE_UNIVERSE,
		IDC_AP_EMITDEP,IDC_AP_EMITDEPSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Hide Emitter
	ParamUIDesc(PB_EMITRHID,TYPE_SINGLECHEKBOX,IDC_SP_EMITHID),

	// Viewport Shows
	ParamUIDesc(PB_VIEWPORTSHOWS,TYPE_RADIO,viewportoptionIDs,4),

	// Particle Display Portion
	ParamUIDesc(
		PB_DISPLAYPORTION,
		EDITTYPE_FLOAT,
		IDC_SP_GENDISP,IDC_SP_GENDISPSPIN,
		0.0f,100.0f,
		0.1f,
		stdPercentDim),
};

#define PARAMPCLOUD_LENGTH 7

// Common Dialog for Particle Generation
static ParamUIDesc descParamPGen[] = {

	// Distribution Method
	ParamUIDesc(PB_BIRTHMETHOD,TYPE_RADIO,countIDs,2),

	// Particle Birth Rate
	ParamUIDesc(
		PB_PBIRTHRATE,
		EDITTYPE_INT,
		IDC_SP_GENRATE,IDC_SP_GENRATESPIN,
		0.0f,65000.0f,
		1.0f),

	// Particle Total Count
	ParamUIDesc(
		PB_PTOTALNUMBER,
		EDITTYPE_INT,
		IDC_SP_GENTTL,IDC_SP_GENTTLSPIN,
		0.0f,65000.0f,
		1.0f),

	// Particle Speed
	ParamUIDesc(
		PB_SPEED,
		EDITTYPE_UNIVERSE,
		IDC_SP_SPEED,IDC_SP_SPEEDSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Speed Var
	ParamUIDesc(
		PB_SPEEDVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPEEDVAR,IDC_SP_SPEEDVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Enter Axis Control
	ParamUIDesc(PB_SPEEDDIR,TYPE_RADIO,particleaxisIDs,3),

	// X-Axis
	ParamUIDesc(
		PB_DIRX,
		EDITTYPE_FLOAT,
		IDC_AP_MOVEDIRX,IDC_AP_MOVEDIRXSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Y-Axis
	ParamUIDesc(
		PB_DIRY,
		EDITTYPE_FLOAT,
		IDC_AP_MOVEDIRY,IDC_AP_MOVEDIRYSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Z-Axis
	ParamUIDesc(
		PB_DIRZ,
		EDITTYPE_FLOAT,
		IDC_AP_MOVEDIRZ,IDC_AP_MOVEDIRZSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Move Var
	ParamUIDesc(
		PB_DIRVAR,
		EDITTYPE_FLOAT,
		IDC_AP_MOVEDIRVAR,IDC_AP_MOVEDIRVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Emitter Start Time
	ParamUIDesc(
		PB_EMITSTART,
		EDITTYPE_TIME,
		IDC_SP_GENEMIT1,IDC_SP_GENEMIT1SPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Emitter Stop Time
	ParamUIDesc(
		PB_EMITSTOP,
		EDITTYPE_TIME,
		IDC_SP_GENEMIT2,IDC_SP_GENEMIT2SPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Particle Time Limit
	ParamUIDesc(
		PB_DISPUNTIL,
		EDITTYPE_TIME,
		IDC_SP_DISPUNTIL,IDC_SP_DISPUNTILSPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Particle Life
	ParamUIDesc(
		PB_LIFE,	
		EDITTYPE_TIME,
		IDC_SP_GENLIFE,IDC_SP_GENLIFESPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Life Var
	ParamUIDesc(
		PB_LIFEVAR,
		EDITTYPE_TIME,
		IDC_SP_GENLIFEVAR,IDC_SP_GENLIFEVARSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Size
	ParamUIDesc(
		PB_SIZE,
		EDITTYPE_UNIVERSE,
		IDC_SP_GENSIZE,IDC_SP_GENSIZESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Size Var
	ParamUIDesc(
		PB_SIZEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_GENSIZEVAR,IDC_SP_GENSIZEVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Particle Grow Time
	ParamUIDesc(
		PB_GROWTIME,
		EDITTYPE_TIME,
		IDC_SP_GENGRO,IDC_SP_GENGROSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Fade Time
	ParamUIDesc(
		PB_FADETIME,
		EDITTYPE_TIME,
		IDC_SP_GENFAD,IDC_SP_GENFADSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Random Number Seed
	ParamUIDesc(
		PB_RNDSEED,
		EDITTYPE_INT,
		IDC_SP_GENSEED,IDC_SP_GENSEEDSPIN,
		0.0f,25000.0f,
		1.0f),
	};

#define PARAMPGEN_LENGTH 20

// Particle Type for PCloud
static ParamUIDesc descParamPType[] = {

	// Particle Class
	ParamUIDesc(PB_PARTICLECLASS,TYPE_RADIO,particleclassIDs,3),

	// Particle Type
	ParamUIDesc(PB_PARTICLETYPE,TYPE_RADIO,particletypeIDs,8),

	// Metaball Tension
	ParamUIDesc(
		PB_METATENSION,
		EDITTYPE_FLOAT,
		IDC_SP_METTENS,IDC_SP_METTENSSPIN,
		0.1f,10.0f,
		SPIN_AUTOSCALE),

	// Metaball Tension Variation
	ParamUIDesc(
		PB_METATENSIONVAR,
		EDITTYPE_FLOAT,
		IDC_SP_METTENSVAR,IDC_SP_METTENSVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Metaball Courseness
	ParamUIDesc(
		PB_METACOURSE,
		EDITTYPE_UNIVERSE,
		IDC_SP_METCOURSE,IDC_SP_METCOURSESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Metaball Courseness ViewPort
	ParamUIDesc(
		PB_METACOURSEV,
		EDITTYPE_UNIVERSE,
		IDC_SP_METCOURSEV,IDC_SP_METCOURSEVSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Metaball Auto Coarseness
	ParamUIDesc(PB_METAAUTOCOARSE,TYPE_SINGLECHEKBOX,IDC_SP_AUTOCOARSE),

	// Display type
	ParamUIDesc(PB_PCNOTDRAFT,TYPE_SINGLECHEKBOX,IDC_SP_DRAFTMODE),

	// Use Subtree Checkbox
	ParamUIDesc(PB_USESUBTREE,TYPE_SINGLECHEKBOX,IDC_AP_USESUBTREE),

	// Display type
	ParamUIDesc(PB_ANIMATIONOFFSET,TYPE_RADIO,animateoffsetIDs,3),

	// Animation Offset Amount
	ParamUIDesc(
		PB_OFFSETAMOUNT,
		EDITTYPE_TIME,
		IDC_AP_ANIRNDFR,IDC_AP_ANIRNDFRSPIN,
		1.0f,999999999.0f,
		10.0f),

	// Mapping Across
	ParamUIDesc(PB_MAPPINGTYPE,TYPE_RADIO,mappingIDs,2),

	// Time Mapping Option
	ParamUIDesc(
		PB_MAPPINGTIME,
		EDITTYPE_TIME,
		IDC_SP_MAPTIMEVAL,IDC_SP_MAPTIMEVALSPIN,
		1.0f,999999999.0f,
		10.0f),

	// Distance Mapping Option
	ParamUIDesc(
		PB_MAPPINGDIST,
		EDITTYPE_UNIVERSE,
		IDC_SP_MAPDISTVAL,IDC_SP_MAPDISTVALSPIN,
		0.1f,999999999.0f,
		SPIN_AUTOSCALE),

	// Use Custom Mtl
	ParamUIDesc(PB_CUSTOMMTL,TYPE_RADIO,custmtlIDs,2),
};
#define PARAMPTYPE_LENGTH 15

// Common Dialog for Particle Spin
static ParamUIDesc descParamPSpin[] = {

	// Spin Time
	ParamUIDesc(
		PB_SPINTIME,
		EDITTYPE_TIME,
		IDC_SP_SPIN,IDC_SP_SPINSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Spin Time Var
	ParamUIDesc(
		PB_SPINTIMEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINVAR,IDC_SP_SPINVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Spin Phase
	ParamUIDesc(
		PB_SPINPHASE,
		EDITTYPE_FLOAT,
		IDC_SP_SPINPHA,IDC_SP_SPINPHASPIN,
		-360.0f,360.0f,
		0.01f,
		stdAngleDim),

	// Spin Phase Variation
	ParamUIDesc(
		PB_SPINPHASEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINPHAVAR,IDC_SP_SPINPHAVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Enter Axis Control
	ParamUIDesc(PB_SPINAXISTYPE,TYPE_RADIO,spindirectionIDs,3),

	// X-Axis
	ParamUIDesc(
		PB_SPINAXISX,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISX,IDC_SP_SPINAXISXSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Y-Axis
	ParamUIDesc(
		PB_SPINAXISY,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISY,IDC_SP_SPINAXISYSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Z-Axis
	ParamUIDesc(
		PB_SPINAXISZ,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISZ,IDC_SP_SPINAXISZSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Spin Direction Variation
	ParamUIDesc(
		PB_SPINAXISVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISVAR,IDC_SP_SPINAXISVARSPIN,
		-180.0f,180.0f,
		0.01f,
		stdAngleDim),

	// Stretch
	ParamUIDesc(
		PB_STRETCH,
		EDITTYPE_INT,
		IDC_AP_STRETCH,IDC_AP_STRETCHSPIN,
		-1000.0f,1000.0f,
		1.0f),

	// IPC Enable
	ParamUIDesc(PB_PCIPCOLLIDE_ON,TYPE_SINGLECHEKBOX,IDC_INTERP_BOUNCEON),

	// IPC Steps
	ParamUIDesc(
		PB_PCIPCOLLIDE_STEPS,
		EDITTYPE_INT,
		IDC_INTERP_NSTEPS,IDC_INTERP_NSTEPSSPIN,
		1.0f,1000.0f,
		1.0f),

	// IPC Bounce
	ParamUIDesc(
		PB_PCIPCOLLIDE_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_INTERP_BOUNCE,IDC_INTERP_BOUNCESPIN,
		0.0f,10000.0f,
		1.0f,
		stdPercentDim),

	// IPC Bounce
	ParamUIDesc(
		PB_PCIPCOLLIDE_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_INTERP_BOUNCEVAR,IDC_INTERP_BOUNCEVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	};
#define PARAMPSPIN_LENGTH 14

// Common Dialog for Secondary Motion Data
static ParamUIDesc descParamEmitV[] = {

	// Emitter Velocity Inheritance Influence Portion
	ParamUIDesc(
		PB_EMITVINFL,
		EDITTYPE_FLOAT,
		IDC_SP_EMVI,IDC_SP_EMVISPIN,
		0.0f,100.0f,
		0.01f),

	// Secondary Motion Multiplier
	ParamUIDesc(
		PB_EMITVMULT,
		EDITTYPE_FLOAT,
		IDC_SP_EMVIMULT,IDC_SP_EMVIMULTSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Multiplier Variation
	ParamUIDesc(
		PB_EMITVMULTVAR,
		EDITTYPE_FLOAT,
		IDC_SP_EMVIMULTVAR,IDC_SP_EMVIMULTVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),
	};
#define PARAMEMITV_LENGTH 3

// Common Dialog for Bubble Motion
static ParamUIDesc descParamBubl[] = {

	// Bubble Amplitude
	ParamUIDesc(
		PB_BUBLAMP,
		EDITTYPE_UNIVERSE,
		IDC_SP_BUBL_AMP,IDC_SP_BUBL_AMPSPIN,
		-.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Bubble Amp Var
	ParamUIDesc(
		PB_BUBLAMPVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_AMPVAR,IDC_SP_BUBL_AMPVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Bubble Period
	ParamUIDesc(
		PB_BUBLPER,
		EDITTYPE_TIME,
		IDC_SP_BUBL_PER,IDC_SP_BUBL_PERSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Bubble Period Var
	ParamUIDesc(
		PB_BUBLPERVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERVAR,IDC_SP_BUBL_PERVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Bubble Phase
	ParamUIDesc(
		PB_BUBLPHAS,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERPHA,IDC_SP_BUBL_PERPHASPIN,
		-360.0f,360.0f,
		0.01f,
		stdAngleDim),

	// Bubble Phase Var
	ParamUIDesc(
		PB_BUBLPHASVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERPHAVAR,IDC_SP_BUBL_PERPHAVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),
};
#define PARAMBUBL_LENGTH 6


static int SpawnTypeIDs[] = {IDC_AP_NOSPAWN,IDC_AP_COLLIDEDIE,IDC_AP_COLLIDESPAWN,IDC_AP_DEATHSPAWN,IDC_AP_SPAWNTRAILS};
static int SpeedChaosIDs[] = {IDC_AP_SPEEDLESS,IDC_AP_SPEEDMORE,IDC_AP_SPEEDBOTH};
static int ScaleChaosIDs[] = {IDC_AP_SCALEDOWN,IDC_AP_SCALEUP,IDC_AP_SCALEBOTH};

// Dialog for Particle Spawning
static ParamUIDesc descPSpawning[] = {
	
	// Spawing Effects Type
	ParamUIDesc(PB_SPAWNTYPE,TYPE_RADIO,SpawnTypeIDs,5),

	ParamUIDesc(
		PB_SPAWNDIEAFTER,
		EDITTYPE_TIME,
		IDC_AP_MAXSPAWNDIEAFTER,IDC_AP_MAXSPAWNDIEAFTERSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Spawn Generations
	ParamUIDesc(
		PB_SPAWNDIEAFTERVAR,
		EDITTYPE_FLOAT,
		IDC_AP_MAXSPAWNDIEAFTERVAR,IDC_AP_MAXSPAWNDIEAFTERVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	ParamUIDesc(
		PB_SPAWNGENS,
		EDITTYPE_INT,
		IDC_AP_MAXSPAWNGENS,IDC_AP_MAXSPAWNGENSSPIN,
		1.0f,65000.0f,
		1.0f),

	// Spawn Percent
	ParamUIDesc(
		PB_SPAWNPERCENT,
		EDITTYPE_INT,
		IDC_AP_PARENTPERCENT,IDC_AP_PARENTPERCENTSPIN,
		1.0f,100.0f,
		1.0f),

	// Spawn Spawncount
	ParamUIDesc(
		PB_SPAWNCOUNT,
		EDITTYPE_INT,
		IDC_AP_NUMBERVAR,IDC_AP_NUMBERVARSPIN,
		1.0f,65000.0f,
		1.0f),

	// Spawn Mult Percent
	ParamUIDesc(
		PB_SPAWNMULTVAR,
		EDITTYPE_FLOAT,
		IDC_AP_NUMBERVARVAR,IDC_AP_NUMBERVARVARSPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Spawn Direction Chaos
	ParamUIDesc(
		PB_SPAWNDIRCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSANGLE,IDC_AP_CHAOSANGLESPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Spawn Speed Chaos
	ParamUIDesc(
		PB_SPAWNSPEEDCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSPEED,IDC_AP_CHAOSSPEEDSPIN,
		0.0f,100.0f,
		0.1f),

	// Spawing Speed Sign
	ParamUIDesc(PB_SPAWNSPEEDSIGN,TYPE_RADIO,SpeedChaosIDs,3),

	// Spawning Inherit Parent V
	ParamUIDesc(PB_SPAWNINHERITV,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSUMV),

	// Spawning Speed Fixed
	ParamUIDesc(PB_SPAWNSPEEDFIXED,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSPEEDFIXED),

	// Spawn Scale Chaos
	ParamUIDesc(
		PB_SPAWNSCALECHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSCALE,IDC_AP_CHAOSSCALESPIN,
		0.0f,100.0f,
		0.1f),

	// Spawning Scale Sign
	ParamUIDesc(PB_SPAWNSCALESIGN,TYPE_RADIO,ScaleChaosIDs,3),

	// Spawning Speed Fixed
	ParamUIDesc(PB_SPAWNSCALEFIXED,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSCALEFIXED),

	// Spawn Lifespan Entry Field
	ParamUIDesc(
		PB_SPAWNLIFEVLUE,
		EDITTYPE_INT,
		IDC_AP_QUEUELIFESPAN,IDC_AP_QUEUELIFESPANSPIN,
		0.0f,65000.0f,
		SPIN_AUTOSCALE),
};
#define PSPAWNINGPARAMS_LENGTH 16

static ParamBlockDescID spdescVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	 // distribution method
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed var
	{ TYPE_INT, NULL, FALSE, 3 },	 // vel dir
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // x
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // y
	{ TYPE_FLOAT, NULL, TRUE, 6 },	 // z
	{ TYPE_FLOAT, NULL, TRUE, 7 },	 // var

	{ TYPE_INT, NULL, FALSE, 8 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 9 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 10},    // total number
	{ TYPE_INT, NULL, FALSE, 11 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 12 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 13 },   // display until
	{ TYPE_INT, NULL, TRUE, 14 },	 // life
	{ TYPE_INT, NULL, TRUE, 15 },	 // life var
	{ TYPE_INT, NULL, FALSE, 16 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 18 },	 // size var
	{ TYPE_INT, NULL, FALSE, 19 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 20 },    // fade time
	{ TYPE_INT, NULL, FALSE, 21 }, // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 22 },  // emitter width
	{ TYPE_FLOAT, NULL, TRUE, 23 },  // emitter height
	{ TYPE_FLOAT, NULL, TRUE, 24 },  // emitter depth
	{ TYPE_INT, NULL, FALSE, 25 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 26 },  // particle class
	{ TYPE_INT, NULL, FALSE, 27 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 28 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 29 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 30 }, // meta course
	{ TYPE_INT, NULL, FALSE, 31}, // auto coarseness
    { TYPE_INT, NULL, FALSE, 32 }, // use subtree
    { TYPE_INT, NULL, FALSE, 33 }, // animation offset
    { TYPE_INT, NULL, FALSE, 34 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 40 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 41 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 42 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 43 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 44 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 46 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 47 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 48 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 49 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 50 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 51 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 52},  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 53 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 54 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 58 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 59 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 60 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 61 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 62 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 63 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 64 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 65 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 67 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 68 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 69 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 70 }, // constant spawn scale
};
static ParamBlockDescID spdescVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	 // distribution method
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed var
	{ TYPE_INT, NULL, FALSE, 3 },	 // vel dir
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // x
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // y
	{ TYPE_FLOAT, NULL, TRUE, 6 },	 // z
	{ TYPE_FLOAT, NULL, TRUE, 7 },	 // var

	{ TYPE_INT, NULL, FALSE, 8 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 9 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 10},    // total number
	{ TYPE_INT, NULL, FALSE, 11 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 12 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 13 },   // display until
	{ TYPE_INT, NULL, TRUE, 14 },	 // life
	{ TYPE_INT, NULL, TRUE, 15 },	 // life var
	{ TYPE_INT, NULL, FALSE, 16 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 18 },	 // size var
	{ TYPE_INT, NULL, FALSE, 19 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 20 },    // fade time
	{ TYPE_INT, NULL, FALSE, 21 }, // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 22 },  // emitter width
	{ TYPE_FLOAT, NULL, TRUE, 23 },  // emitter height
	{ TYPE_FLOAT, NULL, TRUE, 24 },  // emitter depth
	{ TYPE_INT, NULL, FALSE, 25 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 26 },  // particle class
	{ TYPE_INT, NULL, FALSE, 27 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 28 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 29 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 30 }, // meta course
	{ TYPE_INT, NULL, FALSE, 31}, // auto coarseness
    { TYPE_INT, NULL, FALSE, 32 }, // use subtree
    { TYPE_INT, NULL, FALSE, 33 }, // animation offset
    { TYPE_INT, NULL, FALSE, 34 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 40 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 41 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 42 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 43 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 44 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 46 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 47 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 48 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 49 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 50 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 51 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 52},  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 53 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 54 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 58 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 59 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 60 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 61 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 62 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 63 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 64 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 65 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 67 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 68 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 69 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 70 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 71 }, // Meta courseness viewport
};
static ParamBlockDescID spdescVer2[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	 // distribution method
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed var
	{ TYPE_INT, NULL, FALSE, 3 },	 // vel dir
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // x
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // y
	{ TYPE_FLOAT, NULL, TRUE, 6 },	 // z
	{ TYPE_FLOAT, NULL, TRUE, 7 },	 // var

	{ TYPE_INT, NULL, FALSE, 8 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 9 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 10},    // total number
	{ TYPE_INT, NULL, FALSE, 11 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 12 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 13 },   // display until
	{ TYPE_INT, NULL, TRUE, 14 },	 // life
	{ TYPE_INT, NULL, TRUE, 15 },	 // life var
	{ TYPE_INT, NULL, FALSE, 16 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 18 },	 // size var
	{ TYPE_INT, NULL, FALSE, 19 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 20 },    // fade time
	{ TYPE_INT, NULL, FALSE, 21 }, // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 22 },  // emitter width
	{ TYPE_FLOAT, NULL, TRUE, 23 },  // emitter height
	{ TYPE_FLOAT, NULL, TRUE, 24 },  // emitter depth
	{ TYPE_INT, NULL, FALSE, 25 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 26 },  // particle class
	{ TYPE_INT, NULL, FALSE, 27 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 28 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 29 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 30 }, // meta course
	{ TYPE_INT, NULL, FALSE, 31}, // auto coarseness
    { TYPE_INT, NULL, FALSE, 32 }, // use subtree
    { TYPE_INT, NULL, FALSE, 33 }, // animation offset
    { TYPE_INT, NULL, FALSE, 34 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 40 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 41 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 42 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 43 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 44 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 46 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 47 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 48 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 49 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 50 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 51 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 52},  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 53 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 54 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 58 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 59 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 60 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 61 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 62 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 63 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 64 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 65 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 67 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 68 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 69 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 70 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 71 }, // Meta courseness viewport
	{ TYPE_INT, NULL, FALSE, 72 }, // Spawn percent
	{ TYPE_FLOAT, NULL, FALSE, 73 }, // Spawn mult var
};
static ParamBlockDescID spdescVer3[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	 // distribution method
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed var
	{ TYPE_INT, NULL, FALSE, 3 },	 // vel dir
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // x
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // y
	{ TYPE_FLOAT, NULL, TRUE, 6 },	 // z
	{ TYPE_FLOAT, NULL, TRUE, 7 },	 // var

	{ TYPE_INT, NULL, FALSE, 8 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 9 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 10},    // total number
	{ TYPE_INT, NULL, FALSE, 11 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 12 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 13 },   // display until
	{ TYPE_INT, NULL, TRUE, 14 },	 // life
	{ TYPE_INT, NULL, TRUE, 15 },	 // life var
	{ TYPE_INT, NULL, FALSE, 16 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 18 },	 // size var
	{ TYPE_INT, NULL, FALSE, 19 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 20 },    // fade time
	{ TYPE_INT, NULL, FALSE, 21 }, // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 22 },  // emitter width
	{ TYPE_FLOAT, NULL, TRUE, 23 },  // emitter height
	{ TYPE_FLOAT, NULL, TRUE, 24 },  // emitter depth
	{ TYPE_INT, NULL, FALSE, 25 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 26 },  // particle class
	{ TYPE_INT, NULL, FALSE, 27 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 28 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 29 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 30 }, // meta course
	{ TYPE_INT, NULL, FALSE, 31}, // auto coarseness
    { TYPE_INT, NULL, FALSE, 32 }, // use subtree
    { TYPE_INT, NULL, FALSE, 33 }, // animation offset
    { TYPE_INT, NULL, FALSE, 34 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 40 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 41 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 42 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 43 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 44 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 46 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 47 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 48 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 49 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 50 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 51 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 52},  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 53 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 54 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 58 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 59 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 60 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 61 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 62 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 63 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 64 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 65 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 67 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 68 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 69 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 70 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 71 }, // Meta courseness viewport
	{ TYPE_INT, NULL, FALSE, 72 }, // Spawn percent
	{ TYPE_FLOAT, NULL, FALSE, 73 }, // Spawn mult var
	{ TYPE_INT, NULL, FALSE, 74 }, // Not Draft
};
static ParamBlockDescID spdescVer4[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	 // distribution method
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed var
	{ TYPE_INT, NULL, FALSE, 3 },	 // vel dir
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // x
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // y
	{ TYPE_FLOAT, NULL, TRUE, 6 },	 // z
	{ TYPE_FLOAT, NULL, TRUE, 7 },	 // var

	{ TYPE_INT, NULL, FALSE, 8 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 9 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 10},    // total number
	{ TYPE_INT, NULL, FALSE, 11 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 12 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 13 },   // display until
	{ TYPE_INT, NULL, TRUE, 14 },	 // life
	{ TYPE_INT, NULL, TRUE, 15 },	 // life var
	{ TYPE_INT, NULL, FALSE, 16 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 18 },	 // size var
	{ TYPE_INT, NULL, FALSE, 19 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 20 },    // fade time
	{ TYPE_INT, NULL, FALSE, 21 }, // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 22 },  // emitter width
	{ TYPE_FLOAT, NULL, TRUE, 23 },  // emitter height
	{ TYPE_FLOAT, NULL, TRUE, 24 },  // emitter depth
	{ TYPE_INT, NULL, FALSE, 25 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 26 },  // particle class
	{ TYPE_INT, NULL, FALSE, 27 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 28 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 29 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 30 }, // meta course
	{ TYPE_INT, NULL, FALSE, 31}, // auto coarseness
    { TYPE_INT, NULL, FALSE, 32 }, // use subtree
    { TYPE_INT, NULL, FALSE, 33 }, // animation offset
    { TYPE_INT, NULL, FALSE, 34 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 40 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 41 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 42 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 43 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 44 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 46 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 47 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 48 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 49 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 50 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 51 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 52},  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 53 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 54 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 58 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 59 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 60 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 61 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 62 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 63 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 64 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 65 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 67 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 68 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 69 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 70 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 71 }, // Meta courseness viewport
	{ TYPE_INT, NULL, FALSE, 72 }, // Spawn percent
	{ TYPE_FLOAT, NULL, FALSE, 73 }, // Spawn mult var
	{ TYPE_INT, NULL, FALSE, 74 }, // Not Draft
	{ TYPE_INT, NULL, TRUE, 75 }, // die after
	{ TYPE_FLOAT, NULL, TRUE, 76 }, // die after var
};
static ParamBlockDescID spdescVer5[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	 // distribution method
	{ TYPE_FLOAT, NULL, TRUE, 1 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed var
	{ TYPE_INT, NULL, FALSE, 3 },	 // vel dir
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // x
	{ TYPE_FLOAT, NULL, TRUE, 5 },	 // y
	{ TYPE_FLOAT, NULL, TRUE, 6 },	 // z
	{ TYPE_FLOAT, NULL, TRUE, 7 },	 // var

	{ TYPE_INT, NULL, FALSE, 8 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 9 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 10},    // total number
	{ TYPE_INT, NULL, FALSE, 11 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 12 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 13 },   // display until
	{ TYPE_INT, NULL, TRUE, 14 },	 // life
	{ TYPE_INT, NULL, TRUE, 15 },	 // life var
	{ TYPE_INT, NULL, FALSE, 16 },  // Custom Mtl
	{ TYPE_FLOAT, NULL, TRUE, 17 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 18 },	 // size var
	{ TYPE_INT, NULL, FALSE, 19 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 20 },    // fade time
	{ TYPE_INT, NULL, FALSE, 21 }, // rnd seed
	{ TYPE_FLOAT, NULL, TRUE, 22 },  // emitter width
	{ TYPE_FLOAT, NULL, TRUE, 23 },  // emitter height
	{ TYPE_FLOAT, NULL, TRUE, 24 },  // emitter depth
	{ TYPE_INT, NULL, FALSE, 25 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 26 },  // particle class
	{ TYPE_INT, NULL, FALSE, 27 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 28 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 29 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 30 }, // meta course
	{ TYPE_INT, NULL, FALSE, 31}, // auto coarseness
    { TYPE_INT, NULL, FALSE, 32 }, // use subtree
    { TYPE_INT, NULL, FALSE, 33 }, // animation offset
    { TYPE_INT, NULL, FALSE, 34 }, // offset amount

	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist

	{ TYPE_INT, NULL, TRUE, 40 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 41 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 42 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 43 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 44 },  // spin axis choice
	{ TYPE_FLOAT, NULL, TRUE, 45 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 46 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 47 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 48 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 49 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 50 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 51 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 52},  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 53 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 54 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble phase var

	{ TYPE_INT, NULL, TRUE, 58 },  // Stretch
	{ TYPE_INT, NULL, FALSE, 59 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 60 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 61 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 62 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 63 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 64 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 65 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 67 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 68 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 69 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 70 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 71 }, // Meta courseness viewport
	{ TYPE_INT, NULL, FALSE, 72 }, // Spawn percent
	{ TYPE_FLOAT, NULL, FALSE, 73 }, // Spawn mult var
	{ TYPE_INT, NULL, FALSE, 74 }, // Not Draft
	{ TYPE_INT, NULL, TRUE, 75 }, // die after
	{ TYPE_FLOAT, NULL, TRUE, 76 }, // die after var
	{ TYPE_INT, NULL, FALSE, 77 },  // IPC Enable
	{ TYPE_INT, NULL, FALSE, 78 },  // IPC Steps
	{ TYPE_FLOAT, NULL, TRUE, 79 },  // IPC Bounce
	{ TYPE_FLOAT, NULL, TRUE, 80 },  // IPC Bounce Var
};

#define PBLOCK_LENGTH_PCLOUD 81

static ParamVersionDesc pcversions[] = {
	ParamVersionDesc(spdescVer0,71,0),
	ParamVersionDesc(spdescVer1,72,1),
	ParamVersionDesc(spdescVer2,74,2),
	ParamVersionDesc(spdescVer3,75,3),
	ParamVersionDesc(spdescVer4,77,4),
	};
#define NUM_OLDVERSIONS	5

// Current version
#define CURRENT_VERSION	5
static ParamVersionDesc curVersionPC(spdescVer5,PBLOCK_LENGTH_PCLOUD,CURRENT_VERSION);

//-- ParticleDlgProc ------------------------------------------------

class CreatePCloudProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		PCloudParticle *CloudObject;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreatePCloudProc()
			{
			ignoreSelectionChange = FALSE;
			}
//		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_CREATEPCLOUDMODE	CID_USER +14

class CreatePCloudMode : public CommandMode {		
	public:		
		CreatePCloudProc proc;
		IObjParam *ip;
		PCloudParticle *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,PCloudParticle*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEPCLOUDMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreatePCloudMode theCreatePCloudMode;

RefResult CreatePCloudProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( CloudObject && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (CloudObject && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (CloudObject->creating) 
						{  theCreatePCloudMode.JumpStart(CloudObject->ip,CloudObject);
							createInterface->SetCommandMode(&theCreatePCloudMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				CloudObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				CloudObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				CloudObject  = NULL;				
				CloudNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreatePCloudProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	CloudObject       = NULL;
	CreateNewObject();
	}
void CreatePCloudProc::CreateNewObject()
	{
	lastPutCount  = theHold.GetGlobalPutCount();
	CloudObject = (PCloudParticle*)cDesc->Create();
	
	// Start the edit params process
	if ( CloudObject ) {
		CloudObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		CloudObject->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreatePCloudProc::End()
{ if ( CloudObject ) 
	{ 
#ifdef _OSNAP
		CloudObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		CloudObject->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete CloudObject;
			CloudObject = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		}  else if ( CloudNode ) 
		{	theHold.Suspend();
			DeleteReference(0);  // sets cloudNode = NULL
			theHold.Resume();}
	}
}

void CreatePCloudMode::JumpStart(IObjParam *i,PCloudParticle *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}

int PCloudClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreatePCloudMode.Begin(iob,this);
	iob->PushCommandMode(&theCreatePCloudMode);
	return TRUE;
	}

int PCloudClassDesc::EndCreate(Interface *i)
	{
	theCreatePCloudMode.End();
	i->RemoveMode(&theCreatePCloudMode);
	return TRUE;
	}

int CreatePCloudProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res=TRUE;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( CloudObject );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
#ifdef _OSNAP
						CloudObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				   		CloudObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						// Get rid of the reference.
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}
						// new object
						CreateNewObject();   // creates CloudObject
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( CloudObject);
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = CloudObject->GetCreateMouseCallBack();
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();
					mat.IdentityMatrix();
				default:				
					if (createCB) {						
						res = createCB->proc(vpx,msg,point,flag,m,mat);
						createInterface->SetNodeTMRelConstPlane(CloudNode,mat);

						if (res==CREATE_ABORT)
							goto abort;
						if (res==CREATE_STOP){
#ifdef _OSNAP
                         CloudObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
						    theHold.Accept(GetString(IDS_DS_CREATE));	 
						}
						createInterface->RedrawViews(createInterface->GetTime());   //DS
						}

					break;
					
				}			
			break;

		case MOUSE_MOVE:
			if (createCB) {				
				res = createCB->proc(vpx,msg,point,flag,m,mat);
				createInterface->SetNodeTMRelConstPlane(CloudNode,mat);
				if (res==CREATE_ABORT) 
					goto abort;
				if (res==CREATE_STOP){
#ifdef _OSNAP
				CloudObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
					theHold.Accept(GetString(IDS_DS_CREATE));	// TH
				}
				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_INTERACTIVE);		//DS		
				}
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: 
	if (createCB)
	{ res = createCB->proc(vpx,msg,point,flag,m,mat);
	  createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
	  if (res==CREATE_ABORT)
	      goto abort;
	  if (res==CREATE_STOP){
#ifdef _OSNAP
         CloudObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	    theHold.Accept(GetString(IDS_DS_CREATE));	
	  }
	  createInterface->RedrawViews(createInterface->GetTime()); 
		break;
	}
	abort:
		assert( CloudObject );
#ifdef _OSNAP
		CloudObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		CloudObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
		// Toss the Undo stack if any parameters have changed.
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
			GetSystemSetting(SYSSET_CLEAR_UNDO);
		CloudObject=NULL;
		createInterface->RedrawViews(createInterface->GetTime());
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		break;
	
		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP  //PREVIEW SNAP
		 if (createCB) res =createCB->proc(vpx,msg,point,flag,m,mat);
#endif
		vpx->TrackImplicitGrid(m);
			break;
	}

	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
}

void EnterDir(HWND hWnd,BOOL ison,BOOL pickon=FALSE)
{ if (ison)
  { SpinnerOn(hWnd,IDC_AP_MOVEDIRXSPIN,IDC_AP_MOVEDIRX);
	SpinnerOn(hWnd,IDC_AP_MOVEDIRYSPIN,IDC_AP_MOVEDIRY);
	SpinnerOn(hWnd,IDC_AP_MOVEDIRZSPIN,IDC_AP_MOVEDIRZ);
  }
  else
  { SpinnerOff(hWnd,IDC_AP_MOVEDIRXSPIN,IDC_AP_MOVEDIRX);
	SpinnerOff(hWnd,IDC_AP_MOVEDIRYSPIN,IDC_AP_MOVEDIRY);
	SpinnerOff(hWnd,IDC_AP_MOVEDIRZSPIN,IDC_AP_MOVEDIRZ);
  }
  if ((ison)||(pickon)) 
	SpinnerOn(hWnd,IDC_AP_MOVEDIRVARSPIN,IDC_AP_MOVEDIRVAR);
  else
	SpinnerOff(hWnd,IDC_AP_MOVEDIRVARSPIN,IDC_AP_MOVEDIRVAR);
  TurnButton(hWnd,IDC_AP_OBJECTDIRPICK,pickon);
}

void PCCheckInstButtons(IParamBlock *pblock,HWND hptype)
{ int isinst;
  pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
  float width;
  pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
  TurnButton(hptype,IDC_AP_OBJECTPICK,((isinst==INSTGEOM)&&(width>=0.01f)));
}
void PCCheckLifeButtons(int stype,HWND spawn)
{ int rep;
  rep = SendMessage(GetDlgItem(spawn,IDC_AP_LIFEQUEUE),LB_GETCURSEL,0,0);
  TurnButton(spawn,IDC_AP_LIFEQUEUEADD,(stype>1));
  TurnButton(spawn,IDC_AP_LIFEQUEUEREPL,(stype>1)&&(rep>-1));
  TurnButton(spawn,IDC_AP_LIFEQUEUEDEL,(stype>1)&&(rep>-1));
}
void PCCheckSpawnButtons(IParamBlock *pblock,HWND spawn,int repi)
{ int stype;
  pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
  EnableWindow(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),(stype>1));
  TurnButton(spawn,IDC_AP_OBJECTQUEUEPICK,(stype>1));
  TurnButton(spawn,IDC_AP_OBJQUEUEREPLACE,(stype>1)&&(repi>-1));
  TurnButton(spawn,IDC_AP_OBJQUEUEDELETE,(stype>1)&&(repi>-1));
  PCCheckLifeButtons(stype,spawn);
}

void PCCheckPickButtons(IParamBlock *pblock,HWND hptype,HWND spawn,int repi)
{ PCCheckInstButtons(pblock,hptype);
  PCCheckSpawnButtons(pblock,spawn,repi);
}

class PCloudEmitterCreateCallback : public CreateMouseCallBack {
	public:
		PCloudParticle *po;
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int PCloudEmitterCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{
#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	Point3 d;
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point)  {
			case 0:
				// if hidden by category, re-display particles and objects
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				sp0 = m;
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				po->pblock->SetValue(PB_EMITRWID,0,0.01f);
				po->pblock->SetValue(PB_EMITRHEIGHT,0,0.01f);
				po->pblock->SetValue(PB_EMITRDEPTH,0,0.01f);
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1 = p0 + Point3(.01,.01,.01);
				mat.SetTrans(float(.5)*(p0+p1));				
				po->pmapParam->Invalidate();
				break;

			case 1: 
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,snapdim);
				if ((po->createmeth==1)||(po->createmeth==2))
				{ d = p1-p0;}
				else
				{p1.z = p0.z +(float).01; 
				if((flags&MOUSE_CTRL) ||(po->createmeth==3))
				{ mat.SetTrans(p0);	} 
				else mat.SetTrans(float(.5)*(p0+p1));
				d = p1-p0;
				square = FALSE;
				if (flags&MOUSE_CTRL) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;
					square = TRUE;
					}
				}
				po->pblock->SetValue(PB_EMITRWID,0,float(fabs(d.y)));
				po->pblock->SetValue(PB_EMITRHEIGHT,0,float(fabs(d.x)));

				if (msg==MOUSE_POINT)
				{ if (Length(sp1-sp0)<3 || Length(d)<0.1f) 
				   return CREATE_ABORT;	
				  else if ((po->createmeth==1)||(po->createmeth==3))
				  {	TurnButton(po->hptype,IDC_AP_OBJECTPICK,TRUE);
					TurnButton(po->hparam,IDC_AP_FILLPICKBUTTON,TRUE);
					TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,TRUE);
					if (po->pickCB.repi>-1)
					TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,TRUE);
					po->pblock->SetValue(PB_EMITRDEPTH,0,float(fabs(d.y)));
				    po->pmapParam->Invalidate();
					 return CREATE_STOP;
				  }
				}
				po->pblock->SetValue(PB_EMITRDEPTH,0,float(fabs(d.z)));
				po->pmapParam->Invalidate();
				break;
			case 2:
				p1.z = p0.z + vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));
				if (po->createmeth==2)
				{ Point3 tmp=p0;tmp.z=float(.5)*(p0.z+p1.z);
				  mat.SetTrans(tmp);
				}
				else if (!square)
				{ mat.SetTrans(float(.5)*(p0+p1)); }

				d = p1-p0;
				if (square) {
					// Constrain to square base
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;					
					}

				po->pblock->SetValue(PB_EMITRWID,0,float(fabs(d.y)));
				po->pblock->SetValue(PB_EMITRHEIGHT,0,float(fabs(d.x)));
				po->pblock->SetValue(PB_EMITRDEPTH,0,float(fabs(d.z)));
				po->pmapParam->Invalidate();				
					
				if (msg==MOUSE_POINT) {	
					PCCheckPickButtons(po->pblock,po->hptype,po->spawn,po->pickCB.repi);
				TurnButton(po->hparam,IDC_AP_FILLPICKBUTTON,TRUE);
				return CREATE_STOP;	}
				break;

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}
	return 1;
	}

static PCloudEmitterCreateCallback pcloudemitterCallback;

CreateMouseCallBack* PCloudParticle::GetCreateMouseCallBack() 
	{
	pcloudemitterCallback.po = this;
	return &pcloudemitterCallback;
	}

class PCParticleGenDlgProc : public ParamMapUserDlgProc {
	public:
		PCloudParticle *po;
		ICustButton *iBut;

		PCParticleGenDlgProc(PCloudParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void PCParticleGenDlgProc::Update(TimeValue t)
{	if (!po->editOb) return;
    int birthmeth;
	po->pblock->GetValue(PB_BIRTHMETHOD,0,birthmeth,FOREVER);
	if (birthmeth)
	{ SpinnerOff(po->hgen,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
	  SpinnerOn(po->hgen,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
	}else 
	{ SpinnerOn(po->hgen,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
	  SpinnerOff(po->hgen,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
	}
	int ison; 
	po->pblock->GetValue(PB_SPEEDDIR,0,ison,FOREVER);
	EnterDir(po->hgen,ison==1,ison==2);
	po->ShowName(shownormname);
}

BOOL PCParticleGenDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{  int acourse;
       float size;
      switch (msg) 
	  { case WM_INITDIALOG: {
			iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJECTDIRPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			Update(t);
			break;
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SP_GENUSERATE:
				{ SpinnerOn(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
				  SpinnerOff(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
				 return TRUE;
				}
			  case IDC_SP_GENUSETTL:
				{ SpinnerOff(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
				  SpinnerOn(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
				 return TRUE;
				}
			}
			case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) 
			{ case IDC_SP_GENSIZESPIN:
				   { po->pblock->GetValue(PB_METAAUTOCOARSE,t,acourse,FOREVER);
					int mpart;
				    po->pblock->GetValue(PB_PARTICLECLASS,t,mpart,FOREVER);
				    if ((mpart==METABALLS)&&(acourse) )
					 { po->pblock->GetValue(PB_SIZE,t,size,FOREVER);
					   po->pblock->SetValue(PB_METACOURSE,t,size/coursedivider);
					   po->pblock->SetValue(PB_METACOURSEV,t,size/3.0f);
					   po->pmapPType->Invalidate();
					 }
			        return TRUE;
				   }			
				case IDC_SP_GENEMIT1SPIN:
				case IDC_SP_GENEMIT2SPIN:
					{ int sstop,sstart;
					  po->pblock->GetValue(PB_EMITSTOP,t,sstop,FOREVER);
					  po->pblock->GetValue(PB_EMITSTART,t,sstart,FOREVER);
					  if (sstop<sstart) 
					     po->pblock->SetValue(PB_EMITSTOP,t,sstart);
					  return TRUE;
					}
				case IDC_AP_NEWSEED:
					{ srand( (unsigned)time( NULL ) );
					  int newseed=rand() % 25001;
					  po->pblock->SetValue(PB_RNDSEED,0,newseed);
					  po->pmapPGen->Invalidate();
					  break;
					}
				case IDC_AP_PCLOUDDIRRND:
				case IDC_AP_PCLOUDDIRENTER:
				case IDC_AP_PCLOUDDIROBJ:
				   { int ison; 
					po->pblock->GetValue(PB_SPEEDDIR,0,ison,FOREVER);
					EnterDir(hWnd,ison==1,ison==2);
			        return TRUE;
				   }
				case IDC_AP_OBJECTDIRPICK:
				    if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreatePCloudMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePCloudMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickNorm.po = po;						
						  po->ip->SetPickMode(&po->pickNorm);
						}
					break;
			}
	  }
	return FALSE;
	}

void PCCheckStretchBox(HWND hWnd,PCloudParticle *po)
{ if (IsStdMtl(po->cnode))
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),TRUE);
  } else EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
  SpinnerOn(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
  po->pmapPSpin->Invalidate();
}

void PCStretchStuff(int dir,int fragflags,HWND hWnd,PCloudParticle *po)
{ if (dir==0)
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
	SpinnerOff(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
	SpinStuff(hWnd,FALSE,fragflags!=METABALLS);
  }
  else if (dir==1)
  { PCCheckStretchBox(hWnd,po);
	SpinStuff(hWnd,FALSE,fragflags!=METABALLS);
  }  
  else if (dir==2)
  {	EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
	SpinnerOff(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
	SpinStuff(hWnd,TRUE,fragflags!=METABALLS);
  }
}

void CourseCheck(PCloudParticle *po,HWND hWnd,TimeValue t)
{ int acourse;
  float size;
  po->pblock->GetValue(PB_METAAUTOCOARSE,t,acourse,FOREVER);
  if (acourse) 
  { float mc1,mc2,mc,mcv;
	po->pblock->GetValue(PB_SIZE,t,size,FOREVER);mc=size/coursedivider;mcv=size/3.0f;
	po->pblock->GetValue(PB_METACOURSE,t,mc1,FOREVER);
	po->pblock->GetValue(PB_METACOURSEV,t,mc2,FOREVER);
	if ((mc1!=mc)||(mc2!=mcv))
	{ po->pblock->SetValue(PB_METACOURSE,t,mc);
	  po->pblock->SetValue(PB_METACOURSEV,t,mcv);
	  po->pmapPType->Invalidate();
	}
	SpinnerOff(hWnd,IDC_SP_METCOURSESPIN,IDC_SP_METCOURSE);
 	SpinnerOff(hWnd,IDC_SP_METCOURSEVSPIN,IDC_SP_METCOURSEV);
  }
  else 
  { SpinnerOn(hWnd,IDC_SP_METCOURSESPIN,IDC_SP_METCOURSE);
	SpinnerOn(hWnd,IDC_SP_METCOURSEVSPIN,IDC_SP_METCOURSEV);
  }
};
void PCSetMapVals(IParamBlock *pblock,HWND hWnd,TimeValue t)
{ int type,maptype;
  pblock->GetValue(PB_PARTICLETYPE,t,type,FOREVER);
  if (type==RENDTET)
  { SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
 	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
 }
  else
  { pblock->GetValue(PB_MAPPINGTYPE,t,maptype,FOREVER);
    if (maptype)
	{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	  SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
	}
	else
	{ SpinnerOn(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
	}
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
   }
}
void MappingStuff(PCloudParticle *po,HWND hWnd,TimeValue t)
{ int maptype;
  po->pblock->GetValue(PB_CUSTOMMTL,t,maptype,FOREVER);
 if (maptype)
  { SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
    SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
   }
  else PCSetMapVals(po->pblock,hWnd,t);
}

void PCAniFr(HWND hWnd,IParamBlock *pblock)
{ int anitype;
  pblock->GetValue(PB_ANIMATIONOFFSET,0,anitype,FOREVER);
  if (anitype>1)
	  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
  else	SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
}

void PCSetRateSpinner(IParamBlock *pblock,TimeValue t,HWND hWnd)
{ int birthmeth;
  EnableWindow(GetDlgItem(hWnd,IDC_SP_GENUSERATE),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_GENUSETTL),TRUE);
  pblock->GetValue(PB_BIRTHMETHOD,0,birthmeth,FOREVER);
  if (birthmeth)
  { SpinnerOff(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
    SpinnerOn(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
  }else 
  { SpinnerOn(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
    SpinnerOff(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
  }
}

void InstOn(PCloudParticle *po,HWND hWnd,TimeValue t)
{ if ((po->fragflags==METABALLS)||(po->fragflags<0))
  { MetaOff(hWnd);
    SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
  }
  if (po->fragflags<=0)
  { StdStuff(hWnd,FALSE);  }
  po->fragflags=INSTGEOM;
  InstStuff(hWnd,TRUE,po->hparam,po->spawn,FALSE);
  PCAniFr(hWnd,po->pblock);
  int sptype;
  TurnButton(hWnd,IDC_AP_OBJECTPICK,TRUE);
  EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),TRUE);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),TRUE);
  po->pblock->GetValue(PB_SPINAXISTYPE,0,sptype,FOREVER);
  PCStretchStuff(sptype,INSTGEOM,po->hrot,po);
  SpinMainStuff(po->hrot,TRUE);
  MappingStuff(po,hWnd,t);
  PCSetRateSpinner(po->pblock,t,po->hgen);
  int stype;po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
  ObjectMutQueOn(stype,po->spawn,po->pickCB.repi);
  po->pmapPSpin->Invalidate();
}

void MetaIn(PCloudParticle *po,HWND hWnd,TimeValue t)
{ int lastflag=po->fragflags;
  po->fragflags=METABALLS;
  SpinnerOn(hWnd,IDC_SP_METTENSSPIN,IDC_SP_METTENS);
  SpinnerOn(hWnd,IDC_SP_METTENSVARSPIN,IDC_SP_METTENSVAR);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_AUTOCOARSE),TRUE);
  CourseCheck(po,hWnd,t);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_DRAFTMODE),TRUE);
  EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),FALSE);
  PCStretchStuff(0,METABALLS,po->hrot,po);
  SpinMainStuff(po->hrot,FALSE);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
  TurnButton(hWnd,IDC_AP_OBJECTPICK,FALSE);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),FALSE);
  StdStuff(hWnd,FALSE);
  MappingStuff(po,hWnd,t);
  PCSetRateSpinner(po->pblock,t,po->hgen);
  if (lastflag<=0)
  { StdStuff(hWnd,FALSE); }
  if ((lastflag==INSTGEOM)||(lastflag<0))
  {  InstStuff(hWnd,FALSE,po->hparam,po->spawn,FALSE);
     int maptype,viewpt;
     po->pblock->GetValue(PB_CUSTOMMTL,0,maptype,FOREVER);
     if (maptype==2) po->pblock->SetValue(PB_CUSTOMMTL,0,0);
     po->pblock->GetValue(PB_VIEWPORTSHOWS,0,viewpt,FOREVER);
	 if (viewpt==3) po->pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
	 po->pmapParam->Invalidate();
  }
  ObjectMutQueOff(po->spawn);
  int stype;
  po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
//  if (stype>1) po->pblock->SetValue(PB_SPAWNTYPE,0,0);
//  AllSpawnBad(po->spawn,0,FALSE);
  int ison; po->pblock->GetValue(PB_PCIPCOLLIDE_ON,0,ison,FOREVER);
  if (ison) stype=0;
  SpawnStuff(po->spawn,stype);
  po->pmapPSpin->Invalidate();
}

void StdOn(PCloudParticle *po,HWND hWnd,TimeValue t)
{ if ((po->fragflags==METABALLS)||(po->fragflags<0))
  { MetaOff(hWnd);
    SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
  }
  if ((po->fragflags==INSTGEOM)||(po->fragflags<0))
  {  InstStuff(hWnd,FALSE,po->hparam,po->spawn,FALSE);
     int maptype,viewpt;
     po->pblock->GetValue(PB_CUSTOMMTL,0,maptype,FOREVER);
     if (maptype==2) po->pblock->SetValue(PB_CUSTOMMTL,0,0);
     po->pblock->GetValue(PB_VIEWPORTSHOWS,0,viewpt,FOREVER);
	 if (viewpt==3) po->pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
	 po->pmapParam->Invalidate();
  }
  StdStuff(hWnd,TRUE);
  po->fragflags=0;
  EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),TRUE);
 EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),FALSE);
  int sptype;
  po->pblock->GetValue(PB_SPINAXISTYPE,0,sptype,FOREVER);
  PCStretchStuff(sptype,0,po->hrot,po);
  SpinMainStuff(po->hrot,TRUE);
  MappingStuff(po,hWnd,t);
  int facing;
  po->pblock->GetValue(PB_PARTICLETYPE,t,facing,FOREVER);
  if ((facing==RENDTYPE5)||(facing==RENDTYPE6))
  { po->pblock->GetValue(PB_VIEWPORTSHOWS,t,facing,FOREVER);
	if (facing==2) po->pblock->SetValue(PB_VIEWPORTSHOWS,t,1);
   EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),FALSE);
  }
  else  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
  ObjectMutQueOff(po->spawn);
  TurnButton(hWnd,IDC_AP_OBJECTPICK,FALSE);
  SpinnerOff(hWnd,IDC_SP_METTENSSPIN,IDC_SP_METTENS);
}

class PCParticleSpinDlgProc : public ParamMapUserDlgProc {
	public:
		PCloudParticle *po;

		PCParticleSpinDlgProc(PCloudParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};
void PCParticleSpinDlgProc::Update(TimeValue t)
{   int axis;
	po->pblock->GetValue(PB_SPINAXISTYPE,t,axis,FOREVER);
	PCStretchStuff(axis,po->fragflags,po->hrot,po);
	int ison; po->pblock->GetValue(PB_PCIPCOLLIDE_ON,t,ison,FOREVER);
	int stype; po->pblock->GetValue(PB_SPAWNTYPE,t,stype,FOREVER);
	IPCControls(po->hrot,po->spawn,stype,ison);
}

BOOL PCParticleSpinDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: 
		{break;
		}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_PARTICLEDIRTRAVL:
			    PCStretchStuff(1,po->fragflags,hWnd,po);
			  break;
			  case IDC_AP_PARTICLEDIRRND:
				PCStretchStuff(0,po->fragflags,hWnd,po);
			  break;
			  case IDC_AP_PARTICLEDIRUSER:
				PCStretchStuff(2,po->fragflags,hWnd,po);
				break;
			  case IDC_INTERP_BOUNCEON:
				{  int ison; po->pblock->GetValue(PB_PCIPCOLLIDE_ON,t,ison,FOREVER);
				   int stype; po->pblock->GetValue(PB_SPAWNTYPE,t,stype,FOREVER);
				   IPCControls(hWnd,po->spawn,stype,ison);
				}
				break;
			}
		default:
			return FALSE;
	}
	return TRUE;
}

void AddMtl(PCloudParticle *po,TimeValue t)
{ if (po->cnode)
	{ int subtree,frag,custmtl=0,submtl=0;
    po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
    po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
    po->pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	if ((po->custnode)&&(frag==INSTGEOM)&& custmtl) 
		po->AssignMtl(po->cnode,po->custnode,subtree,t);
	po->valid=FALSE;
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
 }

class PCParticleDisableDlgProc : public ParamMapUserDlgProc {
	public:
		PCloudParticle *po;
		ICustButton *iBut;

		PCParticleDisableDlgProc(PCloudParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void PCParticleDisableDlgProc::Update(TimeValue t)
{ if (!po->editOb) return;
	po->ShowName(0);
	int chunky,stype;
	po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
	po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
//	AllSpawnBad(po->spawn,stype,chunky!=METABALLS);
    int ison; po->pblock->GetValue(PB_PCIPCOLLIDE_ON,0,ison,FOREVER);
    if (ison) stype=0;
	SpawnStuff(po->spawn,stype);
	PCCheckSpawnButtons(po->pblock,po->spawn,po->pickCB.repi=0);
	if (chunky==METABALLS) MetaIn(po,po->hptype,t);
	else if (chunky==0) StdOn(po,po->hptype,t);
	else InstOn(po,po->hptype,t);
	PCCheckInstButtons(po->pblock,po->hptype);
}

BOOL PCParticleDisableDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{  switch (msg) {
		case WM_INITDIALOG: {
			iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJECTPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			Update(t);
			break;
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{  case IDC_AP_OBJECTPICK:
				   { po->flags=0;
					if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreatePCloudMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePCloudMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;
					      po->pickCB.dodist=0;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
			case IDC_AP_UPDATEMTL:
				{ AddMtl(po,t);
				  int custmtl;
				  po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
				  if ((po->cnode)&&(custmtl))
				  { EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPCUSTOMEMIT),FALSE);
				    po->origmtl=po->cnode->GetMtl();
				  }
				  break;
				}
			  case IDC_AP_NOANIOFF:
			  case IDC_AP_ANIOFFBIRTH:
				  	SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
				  break;
			  case IDC_AP_ANIOFFRND:
			  	  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
				  break;
			   case IDC_SP_TYPESTD:
				{ po->pblock->SetValue(PB_CUSTOMMTL,0,0);
				  StdOn(po,hWnd,t);
				  po->valid=FALSE;
				  if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
				  { if (po->creating) 
					{  theCreatePCloudMode.JumpStart(po->ip,po);
						po->ip->SetCommandMode(&theCreatePCloudMode);
					} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
				  }
				 break;
				}
			  case IDC_SP_TYPEFAC:
			  case IDC_SP_TYPEPIX:
				{ PCSetMapVals(po->pblock,hWnd,t);
				  int facing;
				  po->pblock->GetValue(PB_VIEWPORTSHOWS,t,facing,FOREVER);
				  if (facing==2) po->pblock->SetValue(PB_VIEWPORTSHOWS,t,1);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),FALSE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
 				  po->pmapParam->Invalidate();
				 break;
				}
			  case IDC_SP_TYPETRI:
			  case IDC_SP_TYPECUB:
			  case IDC_SP_TYPESPC:
			  case IDC_SP_TYPE6PNT:
			  case IDC_SP_TYPESPHERE:
				{ PCSetMapVals(po->pblock,hWnd,t);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
 				 break;
				}
			  case IDC_SP_TYPETET:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
 				 break;
				}
			  case IDC_SP_MAPTIME:
				{ SpinnerOn(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			  case IDC_SP_MAPDIST:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			  case IDC_SP_MAPCUSTOMEMIT:
			  case IDC_SP_MAPCUSTOMINST:
				{ MappingStuff(po,hWnd,t);
				  int dir;
				  po->pblock->GetValue(PB_SPINAXISTYPE,0,dir,FOREVER);
				  if (dir==1)  PCCheckStretchBox(po->hrot,po);
				 break;
				}
			  case IDC_SP_TYPEMET:
				  {po->pblock->SetValue(PB_CUSTOMMTL,0,0);
					MetaIn(po,hWnd,t);
				    po->valid=FALSE;
				  if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
				  { if (po->creating) 
					{  theCreatePCloudMode.JumpStart(po->ip,po);
						po->ip->SetCommandMode(&theCreatePCloudMode);
					} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
				  }
				  break;
				  }
			  case IDC_SP_TYPEINSTANCE:
				  { int custmtl,vshow,anioff;
				    po->pblock->SetValue(PB_CUSTOMMTL,0,1);
					InstOn(po,hWnd,t);
					po->pblock->GetValue(PB_VIEWPORTSHOWS,0,vshow,FOREVER);
					if (vshow>1)
					{int subtree;
					 po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  				 po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					 TimeValue aniend=GetAnimEnd();
					 int anifr=aniend+GetTicksPerFrame();
					 po->GetTimes(po->times,t,anifr,anioff);
					 if (vshow==2)
					 { po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
				       po->GetMesh(t,subtree,custmtl);
					 }
					else po->GetallBB(po->custnode,subtree,t);
					}
				    po->valid=FALSE;
				  break;
				  }
			  case IDC_SP_AUTOCOARSE:
				{ int chunky;
				  po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
				  if (chunky==METABALLS)
					 CourseCheck(po,hWnd,t);
				  break;
				}
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
	}
class PCParticleParmDlgProc : public ParamMapUserDlgProc {
	public:
		PCloudParticle *po;
		ICustButton *iBut;

		PCParticleParmDlgProc(PCloudParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void PCParticleParmDlgProc::Update(TimeValue t)
{ if (!po->editOb) return;
 	float width;
	po->pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
	if (width<0.01f) iBut->Disable(); else iBut->Enable();
	po->ShowName(1);
	po->pblock->GetValue(PB_CREATEIN,0,po->createmeth,FOREVER);
	if (po->createmeth>0)
	  SpinnerOff(po->hparam,IDC_AP_EMITHGTSPIN,IDC_AP_EMITHGT);
	else SpinnerOn(po->hparam,IDC_AP_EMITHGTSPIN,IDC_AP_EMITHGT);
	if ((po->createmeth==0)||(po->createmeth==2))
	  SpinnerOn(po->hparam,IDC_AP_EMITDEPSPIN,IDC_AP_EMITDEP);
	else SpinnerOff(po->hparam,IDC_AP_EMITDEPSPIN,IDC_AP_EMITDEP);
}
	
BOOL PCParticleParmDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_FILLPICKBUTTON));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			Update(t);
			break;
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{   case IDC_AP_FILLPICKBUTTON:
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreatePCloudMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePCloudMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;
					      po->pickCB.dodist=1;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
				case IDC_AP_FILLBOX:
					po->createmeth=0;
					SpinnerOn(hWnd,IDC_AP_EMITHGTSPIN,IDC_AP_EMITHGT);
					SpinnerOn(hWnd,IDC_AP_EMITDEPSPIN,IDC_AP_EMITDEP);
					break;
				case IDC_AP_FILLSPHERE:
					po->createmeth=1;
					SpinnerOff(hWnd,IDC_AP_EMITHGTSPIN,IDC_AP_EMITHGT);
					SpinnerOff(hWnd,IDC_AP_EMITDEPSPIN,IDC_AP_EMITDEP);
					break;
				case IDC_AP_FILLCYLINDER:
					po->createmeth=2;
					SpinnerOff(hWnd,IDC_AP_EMITHGTSPIN,IDC_AP_EMITHGT);
					SpinnerOn(hWnd,IDC_AP_EMITDEPSPIN,IDC_AP_EMITDEP);
					break;
				case IDC_AP_FILLOBJECT:
					po->createmeth=3;
					SpinnerOff(hWnd,IDC_AP_EMITHGTSPIN,IDC_AP_EMITHGT);
					SpinnerOff(hWnd,IDC_AP_EMITDEPSPIN,IDC_AP_EMITDEP);
					break;
			  case IDC_SP_VIEWDISPMESH:
				  {po->valid=FALSE;
				   int subtree,custmtl;
					po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
					po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
					int anioff;
	  				po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					TimeValue aniend=GetAnimEnd();
					int anifr=aniend+GetTicksPerFrame();
					po->GetTimes(po->times,t,anifr,anioff);
				    po->GetMesh(t,subtree,custmtl);
				   break;
				  }
			  case IDC_SP_VIEWDISPBOX:			  
				  { po->valid=FALSE;
					int subtree;
					po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
					int anioff;
	  				po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					TimeValue aniend=GetAnimEnd();
					int anifr=aniend+GetTicksPerFrame();
					po->GetTimes(po->times,t,anifr,anioff);
					po->GetallBB(po->custnode,subtree,t);
				  break;
				  }
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
	}
class PCParticleSpawnDlgProc : public ParamMapUserDlgProc {
	public:
		PCloudParticle *po;
		ICustButton *iBut,*iButrep;

		PCParticleSpawnDlgProc(PCloudParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void PCParticleSpawnDlgProc::Update(TimeValue t)
{ if (!po->editOb) return;
	po->SetUpList();
	float width;
	po->pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
	if (width<0.01f) iBut->Disable();else iBut->Enable();
	po->SetUpLifeList();
	if (width<0.01f) iButrep->Disable();
	else
	{ po->pickCB.repi= SendMessage(GetDlgItem(po->spawn,IDC_AP_OBJECTQUEUE),
					LB_GETCURSEL,0,0);
	  if (po->pickCB.repi<0) iButrep->Disable();
	  else iButrep->Enable();
	}
	int stype,chunky;
	po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
	po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
//	AllSpawnBad(po->spawn,stype,chunky!=METABALLS);
    int ison; po->pblock->GetValue(PB_PCIPCOLLIDE_ON,0,ison,FOREVER);
    if (ison) stype=0;
	SpawnStuff(po->spawn,stype);
//	PCCheckSpawnButtons(po->pblock,po->spawn,po->pickCB.repi);
	if (chunky==INSTGEOM)
	  PCCheckSpawnButtons(po->pblock,po->spawn,po->pickCB.repi);
	 else 
	 { ObjectMutQueOff(po->spawn);
	   PCCheckLifeButtons(stype,po->spawn);
	 }
	if (stype==EMIT) SpinnerOff(po->spawn,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);
}

BOOL PCParticleSpawnDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{  int dtype=2,stype,rep;	
	switch (msg) {
		case WM_INITDIALOG: 
		{ iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUEPICK));
		  iBut->SetType(CBT_CHECK);
		  iBut->SetHighlightColor(GREEN_WASH);
		  iButrep = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJQUEUEREPLACE));
		  iButrep->SetType(CBT_CHECK);
		  iButrep->SetHighlightColor(GREEN_WASH);
		  Update(t);
		  break;
		}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			ReleaseICustButton(iButrep);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{   case IDC_AP_NOSPAWN:stype=0;goto spawnradio;
			  case IDC_AP_COLLIDEDIE:
				  stype=1;goto spawnradio;
			  case IDC_AP_SPAWNTRAILS:stype=EMIT;goto spawnradio;
			  case IDC_AP_COLLIDESPAWN:
			  case IDC_AP_DEATHSPAWN: stype=2;
			spawnradio:	
				int chunky;
			po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
//			AllSpawnBad(po->spawn,stype,chunky!=METABALLS);
				int ison; po->pblock->GetValue(PB_PCIPCOLLIDE_ON,0,ison,FOREVER);
				if (ison) stype=0;
				SpawnStuff(po->spawn,stype);		
				 if (chunky==INSTGEOM)
					PCCheckSpawnButtons(po->pblock,hWnd,po->pickCB.repi);
				 else 
				 {	 ObjectMutQueOff(po->spawn);
				    PCCheckLifeButtons(stype,po->spawn);
				 }
				 if (stype==EMIT) SpinnerOff(po->spawn,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);
			   break;
			case IDC_AP_OBJECTQUEUE:
				{ po->pickCB.repi= SendMessage(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUE),
							LB_GETCURSEL,0,0);
			    TurnButton(hWnd,IDC_AP_OBJQUEUEREPLACE,po->pickCB.repi>-1);
			    TurnButton(hWnd,IDC_AP_OBJQUEUEDELETE,po->pickCB.repi>-1);
				break;
				}
			   case IDC_AP_OBJECTQUEUEPICK:
			      dtype=2;goto dopick;
				case IDC_AP_OBJQUEUEREPLACE:
				  dtype=3;
				  dopick:
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreatePCloudMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePCloudMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;
					      po->pickCB.dodist=dtype;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
				case IDC_AP_OBJQUEUEDELETE:
				{  int i = SendMessage(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUE),
							LB_GETCURSEL,0,0);
					if ((po->nlist.Count()>0)&&(i>-1))
					{	theHold.Begin();
						po->DeleteFromList(i,0);
						theHold.Accept(GetString(IDS_AP_OBJDEL));}
						TurnButton(hWnd,IDC_AP_OBJQUEUEREPLACE,0);
						TurnButton(hWnd,IDC_AP_OBJQUEUEDELETE,0);
					break;
				}
				case IDC_AP_LIFEQUEUEDEL:
				{  int i = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),
							LB_GETCURSEL,0,0);
					int Lcnt=po->llist.Count();
					if ((Lcnt>0)&&(i>-1)&&(i<Lcnt))
					{	theHold.Begin();
						theHold.Put(new PCLifeListRestore(po));
						po->DeleteFromLifeList(i);
						TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
						TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,0);
						theHold.Accept(GetString(IDS_AP_LIFEDEL));
					}
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					break;
				}
				case IDC_AP_LIFEQUEUEADD:
				{   int i;
					po->pblock->GetValue(PB_SPAWNLIFEVLUE,t,i,FOREVER);
					theHold.Begin();
					theHold.Put(new PCLifeListRestore(po));
					po->AddToLifeList(i);
				    TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
					TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,0);
					theHold.Accept(GetString(IDS_AP_LIFEADD));
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					break;
				}
				case IDC_AP_LIFEQUEUE:
				{ rep = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),LB_GETCURSEL,0,0);
				  TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,rep>-1);
				  TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,rep>-1);
				  break;
				}
				case IDC_AP_LIFEQUEUEREPL:
				{ int i;
				rep = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),
							LB_GETCURSEL,0,0);
				  if (rep>-1)
				  {	po->pblock->GetValue(PB_SPAWNLIFEVLUE,t,i,FOREVER);
					theHold.Begin();
					theHold.Put(new PCLifeListRestore(po));
					po->llist[rep]=i;
					po->SetUpLifeList();
				    TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
					TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,0);
					theHold.Accept(GetString(IDS_AP_LIFEREP));
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				  }
					break;
				}
				
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
}

void PCloudParticle::GetFilename(TCHAR *filename)
{   _tcscpy(filename,ip->GetDir(APP_PLUGCFG_DIR));
  int len= _tcslen(filename);
  if (len)
  {  if (filename[len-1]!=_T('\\'))
		  _tcscat(filename,_T("\\"));
  }
  _tcscat(filename,GetString(IDS_AP_PCLOUDCST));
}

void PCloudParticle::SetupTargetList()		
	{TCHAR filename[MAX_PATH];
     FILE *f;
	 int vers,i,future,osize;

	custsettings=0;
    GetFilename(filename);
	BOOL fileok=TRUE;
	if ((f = _tfopen(filename, _T("rb"))) == NULL) return;
	if((ReadInt(&custsettings,f))&&(ReadInt(&vers,f))&&(ReadInt(&osize,f))&&(ReadInt(&future,f)))
	{ if ((vers!=CURRENT_VERSION)&&(fileok=GenNewSaveFile(osize,size,custsettings,f,filename,CURRENT_VERSION)))
		{fileok=((ReadInt(&custsettings,f))&&(ReadInt(&vers,f))&&(ReadInt(&osize,f))&&(ReadInt(&future,f)));
		}
	if (fileok&&(vers==CURRENT_VERSION))
	{ NameLst=new AName[custsettings]; 
	  for (i=0;i<custsettings;i++)
	  if (fread(NameLst[i],NLEN,1,f)==1)
	    fseek(f,size,SEEK_CUR);
	  else goto onerr;
	}}
	onerr:if (i<custsettings) 
	{ custsettings=0;
	MessageBox (NULL,GetString(IDS_RB_BADFILE),
            "", MB_ICONINFORMATION);
	}
	if (fileok) fclose(f);
	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
	for (i=0; i<custsettings; i++) {
		SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);
		}
	}
int PCloudParticle::RemSettings(int overwrite,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  long startpt;
  int vers,newsets,future=0,baselen=size+NLEN;
  GetFilename(filename);
  vers=CURRENT_VERSION;
  newsets=custsettings-1;
  if ((f = _tfopen(filename,_T("r+b"))) == NULL) 
  { MessageBox(NULL,GetString(IDS_AP_WRITEPRO),"", MB_ICONINFORMATION);
	return 0;
  }
  if (custsettings==1) 
  {fclose(f);remove(filename);custsettings=0;delete[] NameLst;NameLst=NULL;
    SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
   return (1);}
 if (!WriteInt(&newsets,f)) {fclose(f);return 0;}
  startpt=overwrite*(baselen)+HLEN;
  fseek(f,startpt,SEEK_SET); 
  int i;
  BYTE *buf;
  buf=new BYTE[baselen];
  assert(buf);
  long cpos=startpt;
  for (i=overwrite+1;i<custsettings;i++)
  {	fseek(f,cpos+baselen,SEEK_SET);
	if (fread(buf,baselen,1,f)!=1) {delete[] buf;fclose(f);return 0;}
	fseek(f,cpos,SEEK_SET);
	if (fwrite(buf,baselen,1,f)!=1) {delete[] buf;fclose(f);return 0;}
	cpos+=baselen;
  }
  delete[] buf;
  _chsize(_fileno(f),ftell(f));
  fclose(f);								  
  AName *Tmp=new AName[custsettings-1];
  int newi=0;
  for (i=0;i<custsettings;i++)
  { if (i!=overwrite) 
      _tcscpy(Tmp[newi++],NameLst[i]);}
  delete []NameLst;NameLst=Tmp;
  custsettings--;
  SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
  for (i=0; i<custsettings; i++) 
  {	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);	}
  return(1);
}
int PCloudParticle::SaveSettings(int overwrite,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  int vers,newsets,future=0;

  if ((overwrite>-1)&&(MessageBox (NULL,GetString(IDS_AP_SETEXISTS),GetString(IDS_AP_WARNING), MB_ICONQUESTION | MB_YESNO ) == IDNO))
	 return 0;
  GetFilename(filename);
  vers=CURRENT_VERSION;
  newsets=custsettings+1;
  if ((f = _tfopen(filename,(custsettings==0?_T("wb"):_T("r+b")))) == NULL)
  { MessageBox(NULL,GetString(IDS_AP_WRITEPRO),"", MB_ICONINFORMATION);
	return 0;
  }
  // longest one
  ParamBlockDescID *descVer=spdescVer5;
  int plength=(PBLOCK_LENGTH_PCLOUD);
  if (custsettings==0)
  { if (!(WriteInt(&newsets,f)&&WriteInt(&vers,f)&&WriteInt(&size,f)&&WriteInt(&future,f))) goto errend;
  } 
  else 
  { if (overwrite>=0) 
    { overwrite=overwrite*(size+NLEN)+HLEN;
      fseek(f,overwrite,SEEK_SET); }
    else 
	{ if (!WriteInt(&newsets,f)) goto errend;
	  fseek(f,0,SEEK_END);
	}
  }	 
  int ival,i;
  float fval;
  if (fwrite(newname,1,NLEN,f)!=NLEN) goto errend;
  for (i=0;i<plength;i++)
  {	if (descVer[i].type==TYPE_INT) 
    { pblock->GetValue(i,0,ival,FOREVER);
      if (fwrite(&ival,isize,1,f)!=1) goto errend;
	}
    else
    { pblock->GetValue(i,0,fval,FOREVER);
      if (fwrite(&fval,fsize,1,f)!=1) goto errend;
	}
  }
  fclose(f);
  if (overwrite<0) 
  { AName *Tmp=new AName[custsettings+1];
    memcpy(Tmp,NameLst,sizeof(AName)*custsettings);
	delete []NameLst;NameLst=Tmp;
    _tcscpy(NameLst[custsettings],newname);
	custsettings++;
	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
	for (int i=0; i<custsettings; i++) {
		SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);
		}
  }  
  return(1);
errend: fclose(f);return(0);
}
int PCloudParticle::GetSettings(int setnum,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  GetFilename(filename);
  if ((f = _tfopen(filename,_T("rb"))) == NULL) return 0;
  { setnum=setnum*(size+NLEN)+HLEN;
    fseek(f,setnum,SEEK_SET); 
  }	 
  int ival,i;
  float fval;
  // longest one
  ParamBlockDescID *descVer=spdescVer5;
  int plength=(PBLOCK_LENGTH_PCLOUD);
  if (fread(newname,1,NLEN,f)!=NLEN) goto errend;
  for (i=0;i<plength;i++)
  {	if (descVer[i].type==TYPE_INT) 
    { if (fread(&ival,isize,1,f)!=1) goto errend;
	  pblock->SetValue(i,0,ival);
	}
    else
    { if (fread(&fval,fsize,1,f)!=1) goto errend;
//	  if (i!=PB_EMITRWID) 
		  pblock->SetValue(i,0,fval);
	}
  }
  fclose(f);
  InvalidateUI();							
  return(1);
  errend: fclose(f);return(0);
}

static BOOL CALLBACK CustomSettingParamDlgProc( 
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{ TCHAR newname[NLEN];
  int i,save=0;
  PCloudParticle *po = (PCloudParticle*)GetWindowLong(hWnd,GWL_USERDATA);
  if (!po && message!=WM_INITDIALOG) return FALSE;

  switch (message) {
		case WM_INITDIALOG: {
			po = (PCloudParticle*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			po->custCtrlEdit = GetICustEdit(GetDlgItem(hWnd,IDC_SP_SETEDIT));
			po->custCtrlEdit->SetText(_T(""));
			po->hParams2 = hWnd;
			po->SetupTargetList();
			break;
			}
		case WM_COMMAND:
			{ switch(LOWORD(wParam)) {
				case IDC_SP_SETLIST:  
					if (HIWORD(wParam)==LBN_DBLCLK)
					  goto doload;
					break;
				case IDC_SP_DELETE:  
					i = SendMessage(GetDlgItem(po->hParams2,IDC_SP_SETLIST),
							LB_GETCURSEL,0,0);
					   if ((i>-1)&&(po->custsettings>0))
					   { po->custCtrlEdit->GetText(newname,NLEN);
						 if (_tcscmp(newname,po->NameLst[i])==0)
						   po->custCtrlEdit->SetText(_T(""));
					     po->RemSettings(i,po->NameLst[i]);
					   }
					break;
				case IDC_SP_SAVE:
				   save=1;
				case IDC_SP_LOAD:
					doload:
					if (!save)
					{ i = SendMessage(GetDlgItem(po->hParams2,IDC_SP_SETLIST),
							LB_GETCURSEL,0,0);
					   if ((i>-1)&&(po->custsettings>0))
					    po->custCtrlEdit->SetText(po->NameLst[i]);
					}
				    po->custCtrlEdit->GetText(newname,NLEN);
					if (save) 
					{int tstblk=0,tstlen=_tcslen(newname);
					  while ((tstblk<tstlen)&&(newname[tstblk]==' ')) tstblk++;
					  if (tstblk>=tstlen) 
						MessageBox (NULL,GetString(IDS_RB_NONAME),
            "", MB_ICONINFORMATION);
					  else 
					  { i=0;
					    while ((i<po->custsettings)&&(_tcscmp(newname,po->NameLst[i])))
					     i++;
						if (i>=po->custsettings) i=-1;
					    po->SaveSettings(i,newname);
					  }
					}
					else if ((i>-1)&&(i<po->custsettings))
					{ po->GetSettings(i,newname);
					  int chunky;
			          po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
					  if (chunky==METABALLS) MetaIn(po,po->hptype,po->ip->GetTime());
				      else 
					  { int stype;
					    po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
//						AllSpawnBad(po->spawn,stype,TRUE);
						int ison; po->pblock->GetValue(PB_PCIPCOLLIDE_ON,0,ison,FOREVER);
						if (ison) stype=0;
						SpawnStuff(po->spawn,stype);
						if (chunky==0) StdOn(po,po->hptype,po->ip->GetTime());
					    else InstOn(po,po->hptype,po->ip->GetTime());
					    if (stype==EMIT) SpinnerOff(po->spawn,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);
					  }
					  PCCheckSpawnButtons(po->pblock,po->spawn,po->pickCB.repi=0);
				 if (chunky==INSTGEOM)
				 { int onscreen;
				   po->pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
				   if (onscreen>1)
				   { int subtree,custmtl=0,anioff;
					TimeValue t=po->ip->GetTime();
					 po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
					 po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  				 po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					 TimeValue aniend=GetAnimEnd();
					 int anifr=aniend+GetTicksPerFrame();
					 po->GetTimes(po->times,t,anifr,anioff);
					 if (onscreen==2)
						 po->GetMesh(po->ip->GetTime(),subtree,custmtl);
						else po->GetallBB(po->custnode,subtree,po->ip->GetTime());
				   }
				 }
					  po->ip->RedrawViews(po->ip->GetTime()); 
					}
					else MessageBox (NULL,GetString(IDS_RB_BADNAME),
            "", MB_ICONINFORMATION);
					break;
				}
			break;
			}

		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustEdit(po->custCtrlEdit);
			if (po->NameLst) {delete []po->NameLst;po->NameLst=NULL;}
			return FALSE;
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			po->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;
		
		default:	return FALSE;		
		}
	return TRUE;
	}	


//--- PCloudParticle Methods--------------------------------------------
TimeValue PCloudParticle::ParticleLife(TimeValue t, int i)
{   int pcount=parts.Count();
	if (!(i<pcount)) return 0.0f;
	return sdata[i].L;
}
void PCloudParticle::ResetSystem(TimeValue t,BOOL full)
{	lc.lastmin=-1;lc.lastcollide=-1;
	rcounter=0;
	vcounter=0;
	if (full)
	{ tvalid = t;
	  valid  = TRUE;
	}
}

Point3 PCloudParticle::ParticlePosition(TimeValue t,int i)
{	int pcount=parts.points.Count();
	if (!(i<pcount)) return Zero;
	Point3 FinalP=parts.points[i];
// figure out particle class
	int isinst;
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
// if we have custom geometry, find the center of the bounding box and velocity normal
	if ((isinst==INSTGEOM)&&(custnode))
	{	int anioff;
		float dlgsize;
		dlgsize=parts.radius[i];
		float zoffset=0.0f;
		Point3 OffsetV=Zero;;
		TimeValue aniend=GetAnimEnd();
		int anifr=aniend+GetTicksPerFrame();
		pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
		TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		int nCount=nlist.Count();
		int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum));
		if (mnum>=0) zoffset=cmbb[mnum].Center().z;
// if we're using DoT/MBlur, account for scaling due to stretch
		int axisentered;
		pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
		if (axisentered==DIRTRAVEL)
		{	int K;
			pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			float strlen=GetLen(parts.vels[i],K);
			zoffset*=strlen;
		}
		float lenV=Length(parts.vels[i]);
		if (lenV>EPSILON) OffsetV=parts.vels[i]/lenV;
		FinalP+=zoffset*dlgsize*OffsetV;
	}
	return FinalP;
}

Point3 PCloudParticle::ParticleVelocity(TimeValue t,int i)
{	Point3 retvel=Zero;
	int pcount=parts.vels.Count();
	if (i<pcount)
		retvel=parts.vels[i];
	return retvel;
}

float PCloudParticle::ParticleSize(TimeValue t,int i)
{	float strlen=1.0f;
	float boxlen=1.0f;
	float dlgsize;
	int axisentered,K,isinst,ptype;
// get the size/scale from the dialog box processed for this particle...
	dlgsize=parts.radius[i];
// figure out particle type and class
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
// if there are custom particles, find bounding box params...
	if ((isinst==INSTGEOM)&&(custnode))
	{	int anioff;
		TimeValue aniend=GetAnimEnd();
		int anifr=aniend+GetTicksPerFrame();
		pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
		TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		int nCount=nlist.Count();
		int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum));
		if (mnum>=0) boxlen=cmbb[mnum].Width().z;
	}
// if we're using MBlur and DoT then account for scaling along DoT
	pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	if (axisentered==DIRTRAVEL)
	{	pblock->GetValue(PB_STRETCH,t,K,FOREVER);
		strlen=GetLen(parts.vels[i],K);
	}
	float templen=boxlen*strlen;
	if ((isinst!=PB_PARTICLECLASS)&&(ptype==RENDTET)) templen*=1.3f;
	return templen*dlgsize;	
}

int PCloudParticle::ParticleCenter(TimeValue t,int i)
{	int ptype,isinst;
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	if (isinst==INSTGEOM) return PARTCENTER_CENTER;
	if (ptype==RENDTET) return PARTCENTER_HEAD;
	return PARTCENTER_CENTER;	
}

int PCloudParticle::RenderBegin(TimeValue t, ULONG flags)
	{	SetAFlag(A_RENDER);
  		ParticleInvalid();		
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		cancelled=FALSE;
		int isinst;
		pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
		if ((isinst==INSTGEOM) &&(custnode))
			custnode->SetProperty(PROPID_FORCE_RENDER_MESH_COPY,(void *)1);
	return 0;
	}

int PCloudParticle::RenderEnd(TimeValue t)
	{
		ClearAFlag(A_RENDER);
		ParticleInvalid();		
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		int isinst;
		pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
		if ((isinst==INSTGEOM) &&(custnode))
			custnode->SetProperty(PROPID_FORCE_RENDER_MESH_COPY,(void *)0);
/*		TimeValue aniend=GetAnimEnd();
	int subtree,onscreen,custmtl=0;
	pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	if ((frag==INSTGEOM)&&(onscreen>1)&&(custnode))
	{ pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
      pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
	  thePCloudDraw.anioff=anioff;
      thePCloudDraw.anifr=aniend+GetTicksPerFrame();
	  thePCloudDraw.t=t;
	  int anioff;
	  pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	  if (anioff>0)
	   GetTimes(times,thePCloudDraw.t,thePCloudDraw.anifr,anioff);
	  else times.tl.ZeroCount();
	  if (onscreen==2)
	   GetMesh(t,subtree,custmtl);
	  else GetallBB(custnode,subtree,t);
	}*/
	return 0;
	}

void PCloudParticle::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{ 
	SimpleParticle::BeginEditParams(ip,flags,prev);
	editOb = this;
	this->ip = ip;

	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }
	if (pmapParam && pmapPGen && pmapPType && pmapPSpin && pmapEmitV && pmapBubl && pmapSpawn) 
	{	pmapParam->SetParamBlock(pblock);
		pmapPGen->SetParamBlock(pblock);
		pmapPType->SetParamBlock(pblock);
		pmapPSpin->SetParamBlock(pblock);
		pmapEmitV->SetParamBlock(pblock);
		pmapBubl->SetParamBlock(pblock);
		pmapSpawn->SetParamBlock(pblock);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)this);
	} else 
	{ 		pmapParam = CreateCPParamMap(
			descParamPCloud,PARAMPCLOUD_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_PARTICLECLOUD),
			GetString(IDS_RB_PARAMETERS),
			dflags&APRTS_ROLLUP1_OPEN?0:APPENDROLL_CLOSED);

		pmapPGen = CreateCPParamMap(
			descParamPGen,PARAMPGEN_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_GEN_PC),
			GetString(IDS_RB_PGEN),
			dflags&APRTS_ROLLUP2_OPEN?0:APPENDROLL_CLOSED);
		
		pmapPType = CreateCPParamMap(
			descParamPType,PARAMPTYPE_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_PARTTYPE_PC),
			GetString(IDS_RB_PTYPE),
			dflags&APRTS_ROLLUP3_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapPSpin = CreateCPParamMap(
			descParamPSpin,PARAMPSPIN_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_ROT),
			GetString(IDS_RB_SPIN),
			dflags&APRTS_ROLLUP4_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapEmitV = CreateCPParamMap(
			descParamEmitV,PARAMEMITV_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_EMITV),
			GetString(IDS_RB_EMITV),
			dflags&APRTS_ROLLUP5_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapBubl = CreateCPParamMap(
			descParamBubl,PARAMBUBL_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_BUBL),
			GetString(IDS_RB_BUBL),
			dflags&APRTS_ROLLUP6_OPEN?0:APPENDROLL_CLOSED);		
		pmapSpawn = CreateCPParamMap(
			descPSpawning,PSPAWNINGPARAMS_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_SPAWNING),
			GetString(IDS_AP_PSPAWN),
			dflags&APRTS_ROLLUP7_OPEN?0:APPENDROLL_CLOSED);		
	
		hParams2 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SUPRPRTS_SAVE),
				CustomSettingParamDlgProc, 
				GetString(IDS_RB_LOADSAVE), 
				(LPARAM)this,dflags&APRTS_ROLLUP8_OPEN?0:APPENDROLL_CLOSED);		
		ip->RegisterDlgWnd(hParams2);
		fragflags=-1;

		}
	spawn=pmapSpawn->GetHWnd();
	hparam=pmapParam->GetHWnd();
	hgen=pmapPGen->GetHWnd();
	hptype=pmapPType->GetHWnd();
	hrot=pmapPSpin->GetHWnd();
	hbubl=pmapBubl->GetHWnd();
	if (pmapParam) pmapParam->SetUserDlgProc(new PCParticleParmDlgProc(this));
	if (pmapPType) pmapPType->SetUserDlgProc(new PCParticleDisableDlgProc(this));
	if (pmapPGen) pmapPGen->SetUserDlgProc(new PCParticleGenDlgProc(this));
	if (pmapSpawn) pmapSpawn->SetUserDlgProc(new PCParticleSpawnDlgProc(this));
	if (pmapPSpin) pmapPSpin->SetUserDlgProc(new PCParticleSpinDlgProc(this));
}	

void PCloudParticle::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
{ TimeValue t0,t2;
	SetFlag(dflags,APRTS_ROLLUP1_OPEN,IsRollupPanelOpen(hparam));
	SetFlag(dflags,APRTS_ROLLUP2_OPEN,IsRollupPanelOpen(hgen));
	SetFlag(dflags,APRTS_ROLLUP3_OPEN,IsRollupPanelOpen(hptype));
	SetFlag(dflags,APRTS_ROLLUP4_OPEN,IsRollupPanelOpen(hrot));
	SetFlag(dflags,APRTS_ROLLUP5_OPEN,IsRollupPanelOpen(pmapEmitV->GetHWnd()));
	SetFlag(dflags,APRTS_ROLLUP6_OPEN,IsRollupPanelOpen(hbubl));
	SetFlag(dflags,APRTS_ROLLUP7_OPEN,IsRollupPanelOpen(spawn));
	SetFlag(dflags,APRTS_ROLLUP8_OPEN,IsRollupPanelOpen(hParams2));
	SimpleParticle::EndEditParams(ip,flags,next);

	if (flags&END_EDIT_REMOVEUI) {
		pblock->GetValue(PB_EMITSTART,0,t0,FOREVER);
		pblock->GetValue(PB_EMITSTOP,0,t2,FOREVER);
		if (t2<t0) pblock->SetValue(PB_EMITSTOP,0,t0);
		DestroyCPParamMap(pmapParam);
		DestroyCPParamMap(pmapPGen);
		DestroyCPParamMap(pmapPType);
		DestroyCPParamMap(pmapPSpin);
		DestroyCPParamMap(pmapEmitV);
		DestroyCPParamMap(pmapBubl);
		DestroyCPParamMap(pmapSpawn);

		ip->UnRegisterDlgWnd(hParams2);
		ip->DeleteRollupPage(hParams2);
		hParams2 = NULL;

		pmapParam  = NULL;
		pmapPGen = NULL;
		pmapPType = NULL;
		pmapPSpin = NULL;
		pmapEmitV = NULL;
		pmapBubl = NULL;
		pmapSpawn = NULL;
		hgen=NULL;
	}else
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)NULL);
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
}

void PCloudParticle::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_EMITSTART,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_EMITSTART,0,TempTime);
	pblock->GetValue(PB_EMITSTOP,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_EMITSTOP,0,TempTime);
	pblock->GetValue(PB_DISPUNTIL,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_DISPUNTIL,0,TempTime);
// scaled values
	pblock->GetValue(PB_LIFE,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_LIFE,0,TempTime);
	pblock->GetValue(PB_LIFEVAR,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_LIFEVAR,0,TempTime);
	pblock->GetValue(PB_GROWTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_GROWTIME,0,TempTime);
	pblock->GetValue(PB_FADETIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_FADETIME,0,TempTime);
	pblock->GetValue(PB_MAPPINGTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_MAPPINGTIME,0,TempTime);
	pblock->GetValue(PB_SPINTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_SPINTIME,0,TempTime);
	pblock->GetValue(PB_BUBLPER,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_BUBLPER,0,TempTime);
//	pblock->GetValue(PB_OFFSETAMOUNT,0,TempTime,FOREVER);
//	TempTime=map->map(TempTime);
//	pblock->SetValue(PB_OFFSETAMOUNT,0,TempTime);
}  

Interval PCloudParticle::GetValidity(TimeValue t)
	{
	// For now...
	return Interval(t,t);
	}

void PCloudParticle::BuildEmitter(TimeValue t, Mesh& amesh)
	{
	float width,height,depth,wholewid;
	int sym,csymv=20,csymf=18,startv,startf;
	mvalid = FOREVER;
    pblock->GetValue(PB_CREATEIN,0,sym,FOREVER);
	pblock->GetValue(PB_EMITRWID,t,height,mvalid);
	pblock->GetValue(PB_EMITRHEIGHT,t,width,mvalid);
	pblock->GetValue(PB_EMITRDEPTH,t,depth,mvalid);
	wholewid=width;
	width  *= 0.5f;
	height  *= 0.5f;
	depth  *= 0.5f;

	if (sym==0)
	{ mesh.setNumVerts(9+csymv);startv=9;
	  mesh.setNumFaces(12+csymf);startf=12;
	  mesh.setVert(0, Point3(-width,-height, depth));
	  mesh.setVert(1, Point3( width,-height, depth));
	  mesh.setVert(2, Point3( width, height, depth));
	  mesh.setVert(3, Point3(-width, height, depth));
	  mesh.setVert(4, Point3(-width,-height, -depth));
	  mesh.setVert(5, Point3( width,-height, -depth));
	  mesh.setVert(6, Point3( width, height, -depth));
	  mesh.setVert(7, Point3(-width, height, -depth));
	  mesh.setVert(8, Point3(0,0,0));

	  mesh.faces[0].setEdgeVisFlags(1,0,1);
	  mesh.faces[0].setSmGroup(0);
	  mesh.faces[0].setVerts(0,1,3);

	  mesh.faces[1].setEdgeVisFlags(1,1,0);
	  mesh.faces[1].setSmGroup(0);
	  mesh.faces[1].setVerts(1,2,3);

	  mesh.faces[2].setEdgeVisFlags(1,1,0);
	  mesh.faces[2].setSmGroup(0);
	  mesh.faces[2].setVerts(1,0,4);
 
	  mesh.faces[3].setEdgeVisFlags(1,0,1);
	  mesh.faces[3].setSmGroup(0);
	  mesh.faces[3].setVerts(5,1,4);

	  mesh.faces[4].setEdgeVisFlags(0,1,1);
	  mesh.faces[4].setSmGroup(0);
	  mesh.faces[4].setVerts(5,2,1);

	  mesh.faces[5].setEdgeVisFlags(1,1,0);
	  mesh.faces[5].setSmGroup(0);
	  mesh.faces[5].setVerts(5,6,2);

	  mesh.faces[6].setEdgeVisFlags(1,0,1);
	  mesh.faces[6].setSmGroup(0);
	  mesh.faces[6].setVerts(2,6,3);

	  mesh.faces[7].setEdgeVisFlags(1,1,0);
	  mesh.faces[7].setSmGroup(0);
	  mesh.faces[7].setVerts(6,7,3);

	  mesh.faces[8].setEdgeVisFlags(1,1,0);
	  mesh.faces[8].setSmGroup(0);
	  mesh.faces[8].setVerts(0,3,7);

	  mesh.faces[9].setEdgeVisFlags(1,0,1);
	  mesh.faces[9].setSmGroup(0);
	  mesh.faces[9].setVerts(4,0,7);

	  mesh.faces[10].setEdgeVisFlags(0,1,1);
	  mesh.faces[10].setSmGroup(0);
	  mesh.faces[10].setVerts(6,4,7);

	  mesh.faces[11].setEdgeVisFlags(1,1,0);
	  mesh.faces[11].setSmGroup(0);
	  mesh.faces[11].setVerts(6,5,4);
	}
	else if (sym==1)
	{ float u,cu,su;
	  #define NUM_SEGS 12
	  startf=3*NUM_SEGS;
	  startv=startf+1;
	  mesh.setNumVerts(startv+csymv);
	  mesh.setNumFaces(startf+csymf);

	  for (int i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			cu=(float)cos(u)*height;su=(float)sin(u)*height;
			mesh.setVert(i, Point3(cu, su, 0.0f));
			mesh.setVert(i+NUM_SEGS, Point3(0.0f, cu, su));
			mesh.setVert(i+2*NUM_SEGS, Point3(cu, 0.0f, su));
			}
	  mesh.setVert(3*NUM_SEGS, Point3(0.0f, 0.0f, 0.0f));
		
	  for (i=0; i<3*NUM_SEGS; i++) {
			int i1 = i+1;
			if (i1%NUM_SEGS==0) i1 -= NUM_SEGS;
			mesh.faces[i].setEdgeVisFlags(1,0,0);
			mesh.faces[i].setSmGroup(0);
			mesh.faces[i].setVerts(i,i1,3*NUM_SEGS);
			}
	}
	else if (sym==2)
	{ float u,cu,su;
	  #define NUM_SEGS 12
	  startv=(startf=2*NUM_SEGS);
	  mesh.setNumVerts(startv+csymv);
	  mesh.setNumFaces(startf+csymf);
      
	  for (int i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			cu=(float)cos(u)*height;su=(float)sin(u)*height;
			mesh.setVert(i, Point3(cu, su, depth));
			mesh.setVert(i+NUM_SEGS, Point3(cu,su, -depth));
			}
	  int il=NUM_SEGS;
	  i=0;	
	  for (int f=0; f<2*NUM_SEGS; f+=2) {
			int i1 = i+1,i2=il+1;
			if (i1%NUM_SEGS==0) {i1 -= NUM_SEGS;i2-=NUM_SEGS;}
			mesh.faces[f].setEdgeVisFlags(1,0,1);
			mesh.faces[f].setSmGroup(0);
			mesh.faces[f].setVerts(i,il,i1);
			mesh.faces[f+1].setEdgeVisFlags(1,1,0);
			mesh.faces[f+1].setSmGroup(0);
			mesh.faces[f+1].setVerts(il,i2,i1);
			il++;i++;
			}
	}
	else
	{ mesh.setNumVerts(35);
	  mesh.setNumFaces(28);
/*	  if (distnode)
	  { Object *cobj=distnode->EvalWorldState(t).obj;
		TriObject *triOb=TriIsUseable(cobj,t);
		if (triOb)
		{ Box3 bbox=triOb->mesh.getBoundingBox();
		  Point3 lens=(bbox.pmax-bbox.pmin)/2.0f;
		  width=lens.x;
	      height=lens.y;
	      depth=lens.z;
		}
	  }*/
	  width=2*height;depth=height;wholewid=width*2;
	  mesh.setVert(0, Point3(-width,-height, depth));
	  mesh.setVert(1, Point3( width,-height, depth));
	  mesh.setVert(2, Point3( width, height, depth));
	  mesh.setVert(3, Point3(-width, height, depth));
	  mesh.setVert(4, Point3(-width,-height, -depth));
	  mesh.setVert(5, Point3( width,-height, -depth));
	  mesh.setVert(6, Point3( width, height, -depth));
	  mesh.setVert(7, Point3(-width, height, -depth));
	  mesh.setVert(8, Point3(0,0,0));

	  mesh.faces[0].setEdgeVisFlags(1,0,1);
	  mesh.faces[0].setSmGroup(0);
	  mesh.faces[0].setVerts(0,1,3);

	  mesh.faces[1].setEdgeVisFlags(1,1,0);
	  mesh.faces[1].setSmGroup(0);
	  mesh.faces[1].setVerts(1,2,3);

	  mesh.faces[2].setEdgeVisFlags(1,1,0);
	  mesh.faces[2].setSmGroup(0);
	  mesh.faces[2].setVerts(1,0,4);
 
	  mesh.faces[3].setEdgeVisFlags(1,0,1);
	  mesh.faces[3].setSmGroup(0);
	  mesh.faces[3].setVerts(5,1,4);

	  mesh.faces[4].setEdgeVisFlags(0,1,1);
	  mesh.faces[4].setSmGroup(0);
	  mesh.faces[4].setVerts(5,2,1);

	  mesh.faces[5].setEdgeVisFlags(1,1,0);
	  mesh.faces[5].setSmGroup(0);
	  mesh.faces[5].setVerts(5,6,2);

	  mesh.faces[6].setEdgeVisFlags(1,0,1);
	  mesh.faces[6].setSmGroup(0);
	  mesh.faces[6].setVerts(2,6,3);

	  mesh.faces[7].setEdgeVisFlags(1,1,0);
	  mesh.faces[7].setSmGroup(0);
	  mesh.faces[7].setVerts(6,7,3);

	  mesh.faces[8].setEdgeVisFlags(1,1,0);
	  mesh.faces[8].setSmGroup(0);
	  mesh.faces[8].setVerts(0,3,7);

	  mesh.faces[9].setEdgeVisFlags(1,0,1);
	  mesh.faces[9].setSmGroup(0);
	  mesh.faces[9].setVerts(4,0,7);

	  mesh.faces[10].setEdgeVisFlags(0,1,1);
	  mesh.faces[10].setSmGroup(0);
	  mesh.faces[10].setVerts(6,4,7);

	  mesh.faces[11].setEdgeVisFlags(1,1,0);
	  mesh.faces[11].setSmGroup(0);
	  mesh.faces[11].setVerts(6,5,4);

	  float h6=height*0.625f,h1=height*0.125f,h3=height*0.375f;
	  float w4=0.4f*wholewid,w3=0.3f*wholewid,w2=0.2f*wholewid,w1=0.1f*wholewid;

	  mesh.setVert(9, Point3(-w4,-h6, 0.0f));
	  mesh.setVert(10, Point3(-w3,-h6, 0.0f));
	  mesh.setVert(11, Point3(-w3,-h1, 0.0f));
	  mesh.setVert(12, Point3(-w2,-h1, 0.0f));
	  mesh.setVert(13, Point3(-w2,h1, 0.0f));
	  mesh.setVert(14, Point3(-w3,h1, 0.0f));
	  mesh.setVert(15, Point3(-w3,h3, 0.0f));
	  mesh.setVert(16, Point3(-w2,h3, 0.0f));
	  mesh.setVert(17, Point3(-w2,h6, 0.0f));
	  mesh.setVert(18, Point3(-w4,h6, 0.0f));
	  mesh.setVert(19, Point3(-w1,-h6, 0.0f));
	  mesh.setVert(20, Point3(0.0f,-h6, 0.0f));
	  mesh.setVert(21, Point3(0.0f,-h1, 0.0f));
	  mesh.setVert(22, Point3(-w1,-h1, 0.0f));
	  mesh.setVert(23, Point3(-w1,h1, 0.0f));
	  mesh.setVert(24, Point3(0.0f,h1, 0.0f));
	  mesh.setVert(25, Point3(0.0f,h3, 0.0f));
	  mesh.setVert(26, Point3(-w1,h3, 0.0f));
	  mesh.setVert(27, Point3(w1,-h6, 0.0f));
	  mesh.setVert(28, Point3(w2,-h6, 0.0f));
	  mesh.setVert(29, Point3(w2,h6, 0.0f));
	  mesh.setVert(30, Point3(w1,h6, 0.0f));
	  mesh.setVert(31, Point3(w3,-h6, 0.0f));
	  mesh.setVert(32, Point3(w4,-h6, 0.0f));
	  mesh.setVert(33, Point3(w4,h6, 0.0f));
	  mesh.setVert(34, Point3(w3,h6, 0.0f));

	  mesh.faces[12].setEdgeVisFlags(1,1,0);
	  mesh.faces[12].setSmGroup(0);
	  mesh.faces[12].setVerts(9,10,11);

	  mesh.faces[13].setEdgeVisFlags(1,1,0);
	  mesh.faces[13].setSmGroup(0);
	  mesh.faces[13].setVerts(11,12,13);

	  mesh.faces[14].setEdgeVisFlags(1,0,0);
	  mesh.faces[14].setSmGroup(0);
	  mesh.faces[14].setVerts(13,14,11);

	  mesh.faces[15].setEdgeVisFlags(1,0,0);
	  mesh.faces[15].setSmGroup(0);
	  mesh.faces[15].setVerts(14,15,18);

	  mesh.faces[16].setEdgeVisFlags(1,1,0);
	  mesh.faces[16].setSmGroup(0);
	  mesh.faces[16].setVerts(15,16,17);

	  mesh.faces[17].setEdgeVisFlags(1,0,0);
	  mesh.faces[17].setSmGroup(0);
	  mesh.faces[17].setVerts(17,18,15);

	  mesh.faces[18].setEdgeVisFlags(1,0,0);
	  mesh.faces[18].setSmGroup(0);
	  mesh.faces[18].setVerts(18,9,14);

	  mesh.faces[27].setEdgeVisFlags(0,0,0);
	  mesh.faces[27].setSmGroup(0);
	  mesh.faces[27].setVerts(9,11,14);

	  mesh.faces[19].setEdgeVisFlags(1,1,0);
	  mesh.faces[19].setSmGroup(0);
	  mesh.faces[19].setVerts(19,20,21);

	  mesh.faces[20].setEdgeVisFlags(1,1,0);
	  mesh.faces[20].setSmGroup(0);
	  mesh.faces[20].setVerts(21,22,19);

	  mesh.faces[21].setEdgeVisFlags(1,1,0);
	  mesh.faces[21].setSmGroup(0);
	  mesh.faces[21].setVerts(27,28,29);

	  mesh.faces[22].setEdgeVisFlags(1,1,0);
	  mesh.faces[22].setSmGroup(0);
	  mesh.faces[22].setVerts(29,30,27);

	  mesh.faces[23].setEdgeVisFlags(1,1,0);
	  mesh.faces[23].setSmGroup(0);
	  mesh.faces[23].setVerts(31,32,33);

	  mesh.faces[24].setEdgeVisFlags(1,1,0);
	  mesh.faces[24].setSmGroup(0);
	  mesh.faces[24].setVerts(33,34,31);

	  mesh.faces[25].setEdgeVisFlags(1,1,0);
	  mesh.faces[25].setSmGroup(0);
	  mesh.faces[25].setVerts(23,24,25);

	  mesh.faces[26].setEdgeVisFlags(1,1,0);
	  mesh.faces[26].setSmGroup(0);
	  mesh.faces[26].setVerts(25,26,23);
	}
	if (sym<3)
	{int s0=startv;
	 int f0=startf;
	  float r=height;
	  float r4=0.4f*r,r2=0.2f*r,r6=0.6f*r,r3=0.3f*r;

	  mesh.setVert(startv++, Point3(r6,r2, 0.0f));
	  mesh.setVert(startv++, Point3(r6,r4, 0.0f));
	  mesh.setVert(startv++, Point3(r4,r6, 0.0f));
	  mesh.setVert(startv++, Point3(-r4,r6, 0.0f));
	  mesh.setVert(startv++, Point3(-r6,r4, 0.0f));
	  mesh.setVert(startv++, Point3(-r6,-r4, 0.0f));
	  mesh.setVert(startv++, Point3(-r4,-r6, 0.0f));
	  mesh.setVert(startv++, Point3(r4,-r6, 0.0f));
	  mesh.setVert(startv++, Point3(r6,-r4, 0.0f));
	  mesh.setVert(startv++, Point3(r6,-r2, 0.0f));
	  mesh.setVert(startv++, Point3(r4,-r2, 0.0f));
	  mesh.setVert(startv++, Point3(r4,-r3, 0.0f));
	  mesh.setVert(startv++, Point3(r3,-r4, 0.0f));
	  mesh.setVert(startv++, Point3(-r3,-r4, 0.0f));
	  mesh.setVert(startv++, Point3(-r4,-r3, 0.0f));
	  mesh.setVert(startv++, Point3(-r4,r3, 0.0f));
	  mesh.setVert(startv++, Point3(-r3,r4, 0.0f));
	  mesh.setVert(startv++, Point3(r3,r4, 0.0f));
	  mesh.setVert(startv++, Point3(r4,r3, 0.0f));
	  mesh.setVert(startv++, Point3(r4,r2, 0.0f));

	  mesh.faces[startf].setEdgeVisFlags(1,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+19,s0,s0+1);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+1,s0+18,s0+19);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+18,s0+1,s0+2);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+2,s0+17,s0+18);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+17,s0+2,s0+3);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+3,s0+16,s0+17);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+16,s0+3,s0+4);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+4,s0+15,s0+16);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+15,s0+4,s0+5);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+5,s0+14,s0+15);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+14,s0+5,s0+6);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+6,s0+13,s0+14);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+13,s0+6,s0+7);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+7,s0+12,s0+13);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+12,s0+7,s0+8);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+8,s0+11,s0+12);

	  mesh.faces[startf].setEdgeVisFlags(0,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+11,s0+8,s0+9);

	  mesh.faces[startf].setEdgeVisFlags(1,1,0);
	  mesh.faces[startf].setSmGroup(0);
	  mesh.faces[startf++].setVerts(s0+9,s0+10,s0+11);

	}
	mesh.InvalidateGeomCache();
	}

int PCloudParticle::CountLive()
{	int c=0;
	for (int i=0; i<parts.Count(); i++)
	  {if (parts.Alive(i)) c++;}
	return c;
}

#define DUMSHINE .20f  //.25f
#define DUMSPEC .20f

void PCloudParticle::RetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc,i;
  Mtl *submtl=node->GetMtl();
  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  RetrieveMtls(node->GetChildNode(i),subtree,numsubs,numtabs,tabmax,t);
  }
  if (IsGEOM(node->EvalWorldState(t).obj)!=NULL)
  { if (*numtabs>=*tabmax)
	{ mttab.Resize((*tabmax)+=256);}
	if (submtl!=NULL)
	{ mttab[(*numtabs)++]=submtl;
	  int subs;
	  if ((subs=submtl->NumSubMtls())>0)
	    (*numsubs)+=subs;
	  else (*numsubs)++;
	}
	else 
	{DWORD tc=node->GetWireColor();
	StdMat *m = NewDefaultStdMat();
	m->SetName(TSTR(_T("C"))+node->GetName());
	Color bcolor=Color(tc);
	m->SetDiffuse(bcolor,0);
	mttab[(*numtabs)++]=(Mtl*)m;
	(*numsubs)++;
	}
  }
}

void PCloudParticle::DoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
   for (int i=0;i<nc;i++)
   { INode *nxtnode=node->GetChildNode(i);
	  if (nxtnode->IsGroupHead()) DoGroupMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
	  else if ((subtree)||(nxtnode->IsGroupMember())) RetrieveMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
  }
}

void PCloudParticle::AssignMtl(INode *node,INode *topnode,int subtree,TimeValue t) 
{	Mtl *submtl;
	MultiMtl *newmat=NULL;
	  Mtl *nmtl=NULL;
	TSTR newname;
	MtlBaseLib glib;
	int tabmax=256;
	newname=TSTR(_T("CMat"))+node->GetName();
	if (_tcslen(newname)>16) newname[16]='\0';
	int numsubs=0,numtabs=0;
	nmtls.SetCount(nlist.Count());
    mttab.SetCount(tabmax);
    submtl=custnode->GetMtl();
	INode *tmpnode=custnode;
	backpatch=FALSE;
	int nCount=nlist.Count();
	for (int mut=0;mut<=nCount;mut++)
	{ if (tmpnode->IsGroupHead())
	    DoGroupMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  else
	  RetrieveMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  if (mut!=nCount)
	  {nmtls[mut]=numsubs;
	   tmpnode=nlist[mut];
	  }
	}
	mttab.Shrink();
	if (!((numtabs==1)&&(submtl!=NULL)))
	{ TSTR oldname=TSTR(_T(" "));
	  if (nmtl=node->GetMtl())
		  oldname=nmtl->GetName();
	  if (_tcscmp(oldname,newname)!=0) 
	  { newmat=NewDefaultMultiMtl();
	    newmat->SetName(newname); }
	  else newmat=(MultiMtl*)nmtl;
//	  nmtl->FindMtl(nmtl);
	  newmat->SetNumSubMtls(numsubs);
	  int k=0,nt=0,j;
	  for (int i=0;i<numtabs;i++)
	  {	if ((nt=mttab[i]->NumSubMtls())>0)
	     for (j=0;j<nt;j++) 
		 { newmat->SetSubMtl(k,mttab[i]->GetSubMtl(j));
	       k++;
	     }
	     else 
		 { newmat->SetSubMtl(k,mttab[i]);
		   k++;
		 }
	  }
	}
    mttab.SetCount(0); mttab.Shrink();
	node->SetMtl(newmat!=NULL?newmat:submtl);  
}
void PCloudParticle::CntRetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc,i;
  Mtl *submtl=node->GetMtl();
  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  CntRetrieveMtls(node->GetChildNode(i),subtree,numsubs,numtabs,tabmax,t);
  }
  if (IsGEOM(node->EvalWorldState(t).obj)!=NULL)
  { if (submtl!=NULL)
	{ int subs;
	  if ((subs=submtl->NumSubMtls())>0)
	    (*numsubs)+=subs;
	  else (*numsubs)++;
	}
	else 
	(*numsubs)++;
  }
}

void PCloudParticle::CntDoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
   for (int i=0;i<nc;i++)
   { INode *nxtnode=node->GetChildNode(i);
	  if (nxtnode->IsGroupHead()) CntDoGroupMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
	  else if ((subtree)||(nxtnode->IsGroupMember())) CntRetrieveMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
  }
}

void PCloudParticle::GetSubs(INode *node,INode *topnode,int subtree,TimeValue t) 
{	Mtl *submtl;
	int tabmax=256;
	int numsubs=0,numtabs=0;
	int mstart=0,mcnt=nlist.Count();INode *onode;
	onode=custnode;
	nmtls.SetCount(mcnt);
    submtl=onode->GetMtl();
	INode *tmpnode=onode;
	for (int mut=mstart;mut<=mcnt;mut++)
	{ if (tmpnode->IsGroupHead())
	    CntDoGroupMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  else
	  CntRetrieveMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  if (mut!=mcnt)
	  {nmtls[mut]=numsubs;
	   tmpnode=nlist[mut];
	  }
	}
}

void PCloudParticle::GetNextBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode)
{int i,nc;
	if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  GetNextBB(node->GetChildNode(i),subtree,count,tabmax,boxcenter,t,tcount,onode);
  }
  Object *cobj=node->EvalWorldState(t).obj;
  TriObject *triOb=TriIsUseable(cobj,t);
  if (triOb)
  {	 if (*count>=*tabmax)
	{ thePCloudDraw.bboxpt[tcount].bpts.Resize((*tabmax)+=256);}
    Matrix3 ctm = node->GetObjTMAfterWSM(t);
	if (node!=custnode)
  { thePCloudDraw.bboxpt[tcount].bpts[*count].Suboffset=Point3(0.0f,0.0f,0.0f)*ctm-boxcenter;
  }	
  else thePCloudDraw.bboxpt[tcount].bpts[*count].Suboffset=Point3(0.0f,0.0f,0.0f);
	ctm.NoTrans();
	Box3 bbox=triOb->GetMesh().getBoundingBox();
  thePCloudDraw.bboxpt[tcount].bpts[*count].pts[0]=Point3(bbox.pmax[0],bbox.pmax[1],bbox.pmax[2])*ctm;
  thePCloudDraw.bboxpt[tcount].bpts[*count].pts[1]=Point3(bbox.pmax[0],bbox.pmax[1],bbox.pmin[2])*ctm;
  thePCloudDraw.bboxpt[tcount].bpts[*count].pts[2]=Point3(bbox.pmax[0],bbox.pmin[1],bbox.pmin[2])*ctm;
  thePCloudDraw.bboxpt[tcount].bpts[*count].pts[3]=Point3(bbox.pmax[0],bbox.pmin[1],bbox.pmax[2])*ctm;
  thePCloudDraw.bboxpt[tcount].bpts[*count].pts[4]=Point3(bbox.pmin[0],bbox.pmax[1],bbox.pmax[2])*ctm;
  thePCloudDraw.bboxpt[tcount].bpts[*count].pts[5]=Point3(bbox.pmin[0],bbox.pmax[1],bbox.pmin[2])*ctm;
  thePCloudDraw.bboxpt[tcount].bpts[*count].pts[6]=Point3(bbox.pmin[0],bbox.pmin[1],bbox.pmin[2])*ctm;
  thePCloudDraw.bboxpt[tcount].bpts[*count].pts[7]=Point3(bbox.pmin[0],bbox.pmin[1],bbox.pmax[2])*ctm;
  (*count)++;
	  if (triOb!=cobj) triOb->DeleteThis();
  }
}

void PCloudParticle::DoGroupBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) DoGroupBB(nxtnode,subtree,count,tabmax,boxcenter,t,tcount,onode);
	  else if((subtree)||(nxtnode->IsGroupMember())) GetNextBB(nxtnode,subtree,count,tabmax,boxcenter,t,tcount,onode);
	}
}

void PCloudParticle::GetallBB(INode *custnode,int subtree,TimeValue t)
{ int tabmax=256;
  int count=1,ocount=times.tl.Count();
  if (ocount>0) count=ocount;
  if (thePCloudDraw.bboxpt) delete[] thePCloudDraw.bboxpt;
  thePCloudDraw.bboxpt=NULL;
  INode *tmpnode;
  if (custnode!=NULL)
  { thePCloudDraw.bboxpt=new boxlst[count];
    int cgen;
    for (int tcount=0;tcount<count;tcount++)
    { TimeValue tofs=(ocount>0?times.tl[tcount].tl:t);
	  cgen=(times.tl.Count()>0?times.tl[tcount].gennum-1:-1);
	  if ((cgen>-1)&&(cgen<nlist.Count()))
	  { if (!(tmpnode=nlist[cgen])) tmpnode=custnode;
	  } else tmpnode=custnode;
	  thePCloudDraw.bboxpt[tcount].bpts.SetCount(tabmax);
      thePCloudDraw.bboxpt[tcount].numboxes=0;
      Matrix3 ctm = tmpnode->GetObjTMAfterWSM(tofs);
      boxcenter=Zero*ctm;
	  if (tmpnode->IsGroupHead())
	    DoGroupBB(tmpnode,subtree,&(thePCloudDraw.bboxpt[tcount].numboxes),&tabmax,boxcenter,tofs,tcount,tmpnode);
	  else
      GetNextBB(tmpnode,subtree,&(thePCloudDraw.bboxpt[tcount].numboxes),&tabmax,boxcenter,tofs,tcount,tmpnode);
	  thePCloudDraw.bboxpt[tcount].bpts.SetCount(thePCloudDraw.bboxpt[tcount].numboxes);
	 thePCloudDraw.bboxpt[tcount].bpts.Shrink();
    }
  }
}

void PCloudParticle::CheckTree(INode *node,Matrix3 tspace,Mesh *cmesh,Box3 *cmbb,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl)
{ Object *pobj;	  
  TriObject *triOb;
  Point3 deftex=Point3(0.5f,0.5f,0.0f);
  TVFace Zerod;
  Zerod.t[0]=0;Zerod.t[1]=0;Zerod.t[2]=0;
  int nc,i,j,subv=0,subf=0,subtvnum=0,tface,tvert;

  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  CheckTree(node->GetChildNode(i),tspace,cmesh,cmbb,numV,numF,tvnum,ismapped,t,subtree,custmtl);
  }
  if ((triOb=TriIsUseable(pobj = node->EvalWorldState(t).obj,t))!=NULL)
  {	Point3 Suboffset;
    Matrix3 ctm = node->GetObjTMAfterWSM(t);
/*	if (node!=custnode)
     Suboffset=Point3(0.0f,0.0f,0.0f)*ctm-boxcenter;
	else 
	Suboffset=Point3(0.0f,0.0f,0.0f);
	ctm.NoTrans();*/
	int submtls=0;
	Mtl* m=node->GetMtl();
	if (!((m!=NULL)&&(submtls=m->NumSubMtls()))) 
	  submtls=-1;
	int tottv;
	subv=triOb->GetMesh().getNumVerts();
    subf=triOb->GetMesh().getNumFaces();
    subtvnum=triOb->GetMesh().getNumTVerts();
	(*cmbb)+=(triOb->GetMesh().getBoundingBox()*ctm);
    cmesh->setNumFaces(tface=(*numF+subf),(*numF>0?TRUE:FALSE));
    cmesh->setNumVerts(tvert=(*numV+subv),(*numV>0?TRUE:FALSE));
    cmesh->setNumTVerts(tottv=(*tvnum+subtvnum),(*tvnum>0?TRUE:FALSE));
    if ((subtvnum>0)||(*ismapped))
    { if ((!(*ismapped))&&(*numF>0))
	  { cmesh->setNumTVFaces(tface);
	    *tvnum=1;
		cmesh->setNumTVerts(tottv+1);
		cmesh->tVerts[0]=deftex;
		for (int k=0;k<*numF;k++)
		  memcpy(&(cmesh->tvFace[k]),&Zerod,sizeof(TVFace));
	   }
	  else 
	   cmesh->setNumTVFaces(tface,(*numF>0?TRUE:FALSE),*numF);
	  *ismapped=1;
	}
	if (subf>0) 
	{ memcpy(&(cmesh->faces[*numF]),triOb->GetMesh().faces,sizeof(Face)*subf);
	  if (subtvnum>0)
	    memcpy(&(cmesh->tvFace[*numF]),triOb->GetMesh().tvFace,sizeof(TVFace)*subf);
	}
	j=(*numF);
	BOOL mirror=DotProd(ctm.GetRow(0)^ctm.GetRow(1),ctm.GetRow(2))<0.0f;
	for (j=(*numF);j<tface;j++)
	{ cmesh->faces[j].v[0]+=*numV;
	  cmesh->faces[j].v[1]+=*numV;
	  cmesh->faces[j].v[2]+=*numV;
	  if (mirror) MirrorFace(&cmesh->faces[j]);
	  if (custmtl)
	  { if (submtls<0) cmesh->faces[j].setMatID(CustMtls);
	  else cmesh->faces[j].setMatID(cmesh->faces[j].getMatID()+CustMtls);
	  }
	  if (subtvnum>0)
	  { cmesh->tvFace[j].t[0]+=*tvnum;
	    cmesh->tvFace[j].t[1]+=*tvnum;
	    cmesh->tvFace[j].t[2]+=*tvnum;
		if (mirror) MirrorTVs(&cmesh->tvFace[j]);
	  }
	  else if (*ismapped)
	    memcpy(&(cmesh->tvFace[j]),&Zerod,sizeof(TVFace));
	}
	if (subtvnum>0) 
      memcpy(&(cmesh->tVerts[*tvnum]),triOb->GetMesh().tVerts,sizeof(UVVert)*subtvnum);
//	if (subv) memcpy(&(clst->v[*numV]),triOb->mesh.verts,sizeof(Point3)*subv);
	int k=0;
	ctm=ctm*tspace;
	for (j=*numV;j<tvert;j++)
//	{ cmesh->verts[j]=triOb->GetMesh().verts[k]*ctm+Suboffset;
	{ cmesh->verts[j]=triOb->GetMesh().verts[k]*ctm;
	  k++;
	}
	*numV+=subv;
	*numF+=subf;
	*tvnum+=subtvnum;
	if (submtls>0)
	CustMtls+=submtls;
	else CustMtls++;
	  if (triOb!=pobj) triOb->DeleteThis();
  }
}

void PCloudParticle::TreeDoGroup(INode *node,Matrix3 tspace,Mesh *cmesh,Box3 *cmbb,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) TreeDoGroup(nxtnode,tspace,cmesh,cmbb,numV,numF,tvnum,ismapped,t,subtree,custmtl);
	  else if ((subtree)||(nxtnode->IsGroupMember())) CheckTree(nxtnode,tspace,cmesh,cmbb,numV,numF,tvnum,ismapped,t,subtree,custmtl);
	}
}

void PCloudParticle::GetMesh(TimeValue t,int subtree,int custmtl)
{	int tnums,numV,numF,tvnum,ismapped,msubtree=subtree;
    INode *tmpnode;
	tnums=times.tl.Count();
	if (tnums==0) tnums=1;
	if (cmesh) delete[] cmesh;cmesh=NULL;
	if (cmbb) delete[] cmbb;cmbb=NULL;
	if (custnode!=NULL)
	{ cmesh=new Mesh[tnums];
	  cmbb=new Box3[tnums];
//	  for (int cm=0;cm<tnums;cm++) cmbb[cm].SetEmpty();
	  int cgen;
	 for (int i=0;i<tnums;i++)
	{ TimeValue tofs=(tnums>1?times.tl[i].tl:t);
	  cgen=(times.tl.Count()>0?times.tl[i].gennum-1:-1);
	  if ((cgen>-1)&&(cgen<nlist.Count()))
	  { if (!(tmpnode=nlist[cgen])) tmpnode=custnode;
	  } else tmpnode=custnode;
	  Matrix3 ptm = tmpnode->GetObjTMAfterWSM(tofs);
	  ptm=Inverse(ptm);
	  numV=numF=tvnum=CustMtls=ismapped=0;
	  if (tmpnode->IsGroupHead())
	   TreeDoGroup(tmpnode,ptm,&cmesh[i],&cmbb[i],&numV,&numF,&tvnum,&ismapped,tofs,subtree,custmtl);
	  else
	   CheckTree(tmpnode,ptm,&cmesh[i],&cmbb[i],&numV,&numF,&tvnum,&ismapped,tofs,subtree,custmtl);
	}
	}
}

#define VEL_SCALE	(0.01f*1200.0f/float(TIME_TICKSPERSEC))
#define VAR_SCALE	(0.01f*1200.0f/float(TIME_TICKSPERSEC))

BOOL PCloudParticle::ComputeParticleStart(TimeValue t0,int c)
	{
	int seed,anioff,tani,sym;
	TimeValue anifr;

	pblock->GetValue(PB_RNDSEED,t0,seed,FOREVER);
    pblock->GetValue(PB_OFFSETAMOUNT,t0,anifr,FOREVER);
    pblock->GetValue(PB_ANIMATIONOFFSET,t0,anioff,FOREVER);
    pblock->GetValue(PB_CREATEIN,0,sym,FOREVER);
	srand(seed);					
	parts.SetCount(c,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
	int pcount=parts.Count();
    if (sdata){delete[] sdata;sdata=NULL;} if (pcount) sdata=new PCSavePt[pcount];
	if ((pcount<c)||(c>0 && (!sdata)))
	{   parts.FreeAll();if (sdata) delete sdata;sdata=NULL;	maincount=0;
		BOOL playing=GetCOREInterface()->IsAnimPlaying();
		if (playing) GetCOREInterface()->EndAnimPlayback();
	    TSTR name;name=(cnode ? cnode->GetName() : TSTR(GetString(IDS_AP_PCLOUD)));
		TSTR buf; buf=TSTR(GetString(IDS_OFM_PART));
		GetCOREInterface()->Log()->LogEntry(SYSLOG_ERROR,DISPLAY_DIALOG,
			GetString(IDS_OFM_ERROR),_T("%s: \n\n%s\n"),buf,name);
	  return (0);
	}
	int oneframe=GetTicksPerFrame();
	for (int i=0; i<parts.Count(); i++) {
		parts.ages[i] = -1;
		sdata[i].themtl=0;
  		sdata[i].L=RND0x(99);sdata[i].DL=-1;sdata[i].pvar=RND11();
		tani=RND0x(anifr/oneframe);
		sdata[i].showframe=(anioff==2?tani*oneframe:0);
		sdata[i].gennum=0;
		sdata[i].V.x=RND11();
		sdata[i].V.y=RND11();
		sdata[i].V.z=RND11();
		sdata[i].Ts0=RND11();
		sdata[i].Ts=0.0f;
		sdata[i].LamTs=RND11();
		sdata[i].A=RND11();
		sdata[i].LamA=RND11();
		parts.vels[i]=Point3(RND11(),RND11(),RND11());
		sdata[i].To=RND11();
		sdata[i].Vsz=RND11();
		sdata[i].W=Point3(RND11(),RND11(),RND11());
		sdata[i].RV=Point3(RND11(),RND11(),RND11());
		parts.radius[i]=0.0f;
		parts.tension[i]=RND11();
		sdata[i].Mltvar=RND11();
		sdata[i].SpVar=RND0x(99);
		parts.points[i]=(sym<3?Point3((float)RNDSign(),(float)RNDSign(),(float)RNDSign()):Point3(RND01(),RND01(),RND01()));
		}
	tvalid = t0-1;
	valid  = TRUE;
	rseed=rand();
	return (1);
	}

 #define EPSILON	0.0001f

BOOL InsideMesh(Ray& ray, Mesh *amesh,Point3 *fnorms)
{	Face *face;	
	Point3 n,p, bry;
	float d, rn, a,at;
	BOOL notfirst = FALSE,inside=FALSE,savein=FALSE;
	int raycount=0;

   while ((!savein)&&(raycount<3))
   { notfirst=FALSE;
     if (raycount==0) ray.dir=Point3(1.0f,0.0f,0.0f);
	 else if (raycount==1) ray.dir=Point3(0.0f,1.0f,0.0f);
	 else ray.dir=Point3(0.0f,0.0f,1.0f);
	face=amesh->faces;
	for (int i=0; i<amesh->getNumFaces(); i++,face++)
	{	n = fnorms[i];
		// See if the ray intersects the plane (backfaced)
		rn = DotProd(ray.dir,n);
		if (fabs(rn) < EPSILON) continue; //is parallel, so bail
		// Use a point on the plane to find d
		d = DotProd(amesh->verts[face->v[0]],n);
		// Find the point on the ray that intersects the plane
		a = (d - DotProd(ray.p,n)) / rn;
		// The point on the ray and in the plane.
		p = ray.p + a*ray.dir;
		inside=(((a > 0.0f)&&(rn>0.0f))||((a < 0.0f)&&(rn<0.0f)));
		// Compute barycentric coords.
		bry = amesh->BaryCoords(i,p);
		// barycentric coordinates must sum to 1 and each component must
		// be in the range 0-1
		if (bry.x<0.0f || bry.x>1.0f || bry.y<0.0f || bry.y>1.0f || bry.z<0.0f || bry.z>1.0f) continue;
		if (fabs(bry.x + bry.y + bry.z - 1.0f) > EPSILON) continue;
		// Must be closer than the closest at so far
		if (notfirst)
			if (fabs(a) > at) continue;

		// Hit!
		notfirst = TRUE;		
		at    = (float)fabs(a);
		savein=inside;
	  } raycount++;
   }
	return savein;

	}

#define TESTLIMIT 100

void PCloudParticle::BirthParticle(INode *node,TimeValue bt,int num,VelDir *ptvel,Mesh* amesh,Point3* fnorms,Matrix3 disttm)
{	Matrix3 atm = (amesh?distnode->GetObjTMBeforeWSM(bt):node->GetObjTMBeforeWSM(bt));
	Matrix3 tm = (amesh?distnode->GetObjTMAfterWSM(bt):node->GetObjTMAfterWSM(bt));
	tm.SetRow(3,atm.GetRow(3));
	Point3 vel;
	float Ie,Em,Vm;
	pblock->GetValue(PB_EMITVINFL,bt,Ie,FOREVER);
	pblock->GetValue(PB_EMITVMULT,bt,Em,FOREVER);
	pblock->GetValue(PB_EMITVMULTVAR,bt,Vm,FOREVER);
	sdata[num].Ts0=(1+sdata[num].Ts0*ptvel->VSpin)/TWOPI;
	sdata[num].Ts=(float)ptvel->Spin*sdata[num].Ts0;
	parts.tension[num]=ptvel->bstr*(1+parts.tension[num]*ptvel->bstrvar);
// ok, so I'm using L for M and .z for L.  They were unused float and ints
	srand(rseed);
	float inheremit,tmp=RND11();
	inheremit=(sdata[num].L<Ie?Em*(1+tmp*Vm):0);  
	sdata[num].L=ptvel->Life+(int)(parts.vels[num].z*ptvel->Vl);
	sdata[num].Vsz*=ptvel->VSz;
	sdata[num].LamTs=ptvel->Phase*(1+sdata[num].LamTs*ptvel->VPhase);
	sdata[num].A = ptvel->ToAmp*(1+sdata[num].A*ptvel->VToAmp);
	sdata[num].LamA=ptvel->ToPhase*(1+sdata[num].LamA*ptvel->VToPhase);
	sdata[num].To=ptvel->ToPeriod*(1+sdata[num].To*ptvel->VToPeriod);
	sdata[num].persist=(TimeValue)(ptvel->persist*(1.0f+sdata[num].pvar*ptvel->pvar));

	if (ptvel->axisentered==2)
	{	sdata[num].W=Normalize(ptvel->Axis);
		if (ptvel->axisvar>0.0f) VectorVar(&sdata[num].W,ptvel->axisvar,PI);
	}
	else
		sdata[num].W=Normalize(sdata[num].W);

	parts.ages[num] = 0;
	float theta=RND01(),gamma=(ptvel->sym==2?RND11():RND01()),r=RND01();

	if (ptvel->sym==0) //box emitter emitter
	{	parts.points[num].x*=ptvel->width*r;
		parts.points[num].y*=ptvel->len*theta;
		parts.points[num].z*=ptvel->depth*gamma;
	}
	else if (ptvel->sym<3)
	{	float thetapi=theta*TWOPI;
		float lec=ptvel->len*r;
		if (ptvel->sym==2) //cylinder emitter
		{	parts.points[num].x=lec*(float)cos(thetapi);
			parts.points[num].y=lec*(float)sin(thetapi);
			parts.points[num].z*=gamma*ptvel->depth;
		} 
		else if (ptvel->sym==1) //spherical emitter
		{	float hgamma=gamma*HalfPI;
			parts.points[num].x=lec*(float)cos(thetapi)*(float)cos(hgamma);
			parts.points[num].y=lec*(float)sin(thetapi)*(float)cos(hgamma);
			parts.points[num].z*=lec*(float)sin(hgamma);
		}
	}
	else //custom emitter
	{	Ray ray;
		Box3 bbox=amesh->getBoundingBox();
		Point3 box=bbox.pmax-bbox.pmin;

//		if (box.x<EPSILON) {box.x=0.2f;bbox.pmin.x-=0.1f;}
//		if (box.y<EPSILON) {box.y=0.2f;bbox.pmin.y-=0.1f;}
//		if (box.z<EPSILON) {box.z=0.2f;bbox.pmin.z-=0.1f;}

		if ((box.x<EPSILON)||(box.y<EPSILON)||(box.z<EPSILON)) //emitter volume isn't
		{	ray.p=bbox.pmin+Point3(RND01(),RND01(),RND01())*box;
		}
		else //assume we have a logically arranged mesh
		{	int testcount=0;
			ray.p=bbox.pmin+parts.points[num]*box;
			while ((!InsideMesh(ray,amesh,fnorms))&&(testcount<TESTLIMIT))
			{	testcount++;
				ray.p=bbox.pmin+Point3(RND01(),RND01(),RND01())*box;
			}
		}
		parts.points[num]=ray.p;
	}
	if ((ptvel->direntered==2)&&(mbase))
	{	Interval ivalid;
		Matrix3 ntm = mbase->GetObjectTM(bt,&ivalid);
		vel=ntm.GetRow(2);
		if (ptvel->DirVar>0.0f)
			VectorVar(&vel,ptvel->DirVar,PI);
	}
	else if (ptvel->direntered==1)
	{	vel=Normalize(ptvel->Dir);
		if (ptvel->DirVar>0.0f) VectorVar(&vel,ptvel->DirVar,PI);
	}
	else
		vel=parts.vels[num];

	vel=VectorTransform(tm,vel);
	vel.x*=ptvel->Speed*(1+sdata[num].V.x*ptvel->VSpeed);
	vel.y*=ptvel->Speed*(1+sdata[num].V.y*ptvel->VSpeed);
	vel.z*=ptvel->Speed*(1+sdata[num].V.z*ptvel->VSpeed);
	vel+=inheremit*ptvel->Ve;
	parts[num] = (parts[num] * tm)+vel*(0.5f*sdata[num].RV.x);
	vel/=(float)GetTicksPerFrame();
	parts.vels[num] = vel;  
	sdata[num].V=parts[num];
	rseed=rand();
}

void PCloudParticle::DoSpawn(int j,int spmult,SpawnVars spvars,TimeValue lvar,BOOL emits)
{ if (!emits) spmult--;
  int oldcount,newcount=((oldcount=parts.Count())+spmult); 
  srand(rseed);
  if (spmult)
  { parts.SetCount(newcount,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
	PCSavePt *tmp=sdata;
	sdata=new PCSavePt[newcount];
	if (tmp)
	{ for (int j=0;j<oldcount;j++) sdata[j]=tmp[j];
	  delete[] tmp;
	}
  }
  int Lcnt=llist.Count();
  int baselife=(Lcnt==0?deftime:(sdata[j].gennum<Lcnt?llist[sdata[j].gennum]:llist[Lcnt-1]))*GetTicksPerFrame();
  if (!emits)
  { sdata[j].gennum++;
	parts.ages[j]=0;}
  Point3 holdv=(emits?-parts.vels[j]:parts.vels[j]);
  for (int i=oldcount;i<newcount;i++)
  { parts.points[i]=parts.points[j];
    parts.vels[i]=holdv;
	parts.radius[i]=parts.radius[j];
	parts.tension[i]=parts.tension[j];
	parts.ages[i]=0;
	memcpy(&sdata[i],&sdata[j],sizeof(PCSavePt));
	if (emits) sdata[i].gennum++;
    parts.vels[i]=DoSpawnVars(spvars,parts.vels[j],holdv,&parts.radius[i],&sdata[i].W);
	sdata[i].Vsz=parts.radius[i];
	sdata[i].L=baselife+(int)RND11()*lvar;
 	sdata[i].Mltvar=RND11();
	sdata[i].SpVar=RND0x(99);
	sdata[i].DL=-1;
 }
  if (!emits)
  {parts.vels[j]=DoSpawnVars(spvars,holdv,holdv,&parts.radius[j],&sdata[j].W);
  sdata[j].Vsz=parts.radius[j];
  sdata[j].L=baselife+(int)RND11()*lvar;
  	sdata[j].Mltvar=RND11();
	sdata[j].SpVar=RND0x(99);
	sdata[j].DL=-1;
}
/*  int tmprseed=rand();
  rseed=(tmprseed==rseed?rand():tmprseed);*/
  rseed=rand();
}
void PCloudParticle::MovePart(int j,TimeValue dt,BOOL fullframe,int tpf)
{ 	float curdt=(float)dt;
	parts[j] = sdata[j].V+parts.vels[j] * (float)dt;
	// add transverse oscillation
	if (fullframe) sdata[j].V=parts[j];
	Point3 DotPt=(FGT0(parts.vels[j]*(float)tpf)?parts.vels[j]:sdata[j].W);
	DotPt=sdata[j].RV^DotPt;				// Cross Product 
	DotPt=Normalize(DotPt);	       
	float oscil=(sdata[j].To>0.0f?parts.ages[j]*TWOPI/sdata[j].To:0.0f);
	oscil=sdata[j].A*(float)sin(oscil+sdata[j].LamA);
	parts[j] +=DotPt*oscil;
}

void PCloudParticle::UpdateParticles(TimeValue t,INode *node)
	{
	TimeValue t0,dt,t2,grow,fade;
	int i, j, c, birth,counter,tpf=GetTicksPerFrame(),count=0,anioff;
	VelDir ptvel;
    Matrix3 tm,lasttm; 
	int isrend=TestAFlag(A_RENDER),bmethod,onscreen,oneframe;
	cancelled=FALSE;
	// The size of steps we take to integrate will be frame size steps.
	oneframe=GetTicksPerFrame();
	if (stepSize!=oneframe) 
	{	stepSize = oneframe;
		valid = FALSE;
	}
	float FperT=GetFrameRate()/(float)TIME_TICKSPERSEC;
    pblock->GetValue(PB_ANIMATIONOFFSET,t,anioff,FOREVER);
	pblock->GetValue(PB_EMITSTART,t,t0,FOREVER);
	pblock->GetValue(PB_SIZE,t,parts.size,FOREVER);	
	pblock->GetValue(PB_BIRTHMETHOD,0,bmethod,FOREVER);
	pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	pblock->GetValue(PB_EMITSTOP,0,t2,FOREVER);
//	t0-=oneframe;t2-=oneframe;
	if (bmethod)
	  pblock->GetValue(PB_PTOTALNUMBER,0,c,FOREVER);
	int subtree,frag,custmtl=0;
    pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
	pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
 	if (t < t0) {
		// Before the start time, nothing is happening
		parts.FreeAll();
		if (sdata) {delete[] sdata;sdata=NULL;}
		ResetSystem(t);
		return;
		}
	int pkind;
	float dpercent;
	pblock->GetValue(PB_DISPLAYPORTION,0,dpercent,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,pkind,FOREVER);

	if (!valid || t<tvalid || tvalid<t0) 
	{	// Set the particle system to the initial condition
	    TimeValue cincr;	
		dispt=-99999;
		if (!bmethod)
		{ c=0;
		  for (TimeValue ti=t0;ti<=t2;ti+=oneframe)
		  { pblock->GetValue(PB_PBIRTHRATE,ti,cincr,FOREVER);
		    if (cincr<0) cincr=0;
			c+=cincr;
		  }
		}
		if (!isrend) c=(int)(dpercent*(float)c+FTOIEPS);
		if (!ComputeParticleStart(t0,c))
		{ ResetSystem(t);
		  return;
		}
		dispt=t-1;
		maincount=parts.Count();
		ResetSystem(t,FALSE);
	}
	int total=maincount;
	valid = TRUE;
	int stype,maxgens,spmultb;float spawnbvar;
    pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
    pblock->GetValue(PB_SPAWNGENS,0,maxgens,FOREVER);
    pblock->GetValue(PB_SPAWNCOUNT,0,spmultb,FOREVER);
	pblock->GetValue(PB_SPINAXISTYPE,0,ptvel.axisentered,FOREVER);
    pblock->GetValue(PB_SPEEDDIR,0,ptvel.direntered,FOREVER);
    pblock->GetValue(PB_DIRX,0,ptvel.Dir.x,FOREVER);
    pblock->GetValue(PB_DIRY,0,ptvel.Dir.y,FOREVER);
    pblock->GetValue(PB_DIRZ,0,ptvel.Dir.z,FOREVER);
    pblock->GetValue(PB_DIRVAR,0,ptvel.DirVar,FOREVER);
	TimeValue dis;
    pblock->GetValue(PB_DISPUNTIL,0,dis,FOREVER);
	SpawnVars spawnvars;
	spawnvars.axisentered=ptvel.axisentered;

	if (t2<t0) t2=t0;
//	TimeValue fstep=oneframe;

	//t2+=fstep;
	TimeValue createover;
	createover=t2-t0+oneframe;
	counter=(isrend?rcounter:vcounter);
	float frate,grate;
	pblock->GetValue(PB_GROWTIME,0,grow,FOREVER);
    pblock->GetValue(PB_FADETIME,0,fade,FOREVER);
	frate=(fade>0.0f?(1-M)/fade:0.0f);
	grate=(grow>0.0f?(1-M)/grow:0.0f);
	float basesize;
	BOOL fullframe;
	if (!isrend)
	{ int offby=t%oneframe;
	  if (offby!=0) t-=offby;
	}
    pblock->GetValue(PB_SPAWNSCALESIGN,0,spawnvars.scsign,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDSIGN,0,spawnvars.spsign,FOREVER);
    pblock->GetValue(PB_SPAWNINHERITV,0,spawnvars.invel,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDFIXED,0,spawnvars.spconst,FOREVER);
    pblock->GetValue(PB_SPAWNSCALEFIXED,0,spawnvars.scconst,FOREVER);
    pblock->GetValue(PB_CREATEIN,0,ptvel.sym,FOREVER);
	if ((ptvel.sym==3)&&(!distnode)) ptvel.sym=0;
	int sper,spmult;float smper;BOOL first=(tvalid<t0);
	while ((tvalid < t)&&(tvalid<=dis))
	{	int born = 0;
	    TimeValue atvalid=abs(tvalid);
	    count=0;
		if (first) tvalid=t0;
			// Compute our step size
		 if (tvalid%stepSize !=0) 
		  { dt = stepSize - atvalid%stepSize;} 
		  else { dt = stepSize;	}
		  if (tvalid + dt > t) {dt = t-tvalid;}

  		  // Increment time
		if (!first) tvalid +=dt;
		if (tvalid>dis)
		{ for (j=0; j<parts.Count(); j++)
		  { parts.ages[j] = -1;  }
		  tvalid=t;
		  continue;
		}
	    pblock->GetValue(PB_SPAWNDIEAFTER,tvalid,ptvel.persist,FOREVER);
	    pblock->GetValue(PB_SPAWNDIEAFTERVAR,tvalid,ptvel.pvar,FOREVER);
	    pblock->GetValue(PB_SPEED,tvalid,ptvel.Speed,FOREVER);
    	pblock->GetValue(PB_SPEEDVAR,tvalid,ptvel.VSpeed,FOREVER);
		pblock->GetValue(PB_SIZE,tvalid,ptvel.Size,FOREVER);
		pblock->GetValue(PB_LIFE,tvalid,ptvel.Life,FOREVER);
		if (llist.Count()==0) deftime=ptvel.Life/oneframe;
		pblock->GetValue(PB_LIFEVAR,tvalid,ptvel.Vl,FOREVER);
		pblock->GetValue(PB_SPINTIME,tvalid,ptvel.Spin,FOREVER);
		pblock->GetValue(PB_SPINTIMEVAR,tvalid,ptvel.VSpin,FOREVER);
		pblock->GetValue(PB_SPINPHASE,tvalid,ptvel.Phase,FOREVER);
		pblock->GetValue(PB_SPINPHASEVAR,tvalid,ptvel.VPhase,FOREVER);
		pblock->GetValue(PB_SIZEVAR,tvalid,ptvel.VSz,FOREVER);
		pblock->GetValue(PB_METATENSION,tvalid,ptvel.bstr,FOREVER);
		pblock->GetValue(PB_METATENSIONVAR,tvalid,ptvel.bstrvar,FOREVER);
		pblock->GetValue(PB_BUBLAMP,tvalid,ptvel.ToAmp,FOREVER);
		pblock->GetValue(PB_BUBLAMPVAR,tvalid,ptvel.VToAmp,FOREVER);
		pblock->GetValue(PB_BUBLPHAS,tvalid,ptvel.ToPhase,FOREVER);
		pblock->GetValue(PB_BUBLPHASVAR,tvalid,ptvel.VToPhase,FOREVER);
		pblock->GetValue(PB_BUBLPER,tvalid,ptvel.ToPeriod,FOREVER);
		pblock->GetValue(PB_BUBLPERVAR,tvalid,ptvel.VToPeriod,FOREVER);
		pblock->GetValue(PB_EMITRHEIGHT,tvalid,ptvel.width,FOREVER);ptvel.width*=0.5f;
		pblock->GetValue(PB_EMITRWID,tvalid,ptvel.len,FOREVER);ptvel.len*=0.5f;
		pblock->GetValue(PB_EMITRDEPTH,tvalid,ptvel.depth,FOREVER);ptvel.depth*=0.5f;
		pblock->GetValue(PB_SPAWNDIRCHAOS,tvalid,spawnvars.dirchaos,FOREVER);
		pblock->GetValue(PB_SPAWNPERCENT,tvalid,sper,FOREVER);	
		pblock->GetValue(PB_SPAWNMULTVAR,tvalid,smper,FOREVER);	
		spawnbvar=smper*spmultb;
		pblock->GetValue(PB_SPAWNSPEEDCHAOS,tvalid,spawnvars.spchaos,FOREVER);
		spawnvars.spchaos/=100.0f;
		pblock->GetValue(PB_SPAWNSCALECHAOS,tvalid,spawnvars.scchaos,FOREVER);
		spawnvars.scchaos/=100.0f;
		pblock->GetValue(PB_SPINAXISX,tvalid,ptvel.Axis.x,FOREVER);
		pblock->GetValue(PB_SPINAXISY,tvalid,ptvel.Axis.y,FOREVER);
		pblock->GetValue(PB_SPINAXISZ,tvalid,ptvel.Axis.z,FOREVER);
		if (Length(ptvel.Axis)==0.0f) ptvel.Axis.x=0.001f;
		pblock->GetValue(PB_SPINAXISVAR,t,ptvel.axisvar,FOREVER);
		spawnvars.Axis=ptvel.Axis;spawnvars.axisvar=ptvel.axisvar;
		basesize=M*ptvel.Size;
		// Compute the number of particles that should be born LAST FRAME!
		birth=0;
		fullframe=(tvalid%tpf==0);
		if (fullframe)
		{ if (bmethod)
		  { int tdelta;
		    if (tvalid>=t2) birth=total-counter;
		    else
		    { tdelta=int((float)total*(tvalid-t0+oneframe)/createover);
		      birth=tdelta-counter;
		    }
	      }
		  else if (tvalid<=t2)
		  { pblock->GetValue(PB_PBIRTHRATE,tvalid,total,FOREVER);
		    if (!isrend) total=(int)(dpercent*(float)total+FTOIEPS);
		    birth=total;
			if (birth+counter>maincount) birth=0;
		  }
		}
		// First increment age and kill off old particles
		for (j=0;j<parts.Count();j++)
		{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
		  if (!parts.Alive(j)) continue;
		  parts.ages[j] += dt;
		  if (parts.ages[j] >= sdata[j].L) 
		  {  if ((stype!=ONDEATH)||(sdata[j].gennum>=maxgens)||(sdata[j].SpVar>=sper)) parts.ages[j] = -1;	
		  else if (fullframe)
			 {spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
				if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,FALSE);
				else parts.ages[j] = -1;
			 }
		  } else if (sdata[j].DL>-1) {sdata[j].DL+=dt;if (sdata[j].DL>sdata[j].persist) parts.ages[j]=-1;}
		  if (parts.ages[j]>-1)
		  { if (fullframe &&((stype==EMIT)&&(sdata[j].gennum==0)&&(sdata[j].SpVar<sper)))
		  {  spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
			  if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,TRUE);
		  }
//			if (pkind==RENDTYPE6)
//		     parts.radius[j]=ptvel.Size;		   else
			   if ((stype<2)||(maxgens==0))
		 	 parts.radius[j]=FigureOutSize(parts.ages[j],ptvel.Size,grow,fade,sdata[j].L,grate,frate)*(1+sdata[j].Vsz);
		   else 
		   { if (sdata[j].gennum==0)
			   parts.radius[j]=FigureOutSize(parts.ages[j],ptvel.Size,grow,0,sdata[j].L,grate,frate)*(1+sdata[j].Vsz);
		     else if (sdata[j].gennum==maxgens)
			   parts.radius[j]=FigureOutSize(parts.ages[j],sdata[j].Vsz,0,fade,sdata[j].L,grate,frate);
		   }
		  }
		}
		if (birth>0)
		{Matrix3 tm;	
		Point3 LastCenter,NextCenter;
	    BOOL newmesh=(ptvel.sym==3)&&(distnode);
		Point3 *fnorms=NULL;TriObject *triOb=NULL;Matrix3 disttm=NULL;Object *pobj=NULL;
		TimeValue checkone=tvalid-t0,acheck=abs(checkone);
		tm= (newmesh?distnode->GetObjTMAfterWSM((acheck<stepSize?t0:(tvalid-stepSize))):node->GetObjTMBeforeWSM((atvalid<stepSize?0:(tvalid-stepSize))));
		LastCenter=Zero*tm;
		tm= (newmesh?distnode->GetObjTMAfterWSM(tvalid+stepSize):node->GetObjTMBeforeWSM(tvalid+stepSize));
		NextCenter=Zero*tm;
		ptvel.Ve=(NextCenter-LastCenter)/((acheck<stepSize)?(1.0f+checkone/stepSize):2.0f);
		if (newmesh&&(born<birth)) 
		{ pobj = distnode->EvalWorldState(tvalid).obj;
		  triOb=TriIsUseable(pobj,tvalid);
		  if (triOb&&(triOb->GetMesh().getNumFaces()>0)) 
		  { int nf=triOb->GetMesh().getNumFaces();
			fnorms=new Point3[nf];
			Point3 v0, v1, v2;
			Face *face=triOb->GetMesh().faces;
			for (int fi=0; fi<nf; fi++) 
			{ v1 = triOb->GetMesh().verts[face[fi].v[1]];
			  fnorms[fi] = Normalize((v1-triOb->GetMesh().verts[face[fi].v[0]])^(triOb->GetMesh().verts[face[fi].v[2]]-v1));
			}
		  } 
		  else {
			ptvel.sym=0;newmesh=FALSE;
		  	tm=node->GetObjTMBeforeWSM(atvalid<stepSize?0:(tvalid-stepSize));LastCenter=Zero*tm;
			tm=node->GetObjTMBeforeWSM(tvalid+stepSize);NextCenter=Zero*tm;
			ptvel.Ve=(NextCenter-LastCenter)/((atvalid<stepSize)?(1.0f+tvalid/stepSize):2.0f);
			}
		}
		// Next, birth particles at the birth rate
		for (j=counter; j<maincount; j++) {
			if (born>=birth) break;
			BirthParticle(node,tvalid,j,&ptvel,(newmesh?&triOb->GetMesh():NULL),fnorms,disttm);
//		    if ((pkind==RENDTYPE5)||(pkind==RENDTYPE6))
//			  parts.radius[j]=ptvel.Size;	else 
			parts.radius[j]=(grow>0?basesize:ptvel.Size)*(1+sdata[j].Vsz);
			sdata[j].themtl=int((tvalid-t0)*FperT);
			sdata[j].showframe=(anioff==1?0:sdata[j].showframe);
			born++;counter++;
			}
		if (triOb&&(triOb!=pobj)) triOb->DeleteThis();
		if (fnorms) delete[] fnorms;
		}
		// Apply forces to modify velocity
		int fc=fields.Count();
		if (fc>0)
		  for (j=0; j<parts.Count(); j++) 
		  { Point3 force,tvel=Zero;
		    for (i=0; i<fc; i++) 
			{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) ) 
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
			if (!parts.Alive(j)) continue;
			 parts[j]=sdata[j].V;
			 force = fields[i]->Force(tvalid,parts[j],parts.vels[j],j);
			 float curdt=(float)dt;
			 if ((parts.ages[j]==0)&&(sdata[j].gennum==0)) curdt=tpf*((0.5f*sdata[j].RV.x)+0.5f);
			 tvel += 10.0f*force * curdt;
			}
		    parts.vels[j]+=tvel;
		}
		// Increment the positions
		count=0;
		// IPC IPC IPC IPC

		int IPC,ipcsteps;float B,Vb;
  		pblock->GetValue(PB_PCIPCOLLIDE_ON,tvalid,IPC,FOREVER);
  		pblock->GetValue(PB_PCIPCOLLIDE_STEPS,tvalid,ipcsteps,FOREVER);
  		pblock->GetValue(PB_PCIPCOLLIDE_BOUNCE,tvalid,B,FOREVER);
  		pblock->GetValue(PB_PCIPCOLLIDE_BOUNCEVAR,tvalid,Vb,FOREVER);
		if (IPC)
		{	CollideParticle cp;
			int ddt=dt/ipcsteps,remtime=0,snum=0;
			TimeValue curt=t;
			if (dt > 0)
				while (snum < ipcsteps)
				{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
				  {	valid=FALSE;
					tvalid=t;
					cancelled=TRUE;
					parts.FreeAll();
					return;
					}
					if (remtime==0) remtime=ddt;
					mindata md=cp.InterPartCollide(parts,cobjs,remtime,snum,B,Vb,curt,lc);
					for (j=0; j<parts.Count(); j++)
					{	if (parts.ages[j]>0) 
						{	if ((j!=md.min)&&(j!=md.min2)) 
							{	if (fullframe) 
									MovePart(j,md.mintime,fullframe,tpf);
								else 
									parts[j]+=parts.vels[j]*(float)md.mintime;
							}
							else if (fullframe) sdata[j].V=parts[j];
						}
					}
				}
			// If we didn't collide, then increment.
			for (j=0; j<parts.Count(); j++)
			{	sdata[j].Ts = (float)ptvel.Spin*sdata[j].Ts0;
				sdata[j].LamTs += (FloatEQ0(sdata[j].Ts)?0.0f:dt/sdata[j].Ts);
			}
		}
		else
		for (j=0; j<parts.Count(); j++)
		{  if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
			if ((!parts.Alive(j))||(parts.ages[j]==0)) continue;
		  count++;
			// Check for collisions
			BOOL collide = FALSE;
			float meaninglesstime;
			for (int i=0; i<cobjs.Count(); i++) {
				if (cobjs[i]->CheckCollision(
						tvalid,parts[j],parts.vels[j], (float)dt, j,&meaninglesstime,TRUE))
				{	collide = TRUE;
					if (stype==1)
					{ if (sdata[j].persist==0) {parts.ages[j] = -1;count--;}else sdata[j].DL=0;}
					else if (fullframe &&((stype==COLLIDE)&&(sdata[j].gennum<maxgens)&&(sdata[j].SpVar<sper)))
				{ int spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
					  if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,FALSE);
					  else break;
					}
				else break;
					}
				}
			sdata[j].Ts=(float)ptvel.Spin*sdata[j].Ts0;
			sdata[j].LamTs+=(FloatEQ0(sdata[j].Ts)?0.0f:dt/sdata[j].Ts);			
			// If we didn't collide, then increment.
			if (!collide) MovePart(j,dt,fullframe,tpf);
			else if (fullframe) sdata[j].V=parts[j];
		}
		if (first) first=FALSE;
	}
/*	if ((frag==METABALLS)&&(onscreen==2))
	{ float res,bstr,thres=0.6f;
      pblock->GetValue(PB_METATENSION,t,bstr,FOREVER);
      pblock->GetValue(PB_METACOURSE,0,res,FOREVER);
	  if (cmesh) delete[] cmesh;cmesh=new Mesh;
      metap.CreateMetas(parts,cmesh,thres,res,bstr);
	}
	else */if ((frag==INSTGEOM)&&(onscreen>1)&&(custnode))
	{ TimeValue anist=GetAnimStart(),aniend=GetAnimEnd();
      thePCloudDraw.anifr=aniend+stepSize;
	  thePCloudDraw.t=t;
	  thePCloudDraw.anioff=anioff;
	  if (count>0)
	   GetTimes(times,t,thePCloudDraw.anifr,anioff);
	  else times.tl.ZeroCount();
	  if (onscreen==2)
	   GetMesh(t,subtree,custmtl);
	  else GetallBB(custnode,subtree,t);
	}  
	if (isrend) rcounter=counter;
	else
	{ vcounter=counter;
	}
	if (tvalid<t) tvalid=t;
	valid=TRUE;
//	assert(tvalid==t);
	}


void PCloudParticle::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	if (pmapPGen) pmapPGen->Invalidate();
	if (pmapPType) pmapPType->Invalidate();
	if (pmapPSpin) pmapPSpin->Invalidate();
	if (pmapEmitV) pmapEmitV->Invalidate();
	if (pmapBubl) pmapBubl->Invalidate();
	if (pmapSpawn) pmapSpawn->Invalidate();
	}

BOOL PCloudParticle::EmitterVisible()
	{
	int hide;
	pblock->GetValue(PB_EMITRHID,0,hide,FOREVER);
	return !hide;
	}

ParamDimension *PCloudParticle::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_SPEED:
		case PB_PBIRTHRATE:
		case PB_PTOTALNUMBER:
		case PB_SIZE:
		case PB_RNDSEED:
		case PB_METATENSION:
		case PB_METACOURSE:
		case PB_MAPPINGDIST:
		case PB_SPINAXISX:
		case PB_SPINAXISY:
		case PB_SPINAXISZ:
		case PB_EMITVMULT:
		case PB_BUBLAMP:
		case PB_EMITRWID:
		case PB_EMITRHEIGHT:
		case PB_EMITRDEPTH:
									return stdWorldDim;

		case PB_SPINPHASE:
		case PB_SPINAXISVAR:
		case PB_BUBLPHAS:			return stdAngleDim;

		case PB_DISPLAYPORTION:
		case PB_SPAWNDIRCHAOS:
		case PB_SIZEVAR:
		case PB_SPEEDVAR:
		case PB_METATENSIONVAR:
		case PB_SPINTIMEVAR:
		case PB_SPINPHASEVAR:
		case PB_EMITVMULTVAR:
		case PB_BUBLAMPVAR:
		case PB_BUBLPERVAR:
		case PB_BUBLPHASVAR:	
		case PB_SPAWNMULTVAR:
		case PB_SPAWNDIEAFTERVAR:
		case PB_PCIPCOLLIDE_BOUNCE:			
		case PB_PCIPCOLLIDE_BOUNCEVAR:			
								return stdPercentDim;

		case PB_EMITSTART:
		case PB_EMITSTOP:
		case PB_DISPUNTIL:
		case PB_LIFE:
		case PB_LIFEVAR:
		case PB_GROWTIME:
		case PB_FADETIME:
		case PB_MAPPINGTIME:
		case PB_SPINTIME:
		case PB_BUBLPER:
		case PB_OFFSETAMOUNT:
		case PB_SPAWNDIEAFTER:
								return stdTimeDim;
		
		default: return defaultDim;
		}
	}

TSTR PCloudParticle::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_SPEED:			return GetString(IDS_RB_SPEED);
		case PB_SPEEDVAR:		return GetString(IDS_RB_SPEEDVAR);
		case PB_DIRX:			return GetString(IDS_AP_SPDIRX);
		case PB_DIRY:			return GetString(IDS_AP_SPDIRY);
		case PB_DIRZ:			return GetString(IDS_AP_SPDIRZ);
		case PB_DIRVAR:			return GetString(IDS_AP_SPDIRVAR);
		case PB_PBIRTHRATE:		return GetString(IDS_RB_PBIRTHRATE);
		case PB_PTOTALNUMBER:	return GetString(IDS_RB_PTOTALNUMBER);
		case PB_DISPLAYPORTION:	return GetString(IDS_RB_DISPLAYPORTION);
		case PB_EMITSTART:		return GetString(IDS_RB_EMITSTART);
		case PB_EMITSTOP:		return GetString(IDS_RB_EMITSTOP);
		case PB_DISPUNTIL:		return GetString(IDS_RB_DISPUNTIL);
		case PB_LIFE:			return GetString(IDS_RB_LIFE);
		case PB_LIFEVAR:		return GetString(IDS_RB_LIFEVAR);
		case PB_SIZE:			return GetString(IDS_RB_SIZE);
		case PB_SIZEVAR:		return GetString(IDS_RB_SIZEVAR);
		case PB_GROWTIME:		return GetString(IDS_RB_GROWTIME);
		case PB_FADETIME:		return GetString(IDS_RB_FADETIME);
		case PB_RNDSEED:		return GetString(IDS_RB_RNDSEED);
		case PB_METATENSION:	return GetString(IDS_RB_METATENSION);
		case PB_METATENSIONVAR:	return GetString(IDS_RB_METATENSIONVAR);
		case PB_METACOURSE:		return GetString(IDS_RB_METACOURSE);
		case PB_MAPPINGTIME:	return GetString(IDS_RB_MAPPINGTIME);
		case PB_MAPPINGDIST:	return GetString(IDS_RB_MAPPINGDIST);
		case PB_SPINTIME:		return GetString(IDS_RB_SPINTIME);
		case PB_SPINTIMEVAR:	return GetString(IDS_RB_SPINTIMEVAR);
		case PB_SPINPHASE:		return GetString(IDS_RB_SPINPHASE);
		case PB_SPINPHASEVAR:	return GetString(IDS_RB_SPINPHASEVAR);
		case PB_SPINAXISX:		return GetString(IDS_RB_SPINAXISX);
		case PB_SPINAXISY:		return GetString(IDS_RB_SPINAXISY);
		case PB_SPINAXISZ:		return GetString(IDS_RB_SPINAXISZ);
		case PB_SPINAXISVAR:	return GetString(IDS_RB_SPINAXISVAR);
		case PB_EMITVINFL:		return GetString(IDS_RB_EMITVINFL);
		case PB_EMITVMULT:		return GetString(IDS_RB_EMITVMULT);
		case PB_EMITVMULTVAR:	return GetString(IDS_RB_EMITVMULTVAR);
		case PB_BUBLAMP:		return GetString(IDS_RB_BUBLAMP);
		case PB_BUBLAMPVAR:		return GetString(IDS_RB_BUBLAMPVAR);
		case PB_BUBLPER:		return GetString(IDS_RB_BUBLPER);
		case PB_BUBLPERVAR:		return GetString(IDS_RB_BUBLPERVAR);
		case PB_BUBLPHAS:		return GetString(IDS_RB_BUBLPHAS);
		case PB_BUBLPHASVAR:	return GetString(IDS_RB_BUBLPHASVAR);
		case PB_EMITRWID:		return GetString(IDS_AP_RADLEN);
		case PB_EMITRHEIGHT:	return GetString(IDS_RB_EMITRWID);
		case PB_EMITRDEPTH:		return GetString(IDS_AP_EMITRHEIGHT);
		case PB_OFFSETAMOUNT:	return GetString(IDS_AP_OFFSETAMT);
		case PB_SPAWNGENS:		return GetString(IDS_AP_SPAWNGENS);
		case PB_SPAWNCOUNT:		return GetString(IDS_AP_SPAWNCOUNT);
		case PB_SPAWNDIRCHAOS:	return GetString(IDS_AP_SPAWNDIRCHAOS);
		case PB_SPAWNSPEEDCHAOS:	return GetString(IDS_AP_SPAWNSPEEDCHAOS);
		case PB_SPAWNSCALECHAOS:	return GetString(IDS_AP_SPAWNSCALECHAOS);
		case PB_SPAWNLIFEVLUE:	return GetString(IDS_AP_SPAWNLIFEVLUE);
		case PB_STRETCH:	return GetString(IDS_AP_STRETCH);
		case PB_SPAWNDIEAFTER:	return GetString(IDS_AP_SPAWNDIEAFTER);
		case PB_SPAWNDIEAFTERVAR:	return GetString(IDS_AP_SPAWNDIEAFTERVAR);
		case PB_PCIPCOLLIDE_ON:			return GetString(IDS_AP_IPCOLLIDE_ON);
		case PB_PCIPCOLLIDE_STEPS:		return GetString(IDS_AP_IPCOLLIDE_STEPS);
		case PB_PCIPCOLLIDE_BOUNCE:		return GetString(IDS_AP_IPCOLLIDE_BOUNCE);
		case PB_PCIPCOLLIDE_BOUNCEVAR:	return GetString(IDS_AP_IPCOLLIDE_BOUNCEVAR);
		default: 				return TSTR(_T(""));
		}
	}	


void PCloudParticle::GetWorldBoundBox(
		TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
	{
	cnode=inode;
	int type,ptype,disptype,createin;
	pblock->GetValue(PB_VIEWPORTSHOWS,0,type,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,disptype,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	pblock->GetValue(PB_CREATEIN,0,createin,FOREVER);
	if ((createin==3) && (!distnode)) type=0;
	if ((type>2)&&((ptype==RENDTYPE5)||(ptype==RENDTYPE6)||((disptype>0)&&(!custnode))  )) type=1;
	if ((type==3)&&((disptype!=INSTGEOM)||(!custnode))) type=1;
	if (type==2) 
	{ Box3 pbox;
		Matrix3 mat;
		mat = inode->GetObjTMBeforeWSM(t);
		UpdateMesh(t);
		box  = mesh.getBoundingBox();
		box=box*mat;
		for (int i=0; i<parts.points.Count(); i++) {
			if (!parts.Alive(i)) {continue;	}
			Point3 pt = parts.points[i];
			float r=parts.radius[i];
			int axisentered,K;
			pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
			if (axisentered==DIRTRAVEL)
			{ pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			  float len=GetLen(parts.vels[i],K);
			  r*=len;
			}
			if ((disptype==INSTGEOM)&&(custnode))
			{ int tlst=times.tl.Count();if (tlst==0) tlst=1;
			  pbox += pt;
			  for (int level=0;level<tlst;level++)
			  {	Box3 cbb=cmbb[level];
			    Point3 dist=cbb.pmax-cbb.pmin;
				float pdist=Largest(dist)*r*SQR2;
			  pbox += pt + Point3( pdist, 0.0f, 0.0f);
			  pbox += pt + Point3(-pdist, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, pdist, 0.0f);
			  pbox += pt + Point3( 0.0f,-pdist, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, pdist);
			  pbox += pt + Point3( 0.0f, 0.0f,-pdist);
			  }
			}
			else
			{ if (ptype==RENDTET) r*=8.0f;
			  pbox += pt;
			  pbox += pt + Point3( r, 0.0f, 0.0f);
			  pbox += pt + Point3(-r, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, r, 0.0f);
			  pbox += pt + Point3( 0.0f,-r, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, r);
			  pbox += pt + Point3( 0.0f, 0.0f,-r);
			}
		}
		if (!pbox.IsEmpty()) box += pbox;
	  }
	else if (type==3) 
	{ Box3 pbox;
		Matrix3 mat;
/*		if (createin)
		{ mat=distnode->GetObjTMAfterWSM(t);
		  box.pmin=box.pmax=Zero;
		} else */
		{ UpdateMesh(t);
		  mat = inode->GetObjTMBeforeWSM(t);
		  box  = mesh.getBoundingBox();
		}
		box  = box * mat;
		for (int i=0; i<parts.points.Count(); i++) {
			if (!parts.Alive(i)) {continue;	}
			Point3 pt;
			float radius=parts.radius[i];
			int axisentered,K;
			pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
			 if ((ptype!=RENDTYPE5)&&(ptype!=RENDTYPE6))
			 {if (axisentered==DIRTRAVEL)
			{ pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			  float strlen=GetLen(parts.vels[i],K);
			  radius*=strlen;
			 }}
			int n=0,found=0;
			TimeValue Ctime=(thePCloudDraw.anioff?GetCurTime(sdata[i].showframe,(thePCloudDraw.anioff>1?thePCloudDraw.t:parts.ages[i]),thePCloudDraw.anifr):thePCloudDraw.t);
			int nCount=nlist.Count();
		found=((n=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum)))>-1);
	  for (int nb=0;nb<thePCloudDraw.bboxpt[n].numboxes;nb++)
	  { for (int j=0;j<8;j++)
		{ pt=(radius*(thePCloudDraw.bboxpt[n].bpts[nb].pts[j]+thePCloudDraw.bboxpt[n].bpts[nb].Suboffset))+parts[i];
			  pbox += pt;
			}
		}
		}
		if (!pbox.IsEmpty()) box += pbox;
	  }
	else {SimpleParticle::GetWorldBoundBox(t,inode,vpt,box);}
	}

/*BOOL PCloudParticleDraw::DrawParticle(GraphicsWindow *gw,ParticleSys &parts,int i)
{ HCURSOR hCur;
  BOOL chcur=FALSE;
if (disptype==METABALLS)
{ if (firstpart)
  { Point3 pt[4]; 
    int nfaces=obj->metamesh->getNumFaces();
    if (nfaces>LOTSOFACES)
	{ hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	  chcur=TRUE;
	}
    for (int j=0;j<nfaces;j++)
    { pt[0]=obj->metamesh->verts[obj->metamesh->faces[j].v[0]];
      pt[1]=obj->metamesh->verts[obj->metamesh->faces[j].v[1]];
	  pt[2]=obj->metamesh->verts[obj->metamesh->faces[j].v[2]];
      gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
	  if (GetAsyncKeyState (VK_ESCAPE)) 
	  { if (chcur) SetCursor(hCur);	return TRUE;}
    }
    firstpart=FALSE;
  }
}
else if (disptype==INSTGEOM)
{ Point3 pt[4];  
 if (obj->custnode)
  { int n=0,found=0;
    TimeValue Ctime=(anioff?GetCurTime(obj->sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
	found=((n=TimeFound(obj->times,Ctime,(obj->sdata[i].gennum>obj->nCount?obj->nCount:obj->sdata[i].gennum)))>-1);
	float radius=parts.radius[i];
	float elapsedtime=(float)parts.ages[i];
    float Angle=(FloatEQ0(obj->sdata[i].Ts)?0.0f:elapsedtime/obj->sdata[i].Ts)+obj->sdata[i].LamTs;
	if (indir.inaxis)
	  indir.vel=parts.vels[i];
	Point3 nextpt;
	if (found) 
	{
	if (bb)
    { Point3 pt[9];
	  for (int nb=0;nb<bboxpt[n].numboxes;nb++)
	  { for (int j=0;j<8;j++)
	    {if (indir.inaxis)
		    pt[j]=RotateAboutAxis(Angle,parts.points[i],radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset),obj->sdata[i].W,indir);
	    else
		{ nextpt=(radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset))+parts[i];
		  RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		  pt[j]=nextpt;
		}
	  }
		gw->polyline(4,pt,NULL,NULL,TRUE,NULL);
		Point3 tmppt[5]; for (int k=0;k<4;k++) tmppt[k]=pt[4+k];
		gw->polyline(4,tmppt,NULL,NULL,TRUE,NULL);
		tmppt[0]=pt[0];tmppt[1]=pt[4];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[1];tmppt[1]=pt[5];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[2];tmppt[1]=pt[6];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[3];tmppt[1]=pt[7];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
	  if (GetAsyncKeyState (VK_ESCAPE)) return TRUE;
	  }
	}
    else
    { Mesh *mp;
	  mp=&obj->cmesh[n];
	  int nfaces=mp->getNumFaces();
	  if (nfaces>LOTSOFACES)
	  {  hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
		 chcur=TRUE;
	  }
		for (int j=0;j<nfaces;j++)
		{ for (int pnum=0;pnum<3;pnum++)
		{if (indir.inaxis)
	    pt[pnum]=RotateAboutAxis(Angle,parts.points[i],radius*(mp->verts[mp->faces[j].v[pnum]]),obj->sdata[i].W,indir);
		else
		  { nextpt=(radius*(mp->verts[mp->faces[j].v[pnum]]))+parts[i];
		    RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		    pt[pnum]=nextpt;
		  }}
		  gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
		  if (GetAsyncKeyState (VK_ESCAPE))  
		  { if (chcur) SetCursor(hCur);	return TRUE;}
		}
	}
	}
  }
}
else
{  Mesh *pm = new Mesh;
    Point3 pt[4],W;  
	int numF,numV;	
    GetMeshInfo(ptype,1,pm,&numF,&numV);
	if (indir.inaxis)
	    indir.vel=parts.vels[i];
    float elapsedtime=(float)parts.ages[i];
    float Angle=(FloatEQ0(obj->sdata[i].Ts)?0.0f:elapsedtime/obj->sdata[i].Ts)+obj->sdata[i].LamTs;
	W=obj->sdata[i].W;
	if (ptype==RENDTYPE1) PlotTriangle(parts.radius[i],0,0,pm,Angle,&W.x,0,&parts.points[i],indir);
	else if (ptype==RENDTYPE2) PlotCube8(parts.radius[i],0,0,pm,Angle,&W.x,0,&parts.points[i],indir);
	else if (ptype==RENDTYPE3) PlotSpecial(parts.radius[i],0,0,pm,Angle,&W.x,0,&parts.points[i],indir);
	else if (ptype==RENDTET) PlotTet(parts.radius[i],0,0,pm,Angle,W,0,&parts.points[i],indir);
	else if (ptype==REND6PT) Plot6PT(parts.radius[i],0,0,pm,Angle,&W.x,0,&parts.points[i],indir);
   int nfaces=pm->getNumFaces();
   for (int j=0;j<nfaces;j++)
    { pt[0]=pm->verts[pm->faces[j].v[0]];
      pt[1]=pm->verts[pm->faces[j].v[1]];
	  pt[2]=pm->verts[pm->faces[j].v[2]];
      gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
    }
  if (pm) delete pm;
	  if (GetAsyncKeyState (VK_ESCAPE)) return TRUE;
}
return 0;
}*/	
BOOL PCloudParticleDraw::DrawParticle(
		GraphicsWindow *gw,ParticleSys &parts,int i)
{ HCURSOR hCur;
  BOOL chcur=FALSE;
  Point3 pt[4];  
  if (!((disptype==INSTGEOM)&&(bb))) return TRUE;
  if (obj->custnode)
  { int n=0,found=0;
    TimeValue Ctime=(anioff?GetCurTime(obj->sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
	int nCount=obj->nlist.Count();
	found=((n=TimeFound(obj->times,Ctime,(obj->sdata[i].gennum>nCount?nCount:obj->sdata[i].gennum)))>-1);
	float radius=parts.radius[i];
	float elapsedtime=(float)parts.ages[i];
    float Angle=obj->sdata[i].LamTs;
	if (indir.inaxis)
	  indir.vel=parts.vels[i];
	Point3 nextpt;
	if (found) 
	{ Point3 pt[9];
	  if (bboxpt[n].numboxes*8>LOTSOFACES)
	  { hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	    chcur=TRUE;
	  }
	  for (int nb=0;nb<bboxpt[n].numboxes;nb++)
	  { for (int j=0;j<8;j++)
	    {if (indir.inaxis)
	       pt[j]=RotateAboutAxis(Angle,parts.points[i],radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset),obj->sdata[i].W,indir);
	     else
		 { nextpt=(radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset))+parts[i];
		   RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		   pt[j]=nextpt;
		 }
	    }
	    gw->polyline(4,pt,NULL,NULL,TRUE,NULL);
		Point3 tmppt[5]; for (int k=0;k<4;k++) tmppt[k]=pt[4+k];
		gw->polyline(4,tmppt,NULL,NULL,TRUE,NULL);
		tmppt[0]=pt[0];tmppt[1]=pt[4];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[1];tmppt[1]=pt[5];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[2];tmppt[1]=pt[6];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[3];tmppt[1]=pt[7];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		if (GetAsyncKeyState (VK_ESCAPE))  { return TRUE;}
	  }
	}
  }
  if (GetAsyncKeyState (VK_ESCAPE)) 
  { if (chcur) SetCursor(hCur);	return TRUE;}
return 0;
}

int GetDrawType(PCloudParticle *po, int &ptype,int &disptype)
{	int type;
	po->pblock->GetValue(PB_VIEWPORTSHOWS,0,type,FOREVER);
	po->pblock->GetValue(PB_PARTICLECLASS,0,disptype,FOREVER);
	po->pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	TimeValue aniend;

	if ((type>2)&&((ptype==RENDTYPE5)||(ptype==RENDTYPE6)||((disptype>0)&&(!po->custnode))  )) type=1;
	if ((type==3)&&((disptype!=INSTGEOM)||(!po->custnode))) type=1;
	if (type>1)
	{ aniend=GetAnimEnd();
	  int oneframe=GetTicksPerFrame();
      po->thePCloudDraw.anifr=aniend+oneframe;
	   int axisentered;
		po->pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	    if (po->thePCloudDraw.indir.inaxis=(axisentered==DIRTRAVEL))
	    { po->pblock->GetValue(PB_STRETCH,0,po->thePCloudDraw.indir.K,FOREVER);
		  po->thePCloudDraw.indir.oneframe=oneframe;
	    }
	}
	return type;
}


MarkerType PCloudParticle::GetMarkerType() 
{int ptype,disptype,type=GetDrawType(this,ptype,disptype);
	switch (type) {
		case 0:
			parts.SetCustomDraw(NULL);
			return POINT_MRKR;			
		case 1:
			parts.SetCustomDraw(NULL);
			return PLUS_SIGN_MRKR;
		case 2:	{			
			thePCloudDraw.obj = this;
			thePCloudDraw.firstpart=TRUE;
			thePCloudDraw.disptype=disptype;
			thePCloudDraw.ptype=ptype;
			parts.SetCustomDraw(&thePCloudDraw);			
			thePCloudDraw.bb=FALSE;
			return POINT_MRKR;
			}	 
		case 3:{thePCloudDraw.obj = this;
			thePCloudDraw.firstpart=TRUE;
			thePCloudDraw.disptype=disptype;
			thePCloudDraw.ptype=ptype;
			thePCloudDraw.bb=TRUE;
			parts.SetCustomDraw(&thePCloudDraw);			
			return POINT_MRKR;
		   }
		default:
			return PLUS_SIGN_MRKR;
		}
	}



//--- PCloud particle -----------------------------------------------

RefTargetHandle PCloudParticle::Clone(RemapDir& remap) 
	{
	PCloudParticle* newob = new PCloudParticle();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	if (distnode) newob->ReplaceReference(DISTNODE,distnode);
	if (mbase) newob->ReplaceReference(MBASE,mbase);
	newob->nlist.SetCount(nlist.Count());
	newob->llist.SetCount(llist.Count());
	for (int ix=0;ix<nlist.Count();ix++) 
	{ newob->nlist[ix]=NULL;
	  newob->ReplaceReference(ix+BASER,nlist[ix]);
	}
	for (ix=0;ix<llist.Count();ix++) newob->llist[ix]=llist[ix];
	newob->createmeth=createmeth;
	newob->custname = custname;
	newob->distnode = distnode;
	newob->normname = normname;
	newob->mvalid.SetEmpty();	
	newob->tvalid = FALSE;
	newob->dflags=dflags;
	newob->dispmesh=NULL;
	newob->times.tl.SetCount(0);
	newob->nmtls.ZeroCount();
	newob->cancelled=FALSE;
	newob->wasmulti=FALSE;
	newob->stepSize=stepSize;
	int vshow;
	pblock->GetValue(PB_VIEWPORTSHOWS,0,vshow,FOREVER);
	if (vshow>1)
	{int subtree,anioff,custmtl;
	 pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	 pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	 TimeValue aniend=GetAnimEnd();
	 int anifr=aniend+GetTicksPerFrame();
	 TimeValue t=GetCOREInterface()->GetTime();
	 newob->GetTimes(newob->times,t,anifr,anioff);
	 if (vshow==2)
	 { pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
	   newob->GetMesh(t,subtree,custmtl);
	 }
	 else newob->GetallBB(newob->custnode,subtree,t);
	}
	return newob;
	}

void CacheSpin(float *holddata,PCSavePt *sdata,int pcount,BOOL issave)
{ for (int i=0;i<pcount;i++)
	if (issave) holddata[i]=sdata[i].LamTs;
	else sdata[i].LamTs=holddata[i];
}

static float findmappos(float curpos)
{ float mappos;

  return(mappos=((mappos=curpos)<0?0:(mappos>1?1:mappos)));
}

Mesh *PCloudParticle::GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete)
{	float Mval, Uval, Vval,Wval,Angle,elapsedtime;
	int type, count,maptype,anioff,anifr;
	float width;
	Point3 Center;
	TVFace defface;
	BOOL mirror=FALSE;
	TimeValue mt,aniend=GetAnimEnd();
 	Mesh *pm = new Mesh;
	if (cancelled) {ZeroMesh(pm);mesh.InvalidateGeomCache();
	needDelete = TRUE;	return pm;}
    anifr=aniend+GetTicksPerFrame();
	dispt=t;
	int nummtls=0,curmtl=0,multi=0,pc=0,custmtl=0;
	pblock->GetValue(PB_PARTICLETYPE,0,type,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,pc,FOREVER);
	if (pc==METABALLS) type=RENDMETA;
	else if (pc==INSTGEOM)
	{if (custnode==NULL) {type=0;pc=ISSTD;} else type=RENDGEOM;
	pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
	}
	float FperT=GetFrameRate()/(float)TIME_TICKSPERSEC;
	pblock->GetValue(PB_EMITRHEIGHT,t,width,FOREVER);
	pblock->GetValue(PB_MAPPINGTYPE,t,maptype,FOREVER);
	if (maptype)
	 pblock->GetValue(PB_MAPPINGDIST,t,Mval,FOREVER);
	else 
	 pblock->GetValue(PB_MAPPINGTIME,0,mt,FOREVER);
	int createin;
	pblock->GetValue(PB_CREATEIN,0,createin,FOREVER);
    BOOL weirdCenter=(createin==3)&&(distnode);

	int isrend=!TestAFlag(A_NOTREND);
	if ((!isrend)&&((type==RENDTYPE5)||(type==RENDTYPE6))) type=RENDTYPE1;
	Matrix3 wcam,cam=ident;
	Point3 v, v0,v1, otherV=Zero,camV=Zero;
	if (isrend)
	{ cam= Inverse(wcam=view.worldToView);
	otherV=cam.GetRow(2),camV = cam.GetRow(3);}
	Matrix3 tm = inode->GetObjTMAfterWSM(t);
	Matrix3 itm = Inverse(tm);
	if (weirdCenter) tm=distnode->GetObjTMAfterWSM(t);
	int vertexnum=0, face=0,numV=0,numF=0,j=0,tvnum=0,ismapped=0;
	ParticleSys lastparts;
	TimeValue offtime=t%GetTicksPerFrame();
	BOOL midframe;
	midframe=offtime>0;
	float *holddata=NULL;int pcount=0;
	if (isrend)
	{ if (midframe) 
	{ Update(t-offtime,inode);
	  if ((pcount=parts.Count())>0)
	  {	CacheData(&parts,&lastparts);
		holddata=new float[pcount];
		CacheSpin(holddata,sdata,pcount,TRUE);
	  }
	}
		Update(t,inode);
	}
	count = CountLive();
	Center = Zero* tm;
	float Thetah;
	Point3 r1;
	if (count==0) {ZeroMesh(pm);goto quit;}
	else
	{mirror=DotProd(tm.GetRow(0)^tm.GetRow(1),tm.GetRow(2))<0.0f;
		if (type==RENDTYPE6)
	  { if (view.projType) type=RENDTYPE5;
	    else
	    { Thetah=view.fov;
	      r1=cam.GetRow(1);
	    }
	  }
	int gtvnum=0;
	if (pc<METABALLS) GetMeshInfo(type,count,pm,&numF,&numV);
	else if (type==RENDGEOM)
	{ int subtree,onscreen;
	  pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	  pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
//	  if (onscreen!=2) { 
	  thePCloudDraw.t=t;
	  GetTimes(times,t,anifr,anioff);
	  GetMesh(t,subtree,custmtl);
//	  }
	  if (backpatch)
	  { int custmtl,frag;
        pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
        pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	    if ((custnode)&&(frag==INSTGEOM)&& custmtl) 
		  GetSubs(inode,custnode,subtree,t);}
	  TimeValue Ctime;
	  int mnum,tmptvs=0;
	  numV=0;numF=0;
	  BOOL alltex=TRUE;
	  for (int pcnt=0;pcnt<parts.Count();pcnt++)
	  { if (GetAsyncKeyState (VK_ESCAPE)) 
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		if (!parts.Alive(pcnt)) continue;
		Ctime=(anioff?GetCurTime(sdata[pcnt].showframe,(anioff>1?t:parts.ages[pcnt]),anifr):t);
		int nCount=nlist.Count();
		mnum=TimeFound(times,Ctime,(sdata[pcnt].gennum>nCount?nCount:sdata[pcnt].gennum));
		numV+=cmesh[mnum].getNumVerts();
		numF+=cmesh[mnum].getNumFaces();
	  }
	  pm->setNumFaces(numF);
	  pm->setNumVerts(numV);
	  int mcnt=0;
      if (!custmtl) gtvnum=count;
	  else 
	  {	mcnt=times.tl.Count();if (mcnt==0) mcnt=1;
		for (int mc=0;mc<mcnt;mc++)
		{ tmptvs=cmesh[mc].getNumTVerts();
		  if (tmptvs==0) alltex=FALSE;
		  else gtvnum+=tmptvs;
		}
        if ((!alltex)&&(gtvnum>0))
		{ defface.setTVerts(gtvnum,gtvnum,gtvnum);gtvnum++;}
	  }
	  int gtv;
//	  pm->setNumTVerts(gtv=(custmtl?gtvnum:count*numV));
	  pm->setNumTVerts(gtv=gtvnum);
	  if ((custmtl)&&(gtvnum>0))
	  { int tvs=0,mtvs=0,imtv;
		 for (int mc=0;mc<mcnt;mc++)
	     { mtvs=cmesh[mc].getNumTVerts();
		   if (mtvs>0)
		   { for (imtv=0;imtv<mtvs;imtv++)
			   pm->tVerts[tvs++]=cmesh[mc].tVerts[imtv];
		   } 
		 }
		 if (!alltex) pm->tVerts[tvs]=deftex;
	  }
	  pm->setNumTVFaces(gtv>0?numF:0);
	}
	Uval=0.5f;Wval=0.5f;
	Point3 ipt;
	int i;
	if (count>0)
	{
	if (type==RENDMETA)
	{ float res,bstr,thres=0.6f;int notdraft;
      pblock->GetValue(PB_METATENSION,t,bstr,FOREVER);
      pblock->GetValue(PB_PCNOTDRAFT,t,notdraft,FOREVER);
	  notdraft = (notdraft?0:1);
	  if (isrend)
		pblock->GetValue(PB_METACOURSE,0,res,FOREVER);
	  else pblock->GetValue(PB_METACOURSEV,0,res,FOREVER);
	  metap.CreateMetas(parts,pm,thres,res,bstr,notdraft);	
	  for (int j=0;j<pm->getNumVerts();j++)
         pm->verts[j] = itm * pm->verts[j];
 	}
	else
	{ Mtl *mtl;
	  mtl=inode->GetMtl();
	  if (mtl)
	  { Class_ID mc=Class_ID(MULTI_CLASS_ID,0);
	    Class_ID oc=mtl->ClassID();
	    if (multi=(oc==mc))
	    { nummtls=mtl->NumSubMtls();
		  if (nummtls==0) multi=0;
		}
	  }
	wasmulti=multi;
	InDirInfo indir;indir.vel=Zero;indir.K=0;indir.oneframe=GetTicksPerFrame();
	int axisentered;
    pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	if (indir.inaxis=(axisentered==DIRTRAVEL))
	{ 	  pblock->GetValue(PB_STRETCH,0,indir.K,FOREVER);
	}
	MtlID cm;
    for (i=0; i<parts.Count(); i++) 
	{ if (GetAsyncKeyState (VK_ESCAPE)) 
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		if (!parts.Alive(i)) continue;
	    if (multi) 
		{ curmtl=sdata[i].themtl;
	      if (curmtl>=nummtls) 
		    curmtl=curmtl % nummtls;
	    } else curmtl=i;
	  if (indir.inaxis)
	    indir.vel=parts.vels[i];
		float x;
	    elapsedtime=(float)parts.ages[i];
		if (maptype) Vval=(x=Length(parts[i]-Center))/Mval;
		else Vval=(float)elapsedtime/mt;
        Angle=sdata[i].LamTs;
	    if (type==RENDTYPE1) PlotTriangle(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTYPE2) PlotCube8(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTYPE3) PlotSpecial(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTET) PlotTet(parts.radius[i],vertexnum,face,pm,Angle,sdata[i].W,curmtl,&parts.points[i],indir);
	    else if (type==REND6PT) Plot6PT(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
		else if (type==RENDSPHERE) PlotSphere(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
		else if (type==RENDTYPE5)
	    {   v  = (view.projType?otherV:Normalize(camV-parts[i]));
			v0 = Normalize(v111^v) * parts.radius[i];
		    v1 = Normalize(v0^v) * parts.radius[i];
		    pm->verts[vertexnum] = (parts[i]+v0+v1);
		    pm->verts[vertexnum+1] = (parts[i]-v0+v1);
		    pm->verts[vertexnum+2] = (parts[i]-v0-v1);
		    pm->verts[vertexnum+3] = (parts[i]+v0-v1);
		    for (int l=0;l<4;l++)
		      RotateOnePoint(pm->verts[vertexnum+l],&parts.points[i].x,&v.x,Angle);
		    AddFace(vertexnum+3,vertexnum+2,vertexnum+1,face,pm,curmtl);
		    AddFace(vertexnum+1,vertexnum,vertexnum+3,face+1,pm,curmtl);
		 }
		 else if (type==RENDTYPE6)
		 { 	Point3 a,b,Rv;
			float Theta,R=Length(Rv=(parts[i]-camV)),angle=parts.radius[i]*R*Thetah/view.screenW;
			a=angle*Normalize(r1^Rv);
			b=angle*Normalize(a^Rv);
			pm->verts[vertexnum]=parts[i];
			for (int l=0;l<numV;l++)
			{ Theta=(l-1)*PIOver5;
			  pm->verts[vertexnum+l]=parts[i]+(float)cos(Theta)*a+(float)sin(Theta)*b;
			}
			for (l=0;l<numF-1;l++)
			  AddFace(vertexnum,vertexnum+1+l,vertexnum+2+l,face+l,pm,curmtl);
		    AddFace(vertexnum,vertexnum+1+l,vertexnum+1,face+l,pm,curmtl);
		 }
		 else if (type==RENDGEOM)
		 { TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		 int nCount=nlist.Count();
		 int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum));
		   if (mnum<0) continue;
		   numF=cmesh[mnum].getNumFaces();
		   numV=cmesh[mnum].getNumVerts();
			if ((gtvnum>0)&&(custmtl))
			{ for (j=0;j<numF;j++)
				if (cmesh[mnum].getNumTVerts()>0)
				    pm->tvFace[j+face].setTVerts(cmesh[mnum].tvFace[j].t[0],cmesh[mnum].tvFace[j].t[1],cmesh[mnum].tvFace[j].t[2]);
			   else pm->tvFace[j+face]=defface;
			}
			int jf=face;
		  for (j=0;j<numF;j++)
		  { Face cface=cmesh[mnum].faces[j];
			pm->faces[jf].flags=cface.flags;
		    pm->faces[jf].setSmGroup(cface.smGroup);
		    pm->faces[jf].setVerts(vertexnum+cface.v[0],vertexnum+cface.v[1],vertexnum+cface.v[2]);
		    if (!custmtl)
		      pm->faces[jf].setMatID((MtlID)curmtl); 
		    else
			{cm=cface.getMatID();
			 int mtlgen=times.tl[mnum].gennum-1,maxmtl=nmtls.Count();
			 if (mtlgen>=maxmtl) mtlgen=maxmtl-1;
			 if ((mtlgen>-1)&&((times.tl.Count()>0)&&(times.tl[mnum].gennum>0)))
				cm+=nmtls[mtlgen];
			 pm->faces[jf].setMatID(cm);
			}
			pm->faces[jf].setEdgeVisFlags(cface.getEdgeVis(0),cface.getEdgeVis(1),cface.getEdgeVis(2));
			jf++;
//		  pm->faces[face].setEdgeVisFlags(f[j].flags&EDGE_A,f[j].flags&EDGE_Bf[j].flags&EDGE_A);
		  }
		  PlotCustom(parts.radius[i],i,vertexnum,pm,Angle,&sdata[i].W.x,&cmesh[mnum],&parts.points[i],numV,indir);
		 }
	  // Convert to object coords
        for (j=0;j<numV;j++)
        { pm->verts[vertexnum] = itm * pm->verts[vertexnum];
          vertexnum++;
        }
		if ((type!=RENDTET)&&(!custmtl))
		{ pm->tVerts[tvnum]=Point3(findmappos(Uval),findmappos(Vval),findmappos(Wval));
	      for (j=0;j<numF;j++)
          { pm->tvFace[face++].setTVerts(tvnum,tvnum,tvnum); }	
	      tvnum++;
		} else face+=numF;
	  }
	}
}
}
  if ((isrend)&&(midframe))
  { if (pcount>0)
  { CacheData(&lastparts,&parts);
	CacheSpin(holddata,sdata,pcount,FALSE);
	delete[] holddata;}
    tvalid=t-offtime;
  }
  if (mirror) SwitchVerts(pm);
quit:mesh.InvalidateGeomCache();
	needDelete = TRUE;
	return pm;
}

const TCHAR *PCloudClassDesc::ClassName ()	{return GetString(IDS_AP_PCLOUD);}
const TCHAR *PCloudClassDesc::Category ()	{return GetString(IDS_RB_PARTICLESYSTEMS);}
TCHAR *PCloudParticle::GetObjectName() {return GetString(IDS_AP_PCLOUDGC);}


void PCloudParticle::GetTimes(TimeLst &times,TimeValue t,int anifr,int ltype)
{ int m,n,found,tmax,tnums=0,tgen;
  TimeValue tframe;
  times.tl.SetCount(0);times.tl.Shrink();
  times.tl.Resize(100);tmax=100;times.tl.SetCount(tmax);
  for (m=0;m<parts.Count();m++)
  { if (!parts.Alive(m)) continue;
    if (ltype)
	{ if (ltype==1) tframe=sdata[m].showframe+parts.ages[m];
	  else tframe=sdata[m].showframe+t;
//      if ((tframe>=anifr)&&(anifr!=0)) tframe=tframe % anifr;
	} else tframe=t;
	found=n=0;
	int nCount=nlist.Count();
	tgen=(sdata[m].gennum>nCount?nCount:sdata[m].gennum);
	while ((n<tnums)&&(!found))
	{ found=((times.tl[n].gennum==tgen)&&(tframe==times.tl[n].tl));
	  n++;
	}
	if (!found) 
	{ if (tnums>=tmax) 
	  { times.tl.Resize(tmax+=100);times.tl.SetCount(tmax);}
	  times.tl[tnums].gennum=tgen;times.tl[tnums++].tl=tframe;
	}
  }
  times.tl.SetCount(tnums);
  times.tl.Shrink();
}

BOOL PCPickOperand::Filter(INode *node)
	{
	if ((node)&&(!node->IsGroupHead())) {
		ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
		if (!IsGEOM(os.obj)) {
			node = NULL;
			return FALSE;
			}
		}

	return node ? TRUE : FALSE;
	}

BOOL PCPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if ((node)&&(!node->IsGroupHead())) {
		ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		if (!IsGEOM(os.obj)) {
			node = NULL;
			return FALSE;
			}
		}

	return node ? TRUE : FALSE;
	}

void PCloudParticle::ShowName(int dist)
{ TSTR name;
  if (dist==shownormname)
  { FormatName(name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (mbase ? normname : TSTR(GetString(IDS_AP_NONE))));
    if (hgen) SetWindowText(GetDlgItem(hgen, IDC_AP_PCLOUDOBJDIRNAME), name);}
  else if (dist) 
  { FormatName(name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (distnode ? distname : TSTR(GetString(IDS_AP_NONE))));
    if (hparam) SetWindowText(GetDlgItem(hparam, IDC_AP_FILLPICKOBJECT), name);}
  else
  { FormatName(name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (custnode ? custname : TSTR(GetString(IDS_AP_NONE))));
    if (hptype) SetWindowText(GetDlgItem(hptype, IDC_AP_INSTANCESRCNAME), name);
  }
}

BOOL PCPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);

	INodeTab nodes;
	int subtree;
//	if (dodist) {nodes.SetCount(1);nodes[0]=node;}
	 if (dodist==1)
	  {	theHold.Begin();
		theHold.Put(new CreatePCPartPickNode(po,po->distname,node->GetName(),1));
		if (po->distnode) po->ReplaceReference(DISTNODE,node,TRUE);
	    else po->MakeRefByID(FOREVER,DISTNODE,node);	
		theHold.Accept(GetString(IDS_AP_COMPICK));
	    po->distname = TSTR(node->GetName());
		po->createmeth=3;
		po->pblock->SetValue(PB_CREATEIN,0,po->createmeth);
		SpinnerOff(po->hparam,IDC_AP_EMITHGTSPIN,IDC_AP_EMITHGT);
		SpinnerOff(po->hparam,IDC_AP_EMITDEPSPIN,IDC_AP_EMITDEP);
	    po->ShowName(dodist);	
	  }
	  else
	  { po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  if (node->IsGroupMember()) 
	   while (node->IsGroupMember()) node=node->GetParentNode();
	  nodes.SetCount(0);
	  if (po->flags=(node->IsGroupHead()?1:0)) MakeGroupNodeList(node,&nodes,subtree,ip->GetTime());
	  else MakeNodeList(node,&nodes,subtree,ip->GetTime());
	  if (dodist==0)
	  {	theHold.Begin();
		theHold.Put(new CreatePCPartPickNode(po,po->custname,node->GetName(),0));
		if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	    else po->MakeRefByID(FOREVER,CUSTNODE,node);	
		theHold.Accept(GetString(IDS_AP_COMPICK));
	    po->custname = TSTR(node->GetName());
		po->ShowName(dodist);	
	  }
	  else if (dodist==2)
	 {  theHold.Begin();
		theHold.Put(new PCObjectListRestore(po));
		po->AddToList(node,po->nlist.Count(),TRUE);
		theHold.Accept(GetString(IDS_AP_OBJADD));
	  }
	  else 
	  { theHold.Begin();
		theHold.Put(new PCObjectListRestore(po));
	    po->AddToList(node,repi,FALSE);
		theHold.Accept(GetString(IDS_AP_OBJADD));
	  }
  	  // Automatically check show result and do one update
		int frag,custmtl,onscreen;
		po->pblock->GetValue(PB_CUSTOMMTL,0,custmtl,FOREVER);
		po->pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
		po->pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
		if ((frag==INSTGEOM)&&(onscreen>1))
		  if (onscreen==2)
			po->GetMesh(ip->GetTime(),subtree,custmtl);
		  else po->GetallBB(node,subtree,ip->GetTime());
	} 
	ip->FlashNodes(&nodes);
	nodes.ZeroCount();nodes.Shrink();
	po->valid=FALSE;
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	if (po->creating) {
		theCreatePCloudMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreatePCloudMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void PCPickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut;
	if (dodist>=2)
	{ iBut=GetICustButton(GetDlgItem(po->spawn,(dodist==3?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK)));
	  TurnButton(po->spawn,(dodist==2?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK),FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEDELETE,FALSE);
	  TurnButton(po->hptype,IDC_AP_OBJECTPICK,FALSE);
	  TurnButton(po->hparam,IDC_AP_FILLPICKBUTTON,FALSE);
	}
    else if (dodist)
	{ iBut=GetICustButton(GetDlgItem(po->hparam,IDC_AP_FILLPICKBUTTON));
	  TurnButton(po->hptype,IDC_AP_OBJECTPICK,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPESTD),FALSE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPEMET),FALSE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPEINSTANCE),FALSE);
	}
	else
	{iBut=GetICustButton(GetDlgItem(po->hptype,IDC_AP_OBJECTPICK));
	  TurnButton(po->hparam,IDC_AP_FILLPICKBUTTON,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
	}
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
	}

void PCPickOperand::ExitMode(IObjParam *ip)
	{if (!po->ip) return;
	ICustButton *iBut;
	if (dodist>=2)
	{ iBut=GetICustButton(GetDlgItem(po->spawn,(dodist==3?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK)));
	  PCCheckInstButtons(po->pblock,po->hptype);
	  TurnButton(po->hparam,IDC_AP_FILLPICKBUTTON,TRUE);
	  if (dodist==3)
	   TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,TRUE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEDELETE,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
	}
	else if (dodist) 
	{ iBut=GetICustButton(GetDlgItem(po->hparam,IDC_AP_FILLPICKBUTTON));
	  PCCheckInstButtons(po->pblock,po->hptype);
	  PCCheckSpawnButtons(po->pblock,po->spawn,repi);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPESTD),TRUE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPEMET),TRUE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPECHUNKS),TRUE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPEINSTANCE),TRUE);
	}
	else
	{ iBut=GetICustButton(GetDlgItem(po->hptype,IDC_AP_OBJECTPICK));
	  TurnButton(po->hparam,IDC_AP_FILLPICKBUTTON,TRUE);
	  PCCheckSpawnButtons(po->pblock,po->spawn,repi);
	}
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
	}

BOOL PCPickNorm::Filter(INode *node)
	{
	return node ? TRUE : FALSE;
	}

BOOL PCPickNorm::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	return node ? TRUE : FALSE;
	}

BOOL PCPickNorm::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	nodes.SetCount(1);nodes[0]=node;
	ip->FlashNodes(&nodes);
	theHold.Begin();
	theHold.Put(new CreatePCPartPickNode(po,po->normname,node->GetName(),shownormname));
	if (po->mbase) po->ReplaceReference(MBASE,node,TRUE);
	else po->MakeRefByID(FOREVER,MBASE,node);
	theHold.Accept(GetString(IDS_AP_COMPICK));
	po->normname = TSTR(node->GetName());
	po->ShowName(shownormname);
	po->valid=FALSE;
	
	if (po->creating) {
		theCreatePCloudMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreatePCloudMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void PCPickNorm::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(po->hgen,IDC_AP_OBJECTDIRPICK));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	}

void PCPickNorm::ExitMode(IObjParam *ip)
	{
	if (po->hgen)
	{	ICustButton *iBut = GetICustButton(GetDlgItem(po->hgen,IDC_AP_OBJECTDIRPICK));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
	}
	}

RefTargetHandle PCloudParticle::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case DISTNODE: return (RefTargetHandle)distnode;
		case CUSTNODE: return (RefTargetHandle)custnode;
		case MBASE: return (RefTargetHandle)mbase;
		default: return (RefTargetHandle)nlist[i-BASER];
		}
	}

void PCloudParticle::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case DISTNODE: distnode = (INode *)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		case MBASE: mbase = (INode *)rtarg; return;
		default: nlist[i-BASER]= (INode *)rtarg;return;
		}
	}

RefResult PCloudParticle::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode) 
				{if (theHold.Holding()) theHold.Put(new CreatePCPartDelNode(this,custnode->GetName(),0));
				custnode=NULL;custname=TSTR(_T(" "));cancelled=FALSE;
				}
			  if (hTarget==distnode) {if (theHold.Holding()) theHold.Put(new CreatePCPartDelNode(this,distnode->GetName(),1));
				  distnode=NULL;distname=TSTR(_T(" "));cancelled=FALSE;
				createmeth=0;
				pblock->SetValue(PB_CREATEIN,0,createmeth);
			  }
			  if (hTarget==mbase) {if (theHold.Holding()) theHold.Put(new CreatePCPartDelNode(this,mbase->GetName(),shownormname));mbase=NULL;normname=TSTR(_T(" "));cancelled=FALSE;}
			  BOOL notfound=TRUE; 
			  for (int i=0;(i<nlist.Count())&&(notfound);i++)
				if (hTarget==nlist[i]) 
				{ DeleteFromList(i,TRUE);
				  notfound=FALSE;cancelled=FALSE;}
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName(0);cancelled=FALSE;
				}
			  if (hTarget==distnode) 
			  { distname = TSTR(distnode->GetName());
			    ShowName(1);cancelled=FALSE;
				}
			  if (hTarget==mbase) 
			  { normname = TSTR(mbase->GetName());
			    ShowName(shownormname);cancelled=FALSE;
				}
			  BOOL notfound=TRUE;
			  for (int i=0;(i<nlist.Count())&&(notfound);i++)
				if (hTarget==nlist[i]) 
			      {notfound=FALSE;SetUpList();cancelled=FALSE;}
			  break;
			  			}
		case REFMSG_NODE_LINK:		
		case REFMSG_CHANGE:
			{ int pblst=0;
			  if (pblock && (pblock==hTarget))
			  { pblst=pblock->LastNotifyParamNum();
			    if (pblst==PB_METACOURSE)
			  	  return REF_STOP;
			  }
		  	  MeshInvalid();
			  ParticleInvalid();
			  if (editOb==this) InvalidateUI();
			  cancelled=FALSE;
			break;
			}
		case REFMSG_SUBANIM_STRUCTURE_CHANGED:
			EnableWindow(GetDlgItem(hptype,IDC_SP_MAPCUSTOMEMIT),TRUE);
			if (editOb==this) InvalidateUI();
//			NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
			break;
		default: SimpleParticle::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}

class PCloudPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		PCloudPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((PCloudParticle*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			int mc;
			if (oldVer<1) {	
				((PCloudParticle*)targ)->pblock->GetValue(PB_METACOURSE,0,mc,FOREVER);
				((PCloudParticle*)targ)->pblock->SetValue(PB_METACOURSEV,0,mc);
				}
			if (oldVer<2) {	
				((PCloudParticle*)targ)->pblock->SetValue(PB_SPAWNPERCENT,0,100);
				}
			if (oldVer<3) {	
				((PCloudParticle*)targ)->pblock->SetValue(PB_PCNOTDRAFT,0,0);
				}
			if (oldVer<4) {	
				((PCloudParticle*)targ)->pblock->SetValue(PB_SPAWNDIEAFTER,0,0);
				((PCloudParticle*)targ)->pblock->SetValue(PB_SPAWNDIEAFTERVAR,0,0.0f);
				}
			if (oldVer<5)
			{ ((PCloudParticle*)targ)->pblock->SetValue(PB_PCIPCOLLIDE_ON,0,0);
			  ((PCloudParticle*)targ)->pblock->SetValue(PB_PCIPCOLLIDE_STEPS,0,2);
			  ((PCloudParticle*)targ)->pblock->SetValue(PB_PCIPCOLLIDE_BOUNCE,0,1.0f);
			  ((PCloudParticle*)targ)->pblock->SetValue(PB_PCIPCOLLIDE_BOUNCEVAR,0,0.0f);
			}
			delete this;
			}
	};

#define PC_CUSTNAME_CHUNK	0x0100
#define PC_DISTNAME_CHUNK	0x0200
#define PC_CUSTFLAGS_CHUNK	0x0300
#define PC_SPAWNC_CHUNK		0x0400
#define PC_LCNT_CHUNK		0x0500
#define PC_LIFE_CHUNK		0x0600
#define PC_NORMNAME_CHUNK	0x0700

IOResult PCloudParticle::Save(ISave *isave)
	{ 	ULONG nb;

	isave->BeginChunk(PC_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();

	isave->BeginChunk(PC_DISTNAME_CHUNK);		
	isave->WriteWString(distname);
	isave->EndChunk();

	isave->BeginChunk(PC_CUSTFLAGS_CHUNK);		
	isave->Write(&flags,sizeof(flags),&nb);
	isave->EndChunk();

	int nCount=nlist.Count();
	isave->BeginChunk(PC_SPAWNC_CHUNK);		
	isave->Write(&nCount,sizeof(nCount),&nb);
	isave->EndChunk();

	int Lcnt=llist.Count();
	isave->BeginChunk(PC_LCNT_CHUNK);		
	isave->Write(&Lcnt,sizeof(Lcnt),&nb);
	isave->EndChunk();

	isave->BeginChunk(PC_LIFE_CHUNK);
	for (int i=0;i<Lcnt;i++)
	{ isave->Write(&llist[i],sizeof(int),&nb);
	}
	isave->EndChunk();

	isave->BeginChunk(PC_NORMNAME_CHUNK);		
	isave->WriteWString(normname);
	isave->EndChunk();

	return IO_OK;
	}

IOResult PCloudParticle::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	iload->RegisterPostLoadCallback(
			new PCloudPostLoadCallback(
				new ParamBlockPLCB(pcversions,NUM_OLDVERSIONS,&curVersionPC,this,0)));
	int cnmtl=0;
	// Default names
	custname = TSTR(_T(" "));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case PC_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			case PC_DISTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				distname = TSTR(buf);
				break;
				}
			case PC_CUSTFLAGS_CHUNK:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;
			case PC_SPAWNC_CHUNK:
				{  int nCount;
					res=iload->Read(&nCount,sizeof(nCount),&nb);
					nlist.SetCount(nCount);
					for (int i=0; i<nCount; i++) nlist[i] = NULL;
				}
				break;
			case PC_LCNT_CHUNK:
				{	int Lcnt;
					res=iload->Read(&Lcnt,sizeof(Lcnt),&nb);
					llist.SetCount(Lcnt);
					for (int i=0; i<Lcnt; i++) llist[i] = NULL;
				}
				break;
			case PC_LIFE_CHUNK:
				{	for (int i=0;i<llist.Count();i++)
					res=iload->Read(&llist[i],sizeof(int),&nb);}
				break;
			case PC_NORMNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				normname = TSTR(buf);
				break;
				}
		}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}

PCloudParticle::PCloudParticle()
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
     int tpf=GetTicksPerFrame();

	MakeRefByID(FOREVER, PBLK, CreateParameterBlock(spdescVer5, PBLOCK_LENGTH_PCLOUD, CURRENT_VERSION));
	pblock->SetValue(PB_SPEED,0,0.0f);
	pblock->SetValue(PB_SPEEDVAR,0,0.0f);
	pblock->SetValue(PB_PBIRTHRATE,0,10);
	pblock->SetValue(PB_PTOTALNUMBER,0,100);
	pblock->SetValue(PB_BIRTHMETHOD,0,0);
	pblock->SetValue(PB_DISPLAYPORTION,0,1.0f);
	pblock->SetValue(PB_EMITSTART,0,0);
	pblock->SetValue(PB_EMITSTOP,0,0);// correct constant?
	pblock->SetValue(PB_DISPUNTIL,0,100*FToTick);// correct constant?
	pblock->SetValue(PB_LIFE,0,101*FToTick);// correct constant?
	pblock->SetValue(PB_LIFEVAR,0,0.0f);
	pblock->SetValue(PB_SIZE,0,1.0f);
	pblock->SetValue(PB_SIZEVAR,0,0.0f);
	pblock->SetValue(PB_GROWTIME,0,0);
	pblock->SetValue(PB_FADETIME,0,0);
	pblock->SetValue(PB_RNDSEED,0,12345);

	pblock->SetValue(PB_PARTICLETYPE,0,0);
	pblock->SetValue(PB_METATENSION,0,1.0f);
	pblock->SetValue(PB_METATENSIONVAR,0,0.0f);
	pblock->SetValue(PB_METAAUTOCOARSE,0,1);
	pblock->SetValue(PB_METACOURSE,0,0.5f);
	pblock->SetValue(PB_METACOURSEV,0,1.0f);
	pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
	pblock->SetValue(PB_MAPPINGTYPE,0,0);
	pblock->SetValue(PB_MAPPINGTIME,0,30*FToTick);
	pblock->SetValue(PB_MAPPINGDIST,0,100.0f);

	pblock->SetValue(PB_SPINTIME,0,10000*FToTick);
	pblock->SetValue(PB_SPINTIMEVAR,0,0.0f);
	pblock->SetValue(PB_SPINPHASE,0,0.0f);
	pblock->SetValue(PB_SPINPHASEVAR,0,0.0f);
	pblock->SetValue(PB_SPINAXISTYPE,0,0);
	pblock->SetValue(PB_SPINAXISX,0,1.0f);
	pblock->SetValue(PB_SPINAXISY,0,0.0f);
	pblock->SetValue(PB_SPINAXISZ,0,0.0f);
	pblock->SetValue(PB_SPINAXISVAR,0,0.0f);
	pblock->SetValue(PB_DIRX,0,1.0f);
	pblock->SetValue(PB_DIRY,0,0.0f);
	pblock->SetValue(PB_DIRZ,0,0.0f);

	pblock->SetValue(PB_EMITVINFL,0,100.0f);
	pblock->SetValue(PB_EMITVMULT,0,1.0f);
	pblock->SetValue(PB_EMITVMULTVAR,0,0.0f);

	pblock->SetValue(PB_BUBLAMP,0,0.0f);
	pblock->SetValue(PB_BUBLAMPVAR,0,0.0f);
	pblock->SetValue(PB_BUBLPER,0,100000*FToTick);
	pblock->SetValue(PB_BUBLPERVAR,0,0.0f);
	pblock->SetValue(PB_BUBLPHAS,0,0.0f);
	pblock->SetValue(PB_BUBLPHASVAR,0,0.0f);

	pblock->SetValue(PB_EMITRWID,0,0.0f);
	pblock->SetValue(PB_EMITRHID,0,0);
	pblock->SetValue(PB_SPAWNGENS,0,1);
	pblock->SetValue(PB_SPAWNPERCENT,0,100);
	pblock->SetValue(PB_SPAWNCOUNT,0,1);
	pblock->SetValue(PB_CREATEIN,0,0);
	createmeth=0;

	pblock->SetValue(PB_PCNOTDRAFT,0,0);
	pblock->SetValue(PB_SPAWNDIEAFTER,0,0);
	pblock->SetValue(PB_SPAWNDIEAFTERVAR,0,0.0f);
	pblock->SetValue(PB_PCIPCOLLIDE_ON,0,0);
	pblock->SetValue(PB_PCIPCOLLIDE_STEPS,0,2);
	pblock->SetValue(PB_PCIPCOLLIDE_BOUNCE,0,1.0f);
	pblock->SetValue(PB_PCIPCOLLIDE_BOUNCEVAR,0,0.0f);
	
	sdata=NULL;
	cnode=NULL;
	custnode=NULL;
	custname=TSTR(_T(" "));
	distnode=NULL;
	mbase=NULL;
	normname=TSTR(_T(" "));
	nlist.ZeroCount();
	llist.ZeroCount();
	distname=TSTR(_T(" "));
	ResetSystem(0,FALSE);
	size=42*isize+fsize*39;
	times.tl.SetCount(0);
	cmesh=NULL;
	cmbb=NULL;
	dispmesh=NULL;
	dispt=-99999;
	thePCloudDraw.bboxpt=NULL;
	nmtls.ZeroCount();
	parts.points.ZeroCount();
	cancelled=FALSE;
	wasmulti=FALSE;
	maincount=0;
	fragflags=-1;
	dflags=APRTS_ROLLUP_FLAGS;
	backpatch=TRUE;
	origmtl=NULL;
	ClearAFlag(A_NOTREND);
    stepSize=GetTicksPerFrame();
}

PCloudParticle::~PCloudParticle()
{
	if (sdata) {delete[] sdata;sdata=NULL;}
	DeleteAllRefsFromMe();
	pblock=NULL;
	parts.FreeAll();
	times.tl.Resize(0);
	nmtls.Resize(0);
	llist.ZeroCount();llist.Shrink();
	nlist.ZeroCount();nlist.Shrink();
	if (cmesh) delete[] cmesh;if (dispmesh) delete dispmesh;
	if (cmbb) delete[] cmbb;
	if (thePCloudDraw.bboxpt) delete[] thePCloudDraw.bboxpt;
}

void PCloudParticle::SetUpList()
{ SendMessage(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),LB_RESETCONTENT,0,0);
  for (int i=0;i<nlist.Count(); i++) 
		SendMessage(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)(nlist[i]->GetName()));
}

void PCloudParticle::AddToList(INode *newnode,int i,BOOL add)
{	if (add)
	{ nlist.Insert(i,1,&newnode);
	  MakeRefByID(FOREVER,BASER+i,newnode);
	}	  
	else ReplaceReference(i+BASER,newnode);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	SetUpList();
}

void PCloudParticle::DeleteFromList(int nnum,BOOL all)
{ int nCount=nlist.Count();
  INode *cnode=nlist[nnum];
  DeleteReference(nnum+BASER);
  if (theHold.Holding() && !TestAFlag(A_HELD)) 
	  theHold.Put(new PCObjectListRestore(this));
  nlist.Delete(nnum,1);
  if (all) 
  { for (int di=nnum;di<nlist.Count();di++)
     if (nlist[di]==cnode)
	 { DeleteReference(di+BASER);
	   nlist.Delete(di,1);
	 }
  }
  NotifyDependents(FOREVER,0,REFMSG_CHANGE);
  if (ip) SetUpList();
  valid=FALSE;
}
void PCloudParticle::SetUpLifeList()
{ TCHAR buffer[20];
  SendMessage(GetDlgItem(spawn,IDC_AP_LIFEQUEUE),LB_RESETCONTENT,0,0);
  for (int i=0;i<llist.Count(); i++) 
  {	_itoa(llist[i], buffer, 10 );
	SendMessage(GetDlgItem(spawn,IDC_AP_LIFEQUEUE),LB_ADDSTRING,0,(LPARAM)(TCHAR*)buffer);
  }
} 

void PCloudParticle::AddToLifeList(int newlife)
{	llist.Insert(llist.Count(),1,&newlife);
	SetUpLifeList();
}

void PCloudParticle::DeleteFromLifeList(int nnum)
{ 	llist.Delete(nnum,1);
    if (ip) SetUpLifeList();
}
int PCloudParticle::HitTest(
		TimeValue t, INode *inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt) 
	{	
	BOOL doupdate=((!cancelled)&&((t!=tvalid)||!valid));
	if (doupdate) Update(t,inode);
	Point2 pt( (float)p[0].x, (float)p[0].y );
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion, type, crossing, 4, p);
	DWORD rlim  = gw->getRndLimits();
	int res;

	gw->setTransform(ident);
	int ptype,disptype,dtype=GetDrawType(this,ptype,disptype);
	if ((dtype<2)||(dtype==3))
	{  if (parts.HitTest(gw,&hitRegion,flags&HIT_ABORTONHIT,GetMarkerType()))
		{return TRUE;}
	}
	else
	{ if ((t!=dispt)||doupdate||!dispmesh)
	  {	NullView nullView;
		BOOL needdel;
		if (dispmesh) delete dispmesh;
		SetAFlag(A_NOTREND);
	    dispmesh=GetRenderMesh(t,inode,nullView,needdel);
		ClearAFlag(A_NOTREND);
		}
		gw->setRndLimits(rlim);
		gw->setTransform(inode->GetObjTMBeforeWSM(t));
		res = dispmesh->select(gw, &particleMtl, &hitRegion, flags & HIT_ABORTONHIT);
		if (res) return TRUE;
	}
	
	if (EmitterVisible()) {
		gw->setRndLimits((rlim|GW_PICK|GW_WIREFRAME) 
			& ~(GW_ILLUM|GW_BACKCULL|GW_FLAT|GW_SPECULAR));
		gw->setTransform(inode->GetObjTMBeforeWSM(t));
		res = mesh.select(gw, &particleMtl, &hitRegion, flags & HIT_ABORTONHIT);

		gw->setRndLimits(rlim);
	} else {
		res = 0;
		}
	return res;
	}

int PCloudParticle::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
{   if (!OKtoDisplay(t)) return 0;
	if (t!=tvalid) cancelled=FALSE;
	if ((ip && origmtl) &&(origmtl!=inode->GetMtl()))
	{ EnableWindow(GetDlgItem(hptype,IDC_SP_MAPCUSTOMEMIT),TRUE);
	  origmtl=NULL;
	}
	GraphicsWindow *gw = vpt->getGW();
	DWORD rlim  = gw->getRndLimits();
	BOOL doupdate=((!cancelled)&&((t!=tvalid)||!valid));
	if (!doupdate) doupdate=CheckMtlChange(inode->GetMtl(),wasmulti);
	if (doupdate) Update(t,inode);

	// Draw emitter
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER) );	// removed BC on 4/29/99
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_PARTICLE_EM));

	if (EmitterVisible()) {
		gw->setTransform(inode->GetObjTMBeforeWSM(t));	
		mesh.render(gw, &particleMtl, 
			(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, COMP_ALL);
		}
		
	  Material *mtl = gw->getMaterial();	
	  if (!inode->Selected() && !inode->IsFrozen())
		gw->setColor( LINE_COLOR, mtl->Kd[0], mtl->Kd[1], mtl->Kd[2]);
	int ptype,disptype,type=GetDrawType(this,ptype,disptype);
	if (type==3)
	{ thePCloudDraw.obj = this;
		thePCloudDraw.firstpart=TRUE;
		thePCloudDraw.disptype=disptype;
		thePCloudDraw.ptype=ptype;
		thePCloudDraw.bb=TRUE;
		parts.SetCustomDraw(&thePCloudDraw);			
	}
	if ((type<2)||(type==3)) // Draw particles
	{ if (type<2) parts.SetCustomDraw(NULL);
	  MarkerType mt=(type==0?POINT_MRKR:PLUS_SIGN_MRKR);
	  gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL| (rlim&(GW_Z_BUFFER|GW_BOX_MODE)) );
	  gw->setTransform(ident);
	  parts.Render(gw,mt);
	  gw->setRndLimits(rlim);
	}
	else
	{ parts.SetCustomDraw(&thePCloudDraw);			
	  NullView nullView;
	  BOOL needdel;
      gw->setRndLimits(rlim);
	  if ((t!=dispt)||doupdate)
	  {if (dispmesh) delete dispmesh;SetAFlag(A_NOTREND);
	  dispmesh=GetRenderMesh(t,inode,nullView,needdel);	ClearAFlag(A_NOTREND);}
	  Matrix3 mat = inode->GetObjTMAfterWSM(t);
	  gw->setTransform(mat);
	  dispmesh->render(gw, inode->Mtls(),
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL,
		COMP_ALL, inode->NumMtls());
	}
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\sprts.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SuprPrts.rc
//
#define IDS_RB_DISTRIBUTION             1
#define IDS_RB_EMITTERCOUNT             2
#define IDS_RB_SPEED                    3
#define IDS_RB_SPEEDVAR                 4
#define IDS_RB_ANGLEDIV                 5
#define IDS_RB_PBIRTHRATE               6
#define IDS_RB_PTOTALNUMBER             7
#define IDS_RB_DISPLAYPORTION           8
#define IDS_RB_EMITSTART                9
#define IDS_RB_EMITSTOP                 10
#define IDS_RB_DISPUNTIL                11
#define IDS_RB_LIFE                     12
#define IDS_RB_LIFEVAR                  13
#define IDS_RB_SIZE                     14
#define IDS_RB_SIZEVAR                  15
#define IDS_RB_GROWTIME                 16
#define IDS_RB_FADETIME                 17
#define IDS_RB_RNDSEED                  18
#define IDS_RB_METATENSION              19
#define IDS_RB_METATENSIONVAR           20
#define IDS_RB_METACOURSE               21
#define IDS_RB_FRAGTHICKNESS            22
#define IDS_RB_FRAGCOUNT                23
#define IDS_RB_MAPPINGTIME              24
#define IDS_RB_MAPPINGDIST              25
#define IDS_RB_SPINTIME                 26
#define IDS_RB_SPINTIMEVAR              27
#define IDS_RB_SPINPHASE                28
#define IDS_RB_SPINPHASEVAR             29
#define IDS_RB_SPINAXISX                30
#define IDS_RB_SPINAXISY                31
#define IDS_RB_SPINAXISZ                32
#define IDS_RB_SPINAXISVAR              33
#define IDS_RB_EMITVINFL                34
#define IDS_RB_EMITVMULT                35
#define IDS_RB_EMITVMULTVAR             36
#define IDS_RB_BUBLAMP                  37
#define IDS_RB_BUBLAMPVAR               38
#define IDS_RB_BUBLPER                  39
#define IDS_RB_BUBLPERVAR               40
#define IDS_RB_BUBLPHAS                 41
#define IDS_RB_BUBLPHASVAR              42
#define IDS_RB_EMITRWID                 43
#define IDS_RB_EMITRLEN                 44
#define IDS_RB_EMITRDEP                 45
#define IDS_RB_PARAMETERS               46
#define IDS_RB_PGEN                     47
#define IDS_RB_PTYPE                    48
#define IDS_RB_SPIN                     49
#define IDS_RB_EMITV                    50
#define IDS_RB_BUBL                     51
#define IDS_RB_DISP                     52
#define IDS_RB_LOADSAVE                 53
#define IDS_DS_CREATE                   54
#define IDS_RB_BADNAME                  55
#define IDS_RB_BADFILE                  56
#define IDS_RB_NONAME                   57
#define IDS_RB_PARRAY                   58
#define IDS_RB_PARTICLESYSTEMS          59
#define IDS_RB_PARRAYGC                 60
#define IDS_RB_TOP                      61
#define IDS_RB_PBOMB                    62
#define IDS_RB_PBOMBMOD                 63
#define IDS_RB_PBOMBBINDING             64
#define IDS_RB_BOMBPARAM                65
#define IDS_RB_SYMMETRY                 66
#define IDS_RB_CHAOS                    67
#define IDS_RB_STARTTIME                68
#define IDS_RB_LASTSFOR                 69
#define IDS_RB_DELTA_V                  70
#define IDS_RB_DECAY                    71
#define IDS_RB_DECAYTYPE                72
#define IDS_RB_ICONSIZE                 73
#define IDS_RB_SPHDEFLECTOR             74
#define IDS_RB_SPHDEFLECTMOD            75
#define IDS_RB_SPHDEFBINDING            76
#define IDS_RB_BOUNCE                   77
#define IDS_RB_BVAR                     78
#define IDS_AP_SUPRSPRAY                79
#define IDS_AP_SUPRSPRAYGC              80
#define IDS_AP_OFFAXIS                  81
#define IDS_AP_AXISSPREAD               82
#define IDS_AP_OFFPLANE                 83
#define IDS_AP_PLANESPREAD              84
#define IDS_AP_BLIZZARD                 85
#define IDS_AP_BLIZZARDGC               86
#define IDS_AP_TUMBLE                   87
#define IDS_AP_TUMBLERATE               88
#define IDS_SAP_EMITMAP                 89
#define IDS_AP_EMITRLENGTH              90
#define IDS_AP_PFOLLOWOBJ               91
#define IDS_AP_PFOLLOW                  92
#define IDS_AP_PATHFOLLOWBINDING        93
#define IDS_AP_RANGEON                  94
#define IDS_AP_RANGE                    95
#define IDS_AP_SPLINETYPE               96
#define IDS_AP_TANGCHAOS                97
#define IDS_AP_SETEXISTS                98
#define IDS_AP_WARNING                  99
#define IDS_AP_TANGCHAOSVAR             100
#define IDD_SUPRPRTS_ROT                101
#define IDS_AP_TANGENTDIR               101
#define IDD_SUPRPRTS_BUBL               102
#define IDS_AP_SPIRCHAOS                102
#define IDD_SUPRPRTS_EMITV              103
#define IDS_AP_SPIRCHAOSVAR             103
#define IDS_AP_SPIRALDIR                104
#define IDD_SUPRPRTS_GEN_PC             104
#define IDD_SUPRPRTS_PARTTYPE_BL        105
#define IDS_AP_TIMESTART                105
#define IDS_AP_TIMETRAVEL               106
#define IDD_AP_UNIVDEFL                 106
#define IDD_SUPRPRTS_SAVE               107
#define IDS_AP_TRAVELVAR                107
#define IDD_SW_DESC                     108
#define IDS_AP_TIMESTOP                 108
#define IDD_SW_PATHFOLLOW               109
#define IDS_AP_ICONSIZE                 109
#define IDD_SW_PARTICLEBOMB             110
#define IDS_AP_PFOLLOWMOD               110
#define IDD_SW_SPHEREDEFL               111
#define IDS_AP_OBJECTSTR                111
#define IDS_AP_NONE                     112
#define IDD_SUPRPRTS_PARTTYPE_PA        113
#define IDS_AP_BLIZZARDCST              113
#define IDD_SUPRPRTS_BLIZZARD           114
#define IDS_AP_SSPRAYCST                114
#define IDD_SUPRPRTS_SUPERSPRAY         115
#define IDS_AP_PBOMB_CLASS              115
#define IDD_SUPRPRTS_PARTICLEARRAY      116
#define IDS_AP_PARRAYCST                116
#define IDD_SUPRPRTS_GEN_BL             117
#define IDS_AP_UNIDEFLECTOR             117
#define IDD_SUPRPRTS_PARTTYPE_SS        118
#define IDS_ILLEGAL_SPLINE              118
#define IDS_AP_FRICTION                 119
#define IDD_SUPRPRTS_ROT_BL             119
#define IDS_AP_UNIDEFMOD                120
#define IDD_SUPRPRTS_PARTICLECLOUD      120
#define IDS_AP_UNIDEFBINDING            121
#define IDD_SUPRPRTS_GEN_SS             121
#define IDS_AP_PCLOUD                   122
#define IDD_SUPRPRTS_SPAWNING           122
#define IDS_AP_PCLOUDGC                 123
#define IDD_SUPRPRTS_GEN_PA             123
#define IDS_AP_EXTENTS                  124
#define IDD_SUPRPRTS_PARTTYPE_PC        124
#define IDS_AP_PSPAWN                   125
#define IDD_SW_DESC_BOTH                125
#define IDS_AP_SPDIRX                   126
#define IDD_SUPRPRTS_SPAWNINGB          126
#define IDS_AP_SPDIRY                   127
#define IDS_AP_SPDIRZ                   128
#define IDS_AP_SPDIRVAR                 129
#define IDS_AP_EMITRHEIGHT              130
#define IDS_AP_EMITRDEPTH               131
#define IDS_AP_OFFSETAMT                132
#define IDS_AP_SPAWNGENS                133
#define IDS_AP_SPAWNCOUNT               134
#define IDS_AP_SPAWNDIRCHAOS            135
#define IDS_AP_SPAWNSPEEDCHAOS          136
#define IDS_AP_SPAWNSCALECHAOS          137
#define IDS_AP_SPAWNLIFEVLUE            138
#define IDS_AP_STRETCH                  139
#define IDS_AP_UDEFPICK                 140
#define IDS_AP_COMPICK                  141
#define IDS_AP_COMDEL                   142
#define IDS_AP_ITEMSTR                  143
#define IDS_AP_PCLOUDCST                144
#define IDS_AP_VELOCITY                 145
#define IDS_AP_RADLEN                   146
#define IDS_AP_STRENGTH                 147
#define IDS_AP_KSPEED                   148
#define IDS_AP_LIFEDEL                  149
#define IDS_AP_LIFEADD                  150
#define IDS_AP_LIFEREP                  151
#define IDS_AP_OBJDEL                   152
#define IDS_AP_OBJADD                   153
#define IDS_AP_OBJREP                   154
#define IDS_AP_SPRTSLIB                 155
#define IDC_CROSS_HAIR                  156
#define IDS_EP_SPAWNAFFECTS             156
#define IDS_EP_SPAWNMULTVAR             157
#define IDS_AP_UNIDEFLECTOR_CLASS       158
#define IDS_AP_SPHDEFLECTOR_CLASS       159
#define SPACEWARPS_FOR_DYNAMICS         160
#define SPACEWARPS_FOR_BOTH             161
#define SPACEWARPS_FOR_PARTICLES        162
#define IDS_AP_USESELECTED              163
#define IDS_AP_SPAWNDIEAFTER            164
#define IDS_AP_SPAWNDIEAFTERVAR         165
#define IDS_AP_IPCOLLIDE_ON             166
#define IDS_AP_IPCOLLIDE_STEPS          167
#define IDS_AP_IPCOLLIDE_BOUNCE         168
#define IDS_AP_IPCOLLIDE_BOUNCEVAR      169
#define IDS_OFM_ERROR                   170
#define IDS_OFM_PART                    171
#define IDS_AP_CREATEMODE               172
#define IDS_AP_PICKMODE                 173
#define IDS_AP_WRITEPRO                 174
#define IDC_SP_GENSMPLMOVE              1000
#define IDC_SP_GENSMPLTIME              1001
#define IDC_SP_LOAD                     1001
#define IDC_AP_PCLOUD_SPINDIR           1001
#define IDC_AP_PCLOUD_MOVEDIR           1001
#define IDC_SP_GENUSERATE               1002
#define IDC_SP_SAVE                     1002
#define IDC_SP_GENUSETTL                1003
#define IDC_SP_DELETE                   1003
#define IDC_SP_EMVI                     1004
#define IDC_AP_COLLISIONDIE             1004
#define IDC_SP_GENSMPLROT               1004
#define IDC_SP_EMVISPIN                 1005
#define IDC_SP_EMVIMULT                 1006
#define IDC_SP_EMVIMULTSPIN             1007
#define IDC_SP_EMVIMULTVAR              1008
#define IDC_SP_EMVIMULTVARSPIN          1009
#define IDC_SP_GENRATE                  1010
#define IDC_SP_METTENS                  1010
#define IDC_SP_GENRATESPIN              1011
#define IDC_SP_METTENSSPIN              1011
#define IDC_SP_METTENSVAR               1012
#define IDC_PCLOUD_PCUST                1012
#define IDC_SP_METTENSVARSPIN           1013
#define IDC_SP_METCOURSE                1015
#define IDC_SP_METCOURSESPIN            1016
#define IDC_SP_TYPE6PNT                 1017
#define IDC_SP_CHUNKFACES               1018
#define IDC_SP_EMITHID                  1020
#define IDC_SP_CHUNKQTY                 1020
#define IDC_SP_CHUNKSMOOTH              1021
#define IDC_SP_PASURFACE                1021
#define IDC_SP_UDEFL_VELINH             1021
#define IDC_SPHDEFLECT_VEL              1021
#define IDC_SP_PAEDGES                  1022
#define IDC_SP_PAPOINTS                 1023
#define IDC_SP_PAPOINTSEDIT             1024
#define IDC_SP_SPIN                     1025
#define IDC_SP_CHUNKQTYEDIT             1025
#define IDC_SP_PAPOINTSEDITSPIN         1025
#define IDC_SP_SPINSPIN                 1026
#define IDC_SP_CHUNKQTYEDITSPIN         1026
#define IDC_SP_SPEED                    1026
#define IDC_SP_USESUBOBJS               1026
#define IDC_SP_SPINVAR                  1027
#define IDC_SP_CHUNKTHICK               1027
#define IDC_SP_SPEEDSPIN                1027
#define IDC_SP_SPINVARSPIN              1028
#define IDC_SP_CHUNKTHICKSPIN           1028
#define IDC_UDEFL_MULT                  1028
#define IDC_SP_PAVERTICES               1028
#define IDC_SP_SPINPHA                  1029
#define IDC_SP_SETEDIT                  1029
#define IDC_UDEFL_MULTSPIN              1029
#define IDC_SP_PAFACEC                  1029
#define IDC_SP_SPINPHASPIN              1030
#define IDC_UDEFL_MULTVAR               1030
#define IDC_SP_BLASTSTOP                1030
#define IDC_SP_CHUNKPICKOBJECT          1030
#define IDC_SP_SPINPHAVAR               1031
#define IDC_UDEFL_MULTVARSPIN           1031
#define IDC_SP_BLASTSTOPSPIN            1031
#define IDC_AP_EDGEMATID                1031
#define IDC_SP_SPINPHAVARSPIN           1032
#define IDC_SP_SETLIST                  1032
#define IDC_UDEFL_CHAOS                 1032
#define IDC_AP_EDGEMATIDSPIN            1032
#define IDC_SP_SPINAXISX                1033
#define IDC_UDEFL_CHAOSSPIN             1033
#define IDC_AP_BACKMATID                1033
#define IDC_SP_BLASTSPHR                1034
#define IDC_SP_SPINAXISXSPIN            1034
#define IDC_AP_BACKMATIDSPIN            1034
#define IDC_SP_SPINAXISY                1035
#define IDC_SP_BLASTCYL                 1035
#define IDC_SP_CHUNKSMANGLE             1035
#define IDC_SP_BLASTPLAN                1036
#define IDC_SP_SPINAXISYSPIN            1036
#define IDC_SP_CHUNKSMANGLESPIN         1036
#define IDC_SP_SPINAXISZ                1037
#define IDC_SP_BLASTDV                  1037
#define IDC_AP_MATID                    1037
#define IDC_SP_BLASTDVSPIN              1038
#define IDC_SP_SPINAXISZSPIN            1038
#define IDC_AP_MATIDSPIN                1038
#define IDC_SP_SPINAXISVAR              1039
#define IDC_SP_BLASTDECAY               1039
#define IDC_SP_VIEWDISPBOX              1039
#define IDC_SP_SPINAXISVARSPIN          1040
#define IDC_SP_BLASTDECAYSPIN           1040
#define IDC_SP_DECAYOFF                 1041
#define IDC_AP_STRETCH                  1041
#define IDC_AP_MOVEDIRX                 1041
#define IDC_SP_DECAYLIN                 1042
#define IDC_AP_STRETCHSPIN              1042
#define IDC_AP_MOVEDIRXSPIN             1042
#define IDC_SP_DECAYEXP                 1043
#define IDC_AP_MOVEDIRY                 1043
#define IDC_INTERP_BOUNCE               1043
#define IDC_SP_BLASTCHAOS               1044
#define IDC_AP_MOVEDIRYSPIN             1044
#define IDC_INTERP_BOUNCESPIN           1044
#define IDC_SP_BLASTCHAOSSPIN           1045
#define IDC_AP_MOVEDIRZ                 1045
#define IDC_INTERP_BOUNCEVAR            1045
#define IDC_SP_BLASTSTRT                1046
#define IDC_AP_MOVEDIRZSPIN             1046
#define IDC_INTERP_BOUNCEVARSPIN        1046
#define IDC_SP_BLASTSTRTSPIN            1047
#define IDC_AP_MOVEDIRVAR               1047
#define IDC_INTERP_NSTEPS               1047
#define IDC_SP_BLAST_ICONSIZE           1048
#define IDC_AP_MOVEDIRVARSPIN           1048
#define IDC_INTERP_NSTEPSSPIN           1048
#define IDC_SP_BLAST_ICONSIZESPIN       1049
#define IDC_AP_SPLINEOFFSET             1050
#define IDC_SP_CHUNKPICKBUTTON          1051
#define IDC_AP_SPLINEPARALLEL           1051
#define IDC_MTRACK_PICK                 1051
#define IDC_AP_RANGELIMITON             1052
#define IDC_AP_TREEPICK                 1052
#define IDC_AP_SPAWNSUMV                1052
#define IDC_AP_PATHCW                   1053
#define IDC_AP_SPAWNSCALEFIXED          1053
#define IDC_AP_PATHCCW                  1054
#define IDC_AP_SPAWNSPEEDFIXED          1054
#define IDC_AP_PATHBIDIR                1055
#define IDC_AP_PATHTANIN                1056
#define IDC_AP_PATHTANOUT               1057
#define IDC_AP_SPEEDVAR                 1058
#define IDC_AP_NOANIOFF                 1058
#define IDC_AP_SPEEDVARSPIN             1059
#define IDC_AP_ANIOFFBIRTH              1059
#define IDC_AP_ICONSIZE                 1060
#define IDC_AP_ANIOFFRND                1060
#define IDC_SP_BUBL_AMP                 1061
#define IDC_AP_ICONSIZESPIN             1061
#define IDC_SP_BUBL_AMPSPIN             1062
#define IDC_AP_PATHTANBOTH              1062
#define IDC_AP_OBJECTQUEUEPICK          1062
#define IDC_SP_BUBL_AMPVAR              1063
#define IDC_AP_SEED                     1063
#define IDC_AP_NUMBERVAR                1063
#define IDC_SP_BUBL_AMPVARSPIN          1064
#define IDC_AP_SEEDSPIN                 1064
#define IDC_AP_NUMBERVARSPIN            1064
#define IDC_SP_BUBL_PER                 1065
#define IDC_AP_OBJECTPICK               1065
#define IDC_AP_CHAOSANGLE               1065
#define IDC_AP_CONSTSPEED               1065
#define IDC_SP_BUBL_PERSPIN             1066
#define IDC_AP_INSTANCESRCNAME          1066
#define IDC_AP_CHAOSANGLESPIN           1066
#define IDC_SP_BUBL_PERVAR              1067
#define IDC_SP_GENDISP                  1067
#define IDC_AP_PARTICLEDIRRND           1067
#define IDC_AP_CHAOSSCALE               1067
#define IDC_AP_UPDATEMTL                1067
#define IDC_SP_BUBL_PERVARSPIN          1068
#define IDC_SP_GENDISPSPIN              1068
#define IDC_AP_PARTICLEDIRUSER          1068
#define IDC_AP_CHAOSSCALESPIN           1068
#define IDC_SP_BUBL_PERPHA              1069
#define IDC_SP_GENSEED                  1069
#define IDC_AP_PARTICLEDIRTRAVL         1069
#define IDC_AP_SCALEDOWN                1069
#define IDC_SP_BUBL_PERPHASPIN          1070
#define IDC_SP_GENSEEDSPIN              1070
#define IDC_AP_PBLURON                  1070
#define IDC_AP_SCALEUP                  1070
#define IDC_SP_BUBL_PERPHAVAR           1071
#define IDC_SP_GENEMIT1                 1071
#define IDC_AP_FILLPICKBUTTON           1071
#define IDC_AP_SCALEBOTH                1071
#define IDC_SP_BUBL_PERPHAVARSPIN       1072
#define IDC_SP_GENEMIT1SPIN             1072
#define IDC_AP_FILLBOX                  1072
#define IDC_AP_OBJQUEUEDELETE           1072
#define IDC_SP_GENEMIT2                 1073
#define IDC_AP_FILLPICKOBJECT           1073
#define IDC_AP_OBJQUEUEREPLACE          1073
#define IDC_SP_GENEMIT2SPIN             1074
#define IDC_AP_FILLSPHERE               1074
#define IDC_AP_OBJECTQUEUE              1074
#define IDC_SP_GENSIZE                  1075
#define IDC_AP_FILLCYLINDER             1075
#define IDC_AP_COLLIDESPAWN             1075
#define IDC_SP_GENSIZESPIN              1076
#define IDC_AP_FILLOBJECT               1076
#define IDC_AP_NOSPAWN                  1076
#define IDC_SP_GENTTL                   1077
#define IDC_AP_COLLIDEDIE               1077
#define IDC_SP_GENTTLSPIN               1078
#define IDC_AP_DEATHSPAWN               1078
#define IDC_SP_GENSIZEVAR               1079
#define IDC_AP_MAXSPAWNGENS             1079
#define IDC_SP_GENSIZEVARSPIN           1080
#define IDC_AP_MAXSPAWNGENSSPIN         1080
#define IDC_SP_DISPUNTIL                1081
#define IDC_SP_OFFAXIS                  1081
#define IDC_AP_CHAOSSPIRAL              1081
#define IDC_AP_CHAOSSPEED               1081
#define IDC_SP_DISPUNTILSPIN            1082
#define IDC_SP_OFFAXISSPIN              1082
#define IDC_AP_CHAOSSPIRALSPIN          1082
#define IDC_AP_CHAOSSPEEDSPIN           1082
#define IDC_SP_GENFAD                   1083
#define IDC_SP_OFFAXISVAR               1083
#define IDC_AP_CHAOSTAN                 1083
#define IDC_AP_SPEEDLESS                1083
#define IDC_SP_GENFADSPIN               1084
#define IDC_SP_OFFAXISVARSPIN           1084
#define IDC_AP_CHAOSTANSPIN             1084
#define IDC_AP_SPEEDMORE                1084
#define IDC_SP_GENGRO                   1085
#define IDC_SP_OFFPLANE                 1085
#define IDC_AP_RANGELIMIT               1085
#define IDC_AP_SPEEDBOTH                1085
#define IDC_SP_GENGROSPIN               1086
#define IDC_SP_OFFPLANESPIN             1086
#define IDC_AP_RANGELIMITSPIN           1086
#define IDC_AP_LIFEQUEUE                1086
#define IDC_SP_GENLIFEVAR               1087
#define IDC_SP_OFFPLANEVAR              1087
#define IDC_SP_PATHNAMEPICK             1087
#define IDC_AP_QUEUELIFESPAN            1087
#define IDC_SP_GENLIFEVARSPIN           1088
#define IDC_SP_OFFPLANEVARSPIN          1088
#define IDC_SP_PATHNAME                 1088
#define IDC_AP_QUEUELIFESPANSPIN        1088
#define IDC_SP_GENLIFE                  1089
#define IDC_AP_TRAVELTIME               1089
#define IDC_AP_LIFEQUEUEADD             1089
#define IDC_SP_GENLIFESPIN              1090
#define IDC_AP_TRAVELTIMESPIN           1090
#define IDC_AP_LIFEQUEUEDEL             1090
#define IDC_AP_CAPTURETIME              1091
#define IDC_AP_EMITRADWID               1091
#define IDC_AP_LIFEQUEUEREPL            1091
#define IDC_SP_SPEEDVAR2                1091
#define IDC_AP_CAPTURETIMESPIN          1092
#define IDC_AP_EMITRADWIDSPIN           1092
#define IDC_SP_SPEEDVARSPIN2            1092
#define IDC_AP_SPAWNTRAILS              1092
#define IDC_AP_LASTFRAME                1093
#define IDC_AP_NUMBERVARVAR             1093
#define IDC_AP_LASTFRAMESPIN            1094
#define IDC_AP_NUMBERVARVARSPIN         1094
#define IDC_AP_CHAOSTANVAR              1095
#define IDC_AP_PCLOUDDIRRND             1095
#define IDC_AP_PARENTPERCENT            1095
#define IDC_AP_CHAOSTANVARSPIN          1096
#define IDC_AP_PCLOUDDIRENTER           1096
#define IDC_AP_PARENTPERCENTSPIN        1096
#define IDC_AP_CHAOSSPIRALVAR           1097
#define IDC_AP_PCLOUDDIROBJ             1097
#define IDC_AP_MAXSPAWNDIEAFTER         1097
#define IDC_AP_CHAOSSPIRALVARSPIN       1098
#define IDC_AP_PCLOUDOBJDIRNAME         1098
#define IDC_AP_MAXSPAWNDIEAFTERSPIN     1098
#define IDC_AP_OBJECTDIRPICK            1099
#define IDC_AP_MAXSPAWNDIEAFTERVAR      1099
#define IDC_SP_UDEFL_VELINHSPIN         1100
#define IDC_AP_OBJECTDIRPICK2           1100
#define IDC_AP_NEWSEED                  1100
#define IDC_AP_MAXSPAWNDIEAFTERVARSPIN  1100
#define IDC_SP_METCOURSEV               1102
#define IDC_SP_METCOURSEVSPIN           1103
#define IDC_SP_DRAFTMODE                1104
#define IDC_SP_DRAFTMODE2               1105
#define IDC_SP_MANYBLOBS                1105
#define IDC_INTERP_BOUNCEON             1105
#define IDC_PBOMB_RANGEON               1106
#define IDC_SP_MAPCUSTOMDIST            1119
#define IDC_SP_AUTOCOARSE               1120
#define IDC_AP_USESUBTREE2              1121
#define IDC_SP_MAPCUSTOMINST            1121
#define IDC_SP_MAPCUSTOMEMIT            1122
#define IDC_SPHDEFLECT_BOUNCE           1175
#define IDC_SPHDEFLECT_BOUNCESPIN       1176
#define IDC_SPHDEFLECT_CHAOS            1177
#define IDC_SPHDEFLECT_CHAOSSPIN        1178
#define IDC_SP_UDEFL_ICONSIZESPIN       1179
#define IDC_SPHDEFLECT_RADIUSSPIN       1179
#define IDC_SP_UDEFL_ICONSIZE           1180
#define IDC_SPHDEFLECT_RADIUS           1180
#define IDC_SPHDEFLECT_BOUNCEVAR        1181
#define IDC_SPHDEFLECT_BOUNCEVARSPIN    1182
#define IDC_SPHDEFLECT_VELSPIN          1184
#define IDC_SPHDEFLECT_FRICTION         1187
#define IDC_SPHDEFLECT_FRICTIONSPIN     1188
#define IDC_AP_USESUBTREE               2000
#define IDC_SP_SPEEDVARSPIN             2001
#define IDC_SP_SPEEDVAR                 2002
#define IDC_SP_DIVERG                   2003
#define IDC_SP_DIVERGSPIN               2004
#define IDC_SP_VIEWDISPDOT              2005
#define IDC_SP_VIEWDISPMESH             2006
#define IDC_SP_VIEWDISPTIK              2007
#define IDC_SP_EMITWID                  3044
#define IDC_SP_EMITWIDSPIN              3045
#define IDC_SP_EMITLEN                  3046
#define IDC_AP_EMITHGT                  3046
#define IDC_SP_EMITLENSPIN              3047
#define IDC_AP_EMITHGTSPIN              3047
#define IDC_SP_MAPTIMEVAL               3048
#define IDC_SP_BLIZSPEED                3048
#define IDC_AP_EMITDEP                  3048
#define IDC_SP_MAPTIMEVALSPIN           3049
#define IDC_SP_BLIZSPEEDSPIN            3049
#define IDC_AP_EMITDEPSPIN              3049
#define IDC_SP_MAPDISTVAL               3050
#define IDC_SP_BLIZSPEEDVAR             3050
#define IDC_SP_MAPDISTVALSPIN           3051
#define IDC_SP_BLIZSPEEDVARSPIN         3051
#define IDC_SP_BLIZTUMBL                3056
#define IDC_SP_BLIZTUMBLSPIN            3057
#define IDC_SP_BLIZTUMBLRATE            3058
#define IDC_SP_BLIZTUMBLRATESPIN        3059
#define IDC_AP_ANIRNDFR                 3069
#define IDC_AP_ANIRNDFRSPIN             3070
#define IDC_SP_TYPETRI                  3074
#define IDC_SP_TYPECUB                  3075
#define IDC_SP_TYPESPC                  3076
#define IDC_SP_TYPEMET                  3077
#define IDC_SP_TYPEFAC                  3078
#define IDC_SP_TYPEPIX                  3079
#define IDC_SP_TYPETET                  3080
#define IDC_SP_MAPTIME                  3081
#define IDC_SP_MAPDIST                  3082
#define IDC_SP_TYPECHUNKS               3083
#define IDC_SP_MAPPLANAR                3083
#define IDC_SP_TYPESTD                  3084
#define IDC_SP_TYPEINSTANCE             3085
#define IDC_SP_TYPESPHERE               3086
#define IDC_SP_TYPESPHEREPA             3086
#define IDC_SP_TYPESPHERE2              3086

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1107
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\parray.cpp ===
/**********************************************************************
 *<									  

	FILE: PArray.CPP
	DESCRIPTION: Particle Array Systems using Input Geometry

	CREATED BY: Audrey Peterson	

	HISTORY: created November 1996
	Geometry Instancing 1/1997

 *>	Copyright (c) 1996 for and assigned to Yost Group, All Rights Reserved.
 **********************************************************************/
#include <io.h>
#include "SuprPrts.h"
#include "iparamm.h"
#include "interpik.h"
#include "texutil.h"
#include "stdmat.h"
//#include "metapart.h"

#define EPSILON 0.0001f
#define MAX_PATH_LENGTH 257
#define MAX_STRING_LENGTH  256
#define PBLK		0
#define CUSTNODE 		1
#define DISTNODE 		2

#define BASER 3

#define DIRTRAVEL 1

typedef Tab<Mtl *>Mtllst;
typedef struct {
  Tab<Face> f;
  Tab<Point3> v;
  Tab<UVVert> tv;
  Tab<TVFace> tvf;
} CustLst;
class PMesh
{  public:
	PMesh();
	~PMesh();
    int numVerts,numFaces,numtvFace;
	Point3 *verts;
	Face *faces;
	TVFace *tvFace;
	BOOL 	setNumVerts(int ct, BOOL keep=FALSE);
	int		getNumVerts(void) const	{ return numVerts; }
	BOOL 	setNumFaces(int ct, BOOL keep=FALSE);
	int		getNumFaces(void) const	{ return numFaces; }
	BOOL 	setNumtvFace(int ct, BOOL keep=FALSE);
	int		getNumtvFace(void) const { return numtvFace; }
};
PMesh::PMesh()
{  numVerts=0;
   verts=NULL;
   faces=NULL;
   tvFace=NULL;
   numFaces=0;
   numtvFace=0;
}
PMesh::~PMesh()
{  if (verts){delete[] verts;verts=NULL;}
   if (tvFace){
	 delete[] tvFace;
	 tvFace=NULL;}
   if (faces){delete[] faces;faces=NULL;}
}
BOOL PMesh::setNumVerts(int ct, BOOL keep)
{ Point3 *tmp;
int maxv=(ct>numVerts?ct:numVerts);
 if (keep)
	{tmp=verts;
     verts=new Point3[ct];
	 if ((tmp!=NULL)&&(verts!=NULL)) memcpy(verts,tmp,sizeof(Point3)*maxv);
	 if (tmp!=NULL) delete[] tmp;
    }
   else 
   {if (verts) delete[] verts;
    if (ct>0) verts=new Point3[ct];
	else verts=NULL;
   }
   numVerts=(verts==NULL?0:ct);
   return(verts!=NULL);
};
BOOL PMesh::setNumFaces(int ct, BOOL keep)
{ Face *tmp;
int maxv=(ct>numFaces?ct:numFaces);
 if (keep)
	{tmp=faces;
     faces=new Face[ct];
	 if ((tmp!=NULL)&&(faces!=NULL)) memcpy(faces,tmp,sizeof(Face)*maxv);
	 if (tmp!=NULL) delete[] tmp;
    }
   else 
   {if (faces) delete[] faces;
    if (ct>0) faces=new Face[ct];
	else faces=NULL;
   }
   numFaces=(faces==NULL?0:ct);
   return(faces!=NULL);
};
BOOL PMesh::setNumtvFace(int ct, BOOL keep)
{ TVFace *tmp;
int maxv=(ct>numtvFace?ct:numtvFace);
 if (keep)
	{tmp=tvFace;
     tvFace=new TVFace[ct];
	 if ((tmp!=NULL)&&(tvFace!=NULL)) memcpy(tvFace,tmp,sizeof(TVFace)*maxv);
	 if (tmp!=NULL) delete[] tmp;
    }
   else 
   {if (tvFace) delete[] tvFace;
    if (ct>0) tvFace=new TVFace[ct];
	else tvFace=NULL;
   }
   numtvFace=(tvFace==NULL?0:ct);
   return(tvFace!=NULL);
};

typedef struct{
 float Vsz,Ts,Ts0,LamTs,A,LamA,To;
 float M,Dis,Fo,Inf,Mltvar,pvar;
 int themtl,showframe,gennum,frommesh,SpVar;
 TimeValue L,DL,persist;
 MtlID pmtl;
 Point3 wbb[8];
 Point3	V,Ve,W,RV,tv,start;
} SavePt;

typedef struct {
 Point3 Axis;
 TimeValue persist;
 float axisvar,div,pvar; 
 int axisentered;
}VelDir2;
typedef struct {
 float Size,VSz,VSpin,Phase,VPhase;
 float bstr,bstrvar,Speed,VSpeed;
 float ToAmp,VToAmp;
 float ToPhase,VToPhase,VToPeriod;
 TimeValue Spin,ToPeriod,Life,Vl;
} VelDir;
static Class_ID PArray_CLASS_ID(0xe3c25b5, 0x109d1659);

class PickOperand;
class PArrayParticle;
class PArrayParticleDraw : public CustomParticleDisplay {
	public:
//		float size,VSz,
		BOOL firstpart;
		PArrayParticle *obj;
		int disptype,ptype,bb,anifr,anioff;
		boxlst *bboxpt;
		TimeValue t;
		InDirInfo indir;

		PArrayParticleDraw() {obj=NULL;}
		BOOL DrawParticle(GraphicsWindow *gw,ParticleSys &parts,int i);
	};
typedef struct{
float M,Vsz;
Point3 Ve,vel,pos;
Point3 wbb[8];
}CacheDataType;

class PArrayParticle : public SimpleParticle, IParamArray {
	public:
		PArrayParticleDraw thePArrayDraw;
		PArrayParticle();
		~PArrayParticle();
		static IParamMap *pmapParam;
		static IParamMap *pmapPGen;
		static IParamMap *pmapPType;
		static IParamMap *pmapPSpin;
		static IParamMap *pmapEmitV;
		static IParamMap *pmapBubl;
		static IParamMap *pmapSpawn;
		int stepSize,size,oldtvnum,lastrnd,emitrnd;
		static custsettings;
		BOOL cancelled,wasmulti,storernd;
		static BOOL creating;
		BOOL fromgeom;
		INode *distnode,*custnode,*cnode;
		CacheDataType *storefrag;
		TSTR distname,custname;
		ULONG dflags;
		int fragflags;
		BOOL doTVs;
		static AName *NameLst;
		static HWND hParams2,hptype,hgen,hparam,hrot,hbubl,spawn;
		static PickOperand pickCB;
		static ICustEdit *custCtrlEdit;
		Mtl *origmtl;

		BOOL GenerateNotGeom(TimeValue t,TimeValue lastt,int c,int counter,INode *distnode,int type,Matrix3 tm,Matrix3 nxttm);
		void GetInfoFromObject(float thick,int *c,INode *distnode,TimeValue t,TimeValue lastt);
		void GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box); 
		void GetWorldBoundBox(TimeValue t, INode *inode, ViewExp* vpt, Box3& box);
		void RendGeom(Mesh *pm,Matrix3 itm,int maxmtl,int maptype,BOOL eitmtl,float mval,PArrayParticleDraw thePArrayDraw,TVFace defface,BOOL notrend);

		Tab<int> nmtls;
		void DoSpawn(int j,int spmult,SpawnVars spvars,TimeValue lvar,BOOL emits,int &oldcnt);
		void SetUpList();
		void AddToList(INode *newnode,int i,BOOL add);
		void DeleteFromList(int nnum,BOOL all);
		Tab<INode*> nlist;
		Tab<int> llist;
		int deftime;
		int maincount;
		int NumRefs() {return BASER+nlist.Count();}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
		void SetUpLifeList();
		void AddToLifeList(int newlife);
		void DeleteFromLifeList(int nnum);
		void ShowName(int dist);
		int CountLive();
		int rcounter,vcounter;
		oldipc lc;
		static IObjParam *ip;
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}

		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		TimeValue ParticleLife(TimeValue t, int i);
		// Animatable methods		
		void DeleteThis() {delete this;}
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void MapKeys(TimeMap *map,DWORD flags);
		int RenderBegin(TimeValue t, ULONG flags);		
		int RenderEnd(TimeValue t);
		
		// From SimpleParticle
		void BuildEmitter(TimeValue t, Mesh& amesh);
		Interval GetValidity(TimeValue t);		
		void InvalidateUI();
		BOOL EmitterVisible();		
		MarkerType GetMarkerType();	
		SavePt *sdata;
		Mesh *pmesh;
		// From BaseObject
		TCHAR *GetObjectName();
		void BirthParticle(INode *node,TimeValue bt,int index,VelDir2 *ptvel2,VelDir ptvel,Matrix3 tmnxt);
		BOOL ComputeParticleStart(TimeValue t0,TimeValue lastt,INode *node,int c);
		int IsInstanceDependent() {return 1;}

		// From GeomObject
		Mesh* GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete);

		// Animatable methods		
		Class_ID ClassID() {return PArray_CLASS_ID;} 

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());		

		// From Simple Particle
		void UpdateParticles(TimeValue t,INode *node);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void GetFilename(TCHAR *filename);
		void SetupTargetList();
		int SaveSettings(int overwrite,TCHAR *newname);
		int GetSettings(int setnum,TCHAR *newname);
		int RemSettings(int setnum,TCHAR *newname);
		Point3 ParticlePosition(TimeValue t,int i);
		Point3 ParticleVelocity(TimeValue t,int i);		
		float ParticleSize(TimeValue t,int i);
		int ParticleCenter(TimeValue t,int i);

		Mesh *cmesh,*dispmesh;
		Box3 *cmbb;
		Point3 boxcenter;
		int CustMtls;
		TimeLst times;
		void GetTimes(TimeLst &times,TimeValue t,int anifr,int ltype,int fragflags);
		void TreeDoGroup(INode *node,Matrix3 tspace,Mesh *cmesh,Box3 *cmbb,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl);
		void CheckTree(INode *node,Matrix3 tspace,Mesh *cmesh,Box3 *cmbb,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl);
		void GetMesh(TimeValue t,int subtree,int custmtl,int fragflags);
		void GetNextBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode);
		void DoGroupBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode);
		void GetallBB(INode *custnode,int subtree,TimeValue t,int fragflags);
		void AssignMtl(INode *node,INode *topnode,int subtree,TimeValue t,int fragflags);
		void DoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void RetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void GetSubs(INode *node,INode *topnode,int subtree,TimeValue t,int fragflags);
		void CntDoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		void CntRetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t);
		BOOL backpatch;
		Mtllst mttab;
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		int HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt);
		TimeValue dispt;
		void MovePart(int j,TimeValue dt,BOOL fullframe,int tpf);
		void ResetSystem(TimeValue t,BOOL full=TRUE);
	};

class PickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		PArrayParticle *po;
		int dodist,repi;
		
		PickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};
//--- ClassDescriptor and class vars ---------------------------------

class PArrayClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new PArrayParticle;}
	const TCHAR *	ClassName(); 
	SClass_ID		SuperClassID() {return GEOMOBJECT_CLASS_ID;}
	Class_ID		ClassID() {return PArray_CLASS_ID;}
	const TCHAR* 	Category(); 
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};

static PArrayClassDesc PArrayDesc;
ClassDesc* GetPArrayDesc() {return &PArrayDesc;}

//--- ClassDescriptor and class vars ---------------------------------
IParamMap *PArrayParticle::pmapParam;
IParamMap *PArrayParticle::pmapPGen;
IParamMap *PArrayParticle::pmapPType;
IParamMap *PArrayParticle::pmapPSpin;
IParamMap *PArrayParticle::pmapEmitV;
IParamMap *PArrayParticle::pmapBubl;
IParamMap *PArrayParticle::pmapSpawn;
IObjParam *PArrayParticle::ip    = NULL;
BOOL PArrayParticle::creating    = FALSE;
PickOperand PArrayParticle::pickCB;
ICustEdit *PArrayParticle::custCtrlEdit=NULL;
int PArrayParticle::custsettings=0;
AName *PArrayParticle::NameLst=NULL;
HWND PArrayParticle::hParams2;
HWND PArrayParticle::hgen;
HWND PArrayParticle::hptype;
HWND PArrayParticle::hparam;
HWND PArrayParticle::hrot;
HWND PArrayParticle::hbubl;
HWND PArrayParticle::spawn;

class PAObjectListRestore : public RestoreObj {
	public:   		
		PArrayParticle *po;
		Tab<INode*> unodes;
		Tab<INode*> rnodes;
		int lnum,lnum2;
		PAObjectListRestore(PArrayParticle *p) 
		{  po=p;
		   unodes=p->nlist;
		}
		void Restore(int isUndo)
		{	if (isUndo) {
				rnodes = po->nlist;
				}
			po->nlist = unodes;
			po->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		}
		void Redo() 
		{	po->nlist = rnodes;
			po->NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		}
	};

class PALifeListRestore : public RestoreObj {
	public:   		
		PArrayParticle *po;
		Tab<int> utimes;
		Tab<int> rtimes;
		PALifeListRestore(PArrayParticle *p) 
		{ po=p;
		  utimes=p->llist;
		}
		void Restore(int isUndo)
		{ if (isUndo) { rtimes = po->llist;	}
		  po->llist=utimes;
		  if (po->ip) po->SetUpLifeList();
		}
		void Redo() 
		{ po->llist = rtimes;
		  if (po->ip) po->SetUpLifeList();
		}
	};


class CreatePAPartDelNode : public RestoreObj {
	public:   		
		PArrayParticle *obj;
		TSTR name;
		int dist;
		CreatePAPartDelNode(PArrayParticle *o, TSTR n,int d) {
			obj = o; name=TSTR(n); dist=d;
			}
		void Restore(int isUndo)
		{if (dist) obj->distname=name; else obj->custname = name;
		 obj->ShowName(dist);
			}
		void Redo() 
			{  if (dist) obj->distname==TSTR(_T(""));else obj->custname=TSTR(_T(""));
		if (((dist)&&(obj->hptype))||((!dist)&&(obj->hparam)))
		{ TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + TSTR(GetString(IDS_AP_NONE));
		  if (dist)
		    SetWindowText(GetDlgItem(obj->hparam, IDC_SP_CHUNKPICKOBJECT), name);
		  else
		    SetWindowText(GetDlgItem(obj->hptype, IDC_AP_INSTANCESRCNAME), name);
		}
		}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};
class CreatePAPartPickNode : public RestoreObj {
	public:   		
		PArrayParticle *obj;
		TSTR name,name2;int dist;
		CreatePAPartPickNode(PArrayParticle *o, TSTR n,TSTR n1,int d) {
			obj = o; name=TSTR(n);name2=TSTR(n1);dist=d;
			}
		void Restore(int isUndo) {
			if (dist)
			{ if (obj->distnode) obj->distname = name;
			else  obj->distname=TSTR(_T(""));}
			else
			{ if (obj->custnode) obj->custname = name;
			else  obj->custname=TSTR(_T(""));}
			obj->ShowName(dist);
			}
		void Redo() 
		{ 
		if (((dist)&&(obj->hptype))||((!dist)&&(obj->hparam)))
		{ TSTR name;
		  if (dist) obj->distname=name2;
		  else  obj->custname = name2;
		  name=TSTR(GetString(IDS_AP_OBJECTSTR))+(_tcslen(name2)>0 ? name2 : TSTR(GetString(IDS_AP_NONE)));
		  if (dist)
		    SetWindowText(GetDlgItem(obj->hparam, IDC_SP_CHUNKPICKOBJECT), name);
		  else
		    SetWindowText(GetDlgItem(obj->hptype, IDC_AP_INSTANCESRCNAME), name);
		}
			}
		TSTR Description() {return GetString(IDS_AP_COMPICK);}
	};


#define SIZEFACTOR (float(TIME_TICKSPERSEC)/120.0f)


//--- Parameter map/block descriptors -------------------------------

#define PB_DISTRIBUTION		0
#define PB_EMITTERCOUNT		1
#define PB_SPEED			2
#define PB_SPEEDVAR			3
#define PB_ANGLEDIV			4

#define PB_BIRTHMETHOD		5
#define PB_PBIRTHRATE		6
#define PB_PTOTALNUMBER		7
#define PB_EMITSTART		8
#define PB_EMITSTOP			9
#define PB_DISPUNTIL		10
#define PB_LIFE				11
#define PB_LIFEVAR			12
#define PB_SUBFRAMEMOVE		13
#define PB_SUBFRAMETIME		14
#define PB_SIZE				15
#define PB_SIZEVAR			16
#define PB_GROWTIME			17
#define PB_FADETIME			18
#define PB_RNDSEED			19
#define PB_EMITRWID			20
#define PB_EMITRHID			21

#define PB_PARTICLECLASS	22
#define PB_PARTICLETYPE		23
#define PB_METATENSION		24
#define PB_METATENSIONVAR	25
#define PB_METACOURSE		26
#define PB_METAAUTOCOARSE	27
#define PB_FRAGTHICKNESS	28
#define PB_FRAGMETHOD		29
#define PB_FRAGCOUNT		30
#define PB_SMOOTHANG		31
#define	PB_USESUBTREE		32
#define PB_ANIMATIONOFFSET  33
#define PB_OFFSETAMOUNT     34
#define PB_VIEWPORTSHOWS	35
#define PB_DISPLAYPORTION	36
#define PB_MAPPINGTYPE		37
#define PB_MAPPINGTIME		38
#define PB_MAPPINGDIST		39
#define PB_CUSTOMMATERIAL	40
#define PB_EMAT				41
#define PB_BMAT				42
#define PB_FMAT				43

#define PB_SPINTIME			44
#define PB_SPINTIMEVAR		45
#define PB_SPINPHASE		46
#define PB_SPINPHASEVAR		47
#define PB_SPINAXISTYPE		48
#define PB_SPINAXISX		49
#define PB_SPINAXISY		50
#define PB_SPINAXISZ		51
#define PB_SPINAXISVAR		52

#define PB_EMITVINFL		53
#define PB_EMITVMULT		54
#define PB_EMITVMULTVAR		55

#define PB_BUBLAMP			56
#define PB_BUBLAMPVAR		57
#define PB_BUBLPER			58
#define PB_BUBLPERVAR		59
#define PB_BUBLPHAS			60
#define PB_BUBLPHASVAR		61

#define PB_STRETCH			62

#define PB_SPAWNTYPE		63
#define PB_SPAWNGENS		64
#define PB_SPAWNCOUNT		65
#define PB_SPAWNDIRCHAOS	66
#define PB_SPAWNSPEEDCHAOS	67
#define PB_SPAWNSPEEDSIGN	68
#define PB_SPAWNINHERITV	69
#define PB_SPAWNSCALECHAOS	70
#define PB_SPAWNSCALESIGN	71
#define PB_SPAWNLIFEVLUE	72
#define PB_SPAWNSPEEDFIXED	73
#define PB_SPAWNSCALEFIXED	74
#define PB_METACOURSEV			75
#define PB_SUBFRAMEROT			76
#define PB_SPAWNPERCENT			77
#define PB_SPAWNMULTVAR			78
#define PB_PANOTDRAFT			79
#define PB_USESELECTED				80
#define PB_PASPAWNDIEAFTER			81
#define PB_PASPAWNDIEAFTERVAR		82
	
#define PB_PAIPCOLLIDE_ON			83
#define PB_PAIPCOLLIDE_STEPS		84
#define PB_PAIPCOLLIDE_BOUNCE		85
#define PB_PAIPCOLLIDE_BOUNCEVAR	86

// render types
#define RENDMETA    8
#define RENDGEOM	9
#define RENDCGEOM	10

//
//
// Parameters

static int distributeIDs[] = {IDC_SP_PASURFACE,IDC_SP_PAEDGES,IDC_SP_PAVERTICES,IDC_SP_PAPOINTS,IDC_SP_PAFACEC};

#define UNIFORM 0
#define EDGES 1
#define VERTS 2
#define EMITS 3
#define FACEC 4

#define ISSTD 0
#define METABALLS 1
#define BYGEOM 2
#define INSTGEOM 3

static int countIDs[] = {IDC_SP_GENUSERATE,IDC_SP_GENUSETTL};

static int particleclassIDs[] = {IDC_SP_TYPESTD,IDC_SP_TYPEMET,IDC_SP_TYPECHUNKS,IDC_SP_TYPEINSTANCE};

static int particletypeIDs[] = {IDC_SP_TYPETRI,IDC_SP_TYPECUB,IDC_SP_TYPESPC,IDC_SP_TYPEFAC,
								IDC_SP_TYPEPIX,IDC_SP_TYPETET,IDC_SP_TYPE6PNT,IDC_SP_TYPESPHERE};

static int fragmenttypeIDs[] = {IDC_SP_CHUNKFACES,IDC_SP_CHUNKQTY,IDC_SP_CHUNKSMOOTH};

static int spindirectionIDs[] = {IDC_AP_PARTICLEDIRRND,IDC_AP_PARTICLEDIRTRAVL,IDC_AP_PARTICLEDIRUSER};

static int animateoffsetIDs[] = {IDC_AP_NOANIOFF,IDC_AP_ANIOFFBIRTH,IDC_AP_ANIOFFRND};

#define FRAGFACE 0
#define FRAGRND 1

static int viewportoptionIDs[] = {IDC_SP_VIEWDISPDOT,IDC_SP_VIEWDISPTIK,IDC_SP_VIEWDISPMESH,IDC_SP_VIEWDISPBOX};

static int mappingIDs[] = {IDC_SP_MAPTIME,IDC_SP_MAPDIST};

static int custmtlIDs[] = {IDC_SP_MAPCUSTOMEMIT,IDC_SP_MAPCUSTOMDIST,IDC_SP_MAPCUSTOMINST};

// Dialog Unique to Particle Array
static ParamUIDesc descParamPArray[] = {
	
	// Distribution Method
	ParamUIDesc(PB_DISTRIBUTION,TYPE_RADIO,distributeIDs,5),

	// Emitter Count
	ParamUIDesc(
		PB_EMITTERCOUNT,
		EDITTYPE_INT,
		IDC_SP_PAPOINTSEDIT,IDC_SP_PAPOINTSEDITSPIN,
		1.0f,65000.0f,
		1.0f),

	// Use Subobjects
	ParamUIDesc(PB_USESELECTED,TYPE_SINGLECHEKBOX,IDC_SP_USESUBOBJS),

	// Emitter Width
	ParamUIDesc(
		PB_EMITRWID,
		EDITTYPE_UNIVERSE,
		IDC_SP_EMITWID,IDC_SP_EMITWIDSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),	

	// Hide Emitter
	ParamUIDesc(PB_EMITRHID,TYPE_SINGLECHEKBOX,IDC_SP_EMITHID),

	// Display type
	ParamUIDesc(PB_VIEWPORTSHOWS,TYPE_RADIO,viewportoptionIDs,4),

	// Particle Display Portion
	ParamUIDesc(
		PB_DISPLAYPORTION,
		EDITTYPE_FLOAT,
		IDC_SP_GENDISP,IDC_SP_GENDISPSPIN,
		0.0f,100.0f,
		0.1f,
		stdPercentDim),
};
#define PARAMPARRAY_LENGTH 7

// Common Dialog for Particle Generation
static ParamUIDesc descParamPGen[] = {

	// Distribution Method
	ParamUIDesc(PB_BIRTHMETHOD,TYPE_RADIO,countIDs,2),

	// Particle Birth Rate
	ParamUIDesc(
		PB_PBIRTHRATE,
		EDITTYPE_INT,
		IDC_SP_GENRATE,IDC_SP_GENRATESPIN,
		0.0f,65000.0f,
		1.0f),

	// Particle Total Count
	ParamUIDesc(
		PB_PTOTALNUMBER,
		EDITTYPE_INT,
		IDC_SP_GENTTL,IDC_SP_GENTTLSPIN,
		0.0f,65000.0f,
		1.0f),

	// Particle Speed
	ParamUIDesc(
		PB_SPEED,
		EDITTYPE_UNIVERSE,
		IDC_SP_SPEED,IDC_SP_SPEEDSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Speed Var
	ParamUIDesc(
		PB_SPEEDVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPEEDVAR,IDC_SP_SPEEDVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Particle Angle Divergence
	ParamUIDesc(
		PB_ANGLEDIV,
		EDITTYPE_FLOAT,
		IDC_SP_DIVERG,IDC_SP_DIVERGSPIN,
		0.0f,90.0f,
		0.1f,stdAngleDim),

		// Emitter Start Time
	ParamUIDesc(
		PB_EMITSTART,
		EDITTYPE_TIME,
		IDC_SP_GENEMIT1,IDC_SP_GENEMIT1SPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Emitter Stop Time
	ParamUIDesc(
		PB_EMITSTOP,
		EDITTYPE_TIME,
		IDC_SP_GENEMIT2,IDC_SP_GENEMIT2SPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Particle Time Limit
	ParamUIDesc(
		PB_DISPUNTIL,
		EDITTYPE_TIME,
		IDC_SP_DISPUNTIL,IDC_SP_DISPUNTILSPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// Particle Life
	ParamUIDesc(
		PB_LIFE,	
		EDITTYPE_TIME,
		IDC_SP_GENLIFE,IDC_SP_GENLIFESPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Life Var
	ParamUIDesc(
		PB_LIFEVAR,
		EDITTYPE_TIME,
		IDC_SP_GENLIFEVAR,IDC_SP_GENLIFEVARSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Subframe Time and Motion Sampling
	ParamUIDesc(PB_SUBFRAMEMOVE,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLMOVE),
	ParamUIDesc(PB_SUBFRAMETIME,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLTIME),
	ParamUIDesc(PB_SUBFRAMEROT,TYPE_SINGLECHEKBOX,IDC_SP_GENSMPLROT),

	// Particle Size
	ParamUIDesc(
		PB_SIZE,
		EDITTYPE_UNIVERSE,
		IDC_SP_GENSIZE,IDC_SP_GENSIZESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Particle Size Var
	ParamUIDesc(
		PB_SIZEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_GENSIZEVAR,IDC_SP_GENSIZEVARSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Particle Grow Time
	ParamUIDesc(
		PB_GROWTIME,
		EDITTYPE_TIME,
		IDC_SP_GENGRO,IDC_SP_GENGROSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Particle Fade Time
	ParamUIDesc(
		PB_FADETIME,
		EDITTYPE_TIME,
		IDC_SP_GENFAD,IDC_SP_GENFADSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Random Number Seed
	ParamUIDesc(
		PB_RNDSEED,
		EDITTYPE_INT,
		IDC_SP_GENSEED,IDC_SP_GENSEEDSPIN,
		0.0f,25000.0f,
		1.0f),
	};

#define PARAMPGEN_LENGTH 19

// Particle Type for PArray
static ParamUIDesc descParamPType[] = {

	// Particle Class
	ParamUIDesc(PB_PARTICLECLASS,TYPE_RADIO,particleclassIDs,4),

	// Particle Type
	ParamUIDesc(PB_PARTICLETYPE,TYPE_RADIO,particletypeIDs,8),

	// Metaball Tension
	ParamUIDesc(
		PB_METATENSION,
		EDITTYPE_FLOAT,
		IDC_SP_METTENS,IDC_SP_METTENSSPIN,
		0.1f,10.0f,
		SPIN_AUTOSCALE),

	// Metaball Tension Variation
	ParamUIDesc(
		PB_METATENSIONVAR,
		EDITTYPE_FLOAT,
		IDC_SP_METTENSVAR,IDC_SP_METTENSVARSPIN,
		0.0f,100.0f,
		SPIN_AUTOSCALE,stdPercentDim),

	// Metaball Courseness
	ParamUIDesc(
		PB_METACOURSE,
		EDITTYPE_UNIVERSE,
		IDC_SP_METCOURSE,IDC_SP_METCOURSESPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Metaball Courseness ViewPort
	ParamUIDesc(
		PB_METACOURSEV,
		EDITTYPE_UNIVERSE,
		IDC_SP_METCOURSEV,IDC_SP_METCOURSEVSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Metaball Auto Coarseness
	ParamUIDesc(PB_METAAUTOCOARSE,TYPE_SINGLECHEKBOX,IDC_SP_AUTOCOARSE),

	// Display type
	ParamUIDesc(PB_PANOTDRAFT,TYPE_SINGLECHEKBOX,IDC_SP_DRAFTMODE),

	// Fragment Thickness
	ParamUIDesc(
		PB_FRAGTHICKNESS,
		EDITTYPE_UNIVERSE,
		IDC_SP_CHUNKTHICK,IDC_SP_CHUNKTHICKSPIN,
		0.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Fragment Object Using
	ParamUIDesc(PB_FRAGMETHOD,TYPE_RADIO,fragmenttypeIDs,3),

	// Number of Chunks
	ParamUIDesc(
		PB_FRAGCOUNT,
		EDITTYPE_INT,
		IDC_SP_CHUNKQTYEDIT,IDC_SP_CHUNKQTYEDITSPIN,
		1.0f,65000.0f,
		1.0f),

	// Smoothing Angle
	ParamUIDesc(
		PB_SMOOTHANG,
		EDITTYPE_FLOAT,
		IDC_SP_CHUNKSMANGLE,IDC_SP_CHUNKSMANGLESPIN,
		0.0f,180.0f,
		1.0f,
		stdAngleDim),

 	// Use Subtree Checkbox
	ParamUIDesc(PB_USESUBTREE,TYPE_SINGLECHEKBOX,IDC_AP_USESUBTREE),

	// Display type
	ParamUIDesc(PB_ANIMATIONOFFSET,TYPE_RADIO,animateoffsetIDs,3),

	// Animation Offset Amount
	ParamUIDesc(
		PB_OFFSETAMOUNT,
		EDITTYPE_TIME,
		IDC_AP_ANIRNDFR,IDC_AP_ANIRNDFRSPIN,
		0.0f,999999999.0f,
		10.0f),

		// Mapping Across
	ParamUIDesc(PB_MAPPINGTYPE,TYPE_RADIO,mappingIDs,2),

	// Time Mapping Option
	ParamUIDesc(
		PB_MAPPINGTIME,
		EDITTYPE_TIME,
		IDC_SP_MAPTIMEVAL,IDC_SP_MAPTIMEVALSPIN,
		1.0f,999999999.0f,
		10.0f),

	// Distance Mapping Option
	ParamUIDesc(
		PB_MAPPINGDIST,
		EDITTYPE_UNIVERSE,
		IDC_SP_MAPDISTVAL,IDC_SP_MAPDISTVALSPIN,
		0.1f,999999999.0f,
		SPIN_AUTOSCALE),
	
	// Use Material From Custom
	ParamUIDesc(PB_CUSTOMMATERIAL,TYPE_RADIO,custmtlIDs,3),

	// Edge Material ID
	ParamUIDesc(
		PB_EMAT,
		EDITTYPE_INT,
		IDC_AP_EDGEMATID,IDC_AP_EDGEMATIDSPIN,
		0.0f,65000.0f,
		SPIN_AUTOSCALE),

	// Back Material ID
	ParamUIDesc(
		PB_BMAT,
		EDITTYPE_INT,
		IDC_AP_BACKMATID,IDC_AP_BACKMATIDSPIN,
		0.0f,65000.0f,
		SPIN_AUTOSCALE),

	// Front Material ID
	ParamUIDesc(
		PB_FMAT,
		EDITTYPE_INT,
		IDC_AP_MATID,IDC_AP_MATIDSPIN,
		0.0f,65000.0f,
		SPIN_AUTOSCALE),

};
#define PARAMPTYPE_LENGTH 22

// Common Dialog for Particle Spin
static ParamUIDesc descParamPSpin[] = {

	// Spin Time
	ParamUIDesc(
		PB_SPINTIME,
		EDITTYPE_TIME,
		IDC_SP_SPIN,IDC_SP_SPINSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Spin Time Var
	ParamUIDesc(
		PB_SPINTIMEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINVAR,IDC_SP_SPINVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Spin Phase
	ParamUIDesc(
		PB_SPINPHASE,
		EDITTYPE_FLOAT,
		IDC_SP_SPINPHA,IDC_SP_SPINPHASPIN,
		-360.0f,360.0f,
		0.01f,
		stdAngleDim),

	// Spin Phase Variation
	ParamUIDesc(
		PB_SPINPHASEVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINPHAVAR,IDC_SP_SPINPHAVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Enter Axis Control
  	ParamUIDesc(PB_SPINAXISTYPE,TYPE_RADIO,spindirectionIDs,3),

	// X-Axis
	ParamUIDesc(
		PB_SPINAXISX,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISX,IDC_SP_SPINAXISXSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Y-Axis
	ParamUIDesc(
		PB_SPINAXISY,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISY,IDC_SP_SPINAXISYSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Z-Axis
	ParamUIDesc(
		PB_SPINAXISZ,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISZ,IDC_SP_SPINAXISZSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Spin Direction Variation
	ParamUIDesc(
		PB_SPINAXISVAR,
		EDITTYPE_FLOAT,
		IDC_SP_SPINAXISVAR,IDC_SP_SPINAXISVARSPIN,
		-180.0f,180.0f,
		0.01f,
		stdAngleDim),

	// Stretch
	ParamUIDesc(
		PB_STRETCH,
		EDITTYPE_INT,
		IDC_AP_STRETCH,IDC_AP_STRETCHSPIN,
		-1000.0f,1000.0f,
		1.0f),

	// IPC Enable
	ParamUIDesc(PB_PAIPCOLLIDE_ON,TYPE_SINGLECHEKBOX,IDC_INTERP_BOUNCEON),

	// IPC Steps
	ParamUIDesc(
		PB_PAIPCOLLIDE_STEPS,
		EDITTYPE_INT,
		IDC_INTERP_NSTEPS,IDC_INTERP_NSTEPSSPIN,
		1.0f,1000.0f,
		1.0f),

	// IPC Bounce
	ParamUIDesc(
		PB_PAIPCOLLIDE_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_INTERP_BOUNCE,IDC_INTERP_BOUNCESPIN,
		0.0f,10000.0f,
		1.0f,
		stdPercentDim),

	// IPC Bounce
	ParamUIDesc(
		PB_PAIPCOLLIDE_BOUNCEVAR,
		EDITTYPE_FLOAT,
		IDC_INTERP_BOUNCEVAR,IDC_INTERP_BOUNCEVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	};
#define PARAMPSPIN_LENGTH 14

// Common Dialog for Secondary Motion Data
static ParamUIDesc descParamEmitV[] = {

	// Emitter Velocity Inheritance Influence Portion
	ParamUIDesc(
		PB_EMITVINFL,
		EDITTYPE_FLOAT,
		IDC_SP_EMVI,IDC_SP_EMVISPIN,
		0.0f,100.0f,
		0.01f),

	// Secondary Motion Multiplier
	ParamUIDesc(
		PB_EMITVMULT,
		EDITTYPE_FLOAT,
		IDC_SP_EMVIMULT,IDC_SP_EMVIMULTSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Multiplier Variation
	ParamUIDesc(
		PB_EMITVMULTVAR,
		EDITTYPE_FLOAT,
		IDC_SP_EMVIMULTVAR,IDC_SP_EMVIMULTVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),
	};
#define PARAMEMITV_LENGTH 3

// Common Dialog for Bubble Motion
static ParamUIDesc descParamBubl[] = {

	// Bubble Amplitude
	ParamUIDesc(
		PB_BUBLAMP,
		EDITTYPE_UNIVERSE,
		IDC_SP_BUBL_AMP,IDC_SP_BUBL_AMPSPIN,
		-.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Bubble Amp Var
	ParamUIDesc(
		PB_BUBLAMPVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_AMPVAR,IDC_SP_BUBL_AMPVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Bubble Period
	ParamUIDesc(
		PB_BUBLPER,
		EDITTYPE_TIME,
		IDC_SP_BUBL_PER,IDC_SP_BUBL_PERSPIN,
		0.0f,999999999.0f,
		10.0f),

	// Bubble Period Var
	ParamUIDesc(
		PB_BUBLPERVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERVAR,IDC_SP_BUBL_PERVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Bubble Phase
	ParamUIDesc(
		PB_BUBLPHAS,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERPHA,IDC_SP_BUBL_PERPHASPIN,
		-360.0f,360.0f,
		0.01f,
		stdAngleDim),

	// Bubble Phase Var
	ParamUIDesc(
		PB_BUBLPHASVAR,
		EDITTYPE_FLOAT,
		IDC_SP_BUBL_PERPHAVAR,IDC_SP_BUBL_PERPHAVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),
};
#define PARAMBUBL_LENGTH 6

static int SpawnTypeIDs[] = {IDC_AP_NOSPAWN,IDC_AP_COLLIDEDIE,IDC_AP_COLLIDESPAWN,IDC_AP_DEATHSPAWN,IDC_AP_SPAWNTRAILS};
static int SpeedChaosIDs[] = {IDC_AP_SPEEDLESS,IDC_AP_SPEEDMORE,IDC_AP_SPEEDBOTH};
static int ScaleChaosIDs[] = {IDC_AP_SCALEDOWN,IDC_AP_SCALEUP,IDC_AP_SCALEBOTH};

// Dialog for Particle Spawning
static ParamUIDesc descPSpawning[] = {
	
	// Spawing Effects Type
	ParamUIDesc(PB_SPAWNTYPE,TYPE_RADIO,SpawnTypeIDs,5),

	// Die after X
	ParamUIDesc(
		PB_PASPAWNDIEAFTER,
		EDITTYPE_TIME,
		IDC_AP_MAXSPAWNDIEAFTER,IDC_AP_MAXSPAWNDIEAFTERSPIN,
		0.0f,999999999.0f,
		10.0f),

	ParamUIDesc(
		PB_PASPAWNDIEAFTERVAR,
		EDITTYPE_FLOAT,
		IDC_AP_MAXSPAWNDIEAFTERVAR,IDC_AP_MAXSPAWNDIEAFTERVARSPIN,
		0.0f,100.0f,
		0.01f,
		stdPercentDim),

	// Spawn Generations
	ParamUIDesc(
		PB_SPAWNGENS,
		EDITTYPE_INT,
		IDC_AP_MAXSPAWNGENS,IDC_AP_MAXSPAWNGENSSPIN,
		1.0f,65000.0f,
		1.0f),

	// Spawn Percent
	ParamUIDesc(
		PB_SPAWNPERCENT,
		EDITTYPE_INT,
		IDC_AP_PARENTPERCENT,IDC_AP_PARENTPERCENTSPIN,
		1.0f,100.0f,
		1.0f),

	// Spawn Spawncount
	ParamUIDesc(
		PB_SPAWNCOUNT,
		EDITTYPE_INT,
		IDC_AP_NUMBERVAR,IDC_AP_NUMBERVARSPIN,
		1.0f,65000.0f,
		1.0f),

	// Spawn Mult Percent
	ParamUIDesc(
		PB_SPAWNMULTVAR,
		EDITTYPE_FLOAT,
		IDC_AP_NUMBERVARVAR,IDC_AP_NUMBERVARVARSPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Spawn Direction Chaos
	ParamUIDesc(
		PB_SPAWNDIRCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSANGLE,IDC_AP_CHAOSANGLESPIN,
		0.0f,100.0f,
		0.1f,stdPercentDim),

	// Spawn Speed Chaos
	ParamUIDesc(
		PB_SPAWNSPEEDCHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSPEED,IDC_AP_CHAOSSPEEDSPIN,
		0.0f,100.0f,
		0.1f),

	// Spawing Speed Sign
	ParamUIDesc(PB_SPAWNSPEEDSIGN,TYPE_RADIO,SpeedChaosIDs,3),

	// Spawning Inherit Parent V
	ParamUIDesc(PB_SPAWNINHERITV,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSUMV),

	// Spawning Speed Fixed
	ParamUIDesc(PB_SPAWNSPEEDFIXED,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSPEEDFIXED),

	// Spawn Scale Chaos
	ParamUIDesc(
		PB_SPAWNSCALECHAOS,
		EDITTYPE_FLOAT,
		IDC_AP_CHAOSSCALE,IDC_AP_CHAOSSCALESPIN,
		0.0f,100.0f,
		0.1f),

	// Spawning Scale Sign
	ParamUIDesc(PB_SPAWNSCALESIGN,TYPE_RADIO,ScaleChaosIDs,3),

	// Spawning Speed Fixed
	ParamUIDesc(PB_SPAWNSCALEFIXED,TYPE_SINGLECHEKBOX,IDC_AP_SPAWNSCALEFIXED),

	// Spawn Lifespan Entry Field
	ParamUIDesc(
		PB_SPAWNLIFEVLUE,
		EDITTYPE_INT,
		IDC_AP_QUEUELIFESPAN,IDC_AP_QUEUELIFESPANSPIN,
		0.0f,65000.0f,
		SPIN_AUTOSCALE),
};
#define PSPAWNINGPARAMS_LENGTH 16

static ParamBlockDescID spdescVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//Distribution
	{ TYPE_INT, NULL, FALSE, 1 },	 // Emitter count
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // speed var
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // angle div

	{ TYPE_INT, NULL, FALSE, 5 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 6 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 7 },    // total number
	{ TYPE_INT, NULL, FALSE, 8 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 9 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 10 },   // display until
	{ TYPE_INT, NULL, TRUE, 11 },	 // life
	{ TYPE_INT, NULL, TRUE, 12 },	 // life var
	{ TYPE_INT, NULL, FALSE, 13 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 15 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size var
	{ TYPE_INT, NULL, FALSE, 17 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 18 },    // fade time
	{ TYPE_INT, NULL, FALSE, 19 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 20 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 21 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 22 },  // particle class
	{ TYPE_INT, NULL, FALSE, 23 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 24 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 26 }, // meta course
	{ TYPE_INT, NULL, FALSE, 27 }, // auto coarseness
	{ TYPE_FLOAT, NULL, FALSE, 28 },  // frag thickness
	{ TYPE_INT, NULL, FALSE, 29 },	  // frag method
	{ TYPE_INT, NULL, FALSE, 30 },	  // frag count
	{ TYPE_FLOAT, NULL, FALSE, 31 },  //smooth angle
	{ TYPE_INT, NULL, FALSE, 32 },  //Use subtree
	{ TYPE_INT, NULL, FALSE, 33 },  //animation offset method
	{ TYPE_INT, NULL, FALSE, 34 },  //animation offset amount
	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist
	{ TYPE_INT, NULL, FALSE, 40 },	  // custom material

	{ TYPE_INT, NULL, FALSE, 41 },  // side material
	{ TYPE_INT, NULL, FALSE, 42 },  // back material
	{ TYPE_INT, NULL, FALSE, 43 },  // front material

	{ TYPE_INT, NULL, TRUE, 44 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 45 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 46 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 48 },  // spin axis type
	{ TYPE_FLOAT, NULL, TRUE, 49 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 50 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 51 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 53 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 54 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 58 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 59 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 60 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble phase var
	{ TYPE_INT, NULL, TRUE, 62 },  // stretch

	{ TYPE_INT, NULL, FALSE, 63 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 64 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 65 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 67 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 68 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 69 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 70 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 71 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 72 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 73 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 74 }, // constant spawn scale
};

static ParamBlockDescID spdescVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//Distribution
	{ TYPE_INT, NULL, FALSE, 1 },	 // Emitter count
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // speed var
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // angle div

	{ TYPE_INT, NULL, FALSE, 5 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 6 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 7 },    // total number
	{ TYPE_INT, NULL, FALSE, 8 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 9 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 10 },   // display until
	{ TYPE_INT, NULL, TRUE, 11 },	 // life
	{ TYPE_INT, NULL, TRUE, 12 },	 // life var
	{ TYPE_INT, NULL, FALSE, 13 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 15 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size var
	{ TYPE_INT, NULL, FALSE, 17 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 18 },    // fade time
	{ TYPE_INT, NULL, FALSE, 19 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 20 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 21 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 22 },  // particle class
	{ TYPE_INT, NULL, FALSE, 23 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 24 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 26 }, // meta course
	{ TYPE_INT, NULL, FALSE, 27 }, // auto coarseness
	{ TYPE_FLOAT, NULL, FALSE, 28 },  // frag thickness
	{ TYPE_INT, NULL, FALSE, 29 },	  // frag method
	{ TYPE_INT, NULL, FALSE, 30 },	  // frag count
	{ TYPE_FLOAT, NULL, FALSE, 31 },  //smooth angle
	{ TYPE_INT, NULL, FALSE, 32 },  //Use subtree
	{ TYPE_INT, NULL, FALSE, 33 },  //animation offset method
	{ TYPE_INT, NULL, FALSE, 34 },  //animation offset amount
	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist
	{ TYPE_INT, NULL, FALSE, 40 },	  // custom material

	{ TYPE_INT, NULL, FALSE, 41 },  // side material
	{ TYPE_INT, NULL, FALSE, 42 },  // back material
	{ TYPE_INT, NULL, FALSE, 43 },  // front material

	{ TYPE_INT, NULL, TRUE, 44 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 45 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 46 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 48 },  // spin axis type
	{ TYPE_FLOAT, NULL, TRUE, 49 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 50 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 51 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 53 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 54 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 58 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 59 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 60 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble phase var
	{ TYPE_INT, NULL, TRUE, 62 },  // stretch

	{ TYPE_INT, NULL, FALSE, 63 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 64 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 65 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 67 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 68 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 69 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 70 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 71 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 72 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 73 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 74 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 75 }, // Meta course viewport
};

static ParamBlockDescID spdescVer2[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//Distribution
	{ TYPE_INT, NULL, FALSE, 1 },	 // Emitter count
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // speed var
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // angle div

	{ TYPE_INT, NULL, FALSE, 5 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 6 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 7 },    // total number
	{ TYPE_INT, NULL, FALSE, 8 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 9 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 10 },   // display until
	{ TYPE_INT, NULL, TRUE, 11 },	 // life
	{ TYPE_INT, NULL, TRUE, 12 },	 // life var
	{ TYPE_INT, NULL, FALSE, 13 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 15 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size var
	{ TYPE_INT, NULL, FALSE, 17 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 18 },    // fade time
	{ TYPE_INT, NULL, FALSE, 19 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 20 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 21 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 22 },  // particle class
	{ TYPE_INT, NULL, FALSE, 23 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 24 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 26 }, // meta course
	{ TYPE_INT, NULL, FALSE, 27 }, // auto coarseness
	{ TYPE_FLOAT, NULL, FALSE, 28 },  // frag thickness
	{ TYPE_INT, NULL, FALSE, 29 },	  // frag method
	{ TYPE_INT, NULL, FALSE, 30 },	  // frag count
	{ TYPE_FLOAT, NULL, FALSE, 31 },  //smooth angle
	{ TYPE_INT, NULL, FALSE, 32 },  //Use subtree
	{ TYPE_INT, NULL, FALSE, 33 },  //animation offset method
	{ TYPE_INT, NULL, FALSE, 34 },  //animation offset amount
	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist
	{ TYPE_INT, NULL, FALSE, 40 },	  // custom material

	{ TYPE_INT, NULL, FALSE, 41 },  // side material
	{ TYPE_INT, NULL, FALSE, 42 },  // back material
	{ TYPE_INT, NULL, FALSE, 43 },  // front material

	{ TYPE_INT, NULL, TRUE, 44 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 45 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 46 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 48 },  // spin axis type
	{ TYPE_FLOAT, NULL, TRUE, 49 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 50 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 51 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 53 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 54 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 58 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 59 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 60 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble phase var
	{ TYPE_INT, NULL, TRUE, 62 },  // stretch

	{ TYPE_INT, NULL, FALSE, 63 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 64 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 65 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 67 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 68 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 69 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 70 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 71 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 72 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 73 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 74 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 75 }, // Meta course viewport
	{ TYPE_INT, NULL, FALSE, 76 }, // Subframe rotation checkbox
};
static ParamBlockDescID spdescVer3[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//Distribution
	{ TYPE_INT, NULL, FALSE, 1 },	 // Emitter count
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // speed var
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // angle div

	{ TYPE_INT, NULL, FALSE, 5 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 6 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 7 },    // total number
	{ TYPE_INT, NULL, FALSE, 8 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 9 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 10 },   // display until
	{ TYPE_INT, NULL, TRUE, 11 },	 // life
	{ TYPE_INT, NULL, TRUE, 12 },	 // life var
	{ TYPE_INT, NULL, FALSE, 13 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 15 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size var
	{ TYPE_INT, NULL, FALSE, 17 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 18 },    // fade time
	{ TYPE_INT, NULL, FALSE, 19 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 20 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 21 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 22 },  // particle class
	{ TYPE_INT, NULL, FALSE, 23 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 24 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 26 }, // meta course
	{ TYPE_INT, NULL, FALSE, 27 }, // auto coarseness
	{ TYPE_FLOAT, NULL, FALSE, 28 },  // frag thickness
	{ TYPE_INT, NULL, FALSE, 29 },	  // frag method
	{ TYPE_INT, NULL, FALSE, 30 },	  // frag count
	{ TYPE_FLOAT, NULL, FALSE, 31 },  //smooth angle
	{ TYPE_INT, NULL, FALSE, 32 },  //Use subtree
	{ TYPE_INT, NULL, FALSE, 33 },  //animation offset method
	{ TYPE_INT, NULL, FALSE, 34 },  //animation offset amount
	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist
	{ TYPE_INT, NULL, FALSE, 40 },	  // custom material

	{ TYPE_INT, NULL, FALSE, 41 },  // side material
	{ TYPE_INT, NULL, FALSE, 42 },  // back material
	{ TYPE_INT, NULL, FALSE, 43 },  // front material

	{ TYPE_INT, NULL, TRUE, 44 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 45 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 46 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 48 },  // spin axis type
	{ TYPE_FLOAT, NULL, TRUE, 49 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 50 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 51 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 53 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 54 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 58 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 59 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 60 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble phase var
	{ TYPE_INT, NULL, TRUE, 62 },  // stretch

	{ TYPE_INT, NULL, FALSE, 63 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 64 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 65 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 67 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 68 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 69 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 70 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 71 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 72 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 73 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 74 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 75 }, // Meta course viewport
	{ TYPE_INT, NULL, FALSE, 76 }, // Subframe rotation checkbox
	{ TYPE_INT, NULL, FALSE, 77 }, // spawn percent
	{ TYPE_FLOAT, NULL, FALSE, 78 }, // spawn mult var
};
static ParamBlockDescID spdescVer4[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//Distribution
	{ TYPE_INT, NULL, FALSE, 1 },	 // Emitter count
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // speed var
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // angle div

	{ TYPE_INT, NULL, FALSE, 5 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 6 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 7 },    // total number
	{ TYPE_INT, NULL, FALSE, 8 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 9 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 10 },   // display until
	{ TYPE_INT, NULL, TRUE, 11 },	 // life
	{ TYPE_INT, NULL, TRUE, 12 },	 // life var
	{ TYPE_INT, NULL, FALSE, 13 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 15 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size var
	{ TYPE_INT, NULL, FALSE, 17 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 18 },    // fade time
	{ TYPE_INT, NULL, FALSE, 19 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 20 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 21 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 22 },  // particle class
	{ TYPE_INT, NULL, FALSE, 23 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 24 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 26 }, // meta course
	{ TYPE_INT, NULL, FALSE, 27 }, // auto coarseness
	{ TYPE_FLOAT, NULL, FALSE, 28 },  // frag thickness
	{ TYPE_INT, NULL, FALSE, 29 },	  // frag method
	{ TYPE_INT, NULL, FALSE, 30 },	  // frag count
	{ TYPE_FLOAT, NULL, FALSE, 31 },  //smooth angle
	{ TYPE_INT, NULL, FALSE, 32 },  //Use subtree
	{ TYPE_INT, NULL, FALSE, 33 },  //animation offset method
	{ TYPE_INT, NULL, FALSE, 34 },  //animation offset amount
	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist
	{ TYPE_INT, NULL, FALSE, 40 },	  // custom material

	{ TYPE_INT, NULL, FALSE, 41 },  // side material
	{ TYPE_INT, NULL, FALSE, 42 },  // back material
	{ TYPE_INT, NULL, FALSE, 43 },  // front material

	{ TYPE_INT, NULL, TRUE, 44 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 45 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 46 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 48 },  // spin axis type
	{ TYPE_FLOAT, NULL, TRUE, 49 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 50 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 51 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 53 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 54 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 58 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 59 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 60 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble phase var
	{ TYPE_INT, NULL, TRUE, 62 },  // stretch

	{ TYPE_INT, NULL, FALSE, 63 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 64 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 65 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 67 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 68 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 69 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 70 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 71 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 72 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 73 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 74 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 75 }, // Meta course viewport
	{ TYPE_INT, NULL, FALSE, 76 }, // Subframe rotation checkbox
	{ TYPE_INT, NULL, FALSE, 77 }, // spawn percent
	{ TYPE_FLOAT, NULL, FALSE, 78 }, // spawn mult var
	{ TYPE_INT, NULL, FALSE, 79 }, // Not Draft
	{ TYPE_INT, NULL, TRUE, 80 }, // Use Selected
};
static ParamBlockDescID spdescVer5[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//Distribution
	{ TYPE_INT, NULL, FALSE, 1 },	 // Emitter count
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // speed var
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // angle div

	{ TYPE_INT, NULL, FALSE, 5 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 6 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 7 },    // total number
	{ TYPE_INT, NULL, FALSE, 8 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 9 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 10 },   // display until
	{ TYPE_INT, NULL, TRUE, 11 },	 // life
	{ TYPE_INT, NULL, TRUE, 12 },	 // life var
	{ TYPE_INT, NULL, FALSE, 13 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 15 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size var
	{ TYPE_INT, NULL, FALSE, 17 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 18 },    // fade time
	{ TYPE_INT, NULL, FALSE, 19 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 20 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 21 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 22 },  // particle class
	{ TYPE_INT, NULL, FALSE, 23 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 24 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 26 }, // meta course
	{ TYPE_INT, NULL, FALSE, 27 }, // auto coarseness
	{ TYPE_FLOAT, NULL, FALSE, 28 },  // frag thickness
	{ TYPE_INT, NULL, FALSE, 29 },	  // frag method
	{ TYPE_INT, NULL, FALSE, 30 },	  // frag count
	{ TYPE_FLOAT, NULL, FALSE, 31 },  //smooth angle
	{ TYPE_INT, NULL, FALSE, 32 },  //Use subtree
	{ TYPE_INT, NULL, FALSE, 33 },  //animation offset method
	{ TYPE_INT, NULL, FALSE, 34 },  //animation offset amount
	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist
	{ TYPE_INT, NULL, FALSE, 40 },	  // custom material

	{ TYPE_INT, NULL, FALSE, 41 },  // side material
	{ TYPE_INT, NULL, FALSE, 42 },  // back material
	{ TYPE_INT, NULL, FALSE, 43 },  // front material

	{ TYPE_INT, NULL, TRUE, 44 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 45 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 46 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 48 },  // spin axis type
	{ TYPE_FLOAT, NULL, TRUE, 49 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 50 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 51 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 53 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 54 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 58 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 59 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 60 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble phase var
	{ TYPE_INT, NULL, TRUE, 62 },  // stretch

	{ TYPE_INT, NULL, FALSE, 63 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 64 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 65 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 67 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 68 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 69 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 70 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 71 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 72 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 73 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 74 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 75 }, // Meta course viewport
	{ TYPE_INT, NULL, FALSE, 76 }, // Subframe rotation checkbox
	{ TYPE_INT, NULL, FALSE, 77 }, // spawn percent
	{ TYPE_FLOAT, NULL, FALSE, 78 }, // spawn mult var
	{ TYPE_INT, NULL, FALSE, 79 }, // Not Draft
	{ TYPE_INT, NULL, TRUE, 80 }, // Use Selected
	{ TYPE_INT, NULL, TRUE, 81 }, // die after X
	{ TYPE_FLOAT, NULL, TRUE, 82 }, // die after X var
};
static ParamBlockDescID spdescVer6[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	//Distribution
	{ TYPE_INT, NULL, FALSE, 1 },	 // Emitter count
	{ TYPE_FLOAT, NULL, TRUE, 2 },	 // speed
	{ TYPE_FLOAT, NULL, TRUE, 3 },	 // speed var
	{ TYPE_FLOAT, NULL, TRUE, 4 },	 // angle div

	{ TYPE_INT, NULL, FALSE, 5 },	 // Birth method
	{ TYPE_INT, NULL, TRUE, 6 },	 // Birth rate
	{ TYPE_INT, NULL, FALSE, 7 },    // total number
	{ TYPE_INT, NULL, FALSE, 8 },	 // emit start
	{ TYPE_INT, NULL, FALSE, 9 },   // emit stop
	{ TYPE_INT, NULL, FALSE, 10 },   // display until
	{ TYPE_INT, NULL, TRUE, 11 },	 // life
	{ TYPE_INT, NULL, TRUE, 12 },	 // life var
	{ TYPE_INT, NULL, FALSE, 13 },	 // sub frame move
	{ TYPE_INT, NULL, FALSE, 14 },	 // sub frame time
	{ TYPE_FLOAT, NULL, TRUE, 15 },	 // size
	{ TYPE_FLOAT, NULL, TRUE, 16 },	 // size var
	{ TYPE_INT, NULL, FALSE, 17 },	 // grow time
	{ TYPE_INT, NULL, FALSE, 18 },    // fade time
	{ TYPE_INT, NULL, FALSE, 19 }, // rnd seed
	{ TYPE_FLOAT, NULL, FALSE, 20 },  // emitter width
	{ TYPE_INT, NULL, FALSE, 21 },    // emitter hidden

	{ TYPE_INT, NULL, FALSE, 22 },  // particle class
	{ TYPE_INT, NULL, FALSE, 23 },  // particle type
	{ TYPE_FLOAT, NULL, TRUE, 24 },	// meta tension
	{ TYPE_FLOAT, NULL, TRUE, 25 },	// metatension var
	{ TYPE_FLOAT, NULL, FALSE, 26 }, // meta course
	{ TYPE_INT, NULL, FALSE, 27 }, // auto coarseness
	{ TYPE_FLOAT, NULL, FALSE, 28 },  // frag thickness
	{ TYPE_INT, NULL, FALSE, 29 },	  // frag method
	{ TYPE_INT, NULL, FALSE, 30 },	  // frag count
	{ TYPE_FLOAT, NULL, FALSE, 31 },  //smooth angle
	{ TYPE_INT, NULL, FALSE, 32 },  //Use subtree
	{ TYPE_INT, NULL, FALSE, 33 },  //animation offset method
	{ TYPE_INT, NULL, FALSE, 34 },  //animation offset amount
	{ TYPE_INT, NULL, FALSE, 35 },	  // viewport shows
	{ TYPE_FLOAT, NULL, FALSE, 36 }, // display portion
	{ TYPE_INT, NULL, FALSE, 37 },	  // mapping type
	{ TYPE_INT, NULL, TRUE, 38 },	  // mapping time
	{ TYPE_FLOAT, NULL, TRUE, 39 },	  // mapping dist
	{ TYPE_INT, NULL, FALSE, 40 },	  // custom material

	{ TYPE_INT, NULL, FALSE, 41 },  // side material
	{ TYPE_INT, NULL, FALSE, 42 },  // back material
	{ TYPE_INT, NULL, FALSE, 43 },  // front material

	{ TYPE_INT, NULL, TRUE, 44 },	// spin time
	{ TYPE_FLOAT, NULL, TRUE, 45 },  // spin time var
	{ TYPE_FLOAT, NULL, TRUE, 46 },  // spin phase
	{ TYPE_FLOAT, NULL, TRUE, 47 },  // spin phase var
	{ TYPE_INT, NULL, FALSE, 48 },  // spin axis type
	{ TYPE_FLOAT, NULL, TRUE, 49 }, // spin axis x
	{ TYPE_FLOAT, NULL, TRUE, 50 }, // spin axis y
	{ TYPE_FLOAT, NULL, TRUE, 51 }, // spin axis z
	{ TYPE_FLOAT, NULL, TRUE, 52 }, // spin axis var

	{ TYPE_FLOAT, NULL, TRUE, 53 },  // emit influence
	{ TYPE_FLOAT, NULL, TRUE, 54 },  // emit multiplier
	{ TYPE_FLOAT, NULL, TRUE, 55 },  // emit mult var

	{ TYPE_FLOAT, NULL, TRUE, 56 },  // bubble amp
	{ TYPE_FLOAT, NULL, TRUE, 57 },  // bubble amp var
	{ TYPE_INT, NULL, TRUE, 58 },  // bubble period
	{ TYPE_FLOAT, NULL, TRUE, 59 },  // bubble period var
	{ TYPE_FLOAT, NULL, TRUE, 60 },  // bubble phase
	{ TYPE_FLOAT, NULL, TRUE, 61 },  // bubble phase var
	{ TYPE_INT, NULL, TRUE, 62 },  // stretch

	{ TYPE_INT, NULL, FALSE, 63 }, // spawn type
	{ TYPE_INT, NULL, FALSE, 64 }, // number of gens
	{ TYPE_INT, NULL, FALSE, 65 }, // number of spawns
	{ TYPE_FLOAT, NULL, TRUE, 66 }, // direction chaos
	{ TYPE_FLOAT, NULL, TRUE, 67 }, // speed chaos
	{ TYPE_INT, NULL, FALSE, 68 }, // speed chaos sign
	{ TYPE_INT, NULL, FALSE, 69 }, // inherit old particle velocity
	{ TYPE_FLOAT, NULL, TRUE, 70 }, // scale chaos 
	{ TYPE_INT, NULL, FALSE, 71 }, // scale chaos sign
	{ TYPE_INT, NULL, FALSE, 72 }, // lifespan entry field
	{ TYPE_INT, NULL, FALSE, 73 }, // constant spawn speed
	{ TYPE_INT, NULL, FALSE, 74 }, // constant spawn scale
	{ TYPE_FLOAT, NULL, FALSE, 75 }, // Meta course viewport
	{ TYPE_INT, NULL, FALSE, 76 }, // Subframe rotation checkbox
	{ TYPE_INT, NULL, FALSE, 77 }, // spawn percent
	{ TYPE_FLOAT, NULL, FALSE, 78 }, // spawn mult var
	{ TYPE_INT, NULL, FALSE, 79 }, // Not Draft
	{ TYPE_INT, NULL, TRUE, 80 }, // Use Selected
	{ TYPE_INT, NULL, TRUE, 81 }, // die after X
	{ TYPE_FLOAT, NULL, TRUE, 82 }, // die after X var
	{ TYPE_INT, NULL, FALSE, 83 },  // IPC Enable
	{ TYPE_INT, NULL, FALSE, 84 },  // IPC Steps
	{ TYPE_FLOAT, NULL, TRUE, 85 },  // IPC Bounce
	{ TYPE_FLOAT, NULL, TRUE, 86 },  // IPC Bounce Var
};

static ParamVersionDesc paversions[] = {
	ParamVersionDesc(spdescVer0,75,0),
	ParamVersionDesc(spdescVer1,76,1),
	ParamVersionDesc(spdescVer2,77,2),
	ParamVersionDesc(spdescVer3,79,3),
	ParamVersionDesc(spdescVer4,81,4),
	ParamVersionDesc(spdescVer5,83,5),
	};
#define PBLOCK_LENGTH_PARRAY 87

#define NUM_OLDVERSIONS	6

// Current version
#define CURRENT_VERSION	6
static ParamVersionDesc curVersionPA(spdescVer6,PBLOCK_LENGTH_PARRAY,CURRENT_VERSION);

void PACheckInstButtons(IParamBlock *pblock,HWND hptype)
{ int isinst;
  pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
  if ((isinst==INSTGEOM)||(isinst==BYGEOM))
   TurnButton(hptype,IDC_AP_OBJECTPICK,TRUE);
}

void PACheckSpawnButtons(IParamBlock *pblock,HWND spawn,int repi)
{ int stype;
  pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
  int ison; pblock->GetValue(PB_PAIPCOLLIDE_ON,0,ison,FOREVER);
  if (ison) stype=0;
  SpawnWithStype(stype,spawn,repi);
}

void PACheckPickButtons(IParamBlock *pblock,HWND hptype,HWND spawn,int repi)
{ PACheckInstButtons(pblock,hptype);
  PACheckSpawnButtons(pblock,spawn,repi);
}

//-- ParticleDlgProc ------------------------------------------------

class CreatePArrayProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		PArrayParticle *PArrayObject;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreatePArrayProc()
			{
			ignoreSelectionChange = FALSE;
			}
		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_CREATEPArrayMODE	CID_USER +13

class CreatePArrayMode : public CommandMode {		
	public:		
		CreatePArrayProc proc;
		IObjParam *ip;
		PArrayParticle *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,PArrayParticle*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEPArrayMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreatePArrayMode theCreatePArrayMode;

RefResult CreatePArrayProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( PArrayObject && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (PArrayObject && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (PArrayObject->creating) 
						{  theCreatePArrayMode.JumpStart(PArrayObject->ip,PArrayObject);
							createInterface->SetCommandMode(&theCreatePArrayMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				PArrayObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				PArrayObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				PArrayObject  = NULL;				
				CloudNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreatePArrayProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{					   
	ip=(IObjParam*)ioc;
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	PArrayObject       = NULL;
	CreateNewObject();
	}
void CreatePArrayProc::CreateNewObject()
	{
	PArrayObject = (PArrayParticle*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
	// Start the edit params process
	if ( PArrayObject ) {
		PArrayObject->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		PArrayObject->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreatePArrayProc::End()
{ if ( PArrayObject ) 
	{ 
#ifdef _OSNAP
		PArrayObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	
	PArrayObject->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete PArrayObject;
			PArrayObject = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		}  else if ( CloudNode ) 
		{	theHold.Suspend();
			DeleteReference(0);  // sets cloudNode = NULL
			theHold.Resume();  }
	}
}

void CreatePArrayMode::JumpStart(IObjParam *i,PArrayParticle *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int PArrayClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreatePArrayMode.Begin(iob,this);
	iob->PushCommandMode(&theCreatePArrayMode);
	return TRUE;
	}

int PArrayClassDesc::EndCreate(Interface *i)
	{
	theCreatePArrayMode.End();
	i->RemoveMode(&theCreatePArrayMode);
	return TRUE;
	}

int CreatePArrayProc::createmethod(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{	Point3 d;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				// if hidden by category, re-display particles and objects
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				sp0 = m;
				PArrayObject->pblock->SetValue(PB_EMITRWID,0,0.01f);
				p0 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1 = p0 + Point3(.01,.01,.01);
				mat.SetTrans(float(.5)*(p0+p1));				
				PArrayObject->pmapParam->Invalidate();
				break;

			case 1: 
				sp1 = m;
				p1 = vpt->SnapPoint(m,m,NULL,snapdim);
				p1.z = p0.z +(float).01; 
				if(flags&MOUSE_CTRL) 
				{ mat.SetTrans(p0);	} 
				else mat.SetTrans(float(.5)*(p0+p1));
				d = p1-p0;
					float len;
					if (fabs(d.x) > fabs(d.y)) len = d.x;
					else len = d.y;
					d.x = d.y = 2.0f * len;
				PArrayObject->pblock->SetValue(PB_EMITRWID,0,float(fabs(d.x)));
				PArrayObject->pmapParam->Invalidate();

				if (msg==MOUSE_POINT)
				{ if (Length(sp1-sp0)<3 || Length(d)<0.1f)  return CREATE_ABORT;	
				  else
				  {	ICustButton *iBut = GetICustButton(GetDlgItem(PArrayObject->hparam,IDC_SP_CHUNKPICKBUTTON));
					iBut->Enable();
					ReleaseICustButton(iBut);
					PACheckPickButtons(PArrayObject->pblock,PArrayObject->hptype,PArrayObject->spawn,PArrayObject->pickCB.repi);
				   return CREATE_STOP;	}
				}
				break;
			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}
	return 1;
	}

int CreatePArrayProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res=TRUE;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( PArrayObject );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
#ifdef _OSNAP
						PArrayObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				   		PArrayObject->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						// Get rid of the reference.
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}
						// new object
						CreateNewObject();   // creates PArrayObject
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( PArrayObject);
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = NULL;
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();

					mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));

					createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
				default:				
						res = createmethod(vpx,msg,point,flag,m,mat);

						if (res==CREATE_ABORT)
							goto abort;
						if (res==CREATE_STOP)
						{
#ifdef _OSNAP
                         PArrayObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
						 theHold.Accept(GetString(IDS_DS_CREATE));	 
						}
						createInterface->RedrawViews(createInterface->GetTime());   //DS

					break;
					
				}			
			break;

		case MOUSE_MOVE:
				mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));			
				res = createmethod(vpx,msg,point,flag,m,mat);
				if (res==CREATE_ABORT) 
					goto abort;
				if (res==CREATE_STOP)
				{
#ifdef _OSNAP
         PArrayObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
					theHold.Accept(GetString(IDS_DS_CREATE));	// TH
				}
				createInterface->RedrawViews(createInterface->GetTime(),REDRAW_INTERACTIVE);		//DS		
			break;

		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP  //PREVIEW SNAP
				res = createmethod(vpx,msg,point,flag,m,mat);
#endif
		vpx->TrackImplicitGrid(m);
			break;
	  case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
	  case MOUSE_ABORT: 
		 abort:
		assert( PArrayObject );
#ifdef _OSNAP
		PArrayObject->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		PArrayObject->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
			GetSystemSetting(SYSSET_CLEAR_UNDO);
		PArrayObject=NULL;
		createInterface->RedrawViews(createInterface->GetTime());
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
	}

	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
}

// The EnterMode and ExitMode methods allow the plug-in to update it's UI
// to indicate the command mode is active.  In this case we update the 
// state of the pick button to indicate the mode is active or inactive.
// The button color GREEN_WASH is the standard for command modes.

void PArrayParticle::GetTimes(TimeLst &times,TimeValue t,int anifr,int ltype,int fragflags)
{ int m,n,found,tmax,tnums=0,tgen;
  TimeValue tframe;  
  times.tl.SetCount(0);times.tl.Shrink();
  times.tl.Resize(100);tmax=100;times.tl.SetCount(tmax);
  int nCount=nlist.Count();
  for (m=0;m<parts.Count();m++)
  { if ((!parts.Alive(m))||((fragflags==BYGEOM)&&((sdata[m].gennum==0)||(nCount==0)))) continue;
    if (ltype)
	{ if (ltype==1) tframe=sdata[m].showframe+parts.ages[m];
	  else tframe=sdata[m].showframe+t;
  //    if ((tframe>=anifr)&&(anifr!=0)) tframe=tframe % anifr;
	} else tframe=t;
	found=n=0;
	tgen=(sdata[m].gennum>nCount?nCount:sdata[m].gennum);
	while ((n<tnums)&&(!found))
	{ found=((times.tl[n].gennum==tgen)&&(tframe==times.tl[n].tl));
	  n++;
	}
	if (!found) 
	{ if (tnums>=tmax) 
	  { times.tl.Resize(tmax+=100);times.tl.SetCount(tmax);}
	  times.tl[tnums].gennum=tgen;times.tl[tnums++].tl=tframe;
	}
  }
  times.tl.SetCount(tnums);
  times.tl.Shrink();
}

void PArrayParticle::RetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc,i;
  Mtl *submtl=node->GetMtl();
  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  RetrieveMtls(node->GetChildNode(i),subtree,numsubs,numtabs,tabmax,t);
  }
  if (IsGEOM(node->EvalWorldState(t).obj)!=NULL)
  { if (*numtabs>=*tabmax)
	{ mttab.Resize((*tabmax)+=256);}
	if (submtl!=NULL)
	{ mttab[(*numtabs)++]=submtl;
	  int subs;
	  if ((subs=submtl->NumSubMtls())>0)
	    (*numsubs)+=subs;
	  else (*numsubs)++;
	}
	else 
	{DWORD tc=node->GetWireColor();
	StdMat *m = NewDefaultStdMat();
	m->SetName(TSTR(_T("C"))+node->GetName());
	Color bcolor=Color(tc);
	m->SetDiffuse(bcolor,0);
	mttab[(*numtabs)++]=(Mtl*)m;
	(*numsubs)++;
	}
  }
}

void PArrayParticle::DoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
   for (int i=0;i<nc;i++)
   { INode *nxtnode=node->GetChildNode(i);
	  if (nxtnode->IsGroupHead()) DoGroupMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
	  else if ((subtree)||(nxtnode->IsGroupMember())) RetrieveMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
  }
}

void PArrayParticle::AssignMtl(INode *node,INode *topnode,int subtree,TimeValue t,int fragflags) 
{	Mtl *submtl;
	MultiMtl *newmat=NULL;
	  Mtl *nmtl=NULL;
	TSTR newname;
	MtlBaseLib glib;
	int tabmax=256;
	newname=TSTR(_T("CMat"))+node->GetName();
	if (_tcslen(newname)>16) newname[16]='\0';
	int numsubs=0,numtabs=0;
	int mstart=0,mcnt=nlist.Count();INode *onode;
	backpatch=FALSE;
	if (fragflags==BYGEOM)
	{ onode=distnode;mstart++;}
	else onode=custnode;
	nmtls.SetCount(mcnt+1);
    mttab.SetCount(tabmax);
    submtl=onode->GetMtl();
	INode *tmpnode=onode;
	if (fragflags==BYGEOM) 
	{ RetrieveMtls(distnode,FALSE,&numsubs,&numtabs,&tabmax,t);
	  nmtls[0]=numsubs;
	  tmpnode=nlist[0];
	}
	for (int mut=mstart;mut<=mcnt;mut++)
	{ if (tmpnode->IsGroupHead())
	    DoGroupMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  else
	  RetrieveMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  if (mut!=mcnt)
	  {nmtls[mut]=numsubs;
	   tmpnode=nlist[mut];
	  }
	}
	mttab.Shrink();
	if (!((numtabs==1)&&(submtl!=NULL)))
	{ TSTR oldname=TSTR(_T(" "));
	  if (nmtl=node->GetMtl())
		  oldname=nmtl->GetName();
	  if (_tcscmp(oldname,newname)!=0) 
	  { newmat=NewDefaultMultiMtl();
	    newmat->SetName(newname); }
	  else newmat=(MultiMtl*)nmtl;
//	  nmtl->FindMtl(nmtl);
	  newmat->SetNumSubMtls(numsubs);
	  int k=0,nt=0,j;
	  for (int i=0;i<numtabs;i++)
	  {	if ((nt=mttab[i]->NumSubMtls())>0)
	     for (j=0;j<nt;j++) 
		 { newmat->SetSubMtl(k,mttab[i]->GetSubMtl(j));
	       k++;
	     }
	     else 
		 { newmat->SetSubMtl(k,mttab[i]);
		   k++;
		 }
	  }
	}
    mttab.SetCount(0); mttab.Shrink();
	node->SetMtl(newmat!=NULL?newmat:submtl);  
}
void PArrayParticle::CntRetrieveMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc,i;
  Mtl *submtl=node->GetMtl();
  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  CntRetrieveMtls(node->GetChildNode(i),subtree,numsubs,numtabs,tabmax,t);
  }
  if (IsGEOM(node->EvalWorldState(t).obj)!=NULL)
  { if (submtl!=NULL)
	{ int subs;
	  if ((subs=submtl->NumSubMtls())>0)
	    (*numsubs)+=subs;
	  else (*numsubs)++;
	}
	else 
	(*numsubs)++;
  }
}

void PArrayParticle::CntDoGroupMtls(INode *node,int subtree,int *numsubs,int *numtabs,int *tabmax,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
   for (int i=0;i<nc;i++)
   { INode *nxtnode=node->GetChildNode(i);
	  if (nxtnode->IsGroupHead()) CntDoGroupMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
	  else if ((subtree)||(nxtnode->IsGroupMember())) CntRetrieveMtls(nxtnode,subtree,numsubs,numtabs,tabmax,t);
  }
}

void PArrayParticle::GetSubs(INode *node,INode *topnode,int subtree,TimeValue t,int fragflags) 
{	Mtl *submtl;
	int tabmax=256;
	int numsubs=0,numtabs=0;
	int mstart=0,mcnt=nlist.Count();INode *onode;
	if (fragflags==BYGEOM)
	{ onode=distnode;mstart++;}
	else onode=custnode;
	nmtls.SetCount(mcnt+1);
    submtl=onode->GetMtl();
	INode *tmpnode=onode;
	if (fragflags==BYGEOM) 
	{ CntRetrieveMtls(distnode,FALSE,&numsubs,&numtabs,&tabmax,t);
	  nmtls[0]=numsubs;
	  tmpnode=nlist[0];
	}
	for (int mut=mstart;mut<=mcnt;mut++)
	{ if (tmpnode->IsGroupHead())
	    CntDoGroupMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  else
	  CntRetrieveMtls(tmpnode,subtree,&numsubs,&numtabs,&tabmax,t);
	  if (mut!=mcnt)
	  {nmtls[mut]=numsubs;
	   tmpnode=nlist[mut];
	  }
	}
}
void MakeBBpts(Point3 *pts,Box3 bbox,Matrix3 ctm)
{ pts[0]=Point3(bbox.pmax[0],bbox.pmax[1],bbox.pmax[2])*ctm;
  pts[1]=Point3(bbox.pmax[0],bbox.pmax[1],bbox.pmin[2])*ctm;
  pts[2]=Point3(bbox.pmax[0],bbox.pmin[1],bbox.pmin[2])*ctm;
  pts[3]=Point3(bbox.pmax[0],bbox.pmin[1],bbox.pmax[2])*ctm;
  pts[4]=Point3(bbox.pmin[0],bbox.pmax[1],bbox.pmax[2])*ctm;
  pts[5]=Point3(bbox.pmin[0],bbox.pmax[1],bbox.pmin[2])*ctm;
  pts[6]=Point3(bbox.pmin[0],bbox.pmin[1],bbox.pmin[2])*ctm;
  pts[7]=Point3(bbox.pmin[0],bbox.pmin[1],bbox.pmax[2])*ctm;
}

void PArrayParticle::GetNextBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode)
{int i,nc;
	if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  GetNextBB(node->GetChildNode(i),subtree,count,tabmax,boxcenter,t,tcount,onode);
  }
  Object *cobj=node->EvalWorldState(t).obj;
  TriObject *triOb=TriIsUseable(cobj,t);
  if (triOb)
  {	 if (*count>=*tabmax)
	{ thePArrayDraw.bboxpt[tcount].bpts.Resize((*tabmax)+=256);}
    Matrix3 ctm = node->GetObjTMAfterWSM(t);
	if (node!=onode)
  { thePArrayDraw.bboxpt[tcount].bpts[*count].Suboffset=Point3(0.0f,0.0f,0.0f)*ctm-boxcenter;
  }	
  else thePArrayDraw.bboxpt[tcount].bpts[*count].Suboffset=Point3(0.0f,0.0f,0.0f);
	ctm.NoTrans();
	Box3 bbox=triOb->GetMesh().getBoundingBox();
	MakeBBpts(thePArrayDraw.bboxpt[tcount].bpts[*count].pts,bbox,ctm);
/* thePArrayDraw.bboxpt[tcount].bpts[*count].pts[0]=Point3(bbox.pmax[0],bbox.pmax[1],bbox.pmax[2])*ctm;
      thePArrayDraw.bboxpt[tcount].bpts[*count].pts[1]=Point3(bbox.pmax[0],bbox.pmax[1],bbox.pmin[2])*ctm;
  thePArrayDraw.bboxpt[tcount].bpts[*count].pts[2]=Point3(bbox.pmax[0],bbox.pmin[1],bbox.pmin[2])*ctm;
  thePArrayDraw.bboxpt[tcount].bpts[*count].pts[3]=Point3(bbox.pmax[0],bbox.pmin[1],bbox.pmax[2])*ctm;
  thePArrayDraw.bboxpt[tcount].bpts[*count].pts[4]=Point3(bbox.pmin[0],bbox.pmax[1],bbox.pmax[2])*ctm;
  thePArrayDraw.bboxpt[tcount].bpts[*count].pts[5]=Point3(bbox.pmin[0],bbox.pmax[1],bbox.pmin[2])*ctm;
  thePArrayDraw.bboxpt[tcount].bpts[*count].pts[6]=Point3(bbox.pmin[0],bbox.pmin[1],bbox.pmin[2])*ctm;
  thePArrayDraw.bboxpt[tcount].bpts[*count].pts[7]=Point3(bbox.pmin[0],bbox.pmin[1],bbox.pmax[2])*ctm;
  */
  (*count)++;
  if (triOb!=cobj) triOb->DeleteThis();
  }
}

void PArrayParticle::DoGroupBB(INode *node,int subtree,int *count,int *tabmax,Point3 boxcenter,TimeValue t,int tcount,INode *onode)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) DoGroupBB(nxtnode,subtree,count,tabmax,boxcenter,t,tcount,onode);
	  else if ((subtree)||(nxtnode->IsGroupMember())) GetNextBB(nxtnode,subtree,count,tabmax,boxcenter,t,tcount,onode);
	}
}
void PArrayParticle::GetallBB(INode *custnode,int subtree,TimeValue t,int fragflags)
{ int tabmax=256;
  int count=1,ocount=times.tl.Count();
  if (ocount>0) count=ocount;
  if (thePArrayDraw.bboxpt) delete[] thePArrayDraw.bboxpt;
  thePArrayDraw.bboxpt=NULL;
  INode *tmpnode,*onode;
  int cofs=(fragflags==BYGEOM?0:1);
  if ((onode=(fragflags==BYGEOM?distnode:custnode))!=NULL)
  { thePArrayDraw.bboxpt=new boxlst[count];
    int cgen;
    for (int tcount=0;tcount<count;tcount++)
    { TimeValue tofs=(ocount>0?times.tl[tcount].tl:t);
	  cgen=(times.tl.Count()>0?times.tl[tcount].gennum-1:-1);
	  if ((cgen>-1)&&(cgen<nlist.Count()))
	  { if (!(tmpnode=nlist[cgen])) tmpnode=onode;
	  } else tmpnode=onode;
	  thePArrayDraw.bboxpt[tcount].bpts.SetCount(tabmax);
      thePArrayDraw.bboxpt[tcount].numboxes=0;
      Matrix3 ctm = tmpnode->GetObjTMAfterWSM(tofs);
      boxcenter=Zero*ctm;
	  if (tmpnode->IsGroupHead())
	    DoGroupBB(tmpnode,subtree,&(thePArrayDraw.bboxpt[tcount].numboxes),&tabmax,boxcenter,tofs,tcount,tmpnode);
	  else
        GetNextBB(tmpnode,subtree,&(thePArrayDraw.bboxpt[tcount].numboxes),&tabmax,boxcenter,tofs,tcount,tmpnode);
	  thePArrayDraw.bboxpt[tcount].bpts.Shrink();
	}
  }
}
void PArrayParticle::CheckTree(INode *node,Matrix3 tspace,Mesh *cmesh,Box3 *cmbb,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl)
{ Object *pobj;	  
  TriObject *triOb;
  Point3 deftex=Point3(0.5f,0.5f,0.0f);
  TVFace Zerod;
  Zerod.t[0]=0;Zerod.t[1]=0;Zerod.t[2]=0;
  int nc,i,j,subv=0,subf=0,subtvnum=0,tface,tvert;

  if (subtree)
  { if ((nc=node->NumberOfChildren())>0)
	for (i=0;i<nc;i++)
	  CheckTree(node->GetChildNode(i),tspace,cmesh,cmbb,numV,numF,tvnum,ismapped,t,subtree,custmtl);
  }
  if ((triOb=TriIsUseable(pobj = node->EvalWorldState(t).obj,t))!=NULL)
  {	Point3 Suboffset;
    Matrix3 ctm = node->GetObjTMAfterWSM(t);
/*	if (node!=custnode)
     Suboffset=Point3(0.0f,0.0f,0.0f)*ctm-boxcenter;
	else
		Suboffset=Point3(0.0f,0.0f,0.0f);
	ctm.NoTrans();*/
	int submtls=0;
	Mtl* m=node->GetMtl();
	if (!((m!=NULL)&&(submtls=m->NumSubMtls()))) 
	  submtls=-1;
	int tottv;
	subv=triOb->GetMesh().getNumVerts();
    subf=triOb->GetMesh().getNumFaces();
    subtvnum=triOb->GetMesh().getNumTVerts();
 	(*cmbb)+=(triOb->GetMesh().getBoundingBox()*ctm);
    cmesh->setNumFaces(tface=(*numF+subf),(*numF>0?TRUE:FALSE));
    cmesh->setNumVerts(tvert=(*numV+subv),(*numV>0?TRUE:FALSE));
    cmesh->setNumTVerts(tottv=(*tvnum+subtvnum),(*tvnum>0?TRUE:FALSE));
    if ((subtvnum>0)||(*ismapped))
    { if ((!(*ismapped))&&(*numF>0))
	  { cmesh->setNumTVFaces(tface);
	    *tvnum=1;
		cmesh->setNumTVerts(tottv+1);
		cmesh->tVerts[0]=deftex;
		for (int k=0;k<*numF;k++)
		  memcpy(&(cmesh->tvFace[k]),&Zerod,sizeof(TVFace));
	   }
	  else 
	   cmesh->setNumTVFaces(tface,(*numF>0?TRUE:FALSE),*numF);
	  *ismapped=1;
	}
	if (subf>0) 
	{ memcpy(&(cmesh->faces[*numF]),triOb->GetMesh().faces,sizeof(Face)*subf);
	  if (subtvnum>0)
	    memcpy(&(cmesh->tvFace[*numF]),triOb->GetMesh().tvFace,sizeof(TVFace)*subf);
	}
	j=(*numF);
	BOOL mirror=DotProd(ctm.GetRow(0)^ctm.GetRow(1),ctm.GetRow(2))<0.0f;
	for (j=(*numF);j<tface;j++)
	{ cmesh->faces[j].v[0]+=*numV;
	  cmesh->faces[j].v[1]+=*numV;
	  cmesh->faces[j].v[2]+=*numV;
	  if (mirror) MirrorFace(&cmesh->faces[j]);
	  if (custmtl)
	  { if (submtls<0) cmesh->faces[j].setMatID(CustMtls);
	  else cmesh->faces[j].setMatID(cmesh->faces[j].getMatID()+CustMtls);
	  }
	  if (subtvnum>0)
	  { cmesh->tvFace[j].t[0]+=*tvnum;
	    cmesh->tvFace[j].t[1]+=*tvnum;
	    cmesh->tvFace[j].t[2]+=*tvnum;
		if (mirror) MirrorTVs(&cmesh->tvFace[j]);
	  }
	  else if (*ismapped)
	    memcpy(&(cmesh->tvFace[j]),&Zerod,sizeof(TVFace));
	}
	if (subtvnum>0) 
      memcpy(&(cmesh->tVerts[*tvnum]),triOb->GetMesh().tVerts,sizeof(UVVert)*subtvnum);
//	if (subv) memcpy(&(clst->v[*numV]),triOb->mesh.verts,sizeof(Point3)*subv);
	int k=0;
	ctm=ctm*tspace;
	for (j=*numV;j<tvert;j++)
	{ cmesh->verts[j]=triOb->GetMesh().verts[k]*ctm;//+Suboffset;
	  k++;
	}
	*numV+=subv;
	*numF+=subf;
	*tvnum+=subtvnum;
	if (submtls>0)
	CustMtls+=submtls;
	else CustMtls++;
  if (triOb!=pobj) triOb->DeleteThis();
  }
}

void PArrayParticle::TreeDoGroup(INode *node,Matrix3 tspace,Mesh *cmesh,Box3 *cmbb,int *numV,int *numF,int *tvnum,int *ismapped,TimeValue t,int subtree,int custmtl)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) TreeDoGroup(nxtnode,tspace,cmesh,cmbb,numV,numF,tvnum,ismapped,t,subtree,custmtl);
	  else if((subtree)||(nxtnode->IsGroupMember())) CheckTree(nxtnode,tspace,cmesh,cmbb,numV,numF,tvnum,ismapped,t,subtree,custmtl);
	}
}

void PArrayParticle::GetMesh(TimeValue t,int subtree,int custmtl,int fragflags)
{	int tnums,numV,numF,tvnum,ismapped;
    INode *tmpnode,*onode;
	tnums=times.tl.Count();
	if (tnums==0) tnums=1;
	if (cmesh) delete[] cmesh;cmesh=NULL;
	if (cmbb) delete[] cmbb;cmbb=NULL;
	onode=(fragflags==BYGEOM?distnode:custnode);
	if (onode!=NULL)
	{ cmesh=new Mesh[tnums];
	  cmbb=new Box3[tnums];
	  int cgen;
	 for (int i=0;i<tnums;i++)
	{ TimeValue tofs=(tnums>1?times.tl[i].tl:t);
	  cgen=(times.tl.Count()>0?times.tl[i].gennum-1:-1);
	  BOOL badnode=TRUE;
	  if ((cgen>-1)&&(cgen<nlist.Count())) badnode=(!(tmpnode=nlist[cgen]));
	  if (badnode)
	  {	if (fragflags==BYGEOM) continue; else tmpnode=custnode;}
	  Matrix3 ptm = tmpnode->GetObjTMAfterWSM(tofs);
	  ptm=Inverse(ptm);
	  numV=numF=tvnum=CustMtls=ismapped=0;
	  if (tmpnode->IsGroupHead())
	   TreeDoGroup(tmpnode,ptm,&cmesh[i],&cmbb[i],&numV,&numF,&tvnum,&ismapped,tofs,subtree,custmtl);
	  else
	   CheckTree(tmpnode,ptm,&cmesh[i],&cmbb[i],&numV,&numF,&tvnum,&ismapped,tofs,subtree,custmtl);
	}
	}
}
BOOL PickOperand::Filter(INode *node)
	{
	if ((node)&&(!node->IsGroupHead())) {
		ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
		if (!IsGEOM(os.obj)) {
			node = NULL;
			return FALSE;
			}
		}

	return node ? TRUE : FALSE;
	}

BOOL PickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if ((node)&&(!node->IsGroupHead())) {
		ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		if (!IsGEOM(os.obj)) {
			node = NULL;
			return FALSE;
			}
		}

	return node ? TRUE : FALSE;
	}

void PArrayParticle::ShowName(int dist)
{ TSTR name;
if (dist)
  {FormatName(name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (distnode ? distname : TSTR(GetString(IDS_AP_NONE))));
   if (hparam) SetWindowText(GetDlgItem(hparam, IDC_SP_CHUNKPICKOBJECT), name);}
 else
 {FormatName(name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (custnode ? custname : TSTR(GetString(IDS_AP_NONE))));
   if (hptype) SetWindowText(GetDlgItem(hptype, IDC_AP_INSTANCESRCNAME), name);}
}

BOOL PickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);

	INodeTab nodes;
	int subtree,flags;
	 if (dodist==1)
	  { nodes.SetCount(1);nodes[0]=node;
		theHold.Begin();
		theHold.Put(new CreatePAPartPickNode(po,po->distname,node->GetName(),1));
		if (po->distnode) po->ReplaceReference(DISTNODE,node,TRUE);
	    else po->MakeRefByID(FOREVER,DISTNODE,node);	
		theHold.Accept(GetString(IDS_AP_COMPICK));
	    po->distname = TSTR(node->GetName());
	    po->ShowName(dodist);	
	  }
	  else
	  {	if (node->IsGroupMember()) 
		  while (node->IsGroupMember()) node=node->GetParentNode();
	    po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
		flags=(node->IsGroupHead()?1:0);
		if ((!subtree)&&(!flags)) {nodes.SetCount(1);nodes[0]=node;}
	    else
		{ nodes.SetCount(0);
		  if (flags) MakeGroupNodeList(node,&nodes,subtree,ip->GetTime());
		  else MakeNodeList(node,&nodes,subtree,ip->GetTime());
		}
		if (dodist==0)
		{ theHold.Begin();
		  theHold.Put(new CreatePAPartPickNode(po,po->custname,node->GetName(),0));
	      if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	      else po->MakeRefByID(FOREVER,CUSTNODE,node);	
		  po->custname = TSTR(node->GetName());
		  theHold.Accept(GetString(IDS_AP_COMPICK));
		  po->ShowName(dodist);	
		}
	  else if (dodist==2)
	 {  theHold.Begin();
		theHold.Put(new PAObjectListRestore(po));
		po->AddToList(node,po->nlist.Count(),TRUE);
		theHold.Accept(GetString(IDS_AP_OBJADD));
	  }
	  else 
	  { theHold.Begin();
		theHold.Put(new PAObjectListRestore(po));
	    po->AddToList(node,repi,FALSE);
		theHold.Accept(GetString(IDS_AP_OBJADD));
	  }
	// Automatically check show result and do one update
		int frag,custmtl,onscreen;
		po->pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
		po->pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
		po->pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
		if (((frag==INSTGEOM)||(frag==BYGEOM))&&(onscreen>1))
		 if (onscreen==2) po->GetMesh(ip->GetTime(),subtree,custmtl,frag);
		else po->GetallBB(node,subtree,ip->GetTime(),frag);
	  }
	po->valid=FALSE;
	ip->FlashNodes(&nodes);
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	 nodes.ZeroCount();nodes.Shrink();
	if (po->creating) {
		theCreatePArrayMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreatePArrayMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void PickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut;
	if (dodist>=2)
	{ iBut=GetICustButton(GetDlgItem(po->spawn,(dodist==3?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK)));
	  TurnButton(po->spawn,(dodist==2?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK),FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEDELETE,FALSE);
	  TurnButton(po->hptype,IDC_AP_OBJECTPICK,FALSE);
	  TurnButton(po->hparam,IDC_SP_CHUNKPICKBUTTON,FALSE);
	}
    else if (dodist) 
	  {iBut=GetICustButton(GetDlgItem(po->hparam,IDC_SP_CHUNKPICKBUTTON));
	   TurnButton(po->hptype,IDC_AP_OBJECTPICK,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPESTD),FALSE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPEMET),FALSE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPECHUNKS),FALSE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPEINSTANCE),FALSE);
	  }
	else
	{ iBut=GetICustButton(GetDlgItem(po->hptype,IDC_AP_OBJECTPICK));
	  TurnButton(po->hparam,IDC_SP_CHUNKPICKBUTTON,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
	}
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
	}

void PickOperand::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut;
	if (!po->ip) return;
	if (dodist>=2)
	{ iBut=GetICustButton(GetDlgItem(po->spawn,(dodist==3?IDC_AP_OBJQUEUEREPLACE:IDC_AP_OBJECTQUEUEPICK)));
	  PACheckInstButtons(po->pblock,po->hptype);
	  TurnButton(po->hparam,IDC_SP_CHUNKPICKBUTTON,TRUE);
	  if (dodist==3)
	   TurnButton(po->spawn,IDC_AP_OBJECTQUEUEPICK,TRUE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEDELETE,FALSE);
	  TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
	}
    else if (dodist)
	{ iBut=GetICustButton(GetDlgItem(po->hparam,IDC_SP_CHUNKPICKBUTTON));
	  PACheckInstButtons(po->pblock,po->hptype);
	  PACheckSpawnButtons(po->pblock,po->spawn,repi);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPESTD),TRUE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPEMET),TRUE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPECHUNKS),TRUE);
	  EnableWindow(GetDlgItem(po->hptype,IDC_SP_TYPEINSTANCE),TRUE);
	}
	else
	{ iBut=GetICustButton(GetDlgItem(po->hptype,IDC_AP_OBJECTPICK));
	  TurnButton(po->hparam,IDC_SP_CHUNKPICKBUTTON,TRUE);
	  PACheckSpawnButtons(po->pblock,po->spawn,repi);
	}
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
}

void PACheckStretchBox(HWND hWnd,PArrayParticle *po)
{ if (IsStdMtl(po->cnode))
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),TRUE);
  } else EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
  SpinnerOn(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
  po->pmapPSpin->Invalidate();
}

void PAStretchStuff(int dir,int fragflags,HWND hWnd,PArrayParticle *po)
{ if (dir==0)
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
	SpinnerOff(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
	SpinStuff(hWnd,FALSE,fragflags!=BYGEOM);
  }
  else if (dir==1)
  {	if (IsStdMtl(po->cnode))
    { EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),TRUE);
    } else EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
	SpinnerOn(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
	SpinStuff(hWnd,FALSE,fragflags!=BYGEOM);
  }  
  else if (dir==2)
  {	EnableWindow(GetDlgItem(hWnd,IDC_AP_PBLURON),FALSE);
	SpinnerOff(hWnd,IDC_AP_STRETCHSPIN,IDC_AP_STRETCH);
	SpinStuff(hWnd,TRUE,fragflags!=BYGEOM);
  }
}

void InitParams(PArrayParticle *po,HWND hWnd)
{ int dist;
  po->pblock->GetValue(PB_DISTRIBUTION,0,dist,FOREVER);
  ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_SP_PAPOINTSEDITSPIN));
  if (dist==3) spin2->Enable();
  else spin2->Disable();
  ReleaseISpinner(spin2);
}
class ParticleDlgProc : public ParamMapUserDlgProc {
	public:
		PArrayParticle *po;
		ICustButton *iBut;

		ParticleDlgProc(PArrayParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void ParticleDlgProc::Update(TimeValue t)
{	if (!po->editOb) return;
	InitParams(po,po->hparam);
	float width;
	po->pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
	if (width<0.01f) iBut->Disable();
	po->ShowName(1);
}

BOOL ParticleDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	switch (msg) {
		case WM_INITDIALOG: {
			iBut = GetICustButton(GetDlgItem(hWnd,IDC_SP_CHUNKPICKBUTTON));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SP_PASURFACE:
			  case IDC_SP_PAEDGES:
			  case IDC_SP_PAVERTICES:
			  case IDC_SP_PAFACEC:
				{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_SP_PAPOINTSEDITSPIN));
				  spin2->Disable();
				  ReleaseISpinner(spin2);
				 break;
				}
			  case IDC_SP_PAPOINTS:
				{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,IDC_SP_PAPOINTSEDITSPIN));
				  spin2->Enable();
				  ReleaseISpinner(spin2);
				 break;
				}
			 case IDC_SP_CHUNKPICKBUTTON:
				   { if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreatePArrayMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePArrayMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;
					      po->pickCB.dodist=1;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
			  case IDC_SP_VIEWDISPMESH:
				  {po->valid=FALSE;
				   int subtree,custmtl;
					po->pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
					po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
					int anioff;
	  				po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	  po->thePArrayDraw.t=t;
	  po->thePArrayDraw.anioff=anioff;
					 TimeValue aniend=GetAnimEnd();
					  int anifr=aniend+GetTicksPerFrame();
					po->thePArrayDraw.anifr=anifr;
					po->GetTimes(po->times,t,anifr,anioff,po->fragflags);
				    po->GetMesh(t,subtree,custmtl,po->fragflags);
				   break;
				  }
			  case IDC_SP_VIEWDISPBOX:			  
				  { po->valid=FALSE;
				   int subtree,custmtl;
					po->pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
					po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
					int anioff;
	  				po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	  po->thePArrayDraw.t=t;
	  po->thePArrayDraw.anioff=anioff;
					 TimeValue aniend=GetAnimEnd();
					    int anifr;
						anifr=aniend+GetTicksPerFrame();
	  po->thePArrayDraw.anifr=anifr;
						po->GetTimes(po->times,t,anifr,anioff,po->fragflags);
					po->GetallBB(po->custnode,subtree,t,po->fragflags);
				  break;
				  }
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
	}
void SetRateSpinner(IParamBlock *pblock,TimeValue t,HWND hWnd)
{ int birthmeth;
  EnableWindow(GetDlgItem(hWnd,IDC_SP_GENUSERATE),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_GENUSETTL),TRUE);
  pblock->GetValue(PB_BIRTHMETHOD,0,birthmeth,FOREVER);
  if (birthmeth)
  { SpinnerOff(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
    SpinnerOn(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
  }else 
  { SpinnerOn(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
    SpinnerOff(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
  }
}

class ParticleGenDlgProc : public ParamMapUserDlgProc {
	public:
		PArrayParticle *po;

		ParticleGenDlgProc(PArrayParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {delete this;}
	};

BOOL ParticleGenDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{  int acourse;
       float size;
      switch (msg) 
	  {   case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_SP_GENUSERATE:
				{ SpinnerOn(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
				  SpinnerOff(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
				 return TRUE;
				}
			  case IDC_SP_GENUSETTL:
				{ SpinnerOff(hWnd,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
				  SpinnerOn(hWnd,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
				 return TRUE;
				}
			}
			case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) 
			{ case IDC_SP_GENSIZESPIN:
				   { po->pblock->GetValue(PB_METAAUTOCOARSE,t,acourse,FOREVER);
					int mpart;
				    po->pblock->GetValue(PB_PARTICLECLASS,t,mpart,FOREVER);
				    if ((mpart==METABALLS)&&(acourse) )
					 { po->pblock->GetValue(PB_SIZE,t,size,FOREVER);
					   po->pblock->SetValue(PB_METACOURSE,t,size/coursedivider);
					   po->pblock->SetValue(PB_METACOURSEV,t,size/3.0f);
					   po->pmapParam->Invalidate();
					 }
			        return TRUE;
				   }
				case IDC_AP_NEWSEED:
					{ srand( (unsigned)time( NULL ) );
					  int newseed=rand() % 25001;
					  po->pblock->SetValue(PB_RNDSEED,0,newseed);
					  po->pmapPGen->Invalidate();
					  return TRUE;
					}
				case IDC_SP_GENEMIT1SPIN:
				case IDC_SP_GENEMIT2SPIN:
					{ int sstop,sstart;
					  po->pblock->GetValue(PB_EMITSTOP,t,sstop,FOREVER);
					  po->pblock->GetValue(PB_EMITSTART,t,sstart,FOREVER);
					  if (sstop<sstart) 
					     po->pblock->SetValue(PB_EMITSTOP,t,sstart);
					  return TRUE;
					}
			}
	  }
	return FALSE;
	}
void CourseCheck(PArrayParticle *po,HWND hWnd,TimeValue t)
{ int acourse;
  float size;
  po->pblock->GetValue(PB_METAAUTOCOARSE,t,acourse,FOREVER);
  if (acourse) 
  {float mc1,mc2,mc,mcv;
	po->pblock->GetValue(PB_SIZE,t,size,FOREVER);mc=size/coursedivider;mcv=size/3.0f;
	po->pblock->GetValue(PB_METACOURSE,t,mc1,FOREVER);
	po->pblock->GetValue(PB_METACOURSEV,t,mc2,FOREVER);
	if ((mc1!=mc)||(mc2!=mcv))
	{ po->pblock->SetValue(PB_METACOURSE,t,mc);
	  po->pblock->SetValue(PB_METACOURSEV,t,mcv);
	  po->pmapPType->Invalidate();
	}
	SpinnerOff(hWnd,IDC_SP_METCOURSESPIN,IDC_SP_METCOURSE);
 	SpinnerOff(hWnd,IDC_SP_METCOURSEVSPIN,IDC_SP_METCOURSEV);
  }
  else 
  { SpinnerOn(hWnd,IDC_SP_METCOURSESPIN,IDC_SP_METCOURSE);
 	SpinnerOn(hWnd,IDC_SP_METCOURSEVSPIN,IDC_SP_METCOURSEV); }
};
void SetMapVals(PArrayParticle *po,HWND hWnd,TimeValue t)
{ int type,maptype;
  po->pblock->GetValue(PB_PARTICLETYPE,t,type,FOREVER);
  if ((po->fragflags!=BYGEOM) &&(type==RENDTET))
  { SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
 	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
  }
  else
  { po->pblock->GetValue(PB_MAPPINGTYPE,t,maptype,FOREVER);
    if (maptype)
	{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	  SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
	}
	else
	{ SpinnerOn(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
	  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
	}
 	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
	EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
  }
}

void PForm(HWND hWnd,BOOL ison,HWND hbubl,HWND hgen,IParamBlock *pblock)
{   EnableWindow(GetDlgItem(hWnd,IDC_SP_PASURFACE),ison);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_PAEDGES),ison);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_PAVERTICES),ison);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_PAPOINTS),ison);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_PAFACEC),ison);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_USESUBOBJS),ison);	
	if (!ison)
	{ SpinnerOff(hWnd,IDC_SP_GENDISPSPIN,IDC_SP_GENDISP);
 	  SpinnerOff(hgen,IDC_SP_GENEMIT2SPIN,IDC_SP_GENEMIT2);
	  SpinnerOff(hgen,IDC_SP_GENSIZESPIN,IDC_SP_GENSIZE);
	  SpinnerOff(hgen,IDC_SP_GENSIZEVARSPIN,IDC_SP_GENSIZEVAR);
	  SpinnerOff(hbubl,IDC_SP_BUBL_PERPHASPIN,IDC_SP_BUBL_PERPHA);
	  SpinnerOff(hbubl,IDC_SP_BUBL_PERPHAVARSPIN,IDC_SP_BUBL_PERPHAVAR);
	  SpinnerOff(hWnd,IDC_SP_PAPOINTSEDITSPIN,IDC_SP_PAPOINTSEDIT);
	}
	else
	{ SpinnerOn(hWnd,IDC_SP_GENDISPSPIN,IDC_SP_GENDISP);
 	  SpinnerOn(hgen,IDC_SP_GENEMIT2SPIN,IDC_SP_GENEMIT2);
	  SpinnerOn(hgen,IDC_SP_GENSIZESPIN,IDC_SP_GENSIZE);
	  SpinnerOn(hgen,IDC_SP_GENSIZEVARSPIN,IDC_SP_GENSIZEVAR);
	  SpinnerOn(hgen,IDC_SP_GENGROSPIN,IDC_SP_GENGRO);
	  SpinnerOn(hgen,IDC_SP_GENFADSPIN,IDC_SP_GENFAD);
	  SpinnerOn(hbubl,IDC_SP_BUBL_PERPHASPIN,IDC_SP_BUBL_PERPHA);
	  SpinnerOn(hbubl,IDC_SP_BUBL_PERPHAVARSPIN,IDC_SP_BUBL_PERPHAVAR);
	  int dist;
	  pblock->GetValue(PB_DISTRIBUTION,0,dist,FOREVER);
	  if (dist==3) SpinnerOn(hWnd,IDC_SP_PAPOINTSEDITSPIN,IDC_SP_PAPOINTSEDIT);
	}
}
void SpawnButtons(HWND hWnd,int repi,int stype,int chunky)
{// AllSpawnBad(hWnd,stype,chunky!=METABALLS);
  SpawnStuff(hWnd,stype);
  if (chunky>=BYGEOM)  SpawnWithStype(stype,hWnd,repi);
  else ObjectMutQueOff(hWnd);
}

void ChunkStuff(HWND hWnd,BOOL ison,HWND hgen,HWND spawn,int stype,int repi,int meth=0)
{ EnableWindow(GetDlgItem(hWnd,IDC_SP_CHUNKFACES),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_CHUNKQTY),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_CHUNKSMOOTH),ison);
  EnableWindow(GetDlgItem(hgen,IDC_SP_GENSMPLMOVE),!ison);
  EnableWindow(GetDlgItem(hgen,IDC_SP_GENSMPLTIME),!ison);
  EnableWindow(GetDlgItem(hgen,IDC_SP_GENSMPLROT),!ison);
  EnableWindow(GetDlgItem(spawn,IDC_AP_COLLIDESPAWN),!ison);
  EnableWindow(GetDlgItem(spawn,IDC_AP_DEATHSPAWN),!ison);	
  if (ison)
  {	SpinnerOn(hWnd,IDC_SP_CHUNKTHICKSPIN,IDC_SP_CHUNKTHICK);
	if (meth==1) 
	{ SpinnerOn(hWnd,IDC_SP_CHUNKQTYEDITSPIN,IDC_SP_CHUNKQTYEDIT);
	  SpinnerOff(hWnd,IDC_SP_CHUNKSMANGLESPIN,IDC_SP_CHUNKSMANGLE);
	}
	else if (meth==2) 
	{ SpinnerOff(hWnd,IDC_SP_CHUNKQTYEDITSPIN,IDC_SP_CHUNKQTYEDIT);
	  SpinnerOn(hWnd,IDC_SP_CHUNKSMANGLESPIN,IDC_SP_CHUNKSMANGLE);
	}
	else 
	{ SpinnerOff(hWnd,IDC_SP_CHUNKQTYEDITSPIN,IDC_SP_CHUNKQTYEDIT);
	  SpinnerOff(hWnd,IDC_SP_CHUNKSMANGLESPIN,IDC_SP_CHUNKSMANGLE);
	}
  }
  else
  {	SpinnerOff(hWnd,IDC_SP_CHUNKTHICKSPIN,IDC_SP_CHUNKTHICK);
	SpinnerOff(hWnd,IDC_SP_CHUNKQTYEDITSPIN,IDC_SP_CHUNKQTYEDIT);
	SpinnerOff(hWnd,IDC_SP_CHUNKSMANGLESPIN,IDC_SP_CHUNKSMANGLE);
  }
	SpinnerOff(hWnd,IDC_AP_MATIDSPIN,IDC_AP_MATID);
	SpinnerOff(hWnd,IDC_AP_EDGEMATIDSPIN,IDC_AP_EDGEMATID);
	SpinnerOff(hWnd,IDC_AP_BACKMATIDSPIN,IDC_AP_BACKMATID);
}

void MappingStuff(PArrayParticle *po,HWND hWnd,TimeValue t)
{ int maptype;
  po->pblock->GetValue(PB_CUSTOMMATERIAL,t,maptype,FOREVER);
 if (maptype)
  { SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
    SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
   }
  else SetMapVals(po,hWnd,t);
}
void GrowFade(HWND hgen,BOOL ison)
{ if (ison)
  { SpinnerOn(hgen,IDC_SP_GENGROSPIN,IDC_SP_GENGRO);
    SpinnerOn(hgen,IDC_SP_GENFADSPIN,IDC_SP_GENFAD);
  }
  else
  { SpinnerOff(hgen,IDC_SP_GENGROSPIN,IDC_SP_GENGRO);
    SpinnerOff(hgen,IDC_SP_GENFADSPIN,IDC_SP_GENFAD);
  }
}

void ChunkOn(PArrayParticle *po,HWND hWnd,BOOL ChunkIn,TimeValue t)
{ if ((po->fragflags==METABALLS)||(po->fragflags<0))
  { MetaOff(hWnd);
	SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
  }
  if (po->fragflags<=0)
  { StdStuff(hWnd,FALSE);
  }
  if ((po->fragflags==INSTGEOM)||(po->fragflags<0))
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_INSTANCESRCNAME),FALSE);
	TurnButton(hWnd,IDC_AP_OBJECTPICK,FALSE);
	TurnButton(hWnd,IDC_AP_TREEPICK,FALSE);
/*     int viewpt;
     po->pblock->GetValue(PB_VIEWPORTSHOWS,0,viewpt,FOREVER);
//	 if (viewpt==3) po->pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
	 po->pmapParam->Invalidate();*/
   InstStuff(hWnd,FALSE,po->hparam,po->spawn,TRUE);
 }
  int meth;
  po->pblock->GetValue(PB_FRAGMETHOD,0,meth,FOREVER);
/*  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_USESUBTREE),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_NOANIOFF),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_ANIOFFBIRTH),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_ANIOFFRND),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPCUSTOMINST,ison);
  EnableWindow(GetDlgItem(hparam,IDC_SP_VIEWDISPBOX),ison);
  EnableWindow(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),ison);
	if (ison)
  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);  
else
  SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);  */
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),TRUE);
  ChunkStuff(hWnd,TRUE,po->hgen,po->spawn,0,po->pickCB.repi,meth);
  int stype;
  po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
//  AllSpawnBad(po->spawn,stype,TRUE);
  int ison; po->pblock->GetValue(PB_PAIPCOLLIDE_ON,0,ison,FOREVER);
  if (ison) stype=0;
  SpawnStuff(po->spawn,stype);
  po->fragflags=BYGEOM;
  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPCUSTOMINST),stype==4);
  int maptype;
  po->pblock->GetValue(PB_CUSTOMMATERIAL,0,maptype,FOREVER);
  if ((maptype==2)&&(stype!=EMIT)) po->pblock->SetValue(PB_CUSTOMMATERIAL,0,0);
  GrowFade(po->hgen,stype==EMIT);
  PForm(po->hparam,FALSE,po->hbubl,po->hgen,po->pblock);
  EnableWindow(GetDlgItem(po->hgen,IDC_SP_GENUSERATE),FALSE);
  EnableWindow(GetDlgItem(po->hgen,IDC_SP_GENUSETTL),FALSE);
  SpinnerOff(po->hgen,IDC_SP_GENRATESPIN,IDC_SP_GENRATE);
  SpinnerOff(po->hgen,IDC_SP_GENTTLSPIN,IDC_SP_GENTTL);
  EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),FALSE);
  TurnButton(po->hptype,IDC_AP_OBJECTPICK,FALSE);
  int sptype;
  po->pblock->GetValue(PB_SPINAXISTYPE,0,sptype,FOREVER);
  if (sptype==1) po->pblock->SetValue(PB_SPINAXISTYPE,0,0);
  PAStretchStuff(sptype,BYGEOM,po->hrot,po);
  SpinMainStuff(po->hrot,TRUE);
  StdStuff(hWnd,FALSE);
  MappingStuff(po,hWnd,t);
  int cmtl;
  po->pblock->GetValue(PB_CUSTOMMATERIAL,0,cmtl,FOREVER);
  if (cmtl>0)
  { SpinnerOn(po->hptype,IDC_AP_MATIDSPIN,IDC_AP_MATID);
    SpinnerOn(po->hptype,IDC_AP_EDGEMATIDSPIN,IDC_AP_EDGEMATID);
    SpinnerOn(po->hptype,IDC_AP_BACKMATIDSPIN,IDC_AP_BACKMATID);
  }
  int showtype;
  po->pblock->GetValue(PB_PARTICLETYPE,0,showtype,FOREVER);
  if (showtype==3) po->pblock->SetValue(PB_PARTICLETYPE,0,0);
  ObjectMutQueOn(stype,po->spawn,po->pickCB.repi);
  po->pmapParam->Invalidate();
  po->pmapPSpin->Invalidate();
}

void MetaOn(PArrayParticle *po,HWND hWnd,BOOL MetaIn,TimeValue t)
{ int lastflag=po->fragflags;
  po->fragflags=METABALLS;
  SpinnerOn(hWnd,IDC_SP_METTENSSPIN,IDC_SP_METTENS);
  SpinnerOn(hWnd,IDC_SP_METTENSVARSPIN,IDC_SP_METTENSVAR);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_AUTOCOARSE),TRUE);
  CourseCheck(po,hWnd,t);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_DRAFTMODE),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_MANYBLOBS),TRUE);
  EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),FALSE);
  PAStretchStuff(0,BYGEOM,po->hrot,po);
  SpinMainStuff(po->hrot,FALSE);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
  StdStuff(hWnd,FALSE);
  MappingStuff(po,hWnd,t);
  SetRateSpinner(po->pblock,t,po->hgen);
 int stype;
	po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
 if ((lastflag==BYGEOM)||(lastflag<0))
  {		ChunkStuff(hWnd,FALSE,po->hgen,po->spawn,stype,po->pickCB.repi);
	PForm(po->hparam,TRUE,po->hbubl,po->hgen,po->pblock);
  }
  if (lastflag<=0)
  { StdStuff(hWnd,FALSE);
  }
  if ((lastflag==INSTGEOM)||(lastflag<0))
  {  InstStuff(hWnd,FALSE,po->hparam,po->spawn,TRUE);
     int maptype,viewpt;
     po->pblock->GetValue(PB_CUSTOMMATERIAL,0,maptype,FOREVER);
     if (maptype==2) po->pblock->SetValue(PB_CUSTOMMATERIAL,0,0);
     po->pblock->GetValue(PB_VIEWPORTSHOWS,0,viewpt,FOREVER);
	 if (viewpt==3) po->pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
  }
//  if (stype>1) po->pblock->SetValue(PB_SPAWNTYPE,0,0);
//  AllSpawnBad(po->spawn,0,FALSE);
  int ison; po->pblock->GetValue(PB_PAIPCOLLIDE_ON,0,ison,FOREVER);
  if (ison) stype=0;
  SpawnStuff(po->spawn,stype);
 TurnButton(hWnd,IDC_AP_OBJECTPICK,FALSE);
 EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),FALSE);
 ObjectMutQueOff(po->spawn);
 po->pmapParam->Invalidate();
 po->pmapPSpin->Invalidate();
}

void PAAniFr(HWND hWnd,IParamBlock *pblock)
{ int anitype;
  pblock->GetValue(PB_ANIMATIONOFFSET,0,anitype,FOREVER);
  if (anitype>1)
	  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
  else	SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
}

void InstOn(PArrayParticle *po,HWND hWnd,TimeValue t)
{ if ((po->fragflags==METABALLS)||(po->fragflags<0))
  { MetaOff(hWnd);
    SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
  }
	int stype;po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
  if ((po->fragflags==BYGEOM)||(po->fragflags<0))
  {	ChunkStuff(po->hptype,FALSE,po->hgen,po->spawn,stype,po->pickCB.repi);
	PForm(po->hparam,TRUE,po->hbubl,po->hgen,po->pblock);
  }
  if (po->fragflags<=0)
  { StdStuff(hWnd,FALSE);
  }
  po->fragflags=INSTGEOM;
  InstStuff(hWnd,TRUE,po->hparam,po->spawn,TRUE);
  TurnButton(po->hptype,IDC_AP_OBJECTPICK,TRUE);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),TRUE);
  PAAniFr(hWnd,po->pblock);
  int sptype;
  EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),TRUE);
  po->pblock->GetValue(PB_SPINAXISTYPE,0,sptype,FOREVER);
  PAStretchStuff(sptype,INSTGEOM,po->hrot,po);
  SpinMainStuff(po->hrot,TRUE);
  MappingStuff(po,hWnd,t);
  SetRateSpinner(po->pblock,t,po->hgen);
  ObjectMutQueOn(stype,po->spawn,po->pickCB.repi);
  po->pmapParam->Invalidate();
  po->pmapPSpin->Invalidate();
}

void StdOn(PArrayParticle *po,HWND hWnd,TimeValue t)
{ if ((po->fragflags==METABALLS)||(po->fragflags<0))
  { MetaOff(hWnd);
    SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
  }
  if ((po->fragflags==BYGEOM)||(po->fragflags<0))
  { int stype;po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
	ChunkStuff(po->hptype,FALSE,po->hgen,po->spawn,stype,po->pickCB.repi);
	PForm(po->hparam,TRUE,po->hbubl,po->hgen,po->pblock);
  }
  if ((po->fragflags==INSTGEOM)||(po->fragflags<0))
  {  InstStuff(hWnd,FALSE,po->hparam,po->spawn,TRUE);
     int maptype,viewpt;
     po->pblock->GetValue(PB_CUSTOMMATERIAL,0,maptype,FOREVER);
     if (maptype==2) po->pblock->SetValue(PB_CUSTOMMATERIAL,0,0);
     po->pblock->GetValue(PB_VIEWPORTSHOWS,0,viewpt,FOREVER);
	 if (viewpt==3) po->pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
	 po->pmapParam->Invalidate();
  }
  StdStuff(hWnd,TRUE);
  TurnButton(po->hptype,IDC_AP_OBJECTPICK,FALSE);
  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPBOX),FALSE);
  po->fragflags=0;
  EnableWindow(GetDlgItem(po->hrot,IDC_AP_PARTICLEDIRTRAVL),TRUE);
  int sptype;
  po->pblock->GetValue(PB_SPINAXISTYPE,0,sptype,FOREVER);
  PAStretchStuff(sptype,0,po->hrot,po);
  SpinMainStuff(po->hrot,TRUE);
  MappingStuff(po,hWnd,t);
  SetRateSpinner(po->pblock,t,po->hgen);
  int facing;
  po->pblock->GetValue(PB_PARTICLETYPE,t,facing,FOREVER);
  if ((facing==RENDTYPE5)||(facing==RENDTYPE6))
  { po->pblock->GetValue(PB_VIEWPORTSHOWS,t,facing,FOREVER);
	if (facing==2) po->pblock->SetValue(PB_VIEWPORTSHOWS,t,1);
   EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),FALSE);
  }
  else  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
  ObjectMutQueOff(po->spawn);
  po->pmapParam->Invalidate();
  po->pmapPSpin->Invalidate();
}

class PAParticleSpinDlgProc : public ParamMapUserDlgProc {
	public:
		PArrayParticle *po;

		PAParticleSpinDlgProc(PArrayParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void PAParticleSpinDlgProc::Update(TimeValue t)
{   int axis;
	po->pblock->GetValue(PB_SPINAXISTYPE,t,axis,FOREVER);
	PAStretchStuff(axis,po->fragflags,po->hrot,po);
	int ison; po->pblock->GetValue(PB_PAIPCOLLIDE_ON,t,ison,FOREVER);
	int stype; po->pblock->GetValue(PB_SPAWNTYPE,t,stype,FOREVER);
	IPCControls(po->hrot,po->spawn,stype,ison);
}

BOOL PAParticleSpinDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: 
		{break;
		}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_PARTICLEDIRTRAVL:
			    PAStretchStuff(1,po->fragflags,hWnd,po);
			  break;
			  case IDC_AP_PARTICLEDIRRND:
				PAStretchStuff(0,po->fragflags,hWnd,po);
			  break;
			  case IDC_AP_PARTICLEDIRUSER:
				PAStretchStuff(2,po->fragflags,hWnd,po);
				break;
			  case IDC_INTERP_BOUNCEON:
				{  int ison; po->pblock->GetValue(PB_PAIPCOLLIDE_ON,t,ison,FOREVER);
				   int stype; po->pblock->GetValue(PB_SPAWNTYPE,t,stype,FOREVER);
				   IPCControls(hWnd,po->spawn,stype,ison);
				}
				break;
			}
		default:
			return FALSE;
	}
	return TRUE;
}


class ParticleDisableDlgProc : public ParamMapUserDlgProc {
	public:
		PArrayParticle *po;
		ICustButton *iBut;

		ParticleDisableDlgProc(PArrayParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void ParticleDisableDlgProc::Update(TimeValue t)
{ if (!po->editOb) return;
	int chunky;
	int stype;
	po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
	po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
    int ison; po->pblock->GetValue(PB_PAIPCOLLIDE_ON,0,ison,FOREVER);
    if (ison) stype=0;
	SpawnButtons(po->spawn,0,stype,chunky);
	if (chunky!=po->fragflags)
	{ if (chunky==BYGEOM) ChunkOn(po,po->hptype,TRUE,t);
	  else if (chunky==METABALLS) MetaOn(po,po->hptype,TRUE,t);
	  else if (chunky==0) StdOn(po,po->hptype,t);
	  else InstOn(po,po->hptype,t);
	}
	float width;
	po->pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
	if (width<0.01f) 
	{ TurnButton(po->hptype,IDC_AP_OBJECTPICK,FALSE);}
	po->ShowName(0);
}
void AddMtl(PArrayParticle *po,TimeValue t)
{ if (po->cnode)
	{ int subtree,frag,custmtl=0,submtl=0;
    po->pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
    po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
    po->pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	if ((po->distnode)&&(custmtl==1)) 
	{ Mtl *submtl;
	  po->cnode->SetMtl(submtl=po->distnode->GetMtl());
	  if (submtl==NULL)
	     po->cnode->SetWireColor(po->distnode->GetWireColor());	
	}
	else if ((po->custnode)&&(frag==INSTGEOM)&& custmtl) 
		po->AssignMtl(po->cnode,po->custnode,subtree,t,frag);
	else if ((po->distnode)&&(frag==BYGEOM)&&(custmtl==2))
		po->AssignMtl(po->cnode,po->distnode,subtree,t,frag);
	po->valid=FALSE;
	po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	}
 }

BOOL ParticleDisableDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
      BOOL dofrag=FALSE;
	switch (msg) {
		case WM_INITDIALOG: {
			iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJECTPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			Update(t);
			break;
			}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{   case IDC_AP_OBJECTPICK:
				   { 
					if (po->ip->GetCommandMode()->ID() == CID_STDPICK)
					{ if (po->creating) 
						{  theCreatePArrayMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePArrayMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;						
					      po->pickCB.dodist=0;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
			case IDC_AP_UPDATEMTL:
				{ AddMtl(po,t);
				  int custmtl;
				  po->pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
				  if (po->cnode)
				  {
				  if (custmtl==2) 
				  { EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPCUSTOMEMIT),FALSE);
				    po->origmtl=po->cnode->GetMtl();
				  }
				  else if (custmtl==1) 
				  { EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPCUSTOMEMIT),FALSE);
				    po->origmtl=po->cnode->GetMtl();
				  }}
				  break;
				}
			  case IDC_SP_TYPECHUNKS:
				  { ChunkOn(po,hWnd,TRUE,t);
				    dofrag=TRUE;
				    goto doshows;
				  }
			  case IDC_SP_TYPEINSTANCE:
				  {	po->pblock->SetValue(PB_CUSTOMMATERIAL,0,2);
					InstOn(po,hWnd,t);
					dofrag=FALSE;
				doshows:
					int custmtl,vshow;
						po->pblock->GetValue(PB_VIEWPORTSHOWS,0,vshow,FOREVER);
					if (vshow>1)
					{int subtree,anioff;
					 po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  				 po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					 po->thePArrayDraw.t=t;
					 po->thePArrayDraw.anioff=anioff;
					 TimeValue aniend=GetAnimEnd();
					 int anifr;
					 anifr=aniend+GetTicksPerFrame();
					 po->thePArrayDraw.anifr=anifr;
					 po->GetTimes(po->times,t,anifr,anioff,po->fragflags);
					 if (vshow==2)
					 { po->pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
				       po->GetMesh(t,subtree,custmtl,po->fragflags);
					 }
					else po->GetallBB(po->custnode,subtree,t,po->fragflags);
					}
				    po->valid=FALSE;
					if ((dofrag)&&(po->ip->GetCommandMode()->ID() == CID_STDPICK))
					{ if (po->creating) 
						{  theCreatePArrayMode.JumpStart(po->ip,po);
							   po->ip->SetCommandMode(&theCreatePArrayMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					}
				  break;
				  }
			  case IDC_AP_NOANIOFF:
			  case IDC_AP_ANIOFFBIRTH:
				  	SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
				  break;
			  case IDC_AP_ANIOFFRND:
			  	  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);
				  break;
			  case IDC_SP_TYPESTD:
				{ StdOn(po,hWnd,t);
				  po->valid=FALSE;
				  if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
				  { if (po->creating) 
					{  theCreatePArrayMode.JumpStart(po->ip,po);
						po->ip->SetCommandMode(&theCreatePArrayMode);
					} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
				  }
				 break;
				}
			  case IDC_SP_TYPEFAC:
			  case IDC_SP_TYPEPIX:
				{ SetMapVals(po,hWnd,t);
				  int facing;
				  po->pblock->GetValue(PB_VIEWPORTSHOWS,t,facing,FOREVER);
				  if (facing==2) po->pblock->SetValue(PB_VIEWPORTSHOWS,t,1);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),FALSE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				  po->pmapParam->Invalidate();
				 break;
				}
			  case IDC_SP_TYPETRI:
			  case IDC_SP_TYPECUB:
			  case IDC_SP_TYPESPC:
			  case IDC_SP_TYPE6PNT:
			  case IDC_SP_TYPESPHERE:
				{ SetMapVals(po,hWnd,t);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
 				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				 break;
				}
			  case IDC_SP_TYPETET:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
 				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
				  EnableWindow(GetDlgItem(po->hparam,IDC_SP_VIEWDISPMESH),TRUE);
				 break;
				}
			  case IDC_SP_MAPTIME:
				{ SpinnerOn(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			  case IDC_SP_MAPDIST:
				{ SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOn(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				 break;
				}
			  case IDC_SP_MAPCUSTOMEMIT:
				 {SpinnerOff(hWnd,IDC_AP_MATIDSPIN,IDC_AP_MATID);	
				  SpinnerOff(hWnd,IDC_AP_EDGEMATIDSPIN,IDC_AP_EDGEMATID);	
				  SpinnerOff(hWnd,IDC_AP_BACKMATIDSPIN,IDC_AP_BACKMATID);	
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),TRUE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),TRUE);
				  SetMapVals(po,hWnd,t);
				  int dir;
				  po->pblock->GetValue(PB_SPINAXISTYPE,0,dir,FOREVER);
				  if (dir==1)  PACheckStretchBox(po->hrot,po);
				}
			  case IDC_SP_MAPCUSTOMDIST:
			  case IDC_SP_MAPCUSTOMINST:
				 {	  int chunky;
				  po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
				  if (chunky==BYGEOM)
				  { SpinnerOn(hWnd,IDC_AP_MATIDSPIN,IDC_AP_MATID);	
				    SpinnerOn(hWnd,IDC_AP_EDGEMATIDSPIN,IDC_AP_EDGEMATID);	
					SpinnerOn(hWnd,IDC_AP_BACKMATIDSPIN,IDC_AP_BACKMATID);	
				  }
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPTIME),FALSE);
				  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPDIST),FALSE);
				  SpinnerOff(hWnd,IDC_SP_MAPTIMEVALSPIN,IDC_SP_MAPTIMEVAL);
				  SpinnerOff(hWnd,IDC_SP_MAPDISTVALSPIN,IDC_SP_MAPDISTVAL);
				  int dir;
				  po->pblock->GetValue(PB_SPINAXISTYPE,0,dir,FOREVER);
				  if (dir==1)  PACheckStretchBox(po->hrot,po);
				 break;
				}
			  case IDC_SP_TYPEMET:
				  { MetaOn(po,hWnd,TRUE,t);
 				    po->valid=FALSE;
				  if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
				  { if (po->creating) 
					{  theCreatePArrayMode.JumpStart(po->ip,po);
						po->ip->SetCommandMode(&theCreatePArrayMode);
					} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
				  }
				  break;
				  }
			  case IDC_SP_CHUNKFACES:
				{  SpinnerOff(hWnd,IDC_SP_CHUNKQTYEDITSPIN,IDC_SP_CHUNKQTYEDIT);
				   SpinnerOff(hWnd,IDC_SP_CHUNKSMANGLESPIN,IDC_SP_CHUNKSMANGLE);
				 break;
				}
			  case IDC_SP_CHUNKQTY:
				{  SpinnerOn(hWnd,IDC_SP_CHUNKQTYEDITSPIN,IDC_SP_CHUNKQTYEDIT);
				   SpinnerOff(hWnd,IDC_SP_CHUNKSMANGLESPIN,IDC_SP_CHUNKSMANGLE);
				 break;
				}
			  case IDC_SP_CHUNKSMOOTH:
				{ SpinnerOff(hWnd,IDC_SP_CHUNKQTYEDITSPIN,IDC_SP_CHUNKQTYEDIT);
				  SpinnerOn(hWnd,IDC_SP_CHUNKSMANGLESPIN,IDC_SP_CHUNKSMANGLE);
				  break;
				}
			  case IDC_SP_AUTOCOARSE:
				{ int chunky;
				  po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
				  if (chunky==METABALLS)
				  {	 CourseCheck(po,hWnd,t);
				  po->valid=FALSE;}
				  break;
				}
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
	}
void PArrayParticle::GetFilename(TCHAR *filename)
{   _tcscpy(filename,ip->GetDir(APP_PLUGCFG_DIR));
  int len= _tcslen(filename);
  if (len)
  {  if (filename[len-1]!=_T('\\'))
		  _tcscat(filename,_T("\\"));
  }
  _tcscat(filename,TSTR(GetString(IDS_AP_PARRAYCST)));
}
void PArrayParticle::SetupTargetList()		
	{TCHAR filename[MAX_PATH];
     FILE *f;
	 int vers,i,future,osize;

	custsettings=0;
    GetFilename(filename);
	BOOL fileok=TRUE;
	if ((f = _tfopen(filename, _T("rb"))) == NULL) return;
	if((ReadInt(&custsettings,f))&&(ReadInt(&vers,f))&&(ReadInt(&osize,f))&&(ReadInt(&future,f)))
	{ if ((vers!=CURRENT_VERSION)&&(fileok=GenNewSaveFile(osize,size,custsettings,f,filename,CURRENT_VERSION)))
		{fileok=((ReadInt(&custsettings,f))&&(ReadInt(&vers,f))&&(ReadInt(&osize,f))&&(ReadInt(&future,f)));
		}
	if (fileok&&(vers==CURRENT_VERSION))
	{ NameLst=new AName[custsettings]; 
	  for (i=0;i<custsettings;i++)
	  if (fread(NameLst[i],NLEN,1,f)==1)
	    fseek(f,size,SEEK_CUR);
	  else goto onerr;
	}}
	onerr:if (i<custsettings) 
	{ custsettings=0;
	MessageBox (NULL,GetString(IDS_RB_BADFILE),
            "", MB_ICONINFORMATION);
	}
	if (fileok) fclose(f);
	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
	for (i=0; i<custsettings; i++) {
		SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);
		}
	}
int PArrayParticle::RemSettings(int overwrite,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  long startpt;
  int vers,newsets,future=0,baselen=size+NLEN;
  GetFilename(filename);
  vers=CURRENT_VERSION;
  newsets=custsettings-1;
  if ((f = _tfopen(filename,_T("r+b"))) == NULL)
  { MessageBox(NULL,GetString(IDS_AP_WRITEPRO),"", MB_ICONINFORMATION);
	return 0;
  }
  if (custsettings==1) 
  {fclose(f);remove(filename);custsettings=0;delete[] NameLst;NameLst=NULL;
    SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
   return (1);}
 if (!WriteInt(&newsets,f)) {fclose(f);return 0;}
  startpt=overwrite*(baselen)+HLEN;
  fseek(f,startpt,SEEK_SET); 
  int i;
  BYTE *buf;
  buf=new BYTE[baselen];
  assert(buf);
  long cpos=startpt;
  for (i=overwrite+1;i<custsettings;i++)
  {	fseek(f,cpos+baselen,SEEK_SET);
	if (fread(buf,baselen,1,f)!=1) {delete[] buf;fclose(f);return 0;}
	fseek(f,cpos,SEEK_SET);
	if (fwrite(buf,baselen,1,f)!=1) {delete[] buf;fclose(f);return 0;}
	cpos+=baselen;
  }
  delete[] buf;
  _chsize(_fileno(f),ftell(f));
  fclose(f);								  
  AName *Tmp=new AName[custsettings-1];
  int newi=0;
  for (i=0;i<custsettings;i++)
  { if (i!=overwrite) 
      _tcscpy(Tmp[newi++],NameLst[i]);}
  delete []NameLst;NameLst=Tmp;
  custsettings--;
  SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
  for (i=0; i<custsettings; i++) 
  {	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);	}
  return(1);
}
int PArrayParticle::SaveSettings(int overwrite,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  int vers,newsets,future=0;

  GetFilename(filename);
  vers=CURRENT_VERSION;
  newsets=custsettings+1;
  if ((f = _tfopen(filename,(custsettings==0?_T("wb"):_T("r+b")))) == NULL) 
  { MessageBox(NULL,GetString(IDS_AP_WRITEPRO),"", MB_ICONINFORMATION);
	return 0;
  }

  if (custsettings==0)
  { if (!(WriteInt(&newsets,f)&&WriteInt(&vers,f)&&WriteInt(&size,f)&&WriteInt(&future,f))) goto errend;
  } 
  else 
  { if (overwrite>=0) 
    { overwrite=overwrite*(size+NLEN)+HLEN;
      fseek(f,overwrite,SEEK_SET); }
    else 
	{ if (!WriteInt(&newsets,f)) goto errend;
	  fseek(f,0,SEEK_END);
	}
  }	 
  int ival,i;
  float fval;
  if (fwrite(newname,1,NLEN,f)!=NLEN) goto errend;
  for (i=0;i<PBLOCK_LENGTH_PARRAY;i++)
  {	if (spdescVer6[i].type==TYPE_INT) 
    { pblock->GetValue(i,0,ival,FOREVER);
      if (fwrite(&ival,isize,1,f)!=1) goto errend;
	}
    else
    { pblock->GetValue(i,0,fval,FOREVER);
      if (fwrite(&fval,fsize,1,f)!=1) goto errend;
	}
  }
  fclose(f);
  if (overwrite<0) 
  { AName *Tmp=new AName[custsettings+1];
    memcpy(Tmp,NameLst,sizeof(AName)*custsettings);
	delete []NameLst;NameLst=Tmp;
    _tcscpy(NameLst[custsettings],newname);
	custsettings++;
	SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),LB_RESETCONTENT,0,0);
	for (int i=0; i<custsettings; i++) {
		SendMessage(GetDlgItem(hParams2,IDC_SP_SETLIST),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)NameLst[i]);
		}
  }  
  return(1);
errend: fclose(f);return(0);
}

int PArrayParticle::GetSettings(int setnum,TCHAR *newname)
{ TCHAR filename[MAX_PATH];
  FILE *f;
  GetFilename(filename);
  if ((f = _tfopen(filename,_T("rb"))) == NULL) return 0;
  { setnum=setnum*(size+NLEN)+HLEN;
    fseek(f,setnum,SEEK_SET); 
  }	 
  int ival,i;
  float fval;
  if (fread(newname,1,NLEN,f)!=NLEN) goto errend;
  for (i=0;i<PBLOCK_LENGTH_PARRAY;i++)
  {	if (spdescVer6[i].type==TYPE_INT) 
    { if (fread(&ival,isize,1,f)!=1) goto errend;
	  pblock->SetValue(i,0,ival);
	}
    else
    { if (fread(&fval,fsize,1,f)!=1) goto errend;
//	  if (i!=PB_EMITRWID) 
		  pblock->SetValue(i,0,fval);
	}
  }
  fclose(f);
  InvalidateUI();
  return(1);
  errend: fclose(f);return(0);
}

static BOOL CALLBACK CustomSettingParamDlgProc( 
		HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{ TCHAR newname[NLEN];
  int i,save=0;
  PArrayParticle *po = (PArrayParticle*)GetWindowLong(hWnd,GWL_USERDATA);
  if (!po && message!=WM_INITDIALOG) return FALSE;

  switch (message) {
		case WM_INITDIALOG: {
			po = (PArrayParticle*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			po->custCtrlEdit = GetICustEdit(GetDlgItem(hWnd,IDC_SP_SETEDIT));
			po->custCtrlEdit->SetText(_T(""));
			po->hParams2 = hWnd;
			po->SetupTargetList();			
			break;
			}

		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDC_SP_SETLIST:  
					if (HIWORD(wParam)==LBN_DBLCLK)
					  goto doload;
					break;
				case IDC_SP_DELETE:  
					i = SendMessage(GetDlgItem(po->hParams2,IDC_SP_SETLIST),
							LB_GETCURSEL,0,0);
					   if ((i>-1)&&(po->custsettings>0))
					   { po->custCtrlEdit->GetText(newname,NLEN);
						 if (_tcscmp(newname,po->NameLst[i])==0)
						   po->custCtrlEdit->SetText(_T(""));
					     po->RemSettings(i,po->NameLst[i]);
					   }
					break;
				case IDC_SP_SAVE:  
				   save=1;
				case IDC_SP_LOAD:
					doload:
					if (!save)
					{ i = SendMessage(GetDlgItem(po->hParams2,IDC_SP_SETLIST),
							LB_GETCURSEL,0,0);
					   if ((i>-1)&&(po->custsettings>0))
					     po->custCtrlEdit->SetText(po->NameLst[i]);
					}
				    po->custCtrlEdit->GetText(newname,NLEN);
					if (save) 
					{int tstblk=0,tstlen=_tcslen(newname);
					  while ((tstblk<tstlen)&&(newname[tstblk]==' ')) tstblk++;
					  if (tstblk>=tstlen) 
						MessageBox (NULL,GetString(IDS_RB_NONAME),
            "", MB_ICONINFORMATION);
					  else 
					  { i=0;
					    while ((i<po->custsettings)&&(_tcscmp(newname,po->NameLst[i])))
					     i++;
						if (i>=po->custsettings) i=-1;
					    po->SaveSettings(i,newname);
					  }
					}
					else if ((i>-1)&&(i<po->custsettings) )
					{ po->GetSettings(i,newname);
					  InitParams(po,po->hparam);
					  po->valid=FALSE;
					  int chunky;
			          po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
					  int stype;
					  po->pblock->GetValue(PB_SPAWNTYPE,po->pickCB.repi=0,stype,FOREVER);
					  int ison; po->pblock->GetValue(PB_PAIPCOLLIDE_ON,0,ison,FOREVER);
					  if (ison) stype=0;
					  SpawnButtons(po->spawn,0,stype,chunky);
			          if (chunky==BYGEOM) ChunkOn(po,po->hptype,TRUE,po->ip->GetTime());
					  else if (chunky==METABALLS) MetaOn(po,po->hptype,TRUE,po->ip->GetTime());
				      else if (chunky==0) StdOn(po,po->hptype,po->ip->GetTime());
					  else InstOn(po,po->hptype,po->ip->GetTime());
					  if (stype==EMIT) SpinnerOff(po->spawn,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);
					int onscreen;
					po->pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
					if (((chunky==INSTGEOM)||(chunky==BYGEOM))&&(onscreen>1))
					{int custmtl;
					po->pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
					int subtree,anioff;
					TimeValue t=po->ip->GetTime();
					 po->pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  				 po->pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
					 po->thePArrayDraw.t=t;
					 po->thePArrayDraw.anioff=anioff;
					 TimeValue aniend=GetAnimEnd();
					 int anifr;
					 anifr=aniend+GetTicksPerFrame();
					 po->thePArrayDraw.anifr=anifr;
					 po->GetTimes(po->times,t,anifr,anioff,po->fragflags);
					if (onscreen==2) po->GetMesh(po->ip->GetTime(),subtree,custmtl,chunky);
					else po->GetallBB(po->custnode,subtree,po->ip->GetTime(),chunky);
					}
					  po->ip->RedrawViews(po->ip->GetTime()); 
					}
					else MessageBox (NULL,GetString(IDS_RB_BADNAME),
            "", MB_ICONINFORMATION);
				}
			break;

		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustEdit(po->custCtrlEdit);
			if (po->NameLst) {delete []po->NameLst;po->NameLst=NULL;}
			return FALSE;
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			po->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;
		
		default:
			return FALSE;
		}
	return TRUE;
	}	

class PAParticleSpawnDlgProc : public ParamMapUserDlgProc {
	public:
		PArrayParticle *po;

		ICustButton *iBut,*iButrep;
		PAParticleSpawnDlgProc(PArrayParticle *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void PAParticleSpawnDlgProc::Update(TimeValue t)
{ if (!po->editOb) return;
	int stype,rep;
	po->SetUpList();
	float width;
	po->pblock->GetValue(PB_EMITRWID,0,width,FOREVER);
	if (width<0.01f) iBut->Disable();
	po->SetUpLifeList();
	po->pickCB.repi= SendMessage(GetDlgItem(po->spawn,IDC_AP_OBJECTQUEUE),
					LB_GETCURSEL,0,0);
	if (width<0.01f) iButrep->Disable();
	else
	{ if (po->pickCB.repi<0) iButrep->Disable(); else iButrep->Enable();
	}
	rep = SendMessage(GetDlgItem(po->spawn,IDC_AP_LIFEQUEUE),LB_GETCURSEL,0,0);
	po->pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
	int chunky;
	po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
    int ison; po->pblock->GetValue(PB_PAIPCOLLIDE_ON,0,ison,FOREVER);
    if (ison) stype=0;
	SpawnButtons(po->spawn,po->pickCB.repi,stype,chunky);
	TurnButton(po->spawn,IDC_AP_OBJQUEUEREPLACE,0);
	TurnButton(po->spawn,IDC_AP_LIFEQUEUEREPL,0);
}

BOOL PAParticleSpawnDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{  int dtype=2,stype,rep;	
	switch (msg) {
		case WM_INITDIALOG: 
		{ 	iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUEPICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			iButrep = GetICustButton(GetDlgItem(hWnd,IDC_AP_OBJQUEUEREPLACE));
			iButrep->SetType(CBT_CHECK);
			iButrep->SetHighlightColor(GREEN_WASH);
			Update(t);
			break;
		}
		case WM_DESTROY:
			// Release all our Custom Controls
			ReleaseICustButton(iBut);
			ReleaseICustButton(iButrep);
			return FALSE;
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_NOSPAWN:stype=0;goto spawnradio;
			  case IDC_AP_COLLIDEDIE:
				  stype=1;goto spawnradio;
			  case IDC_AP_SPAWNTRAILS:stype=EMIT;goto spawnradio;
			  case IDC_AP_COLLIDESPAWN:
			  case IDC_AP_DEATHSPAWN: stype=2;
			spawnradio:	
				int chunky;
				po->pblock->GetValue(PB_PARTICLECLASS,0,chunky,FOREVER);
				int ison; po->pblock->GetValue(PB_PAIPCOLLIDE_ON,0,ison,FOREVER);
				if (ison) stype=0;
				SpawnButtons(hWnd,po->pickCB.repi,stype,chunky);
				 if (chunky==BYGEOM)
				 {	EnableWindow(GetDlgItem(po->hptype,IDC_SP_MAPCUSTOMINST),stype==EMIT);
				    int maptype;
					po->pblock->GetValue(PB_CUSTOMMATERIAL,0,maptype,FOREVER);
 					if ((maptype==2)&&(stype!=EMIT)) po->pblock->SetValue(PB_CUSTOMMATERIAL,0,0);
					GrowFade(po->hgen,(stype==EMIT));
				 } else GrowFade(po->hgen,TRUE);
			   break;
			  case IDC_AP_OBJECTQUEUE:
				{ po->pickCB.repi= SendMessage(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUE),
							LB_GETCURSEL,0,0);
			    TurnButton(hWnd,IDC_AP_OBJQUEUEREPLACE,po->pickCB.repi>-1);
			    TurnButton(hWnd,IDC_AP_OBJQUEUEDELETE,po->pickCB.repi>-1);
				break;
				}
			   case IDC_AP_OBJECTQUEUEPICK:
			      dtype=2;goto dopick;
				case IDC_AP_OBJQUEUEREPLACE:
				  dtype=3;
				  dopick:
				   {if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreatePArrayMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreatePArrayMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;
					      po->pickCB.dodist=dtype;
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}
				case IDC_AP_OBJQUEUEDELETE:
				{  int i = SendMessage(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUE),
							LB_GETCURSEL,0,0);
					if ((po->nlist.Count()>0)&&(i>-1))
					{	theHold.Begin();
						po->DeleteFromList(i,0);
						theHold.Accept(GetString(IDS_AP_OBJDEL));
					}
						TurnButton(hWnd,IDC_AP_OBJQUEUEREPLACE,0);
						TurnButton(hWnd,IDC_AP_OBJQUEUEDELETE,0);
					break;
				}
				case IDC_AP_LIFEQUEUEDEL:
				{  int i = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),
							LB_GETCURSEL,0,0);
					int Lcnt=po->llist.Count();
					if ((Lcnt>0)&&(i>-1)&&(i<Lcnt))
					{	theHold.Begin();
						theHold.Put(new PALifeListRestore(po));
						po->DeleteFromLifeList(i);
						TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
						theHold.Accept(GetString(IDS_AP_LIFEDEL));
					}
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					break;
				}
				case IDC_AP_LIFEQUEUEADD:
				{   int i;
					po->pblock->GetValue(PB_SPAWNLIFEVLUE,t,i,FOREVER);
					theHold.Begin();
					theHold.Put(new PALifeListRestore(po));
					po->AddToLifeList(i);
				    TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
					theHold.Accept(GetString(IDS_AP_LIFEADD));
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
					break;
				}
				case IDC_AP_LIFEQUEUE:
				{ rep = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),LB_GETCURSEL,0,0);
				  TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,rep>-1);
				  break;
				}
				case IDC_AP_LIFEQUEUEREPL:
				{ int i;
				   rep = SendMessage(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),
							LB_GETCURSEL,0,0);
				  if (rep>-1)
				  {	po->pblock->GetValue(PB_SPAWNLIFEVLUE,t,i,FOREVER);
					theHold.Begin();
					theHold.Put(new PALifeListRestore(po));
					po->llist[rep]=i;
					po->SetUpLifeList();
					TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,0);
					theHold.Accept(GetString(IDS_AP_LIFEREP));
					po->valid=FALSE;
					po->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
				  }
					break;
				}
				
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
}


//--- PArrayParticle Methods--------------------------------------------
void PArrayParticle::ResetSystem(TimeValue t,BOOL full)
{	lc.lastmin=-1;lc.lastcollide=-1;
	rcounter=0;
	vcounter=0;
	if (full)
	{ tvalid = t;
	  valid  = TRUE;
	}
}

PArrayParticle::PArrayParticle()
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
     int tpf=GetTicksPerFrame();

	MakeRefByID(FOREVER, 0, CreateParameterBlock(spdescVer6, PBLOCK_LENGTH_PARRAY, CURRENT_VERSION));
	pblock->SetValue(PB_DISTRIBUTION,0,0);
	pblock->SetValue(PB_EMITTERCOUNT,0,20);
	pblock->SetValue(PB_SPEED,0,10.0f);
	pblock->SetValue(PB_SPEEDVAR,0,0.0f);
	pblock->SetValue(PB_ANGLEDIV,0,DegToRad(10));

	pblock->SetValue(PB_PBIRTHRATE,0,10);
	pblock->SetValue(PB_PTOTALNUMBER,0,100);
	pblock->SetValue(PB_BIRTHMETHOD,0,0);
	pblock->SetValue(PB_DISPLAYPORTION,0,0.1f);
	pblock->SetValue(PB_EMITSTART,0,TimeValue(0));
	pblock->SetValue(PB_EMITSTOP,0,(TimeValue)30*FToTick);// correct constant?
	pblock->SetValue(PB_DISPUNTIL,0,100*FToTick);// correct constant?
	pblock->SetValue(PB_LIFE,0,30*FToTick);// correct constant?
	pblock->SetValue(PB_LIFEVAR,0,0);
	pblock->SetValue(PB_SUBFRAMEMOVE,0,1);
	pblock->SetValue(PB_SUBFRAMETIME,0,1);
	pblock->SetValue(PB_SUBFRAMEROT,0,0);
	pblock->SetValue(PB_SIZE,0,1.0f);
	pblock->SetValue(PB_SIZEVAR,0,0.0f);
	pblock->SetValue(PB_GROWTIME,0,10*FToTick);
	pblock->SetValue(PB_FADETIME,0,10*FToTick);
	pblock->SetValue(PB_RNDSEED,0,12345);

	pblock->SetValue(PB_PARTICLETYPE,0,0);
	pblock->SetValue(PB_METATENSION,0,1.0f);
	pblock->SetValue(PB_METATENSIONVAR,0,0.0f);
	pblock->SetValue(PB_METAAUTOCOARSE,0,1);
	pblock->SetValue(PB_METACOURSE,0,0.5f);
	pblock->SetValue(PB_METACOURSEV,0,1.0f);
	pblock->SetValue(PB_FRAGTHICKNESS,0,1.0f);
	pblock->SetValue(PB_FRAGMETHOD,0,0);
	pblock->SetValue(PB_FRAGCOUNT,0,100);
	pblock->SetValue(PB_VIEWPORTSHOWS,0,1);
	pblock->SetValue(PB_MAPPINGTYPE,0,0);
	pblock->SetValue(PB_MAPPINGTIME,0,30*FToTick);
	pblock->SetValue(PB_MAPPINGDIST,0,100.0f);
	pblock->SetValue(PB_CUSTOMMATERIAL,0,0);

	pblock->SetValue(PB_SPINTIME,0,0);
	pblock->SetValue(PB_SPINTIMEVAR,0,0.0f);
	pblock->SetValue(PB_SPINPHASE,0,0.0f);
	pblock->SetValue(PB_SPINPHASEVAR,0,0.0f);
	pblock->SetValue(PB_SPINAXISTYPE,0,0);
	pblock->SetValue(PB_SPINAXISX,0,1.0f);
	pblock->SetValue(PB_SPINAXISY,0,0.0f);
	pblock->SetValue(PB_SPINAXISZ,0,0.0f);
	pblock->SetValue(PB_SPINAXISVAR,0,0.0f);

	pblock->SetValue(PB_EMITVINFL,0,100.0f);
	pblock->SetValue(PB_EMITVMULT,0,1.0f);
	pblock->SetValue(PB_EMITVMULTVAR,0,0.0f);

	pblock->SetValue(PB_BUBLAMP,0,0.0f);
	pblock->SetValue(PB_BUBLAMPVAR,0,0.0f);
	pblock->SetValue(PB_BUBLPER,0,100000*FToTick);
	pblock->SetValue(PB_BUBLPERVAR,0,0.0f);
	pblock->SetValue(PB_BUBLPHAS,0,0.0f);
	pblock->SetValue(PB_BUBLPHASVAR,0,0.0f);

	pblock->SetValue(PB_EMITRWID,0,0.0f);
	pblock->SetValue(PB_EMITRHID,0,0);
	pblock->SetValue(PB_EMAT,0,2);
	pblock->SetValue(PB_BMAT,0,3);
	pblock->SetValue(PB_SPAWNGENS,0,1);
	pblock->SetValue(PB_SPAWNCOUNT,0,1);
	pblock->SetValue(PB_SPAWNPERCENT,0,100);
	pblock->SetValue(PB_PANOTDRAFT,0,0);
	pblock->SetValue(PB_USESELECTED,0,0);
	pblock->SetValue(PB_PASPAWNDIEAFTER,0,0);
	pblock->SetValue(PB_PASPAWNDIEAFTERVAR,0,0.0f);
	pblock->SetValue(PB_PAIPCOLLIDE_ON,0,0);
	pblock->SetValue(PB_PAIPCOLLIDE_STEPS,0,2);
	pblock->SetValue(PB_PAIPCOLLIDE_BOUNCE,0,1.0f);
	pblock->SetValue(PB_PAIPCOLLIDE_BOUNCEVAR,0,0.0f);
	sdata=NULL;
	pmesh=NULL;
	distnode=NULL;
	custnode=NULL;
	custname=TSTR(_T(" "));
	distname=TSTR(_T(" "));
	cnode=NULL;
	storefrag=NULL;
	ResetSystem(0,FALSE);
	doTVs=FALSE;
	storernd=12345;
	size=51*isize+fsize*36;
	times.tl.SetCount(0);
	cmesh=NULL;
	cmbb=NULL;
	dispmesh=NULL;
	cancelled=FALSE;
	wasmulti=FALSE;
	dispt=-99999;
	if (storefrag) delete[] storefrag;
	thePArrayDraw.bboxpt=NULL;
	llist.ZeroCount();
	nlist.ZeroCount();
	nmtls.ZeroCount();
	parts.points.ZeroCount();
	maincount=0;
	fragflags=-1;
	dflags=APRTS_ROLLUP_FLAGS;
	backpatch=TRUE;
	origmtl=NULL;
	ClearAFlag(A_NOTREND);
    stepSize=GetTicksPerFrame();
}

PArrayParticle::~PArrayParticle()
{
	if (sdata) {delete[] sdata;sdata=NULL;}
	if (pmesh) {delete[] pmesh;pmesh=NULL;}
	DeleteAllRefsFromMe();
	pblock=NULL;
	parts.FreeAll();
	times.tl.SetCount(0);
	times.tl.Shrink();
	nmtls.ZeroCount();nmtls.Shrink();
	llist.ZeroCount();llist.Shrink();
	nlist.ZeroCount();nlist.Shrink();
	if (cmesh) delete[] cmesh;
	if (cmbb) delete[] cmbb;
	if (thePArrayDraw.bboxpt) delete[] thePArrayDraw.bboxpt;
	if (dispmesh) delete dispmesh;
}
class PArrayPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		PArrayPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((PArrayParticle*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			int mc;
			if (oldVer<1) {	
				((PArrayParticle*)targ)->pblock->GetValue(PB_METACOURSE,0,mc,FOREVER);
				((PArrayParticle*)targ)->pblock->SetValue(PB_METACOURSEV,0,mc);
				}
			if (oldVer<2) {	
				((PArrayParticle*)targ)->pblock->SetValue(PB_SUBFRAMEROT,0,0);
				}
			if (oldVer<3) {	
				((PArrayParticle*)targ)->pblock->SetValue(PB_SPAWNPERCENT,0,100);
				}
			if (oldVer<4) {	
				((PArrayParticle*)targ)->pblock->SetValue(PB_PANOTDRAFT,0,0);
				((PArrayParticle*)targ)->pblock->SetValue(PB_USESELECTED,0,0);
				}
			if (oldVer<5) {	
				((PArrayParticle*)targ)->pblock->SetValue(PB_PASPAWNDIEAFTER,0,0);
				((PArrayParticle*)targ)->pblock->SetValue(PB_PASPAWNDIEAFTERVAR,0,0.0f);
				}
			if (oldVer<6)
			{ ((PArrayParticle*)targ)->pblock->SetValue(PB_PAIPCOLLIDE_ON,0,0);
			  ((PArrayParticle*)targ)->pblock->SetValue(PB_PAIPCOLLIDE_STEPS,0,2);
			  ((PArrayParticle*)targ)->pblock->SetValue(PB_PAIPCOLLIDE_BOUNCE,0,1.0f);
			  ((PArrayParticle*)targ)->pblock->SetValue(PB_PAIPCOLLIDE_BOUNCEVAR,0,0.0f);
			}
			delete this;
			}
	};

#define PARRAY_DISTNAME_CHUNK	0x0100
#define PARRAY_CUSTNAME_CHUNK	0x0200
#define PARRAY_CUSTFLAGS_CHUNK	0x0300
#define PARRAY_SPAWNC_CHUNK		0x0400
#define PARRAY_LCNT_CHUNK		0x0500
#define PARRAY_LIFE_CHUNK		0x0600

IOResult PArrayParticle::Save(ISave *isave)
	{ULONG nb;

	isave->BeginChunk(PARRAY_DISTNAME_CHUNK);		
	isave->WriteWString(distname);
	isave->EndChunk();
	isave->BeginChunk(PARRAY_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();

	int nCount=nlist.Count();
	isave->BeginChunk(PARRAY_SPAWNC_CHUNK);		
	isave->Write(&nCount,sizeof(nCount),&nb);
	isave->EndChunk();

	int Lcnt=llist.Count();
	isave->BeginChunk(PARRAY_LCNT_CHUNK);		
	isave->Write(&Lcnt,sizeof(Lcnt),&nb);
	isave->EndChunk();

	isave->BeginChunk(PARRAY_LIFE_CHUNK);
	for (int i=0;i<Lcnt;i++)
	{ isave->Write(&llist[i],sizeof(int),&nb);
	}
	isave->EndChunk();

	return IO_OK;
	}

IOResult PArrayParticle::Load(ILoad *iload)
	{
	ULONG nb;
	IOResult res = IO_OK;
	DWORD flags;
	// Default names
	distname = TSTR(_T(" "));
	int cnmtl=0;
	iload->RegisterPostLoadCallback(
			new PArrayPostLoadCallback(
				new ParamBlockPLCB(paversions,NUM_OLDVERSIONS,&curVersionPA,this,0)));
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case PARRAY_DISTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				distname = TSTR(buf);
				break;
				}
			case PARRAY_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			case PARRAY_CUSTFLAGS_CHUNK:
				res=iload->Read(&flags,sizeof(flags),&nb);
				break;
			case PARRAY_SPAWNC_CHUNK:
				{ int nCount=nlist.Count();
					res=iload->Read(&nCount,sizeof(nCount),&nb);
					nlist.SetCount(nCount);
					for (int i=0; i<nCount; i++) nlist[i] = NULL;
				}
				break;
			case PARRAY_LCNT_CHUNK:
				{	int Lcnt;
					res=iload->Read(&Lcnt,sizeof(Lcnt),&nb);
					llist.SetCount(Lcnt);
					for (int i=0; i<Lcnt; i++) llist[i] = NULL;
				}
				break;
			case PARRAY_LIFE_CHUNK:
				{	for (int i=0;i<llist.Count();i++)
					res=iload->Read(&llist[i],sizeof(int),&nb);}
				break;
		}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}

int PArrayParticle::RenderBegin(TimeValue t, ULONG flags)
	{ 	SetAFlag(A_RENDER);
  		ParticleInvalid();		
		int isinst;
		pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
		if ((isinst==INSTGEOM) &&(custnode))
			custnode->SetProperty(PROPID_FORCE_RENDER_MESH_COPY,(void *)1);
		if (distnode)
			distnode->SetProperty(PROPID_FORCE_RENDER_MESH_COPY,(void *)1);
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		cancelled=FALSE;
		return 0;
	}

int PArrayParticle::RenderEnd(TimeValue t)
	{
		ClearAFlag(A_RENDER);
		ParticleInvalid();		
		NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
		int isinst;
		pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
		if ((isinst==INSTGEOM) &&(custnode))
			custnode->SetProperty(PROPID_FORCE_RENDER_MESH_COPY,(void *)0);
		if (distnode)
			distnode->SetProperty(PROPID_FORCE_RENDER_MESH_COPY,(void *)0);
	return 0;
	}

void PArrayParticle::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{ 
	SimpleParticle::BeginEditParams(ip,flags,prev);
	editOb = this;
	this->ip = ip;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }

	if (pmapParam && pmapPGen && pmapPType && pmapPSpin && pmapEmitV && pmapBubl && pmapSpawn) 
	{	pmapParam->SetParamBlock(pblock);
		pmapPGen->SetParamBlock(pblock);
		pmapPType->SetParamBlock(pblock);
		pmapPSpin->SetParamBlock(pblock);
		pmapEmitV->SetParamBlock(pblock);
		pmapBubl->SetParamBlock(pblock);
		pmapSpawn->SetParamBlock(pblock);
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)this);
	} else 
	{ 	pmapParam = CreateCPParamMap(
			descParamPArray,PARAMPARRAY_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_PARTICLEARRAY),
			GetString(IDS_RB_PARAMETERS),
			dflags&APRTS_ROLLUP1_OPEN?0:APPENDROLL_CLOSED);

		pmapPGen = CreateCPParamMap(
			descParamPGen,PARAMPGEN_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_GEN_PA),
			GetString(IDS_RB_PGEN),
			dflags&APRTS_ROLLUP2_OPEN?0:APPENDROLL_CLOSED);
		
		pmapPType = CreateCPParamMap(
			descParamPType,PARAMPTYPE_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_PARTTYPE_PA),
			GetString(IDS_RB_PTYPE),
			dflags&APRTS_ROLLUP3_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapPSpin = CreateCPParamMap(
			descParamPSpin,PARAMPSPIN_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_ROT),
			GetString(IDS_RB_SPIN),
			dflags&APRTS_ROLLUP4_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapEmitV = CreateCPParamMap(
			descParamEmitV,PARAMEMITV_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_EMITV),
			GetString(IDS_RB_EMITV),
			dflags&APRTS_ROLLUP5_OPEN?0:APPENDROLL_CLOSED);		
	
		pmapBubl = CreateCPParamMap(
			descParamBubl,PARAMBUBL_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_BUBL),
			GetString(IDS_RB_BUBL),
			dflags&APRTS_ROLLUP6_OPEN?0:APPENDROLL_CLOSED);		
		pmapSpawn = CreateCPParamMap(
			descPSpawning,PSPAWNINGPARAMS_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_SUPRPRTS_SPAWNING),
			GetString(IDS_AP_PSPAWN),
			dflags&APRTS_ROLLUP7_OPEN?0:APPENDROLL_CLOSED);		
	
		hParams2 = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_SUPRPRTS_SAVE),
				CustomSettingParamDlgProc, 
				GetString(IDS_RB_LOADSAVE), 
				(LPARAM)this,dflags&APRTS_ROLLUP8_OPEN?0:APPENDROLL_CLOSED);	
		
		fragflags=-1;
		ip->RegisterDlgWnd(hParams2);

		}
	spawn=pmapSpawn->GetHWnd();
	hparam=pmapParam->GetHWnd();
	hgen=pmapPGen->GetHWnd();
	hptype=pmapPType->GetHWnd();
	hrot=pmapPSpin->GetHWnd();
	hbubl=pmapBubl->GetHWnd();
	if (pmapParam)
		pmapParam->SetUserDlgProc(new ParticleDlgProc(this));
	if (pmapPType) pmapPType->SetUserDlgProc(new ParticleDisableDlgProc(this));
	if (pmapPGen) pmapPGen->SetUserDlgProc(new ParticleGenDlgProc(this));
	if (pmapSpawn) pmapSpawn->SetUserDlgProc(new PAParticleSpawnDlgProc(this));
	if (pmapPSpin) pmapPSpin->SetUserDlgProc(new PAParticleSpinDlgProc(this));
}	

void PArrayParticle::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
{	SimpleParticle::EndEditParams(ip,flags,next);
	TimeValue t0,t2;
	SetFlag(dflags,APRTS_ROLLUP1_OPEN,IsRollupPanelOpen(hparam));
	SetFlag(dflags,APRTS_ROLLUP2_OPEN,IsRollupPanelOpen(hgen));
	SetFlag(dflags,APRTS_ROLLUP3_OPEN,IsRollupPanelOpen(hptype));
	SetFlag(dflags,APRTS_ROLLUP4_OPEN,IsRollupPanelOpen(hrot));
	SetFlag(dflags,APRTS_ROLLUP5_OPEN,IsRollupPanelOpen(pmapEmitV->GetHWnd()));
	SetFlag(dflags,APRTS_ROLLUP6_OPEN,IsRollupPanelOpen(hbubl));
	SetFlag(dflags,APRTS_ROLLUP7_OPEN,IsRollupPanelOpen(spawn));
	SetFlag(dflags,APRTS_ROLLUP8_OPEN,IsRollupPanelOpen(hParams2));
	editOb = NULL;

	if (flags&END_EDIT_REMOVEUI) {
		pblock->GetValue(PB_EMITSTART,0,t0,FOREVER);
		pblock->GetValue(PB_EMITSTOP,0,t2,FOREVER);
		if (t2<t0) pblock->SetValue(PB_EMITSTOP,0,t0);
		DestroyCPParamMap(pmapParam);
		DestroyCPParamMap(pmapPGen);
		DestroyCPParamMap(pmapPType);
		DestroyCPParamMap(pmapPSpin);
		DestroyCPParamMap(pmapEmitV);
		DestroyCPParamMap(pmapBubl);
		DestroyCPParamMap(pmapSpawn);

		ip->UnRegisterDlgWnd(hParams2);
		ip->DeleteRollupPage(hParams2);
		hParams2 = NULL;

		pmapParam  = NULL;
		pmapPGen = NULL;
		pmapPType = NULL;
		pmapPSpin = NULL;
		pmapEmitV = NULL;
		pmapBubl = NULL;
		pmapSpawn = NULL;
	}else
		SetWindowLong(hParams2,GWL_USERDATA,(LONG)NULL);
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
	}

void PArrayParticle::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_EMITSTART,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_EMITSTART,0,TempTime);
	pblock->GetValue(PB_EMITSTOP,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_EMITSTOP,0,TempTime);
	pblock->GetValue(PB_DISPUNTIL,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_DISPUNTIL,0,TempTime);
// scaled values
	pblock->GetValue(PB_LIFE,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_LIFE,0,TempTime);
	pblock->GetValue(PB_LIFEVAR,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_LIFEVAR,0,TempTime);
	pblock->GetValue(PB_GROWTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_GROWTIME,0,TempTime);
	pblock->GetValue(PB_FADETIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_FADETIME,0,TempTime);
	pblock->GetValue(PB_MAPPINGTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_MAPPINGTIME,0,TempTime);
	pblock->GetValue(PB_SPINTIME,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_SPINTIME,0,TempTime);
	pblock->GetValue(PB_BUBLPER,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_BUBLPER,0,TempTime);
//	pblock->GetValue(PB_OFFSETAMOUNT,0,TempTime,FOREVER);
//	TempTime=map->map(TempTime);
//	pblock->SetValue(PB_OFFSETAMOUNT,0,TempTime);
}  

Interval PArrayParticle::GetValidity(TimeValue t)
	{
	// For now...
	return Interval(t,t);
	}

TimeValue PArrayParticle::ParticleLife(TimeValue t, int i)
{   int pcount=parts.Count();
	if (!(i<pcount)) return 0.0f;
	return sdata[i].L;
}

Point3 PArrayParticle::ParticlePosition(TimeValue t,int i)
{	int pcount=parts.points.Count();
	if (!(i<pcount)) return Zero;
	Point3 FinalP=parts.points[i];
// figure out particle class
	int isinst;
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
// if we have custom geometry, find the center of the bounding box and velocity normal
	if ((isinst==INSTGEOM)&&(custnode))
	{	int anioff;
		float dlgsize;
		dlgsize=parts.radius[i];
		float zoffset=0.0f;
		Point3 OffsetV=Zero;;
		TimeValue aniend=GetAnimEnd();
		int anifr=aniend+GetTicksPerFrame();
		pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
		TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		int nCount=nlist.Count();
		int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum));
		if (mnum>=0) zoffset=cmbb[mnum].Center().z;
// if we're using DoT/MBlur, account for scaling due to stretch
		int axisentered;
		pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
		if (axisentered==DIRTRAVEL)
		{	int K;
			pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			float strlen=GetLen(parts.vels[i],K);
			zoffset*=strlen;
		}
		float lenV=Length(parts.vels[i]);
		if (lenV>EPSILON) OffsetV=parts.vels[i]/lenV;
		FinalP+=zoffset*dlgsize*OffsetV;
	}
	return FinalP;
}

Point3 PArrayParticle::ParticleVelocity(TimeValue t,int i)
{	Point3 retvel=Zero;
	int pcount=parts.vels.Count();
	if (i<pcount)
		retvel=parts.vels[i];
	else
		return retvel;
	return retvel;
}

float PArrayParticle::ParticleSize(TimeValue t,int i)
{	float strlen=1.0f;
	float boxlen=1.0f;
	float dlgsize;
	int axisentered,K,isinst,ptype;
// get the size/scale from the dialog box processed for this particle...
	int pcount=parts.radius.Count();
	if (!(i<pcount)) return 0.0f;
	dlgsize=parts.radius[i];
// figure out particle type and class
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
// if there are custom particles, find bounding box params...
	if ((isinst==INSTGEOM)&&(custnode))
	{	int anioff;
		TimeValue aniend=GetAnimEnd();
		int anifr=aniend+GetTicksPerFrame();
		pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
		TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
		int nCount=nlist.Count();
		int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum));
		if (mnum>=0) boxlen=cmbb[mnum].Width().z;
	}
// if we're using MBlur and DoT then account for scaling along DoT
	pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	if (axisentered==DIRTRAVEL)
	{	pblock->GetValue(PB_STRETCH,t,K,FOREVER);
		strlen=GetLen(parts.vels[i],K);
	}
	float templen=boxlen*strlen;
	if ((isinst!=PB_PARTICLECLASS)&&(ptype==RENDTET)) templen*=1.3f;
	return templen*dlgsize;	
}

int PArrayParticle::ParticleCenter(TimeValue t,int i)
{	int ptype,isinst;
	pblock->GetValue(PB_PARTICLECLASS,0,isinst,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	if (isinst==INSTGEOM) return PARTCENTER_CENTER;
	if (ptype==RENDTET) return PARTCENTER_HEAD;
	return PARTCENTER_CENTER;	
}

void PArrayParticle::BuildEmitter(TimeValue t, Mesh& amesh)
	{
	float width;
	mvalid = FOREVER;
	pblock->GetValue(PB_EMITRWID,t,width,mvalid);
	width  *= 0.5f;

	mesh.setNumVerts(21); //9+12
	mesh.setNumFaces(24); //12+12
	mesh.setVert(0, Point3(-width,-width, width));
	mesh.setVert(1, Point3( width,-width, width));
	mesh.setVert(2, Point3( width, width, width));
	mesh.setVert(3, Point3(-width, width, width));
	mesh.setVert(4, Point3(-width,-width, -width));
	mesh.setVert(5, Point3( width,-width, -width));
	mesh.setVert(6, Point3( width, width, -width));
	mesh.setVert(7, Point3(-width, width, -width));
	mesh.setVert(8, Point3(0,0,0));

	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[0].setSmGroup(0);
	mesh.faces[0].setVerts(0,1,3);

	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(0);
	mesh.faces[1].setVerts(1,2,3);

	mesh.faces[2].setEdgeVisFlags(1,1,0);
	mesh.faces[2].setSmGroup(0);
	mesh.faces[2].setVerts(1,0,4);

	mesh.faces[3].setEdgeVisFlags(1,0,1);
	mesh.faces[3].setSmGroup(0);
	mesh.faces[3].setVerts(5,1,4);

	mesh.faces[4].setEdgeVisFlags(0,1,1);
	mesh.faces[4].setSmGroup(0);
	mesh.faces[4].setVerts(5,2,1);

	mesh.faces[5].setEdgeVisFlags(1,1,0);
	mesh.faces[5].setSmGroup(0);
	mesh.faces[5].setVerts(5,6,2);

	mesh.faces[6].setEdgeVisFlags(1,0,1);
	mesh.faces[6].setSmGroup(0);
	mesh.faces[6].setVerts(2,6,3);

	mesh.faces[7].setEdgeVisFlags(1,1,0);
	mesh.faces[7].setSmGroup(0);
	mesh.faces[7].setVerts(6,7,3);

	mesh.faces[8].setEdgeVisFlags(1,1,0);
	mesh.faces[8].setSmGroup(0);
	mesh.faces[8].setVerts(0,3,7);

	mesh.faces[9].setEdgeVisFlags(1,0,1);
	mesh.faces[9].setSmGroup(0);
	mesh.faces[9].setVerts(4,0,7);

	mesh.faces[10].setEdgeVisFlags(0,1,1);
	mesh.faces[10].setSmGroup(0);
	mesh.faces[10].setVerts(6,4,7);

	mesh.faces[11].setEdgeVisFlags(1,1,0);
	mesh.faces[11].setSmGroup(0);
	mesh.faces[11].setVerts(6,5,4);
	float r6=0.6f*width,a=0.2f*width,a73=a*0.73f,a5=a*0.5f,a7=a*1.0f;
	int nv=9,nf=12,bnv;
	Point3 basept[3]={Point3(r6,0.0f,-r6),Point3(0.0f,0.0f,0.5f*width),Point3(-r6,0.0f,-r6)};
	for (int i=0;i<3;i++)
	{ bnv=nv;
	  mesh.setVert(nv++, Point3(0.0f,a,0.0f)+basept[i]);
	  mesh.setVert(nv++, Point3(-a73,-a5,0.0f)+basept[i]);
	  mesh.setVert(nv++, Point3(a73,-a5,0.0f)+basept[i]);
	  mesh.setVert(nv++, Point3(0.0f,0.0f,a7)+basept[i]);
	  mesh.faces[nf].setVerts(bnv,bnv+1,bnv+3);
	  mesh.faces[nf].setEdgeVisFlags(1,1,1);
	  mesh.faces[nf++].setSmGroup(0);
	  mesh.faces[nf].setVerts(bnv+1,bnv+2,bnv+3);
	  mesh.faces[nf].setEdgeVisFlags(1,1,1);
	  mesh.faces[nf++].setSmGroup(0);
	  mesh.faces[nf].setVerts(bnv+2,bnv,bnv+3);
	  mesh.faces[nf].setEdgeVisFlags(1,1,1);
	  mesh.faces[nf++].setSmGroup(0);
	  mesh.faces[nf].setVerts(bnv+2,bnv+1,bnv);
	  mesh.faces[nf].setEdgeVisFlags(1,1,1);
	  mesh.faces[nf++].setSmGroup(0);
	}
	mesh.InvalidateGeomCache();
	}

int PArrayParticle::CountLive()
{	int c=0;
	for (int i=0; i<parts.Count(); i++)
	  {if (parts.Alive(i)) c++;}
	return c;
}



// ******************************************************
int amatch(DWORD *ptr,DWORD nxt)
{ return((ptr[0]==nxt)||(ptr[1]==nxt)||(ptr[2]==nxt));
}
Point3 GetNormalizedNormal(ulong *curface,Point3 *v)
{return(Normalize((v[curface[0]]-v[curface[1]])^(v[curface[0]]-v[curface[2]])));
}

Point3 AveNormal(Point3 newnorm,Point3 oldnorm)
{ Point3 aveN;

  aveN=(newnorm+oldnorm)/2.0f;
  if (Length(aveN)==0.0f)
  { aveN=Point3(RND11(),RND11(),RND11());}
  return(Normalize(aveN));
}

void SetCore(int faces,int Groups,int *toplist,int *nextlist)
{ int i,nface;
  int newnum;

  nface=faces-1;
  for (i=0;i<Groups;i++)
  { newnum=RND0x(nface);
    while (nextlist[newnum]>-2)
     if (++newnum>=faces) newnum=0;
    toplist[i]=newnum;nextlist[newnum]=-1;
  }
}

int isnext(int faces,int *j,int *nextlist)
{ while ((*j<faces)&&(nextlist[*j]>-2)) 
   (*j)++;
  return(*j<faces);
}
BOOL checkvoverlap(int seedface,int *nextlist,DWORD *nextptr,int *matches,Face *f)
{ BOOL notfound[3];
 notfound[0]=TRUE;notfound[1]=TRUE;notfound[2]=TRUE;
 do
 {if ((notfound[0])&&(amatch(&f[seedface].v[0],nextptr[0])))
  { notfound[0]=FALSE;(*matches)++;}
  if ((notfound[1])&&(amatch(&f[seedface].v[0],nextptr[1])))
  { notfound[1]=FALSE;(*matches)++;}
  if ((notfound[2])&&(amatch(&f[seedface].v[0],nextptr[2])))
  { notfound[2]=FALSE;(*matches)++;}
 }while ((*matches<3)&&((seedface=(nextlist[seedface]))>-1));
  return(*matches>1);
};

typedef struct
{ int fnum,sides;
} EdgeFace;
typedef Tab<EdgeFace> TEdge;
typedef Tab<Edge> OTEdge;
int EdgeFound(TEdge gl,int num)
{ BOOL found=FALSE;int cnt=gl.Count(),i=0;
  while ((!found)&&(i<cnt))
    if (!(found=(gl[i].fnum==num))) i++;
	return (found?i:-1);
}
void FillInEdges(TEdge &gl,OTEdge &el,DWORD tl,int *nxtlst)
{ int e=0,num,f;
  while (e<el.Count())
  { if ((el[e].f[f=0]==tl)||(el[e].f[f=1]==tl))
	{ f=(f?0:1);
	  num=EdgeFound(gl,el[e].f[f]);
      if (num>-1) gl[num].sides++;
	  else if (nxtlst[el[e].f[f]]==-2)
	  { EdgeFace *tmp=new EdgeFace;
		tmp->fnum=el[e].f[f];tmp->sides=1;
		gl.Append(1,tmp,0);
	  }
	  el.Delete(e,1);
	}
    else e++;
  }
}

int FillInGroups(int faces,int basegroup,int *toplist,int* nextlist,Face *f,Point3 *v,OTEdge el)
{ int count,i,j,lastnum,fullcount;
  int topptr[3];
  BOOL *full;
  int Groups=basegroup;

  if (Groups>faces) Groups=faces;
  SetCore(faces,Groups,toplist,nextlist);
  full=new BOOL[faces];
  assert(full!=NULL);
  for (i=0;i<faces;i++) full[i]=FALSE;
  fullcount=0;count=Groups; 
  TEdge *glst;glst=new TEdge[Groups];
  for (int gx=0;gx<Groups;gx++) 
  { glst[gx].SetCount(0);
    FillInEdges(glst[gx],el,toplist[gx],nextlist);
	if (glst[gx].Count()==0) {full[gx]=TRUE;fullcount++;}
  }
  while ((fullcount<Groups)&&(count<faces))
  { i=0;
    while ((i<Groups)&&(count<faces))
    { if (!full[i])
	{	topptr[0]=f[toplist[i]].v[0];topptr[1]=f[toplist[i]].v[1];
	    topptr[2]=f[toplist[i]].v[2];
        j=0;
		Point3 seedcenter=(v[topptr[0]]+v[topptr[1]]+v[topptr[2]])/3.0f;
		int maxs=0;	float Mindist;int ThreeFace=-1; 
		for (int x=0;x<glst[i].Count();x++)
		{ if (nextlist[j=glst[i][x].fnum]>-2) glst[i].Delete(x,1);
		  else if (glst[i][x].sides>=maxs)
		  { float dist=Length(seedcenter-(v[f[j].v[0]]+v[f[j].v[1]]+v[f[j].v[2]])/3.0f);
			if ((glst[i][x].sides>maxs)||(Mindist>dist))
		    { ThreeFace=glst[i][x].fnum; Mindist=dist;}
		    maxs=glst[i][x].sides;
		  }
		}
		if (ThreeFace>-1)
		{ lastnum=toplist[i];while (nextlist[lastnum]>-1) lastnum=nextlist[lastnum];
		  int minj=ThreeFace;
		  nextlist[minj]=-1;nextlist[lastnum]=minj;count++;
		  FillInEdges(glst[i],el,ThreeFace,nextlist);
		  glst[i].Delete(ThreeFace,1);
		  if (glst[i].Count()==0) {full[i]=TRUE;fullcount++;}
		}
		else {full[i]=TRUE;fullcount++;}
      }
      i++;
    }
  }
  if (count<faces) 
  { i=0;
    while ((count<faces)&&(i<faces))
    { if (nextlist[i]<-1)
      {nextlist[i]=-1;toplist[Groups++]=i;count++;}
	  i++;
    }
  }
  if (full) delete[] full;
  if (glst) delete[] glst;
  return(Groups);
}

typedef struct{
  DWORD vfrom,vto,face;
  Point3 normal;
}fEdge;
typedef struct{
  DWORD vfrom,vto,fnum;
  int f0,f1;
}Edgelst;

void getext(float *min,float *max,float *p0,float *p1,float *p2)
{ int i;

  for (i=0;i<3;i++)
  { min[i]=(p0[i]<p1[i]?(p2[i]<p0[i]?p2[i]:p0[i]):(p2[i]<p1[i]?p2[i]:p1[i]));
    max[i]=(p0[i]>p1[i]?(p2[i]>p0[i]?p2[i]:p0[i]):(p2[i]>p1[i]?p2[i]:p1[i]));
  }
}
void FindGroupCenters(int Groups,int *toplist,int *nextlist,ParticleSys *parts,Face *f,Point3 *v)
{ int j;
  float mins[3],maxs[3],facemin[3],facemax[3];

  for (int i=0;i<Groups;i++)
  { j=toplist[i];
    maxs[0]=mins[0]=v[f[j].v[0]].x;
    maxs[1]=mins[1]=v[f[j].v[0]].y;
    maxs[2]=mins[2]=v[f[j].v[0]].z;
    do
    { getext(facemin,facemax,&v[f[j].v[0]].x,&v[f[j].v[1]].x,&v[f[j].v[2]].x);
      if (facemin[0]<mins[0]) mins[0]=facemin[0];
      else if (facemax[0]>maxs[0]) maxs[0]=facemax[0];
      if (facemin[1]<mins[1]) mins[1]=facemin[1];
      else if (facemax[1]>maxs[1]) maxs[1]=facemax[1];
      if (facemin[2]<mins[2]) mins[2]=facemin[2];
      else if (facemax[2]>maxs[2]) maxs[2]=facemax[2];
    } while ((j=nextlist[j])>-1);
	parts->points[i]=Point3((mins[0]+maxs[0])/2.0f,(mins[1]+maxs[1])/2.0f,(mins[2]+maxs[2])/2.0f);
 }
}

void FindAllNormals(int faces,Point3 *norm,Point3 *v,Face *f)
{ int i;
  for (i=0;i<faces;i++)
    norm[i]=GetNormalizedNormal(&f[i].v[0],v);
}

/*void GetXYZ(int num, *ptr)
{ memcpy(ptr,&(fdata[num].v[0]),3*sizeof(ushort));
}  */

BOOL CheckForMatch(Point3 *norm,int one,int two,float NAngle)
{ float inangle,newangle;

   inangle=DotProd(norm[one],norm[two]);
   newangle=(float)acos((inangle>1?1:(inangle<-1?-1:inangle)));
   return((newangle>=-NAngle)&&(newangle<=NAngle));
}

BOOL ismatch(DWORD *ptr,int *nxt,int one,int two,Point3 *norm,float NAngle)
{BOOL found;
 int matches;
  matches=0;if (amatch(ptr,nxt[0])) matches++;if (amatch(ptr,nxt[1])) matches++;
  if ((matches<2)&&(amatch(ptr,nxt[2]))) matches++;
  found=(matches>1)&&(CheckForMatch(norm,one,two,NAngle));
  return(found);
}

BOOL PtInCommon(int topnum,int curnum,int *toplist,int *nextlist,int *nextptr,int *endnum,Point3 *norm,float NAngle,Face *f,Point3 *v)
{ BOOL found,done;
  DWORD ptr[3];

  done=found=0;
  topnum=toplist[topnum];
  ptr[0]=f[topnum].v[0];ptr[1]=f[topnum].v[1];ptr[2]=f[topnum].v[2];
  while (done==FALSE)
  { found=ismatch(ptr,nextptr,topnum,curnum,norm,NAngle);
    if ((found==0)&&(nextlist[topnum]>-1)) 
	{ topnum=nextlist[topnum];
      ptr[0]=f[topnum].v[0];ptr[1]=f[topnum].v[1];ptr[2]=f[topnum].v[2];
	}
    else done=1;
  }
  if (found)
  { while (nextlist[topnum]>-1) topnum=nextlist[topnum]; }
  *endnum=topnum;
  return(found);
}

typedef struct
{ DWORD v[3];
  DWORD fnum;
}ftov;
typedef struct
{ DWORD v0,v1;
}dupedge;
void AddVertsToGroup(DWORD *vlst,int *vcount,DWORD *curface,Point3 norm,Point3 *vnorm,ftov *fnew,int *vsused)
{ BOOL found;
  int j;
  for (int i=0;i<3;i++)
  { j=0;found=FALSE;
    while ((!found)&&(j<*vcount))
	{found=(vlst[j]==curface[i]);
	  if (!found) j++;
	}
	if (!found) 
	{vlst[(*vcount)++]=curface[i]; 
	 if (vnorm) {vnorm[j]=norm;vsused[j]=1;}}
	else if (vnorm) {vnorm[j]+=norm;vsused[j]++;}
	fnew->v[i]=j;
  }
}
BOOL SharedEdge(ftov f1,int ffrom,int fto,ftov f2,DWORD v0,DWORD v1)
{ return(((f1.v[ffrom]==f2.v[v0])&&(f1.v[fto]==f2.v[v1]))||
		 ((f1.v[fto]==f2.v[v0])&&(f1.v[ffrom]==f2.v[v1])));
}

BOOL IsDup(DWORD v0a,DWORD v1a,DWORD v0b,DWORD v1b)
{ return(((v0a==v0b)&&(v1a==v1b))||((v0a==v1b)&&(v1a==v0b)));
}
int CheckForGroupEdges(int count,ftov *flst,Edgelst *edges)
{ BOOL found=FALSE;
  int innercount,ecount=0,fto=0;
  dupedge *de=new dupedge[count*3];int dc=0;
  for (int fcount=0;fcount<count;fcount++)
    for (int fedge=0;fedge<3;fedge++)
	{ found=FALSE;innercount=fcount+1;fto=(fedge<2?fedge+1:0);
	  int cdc=0;BOOL isd=FALSE;
	  while ((!found)&&(cdc<dc)) 
	  {	found=(isd=IsDup(de[cdc].v0,de[cdc].v1,flst[fcount].v[fedge],flst[fcount].v[fto]));
	    cdc++;
	  }
      while ((!found)&&(innercount<count))
	  {found=(SharedEdge(flst[fcount],fedge,fto,flst[innercount],0,1)||SharedEdge(flst[fcount],fedge,fto,flst[innercount],1,2)||
	         SharedEdge(flst[fcount],fedge,fto,flst[innercount],2,0));
	   innercount++;
	  }
	  if (!found)
	  { edges[ecount].vfrom=flst[fcount].v[fedge];
	    edges[ecount].fnum=fcount;
		edges[ecount].f0=fedge;edges[ecount].f1=fto;
	    edges[ecount++].vto=flst[fcount].v[fto];
	  } else if (!isd) {de[dc].v0=flst[fcount].v[fedge];de[dc].v1=flst[fcount].v[fto];dc++;}
    }
	if (de) delete[] de;
  return(ecount);
}

int FillInSmoothing(int faces,float NAngle,Point3* norm,int *toplist,int* nextlist,Face *f,Point3 *v)
{ int topptr[3],nextptr[3],Groups;
  int count,j,lastnum;

  Groups=count=0;
  while (count<faces)
  { j=0;
    isnext(faces,&j,nextlist);
	toplist[Groups]=j;nextlist[j]=-1;count++;j++;
	topptr[0]=f[j].v[0];topptr[1]=f[j].v[1];topptr[2]=f[j].v[2];
	BOOL newfound=TRUE;
	while (newfound==TRUE)
	{ newfound=FALSE;
    while ((count<faces)&&(isnext(faces,&j,nextlist)))
    { nextptr[0]=f[j].v[0];nextptr[1]=f[j].v[1];nextptr[2]=f[j].v[2];
      if (PtInCommon(Groups,j,toplist,nextlist,nextptr,&lastnum,norm,NAngle,f,v)>0)
       {nextlist[j]=-1;nextlist[lastnum]=j;count++;newfound=TRUE;}
      j++;
    } j=0;
	}
    Groups++;
  }
  return(Groups);
}
typedef struct
{ Matrix3 oldtm,newtm;
  Matrix3 curtm;
}Matlist;


void MakeIntoMesh(int Groups,int faces,Point3* norm,int *toplist,int *nextlist,float thickness,Mesh *mesh,Mesh *pmesh,ParticleSys *parts,SavePt *s,Point3 *lastv,Face *lastf,Matlist m,int emat,int bmat,int fmat,BOOL doTVs)
{DWORD *vlst;
 int *vsused;
 BOOL thick=(thickness>0.0f);
 Point3 *vnorm;
 int count,i,Fnum,vcount=0,ecount=0;
  Point3 *oldcenters=new Point3[faces],lastpt;
  vlst=new DWORD[3*faces];
  FindGroupCenters(Groups,toplist,nextlist,parts,lastf,lastv);
  for (i=0;i<Groups;i++)
  {	oldcenters[i]=parts->points[i]; }
  FindGroupCenters(Groups,toplist,nextlist,parts,mesh->faces,mesh->verts);
  ftov *flst;
  vnorm=(thick?new Point3[3*faces]:NULL);
  vsused=(thick?new int[3*faces]:NULL);
  flst=new ftov[faces];
  Edgelst* edges=NULL;
  for (int j=0;j<Groups;j++)
  { if (s[j].M!=0.0f)
    { lastpt=oldcenters[j];
      s[j].Ve=parts->points[j]*(m.newtm)-lastpt*(m.oldtm);
  } else s[j].Ve=Zero;
    Fnum=toplist[j]; count=0;ecount=0;vcount=0;
	do
    { AddVertsToGroup(vlst,&vcount,&(mesh->faces[Fnum].v[0]),norm[Fnum],vnorm,&flst[count],vsused);
	  flst[count].fnum=Fnum;
	  count++;
    } while ((count<faces)&&((Fnum=nextlist[Fnum])>-1));
    parts->vels[j]=norm[toplist[j]];
	if (thick) 
      parts->points[j]-=parts->vels[j]*(thickness*(1+s[j].Vsz))/2.0f;
	pmesh[j].setNumVerts(thick?vcount*2:vcount);
	for (i=0;i<vcount;i++)
	{ pmesh[j].verts[i]=(mesh->verts[vlst[i]]-parts->points[j])*(m.curtm);
	  if (thick)
	  {Point3 aveN=vnorm[i]/(float)vsused[i];
	   if (Length(aveN)==0.0f)
		{ aveN=Point3(RND11(),RND11(),RND11());}
        pmesh[j].verts[i+vcount]=pmesh[j].verts[i]-thickness*aveN*(m.curtm);
	  }
	}
	int fc=2*count;
	if (thick)
	{ edges=(thick?new Edgelst[3*count]:NULL);
	  ecount=CheckForGroupEdges(count,flst,edges);
	  pmesh[j].setNumFaces(2*(count+ecount));
	  if (doTVs)
	   pmesh[j].setNumTVFaces(pmesh[j].numFaces);
	  else pmesh[j].setNumTVFaces(0);
	  for (i=0;i<count;i++)
	  { int icount=i+count;
		pmesh[j].faces[i]=mesh->faces[flst[i].fnum];
		if (fmat>0) pmesh[j].faces[i].setMatID(fmat-1);
		pmesh[j].faces[i].setVerts(flst[i].v[0],flst[i].v[1],flst[i].v[2]);
		pmesh[j].faces[icount]=pmesh[j].faces[i];
		pmesh[j].faces[icount].setVerts(flst[i].v[0]+vcount,flst[i].v[2]+vcount,flst[i].v[1]+vcount);
		if (bmat>0) pmesh[j].faces[icount].setMatID(bmat-1);
		else pmesh[j].faces[icount].setMatID(pmesh[j].faces[i].getMatID());
		if (doTVs)
		{ pmesh[j].tvFace[icount]=(pmesh[j].tvFace[i]=mesh->tvFace[flst[i].fnum]);
		}
	  }	
	  for (i=0;i<ecount;i++)
	  {	MtlID ematerial;
		pmesh[j].faces[fc+1]=(pmesh[j].faces[fc]=pmesh[j].faces[edges[i].fnum+count]);
	    pmesh[j].faces[fc].setVerts(edges[i].vfrom,edges[i].vfrom+vcount,edges[i].vto+vcount);
		pmesh[j].faces[fc].setSmGroup(0);
	    pmesh[j].faces[fc+1].setVerts(edges[i].vfrom,edges[i].vto+vcount,edges[i].vto);
		pmesh[j].faces[fc+1].setEdgeVisFlags(0,1,1);
		pmesh[j].faces[fc+1].setSmGroup(0);
		if (emat>0)	ematerial=emat-1; else ematerial=pmesh[j].faces[fc].getMatID();
		pmesh[j].faces[fc].setMatID(ematerial);
		pmesh[j].faces[fc+1].setMatID(ematerial);
		if (doTVs)
		{ DWORD tv0=pmesh[j].tvFace[edges[i].fnum].t[edges[i].f0],tv1=pmesh[j].tvFace[edges[i].fnum].t[edges[i].f1];
		 pmesh[j].tvFace[fc].setTVerts(tv0,tv0,tv1);
		 pmesh[j].tvFace[fc+1].setTVerts(tv0,tv1,tv1);
		}
		fc+=2;
	  }
	}
	else
	{ pmesh[j].setNumFaces(count);
	  if (doTVs)
	   pmesh[j].setNumTVFaces(pmesh[j].numFaces);
	  else pmesh[j].setNumTVFaces(0);
	  for (i=0;i<count;i++)
	  { pmesh[j].faces[i]=mesh->faces[flst[i].fnum];
	    if (fmat>0) pmesh[j].faces[i].setMatID(fmat-1);
		pmesh[j].faces[i].setVerts(flst[i].v[0],flst[i].v[1],flst[i].v[2]);
		if (doTVs)
		 pmesh[j].tvFace[i]=(pmesh[j].tvFace[i]=mesh->tvFace[flst[i].fnum]);
	  }
	}
    if (edges) delete[] edges;
  }
  if (flst) delete[] flst;
  if (vlst) delete[] vlst;
  if (vnorm) delete[] vnorm;
  if (vsused) delete[] vsused;
  if (oldcenters) delete[] oldcenters;
}

void SelectEmitterPer(int emitters,int pcount,int *lst)
{ int i,j,rounds,counter=0,emits=emitters-1;

  rounds=(int)floor((float)pcount/emitters);
  for (j=0;j<emitters;j++)
  {   counter+=(lst[j]=rounds);
  }
  for (i=counter;i<pcount;i++)
    { j=RND0x(emits);
      lst[j]++;
    }
}

void SpreadOutParts(float *arealst,float TotalArea,int maxfaces,int block,int total,int *lst)
{int i,newcount;

  newcount=0;
  for (i=0;i<block;i++)
  {	newcount+=(lst[i]=(int)floor(total*(arealst[i]/TotalArea)));
  }
  for (i=newcount;i<total;i++)
   lst[RND0x(maxfaces)]+=1;
}

float GetFaceArea(DWORD *curface,Point3 *v)
{ Point3 V1,V2;

  V1=v[curface[1]]-v[curface[0]];
  V2=v[curface[2]]-v[curface[0]];
/* Point3 D,N;
  float h,b;
  N=V1^V2;
	D=Normalize(N^V1);
  h=(float)fabs(DotProd(D,v[curface[2]])-DotProd(D,v[curface[0]]));
  b=Length(V1);
  return(0.5f*b*h);	 */
  return(Length(V1^V2)*0.5f);
}

void FillByFixedPts(int infaces,int emits,int c,int vertices,int lastrnd,Mesh *mesh,ParticleSys *parts,SavePt *s,Point3 *lastv,Face *lastf,Matlist m,BOOL doTVs,int mf,BOOL doall)
{ int i,*elst,*plst,ecount=0;
  float *arealst,TotalArea,*rndx,*rndy;
  Point3 Norm;

  arealst=new float[infaces];
  elst=new int[infaces];
  plst=new int[emits];
  rndx=new float[emits];
  rndy=new float[emits];
  assert(arealst && elst && plst);
  TotalArea=0.0f;int selface=0;
  for (i=0;i<infaces;i++)
  { if (doall || (mesh->faceSel[i])) 
	{ TotalArea+=(arealst[selface]=GetFaceArea(&mesh->faces[i].v[0],mesh->verts));
      selface++;
	}
  }
  //sort fixed emitters
  SpreadOutParts(arealst,TotalArea,selface-1,selface,emits,elst);
  for (i=0;i<emits;i++)
  { rndx[i]=RND01();rndy[i]=RND01();}
  //set parts to emitters
  srand(lastrnd);
  SelectEmitterPer(emits,c,plst);
  Point3 V0,V1,V2,V01,V02,lastpt,lV0,lV01,lV02;
  float rx,ry;int count=0;
  for (i=0;i<infaces;i++)
    if (doall || (mesh->faceSel[i])) 
  { V01=(V1=mesh->verts[mesh->faces[i].v[1]])-(V0=mesh->verts[mesh->faces[i].v[0]]);
    V02=(V2=mesh->verts[mesh->faces[i].v[2]])-V0;
	int li=(i>mf?mf:i);
	lV01=(lastv[lastf[li].v[1]])-(lV0=lastv[lastf[li].v[0]]);
    lV02=(lastv[lastf[li].v[2]])-lV0;
    Norm=GetNormalizedNormal(&mesh->faces[i].v[0],mesh->verts);
    for (int j=0;j<elst[count];j++)
    { if (plst[ecount]>0)
	  { parts->vels[vertices]=Norm;
        rx=rndx[ecount];ry=rndy[ecount];
        if (rx+ry>1) {rx=1-rx;ry=1-ry;}
	    parts->points[vertices]=V0+V01*rx+V02*ry;
		if (s[vertices].M!=0.0f)
		{ lastpt=lV0+lV01*rx+lV02*ry;
		  s[vertices].Ve=parts->points[vertices]*(m.newtm)-lastpt*(m.oldtm);
		} else s[vertices].Ve=Zero;
	    if (doTVs)
	    { Point3 tv0=mesh->tVerts[mesh->tvFace[i].t[0]];
	      Point3 tv1=mesh->tVerts[mesh->tvFace[i].t[1]];
	      Point3 tv2=mesh->tVerts[mesh->tvFace[i].t[2]];
	      s[vertices].tv=Point3((1-ry)*(rx*tv1.x+tv0.x-rx*tv0.x)+ry*tv2.x,(1-ry)*(rx*tv1.y+tv0.y-rx*tv0.y)+ry*tv2.y,0.0f);
		  s[vertices].pmtl=mesh->faces[i].getMatID();
	    }
	    int localv=vertices+1;
		for (int k=1;k<plst[ecount];k++)
		{ parts->points[localv]=parts->points[vertices];
		  parts->vels[localv]=parts->vels[vertices];
		  s[localv].Ve=s[vertices].Ve;
		  if (doTVs) 
		  { s[localv].tv=s[vertices].tv;
			s[localv].pmtl=s[vertices].pmtl;
		  }
		  localv++;
		}
	    vertices=localv;
	  }
	  ecount++;
	}
	count++;
  }
  delete[] arealst;
  delete[] plst;
  delete[] elst;
  delete[] rndx;
  delete[] rndy;
  lastrnd=rand();
} 

void FillInUniform(int infaces,int c,int vertices,Mesh *mesh,ParticleSys *parts,SavePt *s,Point3 *lastv,Face *lastf,Matlist m,BOOL doTVs,int mf,BOOL doall)
{ int i,*lst;
  float *arealst,TotalArea,rx,ry;
  Point3 Norm;

  arealst=new float[infaces];
  lst=new int[infaces];
  assert(arealst && lst);
  TotalArea=0.0f;int fsel=0;
  for (i=0;i<infaces;i++)
  { if (doall || (mesh->faceSel[i])) 
	{ TotalArea+=(arealst[fsel]=GetFaceArea(&mesh->faces[i].v[0],mesh->verts));
	  fsel++;
	}
  }
  SpreadOutParts(arealst,TotalArea,fsel-1,fsel,c,lst);
  Point3 V0,V1,V2,V01,V02,lastpt,lV0,lV01,lV02;
  int count=0;
  for (i=0;i<infaces;i++)
    if (doall || mesh->faceSel[i])
	{ if (lst[count]>0)
		{ V01=(V1=mesh->verts[mesh->faces[i].v[1]])-(V0=mesh->verts[mesh->faces[i].v[0]]);
	  V02=(V2=mesh->verts[mesh->faces[i].v[2]])-V0;
	  int li=(i>mf?mf:i);
	  lV01=(lastv[lastf[li].v[1]])-(lV0=lastv[lastf[li].v[0]]);
      lV02=(lastv[lastf[li].v[2]])-lV0;
      Norm=GetNormalizedNormal(&mesh->faces[i].v[0],mesh->verts);
      for (int j=0;j<lst[count];j++)
	  { parts->vels[vertices]=Norm;
        rx=RND01();ry=RND01();
        if (rx+ry>1) {rx=1-rx;ry=1-ry;}
	    parts->points[vertices]=V0+V01*rx+V02*ry;
	    if (s[vertices].M!=0.0f)
		{ lastpt=lV0+lV01*rx+lV02*ry;
	      s[vertices].Ve=parts->points[vertices]*(m.newtm)-lastpt*(m.oldtm);
		} else s[vertices].Ve=Zero;
	    s[vertices].pmtl=mesh->faces[i].getMatID();
	    if (doTVs)
		{ Point3 tv0=mesh->tVerts[mesh->tvFace[i].t[0]];
		  Point3 tv1=mesh->tVerts[mesh->tvFace[i].t[1]];
		  Point3 tv2=mesh->tVerts[mesh->tvFace[i].t[2]];
	      s[vertices].tv=Point3((1-ry)*(rx*tv1.x+tv0.x-rx*tv0.x)+ry*tv2.x,(1-ry)*(rx*tv1.y+tv0.y-rx*tv0.y)+ry*tv2.y,0.0f);
		}
	    vertices++;
	  }
	}
	count++;
	}
  delete[] arealst;
  delete[] lst;
}

float Checkfordup(DWORD *curface,int P0,int P1,float *arealst,fEdge *edgelst,int *edges,int face,Point3 *vlst,Face *f)
{ int i,found;
  float area;
  Point3 norm;

  found=i=0;area=0.0f;
  while ((!found)&&(i<*edges))
   { found=((edgelst[i].vto==curface[P0])&&(edgelst[i].vfrom==curface[P1]))||
            ((edgelst[i].vfrom==curface[P0])&&(edgelst[i].vto==curface[P1]));
     if (!found) i++;
   }
   if (found)
   { norm=GetNormalizedNormal(curface,vlst);
     edgelst[i].normal=AveNormal(norm,edgelst[i].normal);
     if (f[face].getMatID()!=f[edgelst[i].face].getMatID())
     { if (GetFaceArea(curface,vlst)>GetFaceArea(&f[edgelst[i].face].v[0],vlst))
         edgelst[i].face=face;
     }
   }
   else
   {area=(arealst[i]=Length(vlst[curface[P0]]-vlst[curface[P1]]));
    edgelst[i].vfrom=curface[P0];edgelst[i].vto=curface[P1];
    edgelst[i].normal=GetNormalizedNormal(curface,vlst);
    edgelst[i].face=face;
    (*edges)++;
   }
 return(area);
}

float GetEdgeArea(Mesh *mesh,float *arealst,fEdge *edgelst,int *edges,int face,BOOL byedge)
{ float area;
  DWORD *curface=&(mesh->faces[face]).v[0],flags=mesh->faces[face].flags;
  area=0.0f;int fnum=face*3;
  if ( ((flags & EDGE_A)>0)&&((!byedge)||(mesh->edgeSel[fnum])))
    area+=Checkfordup(curface,0,1,arealst,edgelst,edges,face,mesh->verts,mesh->faces);
  if ( ((flags & EDGE_B)>0)&&((!byedge)||(mesh->edgeSel[fnum+1])))
    area+=Checkfordup(curface,1,2,arealst,edgelst,edges,face,mesh->verts,mesh->faces);
  if ( ((flags & EDGE_C)>0)&&((!byedge)||(mesh->edgeSel[fnum+2])))
    area+=Checkfordup(curface,2,0,arealst,edgelst,edges,face,mesh->verts,mesh->faces);
  return(area);
}

void FillByEdges(int infaces,int c,int vertices,Mesh *mesh,ParticleSys *parts,SavePt *s,Point3 *lastv,Matlist m,BOOL doTVs,int mv,BOOL doall)
{ int i,edges,numedges=3*infaces,*lst;
  float *arealst,TotalArea,r;
  fEdge *edgelst;
  Point3 lastpt;

  edges=0;
  assert((arealst=new float[numedges])!=NULL);
  assert((edgelst=new fEdge[numedges])!=NULL);
  lst=new int[numedges];assert(lst);
  TotalArea=0.0f;int fsel=0;
  BOOL byedge=(!doall)&&(mesh->edgeSel.NumberSet()>0);
  for (i=0;i<infaces;i++)
  {	if (doall || ((byedge)||(mesh->faceSel[i])) )
	{ TotalArea+=GetEdgeArea(mesh,arealst,edgelst,&edges,i,byedge);
	  fsel++;
	}
  }
  SpreadOutParts(arealst,TotalArea,edges-1,edges,c,lst);
  for (i=0;i<edges;i++)
  if (lst[i]>0)
  { Point3 pt=mesh->verts[edgelst[i].vfrom],pdist=mesh->verts[edgelst[i].vto]-pt;
  Point3 lpt=lastv[(edgelst[i].vfrom>(DWORD)mv?mv:edgelst[i].vfrom)],lpdist=lastv[(edgelst[i].vto>(DWORD)mv?mv:edgelst[i].vto)]-lpt;
	for (int j=0;j<lst[i];j++)
	{ r=RND01();
      parts->points[vertices]=pt+pdist*r;
	  if (s[vertices].M!=0.0f)
	  { lastpt=lpt+lpdist*r;
	    s[vertices].Ve=parts->points[vertices]*(m.newtm)-lastpt*(m.oldtm);
	  } else s[vertices].Ve=Zero;
      parts->vels[vertices]=edgelst[i].normal;
	if (doTVs) 
	{ DWORD *vlst;vlst=&mesh->faces[edgelst[i].face].v[0];
	  int st0=(vlst[0]==edgelst[i].vfrom?0:(vlst[1]==edgelst[i].vfrom?1:2));
	  int st1=(vlst[0]==edgelst[i].vto?0:(vlst[1]==edgelst[i].vto?1:2));
	  Point3 tv0=mesh->tVerts[mesh->tvFace[edgelst[i].face].t[st0]];
	  Point3 tv1=mesh->tVerts[mesh->tvFace[edgelst[i].face].t[st1]];
	  s[vertices].tv=Point3(tv0.x+(tv1.x-tv0.x)*r,tv0.y+(tv1.y-tv0.y)*r,0.0f);
	}
	  s[vertices].pmtl=mesh->faces[edgelst[i].face].getMatID();
      vertices++;
    }
  }
  delete[] arealst;
  delete[] edgelst;
}

BOOL VertexinWhichFace(int v,Face *flst,int infaces,int *aface)
{ BOOL found;

  found=0;
  while ((*aface<infaces)&&(!found))
  { found=amatch(flst[*aface].v,v);
    if (!found) (*aface)++;
  }
  return(found);
}

void FillInFaces(int faces,int vertices,Mesh *mesh,int c,ParticleSys *parts,SavePt *s,Point3 *lastv,Face *lastf,Matlist m,BOOL doTVs,int mf,BOOL doall)
{ int i,j,*lst,localf;
  Point3 lastpt;int fsel=0;
  fsel=(doall?faces:mesh->faceSel.NumberSet());
  lst=new int[fsel];
  SelectEmitterPer(fsel,c,lst);
  int count=0;
  for (i=0;i<faces;i++)
  { int li=(i>mf?mf:i);
    if (doall ||(mesh->faceSel[i]))
	{ if (lst[count]>0)
	  { parts->points[vertices]=(mesh->verts[mesh->faces[i].v[0]]+mesh->verts[mesh->faces[i].v[1]]+mesh->verts[mesh->faces[i].v[2]])/3.0f;
		parts->vels[vertices]=GetNormalizedNormal(&mesh->faces[i].v[0],mesh->verts);
		if (s[vertices].M!=0.0f)
		{ lastpt=(lastv[lastf[li].v[0]]+lastv[lastf[li].v[1]]+lastv[lastf[li].v[2]])/3.0f;
		  s[vertices].Ve=parts->points[vertices]*(m.newtm)-lastpt*(m.oldtm);
		} else s[vertices].Ve=Zero;
		if (doTVs)
		{ s[vertices].tv=(mesh->tVerts[mesh->tvFace[i].t[0]]+mesh->tVerts[mesh->tvFace[i].t[1]]+mesh->tVerts[mesh->tvFace[i].t[2]])/3.0f;
		}
		s[vertices].pmtl=mesh->faces[i].getMatID();
		localf=vertices+1;
		for (j=1;j<lst[count];j++)
		{ parts->points[localf]=parts->points[vertices];
		  parts->vels[localf]=parts->vels[vertices];
		  s[localf].Ve=s[vertices].Ve;
		  if (doTVs) 
		  { s[localf].tv=s[vertices].tv;
		  }
		  s[localf].pmtl=s[vertices].pmtl;
		  localf++;
		}
		vertices=localf;
		}
	  count++;
	}
  }
  delete[] lst;
}

void FillInVertex(int inverts,int infaces,int vertices,Mesh *mesh,int c,ParticleSys *parts,SavePt *s,Point3 *lastv,Matlist m,BOOL doTVs,int mv,BOOL doall)
{ int i,j,face,ncounter,firstface,*lst,localv;
  Point3 newNorm,zero=Point3(0.0f,0.0f,0.0f),lastpt;

  int vsel=0;
  vsel=(doall?inverts:mesh->vertSel.NumberSet());
  lst=new int[vsel];
  SelectEmitterPer(vsel,c,lst);
  int count=0;
  for (i=0;i<inverts;i++)
   if (doall ||mesh->vertSel[i])
   { if (lst[count]>0)
	{ parts->points[vertices]=mesh->verts[i];
	  if (s[vertices].M!=0.0f)
	  { lastpt=lastv[(i>mv?mv:i)];
	    s[vertices].Ve=parts->points[vertices]*(m.newtm)-lastpt*(m.oldtm);
	  }else s[vertices].Ve=Zero;
      face=firstface=ncounter=0;
	  newNorm=zero;
      while (VertexinWhichFace(i,mesh->faces,infaces,&face))
	  { newNorm+=GetNormalizedNormal(&mesh->faces[face].v[0],mesh->verts);
	    if (ncounter==0) firstface=face;
	    ncounter++;face++;
	  }
	// texture comes from first vertex of face
	  if (doTVs) 
	  { s[vertices].tv=mesh->tVerts[mesh->tvFace[firstface].t[0]];
	  }
	  s[vertices].pmtl=mesh->faces[firstface].getMatID();
	  parts->vels[vertices]=Normalize(ncounter>0?newNorm/(float)ncounter:Point3(RND11(),RND11(),RND11()));
	  localv=vertices+1;
	  for (j=1;j<lst[count];j++)
	  { parts->points[localv]=mesh->verts[i];
	    parts->vels[localv]=parts->vels[vertices];
	    s[localv].Ve=s[vertices].Ve;
	    if (doTVs) 
		{ s[localv].tv=s[vertices].tv;
		}
	    s[localv].pmtl=s[vertices].pmtl;
	    localv++;
	  }
	  vertices=localv;
	}
	count++;
  }
  delete[] lst;
}

void BlowUpFaces(int faces,Mesh *mesh,Mesh *pmesh,ParticleSys *parts,float thickness,SavePt *s,Matlist m,Point3 *lastv,Face *lastf,int emat,int bmat,int fmat,BOOL doTVs)
{ int i,j;
  Point3 lastpt;

  BOOL thick=(thickness>0.0f);
  for (i=0;i<faces;i++)
  { parts->points[i]=(mesh->verts[mesh->faces[i].v[0]]+mesh->verts[mesh->faces[i].v[1]]+mesh->verts[mesh->faces[i].v[2]])/3.0f;
	if (s[i].M!=0.0f)
	{ lastpt=(lastv[lastf[i].v[0]]+lastv[lastf[i].v[1]]+lastv[lastf[i].v[2]])/3.0f;
	  s[i].Ve=parts->points[i]*(m.newtm)-lastpt*(m.oldtm);
	}else s[i].Ve=Zero;
    parts->vels[i]=GetNormalizedNormal(&mesh->faces[i].v[0],mesh->verts);
    if (thick) 
      parts->points[i]-=parts->vels[i]*(thickness*(1+s[i].Vsz))/2.0f;
	pmesh[i].setNumVerts(thick?6:3);
	pmesh[i].setNumFaces(thick?8:1);
	pmesh[i].faces[0]=mesh->faces[i];
	pmesh[i].faces[0].setVerts(0,1,2);
	if (fmat>0) pmesh[i].faces[0].setMatID(fmat-1);
	pmesh[i].verts[0]=(mesh->verts[mesh->faces[i].v[0]]-parts->points[i])*(m.curtm);
	pmesh[i].verts[1]=(mesh->verts[mesh->faces[i].v[1]]-parts->points[i])*(m.curtm);
	pmesh[i].verts[2]=(mesh->verts[mesh->faces[i].v[2]]-parts->points[i])*(m.curtm);
	if (thick)
	{ Point3 tdir=thickness*parts->vels[i];
	  pmesh[i].verts[3]=pmesh[i].verts[0]-tdir*(m.curtm);
	  pmesh[i].verts[4]=pmesh[i].verts[1]-tdir*(m.curtm);
	  pmesh[i].verts[5]=pmesh[i].verts[2]-tdir*(m.curtm);
	  pmesh[i].faces[1]=pmesh[i].faces[0];
	  if (emat>0) pmesh[i].faces[1].setMatID(emat-1);
	  pmesh[i].faces[1].setSmGroup(0);
	  for (j=2;j<8;j++)
	   pmesh[i].faces[j]=pmesh[i].faces[1];
	  pmesh[i].faces[1].setVerts(0,3,4);
	  pmesh[i].faces[1].setEdgeVisFlags(1,1,0);
	  pmesh[i].faces[2].setVerts(0,4,1);
	  pmesh[i].faces[2].setEdgeVisFlags(0,1,1);
	  pmesh[i].faces[3].setVerts(1,4,5);
	  pmesh[i].faces[3].setEdgeVisFlags(1,1,0);
	  pmesh[i].faces[4].setVerts(1,5,2);
	  pmesh[i].faces[4].setEdgeVisFlags(0,1,1);
	  pmesh[i].faces[5].setVerts(2,5,3);
	  pmesh[i].faces[5].setEdgeVisFlags(1,1,0);
	  pmesh[i].faces[6].setVerts(2,3,0);
	  pmesh[i].faces[6].setEdgeVisFlags(0,1,1);
	  pmesh[i].faces[7].setVerts(3,5,4);
	  if (bmat>0) pmesh[i].faces[7].setMatID(bmat-1);
	  else pmesh[i].faces[7].setMatID(mesh->faces[i].getMatID());
	} else pmesh[i].faces[0].setEdgeVisFlags(1,1,1);
    if (doTVs)
	{ int tv0,tv1,tv2;
	  pmesh[i].setNumTVFaces(thick?8:1);
	  pmesh[i].tvFace[0].setTVerts(tv0=mesh->tvFace[i].t[0],tv1=mesh->tvFace[i].t[1],tv2=mesh->tvFace[i].t[2]);
	  if (thick)
	  {	pmesh[i].tvFace[1].setTVerts(tv0,tv0,tv1);
		pmesh[i].tvFace[2].setTVerts(tv0,tv1,tv1);
		pmesh[i].tvFace[3].setTVerts(tv1,tv1,tv2);
		pmesh[i].tvFace[4].setTVerts(tv1,tv2,tv2);
		pmesh[i].tvFace[5].setTVerts(tv2,tv2,tv0);
		pmesh[i].tvFace[6].setTVerts(tv2,tv0,tv0);
		pmesh[i].tvFace[7].setTVerts(tv0,tv2,tv1);
	  }
	}
	else { pmesh[i].setNumTVFaces(0);}
  }
}
void AddToMesh(INode *node,Mesh **mesh,TimeValue t,Matrix3 mtm,Interval &tmpValid,int subtree=0)
{ /*int nc;
  if (subtree)
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	  AddToMesh(node->GetChildNode(j),ntab,subtree,t);*/
  TriObject *triOb=NULL;
  Object *pobj=NULL;
  if ((!node->IsGroupHead())&&((triOb=TriIsUseable(pobj = node->EvalWorldState(t).obj,t))!=NULL))
  { if (*mesh) 
	{ Matrix3 tm2=node->GetObjectTM(t,&tmpValid);
      Mesh *newmesh=new Mesh;
	  CombineMeshes((*newmesh),(**mesh), triOb->GetMesh(), NULL, &tm2,-1);
	  (*mesh)->DeleteThis();
	  (*mesh)=newmesh;
	}
    else
	{ (*mesh)=new Mesh;(*mesh)->DeepCopy(&triOb->GetMesh(),GEOM_CHANNEL | TOPO_CHANNEL | TEXMAP_CHANNEL |	MTL_CHANNEL | DISP_ATTRIB_CHANNEL | TM_CHANNEL);
	  Matrix3 tm2=node->GetObjectTM(t,&tmpValid);
	  for (int i=0;i<triOb->GetMesh().getNumVerts();i++)
		(*mesh)->verts[i]=(*mesh)->verts[i]*tm2;
	}
  }
  if ((triOb) &&(triOb!=pobj)) triOb->DeleteThis();
}

void GetGroupMeshPtr(INode *node,Mesh **mesh,TimeValue t,Matrix3 curtm,Interval &tmpValid,int subtree=0)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) GetGroupMeshPtr(nxtnode,mesh,t,curtm,tmpValid,subtree);
	  else if ((subtree)||(nxtnode->IsGroupMember())) AddToMesh(nxtnode,mesh,t,curtm,tmpValid,subtree);
	}
}

void PArrayParticle::GetInfoFromObject(float thick,int *c,INode *distnode,TimeValue t,TimeValue lastt)
{ Object *pobj=NULL,*oldpobj=NULL;	  
  TriObject *triOb=NULL,*oldtriOb=NULL;
  Matlist m;
  int oldv,oldf,pnum=0;
  float NAngle,Vsz;
  Interval tmpValid=FOREVER;
  Matrix3 oldtm=distnode->GetObjectTM(lastt,&tmpValid);
  tmpValid=FOREVER; 
  Matrix3 curtm=distnode->GetObjectTM(t,&tmpValid);
  m.newtm=curtm;
  m.oldtm=oldtm;
  m.curtm=curtm;
  m.curtm.NoTrans();
  Mesh *oldmesh=NULL,*curmesh=NULL;
  BOOL tempmesh=FALSE;
  if (distnode->IsGroupHead())
  { tempmesh=TRUE;
	GetGroupMeshPtr(distnode,&oldmesh,lastt,oldtm,tmpValid);
	if (oldmesh) 
	{ Matrix3 itm=Inverse(oldtm);
	  for (int j=0;j<oldmesh->getNumVerts();j++) oldmesh->verts[j]=oldmesh->verts[j]*itm;
	}
  }
  else
  { if ((oldtriOb=TriIsUseable(oldpobj=distnode->EvalWorldState(t).obj,t))==NULL) return;
    oldmesh=&oldtriOb->GetMesh();
  }
  int ov=oldmesh->getNumVerts(),of=oldmesh->getNumFaces();
  Point3 *oldvs=new Point3[ov];
  Face *oldvf=new Face[of];
  for (int cnt=0;cnt<ov;cnt++)
  	oldvs[cnt]=oldmesh->verts[cnt];
  for (cnt=0;cnt<of;cnt++)
  	oldvf[cnt]=oldmesh->faces[cnt];	
  if (distnode->IsGroupHead())
  { tempmesh=TRUE;
	GetGroupMeshPtr(distnode,&curmesh,t,curtm,tmpValid);
	if (curmesh) 
	{ Matrix3 itm=Inverse(curtm);
	  for (int j=0;j<curmesh->getNumVerts();j++) curmesh->verts[j]=curmesh->verts[j]*itm;
	}
  }
  else
  { if ((triOb=TriIsUseable(pobj=distnode->EvalWorldState(t).obj,t))==NULL)
	{ if (oldtriOb!=oldpobj) oldtriOb->DeleteThis(); return;}
    curmesh=&triOb->GetMesh();
  }
  oldv=curmesh->getNumVerts();
  oldf=curmesh->getNumFaces();
  oldtvnum=curmesh->getNumTVerts();	
  doTVs=doTVs && (oldtvnum>0);
  int frag,emat,bmat,fmat;
  float Ie=0.0f,Em=0.0f,Vm=0.0f;
	pblock->GetValue(PB_EMAT,0,emat,FOREVER);
	pblock->GetValue(PB_BMAT,0,bmat,FOREVER);
	pblock->GetValue(PB_FMAT,0,fmat,FOREVER);
  pblock->GetValue(PB_EMITVINFL,t,Ie,FOREVER);
  pblock->GetValue(PB_EMITVMULT,t,Em,FOREVER);
  pblock->GetValue(PB_EMITVMULTVAR,t,Vm,FOREVER);
	pblock->GetValue(PB_FRAGMETHOD,0,frag,FOREVER); 
	pblock->GetValue(PB_SIZEVAR,t,Vsz,FOREVER);
	if (frag==FRAGFACE)
	{ *c=oldf;
      if (sdata){delete[] sdata;sdata=NULL;} 
	  sdata=new SavePt[oldf];
	  assert(sdata);
	  if (thick>0.0f)
	  for (int i=0;i<oldf;i++)
	  {	sdata[i].Vsz=RNDSign()*RND01()*Vsz;
		sdata[i].M=(RND0x(99)<Ie?Em*(1+RND11()*Vm):0); }
	  parts.SetCount(oldf,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
	  if (pmesh) { delete[] pmesh; pmesh=NULL; }pmesh=new Mesh[oldf];
	  BlowUpFaces(oldf,&(*curmesh),pmesh,&parts,thick,&sdata[0],m,oldvs,oldvf,emat,bmat,fmat,doTVs);
    }  //FRAGRND
	else 
	{ int *toplist,*nextlist;
      toplist=new int[oldf];
      nextlist=new int[oldf];
      assert((toplist!=NULL)&&(nextlist!=NULL));
      pblock->GetValue(PB_SMOOTHANG,0,NAngle,FOREVER); 
	  Point3 *norm;
	  norm=new Point3[oldf];
	  assert(norm!=NULL);
	  FindAllNormals(oldf,norm,curmesh->verts,curmesh->faces);
	  for (int i=0;i<oldf;i++) nextlist[i]=-2;
	  if (frag==FRAGRND)
	  { int fcnt;
		pblock->GetValue(PB_FRAGCOUNT,0,fcnt,FOREVER); 
		int numedges;
		Edge* el = curmesh->MakeEdgeList(&numedges,0);
		Tab<Edge> te;te.SetCount(numedges);
		for (int tx=0;tx<numedges;tx++)
		{ te[tx].v[0]=el[tx].v[0];te[tx].v[1]=el[tx].v[1];
		  te[tx].f[0]=el[tx].f[0];te[tx].f[1]=el[tx].f[1];
		} delete[] el;
		*c=FillInGroups(oldf,fcnt,toplist,nextlist,curmesh->faces,curmesh->verts,te); 
		te.Resize(0);
	  }
	  else
	  {	*c=FillInSmoothing(oldf,NAngle,norm,toplist,nextlist,curmesh->faces,curmesh->verts);
	  }
	  if (pmesh) { delete[] pmesh; pmesh=NULL; }pmesh=new Mesh[*c];
	  parts.SetCount(*c,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
      if (sdata){delete[] sdata;sdata=NULL;} sdata=new SavePt[parts.Count()];
	  if (thick>0.0f) 
	  for (int i=0;i<*c;i++)
	  {	sdata[i].Vsz=RNDSign()*RND01()*Vsz;
	    sdata[i].M=(RND0x(99)<Ie?Em*(1+RND11()*Vm):0);}
	  MakeIntoMesh(*c,oldf,norm,toplist,nextlist,thick,&(*curmesh),pmesh,&parts,&sdata[0],oldvs,oldvf,m,emat,bmat,fmat,doTVs);
	  if (norm) delete[] norm;
	  if (toplist) delete[] toplist;
	  if (nextlist) delete[] nextlist;
	}
	  if (pmesh)
	  { pmesh[0].setNumTVerts(oldtvnum);
		for (int tmp=0;tmp<oldtvnum;tmp++)
		{ pmesh[0].tVerts[tmp]=curmesh->tVerts[tmp];}
		curtm.NoTrans();
		Box3 tbox;
		for (int tc=0;tc<*c;tc++)
		{ tbox=pmesh[tc].getBoundingBox();
		  MakeBBpts(sdata[tc].wbb,tbox,curtm);
		}
	  }
	  if (tempmesh) 
	  { oldmesh->DeleteThis();curmesh->DeleteThis();}
	  if (oldvs) delete[] oldvs; 
	  if (oldvf) delete[] oldvf;
	  if (oldtriOb!=oldpobj) oldtriOb->DeleteThis();
	  if (triOb!=pobj) triOb->DeleteThis();
	  if (storefrag) delete[] storefrag;
   storefrag=new CacheDataType[*c];
  for (int ti=0;ti<*c;ti++)
  { storefrag[ti].M=sdata[ti].M;
	storefrag[ti].Ve=sdata[ti].Ve;
	storefrag[ti].Vsz=sdata[ti].Vsz;
	for (int wi=0;wi<8;wi++)
	  storefrag[ti].wbb[wi]=sdata[ti].wbb[wi];
	storefrag[ti].vel=parts.vels[ti];
	storefrag[ti].pos=parts.points[ti];
  }
	storernd=rand();
};
BOOL PArrayParticle::GenerateNotGeom(TimeValue t,TimeValue lastt,int c,int counter,INode *distnode,int type,Matrix3 tm,Matrix3 lasttm)
{	Object *pobj,*oldpobj;	  
	TriObject *triOb=NULL,*oldtriOb=NULL;
	Matlist m;
	int oldv,oldf,pnum=0,cnt;
	Point3 *oldvs=NULL;
	Face *oldvf=NULL;
	BOOL isok=FALSE;
//	srand(emitrnd);
	if ((oldtriOb=TriIsUseable(oldpobj=distnode->EvalWorldState(lastt).obj,lastt))==NULL) 
	  return isok;
	srand(emitrnd);
	int ov=oldtriOb->GetMesh().getNumVerts(),of=oldtriOb->GetMesh().getNumFaces();
	if ((ov==0)||(of==0)) 
		goto bombout;
	oldvs=new Point3[ov];
	oldvf=new Face[of];
	for (cnt=0;cnt<ov;cnt++)
  		oldvs[cnt]=oldtriOb->GetMesh().verts[cnt];
	for (cnt=0;cnt<of;cnt++)
  		oldvf[cnt]=oldtriOb->GetMesh().faces[cnt];	
	if ((triOb=TriIsUseable(pobj=distnode->EvalWorldState(t).obj,t))==NULL)
		goto bombout;
	oldv=triOb->GetMesh().getNumVerts();
	oldf=triOb->GetMesh().getNumFaces();
	if ((oldv==0)||(oldf==0)) goto bombout;
	BOOL doall;  pblock->GetValue(PB_USESELECTED,t,doall,FOREVER);
	doall=!doall;
	if (!doall)
	{	if (! (((type==VERTS)&&(triOb->GetMesh().vertSel.NumberSet()>0))||((type==EDGES)&&(triOb->GetMesh().edgeSel.NumberSet()>0))  )   )
		{	if (triOb->GetMesh().faceSel.NumberSet()==0) goto bombout;
		if (type==VERTS)
			for (int i=0;i<oldf;i++)
			{	if (triOb->GetMesh().faceSel[i])
				for (int j=0;j<3;j++) triOb->GetMesh().vertSel.Set(triOb->GetMesh().faces[i].v[j]);
			}
		}
	}
  oldtvnum=triOb->GetMesh().getNumTVerts();	
  doTVs=doTVs && (oldtvnum>0);
  m.oldtm=lasttm;
  m.newtm=tm;
  float Em,Vm,Ie;
  pblock->GetValue(PB_EMITVINFL,t,Ie,FOREVER);
  pblock->GetValue(PB_EMITVMULT,t,Em,FOREVER);
  pblock->GetValue(PB_EMITVMULTVAR,t,Vm,FOREVER);
  for (cnt=counter;cnt<counter+c;cnt++)
	sdata[cnt].M=(sdata[cnt].L<Ie?Em*(1+sdata[cnt].M*Vm):0);
  if (type==FACEC) FillInFaces(oldf,counter,&(triOb->GetMesh()),c,&parts,&sdata[0],oldvs,oldvf,m,doTVs,of-1,doall);
  else if (type==EDGES) FillByEdges(oldf,c,counter,&(triOb->GetMesh()),&parts,&sdata[0],oldvs,m,doTVs,ov-1,doall);
  else if (type==UNIFORM) FillInUniform(oldf,c,counter,&(triOb->GetMesh()),&parts,&sdata[0],oldvs,oldvf,m,doTVs,of-1,doall);
  else if (type==VERTS) FillInVertex(oldv,oldf,counter,&(triOb->GetMesh()),c,&parts,&sdata[0],oldvs,m,doTVs,ov-1,doall);
  else 
  { int emits,seed;
	pblock->GetValue(PB_EMITTERCOUNT,0,emits,FOREVER); 
	pblock->GetValue(PB_RNDSEED,0,seed,FOREVER); 
	srand(seed);
	FillByFixedPts(oldf,emits,c,counter,emitrnd,&(triOb->GetMesh()),&parts,&sdata[0],oldvs,oldvf,m,doTVs,of-1,doall);
  }
  emitrnd=rand();
  isok=TRUE;
bombout:
  if (oldvs) delete[] oldvs; 
  if (oldvf) delete[] oldvf;
  if ((oldtriOb)&&(oldtriOb!=oldpobj)) oldtriOb->DeleteThis();
  if ((triOb)&&(triOb!=pobj)) triOb->DeleteThis();
  return isok;
}

BOOL PArrayParticle::ComputeParticleStart(TimeValue t0,TimeValue lastt,INode *node,int c)
	{
	int seed,type,anioff,tani;
	TimeValue anifr;
	Point3 vel;
	float thick;
    pblock->GetValue(PB_DISTRIBUTION,0,type,FOREVER);
    pblock->GetValue(PB_FRAGTHICKNESS,0,thick,FOREVER);
	if (!fromgeom) thick=0.0f;
	pblock->GetValue(PB_RNDSEED,t0,seed,FOREVER);
    pblock->GetValue(PB_OFFSETAMOUNT,t0,anifr,FOREVER);
    pblock->GetValue(PB_ANIMATIONOFFSET,t0,anioff,FOREVER);
	srand(seed);					
	int oneframe=GetTicksPerFrame(),frag;
	pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	if (!fromgeom)
	{ if (pmesh) { delete[] pmesh; pmesh=NULL; }
      pmesh=new Mesh[c];
	  parts.SetCount(c,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
	  int pcount=parts.Count();
      if (sdata){delete[] sdata;sdata=NULL;} if (pcount) sdata=new SavePt[pcount];
	if ((pcount<c)||(c>0 && (!sdata)))
	{   parts.FreeAll();if (sdata) delete sdata;sdata=NULL;	maincount=0;
		BOOL playing=GetCOREInterface()->IsAnimPlaying();
		if (playing) GetCOREInterface()->EndAnimPlayback();
	    TSTR name;name=(cnode ? cnode->GetName() : TSTR(GetString(IDS_RB_PARRAY)));
		TSTR buf; buf=TSTR(GetString(IDS_OFM_PART));
		GetCOREInterface()->Log()->LogEntry(SYSLOG_ERROR,DISPLAY_DIALOG,
			GetString(IDS_OFM_ERROR),_T("%s: \n\n%s\n"),buf,name);
	    return (0);
	  }
	} 		
	else if (!pmesh) 
	{ GetInfoFromObject(thick,&c,distnode,t0,t0-lastt);
		srand(storernd);
	}
	else
	{ c=maincount;
	  parts.SetCount(c,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
      if (sdata){delete[] sdata;sdata=NULL;} sdata=new SavePt[parts.Count()];
	  for (int ti=0;ti<maincount;ti++)
	  { sdata[ti].M=storefrag[ti].M;
		sdata[ti].Ve=storefrag[ti].Ve;
		sdata[ti].Vsz=storefrag[ti].Vsz;
		for (int wi=0;wi<8;wi++)
		  sdata[ti].wbb[wi]=storefrag[ti].wbb[wi];
		parts.vels[ti]=storefrag[ti].vel;
		parts.points[ti]=storefrag[ti].pos;
	  }
		srand(storernd);
	}
	float tmp;Point3 tmppt;
	for (int i=0; i<parts.Count(); i++) {
		parts.ages[i] = -1;
		sdata[i].themtl=0;
		sdata[i].gennum=0;
  		sdata[i].L=RND0x(99);sdata[i].DL=-1;sdata[i].pvar=RND11();
		tmp=RND01();sdata[i].Fo=(fromgeom?0:tmp);
		tani=RND0x(anifr/oneframe);
		sdata[i].showframe=(anioff==2?tani*oneframe:0);
		sdata[i].V.x=RND11();
		sdata[i].V.y=RND11();
		sdata[i].V.z=RND11();
		sdata[i].Ts=0.0f;
		sdata[i].Ts0=RND11();
		sdata[i].LamTs=RND11();
		sdata[i].A=RND11();
		sdata[i].LamA=RND11();
		sdata[i].Inf=RND11();
		sdata[i].frommesh=0;
//		tmppt=Point3(RND11(),RND11(),RND11());
		if (!fromgeom)
		{ sdata[i].M=RND11();
		  sdata[i].Ve=Point3(0.0f,0.0f,0.0f);
//		  if (frag==INSTGEOM) parts.vels[i]=tmppt;
		}
		sdata[i].To=RND11();
		tmp=RND11();if (thick==0.0f) sdata[i].Vsz=tmp;
		sdata[i].W=Point3(RND11(),RND11(),RND11());
		sdata[i].RV=Point3(RND11(),RND11(),RND11());
		tmp=RND11();sdata[i].Dis=tmp;
		parts.radius[i]=thick;
		parts.tension[i]=RND11();
		sdata[i].Mltvar=RND11();
		sdata[i].SpVar=RND0x(99);
		}
	tvalid = t0-1;
	valid  = TRUE;
	lastrnd=rand();
	emitrnd=lastrnd;
	return (1);
	}

#define VEL_SCALE	(0.01f*1200.0f/float(TIME_TICKSPERSEC))
#define VAR_SCALE	(0.01f*1200.0f/float(TIME_TICKSPERSEC))

void PArrayParticle::BirthParticle(INode *node,TimeValue bt,int num,VelDir2 *ptvel2,VelDir ptvel,Matrix3 tmnxt)
{	Point3 pos, vel;
	Matrix3 tm = node->GetObjTMBeforeWSM(bt);
	Matrix3 atm = node->GetObjTMAfterWSM(bt);
	tm.SetRow(3,atm.GetRow(3));
	int MotionOffset,EmitOffset;
	pblock->GetValue(PB_SUBFRAMEMOVE,bt,MotionOffset,FOREVER);
	pblock->GetValue(PB_SUBFRAMETIME,bt,EmitOffset,FOREVER);
	int RotSampleOn;
	pblock->GetValue(PB_SUBFRAMEROT,bt,RotSampleOn,FOREVER);
	parts.tension[num]=ptvel.bstr*(1+parts.tension[num]*ptvel.bstrvar);
	sdata[num].L=ptvel.Life+(int)(sdata[num].Inf*ptvel.Vl);
	sdata[num].Vsz*=ptvel.VSz;
	sdata[num].Ts0=(1+sdata[num].Ts0*ptvel.VSpin)/TWOPI;
	sdata[num].Ts=(float)ptvel.Spin*sdata[num].Ts0;
	sdata[num].persist=(TimeValue)(ptvel2->persist*(1.0f+sdata[num].pvar*ptvel2->pvar));
	if (fromgeom) sdata[num].LamTs=0.0f;
	else
	sdata[num].LamTs=ptvel.Phase*(1+sdata[num].LamTs*ptvel.VPhase);
	sdata[num].A = ptvel.ToAmp*(1+sdata[num].A*ptvel.VToAmp);
	sdata[num].LamA=ptvel.ToPhase*(1+sdata[num].LamA*ptvel.VToPhase);
	sdata[num].To=ptvel.ToPeriod*(1+sdata[num].To*ptvel.VToPeriod);
	if (ptvel2->axisentered==2)
	{	sdata[num].W=Normalize(ptvel2->Axis);
		if (ptvel2->axisvar>0.0f)
		VectorVar(&sdata[num].W,ptvel2->axisvar,PI);
	}
	else sdata[num].W=Normalize(sdata[num].W);
	parts.ages[num] = 0;
	Matrix3 OffRotTm;
	if (RotSampleOn) MakeInterpRotXform(tm,tmnxt,(1.0f-sdata[num].Fo),OffRotTm);
	else OffRotTm=tm;OffRotTm.NoScale();
	vel=VectorTransform(OffRotTm,parts.vels[num]);
//vel=VectorTransform(tm,parts.vels[num]);
	if (ptvel2->div>0.0f) vel=CalcSpread(ptvel2->div,vel);
	vel.x*=ptvel.Speed*(1+sdata[num].V.x*ptvel.VSpeed);
	vel.y*=ptvel.Speed*(1+sdata[num].V.y*ptvel.VSpeed);
	vel.z*=ptvel.Speed*(1+sdata[num].V.z*ptvel.VSpeed);
	if (sdata[num].M!=0.0f) vel+=sdata[num].Ve*sdata[num].M;
	pos=parts.points[num]*tm;
	if (MotionOffset) pos+=(sdata[num].Ve)*(1.0f-sdata[num].Fo);
	if (EmitOffset) pos+=(sdata[num].Fo)*vel;
	parts[num]=pos; 
	vel/=(float)GetTicksPerFrame();
	parts.vels[num] = vel;
	sdata[num].start=(sdata[num].V=parts[num]);
}

void PArrayParticle::DoSpawn(int j,int spmult,SpawnVars spvars,TimeValue lvar,BOOL emits,int &oldcount)
{ if (!emits) spmult--;
  int newcount=(oldcount+spmult); 
  srand(lastrnd);
  if ((!emits)&&(spmult))
  { parts.SetCount(newcount,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
	SavePt *tmp=sdata;
	sdata=new SavePt[newcount];
	if (tmp) {memcpy(sdata,tmp,sizeof(SavePt)*oldcount); delete[] tmp;
	}
  }
  int Lcnt=llist.Count();
  int baselife=(Lcnt==0?deftime:(sdata[j].gennum<Lcnt?llist[sdata[j].gennum]:llist[Lcnt-1]))*GetTicksPerFrame();
  if (!emits)
  { sdata[j].gennum++;
	parts.ages[j]=0;}
  Point3 holdv=(emits?-parts.vels[j]:parts.vels[j]);
  for (int i=oldcount;i<newcount;i++)
  { parts.points[i]=parts.points[j];
    parts.vels[i]=holdv;
	parts.radius[i]=parts.radius[j];
	parts.tension[i]=parts.tension[j];
	parts.ages[i]=0;
	memcpy(&sdata[i],&sdata[j],sizeof(SavePt));
 	if (emits) sdata[i].gennum++;
 	if (sdata[j].gennum==1) sdata[i].frommesh=j;
    parts.vels[i]=DoSpawnVars(spvars,parts.vels[j],holdv,&parts.radius[i],&sdata[i].W);
	sdata[i].L=baselife+(int)RND11()*lvar;
	sdata[i].Mltvar=RND11();
	sdata[i].SpVar=RND0x(99);
	sdata[i].DL=-1;
	sdata[i].Vsz=parts.radius[i];
//	parts.radius[i]=basesize*sdata[i].Vsz;
 }
  if (!emits)
  { parts.vels[j]=DoSpawnVars(spvars,holdv,holdv,&parts.radius[j],&sdata[j].W);
 	if (sdata[j].gennum==1) sdata[j].frommesh=j;
    sdata[j].L=baselife+(int)RND11()*lvar;
	sdata[j].Mltvar=RND11();
	sdata[j].SpVar=RND0x(99);
	sdata[j].DL=-1;
//	parts.radius[j]=basesize*sdata[j].Vsz;
  }
  lastrnd=rand();
  oldcount=newcount;
}

void PArrayParticle::MovePart(int j,TimeValue dt,BOOL fullframe,int tpf)
{ 	float curdt=(float)dt;
	parts[j] = sdata[j].V+parts.vels[j] * (float)dt;
	// add transverse oscillation
	if (fullframe) sdata[j].V=parts[j];
	Point3 DotPt=(FGT0(parts.vels[j]*(float)tpf)?parts.vels[j]:sdata[j].W);
	DotPt=sdata[j].RV^DotPt;				// Cross Product 
	DotPt=Normalize(DotPt);	       
	float oscil=(sdata[j].To>0.0f?parts.ages[j]*TWOPI/sdata[j].To:0.0f);
	oscil=sdata[j].A*(float)sin(oscil+sdata[j].LamA);
	parts[j] +=DotPt*oscil;
}

void PArrayParticle::UpdateParticles(TimeValue t,INode *node)
	{
	TimeValue t0,dt,t2,grow,fade;
	int i, j, c, birth,counter,tpf=GetTicksPerFrame(),anioff;
	float FperT;
	VelDir ptvel;
	VelDir2 ptvel2;
    Matrix3 tm,lasttm,nxttm; 
	int isrend=TestAFlag(A_RENDER),bmethod,onscreen,oneframe;
	BOOL custmtl;
	cancelled=FALSE;

	// The size of steps we take to integrate will be frame size steps.
	oneframe=GetTicksPerFrame();
    if (stepSize!=oneframe) 
	{	stepSize = oneframe;
		valid = FALSE;
	}
	FperT=GetFrameRate()/(float)TIME_TICKSPERSEC;
    pblock->GetValue(PB_ANIMATIONOFFSET,t,anioff,FOREVER);
	pblock->GetValue(PB_EMITSTART,t,t0,FOREVER);
	pblock->GetValue(PB_SIZE,t,parts.size,FOREVER);	
	pblock->GetValue(PB_BIRTHMETHOD,0,bmethod,FOREVER);
	pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
	int subtree,frag;
	pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
	pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	pblock->GetValue(PB_EMITSTOP,0,t2,FOREVER);
	if (bmethod)
	  pblock->GetValue(PB_PTOTALNUMBER,0,c,FOREVER);
	if ((t < t0)||(!distnode)) {
		// Before the start time, nothing is happening
		parts.FreeAll();
		if (sdata) {delete[] sdata;sdata=NULL;}
		if ((!distnode)||(!valid))
		{ if (pmesh) {delete[] pmesh; pmesh=NULL;}}
		ResetSystem(t);
		doTVs=FALSE;
		return;
		}
	int pkind,vkind;
	float dpercent;
	pblock->GetValue(PB_DISPLAYPORTION,0,dpercent,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,pkind,FOREVER);
    pblock->GetValue(PB_DISTRIBUTION,0,vkind,FOREVER);
	fromgeom=(frag==BYGEOM);

	if (!valid || t<tvalid || tvalid<t0) 
	{	// Set the particle system to the initial condition
	    TimeValue cincr;	
    	doTVs=custmtl;
		if ((!fromgeom)&&(!bmethod))
		{ c=0;
		  for (TimeValue ti=t0;ti<=t2;ti+=oneframe)
		  { pblock->GetValue(PB_PBIRTHRATE,ti,cincr,FOREVER);
		    if (cincr<0) cincr=0;
			c+=cincr;
		  }
		}
		if (!isrend) c=(int)(dpercent*(float)c+FTOIEPS);
		if ((pmesh)&&(!valid))
		{ delete[] pmesh; pmesh=NULL;}
		if (!ComputeParticleStart(t0,stepSize,distnode,c))
		{ if (pmesh) {delete[] pmesh; pmesh=NULL;}
		  ResetSystem(t);
		  doTVs=FALSE;
		  return;
		}
		dispt=t-1;
		maincount=parts.Count();
		ResetSystem(t,FALSE);
//		if (origmtl==NULL) origmtl=node->GetMtl();
	}
	int total;
	total=maincount;
	valid = TRUE;
	int stype,maxgens,spmultb;
	float spawnbvar;
    pblock->GetValue(PB_SPAWNTYPE,0,stype,FOREVER);
    pblock->GetValue(PB_SPAWNGENS,0,maxgens,FOREVER);
    pblock->GetValue(PB_SPAWNCOUNT,0,spmultb,FOREVER);
	valid = TRUE;
    pblock->GetValue(PB_GROWTIME,0,grow,FOREVER);
    pblock->GetValue(PB_FADETIME,0,fade,FOREVER);
    pblock->GetValue(PB_SPINAXISTYPE,0,ptvel2.axisentered,FOREVER);
	SpawnVars spawnvars;
	spawnvars.axisentered=ptvel2.axisentered;
	TimeValue dis;
    pblock->GetValue(PB_DISPUNTIL,0,dis,FOREVER);
//	if (Length(ptvel2.Dir)==0.0f) ptvel2.Dir.x=0.001f;

	if (t2<t0) t2=t0;
//	TimeValue fstep=oneframe;t2+=fstep;
	TimeValue createover;
	createover=t2-t0+oneframe;
	counter=(isrend?rcounter:vcounter);
	float frate,grate;
	if (frag==BYGEOM) {fade=0;grow=0;}
	frate=(fade>0.0f?(1-M)/fade:0.0f);
	grate=(grow>0.0f?(1-M)/grow:0.0f);
	BOOL fullframe;
	float basesize,startsize;
	if (!isrend)
	{ int offby=t%oneframe;
	  if (offby!=0) t-=offby;
	}
    pblock->GetValue(PB_SPAWNSCALESIGN,0,spawnvars.scsign,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDSIGN,0,spawnvars.spsign,FOREVER);
    pblock->GetValue(PB_SPAWNINHERITV,0,spawnvars.invel,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDFIXED,0,spawnvars.spconst,FOREVER);
    pblock->GetValue(PB_SPAWNSCALEFIXED,0,spawnvars.scconst,FOREVER);
	int count,sper,spmult;float smper;BOOL first=(tvalid<t0);
	while ((tvalid < t)&&(tvalid<=dis))
	{	int born = 0;		
		if (first) tvalid=t0;
		TimeValue atvalid=abs(tvalid);
			// Compute our step size
		 if (tvalid%stepSize !=0) 
		  { dt = stepSize - atvalid%stepSize;} 
		  else { dt = stepSize;	}
		  if (tvalid + dt > t) {dt = t-tvalid;}

  		  // Increment time
		if (!first) tvalid +=dt;
		if (tvalid>dis)
		{ for (j=0; j<parts.Count(); j++)
		  { parts.ages[j] = -1;  }
		  tvalid=t;
		  continue;
		}
	    pblock->GetValue(PB_PASPAWNDIEAFTER,tvalid,ptvel2.persist,FOREVER);
	    pblock->GetValue(PB_PASPAWNDIEAFTERVAR,tvalid,ptvel2.pvar,FOREVER);
		pblock->GetValue(PB_SIZE,tvalid,ptvel.Size,FOREVER);
		pblock->GetValue(PB_SIZEVAR,tvalid,ptvel.VSz,FOREVER);
	    pblock->GetValue(PB_SPEED,tvalid,ptvel.Speed,FOREVER);
	    pblock->GetValue(PB_SPEEDVAR,tvalid,ptvel.VSpeed,FOREVER);
        pblock->GetValue(PB_ANGLEDIV,tvalid,ptvel2.div,FOREVER);
        pblock->GetValue(PB_METATENSION,tvalid,ptvel.bstr,FOREVER);
	    pblock->GetValue(PB_METATENSIONVAR,tvalid,ptvel.bstrvar,FOREVER);
		pblock->GetValue(PB_LIFE,tvalid,ptvel.Life,FOREVER);
		pblock->GetValue(PB_LIFEVAR,tvalid,ptvel.Vl,FOREVER);
	    pblock->GetValue(PB_SPINTIME,tvalid,ptvel.Spin,FOREVER);
		pblock->GetValue(PB_SPINTIMEVAR,tvalid,ptvel.VSpin,FOREVER);
		pblock->GetValue(PB_SPINPHASE,tvalid,ptvel.Phase,FOREVER);
		pblock->GetValue(PB_SPINPHASEVAR,tvalid,ptvel.VPhase,FOREVER);
		pblock->GetValue(PB_SPINAXISX,tvalid,ptvel2.Axis.x,FOREVER);
		pblock->GetValue(PB_SPINAXISY,tvalid,ptvel2.Axis.y,FOREVER);
		pblock->GetValue(PB_SPINAXISZ,tvalid,ptvel2.Axis.z,FOREVER);
		if (Length(ptvel2.Axis)==0.0f) ptvel2.Axis.x=0.001f;
		pblock->GetValue(PB_SPINAXISVAR,tvalid,ptvel2.axisvar,FOREVER);
		pblock->GetValue(PB_BUBLAMP,tvalid,ptvel.ToAmp,FOREVER);
		pblock->GetValue(PB_BUBLAMPVAR,tvalid,ptvel.VToAmp,FOREVER);
		pblock->GetValue(PB_BUBLPHAS,tvalid,ptvel.ToPhase,FOREVER);
		pblock->GetValue(PB_BUBLPHASVAR,tvalid,ptvel.VToPhase,FOREVER);
		pblock->GetValue(PB_BUBLPER,tvalid,ptvel.ToPeriod,FOREVER);
		pblock->GetValue(PB_BUBLPERVAR,tvalid,ptvel.VToPeriod,FOREVER);
    pblock->GetValue(PB_SPAWNPERCENT,tvalid,sper,FOREVER);	
    pblock->GetValue(PB_SPAWNMULTVAR,tvalid,smper,FOREVER);
	spawnbvar=smper*spmultb;
    pblock->GetValue(PB_SPAWNDIRCHAOS,tvalid,spawnvars.dirchaos,FOREVER);
    pblock->GetValue(PB_SPAWNSPEEDCHAOS,tvalid,spawnvars.spchaos,FOREVER);
	spawnvars.spchaos/=100.0f;
    pblock->GetValue(PB_SPAWNSCALECHAOS,tvalid,spawnvars.scchaos,FOREVER);
	spawnvars.scchaos=spawnvars.scchaos/100.0f;
	spawnvars.Axis=ptvel2.Axis;spawnvars.axisvar=ptvel2.axisvar;
	if (llist.Count()==0) deftime=ptvel.Life/oneframe;
	if (frag==BYGEOM) ptvel.Size=1.0f;
	basesize=M*ptvel.Size;
	startsize=((grow==0)?ptvel.Size:basesize);
//	startsize=ptvel.Size;
		// Compute the number of particles that should be born!
		birth=0;
		fullframe=(tvalid%tpf==0);
		if (fullframe)
		{ if (fromgeom)
		  { if (tvalid>=t0) birth=total-counter;	}
		  else
		  { if (bmethod)
		    { int tdelta;
		      if (tvalid>=t2) birth=total-counter;
		      else
		      { tdelta=int((float)total*(tvalid-t0+oneframe)/createover);
		        birth=tdelta-counter;
		      }
	        }
		    else if (tvalid<=t2)
		    { pblock->GetValue(PB_PBIRTHRATE,tvalid,total,FOREVER);
		      if (!isrend) total=(int)(dpercent*(float)total+FTOIEPS);
		      birth=total;
			  if (birth+counter>maincount) birth=maincount-counter;
		    }	  
		  } 
		}
		int pc=parts.Count(),newsp=0,oldcnt=pc;
		if ((fullframe)&&(stype==EMIT))
		{ for (j=0;j<maincount;j++)
		  { if ((!parts.Alive(j))||(parts.ages[j]+dt >= sdata[j].L)) continue;
		    if ((sdata[j].gennum==0)&&(sdata[j].SpVar<sper))
			  newsp+=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
		  }
		  if (newsp>0)
		  { int newcount=pc+newsp;
		    parts.SetCount(newcount,PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
		    SavePt *tmp=sdata;
		    sdata=new SavePt[newcount];
		    if (tmp) {memcpy(sdata,tmp,sizeof(SavePt)*pc); delete[] tmp;}
		  }
		}
		// First increment age and kill off old particles
		for (j=0;j<pc;j++)
		{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) ) 
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
		  if (!parts.Alive(j)) continue;
		  parts.ages[j] += dt;
//		  startsize=ptvel.Size;
		  if (parts.ages[j] >= sdata[j].L) 
		  {  if ((stype!=ONDEATH)||(sdata[j].gennum>=maxgens)||(sdata[j].SpVar>=sper)) parts.ages[j] = -1;	
			else if (fullframe)
			 {spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
				if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,FALSE,oldcnt);
				else parts.ages[j] = -1;
			 }
		  } else if (sdata[j].DL>-1)
		  { sdata[j].DL+=dt;if (sdata[j].DL>sdata[j].persist) parts.ages[j]=-1;}
		  if (parts.ages[j]>-1)
		  { if (fullframe &&((stype==EMIT)&&(sdata[j].gennum==0)&&(sdata[j].SpVar<sper)))
		  {  spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
			  if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,TRUE,oldcnt);
		  }
			if ((stype<2)||(maxgens==0))
		 	 parts.radius[j]=FigureOutSize(parts.ages[j],ptvel.Size,grow,fade,sdata[j].L,grate,frate)*(1+sdata[j].Vsz);
		   else if (!fromgeom) 
		   { if (sdata[j].gennum==0)
			   parts.radius[j]=FigureOutSize(parts.ages[j],ptvel.Size,grow,0,sdata[j].L,grate,frate)*(1+sdata[j].Vsz);
		     else if (sdata[j].gennum==maxgens)
			   parts.radius[j]=FigureOutSize(parts.ages[j],sdata[j].Vsz,0,fade,sdata[j].L,grate,frate);
		   }
		  }
		}
		if (birth>0)
		{ Matrix3 tm;	
		  TimeValue lasttime=(atvalid<stepSize?0:(tvalid-stepSize));
		  lasttm= distnode->GetObjTMAfterWSM(lasttime);
		  tm= distnode->GetObjTMAfterWSM(tvalid);
		  nxttm= distnode->GetObjTMAfterWSM(tvalid+stepSize);
		  if (!fromgeom) 
			  if (!GenerateNotGeom(tvalid,lasttime,birth,counter,distnode,vkind,tm,lasttm))
				  birth=0;
		  for (j=counter; j<maincount; j++) {
			if (born>=birth) break;
			BirthParticle(distnode,tvalid,j,&ptvel2,ptvel,nxttm);
			parts.radius[j]=startsize*(1+sdata[j].Vsz);
			sdata[j].themtl=int((tvalid-t0)*FperT);
			born++;counter++;
			}
		}

		// Apply forces to modify velocity
		int fc=fields.Count();
		if (fc>0)
		  for (j=0; j<parts.Count(); j++) 
		  { Point3 force,tvel=Zero;
		    for (i=0; i<fc; i++) 
			{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
			if (!parts.Alive(j)) continue;
			 parts[j]=sdata[j].V;
			 force = fields[i]->Force(tvalid,parts[j],parts.vels[j],j);
			 float curdt=(float)dt;
			 if ((parts.ages[j]==0)&&(sdata[j].gennum==0)) curdt=tpf*sdata[j].Fo;
			 tvel += 10.0f*force * curdt;
			}
		    parts.vels[j]+=tvel;
		}
		count=0;
		int IPC,ipcsteps;float B,Vb;
  		pblock->GetValue(PB_PAIPCOLLIDE_ON,tvalid,IPC,FOREVER);
  		pblock->GetValue(PB_PAIPCOLLIDE_STEPS,tvalid,ipcsteps,FOREVER);
  		pblock->GetValue(PB_PAIPCOLLIDE_BOUNCE,tvalid,B,FOREVER);
  		pblock->GetValue(PB_PAIPCOLLIDE_BOUNCEVAR,tvalid,Vb,FOREVER);
		if (IPC)
		{	CollideParticle cp;
			int ddt=dt/ipcsteps,remtime=0,snum=0;
			TimeValue curt=t;
			if (dt > 0)
			  while (snum < ipcsteps)
				{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
				  {	valid=FALSE;
					tvalid=t;
					cancelled=TRUE;
					parts.FreeAll();
					return;
				  }
					if (remtime==0) remtime=ddt;
					mindata md=cp.InterPartCollide(parts,cobjs,remtime,snum,B,Vb,curt,lc);
					for (j=0; j<parts.Count(); j++)
					{	if (parts.ages[j]>0) 
						{	if ((j!=md.min)&&(j!=md.min2)) 
							{	if (fullframe) 
									MovePart(j,md.mintime,fullframe,tpf);
								else 
									parts[j]+=parts.vels[j]*(float)md.mintime;
							}
							else if (fullframe) sdata[j].V=parts[j];
						}
					}
				}
			// If we didn't collide, then increment.
			for (j=0; j<parts.Count(); j++)
			{	sdata[j].Ts = (float)ptvel.Spin*sdata[j].Ts0;
				sdata[j].LamTs += (FloatEQ0(sdata[j].Ts)?0.0f:dt/sdata[j].Ts);
			}
		}
		else
		for (j=0; j<parts.Count(); j++)
		{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
			{ valid=FALSE;tvalid=t;cancelled=TRUE;parts.FreeAll();return;}
			if ((!parts.Alive(j))||(parts.ages[j]==0)) continue;
		  count++;
			// Check for collisions
			BOOL collide = FALSE;
			float meaninglesstime;
			for (int i=0; i<cobjs.Count(); i++) {
				if (cobjs[i]->CheckCollision(
						tvalid,parts[j],parts.vels[j], (float)dt, j,&meaninglesstime,TRUE))
				{	collide = TRUE;
					if (stype==1)
					{ if (sdata[j].persist==0) {parts.ages[j] = -1;count--;}else sdata[j].DL=0;}
					else if (fullframe &&((stype==COLLIDE)&&(sdata[j].gennum<maxgens)&&(sdata[j].SpVar<sper)))
					{ int spmult=(int)(sdata[j].Mltvar*spawnbvar)+spmultb;
					  if (spmult!=0) DoSpawn(j,spmult,spawnvars,ptvel.Vl,FALSE,oldcnt);
					  else break;
					}
				else break;
					}
				}
			sdata[j].Ts=(float)ptvel.Spin*sdata[j].Ts0;
			sdata[j].LamTs+=(FloatEQ0(sdata[j].Ts)?0.0f:dt/sdata[j].Ts);			
			
			// If we didn't collide, then increment.
			if (!collide) MovePart(j,dt,fullframe,tpf);
			else if (fullframe) sdata[j].V=parts[j];
		}
		// Next, birth particles at the birth rate
		if (first) first=FALSE;
	}
/*	if ((frag==METABALLS)&&((!isrend)&&(onscreen==2)))
	{ float res,bstr,thres=0.6f;
      pblock->GetValue(PB_METATENSION,tvalid,bstr,FOREVER);
      pblock->GetValue(PB_METACOURSE,0,res,FOREVER);
      metap.CreateMetas(parts,metamesh,thres,res,bstr);
	}
	else */if (((frag==BYGEOM && distnode)||((frag==INSTGEOM)&&custnode))&&(onscreen>1))
	{ TimeValue anist=GetAnimStart(),aniend=GetAnimEnd();
      thePArrayDraw.anifr=aniend+stepSize;
	  thePArrayDraw.t=t;
	  thePArrayDraw.anioff=anioff;
	  if (count>0)
	   GetTimes(times,t,thePArrayDraw.anifr,anioff,frag);
	  else times.tl.ZeroCount();
	  if (onscreen==2)
	   GetMesh(t,subtree,custmtl,frag);
	  else GetallBB(custnode,subtree,t,frag);
	}  
	if (isrend) rcounter=counter;
	else
	{ vcounter=counter;
	}
	if (tvalid<t) tvalid=t;
	valid=TRUE;
//	assert(tvalid==t);
	}


void PArrayParticle::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	if (pmapPGen) pmapPGen->Invalidate();
	if (pmapPType) pmapPType->Invalidate();
	if (pmapPSpin) pmapPSpin->Invalidate();
	if (pmapEmitV) pmapEmitV->Invalidate();
	if (pmapBubl) pmapBubl->Invalidate();
	if (pmapSpawn) pmapSpawn->Invalidate();
	}

BOOL PArrayParticle::EmitterVisible()
	{
	int hide;
	pblock->GetValue(PB_EMITRHID,0,hide,FOREVER);
	return !hide;
	}

ParamDimension *PArrayParticle::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {
		case PB_EMITTERCOUNT:
		case PB_SPEED:
		case PB_PBIRTHRATE:
		case PB_PTOTALNUMBER:
		case PB_SIZE:
		case PB_RNDSEED:
		case PB_METATENSION:
		case PB_METACOURSE:
		case PB_FRAGTHICKNESS:
		case PB_FRAGCOUNT:
		case PB_MAPPINGDIST:
		case PB_SPINAXISX:
		case PB_SPINAXISY:
		case PB_SPINAXISZ:
		case PB_EMITVMULT:
		case PB_BUBLAMP:
		case PB_EMITRWID:  			return stdWorldDim;

		case PB_ANGLEDIV:
		case PB_SPINPHASE:
		case PB_SPINAXISVAR:
		case PB_SMOOTHANG:
		case PB_BUBLPHAS:			return stdAngleDim;

		case PB_DISPLAYPORTION:
		case PB_SPAWNDIRCHAOS:
		case PB_SIZEVAR:
		case PB_SPEEDVAR:
		case PB_METATENSIONVAR:
		case PB_SPINTIMEVAR:
		case PB_SPINPHASEVAR:
		case PB_EMITVMULTVAR:
		case PB_BUBLAMPVAR:
		case PB_BUBLPERVAR:
		case PB_BUBLPHASVAR:		
		case PB_SPAWNMULTVAR:
		case PB_PASPAWNDIEAFTERVAR:
		case PB_PAIPCOLLIDE_BOUNCE:			
		case PB_PAIPCOLLIDE_BOUNCEVAR:			
								return stdPercentDim;

		case PB_EMITSTART:
		case PB_EMITSTOP:
		case PB_DISPUNTIL:
		case PB_LIFE:
		case PB_LIFEVAR:
		case PB_GROWTIME:
		case PB_FADETIME:
		case PB_MAPPINGTIME:
		case PB_SPINTIME:
		case PB_BUBLPER:
		case PB_OFFSETAMOUNT:
		case PB_PASPAWNDIEAFTER:
								return stdTimeDim;
		
		default: return defaultDim;
		}
	}

TSTR PArrayParticle::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_DISTRIBUTION:	return GetString(IDS_RB_DISTRIBUTION);		
		case PB_EMITTERCOUNT:	return GetString(IDS_RB_EMITTERCOUNT);
		case PB_SPEED:			return GetString(IDS_RB_SPEED);
		case PB_SPEEDVAR:		return GetString(IDS_RB_SPEEDVAR);
		case PB_ANGLEDIV:		return GetString(IDS_RB_ANGLEDIV);
		case PB_PBIRTHRATE:		return GetString(IDS_RB_PBIRTHRATE);
		case PB_PTOTALNUMBER:	return GetString(IDS_RB_PTOTALNUMBER);
		case PB_DISPLAYPORTION:	return GetString(IDS_RB_DISPLAYPORTION);
		case PB_EMITSTART:		return GetString(IDS_RB_EMITSTART);
		case PB_EMITSTOP:		return GetString(IDS_RB_EMITSTOP);
		case PB_DISPUNTIL:		return GetString(IDS_RB_DISPUNTIL);
		case PB_LIFE:			return GetString(IDS_RB_LIFE);
		case PB_LIFEVAR:		return GetString(IDS_RB_LIFEVAR);
		case PB_SIZE:			return GetString(IDS_RB_SIZE);
		case PB_SIZEVAR:		return GetString(IDS_RB_SIZEVAR);
		case PB_GROWTIME:		return GetString(IDS_RB_GROWTIME);
		case PB_FADETIME:		return GetString(IDS_RB_FADETIME);
		case PB_RNDSEED:		return GetString(IDS_RB_RNDSEED);
		case PB_METATENSION:	return GetString(IDS_RB_METATENSION);
		case PB_METATENSIONVAR:	return GetString(IDS_RB_METATENSIONVAR);
		case PB_METACOURSE:		return GetString(IDS_RB_METACOURSE);
		case PB_FRAGTHICKNESS:	return GetString(IDS_RB_FRAGTHICKNESS);
		case PB_FRAGCOUNT:		return GetString(IDS_RB_FRAGCOUNT);
		case PB_MAPPINGTIME:	return GetString(IDS_RB_MAPPINGTIME);
		case PB_MAPPINGDIST:	return GetString(IDS_RB_MAPPINGDIST);
		case PB_SPINTIME:		return GetString(IDS_RB_SPINTIME);
		case PB_SPINTIMEVAR:	return GetString(IDS_RB_SPINTIMEVAR);
		case PB_SPINPHASE:		return GetString(IDS_RB_SPINPHASE);
		case PB_SPINPHASEVAR:	return GetString(IDS_RB_SPINPHASEVAR);
		case PB_SPINAXISX:		return GetString(IDS_RB_SPINAXISX);
		case PB_SPINAXISY:		return GetString(IDS_RB_SPINAXISY);
		case PB_SPINAXISZ:		return GetString(IDS_RB_SPINAXISZ);
		case PB_SPINAXISVAR:	return GetString(IDS_RB_SPINAXISVAR);
		case PB_EMITVINFL:		return GetString(IDS_RB_EMITVINFL);
		case PB_EMITVMULT:		return GetString(IDS_RB_EMITVMULT);
		case PB_EMITVMULTVAR:	return GetString(IDS_RB_EMITVMULTVAR);
		case PB_BUBLAMP:		return GetString(IDS_RB_BUBLAMP);
		case PB_BUBLAMPVAR:		return GetString(IDS_RB_BUBLAMPVAR);
		case PB_BUBLPER:		return GetString(IDS_RB_BUBLPER);
		case PB_BUBLPERVAR:		return GetString(IDS_RB_BUBLPERVAR);
		case PB_BUBLPHAS:		return GetString(IDS_RB_BUBLPHAS);
		case PB_BUBLPHASVAR:	return GetString(IDS_RB_BUBLPHASVAR);
		case PB_EMITRWID:		return GetString(IDS_RB_EMITRWID);
		case PB_STRETCH:		return GetString(IDS_AP_STRETCH);
		case PB_OFFSETAMOUNT:	return GetString(IDS_AP_OFFSETAMT);
		case PB_SPAWNGENS:		return GetString(IDS_AP_SPAWNGENS);
		case PB_SPAWNCOUNT:		return GetString(IDS_AP_SPAWNCOUNT);
		case PB_SPAWNDIRCHAOS:	return GetString(IDS_AP_SPAWNDIRCHAOS);
		case PB_SPAWNSPEEDCHAOS:	return GetString(IDS_AP_SPAWNSPEEDCHAOS);
		case PB_SPAWNSCALECHAOS:	return GetString(IDS_AP_SPAWNSCALECHAOS);
		case PB_SPAWNLIFEVLUE:	return GetString(IDS_AP_SPAWNLIFEVLUE);
		case PB_SPAWNPERCENT:	return GetString(IDS_EP_SPAWNAFFECTS);
		case PB_SPAWNMULTVAR:	return GetString(IDS_EP_SPAWNMULTVAR);
		case PB_USESELECTED:	return GetString(IDS_AP_USESELECTED);
		case PB_PASPAWNDIEAFTER:	return GetString(IDS_AP_SPAWNDIEAFTER);
		case PB_PASPAWNDIEAFTERVAR:	return GetString(IDS_AP_SPAWNDIEAFTERVAR);
		case PB_PAIPCOLLIDE_ON:			return GetString(IDS_AP_IPCOLLIDE_ON);
		case PB_PAIPCOLLIDE_STEPS:		return GetString(IDS_AP_IPCOLLIDE_STEPS);
		case PB_PAIPCOLLIDE_BOUNCE:		return GetString(IDS_AP_IPCOLLIDE_BOUNCE);
		case PB_PAIPCOLLIDE_BOUNCEVAR:	return GetString(IDS_AP_IPCOLLIDE_BOUNCEVAR);
		default: 				return TSTR(_T(""));
		}
	}	
void PArrayParticle::GetLocalBoundBox(TimeValue t, INode *inode,ViewExp* vpt,  Box3& box ) 
	{
	Matrix3 mat = inode->GetObjTMAfterWSM(t);
	Box3 pbox;
	cnode=inode;
	int type,ptype,disptype;
	pblock->GetValue(PB_VIEWPORTSHOWS,0,type,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,disptype,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	if ((type==2)&&((ptype==RENDTYPE5)||(ptype==RENDTYPE6)||((disptype==INSTGEOM)&&(!custnode))||((disptype==BYGEOM)&&(!distnode))))
		type=1;
	if ((type==3)&&((disptype==INSTGEOM)||(disptype==BYGEOM)))
		{if (disptype==INSTGEOM?!custnode:!distnode) type=1;}
	else if (type==3) type=1;
	if (disptype!=METABALLS) UpdateMesh(t);
	box  = mesh.getBoundingBox();
	pbox = parts.BoundBox();
	if (type==2) 
	{ if (disptype==BYGEOM)
	  {	for (int i=0; i<parts.points.Count(); i++)
		{ if (!parts.Alive(i)) {continue;	}
		  int frommesh=(sdata[i].gennum>0?sdata[i].frommesh:i);
	      int vpts=pmesh[frommesh].getNumVerts();
		  float elapsedtime=(float)parts.ages[i];
		  float Angle=sdata[i].LamTs;
		  Point3 pt = parts.points[i],nextpt;
		  pbox += pt;
		  for (int j=0;j<vpts;j++)
		  {nextpt=parts.radius[i]*pmesh[frommesh].verts[j]+parts.points[i];
		   RotateOnePoint(&nextpt.x,&parts.points[i].x,&(sdata[i].W.x),Angle);
		   pbox +=nextpt;
	   	  }
		}
	  }
	else 
	  {	for (int i=0; i<parts.points.Count(); i++) {
			if (!parts.Alive(i)) {continue;	}
			Point3 pt = parts.points[i];
			float r=parts.radius[i];
			int axisentered,K;
			pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
			if (axisentered==DIRTRAVEL)
			{ pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			  float len=GetLen(parts.vels[i],K);
			  r*=len;
			}
			if ((disptype==INSTGEOM)&&(custnode))
			{ int tlst=times.tl.Count();if (tlst==0) tlst=1;
			  pbox += pt;
			  for (int level=0;level<tlst;level++)
			  {	Box3 cbb=cmbb[level];  
			    Point3 dist=cbb.pmax-cbb.pmin;
				float pdist=Largest(dist)*r*SQR2;
			  pbox += pt + Point3( pdist, 0.0f, 0.0f);
			  pbox += pt + Point3(-pdist, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, pdist, 0.0f);
			  pbox += pt + Point3( 0.0f,-pdist, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, pdist);
			  pbox += pt + Point3( 0.0f, 0.0f,-pdist);
			  }
			}
			else
			{ if (ptype==RENDTET) r*=8.0f;
			  pbox += pt;
			  pbox += pt + Point3( r, 0.0f, 0.0f);
			  pbox += pt + Point3(-r, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, r, 0.0f);
			  pbox += pt + Point3( 0.0f,-r, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, r);
			  pbox += pt + Point3( 0.0f, 0.0f,-r);
			}
		}
	  }
	}
	else if (type==3) 
	{	for (int i=0; i<parts.points.Count(); i++) {
			if (!parts.Alive(i)) {continue;	}
			Point3 pt;
			float radius=parts.radius[i];
				int axisentered,K;
			    pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
				if (axisentered==DIRTRAVEL)
				{ pblock->GetValue(PB_STRETCH,t,K,FOREVER);
				  float len=GetLen(parts.vels[i],K);
				  radius*=len;
				}
			int n=0,found=0;;
		int nCount=nlist.Count();
		if ((disptype==INSTGEOM)||((sdata[i].gennum>0)&&(nCount>0)))
		{ TimeValue Ctime=(thePArrayDraw.anioff?GetCurTime(sdata[i].showframe,(thePArrayDraw.anioff>1?thePArrayDraw.t:parts.ages[i]),thePArrayDraw.anifr):thePArrayDraw.t);
		  found=((n=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum)))>-1);
		}
		if (!found) 
		{ if (sdata[i].gennum==0) radius=1.0f; 
		  for (int j=0;j<8;j++)
			{ pt=radius*sdata[i].wbb[j]+parts[i];
			  pbox += pt;
			}
		}
		else
		{ for (int nb=0;nb<thePArrayDraw.bboxpt[n].numboxes;nb++)
		    for (int j=0;j<8;j++)
			{ pt=(radius*(thePArrayDraw.bboxpt[n].bpts[nb].pts[j]+thePArrayDraw.bboxpt[n].bpts[nb].Suboffset))+parts[i];
			  pbox += pt;
			}
		}
		}
	  }
	if (!pbox.IsEmpty()) box += pbox * Inverse(mat);
}

void PArrayParticle::GetWorldBoundBox(
		TimeValue t, INode *inode, ViewExp* vpt, Box3& box)
{	cnode=inode;
	int type,ptype,disptype;
	pblock->GetValue(PB_VIEWPORTSHOWS,0,type,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,disptype,FOREVER);
	pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
	if ((type==2)&&((ptype==RENDTYPE5)||(ptype==RENDTYPE6)||((disptype==INSTGEOM)&&(!custnode))||((disptype==BYGEOM)&&(!distnode))))
		type=1;
	if ((type==3)&&((disptype==INSTGEOM)||(disptype==BYGEOM)))
		{if (disptype==INSTGEOM?!custnode:!distnode) type=1;}
	else if (type==3) type=1;
	if (type==2) 
	{ if (disptype==BYGEOM)
	  {	Box3 pbox;
		Matrix3 mat =inode->GetObjTMBeforeWSM(t);	
		UpdateMesh(t);
		box  = mesh.getBoundingBox();
		box  = box * mat;
		for (int i=0; i<parts.points.Count(); i++)
		{ if (!parts.Alive(i)) {continue;	}
		  int frommesh=(sdata[i].gennum>0?sdata[i].frommesh:i);
	      int vpts=pmesh[frommesh].getNumVerts();
		  float elapsedtime=(float)parts.ages[i];
		  float Angle=sdata[i].LamTs;
		  Point3 pt = parts.points[i],nextpt;
		  pbox += pt;
		  for (int j=0;j<vpts;j++)
		  {nextpt=parts.radius[i]*pmesh[frommesh].verts[j]+parts.points[i];
		   RotateOnePoint(&nextpt.x,&parts.points[i].x,&(sdata[i].W.x),Angle);
		   pbox +=nextpt;
	   	  }
		}
		if (!pbox.IsEmpty()) box += pbox;
	  }
	else 
	  { Box3 pbox;
		Matrix3 mat = inode->GetObjTMBeforeWSM(t);
		if (disptype!=METABALLS) UpdateMesh(t);
		box  = mesh.getBoundingBox();
		box  = box * mat;
		for (int i=0; i<parts.points.Count(); i++) {
			if (!parts.Alive(i)) {continue;	}
			Point3 pt = parts.points[i];
			float r=parts.radius[i];
			int axisentered,K;
			pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
			if (axisentered==DIRTRAVEL)
			{ pblock->GetValue(PB_STRETCH,t,K,FOREVER);
			  float len=GetLen(parts.vels[i],K);
			  r*=len;
			}
			if ((disptype==INSTGEOM)&&(custnode))
			{ int tlst=times.tl.Count();if (tlst==0) tlst=1;
			  pbox += pt;
			  for (int level=0;level<tlst;level++)
			  {	Box3 cbb=cmbb[level];  
			    Point3 dist=cbb.pmax-cbb.pmin;
				float pdist=Largest(dist)*r*SQR2;
			  pbox += pt + Point3( pdist, 0.0f, 0.0f);
			  pbox += pt + Point3(-pdist, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, pdist, 0.0f);
			  pbox += pt + Point3( 0.0f,-pdist, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, pdist);
			  pbox += pt + Point3( 0.0f, 0.0f,-pdist);
			  }
			}
			else
			{ if (ptype==RENDTET) r*=8.0f;
			  pbox += pt;
			  pbox += pt + Point3( r, 0.0f, 0.0f);
			  pbox += pt + Point3(-r, 0.0f, 0.0f);
			  pbox += pt + Point3( 0.0f, r, 0.0f);
			  pbox += pt + Point3( 0.0f,-r, 0.0f);
			  pbox += pt + Point3( 0.0f, 0.0f, r);
			  pbox += pt + Point3( 0.0f, 0.0f,-r);
			}
		}
		if (!pbox.IsEmpty()) box += pbox;
	  }
	}
	else if (type==3) 
	{ Box3 pbox;
		Matrix3 mat = inode->GetObjTMBeforeWSM(t);
		if (disptype!=METABALLS) UpdateMesh(t);
		box  = mesh.getBoundingBox();
		box  = box * mat;
		for (int i=0; i<parts.points.Count(); i++) {
			if (!parts.Alive(i)) {continue;	}
			Point3 pt;
			float radius=parts.radius[i];
				int axisentered,K;
			    pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
				if (axisentered==DIRTRAVEL)
				{ pblock->GetValue(PB_STRETCH,t,K,FOREVER);
				  float len=GetLen(parts.vels[i],K);
				  radius*=len;
				}
			int n=0,found=0;;
		int nCount=nlist.Count();
		if ((disptype==INSTGEOM)||((sdata[i].gennum>0)&&(nCount>0)))
		{ TimeValue Ctime=(thePArrayDraw.anioff?GetCurTime(sdata[i].showframe,(thePArrayDraw.anioff>1?thePArrayDraw.t:parts.ages[i]),thePArrayDraw.anifr):thePArrayDraw.t);
		  found=((n=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum)))>-1);
		}
		if (!found) 
		{ if (sdata[i].gennum==0) radius=1.0f; 
		  for (int j=0;j<8;j++)
			{ pt=radius*sdata[i].wbb[j]+parts[i];
			  pbox += pt;
			}
		}
		else
		{ for (int nb=0;nb<thePArrayDraw.bboxpt[n].numboxes;nb++)
		    for (int j=0;j<8;j++)
			{ pt=(radius*(thePArrayDraw.bboxpt[n].bpts[nb].pts[j]+thePArrayDraw.bboxpt[n].bpts[nb].Suboffset))+parts[i];
			  pbox += pt;
			}
		}
		}
		if (!pbox.IsEmpty()) box += pbox;
	  }
 else {SimpleParticle::GetWorldBoundBox(t,inode,vpt,box);}
	}

int GetDrawType(PArrayParticle *po, int &ptype,int &disptype)
{ int type;
  po->pblock->GetValue(PB_VIEWPORTSHOWS,0,type,FOREVER);
  po->pblock->GetValue(PB_PARTICLECLASS,0,disptype,FOREVER);
  po->pblock->GetValue(PB_PARTICLETYPE,0,ptype,FOREVER);
  TimeValue aniend;
  if ((type==2)&&((ptype==RENDTYPE5)||(ptype==RENDTYPE6)||((disptype==INSTGEOM)&&(!po->custnode))||((disptype==BYGEOM)&&(!po->distnode))))
		type=1;
  if ((type==3)&&((disptype==INSTGEOM)||(disptype=BYGEOM)))
  {if (disptype==INSTGEOM?!po->custnode:!po->distnode) type=1;}
  else if (type==3) type=1;
  if (type>1)
  { aniend=GetAnimEnd();
	int oneframe=GetTicksPerFrame();
    po->thePArrayDraw.anifr=aniend+oneframe;
	int axisentered;
	po->pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	if (po->thePArrayDraw.indir.inaxis=(axisentered==1))
	{ po->pblock->GetValue(PB_STRETCH,0,po->thePArrayDraw.indir.K,FOREVER);
	  po->thePArrayDraw.indir.oneframe=oneframe;
	}
  }
  return type;
}


/*BOOL PArrayParticleDraw::DrawParticle(
		GraphicsWindow *gw,ParticleSys &parts,int i)
{ HCURSOR hCur;
  BOOL chcur=FALSE;
  if (disptype==BYGEOM)
 { Point3 pt[4],tmp[2];
   BOOL bail=FALSE;
  float elapsedtime=(float)parts.ages[i];
  float Angle=(FloatEQ0(obj->sdata[i].Ts)?0.0f:elapsedtime/obj->sdata[i].Ts)+obj->sdata[i].LamTs;
  int vpts=obj->pmesh[i].getNumVerts(),nf=obj->pmesh[i].getNumFaces();
  Point3 *rlst=new Point3[vpts],nextpt;
  if (nf>LOTSOFACES)
  {  hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
     chcur=TRUE;
  }
  for (int j=0;j<vpts;j++)
  {	nextpt=obj->pmesh[i].verts[j]+parts.points[i];
	RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
    rlst[j]=nextpt;
	if (GetAsyncKeyState (VK_ESCAPE)) {bail=TRUE;goto done;}
  }
  for (j=0;j<nf;j++)
  {	pt[0]=rlst[obj->pmesh[i].faces[j].v[0]];
	pt[1]=rlst[obj->pmesh[i].faces[j].v[1]];
	pt[2]=rlst[obj->pmesh[i].faces[j].v[2]];
  if ((obj->pmesh[i].faces[j].flags & EDGE_A)>0)
    { tmp[0]=pt[0];tmp[1]=pt[1];gw->polyline(2,tmp,NULL,NULL,FALSE,NULL);}
  if ((obj->pmesh[i].faces[j].flags & EDGE_B)>0)
    { tmp[0]=pt[1];tmp[1]=pt[2];gw->polyline(2,tmp,NULL,NULL,FALSE,NULL);}
  if ((obj->pmesh[i].faces[j].flags & EDGE_C)>0)
    { tmp[0]=pt[2];tmp[1]=pt[0];gw->polyline(2,tmp,NULL,NULL,FALSE,NULL);}
  if (GetAsyncKeyState (VK_ESCAPE)) {bail= TRUE;goto done;}
  }
done:
  if (rlst) delete[] rlst;
  if (chcur) SetCursor(hCur);
  return bail;
}
else if (disptype==METABALLS)
{ if (firstpart)
  { Point3 pt[4]; 
    int nfaces=obj->metamesh->getNumFaces();
    if (nfaces>LOTSOFACES)
	{ hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	  chcur=TRUE;
	}
    for (int j=0;j<nfaces;j++)
    { pt[0]=obj->metamesh->verts[obj->metamesh->faces[j].v[0]];
      pt[1]=obj->metamesh->verts[obj->metamesh->faces[j].v[1]];
	  pt[2]=obj->metamesh->verts[obj->metamesh->faces[j].v[2]];
      gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
	  if (GetAsyncKeyState (VK_ESCAPE)) 
	  { if (chcur) SetCursor(hCur);	return TRUE;}
    }
    firstpart=FALSE;
  }
}
else if (disptype==INSTGEOM)
{ Point3 pt[4];  
 if (obj->custnode)
  { int n=0,found=0;
    TimeValue Ctime=(anioff?GetCurTime(obj->sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
	found=((n=TimeFound(obj->times,Ctime,(obj->sdata[i].gennum>obj->nCount?obj->nCount:obj->sdata[i].gennum)))>-1);
	float radius=parts.radius[i];
	float elapsedtime=(float)parts.ages[i];
    float Angle=(FloatEQ0(obj->sdata[i].Ts)?0.0f:elapsedtime/obj->sdata[i].Ts)+obj->sdata[i].LamTs;
	if (indir.inaxis)
	  indir.vel=parts.vels[i];
	Point3 nextpt;
	if (found) 
	{
	if (bb)
    { Point3 pt[9];
	  for (int nb=0;nb<bboxpt[n].numboxes;nb++)
	  { for (int j=0;j<8;j++)
	    {if (indir.inaxis)
	       pt[j]=RotateAboutAxis(Angle,parts.points[i],radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset),obj->sdata[i].W,indir);
	     else
		 { nextpt=(radius*(bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset))+parts[i];
		   RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		   pt[j]=nextpt;
		 }
	    }
	    gw->polyline(4,pt,NULL,NULL,TRUE,NULL);
		Point3 tmppt[5]; for (int k=0;k<4;k++) tmppt[k]=pt[4+k];
		gw->polyline(4,tmppt,NULL,NULL,TRUE,NULL);
		tmppt[0]=pt[0];tmppt[1]=pt[4];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[1];tmppt[1]=pt[5];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[2];tmppt[1]=pt[6];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[3];tmppt[1]=pt[7];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		if (GetAsyncKeyState (VK_ESCAPE))  { return TRUE;}
	  }
	}
    else
    { Mesh *mp;
	  mp=&obj->cmesh[n];
	  int nfaces=mp->getNumFaces();
	  if (nfaces>LOTSOFACES)
	  {  hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
		 chcur=TRUE;
	  }
		for (int j=0;j<nfaces;j++)
		{ for (int pnum=0;pnum<3;pnum++)
		{if (indir.inaxis)
	    pt[pnum]=RotateAboutAxis(Angle,parts.points[i],radius*(mp->verts[mp->faces[j].v[pnum]]),obj->sdata[i].W,indir);
		else
		  { nextpt=(radius*(mp->verts[mp->faces[j].v[pnum]]))+parts[i];
		    RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		    pt[pnum]=nextpt;
		  }}
		  gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
		  if (GetAsyncKeyState (VK_ESCAPE))  
		  { if (chcur) SetCursor(hCur);	return TRUE;}
		}
	}
	}
  }
}
else
{  Mesh *pm = new Mesh;
    Point3 pt[4];  
	int numF,numV;	
    GetMeshInfo(ptype,1,pm,&numF,&numV);
    float elapsedtime=(float)obj->parts.ages[i];
    float Angle=(FloatEQ0(obj->sdata[i].Ts)?0.0f:elapsedtime/obj->sdata[i].Ts)+obj->sdata[i].LamTs;
	if (indir.inaxis) indir.vel=parts.vels[i];
	if (ptype==RENDTYPE1) PlotTriangle(obj->parts.radius[i],0,0,pm,Angle,&obj->sdata[i].W.x,0,&obj->parts.points[i],indir);
	else if (ptype==RENDTYPE2) PlotCube8(obj->parts.radius[i],0,0,pm,Angle,&obj->sdata[i].W.x,0,&obj->parts.points[i],indir);
	else if (ptype==RENDTYPE3) PlotSpecial(obj->parts.radius[i],0,0,pm,Angle,&obj->sdata[i].W.x,0,&obj->parts.points[i],indir);
	else if (ptype==RENDTET) PlotTet(obj->parts.radius[i],0,0,pm,Angle,obj->sdata[i].W,0,&obj->parts.points[i],indir);
	else if (ptype==REND6PT) Plot6PT(obj->parts.radius[i],0,0,pm,Angle,&obj->sdata[i].W.x,0,&obj->parts.points[i],indir);
	int nfaces=pm->getNumFaces();
	if (nfaces>LOTSOFACES)
	{  hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	   chcur=TRUE;
	}
   for (int j=0;j<nfaces;j++)
    { pt[0]=pm->verts[pm->faces[j].v[0]];
      pt[1]=pm->verts[pm->faces[j].v[1]];
	  pt[2]=pm->verts[pm->faces[j].v[2]];
      gw->polyline(3,pt,NULL,NULL,TRUE,NULL);
    }
  if (pm) delete pm;
  if (GetAsyncKeyState (VK_ESCAPE)) 
  { if (chcur) SetCursor(hCur);	return TRUE;}
}
return 0;
}*/	

BOOL PArrayParticleDraw::DrawParticle(
		GraphicsWindow *gw,ParticleSys &parts,int i)
{ HCURSOR hCur;
  BOOL chcur=FALSE;
  if (!(((disptype==INSTGEOM)||(disptype==BYGEOM))&&(bb))) return TRUE;
  Point3 pt[4];
  INode *onode=(disptype==BYGEOM?obj->distnode:obj->custnode);
  if (onode)
  { int n=0,found=0;
    int nCount=obj->nlist.Count();
    if ((disptype==INSTGEOM)||((obj->sdata[i].gennum>0)&&(nCount>0)))
    { TimeValue Ctime=(anioff?GetCurTime(obj->sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
	  found=((n=TimeFound(obj->times,Ctime,(obj->sdata[i].gennum>nCount?nCount:obj->sdata[i].gennum)))>-1);
	}
	float radius=parts.radius[i];
	float elapsedtime=(float)parts.ages[i];
    float Angle=obj->sdata[i].LamTs;
	if (indir.inaxis)
	  indir.vel=parts.vels[i];
	Point3 nextpt;BOOL usepmesh=FALSE;
	int numbox=(usepmesh=((!found)&&(disptype==BYGEOM))?1:bboxpt[n].numboxes);
	if ((disptype==BYGEOM)&&(obj->sdata[i].gennum==0)) radius=1.0f;
	if (found ||(disptype==BYGEOM)) 
	{ Point3 pt[9];
	  if (numbox*8>LOTSOFACES)
	  { hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	    chcur=TRUE;
	  }
	  for (int nb=0;nb<numbox;nb++)
	  { for (int j=0;j<8;j++)
	  { Point3 boxpt=radius*(found?bboxpt[n].bpts[nb].pts[j]+bboxpt[n].bpts[nb].Suboffset:obj->sdata[i].wbb[j]);
		  if (indir.inaxis)
	       pt[j]=RotateAboutAxis(Angle,parts.points[i],boxpt,obj->sdata[i].W,indir);
	     else
		 { nextpt=boxpt+parts[i];
		   RotateOnePoint(&nextpt.x,&parts.points[i].x,&(obj->sdata[i].W.x),Angle);
		   pt[j]=nextpt;
		 }
	    }
	    gw->polyline(4,pt,NULL,NULL,TRUE,NULL);
		Point3 tmppt[5]; for (int k=0;k<4;k++) tmppt[k]=pt[4+k];
		gw->polyline(4,tmppt,NULL,NULL,TRUE,NULL);
		tmppt[0]=pt[0];tmppt[1]=pt[4];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[1];tmppt[1]=pt[5];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[2];tmppt[1]=pt[6];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		tmppt[0]=pt[3];tmppt[1]=pt[7];
		gw->polyline(2,tmppt,NULL,NULL,FALSE,NULL);
		if (GetAsyncKeyState (VK_ESCAPE))  { return TRUE;}
	  }
	}
  }
  if (GetAsyncKeyState (VK_ESCAPE)) 
  { if (chcur) SetCursor(hCur);	return TRUE;}
return 0;
}

MarkerType PArrayParticle::GetMarkerType() 
{ int ptype,disptype,type=GetDrawType(this,ptype,disptype);
	switch (type) {
		case 0:
			parts.SetCustomDraw(NULL);
			return POINT_MRKR;			
		case 1:
			parts.SetCustomDraw(NULL);
			return PLUS_SIGN_MRKR;
		case 2:	{			
			parts.SetCustomDraw(NULL);
			return POINT_MRKR;
			}	 
		case 3:{thePArrayDraw.obj = this;
			thePArrayDraw.firstpart=TRUE;
			thePArrayDraw.disptype=disptype;
			thePArrayDraw.ptype=ptype;
			thePArrayDraw.bb=TRUE;
			parts.SetCustomDraw(&thePArrayDraw);			
			return POINT_MRKR;
		   }
		default:
			return PLUS_SIGN_MRKR;
		}
	}



//--- PArray particle -----------------------------------------------

RefTargetHandle PArrayParticle::Clone(RemapDir& remap) 
	{
	PArrayParticle* newob = new PArrayParticle();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	if (distnode) newob->ReplaceReference(DISTNODE,distnode);
	newob->custname = custname;
	newob->distname = distname;
	newob->mvalid.SetEmpty();	
	newob->tvalid = FALSE;
	newob->nlist.SetCount(nlist.Count());
	newob->llist.SetCount(llist.Count());
	for (int ix=0;ix<nlist.Count();ix++) 
	{ newob->nlist[ix]=NULL;
	  newob->ReplaceReference(ix+BASER,nlist[ix]);
	}
	for (ix=0;ix<llist.Count();ix++) newob->llist[ix]=llist[ix];
	newob->dflags=dflags;
	newob->dispmesh=NULL;
	newob->times.tl.SetCount(0);
	newob->nmtls.ZeroCount();
	newob->cancelled=FALSE;
	newob->wasmulti=FALSE;
	newob->stepSize=stepSize;
	int vshow;
	pblock->GetValue(PB_VIEWPORTSHOWS,0,vshow,FOREVER);
	if (vshow>1)
	{int subtree,anioff,custmtl;
	 pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	 pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	 TimeValue aniend=GetAnimEnd();
	 int anifr=aniend+GetTicksPerFrame();
	 TimeValue t=GetCOREInterface()->GetTime();
	 newob->GetTimes(newob->times,t,anifr,anioff,fragflags);
	 if (vshow==2)
	 { pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
	   newob->GetMesh(t,subtree,custmtl,fragflags);
	 }
	 else newob->GetallBB(custnode,subtree,t,fragflags);
	}
	return newob;
	}

static float findmappos(float curpos)
{ float mappos;

  return(mappos=((mappos=curpos)<0?0:(mappos>1?1:mappos)));
}


void PArrayParticle::RendGeom(Mesh *pm,Matrix3 itm,int maxmtl,int maptype,int emitmtl,float mval,PArrayParticleDraw thePArrayDraw,TVFace defface,BOOL notrend)
{ float elapsedtime,Angle,Uval=0.5f,Wval=0.5f,Vval=0.0f;
  Point3 nextpt;
  int vertexnum=0,tvcnt=0,fn,face=0,dtvs=pm->getNumTVerts(),ctvs=0;
  if (emitmtl==2) ctvs=cmesh[0].getNumTVerts();
  TimeValue t=thePArrayDraw.t;int anifr=thePArrayDraw.anifr,anioff=thePArrayDraw.anioff;
  MtlID mid=0;
  for (int i=0; i<parts.Count(); i++) 
  { if ((notrend)&&(GetAsyncKeyState (VK_ESCAPE)) ) 
		{ ZeroMesh(pm);cancelled=TRUE;return;}
	if (!parts.Alive(i)) continue;
    elapsedtime=(float)parts.ages[i];
	TVFace parttv(tvcnt,tvcnt,tvcnt);
	int mnum=-1;TimeValue Ctime;int nCount=nlist.Count();
	if ((sdata[i].gennum>0)&&(nCount>0))
	{ Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
	  mnum=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum));
	} 
	if (emitmtl==0)
	{ if (maxmtl) 
		{ mid=sdata[i].themtl;
	      if (mid>=maxmtl) 
		    mid =mid % maxmtl;
	    } else mid=i;
		if (maptype) Vval=Length(parts[i]-sdata[i].start)/mval;
		else Vval=(float)elapsedtime/mval;
		pm->tVerts[tvcnt]=Point3(findmappos(Uval),findmappos(Vval),findmappos(Wval));
		tvcnt++;
	}
	Angle=sdata[i].LamTs;
	int frommesh=(sdata[i].gennum>0?sdata[i].frommesh:i);
	int maxf,numv;
	if (mnum<0) {maxf=pmesh[frommesh].getNumFaces();numv=pmesh[frommesh].getNumVerts();}
	else {maxf=cmesh[mnum].getNumFaces();numv=cmesh[mnum].getNumVerts();}
	for (fn=0;fn<maxf;fn++)
	{ Face f=(mnum<0?pmesh[frommesh].faces[fn]:cmesh[mnum].faces[fn]);
	pm->faces[face].setSmGroup(f.getSmGroup());
	if (emitmtl==0) {pm->tvFace[face]=parttv;pm->faces[face].setMatID(mid);}
	else 
	{ if (dtvs) pm->tvFace[face]=(emitmtl==1?pmesh[frommesh].tvFace[mnum<0?fn:0]:(mnum<0?(ctvs?defface:pmesh[frommesh].tvFace[fn]):(ctvs?cmesh[mnum].tvFace[fn]:defface)  ));
	MtlID mid;
	  if (mnum<0) mid=pmesh[frommesh].faces[fn].getMatID();
	  else 
	  { if (emitmtl==1) mid=pmesh[frommesh].faces[0].getMatID();
		else 
		{ mid=cmesh[mnum].faces[fn].getMatID();
			 int mtlgen=times.tl[mnum].gennum-1,maxmtl=nmtls.Count();
			 if (mtlgen>=maxmtl) mtlgen=maxmtl-1;
			 if ((mtlgen>-1)&&((times.tl.Count()>0)&&(times.tl[mnum].gennum>0)))
			  mid+=nmtls[mtlgen];
		}
	  }
	  if (maxmtl>0)
	  { if (mid<((emitmtl<2)||(sdata[i].gennum>0)?maxmtl:nmtls[0]))
		  pm->faces[face].setMatID(mid);
		 else pm->faces[face].setMatID(0);
	  }else pm->faces[face].setMatID(i);
	}
	 pm->faces[face].setEdgeVisFlags(f.getEdgeVis(0),f.getEdgeVis(1),f.getEdgeVis(2));
	 pm->faces[face++].setVerts(f.v[0]+vertexnum,f.v[1]+vertexnum,f.v[2]+vertexnum);
	}
	float radius=(sdata[i].gennum>0?parts.radius[i]:1.0f);
    for (int j=0;j<numv;j++)
    { nextpt=parts.radius[i]*(mnum<0?pmesh[frommesh].verts[j]:cmesh[mnum].verts[j])+parts[i];
      RotateOnePoint(&nextpt.x,&parts.points[i].x,&sdata[i].W.x,Angle);
      pm->verts[vertexnum++]=itm*nextpt;
	}
  }
}
void CacheSpin(float *holddata,SavePt *sdata,int pcount,BOOL issave)
{ for (int i=0;i<pcount;i++)
	if (issave) holddata[i]=sdata[i].LamTs;
	else sdata[i].LamTs=holddata[i];
}

Mesh *PArrayParticle::GetRenderMesh(TimeValue t, INode *inode, View& view, BOOL& needDelete)
{	float Mval, Uval, Vval,Wval,Angle,elapsedtime;
	int type, count,maptype,anifr;
	float width;
	TVFace defface;
	BOOL mirror=FALSE;
	Mesh *pm = new Mesh;
	if (cancelled) 
	{ZeroMesh(pm);mesh.InvalidateGeomCache();
	needDelete = TRUE;return pm;}
	TimeValue mt,aniend=GetAnimEnd();
	int isrend=!TestAFlag(A_NOTREND);
	if (!isrend) dispt=t;
    anifr=aniend+GetTicksPerFrame();
	int nummtls=0,curmtl=0,multi=0,custmtl,pc=0;
	pblock->GetValue(PB_PARTICLETYPE,0,type,FOREVER);
	pblock->GetValue(PB_PARTICLECLASS,0,pc,FOREVER);
	if (pc==BYGEOM) type=(distnode?RENDGEOM:0);
	else if (pc==METABALLS) type=RENDMETA;
	else if (pc==INSTGEOM) type=(custnode?RENDCGEOM:0);
	if (type==0) pc=ISSTD;
	float FperT=GetFrameRate()/(float)TIME_TICKSPERSEC;
	pblock->GetValue(PB_EMITRWID,t,width,FOREVER);
	pblock->GetValue(PB_MAPPINGTYPE,0,maptype,FOREVER);
	pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
	if (maptype)
	 pblock->GetValue(PB_MAPPINGDIST,t,Mval,FOREVER);
	else 
	 pblock->GetValue(PB_MAPPINGTIME,t,mt,FOREVER);

	if ((!isrend)&&((type==RENDTYPE5)||(type==RENDTYPE6))) type=RENDTYPE1;
	Matrix3 wcam,cam=ident;
	Point3 v, v0,v1, otherV=Zero,camV=Zero;
	if (isrend)
	{ cam= Inverse(wcam=view.worldToView);
	otherV=cam.GetRow(2),camV = cam.GetRow(3);}
	Matrix3 tm = inode->GetObjTMAfterWSM(t);
	Matrix3 itm = Inverse(tm);
	int vertexnum=0, face=0,numV=0,numF=0,j=0,tvnum=0,ismapped=0;

	ParticleSys lastparts;
	TimeValue offtime=t%GetTicksPerFrame();
	BOOL midframe;
	midframe=offtime>0;
	float *holddata=NULL;int pcount=0;
	if (isrend)
	{if (midframe) 
	{ Update(t-offtime,inode);
	  if ((pcount=parts.Count())>0)
	  { CacheData(&parts,&lastparts);
	    holddata=new float[pcount];
        CacheSpin(holddata,sdata,pcount,TRUE);
	  }
	}
	 Update(t,inode);
	}
	count = CountLive();
	Point3 r1;
	float Thetah;
	if (count==0) ZeroMesh(pm);
	else 
	{mirror=DotProd(tm.GetRow(0)^tm.GetRow(1),tm.GetRow(2))<0.0f;
	 Mtl *mtl;
	mtl=inode->GetMtl();
	BOOL txtfound=FALSE;
    if (mtl)
	{ Class_ID mc=Class_ID(MULTI_CLASS_ID,0);
	  Class_ID oc=mtl->ClassID();
	  if (multi=(oc==mc))
	  { nummtls=mtl->NumSubMtls();if (nummtls==0) multi=0;}
    }
	wasmulti=multi;
	if (type==RENDTYPE6)
	  { if (view.projType) type=RENDTYPE5;
	    else
	    { Thetah=view.fov;
	      r1=cam.GetRow(1);
	    }
	  }
	int gtvnum=0,anioff=0;
	if (pc==0) GetMeshInfo(type,count,pm,&numF,&numV);
	else if (type==RENDGEOM)
	{/* int nv=0,nf=0,ntv=0;
      for (int tmp=0; tmp<parts.Count(); tmp++) 
	  { if (GetAsyncKeyState (VK_ESCAPE)) 
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		if (!parts.Alive(tmp)) continue;
	    nv+=pmesh[tmp].getNumVerts();
		nf+=pmesh[tmp].getNumFaces();
	  }
	  pm->setNumVerts(nv);
	  pm->setNumFaces(nf);
	  BOOL dotxt=((doTVs)||(!custmtl));
	  if ((count>0)&&(dotxt))
	  { if (doTVs) pm->setNumTVerts(oldtvnum);
	    else pm->setNumTVerts(count);
	  }
	  else pm->setNumTVerts(0);
	  if ((count>0)&&(dotxt)) 
	  {  pm->setNumTVFaces(nf);
	     if (doTVs)
		 { for (tmp=0;tmp<oldtvnum;tmp++)
		   { pm->tVerts[tmp]=pmesh[0].tVerts[tmp];}
		 }
	  }
	  else pm->setNumTVFaces(0);*/
	int subtree,onscreen;
	  pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	  pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	  thePArrayDraw.t=t;
	  GetTimes(times,t,anifr,anioff,pc);
	  GetMesh(t,subtree,custmtl,pc);
	  TimeValue Ctime;
	  int mnum,tmptvs=0;
	  numV=0;numF=0;
	  BOOL alltex=TRUE;int distemit=0,dtvs=pmesh[0].getNumTVerts();
	  for (int pcnt=0;pcnt<parts.Count();pcnt++)
	  { if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) ) 
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		if (!parts.Alive(pcnt)) continue;mnum=-1;
		int nCount=nlist.Count();
		if ((sdata[pcnt].gennum>0)&&(nCount>0))
		{ Ctime=(anioff?GetCurTime(sdata[pcnt].showframe,(anioff>1?t:parts.ages[pcnt]),anifr):t);
		  mnum=TimeFound(times,Ctime,(sdata[pcnt].gennum>nCount?nCount:sdata[pcnt].gennum));
		} 
		if (mnum<0)
		{ int frommesh=(sdata[pcnt].gennum>0?sdata[pcnt].frommesh:pcnt);
		  numV+=pmesh[frommesh].getNumVerts();
		  numF+=pmesh[frommesh].getNumFaces();
		  distemit++;
		}
		else
		{ numV+=cmesh[mnum].getNumVerts();
		  numF+=cmesh[mnum].getNumFaces();
		}
	  }
	  pm->setNumFaces(numF);
	  pm->setNumVerts(numV);
	  int mcnt=0;
      if (!custmtl) gtvnum=count;
	  else if (custmtl==1) gtvnum=dtvs;
	  else
	  {	mcnt=times.tl.Count();if (mcnt==0) mcnt=1;
	    if (distemit) 
		{ if (dtvs==0) alltex=FALSE;
		  else gtvnum+=dtvs;
		}
		for (int mc=0;mc<mcnt;mc++)
		{ tmptvs=cmesh[mc].getNumTVerts();
		  if (tmptvs==0) alltex=FALSE;
		  else gtvnum+=tmptvs;
		}
        if ((!alltex)&&(gtvnum>0))
		{ defface.setTVerts(gtvnum,gtvnum,gtvnum);gtvnum++;}
	  }
	  int gtv,tvs=0;
	  pm->setNumTVerts(gtv=gtvnum);
	  if ((custmtl)&&(gtvnum>0))	     
		for (int imtv=0;imtv<dtvs;imtv++) pm->tVerts[tvs++]=pmesh[0].tVerts[imtv];
	  if ((custmtl==2)&&(gtvnum>0))
	  { int mtvs=0,imtv;
		 for (int mc=0;mc<mcnt;mc++)
	     { mtvs=cmesh[mc].getNumTVerts();
		   if (mtvs>0)
		   { for (imtv=0;imtv<mtvs;imtv++)
			   pm->tVerts[tvs++]=cmesh[mc].tVerts[imtv];
		   } 
		 }
		 if (!alltex) pm->tVerts[tvs]=deftex;
	  }
	  pm->setNumTVFaces(gtv>0?numF:0);
	}
	else if (type==RENDCGEOM)
	{int subtree,onscreen;
	  pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
	  pblock->GetValue(PB_VIEWPORTSHOWS,0,onscreen,FOREVER);
	  pblock->GetValue(PB_ANIMATIONOFFSET,0,anioff,FOREVER);
	  thePArrayDraw.t=t;
	  GetTimes(times,t,anifr,anioff,pc);
	  GetMesh(t,subtree,custmtl,pc);
	  TimeValue Ctime;
	  int mnum,tmptvs=0;
	  numV=0;numF=0;
	  BOOL alltex=TRUE;
	  for (int pcnt=0;pcnt<parts.Count();pcnt++)
	  { if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
		if (!parts.Alive(pcnt)) continue;
		Ctime=(anioff?GetCurTime(sdata[pcnt].showframe,(anioff>1?t:parts.ages[pcnt]),anifr):t);
		int nCount=nlist.Count();
		mnum=TimeFound(times,Ctime,(sdata[pcnt].gennum>nCount?nCount:sdata[pcnt].gennum));
		numV+=cmesh[mnum].getNumVerts();
		numF+=cmesh[mnum].getNumFaces();
	  }
	  pm->setNumFaces(numF);
	  pm->setNumVerts(numV);
	  int mcnt=0;
      if (!custmtl) gtvnum=count;
	  else if (custmtl==1) gtvnum=((doTVs)?count:0);
	  else
	  {	mcnt=times.tl.Count();if (mcnt==0) mcnt=1;
		for (int mc=0;mc<mcnt;mc++)
		{ tmptvs=cmesh[mc].getNumTVerts();
		  if (tmptvs==0) alltex=FALSE;
		  else gtvnum+=tmptvs;
		}
        if ((!alltex)&&(gtvnum>0))
		{ defface.setTVerts(gtvnum,gtvnum,gtvnum);gtvnum++;}
	  }
	  int gtv;
	  pm->setNumTVerts(gtv=gtvnum);
	  if ((custmtl==2)&&(gtvnum>0))
	  { int tvs=0,mtvs=0,imtv;
		 for (int mc=0;mc<mcnt;mc++)
	     { mtvs=cmesh[mc].getNumTVerts();
		   if (mtvs>0)
		   { for (imtv=0;imtv<mtvs;imtv++)
			   pm->tVerts[tvs++]=cmesh[mc].tVerts[imtv];
		   } 
		 }
		 if (!alltex) pm->tVerts[tvs]=deftex;
	  }
	  else if (custmtl==1) 
	  { pm->setNumTVerts(gtv=((doTVs)&&(count>0)?count:0));
	  }
	  pm->setNumTVFaces(gtv>0?numF:0);
	}
	Uval=0.5f;Wval=0.5f;
	Point3 ipt;
	int i;
	if (count>0)
	{	InDirInfo indir;
	int axisentered;
    pblock->GetValue(PB_SPINAXISTYPE,0,axisentered,FOREVER);
	indir.oneframe=GetTicksPerFrame();indir.vel=Zero;indir.K=0;
	if (indir.inaxis=(axisentered==1))
	{ 
	  pblock->GetValue(PB_STRETCH,0,indir.K,FOREVER);
	}
	if (type==RENDGEOM) 
	{ if (backpatch)
		{int subtree,frag,custmtl=0,submtl=0;
		pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
		pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
		pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
		if ((custnode)&&(frag==INSTGEOM)&& custmtl) 
		  GetSubs(inode,custnode,subtree,t,frag);
		else if ((distnode)&&(frag==BYGEOM)&&(custmtl==2))
			GetSubs(inode,distnode,subtree,t,frag);}
		RendGeom(pm,itm,nummtls,maptype,custmtl,(maptype?Mval:(float)mt),thePArrayDraw,defface,!isrend);
	}
	else 
	if (type==RENDMETA)
	{ float res,bstr,thres=0.6f;int notdraft;
      pblock->GetValue(PB_METATENSION,0,bstr,FOREVER);
      pblock->GetValue(PB_PANOTDRAFT,t,notdraft,FOREVER);
	  notdraft = (notdraft?0:1);
	  if (isrend)
		pblock->GetValue(PB_METACOURSE,0,res,FOREVER);
	  else pblock->GetValue(PB_METACOURSEV,0,res,FOREVER);
	  metap.CreateMetas(parts,pm,thres,res,bstr,notdraft);	
	  for (int j=0;j<pm->getNumVerts();j++)
         pm->verts[j] = itm * pm->verts[j];
 	}
	else
	{   MtlID cm;
    for (i=0; i<parts.Count(); i++) 
	{ if ((!isrend)&&(GetAsyncKeyState (VK_ESCAPE)) )
		{ ZeroMesh(pm);cancelled=TRUE;goto quit;}
	  if (!parts.Alive(i)) continue;
	  if (indir.inaxis)
	    indir.vel=parts.vels[i];
	    if (multi) 
		{ curmtl=((custmtl==1)?sdata[i].pmtl:sdata[i].themtl);
	      if (curmtl>=nummtls) 
		    curmtl=curmtl % nummtls;
	    } else curmtl=i;
		float x;
	    elapsedtime=(float)parts.ages[i];
		if (maptype) Vval=(x=Length(parts[i]-sdata[i].start))/Mval;
		else Vval=(float)elapsedtime/mt;
        Angle=sdata[i].LamTs;
	    if (type==RENDTYPE1) PlotTriangle(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTYPE2) PlotCube8(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTYPE3) PlotSpecial(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
	    else if (type==RENDTET) PlotTet(parts.radius[i],vertexnum,face,pm,Angle,sdata[i].W,curmtl,&parts.points[i],indir);
	    else if (type==REND6PT) Plot6PT(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
		else if (type==RENDSPHERE) PlotSphere(parts.radius[i],vertexnum,face,pm,Angle,&sdata[i].W.x,curmtl,&parts.points[i],indir);
		else if (type==RENDTYPE5)
	    {	v  = (view.projType?otherV:Normalize(camV-parts[i]));
			v0 = Normalize(v111^v) * parts.radius[i];
		    v1 = Normalize(v0^v) * parts.radius[i];
		    pm->verts[vertexnum] = (parts[i]+v0+v1);
		    pm->verts[vertexnum+1] = (parts[i]-v0+v1);
		    pm->verts[vertexnum+2] = (parts[i]-v0-v1);
		    pm->verts[vertexnum+3] = (parts[i]+v0-v1);
		    for (int l=0;l<4;l++)
		      RotateOnePoint(pm->verts[vertexnum+l],&parts.points[i].x,&v.x,Angle);
		    AddFace(vertexnum+3,vertexnum+2,vertexnum+1,face,pm,curmtl);
		    AddFace(vertexnum+1,vertexnum,vertexnum+3,face+1,pm,curmtl);
		 }
		 else if (type==RENDTYPE6)
		 { 	Point3 a,b,Rv;
			float Theta,R=Length(Rv=(parts[i]-camV)),angle=parts.radius[i]*R*Thetah/view.screenW;
			a=angle*Normalize(r1^Rv);
			b=angle*Normalize(a^Rv);
			pm->verts[vertexnum]=parts[i];
			for (int l=0;l<numV;l++)
			{ Theta=(l-1)*PIOver5;
			  pm->verts[vertexnum+l]=parts[i]+(float)cos(Theta)*a+(float)sin(Theta)*b;
			}
			for (l=0;l<numF-1;l++)
			  AddFace(vertexnum,vertexnum+1+l,vertexnum+2+l,face+l,pm,curmtl);
		    AddFace(vertexnum,vertexnum+1+l,vertexnum+1,face+l,pm,curmtl);
		 }
		 else if (type==RENDCGEOM)
		 {  if (backpatch)
			{ int subtree,frag,custmtl=0,submtl=0;
			  pblock->GetValue(PB_CUSTOMMATERIAL,0,custmtl,FOREVER);
			  pblock->GetValue(PB_USESUBTREE,0,subtree,FOREVER);
			  pblock->GetValue(PB_PARTICLECLASS,0,frag,FOREVER);
			  if ((custnode)&&(frag==INSTGEOM)&& custmtl) 
				GetSubs(inode,custnode,subtree,t,frag);
			  else if ((distnode)&&(frag==BYGEOM)&&(custmtl==2))
			  GetSubs(inode,distnode,subtree,t,frag);
			}
			TimeValue Ctime=(anioff?GetCurTime(sdata[i].showframe,(anioff>1?t:parts.ages[i]),anifr):t);
			int nCount=nlist.Count();
		 int mnum=TimeFound(times,Ctime,(sdata[i].gennum>nCount?nCount:sdata[i].gennum));
		   if (mnum<0) continue;
		   numF=cmesh[mnum].getNumFaces();
		   numV=cmesh[mnum].getNumVerts();
			if ((gtvnum>0)&&(custmtl==2))
			{ for (j=0;j<numF;j++)
				 if (cmesh[mnum].getNumTVerts()>0) pm->tvFace[j+face].setTVerts(cmesh[mnum].tvFace[j].t[0],cmesh[mnum].tvFace[j].t[1],cmesh[mnum].tvFace[j].t[2]);
				 else pm->tvFace[j+face]=defface;
			}
			int jf=face;
		  for (j=0;j<numF;j++)
		  { pm->faces[jf].flags=cmesh[mnum].faces[j].flags;
		    pm->faces[jf].setSmGroup(cmesh[mnum].faces[j].smGroup);
		    pm->faces[jf].setVerts(vertexnum+cmesh[mnum].faces[j].v[0],vertexnum+cmesh[mnum].faces[j].v[1],vertexnum+cmesh[mnum].faces[j].v[2]);
		    if (!custmtl)
		      pm->faces[jf].setMatID((MtlID)curmtl); 
		    else if (custmtl==1)
			 pm->faces[jf].setMatID(sdata[i].pmtl);
			else
			{cm=cmesh[mnum].faces[j].getMatID();
			 int mtlgen=times.tl[mnum].gennum-1,maxmtl=nmtls.Count();
			 if (mtlgen>=maxmtl) mtlgen=maxmtl-1;
			 if ((mtlgen>-1)&&((times.tl.Count()>0)&&(times.tl[mnum].gennum>0)))
				cm+=nmtls[mtlgen];
			 pm->faces[jf].setMatID(cm);
			}
			jf++;
//		  pm->faces[face].setEdgeVisFlags(f[j].flags&EDGE_A,f[j].flags&EDGE_Bf[j].flags&EDGE_A);
		  }
		  PlotCustom(parts.radius[i],i,vertexnum,pm,Angle,&sdata[i].W.x,&cmesh[mnum],&parts.points[i],numV,indir);
		 }
	  // Convert to object coords
        for (j=0;j<numV;j++)
        { pm->verts[vertexnum] = itm * pm->verts[vertexnum];
          vertexnum++;
        }
		if ((type!=RENDTET)&&((type!=RENDCGEOM)||(custmtl==0)||((custmtl==1)&&doTVs)) )
		{ if (custmtl)
		    pm->tVerts[tvnum]=sdata[i].tv;
		  else pm->tVerts[tvnum]=Point3(findmappos(Uval),findmappos(Vval),findmappos(Wval));
	      for (j=0;j<numF;j++)
          { pm->tvFace[face++].setTVerts(tvnum,tvnum,tvnum); }	
	      tvnum++;
		} else face+=numF;
	  }
	}
   }
  }
  if ((isrend)&&(midframe))
  { if (pcount>0)
	{ CacheData(&lastparts,&parts);
      CacheSpin(holddata,sdata,pcount,FALSE);
	  delete[] holddata;}
    tvalid=t-offtime;
  }
  if (mirror) SwitchVerts(pm);
quit:  mesh.InvalidateGeomCache();
  needDelete = TRUE;
  return pm;
}

RefTargetHandle PArrayParticle::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case DISTNODE: return (RefTargetHandle)distnode;
		case CUSTNODE: return (RefTargetHandle)custnode;
		default: return (RefTargetHandle)nlist[i-BASER];
		}
	}

void PArrayParticle::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case DISTNODE: distnode = (INode *)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		default: nlist[i-BASER]= (INode *)rtarg;return;
		}
	}

RefResult PArrayParticle::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==distnode)
			 {  if (theHold.Holding())
			     theHold.Put(new CreatePAPartDelNode(this,distnode->GetName(),1));
 				DeleteReference(DISTNODE);
			    distnode=NULL;cancelled=FALSE;
			 }
			 if (hTarget==custnode)
			 { if (theHold.Holding()) theHold.Put(new CreatePAPartDelNode(this,custnode->GetName(),0)); 
 				DeleteReference(CUSTNODE);
			   custnode=NULL;cancelled=FALSE;
			 }
			 BOOL notfound=TRUE;
			  for (int i=0;(i<nlist.Count())&&(notfound);i++)
				if (hTarget==nlist[i]) 
				{ DeleteFromList(i,TRUE);
				 notfound=FALSE;cancelled=FALSE;}
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==distnode) 
			  { distname = TSTR(distnode->GetName());
			    ShowName(1);cancelled=FALSE;
				}
			if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName(0);cancelled=FALSE;
				}
			  BOOL notfound=TRUE;
			  for (int i=0;(i<nlist.Count())&&(notfound);i++)
				if (hTarget==nlist[i]) 
			      {notfound=FALSE;SetUpList();cancelled=FALSE;}
			  break;
			}		
		case REFMSG_NODE_LINK:		
		case REFMSG_CHANGE:
			{int pblst=0;
			  if (pblock && (pblock==hTarget))
			  { pblst=pblock->LastNotifyParamNum();
			    if (pblst==PB_METACOURSE)
			  	  return REF_STOP;
			  }
			  MeshInvalid();
			  ParticleInvalid();
			  if (editOb==this) InvalidateUI();
			  cancelled=FALSE;
			}
			break;
		case REFMSG_SUBANIM_STRUCTURE_CHANGED:
			EnableWindow(GetDlgItem(hptype,IDC_SP_MAPCUSTOMEMIT),TRUE);
			if (editOb==this) InvalidateUI();
			break;
		default: SimpleParticle::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}

const TCHAR *PArrayClassDesc::ClassName ()	{return GetString(IDS_RB_PARRAY);}
const TCHAR *PArrayClassDesc::Category ()	{return GetString(IDS_RB_PARTICLESYSTEMS);}
TCHAR *PArrayParticle::GetObjectName() {return GetString(IDS_RB_PARRAYGC);}

void PArrayParticle::SetUpList()
{ SendMessage(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),LB_RESETCONTENT,0,0);
  for (int i=0;i<nlist.Count(); i++) 
		SendMessage(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),
			LB_ADDSTRING,0,(LPARAM)(TCHAR*)(nlist[i]->GetName()));
}

void PArrayParticle::AddToList(INode *newnode,int i,BOOL add)
{	if (add)
	{ nlist.Insert(i,1,&newnode);
	  MakeRefByID(FOREVER,BASER+i,newnode);
	}	  
	else ReplaceReference(i+BASER,newnode);
	NotifyDependents(FOREVER,0,REFMSG_CHANGE);
	SetUpList();
}

void PArrayParticle::DeleteFromList(int nnum,BOOL all)
{ int nCount=nlist.Count();
  INode *cnode=nlist[nnum];
  DeleteReference(nnum+BASER);
  if (theHold.Holding() && !TestAFlag(A_HELD)) 
	  theHold.Put(new PAObjectListRestore(this));
  nlist.Delete(nnum,1);
  if (all) 
  { for (int di=nnum;di<nlist.Count();di++)
     if (nlist[di]==cnode)
	 { DeleteReference(di+BASER);
	   nlist.Delete(di,1);
	 }
  }
  NotifyDependents(FOREVER,0,REFMSG_CHANGE);
  if (ip) SetUpList();
  valid=FALSE;
}
void PArrayParticle::SetUpLifeList()
{ TCHAR buffer[20];
  SendMessage(GetDlgItem(spawn,IDC_AP_LIFEQUEUE),LB_RESETCONTENT,0,0);
  for (int i=0;i<llist.Count(); i++) 
  {	_itoa(llist[i], buffer, 10 );
	SendMessage(GetDlgItem(spawn,IDC_AP_LIFEQUEUE),LB_ADDSTRING,0,(LPARAM)(TCHAR*)buffer);
  }
} 

void PArrayParticle::AddToLifeList(int newlife)
{	llist.Insert(llist.Count(),1,&newlife);
	SetUpLifeList();
}

void PArrayParticle::DeleteFromLifeList(int nnum)
{ 	llist.Delete(nnum,1);
    if (ip) SetUpLifeList();
}
int PArrayParticle::HitTest(
		TimeValue t, INode *inode, int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt) 
	{	
	BOOL doupdate=((!cancelled)&&((t!=tvalid)||!valid));
	if (doupdate) Update(t,inode);
	Point2 pt( (float)p[0].x, (float)p[0].y );
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	MakeHitRegion(hitRegion, type, crossing, 4, p);
	DWORD rlim  = gw->getRndLimits();
	int res;

	gw->setTransform(ident);
	int ptype,disptype,dtype=GetDrawType(this,ptype,disptype);
	if ((dtype<2)||(dtype==3))
	{  if (parts.HitTest(gw,&hitRegion,flags&HIT_ABORTONHIT,GetMarkerType()))
		{return TRUE;}
	}
	else
	{ if ((t!=dispt)||doupdate||!dispmesh)
	  {	NullView nullView;
		BOOL needdel;
		if (dispmesh) delete dispmesh;
		SetAFlag(A_NOTREND);
	    dispmesh=GetRenderMesh(t,inode,nullView,needdel);
		ClearAFlag(A_NOTREND);
		}
		gw->setRndLimits(rlim);
		gw->setTransform(inode->GetObjTMAfterWSM(t));
		res = dispmesh->select(gw, &particleMtl, &hitRegion, flags & HIT_ABORTONHIT);
		if (res) return TRUE;
	}
	
	if (EmitterVisible()) {
		gw->setRndLimits((rlim|GW_PICK|GW_WIREFRAME) 
			& ~(GW_ILLUM|GW_BACKCULL|GW_FLAT|GW_SPECULAR));
		gw->setTransform(inode->GetObjTMAfterWSM(t));
		res = mesh.select(gw, &particleMtl, &hitRegion, flags & HIT_ABORTONHIT);

		gw->setRndLimits(rlim);
	} else {
		res = 0;
		}
	return res;
	}

int PArrayParticle::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags) 
{   if (!OKtoDisplay(t)) return 0;
	if (t!=tvalid) cancelled=FALSE;
	if ((ip && origmtl) &&(origmtl!=inode->GetMtl()))
	{ EnableWindow(GetDlgItem(hptype,IDC_SP_MAPCUSTOMEMIT),TRUE);
	  origmtl=NULL;
	}
	BOOL doupdate=((!cancelled)&&((t!=tvalid)||!valid));
	if (!doupdate) doupdate=CheckMtlChange(inode->GetMtl(),wasmulti);
	if (doupdate)
	 Update(t,inode);

	GraphicsWindow *gw = vpt->getGW();
	DWORD rlim  = gw->getRndLimits();
	// Draw emitter
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER) );	// removed BC on 4/29/99 DB
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_PARTICLE_EM));
    RECT *r=&vpt->GetDammageRect();
	if (EmitterVisible()) {
		gw->setTransform(inode->GetObjTMAfterWSM(t));	
		r=&vpt->GetDammageRect();
		mesh.render(gw, &particleMtl, 
			(flags&USE_DAMAGE_RECT) ? r : NULL, COMP_ALL);
		}
		
	  Material *mtl = gw->getMaterial();	
	  if (!inode->Selected() && !inode->IsFrozen())
		gw->setColor( LINE_COLOR, mtl->Kd[0], mtl->Kd[1], mtl->Kd[2]);
	int ptype,disptype,type=GetDrawType(this,ptype,disptype);
	if (type==3)
	{ thePArrayDraw.obj = this;
		thePArrayDraw.firstpart=TRUE;
		thePArrayDraw.disptype=disptype;
		thePArrayDraw.ptype=ptype;
		thePArrayDraw.bb=TRUE;
		parts.SetCustomDraw(&thePArrayDraw);			
	}
	if ((type<2)||(type==3)) // Draw particles
	{ if (type<2) parts.SetCustomDraw(NULL);
	  MarkerType mt=(type==0?POINT_MRKR:PLUS_SIGN_MRKR);
	  gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL| (rlim&(GW_Z_BUFFER|GW_BOX_MODE)) );
	  gw->setTransform(ident);
	  parts.Render(gw,mt);
	  gw->setRndLimits(rlim);
	}
	else
	{ parts.SetCustomDraw(NULL);			
	  NullView nullView;
	  BOOL needdel;
	  if ((t!=dispt)||doupdate)
	  {if (dispmesh) delete dispmesh;
		SetAFlag(A_NOTREND);
	  dispmesh=GetRenderMesh(t,inode,nullView,needdel);
		ClearAFlag(A_NOTREND);
	  }
	  Matrix3 mat = inode->GetObjTMAfterWSM(t);
	  gw->setRndLimits(rlim);
	  gw->setTransform(mat);
	  r=&vpt->GetDammageRect();
	  dispmesh->render( gw, inode->Mtls(),
		(flags&USE_DAMAGE_RECT) ? &vpt->GetDammageRect() : NULL, 
		COMP_ALL | ((flags&DISP_SHOWSUBOBJECT)?COMP_OBJSELECTED:0),
		inode->NumMtls());
	   gw->setRndLimits(rlim);
	}
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\suprprts.cpp ===
/**********************************************************************
 *<
	FILE: suprprts.cpp

	DESCRIPTION: Blizzard, Particle Array, and SuperSpray  Support Files

	CREATED BY: Audrey Peterson

	HISTORY: 12/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "SuprPrts.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------
TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_AP_SPRTSLIB); }

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int 
LibNumberClasses() { return 12; }

// This function return the ith class descriptor. We have one.
__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case 0:return GetPBombObjDesc();
	case 1:return GetPBombModDesc();
	case 2:return GetSphereDefDesc();
	case 3:return GetSphereDefModDesc();
	case 4:return GetSuprSprayDesc();
	case 5:return GetBlizzardDesc();
	case 6:return GetPArrayDesc();
	case 7:return GetPFollowDesc();
	case 8:return GetPFollowModDesc();
    case 9:return GetPCloudDesc();
	case 10:return GetUniDefDesc();
	case 11:return GetUniDefModDesc();

    default:return 0;}
 }

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

  	if (!controlsInit) {
		controlsInit = TRUE;		

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	}
	
	return(TRUE);
	}


// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

/* rand returns a number between 0 and 32767 */
/* number between 0 and 1 */
const float IntMax=32767.0f;
const float IntMax1=32768.0f;
const float HalfIntMax=16383.5f;
typedef float Matrix3By3[3][3];
typedef float Matrix4By3[4][3];

int FloatEQ0(float number)
{return((FLOAT_EPSILON>=number)&&(number>=-FLOAT_EPSILON));
}
int SmallerEQ0(float number)
{return((SMALL_EPSILON>=number)&&(SMALL_EPSILON>=-FLOAT_EPSILON));
}
int FGT0(Point3 p1)
{
	return((fabs(p1[0])>SMALL_EPSILON)||(fabs(p1[1])>SMALL_EPSILON)||(fabs(p1[2])>SMALL_EPSILON));
}

#define EPSILON 0.00001f

float sign(float sval)
{	return(sval>=0.0f?1.0f:-1.0f);
}

void MakeInterpRotXform(Matrix3 InTmBegin,Matrix3 InTmEnd,float portion,Matrix3& OutTm)
{	InTmBegin.NoTrans();
	InTmEnd.NoTrans();
	if (portion<EPSILON) {OutTm=InTmBegin; return;}
	else if ((fabs(1.0f-portion))<EPSILON) {OutTm=InTmEnd; return;}
	Matrix3 TmBetween=Inverse(InTmBegin)*InTmEnd;
	Matrix3 InterpTm;
	Point3 N,O,A;
	float theta,bigtheta;
	N=TmBetween.GetRow(0);
	O=TmBetween.GetRow(1);
	A=TmBetween.GetRow(2);
	float Nx=N.x,Ny=N.y,Nz=N.z;
	float Ox=O.x,Oy=O.y,Oz=O.z;
	float Ax=A.x,Ay=A.y,Az=A.z;
	float Kx,Ky,Kz;
	bigtheta=(float)atan(sqrt((Ox-Ay)*(Oz-Ay)+(Ax-Nz)*(Ax-Nz)+(Ny-Ox)*(Ny-Ox))/(Nx+Oy+Az-1));
	if (bigtheta<EPSILON) {Kx=1.0f;Ky=Kz=0.0f;}
	else if (bigtheta<HALFPI)
	{	float stheta2=2.0f*(float)sin(bigtheta);
		Kx=(Oz-Ay)/stheta2;Ky=(Ax-Nz)/stheta2;Kz=(Ny-Ox)/stheta2;
	}
	else if (bigtheta<PI)
	{	float costh=(float)cos(bigtheta),costh1=1.0f-costh,costh12=2.0f*costh1;
		Kx=sign(Oz-Ay)*(float)sqrt((Nx-costh)/costh1);
		Ky=sign(Ax-Nz)*(float)sqrt((Oy-costh)/costh1);
		Kz=sign(Ny-Ox)*(float)sqrt((Az-costh)/costh1);
		if ((Kx>Ky)&&(Kx>Kz))
		{	float xcos=Kx*costh12;
			Ky=(Ny+Ox)/xcos;
			Kz=(Ax+Nz)/xcos;
		}
		else if (Ky>Kz)
		{	float ycos=Ky*costh12;
			Kx=(Ny+Ox)/ycos;
			Kz=(Oz+Ay)/ycos;
		}
		else 
		{	float zcos=Kz*costh12;
			Ky=(Oz+Ay)/zcos;
			Kx=(Ax+Nz)/zcos;
		}
	}
	theta=portion*bigtheta;
	float kx2=Kx*Kx,ky2=Ky*Ky,kz2=Kz*Kz;
	float kxky=Kx*Ky,kxkz=Kx*Kz,kykz=Ky*Kz;
	float ctheta=(float)cos(theta);
	float stheta=(float)sin(theta);
	float vtheta=1.0f-ctheta;
	float kx2vtheta=kx2*vtheta,ky2vtheta=ky2*vtheta,kz2vtheta=kz2*vtheta;
	float kxkyvtheta=kxky*vtheta,kxkzvtheta=kxkz*vtheta,kykzvtheta=kykz*vtheta;
	float kxstheta=Kx*stheta,kystheta=Ky*stheta,kzstheta=Kz*stheta;
	float W11=kx2vtheta+ctheta,W12=kxkyvtheta-kzstheta,W13=kxkzvtheta+kystheta;
	float W21=kxkyvtheta+kzstheta,W22=ky2vtheta+ctheta,W23=kykzvtheta-kxstheta;
	float W31=kxkzvtheta-kystheta,W32=kykzvtheta+kxstheta,W33=kz2vtheta+ctheta;
	InterpTm.SetRow(0,Point3(W11,W21,W31));
	InterpTm.SetRow(1,Point3(W12,W22,W32));
	InterpTm.SetRow(2,Point3(W13,W23,W33));
	InterpTm.SetRow(3,Point3(0.0f,0.0f,0.0f));
	OutTm=InTmBegin*InterpTm;
}

void Mult1X4(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0]+A[3]*B[3][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1]+A[3]*B[3][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2]+A[3]*B[3][2];
   C[3]=A[0]*B[0][3]+A[1]*B[1][3]+A[2]*B[2][3]+A[3]*B[3][3];
}

void Mult4X1(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[0][1]+A[2]*B[0][2]+A[3]*B[0][3];
   C[1]=A[0]*B[1][0]+A[1]*B[1][1]+A[2]*B[1][2]+A[3]*B[1][3];
   C[2]=A[0]*B[2][0]+A[1]*B[2][1]+A[2]*B[2][2]+A[3]*B[2][3];
   C[3]=A[0]*B[3][0]+A[1]*B[3][1]+A[2]*B[3][2]+A[3]*B[3][3];
}

void Mult1X3(float *A,Matrix3By3 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2];
}

void Mult3X4(Matrix3By4 A,Matrix4By4 B,Matrix3By4 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
   C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
   C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
   C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
   C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
   C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
   C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
   C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
   C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
   C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
   C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
   C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
}

void Mult4X3(Matrix4By3 A,Matrix4By4 B,Matrix4By3 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[1][0]*B[0][1]+A[2][0]*B[0][2]+A[3][0]*B[0][3];
   C[1][0]=A[0][0]*B[1][0]+A[1][0]*B[1][1]+A[2][0]*B[1][2]+A[3][0]*B[1][3];
   C[2][0]=A[0][0]*B[2][0]+A[1][0]*B[2][1]+A[2][0]*B[2][2]+A[3][0]*B[2][3];
   C[3][0]=A[0][0]*B[3][0]+A[1][0]*B[3][1]+A[2][0]*B[3][2]+A[3][0]*B[3][3];
   C[0][1]=A[0][1]*B[0][0]+A[1][1]*B[0][1]+A[2][1]*B[0][2]+A[3][1]*B[0][3];
   C[1][1]=A[0][1]*B[1][0]+A[1][1]*B[1][1]+A[2][1]*B[1][2]+A[3][1]*B[1][3];
   C[2][1]=A[0][1]*B[2][0]+A[1][1]*B[2][1]+A[2][1]*B[2][2]+A[3][1]*B[2][3];
   C[3][1]=A[0][1]*B[3][0]+A[1][1]*B[3][1]+A[2][1]*B[3][2]+A[3][1]*B[3][3];
   C[0][2]=A[0][2]*B[0][0]+A[1][2]*B[0][1]+A[2][2]*B[0][2]+A[3][2]*B[0][3];
   C[1][2]=A[0][2]*B[1][0]+A[1][2]*B[1][1]+A[2][2]*B[1][2]+A[3][2]*B[1][3];
   C[2][2]=A[0][2]*B[2][0]+A[1][2]*B[2][1]+A[2][2]*B[2][2]+A[3][2]*B[2][3];
   C[3][2]=A[0][2]*B[3][0]+A[1][2]*B[3][1]+A[2][2]*B[3][2]+A[3][2]*B[3][3];
}

void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
   C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
   C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
   C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
   C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
   C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
   C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
   C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
   C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
   C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
   C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
   C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
   C[3][0]=A[3][0]*B[0][0]+A[3][1]*B[1][0]+A[3][2]*B[2][0]+A[3][3]*B[3][0];
   C[3][1]=A[3][0]*B[0][1]+A[3][1]*B[1][1]+A[3][2]*B[2][1]+A[3][3]*B[3][1];
   C[3][2]=A[3][0]*B[0][2]+A[3][1]*B[1][2]+A[3][2]*B[2][2]+A[3][3]*B[3][2];
   C[3][3]=A[3][0]*B[0][3]+A[3][1]*B[1][3]+A[3][2]*B[2][3]+A[3][3]*B[3][3];
}

float det2x2(float a,float b,float c,float d)
{ return(a*d-b*c);
}
float det3x3(float a1,float a2,float a3,float b1,float b2,float b3,float c1,float c2,float c3)
{ return(a1*det2x2(b2,b3,c2,c3)-b1*det2x2(a2,a3,c2,c3)+c1*det2x2(a2,a3,b2,b3));
}

void Adjoint(Matrix4By4 in, Matrix4By4 out,float det)
{float a1,a2,a3,a4,b1,b2,b3,b4;
 float c1,c2,c3,c4,d1,d2,d3,d4;

 a1=in[0][0];b1=in[0][1];c1=in[0][2];d1=in[0][3];
 a2=in[1][0];b2=in[1][1];c2=in[1][2];d2=in[1][3];
 a3=in[2][0];b3=in[2][1];c3=in[2][2];d3=in[2][3];
 a4=in[3][0];b4=in[3][1];c4=in[3][2];d4=in[3][3];
 out[0][0]= det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)/det;
 out[1][0]=-det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)/det;
 out[2][0]= det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)/det;
 out[3][0]=-det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4)/det;
 out[0][1]=-det3x3(b1,b3,b4,c1,c3,c4,d1,d3,d4)/det;
 out[1][1]= det3x3(a1,a3,a4,c1,c3,c4,d1,d3,d4)/det;
 out[2][1]=-det3x3(a1,a3,a4,b1,b3,b4,d1,d3,d4)/det;
 out[3][1]= det3x3(a1,a3,a4,b1,b3,b4,c1,c3,c4)/det;
 out[0][2]= det3x3(b1,b2,b4,c1,c2,c4,d1,d2,d4)/det;
 out[1][2]=-det3x3(a1,a2,a4,c1,c2,c4,d1,d2,d4)/det;
 out[2][2]= det3x3(a1,a2,a4,b1,b2,b4,d1,d2,d4)/det;
 out[3][2]=-det3x3(a1,a2,a4,b1,b2,b4,c1,c2,c4)/det;
 out[0][3]=-det3x3(b1,b2,b3,c1,c2,c3,d1,d2,d3)/det;
 out[1][3]= det3x3(a1,a2,a3,c1,c2,c3,d1,d2,d3)/det;
 out[2][3]=-det3x3(a1,a2,a3,b1,b2,b3,d1,d2,d3)/det;
 out[3][3]= det3x3(a1,a2,a3,b1,b2,b3,c1,c2,c3)/det;
}

float det4x4(Matrix4By4 m)
{float a1,a2,a3,a4,b1,b2,b3,b4;
 float c1,c2,c3,c4,d1,d2,d3,d4,ans;

 a1=m[0][0];b1=m[0][1];c1=m[0][2];d1=m[0][3];
 a2=m[1][0];b2=m[1][1];c2=m[1][2];d2=m[1][3];
 a3=m[2][0];b3=m[2][1];c3=m[2][2];d3=m[2][3];
 a4=m[3][0];b4=m[3][1];c4=m[3][2];d4=m[3][3];
 ans= a1*det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)
     -b1*det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)
     +c1*det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)
     -d1*det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4);
 return(ans);
}

int MatrixInvert(Matrix4By4 in,Matrix4By4 out)
{ float det;

  det=det4x4(in);
  if (fabs(det)<PRECISION_LIMIT)  /* NO INVERSE */
    return(0);
  Adjoint(in,out,det);
  return(1);
}

void SetUpRotation(float *Q, float *W,float Theta,Matrix4By4 Rq)
{ float ww1,ww2,ww3,w12,w13,w23,CosTheta,SinTheta,MinCosTheta;
  Point3 temp;
  Matrix3By3 R;

 ww1=W[0]*W[0];ww2=W[1]*W[1];ww3=W[2]*W[2];
 w12=W[0]*W[1];w13=W[0]*W[2];w23=W[1]*W[2];
 CosTheta=(float)cos(Theta);MinCosTheta=1.0f-CosTheta;SinTheta=(float)sin(Theta);
 R[0][0]=ww1+(1.0f-ww1)*CosTheta;
 R[0][1]=w12*MinCosTheta+W[2]*SinTheta;
 R[0][2]=w13*MinCosTheta-W[1]*SinTheta;
 R[1][0]=w12*MinCosTheta-W[2]*SinTheta;
 R[1][1]=ww2+(1.0f-ww2)*CosTheta;
 R[1][2]=w23*MinCosTheta+W[0]*SinTheta;
 R[2][0]=w13*MinCosTheta+W[1]*SinTheta;
 R[2][1]=w23*MinCosTheta-W[0]*SinTheta;
 R[2][2]=ww3+(1.0f-ww3)*CosTheta;
 Mult1X3(Q,R,&temp.x);
 memcpy(Rq[0],R[0],row3size);memcpy(Rq[1],R[1],row3size);memcpy(Rq[2],R[2],row3size);
 Rq[3][0]=Q[0]-temp.x;Rq[3][1]=Q[1]-temp.y;Rq[3][2]=Q[2]-temp.z;
 Rq[0][3]=Rq[1][3]=Rq[2][3]=0.0f;Rq[3][3]=1.0f;
}

void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta)
{ Matrix3By4 Pout;
  Matrix4By4 Rq;

 SetUpRotation(Q,W,Theta,Rq);
 Mult3X4(Pin,Rq,Pout);
 memcpy(Pin, Pout, sizeof(Matrix3By4));
}

void RotateOnePoint(float *Pin,float *Q, float *W,float Theta)
{ Matrix4By4 Rq;
  float Pout[4],Pby4[4];

 SetUpRotation(Q,W,Theta,Rq);
 memcpy(Pby4,Pin,row3size);Pby4[3]=1.0f;
 Mult1X4(Pby4,Rq,Pout);
 memcpy(Pin,Pout,row3size);
}

float RND01()
{ float num;

  num=(float)rand();
  return(num/IntMax);
}

// number between -1 and 1 
float RND11()
{ float num;

   num=(float)rand()-HalfIntMax;
   return(num/HalfIntMax);
}

int RNDSign()
{
  return((RND11()<0?-1:1));
}

float RND55()
{ float num;

  num=RND11();
  return(num/2);
}
int RND0x(int maxnum)
{ float num;
  int newnum;

   num=(float)rand();
   if (maxnum==0) return(0);
   newnum=(int)floor((++maxnum)*num/IntMax1);
   return(newnum>maxnum?maxnum:newnum);
}


BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}
void TurnButton(HWND hWnd,int SpinNum,BOOL ison)
{	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(hWnd,SpinNum));
	if (iBut) 
	{ if (ison) iBut->Enable(); else iBut->Disable();
	}
	ReleaseICustButton(iBut);
};
void SpinnerOn(HWND hWnd,int SpinNum,int Winnum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Enable();
	EnableWindow(GetDlgItem(hWnd,Winnum),TRUE);
	ReleaseISpinner(spin2);

};
void SpinnerOff(HWND hWnd,int SpinNum,int Winnum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Disable();
	EnableWindow(GetDlgItem(hWnd,Winnum),FALSE);
	ReleaseISpinner(spin2);
};
Point3 CalcSpread(float divangle,Point3 oldnorm)
{ float Q[3];
  Point3 r;

  Q[0]=Q[1]=Q[2]=0.0f;
  r=Point3(RND11(),RND11(),RND11());
  r=Normalize(r^oldnorm);
  RotateOnePoint(&oldnorm.x,Q,&r.x,RND01()*divangle);
  return(oldnorm);
}

float FigureOutSize(TimeValue age,float size,TimeValue grow,TimeValue fade,TimeValue life,float grate,float frate)
{ TimeValue timeleft=life-age;
  if (timeleft<fade)
   return(size*(timeleft*frate+M));
  else if (age<grow)
   return(size*(age*grate+M));
  else return(size);
}

void AddFace(int a, int b, int c,int face,Mesh *pm,int curmtl)
{ pm->faces[face].setSmGroup(0);
  pm->faces[face].setVerts(a,b,c);
  pm->faces[face].setMatID((MtlID)curmtl);
  pm->faces[face].setEdgeVisFlags(1,1,0);
}

Point3 RotateAboutAxis(float Angle,Point3 C,Point3 L,Point3 W,InDirInfo indir)
{ Point3 V,A,A1,newpt;
  float CAngle=(float)cos(Angle),SAngle=(float)sin(Angle),K,len;

  len=Length(indir.vel);
  if (FloatEQ0(len*GetTicksPerFrame())) 
  { len=1.0f;V=v111;}
  else V=indir.vel/len;
  A=Normalize(W^V);
  A1=Normalize(V^A);
  K=((len*indir.oneframe-1.0f)*indir.K+100.0f)/100.0f;
  newpt=Point3((A*CAngle+A1*SAngle)*L.x+(-A*SAngle+A1*CAngle)*L.y+V*K*L.z)+C;
  return newpt;
}

void PlotSpecial(float radius,int vertexnum,int face,Mesh *pm,float Angle,float *W,int curmtl,Point3 *pt,InDirInfo indir)
{float radius_5,mradius_5,yradius_5,myradius_5,zradius_5,mzradius_5,halfr,AVertex[3];

  AddFace(vertexnum,vertexnum+1,vertexnum+2,face,pm,curmtl);
  AddFace(vertexnum+2,vertexnum+3,vertexnum,++face,pm,curmtl);
  AddFace(vertexnum+4,vertexnum+5,vertexnum+6,++face,pm,curmtl);
  AddFace(vertexnum+6,vertexnum+7,vertexnum+4,++face,pm,curmtl);
  AddFace(vertexnum+8,vertexnum+9,vertexnum+10,++face,pm,curmtl);
  AddFace(vertexnum+10,vertexnum+11,vertexnum+8,++face,pm,curmtl);
  halfr=radius*0.5f;
  if (indir.inaxis)
  {pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(halfr,0.0f,halfr),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(halfr,0.0f,-halfr),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-halfr,0.0f,-halfr),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-halfr,0.0f,halfr),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-halfr,-halfr,0.0f),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(halfr,-halfr,0.0f),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(halfr,halfr,0.0f),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-halfr,halfr,0.0f),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f,-halfr,halfr),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f,-halfr,-halfr),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f,halfr,-halfr),W,indir);
pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f,halfr,halfr),W,indir);
  }
  else
  {
  radius_5=pt->x+halfr;
  mradius_5=pt->x-halfr;
  yradius_5=pt->y+halfr;
  myradius_5=pt->y-halfr;
  zradius_5=pt->z+halfr;
  mzradius_5=pt->z-halfr;
  AVertex[0]=radius_5;AVertex[1]=pt->y;AVertex[2]=zradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=radius_5;AVertex[1]=pt->y;AVertex[2]=mzradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mradius_5;AVertex[1]=pt->y;AVertex[2]=mzradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mradius_5;AVertex[1]=pt->y;AVertex[2]=zradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mradius_5;AVertex[1]=myradius_5;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=radius_5;AVertex[1]=myradius_5;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=radius_5;AVertex[1]=yradius_5;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mradius_5;AVertex[1]=yradius_5;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=pt->x;AVertex[1]=myradius_5;AVertex[2]=zradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=pt->x;AVertex[1]=myradius_5;AVertex[2]=mzradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=pt->x;AVertex[1]=yradius_5;AVertex[2]=mzradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=pt->x;AVertex[1]=yradius_5;AVertex[2]=zradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  }
}

void PlotCube8(float radius,int vertexnum,int face, Mesh *pm, float Angle,float *W,int curmtl,Point3* pt,InDirInfo indir)
{float radius_5,mradius_5,yradius_5,myradius_5,zradius_5,mzradius_5,halfr,AVertex[3];

  halfr=radius*0.5f;
  AddFace(vertexnum+0,vertexnum+1,vertexnum+2,face,pm,curmtl);
  AddFace(vertexnum+2,vertexnum+3,vertexnum,++face,pm,curmtl);
  AddFace(vertexnum+4,vertexnum+5,vertexnum,++face,pm,curmtl);
  AddFace(vertexnum,vertexnum+3,vertexnum+4,++face,pm,curmtl);
  AddFace(vertexnum+5,vertexnum+6,vertexnum+1,++face,pm,curmtl);
  AddFace(vertexnum+1,vertexnum+0,vertexnum+5,++face,pm,curmtl);
  AddFace(vertexnum+6,vertexnum+7,vertexnum+2,++face,pm,curmtl);
  AddFace(vertexnum+2,vertexnum+1,vertexnum+6,++face,pm,curmtl);
  AddFace(vertexnum+7,vertexnum+4,vertexnum+3,++face,pm,curmtl);
  AddFace(vertexnum+3,vertexnum+2,vertexnum+7,++face,pm,curmtl);
  AddFace(vertexnum+5,vertexnum+4,vertexnum+7,++face,pm,curmtl);
  AddFace(vertexnum+7,vertexnum+6,vertexnum+5,++face,pm,curmtl);
  if (indir.inaxis)
  {pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(halfr,halfr,halfr),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(halfr,halfr,-halfr),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-halfr,halfr,-halfr),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-halfr,halfr,halfr),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-halfr,-halfr,halfr),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(halfr,-halfr,halfr),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(halfr,-halfr,-halfr),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-halfr,-halfr,-halfr),W,indir);
  }
  else
  {
  radius_5=pt->x+halfr;
  mradius_5=pt->x-halfr;
  yradius_5=pt->y+halfr;
  myradius_5=pt->y-halfr;
  zradius_5=pt->z+halfr;
  mzradius_5=pt->z-halfr;
  AVertex[0]=radius_5;AVertex[1]=yradius_5;AVertex[2]=zradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=radius_5;AVertex[1]=yradius_5;AVertex[2]=mzradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mradius_5;AVertex[1]=yradius_5;AVertex[2]=mzradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mradius_5;AVertex[1]=yradius_5;AVertex[2]=zradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mradius_5;AVertex[1]=myradius_5;AVertex[2]=zradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=radius_5;AVertex[1]=myradius_5;AVertex[2]=zradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=radius_5;AVertex[1]=myradius_5;AVertex[2]=mzradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mradius_5;AVertex[1]=myradius_5;AVertex[2]=mzradius_5;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  }
}

void Plot6PT(float radius,int vertexnum,int face, Mesh *pm, float Angle,float *W,int curmtl,Point3* pt,InDirInfo indir)
{float halfr,r73,AVertex[3],radius_5,mradius_5,r_r73,mr_r73;

  halfr=radius*0.5f;
  r73=radius*0.73f;
  AddFace(vertexnum+0,vertexnum+1,vertexnum+2,face,pm,curmtl);
  pm->faces[face].setEdgeVisFlags(1,1,1);
  AddFace(vertexnum+3,vertexnum+4,vertexnum+5,++face,pm,curmtl);
  pm->faces[face].setEdgeVisFlags(1,1,1);
  if (indir.inaxis)
  { pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f,-radius,0.0f),W,indir);
 pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(r73,halfr,0.0f),W,indir);
 pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-r73,halfr,0.0f),W,indir);
 pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-r73,-halfr,0.0f),W,indir);
 pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(r73,-halfr,0.0f),W,indir);
 pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f,radius,0.0f),W,indir);
  }
  else
  {
  radius_5=pt->y+halfr;
  mradius_5=pt->y-halfr;
  r_r73=pt->x+r73;
  mr_r73=pt->x-r73;
  AVertex[0]=pt->x;AVertex[1]=pt->y-radius;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=r_r73;AVertex[1]=radius_5;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mr_r73;AVertex[1]=radius_5;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=mr_r73;AVertex[1]=mradius_5;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=r_r73;AVertex[1]=mradius_5;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  AVertex[0]=pt->x;AVertex[1]=pt->y+radius;AVertex[2]=pt->z;
  RotateOnePoint(AVertex,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  }
}

void PlotTet(float radius,int vertexnum,int face, Mesh *pm, float Angle,Point3 W,int curmtl,Point3* pt,InDirInfo indir)
{float AVertex[3],radius_5,r_r73;
 Point3 r1,r2,r3,r4,tmp;
 
  radius=radius/6.0f;
  radius_5=0.5f*radius;
  r_r73=0.732f*radius;
  r1=Point3(radius,0.0f,0.0f);
  r2=Point3(-radius_5,r_r73,0.0f);
  r3=Point3(-radius,-r_r73,0.0f);
  r4=Point3(0.0f,0.0f,-8.0f*radius);
  pm->tvFace[face].setTVerts(0,0,0);  
  pm->tvFace[face+1].setTVerts(0,1,0);  
  pm->tvFace[face+2].setTVerts(0,1,0);  
  pm->tvFace[face+3].setTVerts(0,1,0);  
  AddFace(vertexnum,vertexnum+1,vertexnum+2,face,pm,curmtl);
  pm->faces[face].setEdgeVisFlags(1,1,1);
  AddFace(vertexnum,vertexnum+3,vertexnum+1,++face,pm,curmtl);
  pm->faces[face].setEdgeVisFlags(1,1,1);
  AddFace