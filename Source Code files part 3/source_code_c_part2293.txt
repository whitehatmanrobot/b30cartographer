N ),
    m_MenuType     ( Normal ),
    m_arrMenu      (),
    m_strMenu      (),
    m_iCurrIndex   ( 0 ),
    m_iMaxItems    ( 0 )
{
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Called when menu is initially displayed
//-----------------------------------------------------------------------------
VOID Menu::Start( MenuType menuType )
{
    m_MenuMode = MENU_MODE_MAIN;
    m_MenuType = menuType;
    m_iCurrIndex = 0;
    DWORD dwLang = CXBConfig::GetLanguage();

    switch( m_MenuType )
    {
        case Normal:
            m_arrMenu[ 0 ] = MENU_ITEM_START;
            m_arrMenu[ 1 ] = MENU_ITEM_LOAD_GAME;
            m_arrMenu[ 2 ] = MENU_ITEM_OPTIONS;
            m_strMenu[ 0 ] = strMENU_START[ dwLang ];
            m_strMenu[ 1 ] = strMENU_LOAD[ dwLang ];
            m_strMenu[ 2 ] = strMENU_OPTIONS[ dwLang ];
            m_iMaxItems = 3;
            break;
        case InGame:
            m_arrMenu[ 0 ] = MENU_ITEM_RESUME;
            m_arrMenu[ 1 ] = MENU_ITEM_SAVE_GAME;
            m_arrMenu[ 2 ] = MENU_ITEM_LOAD_GAME;
            m_arrMenu[ 3 ] = MENU_ITEM_QUIT;
            m_strMenu[ 0 ] = strMENU_RESUME[ dwLang ];
            m_strMenu[ 1 ] = strMENU_SAVE[ dwLang ];
            m_strMenu[ 2 ] = strMENU_LOAD[ dwLang ];
            m_strMenu[ 3 ] = strMENU_QUIT[ dwLang ];
            m_iMaxItems = 4;
            break;
        default:
            assert( FALSE );
            break;
    }

    m_InactiveTimer.StartZero();

    // Load our textures
    if( FAILED( m_xprResource.Create( g_pd3dDevice, "MenuResource.xpr", 
                                      MenuResource_NUM_RESOURCES ) ) )
    {
        OUTPUT_DEBUG_STRING( "Menu::Start: failed to load textures\n");
        return;
    }

    // Load our textures from the bundled resource
    m_ptMenuSel = m_xprResource.GetTexture( MenuResource_MenuSelect_OFFSET );
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called when menu is no longer displayed
//-----------------------------------------------------------------------------
VOID Menu::End()
{
    m_xprResource.Destroy();
    m_InactiveTimer.Stop();
    m_JoyTimer.Stop();
    m_Options.End();
}




//-----------------------------------------------------------------------------
// Name: GetCurrItem()
// Desc: Returns the currently selected menu item
//-----------------------------------------------------------------------------
Menu::MenuItem Menu::GetCurrItem() const
{
    return m_arrMenu[ m_iCurrIndex ];
}




//-----------------------------------------------------------------------------
// Name: GetInactiveSeconds()
// Desc: Returns the length of time that the menu has been inactive (no button
//       presses, etc.)
//-----------------------------------------------------------------------------
FLOAT Menu::GetInactiveSeconds() const
{
    return m_InactiveTimer.GetElapsedSeconds();
}




//-----------------------------------------------------------------------------
// Name: ChangeMode()
// Desc: Switch to new menu mode
//-----------------------------------------------------------------------------
VOID Menu::ChangeMode( MenuMode iNewMode )
{
    // End the current mode
    switch( m_MenuMode )
    {
        case MENU_MODE_MAIN:                        break;
        case MENU_MODE_OPTIONS: m_Options.End();    break;
        default:                assert( FALSE );    break;
    }

    // Start the new mode
    switch( iNewMode )
    {
        case MENU_MODE_MAIN:                                     break;
        case MENU_MODE_OPTIONS: m_Options.Start( m_ptMenuSel );  break;
        default:                assert( FALSE );                 break;
    }

    m_MenuMode = iNewMode;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame for animating the menu
//-----------------------------------------------------------------------------
HRESULT Menu::FrameMove( const XBGAMEPAD* pGamePad )
{
    if( pGamePad == NULL )
        return S_OK;

    // If any button is active, then reset the inactive timer
    if( Controller::IsAnyButtonActive( pGamePad ) )
        m_InactiveTimer.StartZero();

    switch( m_MenuMode )
    {
        case MENU_MODE_MAIN:
            
            FrameMoveMainMenu( pGamePad );
            break;

        case MENU_MODE_OPTIONS:

            m_Options.FrameMove( pGamePad );
            if( m_Options.ExitMenu() )
                ChangeMode( MENU_MODE_MAIN );
            break;

        default:

            assert( FALSE );
            break;

    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame for 3d rendering of the menu
//-----------------------------------------------------------------------------
HRESULT Menu::Render()
{
    switch( m_MenuMode )
    {
        case MENU_MODE_MAIN:        RenderMainMenu();       break;
        case MENU_MODE_OPTIONS:     m_Options.Render();     break;
        default:                    assert( FALSE );        break;
    }
    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMoveMainMenu()
// Desc: Called once per frame for animating the main menu
//-----------------------------------------------------------------------------
VOID Menu::FrameMoveMainMenu( const XBGAMEPAD* pGamePad )
{
    if( pGamePad == NULL )
        return;

    // Detect menu change
    BOOL bMenuUp( FALSE );
    BOOL bMenuDown( FALSE );

    // Is the joystick active
    if( pGamePad->fY1 > JOY_THRESHOLD ||
        pGamePad->fY1 < -JOY_THRESHOLD )
    {
        // If we've previously registered a joystick menu move,
        // ignore the joystick until JOY_MIN_MENU_MOVE seconds
        // has elapsed
        if( m_JoyTimer.IsRunning() )
        {
            if( m_JoyTimer.GetElapsedSeconds() < JOY_MIN_MENU_MOVE )
                return;
            else
                m_JoyTimer.StartZero();
        }
        else
        {
            m_JoyTimer.StartZero();
        }

        if( pGamePad->fY1 > JOY_THRESHOLD )
            bMenuUp = TRUE;
        else
            bMenuDown = TRUE;
    }
    else
    {
        m_JoyTimer.Stop();
    }

    // Gamepad also moves menu cursor
    // TCR 3-17 Menu Navigation
    bMenuUp   = bMenuUp   || pGamePad->wPressedButtons & XINPUT_GAMEPAD_DPAD_UP;
    bMenuDown = bMenuDown || pGamePad->wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN;

    if( bMenuUp )
    {
        --m_iCurrIndex;
        if( m_iCurrIndex < 0 )
            m_iCurrIndex = m_iMaxItems - 1;
    }
    else if( bMenuDown )
    {
        ++m_iCurrIndex;
        if( m_iCurrIndex == m_iMaxItems )
            m_iCurrIndex = 0;
    }

    // "A" button
    // TCR 3-16 Menu Buttons
    if( pGamePad->bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        pGamePad->wPressedButtons & XINPUT_GAMEPAD_START )
    {
        switch( m_arrMenu[ m_iCurrIndex ] )
        {
            case MENU_ITEM_OPTIONS:
                ChangeMode( MENU_MODE_OPTIONS );
                break;
            default:
                break;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: RenderMainMenu()
// Desc: Called once per frame for 3d rendering of the menu
//-----------------------------------------------------------------------------
VOID Menu::RenderMainMenu()
{
    DWORD dwLang = CXBConfig::GetLanguage();

    if( m_MenuType == Normal )
    {
        if( dwLang != XC_LANGUAGE_JAPANESE )
            m_Font.DrawText( 320, 100, 0xFFFFFFFF, strGAME_NAME[ dwLang ],
                             XBFONT_CENTER_X );
        else
            m_XFontJPN.DrawText( 320, 100, 0xFFFFFFFF, strGAME_NAME[ dwLang ],
                             CXFONT_CENTER_X );
    }

    const DWORD dwHighlight = 0xffffff00; // Yellow
    const DWORD dwNormal    = 0xffffffff;

    FLOAT fYtop = 150.0f;
    FLOAT fYdelta = 50.0f;

    // Show menu
    for( INT i = 0; i < m_iMaxItems; ++i )
    {
        DWORD dwColor = ( m_iCurrIndex == i ) ? dwHighlight : dwNormal;

        if( dwLang != XC_LANGUAGE_JAPANESE )
            m_Font.DrawText( 260, fYtop + (fYdelta * i), dwColor, m_strMenu[i] );
        else
            m_XFontJPN.DrawText( 260, (LONG)fYtop + (LONG)(fYdelta * i), dwColor, m_strMenu[i] );
    }

    // 3-24 Selection User Interface
    // Show selected item with little triangle

    FLOAT fTop = fYtop + (fYdelta * m_iCurrIndex );
    //              Left,   Top,  Right,  Bottom
    D3DXVECTOR4 rc( 220.0f, fTop, 240.0f, fTop + 20.0f );

    // Show selected item
    struct TILEVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };
    TILEVERTEX* pVertices;

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    g_pd3dDevice->CreateVertexBuffer( 4 * sizeof( TILEVERTEX ), 
                                      D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW | D3DFVF_TEX1, 
                                      D3DPOOL_MANAGED, &pvbTemp );

    // Create a quad for us to render our texture on
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( rc.x - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Bottom Left
    pVertices[1].p = D3DXVECTOR4( rc.x - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Top    Left
    pVertices[2].p = D3DXVECTOR4( rc.z - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Bottom Right
    pVertices[3].p = D3DXVECTOR4( rc.z - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Top    Right
    pvbTemp->Unlock();

    // Set up our state
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( TILEVERTEX ) );

    // Render the quad with our texture
    g_pd3dDevice->SetTexture( 0, m_ptMenuSel );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    g_pd3dDevice->SetTexture( 0, NULL );
    pvbTemp->Release();

}




//-----------------------------------------------------------------------------
// Name: IsVibrationOn()
// Desc: Returns status of vibration
//-----------------------------------------------------------------------------
BOOL Menu::IsVibrationOn() const
{
    return m_Options.IsVibrationOn();
}




//-----------------------------------------------------------------------------
// Name: GetMusicVolume()
// Desc: Returns status of music volume
//-----------------------------------------------------------------------------
FLOAT Menu::GetMusicVolume() const
{
    return m_Options.GetMusicVolume();
}




//-----------------------------------------------------------------------------
// Name: GetEffectsVolume()
// Desc: Returns status of effects volume
//-----------------------------------------------------------------------------
FLOAT Menu::GetEffectsVolume() const
{
    return m_Options.GetEffectsVolume();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Menu.h ===
//-----------------------------------------------------------------------------
// File: Menu.h
//
// Desc: Main menu
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_MENU_H
#define TECH_CERT_GAME_MENU_H

#include "Common.h"
#include <XbStopWatch.h>
#include <XbResource.h>
#include "MenuOptions.h"

struct XBGAMEPAD;
class CXBFont;
class CXFont;



//-----------------------------------------------------------------------------
// Name: class Menu
// Desc: Main menu
//-----------------------------------------------------------------------------
class Menu
{

public:

    enum MenuItem
    {
        // Main menu
        MENU_ITEM_START,
        MENU_ITEM_LOAD_GAME,
        MENU_ITEM_OPTIONS,

        // Ingame menu
        MENU_ITEM_RESUME,
        MENU_ITEM_SAVE_GAME,
        MENU_ITEM_QUIT,

        MENU_ITEM_MAX
    };

    enum MenuType
    {
        Normal,
        InGame
    };

private:

    enum MenuMode
    {
        MENU_MODE_MAIN,     // main menu
        MENU_MODE_OPTIONS   // options
    };

	CXBPackedResource   m_xprResource;
    LPDIRECT3DTEXTURE8  m_ptMenuSel;
    CXBFont&            m_Font;
    CXFont&             m_XFontJPN;
    CXBStopWatch        m_InactiveTimer;
    CXBStopWatch        m_JoyTimer;
    MenuOptions         m_Options;
    MenuMode            m_MenuMode;
    MenuType            m_MenuType;
    MenuItem            m_arrMenu[ MENU_ITEM_MAX ];
    const WCHAR*        m_strMenu[ MENU_ITEM_MAX ];
    INT                 m_iCurrIndex;
    INT                 m_iMaxItems;

public:

    Menu( CXBFont&, CXFont& );

    VOID     Start( MenuType );   // Begin menu display
    VOID     End();               // End menu display

    MenuItem GetCurrItem() const;
    FLOAT    GetInactiveSeconds() const;
    BOOL     StartGame() const;
    BOOL     LoadGame() const;
    VOID     ChangeMode( MenuMode );
    VOID     FrameMoveMainMenu( const XBGAMEPAD* );
    VOID     RenderMainMenu();

    HRESULT  FrameMove( const XBGAMEPAD* );
    HRESULT  Render();

    BOOL     IsVibrationOn() const;
    FLOAT    GetMusicVolume() const;
    FLOAT    GetEffectsVolume() const;

private:

    // Disabled
    Menu( const Menu& );
    Menu& operator=( const Menu& );
};




#endif // TECH_CERT_GAME_MENU_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\math3d.h ===
//-----------------------------------------------------------------------------
// File: Math3d.h
//
// Desc: Math objects
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_MATH_H
#define TECH_CERT_GAME_MATH_H

#include "Common.h"
#pragma inline_depth(255)
#define inline __forceinline
#include <cfloat>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const FLOAT fPI = 3.14159f;




//-----------------------------------------------------------------------------
// Name: Clamp()
// Desc: Clamp value to the given range
//-----------------------------------------------------------------------------
template <class T>
T Clamp( T Minimum, T Value, T Maximum )
{
    if( Value < Minimum )
        return Minimum;

    if( Value > Maximum )
        return Maximum;

    return Value;
}




//-----------------------------------------------------------------------------
// Name: Sqr()
// Desc: Returns x * x
//-----------------------------------------------------------------------------
template <class T>
T Sqr( T x )
{
    return x * x;
}




//-----------------------------------------------------------------------------
// Name: Cube()
// Desc: Returns x * x * x
//-----------------------------------------------------------------------------
template <class T>
T Cube( T x )
{
    return x * x * x;
}




//-----------------------------------------------------------------------------
// Name: struct Vector3
// Desc: Simple wrapper around D3DXVECTOR3
//-----------------------------------------------------------------------------
struct Vector3 : public D3DXVECTOR3
{

public:

    inline Vector3();
    inline Vector3( FLOAT x, FLOAT y, FLOAT z );

    inline Vector3( const D3DXVECTOR3& );
    inline Vector3& operator=( const D3DXVECTOR3& );

    // Operators
    inline Vector3 operator-() const;
    inline Vector3 operator+( const Vector3& ) const;
    inline Vector3 operator-( const Vector3& ) const;
    inline Vector3 operator*( const FLOAT& ) const;
    inline FLOAT   operator*( const Vector3& ) const; // dot product
    inline Vector3 operator^( const Vector3& ) const; // cross product

    inline friend Vector3 operator*( const FLOAT&, const Vector3& );

    inline FLOAT GetLength() const;
    inline VOID Normalize();
    inline VOID Zero();
};




//-----------------------------------------------------------------------------
// Name: class Quaternion
// Desc: Simple wrapper around D3DXQUATERNION
//-----------------------------------------------------------------------------
class Quaternion : public D3DXQUATERNION
{

public:

    inline Quaternion(); // Identity rotation
    inline Quaternion( FLOAT x, FLOAT y, FLOAT z, FLOAT w );
    inline Quaternion( const D3DXQUATERNION& );
           Quaternion( const Vector3& v3Axis, FLOAT fAngle );

    inline Quaternion operator~() const;
    inline Quaternion operator*( const FLOAT& ) const;
    inline Quaternion operator*( const Quaternion& ) const;

    inline friend Vector3 operator*(const Vector3& v, const Quaternion& q);

    VOID Normalize();
};




//-----------------------------------------------------------------------------
// Name: class Matrix3
// Desc: Simple 3x3 matrix class
//-----------------------------------------------------------------------------
class Matrix3
{

public:

    FLOAT m[3][3];

public:

    inline Matrix3();  // Identity matrix
    inline Matrix3( FLOAT m00, FLOAT m01, FLOAT m02, 
                    FLOAT m10, FLOAT m11, FLOAT m12,
                    FLOAT m20, FLOAT m21, FLOAT m22);
           Matrix3( const Quaternion& );

           Matrix3 operator~() const;
           Matrix3 operator*( const Matrix3& ) const;

    inline friend Vector3 operator* (const Vector3& v, const Matrix3& m);

    inline Matrix3 GetTranspose() const;
    inline VOID Zero();

private:

    FLOAT Det2( INT r1, INT r2, INT c1, INT c2 ) const;
    FLOAT RowDotCol( INT row, const Matrix3& m3, INT col ) const;

};




//-----------------------------------------------------------------------------
// Name: class Plane3
// Desc: Simple wrapper around D3DXPLANE
//-----------------------------------------------------------------------------
class Plane3 : public D3DXPLANE
{

public:

    inline Plane3();
    inline Plane3( FLOAT a, FLOAT b, FLOAT c, FLOAT d );
    inline Plane3( const Vector3& v3Normal, const Vector3& v3Point );
    inline Plane3( const D3DXPLANE& );
           Plane3( const Vector3& v1, const Vector3& v2, const Vector3& v3 );

    inline Vector3 GetNormal() const;
    inline FLOAT   GetDistance( const Vector3& ) const;

};




//-----------------------------------------------------------------------------
// Name: class Transformation
// Desc: Simple transform class
//-----------------------------------------------------------------------------
class Transformation
{

    Quaternion m_qRotation;       // Quaterion for fast inversion/composition
    Vector3    m_v3Translation;   // Translation
    Matrix3    m_m3Rotation;      // Matrix for fast vector rotation

public:

    Transformation();
    Transformation( const Quaternion&, const Vector3& );

    Transformation operator~() const;
    Transformation operator*( const Transformation& ) const;

    friend Vector3 operator*( const Vector3&, const Transformation& );
    friend Plane3  operator*( const Plane3&, const Transformation& );

};




//-----------------------------------------------------------------------------
// Include inline functions
//-----------------------------------------------------------------------------
#include "Math3d.inl"




#endif // TECH_CERT_GAME_MATH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\MenuOptions.h ===
//-----------------------------------------------------------------------------
// File: MenuOptions.h
//
// Desc: Options menu
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_MENU_OPTIONS_H
#define TECH_CERT_GAME_MENU_OPTIONS_H

#include "Common.h"
#include <XbStopWatch.h>

struct XBGAMEPAD;
class CXBFont;
class CXFont;




//-----------------------------------------------------------------------------
// Name: class MenuOptions
// Desc: Options menu
//-----------------------------------------------------------------------------
class MenuOptions
{

    CXBFont&            m_Font;
    CXFont&             m_XFontJPN;
    LPDIRECT3DTEXTURE8  m_ptMenuSel;
    CXBStopWatch        m_JoyTimer;
    INT                 m_iCurrIndex;
    BOOL                m_bIsVibrationOn;
    FLOAT               m_fMusicVolume;
    FLOAT               m_fEffectVolume;
    BOOL                m_bExitMenu;

public:

    MenuOptions( CXBFont&, CXFont& );

    VOID     Start( LPDIRECT3DTEXTURE8 );       // Display options menu
    VOID     End();                             // Remove options menu

    HRESULT  FrameMove( const XBGAMEPAD* );
    HRESULT  Render();

    BOOL     ExitMenu() const;

    BOOL     IsVibrationOn() const;
    FLOAT    GetMusicVolume() const;
    FLOAT    GetEffectsVolume() const;

private:

    // Disabled
    MenuOptions( const MenuOptions& );
    MenuOptions& operator=( const MenuOptions& );

};




#endif // TECH_CERT_GAME_MENU_OPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\MenuOptions.cpp ===
//-----------------------------------------------------------------------------
// File: MenuOptions.cpp
//
// Desc: Options menu
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "MenuOptions.h"
#include "Controller.h"
#include "File.h"
#include "Text.h"
#include <XbApp.h>
#include <XbConfig.h>
#include <XbFont.h>
#include "cxfont.h"



//-----------------------------------------------------------------------------
// Local structs
//-----------------------------------------------------------------------------

// Format of the options file
struct Options
{
    BOOL  bIsVibrationOn;
    FLOAT fMusicVolume;
    FLOAT fEffectVolume;
};




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

const CHAR* const strOPTIONS_FILE = "T:\\GameOptions.opt";

// Can't change menu items w/ joystick any faster than this (seconds)
const FLOAT JOY_MIN_MENU_MOVE = 0.2f;

// Joystick must be at least this far away from the center position to register
// ( 0.0f - 1.0f scale )
const FLOAT JOY_THRESHOLD = 0.35f;

// Adjust volume by this amount per frame
const FLOAT fVOLUME_ADJUST = 1.0f;

// Max volume level (0.0f is minimum)
const FLOAT fVOLUME_MAX = 100.0f;

// Menu items
enum
{
    VIBRATION_INDEX,
    MUSIC_VOLUME_INDEX,
    EFFECT_VOLUME_INDEX,
    SAVE_INDEX,

    MENU_ITEM_MAX
};




//-----------------------------------------------------------------------------
// Name: MenuOptions()
// Desc: Constructor
//-----------------------------------------------------------------------------
MenuOptions::MenuOptions( CXBFont& font, CXFont &xFont )
:
    m_Font          ( font ),
    m_XFontJPN      ( xFont ),
    m_ptMenuSel     ( NULL ),
    m_JoyTimer      (),
    m_iCurrIndex    ( VIBRATION_INDEX ),
    m_bIsVibrationOn( TRUE ),
    m_fMusicVolume  ( fVOLUME_MAX ),
    m_fEffectVolume ( fVOLUME_MAX ),
    m_bExitMenu     ( FALSE )
{
    // Open the options file (if it exists)
    File OptionsFile;
    if( !OptionsFile.Open( strOPTIONS_FILE, GENERIC_READ, 0 ) )
        return;

    // Read option information from disk
    Options options;
    DWORD dwRead;
    if( !OptionsFile.Read( &options, sizeof( options ), dwRead ) )
        return;

    // Store options
    m_bIsVibrationOn = options.bIsVibrationOn;
    m_fMusicVolume   = options.fMusicVolume;
    m_fEffectVolume  = options.fEffectVolume;
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Called when option menu is initially displayed
//-----------------------------------------------------------------------------
VOID MenuOptions::Start( LPDIRECT3DTEXTURE8 ptMenuSel )
{
    m_ptMenuSel = ptMenuSel;
    m_iCurrIndex = VIBRATION_INDEX;
    m_bExitMenu = FALSE;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called when option menu is removed from screen
//-----------------------------------------------------------------------------
VOID MenuOptions::End()
{
    m_ptMenuSel = NULL;
    m_JoyTimer.Stop();

    // If we're exiting because of inactivity (e.g. attract mode is starting)
    // restore the old settings
    if( !m_bExitMenu )
    {
        // Open the options file
        File OptionsFile;
        if( OptionsFile.Open( strOPTIONS_FILE, GENERIC_READ, 0 ) )
        {
            // Read option information from disk
            Options options;
            DWORD dwRead;
            if( OptionsFile.Read( &options, sizeof( options ), dwRead ) )
            {
                // Store options locally
                m_bIsVibrationOn = options.bIsVibrationOn;
                m_fMusicVolume   = options.fMusicVolume;
                m_fEffectVolume  = options.fEffectVolume;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame for animating the menu
//-----------------------------------------------------------------------------
HRESULT MenuOptions::FrameMove( const XBGAMEPAD* pGamePad )
{
    if( pGamePad == NULL )
        return S_OK;

    // Detect menu change
    BOOL bMenuUp( FALSE );
    BOOL bMenuDown( FALSE );

    // Is the joystick active
    if( pGamePad->fY1 > JOY_THRESHOLD ||
        pGamePad->fY1 < -JOY_THRESHOLD )
    {
        // If we've previously registered a joystick menu move,
        // ignore the joystick until JOY_MIN_MENU_MOVE seconds
        // has elapsed
        if( m_JoyTimer.IsRunning() )
        {
            if( m_JoyTimer.GetElapsedSeconds() < JOY_MIN_MENU_MOVE )
                return S_OK;
            else
                m_JoyTimer.StartZero();
        }
        else
        {
            m_JoyTimer.StartZero();
        }

        if( pGamePad->fY1 > JOY_THRESHOLD )
            bMenuUp = TRUE;
        else
            bMenuDown = TRUE;
    }
    else
    {
        m_JoyTimer.Stop();
    }

    // Gamepad also moves menu cursor
    // TCR 3-17 Menu Navigation
    bMenuUp   = bMenuUp   || pGamePad->wPressedButtons & XINPUT_GAMEPAD_DPAD_UP;
    bMenuDown = bMenuDown || pGamePad->wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN;

    if( bMenuUp )
    {
        --m_iCurrIndex;
        if( m_iCurrIndex < 0 )
            m_iCurrIndex = MENU_ITEM_MAX - 1;
    }
    else if( bMenuDown )
    {
        ++m_iCurrIndex;
        if( m_iCurrIndex == MENU_ITEM_MAX )
            m_iCurrIndex = 0;
    }

    // "A" button
    // TCR 3-16 Menu Buttons
    if( pGamePad->bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] ||
        pGamePad->wPressedButtons & XINPUT_GAMEPAD_START )
    {
        if( m_iCurrIndex == VIBRATION_INDEX )
        {
            // TCR 3-56 Vibration Option
            // Toggle vibration state
            m_bIsVibrationOn = !m_bIsVibrationOn;
        }
        else if( m_iCurrIndex == SAVE_INDEX )
        {
            // Save option information to disk
            File OptionsFile;
            if( OptionsFile.Create( strOPTIONS_FILE, GENERIC_WRITE, 0 ) )
            {
                Options options;
                options.bIsVibrationOn = m_bIsVibrationOn;
                options.fMusicVolume   = m_fMusicVolume;
                options.fEffectVolume  = m_fEffectVolume;
                OptionsFile.Write( &options, sizeof( options ) );
            }
            m_bExitMenu = TRUE;
        }
    }

    // Handle volume control
    FLOAT fAdjust = 0.0f;
    if( pGamePad->fX2 > JOY_THRESHOLD || 
        ( pGamePad->wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT ) )
    {
        fAdjust = fVOLUME_ADJUST;
    }
    else if( pGamePad->fX2 < -JOY_THRESHOLD || 
          ( pGamePad->wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT ) )
    {
        fAdjust = -fVOLUME_ADJUST;
    }

    if( fAdjust != 0.0f )
    {
        switch( m_iCurrIndex )
        {
            // TCR 3-52 Game Soundtrack Volume Control
            case MUSIC_VOLUME_INDEX:
                m_fMusicVolume += fAdjust;
                break;
            // TCR 3-60 Game Sound Volume Control
            case EFFECT_VOLUME_INDEX:
                m_fEffectVolume += fAdjust;
                break;
        }

        // Clamp
        if( m_fMusicVolume > fVOLUME_MAX )
            m_fMusicVolume = fVOLUME_MAX;
        if( m_fEffectVolume > fVOLUME_MAX )
            m_fEffectVolume = fVOLUME_MAX;

        if( m_fMusicVolume < 0.0f )
            m_fMusicVolume = 0.0f;
        if( m_fEffectVolume < 0.0f )
            m_fEffectVolume = 0.0f;
    }

    // "B" button cancels
    if( pGamePad->bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] ||
        pGamePad->wPressedButtons & XINPUT_GAMEPAD_BACK )
    {
        // Restore default settings
        m_bIsVibrationOn = TRUE;
        m_fMusicVolume = m_fEffectVolume = fVOLUME_MAX;

        // Open the options file
        File OptionsFile;
        if( OptionsFile.Open( strOPTIONS_FILE, GENERIC_READ, 0 ) )
        {
            // Read option information from disk
            Options options;
            DWORD dwRead;
            if( OptionsFile.Read( &options, sizeof( options ), dwRead ) )
            {
                // Store options locally
                m_bIsVibrationOn = options.bIsVibrationOn;
                m_fMusicVolume   = options.fMusicVolume;
                m_fEffectVolume  = options.fEffectVolume;
            }
        }
        m_bExitMenu = TRUE;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame for 3d rendering of the menu
//-----------------------------------------------------------------------------
HRESULT MenuOptions::Render()
{
    DWORD dwLang = CXBConfig::GetLanguage();

    // Game name
    if( dwLang != XC_LANGUAGE_JAPANESE )
        m_Font.DrawText( 320, 100, 0xFFFFFFFF, strGAME_NAME[ dwLang ],
                         XBFONT_CENTER_X );
    else
        m_XFontJPN.DrawText( 320, 100, 0xFFFFFFFF, strGAME_NAME[ dwLang ],
                             CXFONT_CENTER_X );

    // Game options
    if( dwLang != XC_LANGUAGE_JAPANESE )
        m_Font.DrawText( 320, 150, 0xFFFFFFFF, strMENU_OPTIONS[ dwLang ],
                         XBFONT_CENTER_X );
    else
        m_XFontJPN.DrawText( 320, 150, 0xFFFFFFFF, strMENU_OPTIONS[ dwLang ],
                             CXFONT_CENTER_X );

    const WCHAR* strMenu[ MENU_ITEM_MAX ] =
    {
        strMENU_VIBRATION[ dwLang ],
        strMENU_MUSIC_VOLUME[ dwLang ],
        strMENU_EFFECT_VOLUME[ dwLang ],
        strMENU_SAVE_OPTIONS[ dwLang ]
    };

    const DWORD dwHighlight = 0xFFFFFF00; // Yellow
    const DWORD dwNormal    = 0xFFFFFFFF;

    FLOAT fYtop = 200.0f;
    FLOAT fYdelta = 50.0f;

    // Show menu
    for( INT i = 0; i < MENU_ITEM_MAX; ++i )
    {
        DWORD dwColor = ( m_iCurrIndex == i ) ? dwHighlight : dwNormal;

        if( dwLang != XC_LANGUAGE_JAPANESE )
            m_Font.DrawText( 150, fYtop + (fYdelta * i), dwColor, strMenu[i] );
        else
            m_XFontJPN.DrawText( 150, (LONG)fYtop + (LONG)(fYdelta * i), dwColor, strMenu[i] );

        switch( i )
        {
            case VIBRATION_INDEX:
                if( dwLang != XC_LANGUAGE_JAPANESE)
                    m_Font.DrawText( 360, fYtop + (fYdelta * i), dwColor, 
                                     m_bIsVibrationOn ? strON[ dwLang ] : 
                                                        strOFF[ dwLang ] );
                else
                    m_XFontJPN.DrawText( 360, (LONG)fYtop + (LONG)(fYdelta * i), dwColor, 
                                         m_bIsVibrationOn ? strON[ dwLang ] : 
                                                            strOFF[ dwLang ] );
                break;
            case MUSIC_VOLUME_INDEX:
            {
                struct BACKGROUNDVERTEX
                { 
                    D3DXVECTOR4 p;
                    D3DCOLOR color;
                };
                BACKGROUNDVERTEX v[4];
                FLOAT x1 = 360.0f;
                FLOAT x2 = x1 + (150.0f * m_fMusicVolume) / 100.0f;
                FLOAT y1 = fYtop + (fYdelta * i);
                FLOAT y2 = y1 + 20.0f;
                v[0].p = D3DXVECTOR4( x1 - 0.5f, y1 - 0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
                v[1].p = D3DXVECTOR4( x2 - 0.5f, y1 - 0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
                v[2].p = D3DXVECTOR4( x1 - 0.5f, y2 - 0.5f, 1.0f, 1.0f );  v[2].color = 0xff00ff00;
                v[3].p = D3DXVECTOR4( x2 - 0.5f, y2 - 0.5f, 1.0f, 1.0f );  v[3].color = 0xff00ff00;

                g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, 
                                                    D3DTOP_DISABLE );
                g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE );
                g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, 
                                               sizeof(v[0]) );

                WCHAR strPercent[32];
                wsprintfW( strPercent, L"%d %%", INT(m_fMusicVolume) );
                m_Font.DrawText( 520, fYtop + (fYdelta * i), dwColor, strPercent );
                break;
            }

            case EFFECT_VOLUME_INDEX:
            {
                struct BACKGROUNDVERTEX
                { 
                    D3DXVECTOR4 p;
                    D3DCOLOR color;
                };
                BACKGROUNDVERTEX v[4];
                FLOAT x1 = 360.0f;
                FLOAT x2 = x1 + (150.0f * m_fEffectVolume) / 100.0f;
                FLOAT y1 = fYtop + (fYdelta * i);
                FLOAT y2 = y1 + 20.0f;
                v[0].p = D3DXVECTOR4( x1 - 0.5f, y1 - 0.5f, 1.0f, 1.0f );  v[0].color = 0xffffffff;
                v[1].p = D3DXVECTOR4( x2 - 0.5f, y1 - 0.5f, 1.0f, 1.0f );  v[1].color = 0xffffffff;
                v[2].p = D3DXVECTOR4( x1 - 0.5f, y2 - 0.5f, 1.0f, 1.0f );  v[2].color = 0xff00ff00;
                v[3].p = D3DXVECTOR4( x2 - 0.5f, y2 - 0.5f, 1.0f, 1.0f );  v[3].color = 0xff00ff00;

                g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, 
                                                    D3DTOP_DISABLE );
                g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE );
                g_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, 
                                               sizeof(v[0]) );

                WCHAR strPercent[32];
                wsprintfW( strPercent, L"%d %%", INT(m_fEffectVolume) );
                m_Font.DrawText( 520, fYtop + (fYdelta * i), dwColor, strPercent );
                break;
            }
        }
    }

    // Show selected item with little triangle

    FLOAT fTop = fYtop + (fYdelta * m_iCurrIndex );
    //              Left,   Top,  Right,  Bottom
    D3DXVECTOR4 rc( 110.0f, fTop,  130.0f,  fTop + 20.0f );

    // Show selected item
    struct TILEVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };
    TILEVERTEX* pVertices;

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    g_pd3dDevice->CreateVertexBuffer( 4 * sizeof( TILEVERTEX ), 
                                      D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW | D3DFVF_TEX1, 
                                      D3DPOOL_MANAGED, &pvbTemp );

    // Create a quad for us to render our texture on
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( rc.x - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Bottom Left
    pVertices[1].p = D3DXVECTOR4( rc.x - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Top    Left
    pVertices[2].p = D3DXVECTOR4( rc.z - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Bottom Right
    pVertices[3].p = D3DXVECTOR4( rc.z - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Top    Right
    pvbTemp->Unlock();

    // Set up our state
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( TILEVERTEX ) );

    // Render the quad with our texture
    g_pd3dDevice->SetTexture( 0, m_ptMenuSel );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    g_pd3dDevice->SetTexture( 0, NULL );
    pvbTemp->Release();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ExitMenu()
// Desc: Returns TRUE if time to leave the options menu
//-----------------------------------------------------------------------------
BOOL MenuOptions::ExitMenu() const
{
    return m_bExitMenu;
}




//-----------------------------------------------------------------------------
// Name: IsVibrationOn()
// Desc: Returns status of vibration
//-----------------------------------------------------------------------------
BOOL MenuOptions::IsVibrationOn() const
{
    return m_bIsVibrationOn;
}




//-----------------------------------------------------------------------------
// Name: GetMusicVolume()
// Desc: Returns status of music volume
//-----------------------------------------------------------------------------
FLOAT MenuOptions::GetMusicVolume() const
{
    return m_fMusicVolume;
}




//-----------------------------------------------------------------------------
// Name: GetEffectsVolume()
// Desc: Returns status of effects volume
//-----------------------------------------------------------------------------
FLOAT MenuOptions::GetEffectsVolume() const
{
    return m_fEffectVolume;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\MenuResource.h ===
// Automatically generated by the bundler tool from MenuResource.rdf

#define MenuResource_NUM_RESOURCES 1UL

#define MenuResource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\math3d.inl ===
//-----------------------------------------------------------------------------
// File: Math3d.inl
//
// Desc: Inline math functions
//
// Hist: 03.14.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-------------------------------------------------------------------------
// Name: Vector3()
// Desc: Empty vector. No initialization for speed. Use Zero() to clear 
//-------------------------------------------------------------------------
inline Vector3::Vector3()
:
    D3DXVECTOR3()
{
}




//-------------------------------------------------------------------------
// Name: Vector3()
// Desc: Construct given params
//-------------------------------------------------------------------------
inline Vector3::Vector3( FLOAT x, FLOAT y, FLOAT z )
:
    D3DXVECTOR3( x, y, z )
{
}




//-------------------------------------------------------------------------
// Name: Vector3()
// Desc: Construct from D3DXVECTOR3
//-------------------------------------------------------------------------
inline Vector3::Vector3( const D3DXVECTOR3& v )
:
    D3DXVECTOR3( v )
{
}




//-------------------------------------------------------------------------
// Name: operator=()
// Desc: Copy from D3DXVECTOR3
//-------------------------------------------------------------------------
inline Vector3& Vector3::operator=( const D3DXVECTOR3& v )
{
    x = v.x;
    y = v.y;
    z = v.z;
}




//-------------------------------------------------------------------------
// Name: operator-()
// Desc: Negate
//-------------------------------------------------------------------------
inline Vector3 Vector3::operator-() const
{
    return Vector3( -x, -y, -z );
}




//-------------------------------------------------------------------------
// Name: operator+()
// Desc: Add
//-------------------------------------------------------------------------
inline Vector3 Vector3::operator+( const Vector3& rhs ) const
{
    return Vector3( x + rhs.x, y + rhs.y, z + rhs.z );
}




//-------------------------------------------------------------------------
// Name: operator-()
// Desc: Subtract
//-------------------------------------------------------------------------
inline Vector3 Vector3::operator-( const Vector3& rhs ) const
{
    return Vector3( x - rhs.x, y - rhs.y, z - rhs.z );
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Multiply by float
//-------------------------------------------------------------------------
inline Vector3 Vector3::operator*( const FLOAT& f ) const
{
    return Vector3( x*f, y*f, z*f );
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Dot product
//-------------------------------------------------------------------------
inline FLOAT Vector3::operator*( const Vector3& rhs ) const
{
    return x*rhs.x + y*rhs.y + z*rhs.z;
}




//-------------------------------------------------------------------------
// Name: operator^()
// Desc: Cross product
//-------------------------------------------------------------------------
inline Vector3 Vector3::operator^( const Vector3& rhs ) const
{
    return Vector3( y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x );
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Multiply float by vector
//-------------------------------------------------------------------------
inline Vector3 operator*( const FLOAT& f, const Vector3& v )
{
    return Vector3( v.x*f, v.y*f, v.z*f );
}




//-------------------------------------------------------------------------
// Name: GetLength()
// Desc: Vector length
//-------------------------------------------------------------------------
inline FLOAT Vector3::GetLength() const
{
    return FLOAT( sqrt( Sqr(x) + Sqr(y) + Sqr(z) ) );
}




//-------------------------------------------------------------------------
// Name: Normalize()
// Desc: Normalize vector
//-------------------------------------------------------------------------
inline VOID Vector3::Normalize()
{
    FLOAT len = GetLength();

    if( len >= FLT_MIN )
    {
        FLOAT r = 1.0f / len;
        x *= r; 
        y *= r;
        z *= r; 
    }
}




//-------------------------------------------------------------------------
// Name: Zero()
// Desc: Clear vector
//-------------------------------------------------------------------------
inline VOID Vector3::Zero()
{
    x = 0.0f;
    y = 0.0f;
    z = 0.0f;
}




//-------------------------------------------------------------------------
// Name: Quaternion()
// Desc: Construct identity rotation
//-------------------------------------------------------------------------
inline Quaternion::Quaternion()
:
    D3DXQUATERNION( 0.0f, 0.0f, 0.0f, 1.0f )
{
}




//-------------------------------------------------------------------------
// Name: Quaternion()
// Desc: Construct from given values
//-------------------------------------------------------------------------
inline Quaternion::Quaternion( FLOAT x, FLOAT y, FLOAT z, FLOAT w )
:
    D3DXQUATERNION( x, y, z, w )
{
}




//-------------------------------------------------------------------------
// Name: Quaternion()
// Desc: Construct from D3DXQUATERNION
//-------------------------------------------------------------------------
inline Quaternion::Quaternion( const D3DXQUATERNION& rhs )
:
    D3DXQUATERNION( rhs.x, rhs.y, rhs.z, rhs.w )
{
}




//-------------------------------------------------------------------------
// Name: operator~()
// Desc: Inverse
//-------------------------------------------------------------------------
inline Quaternion Quaternion::operator~() const
{
    return Quaternion( -x, -y, -z, w );
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Multiply by float
//-------------------------------------------------------------------------
inline Quaternion Quaternion::operator*( const FLOAT& f ) const
{
    return Quaternion( x*f, y*f, z*f, w*f );
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Multiply
//-------------------------------------------------------------------------
inline Quaternion Quaternion::operator*( const Quaternion& rhs ) const
{
    return Quaternion
    (
        w * rhs.x + x * rhs.w + y * rhs.z - z * rhs.y,
        w * rhs.y + y * rhs.w + z * rhs.x - x * rhs.z,
        w * rhs.z + z * rhs.w + x * rhs.y - y * rhs.x,
        w * rhs.w - x * rhs.x - y * rhs.y - z * rhs.z
    );  
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Transform vector by quaternion
//-------------------------------------------------------------------------
inline Vector3 operator*( const Vector3& v, const Quaternion& q )
{
    Vector3 qV( q.x, q.y, q.z );
    return 2.0f * (q.w * (qV ^ v) + (v * qV) * qV) + (q.w * q.w - (qV * qV)) * v;
}




//-------------------------------------------------------------------------
// Name: Matrix3()
// Desc: Identity matrix
//-------------------------------------------------------------------------
inline Matrix3::Matrix3()
{
    m[0][0] = 1.0f;
    m[0][1] = 0.0f;
    m[0][2] = 0.0f;

    m[1][0] = 0.0f;
    m[1][1] = 1.0f;
    m[1][2] = 0.0f;

    m[2][0] = 0.0f;
    m[2][1] = 0.0f;
    m[2][2] = 1.0f;
}




//-------------------------------------------------------------------------
// Name: Matrix3()
// Desc: Construct given values
//-------------------------------------------------------------------------
inline Matrix3::Matrix3( FLOAT m00, FLOAT m01, FLOAT m02, 
                         FLOAT m10, FLOAT m11, FLOAT m12,
                         FLOAT m20, FLOAT m21, FLOAT m22 )
{
    m[0][0] = m00;
    m[0][1] = m01;
    m[0][2] = m02;

    m[1][0] = m10;
    m[1][1] = m11;
    m[1][2] = m12;

    m[2][0] = m20;
    m[2][1] = m21;
    m[2][2] = m22;
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Transform vector by matrix
//-------------------------------------------------------------------------
inline Vector3 operator*( const Vector3& v, const Matrix3& m )
{
    return Vector3
    (
        v.x * m.m[0][0] + v.y * m.m[1][0] + v.z * m.m[2][0],
        v.x * m.m[0][1] + v.y * m.m[1][1] + v.z * m.m[2][1],
        v.x * m.m[0][2] + v.y * m.m[1][2] + v.z * m.m[2][2]
    );
}




//-------------------------------------------------------------------------
// Name: GetTranspose()
// Desc: Transposed matrix
//-------------------------------------------------------------------------
inline Matrix3 Matrix3::GetTranspose() const
{
    return Matrix3( m[0][0], m[1][0], m[2][0],
                    m[0][1], m[1][1], m[2][1],
                    m[0][2], m[1][2], m[2][2] );
}




//-------------------------------------------------------------------------
// Name: Zero()
// Desc: Clears matrix
//-------------------------------------------------------------------------
inline VOID Matrix3::Zero()
{
    m[0][0] = 0.0f;
    m[0][1] = 0.0f;
    m[0][2] = 0.0f;

    m[1][0] = 0.0f;
    m[1][1] = 0.0f;
    m[1][2] = 0.0f;

    m[2][0] = 0.0f;
    m[2][1] = 0.0f;
    m[2][2] = 0.0f;
}




//-------------------------------------------------------------------------
// Name: Det2()
// Desc: Determinate of the 2x2 sub-matrix consisting of rows r1, r2 
//       and columns c1 and c2.
//-------------------------------------------------------------------------
inline FLOAT Matrix3::Det2( INT r1, INT r2, INT c1, INT c2) const // private
{
    return m[r1][c1] * m[r2][c2] - m[r1][c2] * m[r2][c1];
}




//-------------------------------------------------------------------------
// Name: RowDotCol()
// Desc: Return a row of this matrix dotted with a column of matrix m.
//-------------------------------------------------------------------------
inline FLOAT Matrix3::RowDotCol( INT row, const Matrix3& m3, INT col ) const // private
{
    return m[row][0] * m3.m[0][col] 
         + m[row][1] * m3.m[1][col] 
         + m[row][2] * m3.m[2][col];
}





//-------------------------------------------------------------------------
// Name: Plane3()
// Desc: Construct empty plane
//-------------------------------------------------------------------------
inline Plane3::Plane3()
:
    D3DXPLANE()
{
}




//-------------------------------------------------------------------------
// Name: Plane3()
// Desc: Construct plane from plane params
//-------------------------------------------------------------------------
inline Plane3::Plane3( FLOAT a, FLOAT b, FLOAT c, FLOAT d )
:
    D3DXPLANE( a, b, c, d )
{
}




//-------------------------------------------------------------------------
// Name: Plane3()
// Desc: Construct plane given a normal and a point
//-------------------------------------------------------------------------
inline Plane3::Plane3( const Vector3& v3Normal, const Vector3& v3Point )
:
    D3DXPLANE( v3Normal.x, v3Normal.y, v3Normal.z, -(v3Normal * v3Point) )
{
}




//-------------------------------------------------------------------------
// Name: Plane3()
// Desc: Construct from D3DXPLANE
//-------------------------------------------------------------------------
inline Plane3::Plane3( const D3DXPLANE& rhs )
:
    D3DXPLANE( rhs.a, rhs.b, rhs.c, rhs.d )
{
}




//-------------------------------------------------------------------------
// Name: GetNormal()
// Desc: Vector normal to the plane
//-------------------------------------------------------------------------
inline Vector3 Plane3::GetNormal() const
{
    return Vector3( a, b, c );
}




//-------------------------------------------------------------------------
// Name: GetDistance()
// Desc: Distance from plane to point
//-------------------------------------------------------------------------
inline FLOAT Plane3::GetDistance( const Vector3& v ) const
{
    return v.x * a + v.y * b + v.z * c + d;
}





//-------------------------------------------------------------------------
// Name: Transformation()
// Desc: Construct empty transformation
//-------------------------------------------------------------------------
inline Transformation::Transformation()
:
    m_qRotation(),
    m_v3Translation( 0.0f, 0.0f, 0.0f ),
    m_m3Rotation() // identity
{
}




//-------------------------------------------------------------------------
// Name: Transformation()
// Desc: Construct from quat and vector
//-------------------------------------------------------------------------
inline Transformation::Transformation( const Quaternion& q, const Vector3& v )
:
    m_qRotation( q ),
    m_v3Translation( v ),
    m_m3Rotation( q )
{
}




//-------------------------------------------------------------------------
// Name: operator~()
// Desc: Transformation inverse
//-------------------------------------------------------------------------
inline Transformation Transformation::operator~() const
{
    Quaternion qInverse = ~m_qRotation;
    return Transformation( qInverse, -m_v3Translation * qInverse );
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Transformation composition
//-------------------------------------------------------------------------
inline Transformation Transformation::operator*
                                        ( const Transformation& rhs ) const
{
    return Transformation( m_qRotation * rhs.m_qRotation, 
                           m_v3Translation * rhs.m_m3Rotation + 
                           rhs.m_v3Translation );
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Transform a vector by Transformation
//-------------------------------------------------------------------------
inline Vector3 operator*( const Vector3& v, const Transformation& tf )
{
    return v * tf.m_m3Rotation + tf.m_v3Translation;
}




//-------------------------------------------------------------------------
// Name: operator*()
// Desc: Transform a plane by Transformation
//-------------------------------------------------------------------------
inline Plane3 operator*( const Plane3& pl, const Transformation& tf )
{
    Vector3 vNormal = pl.GetNormal() * tf.m_m3Rotation;
    FLOAT d = pl.d - ( vNormal * tf.m_v3Translation );
    return Plane3( vNormal.x, vNormal.y, vNormal.z, d );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\PerfTimer.h ===
//-----------------------------------------------------------------------------
// File: PerfTimer.cpp
//
// Desc: Performance timers
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

typedef __int64 TimeStamp;

void GetTimeStamp(TimeStamp* pStamp);

double SecondsElapsed(const TimeStamp& ts1, const TimeStamp& ts2);



inline void GetTimeStamp(TimeStamp* pStamp)
{
	__asm
	{
		mov		esi,[pStamp]
		rdtsc
		mov		[esi],eax
		mov		[esi+4],edx
	}
}



inline double SecondsElapsed(const TimeStamp& ts1, const TimeStamp& ts2)
{
	return double(ts2 - ts1) * (1.0 / 800e6);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\MusicManager.cpp ===
//-----------------------------------------------------------------------------
// File: MusicManager.cpp
//
// Desc: Implementation file for CMusicManager class.
//
// Hist: 8.20.01 - New for October XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "musicmanager.h"
#include "XbUtil.h"
#include <assert.h>
#include <stdio.h>
#include <tchar.h>



//
// Here is our game soundtrack including WMA files we ship
// with our game.  If needed, this concept could be extended
// to include several different game soundtracks
//

// Structure representing game soundtrack song
typedef struct {
    WCHAR * szName;
    CHAR *  szFilename;
    DWORD   dwLength;
} MM_SONG;

MM_SONG g_aGameSoundtrack[] =
{
    { L"Becky", "D:\\Media\\Sounds\\default.wma", 165000 },
};

#define NUM_GAME_SONGS ( sizeof( g_aGameSoundtrack ) / sizeof( g_aGameSoundtrack[0] ) )

#define WORKER_THREAD_STACK_SIZE 12 * 1024
#define WMA_LOOKAHEAD 64 * 1024
#define YIELD_RATE 3

//
// The following methods are safe to be called from the main rendering thread.
// In order to avoid CPU-intensive thread synchronization, we assume that only
// one thread will ever be calling into these functions.  That way, we know
// that if there is no state change already pending, then the state cannot 
// possibly change during a function call.  Threading issues are noted for
// each of these functions
//

//-----------------------------------------------------------------------------
// Name: CMusicManager (ctor)
// Desc: Initializes member variables
// Thread issues: None - worker thread is not created yet.
//-----------------------------------------------------------------------------
CMusicManager::CMusicManager()
{
    m_mmOldState    = MM_STOPPED;
    m_mmState       = MM_STOPPED;
    m_fRandom       = FALSE;
    m_fGlobal       = TRUE;
    m_lVolume       = DSBVOLUME_MAX;
    m_dwStream      = 0;
    m_dwSong        = 0;
    m_szSong[0]     = 0;
    m_dwLength      = 0;
    m_dwSongID      = 0;

    m_aSoundtracks          = NULL;
    m_uSoundtrackCount      = 0;
    m_uCurrentSoundtrack    = 0;
    m_dwPacketsCompleted    = 0;

    m_pbSampleData  = NULL;
    m_pDecoder      = NULL;
    m_pStream[0]    = NULL;
    m_pStream[1]    = NULL;
    m_hDecodingFile = INVALID_HANDLE_VALUE;

    m_hThread           = INVALID_HANDLE_VALUE;
    m_hShutdownEvent    = INVALID_HANDLE_VALUE;

    for( INT i = 0; i < PACKET_COUNT + EXTRA_PACKETS; i++ )
        m_adwPacketStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;
}


//-----------------------------------------------------------------------------
// Name: ~CMusicManager (dtor)
// Desc: Releases any resources allocated by the object
// Thread issues: This function waits for the worker thread to shut down
//                before continuing processing.  
//-----------------------------------------------------------------------------
CMusicManager::~CMusicManager()
{
    // Signal our worker thread to shutdown, then wait for it
    // before releasing objects
    if( m_hShutdownEvent != INVALID_HANDLE_VALUE )
        SetEvent( m_hShutdownEvent );
    
    if( m_hThread != INVALID_HANDLE_VALUE )
    {
        WaitForSingleObject( m_hThread, INFINITE );
        CloseHandle( m_hThread );
    }

    // We can't close the handle until we're sure the worker
    // thread has terminated.
    if( m_hShutdownEvent != INVALID_HANDLE_VALUE )
        CloseHandle( m_hShutdownEvent );

    // Now that we've shut down the worker thread, it's safe
    // to clean these guys up.
    if( m_pStream[0] )
    {
        m_pStream[0]->Pause( DSSTREAMPAUSE_RESUME );
        m_pStream[0]->Release();
    }

    if( m_pStream[1] )
    {
        m_pStream[1]->Pause( DSSTREAMPAUSE_RESUME );
        m_pStream[1]->Release();
    }

    if( m_pbSampleData )
        delete[] m_pbSampleData;

    free( m_aSoundtracks );

}


//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Sets up the object to run
// Thread issues: None - worker thread isn't created until end of function
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Initialize( BOOL bSpinThread /* TRUE */ )
{
    HRESULT hr;

    // Load up soundtrack information
    hr = LoadSoundtracks();
    if( FAILED( hr ) )
        return hr;
    SelectSong( 0 );

    srand( GetTickCount() );

    // Soundtrack songs are ripped to this format.  Any individual
    // WMA tracks shipped with the game will need to be encoded
    // similarly.
    // Alternately, streams could be released and re-created when
    // switching tracks, but this would incur additional CPU costs.  
    // In the future, a SetFormat() routine on DirectSound streams 
    // and buffers will make this simpler.
    WAVEFORMATEX wfx = {0};
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 2;
    wfx.nSamplesPerSec = 44100;
    wfx.wBitsPerSample = 16;
    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;

    // Set up a stream desc to create our streams
    DSSTREAMDESC dssd = {0};
    dssd.dwMaxAttachedPackets = PACKET_COUNT;
    dssd.lpwfxFormat = &wfx;
    dssd.lpfnCallback = StreamCallback;
    dssd.lpvContext = this;

    // Create the streams
    hr = DirectSoundCreateStream( &dssd, &m_pStream[0] );
    if( FAILED( hr ) )
        return hr;
    hr = DirectSoundCreateStream( &dssd, &m_pStream[1] );
    if( FAILED( hr ) )
        return hr;

    // Pump the music through the rear speakers (slightly quieter)
    // as well as through the LFE (left + right channels mixed at
    // -6dB to come out full scale)
    DSMIXBINVOLUMEPAIR mixbins[] = { 
        { DSMIXBIN_FRONT_LEFT,      0 },
        { DSMIXBIN_FRONT_RIGHT,     0 },
        { DSMIXBIN_BACK_LEFT,       -600 },
        { DSMIXBIN_BACK_RIGHT,      -600 },
        { DSMIXBIN_LOW_FREQUENCY,   -600 },
        { DSMIXBIN_LOW_FREQUENCY,   -600 },
    };
    DSMIXBINS dsmb = { 6, mixbins };
    m_pStream[0]->SetMixBins( &dsmb );
    m_pStream[1]->SetMixBins( &dsmb );

    // Set up attack envelopes to fade in for us
    DSENVELOPEDESC dsed = {0};
    dsed.dwEG = DSEG_AMPLITUDE;
    dsed.dwMode = DSEG_MODE_ATTACK;
    dsed.dwAttack = DWORD(48000 * FADE_TIME / 512);
    dsed.dwRelease = DWORD(48000 * FADE_TIME / 512);
    dsed.dwSustain = 255;
    m_pStream[0]->SetEG( &dsed );
    m_pStream[1]->SetEG( &dsed );

    // Allocate sample data buffer
    m_pbSampleData = new BYTE[ ( PACKET_COUNT + EXTRA_PACKETS ) * PACKET_SIZE ];
    if( !m_pbSampleData )
        return E_OUTOFMEMORY;

#if _DEBUG
    if( FAILED( DebugVerify() ) )
        return E_FAIL;
#endif // _DEBUG

    if( bSpinThread )
    {
        // Create an event to signal the worker thread to shutdown
        m_hShutdownEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        if( NULL == m_hShutdownEvent )
            return E_FAIL;

        // Create the worker thread
        m_hThread = CreateThread( NULL, WORKER_THREAD_STACK_SIZE, MusicManagerThreadProc, this, 0, NULL );
        if( NULL == m_hThread )
        {
            return E_FAIL;
        }
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Play
// Desc: Starts playing background music
// Thread issues: Depends on worker thread state:
//                MM_PLAYING: No effective change.  Worker thread could be
//                            processing a state change to MM_PAUSED or
//                            MM_STOPPED, in which case we will switch back
//                            to MM_PLAYING on the next iteration of Process()
//                MM_PAUSED:  Next iteration of Process() will pick up the 
//                            state change and resume playback
//                MM_STOPPED: Next iteration of Process() will pick up the
//                            state change and stop playback
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Play()
{
    // Can always transition to playing
    m_mmState = MM_PLAYING;
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Stop
// Desc: Stops background music playback
// Thread issues: Depends on worker thread state:
//                MM_PLAYING: Next iteration of Process() will pick up the
//                            state change and stop playback
//                MM_PAUSED:  Next iteration of Process() will pick up the 
//                            state change and resume playback
//                MM_STOPPED: No effective change.  Worker thread could be
//                            processing a state change to MM_PLAYING, in
//                            which case we will switch back to MM_STOPPED
//                            on the next iteration of Process()
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Stop()
{
    // Can always transition to stopped
    if( m_mmOldState != MM_STOPPED &&
        m_mmState    != MM_STOPPED )
    {
        m_mmState = MM_STOPPED;

        // Pause the streams right now so that we
        // stop playback.  They'll get shut down
        // fully on the worker thread
        m_pStream[0]->Pause( DSSTREAMPAUSE_PAUSE );
        m_pStream[1]->Pause( DSSTREAMPAUSE_PAUSE );
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Pause
// Desc: Pauses background music playback
// Thread issues: Since we can only transition to MM_PAUSED from MM_PLAYING,
//                make sure that we're already at MM_PLAYING, and don't have
//                a pending state change.  Next iteration of Process() will
//                pick up the change to MM_PAUSED and pause playback
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Pause()
{
    // Can only transition to paused from playing.
    if( m_mmOldState == MM_PLAYING &&
        m_mmState == MM_PLAYING )
    {
        m_pStream[0]->Pause( DSSTREAMPAUSE_PAUSE );
        m_pStream[1]->Pause( DSSTREAMPAUSE_PAUSE );
        m_mmState = MM_PAUSED;
        return S_OK;
    }

    return S_FALSE;
}



//-----------------------------------------------------------------------------
// Name: SetRandom
// Desc: Sets the playback mode for how to pick the next song.  If fRandom is
//       true, the next track is picked randomly, otherwise it's sequential.
//       If fGlobal is true, we'll move between soundtracks, otherwise we stay
//       within the current soundtrack
// Thread issues: The worker thread could be in the middle of picking which
//                track to play next.  The new setting may or may not be 
//                used, depending on exactly when the calls occurs.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SetRandom( BOOL fRandom )
{
    m_fRandom = fRandom;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SetGlobal
// Desc: Sets the playback mode for how to pick the next song.  If fGlobal is 
//       true, we'll move between soundtracks, otherwise we stay  within the 
//       current soundtrack
// Thread issues: The worker thread could be in the middle of picking which
//                track to play next.  The new setting may or may not be 
//                used, depending on exactly when the calls occurs.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SetGlobal( BOOL fGlobal )
{
    m_fGlobal = fGlobal;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SetVolume
// Desc: Sets the overall volume level for music playback.  Note that this
//       won't really work properly until we start using envelope release
// Thread issues: None - the worker thread doesn't set volume levels.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SetVolume( LONG lVolume )
{
    assert( m_pStream[0] && m_pStream[1] );

    m_lVolume = lVolume;
    m_pStream[0]->SetVolume( lVolume );
    m_pStream[1]->SetVolume( lVolume );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: GetCurrentInfo
// Desc: Returns pointers to info.  Buffers should be appropriately sized, ie
//       MAX_SOUNDTRACK_NAME and MAX_SONG_NAME, respectively
// Thread issues: The worker thread could be in the middle of switching
//                between songs and/or soundtracks.  In this case, we could
//                return mixed information.  This is OK, since this is meant
//                to be called periodically to update state, so the results
//                will eventually be consistent.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::GetCurrentInfo( WCHAR * szSoundtrack, WCHAR * szSong, DWORD * pdwLength )
{
    if( szSoundtrack )
        m_aSoundtracks[ m_uCurrentSoundtrack ].GetSoundtrackName( szSoundtrack );
    if( szSong )
        wcscpy( szSong, m_szSong );
    if( pdwLength )
        *pdwLength = m_dwLength;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: GetPlaybackPosition
// Desc: Returns the current playback position, in seconds
//-----------------------------------------------------------------------------
FLOAT
CMusicManager::GetPlaybackPosition()
{
    return PACKET_TIME * m_dwPacketsCompleted;
}



//-----------------------------------------------------------------------------
// Name: NextSoundtrack
// Desc: Switches to the next soundtrack.  This is only safe to do if playback
//       is stopped, and we don't have a state change pending.  
// Thread issues: The worker thread could be trying to switch songs or 
//                soundtracks, so we can't make a call unless we know that
//                the worker thread is in MM_STOPPED and will stay there for
//                the duration of this call
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::NextSoundtrack()
{
    if( m_mmOldState == MM_STOPPED &&
        m_mmState    == MM_STOPPED )
    {
        return SelectSoundtrack( ( m_uCurrentSoundtrack + 1 ) % m_uSoundtrackCount );
    }

    return S_FALSE;
}



//-----------------------------------------------------------------------------
// Name: NextSong
// Desc: Switches to the next song in the current soundtrack.  This is only 
//       safe to do if playback is stopped, and we don't have a state change 
//       pending.
// Thread issues: The worker thread could be trying to switch songs or 
//                soundtracks, so we can't make a call unless we know that
//                the worker thread is in MM_STOPPED and will stay there for
//                the duration of this call
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::NextSong()
{
    if( m_mmOldState == MM_STOPPED &&
        m_mmState    == MM_STOPPED )
    {
        return SelectSong( ( m_dwSong + 1 ) % m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() );
    }

    return S_FALSE;
}




//-----------------------------------------------------------------------------
// Name: RandomSong
// Desc: Switches to a random song, either in this soundtrack if fGlobal is
//       FALSE or globally random if fGlobal is TRUE.  This is only safe
//       to do if playback is stopped, and we don't have a state change 
//       pending.
// Thread issues: The worker thread could be trying to switch songs or 
//                soundtracks, so we can't make a call unless we know that
//                the worker thread is in MM_STOPPED and will stay there for
//                the duration of this call
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::RandomSong( BOOL fGlobal )
{
    if( m_mmOldState == MM_STOPPED &&
        m_mmState    == MM_STOPPED )
    {
        if( fGlobal )
        {
            SelectSoundtrack( rand() % m_uSoundtrackCount );
        }
        return SelectSong( rand() % m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() );
    }
    else
        return S_FALSE;
}




//
// The following methods are not public and are meant only to be called 
// internally by the CMusicManager class.  Any tricky threading issues are
// pointed out as needed.
//



//-----------------------------------------------------------------------------
// Name: LoadSoundtracks
// Desc: Loads soundtrack info for user soundtracks stored on HD
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::LoadSoundtracks()
{
    HANDLE hSoundtrack;
    XSOUNDTRACK_DATA stData;
    UINT uAllocatedSoundtracks;

    m_aSoundtracks = (CSoundtrack *)malloc( sizeof( CSoundtrack ) );
    if( !m_aSoundtracks )
        return E_OUTOFMEMORY;
    uAllocatedSoundtracks = 1;

    // Set up our game soundtrack as soundtrack 0.
    // If we had more than 1 game soundtrack, we could
    // set them all up here
    m_aSoundtracks[0].m_fGameSoundtrack     = TRUE;
    m_aSoundtracks[0].m_uSoundtrackIndex    = 0;
    m_aSoundtracks[0].m_uSongCount          = NUM_GAME_SONGS;
    wcscpy( m_aSoundtracks[0].m_szName, L"Game Soundtrack" );
    m_uSoundtrackCount = 1;

    // Start scanning the soundtrack DB
    hSoundtrack = XFindFirstSoundtrack( &stData );
    if( INVALID_HANDLE_VALUE != hSoundtrack )
    {
        do
        {
            // Double our buffer if we need more space
            if( m_uSoundtrackCount + 1 > uAllocatedSoundtracks )
            {
                void * pNewAlloc = realloc( m_aSoundtracks, ( uAllocatedSoundtracks * 2 ) * sizeof( CSoundtrack ) );
                if( !pNewAlloc )
                {
                    // We couldn't expand our buffer, so clean up
                    // and bail out
                    free( m_aSoundtracks );
                    m_aSoundtracks = NULL;
                    XFindClose( hSoundtrack );
                    return E_OUTOFMEMORY;
                }
                m_aSoundtracks = (CSoundtrack *)pNewAlloc;
                uAllocatedSoundtracks *= 2;
            }

            // Ignore empty soundtracks
            if( stData.uSongCount > 0 )
            {
                // Copy the data over
                m_aSoundtracks[ m_uSoundtrackCount ].m_fGameSoundtrack = FALSE;
                m_aSoundtracks[ m_uSoundtrackCount ].m_uSoundtrackID   = stData.uSoundtrackId;
                m_aSoundtracks[ m_uSoundtrackCount ].m_uSongCount      = stData.uSongCount;
                wcscpy( m_aSoundtracks[ m_uSoundtrackCount ].m_szName, stData.szName );

                m_uSoundtrackCount++;
            }

        } while( XFindNextSoundtrack( hSoundtrack, &stData ) );

        XFindClose( hSoundtrack );
    }

    // Shrink our allocation down to what's actually needed, since
    // we can't add soundtracks on the fly
    m_aSoundtracks = (CSoundtrack *)realloc( m_aSoundtracks, m_uSoundtrackCount * sizeof( CSoundtrack ) );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: SelectSoundtrack
// Desc: Changes to the specified soundtrack
// NOTE: This should only be called by the worker thread OR
//       after making sure that playback is stopped with no state change
//       pending.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SelectSoundtrack( DWORD dwSoundtrack )
{
    m_uCurrentSoundtrack = dwSoundtrack;
    SelectSong( 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SelectSong
// Desc: Switches to the specified song and caches song info
// NOTE: This should only be called by the worker thread OR
//       after making sure that playback is stopped with no state change
//       pending.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::SelectSong( DWORD dwSong )
{
    m_dwSong = dwSong;
    m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongInfo( m_dwSong,
                                                        &m_dwSongID,
                                                        &m_dwLength,
                                                        m_szSong );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindNextSong
// Desc: Simple helper function to switch to the next song, based on the
//       global repeat flag.
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::FindNextSong()
{
    if( m_fRandom )
    {
        if( m_fGlobal )
        {
            SelectSoundtrack( rand() % m_uSoundtrackCount );
        }
        SelectSong( rand() % m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() );
    }
    else
    {
        if( m_fGlobal && 
            m_dwSong == m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() - 1 )
        {
            SelectSoundtrack( ( m_uCurrentSoundtrack + 1 ) % m_uSoundtrackCount );
        }
        else
            SelectSong( ( m_dwSong + 1 ) % m_aSoundtracks[ m_uCurrentSoundtrack ].GetSongCount() );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Prepare
// Desc: Prepares to begin playback of the currently set track:
//       1) Clean up the old decoder, if we already had one
//       2) Create a new decoder on the soundtrack handle or our WMA file
//       3) Lower the volume on the output stream for the crossfade
//       4) Mark the start time of the track for rough timing
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Prepare()
{
    WAVEFORMATEX wfx;

    // Kill the old decoder
    Cleanup();

    // Open soundtrack file
    m_hDecodingFile = m_aSoundtracks[ m_uCurrentSoundtrack ].OpenSong( m_dwSongID );
    if( INVALID_HANDLE_VALUE == m_hDecodingFile )
        return E_FAIL;

    // Create the decoder
    if( FAILED( WmaCreateDecoderEx( NULL, 
                                    m_hDecodingFile, 
                                    FALSE,              // Synchronous
                                    WMA_LOOKAHEAD,      // 64k lookahead
                                    PACKET_COUNT,       // # of packets
                                    YIELD_RATE,         // Yield rate
                                    &wfx,               // We know the format already
                                    &m_pDecoder ) ) )   // New decoder
        return E_FAIL;

    // Remember when we started
    m_dwPacketsCompleted = 0;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Cleans up decoding resources
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Cleanup()
{
    // Close soundtrack file, if that's what we had
    if( INVALID_HANDLE_VALUE != m_hDecodingFile )
    {
        CloseHandle( m_hDecodingFile );
        m_hDecodingFile = INVALID_HANDLE_VALUE;
    }

    // Free up the decoder
    if( m_pDecoder )
    {
        m_pDecoder->Release();
        m_pDecoder = NULL;
    }

    m_dwPacketsCompleted = 0;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Process
// Desc: Manages audio packets, filling them from the source XMO and 
//       dispatching them to the appropriate stream.
// Thread issues: This function manages state changes requested from the
//                main game thread.  The main game thread will INT a new value
//                for m_mmState, and then the worker thread will transition
//                to that state as appropriate
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::Process()
{
    HRESULT hr;
    DWORD   dwPacket;
    MM_STATE mmCurrentState = m_mmState;

    // Check to see if our state has changed from a call
    // from the main rendering loop, and if it has,
    // update accordingly.
    if( m_mmOldState != mmCurrentState )
    {
        // We can't transition from MM_STOPPED to
        // anything but MM_PLAYING
        assert( !( m_mmOldState == MM_STOPPED &&
                   mmCurrentState != MM_PLAYING ) );

        switch( m_mmOldState )
        {
        //
        // Valid transitions from MM_STOPPED:
        // -> MM_PLAYING = Prepare to play
        //
        case MM_STOPPED:
            switch( mmCurrentState )
            {
            case MM_PLAYING:
                // Make sure the streams are unpaused
                m_pStream[0]->Pause( DSSTREAMPAUSE_RESUME );
                m_pStream[1]->Pause( DSSTREAMPAUSE_RESUME );
                Prepare();
                break;
            }
            break;

        //
        // Valid transitions from MM_PAUSED:
        // -> MM_PLAYING = Resume playback
        // -> MM_STOPPED = Stop playback and clean up
        //
        case MM_PAUSED:
            switch( mmCurrentState )
            {
            case MM_PLAYING:
                m_pStream[0]->Pause( DSSTREAMPAUSE_RESUME );
                m_pStream[1]->Pause( DSSTREAMPAUSE_RESUME );
                break;
            case MM_STOPPED:
                m_pStream[0]->Flush();
                m_pStream[1]->Flush();
                Cleanup();
                break;
            }
            break;

        //
        // Valid transitions from MM_PLAYING:
        // -> MM_PAUSED = Pause streams (already done)
        // -> MM_STOPPED = Stop playback and clean up
        case MM_PLAYING:
            switch( mmCurrentState )
            {
            case MM_STOPPED:
                m_pStream[0]->Flush();
                m_pStream[1]->Flush();
                Cleanup();
                break;
            }
            break;
        }

        // We're done with the transition.  At this point,
        // we're really in the appropriate state, and the
        // other thread can push a new state change through
        m_mmOldState = mmCurrentState;
    }


    // If we're currently playing, then process packets
    // and fades
    if( mmCurrentState == MM_PLAYING )
    {
        // Process packets
        while( FindFreePacket( &dwPacket, m_dwStream ) )
        {
            XMEDIAPACKET xmp;

            hr = ProcessSource( dwPacket, &xmp );
            if( FAILED( hr ) )
                return hr;

            // Make sure we got data from the decoder.  When we
            // hit the end of a track, we may end up with an
            // empty packet.  We'll just loop again and fill it
            // up from the next track.
            if( xmp.dwMaxSize )
            {
                hr = ProcessStream( dwPacket, &xmp );
                if( FAILED( hr ) )
                    return hr;
            }
        }
    }


    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Looks for a free audio packet.  Returns TRUE if one was found and
//       returns the index
//-----------------------------------------------------------------------------
BOOL CMusicManager::FindFreePacket( DWORD * pdwPacket, DWORD dwStream )
{
    for( DWORD dwIndex = dwStream; dwIndex < PACKET_COUNT; dwIndex += 2 )
    {
        // The first EXTRA_PACKETS * 2 packets are reserved - odd packets
        // for stream 1, even packets for stream 2.  This is to ensure
        // that there are packets available during the crossfade
        if( XMEDIAPACKET_STATUS_PENDING != m_adwPacketStatus[ dwIndex ] &&
            ( dwIndex > EXTRA_PACKETS * 2 || dwIndex % 2 == dwStream ) )
        {
            if( pdwPacket )
                *pdwPacket = dwIndex;
            return TRUE;
        }
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: ProcessSource
// Desc: Fills audio packets from the decoder XMO
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::ProcessSource( DWORD dwPacket, XMEDIAPACKET * pxmp )
{
    HRESULT      hr;
    DWORD        dwBytesDecoded;

    // Set up the XMEDIAPACKET structure
    ZeroMemory( pxmp, sizeof( XMEDIAPACKET ) );
    pxmp->pvBuffer          = m_pbSampleData + dwPacket * PACKET_SIZE;
    pxmp->dwMaxSize         = PACKET_SIZE;
    pxmp->pdwCompletedSize  = &dwBytesDecoded;

    hr = m_pDecoder->Process( NULL, pxmp );
    if( FAILED( hr ) )
        return hr;

    if( 0 == dwBytesDecoded )
    {
        // We hit the end of the current track.  Key the fade-out
        m_pStream[ m_dwStream ]->Discontinuity();
        m_pStream[ m_dwStream ]->FlushEx( 0, DSSTREAMFLUSHEX_ASYNC | DSSTREAMFLUSHEX_ENVELOPE );

        // Clean up resources from this song, and get
        // ready for the next one:
        Cleanup();
        FindNextSong();
        m_dwStream = ( m_dwStream + 1 ) % 2;
        Prepare();

    }
    pxmp->dwMaxSize = dwBytesDecoded;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: ProcessStream
// Desc: Submits audio packets to the appropriate stream
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::ProcessStream( DWORD dwPacket, XMEDIAPACKET * pxmp )
{
    HRESULT      hr;

    // The XMEDIAPACKET should already have been filled out
    // by the call to ProcessSource().  In addition, ProcessSource()
    // should have properly set the dwMaxSize member to reflect
    // how much data was decoded.
    pxmp->pdwStatus = &m_adwPacketStatus[ dwPacket ];
    pxmp->pdwCompletedSize = NULL;
    pxmp->pContext = (LPVOID)m_dwStream;

    hr = m_pStream[ m_dwStream ]->Process( pxmp, NULL );
    if( FAILED( hr ) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: MusicManagerDoWork
// Desc: Workhorse function for the CMusicManager class.  Either called by
//       the MusicManager's threadproc, or manually by a game worker thread
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::MusicManagerDoWork()
{
    Process();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: MusicManagerThreadProc
// Desc: Thread procedure on which the music manager decodes
//-----------------------------------------------------------------------------
DWORD WINAPI MusicManagerThreadProc( LPVOID lpParameter )
{
    CMusicManager * pThis = (CMusicManager *)lpParameter;
    DWORD dwResult;

    //
    // Our thread procedure basically just loops indefinitely,
    // processing packets and switching between songs as 
    // appropriate, until we're signalled to shutdown.
    //
    do
    {
        pThis->MusicManagerDoWork();
        dwResult = WaitForSingleObject( pThis->m_hShutdownEvent, 1000 / 60 );
    } while( dwResult == WAIT_TIMEOUT );

    // Since we created the decoder on this thread, we'll
    // release it on this thread.
    pThis->Cleanup();

    return 0;
}



//-----------------------------------------------------------------------------
// Name: StreamCallback
// Desc: Called back on completion of stream packets.  The stream context
//       contains a pointer to the CMusicManager object, and the packet
//       context contains the stream number
//-----------------------------------------------------------------------------
void CALLBACK 
StreamCallback( LPVOID pStreamContext, LPVOID pPacketContext, DWORD dwStatus )
{
    CMusicManager * pThis = (CMusicManager *)pStreamContext;

    if( DWORD(pPacketContext) == pThis->m_dwStream &&
        dwStatus == XMEDIAPACKET_STATUS_SUCCESS )
        ++pThis->m_dwPacketsCompleted;
}




#if _DEBUG
//-----------------------------------------------------------------------------
// Name: DebugVerify
// Desc: Debug routine to verify that everything is properly set up:
//       * Must have at least 1 game soundtrack, since a game can't depend
//         on there being user soundtracks on the Xbox hard drive
//       * Check that we can open all soundtrack songs
//-----------------------------------------------------------------------------
HRESULT
CMusicManager::DebugVerify()
{
    // Make sure we have at least 1 game soundtrack
    if( !m_aSoundtracks[ 0 ].m_fGameSoundtrack )
    {
        OUTPUT_DEBUG_STRING( "Must have at least 1 game soundtrack.\n" );
        return E_FAIL;
    }

    // Verify we can open all soundtrack files.  This could take a while.
    for( UINT uSoundtrack = 0; uSoundtrack < m_uSoundtrackCount; uSoundtrack++ )
    {
        for( UINT uSong = 0; uSong < m_aSoundtracks[ uSoundtrack ].GetSongCount(); uSong++ )
        {
            DWORD dwSongID;
            DWORD dwSongLength;
            WCHAR szSongName[ MAX_SONG_NAME ];

            m_aSoundtracks[ uSoundtrack ].GetSongInfo( uSong, &dwSongID, &dwSongLength, szSongName );
            HANDLE h = m_aSoundtracks[ uSoundtrack ].OpenSong( dwSongID );
            if( INVALID_HANDLE_VALUE == h )
            {
                OUTPUT_DEBUG_STRING( "Failed to open a soundtrack file.\n" );
                return E_FAIL;
            }
            CloseHandle( h );
        }
    }

    return S_OK;
}
#endif // _DEBUG




//
// CSoundtrack functions
//



//-----------------------------------------------------------------------------
// Name: GetSongInfo
// Desc: Returns information about the given song
//-----------------------------------------------------------------------------
void
CSoundtrack::GetSongInfo( UINT uSongIndex, DWORD * pdwID, DWORD * pdwLength, WCHAR szName[MAX_SONG_NAME] )
{
    if( m_fGameSoundtrack )
    {
        *pdwID = uSongIndex;
        *pdwLength = g_aGameSoundtrack[ uSongIndex ].dwLength;
        wcscpy( szName, g_aGameSoundtrack[ uSongIndex ].szName );
    }
    else
    {
        XGetSoundtrackSongInfo( m_uSoundtrackID, uSongIndex, pdwID, pdwLength, szName, MAX_SONG_NAME );
    }
}



//-----------------------------------------------------------------------------
// Name: OpenSong
// Desc: Opens the song with the given ID and returns a handle to the file
//-----------------------------------------------------------------------------
HANDLE
CSoundtrack::OpenSong( DWORD dwSongID )
{
    if( m_fGameSoundtrack )
        return CreateFile( g_aGameSoundtrack[ dwSongID ].szFilename, 
                           GENERIC_READ, 
                           FILE_SHARE_READ, 
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );
    else
        return XOpenSoundtrackSong( dwSongID, FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Mesh.cpp ===
//-----------------------------------------------------------------------------
// File: Mesh.cpp
//
// Desc: Mesh objects
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Mesh.h"
#include "File.h"
#include "Globals.h"

#if defined(_XBOX)

#include <XbUtil.h>

#endif




//-----------------------------------------------------------------------------
// Global mesh lists
//-----------------------------------------------------------------------------
DWORD g_D3DPrimTypeConstants[] =
{
    D3DPT_POINTLIST,
    D3DPT_LINELIST,
    D3DPT_LINESTRIP,
    D3DPT_TRIANGLELIST,
    D3DPT_TRIANGLESTRIP,
    D3DPT_TRIANGLEFAN,
    D3DPT_FORCE_DWORD
};

const INT MAX_VIS_INDEX = 6;
D3DMATERIAL8 g_VisualizationColors[ MAX_VIS_INDEX ] =
{
    {
        { 1.0f, 0.0f, 0.0f, 1.0f },
        { 1.0f, 0.0f, 0.0f, 1.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        0.0f,
    },

    {
        { 0.0f, 1.0f, 0.0f, 1.0f },
        { 0.0f, 1.0f, 0.0f, 1.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        0.0f,
    },

    {
        { 0.0f, 0.0f, 1.0f, 1.0f },
        { 0.0f, 0.0f, 1.0f, 1.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        0.0f,
    },

    {
        { 0.0f, 1.0f, 1.0f, 1.0f },
        { 0.0f, 1.0f, 1.0f, 1.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        0.0f,
    },

    {
        { 1.0f, 0.0f, 1.0f, 1.0f },
        { 1.0f, 0.0f, 1.0f, 1.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        0.0f,
    },

    {
        { 1.0f, 1.0f, 0.0f, 1.0f },
        { 1.0f, 1.0f, 0.0f, 1.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        { 0.0f, 0.0f, 0.0f, 0.0f },
        0.0f,
    },
};




//-----------------------------------------------------------------------------
// Local structs
//-----------------------------------------------------------------------------
struct MeshElementData // for writing to file
{
    DWORD dwPrimitives;
    DWORD dwPrimType;
    DWORD dwIndexBufferCount;
    DWORD dwNumVertices;
    DWORD dwVertexSize;
    DWORD dwFVF;
    DWORD dwBasisVectorOffset;
};




//-----------------------------------------------------------------------------
// Name: MeshElement()
// Desc: Construct an empty element
//-----------------------------------------------------------------------------
MeshElement::MeshElement()
:
    m_pShader           ( NULL ),
    m_uNumPrimitives    ( 0 ),
    m_PrimType          ( D3DPT_TRIANGLELIST ),
    m_uIndexBufferCount ( 0 ),
    m_pIndexBuffer      ( NULL ),
    m_dwFVF             ( 0 ),
    m_iBasisVectorOffset( 0 ),
    m_uNumVertices      ( 0 ),
    m_uVertexSize       ( 0 ),
    m_pVertexBuffer     ( NULL )
{
}




//-----------------------------------------------------------------------------
// Name: MeshElement()
// Desc: Create a mesh element using an FVF code
//-----------------------------------------------------------------------------
MeshElement::MeshElement( DWORD dwFVF, UINT uNumVerts, UINT uNumIndices )
:
    m_pShader           ( NULL ),
    m_uNumPrimitives    ( 0 ),
    m_PrimType          ( D3DPT_TRIANGLELIST ),
    m_uIndexBufferCount ( uNumIndices ),
    m_pIndexBuffer      ( NULL ),
    m_dwFVF             ( dwFVF ),
    m_iBasisVectorOffset( 0 ),
    m_uNumVertices      ( uNumVerts ),
    m_uVertexSize       ( D3DXGetFVFVertexSize( dwFVF ) ),
    m_pVertexBuffer     ( NULL )
{
    HRESULT hr = g_pd3dDevice->CreateVertexBuffer( m_uVertexSize * m_uNumVertices, 
                                                   D3DUSAGE_WRITEONLY, 0, 
                                                   D3DPOOL_MANAGED, &m_pVertexBuffer);
    assert( hr == S_OK );

    hr = g_pd3dDevice->CreateIndexBuffer( sizeof(WORD) * m_uIndexBufferCount, 
                                          D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                          D3DPOOL_MANAGED, &m_pIndexBuffer );
    assert( hr == S_OK );
}



//-----------------------------------------------------------------------------
// Name: ~MeshElement()
// Desc: Destroy mesh lement
//-----------------------------------------------------------------------------
MeshElement::~MeshElement()
{
    SAFE_RELEASE( m_pIndexBuffer );
    SAFE_RELEASE( m_pVertexBuffer );
}




//-----------------------------------------------------------------------------
// Name: Save()
// Desc: Write the mesh element to the file
//-----------------------------------------------------------------------------
HRESULT MeshElement::Save( const File& file )
{
    assert( m_pShader != NULL );

    // Save shader type and shader data
    DWORD dwShaderType = m_pShader->Type();
    if( !file.Write( &dwShaderType, sizeof(dwShaderType) ) )
        return E_FAIL;
    m_pShader->Save( file );

    MeshElementData data;
    data.dwPrimitives        = m_uNumPrimitives;
    data.dwPrimType          = ConstantToIndex( m_PrimType, g_D3DPrimTypeConstants );
    data.dwIndexBufferCount  = m_uIndexBufferCount;
    data.dwNumVertices       = m_uNumVertices;
    data.dwVertexSize        = m_uVertexSize;
    data.dwFVF               = m_dwFVF;
    data.dwBasisVectorOffset = m_iBasisVectorOffset;
    if( !file.Write( &data, sizeof(data) ) )
        return E_FAIL;

    // Save indices
    DWORD dwIndexBufferSize = sizeof(WORD) * m_uIndexBufferCount;
    BYTE* pIndices;
    m_pIndexBuffer->Lock( 0, dwIndexBufferSize, &pIndices, D3DLOCK_READONLY );
    if( !file.Write( pIndices, dwIndexBufferSize ) )
        return E_FAIL;
    m_pIndexBuffer->Unlock();

    // Save vertices
    DWORD dwVertexBufferSize = m_uVertexSize * m_uNumVertices;
    BYTE* pVertices;
    m_pVertexBuffer->Lock( 0, dwVertexBufferSize, &pVertices, D3DLOCK_READONLY );
    if( !file.Write( pVertices, dwVertexBufferSize ) )
        return E_FAIL;
    m_pVertexBuffer->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Load the mesh element from the file
//-----------------------------------------------------------------------------
HRESULT MeshElement::Load( const File& file )
{
    DWORD dwBytesRead;

    // Load the shader
    DWORD dwShaderType;
    if( !file.Read( &dwShaderType, sizeof(dwShaderType), dwBytesRead ) )
        return E_FAIL;

    m_pShader = Shader::CreateShaderOfType( dwShaderType );
    m_pShader->Load( file );

    // Read basic mesh element data
    MeshElementData data;
    if( !file.Read( &data, sizeof(data), dwBytesRead ) )
        return E_FAIL;

    m_uNumPrimitives     = data.dwPrimitives;
    m_PrimType           = D3DPRIMITIVETYPE( IndexToConstant( data.dwPrimType, 
                                             g_D3DPrimTypeConstants ) );
    m_uIndexBufferCount  = data.dwIndexBufferCount;
    m_uNumVertices       = data.dwNumVertices;
    m_uVertexSize        = data.dwVertexSize;
    m_dwFVF              = data.dwFVF;
    m_iBasisVectorOffset = data.dwBasisVectorOffset;

    // Load indices
    DWORD dwIndexBufferSize = sizeof(WORD) * m_uIndexBufferCount;
    HRESULT hr = g_pd3dDevice->CreateIndexBuffer( dwIndexBufferSize, 
                                                  D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                                  D3DPOOL_MANAGED, &m_pIndexBuffer);

    assert( hr == D3D_OK );
    BYTE* pIndices;
    m_pIndexBuffer->Lock(0, dwIndexBufferSize, &pIndices, D3DLOCK_READONLY);
    if( !file.Read( pIndices, dwIndexBufferSize, dwBytesRead ) )
        return E_FAIL;

    m_pIndexBuffer->Unlock();

    // Load vertices
    DWORD dwVertexBufferSize = m_uVertexSize * m_uNumVertices;
    hr = g_pd3dDevice->CreateVertexBuffer( dwVertexBufferSize, D3DUSAGE_WRITEONLY, 
                                           0, D3DPOOL_MANAGED, &m_pVertexBuffer );

    assert(hr == D3D_OK);
    BYTE* pVertices;
    m_pVertexBuffer->Lock(0, dwVertexBufferSize, &pVertices, D3DLOCK_READONLY);
    if( !file.Read( pVertices, dwVertexBufferSize, dwBytesRead ) )
        return E_FAIL;

    m_pVertexBuffer->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Render the mesh element
//-----------------------------------------------------------------------------
VOID MeshElement::Render()
{
    g_pd3dDevice->SetIndices( m_pIndexBuffer, 0 );
    g_pd3dDevice->SetStreamSource( 0, m_pVertexBuffer, m_uVertexSize );

    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, g_bWireframe ? D3DFILL_WIREFRAME :
                                                                 D3DFILL_SOLID );

    INT iNumPasses = m_pShader->GetNumPasses();
    for( INT iPass = 0; iPass < iNumPasses; ++iPass )
    {
        // Output the shader
        m_pShader->Output( iPass );

        if( g_bVisualizeStrips )
        {
            INT iVisIndex = 0;

            UINT uIndexStart = 0;
            UINT uIndexEnd;

            UINT uIndexBufferSize = sizeof(WORD) * m_uIndexBufferCount;
            WORD* pIndices = NULL;
            m_pIndexBuffer->Lock( 0, uIndexBufferSize, (BYTE**)&pIndices, 
                                  D3DLOCK_READONLY );

            while( uIndexStart < m_uIndexBufferCount )
            {
                // Find end of strip
                for( uIndexEnd = uIndexStart+2; 
                     uIndexEnd < m_uIndexBufferCount-1; ++uIndexEnd )
                {
                    // Check for duplicate verts
                    if( pIndices[uIndexEnd+1] == pIndices[uIndexEnd] )
                        break;
                }

                // Draw strip
                g_pd3dDevice->SetMaterial( &g_VisualizationColors[iVisIndex++] );
                if( iVisIndex >= MAX_VIS_INDEX )
                    iVisIndex = 0;

                g_pd3dDevice->DrawIndexedPrimitive( m_PrimType, 0, m_uNumVertices, 
                                                    uIndexStart, uIndexEnd-uIndexStart-1 );

                if( (uIndexEnd-uIndexStart-1) & 1 )
                    uIndexStart = uIndexEnd+2;
                else
                    uIndexStart = uIndexEnd+3;
            }

            m_pIndexBuffer->Unlock();
        }
        else
        {
            // Draw the strip
            g_pd3dDevice->DrawIndexedPrimitive( m_PrimType, 0, m_uNumVertices, 
                                                0, m_uNumPrimitives );
        }
    }

    if( g_bShowNormals )
    {
        UINT uVertexBufferSize = m_uVertexSize * m_uNumVertices;
        BYTE* pVertices;
        m_pVertexBuffer->Lock(0, uVertexBufferSize, &pVertices, D3DLOCK_READONLY);

        INT iNormalOffset = ComputeFVFOffset(D3DFVF_NORMAL, m_dwFVF);

        g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESSEQUAL );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
        g_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_DIFFUSE );
        g_pd3dDevice->SetPixelShader( 0 );
        g_pd3dDevice->SetTexture( 0, 0 );
        g_pd3dDevice->SetTexture( 1, 0 );
        g_pd3dDevice->SetTexture( 2, 0 );
        g_pd3dDevice->SetTexture( 3, 0 );

        for( UINT i = 0; i < m_uNumVertices; ++i )
        {
            D3DXVECTOR3* pPos = (D3DXVECTOR3*)( pVertices + i * m_uVertexSize );
            D3DXVECTOR3* pNormal = (D3DXVECTOR3*)( pVertices + 
                                                   i * m_uVertexSize + iNormalOffset);
            
            struct
            { 
                D3DVECTOR pos;
                D3DCOLOR color;
            }
            LinePnts[2];
            
            LinePnts[0].pos = *pPos;
            LinePnts[0].color = 0xffffffff;
            LinePnts[1].pos = *pPos + *pNormal;
            LinePnts[1].color = 0xffffffff;

            g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, LinePnts, 
                                           sizeof(D3DXVECTOR3) );
        }

        m_pVertexBuffer->Unlock();
    }

    if( g_bShowBasisVectors )
    {
        UINT uVertexBufferSize = m_uVertexSize * m_uNumVertices;
        BYTE* pVertices;
        m_pVertexBuffer->Lock(0, uVertexBufferSize, &pVertices, D3DLOCK_READONLY);

        g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESSEQUAL );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
        g_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_DIFFUSE );
        g_pd3dDevice->SetPixelShader( 0 );
        g_pd3dDevice->SetTexture( 0, 0 );
        g_pd3dDevice->SetTexture( 1, 0 );
        g_pd3dDevice->SetTexture( 2, 0 );
        g_pd3dDevice->SetTexture( 3, 0 );

        for( UINT i = 0; i < m_uNumVertices; ++i )
        {
            D3DXVECTOR3* pPos = (D3DXVECTOR3*)( pVertices + i * m_uVertexSize );
            D3DXVECTOR3* pBV = (D3DXVECTOR3*)( pVertices + i * m_uVertexSize + 
                                               m_iBasisVectorOffset );
            
            struct
            { 
                D3DVECTOR pos;
                D3DCOLOR color;
            }
            LinePnts[2];
            
            LinePnts[0].pos = *pPos;
            LinePnts[0].color = 0xffff0000;
            LinePnts[1].pos = *pPos + pBV[0];
            LinePnts[1].color = 0xffff0000;
            g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, LinePnts, 
                                           sizeof(LinePnts[0]) );

            LinePnts[0].pos = *pPos;
            LinePnts[0].color = 0xff00ff00;
            LinePnts[1].pos = *pPos + pBV[1];
            LinePnts[1].color = 0xff00ff00;
            g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, LinePnts, 
                                           sizeof(LinePnts[0]) );

            LinePnts[0].pos = *pPos;
            LinePnts[0].color = 0xff0000ff;
            LinePnts[1].pos = *pPos + pBV[2];
            LinePnts[1].color = 0xff0000ff;
            g_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, LinePnts, 
                                           sizeof(LinePnts[0]) );
        }
        m_pVertexBuffer->Unlock();
    }
}




//-----------------------------------------------------------------------------
// Name: AddBasisVectors()
// Desc: Allocate space for basis vectors
//-----------------------------------------------------------------------------
VOID MeshElement::AddBasisVectors()
{
    UINT uOldVertexSize = m_uVertexSize;
    LPDIRECT3DVERTEXBUFFER8 pOldVertexBuffer = m_pVertexBuffer;
    UINT uOldVertexBufferSize = m_uVertexSize * m_uNumVertices;

    m_uVertexSize += sizeof(D3DXVECTOR3) * 3;

    UINT uVertexBufferSize = m_uVertexSize * m_uNumVertices;

    // Allocate space for basis vectors in vertices
    HRESULT hr = g_pd3dDevice->CreateVertexBuffer( uVertexBufferSize, 
                                                   D3DUSAGE_WRITEONLY, 
                                                   0, D3DPOOL_MANAGED,
                                                   &m_pVertexBuffer );
    assert( hr == S_OK );
    USED( hr );

    INT iUVOffset = ComputeFVFOffset( D3DFVF_TEX1, m_dwFVF );
    INT iBVOffset = uOldVertexSize;

    BYTE *pOldVertices;
    BYTE *pVertices;
    pOldVertexBuffer->Lock( 0, uOldVertexBufferSize, &pOldVertices, D3DLOCK_READONLY );
    m_pVertexBuffer->Lock( 0, uVertexBufferSize, &pVertices, D3DLOCK_READONLY );

    // Copy vertex data over
    for( UINT i = 0; i < m_uNumVertices; ++i )
    {
        memcpy( pVertices + i * m_uVertexSize, 
                pOldVertices + i * uOldVertexSize, uOldVertexSize);
    }

    pOldVertexBuffer->Unlock();
    m_pVertexBuffer->Unlock();

    pOldVertexBuffer->Release();

    // Calculate basis vectors
    CalculateBasisVectors( iUVOffset, iBVOffset );
    m_iBasisVectorOffset = iBVOffset;
}




//-----------------------------------------------------------------------------
// Name: AddBasisVectors()
// Desc: Calculate basis vectors for the mesh element
//-----------------------------------------------------------------------------
VOID MeshElement::CalculateBasisVectors( INT iUVOffset, INT iBVOffset )
{
    static const FLOAT SMALL_FLOAT = 1e-12f;

    INT iNormalOffset = ComputeFVFOffset(D3DFVF_NORMAL, m_dwFVF);

    UINT uVertexBufferSize = m_uVertexSize * m_uNumVertices;
    BYTE* pVertices;
    m_pVertexBuffer->Lock( 0, uVertexBufferSize, &pVertices, D3DLOCK_READONLY );

    struct BasisVector
    { 
        D3DXVECTOR3 S;
        D3DXVECTOR3 T;
        D3DXVECTOR3 SxT;
    };
    
    // Clear the basis vectors
    for( UINT j = 0; j < m_uNumVertices; ++j )
    {
        BasisVector* pBasis = (BasisVector*)(pVertices + j*m_uVertexSize + iBVOffset);

        pBasis->S = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
        pBasis->T = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    }

    // Walk through the triangle list and calculate gradiants for each triangle.
    // Sum the results into the S and T components.
    UINT uIndexBufferSize = sizeof(WORD) * m_uIndexBufferCount;
    WORD *pIndices;
    m_pIndexBuffer->Lock(0, uIndexBufferSize, (BYTE**)&pIndices, D3DLOCK_READONLY);

    UINT i = 0;
    INT ind0 = 0;
    INT ind1 = 0;
    INT ind2 = 0;

    if( D3DPT_TRIANGLELIST == m_PrimType )
    {
        i = 0;
    }
    else if( D3DPT_TRIANGLESTRIP == m_PrimType )
    {
        ind0 = -1;
        ind1 = pIndices[0];
        ind2 = pIndices[1];
        i = 2;
    }

    while( i < m_uIndexBufferCount )
    {
        BYTE *pVert0 = NULL;
        BYTE *pVert1 = NULL;
        BYTE *pVert2 = NULL;

        if( D3DPT_TRIANGLELIST == m_PrimType )
        {
            pVert0 = pVertices + pIndices[i+0] * m_uVertexSize;
            pVert1 = pVertices + pIndices[i+1] * m_uVertexSize;
            pVert2 = pVertices + pIndices[i+2] * m_uVertexSize;
            i += 3;
        }
        else if( D3DPT_TRIANGLESTRIP == m_PrimType )
        {
            ind0 = ind1;
            ind1 = ind2;
            ind2 = pIndices[i];
            
            if( ind0 != ind1 && ind1 != ind2 && ind2 != ind0 )
            {
                if( i & 1 )
                {
                    pVert0 = pVertices + ind2 * m_uVertexSize;
                    pVert1 = pVertices + ind1 * m_uVertexSize;
                    pVert2 = pVertices + ind0 * m_uVertexSize;
                }
                else
                {
                    pVert0 = pVertices + ind0 * m_uVertexSize;
                    pVert1 = pVertices + ind1 * m_uVertexSize;
                    pVert2 = pVertices + ind2 * m_uVertexSize;
                }

                ++i;
            }
            else
            {
                // Degenerate triangle
                ++i;
                continue;
            }
        }
        else
        {
            // Unsupported primitive type
            assert(0);
        }

        D3DXVECTOR3* pPos0 = (D3DXVECTOR3*)pVert0;
        D3DXVECTOR3* pPos1 = (D3DXVECTOR3*)pVert1;
        D3DXVECTOR3* pPos2 = (D3DXVECTOR3*)pVert2;

        D3DXVECTOR2* pTC0 = (D3DXVECTOR2*)(pVert0 + iUVOffset);
        D3DXVECTOR2* pTC1 = (D3DXVECTOR2*)(pVert1 + iUVOffset);
        D3DXVECTOR2* pTC2 = (D3DXVECTOR2*)(pVert2 + iUVOffset);

        BasisVector* pBV0 = (BasisVector*)(pVert0 + iBVOffset);
        BasisVector* pBV1 = (BasisVector*)(pVert1 + iBVOffset);
        BasisVector* pBV2 = (BasisVector*)(pVert2 + iBVOffset);

        FLOAT ds1 = pTC1->x - pTC0->x;
        FLOAT dt1 = pTC1->y - pTC0->y;

        FLOAT ds2 = pTC2->x - pTC0->x;
        FLOAT dt2 = pTC2->y - pTC0->y;

        // x, s, t
        D3DXVECTOR3 edge01 = D3DXVECTOR3( pPos1->x - pPos0->x, ds1, dt1 );
        D3DXVECTOR3 edge02 = D3DXVECTOR3( pPos2->x - pPos0->x, ds2, dt2 );

        D3DXVECTOR3 cp;
        D3DXVec3Cross( &cp, &edge01, &edge02 );
        if( fabs(cp.x) > SMALL_FLOAT )
        {
            FLOAT dsdx = -cp.y / cp.x;
            FLOAT dtdx = -cp.z / cp.x;

            pBV0->S.x += dsdx;
            pBV0->T.x += dtdx;

            pBV1->S.x += dsdx;
            pBV1->T.x += dtdx;

            pBV2->S.x += dsdx;
            pBV2->T.x += dtdx;
        }

        // y, s, t
        edge01 = D3DXVECTOR3( pPos1->y - pPos0->y, ds1, dt1 );
        edge02 = D3DXVECTOR3( pPos2->y - pPos0->y, ds2, dt2 );

        D3DXVec3Cross( &cp, &edge01, &edge02 );
        if( fabs(cp.x) > SMALL_FLOAT )
        {
            FLOAT dsdx = -cp.y / cp.x;
            FLOAT dtdx = -cp.z / cp.x;

            pBV0->S.y += dsdx;
            pBV0->T.y += dtdx;

            pBV1->S.y += dsdx;
            pBV1->T.y += dtdx;

            pBV2->S.y += dsdx;
            pBV2->T.y += dtdx;
        }

        // z, s, t
        edge01 = D3DXVECTOR3( pPos1->z - pPos0->z, ds1, dt1 );
        edge02 = D3DXVECTOR3( pPos2->z - pPos0->z, ds2, dt2 );

        D3DXVec3Cross( &cp, &edge01, &edge02 );
        if( fabs(cp.x) > SMALL_FLOAT )
        {
            FLOAT dsdx = -cp.y / cp.x;
            FLOAT dtdx = -cp.z / cp.x;

            pBV0->S.z += dsdx;
            pBV0->T.z += dtdx;

            pBV1->S.z += dsdx;
            pBV1->T.z += dtdx;

            pBV2->S.z += dsdx;
            pBV2->T.z += dtdx;
        }
    }

    m_pIndexBuffer->Unlock();

    // Calculate the SxT vector
    for( i = 0; i < m_uNumVertices; ++i )
    {
        BasisVector* pBasis = (BasisVector*)(pVertices + i * m_uVertexSize + iBVOffset);

        // Normalize the S, T vectors
        D3DXVec3Normalize( &pBasis->S, &pBasis->S );
        D3DXVec3Normalize( &pBasis->T, &pBasis->T );

        // Get the cross of the S and T vectors
        D3DXVec3Cross( &pBasis->SxT, &pBasis->S, &pBasis->T );

        // v coordinates go in opposite direction from the texture v increase in xyz
        //pBasis->T = -pBasis->T;

        D3DXVECTOR3* pNormal = (D3DXVECTOR3*)( pVertices + i * m_uVertexSize + 
                                               iNormalOffset );

        // Get the direction of the SxT vector
        if( D3DXVec3Dot( &pBasis->SxT, pNormal ) < 0.0f )
            pBasis->SxT = -pBasis->SxT;
    }

    m_pVertexBuffer->Unlock();
}



//-----------------------------------------------------------------------------
// Name: ConstantToIndex()
// Desc: Returns the index of the given constant
//-----------------------------------------------------------------------------
DWORD MeshElement::ConstantToIndex( DWORD dwConst, const DWORD* pTable ) // static
{
    assert( pTable != NULL );
    for( DWORD i = 0; pTable[i] != 0x7fffffff; ++i )
    {
        if( pTable[i] == dwConst )
            return i;
    }

    // Unknown constant?
    assert(0);
    return 0;
}




//-----------------------------------------------------------------------------
// Name: IndexToConstant()
// Desc: Returns the constant stored at the given index
//-----------------------------------------------------------------------------
DWORD MeshElement::IndexToConstant( DWORD dwIndex, const DWORD* pTable ) // static
{
    return pTable[ dwIndex ];
}




//-----------------------------------------------------------------------------
// Name: ComputeFVFOffset()
// Desc: Compute an offset to the selected component of a vertex based on the FVF
//-----------------------------------------------------------------------------
DWORD MeshElement::ComputeFVFOffset( DWORD dwComponentFVF, DWORD dwFVF ) // static
{
    DWORD dwOffset = 0;

    if( dwComponentFVF >= D3DFVF_XYZ && dwComponentFVF <= D3DFVF_XYZB4 )
        return dwOffset;

    // Position (plus blend weights) offset.
    DWORD dwPositionFVF = dwFVF & D3DFVF_POSITION_MASK;

    dwOffset += 12;

    if( D3DFVF_XYZRHW == dwPositionFVF )
        dwOffset += 4;
    else if( dwPositionFVF >= D3DFVF_XYZB1 )
        dwOffset += 4 * ((dwPositionFVF-4)/2);

    if( D3DFVF_NORMAL == dwComponentFVF )
        return dwOffset;

    if( dwFVF & D3DFVF_NORMAL )
        dwOffset += 12;

    if( D3DFVF_DIFFUSE == dwComponentFVF )
        return dwOffset;

    if( dwFVF & D3DFVF_DIFFUSE )
        dwOffset += 4;

    if( D3DFVF_SPECULAR == dwComponentFVF )
        return dwOffset;

    if( dwFVF & D3DFVF_SPECULAR )
        dwOffset += 4;

    // Texture coordinates
    DWORD dwTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i = 0; i < dwTexCount; ++i )
    {
        if( D3DFVF_TEX1+i == dwComponentFVF )
            return dwOffset;

        DWORD dwFormat = (dwFVF >> (i*2 + 16)) & 0x03;

        if( D3DFVF_TEXTUREFORMAT1 == dwFormat )
            dwOffset += 4;
        else if( D3DFVF_TEXTUREFORMAT2 == dwFormat )
            dwOffset += 8;
        else if( D3DFVF_TEXTUREFORMAT3 == dwFormat )
            dwOffset += 12;
        else if( D3DFVF_TEXTUREFORMAT4 == dwFormat )
            dwOffset += 16;
    }

    // dwComponentFVF not found
    return dwOffset;
}




//-----------------------------------------------------------------------------
// Name: Mesh()
// Desc: Create empty mesh
//-----------------------------------------------------------------------------
Mesh::Mesh()
:
    m_iNumMeshElements( 0 ),
    m_Elements( NULL )
{
}




//-----------------------------------------------------------------------------
// Name: Mesh()
// Desc: Create mesh of given size
//-----------------------------------------------------------------------------
Mesh::Mesh( INT iNumElements )
:
    m_iNumMeshElements( iNumElements ),
    m_Elements( new MeshElement [iNumElements] )
{
}




//-----------------------------------------------------------------------------
// Name: ~Mesh()
// Desc: Destroy mesh
//-----------------------------------------------------------------------------
Mesh::~Mesh()
{
    delete [] m_Elements;
}




//-----------------------------------------------------------------------------
// Name: Save()
// Desc: Save all mesh elements to the file
//-----------------------------------------------------------------------------
HRESULT Mesh::Save( const File& file )
{
    if( !file.Write( &m_v3BoxMin, sizeof(m_v3BoxMin) ) )
        return E_FAIL;

    if( !file.Write( &m_v3BoxMax, sizeof(m_v3BoxMax) ) )
        return E_FAIL;

    if( !file.Write( &m_iNumMeshElements, sizeof(m_iNumMeshElements) ) )
        return E_FAIL;

    for( INT i = 0; i < m_iNumMeshElements; ++i )
    {
        if( FAILED( m_Elements[i].Save( file ) ) )
            return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadSave()
// Desc: Load a mesh
//-----------------------------------------------------------------------------
HRESULT Mesh::Load( const File& file )
{
    DWORD dwBytesRead;

    if( !file.Read( &m_v3BoxMin, sizeof(m_v3BoxMin), dwBytesRead ) )
        return E_FAIL;

    if( !file.Read( &m_v3BoxMax, sizeof(m_v3BoxMax), dwBytesRead ) )
        return E_FAIL;

    if( !file.Read( &m_iNumMeshElements, sizeof(m_iNumMeshElements), dwBytesRead ) )
        return E_FAIL;

    delete [] m_Elements;

    m_Elements = new MeshElement [m_iNumMeshElements];

    for( INT i = 0; i < m_iNumMeshElements; ++i )
    {
        if( m_Elements[i].Load( file ) != S_OK )
            return E_FAIL;
    }

    return 0;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Render the mesh
//-----------------------------------------------------------------------------
VOID Mesh::Render()
{
    // Render each mesh element
    for( INT i = 0; i < m_iNumMeshElements; ++i )
        m_Elements[i].Render();
}



//-----------------------------------------------------------------------------
// Name: AddBasisVectors()
// Desc: Add and calculate basis vector for the mesh
//-----------------------------------------------------------------------------
VOID Mesh::AddBasisVectors()
{
    for( INT i = 0; i < m_iNumMeshElements; ++i )
    {
        m_Elements[i].AddBasisVectors();
    }
}




//-----------------------------------------------------------------------------
// Name: Box()
// Desc: Create box mesh
//-----------------------------------------------------------------------------
Box::Box( FLOAT width, FLOAT height, FLOAT depth, const D3DMATERIAL8& d3dMat )
: 
    Mesh( 1 )
{
    MeshElement& elem = m_Elements[0];
    elem.m_pShader = new ShaderLit( d3dMat );
    elem.m_uNumPrimitives = 12;
    elem.m_uIndexBufferCount = 12*3;

    UINT uIndexBufferSize = sizeof(WORD) * elem.m_uIndexBufferCount;
    HRESULT hr = g_pd3dDevice->CreateIndexBuffer( uIndexBufferSize, D3DUSAGE_WRITEONLY, 
                                                  D3DFMT_INDEX16, D3DPOOL_MANAGED, 
                                                  &elem.m_pIndexBuffer );
    assert( hr == S_OK );

    struct SimpleVertex
    {
        D3DXVECTOR3 pos;
        D3DXVECTOR3 norm;
    };
    
    elem.m_uNumVertices = 4*6;
    elem.m_uVertexSize = sizeof(SimpleVertex);
    
    UINT uVertexBufferSize = elem.m_uVertexSize * elem.m_uNumVertices;
    hr = g_pd3dDevice->CreateVertexBuffer( uVertexBufferSize, D3DUSAGE_WRITEONLY, 
                                           (D3DFVF_XYZ | D3DFVF_NORMAL), 
                                           D3DPOOL_MANAGED, &elem.m_pVertexBuffer );
    assert( hr == S_OK );

    // Fill vertex buffer
    SimpleVertex* pVerts = NULL;
    elem.m_pVertexBuffer->Lock(0, uVertexBufferSize, (BYTE**)&pVerts, 0 );

    FLOAT hh = height * 0.5f;
    FLOAT hw = width * 0.5f;
    FLOAT hd = depth * 0.5f;

    // Bottom
    pVerts[0].pos  = D3DXVECTOR3( -hw, -hh, -hd );
    pVerts[0].norm = D3DXVECTOR3( 0.0f, -1.0f, 0.0f );
    pVerts[1].pos  = D3DXVECTOR3( hw, -hh, -hd );
    pVerts[1].norm = D3DXVECTOR3( 0.0f, -1.0f, 0.0f );
    pVerts[2].pos  = D3DXVECTOR3( hw, -hh, hd );
    pVerts[2].norm = D3DXVECTOR3( 0.0f, -1.0f, 0.0f );
    pVerts[3].pos  = D3DXVECTOR3( -hw, -hh, hd );
    pVerts[3].norm = D3DXVECTOR3( 0.0f, -1.0f, 0.0f );

    // Top
    pVerts[4].pos  = D3DXVECTOR3( -hw, hh, -hd );
    pVerts[4].norm = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    pVerts[5].pos  = D3DXVECTOR3( -hw, hh, hd );
    pVerts[5].norm = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    pVerts[6].pos  = D3DXVECTOR3( hw, hh, hd );
    pVerts[6].norm = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    pVerts[7].pos  = D3DXVECTOR3( hw, hh, -hd );
    pVerts[7].norm = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    // Left
    pVerts[8].pos   = D3DXVECTOR3( -hw, -hh, -hd );
    pVerts[8].norm  = D3DXVECTOR3( -1.0f, 0.0f, 0.0f );
    pVerts[9].pos   = D3DXVECTOR3( -hw, -hh, hd );
    pVerts[9].norm  = D3DXVECTOR3( -1.0f, 0.0f, 0.0f );
    pVerts[10].pos  = D3DXVECTOR3( -hw, hh, hd );
    pVerts[10].norm = D3DXVECTOR3( -1.0f, 0.0f, 0.0f );
    pVerts[11].pos  = D3DXVECTOR3( -hw, hh, -hd );
    pVerts[11].norm = D3DXVECTOR3( -1.0f, 0.0f, 0.0f );

    // Right
    pVerts[12].pos  = D3DXVECTOR3( hw, -hh, -hd );
    pVerts[12].norm = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    pVerts[13].pos  = D3DXVECTOR3( hw, hh, -hd );
    pVerts[13].norm = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    pVerts[14].pos  = D3DXVECTOR3( hw, hh, hd );
    pVerts[14].norm = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    pVerts[15].pos  = D3DXVECTOR3( hw, -hh, hd );
    pVerts[15].norm = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );

    // Front
    pVerts[16].pos  = D3DXVECTOR3( -hw, -hh, -hd );
    pVerts[16].norm = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVerts[17].pos  = D3DXVECTOR3( -hw, hh, -hd );
    pVerts[17].norm = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVerts[18].pos  = D3DXVECTOR3( hw, hh, -hd );
    pVerts[18].norm = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );
    pVerts[19].pos  = D3DXVECTOR3( hw, -hh, -hd );
    pVerts[19].norm = D3DXVECTOR3( 0.0f, 0.0f, -1.0f );

    // Back
    pVerts[20].pos  = D3DXVECTOR3( -hw, -hh, hd );
    pVerts[20].norm = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
    pVerts[21].pos  = D3DXVECTOR3( hw, -hh, hd );
    pVerts[21].norm = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
    pVerts[22].pos  = D3DXVECTOR3( hw, hh, hd );
    pVerts[22].norm = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
    pVerts[23].pos  = D3DXVECTOR3( -hw, hh, hd );
    pVerts[23].norm = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );

    elem.m_pVertexBuffer->Unlock();

    // Fill index buffer
    WORD* pIndices = 0;
    elem.m_pIndexBuffer->Lock(0, uIndexBufferSize, (BYTE**)&pIndices, 0 );

    // All verts are clockwise for each face
    for( WORD face = 0; face < 6; ++face )
    {
        WORD base = face * 4;
        *pIndices++ = base+0; 
        *pIndices++ = base+1; 
        *pIndices++ = base+3;
        *pIndices++ = base+1; 
        *pIndices++ = base+2; 
        *pIndices++ = base+3;
    }

    elem.m_pIndexBuffer->Unlock();
}




//-----------------------------------------------------------------------------
// Name: Sphere()
// Desc: Create sphere mesh
//-----------------------------------------------------------------------------
Sphere::Sphere( FLOAT radius, INT numMajor, INT numMinor, const D3DMATERIAL8& d3dMat )
: 
    Mesh( 1 )
{
    FLOAT majorStep = (D3DX_PI / numMajor);
    FLOAT minorStep = (2.0f * D3DX_PI / numMinor);

    MeshElement& elem = m_Elements[0];
    elem.m_pShader = new ShaderLit( d3dMat );

    INT NumStrips = numMajor;
    INT StripSize = (numMinor+1)*2;

    elem.m_PrimType = D3DPT_TRIANGLESTRIP;
    elem.m_uIndexBufferCount = NumStrips * StripSize + (NumStrips - 1) * 2;
    elem.m_uNumPrimitives = elem.m_uIndexBufferCount - 2;

    UINT uIndexBufferSize = sizeof(WORD) * elem.m_uIndexBufferCount;
    HRESULT hr = g_pd3dDevice->CreateIndexBuffer( uIndexBufferSize, D3DUSAGE_WRITEONLY, 
                                                  D3DFMT_INDEX16, D3DPOOL_MANAGED, 
                                                  &elem.m_pIndexBuffer );
    assert( hr == S_OK );

    struct SimpleVertex
    {
        D3DXVECTOR3 pos;
        D3DXVECTOR3 norm;
    };
    
    elem.m_uNumVertices = (numMajor+1) * (numMinor+1);
    elem.m_uVertexSize = sizeof(SimpleVertex);
    
    UINT uVertexBufferSize = elem.m_uVertexSize * elem.m_uNumVertices;
    hr = g_pd3dDevice->CreateVertexBuffer( uVertexBufferSize, D3DUSAGE_WRITEONLY, 
                                           (D3DFVF_XYZ | D3DFVF_NORMAL), 
                                            D3DPOOL_MANAGED, &elem.m_pVertexBuffer );
    assert( hr == S_OK );

    // Fill vertex buffer
    SimpleVertex* pVerts = NULL;
    elem.m_pVertexBuffer->Lock(0, uVertexBufferSize, (BYTE**)&pVerts, 0 );

    INT k = 0;

    // Build verts
    INT i;
    for( i = 0; i <= numMajor; ++i ) 
    {
        FLOAT a = i * majorStep;
        FLOAT r0 = radius * sinf(a);
        FLOAT z0 = radius * cosf(a);

        for( INT j = 0; j <= numMinor; ++j )
        {
            FLOAT c = j * minorStep;
            FLOAT x = cosf(c);
            FLOAT y = sinf(c);

            pVerts[k].pos.x = x * r0;
            pVerts[k].pos.y = y * r0;
            pVerts[k].pos.z = z0;

            //tx_coords[k][0] = FLOAT(j) / numMinor;
            //tx_coords[k][1] = FLOAT(i) / numMajor;

            FLOAT nx = (x * r0) / radius;
            FLOAT ny = (y * r0) / radius;
            FLOAT nz = z0 / radius;

            pVerts[k].norm.x = nx;
            pVerts[k].norm.y = ny;
            pVerts[k].norm.z = nz;

            //if( ny < 0.0f )
            //    ny = 0.0f;
            //INT color = 50 + INT(ny * 200);

            //colors[k][0] = (unsigned CHAR)color;
            //colors[k][1] = (unsigned CHAR)color;
            //colors[k][2] = (unsigned CHAR)color;
            ++k;
        }
    }

    elem.m_pVertexBuffer->Unlock();

    // Fill index buffer
    WORD* pIndices = NULL;
    elem.m_pIndexBuffer->Lock(0, uIndexBufferSize, (BYTE**)&pIndices, 0 );

    k = 0;

    // Build strips
    for( i = 0; i < numMajor; ++i )
    {
        if( i > 0 )
        {
            // Stitch strips together.
            pIndices[k] = pIndices[k-1];
            ++k;

            pIndices[k++] = WORD( (i)*(numMinor+1) );
        }

        for( INT j = 0; j <= numMinor; ++j )
        {
            // i,j
            pIndices[k++] = WORD( (i)*(numMinor+1) + j );

            // (i+1), j
            pIndices[k++] = WORD( (i+1)*(numMinor+1) + j );
        }
    }

    elem.m_pIndexBuffer->Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Mesh.h ===
//-----------------------------------------------------------------------------
// File: Mesh.h
//
// Desc: Mesh object
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_MESH_H
#define TECH_CERT_GAME_MESH_H

#include "Common.h"
#include "Shader.h"




//-----------------------------------------------------------------------------
// Name: class MeshElement
// Desc: Mesh element
//-----------------------------------------------------------------------------
class MeshElement
{
    Shader*                 m_pShader;
    UINT                    m_uNumPrimitives;
    D3DPRIMITIVETYPE        m_PrimType;
    UINT                    m_uIndexBufferCount;
    LPDIRECT3DINDEXBUFFER8  m_pIndexBuffer;
    DWORD                   m_dwFVF;
    INT                     m_iBasisVectorOffset;
    UINT                    m_uNumVertices;
    UINT                    m_uVertexSize;
    LPDIRECT3DVERTEXBUFFER8 m_pVertexBuffer;

    friend class Box;
    friend class Sphere;
	friend class Mesh;
	friend class HeightField;

public:

    MeshElement();
    MeshElement( DWORD dwFVF, UINT uNumVerts, UINT uNumIndices );
    virtual ~MeshElement();

    virtual HRESULT Save( const File& );
    virtual HRESULT Load( const File& );
    virtual VOID    Render();
    VOID            AddBasisVectors();

    inline UINT GetNumVerts() const
    {
        return m_uNumVertices;
    }

    inline D3DPRIMITIVETYPE GetPrimType() const
    {
        return m_PrimType;
    }

    inline UINT GetIndexBufferCount() const
    {
        return m_uIndexBufferCount;
    }

    inline const LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer() const
    {
        return m_pVertexBuffer;
    }

    inline UINT GetVertexSize() const
    {
        return m_uVertexSize;
    }

    inline const LPDIRECT3DINDEXBUFFER8 GetIndexBuffer() const
    {
        return m_pIndexBuffer;
    }


private:

	HRESULT AllocateVertices(DWORD dwFVF, UINT uNumVerts);
	HRESULT AllocateIndices(UINT uNumIndices);

    VOID CalculateBasisVectors( INT iUVOffset, INT iBVOffset );
    static DWORD ConstantToIndex( DWORD dwConst, const DWORD* pTable );
    static DWORD IndexToConstant( DWORD dwIndex, const DWORD* pTable );
    static DWORD ComputeFVFOffset( DWORD dwComponentFVF, DWORD dwFVF );

};




//-----------------------------------------------------------------------------
// Name: class Mesh
// Desc: List of MeshElements
//-----------------------------------------------------------------------------
class Mesh
{

protected:

    INT          m_iNumMeshElements;
    MeshElement* m_Elements;

    D3DXVECTOR3  m_v3BoxMin, m_v3BoxMax;

	friend class HeightField;

public:

    Mesh();
    Mesh( INT iNumElements );
    virtual ~Mesh();
    
    virtual HRESULT Save( const File& );
    virtual HRESULT Load( const File& );
    VOID            Render();
    VOID            AddBasisVectors();

    inline INT GetNumElements() const
    {
        return m_iNumMeshElements;
    }

    inline MeshElement* GetElement( INT i )
    {
        assert( i < m_iNumMeshElements );
        return m_Elements + i;
    }

    inline const MeshElement* GetElement( INT i ) const
    {
        assert( i < m_iNumMeshElements );
        return m_Elements + i;
    }

	inline const D3DXVECTOR3& GetBoxMin()
	{
		return m_v3BoxMin;
	}

	inline const D3DXVECTOR3& GetBoxMax()
	{
		return m_v3BoxMax;
	}

#if !defined(_XBOX)
	static Mesh* CreateFromXFile(LPDIRECT3DDEVICE8 pd3dDev, char* sz_fname);
#endif
};




//-----------------------------------------------------------------------------
// Name: class Box
// Desc: Box mesh
//-----------------------------------------------------------------------------
class Box : public Mesh
{

public:

    Box( FLOAT width, FLOAT height, FLOAT depth, const D3DMATERIAL8& d3dMat );

private:

    // Disabled
    Box();

};




//-----------------------------------------------------------------------------
// Name: class Sphere
// Desc: Sphere mesh
//-----------------------------------------------------------------------------
class Sphere : public Mesh
{

public:

    Sphere( FLOAT radius, INT numMajor, INT numMinor, const D3DMATERIAL8& d3dMat );

private:

    // Disabled
    Sphere();

};




#endif // TECH_CERT_GAME_MESH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\MusicManager.h ===
//-----------------------------------------------------------------------------
// File: MusicManager.h
//
// Desc: Class definition for the CMusicManager class.  This is the real
//       playback engine.
//
// Hist: 8.20.01 - New for October XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef _MUSICMANAGER_H_
#define _MUSICMANAGER_H_

#include <xtl.h>
#include <dsound.h>

// Packet size is set up to be 2048 samples
// Samples are 16-bit and stereo
#define PACKET_SIZE ( 2048 * 2 * 2 )
#define PACKET_TIME ( 2048.0f / 44100.0f )

#define PACKET_COUNT 43     // Base number of packets
#define EXTRA_PACKETS 10    // Extra packets to get through the transition
#define FADE_TIME ( PACKET_COUNT * PACKET_TIME )


typedef enum {
    MM_STOPPED,
    MM_PAUSED,
    MM_PLAYING,
} MM_STATE;



//-----------------------------------------------------------------------------
// Name: class CSoundtrack
// Desc: Abstraction layer for soundtracks that help merge together game
//       soundtracks and user soundtracks stored on the Xbox hard drive
//-----------------------------------------------------------------------------
class CSoundtrack
{
public:
    CSoundtrack() {}

    VOID    GetSoundtrackName( WCHAR * szName )
        { wcscpy( szName, m_szName ); }
    UINT    GetSongCount()
        { return m_uSongCount; }

    VOID    GetSongInfo( UINT uSongIndex, DWORD * pdwID, DWORD * pdwLength, WCHAR * szName );
    HANDLE  OpenSong( DWORD dwSongID );
    
    WCHAR       m_szName[MAX_SOUNDTRACK_NAME];
    UINT        m_uSongCount;
    BOOL        m_fGameSoundtrack;
    union {
        UINT    m_uSoundtrackID;
        UINT    m_uSoundtrackIndex;
    };
};


//-----------------------------------------------------------------------------
// Name: class CMusicManager
// Desc: Background music engine class.  Spawns its own worker thread when
//       initialized.  Cost of calls from main rendering loop is negligible.
//       All public methods are safe to be called from main rendering loop, 
//       however, they do not all take effect immediately.
//-----------------------------------------------------------------------------
class CMusicManager
{
public:
    CMusicManager();
    ~CMusicManager();
    HRESULT Initialize( BOOL bSpinThread = TRUE );  // Initialize MusicManager

    HRESULT Play();                                 // Start playing
    HRESULT Stop();                                 // Stop playback
    HRESULT Pause();                                // Pause playback
    MM_STATE GetStatus() { return m_mmOldState; }   // Returns current playback status
    HRESULT SetRandom( BOOL fRandom );              // Change random mode
    BOOL    GetRandom() { return m_fRandom; }       // Get random mode
    HRESULT SetGlobal( BOOL fGlobal );              // Toggle global mode
    BOOL    GetGlobal() { return m_fGlobal; }       // Get global mode
    HRESULT SetVolume( LONG lVolume );              // Set volume level
    LONG    GetVolume() { return m_lVolume; }       // Get volume level

    // Returns info on currently playing song
    HRESULT GetCurrentInfo( WCHAR * szSoundtrack, WCHAR * szSong, DWORD * pdwLength );
    FLOAT   GetPlaybackPosition();                  // Returns position in current song
    HRESULT NextSoundtrack();                       // Switch to next soundtrack
    HRESULT NextSong();                             // Switch to next song
    HRESULT RandomSong( BOOL fGlobal = TRUE );      // Switch to a random song

    HRESULT MusicManagerDoWork();                   // Performs processing

private:
    HRESULT LoadSoundtracks();                      // Fill our soundtrack cache
    HRESULT SelectSoundtrack( DWORD dwSoundtrack ); // Switch to a soundtrack
    HRESULT SelectSong( DWORD dwSong );             // Switch to a song
    HRESULT FindNextSong();                         // Determine next song to play

    HRESULT Prepare();          // Get ready to decode and playback current song
    HRESULT Cleanup();          // Cleanup from playing current song
    HRESULT Process();          // Workhorse function - update state and manage packets

    BOOL    FindFreePacket( DWORD *pdwPacket, DWORD dwStream );     // Looks for a free packet
    HRESULT ProcessSource( DWORD dwPacket, XMEDIAPACKET * pxmp );   // Fills packet from source
    HRESULT ProcessStream( DWORD dwPacket, XMEDIAPACKET * pxmp );   // Submist packet to stream

    // Give the threadproc access to our Process() method
    friend DWORD WINAPI MusicManagerThreadProc(LPVOID lpParameter );

    // Stream callback routine for updating playback position
    friend static void CALLBACK StreamCallback( LPVOID pStreamContext, LPVOID pPacketContext, DWORD dwStatus );

    // State variables
    BOOL                    m_fGlobal;                          // TRUE to loop/randomize globally
    BOOL                    m_fRandom;                          // TRUE to move randomly
    LONG                    m_lVolume;                          // Volume level
    MM_STATE                m_mmOldState;                       // Old/current state
    MM_STATE                m_mmState;                          // New state set from game thread
    DWORD                   m_dwPacketsCompleted;               // # of packets completed

    // Music information
    CSoundtrack *           m_aSoundtracks;                     // List of soundtracks
    UINT                    m_uSoundtrackCount;                 // Total number of soundtracks
    UINT                    m_uCurrentSoundtrack;               // Currently selected soundtrack
    WCHAR                   m_szSong[MAX_SONG_NAME];            // Current song name
    DWORD                   m_dwLength;                         // Length of current song
    DWORD                   m_dwSong;                           // Current song index
    DWORD                   m_dwSongID;                         // Current song ID
    HANDLE                  m_hDecodingFile;                    // Song file handle

    // Decode/playback members
    XWmaFileMediaObject *   m_pDecoder;                         // WMA decoder
    IDirectSoundStream *    m_pStream[2];                       // Output streams
    DWORD                   m_dwStream;                         // Current stream
    BYTE *                  m_pbSampleData;                     // Audio sample data

    // Packet status values
    DWORD                   m_adwPacketStatus[PACKET_COUNT+EXTRA_PACKETS];

    // Thread/Synchronization
    HANDLE                  m_hThread;                          // Worker thread
    HANDLE                  m_hShutdownEvent;                   // Shutdown event

#if _DEBUG
    HRESULT DebugVerify();  // Verify all game soundtracks are present
#endif
};

#endif // _MUSICMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\PhysicsShape.h ===
//-----------------------------------------------------------------------------
// FILE: PhysicsShape.h
//
// Desc: Collision primitive base class for all objects.
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef TECH_CERT_GAME_PHYSICS_SHAPE_H
#define TECH_CERT_GAME_PHYSICS_SHAPE_H

#include "Math3d.h"


// Structure conaining the information necessary for resolving an intersection.
struct IntersectionInfo
{
	bool bAtowardsB;				// a towards b if true, else b towards a.
	float fPenetrationDepth;
	Vector3 v3CenterOfIntersection;
	Vector3 v3ExtractionDirection;
};


#endif // TECH_CERT_GAME_PHYSICS_SHAPE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\PhysicsObject.cpp ===
//-----------------------------------------------------------------------------
// FILE: PhysicsObject.cpp
//
// Desc: Physical object in the physics system.
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <assert.h>
#include "PhysicsObject.h"
#include "Polyhedron.h"


PhysicsObject::PhysicsObject( PhysicsSystem* pPhysicsSystem )
:
    m_pPhysicsSystem( pPhysicsSystem )
{
    assert( pPhysicsSystem != NULL );

	fMass = 0.0f;
	fInvMass = 0.0f;

	m3Ibody.Zero();
	m3InvIbody.Zero();

	v3X.Zero();
	v3P.Zero();
	v3L.Zero();

	v3Vel.Zero();
	v3Omega.Zero();
	m3InvI.Zero();

	v3Force.Zero();
	v3Torque.Zero();

	pShape = 0;

	pOverlaps = 0;

	// Setup extent values.
	MinX.bStart = true;
	MinX.pObject = this;
	MaxX.bStart = false;
	MaxX.pObject = this;

	MinY.bStart = true;
	MinY.pObject = this;
	MaxY.bStart = false;
	MaxY.pObject = this;

	MinZ.bStart = true;
	MinZ.pObject = this;
	MaxZ.bStart = false;
	MaxZ.pObject = this;
}


PhysicsObject::PhysicsObject( PhysicsSystem* pPhysicsSystem, 
                              const Vector3& v3Pos, const Quaternion& qRot)
:
    m_pPhysicsSystem( pPhysicsSystem )
{
    assert( pPhysicsSystem != NULL );

	fMass = 0.0f;
	fInvMass = 0.0f;

	m3Ibody.Zero();
	m3InvIbody.Zero();

	v3X = v3Pos;
	qR = qRot;

	v3P.Zero();
	v3L.Zero();

	v3Vel.Zero();
	v3Omega.Zero();
	m3InvI.Zero();

	v3Force.Zero();
	v3Torque.Zero();

	pShape = 0;

	pOverlaps = 0;

	// Setup extent values.
	MinX.bStart = true;
	MinX.pObject = this;
	MaxX.bStart = false;
	MaxX.pObject = this;

	MinY.bStart = true;
	MinY.pObject = this;
	MaxY.bStart = false;
	MaxY.pObject = this;

	MinZ.bStart = true;
	MinZ.pObject = this;
	MaxZ.bStart = false;
	MaxZ.pObject = this;
}

PhysicsSystem* PhysicsObject::GetPhysicsSystem()
{
    return m_pPhysicsSystem;
}


void PhysicsObject::SetPhysicalProperties(float fMass, Matrix3 m3Ibody)
{
	PhysicsObject::fMass = fMass;
	fInvMass = 1.0f / fMass;

	PhysicsObject::m3Ibody = m3Ibody;
	m3InvIbody = ~m3Ibody;

	// Recompute derived variables.
	ComputeDerivedVariables();
}


void PhysicsObject::SetShape(Polyhedron* pShape)
{
	PhysicsObject::pShape = pShape;
}


void PhysicsObject::SetRotation(const Quaternion& qRot)
{
	qR = qRot;
	ComputeDerivedVariables();
}


const Quaternion& PhysicsObject::GetRotation()
{
	return qR;
}


const Vector3& PhysicsObject::GetTranslation()
{
	return v3X;
}


void PhysicsObject::SetTranslation(const Vector3& v3Trans)
{
	v3X = v3Trans;
}


void PhysicsObject::UpdateExtents()
{
	if (pShape)
	{
		Vector3 min, max;

		pShape->ComputeExtents(Transformation(qR, v3X), &min, &max);

		MinX.Value = min.x;
		MaxX.Value = max.x;
		MinY.Value = min.y;
		MaxY.Value = max.y;
		MinZ.Value = min.z;
		MaxZ.Value = max.z;
	}
}


bool PhysicsObject::ExtentsOverlap(PhysicsObject* pA, PhysicsObject* pB)
{
	if (pA->MinX.Value > pB->MaxX.Value || pB->MinX.Value > pA->MaxX.Value ||
		pA->MinY.Value > pB->MaxY.Value || pB->MinY.Value > pA->MaxY.Value ||
		pA->MinZ.Value > pB->MaxZ.Value || pB->MinZ.Value > pA->MaxZ.Value ||
		(pA->fMass == 0.0f && pB->fMass == 0.0f) )
	{
		return false;
	}
	else
	{
		return true;
	}
}		


void PhysicsObject::ComputeDerivedVariables()
{
	// Renormalize quaternion.
	qR.Normalize();

	// Compute rotation matrix.
	Matrix3 m3R(qR);

	// Compute world space inverse inertia tensor.
	m3InvI = m3R.GetTranspose() * m3InvIbody * m3R;

	// Compute linear velocity.
	v3Vel = v3P * fInvMass;

	// Compute angular velocity.
	v3Omega = v3L * m3InvI;
}


void PhysicsObject::ApplyImpulse(const Vector3& v3At, const Vector3& v3Impulse)
{
	if (fInvMass > 0.0f)
	{
		// Apply impulse to linear and angular momentum.
		v3P += v3Impulse;
		v3L += (v3At - v3X) ^ v3Impulse;

		// Recompute derived variables.
		v3Vel = v3P * fInvMass;
		v3Omega = v3L * m3InvI;
	}
}


void PhysicsObject::AddForce(const Vector3& v3At, const Vector3& v3Force)
{
	PhysicsObject::v3Force += v3Force;
	v3Torque += (v3At - v3X) ^ v3Force;
}


Vector3 PhysicsObject::VelocityAtPoint(const Vector3& v3At)
{
	return v3Vel + (v3Omega ^ (v3At - v3X));
}


Vector3 PhysicsObject::GetVelocity()
{
    return v3Vel;
}


void PhysicsObject::AddConstraints(float time)
{
    USED( time );
	return;
}


void PhysicsObject::ComputeForceAndTorque(float time)
{
    USED( time );
	if (fInvMass > 0.0f)
	{
		v3Force += Vector3(0.0f, -9.8f, 0.0f) * fMass;

		// Dampen any linear and angular velocity.
		v3Force -= v3Vel * 0.2f * fMass;
		v3Torque -= v3Omega * 2.0f * ~m3InvI;
	}
}


bool PhysicsObject::ReadyToSleep()
{
	return	v3Vel.GetLength() < 0.05f && 
			v3Omega.GetLength() < 0.05f &&
			(v3Force * fInvMass).GetLength() < 0.1f &&
			(v3Torque * m3InvI).GetLength() < 0.1f;
}


DWORD PhysicsObject::GetMaxStateSize() // static
{
	return 13;
}


int PhysicsObject::StateSize()
{
	return 13;
}


void PhysicsObject::GetState( FLOAT* pState )
{
	pState[0] = v3X.x;
	pState[1] = v3X.y;
	pState[2] = v3X.z;

	pState[3] = qR.x;
	pState[4] = qR.y;
	pState[5] = qR.z;
	pState[6] = qR.w;

	pState[7] = v3P.x;
	pState[8] = v3P.y;
	pState[9] = v3P.z;

	pState[10] = v3L.x;
	pState[11] = v3L.y;
	pState[12] = v3L.z;

	for (int i = 0; i < 13; i++)
		assert(_finite(pState[i]));
}


void PhysicsObject::SetState( const FLOAT* pState )
{
	for (int i = 0; i < 13; i++)
		assert(_finite(pState[i]));

	v3X.x = pState[0];
	v3X.y = pState[1];
	v3X.z = pState[2];

	qR.x = pState[3];
	qR.y = pState[4];
	qR.z = pState[5];
	qR.w = pState[6];

	v3P.x = pState[7];
	v3P.y = pState[8];
	v3P.z = pState[9];

	v3L.x = pState[10];
	v3L.y = pState[11];
	v3L.z = pState[12];

	// Recompute derived variables.
	ComputeDerivedVariables();
}


void PhysicsObject::GetDerivatives(float* derivs)
{
	derivs[0] = v3Vel.x;
	derivs[1] = v3Vel.y;
	derivs[2] = v3Vel.z;

	Quaternion qdot = 0.5f * (Quaternion(v3Omega.x, v3Omega.y, v3Omega.z, 0.0f) * qR);
	derivs[3] = qdot.x;
	derivs[4] = qdot.y;
	derivs[5] = qdot.z;
	derivs[6] = qdot.w;

	derivs[7] = v3Force.x;
	derivs[8] = v3Force.y;
	derivs[9] = v3Force.z;

	derivs[10] = v3Torque.x;
	derivs[11] = v3Torque.y;
	derivs[12] = v3Torque.z;

	for (int i = 0; i < 13; i++)
		assert(_finite(derivs[i]));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\PhysicsSystem.cpp ===
//-----------------------------------------------------------------------------
// FILE: PhysicsSystem.cpp
//
// Desc: Physics system
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <assert.h>
#include "PhysicsSystem.h"
#include "Polyhedron.h"
#include "HeightField.h"
#include "PerfTimer.h"
#include "Globals.h"
#include "Controller.h"
#pragma warning(disable: 4355)



//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_PHYSICS_OBJECTS = 20; // arbitrary




PhysicsSystem::PhysicsSystem()
:
    m_WorldObject( this )
{
	// Initilize global overlap list.
	OverlapsHead.pPrev = 0;
	OverlapsHead.pNext = &OverlapsTail;
	OverlapsTail.pPrev = &OverlapsHead;
	OverlapsTail.pNext = 0;

	pHeightField = 0;
}




//-----------------------------------------------------------------------------
// Name: ~PhysicsSystem()
// Desc: Destroy the system
//-----------------------------------------------------------------------------
PhysicsSystem::~PhysicsSystem()
{
    Shutdown();
}




//-----------------------------------------------------------------------------
// Name: Shutdown()
// Desc: Shutdown the physics system
//-----------------------------------------------------------------------------
void PhysicsSystem::Shutdown()
{
    // Bye bye static constraints
    for( ConstraintList::iterator i = StaticConstraints.begin();
         i != StaticConstraints.end(); ++i )
    {
        delete *i;
    }
    StaticConstraints.clear();

	// Remove any objects left in the object list.
	PhysObjList::iterator it = Objects.begin();
	while (it != Objects.end())
	{
		RemoveObject((*it));
		it = Objects.begin();
	}

    // Initilize global overlap list
    OverlapsHead.pPrev = NULL;
    OverlapsHead.pNext = &OverlapsTail;
    OverlapsTail.pPrev = &OverlapsHead;
    OverlapsTail.pNext = NULL;

	// Make sure extent lists are empty.
	ExtentsX.clear();
	ExtentsY.clear();
	ExtentsZ.clear();

    // Nuke height field
    delete pHeightField;
    pHeightField = NULL;
}




FLOAT PhysicsSystem::Simulate(float start_time, float end_time)
{
	static float fLeftOverTime = 0.0f;

	float state0[13*32], state1[13*32], derivatives[13*32];
	PhysObjList::iterator it;
	TimeStamp start, end;

	// Add in left over time.
	start_time -= fLeftOverTime;
	fLeftOverTime = 0.0f;

	// Clamp timestep.
	if (end_time > start_time+0.05f)
		end_time = start_time+0.05f;

#if (0)
	// Fixed time step for debugging.
	end_time = start_time + 0.002f;
#endif

	GetTimeStamp(&start);

    FLOAT fRumble = 0.0f;
	while (start_time < end_time)
	{
		float step = end_time - start_time;

		if (step > fMaxTimeStep)
			step = fMaxTimeStep;

		if (step < fMinTimeStep)
		{
			fLeftOverTime = step;
			break;
		}

		// Take half step.
		ProcessCollisionsAndForces( start_time, fRumble );

		float half_step = step*0.5f;

		int offset = 0;
		for (it = Objects.begin(); it != Objects.end(); ++it )
		{
			// Get state.
			(*it)->GetState(state0+offset);

			// Get derivatives.
			(*it)->GetDerivatives(derivatives+offset);

			int state_size = (*it)->StateSize();

			// Take half step.
			for (int i = offset; i < offset+state_size; i++)
				state1[i] = state0[i] + half_step * derivatives[i];

			// Set state.
			(*it)->SetState(state1+offset);

			offset += state_size;
		}

		bool bDiscontinous = ProcessCollisionsAndForces( start_time+half_step, fRumble );

		if (bDiscontinous)
		{
			// Bail out of integrator.
			start_time += half_step;
			continue;
		}

		// Take full step with derivatives from midpoint.
		offset = 0;
		for (it = Objects.begin(); it != Objects.end(); ++it )
		{
			// Get derivatives at midpoint.
			(*it)->GetDerivatives(derivatives+offset);

			int state_size = (*it)->StateSize();

			// Take half step.
			for (int i = offset; i < offset+state_size; i++)
				state1[i] = state0[i] + step * derivatives[i];

			// Set state.
			(*it)->SetState(state1+offset);

			offset += state_size;
		}

		start_time += step;
	}

	GetTimeStamp(&end);
	g_PhysicsTime += SecondsElapsed(start, end);

    if( fRumble < 0.0f )
        fRumble = 0.0f;
    else if( fRumble > 1.0f )
        fRumble = 1.0f;
    return fRumble;
}


bool PhysicsSystem::ProcessCollisionsAndForces( float cur_time, FLOAT& fRumble )
{
	float A[iMaxConstraints][iMaxConstraints];
	float b[iMaxConstraints];
	TimeStamp start, end;
	PhysObjList::iterator it;
	bool bAppliedImpulse = false;

	g_DebugLines.clear();
	Collisions.clear();

	// Update object extents.
	for (it = Objects.begin(); it != Objects.end(); ++it )
		(*it)->UpdateExtents();

	// Find any intersections.
	SortExtentsAndUpdate(ExtentsX);
	SortExtentsAndUpdate(ExtentsY);
	SortExtentsAndUpdate(ExtentsZ);

	static IntersectionInfo IntInfos[32];

	for (OverlapRecord* pRec = OverlapsHead.pNext; pRec != &OverlapsTail; pRec = pRec->pNext)
	{
		PhysicsObject* pA = pRec->pA;
		PhysicsObject* pB = pRec->pB;

		// Check objects we overlap.
		Transformation TransformA(pA->qR, pA->v3X);
		Transformation TransformB(pB->qR, pB->v3X);

		if (Polyhedron::CheckForIntersection(TransformA, *pA->pShape, 
											 TransformB, *pB->pShape))
		{
			GetTimeStamp(&start);

			int iNumInfos = 0;
			Polyhedron::ComputeIntersectionInfo(TransformA, *pA->pShape, 
												TransformB, *pB->pShape, 
												&iNumInfos, IntInfos);

			for (int i = 0; i < iNumInfos; i++)
			{
				if (IntInfos[i].bAtowardsB)
					Collisions.push_back(CollisionRecord(pA, pB));
				else
					Collisions.push_back(CollisionRecord(pB, pA));

				CollisionRecord& crec = Collisions.back();
				crec.info = IntInfos[i];

#if (0)
				// Add debug lines for intersection.
				g_DebugLines.push_back(DebugLine());
				DebugLine& line = g_DebugLines.back();
				line.pos1 = crec.info.v3CenterOfIntersection;
				line.color1 = 0x00ff0000;
				line.pos2 = crec.info.v3CenterOfIntersection 
							+ crec.info.v3ExtractionDirection * 0.5f;
				line.color2 = 0x0000ff00;
#endif
			}

			GetTimeStamp(&end);
			g_CollisionTime += SecondsElapsed(start, end);
		}
	}

	// Check against heightfield.
	if (pHeightField)
	{
		for (it = Objects.begin(); it != Objects.end(); ++it )
		{
			// Skip static objects.
			if ((*it)->fMass == 0.0f)
				continue;

			int iNumInfos = 0;
			Transformation TransformA;
			Transformation TransformB((*it)->qR, (*it)->v3X);
			pHeightField->ComputeIntersectionInfo(TransformA, TransformB, *(*it)->pShape, &iNumInfos, IntInfos);

			for (int i = 0; i < iNumInfos; i++)
			{
				if (IntInfos[i].bAtowardsB)
					Collisions.push_back(CollisionRecord( GetWorldObject(), (*it)));
				else
					Collisions.push_back(CollisionRecord((*it), GetWorldObject() ));

				CollisionRecord& crec = Collisions.back();
				crec.info = IntInfos[i];

#if (0)
				// Add debug lines for intersection.
				g_DebugLines.push_back(DebugLine());
				DebugLine& line = g_DebugLines.back();
				line.pos1 = crec.info.v3CenterOfIntersection;
				line.color1 = 0x00ff0000;
				line.pos2 = crec.info.v3CenterOfIntersection 
							+ crec.info.v3ExtractionDirection * 0.5f;
				line.color2 = 0x0000ff00;
#endif
			}
		}
	}

	// Setup active constraint list.
	for (it = Objects.begin(); it != Objects.end(); ++it )
	{
		(*it)->AddConstraints(cur_time);
	}

	// Add static constraints to active list.
	for (UINT i = 0; i < StaticConstraints.size(); i++)
	{
		const Constraint& sc = *StaticConstraints[i];

		Constraint* dc = new Constraint(sc.pA, sc.pB);

		dc->Type = sc.Type;
		dc->v3Point = sc.v3Point * sc.pA->qR + sc.pA->v3X;
		dc->v3Normal = sc.v3Normal * sc.pB->qR;
		dc->fDist = sc.fDist - dc->v3Normal * sc.pB->v3X;

		ActiveConstraints.push_back(dc);
	}

	// Compute A matrix for constraint solver.
	ComputeAMatrix(ActiveConstraints, A);

	// Resolve any collisions.
	bool bCollisionsResolved = false;
	while (!bCollisionsResolved)
	{
		bCollisionsResolved = true;

		CollisionList::iterator cit;
		for (cit = Collisions.begin(); cit != Collisions.end(); ++cit )
		{
			PhysicsObject* pA = (*cit).pA;
			PhysicsObject* pB = (*cit).pB;
			const Vector3& n = (*cit).info.v3ExtractionDirection;
			const Vector3& p = (*cit).info.v3CenterOfIntersection;

			Vector3 ra = p - pA->v3X;
			Vector3 rb = p - pB->v3X;

			Vector3 padot = pA->VelocityAtPoint(p);
			Vector3 pbdot = pB->VelocityAtPoint(p);
			float vrel = n * (padot - pbdot);

			// Stop any velocity that will cause further penetration.
			if (vrel < -0.1f)
			{
				float numerator = -(1.0f + 0.0f) * vrel;
				float term3 = n * (((ra ^ n) * pA->m3InvI) ^ ra);
				float term4 = n * (((rb ^ n) * pB->m3InvI) ^ rb);
				float j = numerator / (pA->fInvMass + pB->fInvMass + term3 + term4);

				Vector3 impulse = j * n;

				assert(_finite(impulse.x) && _finite(impulse.y) && _finite(impulse.z));

				pA->ApplyImpulse(p,  impulse);
				pB->ApplyImpulse(p, -impulse);

				// We may have messed up another collision.
				bCollisionsResolved = false;
				bAppliedImpulse = true;
			}
		}
	}

	// Compute b vector (velocities) for constriants.
	for (i = 0; i < ActiveConstraints.size(); i++)
	{
		Constraint& c = *ActiveConstraints[i];

		Vector3 pa_dot = c.pA->VelocityAtPoint(c.v3Point);
		Vector3 pb_dot = c.pB->VelocityAtPoint(c.v3Point);
		b[i] = c.v3Normal * (pa_dot - pb_dot);

		if (c.Type == Constraint::Bilateral)
		{
			// Return to correct position.
			float error_dist = c.v3Normal * c.v3Point + c.fDist;
			b[i] += 0.1f * error_dist;
		}
	}

	// Solve for constraint impulses.
	float constraint_impulses[iMaxConstraints];
	ConstraintSolver(ActiveConstraints, A, b, constraint_impulses);

	// Apply constraint impulses.
	for (i = 0; i < ActiveConstraints.size(); i++)
	{
		Constraint& c = *ActiveConstraints[i];

		c.pA->ApplyImpulse(c.v3Point, c.v3Normal * constraint_impulses[i]);
		c.pB->ApplyImpulse(c.v3Point, c.v3Normal * -constraint_impulses[i]);
	}

	// Add external forces.
	for (it = Objects.begin(); it != Objects.end(); ++it )
	{
		(*it)->v3Force.Zero();
		(*it)->v3Torque.Zero();

		(*it)->ComputeForceAndTorque(cur_time);
	}

	// Add non-penetration forces.
	CollisionList::iterator cit;
	for (cit = Collisions.begin(); cit != Collisions.end(); ++cit )
	{
		PhysicsObject* pA = (*cit).pA;
		PhysicsObject* pB = (*cit).pB;
		const Vector3& n = (*cit).info.v3ExtractionDirection;
		const Vector3& p = (*cit).info.v3CenterOfIntersection;

		// Add non-penetration force.
		Vector3 padot = pA->VelocityAtPoint(p);
		Vector3 pbdot = pB->VelocityAtPoint(p);
		float vrel = n * (padot - pbdot);
		Vector3 tvel = (padot - pbdot) - (n * vrel);

		if (vrel < 0.0f) vrel = 0.0f;

		float ks = 100.0f * (pA->fMass + pB->fMass);
		float kd = 10.0f * (pA->fMass + pB->fMass);

		Vector3 force = n * (ks * (*cit).info.fPenetrationDepth - kd * vrel);

		if (tvel.GetLength() > 0.01f)
		{
			// Add friction force.
			float mag = force.GetLength();
			force -= tvel * mag * 0.2f;
		}

		assert(_finite(force.x) && _finite(force.y) && _finite(force.z));

		pA->AddForce(p,  force);
		pB->AddForce(p, -force);

        fRumble += force.GetLength();
	}

	// Compute b vector (accelerations) for constriants.
	ComputeBVector(ActiveConstraints, b);

	// Solve for constraint forces.
	float constraint_forces[iMaxConstraints];
	ConstraintSolver(ActiveConstraints, A, b, constraint_forces);

	// Add constraint forces.
	for (i = 0; i < ActiveConstraints.size(); i++)
	{
		Constraint& c = *ActiveConstraints[i];

		c.pA->AddForce(c.v3Point, c.v3Normal * constraint_forces[i]);
		c.pB->AddForce(c.v3Point, c.v3Normal * -constraint_forces[i]);
	}

#if (0)
	// Check to make sure accelerations were zeroed.
	ComputeBVector(ActiveConstraints, b);
	for (i = 0; i < ActiveConstraints.size(); i++)
	{
		switch (ActiveConstraints[i]->Type)
		{
		case Constraint::UnilateralVertFace:
		case Constraint::UnilateralEdgeEdge:
			assert(b[i] > -0.001f);
		break;

		case Constraint::StaticFriction:
			assert(fabs(b[i]) < 0.001f || fabs(constraint_forces[i])+0.001f > ActiveConstraints[i]->fFrictionForce);
		break;

		case Constraint::Bilateral:
			assert(fabs(b[i]) < 0.001f);
		break;
		}
	}
#endif;

	// Get rid of active constraints.
	for (i = 0; i < ActiveConstraints.size(); i++)
		delete ActiveConstraints[i];

	ActiveConstraints.clear();

	return bAppliedImpulse;
}


void PhysicsSystem::AddObject(PhysicsObject* pObj)
{
	pObj->UpdateExtents();

	// Add object extents.
	InsertExtent(ExtentsX, &pObj->MinX);
	InsertExtent(ExtentsX, &pObj->MaxX);

	InsertExtent(ExtentsY, &pObj->MinY);
	InsertExtent(ExtentsY, &pObj->MaxY);

	InsertExtent(ExtentsZ, &pObj->MinZ);
	InsertExtent(ExtentsZ, &pObj->MaxZ);

	// Add overlaps.
	for (PhysObjList::iterator it = Objects.begin(); it != Objects.end(); ++it )
	{
		PhysicsObject* pB = *it;

		if (PhysicsObject::ExtentsOverlap(pObj, pB))
		{
			AddOverlap(pObj, pB);
		}
	}

	// Add object to object list.
	Objects.push_back(pObj);
    assert( Objects.size() < MAX_PHYSICS_OBJECTS );
}


void PhysicsSystem::RemoveObject(PhysicsObject* pObj)
{
	// Remove object from object list.
	Objects.remove(pObj);

	// Remove object extents.
	RemoveExtent(ExtentsX, &pObj->MinX);
	RemoveExtent(ExtentsX, &pObj->MaxX);

	RemoveExtent(ExtentsY, &pObj->MinY);
	RemoveExtent(ExtentsY, &pObj->MaxY);

	RemoveExtent(ExtentsZ, &pObj->MinZ);
	RemoveExtent(ExtentsZ, &pObj->MaxZ);

	// Remove overlaps.
	OverlapRecord* pRec = pObj->pOverlaps;
	while (pRec)
	{
		RemoveOverlap(pRec->pA, pRec->pB);
		pRec = pObj->pOverlaps;
	}
}


void PhysicsSystem::AddHeightField(HeightField* pHF)
{
	pHeightField = pHF;
}


void PhysicsSystem::AddPinJointConstraint(PhysicsObject* pA, PhysicsObject* pB, const Vector3& v3Point)
{
	Vector3 pos_a = v3Point * ~Transformation(pA->qR, pA->v3X);
	Vector3 pos_b = v3Point * ~Transformation(pB->qR, pB->v3X);

	Constraint* c1 = new Constraint(pA, pB);
	Constraint* c2 = new Constraint(pA, pB);
	Constraint* c3 = new Constraint(pA, pB);

	c1->Type = Constraint::Bilateral;
	c1->v3Point = pos_a;
	c1->v3Normal = Vector3(1.0f, 0.0f, 0.0f);
	c1->fDist = -(c1->v3Normal * pos_b);

	c2->Type = Constraint::Bilateral;
	c2->v3Point = pos_a;
	c2->v3Normal = Vector3(0.0f, 1.0f, 0.0f);
	c2->fDist = -(c2->v3Normal * pos_b);

	c3->Type = Constraint::Bilateral;
	c3->v3Point = pos_a;
	c3->v3Normal = Vector3(0.0f, 0.0f, 1.0f);
	c3->fDist = -(c3->v3Normal * pos_b);

	StaticConstraints.push_back(c1);
	StaticConstraints.push_back(c2);
	StaticConstraints.push_back(c3);
}


Constraint* PhysicsSystem::AddConstraint(PhysicsObject* pA, PhysicsObject* pB)
{
	Constraint* c = new Constraint(pA, pB);

	ActiveConstraints.push_back(c);

	return c;
}


bool PhysicsSystem::CheckLineSegment(const Vector3& p1, const Vector3& p2, float* p_t, Vector3* p_q)
{
	if (pHeightField)
	{
		return( pHeightField->CheckLineSegment(p1, p2, p_t, p_q) == TRUE );
	}
	else
	{
		// Check line (p1,p2).
		Plane3 ground(0.0f, 1.0f, 0.0f, -0.5f);

		float d1 = ground.GetDistance(p1);
		float d2 = ground.GetDistance(p2);

		if (d2 < 0.0f)
		{
			float t = d1 / (d1 - d2);
			*p_q = (1.0f - t) * p1 + t * p2;
			*p_t = t;
			return true;
		}
	}

	return false;
}



//-----------------------------------------------------------------------------
// Name: GetMaxStateSize()
// Desc: Returns the maximum state size of the physics system
//-----------------------------------------------------------------------------
DWORD PhysicsSystem::GetMaxStateSize() // static
{
    return MAX_PHYSICS_OBJECTS * PhysicsObject::GetMaxStateSize();
}




int PhysicsSystem::GetStateSize()
{
	// Return the total of the sizes of each object.
	int state_size = 0;

	PhysObjList::iterator it;
	for (it = Objects.begin(); it != Objects.end(); ++it )
	{
		state_size += (*it)->StateSize();
	}

	return state_size;
}



void PhysicsSystem::GetState( FLOAT* pState )
{
    assert( pState != NULL );

	// Get the state of each object
	PhysObjList::iterator it;
	for (it = Objects.begin(); it != Objects.end(); ++it )
	{
		// Get state
		(*it)->GetState( pState );

		pState += (*it)->StateSize();
	}
}



void PhysicsSystem::SetState( const FLOAT* pState )
{
    assert( pState != NULL );

	// Set the state of each object
	PhysObjList::iterator it;
	for (it = Objects.begin(); it != Objects.end(); ++it )
	{
		// Get state
		(*it)->SetState( pState );

		pState += (*it)->StateSize();
	}
}



PhysicsObject* PhysicsSystem::GetWorldObject()
{
    return &m_WorldObject;
}



void PhysicsSystem::AddOverlap(PhysicsObject* pA, PhysicsObject* pB)
{
	// Check for duplicates.
	OverlapRecord* pRec = pA->pOverlaps;
	while (pRec)
	{
		if (pRec->pA == pA)
		{
			if (pRec->pB == pB)
				return;

			pRec = pRec->pNextA;
		}
		else // if (pRec->pB == pA)
		{
			if (pRec->pA == pB)
				return;

			pRec = pRec->pNextB;
		}
	}

	// Allocate new record.
	pRec = new OverlapRecord(pA, pB);

	// Add to overlap list for pA.
	pRec->pNextA = pA->pOverlaps;
	pA->pOverlaps = pRec;

	// Add to overlap list for pA.
	pRec->pNextB = pB->pOverlaps;
	pB->pOverlaps = pRec;

	// Add to global overlap list.
	OverlapsTail.pPrev->pNext = pRec;
	pRec->pPrev = OverlapsTail.pPrev;
	pRec->pNext = &OverlapsTail;
	OverlapsTail.pPrev = pRec;
}


void PhysicsSystem::RemoveOverlap(PhysicsObject* pA, PhysicsObject* pB)
{
	// Remove record from A's list.
	OverlapRecord** pPrevPtr = &pA->pOverlaps;
	OverlapRecord* pRec = pA->pOverlaps;
	while (pRec)
	{
		if (pRec->pA == pA)
		{
			if (pRec->pB == pB)
			{
				*pPrevPtr = pRec->pNextA;
				break;
			}

			pRec = pRec->pNextA;
		}
		else // if (pRec->pB == pA)
		{
			if (pRec->pA == pB)
			{
				*pPrevPtr = pRec->pNextB;
				break;
			}

			pRec = pRec->pNextB;
		}
	}

	// Remove record from B's list.
	pPrevPtr = &pB->pOverlaps;
	pRec = pB->pOverlaps;
	while (pRec)
	{
		if (pRec->pA == pB)
		{
			if (pRec->pB == pA)
			{
				*pPrevPtr = pRec->pNextA;
				break;
			}

			pRec = pRec->pNextA;
		}
		else // if (pRec->pB == pB)
		{
			if (pRec->pA == pA)
			{
				*pPrevPtr = pRec->pNextB;
				break;
			}

			pRec = pRec->pNextB;
		}
	}

	if (pRec)
	{
		// Remove from global overlap list.
		pRec->pPrev->pNext = pRec->pNext;
		pRec->pNext->pPrev = pRec->pPrev;

		delete pRec;
	}
}


void PhysicsSystem::InsertExtent(ExtentList& extents, PhysicsObject::Extent* extent)
{
	int n = extents.size();

	// Find where the extent goes and insert it.
	int i;
	for (i = 0; i < n; i++)
	{
		if (extent->Value < extents[i]->Value)
			break;
	}

	// Make room.
	extents.resize(n+1);
	for (int j = n; j > i; j--)
	{
		extents[j] = extents[j-1];
	}

	extents[i] = extent;
}


void PhysicsSystem::RemoveExtent(ExtentList& extents, PhysicsObject::Extent* extent)
{
	int n = extents.size();

	// Find where the extent is and remove it.
	int i;
	for (i = 0; i < n; i++)
	{
		if (extents[i] == extent)
			break;
	}

	assert(i < n);

	// Make room.
	for (int j = i; j < n-1; j++)
	{
		extents[j] = extents[j+1];
	}

	extents.resize(n-1);
}


void PhysicsSystem::SortExtentsAndUpdate(ExtentList& extents)
{
	const int n = extents.size();

	for (int step = 1; step < n; step++)
	{
		int i;
		PhysicsObject::Extent* temp;

		temp = extents[step];
		for (i = step-1; i >= 0; i--)
		{
			if (extents[i]->Value > temp->Value)
			{
				// Make room.
				extents[i+1] = extents[i];

				// See if overlap status has changed.
				if (temp->bStart ^ extents[i]->bStart)
				{
					// REVISIT: Should we save up a count of swaps to minimize checks?
					if (PhysicsObject::ExtentsOverlap(temp->pObject, extents[i]->pObject))
					{
						// Add overlap.
						AddOverlap(temp->pObject, extents[i]->pObject);
					}
					else
					{
						// Remove overlap.
						RemoveOverlap(temp->pObject, extents[i]->pObject);
					}
				}
			}
			else
			{
				// Found place.
				break;
			}
		}

		// Insert value from Array[step].
		extents[i+1] = temp;
	}
}


void PhysicsSystem::ComputeAMatrix(const ConstraintList& Constraints, float matA[][iMaxConstraints])
{
	const int iNumConstraints = Constraints.size();

	for (int i = 0; i < iNumConstraints; i++)
	{
		const Constraint& ci = *Constraints[i];

		for (int j = 0; j < iNumConstraints; j++)
		{
			const Constraint& cj = *Constraints[j];

			// Check to see if constraints are distict.
			if ((ci.pA != cj.pA) && (ci.pB != cj.pB) &&
				(ci.pA != cj.pB) && (ci.pB != cj.pA))
			{
				matA[i][j] = 0.0f;
				continue;
			}

			PhysicsObject* pA = ci.pA;
			PhysicsObject* pB = ci.pB;
			Vector3 ra = (ci.v3Point - pA->v3X);
			Vector3 rb = (ci.v3Point - pB->v3X);

			// What force and torque does constraint j exert on body A?
			Vector3 force_on_a(0.0f, 0.0f, 0.0f);
			Vector3 torque_on_a(0.0f, 0.0f, 0.0f);

			if (cj.pA == ci.pA)
			{
				force_on_a = cj.v3Normal;
				torque_on_a = (cj.v3Point - pA->v3X) ^ cj.v3Normal;
			}
			else if (cj.pB == ci.pA)
			{
				force_on_a = -cj.v3Normal;
				torque_on_a = (cj.v3Point - pA->v3X) ^ -cj.v3Normal;
			}

			// What force and torque does constraint j exert on body B?
			Vector3 force_on_b(0.0f, 0.0f, 0.0f);
			Vector3 torque_on_b(0.0f, 0.0f, 0.0f);

			if (cj.pA == ci.pB)
			{
				force_on_b = cj.v3Normal;
				torque_on_b = (cj.v3Point - pB->v3X) ^ cj.v3Normal;
			}
			else if (cj.pB == ci.pB)
			{
				force_on_b = -cj.v3Normal;
				torque_on_b = (cj.v3Point - pB->v3X) ^ -cj.v3Normal;
			}

			// Compute how the j'th contact force affects the linear and
			// angular acceleration of the contact point on body A.
			Vector3 a_linear = force_on_a * pA->fInvMass;
			Vector3 a_angular = (torque_on_a * pA->m3InvI) ^ ra;

			// Do the same for body B.
			Vector3 b_linear = force_on_b * pB->fInvMass;
			Vector3 b_angular = (torque_on_b * pB->m3InvI) ^ rb;

			matA[i][j] = ci.v3Normal * ((a_linear + a_angular) - (b_linear + b_angular));
		}
	}
}


void PhysicsSystem::ComputeBVector(const ConstraintList& Constraints, float* vecB)
{
	const int iNumConstraints = Constraints.size();

	for (int i = 0; i < iNumConstraints; i++)
	{
		const Constraint& c = *Constraints[i];

		PhysicsObject* pA = c.pA;
		PhysicsObject* pB = c.pB;

		Vector3 ra = (c.v3Point - pA->v3X);
		Vector3 rb = (c.v3Point - pB->v3X);

		// Compute the part of pa_dot_dot due to external force and torque.
		Vector3 pa_dot_dot = pA->v3Force * pA->fInvMass +
							 ((pA->v3Torque * pA->m3InvI) ^ ra);

		// .. and similarly for pb_dot_dot.
		Vector3 pb_dot_dot = pB->v3Force * pB->fInvMass +
							 ((pB->v3Torque * pB->m3InvI) ^ rb);

		// Compute the part of pa_dot_dot due to velocity
		pa_dot_dot += (pA->v3Omega ^ (pA->v3Omega ^ ra)) +
					  (((pA->v3L ^ pA->v3Omega) * pA->m3InvI) ^ ra);

		// .. and similarly for pb_dot_dot.
		pb_dot_dot += (pB->v3Omega ^ (pB->v3Omega ^ rb)) +
					  (((pB->v3L ^ pB->v3Omega) * pB->m3InvI) ^ rb);

		vecB[i] = c.v3Normal * (pa_dot_dot - pb_dot_dot);

		Vector3 pa_dot = c.pA->VelocityAtPoint(c.v3Point);
		Vector3 pb_dot = c.pB->VelocityAtPoint(c.v3Point);
	
		switch(c.Type)
		{
			/*
			case Constraint::Bilateral:
			{
				//Vector3 ndot = pB->v3Omega ^ c.v3Normal;
				//vecB[i] += 2.0f * ndot * (pa_dot - pb_dot);

				float error_dist = c.v3Normal * c.v3Point + c.fDist;
				vecB[i] += 1.0f * error_dist + (c.v3Normal * (pa_dot - pb_dot) * 0.1f);
			}
			break;
			*/

			case Constraint::UnilateralVertFace:
			{
				Vector3 ndot = pB->v3Omega ^ c.v3Normal;
				vecB[i] += 2.0f * ndot * (pa_dot - pb_dot);
			}
			break;

			case Constraint::UnilateralEdgeEdge:
			{
				Vector3 eadot = pA->v3Omega ^ c.v3EdgeA;
				Vector3 ebdot = pB->v3Omega ^ c.v3EdgeB;
				Vector3 z = (eadot ^ c.v3EdgeB) + (c.v3EdgeA ^ ebdot);
				Vector3 n = c.v3EdgeA ^ c.v3EdgeB;

				float l = n.GetLength();
				n /= l;

				Vector3 ndot = (z - ((z * n) * n)) / l;

				vecB[i] += 2.0f * ndot * (pa_dot - pb_dot);
			}
			break;

			case Constraint::StaticFriction:
			{
				//Vector3 ndot = pB->v3Omega ^ c.v3Normal;
				//vecB[i] += 2.0f * ndot * (pa_dot - pb_dot);
			}
			break;
		}
	}
}


//
// Solve a linear system of equations A * x = b
//
bool PhysicsSystem::SolveLinearSystem(float A[][iMaxConstraints], int n, float* b, float* x)
{
	float p[iMaxConstraints];

	// Cholesky decomposition.
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			float sum = A[i][j];

			for (int k = i-1; k >= 0; k--)
				sum -= A[i][k] * A[j][k];

			if (i == j)
			{
				if (sum <= 0.0f)
					return false;

				p[i] = sqrtf(sum);
			}
			else
			{
				A[j][i] = sum / p[i];
			}
		}
	}

	// Backsubstitution.
	for (i = 0; i < n; i++)
	{
		float sum = b[i];
		for (int k = i-1; k >= 0; k--)
			sum -= A[i][k] * x[k];

		x[i] = sum / p[i];
	}

	for (i = n-1; i >= 0; i--)
	{
		float sum = x[i];
		for (int k = i+1; k < n; k++)
			sum -= A[k][i] * x[k];

		x[i] = sum / p[i];
	}

	return true;
}


//
// Vector matrix multiplication (x = A * b)
//
void PhysicsSystem::MatVecMul(float A[][iMaxConstraints], int n, float* b, float* x)
{
	for (int i = 0; i < n; i++)
	{
		float sum = 0.0f;

		for (int j = 0; j < n; j++)
		{
			sum += A[i][j] * b[j];
		}

		x[i] = sum;
	}
}


void PhysicsSystem::ConstraintSolver(const ConstraintList& Constraints, float A[][iMaxConstraints], float* b, float* f)
{
	int i;
	float A11[iMaxConstraints][iMaxConstraints];	// Subset of A matrix.
	float a[iMaxConstraints];						// Current accelerations.
	float delta_f[iMaxConstraints];					// Change in forces.
	float delta_a[iMaxConstraints];					// Change in accelerations.
	SolverSets ConstraintSet[iMaxConstraints];		// Current classification of each constraint.
	int A11_index[iMaxConstraints];					// Indices used for build A11 matrix.
	float v1[iMaxConstraints];
	float x[iMaxConstraints];
	int A11_size;

	const int iNumConstraints = Constraints.size();

	// C = NC = Cf = NC+ = NC- = empty
	for (i = 0; i < iNumConstraints; i++)
		ConstraintSet[i] = SetNone;

	// f = 0
	for (i = 0; i < iNumConstraints; i++)
		f[i] = 0.0f;

	// a = b
	for (i = 0; i < iNumConstraints; i++)
		a[i] = b[i];

	//
	// Solve for bilateral constraints and place them in C.
	//
	A11_size = 0;
	for (i = 0; i < iNumConstraints; i++)
	{
		if (Constraints[i]->Type == Constraint::Bilateral)
		{
			ConstraintSet[i] = SetC;
			A11_index[A11_size++] = i;
		}
	}

	// A11 = A(CC)
	for (i = 0; i < A11_size; i++)
		for (int j = 0; j < A11_size; j++)
			A11[i][j] = A[A11_index[i]][A11_index[j]];

	// -v1 = -b
	for (i = 0; i < A11_size; i++)
		v1[i] = -b[A11_index[i]];

#if (0)
	float Temp[iMaxConstraints][iMaxConstraints];
	memcpy(Temp, A11, sizeof(A11));
#endif

	// Solve A11*x = -v1
	SolveLinearSystem(A11, A11_size, v1, x);

#if (0)
	// Check solution.
	float y[iMaxConstraints];
	MatVecMul(Temp, A11_size, x, y);

	for (i = 0; i < A11_size; i++)
		assert(fabs(v1[i] - y[i]) < 0.001f);
#endif

	// df = 0
	for (i = 0; i < iNumConstraints; i++)
		delta_f[i] = 0.0f;

	// Transfer x into delta_f
	for (i = 0; i < A11_size; i++)
		delta_f[A11_index[i]] = x[i];

	// delta_a = A * delta_f
	MatVecMul(A, iNumConstraints, delta_f, delta_a);

	// f = f + delta_f
	for (i = 0; i < iNumConstraints; i++)
		f[i] +=  delta_f[i];

	// a = a + delta_a
	for (i = 0; i < iNumConstraints; i++)
		a[i] += delta_a[i];

	//
	// Now use Dantzig's algorithm for solving LCP's to solve for the unilateral
	// and friction constraint forces.
	//
	for (int d = 0; d < iNumConstraints; d++)
	{
		// Scan for a constraint where the conditions are not met.
		if (ConstraintSet[d] != SetNone)
			continue;

		if ((Constraints[d]->Type == Constraint::UnilateralVertFace ||
			 Constraints[d]->Type == Constraint::UnilateralVertFace) &&
			a[d] > 0.0f)
		{
			// Go ahead and put this constraint in NC.
			ConstraintSet[d] = SetNC;
			continue;
		}

		if (Constraints[d]->Type == Constraint::StaticFriction && fabs(a[d]) < 1e-6f)
		{
			// Go ahead and put this constraint in Cf.
			ConstraintSet[d] = SetCf;
			continue;
		}

L1:
		//
		// drive-to-zero(d)
		//

		//
		// delta_f = fdirection(d)
		//
		for (i = 0; i < iNumConstraints; i++)
		{
			delta_f[i] = 0.0f;
		}

		if (a[d] < 0.0f)
			delta_f[d] = 1.0f;
		else
			delta_f[d] = -1.0f;

		// A11 = A(CC)
		A11_size = 0;
		for (i = 0; i < iNumConstraints; i++)
			if (ConstraintSet[i] == SetC || ConstraintSet[i] == SetCf)
				A11_index[A11_size++] = i;

		for (i = 0; i < A11_size; i++)
			for (int j = 0; j < A11_size; j++)
				A11[i][j] = A[A11_index[i]][A11_index[j]];

		// -v1 = -A(Cd)
		for (i = 0; i < A11_size; i++)
			v1[i] = -A[A11_index[i]][d] * delta_f[d];

#if (0)
		float Temp[iMaxConstraints][iMaxConstraints];
		memcpy(Temp, A11, sizeof(A11));
#endif

		// Solve A11*x = -v1
		SolveLinearSystem(A11, A11_size, v1, x);

#if (0)
		// Check solution.
		float y[iMaxConstraints];
		MatVecMul(Temp, A11_size, x, y);

		for (i = 0; i < A11_size; i++)
			assert(fabs(v1[i] - y[i]) < 0.001f);
#endif

		// Transfer x into delta_f
		for (i = 0; i < A11_size; i++)
			delta_f[A11_index[i]] = x[i];

		// delta_a = A * delta_f
		MatVecMul(A, iNumConstraints, delta_f, delta_a);

		//
		// (s,j) = maxstep(f,a,delta_f,delta_a,d)
		//
		float s = FLT_MAX;
		int j = -1;
		SolverSets NextSet = SetNone;

		if (Constraints[d]->Type == Constraint::StaticFriction)
		{
			if (delta_a[d]*delta_f[d] > 0.0f)
			{
				// Either reduce a to zero ..
				j = d;
				s = -a[d] / delta_a[d];
				NextSet = SetCf;
			}
				
			// .. or increase f to maximum.
			if (delta_f[d] > 0.0f)
			{
				float s_prime = (Constraints[d]->fFrictionForce - f[d]) / delta_f[d];
				if (s_prime < s)
				{
					j = d;
					s = s_prime;
					NextSet = SetNCfplus;
				}
			}
			else if (delta_f[d] < 0.0f)
			{
				float s_prime = (-Constraints[d]->fFrictionForce - f[d]) / delta_f[d];
				if (s_prime < s)
				{
					j = d;
					s = s_prime;
					NextSet = SetNCfminus;
				}
			}
		}
		else
		{
			assert(delta_a[d] > 0.0f);

			// Step that will reduce accel to zero.
			j = d;
			s = -a[d] / delta_a[d];
			NextSet = SetC;
		}

		for (i = 0; i < iNumConstraints; i++)
		{
			if (ConstraintSet[i] == SetC && Constraints[i]->Type != Constraint::Bilateral)
			{
				// Step that would reduce force to zero.
				if (delta_f[i] < 0.0f)
				{
					float s_prime = -f[i] / delta_f[i];
					if (s_prime < s)
					{
						j = i;
						s = s_prime;
					}
				}	
			}
			else if (ConstraintSet[i] == SetNC)
			{
				// Step that would reduce accel to zero.
				if (delta_a[i] < 0.0f)
				{
					float s_prime = -a[i] / delta_a[i];
					if (s_prime < s)
					{
						j = i;
						s = s_prime;
					}
				}
			}
			else if (ConstraintSet[i] == SetCf)
			{
				// Step that would increase force to maximum.
				if (delta_f[i] > 0.0f)
				{
					float s_prime = (Constraints[i]->fFrictionForce - f[i]) / delta_f[i];
					if (s_prime < s)
					{
						j = i;
						s = s_prime;
						NextSet = SetNCfplus;
					}
				}
				else if (delta_f[i] < 0.0f)
				{
					float s_prime = (-Constraints[i]->fFrictionForce - f[i]) / delta_f[i];
					if (s_prime < s)
					{
						j = i;
						s = s_prime;
						NextSet = SetNCfminus;
					}
				}
			}
			else if (ConstraintSet[i] == SetNCfplus)
			{
				// Step that would reduce accel to zero.
				if (delta_a[i] > 0.0f)
				{
					float s_prime = -a[i] / delta_a[i];
					if (s_prime < s)
					{
						j = i;
						s = s_prime;
					}
				}
			}
			else if (ConstraintSet[i] == SetNCfminus)
			{
				// Step that would reduce accel to zero.
				if (delta_a[i] < 0.0f)
				{
					float s_prime = -a[i] / delta_a[i];
					if (s_prime < s)
					{
						j = i;
						s = s_prime;
					}
				}
			}
		}

		assert(j != -1);

		// f = f + s * delta_f
		for (i = 0; i < iNumConstraints; i++)
			f[i] += s * delta_f[i];

		// a = a + s * delta_a
		for (i = 0; i < iNumConstraints; i++)
			a[i] += s * delta_a[i];

		if (ConstraintSet[j] == SetC)
		{
			// Move to NC.
			ConstraintSet[j] = SetNC;
			goto L1;
		}
		else if (ConstraintSet[j] == SetNC)
		{
			// Move to C.
			ConstraintSet[j] = SetC;
			goto L1;
		}
		else if (ConstraintSet[j] == SetCf)
		{
			// Move to NCf+ or NCf- based on a.
			ConstraintSet[j] = NextSet;
			goto L1;
		}
		else if (ConstraintSet[j] == SetNCfplus)
		{
			// Move to Cf.
			ConstraintSet[j] = SetCf;
			goto L1;
		}
		else if (ConstraintSet[j] == SetNCfminus)
		{
			// Move to Cf.
			ConstraintSet[j] = SetCf;
			goto L1;
		}
		else
		{
			// Place in C, Cf, NCf+, or NCf-.
			ConstraintSet[j] = NextSet;
		}
	}
}


const float PhysicsSystem::fMaxTimeStep = 0.02f;
const float PhysicsSystem::fMinTimeStep = 0.001f;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\PhysicsObject.h ===
//-----------------------------------------------------------------------------
// FILE: PhysicsObject.h
//
// Desc: Physical object in the physics system.
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef TECH_CERT_GAME_PHYSICS_OBJECT_H
#define TECH_CERT_GAME_PHYSICS_OBJECT_H

#include "Common.h"
#include "Math3d.h"


class Polyhedron;
class OverlapRecord;


class PhysicsObject
{
public:
	friend class PhysicsSystem;

	// Construct a static object.
	PhysicsObject( PhysicsSystem* );

	// Construct a static object at a specific location.
	PhysicsObject( PhysicsSystem*, const Vector3& v3Pos, const Quaternion& qRot);

    PhysicsSystem* GetPhysicsSystem();

	// Set the physical properties of the object.
	void SetPhysicalProperties(float fMass, Matrix3 m3Ibody);

	// Set the collision primitive for the object.
	void SetShape(Polyhedron* pShape);

	// Get the current rotation of the object.
	const Quaternion& GetRotation();

	// Set the current rotation of the object.
	void SetRotation(const Quaternion& qRot);

	// Get the current translation of the object.
	const Vector3& GetTranslation();

	// Set the current translation of the object.
	void SetTranslation(const Vector3& v3Trans);

	// Update world space extents.
	void UpdateExtents();

	// Return true if the extenst of the two objects overlap.
	static bool ExtentsOverlap(PhysicsObject* pA, PhysicsObject* pB);

	// Recompute derived variables.
	void ComputeDerivedVariables();

	// Apply an impulse at a point on the object.
	void ApplyImpulse(const Vector3& v3At, const Vector3& v3Impulse);

	// Add force at a point on the object.
	void AddForce(const Vector3& v3At, const Vector3& v3Force);

	// Get the velocity at a point on the object.
	Vector3 VelocityAtPoint(const Vector3& v3At);

    // Get the linear velocity of the object
    Vector3 GetVelocity();

	// Add any non-static constraints acting on the object.
	virtual void AddConstraints(float time);

	// Compute force and torque acting on the object.
	virtual void ComputeForceAndTorque(float time);

	// Is the object ready to sleep?
	bool ReadyToSleep();

	// Methods to support numerical integration.
    static DWORD GetMaxStateSize();
	int  StateSize();
	void GetState( FLOAT* pState );
	void SetState( const FLOAT* pState );
	void GetDerivatives(float* derivs);

private:

    // Disable
	PhysicsObject();
    PhysicsObject( const PhysicsObject& );

private:

    PhysicsSystem* m_pPhysicsSystem; // System in which object participates

	// Properties.
	float	fMass;
	float	fInvMass;		// 1 / Mass
	Matrix3 m3Ibody;		// Inertia tensor in body space.
	Matrix3 m3InvIbody;		// Inverse inertia tensor in body space.

	// State variables.
	Vector3 v3X;			// Position of center of mass.
	Quaternion qR;			// Orientation (local to world rotation).
	Vector3 v3P;			// Linear momentum.
	Vector3 v3L;			// Angular momentum.

	// Derived variables.
	Vector3 v3Vel;			// Linear velocity.
	Vector3 v3Omega;		// Angular velocity.
	Matrix3 m3InvI;			// World space inverse inertia tensor.

	// Computed variables.
	Vector3 v3Force;		// Force accumulator.
	Vector3 v3Torque;		// Torque accumulator.

	// Collision data.
	Polyhedron* pShape;		// Collision primitive.

	// Extent in a dimension.
	struct Extent
	{
		float Value;				// Value.
		bool bStart;				// Start or end?
		PhysicsObject* pObject;		// Object the extent belongs to.
	};

	Extent MinX, MaxX, MinY, MaxY, MinZ, MaxZ;

	// Overlap records involving this object.
	OverlapRecord* pOverlaps;
};


#endif // TECH_CERT_GAME_PHYSICS_OBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Polyhedron.cpp ===
//-----------------------------------------------------------------------------
// FILE: Polyhedron.cpp
//
// Desc: Collision primitive for all objects.
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "Common.h"
#include <memory>
#include <assert.h>
#include "Polyhedron.h"
#include "PerfTimer.h"
#include "Globals.h"




Polyhedron::Polyhedron()
{
	m_iNumFaces = 0;
	m_iNumVerts = 0;
	m_iNumVertPtrsUsed = 0;
}


Polyhedron::Polyhedron(float w, float h, float d)
{
	float hh = 0.5f * h;
	float hw = 0.5f * w;
	float hd = 0.5f * d;

	new (this) Polyhedron( Vector3(-hw, -hh, -hd), Vector3(hw, hh, hd) );
}


Polyhedron::Polyhedron(const Vector3& min, const Vector3& max)
{
	m_iNumFaces = 6;
	m_iNumVerts = 8;

	for (int i = 0; i < 6; i++)
		m_Faces[i].pVerts = m_VertPtrPool + i*4;

	m_iNumVertPtrsUsed = 6*4;

	for (int i = 0; i < 8; i++)
	{
		m_v3Verts[i].x = (i & 4) ? max.x : min.x;
		m_v3Verts[i].y = (i & 2) ? max.y : min.y;
		m_v3Verts[i].z = (i & 1) ? max.z : min.z;
	}

	// Bottom.
	m_Faces[0].plPlane = Plane3(0.0f, -1.0f, 0.0f, min.y);
	m_Faces[0].iNumVerts = 4;
	m_Faces[0].pVerts[0] = 0; // 000
	m_Faces[0].pVerts[1] = 4; // 100
	m_Faces[0].pVerts[2] = 5; // 101
	m_Faces[0].pVerts[3] = 1; // 001

	// Top.
	m_Faces[1].plPlane = Plane3(0.0f, 1.0f, 0.0f, -max.y);
	m_Faces[1].iNumVerts = 4;
	m_Faces[1].pVerts[0] = 2; // 010
	m_Faces[1].pVerts[1] = 3; // 011
	m_Faces[1].pVerts[2] = 7; // 111
	m_Faces[1].pVerts[3] = 6; // 110

	// Left.
	m_Faces[2].plPlane = Plane3(-1.0f, 0.0f, 0.0f, min.x);
	m_Faces[2].iNumVerts = 4;
	m_Faces[2].pVerts[0] = 0; // 000
	m_Faces[2].pVerts[1] = 1; // 001
	m_Faces[2].pVerts[2] = 3; // 011
	m_Faces[2].pVerts[3] = 2; // 010

	// Right.
	m_Faces[3].plPlane = Plane3(1.0f, 0.0f, 0.0f, -max.x);
	m_Faces[3].iNumVerts = 4;
	m_Faces[3].pVerts[0] = 4; // 100
	m_Faces[3].pVerts[1] = 6; // 110
	m_Faces[3].pVerts[2] = 7; // 111
	m_Faces[3].pVerts[3] = 5; // 101

	// Front.
	m_Faces[4].plPlane = Plane3(0.0f, 0.0f, -1.0f, min.z);
	m_Faces[4].iNumVerts = 4;
	m_Faces[4].pVerts[0] = 0; // 000
	m_Faces[4].pVerts[1] = 2; // 010
	m_Faces[4].pVerts[2] = 6; // 110
	m_Faces[4].pVerts[3] = 4; // 100

	// Back.
	m_Faces[5].plPlane = Plane3(0.0f, 0.0f, 1.0f, -max.z);
	m_Faces[5].iNumVerts = 4;
	m_Faces[5].pVerts[0] = 1; // 001
	m_Faces[5].pVerts[1] = 5; // 101
	m_Faces[5].pVerts[2] = 7; // 111
	m_Faces[5].pVerts[3] = 3; // 011
}


Polyhedron::Polyhedron(float radius, int numMajor, int numMinor)
{
	float majorStep = (fPI / numMajor);
	float minorStep = (2.0f * fPI / numMinor);

	m_iNumFaces = numMajor * numMinor;
	m_iNumVerts = 2 + (numMajor - 1) * numMinor;
	m_iNumVertPtrsUsed = 0;

	int k = 0;

    // Build verts
    for( int i = 0; i <= numMajor; ++i ) 
    {
        FLOAT a = i * majorStep;
        FLOAT r0 = radius * sinf(a);
        FLOAT z0 = radius * cosf(a);

		if (i == 0)
		{
			// Top vert.
			m_v3Verts[k].x = 0.0f;
			m_v3Verts[k].y = 0.0f;
			m_v3Verts[k].z = z0;

			++k;
		}
		else if (i == numMajor)
		{
			// Bottom vert.
			m_v3Verts[k].x = 0.0f;
			m_v3Verts[k].y = 0.0f;
			m_v3Verts[k].z = z0;

			++k;
		}
		else
		{
			for( int j = 0; j < numMinor; ++j )
			{
				FLOAT c = j * minorStep;
				FLOAT x = cosf(c);
				FLOAT y = sinf(c);

				m_v3Verts[k].x = x * r0;
				m_v3Verts[k].y = y * r0;
				m_v3Verts[k].z = z0;

				++k;
			}
		}
    }

	assert(k == m_iNumVerts);

	k = 0;

	// Build faces.
    for( int i = 0; i < numMajor; ++i )
    {
        for( int j = 0; j < numMinor; ++j )
        {
			if (i == 0)
			{
				// Top tri.
				m_Faces[k].iNumVerts = 3;
				m_Faces[k].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
				m_iNumVertPtrsUsed += 3;

				int base = 1;

				m_Faces[k].pVerts[0] = base + j;
				m_Faces[k].pVerts[1] = 0;
				m_Faces[k].pVerts[2] = base + (j+1) % numMinor;

				m_Faces[k].plPlane = Plane3(m_v3Verts[m_Faces[k].pVerts[0]], 
										    m_v3Verts[m_Faces[k].pVerts[1]], 
										    m_v3Verts[m_Faces[k].pVerts[2]]);
			}
			else if (i == numMajor-1)
			{
				// Bottom tri.
				m_Faces[k].iNumVerts = 3;
				m_Faces[k].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
				m_iNumVertPtrsUsed += 3;

				int base = 1 + (i - 1) * numMinor;

				m_Faces[k].pVerts[0] = base + j;
				m_Faces[k].pVerts[1] = base + (j+1) % numMinor;
				m_Faces[k].pVerts[2] = m_iNumVerts-1;

				m_Faces[k].plPlane = Plane3(m_v3Verts[m_Faces[k].pVerts[0]], 
										    m_v3Verts[m_Faces[k].pVerts[1]], 
										    m_v3Verts[m_Faces[k].pVerts[2]]);
			}
			else
			{
				m_Faces[k].iNumVerts = 4;
				m_Faces[k].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
				m_iNumVertPtrsUsed += 4;

				int base = 1 + (i - 1) * numMinor;

				m_Faces[k].pVerts[0] = base + j;
				m_Faces[k].pVerts[1] = base + (j+1) % numMinor;
				m_Faces[k].pVerts[2] = base + numMinor + (j+1) % numMinor;
				m_Faces[k].pVerts[3] = base + numMinor + j;

				m_Faces[k].plPlane = Plane3(m_v3Verts[m_Faces[k].pVerts[0]], 
										    m_v3Verts[m_Faces[k].pVerts[1]], 
										    m_v3Verts[m_Faces[k].pVerts[2]]);
			}

			k++;
        }
    }

	assert(k == m_iNumFaces);
}


Polyhedron::Polyhedron(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& sweep)
{
	m_iNumFaces = 5;
	m_iNumVerts = 6;
	m_iNumVertPtrsUsed = 0;

	m_v3Verts[0] = v1;
	m_v3Verts[1] = v2;
	m_v3Verts[2] = v3;
	m_v3Verts[3] = v1 + sweep;
	m_v3Verts[4] = v2 + sweep;
	m_v3Verts[5] = v3 + sweep;

	// Top.
	m_Faces[0].plPlane = Plane3(v1, v2, v3);
	m_Faces[0].iNumVerts = 3;
	m_Faces[0].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
	m_iNumVertPtrsUsed += 3;
	m_Faces[0].pVerts[0] = 0;
	m_Faces[0].pVerts[1] = 1;
	m_Faces[0].pVerts[2] = 2;

	// Sides.
	m_Faces[1].plPlane = Plane3(v2, v1, v1+sweep);
	m_Faces[1].iNumVerts = 4;
	m_Faces[1].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
	m_iNumVertPtrsUsed += 4;
	m_Faces[1].pVerts[0] = 1;
	m_Faces[1].pVerts[1] = 0;
	m_Faces[1].pVerts[2] = 0 + 3;
	m_Faces[1].pVerts[3] = 1 + 3;

	m_Faces[2].plPlane = Plane3(v3, v2, v2+sweep);
	m_Faces[2].iNumVerts = 4;
	m_Faces[2].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
	m_iNumVertPtrsUsed += 4;
	m_Faces[2].pVerts[0] = 2;
	m_Faces[2].pVerts[1] = 1;
	m_Faces[2].pVerts[2] = 1 + 3;
	m_Faces[2].pVerts[3] = 2 + 3;

	m_Faces[3].plPlane = Plane3(v1, v3, v3+sweep);
	m_Faces[3].iNumVerts = 4;
	m_Faces[3].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
	m_iNumVertPtrsUsed += 4;
	m_Faces[3].pVerts[0] = 0;
	m_Faces[3].pVerts[1] = 2;
	m_Faces[3].pVerts[2] = 2 + 3;
	m_Faces[3].pVerts[3] = 0 + 3;

	// Bottom.
	m_Faces[4].plPlane = Plane3(v3+sweep, v2+sweep, v1+sweep);
	m_Faces[4].iNumVerts = 3;
	m_Faces[4].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
	m_iNumVertPtrsUsed += 3;
	m_Faces[4].pVerts[0] = 2 + 3;
	m_Faces[4].pVerts[1] = 1 + 3;
	m_Faces[4].pVerts[2] = 0 + 3;
}


Polyhedron::Polyhedron(const Polyhedron& ph)
{
	m_iNumFaces = ph.m_iNumFaces;
	m_iNumVerts = ph.m_iNumVerts;
	m_iNumVertPtrsUsed = 0;

	for (int i = 0; i < m_iNumVerts; i++)
	{
		m_v3Verts[i] = ph.m_v3Verts[i];
	}

	for (int i = 0; i < m_iNumFaces; i++)
	{
		m_Faces[i].plPlane = ph.m_Faces[i].plPlane;
		m_Faces[i].iNumVerts = ph.m_Faces[i].iNumVerts;
		m_Faces[i].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
		m_iNumVertPtrsUsed += m_Faces[i].iNumVerts;

		for (int j = 0; j < m_Faces[i].iNumVerts; j++)
			m_Faces[i].pVerts[j] = ph.m_Faces[i].pVerts[j];
	}
}


Polyhedron& Polyhedron::operator= (const Polyhedron& ph)
{
	new (this) Polyhedron(ph);

	return *this;
}


Polyhedron::Polyhedron(const Polyhedron& ph, const Transformation& tf)
{
	m_iNumFaces = ph.m_iNumFaces;
	m_iNumVerts = ph.m_iNumVerts;
	m_iNumVertPtrsUsed = 0;

	for (int i = 0; i < m_iNumVerts; i++)
	{
		m_v3Verts[i] = ph.m_v3Verts[i] * tf;
	}

	for (int i = 0; i < m_iNumFaces; i++)
	{
		m_Faces[i].plPlane = ph.m_Faces[i].plPlane * tf;
		m_Faces[i].iNumVerts = ph.m_Faces[i].iNumVerts;
		m_Faces[i].pVerts = m_VertPtrPool + m_iNumVertPtrsUsed;
		m_iNumVertPtrsUsed += m_Faces[i].iNumVerts;

		for (int j = 0; j < m_Faces[i].iNumVerts; j++)
			m_Faces[i].pVerts[j] = ph.m_Faces[i].pVerts[j];
	}
}


Polyhedron::~Polyhedron()
{
}


bool Polyhedron::PointInPolyhedron(const Vector3& pnt, float fEpsilon) const
{
	for (int i = 0; i < m_iNumFaces; i++)
	{
		float dist = m_Faces[i].plPlane.GetDistance(pnt);
		if (dist > fEpsilon)
			return false;
	}

	return true;
}


void Polyhedron::ComputeExtents(const Transformation& tf, Vector3* pMin, Vector3* pMax)
{
	pMin->x = FLT_MAX;
	pMin->y = FLT_MAX;
	pMin->z = FLT_MAX;

	pMax->x = -FLT_MAX;
	pMax->y = -FLT_MAX;
	pMax->z = -FLT_MAX;

	for (int i = 0; i < m_iNumVerts; i++)
	{
		Vector3 vert = m_v3Verts[i] * tf;

		if (vert.x < pMin->x)
			pMin->x = vert.x;

		if (vert.y < pMin->y)
			pMin->y = vert.y;

		if (vert.z < pMin->z)
			pMin->z = vert.z;

		if (vert.x > pMax->x)
			pMax->x = vert.x;

		if (vert.y > pMax->y)
			pMax->y = vert.y;

		if (vert.z > pMax->z)
			pMax->z = vert.z;
	}
}


void Polyhedron::ComputeExtents(Vector3* pMin, Vector3* pMax)
{
	pMin->x = FLT_MAX;
	pMin->y = FLT_MAX;
	pMin->z = FLT_MAX;

	pMax->x = -FLT_MAX;
	pMax->y = -FLT_MAX;
	pMax->z = -FLT_MAX;

	for (int i = 0; i < m_iNumFaces; i++)
	{
		Vector3& vert = m_v3Verts[i];

		if (vert.x < pMin->x)
			pMin->x = vert.x;

		if (vert.y < pMin->y)
			pMin->y = vert.y;

		if (vert.z < pMin->z)
			pMin->z = vert.z;

		if (vert.x > pMax->x)
			pMax->x = vert.x;

		if (vert.y > pMax->y)
			pMax->y = vert.y;

		if (vert.z > pMax->z)
			pMax->z = vert.z;
	}
}


bool Polyhedron::CheckForIntersection(const Transformation& ta, const Polyhedron& a, 
									  const Transformation& tb, const Polyhedron& b)
{
	const Transformation a_to_b = ta * ~tb;
	const Transformation b_to_a = ~a_to_b;

	// Are all points of b outside any plane of a?
	for (int i = 0; i < a.m_iNumFaces; i++)
	{
		bool bAllOut = true;

		for (int j = 0; j < b.m_iNumVerts; j++)
		{
			float d = a.m_Faces[i].plPlane.GetDistance(b.m_v3Verts[j] * b_to_a);

			if (d < 0.0f)
			{
				bAllOut = false;
				break;
			}
		}

		if (bAllOut)
			return false;
	}
				
	// Are all points of a outside any plane of b?
	for (int i = 0; i < b.m_iNumFaces; i++)
	{
		bool bAllOut = true;

		for (int j = 0; j < a.m_iNumVerts; j++)
		{
			float d = b.m_Faces[i].plPlane.GetDistance(a.m_v3Verts[j] * a_to_b);

			if (d < 0.0f)
			{
				bAllOut = false;
				break;
			}
		}

		if (bAllOut)
			return false;
	}

	// The polyhedrons may also be seperated by and edge/edge plane.

	return true;
}


bool Polyhedron::ComputeIntersectionInfo(const Transformation& ta, const Polyhedron& a, 
										 const Transformation& tb, const Polyhedron& b, 
										 int* pNumInfos, IntersectionInfo* pInfo)
{
	TimeStamp start, end;

	*pNumInfos = 0;

	GetTimeStamp(&start);

	// Transform both polyhedrons into world space.
	Polyhedron world_a(a, ta);
	Polyhedron world_b(b, tb);

	GetTimeStamp(&end);
	g_TransformTime += SecondsElapsed(start, end);

	GetTimeStamp(&start);

	// Find any vertices of a that are in b.
	for (int i = 0; i < world_a.m_iNumVerts; i++)
	{
		bool bInside = true;
		float nearest_dist = -FLT_MAX;
		int nearest_face = 0;

		for (int j = 0; j < world_b.m_iNumFaces; j++)
		{
			float d = world_b.m_Faces[j].plPlane.GetDistance(world_a.m_v3Verts[i]);

			if (d >= 0.0f)
			{
				bInside = false;
				break;
			}
			else if (d > nearest_dist)
			{
				nearest_dist = d;
				nearest_face = j;
			}
		}

		if (bInside)
		{
			// Add spring.
			pInfo[*pNumInfos].bAtowardsB = true;
			pInfo[*pNumInfos].v3ExtractionDirection = world_b.m_Faces[nearest_face].plPlane.GetNormal();
			pInfo[*pNumInfos].v3CenterOfIntersection = world_a.m_v3Verts[i];
			pInfo[*pNumInfos].fPenetrationDepth = -nearest_dist;
			(*pNumInfos)++;
		}
	}

	// Find any vertices of b that are in a.
	for (int i = 0; i < world_b.m_iNumVerts; i++)
	{
		bool bInside = true;
		float nearest_dist = -FLT_MAX;
		int nearest_face = 0;

		for (int j = 0; j < world_a.m_iNumFaces; j++)
		{
			float d = world_a.m_Faces[j].plPlane.GetDistance(world_b.m_v3Verts[i]);

			if (d >= 0.0f)
			{
				bInside = false;
				break;
			}
			else if (j == 0 /*d > nearest_dist*/)
			{
				nearest_dist = d;
				nearest_face = j;
			}
		}

		if (bInside)
		{
			// Add spring.
			pInfo[*pNumInfos].bAtowardsB = false;
			pInfo[*pNumInfos].v3ExtractionDirection = world_a.m_Faces[nearest_face].plPlane.GetNormal();
			pInfo[*pNumInfos].v3CenterOfIntersection = world_b.m_v3Verts[i];
			pInfo[*pNumInfos].fPenetrationDepth = -nearest_dist;
			(*pNumInfos)++;
		}
	}

	GetTimeStamp(&end);
	g_ClipTime += SecondsElapsed(start, end);

	return( *pNumInfos != 0 ? TRUE : FALSE );
}


// Some defines used by the following code.
#define CUBE(x) ((x) * (x) * (x))
#define SQR(x) ((x) * (x))
enum { X = 0, Y = 1, Z = 2 };


void Polyhedron::ComputeCenterOfMassAndVolume(Vector3* pCoM, float* pVolume)
{
	float total_volume = 0.0f;
	Vector3 center_of_mass(0.0f, 0.0f, 0.0f);

	for (int i = 0; i < m_iNumFaces; i++)
	{
		assert(m_Faces[i].iNumVerts >= 3);

		// Area of face times normal.
		for (int j = 2; j < m_Faces[i].iNumVerts; j++)
		{
			// Area of triangle.
			Vector3 v1 = m_v3Verts[m_Faces[i].pVerts[j-1]] - m_v3Verts[m_Faces[i].pVerts[0]];
			Vector3 v2 = m_v3Verts[m_Faces[i].pVerts[j]] - m_v3Verts[m_Faces[i].pVerts[0]];
			Vector3 cross = (v1 ^ v2);
			float area = 0.5f * cross.GetLength();

			float volume = -m_Faces[i].plPlane.d * area;

			// Add the volume of this tetrahedron.
			total_volume += volume;

			// Centroid of triangle (and center of mass of this tetrahedron).
			Vector3 cent = m_v3Verts[m_Faces[i].pVerts[0]] + 
						   m_v3Verts[m_Faces[i].pVerts[j-1]] + 
						   m_v3Verts[m_Faces[i].pVerts[j]];

			center_of_mass += volume * cent;
		}
	}

	center_of_mass /= 4.0f * total_volume;
	total_volume *= (1.0f/3.0f);

	*pVolume = total_volume;
	*pCoM = center_of_mass;
}


//
// The following code is based on:
//
// Brian Mirtich, ``Fast and Accurate Computation of Polyhedral Mass Properties,'' 
// journal of graphics tools, volume 1, number 2, 1996
//
void Polyhedron::ComputeMassProperties(float fDensity, float* pMass, Vector3* pCoM, Matrix3* pIT)
{
	VolumeIntegrals vi;

	ComputeVolumeIntegrals(vi);

	float fMass = fDensity * vi.T0[X];
	float r[3];
	float J[3][3];

	// Compute center of mass.
	r[X] = vi.T1[X] / vi.T0[X];
	r[Y] = vi.T1[Y] / vi.T0[X];
	r[Z] = vi.T1[Z] / vi.T0[X];

	// Compute inertia tensor.
	J[X][X] = fDensity * (vi.T2[Y] + vi.T2[Z]);
	J[Y][Y] = fDensity * (vi.T2[Z] + vi.T2[X]);
	J[Z][Z] = fDensity * (vi.T2[X] + vi.T2[Y]);
	J[X][Y] = J[Y][X] = -fDensity * vi.TP[X];
	J[Y][Z] = J[Z][Y] = -fDensity * vi.TP[Y];
	J[Z][X] = J[X][Z] = -fDensity * vi.TP[Z];

	// Translate inertia tensor to center of mass.
	J[X][X] -= fMass * (r[Y]*r[Y] + r[Z]*r[Z]);
	J[Y][Y] -= fMass * (r[Z]*r[Z] + r[X]*r[X]);
	J[Z][Z] -= fMass * (r[X]*r[X] + r[Y]*r[Y]);
	J[X][Y] = J[Y][X] += fMass * r[X] * r[Y];
	J[Y][Z] = J[Z][Y] += fMass * r[Y] * r[Z];
	J[Z][X] = J[X][Z] += fMass * r[Z] * r[X];

	// Copy to output.
	*pMass = fMass;

	pCoM->x = r[X];
	pCoM->y = r[Y];
	pCoM->z = r[Z];

	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 3; j++)
			pIT->m[i][j] = J[i][j];
}


void Polyhedron::ComputeProjectionIntegrals(const Face& face, VolumeIntegrals& vi)
{
	vi.P1 = 0.0f;
	vi.Pa = 0.0f;
	vi.Pb = 0.0f;
	vi.Paa = 0.0f;
	vi.Pab = 0.0f;
	vi.Pbb = 0.0f;
	vi.Paaa = 0.0f;
	vi.Paab = 0.0f;
	vi.Pabb = 0.0f;
	vi.Pbbb = 0.0f;

	int v1 = face.iNumVerts-1;
	for (int v2 = 0; v2 < face.iNumVerts; v1 = v2, v2++) 
	{
		float a0 = m_v3Verts[face.pVerts[v1]][vi.A];
		float b0 = m_v3Verts[face.pVerts[v1]][vi.B];
		float a1 = m_v3Verts[face.pVerts[v2]][vi.A];
		float b1 = m_v3Verts[face.pVerts[v2]][vi.B];
		float da = a1 - a0;
		float db = b1 - b0;
		float a0_2 = a0 * a0; 
		float a0_3 = a0_2 * a0; 
		float a0_4 = a0_3 * a0;
		float b0_2 = b0 * b0; 
		float b0_3 = b0_2 * b0; 
		float b0_4 = b0_3 * b0;
		float a1_2 = a1 * a1; 
		float a1_3 = a1_2 * a1; 
		float b1_2 = b1 * b1; 
		float b1_3 = b1_2 * b1;

		float C1 = a1 + a0;
		float Ca = a1*C1 + a0_2; 
		float Caa = a1*Ca + a0_3; 
		float Caaa = a1*Caa + a0_4;
		float Cb = b1*(b1 + b0) + b0_2; 
		float Cbb = b1*Cb + b0_3; 
		float Cbbb = b1*Cbb + b0_4;
		float Cab = 3*a1_2 + 2*a1*a0 + a0_2; 
		float Kab = a1_2 + 2*a1*a0 + 3*a0_2;
		float Caab = a0*Cab + 4*a1_3; 
		float Kaab = a1*Kab + 4*a0_3;
		float Cabb = 4*b1_3 + 3*b1_2*b0 + 2*b1*b0_2 + b0_3;
		float Kabb = b1_3 + 2*b1_2*b0 + 3*b1*b0_2 + 4*b0_3;

		vi.P1 += db*C1;
		vi.Pa += db*Ca;
		vi.Paa += db*Caa;
		vi.Paaa += db*Caaa;
		vi.Pb += da*Cb;
		vi.Pbb += da*Cbb;
		vi.Pbbb += da*Cbbb;
		vi.Pab += db*(b1*Cab + b0*Kab);
		vi.Paab += db*(b1*Caab + b0*Kaab);
		vi.Pabb += da*(a1*Cabb + a0*Kabb);
	}

	vi.P1 *= (1.0f / 2.0f);
	vi.Pa *= (1.0f / 6.0f);
	vi.Paa *= (1.0f / 12.0f);
	vi.Paaa *= (1.0f / 20.0f);
	vi.Pb *= (1.0f / -6.0f);
	vi.Pbb *= (1.0f / -12.0f);
	vi.Pbbb *= (1.0f / -20.0f);
	vi.Pab *= (1.0f / 24.0f);
	vi.Paab *= (1.0f / 60.0f);
	vi.Pabb *= (1.0f / -60.0f);
}


void Polyhedron::ComputeFaceIntegrals(const Face& face, VolumeIntegrals& vi)
{
	ComputeProjectionIntegrals(face, vi);

	const float* n = face.plPlane;
	float w = face.plPlane.d;

	float k1 = 1.0f / n[vi.C]; 
	float k2 = k1 * k1; 
	float k3 = k2 * k1; 
	float k4 = k3 * k1;

	vi.Fa = k1 * vi.Pa;
	vi.Fb = k1 * vi.Pb;
	vi.Fc = -k2 * (n[vi.A]*vi.Pa + n[vi.B]*vi.Pb + w*vi.P1);

	vi.Faa = k1 * vi.Paa;
	vi.Fbb = k1 * vi.Pbb;
	vi.Fcc = k3 * (SQR(n[vi.A])*vi.Paa + 2*n[vi.A]*n[vi.B]*vi.Pab + SQR(n[vi.B])*vi.Pbb
		   + w*(2*(n[vi.A]*vi.Pa + n[vi.B]*vi.Pb) + w*vi.P1));

	vi.Faaa = k1 * vi.Paaa;
	vi.Fbbb = k1 * vi.Pbbb;
	vi.Fccc = -k4 * (CUBE(n[vi.A])*vi.Paaa + 3*SQR(n[vi.A])*n[vi.B]*vi.Paab 
			+ 3*n[vi.A]*SQR(n[vi.B])*vi.Pabb + CUBE(n[vi.B])*vi.Pbbb
			+ 3*w*(SQR(n[vi.A])*vi.Paa + 2*n[vi.A]*n[vi.B]*vi.Pab + SQR(n[vi.B])*vi.Pbb)
			+ w*w*(3*(n[vi.A]*vi.Pa + n[vi.B]*vi.Pb) + w*vi.P1));

	vi.Faab = k1 * vi.Paab;
	vi.Fbbc = -k2 * (n[vi.A]*vi.Pabb + n[vi.B]*vi.Pbbb + w*vi.Pbb);
	vi.Fcca = k3 * (SQR(n[vi.A])*vi.Paaa + 2*n[vi.A]*n[vi.B]*vi.Paab + SQR(n[vi.B])*vi.Pabb
			+ w*(2*(n[vi.A]*vi.Paa + n[vi.B]*vi.Pab) + w*vi.Pa));
}


void Polyhedron::ComputeVolumeIntegrals(VolumeIntegrals& vi)
{
	vi.T0[X] = 0.0f;
	vi.T0[Y] = 0.0f;
	vi.T0[Z] = 0.0f;
	vi.T1[X] = 0.0f;
	vi.T1[Y] = 0.0f;
	vi.T1[Z] = 0.0f;
	vi.T2[X] = 0.0f;
	vi.T2[Y] = 0.0f;
	vi.T2[Z] = 0.0f;
	vi.TP[X] = 0.0f;
	vi.TP[Y] = 0.0f;
	vi.TP[Z] = 0.0f;

	for (int i = 0; i < m_iNumFaces; i++) 
	{
		float nx = fabsf(m_Faces[i].plPlane[X]);
		float ny = fabsf(m_Faces[i].plPlane[Y]);
		float nz = fabsf(m_Faces[i].plPlane[Z]);

		if (nx > ny && nx > nz)
			vi.C = X;
		else
			vi.C = (ny > nz) ? Y : Z;

		vi.A = (vi.C + 1) % 3;
		vi.B = (vi.A + 1) % 3;

		ComputeFaceIntegrals(m_Faces[i], vi);

		vi.T0[vi.A] += m_Faces[i].plPlane[vi.A] * vi.Fa;
		vi.T0[vi.B] += m_Faces[i].plPlane[vi.B] * vi.Fb;
		vi.T0[vi.C] += m_Faces[i].plPlane[vi.C] * vi.Fc;

		vi.T1[vi.A] += m_Faces[i].plPlane[vi.A] * vi.Faa;
		vi.T1[vi.B] += m_Faces[i].plPlane[vi.B] * vi.Fbb;
		vi.T1[vi.C] += m_Faces[i].plPlane[vi.C] * vi.Fcc;
		vi.T2[vi.A] += m_Faces[i].plPlane[vi.A] * vi.Faaa;
		vi.T2[vi.B] += m_Faces[i].plPlane[vi.B] * vi.Fbbb;
		vi.T2[vi.C] += m_Faces[i].plPlane[vi.C] * vi.Fccc;
		vi.TP[vi.A] += m_Faces[i].plPlane[vi.A] * vi.Faab;
		vi.TP[vi.B] += m_Faces[i].plPlane[vi.B] * vi.Fbbc;
		vi.TP[vi.C] += m_Faces[i].plPlane[vi.C] * vi.Fcca;
	}

	vi.T1[X] *= (1.0f / 2.0f); 
	vi.T1[Y] *= (1.0f / 2.0f); 
	vi.T1[Z] *= (1.0f / 2.0f);
	vi.T2[X] *= (1.0f / 3.0f); 
	vi.T2[Y] *= (1.0f / 3.0f); 
	vi.T2[Z] *= (1.0f / 3.0f);
	vi.TP[X] *= (1.0f / 2.0f); 
	vi.TP[Y] *= (1.0f / 2.0f); 
	vi.TP[Z] *= (1.0f / 2.0f);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\PhysicsSystem.h ===
//-----------------------------------------------------------------------------
// FILE: PhysicsSystem.h
//
// Desc: Physics system
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef TECH_CERT_GAME_PHYSICS_SYSTEM_H
#define TECH_CERT_GAME_PHYSICS_SYSTEM_H

#pragma warning( disable: 4702 )
#include "Common.h"
#include "PhysicsObject.h"
#include "PhysicsShape.h"

#pragma warning( push, 3 )  // Suppress VC warnings when compiling at W4
#include <vector>
#include <list>
#pragma warning( pop )



const int iMaxConstraints = 16;
class HeightField;

//
// Record of two object whose bounding boxes overlap.
//
class OverlapRecord
{
public:
	OverlapRecord()
	{
		pA = 0;
		pB = 0;
	}

	OverlapRecord(PhysicsObject* a, PhysicsObject* b)
	{
		pA = a;
		pB = b;
	}

	bool operator== (const OverlapRecord& lhs) const
	{
		return (pA == lhs.pA && pB == lhs.pB) || (pA == lhs.pA && pB == lhs.pB);
	}

	PhysicsObject* pA;
	PhysicsObject* pB;
	OverlapRecord* pNextA;		// Next pointer for object A's list.
	OverlapRecord* pNextB;		// Next pointer for object B's list.

	OverlapRecord* pPrev;		// Previous pointer for global list.
	OverlapRecord* pNext;		// Next pointer for global list.
};


//
// Record of two intersecting objects.
//
class CollisionRecord
{
public:
	CollisionRecord(PhysicsObject* a, PhysicsObject* b)
	{
		pA = a;
		pB = b;
	}

	PhysicsObject* pA;
	PhysicsObject* pB;
	IntersectionInfo info;
};

typedef std::vector<CollisionRecord> CollisionList;


//
// A constraint between two objects.
//
class Constraint
{
public:
	Constraint(PhysicsObject* a, PhysicsObject* b)
	{
		pA = a;
		pB = b;
	}

	enum ConstraintType 
	{
		Bilateral, UnilateralVertFace, UnilateralEdgeEdge, StaticFriction 
	};

	ConstraintType Type;

	PhysicsObject* pA;
	PhysicsObject* pB;

	Vector3 v3Point;
	Vector3 v3Normal;
	Vector3 v3EdgeA, v3EdgeB;

	float fDist;			// D value of plane point is on for bilateral constraints.

	float fFrictionForce;	// Maximum value for static friction constraints.
	float fConstraintAccel;	// Extra acceleration at constraint.
};

typedef std::vector<Constraint*> ConstraintList;


//
// The physics system.
//
class PhysicsSystem
{
public:
	// Constructor/Destructor.
	PhysicsSystem();
	~PhysicsSystem();

    // Shutdown the physics system.
    void Shutdown();

    // Simulate over the specified time period. Returns the rumble level
	FLOAT Simulate(float start_time, float end_time);

	// Find intersections, apply collision impulses, and add forces.
	bool ProcessCollisionsAndForces(float cur_time, FLOAT& fRumble );

	// Add an object to the simulation.
	void AddObject(PhysicsObject* pObj);

	// Remove an object from the simulation.
	void RemoveObject(PhysicsObject* pObj);

	// Add a heightfield object.
	void AddHeightField(HeightField* pHF);

	// Add a pin joint constriant between two objects.
	void AddPinJointConstraint(PhysicsObject* pA, PhysicsObject* pB, const Vector3& v3Point);

	// Add a constraint between two objects.
	// Note: The constraint data needs to be filled in.
	Constraint* AddConstraint(PhysicsObject* pA, PhysicsObject* pB);

	// Check a line segment from p1 to p2 for intersection again all objects in the physics system.
	bool CheckLineSegment(const Vector3& p1, const Vector3& p2, float* p_t, Vector3* p_q);

	// Save/Load physics state.
    static DWORD GetMaxStateSize();
	int GetStateSize();
	void GetState( FLOAT* pState );
	void SetState( const FLOAT* pState );

	// Draw debugging info.
	void DrawDebug();

	// Physics object representing the world
	PhysicsObject* GetWorldObject();

private:
	typedef std::list<PhysicsObject*> PhysObjList;
	typedef std::vector<PhysicsObject::Extent*> ExtentList;

	// Add an overlap record.
	void AddOverlap(PhysicsObject* pA, PhysicsObject* pB);

	// Remove an overlap record.
	void RemoveOverlap(PhysicsObject* pA, PhysicsObject* pB);

	// Add an extent the an extent list maintaining sorted order.
	void InsertExtent(ExtentList& extents, PhysicsObject::Extent* extent);

	// Remove an extent the an extent list maintaining sorted order.
	void RemoveExtent(ExtentList& extents, PhysicsObject::Extent* extent);

	// Sort the extent list and update the overlaps.
	void SortExtentsAndUpdate(ExtentList& extents);

	// Compute the A matrix for a set of constraints.
	void ComputeAMatrix(const ConstraintList& Constraints, float matA[][iMaxConstraints]);

	// Compute the b vector for a set of constraints.
	void ComputeBVector(const ConstraintList& Constraints, float* vecB);

	// Solve a linear system of equations A * x = b
	bool SolveLinearSystem(float A[][iMaxConstraints], int n, float* b, float* x);

	// Matrix vector multiplication (x = A * b)
	void MatVecMul(float A[][iMaxConstraints], int n, float* b, float* x);

	// Sets used by the constraint solver.
	enum SolverSets
	{
		SetNone, SetC, SetNC, SetCf, SetNCfplus, SetNCfminus
	};

	// Solve for forces that will cause constraints to be met.
	void ConstraintSolver(const ConstraintList& Constraints, float A[][iMaxConstraints], float* b, float* f);

    PhysicsObject m_WorldObject;

	// List of physics objects.
	PhysObjList Objects;
	
	HeightField* pHeightField;

	// Sorted extent lists for physics objects.
	ExtentList ExtentsX, ExtentsY, ExtentsZ;

	// List of overlap records.
	OverlapRecord OverlapsHead;
	OverlapRecord OverlapsTail;

	// List of static constraints.
	ConstraintList StaticConstraints;

	// List of active constraints.
	ConstraintList ActiveConstraints;

	// List of currently intersecting objects.
	CollisionList Collisions;

	// Maximum number of constraints in a group.
	static const float fMaxTimeStep;
	static const float fMinTimeStep;
};


#endif // TECH_CERT_GAME_PHYSICS_SYSTEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Shader.cpp ===
//-----------------------------------------------------------------------------
// File: Shader.cpp
//
// Desc: Shader classes for advanced lighting
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Shader.h"
#include "Globals.h"
#include "Light.h"
#include "File.h"




//-----------------------------------------------------------------------------
// Statics
//-----------------------------------------------------------------------------
LightList Shader::m_LightList;




//-----------------------------------------------------------------------------
// Name: CreateShaderOfType()
// Desc: Make a shader of the specified type
//-----------------------------------------------------------------------------
Shader* Shader::CreateShaderOfType( DWORD dwShaderType )
{
    switch( dwShaderType )
    {
//      case TypeShaderFlat:         return new ShaderFlat();
        case TypeShaderLit:          return new ShaderLit();
//      case TypeShaderTexturedLit:  return new ShaderTexturedLit();
//      case TypeShaderTexturedBump: return new ShaderTexturedBump();

        default: assert( FALSE ); break;
    }
    return NULL;
}




#if (0)
//-----------------------------------------------------------------------------
// Name: ShaderFlat()
// Desc: Construct empty shader
//-----------------------------------------------------------------------------
ShaderFlat::ShaderFlat()
:
    m_Material()
{
    ZeroMemory( &m_Material, sizeof(D3DMATERIAL8) );
}




//-----------------------------------------------------------------------------
// Name: ShaderFlat()
// Desc: Initialize with the given color
//-----------------------------------------------------------------------------
ShaderFlat::ShaderFlat( FLOAT fRed, FLOAT fGreen, FLOAT fBlue )
:
    m_Material()
{
    ZeroMemory( &m_Material, sizeof(D3DMATERIAL8) );
    m_Material.Diffuse.r = m_Material.Ambient.r = fRed;
    m_Material.Diffuse.g = m_Material.Ambient.g = fGreen;
    m_Material.Diffuse.b = m_Material.Ambient.b = fBlue;
    m_Material.Diffuse.a = m_Material.Ambient.a = 1.0f;
}




//-----------------------------------------------------------------------------
// Name: Save()
// Desc: Write shader info to file
//-----------------------------------------------------------------------------
HRESULT ShaderFlat::Save( const File& file )
{
    if( !file.Write( &m_Material.Diffuse.r, sizeof(m_Material.Diffuse.r) ) ||
        !file.Write( &m_Material.Diffuse.g, sizeof(m_Material.Diffuse.g) ) ||
        !file.Write( &m_Material.Diffuse.b, sizeof(m_Material.Diffuse.b) ) ||
        !file.Write( &m_Material.Diffuse.a, sizeof(m_Material.Diffuse.a) ) )
    {
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Load shader from file
//-----------------------------------------------------------------------------
HRESULT ShaderFlat::Load( const File& file )
{
    DWORD r;
    if( !file.Read( &m_Material.Diffuse.r, sizeof(m_Material.Diffuse.r), r ) ||
        !file.Read( &m_Material.Diffuse.g, sizeof(m_Material.Diffuse.g), r ) ||
        !file.Read( &m_Material.Diffuse.b, sizeof(m_Material.Diffuse.b), r ) ||
        !file.Read( &m_Material.Diffuse.a, sizeof(m_Material.Diffuse.a), r ) )
    {
        return E_FAIL;
    }

    m_Material.Ambient.r = m_Material.Diffuse.r;
    m_Material.Ambient.g = m_Material.Diffuse.g;
    m_Material.Ambient.b = m_Material.Diffuse.b;
    m_Material.Ambient.a = m_Material.Diffuse.a;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Output()
// Desc: Output shader
//-----------------------------------------------------------------------------
VOID ShaderFlat::Output( INT )
{
    g_pd3dDevice->SetMaterial( &m_Material );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_NORMAL );

    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING,       TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZFUNC,          D3DCMP_LESSEQUAL );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE,       D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_SHADEMODE,      D3DSHADE_GOURAUD );

    for( INT i = 0; i < 4; ++i )
        g_pd3dDevice->SetTexture( i, 0 );
}
#endif




//-----------------------------------------------------------------------------
// Name: ShaderLit()
// Desc: Construct empty shader
//-----------------------------------------------------------------------------
ShaderLit::ShaderLit()
:
    m_Material()
{
    ZeroMemory( &m_Material, sizeof(D3DMATERIAL8) );
}




//-----------------------------------------------------------------------------
// Name: ShaderLit()
// Desc: Initialize from given material
//-----------------------------------------------------------------------------
ShaderLit::ShaderLit( const D3DMATERIAL8& d3dMat )
:
    m_Material( d3dMat )
{
}




//-----------------------------------------------------------------------------
// Name: Save()
// Desc: Save shader info to file
//-----------------------------------------------------------------------------
HRESULT ShaderLit::Save( const File& file )
{
    if( !file.Write( &m_Material, sizeof( m_Material) ) )
        return E_FAIL;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Load shader info from file
//-----------------------------------------------------------------------------
HRESULT ShaderLit::Load( const File& file )
{
    DWORD r;
    if( !file.Read( &m_Material, sizeof(m_Material), r ) )
        return E_FAIL;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Output()
// Desc: Output shader
//-----------------------------------------------------------------------------
VOID ShaderLit::Output( INT )
{
    g_pd3dDevice->SetMaterial( &m_Material );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_NORMAL );

    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING,       TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZFUNC,          D3DCMP_LESSEQUAL );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE,       D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_SHADEMODE,      D3DSHADE_GOURAUD );

    for( INT i = 0; i < 4; ++i )
        g_pd3dDevice->SetTexture( i, 0 );
}




#if (0)
//-----------------------------------------------------------------------------
// Name: ShaderTexturedLit()
// Desc: Construct empty shader
//-----------------------------------------------------------------------------
ShaderTexturedLit::ShaderTexturedLit()
:
    m_pTexture( NULL ),
    m_Material()
{
    ZeroMemory( &m_Material, sizeof(D3DMATERIAL8) );
}




//-----------------------------------------------------------------------------
// Name: ShaderTexturedLit()
// Desc: Construct from given texture and material
//-----------------------------------------------------------------------------
ShaderTexturedLit::ShaderTexturedLit( Texture* pTexture, 
                                      const D3DMATERIAL8& d3dMat )
:
    m_pTexture( pTexture ),
    m_Material( d3dMat )
{
}




//-----------------------------------------------------------------------------
// Name: ~ShaderTexturedLit()
// Desc: Destroy shader
//-----------------------------------------------------------------------------
ShaderTexturedLit::~ShaderTexturedLit()
{
    Texture::ReleaseTexture( m_pTexture );
}




//-----------------------------------------------------------------------------
// Name: Save()
// Desc: Save shader info to file
//-----------------------------------------------------------------------------
HRESULT ShaderTexturedLit::Save( const File& file )
{
    if( !file.Write( &m_Material, sizeof(m_Material) ) )
        return E_FAIL;

    if( !Texture::SaveTextureID( file, m_pTexture ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Load shader info from file
//-----------------------------------------------------------------------------
HRESULT ShaderTexturedLit::Load( const File& file )
{
    DWORD r;
    if( !file.Read( &m_Material, sizeof( m_Material ), r ) )
        return E_FAIL;

    m_pTexture = Texture::CreateTextureFromID( file );
    if( m_pTexture == NULL )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Output()
// Desc: Output shader
//-----------------------------------------------------------------------------
VOID ShaderTexturedLit::Output( INT )
{
    g_pd3dDevice->SetMaterial( &m_Material );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 );

    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING,       TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZFUNC,          D3DCMP_LESSEQUAL );
    g_pd3dDevice->SetRenderState( D3DRS_CULLMODE,       D3DCULL_CCW );
    g_pd3dDevice->SetRenderState( D3DRS_SHADEMODE,      D3DSHADE_GOURAUD );

    g_pd3dDevice->SetTexture( 0, ( m_pTexture != NULL ) ? 
                                    m_pTexture->GetD3DTexture() : 0 );

    for( INT i = 1; i < 4; ++i )
        g_pd3dDevice->SetTexture( i, 0 );
}




//-----------------------------------------------------------------------------
// Name: ShaderTexturedBump()
// Desc: Construct empty shader
//-----------------------------------------------------------------------------
ShaderTexturedBump::ShaderTexturedBump()
:
    m_pImageTexture             ( NULL ),
    m_pBumpTexture              ( NULL ),
    m_dwBumpVertexShaderHandle  ( 0 ),
    m_dwImageVertexShaderHandle ( 0 ),
    m_dwBumpPixelShaderHandle   ( 0 ),
    m_dwImagePixelShaderHandle  ( 0 ),
    m_pNormalizationCubemap     ( NULL )
{
    InitShaders(); 
}




//-----------------------------------------------------------------------------
// Name: ShaderTexturedBump()
// Desc: Construct shader given texture and bump
//-----------------------------------------------------------------------------
ShaderTexturedBump::ShaderTexturedBump( Texture* pImageTexture, 
                                        Texture* pBumpTexture )
:
    m_pImageTexture             ( pImageTexture ),
    m_pBumpTexture              ( pBumpTexture ),
    m_dwBumpVertexShaderHandle  ( 0 ),
    m_dwImageVertexShaderHandle ( 0 ),
    m_dwBumpPixelShaderHandle   ( 0 ),
    m_dwImagePixelShaderHandle  ( 0 ),
    m_pNormalizationCubemap     ( NULL )
{
    InitShaders();
}




//-----------------------------------------------------------------------------
// Name: ~ShaderTexturedBump()
// Desc: Destroy shader
//-----------------------------------------------------------------------------
ShaderTexturedBump::~ShaderTexturedBump()
{
    Texture::ReleaseTexture( m_pImageTexture );
    Texture::ReleaseTexture( m_pBumpTexture );

    if( m_dwBumpVertexShaderHandle )
        g_pd3dDevice->DeleteVertexShader( m_dwBumpVertexShaderHandle );

    if( m_dwImageVertexShaderHandle )
        g_pd3dDevice->DeleteVertexShader( m_dwImageVertexShaderHandle );

    if( m_dwBumpPixelShaderHandle )
        g_pd3dDevice->DeletePixelShader( m_dwBumpPixelShaderHandle );

    if( m_dwImagePixelShaderHandle )
        g_pd3dDevice->DeletePixelShader( m_dwImagePixelShaderHandle );

    SAFE_RELEASE( m_pNormalizationCubemap );
}




//-----------------------------------------------------------------------------
// Name: Save()
// Desc: Save shader info to file
//-----------------------------------------------------------------------------
HRESULT ShaderTexturedBump::Save( const File& file )
{
    if( !Texture::SaveTextureID( file, m_pImageTexture ) ||
        !Texture::SaveTextureID( file, m_pBumpTexture ) )
    {
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Load shader into from file
//-----------------------------------------------------------------------------
HRESULT ShaderTexturedBump::Load( const File& file )
{
    m_pImageTexture = Texture::CreateTextureFromID( file );
    m_pBumpTexture = Texture::CreateTextureFromID( file );
    
    if( m_pImageTexture == NULL || m_pBumpTexture == NULL )
        return E_FAIL;

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: GetNumPasses()
// Desc: Number of passes required by shader
//-----------------------------------------------------------------------------
INT ShaderTexturedBump::GetNumPasses()
{
#if defined(_XBOX)
	return m_LightList.size()+1;
#else
	return 1;
#endif
}




//-----------------------------------------------------------------------------
// Name: Output()
// Desc: Output shader
//-----------------------------------------------------------------------------
VOID ShaderTexturedBump::Output( INT iPass )
{
#if defined(_XBOX)

	if (iPass < (int)m_LightList.size())
	{
		// Light #iPass
		if (iPass == 0)
		{
			// First pass.
			g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
			g_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
			g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
			g_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_GOURAUD );

			g_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESSEQUAL );
			g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
			g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

			g_pd3dDevice->SetTexture( 0, m_pBumpTexture->GetD3DTexture() );
			g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
			g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
			g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
			g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );

			g_pd3dDevice->SetTexture( 1, m_pNormalizationCubemap );
			g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
			g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
			g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP );
			g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
			g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_NONE );

			g_pd3dDevice->SetTexture( 2, m_pNormalizationCubemap );
			g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
			g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
			g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP );
			g_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
			g_pd3dDevice->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_NONE );

			// Set vertex shader.
			g_pd3dDevice->SetVertexShader( m_dwBumpVertexShaderHandle );

			// Set pixel shader.
			g_pd3dDevice->SetPixelShader( m_dwBumpPixelShaderHandle );

			// Get current transforms.
			D3DXMATRIX matWorld, matView, matProj;
			g_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorld );		// local->world
			g_pd3dDevice->GetTransform( D3DTS_VIEW, &matView );			// world->view
			g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );	// view->screen

			// Set composite matrix.
			D3DXMATRIX matComposite;
			D3DXMatrixMultiply( &matComposite, &matWorld, &matView );
			D3DXMatrixMultiply( &matComposite, &matComposite, &matProj );
			D3DXMatrixTranspose( &matComposite, &matComposite );

			g_pd3dDevice->SetVertexShaderConstant( 0, &matComposite, 4 );

			// Set viewer position in object space.
			D3DXMATRIX matViewInverse, matWorldInverse;
			D3DXMatrixInverse( &matViewInverse, 0, &matView );
			D3DXMatrixInverse( &matWorldInverse, 0, &matWorld );

			D3DXVECTOR4 v4LocalViewerPos(0.0f,0.0f,0.0f,1.0f);
			D3DXVec4Transform( &v4LocalViewerPos, &v4LocalViewerPos, &matViewInverse );
			D3DXVec4Transform( &v4LocalViewerPos, &v4LocalViewerPos, &matWorldInverse );

			g_pd3dDevice->SetVertexShaderConstant( 8, &v4LocalViewerPos, 1 );
		}
		else if (iPass == 1)
		{
			// Subsequent passes.
			g_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_EQUAL );
			g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );

			g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
			g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_ONE );
			g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
		}

		// All passes.

		// Set light volume.
		g_pd3dDevice->SetTexture( 3, m_LightList[iPass]->GetLightFalloffVolume() );
		g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSU, D3DTADDRESS_BORDER );
		g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSV, D3DTADDRESS_BORDER );
		g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSW, D3DTADDRESS_BORDER );
		g_pd3dDevice->SetTextureStageState( 3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
		g_pd3dDevice->SetTextureStageState( 3, D3DTSS_MIPFILTER, D3DTEXF_NONE );
		g_pd3dDevice->SetTextureStageState( 3, D3DTSS_BORDERCOLOR, 0 );

		// Get world transform.
		D3DXMATRIX matWorld, matWorldInverse;
		g_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorld );
		D3DXMatrixInverse( &matWorldInverse, 0, &matWorld );

		// Set object space to light space transform.
		D3DXMATRIX matLocalToLight = m_LightList[iPass]->GetWorldToLightTransform();
		D3DXMatrixMultiply( &matLocalToLight, &matWorld, &matLocalToLight );
		D3DXMatrixTranspose( &matLocalToLight, &matLocalToLight );
		g_pd3dDevice->SetVertexShaderConstant( 4, &matLocalToLight, 3 );

		// Light position in object space.
		D3DXVECTOR4 v4LocalLightPos = m_LightList[iPass]->GetPosition();
		D3DXVec4Transform( &v4LocalLightPos, &v4LocalLightPos, &matWorldInverse );
		g_pd3dDevice->SetVertexShaderConstant( 7, &v4LocalLightPos, 1 );

		float fDiffuse[4] = { 0.9f, 0.9f, 0.9f, 0.9f };
		float fSpecular[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
		float fAmbient[4] = { 0.2f, 0.2f, 0.2f, 0.2f };
		g_pd3dDevice->SetPixelShaderConstant( 0, fDiffuse, 1 );
		g_pd3dDevice->SetPixelShaderConstant( 1, fSpecular, 1 );
		g_pd3dDevice->SetPixelShaderConstant( 2, fAmbient, 1 );
	}
	else
	{
		// Final pass, modulate color with lighting.
		g_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_EQUAL );
		g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );

		g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
		g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_DESTCOLOR );
		g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ZERO );
//		g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_SRCCOLOR );

		g_pd3dDevice->SetVertexShader( m_dwImageVertexShaderHandle );
		g_pd3dDevice->SetPixelShader( m_dwImagePixelShaderHandle );

		// Modulate image texture with lighting.
		g_pd3dDevice->SetTexture( 0, m_pImageTexture->GetD3DTexture() );
		g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
		g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
		g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
		g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );

		g_pd3dDevice->SetTexture( 1, 0 );

		g_pd3dDevice->SetTexture( 2, 0 );

		g_pd3dDevice->SetTexture( 3, 0 );
	}

#else

	g_pd3dDevice->SetVertexShader( m_dwImageVertexShaderHandle );

	g_pd3dDevice->SetRenderState( D3DRS_LIGHTING,	   FALSE );
	g_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
	g_pd3dDevice->SetRenderState( D3DRS_ZFUNC,	  D3DCMP_LESSEQUAL );
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE,  D3DCULL_CCW );
	g_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_GOURAUD );

	if (m_pImageTexture)
		g_pd3dDevice->SetTexture( 0, m_pImageTexture->GetD3DTexture() );
	else
		g_pd3dDevice->SetTexture( 0, 0 );

#endif
}




//-----------------------------------------------------------------------------
// Name: InitShaders()
// Desc: Initialize shaders
//-----------------------------------------------------------------------------
VOID ShaderTexturedBump::InitShaders()
{
#if defined(_XBOX)

	HRESULT hr;

	// Create vertex shaders for lighting.
    DWORD dwBumpVertexShaderDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = position
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = normal
        D3DVSD_REG( 2, D3DVSDT_FLOAT2 ), // v2 = texture co-oridnate
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // v3 = basis vector S
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ), // v4 = basis vector T
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ), // v5 = basis vector SxT
        D3DVSD_END()
    };

	hr = XBUtil_CreateVertexShader( g_pd3dDevice, "Shaders\\BumpMap.xvu",
									dwBumpVertexShaderDecl, &m_dwBumpVertexShaderHandle );
	assert(hr == D3D_OK);

    DWORD dwImageVertexShaderDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = position
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = normal
        D3DVSD_REG( 2, D3DVSDT_FLOAT2 ), // v2 = texture co-oridnate
        D3DVSD_END()
    };

	hr = XBUtil_CreateVertexShader( g_pd3dDevice, "Shaders\\ImageMap.xvu",
									dwImageVertexShaderDecl, &m_dwImageVertexShaderHandle );
	assert(hr == D3D_OK);

	// Create pixel shader for bumpmap lighting.
	D3DPIXELSHADERDEF psd;
	memset( &psd, 0, sizeof(psd) );
	psd.PSCombinerCount=PS_COMBINERCOUNT(
		8,
		PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
	psd.PSTextureModes=PS_TEXTUREMODES(
		PS_TEXTUREMODES_PROJECT2D,
		PS_TEXTUREMODES_CUBEMAP,
		PS_TEXTUREMODES_CUBEMAP,
		PS_TEXTUREMODES_PROJECT3D);

	//------------- Stage 0 -------------
	psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
		PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL,
		PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL,
		PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL,
		PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL);
	psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
		PS_REGISTER_T1 | PS_CHANNEL_BLUE | PS_INPUTMAPPING_EXPAND_NORMAL,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
		PS_REGISTER_T1 | PS_CHANNEL_BLUE | PS_INPUTMAPPING_EXPAND_NORMAL,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
	psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
		PS_REGISTER_R0,
		PS_REGISTER_R1,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_DOT_PRODUCT | PS_COMBINEROUTPUT_CD_DOT_PRODUCT | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_REGISTER_R0,
		PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSConstant0[0]=0x007f7fff;
	psd.PSConstant1[0]=0x00000000;

	// R0 = L dot N
	// R1 = H dot N
	// R0.a = S(self)

	//------------- Stage 1 -------------
	psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
		PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
		PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT);
	psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
		PS_REGISTER_T2 | PS_CHANNEL_BLUE | PS_INPUTMAPPING_EXPAND_NORMAL,
		PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_T2 | PS_CHANNEL_BLUE | PS_INPUTMAPPING_EXPAND_NORMAL,
		PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_REGISTER_R1,
		PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
		PS_REGISTER_R1,
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSConstant0[1]=0xc0c0c0c0;
	psd.PSConstant1[1]=0x00000000;

	// R1 = 4*(max(0,(H dot N))-0.75)
	// R1.a = S(self) for specular

	//------------- Stage 2 -------------
	psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
		PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
		PS_REGISTER_R1,
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSConstant0[2]=0x00000000;
	psd.PSConstant1[2]=0x00000000;

	// R1 = max(0,4*(max(0,(H dot N))-0.75))^2

	for (int i = 3; i <= 4; i++)
	{
		//------------- Stage 3,4 -------------
		psd.PSRGBInputs[i]=PS_COMBINERINPUTS(
			PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
			PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
			PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
			PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
		psd.PSAlphaInputs[i]=PS_COMBINERINPUTS(
			PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
			PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
			PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
			PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
		psd.PSRGBOutputs[i]=PS_COMBINEROUTPUTS(
			//PS_REGISTER_DISCARD,
			PS_REGISTER_R1,
			PS_REGISTER_DISCARD,
			PS_REGISTER_DISCARD,
			PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
		psd.PSAlphaOutputs[i]=PS_COMBINEROUTPUTS(
			PS_REGISTER_DISCARD,
			PS_REGISTER_DISCARD,
			PS_REGISTER_DISCARD,
			PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
		psd.PSConstant0[i]=0x00000000;
		psd.PSConstant1[i]=0x00000000;
	}

	//------------- Stage 5 -------------
	psd.PSRGBInputs[5]=PS_COMBINERINPUTS(
		PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSAlphaInputs[5]=PS_COMBINERINPUTS(
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSRGBOutputs[5]=PS_COMBINEROUTPUTS(
		PS_REGISTER_R0,
		PS_REGISTER_R1,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSAlphaOutputs[5]=PS_COMBINEROUTPUTS(
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSConstant0[5]=0x00000000;
	psd.PSConstant1[5]=0x00000000;

	// R0 = S(self)*max(0,(L dot N))
	// R1 = S(self)*max(0,(H dot N))^shininess

	//------------- Stage 6 -------------
	psd.PSRGBInputs[6]=PS_COMBINERINPUTS(
		PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_C1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSAlphaInputs[6]=PS_COMBINERINPUTS(
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSRGBOutputs[6]=PS_COMBINEROUTPUTS(
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_REGISTER_R0,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSAlphaOutputs[6]=PS_COMBINEROUTPUTS(
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSConstant0[6]=0xdfdfdfdf;
	psd.PSConstant1[6]=0xdfdfdfdf;

	// R0 = kDiffuse*S(self)*max(0,(L dot N)) + kSpecular*S(self)*max(0,(H dot N))^shininess

	//------------- Stage 7 -------------
	psd.PSRGBInputs[7]=PS_COMBINERINPUTS(
		PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT);
	psd.PSAlphaInputs[7]=PS_COMBINERINPUTS(
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSRGBOutputs[7]=PS_COMBINEROUTPUTS(
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_REGISTER_R0,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSAlphaOutputs[7]=PS_COMBINEROUTPUTS(
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSConstant0[7]=0x20202020;
	psd.PSConstant1[7]=0x00000000;

	// R0 = R0*falloff + ambient

	//------------- FinalCombiner -------------
	psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
		PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
		0);

	psd.PSFinalCombinerConstant0 = 0x00000000;
	psd.PSFinalCombinerConstant1 = 0x00000000;

	psd.PSC0Mapping = PS_CONSTANTMAPPING(15,15,15,15,15,15,0,2);
	psd.PSC1Mapping = PS_CONSTANTMAPPING(15,15,15,15,15,15,1,15);
	psd.PSFinalCombinerConstants = PS_FINALCOMBINERCONSTANTS(15,15,PS_GLOBALFLAGS_NO_TEXMODE_ADJUST);

	hr = g_pd3dDevice->CreatePixelShader( &psd, &m_dwBumpPixelShaderHandle );
	assert(hr == D3D_OK);

	// Create pixel shader for image map blend.
	memset( &psd, 0, sizeof(psd) );
	psd.PSCombinerCount=PS_COMBINERCOUNT(
		1,
		PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
	psd.PSTextureModes=PS_TEXTUREMODES(
		PS_TEXTUREMODES_PROJECT2D,
		PS_TEXTUREMODES_NONE,
		PS_TEXTUREMODES_NONE,
		PS_TEXTUREMODES_NONE);

	//------------- Stage 0 -------------
	psd.PSRGBInputs[0]=DWORD(PS_COMBINERINPUTS(
		PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY));
	psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
		PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
		PS_REGISTER_R0,
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
		PS_REGISTER_R0,
		PS_REGISTER_DISCARD,
		PS_REGISTER_DISCARD,
		PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
	psd.PSConstant0[0]=0x00000000;
	psd.PSConstant1[0]=0x00000000;

	//------------- FinalCombiner -------------
	psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
		PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
	psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
		0);

	psd.PSFinalCombinerConstants = PS_FINALCOMBINERCONSTANTS(15,15,PS_GLOBALFLAGS_TEXMODE_ADJUST);

	hr = g_pd3dDevice->CreatePixelShader( &psd, &m_dwImagePixelShaderHandle );
	assert(hr == D3D_OK);

	// Create vector normalization cube map.
	hr = XBUtil_CreateNormalizationCubeMap( g_pd3dDevice, 64, &m_pNormalizationCubemap );
	assert(hr == D3D_OK);
   
#else

	DWORD dwDecl[] =
	{
		D3DVSD_STREAM( 0 ),
		D3DVSD_REG( D3DVSDE_POSITION,  D3DVSDT_FLOAT3 ),
		D3DVSD_REG( D3DVSDE_NORMAL,    D3DVSDT_FLOAT3 ),
		D3DVSD_REG( D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2 ),
		D3DVSD_REG( D3DVSDE_TEXCOORD1, D3DVSDT_FLOAT3 ),
		D3DVSD_REG( D3DVSDE_TEXCOORD2, D3DVSDT_FLOAT3 ),
		D3DVSD_REG( D3DVSDE_TEXCOORD3, D3DVSDT_FLOAT3 ),
		D3DVSD_END()
	};

	m_dwBumpVertexShaderHandle = 0;
	g_pd3dDevice->CreateVertexShader(dwDecl, 0, &m_dwImageVertexShaderHandle, 0);

	m_dwImagePixelShaderHandle = 0;
	m_dwBumpPixelShaderHandle = 0;

#endif
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Polyhedron.h ===
//-----------------------------------------------------------------------------
// FILE: Polyhedron.h
//
// Desc: Collision primitive for all objects.
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef TECH_CERT_GAME_POLYHEDRON_H
#define TECH_CERT_GAME_POLYHEDRON_H

#include "Common.h"
#include "XMath.h"
#include "PhysicsShape.h"


const int AVG_VERTS_PER_FACE = 4;
const int MAX_FACES_PER_POLYHEDRON = 64;
const int MAX_VERTS_PER_POLYHEDRON = 64;


//
// Convex polyhedron.
//
class Polyhedron
{
public:
	Polyhedron();

	// Construct a box centered at zero.
	Polyhedron(float w, float h, float d);

	// Construct a box with an arbitrary center.
	Polyhedron(const Vector3& min, const Vector3& max);

	// Construct a sphere.
	Polyhedron(float radius, int num_major, int num_minor);

	// Construct a volume from a triangle swept along a direction.
	Polyhedron(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& sweep);

	// Copy constructor.
	Polyhedron(const Polyhedron& ph);

	// Assignment operator.
	Polyhedron& operator= (const Polyhedron& ph);

	// Construct a copy transformed by the given coordinate frame.
	Polyhedron(const Polyhedron& ph, const Transformation& tf);

	// Destructor.
	~Polyhedron();

	// Return true if a point is inside a polyhedron.
	bool PointInPolyhedron(const Vector3& pnt, float fEpsilon = 0.0f) const;

	// Compute world space extents of the polyhedron (with a transform).
	void ComputeExtents(const Transformation& tf, Vector3* pMin, Vector3* pMax);

	// Compute world space extents of the polyhedron.
	void ComputeExtents(Vector3* pMin, Vector3* pMax);

	// Return true if the two polyhedrons intersect.
	static bool CheckForIntersection(const Transformation& ta, const Polyhedron& a, 
									 const Transformation& tb, const Polyhedron& b);

	// Find intersections.
	static bool ComputeIntersectionInfo(const Transformation& ta, const Polyhedron& a, 
										const Transformation& tb, const Polyhedron& b,
										int* pNumInfos, IntersectionInfo* pInfo);

	// Compute the center of mass of a polyhedron.
	void ComputeCenterOfMassAndVolume(Vector3* pCoM, float* pVolume);

	// Compute the mass, center of mass, and intertia tensor given the density.
	void ComputeMassProperties(float fDensity, float* pMass, Vector3* pCoM, Matrix3* pIT);

private:
	// A Face of the polyhedron.
	struct Face
	{
		Plane3 plPlane;
		int iNumVerts;
		int* pVerts;
	};

	// Intermediate data used when computing mass properties.
	struct VolumeIntegrals
	{
		int A;   // alpha
		int B;   // beta
		int C;   // gamma

		// projection integrals
		float P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;

		// face integrals
		float Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;

		// volume integrals
		float T0[3], T1[3], T2[3], TP[3];
	};

	// Compute various integrations over a projection of a face.
	void ComputeProjectionIntegrals(const Face& face, VolumeIntegrals& vi);
	void ComputeFaceIntegrals(const Face& face, VolumeIntegrals& vi);
	void ComputeVolumeIntegrals(VolumeIntegrals& vi);

	int m_iNumFaces;
	Face m_Faces[MAX_FACES_PER_POLYHEDRON];

	int m_iNumVerts;
	Vector3 m_v3Verts[MAX_VERTS_PER_POLYHEDRON];

	int m_iNumVertPtrsUsed;
	int m_VertPtrPool[AVG_VERTS_PER_FACE*MAX_VERTS_PER_POLYHEDRON];
};


#endif // TECH_CERT_GAME_POLYHEDRON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Shader.h ===
//-----------------------------------------------------------------------------
// File: Shader.h
//
// Desc: Shader classes for advanced lighting
//
// Hist: 03.14.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_SHADER_H
#define TECH_CERT_GAME_SHADER_H

#include "Common.h"
#include "File.h"
//#include "Texture.h" not currently used
#include "Light.h"




//-----------------------------------------------------------------------------
// Name: class Shader
// Desc: Abstract base shader object
//-----------------------------------------------------------------------------
class Shader
{

protected:

    // Shader types (used when shader object is saved/read from file)
    enum ShaderTypes
    { 
        TypeShaderFlat = 1, 
        TypeShaderLit, 
        TypeShaderTexturedLit, 
        TypeShaderTexturedBump
    };

    static LightList m_LightList;

public:

    Shader()
    {
    }

    virtual ~Shader() = 0
    {
    }

    virtual DWORD Type()
    { 
        return 0;
    }

    virtual HRESULT Save( const File& )
    {
        return S_OK;
    }

    virtual HRESULT Load( const File& )
    { 
        return S_OK;
    }

    virtual INT GetNumPasses()
    { 
        return 1;
    }

    virtual VOID Output( INT iPass )
    { 
        (VOID)iPass;
    }

    // Create a shader based on the passed in type
    static Shader* CreateShaderOfType( DWORD dwShaderType );

};




#if (0)
//-----------------------------------------------------------------------------
// Name: class ShaderFlat
// Desc: Flat shader object
//-----------------------------------------------------------------------------
class ShaderFlat : public Shader
{

    D3DMATERIAL8 m_Material;

public:

    ShaderFlat();
    ShaderFlat( FLOAT fRed, FLOAT fGreen, FLOAT fBlue );

    virtual DWORD Type()
    { 
        return TypeShaderFlat;
    }

    virtual HRESULT Save( const File& );
    virtual HRESULT Load( const File& );
    virtual VOID    Output( INT iPass );

};
#endif




//-----------------------------------------------------------------------------
// Name: class ShaderLit
// Desc: Lit shader object
//-----------------------------------------------------------------------------
class ShaderLit : public Shader
{

    D3DMATERIAL8 m_Material;

public:

    ShaderLit();
    ShaderLit( const D3DMATERIAL8& );

    virtual DWORD Type()
    { 
        return TypeShaderLit;
    }

    virtual HRESULT Save( const File& );
    virtual HRESULT Load( const File& );
    virtual VOID    Output( INT iPass );

};




#if (0)
//-----------------------------------------------------------------------------
// Name: class ShaderTexturedLit
// Desc: Lit and textured shader object
//-----------------------------------------------------------------------------
class ShaderTexturedLit : public Shader
{

    Texture*     m_pTexture;
    D3DMATERIAL8 m_Material;

public:

    ShaderTexturedLit();
    ShaderTexturedLit( Texture*, const D3DMATERIAL8& );
    ~ShaderTexturedLit();

    virtual DWORD Type()
    { 
        return TypeShaderTexturedLit;
    }

    virtual HRESULT Save( const File& );
    virtual HRESULT Load( const File& );
    virtual VOID    Output( INT iPass );

};




//-----------------------------------------------------------------------------
// Name: class ShaderTexturedBump
// Desc: Bumpmapped texture shader object
//-----------------------------------------------------------------------------
class ShaderTexturedBump : public Shader
{
    Texture* m_pImageTexture;
    Texture* m_pBumpTexture;

    DWORD    m_dwBumpVertexShaderHandle;
    DWORD    m_dwImageVertexShaderHandle;
    DWORD    m_dwBumpPixelShaderHandle;
    DWORD    m_dwImagePixelShaderHandle;

    LPDIRECT3DCUBETEXTURE8 m_pNormalizationCubemap;

public:

    ShaderTexturedBump();
    ShaderTexturedBump( Texture* pImageTexture, Texture* pBumpTexture );
    ~ShaderTexturedBump();

    virtual DWORD Type()
    { 
        return TypeShaderTexturedBump;
    }

    virtual HRESULT Save( const File& );
    virtual HRESULT Load( const File& );
    virtual INT     GetNumPasses();
    virtual VOID    Output( INT iPass );

private:

    VOID InitShaders();

};
#endif // 0




#endif // TECH_CERT_GAME_SHADER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\SoundEffect.cpp ===
//-----------------------------------------------------------------------------
// File: SoundEffect.cpp
//
// Desc: Plays a WAV file sound effect
//
// Hist: 06.21.01 - New for July XDK
//       06.28.01 - Converted to using pitch modulation instead of multiple files
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "SoundEffect.h"




//-----------------------------------------------------------------------------
// Definitions
//-----------------------------------------------------------------------------

// The audible volume range is around [-40db, 0db], instead of the [-100db, 0db]
// the Xbox offers.  Interpolating across this yields better results.
const LONG VOLUME_MAX = DSBVOLUME_MAX;
const LONG VOLUME_MIN = -4000;

const CHAR* const strENGINE_SOUND = "D:\\Media\\Sounds\\engine.wav";




//-----------------------------------------------------------------------------
// Name: CSoundEffect()
// Desc: Construct sound effect object
//-----------------------------------------------------------------------------
CSoundEffect::CSoundEffect()
:
    m_bIsPlaying       ( FALSE ),
    m_bIsInitialized   ( FALSE ),
    m_bIsPaused        ( FALSE ),
    m_fVolume          ( 100.0f ),
    m_pdsndDevice      ( NULL ),
    m_pDSBuffer        ( NULL )
{
}




//-----------------------------------------------------------------------------
// Name: ~CSoundEffect()
// Desc: Deconstructs the object
//-----------------------------------------------------------------------------
CSoundEffect::~CSoundEffect()
{
    Stop();
    delete [] m_pbSampleData;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes a sound effect.  Only has to be called once for an object
//       pdsound must be a pointer to a valid object
//-----------------------------------------------------------------------------
HRESULT CSoundEffect::Initialize( LPDIRECTSOUND8 pdsound )
{
    m_pdsndDevice = pdsound;

    // Create a buffer of 0 size, since we don't know the size of the files 
    // we'll play
    WAVEFORMATEX wfx;
    DSBUFFERDESC dsbdesc;
    ZeroMemory( &dsbdesc, sizeof( DSBUFFERDESC ) );
    dsbdesc.dwSize = sizeof( DSBUFFERDESC );
    dsbdesc.dwFlags = 0;
    dsbdesc.dwBufferBytes = 0;
    dsbdesc.lpwfxFormat = &wfx;

    ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) );
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 2;
    wfx.nSamplesPerSec = 44100;
    wfx.cbSize = 0;
    wfx.wBitsPerSample = 16;
    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;

    if( FAILED( m_pdsndDevice->CreateSoundBuffer( &dsbdesc, &m_pDSBuffer, NULL ) ) )
        return E_FAIL;

    // Grab the wave file and read it in
    if( FAILED( m_WaveFile.Open( strENGINE_SOUND ) ) )
        return E_FAIL;

    DWORD dwSize;
    m_WaveFile.GetDuration( &dwSize );
    m_pbSampleData = new BYTE[dwSize];
    if( !m_pbSampleData )
        return E_FAIL;

    m_WaveFile.ReadSample( 0, m_pbSampleData, dwSize, &dwSize );
    m_bIsInitialized = TRUE;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: IsInitialized()
// Desc: Returns TRUE if Initialize() has been called
//-----------------------------------------------------------------------------
BOOL CSoundEffect::IsInitialized() const
{
    return m_bIsInitialized;
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Starts playing a sound
//-----------------------------------------------------------------------------
HRESULT CSoundEffect::PlaySound( BOOL bLooping )
{
    DWORD dwNewSize;

    // If we were paused, just start playing (if idx is the same)
    if( IsPaused() )
    {
        m_pDSBuffer->Play( 0, 0, bLooping ? DSBPLAY_LOOPING : 0 );
        m_bIsPaused = FALSE;
        return S_OK;
    }

    // If the sound is already being played, return
    if( m_bIsPlaying )
    {
        m_pDSBuffer->GetStatus( &dwNewSize );
        if( dwNewSize & DSBSTATUS_PLAYING )
            return S_OK;
    }

    m_WaveFile.GetDuration( &dwNewSize );
    m_pDSBuffer->SetBufferData( m_pbSampleData, dwNewSize );
    m_pDSBuffer->SetLoopRegion( 0, dwNewSize );
    m_pDSBuffer->SetCurrentPosition( 0 );
    m_pDSBuffer->SetVolume( (LONG)(VOLUME_MIN + 
                            (VOLUME_MAX - VOLUME_MIN)*(m_fVolume/100.0f)) );
    m_pDSBuffer->Play( 0, 0, bLooping ? DSBPLAY_LOOPING : 0 );
    m_bIsPlaying = TRUE;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stops sound playing
//-----------------------------------------------------------------------------
VOID CSoundEffect::Stop()
{
    if( m_bIsPlaying )
    {
        m_pDSBuffer->StopEx( 0, DSBSTOPEX_IMMEDIATE );
        m_pDSBuffer->SetBufferData( NULL, 0 );

        m_bIsPlaying = FALSE;
        m_bIsPaused = FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: Pause()
// Desc: Pauses the current sound
//-----------------------------------------------------------------------------
VOID CSoundEffect::Pause()
{
    if( m_bIsPlaying && !m_bIsPaused )
    {
        m_pDSBuffer->StopEx( 0, DSBSTOPEX_IMMEDIATE );
        m_bIsPaused = TRUE;
    }
}




//-----------------------------------------------------------------------------
// Name: IsPaused()
// Desc: TRUE if the current sound is paused
//-----------------------------------------------------------------------------
BOOL CSoundEffect::IsPaused() const
{
    if( m_bIsPlaying && m_bIsPaused )
        return TRUE;
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: SetVolume
// Desc: Sets the volume of the sound effect object.  This propagates to all sounds played
//-----------------------------------------------------------------------------
VOID CSoundEffect::SetVolume( FLOAT fVolume )
{
    m_fVolume = fVolume;
}




//-----------------------------------------------------------------------------
// Name: SetPitch
// Desc: Sets the pitch of the currently playing sound
//-----------------------------------------------------------------------------
VOID CSoundEffect::SetPitch( LONG lPitch )
{
    if( m_pDSBuffer )
        m_pDSBuffer->SetPitch( lPitch );
}




//-----------------------------------------------------------------------------
// Name: IsDone
// Desc: Polls the buffer to see if it is playing and sets the proper fields
//-----------------------------------------------------------------------------
BOOL CSoundEffect::IsDone()
{
    DWORD dwStatus;

    if( !m_bIsPlaying )
        return TRUE;

    m_pDSBuffer->GetStatus( &dwStatus );
    if( dwStatus & DSBSTATUS_PLAYING )
        return FALSE;

    m_bIsPlaying = FALSE;
    m_bIsPaused = FALSE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\SoundEffect.h ===
//-----------------------------------------------------------------------------
// File: SoundEffect.h
//
// Desc: Plays a WAV file sound effect
//
// Hist: 06.21.01 - New for July XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _SOUND_EFFECT_H_
#define _SOUND_EFFECT_H_

#include <xtl.h>
#include "XbSound.h"




//-----------------------------------------------------------------------------
// Name: class CSoundEffect
// Desc: WAV sound effect object
//-----------------------------------------------------------------------------
class CSoundEffect
{
private:
    BOOL                          m_bIsPlaying;             //  TRUE if sound is playing
    BOOL                          m_bIsInitialized;         //  TRUE if Initialized() was called
    BOOL                          m_bIsPaused;              //  TRUE if the sound is paused
    FLOAT                         m_fVolume;                //  Volume level expressed as percentage (0 .. 100)
    LPDIRECTSOUND8                m_pdsndDevice;            //  DSound object
    LPDIRECTSOUNDBUFFER8          m_pDSBuffer;              //  DSound buffer object
    CWaveFile                     m_WaveFile;               //  Wave File object
    BYTE                         *m_pbSampleData;           //  Buffer for data from the sound
    INT                           m_iCurrentIdx;            //  Currently playing sound

public:
    CSoundEffect();
    ~CSoundEffect();

    BOOL    IsInitialized() const;
    BOOL    IsPaused() const;
    BOOL    IsDone();

    HRESULT Initialize( LPDIRECTSOUND8 pdsound );
    HRESULT PlaySound( BOOL bLooping = TRUE );
    VOID    Stop();
    VOID    Pause();
    VOID    SetVolume( FLOAT fVolume );
    VOID    SetPitch( LONG lPitch );
};

#endif // _SOUND_EFFECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Splash.cpp ===
//-----------------------------------------------------------------------------
// File: Splash.cpp
//
// Desc: Splash screen
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Splash.h"
#include "Text.h"
#include <XbApp.h>
#include <XbConfig.h>
#include <XbFont.h>
#include "cxfont.h"




//-----------------------------------------------------------------------------
// Name: Splash()
// Desc: Constructor
//-----------------------------------------------------------------------------
Splash::Splash( CXBFont& font, CXFont& xFont )
:
    m_Font( font ),
    m_XFontJPN( xFont ),
    m_Timer()
{
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Start the splash
//-----------------------------------------------------------------------------
VOID Splash::Start()
{
    m_Timer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Quit the splash
//-----------------------------------------------------------------------------
VOID Splash::End()
{
    m_Timer.Stop();
}




//-----------------------------------------------------------------------------
// Name: GetElapsedSeconds()
// Desc: Returns the length of time elapsed since Start() called
//-----------------------------------------------------------------------------
FLOAT Splash::GetElapsedSeconds() const
{
    return m_Timer.GetElapsedSeconds();
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame for animating the splash
//-----------------------------------------------------------------------------
HRESULT Splash::FrameMove( const XBGAMEPAD* )
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame for 3d rendering of the splash
//-----------------------------------------------------------------------------
HRESULT Splash::Render()
{
    DWORD dwLang = CXBConfig::GetLanguage();

    if( dwLang != XC_LANGUAGE_JAPANESE )
    {
        m_Font.DrawText( 320, 100, 0xFFFFFFFF, strGAME_NAME[ dwLang ],
                         XBFONT_CENTER_X );
        m_Font.DrawText( 320.0f, 240.0f, 0xFFFFFFFF, strMS_XBOX[ dwLang ],
                         XBFONT_CENTER_X | XBFONT_CENTER_Y );
    }
    else
    {
        m_XFontJPN.DrawText( 320, 100, 0xFFFFFFFF, strGAME_NAME[ dwLang ],
                             CXFONT_CENTER_X );
        m_XFontJPN.DrawText( 320, 240, 0xFFFFFFFF, strMS_XBOX[ dwLang ],
                             CXFONT_CENTER_X | CXFONT_CENTER_Y );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Splash.h ===
//-----------------------------------------------------------------------------
// File: Splash.h
//
// Desc: Splash screen
//
// Hist: 01.24.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_SPLASH_H
#define TECH_CERT_GAME_SPLASH_H

#include "Common.h"
#include <XbStopWatch.h>

struct XBGAMEPAD;
class CXBFont;
class CXFont;




//-----------------------------------------------------------------------------
// Name: class Splash
// Desc: Splash screen
//-----------------------------------------------------------------------------
class Splash
{

    CXBFont&     m_Font;
    CXFont&      m_XFontJPN;
    CXBStopWatch m_Timer;

public:

    Splash( CXBFont&, CXFont& );

    VOID    Start();
    VOID    End();
    FLOAT   GetElapsedSeconds() const;
    HRESULT Render();
    HRESULT FrameMove( const XBGAMEPAD* );

private:

    // Disabled
    Splash( const Splash& );
    Splash& operator=( const Splash& );

};




#endif // TECH_CERT_GAME_SPLASH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\StartScreen.h ===
//-----------------------------------------------------------------------------
// File: StartScreen.h
//
// Desc: Start screen
//
// Hist: 05.07.01 - New for June XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_START_H
#define TECH_CERT_GAME_START_H

#include "Common.h"
#include <XbStopWatch.h>

struct XBGAMEPAD;
class CXBFont;
class CXFont;




//-----------------------------------------------------------------------------
// Name: class StartScreen
// Desc: Start screen
//-----------------------------------------------------------------------------
class StartScreen
{

    CXBFont&     m_Font;
    CXFont&      m_XFontJPN;
    CXBStopWatch m_Timer;

public:

    StartScreen( CXBFont&, CXFont& );

    VOID    Start();
    VOID    End();
    FLOAT   GetElapsedSeconds() const;
    HRESULT Render();
    HRESULT FrameMove( const XBGAMEPAD* );

private:

    // Disabled
    StartScreen( const StartScreen& );
    StartScreen& operator=( const StartScreen& );

};




#endif // TECH_CERT_GAME_START_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\StartScreen.cpp ===
//-----------------------------------------------------------------------------
// File: StartScreen.cpp
//
// Desc: Start screen
//
// Hist: 05.07.01 - New for June XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "StartScreen.h"
#include "Controller.h"
#include "Text.h"
#include <XbApp.h>
#include <XbConfig.h>
#include <XbFont.h>
#include "cxfont.h"




//-----------------------------------------------------------------------------
// Name: StartScreen()
// Desc: Constructor
//-----------------------------------------------------------------------------
StartScreen::StartScreen( CXBFont& font, CXFont& xFont )
:
    m_Font( font ),
    m_XFontJPN( xFont ),
    m_Timer()
{
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Start the start screen
//-----------------------------------------------------------------------------
VOID StartScreen::Start()
{
    m_Timer.StartZero();
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Quit the start screen
//-----------------------------------------------------------------------------
VOID StartScreen::End()
{
    m_Timer.Stop();
}




//-----------------------------------------------------------------------------
// Name: GetElapsedSeconds()
// Desc: Returns the length of time elapsed since Start() called
//-----------------------------------------------------------------------------
FLOAT StartScreen::GetElapsedSeconds() const
{
    return m_Timer.GetElapsedSeconds();
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame for animating the start screen
//-----------------------------------------------------------------------------
HRESULT StartScreen::FrameMove( const XBGAMEPAD* )
{
    // Allow any controller to become the primary controller.
    // We do this on every loop because we're waiting for the Start button
    // to indicate the primary controller
    Controller::ClearPrimaryController();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame for 3d rendering of the start screen
//-----------------------------------------------------------------------------
HRESULT StartScreen::Render()
{
    DWORD dwLang = CXBConfig::GetLanguage();

    if( dwLang != XC_LANGUAGE_JAPANESE )
    {
        m_Font.DrawText( 320, 100, 0xffffffff, strGAME_NAME[ dwLang ],
                         XBFONT_CENTER_X );
        m_Font.DrawText( 320, 200, 0xffffffff, strINTRO[ dwLang ],
                         XBFONT_CENTER_X | XBFONT_CENTER_Y );

        // TCR 6-6 Press Start
        m_Font.DrawText( 320, 300, 0xffffffff, strPRESS_START[ dwLang ],
                         XBFONT_CENTER_X );
    }
    else
    {
        m_XFontJPN.DrawText( 320, 100, 0xffffffff, strGAME_NAME[ dwLang ],
                             CXFONT_CENTER_X );
        m_XFontJPN.DrawText( 320, 200, 0xffffffff, strINTRO[ dwLang ],
                             CXFONT_CENTER_X | CXFONT_CENTER_Y );

        // TCR 6-6 Press Start
        m_XFontJPN.DrawText( 320, 300, 0xffffffff, strPRESS_START[ dwLang ],
                             CXFONT_CENTER_X );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Vehicle.cpp ===
//-----------------------------------------------------------------------------
// File: Vehicle.cpp
//
// Desc: Vehicle object
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Vehicle.h"
#include "PhysicsSystem.h"
#include "Globals.h"


Vehicle::Vehicle( PhysicsSystem* pPhysicsSystem, const Vector3& v3Pos, 
                  const Quaternion& qRot, const Vector3* v3Supports,
                  const float* fSupportLength)
: 
    PhysicsObject( pPhysicsSystem, v3Pos, qRot )
{
	m_iNumSupports = 4;

	for (int i = 0; i < m_iNumSupports; i++)
	{
		m_v3SupportOffset[i] = v3Supports[i];
		m_fSupportLength[i] = fSupportLength[i];
		m_fCurrentSupportLength[i] = m_fSupportLength[i];

	}

	m_fTurnAngle = 0.0f;
	m_fSpeedControl = 0.0f;
}


void Vehicle::AddConstraints(float time)
{
    USED( time );
	Vector3 down = Vector3(0.0f, -1.0f, 0.0f) * GetRotation();
	Vector3 forward = Vector3(0.0f, 0.0f, 1.0f) * GetRotation();
	Vector3 right = Vector3(1.0f, 0.0f, 0.0f) * GetRotation();
	Vector3 turn = right * Quaternion(Vector3(0.0f,1.0f,0.0f), m_fTurnAngle);

	// Find wheel contacts.
	for (int i = 0; i < m_iNumSupports; i++)
	{
		Vector3 p1 = GetTranslation() + m_v3SupportOffset[i] * GetRotation();
		Vector3 p2 = p1 + down * m_fSupportLength[i];

		m_fContactT[i] = 1.0f;
		GetPhysicsSystem()->CheckLineSegment(p1, p2, &m_fContactT[i], &m_v3ContactPoint[i]);

		if (m_fContactT[i] < 1.0f)
			m_fCurrentSupportLength[i] = (p1 - m_v3ContactPoint[i]).GetLength();
		else
			m_fCurrentSupportLength[i] = m_fSupportLength[i];
	}

	if (m_fContactT[0] < 1.0f || m_fContactT[1] < 1.0f)
	{
		// Add friction constraints.
		Constraint* c = GetPhysicsSystem()->AddConstraint( 
                                    GetPhysicsSystem()->GetWorldObject(), this );
		c->Type = Constraint::StaticFriction;

		if (m_fContactT[0] < 1.0f && m_fContactT[1] < 1.0f)
			c->v3Point = (m_v3ContactPoint[0] + m_v3ContactPoint[1]) * 0.5f;
		else if (m_fContactT[0] < 1.0f)
			c->v3Point = m_v3ContactPoint[0];
		else if (m_fContactT[1] < 1.0f)
			c->v3Point = m_v3ContactPoint[1];

		c->v3Normal = turn;
		c->fFrictionForce = 5.0f;

#if (0)
		g_DebugLines.push_back(DebugLine());
		DebugLine& line0 = g_DebugLines.back();
		line0.pos1 = c->v3Point;
		line0.c	assert(temp1.PointInPolyhedron(pInfo->v3CenterOfIntersection, 0.1f));
olor1 = 0x000000ff;
		line0.pos2 = c->v3Point + forward * Quaternion(Vector3(0.0f,1.0f,0.0f), m_fTurnAngle);
		line0.color2 = 0x000000ff;

		g_DebugLines.push_back(DebugLine());
		DebugLine& line1 = g_DebugLines.back();
		line1.pos1 = c->v3Point;
		line1.color1 = 0x00ff0000;
		line1.pos2 = c->v3Point + c->v3Normal * 0.5f;
		line1.color2 = 0x00ff0000;
#endif
	}

	if (m_fContactT[2] < 1.0f || m_fContactT[3] < 1.0f)
	{
		// Rear.
		Constraint* c = GetPhysicsSystem()->AddConstraint(
                                    GetPhysicsSystem()->GetWorldObject(), this );
		c->Type = Constraint::StaticFriction;

		if (m_fContactT[2] < 1.0f && m_fContactT[3] < 1.0f)
			c->v3Point = (m_v3ContactPoint[2] + m_v3ContactPoint[3]) * 0.5f;
		else if (m_fContactT[2] < 1.0f)
			c->v3Point = m_v3ContactPoint[2];
		else if (m_fContactT[3] < 1.0f)
			c->v3Point = m_v3ContactPoint[3];

		c->v3Normal = right;
		c->fFrictionForce = 5.0f;

#if (0)
		g_DebugLines.push_back(DebugLine());
		DebugLine& line3 = g_DebugLines.back();
		line3.pos1 = c->v3Point;
		line3.color1 = 0x00ff0000;
		line3.pos2 = c->v3Point + c->v3Normal * 0.5;
		line3.color2 = 0x00ff0000;
#endif
	}
}


void Vehicle::ComputeForceAndTorque(float time)
{
	// Add standard forces.
	PhysicsObject::ComputeForceAndTorque(time);

	const float ks = 3000.0f;
	const float kd = 300.0f;

	Vector3 down = Vector3(0.0f, -1.0f, 0.0f) * GetRotation();
	Vector3 forward = Vector3(0.0f, 0.0f, 1.0f) * GetRotation();
	Vector3 right = Vector3(1.0f, 0.0f, 0.0f) * GetRotation();
	Vector3 turn = right * Quaternion(Vector3(0.0f,1.0f,0.0f), m_fTurnAngle);

	// Add spring forces.
	for (int i = 0; i < m_iNumSupports; i++)
	{
		if (m_fContactT[i] < 1.0f)
		{
			float t = m_fContactT[i];
			Vector3 ip = m_v3ContactPoint[i];

			// Add spring force.
			float vrel = -down * VelocityAtPoint(ip);
			Vector3 force = -down * (ks * (1.0f - t) - kd * vrel);

			float force_magnitude = force.GetLength();

			if (i < 2)
			{
				// Add dynamic friction force.
				float tvel = VelocityAtPoint(ip) * turn;
				if (fabs(tvel) > 0.01f)
				{
					// Add friction force.
					force -= tvel * turn * force_magnitude * 0.2f;
				}
			}
			else
			{
				// Add dynamic friction force.
				float tvel = VelocityAtPoint(ip) * right;
				if (fabs(tvel) > 0.01f)
				{
					// Add friction force.
					force -= tvel * right * force_magnitude * 0.2f;
				}

				// Apply acceleration/braking.
				if (m_fSpeedControl > 0.0f)
				{
					force += forward * m_fSpeedControl * 500.0f;
				}
				else
				{
					force += forward * m_fSpeedControl * 250.0f;
				}
			}

			AddForce(ip, force);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\WorldDB.h ===
//-----------------------------------------------------------------------------
// FILE: WorldDB.h
//
// Desc: World database
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

class WorldSection
{
public:
	BoundingBox m_Bounds;
	WorldSection* m_pPrev;
	WorldSection* m_pNext;
	SectionMesh* m_pMesh;			// May not be loaded.
};


class CoordinateFrame
{
public:
	D3DXVECTOR3 pos;
	D3DXQUATERNION quat;
};


class Actor
{
public:
	CoordinateFrame m_Location;
	WorldSection* m_pSections[2];		// Actor can be in at most two sections.
	ActorMesh* m_pMesh;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\obj\i386\Font12.h ===
// Automatically generated by the bundler tool from Font12.rdf

#define Font12_NUM_RESOURCES 2UL

#define Font12_Font_OFFSET 0UL
#define Font12_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Text.cpp ===
//-----------------------------------------------------------------------------
// File: Text.cpp
//
// Desc: All text in single place to simplify localization
//
// Hist: 04.10.01 - New for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Text.h"





//-----------------------------------------------------------------------------
// Order of text matches XC_LANGUAGE_XXX #definitions in Xbox.h
//-----------------------------------------------------------------------------

// TCR 3-25 Xbox Official Naming Standards
// TCR 3-27 Xbox Official Naming Localization

const WCHAR* const strGAME_NAME_FORMAT[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"%s drive %s", // EN
	L"%s " L"\x30C9" L"\x30E9" L"\x30A4" L"\x30D6" L" %s", //JP
    L"LW - %s %s", // DE
    L"Sauvegarde du %s %s", // FR
    L"Carrera de %s %s", // ES
    L"Gara di %s drive %s", // IT
};

const WCHAR* const strSUNDAY[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Sun.",
    L"\x65E5" L"\x66DC" L"\x65E5" L" = "  L"\x65E5", // JP
    L"So.", // DE
    L"dim.", // FR
    L"dom.", // ES
    L"dom.", // IT
};

const WCHAR* const strMONDAY[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Mon.",
    L"\x6708" L"\x66DC" L"\x65E5" L" = " L"\x6708", // JP
    L"Mo.", // DE
    L"cun.", // FR
    L"lun.", // ES
    L"lun.", // IT
};

const WCHAR* const strTUESDAY[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Tues",
    L"\x706B" L"\x66DC" L"\x65E5" L" = " L"\x706B", // JP
    L"Di.", // DE
    L"mar.", // FR
    L"mar.", // ES
    L"mar.", // IT
};

const WCHAR* const strWEDNESDAY[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Wed.",
    L"\x6C34" L"\x66DC" L"\x65E5" L" = " L"\x6C34", // JP
    L"mi.", // DE
    L"mer.", // FR
    L"mi" L"\xE9" L".", // ES
    L"mer.", // IT
};

const WCHAR* const strTHURSDAY[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Thurs",
    L"\x6728" L"\x66DC" L"\x65E5"  L" = " L"\x6728", // JP
    L"Do.", // DE
    L"jeu.", // FR
    L"jue.", // ES
    L"gio.", // IT
};

const WCHAR* const strFRIDAY[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Friday",
    L"\x91D1" L"\x66DC" L"\x65E5"  L" = " L"\x91D1", // JP
    L"Fr", // DE
    L"ven", // FR
    L"vie.", // ES
    L"ven.", // IT
};

const WCHAR* const strSATURDAY[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Sat",
    L"\x571F" L"\x66DC" L"\x65E5"  L" = " L"\x571F", // JP
    L"Sa", // DE
    L"sam.", // FR
    L"s" L"\xE1" L"b.", // ES
    L"sab.", // IT
};

// TCR 6-7 Lost Controller
const WCHAR* const strRECONNECT_CNTRLR[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Please reconnect the controller\nand press START to continue",

    L"\x30B3" L"\x30F3" L"\x30C8" L"\x30ED" L"\x30FC" L"\x30E9" L"\x3092" 
    L"\x63A5" L"\x7D9A" L"\x3057" L"\x76F4" L"\x3057" L"\x3001" 
    L"\nSTART" L"\x30DC" L"\x30BF" L"\x30F3" L"\x3092" L"\x62BC" L"\x3057" 
    L"\x3066" L"\x7D9A" L"\x3051" L"\x3066" L"\x304F" L"\x3060" 
    L"\x3055" L"\x3044" , // JP

    L"Bitte Controller wieder\nanschlie" L"\xDF" L"en", // DE
    L"Pour continuer, rebrancher la\nmanette et appuyer sur START.", // FR
    L"Vuelva a conectar el controlador y\n"
    L"presione START (inicio) para continuar.", // ES
    L"Ricollegare il controller e\npremere START per continuare.", // IT
};

const WCHAR* const strCONFIRM_QUIT[ XC_LANGUAGE_MAX ] =
{
    L"",

    L"Are you sure you\nwant to quit this race?\n\n"    
    L"Press A for Yes\n"
    L"Press B for No", // US

    L"\x3053" L"\x306E" L"\x30EC" L"\x30FC" L"\x30B9" L"\x3092" 
    L"\x7D42" L"\x4E86" L"\x3057" L"\x307E" L"\x3059" 
    L"\x304B" L"\x003F" L"\n\n"
    L"\x7D42" L"\x4E86" L"\x3059" L"\x308B" L" - A " 
    L"\x30DC" L"\x30BF" L"\x30F3" L"\n"
    L"\x7D9A" L"\x3051" L"\x308B" L" - B " 
    L"\x30DC" L"\x30BF" L"\x30F3",  //JP

    L"Dieses Rennen wirklich verlassen?\n\n"
    L"A - Taste f" L"\xFC" L"r JA dr" L"\xFC" L"cken\n"
    L"B - Taste f" L"\xFC" L"r NEIN dr" L"\xFC" L"cken",// DE

    L"Quitter cette course?\n\n"
    L"Oui: appuyer sur A\n"
    L"Non: appuyer sur B", // FR

    L"\xBF" L"Seguro que desea salir de la carrera?\n\n"
    L"Presione A si quiere\n"
    L"Presione B si no quiere", // ES

    L"Si " L"\xE8" L" sicuri di voler abbandonare questa gara?\n\n"
    L"Premere A per confermare\n"
    L"Premere B per rinunciare", // IT
};

const WCHAR* const strDEMO[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Demo",
    L"\x30C7" L"\x30E2", // JP
    L"Demo", // DE
    L"D" L"\xE9" L"mo", // FR
    L"Demo", // ES
    L"Demo", // IT
};

const WCHAR* const strRETURN_TO_MENU[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Press any button to return to the menu",

    L"\x30E1" L"\x30CB" L"\x30E5" L"\x30FC" L"\x306B" 
    L"\x623B" L"\x308B" L"\x306B" L"\x306F" L"\x3044" 
    L"\x305A" L"\x308C" L"\x304B" L"\x306E" L"\x30DC" 
    L"\x30BF" L"\x30F3" L"\x3092" L"\x62BC" L"\x3057" 
    L"\x3066" L"\x304F" L"\x3060" L"\x3055" L"\x3044", // JP

    L"Beliebige Taste zur R" L"\xFC" L"ckkehr", // DE
    L"Appuyer sur une touche pour revenir au menu", // FR
    L"Presione cualquier bot" L"\xF3" L"n para volver al men" L"\xFA", // ES
    L"Premere un pulsante per tornare al menu", // IT
};

const WCHAR* const strGAME_NAME[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Technical Certification Game",

    L"\x6280" L"\x8853" L"\x8A8D" L"\x8A3C" L"\x9805" 
    L"\x76EE" L"\x30C7" L"\x30E2" L"\x0020" L"\x30B2" 
    L"\x30FC" L"\x30E0" , // JP

    L"Spiel mit techn. Zertifikation", // DE
    L"Jeu de certification technique", // FR
    L"Partida de certificaci" L"\xF3" L"n t" L"\xE9" L"cnica", // ES
    L"Gioco con certificazione tecnica", // IT
};

const WCHAR* const strLOADINGX[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Loading...",
    L"\x8AAD" L"\x307F" L"\x8FBC" L"\x307F" L"\x4E2D" L"...", // JP
    L"Laden...", // DE
    L"Chargement en cours...", // FR
    L"Cargando...", // ES
    L"Caricamento in corso...", // IT
};

const WCHAR* const strFREE[ XC_LANGUAGE_MAX ] =
{
    L"",

    L"Your Xbox doesn't have enough\n"
    L"free blocks to save games.\n\n"
    L"Press A to continue without saving\n"
    L"or B to free at least %lu blocks.",

    L"\x30B2" L"\x30FC" L"\x30E0" L"\x306E" 
    L"\x4FDD" L"\x5B58" L"\x306B" L"\x5FC5" 
    L"\x8981" L"\x306A" L"\x7A7A" L"\x304D" 
    L"\x30D6" L"\x30ED" L"\x30C3" L"\x30AF" 
    L"\x304C" L"\x3042" L"\x308A" L"\x307E" 
    L"\x305B" L"\x3093" L"\x3002" L"\x0020" L"\n A " 
    L"\x30DC" L"\x30BF" L"\x30F3" L"\x3092" L"\x62BC" 
    L"\x3057" L"\x3066" L"\x4FDD" L"\x5B58" L"\x305B" 
    L"\x305A" L"\x306B" L"\x7D9A" L"\x3051" L"\x308B" 
    L"\x304B" L"\x3001" L"\n B " L"\x30DC" L"\x30BF" L"\x30F3" 
    L"\x3092" L"\x62BC" L"\x3057" L"\x3066" L"\x30D6" 
    L"\x30ED" L"\x30C3" L"\x30AF" L"\x3092" L"\x89E3" L"\x653E" 
    L"\x3057" L"\x3066" L"\x304F" L"\x3060" L"\x3055" 
    L"\x3044" L"\x3002", // JP

    L"Xbox-Festplatte hat nicht gen" L"\xFC" L"gend\n"
    L"freie Bl" L"\xF6" L"cke, um Spielst" L"\xE4" L"nde\n"
    L"zu speichern. A dr" L"\xFC" L"cken: Weiterspielen,\n"
    L"ohne zu speichern. B dr" L"\xFC" L"cken:\n"
    L"Bl" L"\xF6" L"cke frei machen.", // DE

    L"La Xbox ne comporte pas assez de blocs\n"
    L"libres pour sauvegarder les parties.\n"
    L"Appuyer sur A pour jouer sans sauvegarder.\n"
    L"Appuyer sur B pour lib" L"\xE9" L"rer des blocs.", // FR

    L"El disco de memoria de su Xbox no\n"
    L"dispone de suficientes bloques libres\n"
    L"para guardar partidas. Presione A para\n"
    L"continuar sin guardar o B para\n"
    L"liberar espacio.", // ES

    L"Sul disco rigido di Xbox non ci sono\n"
    L"blocchi liberi sufficienti per salvare\n"
    L"le partite. Premere A per continuare\n"
    L"senza salvare, oppure premere B per\n"
    L"liberare alcuni blocchi.", // IT
};

const WCHAR* const strMENU_START[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Start Race",
    L"\x30EC" L"\x30FC" L"\x30B9" L"\x306E" L"\x958B" L"\x59CB", // JP
    L"Rennen starten", // DE
    L"D" L"\xE9" L"marrer la course", // FR
    L"Comenzar carrera", // ES
    L"Inizia gara", // IT
};

const WCHAR* const strMENU_LOAD[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Load Saved Race",
    L"\x4FDD" L"\x5B58" L"\x3057" L"\x305F" L"\x30EC" L"\x30FC" 
    L"\x30B9" L"\x306E" L"\x8AAD" L"\x307F" L"\x8FBC" L"\x307F", // JP
    L"Gesp. Rennen starten", // DE
    L"Charger une course sauvegard" L"\xE9" L"e", // FR
    L"Cargar carrera guardada", // ES
    L"Carica gara salvata", // IT
};

const WCHAR* const strMENU_OPTIONS[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Options",
    L"\x30AA" L"\x30D7" L"\x30B7" L"\x30E7" L"\x30F3", // JP
    L"Options", // DE
    L"Options", // FR
    L"Opciones", // ES
    L"Opzioni", // IT
};

const WCHAR* const strMENU_RESUME[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Resume Race",
    L"\x30EC" L"\x30FC" L"\x30B9" L"\x306E" L"\x518D" L"\x958B", // JP
    L"Rennen weiterspielen", // DE
    L"Reprendre la course", // FR
    L"Continuar carrera", // ES
    L"Riprendi gara", // IT
};

const WCHAR* const strMENU_SAVE[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Save Race",
    L"\x30EC" L"\x30FC" L"\x30B9" L"\x306E" L"\x4FDD" L"\x5B58", // JP
    L"Rennen speichern", // DE
    L"Sauvegarder la course", // FR
    L"Guardar carrera", // ES
    L"Salva gara", // IT
};


const WCHAR* const strMENU_QUIT[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Quit Race",
    L"\x30EC" L"\x30FC" L"\x30B9" L"\x306E" L"\x7D42" L"\x4E86", // JP
    L"Rennen beenden", // DE
    L"Quitter la course", // FR
    L"Salir de carrera", // ES
    L"Abbandona gara", // IT
};

const WCHAR* const strMENU_VIBRATION[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Vibration",
    L"\x30B3" L"\x30F3" L"\x30C8" L"\x30ED" L"\x30FC" L"\x30E9" 
    L"\x306E" L"\x30D0" L"\x30A4" L"\x30D6" L"\x30EC" L"\x30FC" L"\x30B7" 
    L"\x30E7" L"\x30F3" L"\x0020" L"\x0020" L"\x632F" L"\x52D5" L"\x0029", // JP
    L"Controller-Vibration", // DE
    L"Vibration", // FR
    L"Funci" L"\xF3" L"n de vibraci" L"\xF3" L"n", // ES
    L"Vibrazione", // IT
};

const WCHAR* const strON[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"On",
    L"\x30AA" L"\x30F3", // JP
    L"Ein", // DE
    L"Oui", // FR
    L"Activar", // ES
    L"S" L"\xEC" L"", // IT
};

const WCHAR* const strOFF[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Off",
    L"\x30AA" L"\x30D5", // JP
    L"Aus", // DE
    L"Non", // FR
    L"Desactivar", // ES
    L"No", // IT
};

const WCHAR* const strMENU_MUSIC_VOLUME[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Music Volume",
    L"\x97F3" L"\x697D" L"\x306E" L"\x30DC" L"\x30EA" L"\x30E5" L"\x30FC" L"\x30E0", // JP
    L"Musik-Lautst" L"\x00E4" L"rke", // DE  
    L"Volume musique", // FR
    L"Volumen de m" L"\x00FA" L"sica", // ES
    L"Volume musica", // IT
};


const WCHAR* const strMENU_EFFECT_VOLUME[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Sound Effect Volume",
    L"\x52B9" L"\x679C" L"\x97F3" L"\x306E" L"\x30DC" L"\x30EA" L"\x30E5" L"\x30FC" L"\x30E0" , // JP
    L"Effekt-Lautst" L"\x00E4" L"rke", // DE  
    L"Volume effets son.", // FR
    L"Volumen de efectos", // ES
    L"Volume effetti", // IT
};

const WCHAR* const strMENU_SAVE_OPTIONS[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Save Options",
    L"\x30AA" L"\x30D7" L"\x30B7" L"\x30E7" L"\x30F3" L"\x306E" L"\x4FDD" L"\x5B58" , // JP
    L"Optionen speichern", // DE
    L"Sauvegarde des options", // FR
    L"Guardar opciones", // ES
    L"Salva opzioni", // IT
};

const WCHAR* const strMS_XBOX[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Microsoft Xbox",
    L"Microsoft Xbox", // JP
    L"Microsoft Xbox", // DE
    L"Microsoft Xbox", // FR
    L"Xbox de Microsoft", // ES
    L"Microsoft Xbox", // IT
};

const WCHAR* const strINTRO[ XC_LANGUAGE_MAX ] =
{
    L"",

    L"This sample shows a simple game that\n"
    L"meets Xbox Technical Certification\n"
    L"Requirements. Please do not lift the\n"
    L"graphics for use in your game.",

    L"\x3053" L"\x306E" L"\x30B5" L"\x30F3" L"\x30D7" 
    L"\x30EB" L"\x306F" L"\x3001" L" Xbox\n" L"\x306E" 
    L"\x6280" L"\x8853" L"\x9762" L"\x306E" L"\x691C" L"\x5B9A" 
    L"\x57FA" L"\x6E96" L"\x3092" L"\x6E80" L"\x305F" L"\x3057" 
    L"\x305F" L"\x7C21" L"\x5358" L"\x306A" L"\x30B2" L"\x30FC" 
    L"\x30E0" L"\x3067" L"\x3059" L"\x3002" L"\n" L"\x3053" L"\x306E" 
    L"\x30B2" L"\x30FC" L"\x30E0" L"\x3067" L"\x4F7F" L"\x7528" 
    L"\x3057" L"\x3066" L"\x3044" L"\x308B" L"\x753B" L"\x50CF" 
    L"\x306F" L"\x3001" L"\n" L"\x307B" L"\x304B" L"\x306E" L"\x30B2" 
    L"\x30FC" L"\x30E0" L"\x3067" L"\x306F" L"\x4F7F" L"\x7528" 
    L"\x3067" L"\x304D" L"\x307E" L"\x305B" L"\x3093" L"\x3002", // JP

    L"Dieses Beispiel ist ein einfaches Spiel,\n"
    L"das der techn. Zertifikation f" L"\xFC" L"r\n"
    L"die Xbox entspricht. Bitte die Grafik\n"
    L"nicht in Ihrem Spiel verwenden.",// DE

    L"Voici un jeu simple r" L"\xE9" L"pondant\n"
    L"aux Crit" L"\xE8" L"res de Certification\n"
    L"Technique Xbox. Merci de ne pas utiliser\n"
    L"ces graphismes dans votre jeu.",// FR

    L"\xC9" L"sta es una muestra de una partida\n"
    L"sencilla que re" L"\xFA" L"ne los requisitos\n"
    L"de certificaci" L"\xF3" L"n t" L"\xE9" L"cnica de\n"
    L"la Xbox. No utilice estos gr" L"\xE1" L"ficos\n"
    L"en la partida.", // ES

    L"Questo esempio mostra un semplice gioco che\n"
    L"soddisfa i requisiti di certificazione tecnica\n"
    L"per Xbox. Si prega di non riutilizzare la\n"
    L"grafica in altri giochi da voi sviluppati.", // IT
};

// TCR 6-6 Press Start
const WCHAR* const strPRESS_START[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Please press START to begin",
    L"START " L"\x30DC" L"\x30BF" L"\x30F3" L"\x3092" 
    L"\x62BC" L"\x3057" L"\x3066" L"\x958B" L"\x59CB" 
    L"\x3057" L"\x3066" L"\x304F" L"\x3060" L"\x3055" L"\x3044", // JP
    L"START dr" L"\xFC" L"cken, um zu beginnen", // DE
    L"Appuyer sur Start pour d" L"\xE9" L"marrer", // FR
    L"Presione START (inicio) para comenzar", // ES
    L"Premere START per iniziare", // IT
};

const WCHAR* const strSAVE_FAILED[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Unable to save game.\n"
    L"Press A to continue",

    L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x4FDD" L"\x5B58" 
    L"\x3067" L"\x304D" L"\x307E" L"\x305B" L"\x3093" L"\x3002" 
    L"\n A " L"\x30DC" L"\x30BF" L"\x30F3" L"\x3092" L"\x62BC" 
    L"\x3057" L"\x3066" L"\x7D9A" L"\x3051" L"\x3066" L"\x304F" 
    L"\x3060" L"\x3055" L"\x3044",

    L"Spiel konnte nicht\n"
    L"gespeichert werden", // DE

    L"Impossible de sauvegarder\n"
    L"la partie. Appuyer sur A\n"
    L"pour continuer.",// FR

    L"Fallo al guardar la partida.\n"
    L"Presione A para continuar.", // ES

    L"Impossibile salvare la\n"
    L"partita. Premere A per\n"
    L"continuare.", // IT
};

const WCHAR* const strGAME_SAVED[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Game Saved",
    L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x4FDD" 
    L"\x5B58" L"\x3057" L"\x307E" L"\x3057" L"\x305F",
    L"Spiel wurde gespeichert", // DE
    L"Partie sauvegard" L"\xE9" L"e", // FR
    L"Partida guardada", // ES
    L"Partita salvata", // IT
};

// TCR 6-5 Content Protection Fault
const WCHAR* const strLOAD_FAILED[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Unable to load game.\n"
    L"Press A to continue",

    L"", //need to get this string for JP

    L"Spiel konnte nicht\n"
    L"geladen werden", // DE

    L"Impossible de charger la\n"
    L"partie. Appuyer sur A pour\n"
    L"continuer.",// FR

    L"Fallo al cargar la partida.\n"
    L"Presione A para continuar.", // ES

    L"Impossibile caricare\n"
    L"la partita. Premere A\n"
    L"per continuare.", // IT
};

const WCHAR* const strGAME_LOADED[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Game Loaded",
    L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x8AAD" L"\x307F" 
    L"\x8FBC" L"\x307F" L"\x307E" L"\x3057" L"\x305F",
    L"Spiel wurde geladen", // DE
    L"Partie charg" L"\xE9" L"e", // FR
    L"Partida cargada", // ES
    L"Partita caricata", // IT
};

const WCHAR* const strNO_ROOM_MU[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"The memory unit does not\n"
    L"have enough free blocks\n"
    L"for this saved game.",

    L"\x4FDD" L"\x5B58" L"\x3057" L"\x305F" L"\x30B2" L"\x30FC" 
    L"\x30E0" L"\x3092" L"\x30D7" L"\x30EC" L"\x30A4" L"\x3059" 
    L"\x308B" L"\x306B" L"\x306F" L"\x3001" L"\n" L"\x30E1" L"\x30E2" 
    L"\x30EA" L"\x0020" L"\x30E6" L"\x30CB" L"\x30C3" L"\x30C8" 
    L"\x306E" L"\x7A7A" L"\x304D" L"\x30D6" L"\x30ED" L"\x30C3" 
    L"\x30AF" L"\x6570" L"\x304C" L"\x8DB3" L"\x308A" L"\x307E" 
    L"\x305B" L"\x3093" L"\x3002", //JP

    L"Die Speicher-Einheit hat nicht\n"
    L"gen" L"\xFC" L"gend freie Bl" L"\xF6" L"cke f" L"\xFC" L"r \n"
    L"diesen Spielstand.",// DE

    L"La Carte m" L"\xE9" L"moire ne\n"
    L"comporte pas assez de blocs\n"
    L"libres pour sauvegarder\n"
    L"la partie.",// FR

    L"La Unidad de Memoria no\n"
    L"dispone de suficientes\n"
    L"bloques libres para la\n"
    L"partida guardada.", // ES

    L"Sull'unit" L"\xE0" L" di memoria non\n"
    L"ci sono blocchi liberi sufficienti\n"
    L"per questo salvataggio.", // IT
};

const WCHAR* const strNO_ROOM_HD[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"The hard disk does not\n"
    L"have enough free blocks\n"
    L"for this saved game.",

    L"\x4FDD" L"\x5B58" L"\x3057" L"\x305F" L"\x30B2" L"\x30FC" 
    L"\x30E0" L"\x3092" L"\x30D7" L"\x30EC" L"\x30A4" L"\x3059" 
    L"\x308B" L"\x306B" L"\x306F" L"\x3001" L"\n" L"\x30CF" L"\x30FC" 
    L"\x30C9" L"\x0020" L"\x30C7" L"\x30A3" L"\x30B9" L"\x30AF" 
    L"\x306E" L"\x7A7A" L"\x304D" L"\x30D6" L"\x30ED" L"\x30C3" 
    L"\x30AF" L"\x6570" L"\x304C" L"\x8DB3" L"\x308A" L"\x307E" 
    L"\x305B" L"\x3093" L"\x3002",

    L"Die Festplatte hat nicht\n"
    L"gen" L"\xFC" L"gend\n freie Bl" L"\xF6" L"cke f" L"\xFC" L"r\n"
    L"diesen Spielstand.", // DE

    L"Le disque dur ne comporte\n"
    L"pas assez de blocs libres\n"
    L"pour sauvegarder la partie.", // FR

    L"El disco de memoria no dispone\n"
    L"de suficientes bloques libres\n"
    L"para la partida guardada", // ES

    L"Sul disco rigido non ci sono\n"
    L"blocchi liberi sufficienti\n"
    L"per questo salvataggio.", // IT
};

const WCHAR* const strNO_ROOM_MU_PLZ_FREE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"The memory unit does not\n"
    L"have enough free blocks for\n"
    L"this saved game.\n"
    L"%lu blocks must be free.",

    L"\x3053" L"\x306E" L"\x30E1" L"\x30E2" L"\x30EA" L"\x0020" 
    L"\x30E6" L"\x30CB" L"\x30C3" L"\x30C8" L"\x306B" L"\x306F" 
    L"\x3001" L"\x5FC5" L"\x8981" L"\x306A" L"\x7A7A" L"\x304D" 
    L"\x5BB9" L"\x91CF" L"\x304C" L"\x3042" L"\x308A" L"\x307E" 
    L"\x305B" L"\x3093" L"\x3002" L"\n %lu " L"\x30D6" L"\x30ED" 
    L"\x30C3" L"\x30AF" L"\x306E" L"\x7A7A" L"\x304D" L"\x5BB9" 
    L"\x91CF" L"\x3092" L"\x78BA" L"\x4FDD" L"\x3057" L"\x3066" 
    L"\x304F" L"\x3060" L"\x3055" L"\x3044" L"\x3002" L"\n A " 
    L"\x30DC" L"\x30BF" L"\x30F3" L"\x3092" L"\x62BC" L"\x3057" 
    L"\x3066" L"\x7D9A" L"\x3051" L"\x3066" L"\x304F" L"\x3060" 
    L"\x3055" L"\x3044" L"\x3002", //JP

    L"Auf dieser Speicher-Einheit ist\n"
    L"nicht gen" L"\xFC" L"gend Platz. Bitte\n"
    L"%lu Bl" L"\xF6" L"cke frei machen.",// DE

    L"La Carte m" L"\xE9" L"moire ne\n"
    L"comporte pas assez de blocs\n"
    L"libres. Il faut effacer\n"
    L"%lu blocs.", // FR

    L"La Unidad de Memoria no\n"
    L"dispone de suficientes\n"
    L"bloques libres. Se necesitan\n"
    L"%lu bloques. Presione\n"
    L"A para continuar.", // ES

    L"Sull'unit" L"\xE0" L" di memoria non\n"
    L"ci sono blocchi liberi sufficienti\n"
    L"per questo salvataggio.\n"
    L"Occorre liberare %lu blocchi.", // IT
};

const WCHAR* const strNO_ROOM_HD_PLZ_FREE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"The hard disk does not\n"
    L"have enough free blocks for\n"
    L"this saved game.\n"
    L"%lu blocks must be free.",

    L"\x3053" L"\x306E" L"\x30CF" L"\x30FC" L"\x30C9" L"\x0020" L"\x30C7" 
    L"\x30A3" L"\x30B9" L"\x30AF" L"\x306B" L"\x306F" L"\x3001" L"\x5FC5" 
    L"\x8981" L"\x306A" L"\x7A7A" L"\x304D" L"\x5BB9" L"\x91CF" L"\x304C" 
    L"\x3042" L"\x308A" L"\x307E" L"\x305B" L"\x3093" L"\x3002" L"\n %lu " 
    L"\x30D6" L"\x30ED" L"\x30C3" L"\x30AF" L"\x306E" L"\x7A7A" L"\x304D" 
    L"\x5BB9" L"\x91CF" L"\x3092" L"\x78BA" L"\x4FDD" L"\x3057" L"\x3066" 
    L"\x304F" L"\x3060" L"\x3055" L"\x3044" L"\x3002" L"\n A " L"\x30DC" 
    L"\x30BF" L"\x30F3" L"\x3092" L"\x62BC" L"\x3057" L"\x3066" L"\x7D9A"  
    L"\x3051" L"\x3066" L"\x304F" L"\x3060" L"\x3055" L"\x3044", //JP

    L"Auf dieser Festplatte ist nicht\n"
    L"gen" L"\xFC" L"gend Platz. Bitte %lu\n"
    L"Bl" L"\xF6" L"cke frei machen.",// DE

    L"Le disque dur ne comporte\n"
    L"pas assez de blocs libres.\n"
    L"Il faut effacer %lu blocs.", // FR

    L"El disco de memoria no\n"
    L"dispone de suficientes bloques\n"
    L"libres. Se necesitan %lu\n"
    L"bloques. Presione A para\n"
    L"continuar.", // ES

    L"Sul disco rigido non ci sono\n"
    L"blocchi liberi sufficienti per\n"
    L"questo salvataggio. Occorre\n"
    L"liberare %lu blocchi.", // IT
};

const WCHAR* const strNO_SAVES[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"No saved games",

    L"\x4FDD" L"\x5B58" L"\x3057" L"\x305F" L"\x30B2" L"\x30FC" L"\x30E0" 
    L"\x306F" L"\x3042" L"\x308A" L"\x307E" L"\x305B" L"\x3093",

    L"Kein Spielst" L"\xE4" L"nde vorhanden.",// DE

    L"Aucune partie sauvegard" L"\xE9" L"e", // FR

    L"No hay partidas guardadas", // ES

    L"Nessun salvataggio", // IT
};

// TCR 6-3 MU Read Warning
const WCHAR* const strLOADING[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Loading Game.\n",

    L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x8AAD" L"\x307F" L"\x8FBC" 
    L"\x307F" L"\x4E2D" L"\x3067" L"\x3059" L".\n",

    L"Spiel wird geladen.\n", // DE

    L"Chargement de la\n"
    L"partie en cours.\n", // FR

    L"Cargando partida.\n", // ES

    L"Caricamento partita in corso.\n", // IT
};


// TCR 6-2 MU Write Warning
const WCHAR* const strSAVING_MU[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Saving game to memory unit\n%s.\n",

    L"\x30E1" L"\x30E2" L"\x30EA" L" " L"\x30E6" L"\x30CB" L"\x30C3" L"\x30C8" 
	L"\x306B" L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x4FDD" L"\x5B58" L"\x4E2D" L"\n%s",

    L"Spiel wird auf\n"
    L"Speicher-Einheitgespeichert\n%s.\n", // DE

    L"Sauvegarde en cours sur\n"
    L"la Carte m" L"\x00E9" L"moire\n%s.\n", // FR

    L"Guardando partida en\n"
    L"unidad de memoria\n%s.\n", // ES

    L"Salvataggio su memory unit\n"
    L"in corso\n%s.\n", // IT
};

// TCR 6-4 Hard Disk Write Warning
const WCHAR* const strSAVING[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Saving Game.\n",

    L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x4FDD" L"\x5B58" L"\x4E2D" 
    L"\x3067" L"\x3059" L".\n",

    L"Spiel wird gespeichert.\n", // DE

    L"Sauvegarde de la\n"
    L"partie en cours.\n", // FR

    L"Guardando partida.\n", // ES

    L"Salvataggio partita in corso.\n", // IT
};

// TCR 6-2 MU Write Warning
// TCR 6-3 MU Read Warning
const WCHAR* const strDO_NOT_REMOVE_MU[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Please don't remove memory\n"
    L"units or disconnect any\n"
    L"controllers.",

    L"\x30E1" L"\x30E2" L"\x30EA" L"\x0020" L"\x30E6" L"\x30CB" 
    L"\x30C3" L"\x30C8" L"\x3084" L"\x30B3" L"\x30F3" L"\x30C8" L"\x30ED" L"\n"
    L"\x30FC" L"\x30E9" L"\x3092" L"\x53D6" L"\x308A" L"\x5916" L"\x3055" 
    L"\x306A" L"\x3044" L"\x3067" L"\x304F" L"\x3060" L"\x3055" L"\x3044" L"\x3002",

    L"Bitte entfernen Sie keine\n"
    L"Speicher-Einheiten und\n"
    L"keine Controller.",// DE

    L"Ne pas retirer de Carte\n"
    L"m" L"\xE9" L"moire ou d" L"\xE9" L"connecter\n"
    L"de manette.", // FR

    L"No retire las Unidades de\n"
    L"Memoria ni desconecte\n"
    L"los controladores.", // ES

    L"Non rimuovere alcun\n"
    L"controller o unit" L"\xE0" L" di memoria.", // IT
};

// TCR 6-4 Hard Disk Write Warning
const WCHAR* const strDO_NOT_POWEROFF[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Please don't turn\n"
    L"off your Xbox console.\n",

    L"Xbox\n" L"\x306E" L"\x96FB" L"\x6E90" L"\x3092" 
    L"\x5207" L"\x3089" L"\x306A" L"\x3044" L"\x3067" L"\x304F" 
    L"\x3060" L"\x3055" L"\x3044" L"\x3002",  //JP

    L"Bitte schalten Sie\n"
    L"Ihre Xbox nicht aus.", // DE

    L"Ne pas " L"\xE9" L"teindre\n"
    L"la console Xbox.", // FR

    L"No apague la Xbox.", // ES

    L"Non spegnere Xbox.", // IT
};

const WCHAR* const strSAVE_GAME[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Save Game",
    L"\x30B2" L"\x30FC" L"\x30E0" L"\x306E" L"\x4FDD" L"\x5B58",
    L"Spiel speichern", // DE
    L"Sauvegarder la partie", // FR
    L"Guardar partida", // ES
    L"Salva partita", // IT
};

const WCHAR* const strLOAD_GAME[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Load Game",
    L"\x30B2" L"\x30FC" L"\x30E0" L"\x306E" L"\x8AAD" L"\x307F" L"\x8FBC" L"\x307F",
    L"Spiel laden", // DE
    L"Charger la partie", // FR
    L"Cargar partida", // ES
    L"Carica partita", // IT
};

const WCHAR* const strILLUS_GRAPHICS[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Sample graphics. Don't use in your game",

    L"\x30B5" L"\x30F3" L"\x30D7" L"\x30EB" L"\x0020" L"\x30B0" L"\x30E9" 
    L"\x30D5" L"\x30A3" L"\x30C3" L"\x30AF" L"\x3002" L"\n" L"\x4F5C" 
    L"\x6210" L"\x3059" L"\x308B" L"\x30B2" L"\x30FC" L"\x30E0" L"\x3067" 
    L"\x4F7F" L"\x7528" L"\x3057" L"\x306A" L"\x3044" L"\x3067" L"\x304F" 
    L"\x3060" L"\x3055" L"\x3044",
    
    L"Beispiel-Grafik. Nicht im Spiel verwenden.",// DE
    
    L"Exemples de graphismes.\n"
    L"Ne pas utiliser dans votre jeu.", // FR
    
    L"Gr" L"\xE1" L"ficos de muestra.\n"
    L"No utilizar en la partida.", // ES
    
    L"Immagine dimostrativa. Da non\n"
    L"utilizzare per i giochi da\n"
    L"voi sviluppati.", // IT
};

const WCHAR* const strFORMAT_DEVICE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Total blocks\n%hs\n"
    L"Available blocks\n%hs",

    L"\x7DCF" L"\x30D6" L"\x30ED" L"\x30C3" L"\x30AF" L"\x6570" L"\n%hs\n" 
    L"\x5229" L"\x7528" L"\x53EF" L"\x80FD" L"\x30D6" L"\x30ED" L"\x30C3" 
    L"\x30AF" L"\x6570" L"\n%hs",

    L"Gesamtzahl Bl" L"\xF6" L"cke\n%hs\n"
    L"Verf" L"\xFC" L"gbare Bl" L"\xF6" L"cke\n%hs", //DE

    L"Nombre de blocs\n%hs\n"
    L"Blocs disponibles\n%hs", // FR

    L"Bloques totales\n%hs\n"
    L"Bloques libres\n%hs", // ES

    L"Blocchi totali\n%hs\n"
    L"Blocchi liberi\n%hs", // IT
};

const WCHAR* const strCHOOSE_LOAD[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Choose memory device to load game",

    L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x8AAD" L"\x307F" 
    L"\x8FBC" L"\x3080" L"\x30E1" L"\x30E2" L"\x30EA" L"\x0020" 
    L"\x30C7" L"\x30D0" L"\x30A4" L"\x30B9" L"\x3092" L"\x9078" 
    L"\x629E" L"\x3057" L"\x3066" L"\x304F" L"\x3060" L"\x3055" L"\x3044",

    L"Speichermedium w" L"\xE4" L"hlen, um Spiel zu laden",// DE

    L"Choisir un emplacement pour charger la partie", // FR

    L"Elija un dispositivo de memoria para cargar la partida", // ES

    L"Scegliere la periferica di memoria da cui caricare il gioco", // IT
};

const WCHAR* const strCHOOSE_SAVE[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Choose memory device to save game",

    L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x4FDD" L"\x5B58" L"\x3059" 
    L"\x308B" L"\x30E1" L"\x30E2" L"\x30EA" L"\x0020" L"\x30C7" L"\x30D0" 
    L"\x30A4" L"\x30B9" L"\x3092" L"\x9078" L"\x629E" L"\x3057" L"\x3066" 
    L"\x304F" L"\x3060" L"\x3055" L"\x3044",

    L"Speichermedium w" L"\xE4" L"hlen, um Spiel zu speichern",// DE

    L"Choisir un emplacement pour sauvegarder la partie", // FR

    L"Elija un dispositivo de memoria para guardar la partida", // ES

    L"Scegliere su quale dispositivo di memoria si vuole salvare la partita", // IT
};

const WCHAR* const strTODAY[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Today",
    L"\x4ECA" L"\x65E5", 
    L"Heute", // DE
    L"Aujourd'hui", // FR
    L"Hoy", // ES
    L"Oggi", // IT
};

const WCHAR* const strNOW[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Now",
    L"L\x73FE" L"\x5728",
    L"Jetzt", // DE
    L"Maintenant", // FR
    L"Ahora", // ES
    L"Ora", // IT
};

const WCHAR* const strFORMAT_GAME[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Name: %s\nBlocks: %hs\n"
    L"Date: %s\nTime: %s",

    L"\x540D" L"\x524D" L" : %s\n" L"\x30D6" L"\x30ED" L"\x30C3" 
    L"\x30AF" L" : %hs\n" L"\x65E5" L"\x4ED8"  L": %s\n" 
    L"\x6642" L"\x523B" L" : %s",

    L"Name: %s\nBl" L"\xF6" L"cke: %hs\n"
    L"Datum: %s\nZeit: %s",// DE

    L"Nom: %s\nBlocs: %hs\n"
    L"Date: %s\nHeure: %s", // FR

    L"Nombre: %s\nBloques: %hs\n"
    L"Fecha: %s\nHora: %s", // ES

    L"Nome: %s\nBlocchi: %hs\n"
    L"Data: %s\nOra: %s", // IT
};

const WCHAR* const strEMPTY_SPACE[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Empty Space",
    L"\x7A7A" L"\x304D" L"\x5BB9" L"\x91CF",
    L"Freier Platz", // DE
    L"M" L"\xE9" L"moire disponible", // FR
    L"Espacio vac" L"\xED" L"o", // ES
    L"Spazio libero", // IT
};

const WCHAR* const strA_SELECT[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"select",
    L"\x9078" L"\x629E",
    L"ausw" L"\xE4" L"hlen", // DE
    L"s" L"\xE9" L"lectionner", // FR               
    L"seleccionar", // ES
    L"scegli", // IT
};

const WCHAR* const strB_BACK[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"back",
    L"\x623B" L"\x308B",
    L"zur" L"\xFC" L"ck", // DE
    L"retour", // FR
    L"volver", // ES
    L"indietro", // IT
};

const WCHAR* const strY_DELETE[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"delete",
    L"\x524A" L"\x9664",
    L"l" L"\xF6" L"schen", // DE
    L"supprimer", // FR
    L"eliminar", // ES
    L"cancella", // IT
};

const WCHAR* const strOVERWRITE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Overwrite saved game?",

    L"\x4FDD" L"\x5B58" L"\x3057" L"\x305F" L"\x30B2" L"\x30FC" 
    L"\x30E0" L"\x3092" L"\x4E0A" L"\x66F8" L"\x304D" L"\x3057" 
    L"\x307E" L"\x3059" L"\x304B" L"\003F",

    L"Spielstand " L"\xFC" L"berschreiben?", //DE
    
    L"\xC9" L"craser la partie\n"
    L"sauvegard" L"\xE9" L"e ?", // FR

    L"\xBF" L"Desea sobrescribir\n"
    L"la partida guardada?", // ES

    L"Si vuole sovrascrivere\n"
    L"il salvataggio?", // IT
};

const WCHAR* const strYES[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Yes",
    L"\x306F" L"\x3044",
    L"Ja", // DE
    L"Oui", // FR
    L"S" L"\xED" L"", // ES
    L"S" L"\xEC" L"", // IT
};

const WCHAR* const strNO[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"No",
    L"\x3044" L"\x3044" L"\x3048",
    L"Nein", // DE
    L"Non", // FR
    L"No", // ES
    L"No", // IT
};

const WCHAR* const strDELETE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Delete saved game?",

    L"\x4FDD" L"\x5B58" L"\x3057" L"\x305F" L"\x30B2" L"\x30FC" 
    L"\x30E0" L"\x3092" L"\x524A" L"\x9664" L"\x3057" L"\x307E" 
    L"\x3059" L"\x304B" L"\003F",

    L"Spielstand l" L"\xF6" L"schen?", //DE
    
    L"Supprimer la partie\n"
    L"sauvegard" L"\xE9" L"e ?", // FR

    L"\xBF" L"Desea eliminar\n"
    L"la partida guardada?", // ES

    L"Si vuole eliminare\n"
    L"il salvataggio?", // IT
};

const WCHAR* const strLOADING_GAME_LIST[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"Loading game list",

    L"\x30B2" L"\x30FC" L"\x30E0" L"\x306E" L"\x4E00" L"\x89A7" L"\x3092" 
    L"\x8AAD" L"\x307F" L"\x8FBC" L"\x307F" L"\x4E2D" L"\x3067" L"\x3059",

    L"Spieleliste wird geladen", // DE

    L"Chargement de la liste\n"
    L"des parties", // FR

    L"Cargando lista\n"
    L"de partidas", // ES

    L"Caricamento elenco\n"
    L"partite in corso", // IT
};

const WCHAR* const strMAX_SAVED_GAMES[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"There is a maximum of\n"
    L"4,096 saved games.",

    L"\x3053" L"\x306E" L"\x30C7" L"\x30D0" L"\x30A4" L"\x30B9" 
    L"\x306B" L"\x306F" L" 4097 " L"\x4EF6" L"\x4EE5" L"\x4E0A" 
    L"\x306E" L"\x30B2" L"\x30FC" L"\x30E0" L"\x3092" L"\x4FDD" 
    L"\x5B58" L"\x3059" L"\x308B" L"\x3053" L"\x3068" L"\x306F" 
    L"\x3067" L"\x304D" L"\x307E" L"\x305B" L"\x3093" L"\x3002",  //JP  Needs to be updated.

    L"Speichern von mehr als 4.096\n"
    L"Spielen auf diesem Medium\n"
    L"nicht m" L"\xF6" L"glich.", //DE
    
    L"Impossible de sauvegarder\n"
    L"plus de 4 096 parties sur\n"
    L"le disque dur.", // FR

    L"No puede guardar m" L"\xE1" L"s\n"
    L"de 4.096 partidas en este\n"
    L"dispositivo.", // ES

    L"Questa periferica non pu" L"\xF2" L" \n"
    L"contenere pi" L"\xF9" L" di 4.096 salvataggi.", // IT
};

const WCHAR* const strMU_UNUSABLE[ XC_LANGUAGE_MAX ] = 
{
    L"",

    L"This memory unit is unusable",

    L"\x3053" L"\x306E" L"\x30E1" L"\x30E2" L"\x30EA" L"\x0020" L"\x30E6" 
    L"\x30CB" L"\x30C3" L"\x30C8" L"\x306F" L"\x52D5" L"\x4F5C" L"\x3057" 
    L"\x3066" L"\x3044" L"\x307E" L"\x305B" L"\x3093" L"\x3002" L"\n" L"\x30E1" 
    L"\x30E2" L"\x30EA" L"\x0020" L"\x30E6" L"\x30CB" L"\x30C3" L"\x30C8" 
    L"\x304C" L"\x7834" L"\x640D" L"\x3057" L"\x3066" L"\x3044" L"\x308B" 
    L"\x53EF" L"\x80FD" L"\x6027" L"\x304C" L"\x3042" L"\x308A" L"\x307E" 
    L"\x3059" L"\x3002",

    L"Diese Speicher-Einheit\n"
    L"funktioniert nicht. M" L"\xF6" L"glicher-\n"
    L"weise ist sie defekt.", //DE
    
    L"Cette Carte m" L"\xE9" L"moire ne\n"
    L"fonctionne pas. Elle est\n"
    L"peut-" L"\xEA" L"tre endommag" L"\xE9" L"e.", // FR

    L"La Unidad de Memoria no\n"
    L"funciona. Podr" L"\xED" L"a estar\n"
    L"da" L"\xF1" L"ada.", // ES

    L"Questa unit" L"\xE0" L" di memoria non\n"
    L"risponde: potrebbe essere\n"
    L"danneggiata.", // IT
};

const WCHAR* const strMU_FULL[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"This memory unit is full",

    L"\x30E1" L"\x30E2" L"\x30EA" L" " L"\x30E6" L"\x30CB" L"\x30C3" 
	L"\x30C8" L"\x304C" L"\x3044" L"\x3063" L"\x3071" L"\x3044" L"\x3067" L"\x3059" , // JP

    L"Diese Speicher-Einheit ist voll", // DE
    L"La Carte m" L"\x00E9"  L"moire est pleine", // FR
    L"Esta unidad de memoria est" L"\x00E1" L"llena", // ES
    L"Questa memory unit " L"\x00E8" L"piena", // IT
};

const WCHAR* const strUNUSABLE_MU_NAME[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Unusable Xbox MU",
    L"\x7834" L"\x640D" L"\x3057" L"\x305F" L" Xbox " L"\x30E1" 
    L"\x30E2" L"\x30EA" L"\x0020" L"\x30E6" L"\x30CB" L"\x30C3" L"\x30C8",
    L"Xbox-SE besch" L"\xE4" L"digt", // DE
    L"CM Xbox endommag" L"\xE9" L"e", // FR
    L"UM de la Xbox da" L"\xF1" L"ada", // ES
    L"UM Xbox danneggiata", // IT
};

const WCHAR* const strFULL_MU_NAME[ XC_LANGUAGE_MAX ] = 
{
    L"",
    L"Full Xbox MU",

    L"\x7A7A" L"\x304D" L"\x5BB9" L"\x91CF" L"\x304C" L"\x306A" L"\x3044" 
	L" Xbox " L"\x30E1" L"\x30E2" L"\x30EA" L" " L"\x30E6" L"\x30CB" L"\x30C3" L"\x30C8",

    L"Xbox-SE voll.", // DE
    L"CM Xbox pleine", // FR
    L"UM Xbox llena", // ES
    L"MU Xbox piena", // IT
};

// TCR 6-1 Surprise MU Removal!
const WCHAR* const strMU_REMOVED[ XC_LANGUAGE_MAX ] =
{
    L"",

    L"%s\nwas removed during use.\n"
    L"%s failed.\n"
    L"Press A to continue.",

    L"%s " L"\x304C" L"\x4F7F" L"\x7528" L"\x4E2D" L"\x306B" L"\x53D6" 
    L"\x308A" L"\x5916" L"\x3055" L"\x308C" L"\x307E" L"\x3057" L"\x305F" 
    L"\x3002" L"\n%s " L"\x3067" L"\x554F" L"\x984C" L"\x304C" L"\x767A" 
    L"\x751F" L"\x3057" L"\x307E" L"\x3057" L"\x305F" L"\x3002" L"\n A "  
    L"\x30DC" L"\x30BF" L"\x30F3" L"\x3092" L"\x62BC" L"\x3057" L"\x3066" 
    L"\x7D9A" L"\x3051" L"\x3066" L"\x304F" L"\x3060" L"\x3055" L"\x3044" L"\x3002",

    L"%s\nwurde w" L"\xE4" L"hrend Benutzung\n"
    L"entfernt. %s ist\n"
    L"fehlgeschlagen. Weiter\n"
    L"mit A-Taste.", // DE

    L"%s\na " L"\xE9" L"t" L"\xE9" L" retir" L"\xE9" L"e de mani" L"\xE8" L"re\n"
    L"intempestive. %s\n"
    L"a " L"\xE9" L"chou" L"\xE9" L". Appuyer sur A\n"
    L"pour continuer.", // FR

    L"%s\nse ha extra" L"\xED" L"do mientras\n"
    L"estaba en uso. Error\n"
    L"de %s. Presione A\n"
    L"para continuar.", // ES

    L"%s\nrimosso durante l'uso.\n"
    L"Errore di %s. Premere\n"
    L"A per continuare.", // IT
};

const WCHAR* const strACTION_SAVE[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Save",
    L"\x4FDD" L"\x5B58",
    L"Speichern", // DE
    L"Sauvegarder", // FR
    L"Guardar", // ES
    L"Salva", // IT
};

const WCHAR* const strACTION_LOAD[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Load",
    L"\x8AAD" L"\x307F" L"\x8FBC" L"\x307F",
    L"Laden", // DE
    L"Charger", // FR
    L"Cargar", // ES
    L"Carica", // IT
};

const CHAR* const strMAX_BLOCKS[ XC_LANGUAGE_MAX ] =
{
    "",
    "50,000+",
    "50,000+", // JP
    "50.000+", // DE
    "50 000+", // FR
    "50.000+", // ES
    "50.000+", // IT
};

const WCHAR* const strXHD[ XC_LANGUAGE_MAX ] =
{
    L"",
    L"Xbox Hard Disk",
    L"Xbox Hard Disk", // JP
    L"Xbox Festplatte", // DE
    L"Xbox Disque", // FR
    L"Xbox Disco", // ES
    L"Xbox Disco Rigido", // IT
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Vehicle.h ===
//-----------------------------------------------------------------------------
// File: Vehicle.h
//
// Desc: Vehicle object
//
// Hist: 03.14.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_VEHICLE_H
#define TECH_CERT_GAME_VEHICLE_H

#include "Common.h"
#include "PhysicsObject.h"




//-----------------------------------------------------------------------------
// Name: class Vehicle
// Desc: Vehicle object
//-----------------------------------------------------------------------------
class Vehicle : public PhysicsObject
{
public:
	Vehicle( PhysicsSystem*, const Vector3& v3Pos, const Quaternion& qRot, 
             const Vector3* v3Supports, const FLOAT* fSupportLength);

	// Also add constraints for the vehicle.
	virtual void AddConstraints(float time);

	// Compute force and torque acting on the vehicle.
	virtual void ComputeForceAndTorque(float time);

	inline void SetTurnAngle(float angle)
	{
		m_fTurnAngle = angle;
	}

	inline void SetSpeedControl(float speed)
	{
		m_fSpeedControl = speed;
	}

	inline float GetTurnAngle()
	{
		return m_fTurnAngle;
	}

	inline float GetSupportLength(int i)
	{
		return m_fCurrentSupportLength[i];
	}

protected:
	int m_iNumSupports;
	Vector3 m_v3SupportOffset[4];

	float m_fSupportLength[4];
	float m_fCurrentSupportLength[4];

	Vector3 m_v3ContactPoint[4];
	float m_fContactT[4];

	float m_fTurnAngle;
	float m_fSpeedControl;

private:

    // Disabled
    Vehicle();
};




#endif // TECH_CERT_GAME_VEHICLE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Text.h ===
//-----------------------------------------------------------------------------
// File: Text.cpp
//
// Desc: All text in single place to simplify localization
//
// Hist: 04.16.01 - Added for May XDK release 
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TECH_CERT_GAME_TEXT_H
#define TECH_CERT_GAME_TEXT_H

#include "Common.h"




const UINT XC_LANGUAGE_MAX = XC_LANGUAGE_ITALIAN + 1;




extern const WCHAR* const strGAME_NAME_FORMAT   [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strSUNDAY             [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMONDAY             [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strTUESDAY            [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strWEDNESDAY          [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strTHURSDAY           [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strFRIDAY             [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strSATURDAY           [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strRECONNECT_CNTRLR   [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strCONFIRM_QUIT       [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strDEMO               [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strRETURN_TO_MENU     [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strGAME_NAME          [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strLOADINGX           [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strFREE               [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_START         [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_LOAD          [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_OPTIONS       [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_RESUME        [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_SAVE          [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_QUIT          [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_VIBRATION     [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_SAVE_OPTIONS  [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strON                 [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strOFF                [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_MUSIC_VOLUME  [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMENU_EFFECT_VOLUME [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMS_XBOX            [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strINTRO              [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strPRESS_START        [ XC_LANGUAGE_MAX ];

extern const WCHAR* const strSAVE_FAILED        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strGAME_SAVED         [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strLOAD_FAILED        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strGAME_LOADED        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_ROOM_MU         [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_ROOM_HD         [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_ROOM_MU_PLZ_FREE[ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_ROOM_HD_PLZ_FREE[ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO_SAVES           [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strLOADING            [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strSAVING_MU          [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strSAVING             [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strDO_NOT_REMOVE_MU   [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strDO_NOT_POWEROFF    [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strSAVE_GAME          [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strLOAD_GAME          [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strILLUS_GRAPHICS     [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strFORMAT_DEVICE      [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strCHOOSE_LOAD        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strCHOOSE_SAVE        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strTODAY              [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNOW                [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strFORMAT_GAME        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strEMPTY_SPACE        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strA_SELECT           [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strB_BACK             [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strY_DELETE           [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strOVERWRITE          [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strYES                [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strNO                 [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strDELETE             [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strLOADING_GAME_LIST  [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strMAX_SAVED_GAMES    [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strMU_UNUSABLE        [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strMU_FULL            [ XC_LANGUAGE_MAX ]; 
extern const WCHAR* const strUNUSABLE_MU_NAME   [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strFULL_MU_NAME       [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strMU_REMOVED         [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strACTION_SAVE        [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strACTION_LOAD        [ XC_LANGUAGE_MAX ];
extern const  CHAR* const strMAX_BLOCKS         [ XC_LANGUAGE_MAX ];
extern const WCHAR* const strXHD                [ XC_LANGUAGE_MAX ];




#endif // TECH_CERT_GAME_TEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\obj\i386\Font16.h ===
// Automatically generated by the bundler tool from Font16.rdf

#define Font16_NUM_RESOURCES 2UL

#define Font16_Font_OFFSET 0UL
#define Font16_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\obj\i386\Font9.h ===
// Automatically generated by the bundler tool from Font9.rdf

#define Font9_NUM_RESOURCES 2UL

#define Font9_Font_OFFSET 0UL
#define Font9_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\obj\i386\LoadSaveResource.h ===
// Automatically generated by the bundler tool from LoadSaveResource.rdf

#define LoadSaveResource_NUM_RESOURCES 11UL

#define LoadSaveResource_Background_OFFSET 0UL
#define LoadSaveResource_PlainBack_OFFSET 20UL
#define LoadSaveResource_Up_OFFSET 40UL
#define LoadSaveResource_Down_OFFSET 60UL
#define LoadSaveResource_MsgBox_OFFSET 80UL
#define LoadSaveResource_MU_OFFSET 100UL
#define LoadSaveResource_MUWide_OFFSET 120UL
#define LoadSaveResource_MU_Sel_OFFSET 140UL
#define LoadSaveResource_Xbox_OFFSET 160UL
#define LoadSaveResource_Xbox_Sel_OFFSET 180UL
#define LoadSaveResource_MU_Bad_OFFSET 200UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\Xboxdings_24.h ===
// Automatically generated by the bundler tool from Xboxdings_24.rdf

#define Xboxdings_24_NUM_RESOURCES 2UL

#define Xboxdings_24_Font_OFFSET 0UL
#define Xboxdings_24_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\obj\i386\MenuResource.h ===
// Automatically generated by the bundler tool from MenuResource.rdf

#define MenuResource_NUM_RESOURCES 1UL

#define MenuResource_MenuSelect_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\cert\game\obj\i386\Xboxdings_24.h ===
// Automatically generated by the bundler tool from Xboxdings_24.rdf

#define Xboxdings_24_NUM_RESOURCES 2UL

#define Xboxdings_24_Font_OFFSET 0UL
#define Xboxdings_24_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbConfig.h ===
//-----------------------------------------------------------------------------
// File: XbConfig.h
//
// Desc: Config object wraps XQueryValue
//
// Hist: 03.02.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBCONFIG_H
#define XBCONFIG_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBConfig
// Desc: Xbox configuration parameters
//-----------------------------------------------------------------------------
class CXBConfig
{
    static DWORD mLanguage; // cached for speed

public:

    static DWORD GetLanguage();

    // Localized dates, times and numbers
    static VOID FormatDateTime( const FILETIME&, WCHAR* strDate, WCHAR* strTime,
                                BOOL bIncludeSeconds = FALSE );
    static VOID FormatInt( INT, CHAR* strNumber );
    static VOID FormatFloat( DOUBLE, CHAR* strNumber, INT nCount = 2,
                             BOOL bThousandsSep = TRUE );

    // Symbols based on current language
    static CHAR GetDecimalSymbol();
    static CHAR GetThousandsSeparator();
};




#endif // XBCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbapp.h ===
//-----------------------------------------------------------------------------
// File: XBApp.h
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class CXBApplication
// Desc: A base class for creating sample Xbox applications. To create a simple
//       Xbox application, simply derive this class and override the following
//       functions:
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class CXBApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize()            { return S_OK; }
    virtual HRESULT FrameMove()             { return S_OK; }
    virtual HRESULT Render()                { return S_OK; }
    virtual HRESULT Cleanup()               { return S_OK; }

public:
    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    CXBApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbinput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};




//-----------------------------------------------------------------------------
// Global access to input states
//-----------------------------------------------------------------------------
extern XINPUT_STATE g_InputStates[4];




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbMediaDebug.h ===
//-----------------------------------------------------------------------------
// File: XbMediaDebug.h
//
// Desc: Miscellaneous functions to aid debugging of media/graphics/etc.
//
// Hist: 11.01.01 - New for November 2001 XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

// NOTES:
//
// * Most of these functions are designed so that they can be called
//   via the the debugger watch window, which is often the most convenient
//   way to use them.
//
// * However, these routines might cause strange behavior if you're using a
//   D3D pure device, because many of them save/modify/restore device state.

#ifndef XBMEDIADEBUG_H
#define XBMEDIADEBUG_H

#include <xtl.h>
#include <xgraphics.h>


// Uncomment these lines and #include this header in your code (or just add
// these lines directly to your code) to force the linker to include the
// specified symbol(s).
//
// This is useful for making sure functions don't get optimized-out when
// linking.  It ensures you'll be able to call the functions via the debugger
// watch window, even if you never called the routines in your code.
///#pragma comment( linker, "/include:_DebugPixels" )


#ifdef __cplusplus
extern "C" {
#endif


///////////////////////////////////////////////////////////////////////////////
// BUFFER CLEARING
///////////////////////////////////////////////////////////////////////////////
extern D3DXCOLOR g_DebugClearColor; // bkgrnd color when this lib clears screen


///////////////////////////////////////////////////////////////////////////////
// TEXTURE/SURFACE DEBUGGING
///////////////////////////////////////////////////////////////////////////////
extern bool g_bDebugShrinkToFit;  // decrease size (if necess) to fit screen
extern bool g_bDebugExpandToFit;  // increase size (if necess) to fill screen
extern bool g_bDebugAlpha;  // view the alpha channel when rendering

//-----------------------------------------------------------------------------
// Name: DebugPixels
// Desc: Displays a pTexture or pSurface (you can pass-in either one here).
//       For convenience, you can also pass-in special pre-defined values for
//       convenient access to common surfaces:
//          1 == 1st back-color-buffer (note: differs from GetBackBuffer param)
//          2 == 2nd back-color-buffer
//          N == Nth back-color-buffer
//         -1 == depth-stencil-buffer
// Note: This function can be called via the debugger watch window, in which
//       case it will be executed with each step through the code.
//-----------------------------------------------------------------------------
HRESULT __cdecl DebugPixels( void* pTextureOrSurface, UINT iLevel = 0 );



#ifdef __cplusplus
};
#endif

#endif // XBMEDIADEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbhelp.h ===
//-----------------------------------------------------------------------------
// File: XBHelp.h
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.06.01 - Changes for April XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBHELP_H
#define XBHELP_H
#include "XBFont.h"
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: struct XBHELP_CALLOUT
// Desc: Structure for callout information, used to label controls when
//       rendering an image of an Xbox gamepad. An app will define an array of
//       of these, one for each gamepad control used.
//-----------------------------------------------------------------------------
struct XBHELP_CALLOUT
{
    WORD     wControl;    // An index to identify a control, as enum'ed below
    WORD     wPlacement;  // An offset to pick from one of the possible placements
    WCHAR*   strText;     // Text to draw when rendering this callout
};




//-----------------------------------------------------------------------------
// Name: class CXBHelp
// Desc: Class for rendering a help image of a gamepad with labelled callouts.
//-----------------------------------------------------------------------------
class CXBHelp
{
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pGamepadTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVB;

public:
    // Constructor/destructor
    CXBHelp();
    ~CXBHelp();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* pResource );
    HRESULT Destroy();

    // Renders the help screen
    HRESULT Render( CXBFont* pFont, XBHELP_CALLOUT* tags, DWORD dwNumCallouts );
};




//-----------------------------------------------------------------------------
// A bunch of constants used to identify callout positions
//-----------------------------------------------------------------------------
enum
{   
    XBHELP_LEFTSTICK,
    XBHELP_LEFTSTICK_LINEEND_1, XBHELP_LEFTSTICK_TEXTPOS_1,
    XBHELP_LEFTSTICK_LINEEND_2, XBHELP_LEFTSTICK_TEXTPOS_2,

    XBHELP_RIGHTSTICK,
    XBHELP_RIGHTSTICK_LINEEND_1, XBHELP_RIGHTSTICK_TEXTPOS_1,
    XBHELP_RIGHTSTICK_LINEEND_2, XBHELP_RIGHTSTICK_TEXTPOS_2,

    XBHELP_DPAD,
    XBHELP_DPAD_LINEEND_1, XBHELP_DPAD_TEXTPOS_1,
    XBHELP_DPAD_LINEEND_2, XBHELP_DPAD_TEXTPOS_2,

    XBHELP_BACK_BUTTON,
    XBHELP_BACK_BUTTON_LINEEND_1, XBHELP_BACK_BUTTON_TEXTPOS_1,
    XBHELP_BACK_BUTTON_LINEEND_2, XBHELP_BACK_BUTTON_TEXTPOS_2,

    XBHELP_START_BUTTON,
    XBHELP_START_BUTTON_LINEEND_1, XBHELP_START_BUTTON_TEXTPOS_1,
    XBHELP_START_BUTTON_LINEEND_2, XBHELP_START_BUTTON_TEXTPOS_2,

    XBHELP_X_BUTTON,
    XBHELP_X_BUTTON_LINEEND_1, XBHELP_X_BUTTON_TEXTPOS_1,
    XBHELP_X_BUTTON_LINEEND_2, XBHELP_X_BUTTON_TEXTPOS_2,

    XBHELP_Y_BUTTON,
    XBHELP_Y_BUTTON_LINEEND_1, XBHELP_Y_BUTTON_TEXTPOS_1,
    XBHELP_Y_BUTTON_LINEEND_2, XBHELP_Y_BUTTON_TEXTPOS_2,

    XBHELP_A_BUTTON,
    XBHELP_A_BUTTON_LINEEND_1, XBHELP_A_BUTTON_TEXTPOS_1,
    XBHELP_A_BUTTON_LINEEND_2, XBHELP_A_BUTTON_TEXTPOS_2,

    XBHELP_B_BUTTON,
    XBHELP_B_BUTTON_LINEEND_1, XBHELP_B_BUTTON_TEXTPOS_1,
    XBHELP_B_BUTTON_LINEEND_2, XBHELP_B_BUTTON_TEXTPOS_2,

    XBHELP_WHITE_BUTTON,
    XBHELP_WHITE_BUTTON_LINEEND_1, XBHELP_WHITE_BUTTON_TEXTPOS_1,
    XBHELP_WHITE_BUTTON_LINEEND_2, XBHELP_WHITE_BUTTON_TEXTPOS_2,

    XBHELP_BLACK_BUTTON,
    XBHELP_BLACK_BUTTON_LINEEND_1, XBHELP_BLACK_BUTTON_TEXTPOS_1,
    XBHELP_BLACK_BUTTON_LINEEND_2, XBHELP_BLACK_BUTTON_TEXTPOS_2,

    XBHELP_LEFT_BUTTON,
    XBHELP_LEFT_BUTTON_LINEEND_1, XBHELP_LEFT_BUTTON_TEXTPOS_1,
    XBHELP_LEFT_BUTTON_LINEEND_2, XBHELP_LEFT_BUTTON_TEXTPOS_2,

    XBHELP_RIGHT_BUTTON,
    XBHELP_RIGHT_BUTTON_LINEEND_1, XBHELP_RIGHT_BUTTON_TEXTPOS_1,
    XBHELP_RIGHT_BUTTON_LINEEND_2, XBHELP_RIGHT_BUTTON_TEXTPOS_2,

    XBHELP_MISC_CALLOUT,
    XBHELP_MISC_CALLOUT_LINEEND_1, XBHELP_MISC_CALLOUT_TEXTPOS_1,
    XBHELP_MISC_CALLOUT_LINEEND_2, XBHELP_MISC_CALLOUT_TEXTPOS_2,
};




//-----------------------------------------------------------------------------
// Placement options for each callout, used as an offset into the enumerated
// list above.
//-----------------------------------------------------------------------------
#define XBHELP_PLACEMENT_CUSTOM 0   // For future implementation
#define XBHELP_PLACEMENT_1      1   // Callout has one line of text
#define XBHELP_PLACEMENT_2      2   // Callout has two lines of text




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbMemUnit.h ===
//-----------------------------------------------------------------------------
// File: XbMemUnit.h
//
// Desc: Memory unit object wraps XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT )
//       and XMount/UnmountMU
//
// Hist: 01.29.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBMEMUNIT_H
#define XBMEMUNIT_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBMemUnit
// Desc: Xbox memory unit
//-----------------------------------------------------------------------------
class CXBMemUnit
{
    static const DWORD dwINVALID = DWORD(-1);

    DWORD m_dwPort;           // XDEVICE_PORT0-3
    DWORD m_dwSlot;           // XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT
    CHAR  m_chLogicalDrive;   // MU drive letter alias; 0 if not mounted

public:

    explicit CXBMemUnit( DWORD dwPort = dwINVALID, DWORD dwSlot = dwINVALID );
    CXBMemUnit( const CXBMemUnit& );
    CXBMemUnit& operator=( const CXBMemUnit& );
    virtual ~CXBMemUnit();

    VOID  Insert( DWORD dwPort, DWORD dwSlot );
    BOOL  Mount( DWORD& dwError );
    VOID  Unmount();
    VOID  Remove();

    BOOL  IsValid() const;
    BOOL  IsMounted() const;
    CHAR  GetDrive() const;
    DWORD GetPort() const;
    DWORD GetSlot() const;
    VOID  GetName( WCHAR* ) const;

    static DWORD GetMemUnitSnapshot();
    static BOOL  GetMemUnitChanges( DWORD& dwInsertions, DWORD& dwRemovals );

    static DWORD GetMemUnitMask( DWORD dwMuIndex );
    static DWORD GetMemUnitPort( DWORD dwMuIndex );
    static DWORD GetMemUnitSlot( DWORD dwMuIndex );
};

#endif // XBMEMUNIT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbnet.h ===
//-----------------------------------------------------------------------------
// File: XbNet.h
//
// Desc: Shortcut macros and helper functions for the Xbox networking samples
//       Requires linking with XNET[D][S].LIB or XONLINE[D][S].LIB
//
// Hist: 09.06.01 - New for November XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBNET_H
#define XBNET_H

#include <xtl.h>
#include "XBStopWatch.h"
#include <xonline.h>



//-----------------------------------------------------------------------------
// Name: XBNet_Init() / XBNet_Cleanup()
// Desc: Performs all required initialization/shutdown for  
//       network play
//-----------------------------------------------------------------------------
HRESULT XBNet_Init( BYTE cfgFlags = 0 );
HRESULT XBNet_Cleanup();




//-----------------------------------------------------------------------------
// Name: XBNet_OnlineInit() / XBNet_OnlineCleanup()
// Desc: Performs all required initialization/shutdown for online and 
//       network play
//-----------------------------------------------------------------------------
HRESULT XBNet_OnlineInit( BYTE cfgFlags = 0, 
						  PXONLINE_STARTUP_PARAMS pxosp = NULL );
HRESULT XBNet_OnlineCleanup();




//-----------------------------------------------------------------------------
// Name: class CXBNetLink
// Desc: Xbox network link
//-----------------------------------------------------------------------------
class CXBNetLink
{
    mutable CXBStopWatch m_LinkStatusTimer;

public:

    CXBNetLink();
    BOOL IsActive() const;
};




#endif // XBNET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbNetMsg.h ===
//-----------------------------------------------------------------------------
// File: XbNetMsg.h
//
// Desc: Simple "waving" game messages to show Xbox communication.
//       Requires linking with XNET[D][S].LIB or XONLINE[D][S].LIB
//
// Hist: 10.20.01 - New for November XDK release
//       02.15.02 - Updated for Mar release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBNETMSG_H
#define XBNETMSG_H

#include <xtl.h>
#include "XBSocket.h"
#include "XBSockAddr.h"

#pragma warning( disable: 4786 )
#include <vector>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
// matches XONLINE_USERNAME_SIZE for consistency
const DWORD MAX_PLAYER_STR = 28; 
const DWORD MAX_PLAYERS    = 4;  // Game dependent




//-----------------------------------------------------------------------------
// Message IDs
//
// A "host" is the player who started the game.
// A "client" is a potential player. A client is not currently playing a game.
// A "player" is anyone playing a game.
//-----------------------------------------------------------------------------
enum
{                       // From     To      Type        Expected response
                        //-----------------------------------------------------
    MSG_JOIN_GAME,      // client   host    direct      MSG_JOIN_APPROVED/DENIED
    MSG_JOIN_APPROVED,  // host     client  direct      <none>
    MSG_JOIN_DENIED,    // host     client  direct      <none>
    MSG_PLAYER_JOINED,  // host     player  direct      <none>
    MSG_WAVE,           // player   player  direct      <none>
    MSG_HEARTBEAT       // player   player  direct      <none>
};




//-----------------------------------------------------------------------------
// Message payloads
//-----------------------------------------------------------------------------
// Pack to minimize network traffic
#pragma pack( push )
#pragma pack( 1 )




//-----------------------------------------------------------------------------
// Local Player struct used by some messages
//-----------------------------------------------------------------------------
struct CXBNetPlayer
{
    XNADDR xnAddr;                          // player's XNet address
    WCHAR  strPlayerName[ MAX_PLAYER_STR ]; // player's name
};




//-----------------------------------------------------------------------------
// Sent from a client to a host to join a game
//-----------------------------------------------------------------------------
struct CXBNetMsgJoinGame
{
    WCHAR     strPlayerName[ MAX_PLAYER_STR ]; // player who wants to join
    ULONGLONG qwUserID;                        // unique player ID
};




//-----------------------------------------------------------------------------
// Sent from a host to a client in response to a MSG_JOIN_GAME
//-----------------------------------------------------------------------------
struct CXBNetMsgJoinApproved
{
    WCHAR        strHostName[ MAX_PLAYER_STR ]; // host name
    BYTE         byNumPlayers;                  // does not include host
    CXBNetPlayer PlayerList[ MAX_PLAYERS ];     // list of players (no host)
};




//-----------------------------------------------------------------------------
// Sent from a host to a client in response to a MSG_JOIN_GAME
//-----------------------------------------------------------------------------
struct CXBNetMsgJoinDenied
{
    // No payload required
};




//-----------------------------------------------------------------------------
// Sent from a host to other players to notify them that a new player has joined
//-----------------------------------------------------------------------------
struct CXBNetMsgPlayerJoined
{
    CXBNetPlayer player; // The latest player to join the game
};




//-----------------------------------------------------------------------------
// Sent from a player to other players to "wave"
//-----------------------------------------------------------------------------
struct CXBNetMsgWave
{
    // No payload required
};




//-----------------------------------------------------------------------------
// Sent from a player to other players as a "keep-alive"
//-----------------------------------------------------------------------------
struct CXBNetMsgHeartbeat
{
    // No payload required
};




//-----------------------------------------------------------------------------
// End structure packing
//-----------------------------------------------------------------------------
#pragma pack( pop )




//-----------------------------------------------------------------------------
// Name: class CXBNetMessage
// Desc: NetMessage object sent between players and hosts
//-----------------------------------------------------------------------------
class CXBNetMessage
{
    BYTE m_byMessageId;

    union
    {
        CXBNetMsgJoinGame     m_JoinGame;
        CXBNetMsgJoinApproved m_JoinApproved;
        CXBNetMsgJoinDenied   m_JoinDenied;
        CXBNetMsgPlayerJoined m_PlayerJoined;
        CXBNetMsgWave         m_Wave;
        CXBNetMsgHeartbeat    m_Heartbeat;
    };

public:

    // Must construct via ID
    explicit CXBNetMessage( BYTE byMessageId = 0 );

    // Accessors
    BYTE GetId() const      { return m_byMessageId; }
    INT  GetMaxSize() const { return sizeof(*this); }

    CXBNetMsgJoinGame&     GetJoinGame()     { return m_JoinGame;     }
    CXBNetMsgJoinApproved& GetJoinApproved() { return m_JoinApproved; }
    CXBNetMsgJoinDenied&   GetJoinDenied()   { return m_JoinDenied;   }
    CXBNetMsgPlayerJoined& GetPlayerJoined() { return m_PlayerJoined; }
    CXBNetMsgWave&         GetWave()         { return m_Wave;         }
    CXBNetMsgHeartbeat&    GetHeartbeat()    { return m_Heartbeat;    }

    INT GetSize() const;

private:

    // Disabled
    CXBNetMessage( const CXBNetMessage& );
    CXBNetMessage& operator=( const CXBNetMessage& );

};




//-----------------------------------------------------------------------------
// Name: class CXBNetPlayerInfo
// Desc: Player information used to store list of other players in the game
//-----------------------------------------------------------------------------
struct CXBNetPlayerInfo
{
    XNADDR    xnAddr;                          // XNet address
    IN_ADDR   inAddr;                          // Xbox IP (not a "real" IP)
    ULONGLONG qwUserID;                        // Unique player ID
    WCHAR     strPlayerName[ MAX_PLAYER_STR ]; // player name
    DWORD     dwLastHeartbeat;                 // last heartbeat, in our clocks
};

typedef std::vector< CXBNetPlayerInfo > CXBNetPlayerList;




//-----------------------------------------------------------------------------
// Name: class CXBNetMsgHandler
// Desc: Sends, receives and processes simple network messages
//-----------------------------------------------------------------------------
class CXBNetMsgHandler
{

public:

    static const WORD GAME_PORT = 9137;   // any port is valid

private:

    CXBSocket m_Sock;                       // communication socket
    XNKID     m_xnSessionID;                // session ID
    WCHAR     m_strHost[ MAX_PLAYER_STR ];  // host name
    BOOL      m_bIsHost;                    // TRUE if host

public:

    CXBNetMsgHandler();
    virtual ~CXBNetMsgHandler();

    HRESULT Initialize();
    VOID SetUser( const WCHAR* strUser, BOOL bIsHost );
    VOID SetSessionID( const XNKID& );

    // Send messages
    VOID SendJoinGame( const CXBSockAddr& saGameHost, const WCHAR* strUser,
                       ULONGLONG qwUserID );
    VOID SendWave( const CXBNetPlayerList& );
    VOID SendHeartbeat( const CXBNetPlayerList& );

    // Receive messages
    BOOL ProcessMessages( CXBNetPlayerList& );

    // Process dropouts
    BOOL ProcessPlayerDropouts( const CXBNetPlayerList&, DWORD dwTimeout );

    // Override for custom behavior
    virtual VOID OnJoinGame( const CXBNetPlayerInfo& );
    virtual VOID OnJoinApproved( const CXBNetPlayerInfo& );
    virtual VOID OnJoinApprovedAddPlayer( const CXBNetPlayerInfo& );
    virtual VOID OnJoinDenied();
    virtual VOID OnPlayerJoined( const CXBNetPlayerInfo& );
    virtual VOID OnWave( const CXBNetPlayerInfo& );
    virtual VOID OnHeartbeat( const CXBNetPlayerInfo& );
    virtual VOID OnPlayerDropout( const CXBNetPlayerInfo&, BOOL bIsHost );

private:

    VOID SendJoinApproved( const CXBSockAddr& saClient, const CXBNetPlayerList& );
    VOID SendJoinDenied( const CXBSockAddr& saClient );
    VOID SendPlayerJoined( const CXBNetPlayer&, const CXBSockAddr& saPlayer );

    VOID SendWave( const CXBSockAddr& );
    VOID SendHeartbeat( const CXBSockAddr& );

    VOID ProcessMessage( CXBNetMessage&, const CXBSockAddr&,
                         CXBNetPlayerList& );

    VOID ProcessJoinGame( const CXBNetMsgJoinGame&, const CXBSockAddr&, 
                          CXBNetPlayerList& );
    VOID ProcessJoinApproved( const CXBNetMsgJoinApproved&, const CXBSockAddr& );
    VOID ProcessJoinDenied();
    VOID ProcessPlayerJoined( const CXBNetMsgPlayerJoined&, const CXBSockAddr& );
    VOID ProcessWave( const CXBSockAddr&, const CXBNetPlayerList& );
    VOID ProcessHeartbeat( const CXBSockAddr&, const CXBNetPlayerList& );

};

#endif // XBNETMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbmesh.h ===
//-----------------------------------------------------------------------------
// File: XBMesh.h
//
// Desc: Support code for loading geometry stored in .xbg files. These files
//       typically converted from .x geometry files using the MakeXBG tool. See
//       that tool for more information.
//
//       XBG files were designed to minimalize overhead in the loading and
//       rendering process on the Xbox. The data in a .xbg file is basically
//       stored in one system memory chunk, and one video memory chunk.
//       Therefore, loading a .xbg file is simply two fread() calls followed
//       by some patchup (which turns file offsets into real pointers).
//
//       Geometry files are loaded into arrays of the following structures.
//       XBMESH_FRAME structures contain data to make a frame hierarchy (such
//       as "next" and "child" pointers, plus a transformation matrix). The
//       XMMESH_DATA structure contains data for rendering a mesh (such as
//       the vertex buffer, num of indices, etc.). Finally, the XBMESH_SUBSET
//       structure contains subset properties (materials and textures) and
//       primitive ranges (start index, index count, etc.) for each subset of
//       the data in the XBMESH_DATA structure.
//
//       To use this class, simply instantiate the class, and call Create().
//       Thereafter, the mesh can be rendered with the Render() call. Some
//       render flags are available (see below) to limit what gets rendered.
//       For instance, an app might want to render opaque subsets only, or
//       use a custom vertex shader. For truely custom control, override the
//       CXBMesh class with a new RenderCallback() function, and put any
//       custom pre-rendering code in the callback. The typical use for this
//       is to pass data to a custom vertex shader.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.15.01 - Mass changes (removed D3DX and .x support) for April XDK
//       04.15.01 - Using packed resources for May XDK
//       04.17.01 - 16-byte aligning matrices in the file format
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBMESH_H
#define XBMESH_H
#include "XBResource.h"
#include "XBUtil.h"




// Rendering flags. Default is no flags (0x00000000)
#define XBMESH_OPAQUEONLY      0x00000001 // Only render opaque subsets
#define XBMESH_ALPHAONLY       0x00000002 // Only render alpha subsets

#define XBMESH_NOMATERIALS     0x00000010 // Do not use mesh materials
#define XBMESH_NOTEXTURES      0x00000020 // Do not use mesh textures
#define XBMESH_NOFVF           0x00000040 // Do not use mesh FVF code


// The magic number to identify .xbg files
#define XBG_FILE_ID (((DWORD)'X'<<0)|(((DWORD)'B'<<8))|(((DWORD)'G'<<16))|(2<<24))




//-----------------------------------------------------------------------------
// Name: struct XBMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBMESH_SUBSET
{
    D3DMATERIAL8       mtrl;            // Material for this subset
    LPDIRECT3DTEXTURE8 pTexture;        // Texture
    CHAR               strTexture[64];
    DWORD              dwVertexStart;   // Range of vertices to render
    DWORD              dwVertexCount;
    DWORD              dwIndexStart;    // Range of vertex indices to render
    DWORD              dwIndexCount;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_DATA
// Desc: Struct for mesh data
//-----------------------------------------------------------------------------
struct XBMESH_DATA
{
    D3DVertexBuffer   m_VB;            // Mesh geometry
    DWORD             m_dwNumVertices;
    D3DIndexBuffer    m_IB;
    DWORD             m_dwNumIndices;
    
    DWORD             m_dwFVF;         // Mesh vertex info
    DWORD             m_dwVertexSize;
    D3DPRIMITIVETYPE  m_dwPrimType;

    DWORD             m_dwNumSubsets;  // Subset info for rendering calls
    XBMESH_SUBSET*    m_pSubsets;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESHFRAME
// Desc: Struct for building a hierarchy of meshes.
//-----------------------------------------------------------------------------
__declspec(align(16)) struct XBMESH_FRAME
{
    D3DXMATRIX        m_matTransform; // The transformation matrix for this frame
    
    XBMESH_DATA       m_MeshData;     // The mesh data belonging to this frame

    CHAR              m_strName[64];
    
    XBMESH_FRAME*     m_pChild;       // Child and sibling ptrs for the hierarchy
    XBMESH_FRAME*     m_pNext;
};




//-----------------------------------------------------------------------------
// Name: class CXBMesh
// Desc: Wrapper class for loading geoemtry files, and rendering the resulting
//       hierachy of meshes and frames.
//-----------------------------------------------------------------------------
class CXBMesh
{
    // Memory allocated during file loading. Ptrs are retained for cleanup.
    VOID* m_pAllocatedSysMem;
    VOID* m_pAllocatedVidMem;

public:
    // Hierarchy (frames and meshes) of loaded geometry
    XBMESH_FRAME* m_pMeshFrames;
    DWORD         m_dwNumFrames;

    // Internal rendering functions
    virtual HRESULT RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pMesh, 
                                 DWORD dwFlags );
    virtual HRESULT RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                                DWORD dwFlags );

    // Internal functions to find the radius of sphere centered at zero enclosing mesh.
    float ComputeFrameRadius(XBMESH_FRAME* pFrame, D3DXMATRIX* pParentMat);
    float ComputeMeshRadius(XBMESH_DATA* pMesh, D3DXMATRIX* pMat);
	
    // Internal functions to find the bounding box of the mesh.
    HRESULT ComputeFrameBoundingBox(XBMESH_FRAME* pFrame, D3DXMATRIX* pParentMat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
	HRESULT ComputeMeshBoundingBox(XBMESH_DATA* pMesh, D3DXMATRIX* pMat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);

public:
    // Reference counting
    DWORD   m_dwRefCount;
    DWORD   AddRef()  { return ++m_dwRefCount; }
    DWORD   Release() { if( --m_dwRefCount ) return m_dwRefCount;
                        delete this; return 0L; }

public:
    // Constructor/destructor
    CXBMesh();
    virtual ~CXBMesh();

    // Creation function. Call this function to create the hierarchy of frames
    // and meshes from a geometry file.
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                    CXBPackedResource* pResource = NULL );

    // Access functions
    XBMESH_FRAME* GetFrame( DWORD i ) { return &m_pMeshFrames[i]; }
    XBMESH_DATA*  GetMesh( DWORD i )  { return &m_pMeshFrames[i].m_MeshData; }

    // Overridable callback function (called before anything is rendered). 
    // This is useful for setting vertex shader constants, etc., before
    // rendering.
    virtual BOOL RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                                 XBMESH_SUBSET* pSubset, DWORD dwFlags ) { return TRUE; }
    
    // Render function. Call this function to render the hierarchy of frames
    // and meshes.
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags = 0x00000000 );

    // Function to find the radius of sphere centered at zero enclosing mesh.
    float ComputeRadius();
    // find the bounding box of all the subsets
	HRESULT ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbRandName.h ===
//-----------------------------------------------------------------------------
// File: XbRandName.h
//
// Desc: Generates a random and somewhat readable name. Useful for fake
//       player names, session names, etc.
//
// Hist: 10.10.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRANDNAME_H
#define XBRANDNAME_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBRandName
// Desc: Random name 
//-----------------------------------------------------------------------------
class CXBRandName
{
    
    mutable LONG m_nValue;

public:

    explicit CXBRandName( DWORD dwSeed = 0 );
    ~CXBRandName();

    VOID SetSeed( DWORD dwSeed );
    VOID GetName( WCHAR* strName, DWORD dwSize ) const;

private:

    DWORD GetRand() const;
    WCHAR GetRandVowel() const;
    WCHAR GetRandConsonant() const;
    VOID  AppendConsonant( WCHAR* strRandom, BOOL bLeading ) const;
    VOID  AppendVowel( WCHAR* strRandom ) const;

    // Not used, so not defined
    CXBRandName( const CXBRandName& );

};

#endif // XBRANDNAME_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XBPerf.h ===
//-----------------------------------------------------------------------------
// File: XBPerf.h
//
// Desc: Sample to show off tri-stripping performance results
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: XBPerf_CalcCacheHits()
// Desc: Calculate the number of cache hits and degenerate triangles
//-----------------------------------------------------------------------------
HRESULT XBPerf_CalcCacheHits( D3DPRIMITIVETYPE dwPrimType, DWORD dwVertexSize,
						      WORD* pIndices, DWORD dwNumIndices,
						      DWORD* pdwNumDegenerateTris,
						      DWORD* pdwNumCacheHits,
						      DWORD* pdwNumPagesCrossed );




//-----------------------------------------------------------------------------
// Name: XBPerf_GetCpuSpeed()
// Desc: Returns a calculation of the CPU speed.
//-----------------------------------------------------------------------------
double XBPerf_GetCpuSpeed();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbonlinetask.h ===
//-----------------------------------------------------------------------------
// File: XbOnlineTask.h
//
// Desc: Wraps online task HANDLE object
//
// Hist: 09.04.01 - New for Nov XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBONLINE_TASK_H
#define XBONLINE_TASK_H

#include <xtl.h>
#include <xonline.h>




//-----------------------------------------------------------------------------
// Name: class OnlineTask
// Desc: Xbox online task object
//-----------------------------------------------------------------------------
class CXBOnlineTask
{
    XONLINETASK_HANDLE m_hOnlineTask;

public:

    explicit CXBOnlineTask( XONLINETASK_HANDLE = NULL );
    ~CXBOnlineTask();

    operator XONLINETASK_HANDLE() const;
    XONLINETASK_HANDLE* operator&();

    BOOL    IsOpen() const;
    BOOL    IsClosed() const;
    void    Close();
    HRESULT Continue();

private:

    CXBOnlineTask( const CXBOnlineTask& );
    CXBOnlineTask& operator=( const CXBOnlineTask& );

};

#endif // XBONLINE_TASK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbSavedGame.h ===
//-----------------------------------------------------------------------------
// File: XbSavedGame.h
//
// Desc: Saved game container
//
// Hist: 02.05.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSAVED_GAME_H
#define XBSAVED_GAME_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBSavedGame
// Desc: Xbox saved game container
//-----------------------------------------------------------------------------
class CXBSavedGame
{

    WCHAR         m_strName[ MAX_GAMENAME ]; // name from container
    CHAR          m_strDir[ MAX_PATH ];      // folder
    mutable DWORD m_dwSize;                  // size in bytes
    mutable LPDIRECT3DTEXTURE8 m_pImage;     // game image
    mutable BOOL  m_bIsValidImage;           // TRUE if SaveImage.xbx is valid format

    union
    {
        mutable FILETIME  m_ftLastWriteTime;  // last write date/time
        mutable ULONGLONG m_qwLastWriteTime;
    };

public:

    CXBSavedGame();
    CXBSavedGame( const CXBSavedGame& );
    CXBSavedGame& operator =( const CXBSavedGame& );
    ~CXBSavedGame();
    explicit CXBSavedGame( const _XGAME_FIND_DATA& );
    CXBSavedGame( const WCHAR* strName, const CHAR* strDir );

    BOOL  CreateGame( CHAR chDestDrive, const WCHAR* strName );
    BOOL  OpenGame( CHAR chDestDrive, const WCHAR* strName,
                    DWORD dwOpenDisposition );
    BOOL  DeleteGame();
    BOOL  IsEmpty() const;
    CHAR  GetDrive() const;
    DWORD GetSize() const;

    FILETIME     GetLastWriteTime() const;
    ULONGLONG    GetLastWriteQword() const;
    BOOL         GetImage( LPDIRECT3DTEXTURE8* ) const;
    BOOL         SaveImage( const LPDIRECT3DTEXTURE8 );
    const WCHAR* GetName() const;
    const CHAR*  GetDirectory() const;

private:

    VOID Init();

};

#endif // XBSAVED_GAME_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbOnline.h ===
//-----------------------------------------------------------------------------
// File: XbOnline.h
//
// Desc: Shortcut macros and helper functions for the Xbox online samples.
//       Requires linking with XONLINE[D][S].LIB
//
// Hist: 10.11.01 - New for November XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBONLINE_H
#define XBONLINE_H

#pragma warning( disable: 4786 ) // ignore STL identifier truncation
#include <xtl.h>
#include <vector>
#include "xonline.h"
#include "XBResource.h"
#include "XBFont.h"
#include "XBHelp.h"
#include "XBStopWatch.h"




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_ERROR_STR = 1024;




//-----------------------------------------------------------------------------
// Name: XBOnline_GetUserList() / XBOnline_UpdateUserList
// Desc: Extract accounts from hard disk and MUs
//-----------------------------------------------------------------------------
typedef std::vector< XONLINE_USER > XBUserList;
HRESULT XBOnline_GetUserList( XBUserList& UserList );




//-----------------------------------------------------------------------------
// Name: class CXBPinEntry
// Desc: Xbox PIN entry
//-----------------------------------------------------------------------------
class CXBPinEntry
{

    XPININPUTHANDLE m_hPinInput;                    // PIN input handle
    BYTE            m_byPin[ XONLINE_PIN_LENGTH ];  // Current PIN
    DWORD           m_dwPinLength;                  // number of buttons entered

public:

    CXBPinEntry();
    ~CXBPinEntry();

    HRESULT BeginInput( const XINPUT_GAMEPAD& );
    HRESULT DecodeInput( const XINPUT_GAMEPAD& );
    DWORD   GetPinLength() const;
    BOOL    IsPinComplete() const;
    BOOL    IsPinValid( const BYTE* ) const;
    HRESULT EndInput();

};




//-----------------------------------------------------------------------------
// Name: class CXBOnlineUI
// Desc: UI class for standard online UI
//-----------------------------------------------------------------------------
class CXBOnlineUI
{
    CXBPackedResource   m_xprResource;               // app resources
    mutable CXBFont     m_Font;                      // game font
    CXBHelp             m_Help;                      // help screen
    LPDIRECT3DTEXTURE8  m_ptMenuSel;                 // menu selection image
    WCHAR               m_strError[ MAX_ERROR_STR ]; // generic err
    WCHAR*              m_strFrameRate;              // from CXBApp
    WCHAR*              m_strHeader;                 // header string
    CXBStopWatch        m_CaretTimer;                // for PIN entry

public:

    static const D3DCOLOR COLOR_HIGHLIGHT = 0xffffff00; // Yellow
    static const D3DCOLOR COLOR_GREEN     = 0xff00ff00; // Green
    static const D3DCOLOR COLOR_NORMAL    = 0xffffffff; // White

public:

    explicit CXBOnlineUI( WCHAR* strFrameRate, WCHAR* strHeader );

    HRESULT Initialize( DWORD dwNumResources, DWORD dwMenuSelectorOffset );

    // Accessors
    VOID SetErrorStr( const WCHAR*, va_list );

    // UI functions
    VOID RenderCreateAccount( BOOL bHasMachineAccount ) const;
    VOID RenderSelectAccount( DWORD, const XBUserList& ) const;
    VOID RenderGetPin( const CXBPinEntry&, const WCHAR* strUser ) const;
    VOID RenderLoggingOn() const;
    VOID RenderError() const;

    VOID RenderHeader() const;
    VOID RenderMenuSelector( FLOAT, FLOAT ) const;

    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L ) const;

private:

    // Disabled
    CXBOnlineUI();
    CXBOnlineUI( const CXBOnlineUI& );

};

#endif // XBONLINE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbsockaddr.h ===
//-----------------------------------------------------------------------------
// File: XbSockAddr.h
//
// Desc: Wraps SOCKADDR_IN object
//
// Hist: 05.17.01 - New for June XDK release
//       08.08.01 - Moved to common framework
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSOCKADDR_H
#define XBSOCKADDR_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBSockAddr
// Desc: Xbox socket address object
//-----------------------------------------------------------------------------
class CXBSockAddr : private SOCKADDR_IN
{
public:

    explicit CXBSockAddr( const SOCKADDR_IN& sa );
    CXBSockAddr( DWORD inAddr, WORD wPort );
    CXBSockAddr( const IN_ADDR& inAddr, WORD wPort );

    IN_ADDR            GetInAddr() const;
    const SOCKADDR_IN* GetPtr() const;
    DWORD              GetAddr() const;
    WORD               GetPort() const;
    VOID               GetStr( WCHAR*, BOOL bIncludePort=TRUE ) const;

private:

    // Not used, so not defined
    CXBSockAddr();
    CXBSockAddr( const CXBSockAddr& );

};

#endif // XBSOCKADDR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbSocket.h ===
//-----------------------------------------------------------------------------
// File: XbSocket.h
//
// Desc: Wraps SOCKET object
//
// Hist: 05.17.01 - New for June XDK release
//       08.08.01 - Moved to common framework
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSOCKET_H
#define XBSOCKET_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class Socket
// Desc: Xbox socket object
//-----------------------------------------------------------------------------
class CXBSocket
{
    SOCKET m_Socket;

public:

    enum SocketType
    {
        Type_UDP,
        Type_TCP
    };

    explicit CXBSocket( SOCKET = INVALID_SOCKET );
    explicit CXBSocket( SocketType );
    CXBSocket( INT iType, INT iProtocol );
    ~CXBSocket();

    BOOL   Open( SocketType );
    BOOL   Open( INT iType, INT iProtocol );
    BOOL   IsOpen() const;
    INT    Close();
    SOCKET Accept( SOCKADDR_IN* = NULL );
    INT    Bind( const SOCKADDR_IN* );
    INT    Connect( const SOCKADDR_IN* );
    INT    GetSockName( SOCKADDR_IN* ) const;
    INT    GetSockOpt( INT iLevel, INT iName, VOID* pValue, INT* piSize ) const;
    INT    IoCtlSocket( LONG nCmd, DWORD* pArg );
    INT    Listen( INT iBacklog = SOMAXCONN );
    INT    Recv( VOID* pBuffer, INT iBytes );
    INT    RecvFrom( VOID* pBuffer, INT iBytes, SOCKADDR_IN* = NULL );
    INT    Send( const VOID* pBuffer, INT iBytes );
    INT    SendTo( const VOID* pBuffer, INT iBytes, const SOCKADDR_IN* = NULL );
    INT    SetSockOpt( INT iLevel, INT iName, const VOID* pValue, INT iBytes );
    INT    Shutdown( INT iHow );

private:

    CXBSocket( const CXBSocket& );
    CXBSocket& operator=( const CXBSocket& );

};

#endif // XBSOCKET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XBStrip.h ===
//-----------------------------------------------------------------------------
// File: XBStrip.h
//
// Desc: Tristrip routines (which convert a mesh into a list of optimized
//       triangle strips).
//
// Hist: 02.01.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
#define OPTIMIZE_FOR_CACHE      0x00
#define OPTIMIZE_FOR_INDICES    0x01
#define OUTPUT_TRISTRIP         0x00
#define OUTPUT_TRILIST          0x02




//-----------------------------------------------------------------------------
// Name: Stripify()
// Desc: Main stripify routine. Stripifies a mesh and returns the number of 
//       strip indices contained in ppStripIndices.
// Note: Caller must make sure to call delete[] on the ppStripIndices array
//       when finished with it.
//-----------------------------------------------------------------------------
DWORD Stripify( DWORD  dwNumTriangles,   // Number of triangles
                WORD*  pTriangles,       // Ptr to triangle indices
                DWORD* pdwNumIndices,    // Number of output indices
                WORD** ppStripIndices,   // Output indices
                DWORD  dwFlags = 0 );    // Flags controlling optimizer.



//-----------------------------------------------------------------------------
// Name: ComputeVertexPermutation()
// Desc: Re-arrange vertices so that they occur in the order that they are
//       first used. Instead of actually moving vertex data around, this
//       function returns an array that specifies where (in the new vertex
//       array) each old vertex should go. It also re-maps the strip indices
//       to use the new vertex locations.
// Note: Caller must make sure to call delete[] on the pVertexPermutation array
//       when finished with it.
//-----------------------------------------------------------------------------
VOID ComputeVertexPermutation( DWORD  dwNumStripIndices,     // Number of strip indices
                               WORD*  pStripIndices,         // Ptr to strip indices
                               DWORD  dwNumVertices,         // Number of verticess in
                               WORD** ppVertexPermutation ); // Map from orignal index to remapped index
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbStorageDevice.h ===
//-----------------------------------------------------------------------------
// File: XbStorageDevice.h
//
// Desc: Hard disk and memory unit devices. Provides save and load game
//       functionality.
//
// Hist: 01.30.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSTORAGE_DEVICE_H
#define XBSTORAGE_DEVICE_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBStorageDevice
// Desc: Xbox storage device (hard drive, MU)
//-----------------------------------------------------------------------------
class CXBStorageDevice
{

    mutable HANDLE m_hSaveGame;         // For iterating through saved games
    CHAR           m_strRootPath[4];    // "@:\" where @ is the logical drive
                                        // letter of the storage device

public:

    explicit CXBStorageDevice( CHAR chDriveLetter = 0 );
    CXBStorageDevice( const CXBStorageDevice& );
    CXBStorageDevice& operator=( const CXBStorageDevice& );
    virtual ~CXBStorageDevice();

    static CXBStorageDevice GetUserRegion();
    static CXBStorageDevice GetTitleRegion();
    static CXBStorageDevice GetUtilityRegion( BOOL fFormatClean );
    static DWORD GetBlockSize();

    CHAR  GetDrive() const;
    VOID  SetDrive( CHAR chDriveLetter );
    BOOL  IsValid() const;
    BOOL  IsTitleRegion() const;
    BOOL  IsUtilityRegion() const;
    BOOL  GetSize( ULONGLONG& qwTotalBlocks, ULONGLONG& qwUsedBlocks, 
                   ULONGLONG& qwFreeBlocks ) const;
    DWORD GetSavedGameCount() const;
    DWORD GetSectorSize() const;
    DWORD GetClusterSize() const;
    DWORD GetSaveGameOverhead() const;
    DWORD GetFileBytes( DWORD ) const;
    BOOL  FindFirstSaveGame( XGAME_FIND_DATA& ) const;
    BOOL  FindNextSaveGame( XGAME_FIND_DATA& ) const;

private:

    VOID Cleanup() const;

};

#endif // XBSTORAGE_DEVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbStopWatch.h ===
//-----------------------------------------------------------------------------
// File: XbStopWatch.h
//
// Desc: StopWatch object using QueryPerformanceCounter
//
// Hist: 01.19.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSTOPWATCH_H
#define XBSTOPWATCH_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBStopWatch
// Desc: Simple timing object using stopwatch metaphor
//-----------------------------------------------------------------------------
class CXBStopWatch
{
    FLOAT    m_fTimerPeriod;        // seconds per tick (1/Hz)
    LONGLONG m_nStartTick;          // time watch last started/reset
    LONGLONG m_nPrevElapsedTicks;   // time watch was previously running
    BOOL     m_bIsRunning;          // TRUE if watch is running

public:

    explicit CXBStopWatch( BOOL bStartWatch = TRUE );

    VOID  Start();
    VOID  StartZero();
    VOID  Stop();
    VOID  Reset();

    BOOL  IsRunning() const;
    FLOAT GetElapsedSeconds() const;
    FLOAT GetElapsedMilliseconds() const;

private:

    LONGLONG GetTicks() const;

};

#endif // XBSTOPWATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbsound.h ===
//-----------------------------------------------------------------------------
// File: XBSound.h
//
// Desc: Helper class for reading a .wav file and playing it in a DirectSound
//       buffer.
//
// Hist: 12.15.00 - New for December XDK release
//       02.15.01 - Updated for March XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSOUND_H
#define XBSOUND_H
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: RIFFHEADER
// Desc: For parsing WAV files
//-----------------------------------------------------------------------------
struct RIFFHEADER
{
    FOURCC  fccChunkId;
    DWORD   dwDataSize;
};

#define RIFFCHUNK_FLAGS_VALID   0x00000001


//-----------------------------------------------------------------------------
// Name: class CRiffChunk
// Desc: RIFF chunk utility class
//-----------------------------------------------------------------------------
class CRiffChunk
{
    FOURCC            m_fccChunkId;       // Chunk identifier
    const CRiffChunk* m_pParentChunk;     // Parent chunk
    HANDLE            m_hFile;
    DWORD             m_dwDataOffset;     // Chunk data offset
    DWORD             m_dwDataSize;       // Chunk data size
    DWORD             m_dwFlags;          // Chunk flags

public:
    CRiffChunk();

    // Initialization
    VOID    Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk,
                        HANDLE hFile );
    HRESULT Open();
    BOOL    IsValid()     { return !!(m_dwFlags & RIFFCHUNK_FLAGS_VALID); }

    // Data
    HRESULT ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize );

    // Chunk information
    FOURCC  GetChunkId()  { return m_fccChunkId; }
    DWORD   GetDataSize() { return m_dwDataSize; }
};




//-----------------------------------------------------------------------------
// Name: class CWaveFile
// Desc: Wave file utility class
//-----------------------------------------------------------------------------
class CWaveFile
{
    HANDLE      m_hFile;            // File handle
    CRiffChunk  m_RiffChunk;        // RIFF chunk
    CRiffChunk  m_FormatChunk;      // Format chunk
    CRiffChunk  m_DataChunk;        // Data chunk
    CRiffChunk  m_WaveSampleChunk;  // Wave Sample chunk
    
public:
    CWaveFile();
    ~CWaveFile();

    // Initialization
    HRESULT Open( const CHAR* strFileName );
    VOID    Close();

    // File format
    HRESULT GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize, DWORD *pdwRequiredSize = NULL );

    // File data
    HRESULT ReadSample( DWORD dwPosition, VOID* pBuffer, DWORD dwBufferSize, 
                        DWORD* pdwRead );

    // Loop region
    HRESULT GetLoopRegion( DWORD* pdwStart, DWORD* pdwLength );

    // File properties
    VOID    GetDuration( DWORD* pdwDuration ) { *pdwDuration = m_DataChunk.GetDataSize(); }
};




//-----------------------------------------------------------------------------
// Name: class CSound
// Desc: Encapsulates functionality of a DirectSound buffer.
//-----------------------------------------------------------------------------
class CXBSound
{
protected:
    LPDIRECTSOUNDBUFFER  m_pDSoundBuffer;
    WAVEFORMATEX         m_WaveFormat;
    DSBUFFERDESC         m_dsbd;
    DWORD                m_dwBufferSize;

public:
    HRESULT Create( const CHAR* strFileName, DWORD dwFlags = 0L );
    HRESULT Create( const WAVEFORMATEX* pwfxFormat, DWORD dwFlags,
                    const VOID* pBuffer, DWORD dwBytes );
    VOID    Destroy();

    HRESULT Play( DWORD dwFlags = 0L ) const;
    HRESULT Stop() const;
    HRESULT SetPosition( const D3DXVECTOR3& vPosition ) const;
    HRESULT SetVelocity( const D3DXVECTOR3& vVelocity ) const;

    CXBSound();
    ~CXBSound();
};



//-----------------------------------------------------------------------------
// Name: class CDSPImage
// Desc: Encapsulates DSP image for loading from file, downloading to DSP, etc.
//-----------------------------------------------------------------------------
class CDSPImage
{
protected:
    DWORD           m_dwImageSize;
    BYTE *          m_pbImageData;

public:
    CDSPImage();
    ~CDSPImage();

    HRESULT LoadFromFile( char * szFilename );
    HRESULT DownloadImage( LPDIRECTSOUND8 pDSound );
};
#endif // XBSOUND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\XbVoice.h ===
//-----------------------------------------------------------------------------
// File: XbVoice.h
//
// Desc: Shortcut macros and helper functions for the Xbox voice samples
//       Requires linking with XVOICE[D].LIB
//
// Hist: 10.21.01 - New for November XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBVOICE_H
#define XBVOICE_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: XBVoice_HasDevice()
// Desc: TRUE if Xbox Communicator is current available
//-----------------------------------------------------------------------------
BOOL XBVoice_HasDevice();




#endif // XBVOICE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xdppeer.h ===
#ifndef __XDPPEER_H
#define __XDPPEER_H

#include <xtl.h>
#include <dplay8.h>

extern LPDIRECTPLAY8PEER g_pDP;					// DirectPlay peer object

extern LPDIRECTPLAY8ADDRESS g_pDeviceAddress;	// device address of SP
extern LPDIRECTPLAY8ADDRESS g_pHostAddress ;	// host address of SP

extern DWORD g_dwNumPlayers;					// # of players in game
extern DWORD g_dpnidLocalPlayer;				// DPNID of local player
extern DWORD g_dpnidHost;						// DPNID of host

extern WCHAR g_wszXDPPlayerName[32];			// players name
extern WCHAR g_wszXDPSessionName[32];			// session name

// connect stuff
enum
{
	GAME_NOTCONNECTED=0,						// no network connection
	GAME_ENUMERATING,							// searching for hosts
	GAME_CONNECTING,							// connecting to a host
	GAME_CONNECTED,								// connected to a host
	GAME_HOSTING,								// hosting a game
	GAME_DISCONNECTING							// disconecting from a game
};

extern DWORD g_dwConnectStatus;

// active game list stuff
#define MAX_ACTIVEGAMES 32
typedef struct _ActiveGame
{
	DPN_APPLICATION_DESC AppDesc;
	IDirectPlay8Address	*pHostAddr;				// address of host who responded
	IDirectPlay8Address	*pDevAddr;				// device response was received on
	DWORD dwPing;								// ping time
	DWORD dwReportTime;							// last time this server reported
} ActiveGame;

// this message tells the app to delete a game from
// the game menu. hopefully it will never collide with
// any dplay message id's.
#define DPPEER_MSGID_DELETE_GAME (DPN_MSGID_OFFSET|0x0110)

#ifdef __cplusplus
extern "C" {
#endif

HRESULT XDPInit(HRESULT (WINAPI *DPMsgHandler)(void *, DWORD, void *));
void XDPShutdown();
HRESULT XDPDoWork(DWORD param);

HRESULT XDPEnumHosts(DWORD port, GUID *pGuid);
ActiveGame *XDPAddGame(DPNMSG_ENUM_HOSTS_RESPONSE *pHost);
void XDPCancelEnumHosts();
void XDPExpireGames();

HRESULT XDPCreate(DWORD port, GUID *pGuid, DWORD dwMaxPlayers, DWORD flags);
HRESULT XDPConnect(DPN_APPLICATION_DESC *pAppDesc, IDirectPlay8Address *pHostAddr, IDirectPlay8Address *pDevAddr);
HRESULT XDPDisconnect();
HRESULT XDPTerminate();

#define XDPIsConnected() (g_dwConnectStatus==GAME_CONNECTED||g_dwConnectStatus==GAME_HOSTING)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xdpvoice.h ===
#ifndef __XDPVOICE_H
#define __XDPVOICE_H

#include <xtl.h>
#include <dsound.h>
#include <dplay8.h>
#include <dvoice.h>

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TARGETS 64
extern DVID g_dvidTargets[MAX_TARGETS];
extern DWORD g_dwNumTargets;

HRESULT XDVInit(HRESULT (WINAPI *DVMsgHandler)(void *, DWORD, void *));

HRESULT XDVCreate(DWORD dwSessionType, GUID guidCT);
HRESULT XDVConnect(DWORD dwFlags);
HRESULT XDVDisconnect();
HRESULT XDVStopSession();
HRESULT XDVDoWork();

HRESULT XDVSetTransmitTargets();
HRESULT XDVClearTransmitTargets();
HRESULT XDVRemoveTransmitTarget(DVID dvidTarget);
HRESULT XDVAddTransmitTarget(DVID dvidTarget);

extern IDirectPlayVoiceServer *g_pDVServer;				// server object
extern IDirectPlayVoiceClient *g_pDVClient;				// client object

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <xtl.h>
#include <tchar.h>
#include <assert.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

#ifdef _DEBUG
    #define OUTPUT_DEBUG_STRING(s) OutputDebugStringA(s)
#else
    #define OUTPUT_DEBUG_STRING(s) (VOID)(s)
#endif

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName,
                            BOOL bSurfaceIsTiled = FALSE );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetWide()
// Desc: Convert CHAR string to WCHAR string. dwMax includes the null byte.
//       Never copies more than dwMax-1 characters into strWide.
//          Ex: GetWide( "abc", strWide, 3 ) gives strWide = "ab"
//       Typical usage:
//          WCHAR strResult[MAX];
//          XBUtil_GetWide( strThin, strResult, MAX );
//-----------------------------------------------------------------------------
VOID XBUtil_GetWide( const CHAR* strThin, WCHAR* strWide, DWORD dwMax );


#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xfvf.h ===
//-----------------------------------------------------------------------------
// File: xfvf.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __FVF_H
#define __FVF_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif

#define FVF_XYZDIFF (D3DFVF_XYZ|D3DFVF_DIFFUSE)
#define FVF_XYZNORM (D3DFVF_XYZ|D3DFVF_NORMAL)
#define FVF_XYZTEX1 (D3DFVF_XYZ|D3DFVF_TEX1)
#define FVF_XYZRHWTEX1 (D3DFVF_XYZRHW|D3DFVF_TEX1)
#define FVF_XYZRHWDIFF (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
#define FVF_XYZDIFFTEX1 (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

#define FVF_XYZNORMTEX1 (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)
#define FVF_XYZNORMDIFF (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE)
#define FVF_XYZNORMDIFFTEX1 (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1)

#ifdef __cplusplus
extern "C" {
#endif

// predefined flexible vertex formats

// D3DFVF_XYZ|D3DFVF_DIFFUSE
typedef struct sFVFT_XYZDIFF
{
	D3DVECTOR v;
	DWORD diff;
} FVFT_XYZDIFF;

// D3DFVF_XYZ|D3DFVF_NORMAL
typedef struct sFVFT_XYZNORM
{
	D3DVECTOR v;
	D3DVECTOR norm;
} FVFT_XYZNORM;

// D3DFVF_XYZ|D3DFVF_TEX1
typedef struct sFVFT_XYZTEX1
{
	D3DVECTOR v;
	float tu;
	float tv;
} FVFT_XYZTEX1;

// D3DFVF_XYZRHW|D3DFVF_TEX1
typedef struct sFVFT_XYZRHWTEX1
{
	D3DVECTOR v;
	float w;
	float tu;
	float tv;
} FVFT_XYZRHWTEX1;

// D3DFVF_XYZRHW|D3DFVF_TEX1
typedef struct sFVFT_XYZRHWDIFF
{
	D3DVECTOR v;
	float w;
	DWORD diff;
} FVFT_XYZRHWDIFF;

// D3DFVF_XYZ|D3DFV_DIFFUSE|D3DFVF_TEX1
typedef struct sFVFT_XYZDIFFTEX1
{
	D3DVECTOR v;
	DWORD diff;
	float tu;
	float tv;
} FVFT_XYZDIFFTEX1;

// D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1
typedef struct sFVFT_XYZNORMTEX1
{
	D3DVECTOR v;
	D3DVECTOR norm;
	float tu;
	float tv;
} FVFT_XYZNORMTEX1;

// D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE
typedef struct sFVFT_XYZNORMDIFF
{
	D3DVECTOR v;
	D3DVECTOR norm;
	DWORD diff;
} FVFT_XYZNORMDIFF;

// D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_DIFFUSE|D3DFVF_TEX1
typedef struct sFVFT_XYZNORMDIFFTEX1
{
	D3DVECTOR v;
	D3DVECTOR norm;
	DWORD diff;
	float tu;
	float tv;
} FVFT_XYZNORMDIFFTEX1;

DWORD FVF_VSize(DWORD fvf);

void FVF_GetVert(void *verts, D3DVECTOR *vout, DWORD first, DWORD cnt, DWORD fvf);
void FVF_GetNorm(void *verts, D3DVECTOR *nout, DWORD first, DWORD cnt, DWORD fvf);
void FVF_GetDiff(void *verts, DWORD *dout, DWORD first, DWORD cnt, DWORD fvf);
void FVF_GetUV(void *verts, float *uvout, DWORD first, DWORD cnt, DWORD fvf);

void FVF_SetVert(void *verts, D3DVECTOR *vin, DWORD first, DWORD cnt, DWORD fvf);
void FVF_SetNorm(void *verts, D3DVECTOR *nin, DWORD first, DWORD cnt, DWORD fvf);
void FVF_SetDiff(void *verts, DWORD *din, DWORD first, DWORD cnt, DWORD fvf);
void FVF_SetAllDiff(void *verts, DWORD din, DWORD first, DWORD cnt, DWORD fvf);
void FVF_SetUV(void *verts, float *uvin, DWORD first, DWORD cnt, DWORD fvf);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xmenu.h ===
#ifndef __XMENU_H
#define __XMENU_H

#include "XBFont.h"
#include "XBInput.h"

// menu item flags
#define MITEM_SEPARATOR		0x0001			// this item is a separator
#define MITEM_ROUTINE		0x0002			// this item calls a routine
#define MITEM_DISABLED		0x0004			// this item is greyed out

// menu routine commands
#define MROUTINE_INIT		0xffff			// first call to routine
#define MROUTINE_ABORT		0xfffe			// abort routine triggered

// menu routine return values
#define MROUTINE_RETURN		0x0001			// return to menu
#define MROUTINE_DIE		0x0002			// kill routine
#define MROUTINE_SLEEP		0x0003			// routine sleeps

// menu item definition
#define MITEM_STRINGLEN 48
typedef struct _xmenuitem
{
	DWORD flags;
	WCHAR string[MITEM_STRINGLEN];			// text to display
	DWORD val1;								// user defined values
	DWORD val2;
	void *action;							// link to menu or routine
	struct _xmenu *menu;					// menu that owns this item
	DWORD color;							// item color
} XMenuItem;

// menu commands
#define MENU_NEXTITEM		0x0001			// next menu item
#define MENU_PREVITEM		0x0002			// previous menu item
#define MENU_SELECTITEM		0x0003			// select this menu item
#define MENU_BACK			0x0004			// go back one level
#define MENU_ACTIVATE		0x0005			// activate menu

// menu flags
#define MENU_LEFT			0x0001			// left justify menu text
#define MENU_RIGHT			0x0002			// right justify menu text
#define MENU_WRAP			0x0004			// wrap menu selection
#define MENU_NOBACK			0x0008			// cannot use back button

typedef struct _xmenu
{
	float x, y;								// screen position
	float w, h;								// menu size
	DWORD flags;							// menu flags
	DWORD topcolor, bottomcolor;			// menu background gradient color
	DWORD seltopcolor, selbotcolor;			// menu selection bar gradient color
	DWORD itemcolor;						// menu item default color
	struct _xmenu *parent;					// parent menu

	WCHAR title[MITEM_STRINGLEN];			// menu title
	DWORD titlecolor;						// memu title color
	DWORD maxshow;							// max # of items to show at one time
	DWORD maxitems;							// max # of items
	DWORD nitems;							// # of items
	DWORD curitem;							// current selected item
	XMenuItem *items;						// items

	DWORD (*abortroutine)(DWORD, XMenuItem *);	// called when menu aborted
} XMenu;

#ifdef __cplusplus
extern "C" {
#endif

extern XMenu *XMenu_CurMenu;
extern int (*XMenu_CurRoutine)(DWORD cmd, XMenuItem *mi);

void XMenu_SetFont(CXBFont *font);
XMenu *XMenu_Init(float x, float y, DWORD maxitems, DWORD flags, DWORD (*abortroutine)(DWORD, XMenuItem *));
void XMenu_Shutdown();
void XMenu_Delete(XMenu *m);
XMenuItem *XMenu_AddItem(XMenu *m, DWORD flags, WCHAR *string, void *action);
void XMenu_DeleteItem(XMenuItem *mi);
void XMenu_SetMaxShow(XMenu *m, DWORD maxshow);
void XMenu_SetTitle(XMenu *m, WCHAR *string, DWORD color);
void XMenu_SetItemText(XMenuItem *mi, WCHAR *string);
#define XMenu_IsActive() (XMenu_CurMenu||XMenu_CurRoutine)

DWORD XMenu_GetCommand(XBGAMEPAD *gamepad);	// gets command based on joypad
DWORD XMenu_Activate(XMenu *m);				// activates a menu
DWORD XMenu_Routine(DWORD command);			// called each frame to update menu

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xmodel.h ===
//-----------------------------------------------------------------------------
// File: xmodel.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __XMODEL_H
#define __XMODEL_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include <xbresource.h>
#include "xfvf.h"

extern CXBPackedResource *g_pModelResource;

#define XMF_STRIP	0x0001				// xmodel flag - generate tri strips
#define MFP_EYEWT	0x0001				// vfunc eye weight parameter

//-----------------------------------------------------------------------------
// Model class
//-----------------------------------------------------------------------------
class CXModel
{
	public:
	DWORD		m_dwFlags;
	DWORD		m_dwRefCount;
	DWORD		m_dwNumTriangles;		// # of triangles
	DWORD		m_dwNumVertices;		// # of vertices
	DWORD		m_dwVShader;			// vertex shader
	float		m_fRadius;				// radius
	float		m_fRadius2;				// radius squared

    LPDIRECT3DTEXTURE8 m_pTexture;		// texture

	DWORD		m_dwFVF;				// fvf type
	DWORD		m_dwVBSize;				// size of vbuf
	DWORD		m_dwVBStride;			// vbuf stride
    LPDIRECT3DVERTEXBUFFER8 m_pVB;		// vertex buffer

	D3DPRIMITIVETYPE m_PrimType;		// primitive type
	DWORD		m_dwIBSize;				// index buffer size
    LPDIRECT3DINDEXBUFFER8 m_pIB;		// index buffer
	DWORD		m_dwNumIndices;			// # of indices

	CXModel();
	~CXModel();

	DWORD Render();
	DWORD CXModel::Build(DWORD nvert, D3DVECTOR *vert, 
						 DWORD ntri, DWORD nidx, WORD *trilist, 
						 float *tc, D3DVECTOR *norm, DWORD *diff, 
						 DWORD fvf, DWORD flags);
	D3DVECTOR *GenNormals(DWORD nvert, D3DVECTOR *vert, DWORD ntri, WORD *trilist);
	void DrawNormals();
	DWORD Read_M(char *fname, char *imgname, DWORD fvf, DWORD flags, void (*vfunc)(int, int, float));
	void LoadTexture(char *imgname);

	// primitives
	DWORD Sphere(float radius, DWORD tessx, DWORD tessy, DWORD fvf, char *imgname, float txscale);
	DWORD GridXZ(DWORD tessx, DWORD tessz, float xsize, float zsize, DWORD fvf, char *imgname, float texx, float texz);
	DWORD Cylinder(float rad0, DWORD diff0, float rad1, DWORD diff1, float len, DWORD tess, DWORD fvf, char *imgname, float txscale);

	void LockVB(BYTE **bptr, DWORD flags)
	{
		m_pVB->Lock(0, m_dwVBSize, bptr, flags);
	}
	void UnlockVB()
	{
		m_pVB->Unlock();
	}
	void LockIB(BYTE **bptr, DWORD flags)
	{
		m_pIB->Lock(0, m_dwIBSize, bptr, flags);
	}
	void UnlockIB()
	{
		m_pIB->Unlock();
	}
	void SetVertexShader(DWORD vshader)
	{
		if(vshader==0)
			m_dwVShader = m_dwFVF;
		else
			m_dwVShader = vshader;
	}

	int AddRef() { return ++m_dwRefCount; }
	int Release();
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xobj.h ===
//-----------------------------------------------------------------------------
// File: xobj.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __XOBJ_H
#define __XOBJ_H

#ifdef _XBOX
#include <xtl.h>
#include <XBMesh.h>
#else
#include <d3dx8.h>
#endif
#include "xmodel.h"

// object flags
#define OBJ_SYSFLAGSM	0xffff0000			// system flags mask
#define OBJ_USRFLAGSM	0x0000ffff			// user flags mask

#define OBJ_NOMCALCS	0x00010000			// dont do matrix calcs in render

//-----------------------------------------------------------------------------
// Object class
//-----------------------------------------------------------------------------
class CXObject
{
public:

	CXModel				*m_Model;			// model to render
#ifdef _XBOX
	CXBMesh				*m_pXBMesh;			// xbg mesh
#endif

	D3DXVECTOR3			m_vPosition;		// position
	D3DXVECTOR3			m_vRotation;		// rotation
	D3DXMATRIX			m_matOrientation;	// orientation matrix
	D3DMATERIAL8		*m_Material;		// lighting material

	DWORD				m_dwFlags;			// object flags
	DWORD				m_dwType;			// object type
	VOID				*m_pvInfo;			// info pointer

    CXObject();
    ~CXObject();

	void SetModel(CXModel *model);
	void SetXBMesh(CXBMesh *xbm);

	void SetPosition(float x, float y, float z)
	{
		m_vPosition.x = x;
		m_vPosition.y = y;
		m_vPosition.z = z;
	};

	void SetRotation(float x, float y, float z)
	{
		m_vRotation.x = x;
		m_vRotation.y = y;
		m_vRotation.z = z;
	};

	float GetRadius2();
	float GetRadius();

	void CrunchMatrix();
	void Render(int flags);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xparse.h ===
//-----------------------------------------------------------------------------
// File: xparse.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __PARSE_H
#define __PARSE_H

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TOKENS 32
#define MAX_TOKENSIZE 40
#define TOK_ERR -1

typedef struct sParseBlk
{
	char str[32];
	int val;
} ParseBlock;

typedef struct sToken
{
	char str[MAX_TOKENSIZE];	// token string
	int val;					// token value
} Token;

extern Token tokens[MAX_TOKENS];

int	Parse(char *string, struct sParseBlk *pb);
int ParseTok(char *string, struct sParseBlk *pb);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xpath.h ===
//-----------------------------------------------------------------------------
// File: xpath.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __XPATH_H
#define __XPATH_H

#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef UNICODE
#define _FN(a) XPath_GetFileNameT(a, NULL)
#else
#define _FN(a) XPath_GetFileNameA(a, NULL)
#endif

#define _FNA(a) XPath_GetFileNameA(a, NULL)

void XPath_SetBasePath(TCHAR *path);
TCHAR *XPath_GetFileNameT(TCHAR *in, TCHAR *out=NULL);
char *XPath_GetFileNameA(char *in, char *out=NULL);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xshadow.h ===
#ifndef __XSHADOW_H
#define __XSHADOW_H

#include "xobj.h"
#include "xfvf.h"

class CXShadowVolume
{
	float m_fWidth;
	float m_fHeight;

	DWORD m_dwNumTriangles;
	DWORD m_dwNumVertices;
	DWORD m_dwNumEdges;

	D3DMATRIX m_Matrix;
	FVFT_XYZDIFF *m_Vert;
	WORD *m_Tris;

	void AddEdge(DWORD *edgelist, WORD v0, WORD v1);

public:
	CXShadowVolume(float w, float h);
	~CXShadowVolume();

	void AddObj(CXObject *obj, D3DXVECTOR3 *lightpos);
	void Render();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbConfig.cpp ===
//-----------------------------------------------------------------------------
// File: XbConfig.cpp
//
// Desc: Config object wraps XQueryValue
//
// Hist: 03.02.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbConfig.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Globals (cached for speed)
//-----------------------------------------------------------------------------
DWORD CXBConfig::mLanguage = 0xFFFFFFFF;




//-----------------------------------------------------------------------------
// Name: GetLanguage()
// Desc: The current language setting
//-----------------------------------------------------------------------------
DWORD CXBConfig::GetLanguage()
{
    // TCR 3-14 Global Language Setting
    if( mLanguage == 0xFFFFFFFF )
    {
        mLanguage = XGetLanguage();

        // Any unrecognized languages map to English
        if( mLanguage < XC_LANGUAGE_ENGLISH ||
            mLanguage > XC_LANGUAGE_ITALIAN )
            mLanguage = XC_LANGUAGE_ENGLISH;
    }
    return mLanguage;
}



//-----------------------------------------------------------------------------
// Name: FormatDateTime()
// Desc: Formats the incoming date/time value in the proper format for
//       the current language setting.
//
//       ftZulu must be the time in UTC format, e.g. result from FindFirstFile
//       strDate is the formatted date result. NULL allowed. Minimum 11 WCHARs.
//       strTime is the formatted time result. NULL allowed. Minimum 12 WCHARs.
//-----------------------------------------------------------------------------
VOID CXBConfig::FormatDateTime( const FILETIME& ftZulu, WCHAR* strDate, 
                                WCHAR* strTime, BOOL bIncludeSeconds )
{
    // Handle empty FILETIME
    if( ftZulu.dwLowDateTime == 0 && ftZulu.dwHighDateTime == 0 )
    {
        if( strDate != NULL )
            *strDate = 0;
        if( strTime != NULL )
            *strTime = 0;
        return;
    }

    // TCR 1-13 Display Time
    // TCR 3-15 Global Time Zone Setting

    // Convert to local time
    FILETIME ftTimeLocal;
    FileTimeToLocalFileTime( &ftZulu, &ftTimeLocal );

    // Extract date/time data
    SYSTEMTIME SystemTime;
    FileTimeToSystemTime( &ftTimeLocal, &SystemTime );

    // Format the date
    if( strDate != NULL )
    {
        const WCHAR* strDateFormat = L"%d/%d/%d";
        switch( GetLanguage() )
        {
            case XC_LANGUAGE_ENGLISH:  // mm/dd/yyyy
                wsprintfW( strDate, strDateFormat, SystemTime.wMonth,
                           SystemTime.wDay, SystemTime.wYear );
                break;

            case XC_LANGUAGE_JAPANESE: // yyyy/mm/dd
                wsprintfW( strDate, strDateFormat, SystemTime.wYear,
                           SystemTime.wMonth, SystemTime.wDay  );
                break;

            case XC_LANGUAGE_GERMAN:   // dd.mm.yyyy
                wsprintfW( strDate, L"%d.%d.%d", SystemTime.wDay, 
                           SystemTime.wMonth, SystemTime.wYear );
                break;

            case XC_LANGUAGE_FRENCH:   // dd/mm/yyyy
            case XC_LANGUAGE_SPANISH:  // dd/mm/yyyy
            case XC_LANGUAGE_ITALIAN:  // dd/mm/yyyy
            default:
                wsprintfW( strDate, strDateFormat, SystemTime.wDay,
                           SystemTime.wMonth, SystemTime.wYear );
                break;
        }
    }

    // Format the time
    if( strTime != NULL )
    {
        const WORD wHalfDay = 12;
        WORD wHour12 = 0;
        BOOL bUse24Hour = ( GetLanguage() != XC_LANGUAGE_ENGLISH );
        if( !bUse24Hour )
        {
            // Convert base 24 hours to base 12 hours
            wHour12 = SystemTime.wHour;
            if( wHour12 >= wHalfDay )
                wHour12 -= wHalfDay;
            if( wHour12 == 0 )
                wHour12 = wHalfDay;
        }

        // hh:mm
        wsprintfW( strTime, L"%d:%2.2d", bUse24Hour ? SystemTime.wHour : wHour12,
                   SystemTime.wMinute );

        // append :ss if desired
        if( bIncludeSeconds )
        {
            WCHAR strSeconds[3];
            wsprintfW( strSeconds, L":%2.2d", SystemTime.wSecond );
            lstrcatW( strTime, strSeconds );
        }

        // append AM/PM if not 24-hour clock
        if( !bUse24Hour )
            lstrcatW( strTime, ( SystemTime.wHour < wHalfDay ) ? L" AM" : L" PM" );
    }
}




//-----------------------------------------------------------------------------
// Name: FormatInt()
// Desc: Formats the incoming integer into the proper format for the current
//       language setting, including thousands separators. Minimum size for
//       strNumber is 15 bytes.
//-----------------------------------------------------------------------------
VOID CXBConfig::FormatInt( INT nValue, CHAR* strNumber )
{
    const INT RADIX = 10;       // Base 10

    // Format normally; no separtors here
    _itoa( nValue, strNumber, RADIX );

    // Determine number of separators to insert, if any
    INT nLen = lstrlenA( strNumber );
    INT nSeparators = ( nLen - 1 ) / 3;
    if( nSeparators <= 0 )
        return;

    // Separator character is based on language
    CHAR cSeparator = GetThousandsSeparator();

    // Insert separators in place via backward walk
    CHAR* pDest = strNumber + nLen + nSeparators;
    const CHAR* pSrc = strNumber + nLen;
    for( INT i = 0; i < nLen; ++i, --pDest, --pSrc )
    {
        *pDest = *pSrc;
        if( i && ( i % 3 == 0 ) )
        {
            --pDest;
            *pDest = cSeparator;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FormatFloat()
// Desc: Formats the incoming float into the proper format for the current
//       language setting. Includes thousands separators if desired.
//       nCount indicates number of chars after the decimal point. If
//       nCount is 0, the decimal point is not included. If nCount is less
//       than 0, the decimal point is not included if fValue > 1.0.
//       strNumber minimum size depends on fValue and nCount.
//-----------------------------------------------------------------------------
VOID CXBConfig::FormatFloat( DOUBLE fValue, CHAR* strNumber, INT nCount,
                             BOOL bThousandsSep )
{
    // Format normally; no decimal point or separators here
    INT nDecimalPtPos;
    INT nSign;
    CHAR* strDigits = _fcvt( fValue, (nCount < 0) ? 0 : nCount, 
                             &nDecimalPtPos, &nSign );

    CHAR cDecimal = GetDecimalSymbol();
    CHAR cSeparator = GetThousandsSeparator();

    // Sign
    if( nSign != 0 )
        *strNumber++ = '-';

    // If fValue < 1.0, include the zero before the decimal point
    if( nDecimalPtPos <= 0 )
    {
        *strNumber++ = '0';
        if( nCount > 0 )
        {
            *strNumber++ = cDecimal;
            for( INT i = nDecimalPtPos; i < 0; ++i )
                *strNumber++ = '0';
        }
    }

    // Copy the floating point digits, adding separators and the decimal symbol
    INT nOffset = 2 - ( ( nDecimalPtPos + 1 ) % 3 );
    for( INT i = 0; *strDigits ; ++i, ++strDigits )
    {
        *strNumber++ = *strDigits;

        // Thousands separator
        if( ( bThousandsSep ) && 
            ( nDecimalPtPos > 3 ) && 
            ( i < nDecimalPtPos - 1 ) && 
            ( ( ( i + nOffset ) % 3 ) == 0 ) )
        {
            *strNumber++ = cSeparator;
        }

        // Decimal point
        if( i + 1 == nDecimalPtPos && nCount > 0 )
            *strNumber++ = cDecimal;
    }

    // Slam in the null char
    *strNumber = 0;
}




//-----------------------------------------------------------------------------
// Name: GetDecimalSymbol()
// Desc: Returns the character for the decimal symbol based on the current
//       language.
//-----------------------------------------------------------------------------
CHAR CXBConfig::GetDecimalSymbol()
{
    switch( GetLanguage() )
    {
        default:
        case XC_LANGUAGE_ENGLISH:
        case XC_LANGUAGE_JAPANESE: return( '.' );
        case XC_LANGUAGE_GERMAN:
        case XC_LANGUAGE_FRENCH:
        case XC_LANGUAGE_SPANISH:
        case XC_LANGUAGE_ITALIAN:  return( ',' );
    }
}




//-----------------------------------------------------------------------------
// Name: GetThousandsSeparator()
// Desc: Returns the character for the separator symbol based on the current
//       language.
//-----------------------------------------------------------------------------
CHAR CXBConfig::GetThousandsSeparator()
{
    switch( GetLanguage() )
    {
        default:
        case XC_LANGUAGE_ENGLISH:
        case XC_LANGUAGE_JAPANESE: return( ',' );
        case XC_LANGUAGE_FRENCH:   return( ' ' );
        case XC_LANGUAGE_GERMAN:
        case XC_LANGUAGE_SPANISH:
        case XC_LANGUAGE_ITALIAN:  return( '.' );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbapp.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"
#include <D3D8Perf.h>




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
CXBApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;

// Deadzone for the gamepad inputs
const SHORT XINPUT_DEADZONE = (SHORT)( 0.24f * FLOAT(0x7FFF) );




//-----------------------------------------------------------------------------
// Name: CXBApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBApplication::CXBApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OUTPUT_DEBUG_STRING( "XBApp: Creating Direct3D...\n" );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OUTPUT_DEBUG_STRING( "XBApp: Unable to create Direct3D!\n" );
        return E_FAIL;
    }

    // Create the device
    OUTPUT_DEBUG_STRING( "XBApp: Creating the D3D device...\n" );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OUTPUT_DEBUG_STRING( "XBApp: Could not create D3D device!\n" );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    OUTPUT_DEBUG_STRING( "XBApp: Creating gamepad devices...\n" );
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        OUTPUT_DEBUG_STRING( "XBApp: Call to CreateGamepads() failed!\n" );
        return hr;
    }

    // Initialize the app's device-dependent objects
    OUTPUT_DEBUG_STRING( "XBApp: Initializing the app...\n" );
    if( FAILED( hr = Initialize() ) )
    {
        OUTPUT_DEBUG_STRING( "XBApp: Call to Initialize() failed!\n" );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID CXBApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT CXBApplication::Run()
{
    OUTPUT_DEBUG_STRING( "XBApp: Running the application...\n" );

    // Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;

    // Run the game loop, animating and rendering frames
    for( ;; )
    {
        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        INT nThumbLX = 0;
        INT nThumbLY = 0;
        INT nThumbRX = 0;
        INT nThumbRY = 0;

        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                // Only account for thumbstick info beyond the deadzone
                if( m_Gamepad[i].sThumbLX > XINPUT_DEADZONE ||
                    m_Gamepad[i].sThumbLX < -XINPUT_DEADZONE )
                    nThumbLX += m_Gamepad[i].sThumbLX;
                if( m_Gamepad[i].sThumbLY > XINPUT_DEADZONE ||
                    m_Gamepad[i].sThumbLY < -XINPUT_DEADZONE )
                    nThumbLY += m_Gamepad[i].sThumbLY;
                if( m_Gamepad[i].sThumbRX > XINPUT_DEADZONE ||
                    m_Gamepad[i].sThumbRX < -XINPUT_DEADZONE )
                    nThumbRX += m_Gamepad[i].sThumbRX;
                if( m_Gamepad[i].sThumbRY > XINPUT_DEADZONE ||
                    m_Gamepad[i].sThumbRY < -XINPUT_DEADZONE )
                    nThumbRY += m_Gamepad[i].sThumbRY;

                m_DefaultGamepad.fX1 += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1 += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2 += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2 += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Clamp summed thumbstick values to proper range
        m_DefaultGamepad.sThumbLX = SHORT( nThumbLX );
        m_DefaultGamepad.sThumbLY = SHORT( nThumbLY );
        m_DefaultGamepad.sThumbRX = SHORT( nThumbRX );
        m_DefaultGamepad.sThumbRY = SHORT( nThumbRY );

        // Handle special input combo to trigger a reboot to the Xbox Dashboard
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                {
                    LD_LAUNCH_DASHBOARD LaunchData = { XLD_LAUNCH_DASHBOARD_MAIN_MENU };
                    XLaunchNewImage( NULL, (LAUNCH_DATA*)&LaunchData );
                }
            }
        }

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

        // Check Start button
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
            m_bPaused = !m_bPaused;

        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwElapsedTime.QuadPart));
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();
    }
}




//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXBApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 1.0f, 1.0f );  v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 1.0f, 1.0f );  v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 1.0f, 1.0f );  v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 1.0f, 1.0f );  v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\include\xtextbox.h ===
#ifndef __XTEXTBOX_H
#define __XTEXTBOX_H

#include "XBFont.h"

// max textbox string length
#define TBOX_STRINGLEN 80

// textbox flags
#define TBOX_POPUP		0x01		// only active when text in box

typedef struct _XTextBoxItem
{
	DWORD val1, val2;				// user values
	WCHAR string[TBOX_STRINGLEN];
	DWORD expiretime;
	DWORD color;
} XTextBoxItem;

typedef struct _XTextBox
{
	float x, y, w, h;				// screen position & size
	DWORD flags;					// textbox flags
	DWORD textcolor;				// text color
	DWORD topcolor, bottomcolor;	// background color

	DWORD head, tail;
	DWORD maxshow;					// max lines to show
	DWORD maxitems;					// max lines to hold
	DWORD nitems;					// current number of items
	DWORD expiretime;				// time each line lives

	XTextBoxItem *items;			// text items
} XTextBox;

#ifdef __cplusplus
extern "C" {
#endif

void XTextBox_SetFont(CXBFont *font);
XTextBox *XTextBox_Init(float x, float y, float w, DWORD maxitems, DWORD flags);
void XTextBox_Shutdown();
XTextBoxItem *XTextBox_AddItem(XTextBox *xbox, WCHAR *string);
void XTextBox_Display(XTextBox *xbox);
void XTextBox_Expire(XTextBox *xbox);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbinput.cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.01 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.24f

// Global instance of input states
XINPUT_STATE g_InputStates[4];

// Global instance of custom gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_InputStates[i], sizeof(XINPUT_STATE) );
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // TCR 3-21 Controller Discovery
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
            pGamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
            pGamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( pGamepads[i].hDevice, &pGamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XInputGetState( pGamepads[i].hDevice, &g_InputStates[i] );

            // Copy gamepad to local structure
            memcpy( &pGamepads[i], &g_InputStates[i].Gamepad, sizeof(XINPUT_GAMEPAD) );

            // Put Xbox device input for the gamepad into our custom format
            FLOAT fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            pGamepads[i].fX1 = ( fX1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            pGamepads[i].fY1 = ( fY1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            pGamepads[i].fX2 = ( fX2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            pGamepads[i].fY2 = ( fY2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed or released since
            // the last call.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] > XINPUT_GAMEPAD_MAX_CROSSTALK );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);
    (VOID)dwResourceType; // not used
    (VOID)dwResourceSize; // not used

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);
    (VOID)dwBPP; // not used

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OUTPUT_DEBUG_STRING( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,     D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbhelp.cpp ===
//-----------------------------------------------------------------------------
// File: XBHelp.cpp
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.06.01 - Changes for April XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include "XBHelp.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Constants for rendering callouts on the help screen. The order of these
// callouts is in agreement with the enum structure in XBHelp.h
//-----------------------------------------------------------------------------
static D3DXVECTOR2 g_vHelpCallouts[] = 
{
    // Order:
    // Button position (start of line),
    // End of line for placement one, Start of text for placement one
    // End of line for placement two, Start of text for placement two

    // Left thumbstick
    D3DXVECTOR2( 255.0f, 149.0f ),
    D3DXVECTOR2( 141.0f,  99.0f ), D3DXVECTOR2( 108.0f,  77.0f ),
    D3DXVECTOR2( 145.0f, 124.0f ), D3DXVECTOR2( 108.0f,  77.0f ),
    
    // Right thumbstick 
    D3DXVECTOR2( 370.0f, 191.0f ),
    D3DXVECTOR2( 370.0f, 363.0f ), D3DXVECTOR2( 352.0f, 364.0f ),
    D3DXVECTOR2( 370.0f, 363.0f ), D3DXVECTOR2( 352.0f, 364.0f ),

    // D-pad
    D3DXVECTOR2( 254.0f, 194.0f ),
    D3DXVECTOR2( 117.0f, 223.0f ), D3DXVECTOR2(  78.0f, 222.0f ),
    D3DXVECTOR2( 117.0f, 223.0f ), D3DXVECTOR2(  78.0f, 222.0f ),
    
    // Back button
    D3DXVECTOR2( 288.0f, 221.0f ),
    D3DXVECTOR2( 185.0f, 284.0f ), D3DXVECTOR2( 145.0f, 282.0f ),
    D3DXVECTOR2( 185.0f, 284.0f ), D3DXVECTOR2( 145.0f, 282.0f ),

    // Start button
    D3DXVECTOR2( 322.0f, 223.0f ),
    D3DXVECTOR2( 262.0f, 343.0f ), D3DXVECTOR2( 217.0f, 340.0f ),
    D3DXVECTOR2( 262.0f, 343.0f ), D3DXVECTOR2( 217.0f, 340.0f ),

    // X button
    D3DXVECTOR2( 394.0f, 176.0f ),
    D3DXVECTOR2( 295.0f, 124.0f ), D3DXVECTOR2( 268.0f, 101.0f ),
    D3DXVECTOR2( 300.0f, 149.0f ), D3DXVECTOR2( 268.0f, 101.0f ),

    // Y button
    D3DXVECTOR2( 405.0f, 164.0f ),
    D3DXVECTOR2( 416.0f,  99.0f ), D3DXVECTOR2( 404.0f, 76.0f ),
    D3DXVECTOR2( 416.0f,  99.0f ), D3DXVECTOR2( 404.0f, 51.0f ),

    // A button
    D3DXVECTOR2( 411.0f, 189.0f ),
    D3DXVECTOR2( 431.0f, 298.0f ), D3DXVECTOR2( 424.0f, 298.0f ),
    D3DXVECTOR2( 431.0f, 298.0f ), D3DXVECTOR2( 424.0f, 298.0f ),

    // B button
    D3DXVECTOR2( 422.0f, 175.0f ),
    D3DXVECTOR2( 443.0f, 244.0f ), D3DXVECTOR2( 435.0f, 243.0f ),
    D3DXVECTOR2( 443.0f, 244.0f ), D3DXVECTOR2( 435.0f, 243.0f ),

    // White button
    D3DXVECTOR2( 424.0f, 158.0f ),
    D3DXVECTOR2( 458.0f, 124.0f ), D3DXVECTOR2( 444.0f, 102.0f ),
    D3DXVECTOR2( 448.0f, 148.0f ), D3DXVECTOR2( 444.0f, 102.0f ),
    
    // Black button
    D3DXVECTOR2( 443.0f, 170.0f ),
    D3DXVECTOR2( 456.0f, 183.0f ), D3DXVECTOR2( 442.0f, 182.0f ),
    D3DXVECTOR2( 456.0f, 183.0f ), D3DXVECTOR2( 442.0f, 182.0f ),

    // Left trigger button
    D3DXVECTOR2( 230.0f, 173.0f ),
    D3DXVECTOR2( 164.0f, 160.0f ), D3DXVECTOR2( 66.0f, 150.0f ),
    D3DXVECTOR2( 164.0f, 160.0f ), D3DXVECTOR2( 66.0f, 150.0f ),

    // Right trigger button
    D3DXVECTOR2( 462.0f, 172.0f ),
    D3DXVECTOR2( 480.0f, 170.0f ), D3DXVECTOR2( 482.0f, 158.0f ),
    D3DXVECTOR2( 480.0f, 170.0f ), D3DXVECTOR2( 482.0f, 158.0f ),

    // Misc callout
    D3DXVECTOR2(  64.0f, 380.0f ),
    D3DXVECTOR2(  64.0f, 380.0f ), D3DXVECTOR2( 64.0f, 405.0f ),
    D3DXVECTOR2(  64.0f, 380.0f ), D3DXVECTOR2( 64.0f, 380.0f ),
};




//-----------------------------------------------------------------------------
// Name: CXBHelp()
// Desc: Help class constructor
//-----------------------------------------------------------------------------
CXBHelp::CXBHelp()
{
    m_pd3dDevice      = NULL;
    m_pGamepadTexture = NULL;
    m_pVB             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBHelp()
// Desc: Help class destructor
//-----------------------------------------------------------------------------
CXBHelp::~CXBHelp()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the help class' internal objects
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strResource )
{
    // Keep track of the device
    m_pd3dDevice = pd3dDevice;

    // Create the gamepad resource
    if( FAILED( m_xprResource.Create( pd3dDevice, strResource, 1 ) ) )
        return E_FAIL;

    // Store access to the 640x480, linear gamepad texture
    m_pGamepadTexture = m_xprResource.GetTexture( 0UL );

    // Create a vertex buffer for rendering the help screen
    m_pd3dDevice->CreateVertexBuffer( 4*6*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                      0L, D3DPOOL_DEFAULT, &m_pVB );
    struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
    VERTEX* v;
    m_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
    v[0].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 0, 0 );  v[0].tu =   0; v[0].tv =   0;
    v[1].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 0, 0 );  v[1].tu = 640; v[1].tv =   0;
    v[2].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 0, 0 );  v[2].tu = 640; v[2].tv = 480;
    v[3].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 0, 0 );  v[3].tu =   0; v[3].tv = 480;
    m_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the help class' internal objects/
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Destroy()
{
    SAFE_RELEASE( m_pVB );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the gamepad help image, and it's labelled callouts.
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Render( CXBFont* pFont, XBHELP_CALLOUT* tags, 
                         DWORD dwNumCallouts )
{
    // Set state to render the gamepad image
    m_pd3dDevice->SetTexture( 0, m_pGamepadTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE, D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,     D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,     D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );

    // Render the gamepad image
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 6*sizeof(FLOAT) );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );

    // Set state to draw the lines
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    for( DWORD i=0; i<dwNumCallouts; i++ )
    {
        // Determine the line start and end positions
        WORD wLineStartIndex = tags[i].wControl;
        WORD wLineEndIndex   = tags[i].wControl + 2*(tags[i].wPlacement-1)+1;
        FLOAT line1x = g_vHelpCallouts[wLineStartIndex].x;
        FLOAT line1y = g_vHelpCallouts[wLineStartIndex].y;
        FLOAT line2x = g_vHelpCallouts[wLineEndIndex].x;
        FLOAT line2y = g_vHelpCallouts[wLineEndIndex].y;

        // Draw the callout line
        D3DXVECTOR4 v[2];
        v[0] = D3DXVECTOR4( line1x, line1y, 0.0f, 0.0f );
        v[1] = D3DXVECTOR4( line2x, line2y, 0.0f, 0.0f );
        
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, v, sizeof(D3DXVECTOR4) );
    }

    // Prepare font for rendering
    pFont->Begin();

    // Render the callouts
    for( i=0; i<dwNumCallouts; i++ )
    {
        // Determine the text position
        WORD wTextPosIndex = tags[i].wControl + 2*(tags[i].wPlacement-1)+2;
        FLOAT textx = g_vHelpCallouts[wTextPosIndex].x;
        FLOAT texty = g_vHelpCallouts[wTextPosIndex].y;

        // Draw the callout text
        pFont->DrawText( textx, texty, 0xffffffff, tags[i].strText );
    }

    // Flush the text drawing
    pFont->End();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbMediaDebug.cpp ===
//-----------------------------------------------------------------------------
// File: XbMediaDebug.cpp
//
// Desc: Miscellaneous functions to aid debugging of media/graphics/etc.
//
// Hist: 11.01.01 - New for November 2001 XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbMediaDebug.h"


//-----------------------------------------------------------------------------
// Macros to set new state, then restore old state upon leaving scope.
//-----------------------------------------------------------------------------
#define SET_D3DTSS(STAGE, NAME, VALUE)\
    struct D3DTSS_STAGE##STAGE##_##NAME {\
        DWORD m_dw; \
        D3DTSS_STAGE##STAGE##_##NAME(DWORD dw) { /* ctor saves curr value and sets new value */ \
            D3DDevice_GetTextureStageState(STAGE, NAME, &m_dw);\
            D3DDevice_SetTextureStageState(STAGE, NAME, dw);\
        }\
        ~D3DTSS_STAGE##STAGE##_##NAME() { /* on scope exit, saved value is restored */ \
            D3DDevice_SetTextureStageState(STAGE, NAME, m_dw);\
        }\
    } _D3DTSS_STAGE##STAGE##_##NAME(VALUE)

#define SET_D3DTEXTURE(STAGE, TEXTURE)\
    struct D3DTEXTURE_STAGE##STAGE {\
        D3DBaseTexture *m_pTexture; \
        D3DTEXTURE_STAGE##STAGE(D3DBaseTexture *pTexture) { /* ctor saves curr value and sets new value */ \
            D3DDevice_GetTexture(STAGE, &m_pTexture);\
            D3DDevice_SetTexture(STAGE, pTexture);\
        }\
        ~D3DTEXTURE_STAGE##STAGE() { /* on scope exit, saved value is restored */ \
            D3DDevice_SetTexture(STAGE, m_pTexture);\
            if (m_pTexture != NULL) m_pTexture->Release();\
        }\
    } _D3DTEXTURE_STAGE##STAGE(TEXTURE)

#define SET_D3DRS(NAME, VALUE)\
    struct D3DRS_##NAME {\
        DWORD m_dw; \
        D3DRS_##NAME(DWORD dw) { /* ctor saves curr value and sets new value */ \
            D3DDevice_GetRenderState(NAME, &m_dw);\
            D3DDevice_SetRenderState(NAME, dw);\
        }\
        ~D3DRS_##NAME() { /* on scope exit, saved value is restored */ \
            D3DDevice_SetRenderState(NAME, m_dw);\
        }\
    } _D3DRS_##NAME(VALUE)

#define SET_D3DVERTEXSHADER(VALUE)\
    struct D3DVERTEXSHADER {\
        DWORD m_dw; \
        D3DVERTEXSHADER(DWORD dw) { /* ctor saves curr value and sets new value */ \
            D3DDevice_GetVertexShader(&m_dw);\
            D3DDevice_SetVertexShader(dw);\
        }\
        ~D3DVERTEXSHADER() { /* on scope exit, saved value is restored */ \
            D3DDevice_SetVertexShader(m_dw);\
        }\
    } _D3DVERTEXSHADER(VALUE)

#define SET_D3DPIXELSHADER(VALUE)\
    struct D3DPIXELSHADER {\
        DWORD m_dw; \
        D3DPIXELSHADER(DWORD dw) { /* ctor saves curr value and sets new value */ \
            D3DDevice_GetPixelShader(&m_dw);\
            D3DDevice_SetPixelShader(dw);\
        }\
        ~D3DPIXELSHADER() { /* on scope exit, saved value is restored */ \
            D3DDevice_SetPixelShader(m_dw);\
        }\
    } _D3DPIXELSHADER(VALUE)

#define SET_D3DVIEWPORT(PVIEWPORT)\
    struct D3DVIEWPORT {\
        D3DVIEWPORT8 m_viewport; \
        D3DVIEWPORT(D3DVIEWPORT *pViewport) { /* ctor saves curr value and sets new value */ \
            D3DDevice_GetViewport(&m_viewport);\
            D3DDevice_SetViewport(pViewport);\
        }\
        ~D3DVIEWPORT() { /* on scope exit, saved value is restored */ \
            D3DDevice_SetViewport(&m_viewport);\
        }\
    } _D3DVIEWPORT(PVIEWPORT)

#define SET_D3DTRANSFORM(NAME, PTRANSFORM)\
    struct D3DTRANSFORM_##NAME {\
        D3DMATRIX m_transform; \
        D3DTRANSFORM_##NAME(D3DMATRIX *pTransform) { /* ctor saves curr value and sets new value */ \
            D3DDevice_GetTransform(NAME, &m_transform);\
            D3DDevice_SetTransform(NAME, pTransform);\
        }\
        ~D3DTRANSFORM_##NAME() { /* on scope exit, saved value is restored */ \
            D3DDevice_SetTransform(NAME, &m_transform);\
        }\
    } _D3DTRANSFORM_##NAME(PTRANSFORM)


#define SETUP_RENDER_TARGET() \
    struct DebugSetupRenderTarget \
    { \
        IDirect3DSurface8* m_pPrevColorBuffer; \
        IDirect3DSurface8* m_pPrevDepthBuffer; \
      \
        DebugSetupRenderTarget() \
        { \
            /* Save info about the current render target */ \
            D3DDevice_GetRenderTarget( &m_pPrevColorBuffer ); \
            D3DDevice_GetDepthStencilSurface( &m_pPrevDepthBuffer ); \
          \
            /* Make the front buffer the new render target */ \
            IDirect3DSurface8* pFrontBuffer = NULL; \
            D3DDevice_GetBackBuffer( -1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer ); \
            D3DDevice_SetRenderTarget( pFrontBuffer, NULL ); \
            pFrontBuffer->Release(); \
          \
            /* Make sure all the commands so far are done */ \
            D3DDevice_BlockUntilIdle(); \
        } \
      \
        ~DebugSetupRenderTarget() \
        { \
            /* Restore render target, etc. */ \
            D3DDevice_SetRenderTarget( m_pPrevColorBuffer, m_pPrevDepthBuffer ); \
            if( m_pPrevColorBuffer )  { m_pPrevColorBuffer->Release(); } \
            if( m_pPrevDepthBuffer )  { m_pPrevDepthBuffer->Release(); } \
        } \
    } __DebugSetupRenderTarget;



//-----------------------------------------------------------------------------
// Name: DebugPresent
// Desc: Forces all GPU commands to be processed, so that data will appear
//       on-screen.
//-----------------------------------------------------------------------------
HRESULT __cdecl DebugPresent()
{
    D3DDevice_KickPushBuffer();
    D3DDevice_BlockUntilIdle();
    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// FORMAT REMAPPING
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Name: MapLinearToSwizzledFormat
// Desc: Convert from a linear D3DFORMAT to the equivalent swizzled format.
//-----------------------------------------------------------------------------
D3DFORMAT __cdecl MapLinearToSwizzledFormat( D3DFORMAT fmt )
{
    switch( fmt )
    {
        case D3DFMT_LIN_A1R5G5B5:   return D3DFMT_A1R5G5B5;
        case D3DFMT_LIN_A4R4G4B4:   return D3DFMT_A4R4G4B4;
        case D3DFMT_LIN_A8:         return D3DFMT_A8;
        case D3DFMT_LIN_A8B8G8R8:   return D3DFMT_A8B8G8R8;
        case D3DFMT_LIN_A8R8G8B8:   return D3DFMT_A8R8G8B8;
        case D3DFMT_LIN_B8G8R8A8:   return D3DFMT_B8G8R8A8;
        case D3DFMT_LIN_G8B8:       return D3DFMT_G8B8;
        case D3DFMT_LIN_R4G4B4A4:   return D3DFMT_R4G4B4A4;
        case D3DFMT_LIN_R5G5B5A1:   return D3DFMT_R5G5B5A1;
        case D3DFMT_LIN_R5G6B5:     return D3DFMT_R5G6B5;
        case D3DFMT_LIN_R6G5B5:     return D3DFMT_R6G5B5;
        case D3DFMT_LIN_R8B8:       return D3DFMT_R8B8;
        case D3DFMT_LIN_R8G8B8A8:   return D3DFMT_R8G8B8A8;
        case D3DFMT_LIN_X1R5G5B5:   return D3DFMT_X1R5G5B5;
        case D3DFMT_LIN_X8R8G8B8:   return D3DFMT_X8R8G8B8;
        case D3DFMT_LIN_A8L8:       return D3DFMT_A8L8;
        case D3DFMT_LIN_AL8:        return D3DFMT_AL8;
        case D3DFMT_LIN_L16:        return D3DFMT_L16;
        case D3DFMT_LIN_L8:         return D3DFMT_L8;
        case D3DFMT_LIN_V16U16:     return D3DFMT_V16U16;
//These constants have same value as other constants above.
//        case D3DFMT_LIN_V8U8:       return D3DFMT_V8U8;
//        case D3DFMT_LIN_L6V5U5:     return D3DFMT_L6V5U5;
//        case D3DFMT_LIN_X8L8V8U8:   return D3DFMT_X8L8V8U8;
//        case D3DFMT_LIN_Q8W8V8U8:   return D3DFMT_Q8W8V8U8;
        case D3DFMT_LIN_D24S8:      return D3DFMT_D24S8;
        case D3DFMT_LIN_F24S8:      return D3DFMT_F24S8;
        case D3DFMT_LIN_D16:        return D3DFMT_D16;
        case D3DFMT_LIN_F16:        return D3DFMT_F16;
        default:
            return fmt;
    }
}



//-----------------------------------------------------------------------------
// Name: MapSwizzledToLinearFormat
// Desc: Convert from a swizzled D3DFORMAT to the equivalent linear format.
//-----------------------------------------------------------------------------
D3DFORMAT __cdecl MapSwizzledToLinearFormat( D3DFORMAT fmt )
{
    switch( fmt )
    {
        case D3DFMT_A1R5G5B5:   return D3DFMT_LIN_A1R5G5B5;
        case D3DFMT_A4R4G4B4:   return D3DFMT_LIN_A4R4G4B4;
        case D3DFMT_A8:         return D3DFMT_LIN_A8;
        case D3DFMT_A8B8G8R8:   return D3DFMT_LIN_A8B8G8R8;
        case D3DFMT_A8R8G8B8:   return D3DFMT_LIN_A8R8G8B8;
        case D3DFMT_B8G8R8A8:   return D3DFMT_LIN_B8G8R8A8;
        case D3DFMT_G8B8:       return D3DFMT_LIN_G8B8;
        case D3DFMT_R4G4B4A4:   return D3DFMT_LIN_R4G4B4A4;
        case D3DFMT_R5G5B5A1:   return D3DFMT_LIN_R5G5B5A1;
        case D3DFMT_R5G6B5:     return D3DFMT_LIN_R5G6B5;
        case D3DFMT_R6G5B5:     return D3DFMT_LIN_R6G5B5;
        case D3DFMT_R8B8:       return D3DFMT_LIN_R8B8;
        case D3DFMT_R8G8B8A8:   return D3DFMT_LIN_R8G8B8A8;
        case D3DFMT_X1R5G5B5:   return D3DFMT_LIN_X1R5G5B5;
        case D3DFMT_X8R8G8B8:   return D3DFMT_LIN_X8R8G8B8;
        case D3DFMT_A8L8:       return D3DFMT_LIN_A8L8;
        case D3DFMT_AL8:        return D3DFMT_LIN_AL8;
        case D3DFMT_L16:        return D3DFMT_LIN_L16;
        case D3DFMT_L8:         return D3DFMT_LIN_L8;
        case D3DFMT_V16U16:     return D3DFMT_LIN_V16U16;
//These constants have same value as other constants above.
//        case D3DFMT_V8U8:       return D3DFMT_LIN_V8U8;
//        case D3DFMT_L6V5U5:     return D3DFMT_LIN_L6V5U5;
//        case D3DFMT_X8L8V8U8:   return D3DFMT_LIN_X8L8V8U8;
//        case D3DFMT_Q8W8V8U8:   return D3DFMT_LIN_Q8W8V8U8;
        case D3DFMT_D24S8:      return D3DFMT_LIN_D24S8;
        case D3DFMT_F24S8:      return D3DFMT_LIN_F24S8;
        case D3DFMT_D16:        return D3DFMT_LIN_D16;
        case D3DFMT_F16:        return D3DFMT_LIN_F16;
        default:
            return fmt;
    }
}



//-----------------------------------------------------------------------------
// Name: MapToColorFormat
// Desc: Given a D3DFORMAT, return a format with which the data can be
//       displayed visually.  For example, we might convert from D24S8 to
//       R8G8B8A8.  Useful for debugging texture/surface contents visually.
// Note: For some formats, it's not clear what the "right" choice is, but we
//       try to pick something reasonable.
//-----------------------------------------------------------------------------
D3DFORMAT __cdecl MapToColorFormat( D3DFORMAT fmt )
{
    switch( fmt )
    {
        // Swizzled formats
        //case D3DFMT_P8:  // don't remap; just use current palette
        case D3DFMT_A8:
        case D3DFMT_AL8:
            return D3DFMT_L8;

        case D3DFMT_A8L8:
        case D3DFMT_L16:
        case D3DFMT_V8U8:
            return D3DFMT_G8B8;

        case D3DFMT_L6V5U5:
            return D3DFMT_R6G5B5;

        case D3DFMT_X8L8V8U8:
        case D3DFMT_Q8W8V8U8:
        case D3DFMT_V16U16:
            return D3DFMT_A8R8G8B8;

        case D3DFMT_D16:
        case D3DFMT_F16:
            return D3DFMT_R5G6B5;

        case D3DFMT_D24S8:
        case D3DFMT_F24S8:
            return D3DFMT_R8G8B8A8;


        // Linear formats
        case D3DFMT_LIN_A8:
        case D3DFMT_LIN_AL8:
            return D3DFMT_LIN_L8;

        case D3DFMT_LIN_A8L8:
        case D3DFMT_LIN_L16:
        case D3DFMT_LIN_V8U8:
            return D3DFMT_LIN_G8B8;

        case D3DFMT_LIN_L6V5U5:
            return D3DFMT_LIN_R6G5B5;

        case D3DFMT_LIN_X8L8V8U8:
        case D3DFMT_LIN_Q8W8V8U8:
        case D3DFMT_LIN_V16U16:
            return D3DFMT_LIN_A8R8G8B8;

        case D3DFMT_LIN_D16:
        case D3DFMT_LIN_F16:
            return D3DFMT_LIN_R5G6B5;
    
        case D3DFMT_LIN_D24S8:
        case D3DFMT_LIN_F24S8:
            return D3DFMT_LIN_R8G8B8A8;

        default:
            return fmt;
    }
}



///////////////////////////////////////////////////////////////////////////////
// BUFFER CLEARING
///////////////////////////////////////////////////////////////////////////////

D3DXCOLOR g_DebugClearColor(0.5f, 0.5f, 0.5f, 1.0f); // bkgrnd color when this lib clears screen


//-----------------------------------------------------------------------------
// Name: DebugClear
// Desc: Clears the current color buffer (but not z or stencil), using the
//       value specified in 'g_DebugClearColor'.
//-----------------------------------------------------------------------------
void __cdecl DebugClear()
{
    D3DDevice_Clear( 0L, NULL, D3DCLEAR_TARGET, g_DebugClearColor, 1.0f, 0 );
}



///////////////////////////////////////////////////////////////////////////////
// TEXTURE/SURFACE DEBUGGING
///////////////////////////////////////////////////////////////////////////////

bool g_bDebugShrinkToFit = true;   // decrease size (if necess) to fit screen
bool g_bDebugExpandToFit = false;  // increase size (if necess) to fill screen
bool g_bDebugAlpha = false;  // view the alpha channel when rendering


//-----------------------------------------------------------------------------
// Name: DebugPixels
// Desc: Displays a pTexture or pSurface (you can pass-in either one here).
//       For convenience, you can also pass-in special pre-defined values for
//       convenient access to common surfaces:
//          1 == 1st back-color-buffer (note: differs from GetBackBuffer param)
//          2 == 2nd back-color-buffer
//          N == Nth back-color-buffer
//         -1 == depth-stencil-buffer
// Note: This function can be called via the debugger watch window, in which
//       case it will be executed with each step through the code.
//-----------------------------------------------------------------------------
HRESULT __cdecl DebugPixels( void* pTextureOrSurface, UINT iLevel )
{
    D3DPixelContainer* pPixelContainer = (D3DPixelContainer*)pTextureOrSurface;
    
    //
    // Check for special-code argument
    //
    bool bSpecialCodeSurface = false;
    if( int(pTextureOrSurface) >= 1  &&  int(pTextureOrSurface) <= 8 )
    {
        // requested a back color buffer
        bSpecialCodeSurface = true;
        D3DDevice_GetBackBuffer( int(pTextureOrSurface) - 1,
                                 D3DBACKBUFFER_TYPE_MONO,
                                 (D3DSurface**)&pPixelContainer );
    }
    else if( int(pTextureOrSurface) == -1 )
    {
        // requested depth-stencil buffer
        bSpecialCodeSurface = true;
        D3DDevice_GetDepthStencilSurface( (D3DSurface**)&pPixelContainer );
    }

    if( NULL == pPixelContainer )  { return S_FALSE; }


    //
    // Get info about the width, height, format, etc. of the texture/surface
    //
    D3DSURFACE_DESC desc;
    DWORD dwPixelContainerType = (pPixelContainer->Common & D3DCOMMON_TYPE_MASK);
    switch( dwPixelContainerType )
    {
        case D3DCOMMON_TYPE_TEXTURE:
        {
            D3DTexture* pTexture = (D3DTexture*)pPixelContainer;

            DWORD nLevels = pTexture->GetLevelCount();
            if(iLevel >= nLevels)
            {
                return S_FALSE;
            }

            pTexture->GetLevelDesc(iLevel, &desc);
        }
        break;

        case D3DCOMMON_TYPE_SURFACE:
        {
            D3DSurface* pSurface = (D3DSurface*)pPixelContainer;

            pSurface->GetDesc(&desc);
            iLevel = 0;  // no other choice for surface; don't let caller specify something else
        }
        break;

        default:
            return S_FALSE; // we only handle textures and surfaces
    }


    //
    // In case the texture/surface was in tiled memory, make a temp copy here
    // (w/o tiling), so that we will always view "real" contents w/o distortion
    // caused by tiling. (Yeah, this isn't optimal, and it isn't always
    // required, but it makes this function much more robust. And this is only
    // a debug function anyway....)
    //
    D3DTexture* pTexCopy = NULL;
    D3DSurface* pSurfSrc  = NULL;
    D3DSurface* pSurfDest = NULL;

    // Copy the desired level
    D3DDevice_CreateTexture( desc.Width, desc.Height, 1, 0, desc.Format, 0, &pTexCopy );
    if( NULL == pTexCopy )  { return S_FALSE; }
    {
        pTexCopy->GetSurfaceLevel( 0, &pSurfDest );
        switch(dwPixelContainerType)
        {
          case D3DCOMMON_TYPE_TEXTURE:
            ((D3DTexture*)pPixelContainer)->GetSurfaceLevel(iLevel, &pSurfSrc);
            break;
          case D3DCOMMON_TYPE_SURFACE:
            pSurfSrc = (D3DSurface*)pPixelContainer;
            break;
        }

        D3DDevice_CopyRects( pSurfSrc, NULL, 0, pSurfDest, NULL );

        pSurfDest->Release();
        switch(dwPixelContainerType)
        {
          case D3DCOMMON_TYPE_TEXTURE:  
            pSurfSrc->Release();
            break;
          case D3DCOMMON_TYPE_SURFACE:
            break;
        }
    }


    //
    // Hack the format info so that it's a viewable color-based format
    // (in case it was z-based, or whatever)
    //
    D3DFORMAT fmtOld = (D3DFORMAT)((pPixelContainer->Format & D3DFORMAT_FORMAT_MASK) >> D3DFORMAT_FORMAT_SHIFT);
    D3DFORMAT fmtTemp = MapToColorFormat(fmtOld); // remap it
    pTexCopy->Format = (pTexCopy->Format & ~D3DFORMAT_FORMAT_MASK) | (fmtTemp << D3DFORMAT_FORMAT_SHIFT);


    //
    // Calculate output size and position
    //
    UINT outpSizeX, outpSizeY;
    if(    (g_bDebugShrinkToFit && (desc.Width > 400 || desc.Height > 400))
        || (g_bDebugExpandToFit && (desc.Width < 400 && desc.Height < 400)) )
    {
        // modify size to fit well on screen (but maintain aspect ratio)
        if( desc.Width > desc.Height )
        {
            outpSizeX = 400;
            outpSizeY = int( desc.Height * (400.0f / float(desc.Width))  );
        }
        else
        {
            outpSizeY = 400;
            outpSizeX = int( desc.Width  * (400.0f / float(desc.Height)) );
        }
    }
    else
    {
        // don't modify size of texture/surface when displaying on screen
        outpSizeX = desc.Width;
        outpSizeY = desc.Height;
    }

    D3DDISPLAYMODE DisplayMode;
    D3DDevice_GetDisplayMode(&DisplayMode);
    UINT outpOffsetX = (DisplayMode.Width  - outpSizeX) / 2;  // center texture
    UINT outpOffsetY = (DisplayMode.Height - outpSizeY) / 2;

    // Account for linear vs swizzled tex coords.
    float maxU, maxV;
    if( XGIsSwizzledFormat(desc.Format) )
    {
        maxU = 1.0f;
        maxV = 1.0f;
    } else {
        maxU = (float)(desc.Width);
        maxV = (float)(desc.Height);
    }

    // Setup geometry for displaying texture/surface on screen.
    struct
    {
        float x, y, z, w;
        float u, v;
    }
    rgQuad[4] =
    {
        {outpOffsetX - 0.5f,             outpOffsetY - 0.5f,             1.0f, 1.0f, 0.0f, 0.0f },
        {outpOffsetX + outpSizeX - 0.5f, outpOffsetY - 0.5f,             1.0f, 1.0f, maxU, 0.0f },
        {outpOffsetX - 0.5f,             outpOffsetY + outpSizeY - 0.5f, 1.0f, 1.0f, 0.0f, maxV },
        {outpOffsetX + outpSizeX - 0.5f, outpOffsetY + outpSizeY - 0.5f, 1.0f, 1.0f, maxU, maxV }
    };


    //
    // Setup render states and texture states as necessary
    //
    // Notice that we set a lot of state here, because we may be called at any
    // time.  The device could be set to some arbitrary state, which could
    // cause rendering problems unless we set all states that we rely upon.
    //
    SETUP_RENDER_TARGET();

    SET_D3DVERTEXSHADER( D3DFVF_XYZRHW | D3DFVF_TEX1 );
    SET_D3DPIXELSHADER( 0 );

    SET_D3DRS( D3DRS_FILLMODE,                     D3DFILL_SOLID );
    SET_D3DRS( D3DRS_BACKFILLMODE,                 D3DFILL_SOLID );
    SET_D3DRS( D3DRS_CULLMODE,                     D3DCULL_NONE );
    SET_D3DRS( D3DRS_DITHERENABLE,                 TRUE );
    SET_D3DRS( D3DRS_ALPHATESTENABLE,              FALSE );
    SET_D3DRS( D3DRS_ALPHABLENDENABLE,             FALSE );
    SET_D3DRS( D3DRS_FOGENABLE,                    FALSE );
    SET_D3DRS( D3DRS_EDGEANTIALIAS,                FALSE );
    SET_D3DRS( D3DRS_STENCILENABLE,                FALSE );
    SET_D3DRS( D3DRS_LIGHTING,                     FALSE );
    SET_D3DRS( D3DRS_MULTISAMPLEMASK,              0xffffffff );
    SET_D3DRS( D3DRS_LOGICOP,                      D3DLOGICOP_NONE );
    SET_D3DRS( D3DRS_COLORWRITEENABLE,             D3DCOLORWRITEENABLE_ALL );
    SET_D3DRS( D3DRS_YUVENABLE,                    FALSE );
    SET_D3DRS( D3DRS_SPECULARENABLE,               FALSE );
    SET_D3DRS( D3DRS_ZBIAS,                        0 );
    SET_D3DRS( D3DRS_MULTISAMPLERENDERTARGETMODE,  D3DMULTISAMPLEMODE_1X );

    SET_D3DRS( D3DRS_ZENABLE,                      D3DZB_FALSE );

    SET_D3DTEXTURE( 0, pTexCopy );
    SET_D3DTSS( 0, D3DTSS_COLOROP,       D3DTOP_SELECTARG1 );
    SET_D3DTSS( 0, D3DTSS_COLORARG1,     g_bDebugAlpha ? D3DTA_TEXTURE|D3DTA_ALPHAREPLICATE : D3DTA_TEXTURE );
    SET_D3DTSS( 0, D3DTSS_ALPHAOP,       D3DTOP_SELECTARG1 );
    SET_D3DTSS( 0, D3DTSS_ALPHAARG1,     D3DTA_TEXTURE );
    SET_D3DTSS( 0, D3DTSS_TEXCOORDINDEX, 0 );
    SET_D3DTSS( 0, D3DTSS_ADDRESSU,      D3DTADDRESS_CLAMP );
    SET_D3DTSS( 0, D3DTSS_ADDRESSV,      D3DTADDRESS_CLAMP );
    SET_D3DTSS( 0, D3DTSS_ADDRESSW,      D3DTADDRESS_CLAMP );
    SET_D3DTSS( 0, D3DTSS_COLORKEYOP,    D3DTCOLORKEYOP_DISABLE );
    SET_D3DTSS( 0, D3DTSS_COLORSIGN,     0 );
    SET_D3DTSS( 0, D3DTSS_ALPHAKILL,     D3DTALPHAKILL_DISABLE );
    SET_D3DTSS( 0, D3DTSS_MINFILTER,     D3DTEXF_POINT );
    SET_D3DTSS( 0, D3DTSS_MAGFILTER,     D3DTEXF_POINT );

    float fMipBias = -1000.f; // bias mipmap toward the more detailed level
    SET_D3DTSS( 0, D3DTSS_MIPMAPLODBIAS, *((DWORD*) (&fMipBias)) );
    SET_D3DTSS( 0, D3DTSS_MAXMIPLEVEL,   0 );
    SET_D3DTSS( 0, D3DTSS_MIPFILTER,     D3DTEXF_POINT );
    SET_D3DTEXTURE( 1, NULL );
    SET_D3DTSS( 1, D3DTSS_COLOROP,       D3DTOP_DISABLE );
    SET_D3DTSS( 1, D3DTSS_ALPHAOP,       D3DTOP_DISABLE );
    SET_D3DTSS( 1, D3DTSS_ALPHAKILL,     D3DTALPHAKILL_DISABLE );
    SET_D3DTEXTURE( 2, NULL );
    SET_D3DTSS( 2, D3DTSS_COLOROP,       D3DTOP_DISABLE );
    SET_D3DTSS( 2, D3DTSS_ALPHAOP,       D3DTOP_DISABLE );
    SET_D3DTSS( 2, D3DTSS_ALPHAKILL,     D3DTALPHAKILL_DISABLE );
    SET_D3DTEXTURE( 3, NULL );
    SET_D3DTSS( 3, D3DTSS_COLOROP,       D3DTOP_DISABLE );
    SET_D3DTSS( 3, D3DTSS_ALPHAOP,       D3DTOP_DISABLE );
    SET_D3DTSS( 3, D3DTSS_ALPHAKILL,     D3DTALPHAKILL_DISABLE );


    //
    // Draw the texture/surface
    //
    DebugClear();
    D3DDevice_DrawVerticesUP(D3DPT_TRIANGLESTRIP, 4, rgQuad, sizeof(rgQuad[0]));
    DebugPresent();

    D3DDevice_SetTexture(0,NULL); // so D3D won't complain when we reset tex-addressing modes
                                  // (eg, to avoid case where linear tex + wrap mode gets set)

    //
    // Cleanup
    //
    if( NULL != pTexCopy )  { pTexCopy->Release(); }
    if( bSpecialCodeSurface  &&  NULL != pPixelContainer )
    {
        pPixelContainer->Release();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbMemUnit.cpp ===
//-----------------------------------------------------------------------------
// File: XbMemUnit.cpp
//
// Desc: Memory unit object wraps XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT )
//       and XMount/UnmountMU
//
// Hist: 01.29.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbMemUnit.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Name: CXBMemUnit()
// Desc: Creates an unmounted memory unit object
//-----------------------------------------------------------------------------
CXBMemUnit::CXBMemUnit( DWORD dwPort, DWORD dwSlot )
:
    m_dwPort( dwPort ),
    m_dwSlot( dwSlot ),
    m_chLogicalDrive( 0 )
{
    assert( dwPort == dwINVALID || dwPort >= XDEVICE_PORT0 );
    assert( dwPort == dwINVALID || dwPort <= XDEVICE_PORT3 );
    assert( dwSlot == dwINVALID || 
            dwSlot == XDEVICE_TOP_SLOT || dwSlot == XDEVICE_BOTTOM_SLOT );
}




//-----------------------------------------------------------------------------
// Name: CXBMemUnit()
// Desc: Copies the given memory unit. Note: You cannot mount a device more 
//       than once. CXBMemUnit is a lightweight wrapper that doesn't
//       implement reference counting. Therefore, the only safe copy is a 
//       copy of an unmounted MU. This function asserts if the source
//       MU is already mounted.
//-----------------------------------------------------------------------------
CXBMemUnit::CXBMemUnit( const CXBMemUnit& rhs )
:
    m_dwPort( rhs.m_dwPort ),
    m_dwSlot( rhs.m_dwSlot ),
    m_chLogicalDrive( 0 )
{
    assert( !rhs.IsMounted() );
    (VOID)rhs;
}



//-----------------------------------------------------------------------------
// Name: CXBMemUnit()
// Desc: Copies the given memory unit. Note: You cannot mount a device more 
//       than once. CXBMemUnit is a lightweight wrapper that doesn't
//       implement reference counting. Therefore, the only safe copy is a 
//       copy of an unmounted MU. This function asserts if the source
//       MU is already mounted.
//-----------------------------------------------------------------------------
CXBMemUnit& CXBMemUnit::operator=( const CXBMemUnit& rhs )
{
    assert( !rhs.IsMounted() );
    m_dwPort = rhs.m_dwPort;
    m_dwSlot = rhs.m_dwSlot;
    m_chLogicalDrive = 0;
    return *this;
}




//-----------------------------------------------------------------------------
// Name: ~CXBMemUnit()
// Desc: Unmounts the memory unit
//-----------------------------------------------------------------------------
CXBMemUnit::~CXBMemUnit()
{
    Unmount();
}




//-----------------------------------------------------------------------------
// Name: Insert()
// Desc: Sets the port and slot numbers. IsValid() will now return TRUE.
//-----------------------------------------------------------------------------
VOID CXBMemUnit::Insert( DWORD dwPort, DWORD dwSlot )
{
    assert( dwPort >= XDEVICE_PORT0 );
    assert( dwPort <= XDEVICE_PORT3 );
    assert( dwSlot == XDEVICE_TOP_SLOT || dwSlot == XDEVICE_BOTTOM_SLOT );

    if( m_dwPort == dwPort && m_dwSlot == dwSlot )
        return;

    Unmount();
    m_dwPort = dwPort;
    m_dwSlot = dwSlot;
}




//-----------------------------------------------------------------------------
// Name: Mount()
// Desc: Mounts the memory unit in preparation for saving/loading. If
//       successful, GetDrive() will contain the drive mapping for the MU.
//-----------------------------------------------------------------------------
BOOL CXBMemUnit::Mount( DWORD& dwError )
{
    assert( IsValid() );

    // If already mounted, do nothing
    if( IsMounted() )
        return TRUE;

    Unmount();
    CHAR chDrive;
    dwError = XMountMU( m_dwPort, m_dwSlot, &chDrive );
    if( dwError != ERROR_SUCCESS )
        return FALSE;

    m_chLogicalDrive = chDrive;
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: Unmount()
// Desc: Unmounts the memory unit when it is no longer used. If successful,
//       calls to IsMounted() will return FALSE.
//-----------------------------------------------------------------------------
VOID CXBMemUnit::Unmount()
{
    if( IsMounted() )
    {
        DWORD dwSuccess = XUnmountMU( m_dwPort, m_dwSlot );
        assert( dwSuccess == ERROR_SUCCESS );
        (VOID)dwSuccess;
        m_chLogicalDrive = 0;
    }
}




//-----------------------------------------------------------------------------
// Name: Remove()
// Desc: Unmounts and invalidates the memory unit. Used when an MU is pulled
//       from its slot. If successful, calls to IsValid() will return FALSE.
//-----------------------------------------------------------------------------
VOID CXBMemUnit::Remove()
{
    Unmount();
    m_dwPort = dwINVALID;
    m_dwSlot = dwINVALID;
}




//-----------------------------------------------------------------------------
// Name: IsValid()
// Desc: Returns TRUE if the MU refers to a valid port and slot
//-----------------------------------------------------------------------------
BOOL CXBMemUnit::IsValid() const
{
    return( m_dwPort != dwINVALID && m_dwSlot != dwINVALID );
}




//-----------------------------------------------------------------------------
// Name: IsMounted()
// Desc: Returns TRUE if the MU is currently mounted
//-----------------------------------------------------------------------------
BOOL CXBMemUnit::IsMounted() const
{
    return( IsValid() && m_chLogicalDrive != 0 );
}




//-----------------------------------------------------------------------------
// Name: GetDrive()
// Desc: Returns the logical drive mapping for the MU. Returns 0 if the MU 
//       is not mounted.
//-----------------------------------------------------------------------------
CHAR CXBMemUnit::GetDrive() const
{
    assert( IsValid() );
    return m_chLogicalDrive;
}




//-----------------------------------------------------------------------------
// Name: GetPort()
// Desc: Returns the MU port (XDEVICE_PORT0-3)
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetPort() const
{
    assert( IsValid() );
    return m_dwPort;
}




//-----------------------------------------------------------------------------
// Name: GetSlot()
// Desc: Returns the MU slot (XDEVICE_TOP_SLOT or XDEVICE_BOTTOM_SLOT)
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetSlot() const
{
    assert( IsValid() );
    return m_dwSlot;
}




//-----------------------------------------------------------------------------
// Name: GetName()
// Desc: Get the full name of the device. Assumes the buffer holds at least
//       MAX_MUNAME + 32 characters. Does not require that the MU has been
//       mounted. Resulting name is of the form: "Xbox MU 2B (PersonalName)"
//-----------------------------------------------------------------------------
VOID CXBMemUnit::GetName( WCHAR* strPathBuffer ) const
{
    assert( strPathBuffer != NULL );
    assert( IsValid() );

    // Build the default name
    lstrcpyW( strPathBuffer, L"Xbox MU " );
    
    // Append port and slot
    DWORD dwLen = lstrlenW( strPathBuffer );
    strPathBuffer[dwLen++] = WCHAR( m_dwPort + '1' );
    strPathBuffer[dwLen++] = WCHAR( m_dwSlot + 'A' );
    strPathBuffer[dwLen] = 0;

    // TCR 3-10 Memory Unit Personalization
    // If the player has named the memory unit, append the name
    WCHAR strName[ MAX_MUNAME ];
    DWORD dwSuccess;
    if( IsMounted() )
    {
        // If the MU is already mounted, use drive letter to extract name
        dwSuccess = XMUNameFromDriveLetter( m_chLogicalDrive, strName, MAX_MUNAME );
    }
    else
    {
        // If the MU is not mounted, use lightweight method.
        // This API is not currently implemented, but may appear in a
        // future release.
        // dwSuccess = XMUNameFromPortSlot( m_dwPort, m_dwSlot, strName, MAX_MUNAME );
        dwSuccess = 0;
        *strName = 0;
    }

    if( dwSuccess == ERROR_SUCCESS && *strName != 0 )
    {
        // If there was a valid personal name, append it in parens
        WCHAR strFmtName[ MAX_MUNAME + 3 ];
        wsprintfW( strFmtName, L" (%ls)", strName );
        lstrcatW( strPathBuffer, strFmtName );
    }
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitSnapshot()
// Desc: Calls XGetDevices( XDEVICE_TYPE_MEMORY_UNIT ) to determine
//       what MUs are available. Returns a bitmask corresponding to the
//       installed MUs. May take on the order of 1 second.
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetMemUnitSnapshot() // static
{
    return XGetDevices( XDEVICE_TYPE_MEMORY_UNIT );
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitChanges()
// Desc: Calls XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT ) to determine
//       which MUs have been added or removed since the last call to
//       GetMemUnitChanges() or GetMemUnitShapshot(). Returns TRUE if there 
//       were any dynamic insertions or removals since the last call to
//       GetMemUnitChanges() or GetMemUnitSnapshot(). Parameters return
//       bitmasks indicating what devices have changed.
//-----------------------------------------------------------------------------
BOOL CXBMemUnit::GetMemUnitChanges( DWORD& dwInsertions, DWORD& dwRemovals ) // static
{
    return XGetDeviceChanges( XDEVICE_TYPE_MEMORY_UNIT, &dwInsertions, &dwRemovals );
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitMask()
// Desc: Given an MU index, returns the matching bitmask used by 
//       XGetDevices( XDEVICE_TYPE_MEMORY_UNIT )
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetMemUnitMask( DWORD i ) // static
{
    // The XGetDevices bitmask is formatted as follows:
    //
    //      0x00000001      port 0 top slot         i = 0
    //      0x00010000      port 0 bottom slot          1
    //      0x00000002      port 1 top slot             2
    //      0x00020000      port 1 bottom slot          3
    //      0x00000004      port 2 top slot             4
    //      0x00040000      port 2 bottom slot          5
    //      0x00000008      port 3 top slot             6
    //      0x00080000      port 3 bottom slot          7

    DWORD dwMask = 1 << GetMemUnitPort( i );
    if( GetMemUnitSlot( i ) == XDEVICE_BOTTOM_SLOT )
        dwMask <<= 16;

    return( dwMask );
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitPort()
// Desc: Given an MU index, returns the port number for the MU
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetMemUnitPort( DWORD i ) // static
{
    return( i / 2 );
}




//-----------------------------------------------------------------------------
// Name: GetMemUnitSlot()
// Desc: Given an MU index, returns the slot identifier for the MU
//-----------------------------------------------------------------------------
DWORD CXBMemUnit::GetMemUnitSlot( DWORD i ) // static
{
    return( ( i % 2 ) ? XDEVICE_BOTTOM_SLOT : XDEVICE_TOP_SLOT );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbmesh.cpp ===
//-----------------------------------------------------------------------------
// File: XBMesh.cpp
//
// Desc: Support code for loading geometry stored in .xbg files. See the
//       <XBMesh.h> header file for information on using this class.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.15.01 - Mass changes (removed D3DX and .x support) for April XDK
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgmath.h>
#include <stdio.h>
#include "XBMesh.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: CXBMesh()
// Desc: 
//-----------------------------------------------------------------------------
CXBMesh::CXBMesh()
{
    m_pAllocatedSysMem = NULL;
    m_pAllocatedVidMem = NULL;
    m_pMeshFrames      = NULL;
    m_dwNumFrames      = 0;
    m_dwRefCount       = 1L;
}




//-----------------------------------------------------------------------------
// Name: ~CXBMesh()
// Desc: 
//-----------------------------------------------------------------------------
CXBMesh::~CXBMesh()
{
    // Free textures
    for( DWORD i=0; i<m_dwNumFrames; i++ )
    {
        for( DWORD j = 0; j < m_pMeshFrames[i].m_MeshData.m_dwNumSubsets; j++ )
        {
            SAFE_RELEASE( m_pMeshFrames[i].m_MeshData.m_pSubsets[j].pTexture );
        }
    }

    // Free alloacted memory
    if( m_pAllocatedSysMem )
        delete[] m_pAllocatedSysMem;

    if( m_pAllocatedVidMem )
        D3D_FreeContiguousMemory( m_pAllocatedVidMem );
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                         CXBPackedResource* pResource )
{
    // Find the media file
    CHAR strMeshPath[512];
    if( FAILED( XBUtil_FindMediaFile( strMeshPath, strFilename ) ) )
        return E_FAIL;

    // Open the file
	HANDLE hFile;
	DWORD dwNumBytesRead;
	hFile = CreateFile(strMeshPath, GENERIC_READ, FILE_SHARE_READ, NULL,
		               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		OUTPUT_DEBUG_STRING( "CXBMesh::Create(): ERROR: File not found!\n" );
        return E_FAIL;
    }

    // Read the magic number
    DWORD dwFileID;
	ReadFile(hFile, &dwFileID, sizeof(DWORD), &dwNumBytesRead, NULL);
    if( dwFileID != XBG_FILE_ID )
    {
        OUTPUT_DEBUG_STRING( "CXBMesh::Create(): ERROR: Invalid XBG file type!\n" );
        return E_FAIL;
    }

    // Read in header
    DWORD dwNumFrames;  // Number of mesh frames in the file
    DWORD dwSysMemSize; // Num bytes needed for system memory objects
    DWORD dwVidMemSize; // Num bytes needed for video memory objects

    ReadFile(hFile,  &dwNumFrames, sizeof(DWORD), &dwNumBytesRead, NULL);
	ReadFile(hFile,  &dwSysMemSize, sizeof(DWORD), &dwNumBytesRead, NULL);
	ReadFile(hFile,  &dwVidMemSize, sizeof(DWORD), &dwNumBytesRead, NULL);
	
    // Read in system memory objects
    m_pAllocatedSysMem = (VOID*)new BYTE[dwSysMemSize];
	ReadFile(hFile, m_pAllocatedSysMem, dwSysMemSize, &dwNumBytesRead, NULL);
		

    // Read in video memory objects
    m_pAllocatedVidMem = D3D_AllocContiguousMemory( dwVidMemSize, D3DVERTEXBUFFER_ALIGNMENT );
    ReadFile(hFile, m_pAllocatedVidMem, dwVidMemSize, &dwNumBytesRead, NULL);
	    
    // Done with the file
    CloseHandle(hFile);

    // Now we need to patch the mesh data. Any pointers read from the file were
    // stored as file offsets. So, we simply need to add a base address to patch
    // things up.
    m_pMeshFrames = (XBMESH_FRAME*)m_pAllocatedSysMem;
    m_dwNumFrames = dwNumFrames;

    for( DWORD i=0; i<m_dwNumFrames; i++ )
    {
        XBMESH_FRAME* pFrame = &m_pMeshFrames[i];
        XBMESH_DATA*  pMesh  = &m_pMeshFrames[i].m_MeshData;

        if( pFrame->m_pChild )
            pFrame->m_pChild  = (XBMESH_FRAME*)( (DWORD)pFrame->m_pChild - 16 + (DWORD)m_pMeshFrames );
        if( pFrame->m_pNext )
            pFrame->m_pNext   = (XBMESH_FRAME*)( (DWORD)pFrame->m_pNext  - 16 + (DWORD)m_pMeshFrames );
        if( pMesh->m_pSubsets )
            pMesh->m_pSubsets = (XBMESH_SUBSET*)( (DWORD)pMesh->m_pSubsets - 16 + (DWORD)m_pMeshFrames);
        
        if( pMesh->m_dwNumIndices )
            pMesh->m_IB.Data  = pMesh->m_IB.Data - 16 + (DWORD)m_pMeshFrames;
        if( pMesh->m_dwNumVertices )
            pMesh->m_VB.Register( m_pAllocatedVidMem );
    }

    // Finally, create any textures used by the meshes' subsets. In this 
    // implementation, we are pulling textures out of the passed in resource.
    if( pResource )
    {
        for( DWORD i=0; i<m_dwNumFrames; i++ )
        {
            XBMESH_DATA* pMesh = &m_pMeshFrames[i].m_MeshData;

            for( DWORD j = 0; j < pMesh->m_dwNumSubsets; j++ )
            {
                XBMESH_SUBSET* pSubset = &pMesh->m_pSubsets[j];

                pSubset->pTexture = pResource->GetTexture( pSubset->strTexture );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the hierarchy of frames and meshes.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags )
{
    if( m_pMeshFrames )
        RenderFrame( pd3dDevice, m_pMeshFrames, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderFrame()
// Desc: Renders a frame (save state, apply matrix, render children, restore).
//-----------------------------------------------------------------------------
HRESULT CXBMesh::RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pFrame, 
                              DWORD dwFlags )
{
    // Apply the frame's local transform
    D3DXMATRIX matSavedWorld, matWorld;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld );
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, &matSavedWorld );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Render the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        RenderMesh( pd3dDevice, &pFrame->m_MeshData, dwFlags );

    // Render any child frames
    if( pFrame->m_pChild ) 
        RenderFrame( pd3dDevice, pFrame->m_pChild, dwFlags );

    // Restore the transformation matrix
    pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld );
    
    // Render any sibling frames
    if( pFrame->m_pNext )  
        RenderFrame( pd3dDevice, pFrame->m_pNext, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderMesh()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                             DWORD dwFlags )
{
    D3DVertexBuffer* pVB           = &pMesh->m_VB;
    DWORD            dwNumVertices =  pMesh->m_dwNumVertices;
    D3DIndexBuffer*  pIB           = &pMesh->m_IB;
    DWORD            dwNumIndices  =  pMesh->m_dwNumIndices;
    DWORD            dwFVF         =  pMesh->m_dwFVF;
    DWORD            dwVertexSize  =  pMesh->m_dwVertexSize;
    D3DPRIMITIVETYPE dwPrimType    =  pMesh->m_dwPrimType;
    DWORD            dwNumSubsets  =  pMesh->m_dwNumSubsets;
    XBMESH_SUBSET*   pSubsets      = &pMesh->m_pSubsets[0];

    (VOID)dwNumIndices; // not used

    if( dwNumVertices == 0 )
        return S_OK;

    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, pVB, dwVertexSize );
    pd3dDevice->SetIndices( pIB, 0 );

    // Set the FVF code, unless the user asked us not to
    if( 0 == ( dwFlags & XBMESH_NOFVF ) )
        pd3dDevice->SetVertexShader( dwFVF );

    // Render the subsets
    for( DWORD i = 0; i < dwNumSubsets; i++ )
    {
        BOOL bRender = FALSE;

        // Render the opaque subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_ALPHAONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    bRender = TRUE;
            }
            else
                bRender = TRUE;
        }

        // Render the transparent subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_OPAQUEONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    bRender = TRUE;
            }
        }

        if( bRender )
        {
            // Set the material, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
                pd3dDevice->SetMaterial( &pSubsets[i].mtrl );

            // Set the texture, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOTEXTURES ) )
                pd3dDevice->SetTexture( 0, pSubsets[i].pTexture );

            // Call the callback, so the app can tweak state before rendering
            // each subset
            BOOL bRenderSubset = RenderCallback( pd3dDevice, i, &pSubsets[i], dwFlags );

            // Draw the mesh subset
            if( bRenderSubset )
            {
                DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == dwPrimType ) ? pSubsets[i].dwIndexCount-2 : pSubsets[i].dwIndexCount/3;
                pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, pSubsets[i].dwIndexCount,
                                                  pSubsets[i].dwIndexStart, dwNumPrimitives );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ComputeRadius()
// Desc: Finds the farthest point from zero on the mesh.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeRadius()
{
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );

    return ComputeFrameRadius( m_pMeshFrames, &matIdentity );
}




//-----------------------------------------------------------------------------
// Name: ComputeFrameRadius()
// Desc: Calls ComputeMeshRadius for each frame with the correct transform.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeFrameRadius( XBMESH_FRAME* pFrame, D3DXMATRIX* pmatParent )
{
    // Apply the frame's local transform
    D3DXMATRIX matWorld;
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, pmatParent );

    FLOAT fRadius = 0.0f;

    // Compute bounds for the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        fRadius = ComputeMeshRadius( &pFrame->m_MeshData, &matWorld );

    // Compute bounds for any child frames
    if( pFrame->m_pChild ) 
    {
        FLOAT fChildRadius = ComputeFrameRadius( pFrame->m_pChild, &matWorld  );

        if( fChildRadius > fRadius )
            fRadius = fChildRadius;
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )  
    {
        FLOAT fSiblingRadius = ComputeFrameRadius( pFrame->m_pNext, pmatParent );

        if( fSiblingRadius > fRadius )
            fRadius = fSiblingRadius;
    }

    return fRadius;
}




//-----------------------------------------------------------------------------
// Name: ComputeMeshRadius()
// Desc: Finds the farthest point from zero on the mesh.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeMeshRadius( XBMESH_DATA* pMesh, D3DXMATRIX* pmat )
{
    DWORD       dwNumVertices = pMesh->m_dwNumVertices;
    DWORD       dwVertexSize  = pMesh->m_dwVertexSize;
    BYTE*       pVertices;
    D3DXVECTOR3 vPos;
    FLOAT       fMaxDist2 = 0.0f;

    pMesh->m_VB.Lock( 0, 0, &pVertices, 0 );

    while( dwNumVertices-- )
    {
        D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pmat );

        FLOAT fDist2 = vPos.x*vPos.x + vPos.y*vPos.y + vPos.z*vPos.z;

        if( fDist2 > fMaxDist2 )
            fMaxDist2 = fDist2;

        pVertices += dwVertexSize;
    }

    pMesh->m_VB.Unlock();

    return sqrtf( fMaxDist2 );
}

//-----------------------------------------------------------------------------
//  Take the union of two boxes
//-----------------------------------------------------------------------------
inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }
static void UnionBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)
{
	pvMin->x = MIN(pvMin->x, vMin.x);
	pvMin->y = MIN(pvMin->y, vMin.y);
	pvMin->z = MIN(pvMin->z, vMin.z);
	pvMax->x = MAX(pvMax->x, vMax.x);
	pvMax->y = MAX(pvMax->y, vMax.y);
	pvMax->z = MAX(pvMax->z, vMax.z);
}

//-----------------------------------------------------------------------------
// Name: ComputeBoundingBox()
// Desc: Calculates the bounding box of the entire hierarchy.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );
    return ComputeFrameBoundingBox( m_pMeshFrames, &matIdentity, pvMin, pvMax );
}

//-----------------------------------------------------------------------------
// Name: ComputeFrameBoundingBox()
// Desc: Calls ComputeMeshBoundingBox for each frame with the correct transform.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeFrameBoundingBox( XBMESH_FRAME* pFrame, D3DXMATRIX* pmatParent, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	HRESULT hr;
	
	// initialize bounds to be reset on the first UnionBox
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;
	
    // Apply the frame's local transform
    D3DXMATRIX matWorld;
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, pmatParent );

    // Compute bounds for the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets )
	{
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeMeshBoundingBox( &pFrame->m_MeshData, &matWorld, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
	}

    // Compute bounds for any child frames
    if( pFrame->m_pChild ) 
    {
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeFrameBoundingBox( pFrame->m_pChild, &matWorld, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )  
    {
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeFrameBoundingBox( pFrame->m_pNext, pmatParent, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ComputeMeshBoundingBox()
// Desc: Calculate the bounding box of the transformed mesh.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeMeshBoundingBox( XBMESH_DATA* pMesh, D3DXMATRIX* pmat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	// initialize bounds to be reset on the first point
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;
    DWORD       dwNumVertices = pMesh->m_dwNumVertices;
    DWORD       dwVertexSize  = pMesh->m_dwVertexSize;
    BYTE*       pVertices;
    D3DXVECTOR3 vPos;
    pMesh->m_VB.Lock( 0, 0, &pVertices, 0 );
    while( dwNumVertices-- )
    {
        D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pmat );
		UnionBox(pvMin, pvMax, vPos, vPos);	// expand the bounding box to include the point
        pVertices += dwVertexSize;
    }
    pMesh->m_VB.Unlock();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbOnline.cpp ===
//-----------------------------------------------------------------------------
// File: XbOnline.cpp
//
// Desc: Shortcut macros and helper functions for the Xbox online samples.
//       Requires linking with XONLINE[D][S].LIB.
//
// Hist: 10.11.01 - New for November XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBOnline.h"
#include "XBMemUnit.h"
#include "XBApp.h"
#include <cassert>
#include <algorithm>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_MEMORY_UNITS  = 2 * XGetPortCount();

// How often (per second) the caret blinks during PIN entry
const FLOAT fCARET_BLINK_RATE = 1.0f;

// During the blink period, the amount the caret is visible. 0.5 equals
// half the time, 0.75 equals 3/4ths of the time, etc.
const FLOAT fCARET_ON_RATIO = 0.75f;




//-----------------------------------------------------------------------------
// Name: XBOnline_GetUserList()
// Desc: Extract all accounts from hard disk and MUs
//-----------------------------------------------------------------------------
HRESULT XBOnline_GetUserList( XBUserList& UserList )
{
    // On input, the list must have room for XONLINE_MAX_STORED_ONLINE_USERS
    // accounts
    XONLINE_USER pUserList[ XONLINE_MAX_STORED_ONLINE_USERS ];

    // Get accounts stored on the hard disk
    DWORD dwUsers;
    HRESULT hr = XOnlineGetUsers( pUserList, &dwUsers );
    if( SUCCEEDED(hr) )
    {
        for( DWORD i = 0; i < dwUsers; ++i )
            UserList.push_back( pUserList[i] );
    }

    return hr;
}





//-----------------------------------------------------------------------------
// Name: CXBPinEntry()
// Desc: Create PIN entry object
//-----------------------------------------------------------------------------
CXBPinEntry::CXBPinEntry()
{
    m_hPinInput = NULL;
    m_dwPinLength = 0;

    for( DWORD i = 0; i < XONLINE_PIN_LENGTH; ++i )
        m_byPin[i] = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPinEntry()
// Desc: Destry PIN entry object
//-----------------------------------------------------------------------------
CXBPinEntry::~CXBPinEntry()
{
    EndInput();
}




//-----------------------------------------------------------------------------
// Name: BeginInput()
// Desc: Start PIN entry input
//-----------------------------------------------------------------------------
HRESULT CXBPinEntry::BeginInput( const XINPUT_GAMEPAD& DefaultGamepad )
{
    EndInput();

    m_dwPinLength = 0;
    assert( m_hPinInput == NULL );

    // The samples application framework, although it saves the full
    // XINPUT_STATE struct for each gamepad, does not track the "current"
    // or "primary" gamepad, but rather merges all input together
    // in one gamepad struct called the default gamepad.

    // The PIN functions want the full XINPUT_STATE, so we create a local
    // version. Your game should use the actual XINPUT_STATE from whichever
    // gamepad is doing the PIN entry.
    XINPUT_STATE xis;
    CopyMemory( &xis.Gamepad, &DefaultGamepad, sizeof(DefaultGamepad) );

    m_hPinInput = XOnlinePINStartInput( &xis );
    if( m_hPinInput == NULL )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DecodeInput()
// Desc: Continue PIN entry input. If input is B or BACK, ends input and
//       returns E_ABORT;
//-----------------------------------------------------------------------------
HRESULT CXBPinEntry::DecodeInput( const XINPUT_GAMEPAD& DefaultGamepad )
{
    assert( m_hPinInput != NULL );

    // Ignore A and START
    if( DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_A ] )
        return S_OK;
    if( DefaultGamepad.wButtons & XINPUT_GAMEPAD_START )
        return S_OK;

    // "Cancel" buttons
    if( ( DefaultGamepad.wButtons & XINPUT_GAMEPAD_BACK ) ||
        ( DefaultGamepad.bAnalogButtons[ XINPUT_GAMEPAD_B ] ) )
    {
        EndInput();
        return E_ABORT;
    }

    // The samples application framework, although it saves the full
    // XINPUT_STATE struct for each gamepad, does not track the "current"
    // or "primary" gamepad, but rather merges all input together
    // in one gamepad struct called the default gamepad.

    // The PIN functions want the full XINPUT_STATE, so we create a local
    // version. Your game should use the actual XINPUT_STATE from whichever
    // gamepad is doing the PIN entry.
    XINPUT_STATE xis;
    CopyMemory( &xis.Gamepad, &DefaultGamepad, sizeof(DefaultGamepad) );

    // For all other controller input, decode PIN input
    BYTE byPin;
    HRESULT hr = XOnlinePINDecodeInput( m_hPinInput, &xis, &byPin );
    if( hr == S_OK )
    {
        m_byPin[ m_dwPinLength ] = byPin;
        ++m_dwPinLength;
    }

    // If no code byte entered this cycle, we're done
    if( hr == S_FALSE )
        return S_OK;

    // Error
    return hr;
}




//-----------------------------------------------------------------------------
// Name: GetPinLength()
// Desc: Returns the number of button presses that have been registered
//-----------------------------------------------------------------------------
DWORD CXBPinEntry::GetPinLength() const
{
    return m_dwPinLength;
}




//-----------------------------------------------------------------------------
// Name: IsPinComplete()
// Desc: TRUE if the entered PIN has enough digits
//-----------------------------------------------------------------------------
BOOL CXBPinEntry::IsPinComplete() const
{
    return( m_dwPinLength == XONLINE_PIN_LENGTH );
}




//-----------------------------------------------------------------------------
// Name: IsPinValid()
// Desc: TRUE if the PIN is valid. Must only be called on complete PINs.
//-----------------------------------------------------------------------------
BOOL CXBPinEntry::IsPinValid( const BYTE* pinCompare ) const
{
    assert( IsPinComplete() );
    assert( pinCompare != NULL );
    return( memcmp( m_byPin, pinCompare, XONLINE_PIN_LENGTH ) == 0 );
}




//-----------------------------------------------------------------------------
// Name: EndInput()
// Desc: Clean up PIN entry
//-----------------------------------------------------------------------------
HRESULT CXBPinEntry::EndInput()
{
    if( m_hPinInput != NULL )
    {
        HRESULT hr = XOnlinePINEndInput( m_hPinInput );
        assert( SUCCEEDED(hr) );
        m_hPinInput = NULL;
        m_dwPinLength = 0;
        return hr;
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CXBOnlineUI()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBOnlineUI::CXBOnlineUI( WCHAR* strFrameRate, WCHAR* strHeader )
:
    m_strFrameRate( strFrameRate ),
    m_strHeader   ( strHeader ),
    m_CaretTimer  ( TRUE )
{
    m_ptMenuSel = NULL;
    *m_strError = 0;
}




//-----------------------------------------------------------------------------
// Name: SetErrorStr()
// Desc: Set error string
//-----------------------------------------------------------------------------
VOID CXBOnlineUI::SetErrorStr( const WCHAR* strFormat, va_list pArglist )
{
    INT iChars = wvsprintfW( m_strError, strFormat, pArglist );
    assert( iChars < MAX_ERROR_STR );
    (VOID)iChars; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects
//-----------------------------------------------------------------------------
HRESULT CXBOnlineUI::Initialize( DWORD dwNumResources, DWORD dwMenuSelectorOffset )
{
    // Create a font
    if( FAILED( m_Font.Create( g_pd3dDevice, "Font.xpr" ) ) )
    {
        OUTPUT_DEBUG_STRING( "Failed to load fonts\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Initialize the help system
    if( FAILED( m_Help.Create( g_pd3dDevice, "Gamepad.xpr" ) ) )
    {
        OUTPUT_DEBUG_STRING( "Failed to load help\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Load our textures
    if( FAILED( m_xprResource.Create( g_pd3dDevice, "Resource.xpr", dwNumResources ) ) )
    {
        OUTPUT_DEBUG_STRING( "Failed to load textures\n" );
        return XBAPPERR_MEDIANOTFOUND;
    }

    // Set up texture ptrs
    m_ptMenuSel = m_xprResource.GetTexture( dwMenuSelectorOffset );

    // Set projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 100.0f );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set view position
    D3DXMATRIX matView;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 40.0f);
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderCreateAccount()
// Desc: Allow player to launch account creation tool
//-----------------------------------------------------------------------------
VOID CXBOnlineUI::RenderCreateAccount( BOOL bHasMachineAccount ) const
{
    RenderHeader();

    WCHAR* strInfo;
    if( bHasMachineAccount )
    {
        strInfo = L"No online accounts exist on this Xbox.\n\n"
                  L"Run the Xbox Online Setup Tool to create accounts.\n\n"
                  L"Press A to continue.";
    }
    else
    {
        strInfo = L"This Xbox does not have a machine account.\n\n"
                  L"Run the Xbox Online Setup Tool to create accounts.\n\n"
                  L"Press A to continue.";
    }

    m_Font.DrawText( 320, 140, COLOR_NORMAL, strInfo, XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderSelectAccount()
// Desc: Display list of accounts
//-----------------------------------------------------------------------------
VOID CXBOnlineUI::RenderSelectAccount( DWORD dwCurrItem, 
                                       const XBUserList& UserList ) const
{
    assert( !UserList.empty() );

    RenderHeader();

    m_Font.DrawText( 320, 140, COLOR_NORMAL, L"Select an account",
                     XBFONT_CENTER_X );

    FLOAT fYtop = 220.0f;
    FLOAT fYdelta = 30.0f;

    // Show list of user accounts
    for( DWORD i = 0; i < UserList.size(); ++i )
    {
        DWORD dwColor = ( dwCurrItem == i ) ? COLOR_HIGHLIGHT : COLOR_NORMAL;

        // Convert user name to WCHAR string
        WCHAR strUserName[ XONLINE_NAME_SIZE ];
        XBUtil_GetWide( UserList[i].name, strUserName, XONLINE_NAME_SIZE );

        m_Font.DrawText( 160, fYtop + (fYdelta * i), dwColor, strUserName );
    }

    // Show selected item with little triangle
    RenderMenuSelector( 120.0f, fYtop + (fYdelta * dwCurrItem ) );
}




//-----------------------------------------------------------------------------
// Name: RenderGetPin()
// Desc: Display PIN entry screen
//-----------------------------------------------------------------------------
VOID CXBOnlineUI::RenderGetPin( const CXBPinEntry& PinEntry, 
                                  const WCHAR* strUser ) const
{
    RenderHeader();

    WCHAR strMsg[ 256 + XONLINE_USERNAME_SIZE ];
    wsprintfW( strMsg, L"Please enter the four-sequence pass code for\n"
                       L"'%.*s'\n"
                       L"using the directional pad, X, Y, black or\n"
                       L"white buttons, or left and right triggers.\n"
                       L"\n\n"
                       L"Press B to cancel",
               XONLINE_USERNAME_SIZE, strUser );
    m_Font.DrawText( 320, 120, COLOR_GREEN, strMsg, XBFONT_CENTER_X );

    // Build PIN text string (stars)
    WCHAR strPIN[ XONLINE_PIN_LENGTH * 2 + 1 ] = { 0 };
    for( DWORD i = 0; i < PinEntry.GetPinLength() * 2; i += 2 )
    {
        strPIN[ i   ] = L'*';
        strPIN[ i+1 ] = L' ';
    }

    // Determine caret location
    FLOAT fWidth;
    FLOAT fHeight;
    m_Font.GetTextExtent( strPIN, &fWidth, &fHeight );

    // Display text "cursor"
    if( fmod( m_CaretTimer.GetElapsedSeconds(), fCARET_BLINK_RATE ) <
        fCARET_ON_RATIO )
    {
        m_Font.DrawText( 300.0f + fWidth - 2.0f, 300.0f, COLOR_HIGHLIGHT, L"|" );
    }

    // Display "PIN"
    m_Font.DrawText( 300, 300, COLOR_NORMAL, strPIN );
}




//-----------------------------------------------------------------------------
// Name: RenderLoggingOn()
// Desc: Display "logging on" animation
//-----------------------------------------------------------------------------
VOID CXBOnlineUI::RenderLoggingOn() const
{
    RenderHeader();
    m_Font.DrawText( 320, 200, COLOR_NORMAL, L"Authenticating Xbox Account", 
                     XBFONT_CENTER_X );
    m_Font.DrawText( 320, 260, COLOR_NORMAL, L"Press B to cancel", 
                     XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderError()
// Desc: Display error (or any other) message
//-----------------------------------------------------------------------------
VOID CXBOnlineUI::RenderError() const
{
    RenderHeader();
    m_Font.DrawText( 320, 200, COLOR_NORMAL, m_strError, XBFONT_CENTER_X );
    m_Font.DrawText( 320, 300, COLOR_NORMAL, L"Press A to continue", 
                     XBFONT_CENTER_X );
}




//-----------------------------------------------------------------------------
// Name: RenderHeader()
// Desc: Display standard text
//-----------------------------------------------------------------------------
VOID CXBOnlineUI::RenderHeader() const
{
    m_Font.DrawText(  64, 50, COLOR_NORMAL, m_strHeader );
    m_Font.DrawText( 450, 50, COLOR_HIGHLIGHT, m_strFrameRate );
}




//-----------------------------------------------------------------------------
// Name: RenderMenuSelector()
// Desc: Display menu selector
//-----------------------------------------------------------------------------
VOID CXBOnlineUI::RenderMenuSelector( FLOAT fLeft, FLOAT fTop ) const
{
    D3DXVECTOR4 rc( fLeft, fTop, fLeft + 20.0f, fTop + 20.0f );

    // Show selected item
    struct TILEVERTEX
    {
        D3DXVECTOR4 p;
        D3DXVECTOR2 t;
    };
    TILEVERTEX* pVertices;

    LPDIRECT3DVERTEXBUFFER8 pvbTemp;
    g_pd3dDevice->CreateVertexBuffer( 4 * sizeof( TILEVERTEX ), 
                                      D3DUSAGE_WRITEONLY, 
                                      D3DFVF_XYZRHW | D3DFVF_TEX1, 
                                      D3DPOOL_MANAGED, &pvbTemp );

    // Create a quad for us to render our texture on
    pvbTemp->Lock( 0, 0, (BYTE **)&pVertices, 0L );
    pVertices[0].p = D3DXVECTOR4( rc.x - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f ); // Bottom Left
    pVertices[1].p = D3DXVECTOR4( rc.x - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f ); // Top    Left
    pVertices[2].p = D3DXVECTOR4( rc.z - 0.5f, rc.w - 0.5f, 1.0f, 1.0f );  pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f ); // Bottom Right
    pVertices[3].p = D3DXVECTOR4( rc.z - 0.5f, rc.y - 0.5f, 1.0f, 1.0f );  pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f ); // Top    Right
    pvbTemp->Unlock();

    // Set up our state
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetStreamSource( 0, pvbTemp, sizeof( TILEVERTEX ) );

    // Render the quad with our texture
    g_pd3dDevice->SetTexture( 0, m_ptMenuSel );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    g_pd3dDevice->SetTexture( 0, NULL );
    pvbTemp->Release();
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Display text using UI font
//-----------------------------------------------------------------------------
HRESULT CXBOnlineUI::DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                               const WCHAR* strText, DWORD dwFlags ) const
{
    return m_Font.DrawText( sx, sy, dwColor, strText, dwFlags );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbNetMsg.cpp ===
//-----------------------------------------------------------------------------
// File: XbNetMsg.cpp
//
// Desc: Simple "waving" game messages to show Xbox communication.
//       Requires linking with XNET[D][S].LIB or XONLINE[D][S].LIB
//
// Hist: 10.20.01 - New for November XDK release
//       02.15.02 - Updated for Mar release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBNetMsg.h"
#include <cassert>
#include <algorithm>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const XNKID EMPTY_KEY = { 0 };




//-----------------------------------------------------------------------------
// Name: class MatchInAddr
// Desc: Predicate functor used to match on IN_ADDRs in player lists
//-----------------------------------------------------------------------------
struct MatchInAddr
{
    IN_ADDR ia;

    explicit MatchInAddr( const CXBSockAddr& sa )
    : 
        ia( sa.GetInAddr() )
    {
    }

    bool operator()( const CXBNetPlayerInfo& playerInfo ) const
    {
        return playerInfo.inAddr.s_addr == ia.s_addr;
    }
};




//-----------------------------------------------------------------------------
// Name: CXBNetMessage
// Desc: constructor
//-----------------------------------------------------------------------------
CXBNetMessage::CXBNetMessage( BYTE byMessageId )
{
    m_byMessageId = byMessageId;
}




//-----------------------------------------------------------------------------
// Name: CXBNetMessage
// Desc: constructor
//-----------------------------------------------------------------------------
INT CXBNetMessage::GetSize() const
{ 
    switch( m_byMessageId )
    {
        case MSG_JOIN_GAME:     return sizeof(BYTE) + sizeof(CXBNetMsgJoinGame);
        case MSG_JOIN_APPROVED: return sizeof(BYTE) + sizeof(CXBNetMsgJoinApproved);
        case MSG_JOIN_DENIED:   return sizeof(BYTE) + sizeof(CXBNetMsgJoinDenied);
        case MSG_PLAYER_JOINED: return sizeof(BYTE) + sizeof(CXBNetMsgPlayerJoined);
        case MSG_WAVE:          return sizeof(BYTE) + sizeof(CXBNetMsgWave);
        case MSG_HEARTBEAT:     return sizeof(BYTE) + sizeof(CXBNetMsgHeartbeat);
        default:                assert( FALSE ); return 0;
    }
}




//-----------------------------------------------------------------------------
// Name: CXBMsgHandler()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBNetMsgHandler::CXBNetMsgHandler()
{
    ZeroMemory( &m_xnSessionID, sizeof( m_xnSessionID ) );
    *m_strHost = 0;
    m_bIsHost = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CXBNetMsgHandler
// Desc: destructor
//-----------------------------------------------------------------------------
CXBNetMsgHandler::~CXBNetMsgHandler()
{
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Init object
//-----------------------------------------------------------------------------
HRESULT CXBNetMsgHandler::Initialize()
{
    // The game socket is a non-blocking socket on port GAME_PORT.
    BOOL bSuccess = m_Sock.Open( CXBSocket::Type_UDP );
    if( !bSuccess )
        return E_FAIL;

    CXBSockAddr directAddr( INADDR_ANY, GAME_PORT );
    INT iResult = m_Sock.Bind( directAddr.GetPtr() );
    if( iResult == SOCKET_ERROR )
        return E_FAIL;

    DWORD dwNonBlocking = 1;
    iResult = m_Sock.IoCtlSocket( FIONBIO, &dwNonBlocking );
    if( iResult == SOCKET_ERROR )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetUser()
// Desc: Set user name
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SetUser( const WCHAR* strUser, BOOL bIsHost )
{
    lstrcpynW( m_strHost, strUser, MAX_PLAYER_STR );
    m_bIsHost = bIsHost;
}




//-----------------------------------------------------------------------------
// Name: SetSessionID()
// Desc: Set user name
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SetSessionID( const XNKID& xnSessionID )
{
    CopyMemory( &m_xnSessionID, &xnSessionID, sizeof( xnSessionID ) );
}




//-----------------------------------------------------------------------------
// Name: SendJoinGame()
// Desc: Issue a MSG_JOIN_GAME from our client to the game host
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SendJoinGame( const CXBSockAddr& saGameHost, 
                                     const WCHAR* strUser, ULONGLONG qwUserID )
{
    assert( !m_bIsHost );
    CXBNetMessage msgJoinGame( MSG_JOIN_GAME );
    CXBNetMsgJoinGame& msg = msgJoinGame.GetJoinGame();

    // Include our player name
    lstrcpynW( msg.strPlayerName, strUser, MAX_PLAYER_STR );

    // Include our player ID
    msg.qwUserID = qwUserID;

    // We can send this message directly to the host
    INT nBytes = m_Sock.SendTo( &msgJoinGame, msgJoinGame.GetSize(),
                                saGameHost.GetPtr() );
    assert( nBytes == msgJoinGame.GetSize() );
    (VOID)nBytes; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: SendWave()
// Desc: Wave to all other players in game
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SendWave( const CXBNetPlayerList& PlayerList )
{
    // Send a "wave" message to each of the other players in the game
    CXBNetPlayerList::const_iterator i = PlayerList.begin();
    for( ; i != PlayerList.end(); ++i )
        SendWave( CXBSockAddr( i->inAddr, GAME_PORT ) );
}




//-----------------------------------------------------------------------------
// Name: SendWave()
// Desc: Issue a MSG_WAVE from ourself (either a host or player) to another
//       player
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SendWave( const CXBSockAddr& saPlayer ) // private
{
    CXBNetMessage msgWave( MSG_WAVE );
    INT nBytes = m_Sock.SendTo( &msgWave, msgWave.GetSize(), saPlayer.GetPtr() );
    assert( nBytes == msgWave.GetSize() );
    (VOID)nBytes; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: SendHeartbeat()
// Desc: Send heartbeat to players in the game
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SendHeartbeat( const CXBNetPlayerList& PlayerList )
{
    // Send a "heartbeat" message to each of the other players in the game
    // to let them know we're alive
    CXBNetPlayerList::const_iterator i = PlayerList.begin();
    for( ; i != PlayerList.end(); ++i )
        SendHeartbeat( CXBSockAddr( i->inAddr, GAME_PORT ) );
}




//-----------------------------------------------------------------------------
// Name: SendHeartbeat()
// Desc: Issue a MSG_HEARTBEAT from ourself (either a host or player) to
//       another player
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SendHeartbeat( const CXBSockAddr& saPlayer ) // private
{
    // Send the heartbeat
    CXBNetMessage msgHeartbeat( MSG_HEARTBEAT );
    INT nBytes = m_Sock.SendTo( &msgHeartbeat, msgHeartbeat.GetSize(),
                                saPlayer.GetPtr() );
    assert( nBytes == msgHeartbeat.GetSize() );
    (VOID)nBytes; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: ProcessMessages()
// Desc: Checks to see if any messages are waiting on the game socket.
//       If a message is waiting, it is routed and processed.
//       If no messages are waiting, the function returns immediately.
//       Returns TRUE if a message was processed.
//-----------------------------------------------------------------------------
BOOL CXBNetMsgHandler::ProcessMessages( CXBNetPlayerList& PlayerList )
{
    if( !m_Sock.IsOpen() )
        return FALSE;

    // See if a network message is waiting for us
    CXBNetMessage msg;
    SOCKADDR_IN saFromIn;
    INT iResult = m_Sock.RecvFrom( &msg, msg.GetMaxSize(), &saFromIn );
    CXBSockAddr saFrom( saFromIn );

    // If message waiting, process it
    if( iResult != SOCKET_ERROR && iResult > 0 )
    {
        assert( iResult == msg.GetSize() );
        ProcessMessage( msg, saFrom, PlayerList );
        return TRUE;
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayersDropouts()
// Desc: Process players and determine if anybody has left the game.
//       Returns TRUE if any player left the game. It's up to the caller
//       to remove elements from the player list on dropouts.
//-----------------------------------------------------------------------------
BOOL CXBNetMsgHandler::ProcessPlayerDropouts( const CXBNetPlayerList& PlayerList,
                                              DWORD dwTimeout )
{
    DWORD dwTickCount = GetTickCount();
    CXBNetPlayerList::const_iterator i = PlayerList.begin();
    for( ; i != PlayerList.end(); ++i )
    {
        CXBNetPlayerInfo playerInfo = *i;
        DWORD dwElapsed = dwTickCount - playerInfo.dwLastHeartbeat;
        if( dwElapsed > dwTimeout )
        {
            // This player hasn't sent a heartbeat message in a long time.
            // Assume they left the game.

            if( !m_bIsHost && i == PlayerList.begin() )
            {
                OnPlayerDropout( playerInfo, TRUE );
            }
            else
            {
                OnPlayerDropout( playerInfo, FALSE );
            }
            return TRUE;
        }
    }
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessMessage()
// Desc: Routes any messages
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::ProcessMessage( CXBNetMessage& msg, 
                                       const CXBSockAddr& saFrom,
                                       CXBNetPlayerList& PlayerList ) // private
{
    // Process the message
    switch( msg.GetId() )
    {
        // From client to host; processed by host
        case MSG_JOIN_GAME:
            ProcessJoinGame( msg.GetJoinGame(), saFrom, PlayerList );
            break;

        // From host to client: processed by client
        case MSG_JOIN_APPROVED:
            ProcessJoinApproved( msg.GetJoinApproved(), saFrom );
            break;
        case MSG_JOIN_DENIED:
            ProcessJoinDenied();
            break;
        case MSG_PLAYER_JOINED:
            ProcessPlayerJoined( msg.GetPlayerJoined(), saFrom );
            break;

        // From player to player: processed by client player
        case MSG_WAVE:
            ProcessWave( saFrom, PlayerList );
            break;
        case MSG_HEARTBEAT:
            ProcessHeartbeat( saFrom, PlayerList );
            break;

        // Any other message on this port is invalid and we ignore it
        default:
            assert( FALSE );
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinGame()
// Desc: Process the join game message.
//       Returns TRUE if the player successfully joined, FALSE if not.
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::ProcessJoinGame( const CXBNetMsgJoinGame& joinGame,
                                        const CXBSockAddr& saFrom,
                                        CXBNetPlayerList& PlayerList ) // private
{
    // If for some reason we receive a "join game" message and we're not a
    // host, ignore it. Only hosts respond to "join game" messages
    if( !m_bIsHost )
        return;

    // We're hosting

    // A session exists between us (the host) and the client. We can now
    // convert the incoming IP address (saFrom) into a valid XNADDR.
    XNADDR xnAddrClient;
    INT iResult = XNetInAddrToXnAddr( saFrom.GetInAddr(), &xnAddrClient, NULL );
    if( iResult == SOCKET_ERROR )
    {
        // If the client INADDR can't be converted to an XNADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        assert( FALSE );
        return;
    }

    MatchInAddr matchInAddr( saFrom );

    // First check to make sure the player isn't already in the list.
    // If so, remove the player first.  This can happen if the player
    // drops out of a game and rejoins before the next heartbeat.
    CXBNetPlayerList::iterator i = 
        std::find_if( PlayerList.begin(), PlayerList.end(), matchInAddr );

    if( i != PlayerList.end() )
    {
        PlayerList.erase( i );
    }
 
    // A player may join if we haven't reached the player limit.
    // In a real game, you would need to "lock" the game during a join
    // or track the number of joins in progress so that if multiple
    // players were attempting to join at the same time, they wouldn't
    // all be granted access and then exceed the player maximum.
    if( PlayerList.size() + 1 < MAX_PLAYERS )
    {
        SendJoinApproved( saFrom, PlayerList );

        // Notify the other players about the new guy
        CXBNetPlayer player;
        CopyMemory( &player.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        lstrcpynW( player.strPlayerName, joinGame.strPlayerName, MAX_PLAYER_STR );
        CXBNetPlayerList::const_iterator i = PlayerList.begin(); 
        for( ; i != PlayerList.end(); ++i )
            SendPlayerJoined( player, CXBSockAddr( i->inAddr, GAME_PORT ) );

        // Add this new player to our player list
        CXBNetPlayerInfo playerInfo;
        CopyMemory( &playerInfo.xnAddr, &xnAddrClient, sizeof( XNADDR ) );
        playerInfo.inAddr = saFrom.GetInAddr();
        lstrcpynW( playerInfo.strPlayerName, joinGame.strPlayerName, 
                   MAX_PLAYER_STR );
        playerInfo.qwUserID = joinGame.qwUserID;
        playerInfo.dwLastHeartbeat = GetTickCount();

        OnJoinGame( playerInfo );
    }
    else // We've reached the player limit; inform the client that the game is full    
        SendJoinDenied( saFrom );
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinApproved()
// Desc: Process the join approved message
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::ProcessJoinApproved( const CXBNetMsgJoinApproved& joinApproved, 
                                            const CXBSockAddr& saFrom ) // private
{
    // Only clients should receive "join approved" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join approved" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    // Add the host to the list of players (always at position 0 )
    CXBNetPlayerInfo hostInfo;

    // Client doesn't need the XNADDR of the host, so we just leave it zero.
    // This data member is only used by hosts.
    // Client doesn't need the ID of the host either, so that also
    // remains zero.
    ZeroMemory( &hostInfo.xnAddr, sizeof( XNADDR ) );
    hostInfo.inAddr = saFrom.GetInAddr();
    lstrcpynW( hostInfo.strPlayerName, joinApproved.strHostName, MAX_PLAYER_STR );
    hostInfo.dwLastHeartbeat = GetTickCount();

    OnJoinApproved( hostInfo );

    // Build the list of the other players
    for( BYTE i = 0; i < joinApproved.byNumPlayers; ++i )
    {
        CXBNetPlayerInfo playerInfo;

        // Convert the XNADDR of the player to the INADDR we'll use to wave
        // to the player
        assert( memcmp( &m_xnSessionID, &EMPTY_KEY, sizeof( XNKID ) ) != 0 );
        INT iResult = XNetXnAddrToInAddr( &joinApproved.PlayerList[ i ].xnAddr,
                                          &m_xnSessionID, &playerInfo.inAddr );
        if( iResult == SOCKET_ERROR )
        {
            // If the client XNADDR can't be converted to an INADDR, then
            // the client does not have a valid session established, and
            // we ignore that client.
            assert( FALSE );
            continue;
        }

        // Client doesn't need the XNADDR of the host anymore, 
        // so we just leave it zero. This data member is only used by hosts.
        ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

        // Save the player name
        lstrcpynW( playerInfo.strPlayerName, 
                   joinApproved.PlayerList[ i ].strPlayerName, MAX_PLAYER_STR );

        // Last heartbeat
        playerInfo.dwLastHeartbeat = GetTickCount();

        OnJoinApprovedAddPlayer( playerInfo );
    }
}




//-----------------------------------------------------------------------------
// Name: ProcessJoinDenied()
// Desc: Process the join denied message
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::ProcessJoinDenied() // private
{
    // Only clients should receive "join denied" messages
    assert( !m_bIsHost );

    // If for some reason we receive a "join denied" message and we're hosting
    // a game, ignore the message. Only clients handle this message
    if( m_bIsHost )
        return;

    OnJoinDenied();
}




//-----------------------------------------------------------------------------
// Name: ProcessPlayerJoined()
// Desc: Process the player joined message
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::ProcessPlayerJoined( const CXBNetMsgPlayerJoined& playerJoined, 
                                            const CXBSockAddr& saFrom ) // private
{
    // Only clients should receive "player joined" messages
    assert( !m_bIsHost );

    // saFrom is the address of the host that sent this message, but we
    // we already have his address, so throw it away
    (VOID)saFrom; // avoid compiler warning

    const CXBNetPlayer& player = playerJoined.player;
    CXBNetPlayerInfo playerInfo;

    // Convert the XNADDR of the player to the INADDR we'll use to wave
    // to the player
    assert( memcmp( &m_xnSessionID, &EMPTY_KEY, sizeof( XNKID ) ) != 0 );
    INT iResult = XNetXnAddrToInAddr( &player.xnAddr, &m_xnSessionID,
                                      &playerInfo.inAddr );
    if( iResult == SOCKET_ERROR )
    {
        // If the client XNADDR can't be converted to an INADDR, then
        // this client does not have a valid session established, and
        // we ignore the message.
        assert( FALSE );
        return;
    }

    // Client doesn't need the XNADDR of the new player, so we just 
    // leave it zero. This data member is only used by hosts.
    ZeroMemory( &playerInfo.xnAddr, sizeof( XNADDR ) );

    // Save the player name
    lstrcpynW( playerInfo.strPlayerName, player.strPlayerName, MAX_PLAYER_STR );

    // Client doesn't need the ID of the new player, so we just leave
    // it zero. This data member is only used by hosts
    playerInfo.qwUserID = 0;

    // Last heartbeat
    playerInfo.dwLastHeartbeat = GetTickCount();

    OnPlayerJoined( playerInfo );
}




//-----------------------------------------------------------------------------
// Name: ProcessWave()
// Desc: Process the wave message
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::ProcessWave( const CXBSockAddr& saFrom,
                                    const CXBNetPlayerList& PlayerList ) // private
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who waved by matching the INADDR
    CXBNetPlayerList::const_iterator i = 
        std::find_if( PlayerList.begin(), PlayerList.end(), matchInAddr );

    if( i != PlayerList.end() )
        OnWave( *i );
}




//-----------------------------------------------------------------------------
// Name: ProcessHeartbeat()
// Desc: Process the heartbeat message
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::ProcessHeartbeat( const CXBSockAddr& saFrom,
                                         const CXBNetPlayerList& PlayerList ) // private
{
    MatchInAddr matchInAddr( saFrom );

    // Find out who sent a heartbeat by matching the INADDR
    CXBNetPlayerList::const_iterator i = 
        std::find_if( PlayerList.begin(), PlayerList.end(), matchInAddr );

    // Update that player's heartbeat time
    if( i != PlayerList.end() )
        OnHeartbeat( *i );
}




//-----------------------------------------------------------------------------
// Name: SendJoinApproved()
// Desc: Issue a MSG_JOIN_APPROVED from our host to the requesting client.
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SendJoinApproved( const CXBSockAddr& saClient, 
                                         const CXBNetPlayerList& PlayerList ) // private
{
    assert( m_bIsHost );
    CXBNetMessage msgJoinApproved( MSG_JOIN_APPROVED );
    CXBNetMsgJoinApproved& msg = msgJoinApproved.GetJoinApproved();

    // The host is us
    assert( *m_strHost != 0 );
    lstrcpynW( msg.strHostName, m_strHost, MAX_PLAYER_STR );

    // Send the list of all the current players to the new player.
    // We don't send the host player info, since the new player 
    // already has all of the information it needs about the host player.
    msg.byNumPlayers = BYTE( PlayerList.size() );
    BYTE j = 0;
    CXBNetPlayerList::const_iterator i = PlayerList.begin();
    for( ; i != PlayerList.end(); ++i, ++j )
    {
        CXBNetPlayerInfo playerInfo = *i;
        CopyMemory( &msg.PlayerList[j].xnAddr, &playerInfo.xnAddr, 
                    sizeof( XNADDR ) );
        lstrcpynW( msg.PlayerList[j].strPlayerName, 
                   playerInfo.strPlayerName, MAX_PLAYER_STR );
    }

    // We can send this message directly back to the requesting client
    INT nBytes = m_Sock.SendTo( &msgJoinApproved, msgJoinApproved.GetSize(),
                                saClient.GetPtr() );
    assert( nBytes == msgJoinApproved.GetSize() );
    (VOID)nBytes; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: SendJoinDenied()
// Desc: Issue a MSG_JOIN_DENIED from our host to the requesting client
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SendJoinDenied( const CXBSockAddr& saClient ) // private
{
    assert( m_bIsHost );
    CXBNetMessage msgJoinDenied( MSG_JOIN_DENIED );

    // We can send this message directly back to the requesting client
    INT nBytes = m_Sock.SendTo( &msgJoinDenied, msgJoinDenied.GetSize(),
                                saClient.GetPtr() );
    assert( nBytes == msgJoinDenied.GetSize() );
    (VOID)nBytes; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: SendPlayerJoined()
// Desc: Issue a MSG_PLAYER_JOINED from our host to a player in the game
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::SendPlayerJoined( const CXBNetPlayer& player, 
                                         const CXBSockAddr& saPlayer ) // private
{
    assert( m_bIsHost );
    CXBNetMessage msgPlayerJoined( MSG_PLAYER_JOINED );
    CXBNetMsgPlayerJoined& msg = msgPlayerJoined.GetPlayerJoined();

    // The payload is the information about the player who just joined
    CopyMemory( &msg.player, &player, sizeof(player) );

    // We send this message directly to the player
    INT nBytes = m_Sock.SendTo( &msgPlayerJoined, msgPlayerJoined.GetSize(),
                                saPlayer.GetPtr() );
    assert( nBytes == msgPlayerJoined.GetSize() );
    (VOID)nBytes; // avoid compiler warning
}




//-----------------------------------------------------------------------------
// Name: OnXxx
// Desc: Default implementations do nothing
//-----------------------------------------------------------------------------
VOID CXBNetMsgHandler::OnJoinGame( const CXBNetPlayerInfo& )
{
}

VOID CXBNetMsgHandler::OnJoinApproved( const CXBNetPlayerInfo& )
{
}

VOID CXBNetMsgHandler::OnJoinApprovedAddPlayer( const CXBNetPlayerInfo& )
{
}

VOID CXBNetMsgHandler::OnJoinDenied()
{
}

VOID CXBNetMsgHandler::OnPlayerJoined( const CXBNetPlayerInfo& )
{
}

VOID CXBNetMsgHandler::OnWave( const CXBNetPlayerInfo& )
{
}

VOID CXBNetMsgHandler::OnHeartbeat( const CXBNetPlayerInfo& )
{
}

VOID CXBNetMsgHandler::OnPlayerDropout( const CXBNetPlayerInfo&, BOOL )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbonlinetask.cpp ===
//-----------------------------------------------------------------------------
// File: XbOnlineTask.cpp
//
// Desc: Wraps online task HANDLE object
//
// Hist: 09.04.01 - New for Nov XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbOnlineTask.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Name: CXBOnlineTask()
// Desc: Associate existing online task handle with object. Object will close
//       the handle when it is destroyed.
//-----------------------------------------------------------------------------
CXBOnlineTask::CXBOnlineTask( XONLINETASK_HANDLE hOnlineTask )
:
    m_hOnlineTask( hOnlineTask )
{
}




//-----------------------------------------------------------------------------
// Name: ~CXBOnlineTask()
// Desc: Close and release online task handle
//-----------------------------------------------------------------------------
CXBOnlineTask::~CXBOnlineTask()
{
    Close();
}




//-----------------------------------------------------------------------------
// Name: XONLINETASK_HANDLE()
// Desc: Direct access
//-----------------------------------------------------------------------------
CXBOnlineTask::operator XONLINETASK_HANDLE() const
{
    return m_hOnlineTask;
}




//-----------------------------------------------------------------------------
// Name: op&()
// Desc: Direct access to task handle
//-----------------------------------------------------------------------------
XONLINETASK_HANDLE* CXBOnlineTask::operator&()
{
    // If we're passing the task handle to a function that's changing it, the
    // handle should be closed (NULL). If this assertion fails, it's because
    // Close() -- i.e. XOnlineTaskCloseHandle -- wasn't called.
    assert( m_hOnlineTask == NULL );
    return &m_hOnlineTask;
}




//-----------------------------------------------------------------------------
// Name: IsOpen()
// Desc: TRUE if online task is open (being used)
//-----------------------------------------------------------------------------
BOOL CXBOnlineTask::IsOpen() const
{
    return( m_hOnlineTask != NULL );
}




//-----------------------------------------------------------------------------
// Name: IsClosed()
// Desc: TRUE if online task is closed (not in use)
//-----------------------------------------------------------------------------
BOOL CXBOnlineTask::IsClosed() const
{
    return( m_hOnlineTask == NULL );
}




//-----------------------------------------------------------------------------
// Name: Close()
// Desc: Close online task
//-----------------------------------------------------------------------------
void CXBOnlineTask::Close()
{
    if( m_hOnlineTask != NULL )
    {
        XOnlineTaskClose( m_hOnlineTask );
        m_hOnlineTask = NULL;
    }
}




//-----------------------------------------------------------------------------
// Name: Continue()
// Desc: Pump the task 
//-----------------------------------------------------------------------------
HRESULT CXBOnlineTask::Continue()
{
   return XOnlineTaskContinue( m_hOnlineTask );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbRandName.cpp ===
//-----------------------------------------------------------------------------
// File: XbRandName.cpp
//
// Desc: Generates a random and somewhat readable name. Useful for fake
//       player names, session names, etc.
//
//       Based on "Random Number Generators; Good ones are hard to find", 
//       Stephen K. Park and Keith W. Miller, Communications of the ACM,
//       October 1988, Volume 31, Number 10, page 1192-1201.
//
// Hist: 10.10.01 - New for Nov release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbRandName.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const DWORD MAX_RAND_NAME = 128;

// These values based on original RNG article (see above)
const LONG MODULUS = 2147483647L;
const LONG MULTIPLIER = 48271L;
const LONG Q = MODULUS / MULTIPLIER;
const LONG R = MODULUS % MULTIPLIER;




//-----------------------------------------------------------------------------
// Name: CXBRandName()
// Desc: Create rand name generator
//-----------------------------------------------------------------------------
CXBRandName::CXBRandName( DWORD dwSeed )
{
    SetSeed( dwSeed );
}




//-----------------------------------------------------------------------------
// Name: ~CXBRandName()
// Desc: Destroy rand name generator
//-----------------------------------------------------------------------------
CXBRandName::~CXBRandName()
{
}




//-----------------------------------------------------------------------------
// Name: SetSeed()
// Desc: Reseed the generator
//-----------------------------------------------------------------------------
VOID CXBRandName::SetSeed( DWORD dwSeed )
{
    m_nValue = LONG( dwSeed );
    if( m_nValue <= 0 )
        m_nValue += MODULUS;
    assert( m_nValue > 0 && m_nValue <= MODULUS );
}




//-----------------------------------------------------------------------------
// Name: GetName()
// Desc: Generate a random name
//-----------------------------------------------------------------------------
VOID CXBRandName::GetName( WCHAR* strName, DWORD dwSize ) const
{
    assert( dwSize < MAX_RAND_NAME );

    // Name consists of two to five parts.
    //
    // 1) consonant or consonant group (e.g. th, qu, st) [optional]
    // 2) vowel or vowel group (e.g. ea, ee, au)
    // 3) consonant or consonant group
    // 4) vowel or vowel group [optional]
    // 5) consonant or consonant group [optional]

    WCHAR strRandom[ MAX_RAND_NAME ];
    strRandom[ 0 ] = 0;
    if( ( GetRand() % 2 == 0 ) )
        AppendConsonant( strRandom, TRUE );
    AppendVowel( strRandom );
    AppendConsonant( strRandom, FALSE );
    if( ( GetRand() % 2 == 0 ) )
    {
        AppendVowel( strRandom );
        if( ( GetRand() % 2 == 0 ) )
            AppendConsonant( strRandom, FALSE );
    }

    // Make the first letter upper case
    *strRandom = towupper( *strRandom );

    lstrcpynW( strName, strRandom, dwSize );
}




//-----------------------------------------------------------------------------
// Name: GetRand()
// Desc: Generates a pseudo random number. This implementation is based on
//       the portable implementation defined in the C Standard. We use
//       this instead of CRT rand() to avoid interfering with the random
//       number sequence generated by rand().
//-----------------------------------------------------------------------------
DWORD CXBRandName::GetRand() const
{
    m_nValue = ( MULTIPLIER * ( m_nValue % Q ) ) - ( R * ( m_nValue / Q ) );
    if( m_nValue <= 0 )
        m_nValue += MODULUS;
    assert( m_nValue > 0 && m_nValue <= MODULUS );
    return DWORD( m_nValue );
}



//-----------------------------------------------------------------------------
// Name: GetRandVowel()
// Desc: Get a random vowel
//-----------------------------------------------------------------------------
WCHAR CXBRandName::GetRandVowel() const // private
{
    for(;;)
    {
        WCHAR c = WCHAR( L'a' + ( GetRand() % 26 ) );
        if( wcschr( L"aeiou", c ) != NULL )
            return c;
    }
}




//-----------------------------------------------------------------------------
// Name: GetRandConsonant()
// Desc: Get a random consonant
//-----------------------------------------------------------------------------
WCHAR CXBRandName::GetRandConsonant() const // private
{
    for(;;)
    {
        WCHAR c = WCHAR( L'a' + ( GetRand() % 26 ) );
        if( wcschr( L"aeiou", c ) == NULL )
            return c;
    }
}




//-----------------------------------------------------------------------------
// Name: AppendConsonant()
// Desc: Append consonant or consonant group to string
//-----------------------------------------------------------------------------
VOID CXBRandName::AppendConsonant( WCHAR* strRandom, BOOL bLeading ) const // private
{
    if( ( GetRand() % 2 == 0 ) )
    {
        WCHAR strChar[ 2 ] = { GetRandConsonant(), 0 };
        lstrcatW( strRandom, strChar );
    }
    else
    {
        WCHAR* strLeadConGroup[32] = 
        {
            L"bl", L"br", L"cl", L"cr", L"dr", L"fl", L"fr", L"gh", L"gl", L"gn", 
            L"gr", L"kl", L"kn", L"kr", L"ph", L"pl", L"pr", L"ps", L"qu", L"sc", 
            L"sk", L"sl", L"sn", L"sp", L"st", L"sw", L"th", L"tr", L"vh", L"vl", 
            L"wh", L"zh"
        };
        WCHAR* strTrailConGroup[32] = 
        {
            L"rt", L"ng", L"bs", L"cs", L"ds", L"gs", L"hs", L"sh", L"ss", L"ks",
            L"ms", L"ns", L"ps", L"rs", L"ts", L"gh", L"ph", L"sk", L"st", L"tt",
            L"nd", L"nk", L"nt", L"nx", L"pp", L"rd", L"rg", L"rk", L"rn", L"rv",
            L"th", L"ys"
        };
        if( bLeading )
            lstrcatW( strRandom, strLeadConGroup[ GetRand() % 32 ] );
        else
            lstrcatW( strRandom, strTrailConGroup[ GetRand() % 32 ] );
    }
}




//-----------------------------------------------------------------------------
// Name: AppendVowel()
// Desc: Append vowel or vowel group to string
//-----------------------------------------------------------------------------
VOID CXBRandName::AppendVowel( WCHAR* strRandom ) const // private
{
    if( ( GetRand() % 2 == 0 ) )
    {
        WCHAR strChar[ 2 ] = { GetRandVowel(), 0 };
        lstrcatW( strRandom, strChar );
    }
    else
    {
        WCHAR* strVowelGroup[10] =
        {
            L"ai", L"au", L"ay", L"ea", L"ee", L"ie", L"oa", L"oi", L"oo", L"ou"
        };
        lstrcatW( strRandom, strVowelGroup[ GetRand() % 10 ] );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbnet.cpp ===
//-----------------------------------------------------------------------------
// File: XbNet.cpp
//
// Desc: Shortcut macros and helper functions for the Xbox networking samples
//       Requires linking with XNET[D][S].LIB or XONLINE[D][S].LIB
//
// Hist: 09.06.01 - New for November XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBNet.h"




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

// Check network link status twice/sec
const FLOAT CHECK_LINK_STATUS = 0.5f;




//-----------------------------------------------------------------------------
// Name: XBNet_Init()
// Desc: Performs all required initialization for network play
//-----------------------------------------------------------------------------
HRESULT XBNet_Init( BYTE cfgFlags )
{
    // Initialize the network stack. For default initialization, call
    // XNetStartup( NULL );
    XNetStartupParams xnsp;
    ZeroMemory( &xnsp, sizeof(xnsp) );
    xnsp.cfgSizeOfStruct = sizeof(xnsp);
    xnsp.cfgFlags = cfgFlags;
    INT iResult = XNetStartup( &xnsp );
    if( iResult != NO_ERROR )
        return E_FAIL;

    // Standard WinSock startup. The Xbox allows all versions of Winsock
    // up through 2.2 (i.e. 1.0, 1.1, 2.0, 2.1, and 2.2), although it 
    // technically supports only and exactly what is specified in the 
    // Xbox network documentation, not necessarily the full Winsock 
    // functional specification.
    WSADATA WsaData;
    iResult = WSAStartup( MAKEWORD(2,2), &WsaData );
    if( iResult != NO_ERROR )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBNet_OnlineInit()
// Desc: Performs all required initialization for XOnline and network APIs
//-----------------------------------------------------------------------------
HRESULT XBNet_OnlineInit( BYTE cfgFlags, PXONLINE_STARTUP_PARAMS pxosp)
{
	XONLINE_STARTUP_PARAMS xosp = { 0 };

	if( pxosp == NULL )
	{
		pxosp = &xosp;
	}

    HRESULT hr = XBNet_Init( cfgFlags );
    if( SUCCEEDED( hr ) )
    {
        hr = XOnlineStartup( pxosp );
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBNet_Cleanup()
// Desc: Performs all required cleanup for network play
//-----------------------------------------------------------------------------
HRESULT XBNet_Cleanup()
{
    // Shutdown sockets
    INT iResult = WSACleanup();
    BOOL bSuccess = ( iResult == NO_ERROR );

    // Shutdown network stack
    // Always call XNetCleanup even if WSACleanup failed
    iResult = XNetCleanup();
    bSuccess &= ( iResult == NO_ERROR );

    return( bSuccess ? S_OK : E_FAIL );
}




//-----------------------------------------------------------------------------
// Name: XBNet_OnlineCleanup()
// Desc: Performs all required cleanup for online APIs
//-----------------------------------------------------------------------------
HRESULT XBNet_OnlineCleanup()
{

  HRESULT hr = XOnlineCleanup();

  if( SUCCEEDED( hr ) )
  {
      hr = XBNet_Cleanup();
  }

  return hr;
}




//-----------------------------------------------------------------------------
// Name: CXBNetLink()
// Desc: Create network link checker
//-----------------------------------------------------------------------------
CXBNetLink::CXBNetLink()
:
    m_LinkStatusTimer( FALSE ) // don't start timer yet
{
}




//-----------------------------------------------------------------------------
// Name: IsActive()
// Desc: Returns TRUE if network link is active; FALSE if not
//-----------------------------------------------------------------------------
BOOL CXBNetLink::IsActive() const
{
    BOOL bIsActive = TRUE;

    // For speed, only check every half second
    if( !m_LinkStatusTimer.IsRunning() ||
         m_LinkStatusTimer.GetElapsedSeconds() > CHECK_LINK_STATUS )
    {
        // Reset timer
        m_LinkStatusTimer.StartZero();

        // Poll status
        DWORD dwStatus = XNetGetEthernetLinkStatus();
        bIsActive = ( dwStatus & XNET_ETHERNET_LINK_ACTIVE ) != 0;
    }

    return bIsActive;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XBPerf.cpp ===
//-----------------------------------------------------------------------------
// File: XBPerf.cpp
//
// Desc: Sample to show off tri-stripping performance results
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: XBPerf_CalcCacheHits()
// Desc: Calculate the number of cache hits and degenerate triangles
//-----------------------------------------------------------------------------
HRESULT XBPerf_CalcCacheHits( D3DPRIMITIVETYPE dwPrimType, DWORD dwVertexSize,
						      WORD* pIndices, DWORD dwNumIndices,
						      DWORD* pdwNumDegenerateTris,
						      DWORD* pdwNumCacheHits,
 						      DWORD* pdwNumPagesCrossed )
{
	// Check arguments
	if( NULL == pdwNumDegenerateTris || NULL == pdwNumCacheHits || 
		NULL == pdwNumPagesCrossed )
		return E_INVALIDARG;

	// Initialize results
    (*pdwNumDegenerateTris) = 0;
    (*pdwNumCacheHits)      = 0;
    (*pdwNumPagesCrossed)   = 1;

	// Simulate a vertex cache
    static const int CACHE_SIZE = 12;
	static const int PAGE_SIZE  = 4096;
    DWORD rgdwCache[CACHE_SIZE];
    INT   iCachePtr      = 0;
    BOOL  bIsTriStrip    = (dwPrimType == D3DPT_TRIANGLESTRIP);
    DWORD dwLastPageAddr = 0;
    memset( rgdwCache, 0xff, sizeof(rgdwCache) );

	// Run all vertices through the sumilated vertex cache, tallying cache hits,
	// degenerate triangles, and pages crossed.
    for( DWORD i = 0; i < dwNumIndices; i++ )
    {
        // This makes all kinds of assumptions such as page size is 4k,
        // page across then back is ok, etc etc. Seems to be an ok
        // estimate on data locality though.
        DWORD dwPage = dwVertexSize * pIndices[i] / PAGE_SIZE;

        if( ( dwPage > dwLastPageAddr ) || ( dwPage+1 < dwLastPageAddr ) )
        {
            (*pdwNumPagesCrossed)++;
            dwLastPageAddr = dwVertexSize * pIndices[i] / PAGE_SIZE;
        }

        // Update our count of degenerate tris
        if( bIsTriStrip && (i > 1) )
			if( ( pIndices[i-0] == pIndices[i-1] ) ||
			    ( pIndices[i-0] == pIndices[i-2] ) ||
			    ( pIndices[i-1] == pIndices[i-2] ) )
				(*pdwNumDegenerateTris)++;

		// Check to see if the vertex would be in the cache
		BOOL bVertexInCache = FALSE;
        for( int cache_index = 0; cache_index < CACHE_SIZE; cache_index++ )
        {
            if( pIndices[i] == rgdwCache[cache_index] )
            {
				bVertexInCache = TRUE;
                break;
            }
        }

        if( bVertexInCache )
        {
			// Keep track of cache hits
            (*pdwNumCacheHits)++;
		}
        else 
        {
            // Add vertex to simulated cache
            rgdwCache[iCachePtr] = pIndices[i];
            iCachePtr = (iCachePtr + 1) % CACHE_SIZE;
        }
    }

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBPerf_GetCpuSpeed()
// Desc: Returns a calculation of the CPU speed.
//-----------------------------------------------------------------------------
#pragma optimize("g", on)
double XBPerf_GetCpuSpeed()
{
    __int64 start, end, freq;
    int     clocks;
	HANDLE  hThread;
    int     iOldThreadPriority;

    hThread = GetCurrentThread();

    // save the current so it can be set back later
    iOldThreadPriority = GetThreadPriority(hThread);

    // boost this thread to do the calculations, making sure no other
    // thread interrupts the calculations
    SetThreadPriority(hThread, THREAD_PRIORITY_TIME_CRITICAL);

    Sleep(10);

    QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
    QueryPerformanceCounter((LARGE_INTEGER*)&start);
    _asm
    {
        rdtsc
        mov     ecx, 100000
x:      dec     ecx
        jnz     x
        mov     ebx,eax
        rdtsc
        sub     eax,ebx
        mov     dword ptr clocks[0],eax
    }
    QueryPerformanceCounter((LARGE_INTEGER*)&end);

    // restore the thread priority
    SetThreadPriority(hThread, iOldThreadPriority);
    CloseHandle(hThread);

    int time = MulDiv((int)(end - start), 1000000, (int)freq);

    return ((clocks + time / 2) / time);
}
#pragma optimize("g", off)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbSocket.cpp ===
//-----------------------------------------------------------------------------
// File: XbSocket.cpp
//
// Desc: Wraps SOCKET object
//
// Hist: 05.17.01 - New for June XDK release
//       08.08.01 - Moved to common framework
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbSocket.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Name: CXBSocket()
// Desc: Associate existing socket with object. Object will close the socket
//       when it is destroyed.
//-----------------------------------------------------------------------------
CXBSocket::CXBSocket( SOCKET sock )
:
    m_Socket( sock )
{
}




//-----------------------------------------------------------------------------
// Name: CXBSocket()
// Desc: Create a socket of the given type
//-----------------------------------------------------------------------------
CXBSocket::CXBSocket( SocketType type )
:
    m_Socket( INVALID_SOCKET )
{
    BOOL bSuccess = Open( type );
    assert( bSuccess );
    (VOID)bSuccess;
}






//-----------------------------------------------------------------------------
// Name: CXBSocket()
// Desc: Create a socket of the given type/protocol
//-----------------------------------------------------------------------------
CXBSocket::CXBSocket( INT iType, INT iProtocol )
:
    m_Socket( INVALID_SOCKET )
{
    BOOL bSuccess = Open( iType, iProtocol );
    assert( bSuccess );
    (VOID)bSuccess;
}




//-----------------------------------------------------------------------------
// Name: ~CXBSocket()
// Desc: Close and release socket
//-----------------------------------------------------------------------------
CXBSocket::~CXBSocket()
{
    Close();
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Open a socket of the given type
//-----------------------------------------------------------------------------
BOOL CXBSocket::Open( SocketType type )
{
    return ( type == Type_UDP ) ? Open( SOCK_DGRAM, IPPROTO_UDP ) :
                                  Open( SOCK_STREAM, IPPROTO_TCP );
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Open a socket of the given type/protocol
//-----------------------------------------------------------------------------
BOOL CXBSocket::Open( INT iType, INT iProtocol )
{
    Close();
    m_Socket = socket( AF_INET, iType, iProtocol );
    return( m_Socket != INVALID_SOCKET );
}




//-----------------------------------------------------------------------------
// Name: IsOpen()
// Desc: TRUE if socket is open
//-----------------------------------------------------------------------------
BOOL CXBSocket::IsOpen() const
{
    return( m_Socket != INVALID_SOCKET );
}




//-----------------------------------------------------------------------------
// Name: Close()
// Desc: Close socket
//-----------------------------------------------------------------------------
INT CXBSocket::Close()
{
    INT iResult = 0;
    if( m_Socket != INVALID_SOCKET )
    {
        iResult = closesocket( m_Socket );
        m_Socket = INVALID_SOCKET;
    }
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: Accept()
// Desc: Permit incoming connection attempt
//-----------------------------------------------------------------------------
SOCKET CXBSocket::Accept( SOCKADDR_IN* pSockAddr )
{
    assert( m_Socket != INVALID_SOCKET );
    INT iSize = sizeof( SOCKADDR_IN );

    SOCKET sockResult = accept( m_Socket, (sockaddr*)(pSockAddr), &iSize );

    if( sockResult != INVALID_SOCKET && pSockAddr != NULL )
        assert( iSize == sizeof( SOCKADDR_IN ) );
    return sockResult;
}




//-----------------------------------------------------------------------------
// Name: Bind()
// Desc: Associate local address with socket
//-----------------------------------------------------------------------------
INT CXBSocket::Bind( const SOCKADDR_IN* pSockAddr )
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pSockAddr != NULL );
    assert( pSockAddr->sin_family == AF_INET );

    INT iResult = bind( m_Socket, (const sockaddr*)(pSockAddr), 
                        sizeof( SOCKADDR_IN ) );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: Connect()
// Desc: Connect socket
//-----------------------------------------------------------------------------
INT CXBSocket::Connect( const SOCKADDR_IN* pSockAddr )
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pSockAddr != NULL );
    assert( pSockAddr->sin_family == AF_INET );

    INT iResult = connect( m_Socket, (const sockaddr*)(pSockAddr), 
                           sizeof( SOCKADDR_IN ) );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: GetSockName()
// Desc: Get socket "name"
//-----------------------------------------------------------------------------
INT CXBSocket::GetSockName( SOCKADDR_IN* pSockAddr ) const
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pSockAddr != NULL );
    INT iSize = sizeof( SOCKADDR_IN );

    INT iResult = getsockname( m_Socket, (sockaddr*)(pSockAddr), &iSize );

    if( iResult != SOCKET_ERROR )
        assert( iSize == sizeof( SOCKADDR_IN ) );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: GetSockOpt()
// Desc: Get socket option
//-----------------------------------------------------------------------------
INT CXBSocket::GetSockOpt( INT iLevel, INT iName, VOID* pValue, INT* piSize ) const
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pValue != NULL );
    assert( piSize != NULL );

    INT iResult = getsockopt( m_Socket, iLevel, iName, (CHAR*)(pValue), piSize );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: IoCtlSocket()
// Desc: Configure socket I/O mode
//-----------------------------------------------------------------------------
INT CXBSocket::IoCtlSocket( LONG nCmd, DWORD* pArg )
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pArg != NULL );

    INT iResult = ioctlsocket( m_Socket, nCmd, pArg );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: Listen()
// Desc: Listen for incoming connection
//-----------------------------------------------------------------------------
INT CXBSocket::Listen( INT iBacklog )
{
    assert( m_Socket != INVALID_SOCKET );

    INT iResult = listen( m_Socket, iBacklog );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: Recv()
// Desc: Receive data on socket
//-----------------------------------------------------------------------------
INT CXBSocket::Recv( VOID* pBuffer, INT iBytes )
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pBuffer != NULL );
    assert( iBytes >= 0 );

    INT iResult = recv( m_Socket, (CHAR*)(pBuffer), iBytes, 0 );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: RecvFrom()
// Desc: Receive data on socket and report source address
//-----------------------------------------------------------------------------
INT CXBSocket::RecvFrom( VOID* pBuffer, INT iBytes, SOCKADDR_IN* pSockAddr )
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pBuffer != NULL );
    assert( iBytes >= 0 );
    INT iSize = sizeof( SOCKADDR_IN );

    INT iResult = recvfrom( m_Socket, (CHAR*)(pBuffer), iBytes, 0, 
                            (sockaddr*)(pSockAddr), &iSize );
    if( iResult != SOCKET_ERROR && pSockAddr != NULL )
        assert( iSize == sizeof( SOCKADDR_IN ) );

    return iResult;
}




//-----------------------------------------------------------------------------
// Name: Send()
// Desc: Send data on socket
//-----------------------------------------------------------------------------
INT CXBSocket::Send( const VOID* pBuffer, INT iBytes )
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pBuffer != NULL );
    assert( iBytes >= 0 );

    INT iResult = send( m_Socket, (const CHAR*)(pBuffer), iBytes, 0 );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: SendTo()
// Desc: Send data on socket to specific destination
//-----------------------------------------------------------------------------
INT CXBSocket::SendTo( const VOID* pBuffer, INT iBytes, const SOCKADDR_IN* pSockAddr )
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pBuffer != NULL );
    assert( iBytes >= 0 );

    INT iResult = sendto( m_Socket, (const CHAR*)(pBuffer), iBytes, 0, 
                          (const sockaddr*)(pSockAddr), sizeof( SOCKADDR_IN ) );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: SetSockOpt()
// Desc: Set socket option
//-----------------------------------------------------------------------------
INT CXBSocket::SetSockOpt( INT iLevel, INT iName, const VOID* pValue, INT iBytes )
{
    assert( m_Socket != INVALID_SOCKET );
    assert( pValue != NULL );

    INT iResult = setsockopt( m_Socket, iLevel, iName, (const CHAR*)(pValue), 
                              iBytes );
    return iResult;
}




//-----------------------------------------------------------------------------
// Name: Shutdown()
// Desc: Disabled sending and/or receiving on socket
//-----------------------------------------------------------------------------
INT CXBSocket::Shutdown( INT iHow )
{
    assert( m_Socket != INVALID_SOCKET );

    INT iResult = shutdown( m_Socket, iHow );
    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XBResource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

	// Open the file
	HANDLE hFile;
	DWORD dwNumBytesRead;
	hFile = CreateFile(strResourcePath, GENERIC_READ, FILE_SHARE_READ, NULL,
		               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
	    OUTPUT_DEBUG_STRING( "CXBPackedResource::Create(): ERROR: File not found!\n" );
        return E_FAIL;
    }

   
	// Read in and verify the XPR magic header
    XPR_HEADER xprh;

	ReadFile(hFile, &xprh, sizeof(XPR_HEADER), &dwNumBytesRead, NULL);
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OUTPUT_DEBUG_STRING( "Invalid Xbox Packed Resource (.xpr) file" );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
	ReadFile(hFile, m_pSysMemData, dwSysMemDataSize, &dwNumBytesRead, NULL);
	ReadFile(hFile, m_pVidMemData, dwVidMemDataSize, &dwNumBytesRead, NULL);

    // Done with the file
    CloseHandle(hFile);
    
    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += sizeof(DWORD) * 2;

            (VOID)dwType; // not used
			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbsockaddr.cpp ===
//-----------------------------------------------------------------------------
// File: XbSockAddr.cpp
//
// Desc: Wraps SOCKADDR_IN object
//
// Hist: 05.17.01 - New for June XDK release
//       08.08.01 - Moved to common framework
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbSockAddr.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Name: CXBSockAddr()
// Desc: Create from SOCKADDR_IN
//-----------------------------------------------------------------------------
CXBSockAddr::CXBSockAddr( const SOCKADDR_IN& sa )
: 
    sockaddr_in()
{
    assert( sa.sin_family == AF_INET );
    sin_family = AF_INET;
    sin_addr = sa.sin_addr;
    sin_port = sa.sin_port;
}




//-----------------------------------------------------------------------------
// Name: CXBSockAddr()
// Desc: Create from IP address and port
//-----------------------------------------------------------------------------
CXBSockAddr::CXBSockAddr( DWORD inAddr, WORD wPort )
: 
    sockaddr_in()
{
    sin_family = AF_INET;
    sin_addr.s_addr = inAddr;
    sin_port = htons( wPort );
}




//-----------------------------------------------------------------------------
// Name: CXBSockAddr()
// Desc: Create from IN_ADDR and port
//-----------------------------------------------------------------------------
CXBSockAddr::CXBSockAddr( const IN_ADDR& inAddr, WORD wPort )
: 
    sockaddr_in()
{
    sin_family = AF_INET;
    sin_addr = inAddr;
    sin_port = htons( wPort );
}




//-----------------------------------------------------------------------------
// Name: GetInAddr()
// Desc: Extract IN_ADDR
//-----------------------------------------------------------------------------
IN_ADDR CXBSockAddr::GetInAddr() const
{
    return sin_addr;
}




//-----------------------------------------------------------------------------
// Name: GetPtr()
// Desc: Direct (constant) access
//-----------------------------------------------------------------------------
const SOCKADDR_IN* CXBSockAddr::GetPtr() const
{
    return this;
}




//-----------------------------------------------------------------------------
// Name: GetAddr()
// Desc: Socket IP address
//-----------------------------------------------------------------------------
DWORD CXBSockAddr::GetAddr() const
{
    return( ntohl( sin_addr.s_addr ) );
}




//-----------------------------------------------------------------------------
// Name: GetPort()
// Desc: Port number
//-----------------------------------------------------------------------------
WORD CXBSockAddr::GetPort() const
{
    return( ntohs( sin_port ) );
}




//-----------------------------------------------------------------------------
// Name: GetStr()
// Desc: Address in dotted decimal (a.b.c.d) format, with optional port
//       specifier (a.b.c.d:p). Incoming string buffer must have enough
//       room for result (16 WCHARS if no port, 22 if port).
//-----------------------------------------------------------------------------
VOID CXBSockAddr::GetStr( WCHAR* strAddr, BOOL bIncludePort ) const
{
    assert( strAddr != NULL );
    
    INT iChars = wsprintfW( strAddr, L"%d.%d.%d.%d", 
                            sin_addr.S_un.S_un_b.s_b1,
                            sin_addr.S_un.S_un_b.s_b2,
                            sin_addr.S_un.S_un_b.s_b3,
                            sin_addr.S_un.S_un_b.s_b4 );

    if( bIncludePort )
    {
        WCHAR strPort[8];
        wsprintfW( strPort, L":%d", GetPort() );
        lstrcpyW( strAddr + iChars, strPort );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbStopWatch.cpp ===
//-----------------------------------------------------------------------------
// File: XbStopWatch.cpp
//
// Desc: StopWatch object using QueryPerformanceCounter
//
// Hist: 01.19.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbStopWatch.h"




//-----------------------------------------------------------------------------
// Name: CXBStopWatch()
// Desc: Creates the stopwatch. By default, stopwatch starts running immediately
//-----------------------------------------------------------------------------
CXBStopWatch::CXBStopWatch( BOOL bStartWatch )
:
    m_fTimerPeriod      ( 0.0f ),
    m_nStartTick        ( 0 ),
    m_nPrevElapsedTicks ( 0 ),
    m_bIsRunning        ( FALSE )   // set in Start()
{
    // Get the timer frequency (ticks per second)
    LARGE_INTEGER qwTimerFreq;
    QueryPerformanceFrequency( &qwTimerFreq );

    // Store as period to avoid division in GetElapsed()
    m_fTimerPeriod = 1.0f / (FLOAT)( qwTimerFreq.QuadPart );

    if( bStartWatch )
        Start();
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Starts the stopwatch running. Does not clear any previous time held
//       by the watch.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Start()
{
    m_nStartTick = GetTicks();
    m_bIsRunning = TRUE;
}




//-----------------------------------------------------------------------------
// Name: StartZero()
// Desc: Starts the stopwatch running at time zero. Same as calling Reset() and
//       then Start();
//-----------------------------------------------------------------------------
VOID CXBStopWatch::StartZero()
{
    m_nPrevElapsedTicks = 0;
    m_nStartTick = GetTicks();
    m_bIsRunning = TRUE;
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stops the stopwatch. After stopping the watch, GetElapsed() will 
//       return the same value until the watch is started or reset.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Stop()
{
    if( m_bIsRunning )
    {
        // Store the elapsed time
        m_nPrevElapsedTicks += GetTicks() - m_nStartTick;
        m_nStartTick = 0;

        // Stop running
        m_bIsRunning = FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: Reset()
// Desc: Resets the stopwatch to zero. If the watch was running, it continues
//       to run.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Reset()
{
    m_nPrevElapsedTicks = 0;
    if( m_bIsRunning )
        m_nStartTick = GetTicks();
}




//-----------------------------------------------------------------------------
// Name: IsRunning()
// Desc: TRUE if the stopwatch is running, else FALSE
//-----------------------------------------------------------------------------
BOOL CXBStopWatch::IsRunning() const
{
    return( m_bIsRunning );
}




//-----------------------------------------------------------------------------
// Name: GetElapsedSeconds()
// Desc: The amount of time the watch has been running since it was last
//       reset, in seconds
//-----------------------------------------------------------------------------
FLOAT CXBStopWatch::GetElapsedSeconds() const
{
    // Start with any previous time
    LONGLONG nTotalTicks( m_nPrevElapsedTicks );

    // If the watch is running, add the time since the last start
    if( m_bIsRunning )
        nTotalTicks += GetTicks() - m_nStartTick;

    // Convert to floating pt
    FLOAT fSeconds = (FLOAT)( nTotalTicks ) * m_fTimerPeriod;
    return( fSeconds );
}




//-----------------------------------------------------------------------------
// Name: GetElapsedMilliseconds()
// Desc: The amount of time the watch has been running since it was last
//       reset, in mS
//-----------------------------------------------------------------------------
FLOAT CXBStopWatch::GetElapsedMilliseconds() const
{
    return( GetElapsedSeconds() * 1000.0f );
}




//-----------------------------------------------------------------------------
// Name: GetTicks()
// Desc: Private function wraps QueryPerformanceCounter()
//-----------------------------------------------------------------------------
LONGLONG CXBStopWatch::GetTicks() const
{
    // Grab the current tick count
    LARGE_INTEGER qwCurrTicks;
    QueryPerformanceCounter( &qwCurrTicks );
    return( qwCurrTicks.QuadPart );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbsound.cpp ===
//-----------------------------------------------------------------------------
// File: XBSound.cpp
//
// Desc: Helper class for reading a .wav file and playing it in a DirectSound
//       buffer.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBSound.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// FourCC definitions
//-----------------------------------------------------------------------------
const DWORD FOURCC_RIFF   = 'FFIR';
const DWORD FOURCC_WAVE   = 'EVAW';
const DWORD FOURCC_FORMAT = ' tmf';
const DWORD FOURCC_DATA   = 'atad';
const DWORD FOURCC_WSMP   = 'pmsw';



//-----------------------------------------------------------------------------
// Name: struct WAVESAMPE
// Desc: RIFF chunk type that contains loop point information
//-----------------------------------------------------------------------------
struct WAVESAMPLE
{
    ULONG   cbSize;
    USHORT  usUnityNote;
    SHORT   sFineTune;
    LONG    lGain;
    ULONG   ulOptions;
    ULONG   cSampleLoops;
};

//-----------------------------------------------------------------------------
// Name: struct WAVESAMPLE_LOOP
// Desc: Loop point (contained in WSMP chunk)
//-----------------------------------------------------------------------------
struct WAVESAMPLE_LOOP
{
    ULONG cbSize;
    ULONG ulLoopType;
    ULONG ulLoopStart;
    ULONG ulLoopLength;
};




//-----------------------------------------------------------------------------
// Name: CRiffChunk()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CRiffChunk::CRiffChunk()
{
    // Initialize defaults
    m_fccChunkId   = 0;
    m_pParentChunk = NULL;
    m_hFile        = INVALID_HANDLE_VALUE;
    m_dwDataOffset = 0;
    m_dwDataSize   = 0;
    m_dwFlags      = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the object
//-----------------------------------------------------------------------------
VOID CRiffChunk::Initialize( FOURCC fccChunkId, const CRiffChunk* pParentChunk, 
                             HANDLE hFile )
{
    m_fccChunkId   = fccChunkId;
    m_pParentChunk = pParentChunk;
    m_hFile        = hFile;
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Opens an existing chunk.
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::Open()
{
    RIFFHEADER rhRiffHeader;
    LONG       lOffset = 0;

    // Seek to the first byte of the parent chunk's data section
    if( m_pParentChunk )
    {
        lOffset = m_pParentChunk->m_dwDataOffset;

        // Special case the RIFF chunk
        if( FOURCC_RIFF == m_pParentChunk->m_fccChunkId )
            lOffset += sizeof(FOURCC);
    }
    
    // Read each child chunk header until we find the one we're looking for
    for( ;; )
    {
        if( INVALID_SET_FILE_POINTER == SetFilePointer( m_hFile, lOffset, NULL, FILE_BEGIN ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        DWORD dwRead;
        if( 0 == ReadFile( m_hFile, &rhRiffHeader, sizeof(rhRiffHeader), &dwRead, NULL ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        // Hit EOF without finding it
        if( 0 == dwRead )
            return E_FAIL;

        // Check if we found the one we're looking for
        if( m_fccChunkId == rhRiffHeader.fccChunkId )
        {
            // Save the chunk size and data offset
            m_dwDataOffset = lOffset + sizeof(rhRiffHeader);
            m_dwDataSize   = rhRiffHeader.dwDataSize;

            // Success
            m_dwFlags |= RIFFCHUNK_FLAGS_VALID;

            return S_OK;
        }

        lOffset += sizeof(rhRiffHeader) + rhRiffHeader.dwDataSize;
    }
}




//-----------------------------------------------------------------------------
// Name: Read()
// Desc: Reads from the file
//-----------------------------------------------------------------------------
HRESULT CRiffChunk::ReadData( LONG lOffset, VOID* pData, DWORD dwDataSize )
{
    // Seek to the offset
    DWORD dwPosition = SetFilePointer( m_hFile, m_dwDataOffset+lOffset, NULL, FILE_BEGIN );
    if( INVALID_SET_FILE_POINTER == dwPosition )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Read from the file
    DWORD dwRead;
    if( 0 == ReadFile( m_hFile, pData, dwDataSize, &dwRead, NULL ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CWaveFile()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWaveFile::CWaveFile()
{
    m_hFile = INVALID_HANDLE_VALUE;
}




//-----------------------------------------------------------------------------
// Name: ~CWaveFile()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWaveFile::~CWaveFile()
{
    Close();
}




//-----------------------------------------------------------------------------
// Name: Open()
// Desc: Initializes the object.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::Open( const CHAR* strFileName )
{
    // If we're already open, close
    Close();
    
    // Open the file
    m_hFile = CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                          OPEN_EXISTING, 0L, NULL );
    if( INVALID_HANDLE_VALUE == m_hFile )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Initialize the chunk objects
    m_RiffChunk.Initialize( FOURCC_RIFF, NULL, m_hFile );
    m_FormatChunk.Initialize( FOURCC_FORMAT, &m_RiffChunk, m_hFile );
    m_DataChunk.Initialize( FOURCC_DATA, &m_RiffChunk, m_hFile );
    m_WaveSampleChunk.Initialize( FOURCC_WSMP, &m_RiffChunk, m_hFile );

    HRESULT hr = m_RiffChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_FormatChunk.Open();
    if( FAILED(hr) )
        return hr;

    hr = m_DataChunk.Open();
    if( FAILED(hr) )
        return hr;

    // Wave Sample chunk is not required
    m_WaveSampleChunk.Open();

    // Validate the file type
    FOURCC fccType;
    hr = m_RiffChunk.ReadData( 0, &fccType, sizeof(fccType) );
    if( FAILED(hr) )
        return hr;

    if( FOURCC_WAVE != fccType )
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetFormat()
// Desc: Gets the wave file format
//-----------------------------------------------------------------------------
HRESULT CWaveFile::GetFormat( WAVEFORMATEX* pwfxFormat, DWORD dwFormatSize, DWORD * pdwRequiredSize )
{
    HRESULT hr = S_OK;
    DWORD dwValidSize = m_FormatChunk.GetDataSize();

    // We should be reading a wave format and/or
    // telling the caller the size of the format
    if( ( NULL == pwfxFormat ||
          0 == dwFormatSize ) && 
        NULL == pdwRequiredSize )
        return E_INVALIDARG;

    if( pwfxFormat && dwFormatSize )
    {
        // Read the format chunk into the buffer
        hr = m_FormatChunk.ReadData( 0, pwfxFormat, min(dwFormatSize, dwValidSize) );
        if( FAILED(hr) )
            return hr;

        // Zero out remaining bytes, in case enough bytes were not read
        if( dwFormatSize > dwValidSize )
            ZeroMemory( (BYTE*)pwfxFormat + dwValidSize, dwFormatSize - dwValidSize );
    }
    
    // Tell caller how much space they need for the format
    if( pdwRequiredSize )
    {
        *pdwRequiredSize = max( dwValidSize, sizeof( *pwfxFormat ) );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ReadSample()
// Desc: Reads data from the audio file.
//-----------------------------------------------------------------------------
HRESULT CWaveFile::ReadSample( DWORD dwPosition, VOID* pBuffer, 
                               DWORD dwBufferSize, DWORD* pdwRead )
{                                   
    // Don't read past the end of the data chunk
    DWORD dwDuration;
    GetDuration( &dwDuration );

    if( dwPosition + dwBufferSize > dwDuration )
        dwBufferSize = dwDuration - dwPosition;

    HRESULT hr = S_OK;
    if( dwBufferSize )
        hr = m_DataChunk.ReadData( (LONG)dwPosition, pBuffer, dwBufferSize );

    if( pdwRead )
        *pdwRead = dwBufferSize;

    return hr;
}




//-----------------------------------------------------------------------------
// Name: GetLoopRegion
// Desc: Gets the loop region, in terms of samples
//-----------------------------------------------------------------------------
HRESULT CWaveFile::GetLoopRegion( DWORD *pdwStart, DWORD *pdwLength )
{
    HRESULT hr = S_OK;
    WAVESAMPLE ws;
    WAVESAMPLE_LOOP wsl;

    // Check arguments
    if( NULL == pdwStart || NULL == pdwLength )
        return E_INVALIDARG;

    // Check to see if there was a wave sample chunk
    if( !m_WaveSampleChunk.IsValid() )
        return E_FAIL;
    
    // Read the WAVESAMPLE struct from the chunk
    hr = m_WaveSampleChunk.ReadData( 0, &ws, sizeof( WAVESAMPLE ) );
    if( FAILED( hr ) )
        return hr;

    // Currently, only 1 loop region is supported
    if( ws.cSampleLoops != 1 )
        return E_FAIL;

    // Read the loop region
    hr = m_WaveSampleChunk.ReadData( ws.cbSize, &wsl, sizeof( WAVESAMPLE_LOOP ) );
    if( FAILED( hr ) )
        return hr;
    
    // Fill output vars with the loop region
    *pdwStart = wsl.ulLoopStart;
    *pdwLength = wsl.ulLoopLength;

    return S_OK;
}
    



//-----------------------------------------------------------------------------
// Name: Close()
// Desc: Closes the object
//-----------------------------------------------------------------------------
VOID CWaveFile::Close()
{
    if( m_hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }
}




//-----------------------------------------------------------------------------
// Name: CXBSound()
// Desc: 
//-----------------------------------------------------------------------------
CXBSound::CXBSound()
{
    m_pDSoundBuffer = NULL;
    m_dwBufferSize  = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CXBSound()
// Desc: 
//-----------------------------------------------------------------------------
CXBSound::~CXBSound()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the sound. Sound is buffered to memory allocated internally
//       by DirectSound.
//-----------------------------------------------------------------------------
HRESULT CXBSound::Create( const CHAR* strFileName, DWORD dwFlags )
{
    // Find the media file
    CHAR strWavePath[512];
    HRESULT   hr;
    if( FAILED( hr = XBUtil_FindMediaFile( strWavePath, strFileName ) ) )
        return hr;

    // Open the .wav file
    CWaveFile waveFile;
    hr = waveFile.Open( strWavePath );
    if( FAILED(hr) )
        return hr;

    // Get the WAVEFORMAT structure for the .wav file
    hr = waveFile.GetFormat( &m_WaveFormat, sizeof(WAVEFORMATEX) );
    if( FAILED(hr) )
        return hr;

    // Get the size of the .wav file
    waveFile.GetDuration( &m_dwBufferSize );

    // Create the sound buffer
    hr = Create( &m_WaveFormat, dwFlags, NULL, m_dwBufferSize );
    if( FAILED(hr) )
        return hr;

    // Lock the buffer so it can be filled
    VOID* pLock1 = NULL;
    VOID* pLock2 = NULL;
    DWORD dwLockSize1 = 0L;
    DWORD dwLockSize2 = 0L;
    hr = m_pDSoundBuffer->Lock( 0L, m_dsbd.dwBufferBytes, &pLock1, &dwLockSize1, 
                                &pLock2, &dwLockSize2, 0L );
    if( FAILED(hr) )
        return hr;

    // Read the wave file data into the buffer
    hr = waveFile.ReadSample( 0L, pLock1, dwLockSize1, NULL );
    if( FAILED(hr) )
        return hr;

    // Unlock the buffer
    hr = m_pDSoundBuffer->Unlock( &pLock1, dwLockSize1, &pLock2, dwLockSize2 );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the sound and tells DirectSound where the sound data will be
//       stored. If pBuffer is NULL, DirectSound handles buffer creation.
//-----------------------------------------------------------------------------
HRESULT CXBSound::Create( const WAVEFORMATEX* pwfxFormat, DWORD dwFlags,
                          const VOID* pBuffer, DWORD dwBytes )
{
    // Setup the sound buffer description
    ZeroMemory( &m_dsbd, sizeof(DSBUFFERDESC) );
    m_dsbd.dwSize      = sizeof(DSBUFFERDESC);
    m_dsbd.dwFlags     = dwFlags;
    m_dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;

    // If pBuffer is non-NULL, dwBufferBytes will be zero, which informs
    // DirectSoundCreateBuffer that we will presently be using SetBufferData().
    // Otherwise, we set dwBufferBytes to the size of the WAV data, potentially
    // including alignment bytes.
    if( pBuffer == NULL )
    {
        m_dsbd.dwBufferBytes = ( 0 == m_WaveFormat.nBlockAlign ) ? dwBytes : 
                                 dwBytes - ( dwBytes % m_WaveFormat.nBlockAlign );
    }

    HRESULT hr = DirectSoundCreateBuffer(&m_dsbd, &m_pDSoundBuffer);
    if( FAILED(hr) )
        return hr;

    // If buffer specified, tell DirectSound to use it
    if( pBuffer != NULL )
    {
        hr = m_pDSoundBuffer->SetBufferData( (LPVOID)pBuffer, dwBytes );
        if( FAILED(hr) )
            return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the resources used by the sound
//-----------------------------------------------------------------------------
VOID CXBSound::Destroy()
{
    SAFE_RELEASE( m_pDSoundBuffer );
}




//-----------------------------------------------------------------------------
// Name: Play()
// Desc: Plays the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::Play( DWORD dwFlags ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->Play( 0, 0, dwFlags );
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stops the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::Stop() const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->Stop();
}




//-----------------------------------------------------------------------------
// Name: SetPosition()
// Desc: Positions the sound
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetPosition( const D3DXVECTOR3& v ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetPosition( v.x, v.y, v.z, DS3D_IMMEDIATE );
}




//-----------------------------------------------------------------------------
// Name: SetVelocity()
// Desc: Sets the sound's velocity
//-----------------------------------------------------------------------------
HRESULT CXBSound::SetVelocity( const D3DXVECTOR3& v ) const
{
    if( NULL == m_pDSoundBuffer )
        return E_INVALIDARG;
        
    return m_pDSoundBuffer->SetVelocity( v.x, v.y, v.z, DS3D_IMMEDIATE );
}



//-----------------------------------------------------------------------------
// Name: CDSPImage (constructor)
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CDSPImage::CDSPImage()
{
    m_dwImageSize = 0;
    m_pbImageData = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CDSPImage (destructor)
// Desc: Releases memory held by the object
//-----------------------------------------------------------------------------
CDSPImage::~CDSPImage()
{
    delete[] m_pbImageData;
}


//-----------------------------------------------------------------------------
// Name: LoadFromFile
// Desc: Loads the DSP image from the given file.  Searches in the media 
//       directory if it can't find the file as specified.
//-----------------------------------------------------------------------------
HRESULT 
CDSPImage::LoadFromFile( char * szFilename )
{
    HRESULT hr = S_OK;
    char szImagePath[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    // Find the media file
    hr = XBUtil_FindMediaFile( szImagePath, szFilename );
    if( FAILED( hr ) )
        return hr;

    // open scratch image file generated by XGPImage tool
    hFile = CreateFile( szImagePath,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    // Determine the size of the scratch image by seeking to
    // the end of the file
    m_dwImageSize = SetFilePointer( hFile, 0, NULL, FILE_END );
    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    // Delete and re-allocate buffer
    delete[] m_pbImageData;
    m_pbImageData = new BYTE[ m_dwImageSize ];

    // Read the image into memory
    DWORD dwBytesRead;
    BOOL bResult = ReadFile( hFile,
                             m_pbImageData,
                             m_dwImageSize,
                             &dwBytesRead,
                             0 );

    if( !bResult || dwBytesRead != m_dwImageSize )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        return hr;
    }

    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DownloadImage
// Desc: Downloads the DSP image by calling DownloadEffectsImage on the 
//       given DSound object
//-----------------------------------------------------------------------------
HRESULT 
CDSPImage::DownloadImage( LPDIRECTSOUND8 pDSound )
{
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;

    // Use a copy of the buffer so we can keep the original intact
    BYTE * pBuffer = new BYTE[ m_dwImageSize ];
    memcpy( pBuffer, m_pbImageData, m_dwImageSize );

    // call dsound api to download the image..
    hr = pDSound->DownloadEffectsImage( pBuffer,
                                        m_dwImageSize,
                                        NULL,
                                        &pDesc );
    // delete our modified copy
    delete[] pBuffer;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbStorageDevice.cpp ===
//-----------------------------------------------------------------------------
// File: XbStorageDevice.cpp
//
// Desc: Hard disk and memory unit devices. Provides save and load game
//       functionality.
//
// Hist: 01.30.01 - New for March XDK release
//       04.13.01 - Added GetClusterSize(), GetSaveGameOverhead() and
//                  GetFileBytes() for more accurate calculation of
//                  file sizes.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbStorageDevice.h"
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const CHAR* strROOT_PATH = "#:\\";  // "#:\", where # is the drive letter
const DWORD BLOCK_SIZE = 16384;     // TCR 3-11 Space Display




//-----------------------------------------------------------------------------
// Name: CXBStorageDevice()
// Desc: Construct storage device
//-----------------------------------------------------------------------------
CXBStorageDevice::CXBStorageDevice( CHAR chDriveLetter )
:
    m_hSaveGame( INVALID_HANDLE_VALUE ),
    m_strRootPath()
{
    lstrcpyA( m_strRootPath, strROOT_PATH );
    *m_strRootPath = chDriveLetter;
}




//-----------------------------------------------------------------------------
// Name: CXBStorageDevice()
// Desc: Copy storage device
//-----------------------------------------------------------------------------
CXBStorageDevice::CXBStorageDevice( const CXBStorageDevice& rhs )
:
    m_hSaveGame( INVALID_HANDLE_VALUE ),
    m_strRootPath()
{
    lstrcpyA( m_strRootPath, strROOT_PATH );
    *m_strRootPath = *rhs.m_strRootPath;
}




//-----------------------------------------------------------------------------
// Name: CXBStorageDevice()
// Desc: Copy storage device
//-----------------------------------------------------------------------------
CXBStorageDevice& CXBStorageDevice::operator=( const CXBStorageDevice& rhs )
{
    Cleanup();
    *m_strRootPath = *rhs.m_strRootPath;
    return *this;
}




//-----------------------------------------------------------------------------
// Name: ~CXBStorageDevice()
// Desc: Tear down the storage device
//-----------------------------------------------------------------------------
CXBStorageDevice::~CXBStorageDevice()
{
    Cleanup();
}




//-----------------------------------------------------------------------------
// Name: GetUserRegion()
// Desc: Get the object representing the save/load region of the Xbox hard drive
//-----------------------------------------------------------------------------
CXBStorageDevice CXBStorageDevice::GetUserRegion() // static
{
    return CXBStorageDevice( 'U' );
}




//-----------------------------------------------------------------------------
// Name: GetTitleRegion()
// Desc: Get the object representing the title persistent data region of the
//       Xbox hard drive
//-----------------------------------------------------------------------------
CXBStorageDevice CXBStorageDevice::GetTitleRegion() // static
{
    return CXBStorageDevice( 'T' );
}




//-----------------------------------------------------------------------------
// Name: GetUtilityRegion()
// Desc: Get the object representing the utility region of the Xbox hard drive
//-----------------------------------------------------------------------------
CXBStorageDevice CXBStorageDevice::GetUtilityRegion( BOOL fFormatClean ) // static
{
    XMountUtilityDrive( fFormatClean );
    return CXBStorageDevice( 'Z' );
}




//-----------------------------------------------------------------------------
// Name: GetBlockSize()
// Desc: Get the size of a device block in bytes
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetBlockSize() // static
{
    // TCR 3-11 Space Display
    return BLOCK_SIZE;
}




//-----------------------------------------------------------------------------
// Name: GetDrive()
// Desc: Returns the drive letter of this device. Returns 0 if device
//       identifies a nul device.
//-----------------------------------------------------------------------------
CHAR CXBStorageDevice::GetDrive() const
{
    return *m_strRootPath;
}




//-----------------------------------------------------------------------------
// Name: SetDrive()
// Desc: Changes the device to refer to a new drive. Invalidates any save game
//       enumeration.
//-----------------------------------------------------------------------------
VOID CXBStorageDevice::SetDrive( CHAR chDriveLetter )
{
    Cleanup();
    *m_strRootPath = chDriveLetter;
}




//-----------------------------------------------------------------------------
// Name: IsValid()
// Desc: TRUE if object specifies a valid storage device (drive letter != 0)
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::IsValid() const
{
    return( *m_strRootPath != 0 );
}




//-----------------------------------------------------------------------------
// Name: IsTitleRegion()
// Desc: TRUE if device specifies location of title persistent storage
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::IsTitleRegion() const
{
    return( *m_strRootPath == 'T' );
}




//-----------------------------------------------------------------------------
// Name: IsUtilityRegion()
// Desc: TRUE if device specifies location of utility/cache region
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::IsUtilityRegion() const
{
    return( *m_strRootPath == 'Z' );
}




//-----------------------------------------------------------------------------
// Name: GetSize()
// Desc: Get the total, used and free bytes. These values are always cluster
//       based; in other words, they're always evenly divisible by the
//       cluster size of the device.
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::GetSize( ULONGLONG& qwTotalBytes, ULONGLONG& qwUsedBytes,
                                ULONGLONG& qwFreeBytes ) const
{
    if( !IsValid() )
        return FALSE;

    ULARGE_INTEGER lFreeBytesAvailable;
    ULARGE_INTEGER lTotalNumberOfBytes;
    ULARGE_INTEGER lTotalNumberOfFreeBytes;

    BOOL bSuccess = GetDiskFreeSpaceEx( m_strRootPath,
                                        &lFreeBytesAvailable,
                                        &lTotalNumberOfBytes,
                                        &lTotalNumberOfFreeBytes );

    if( !bSuccess )
        return FALSE;

    qwTotalBytes = lTotalNumberOfBytes.QuadPart;
    qwFreeBytes  = lFreeBytesAvailable.QuadPart;
    qwUsedBytes  = qwTotalBytes - qwFreeBytes;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: GetSavedGameCount()
// Desc: Returns the number of games currently saved on the device
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetSavedGameCount() const
{
    // Use a local CXBStorageDevice object so we don't affect the state of
    // the save game handle.
    CXBStorageDevice thisDevice( *this );
    XGAME_FIND_DATA SaveGameData;

    // Any saves?
    if( !thisDevice.FindFirstSaveGame( SaveGameData ) )
        return 0;

    // At least one; count up the rest
    DWORD dwCount = 1;
    while( thisDevice.FindNextSaveGame( SaveGameData ) )
        ++dwCount;

    return dwCount;
}




//-----------------------------------------------------------------------------
// Name: GetSectorSize()
// Desc: Returns the sector size of the device in bytes
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetSectorSize() const
{
    return XGetDiskSectorSize( m_strRootPath );
}




//-----------------------------------------------------------------------------
// Name: GetClusterSize()
// Desc: Returns the cluster size of the device in bytes
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetClusterSize() const
{
    return XGetDiskClusterSize( m_strRootPath );
}




//-----------------------------------------------------------------------------
// Name: GetOverhead()
// Desc: Number of bytes used on device by XCreateSaveGame. Includes the
//       size of the save game directory and text meta data.
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetSaveGameOverhead() const
{
    // XCreateSaveGame() uses two clusters, one for the saved game directory,
    // and one for the saved game text meta data file.

    return( GetClusterSize() * 2 );
}




//-----------------------------------------------------------------------------
// Name: GetFileBytes()
// Desc: The total number of bytes a file will consume on the device.
//       Automatically pads to the cluster size of the device.
//-----------------------------------------------------------------------------
DWORD CXBStorageDevice::GetFileBytes( DWORD dwBytes ) const
{
    DWORD dwClusterSize = GetClusterSize();

    // Determine clusters required for this file
    DWORD dwClusters = ( dwBytes + ( dwClusterSize-1 ) ) / dwClusterSize;

    // Return total bytes
    return( dwClusters * dwClusterSize );
}




//-----------------------------------------------------------------------------
// Name: FindFirstSaveGame()
// Desc: Returns information about the first save game on the device. Returns
//       FALSE if no saves on the device.
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::FindFirstSaveGame( XGAME_FIND_DATA& SaveGameData ) const
{
    Cleanup();
    if( *m_strRootPath == 0 )
        return FALSE;

    m_hSaveGame = XFindFirstSaveGame( m_strRootPath, &SaveGameData );
    return( m_hSaveGame != INVALID_HANDLE_VALUE );
}




//-----------------------------------------------------------------------------
// Name: FindNextSaveGame()
// Desc: Returns information about the next save game on the device. Returns
//       FALSE if no more saves on the device.
//-----------------------------------------------------------------------------
BOOL CXBStorageDevice::FindNextSaveGame( XGAME_FIND_DATA& SaveGameData ) const
{
    return XFindNextSaveGame( m_hSaveGame, &SaveGameData );
}




//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Tear down the storage device
//-----------------------------------------------------------------------------
VOID CXBStorageDevice::Cleanup() const
{
    if( m_hSaveGame != INVALID_HANDLE_VALUE )
    {
        XFindClose( m_hSaveGame );
        m_hSaveGame = INVALID_HANDLE_VALUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XBStrip.cpp ===
//-----------------------------------------------------------------------------
// File: XBStrip.cpp
//
// Desc: Tristrip routines (which convert a mesh into a list of optimized
//       triangle strips).
//
// Hist: 02.01.01 - New for March XDK release
//       06.10.01 - Revised algorithm for better cache performance
//       02.14.01 - Fixed some memory leaks
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <stdarg.h>
#include <algorithm> // This is the STL header for the sort template

#include <assert.h>

#if defined(_XBOX)
#include <xtl.h>
#else
#include <limits.h>
#include <D3D8.h>
#endif

#include "XBStrip.h"




// Cache size to optimize for.  The actual cache size is 24, but it is in 
// general not good to use the oldest 6 entries.
#define CACHE_SIZE 18


// Estimated length of the vertex shader to use when comparing the cost of
// different stripifications.
#define SHADER_CYCLES 20




//-----------------------------------------------------------------------------
// structs
//-----------------------------------------------------------------------------
typedef WORD (*TRIANGLELIST)[3];


struct TRIANGLEINFO
{
    int neighbortri[3];     // Triangle sharing edge (i,i+1), or -1
    int neighboredge[3];    // Edge (j,j+1) of neighboring triangle.
};




//-----------------------------------------------------------------------------
// Name: struct CStrip
// Desc: A single triangle strip. After a mesh is stripified, it typically is 
//       composed of several of these.
//-----------------------------------------------------------------------------
struct CStrip
{
    BOOL  m_bIsStripCW;

    DWORD m_dwNumTriangles;
    int*  m_pTriangles;

    DWORD m_dwNumIndices;
    WORD* m_pIndices;

    DWORD m_dwNumNeighbors;

    CStrip( DWORD num_tris, DWORD num_indices ) 
    {
        m_dwNumTriangles = num_tris;
        m_pTriangles = new int[ num_tris ]; 

        m_dwNumIndices = num_indices;
        m_pIndices = new WORD[ num_indices ];
    }

    ~CStrip()
    {
        delete[] m_pTriangles;
        delete[] m_pIndices;
    }
};




//-----------------------------------------------------------------------------
// Name: struct CSubStrip
// Desc: A structure that specifies part of a strip in a striplist.
//-----------------------------------------------------------------------------
struct CSubStrip
{
    int m_iStrip;   // Index into striplist.
    int m_iStart;   // Starting triangle index
    int m_iEnd;     // Ending triangle index.
};




//-----------------------------------------------------------------------------
// Name: struct CStripList
// Desc: A list of triangle strips.
//-----------------------------------------------------------------------------
struct CStripList
{
    CStrip** m_pStrips;
    DWORD    m_dwNumStrips;

    CStrip** begin() { return (m_dwNumStrips) ? &m_pStrips[0] : NULL; }

    VOID RemoveStripFromList( CStrip** pStrip )
    {
        for( DWORD i=0; i<m_dwNumStrips; i++ )
        {
            if( &m_pStrips[i] == pStrip )
            {
                delete m_pStrips[i];
                m_dwNumStrips--;

                while( i < m_dwNumStrips )
                {
                    m_pStrips[i] = m_pStrips[i+1];
                    i++;
                }
                break;
            }
        }
    }
    
    VOID RemoveFirst()
    {
        RemoveStripFromList( &m_pStrips[0] );
    }

    VOID AddStripToList( CStrip* pStrip )
    {
        m_pStrips[m_dwNumStrips++] = pStrip;
    }

    CStripList(DWORD dwMaxSize)
    {
        m_pStrips     = new CStrip*[dwMaxSize];
        m_dwNumStrips = 0L;
    }

    ~CStripList()
    {
        for( DWORD i=0; i<m_dwNumStrips; i++ )
        {
            delete m_pStrips[i];
        }

        delete[] m_pStrips;
    }
};




//-----------------------------------------------------------------------------
// Class used to vertices for locality of access.
//-----------------------------------------------------------------------------
struct SortEntry
{
    int iFirstUsed;
    int iOrigIndex;

    // Define the < operator, which is needed for the STL sort() routine.
    BOOL operator<( const SortEntry& rhs ) { return iFirstUsed < rhs.iFirstUsed; }
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: vertex cache class
//-----------------------------------------------------------------------------
class CVertCache
{
public:
    CVertCache()    { Reset(); }
    ~CVertCache()   {};

    // Reset cache
    void Reset()
    {
        m_iCachePtr = 0;
        m_cachehits = 0;
        memset( m_rgCache, 0xff, sizeof(m_rgCache) );
    }

    // Add vertindex to cache
    int Add(int strip, int vertindex);

    // Check if a vert is in the cache.
    BOOL IsCached(int vertindex)
    {
        for( int iCache = 0; iCache < CACHE_SIZE; iCache++ )
        {
            if( vertindex == m_rgCache[iCache] )
            {
                // Item is in the cache
                return TRUE;
            }
        }

        return FALSE;
    }

    // Check if a vert uses one of the last two cached verts.
    BOOL IsOld(int vertindex)
    {
        if( vertindex == m_rgCache[m_iCachePtr] )
        {
            // Item is in the cache
            return TRUE;
        }

        return FALSE;
    }

    int NumCacheHits() const
    {
        return m_cachehits;
    }

private:
    int  m_cachehits;                // current # of cache hits
    WORD m_rgCache[CACHE_SIZE];      // vertex cache
    int  m_rgCacheStrip[CACHE_SIZE]; // strip # which added or re-used vert
    int  m_iCachePtr;                // fifo ptr
    bool m_bReUsed[CACHE_SIZE];      // true if vert was re-used.
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: main stripper class
//-----------------------------------------------------------------------------
class CStripper
{
public:
    int           m_dwNumTris;   // # tris
    TRIANGLELIST  m_pTriangles;  // trilist

    TRIANGLEINFO* m_pTriInfo;    // tri edge, neighbor info
    int*          m_pUsed;       // tri used flag

    // ctors/dtors
    CStripper( int dwNumtris, TRIANGLELIST pTriangles );
    ~CStripper();

    // initialize tri info
    VOID InitTriangleInfo( int tri, int vert );

    // get maximum length strip from tri/vert
    int CreateStrip( int tri, int vert, int maxlen, int *pswaps, 
                     BOOL bLookAhead, BOOL bNonSequential, BOOL bStartCW, 
                     int* pTris );

    // Turn a list of triangles into indices.
    int CreateIndices( BOOL bStartCW, int iNumTriangles, int* pTriangles, 
                       WORD* pStripVerts );

    // stripify entire mesh
    VOID BuildStrips( CStripList* pStripList, int maxlen, BOOL bLookAhead, 
                      BOOL bNonSequential, BOOL bSwapOrientation );

    // blast strip indices to ppstripindices
    int CreateManyStrips( CStripList *pstriplist, WORD **ppstripindices );
    int CreateLongStrip( CStripList *pstriplist, WORD **ppstripindices );
    int CreateCachedStrip( CStripList *pstriplist, WORD **ppstripindices );

    // find the best cached strip.
    CStrip** FindBestCachedStrip( CStripList* pStripList, const CVertCache &VertexCache );

    int GetNeighborCount( int tri )
    {
        int count = 0;
        for( int vert = 0; vert < 3; vert++ )
        {
            int neighbortri = m_pTriInfo[tri].neighbortri[vert];
            count += (neighbortri != -1) && !m_pUsed[neighbortri];
        }
        return count;
    }
};




//-----------------------------------------------------------------------------
// Name: CreateStrip()
// Desc: Get maximum length of strip starting at tri/vert
//-----------------------------------------------------------------------------
int CStripper::CreateStrip( int tri, int vert, int maxlen, int *pswaps,
                            BOOL bLookAhead, BOOL bNonSequential, 
                            BOOL bStartCW, int* pTris )
{
    *pswaps = 0;

    // this guy has already been used?
    if(m_pUsed[tri])
        return 0;

    // mark tri as used
    m_pUsed[tri] = 1;

    int swaps = 0;

    // add first tri
    int iNumTris = 0;
    pTris[iNumTris++] = tri;

	// toggle orientation
    bStartCW = !bStartCW;

    // get next tri information
    int edge     = (bStartCW ? vert + 2 : vert + 1) % 3;
    int nexttri  = m_pTriInfo[tri].neighbortri[edge];
    int nextvert = m_pTriInfo[tri].neighboredge[edge];

    // start building the strip until we run out of room or indices
    for(int stripcount = 3; stripcount < maxlen; stripcount++)
    {
        // dead end?
        if(nexttri == -1 || m_pUsed[nexttri])
            break;

        // move to next tri
        tri  = nexttri;
        vert = nextvert;

        // toggle orientation
        bStartCW = !bStartCW;

        // find the next natural edge
        edge = (bStartCW ? vert + 2 : vert + 1) % 3;
        nexttri  = m_pTriInfo[tri].neighbortri[edge];
        nextvert = m_pTriInfo[tri].neighboredge[edge];

        BOOL bSwap = FALSE;
        if(nexttri == -1 || m_pUsed[nexttri])
        {
            // if the next tri is a dead end - try swapping orientation
            bSwap = TRUE;
        }
        else if( bLookAhead )
        {
            // try a swap and see who our new neighbor would be
            int edgeswap     = (bStartCW ? vert + 1 : vert + 2) % 3;
            int nexttriswap  = m_pTriInfo[tri].neighbortri[edgeswap];
            int nextvertswap = m_pTriInfo[tri].neighboredge[edgeswap];

            if( nexttriswap != -1 && !m_pUsed[nexttriswap] )
            {
                // if the swap neighbor has a lower count, change directions
                if( GetNeighborCount(nexttriswap) < GetNeighborCount(nexttri) )
                {
                    bSwap = TRUE;
                }
                else if( GetNeighborCount(nexttriswap) == GetNeighborCount(nexttri) )
                {
                    // if they have the same number of neighbors - check their neighbors
                    edgeswap    = (bStartCW ? nextvertswap + 2 : nextvertswap + 1) % 3;
                    nexttriswap = m_pTriInfo[nexttriswap].neighbortri[edgeswap];

                    int edge1    = (bStartCW ? nextvert + 1 : nextvert + 2) % 3;
                    int nexttri1 = m_pTriInfo[nexttri].neighbortri[edge1];

                    if( nexttri1 == -1 || m_pUsed[nexttri1] )
                    {
                        // natural winding order leads us to a dead end so turn
                        bSwap = TRUE;
                    }
                    else if( nexttriswap != -1 && !m_pUsed[nexttriswap] )
                    {
                        // check neighbor counts on both directions and swap if it's better
                        if( GetNeighborCount(nexttriswap) < GetNeighborCount(nexttri1) )
                            bSwap = TRUE;
                    }
                }
            }
        }

        if( bSwap && bNonSequential )
        {
            // we've been told to change directions so make sure we actually can
            // and then add the swap vertex
            int edgeswap = (bStartCW ? vert + 1 : vert + 2) % 3;
            nexttri      = m_pTriInfo[tri].neighbortri[edgeswap];
            nextvert     = m_pTriInfo[tri].neighboredge[edgeswap];

            if( nexttri != -1 && !m_pUsed[nexttri] )
            {
                stripcount++;
                swaps++;
                bStartCW = !bStartCW;
            }
        }

        pTris[iNumTris++] = tri;

        // mark triangle as used
        m_pUsed[tri] = 1;
    }

    // clear the used flags
    for( int j = 0; j < iNumTris; j++ )
        m_pUsed[pTris[j]] = 0;

    // return swap count and striplen
    *pswaps = swaps;

    return iNumTris;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateIndices()
// Desc: Make strip indices from triangle list.
//-----------------------------------------------------------------------------
int CStripper::CreateIndices( BOOL bStartCW, int iNumTriangles, int* pTriangles, WORD* pStripVerts )
{
    int stripcount = 0;
    BOOL bCW = bStartCW;
    int in_edge = -1;

    for( int i = 0; i < iNumTriangles; i++ )
    {
        int out_edge;

        int tri = pTriangles[i];

        // get next tri information
        if( i < iNumTriangles-1 )
        {
            int nexttri = pTriangles[i+1];

            for( out_edge = 0; out_edge < 3; out_edge++ )
                if( m_pTriInfo[tri].neighbortri[out_edge] == nexttri )
                    break;
        }
        else
        {
            out_edge = (bCW ? (in_edge + 1) : (in_edge + 2)) % 3;
        }

        if( i == 0 )
        {
            if( bCW )
            {
                pStripVerts[0] = m_pTriangles[tri][(out_edge + 2) % 3];
                pStripVerts[1] = m_pTriangles[tri][(out_edge + 0) % 3];
                pStripVerts[2] = m_pTriangles[tri][(out_edge + 1) % 3];
            }
            else
            {
                pStripVerts[0] = m_pTriangles[tri][(out_edge + 2) % 3];
                pStripVerts[1] = m_pTriangles[tri][(out_edge + 1) % 3];
                pStripVerts[2] = m_pTriangles[tri][(out_edge + 0) % 3];
            }

            stripcount = 3;
        }
        else
        {
            if( out_edge == (bCW ? (in_edge + 1) : (in_edge + 2)) % 3 )
            {
                // In order.
                pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
            }
            else
            {
                // Swap.
                if( bCW )
                {
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 0) % 3];
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
                }
                else
                {
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 1) % 3];
                    pStripVerts[stripcount++] = m_pTriangles[tri][(in_edge + 2) % 3];
                }

                bCW = !bCW;
            }
        }

        in_edge = m_pTriInfo[tri].neighboredge[out_edge];
        bCW = !bCW;
    }

    return stripcount;
}




//-----------------------------------------------------------------------------
// Name: FindBestStrip()
// Desc: Given a striplist and current cache state, pick the best next strip
//-----------------------------------------------------------------------------
CStrip** FindBestStrip( CStripList* pStripList,
                              const CVertCache &VertexCache )
{
    if( 0 == pStripList->m_dwNumStrips ) 
        return NULL;

    CStrip** ppBestStrip       = pStripList->begin();
    DWORD    dwBestStripLen    = (*ppBestStrip)->m_dwNumIndices;
    BOOL     bStartCW          = (*ppBestStrip)->m_bIsStripCW;
    BOOL     bBestStripFlipped = FALSE;
    int      MaxCacheHits      = -1;

    // Go through all the other strips looking for the best caching
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip        = pStripList->m_pStrips[i];
        DWORD   dwStripLen    = pStrip->m_dwNumIndices;
        BOOL    bStripFlipped = FALSE;

        // Check cache if this strip is the same type as us (ie: cw/odd)
        if( ( pStrip->m_bIsStripCW == bStartCW) && ( (dwBestStripLen & 0x1) == (dwStripLen & 0x1) ) )
        {
            // Copy current state of cache
            CVertCache NewVertexCache = VertexCache;

            // Figure out what this guy would do to our cache
            for( DWORD ivert = 0; ivert < dwStripLen; ivert++ )
                NewVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

            // For even length strips - see if we can get better cache hits
            // if we reverse the vertex cache contents
            if( !(dwStripLen & 0x1) )
            {
                // Create a copy of the vertex cache, with all vertices flipped
                CVertCache FlippedVertexCache = VertexCache;
                for( int ivert = pStrip->m_dwNumIndices-1; ivert >= 0; ivert-- )
                    FlippedVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

                // Accept the flipped cache if it gives us more cahce hits
                if( FlippedVertexCache.NumCacheHits() > NewVertexCache.NumCacheHits() )
                {
                    NewVertexCache = FlippedVertexCache;
                    bStripFlipped  = TRUE;
                }
            }

            // Record the best number of cache hits to date
            int NumCacheHits = NewVertexCache.NumCacheHits() - VertexCache.NumCacheHits();
            
            if( NumCacheHits > MaxCacheHits )
            {
                MaxCacheHits      = NumCacheHits;
                ppBestStrip       = &pStripList->m_pStrips[i];
                dwBestStripLen    = dwStripLen;//? added by mikey
                bBestStripFlipped = bStripFlipped;
            }
        }
    }

    if( bBestStripFlipped )
    {
        CStrip* pStrip = *ppBestStrip;
        int first = 0;
        int last  = pStrip->m_dwNumIndices - 1;

        while( first < last )
        {
            // Swap vertex indices
            WORD temp                 = pStrip->m_pIndices[first];
            pStrip->m_pIndices[first] = pStrip->m_pIndices[last];
            pStrip->m_pIndices[last]  = temp;
            first++;
            last--;
        }
    }

    // Make sure we keep the list in order and always pull off
    // the first dude.
    if( ppBestStrip != pStripList->begin() )
    {
        // Swap strips
        CStrip* temp           = (*ppBestStrip);
        (*ppBestStrip)         = (*pStripList->begin());
        (*pStripList->begin()) = temp;
    }

    return pStripList->begin();
}




//-----------------------------------------------------------------------------
// Name: CStripper::FindBestCachedStrip()
// Desc: Given a striplist and current cache state, pick the best next strip
//-----------------------------------------------------------------------------
CStrip** CStripper::FindBestCachedStrip( CStripList* pStripList,
                                         const CVertCache &VertexCache )
{
    if( 0 == pStripList->m_dwNumStrips ) 
        return NULL;

    CStrip** ppBestStrip       = pStripList->begin();

    BOOL     bBestStripFlipped = FALSE;

    int      MaxCacheHits      = -1;

    DWORD    dwBestNeighborCount = (*ppBestStrip)->m_dwNumNeighbors;

    // Go through all the other strips looking for the best caching
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip        = pStripList->m_pStrips[i];
        DWORD   dwStripLen    = pStrip->m_dwNumIndices;
        BOOL    bStripFlipped = FALSE;

        // Copy current state of cache
        CVertCache NewVertexCache = VertexCache;

        // Figure out what this guy would do to our cache
        for( DWORD ivert = 0; ivert < dwStripLen; ivert++ )
            NewVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

        // See if we can get better cache hits if we reverse the order we draw
        // the strip in.
        {
            // Create a copy of the vertex cache, with all vertices flipped
            CVertCache FlippedVertexCache = VertexCache;
            for( int ivert = pStrip->m_dwNumIndices-1; ivert >= 0; ivert-- )
                FlippedVertexCache.Add( 2, pStrip->m_pIndices[ivert] );

            // Accept the flipped cache if it gives us more cahce hits
            if( FlippedVertexCache.NumCacheHits() > NewVertexCache.NumCacheHits() )
            {
                NewVertexCache = FlippedVertexCache;
                bStripFlipped  = TRUE;
            }
        }

        // Record the best number of cache hits to date
        int NumCacheHits = NewVertexCache.NumCacheHits() - VertexCache.NumCacheHits();
        
        if( NumCacheHits > MaxCacheHits )
        {
            MaxCacheHits        = NumCacheHits;
            ppBestStrip         = &pStripList->m_pStrips[i];
            bBestStripFlipped   = bStripFlipped;
            dwBestNeighborCount = pStripList->m_pStrips[i]->m_dwNumNeighbors;
        }
        else if ( NumCacheHits == MaxCacheHits && 
                  pStripList->m_pStrips[i]->m_dwNumNeighbors < dwBestNeighborCount )
        {
            ppBestStrip         = &pStripList->m_pStrips[i];
            bBestStripFlipped   = bStripFlipped;
            dwBestNeighborCount = pStripList->m_pStrips[i]->m_dwNumNeighbors;
        }
    }

    if( bBestStripFlipped )
    {
        CStrip* pStrip = *ppBestStrip;
        int first = 0;
        int last  = pStrip->m_dwNumIndices - 1;

        while( first < last )
        {
            // Swap vertex indices
            WORD temp                 = pStrip->m_pIndices[first];
            pStrip->m_pIndices[first] = pStrip->m_pIndices[last];
            pStrip->m_pIndices[last]  = temp;
            first++;
            last--;
        }

        // We must also reverse the starting winding for odd length strips.
        if( (pStrip->m_dwNumIndices & 0x1) )
        {
            pStrip->m_bIsStripCW = !pStrip->m_bIsStripCW;
        }
    }

    // Make sure we keep the list in order and always pull off
    // the first dude.
    if( ppBestStrip != pStripList->begin() )
    {
        // Swap strips
        CStrip* temp           = (*ppBestStrip);
        (*ppBestStrip)         = (*pStripList->begin());
        (*pStripList->begin()) = temp;
    }

    return pStripList->begin();
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateManyStrips()
// Desc: Don't merge the strips - just blast em into the stripbuffer one by one
//       (useful for debugging)
//-----------------------------------------------------------------------------
int CStripper::CreateManyStrips( CStripList* pStripList, WORD** ppStripIndices )
{
    // Count the number of indices. Allow room for each of the strips size
    // plus the final 0
    DWORD dwIndexCount = pStripList->m_dwNumStrips + 1;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( DWORD i = 0; i < pStripList->m_dwNumStrips; i++ )
    {
        // Add striplength plus potential degenerate to swap ccw --> cw
        dwIndexCount += pStripList->m_pStrips[i]->m_dwNumIndices + 1;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    DWORD      dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Loop through all strips
    CStrip** ppStrip = pStripList->begin();

    while( pStripList->m_dwNumStrips > 0 )
    {
        CStrip* pStrip = *ppStrip;

        if( !pStrip->m_bIsStripCW )
        {
            // add an extra index if it's ccw
            pStripIndices[dwNumStripIndices++] = (WORD)pStrip->m_dwNumIndices + 1;
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[0];
        }
        else
        {
            // add the strip length
            pStripIndices[dwNumStripIndices++] = (WORD)pStrip->m_dwNumIndices;
        }

        // add all the strip indices
        for( DWORD i = 0; i < pStrip->m_dwNumIndices; i++)
        {
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[i];
            VertexCache.Add( 1, pStrip->m_pIndices[i] );
        }

        // free this guy and pop him off the list
        pStripList->RemoveFirst();

        // Get the next best strip
        ppStrip = FindBestStrip( pStripList, VertexCache );
    }

    // add terminating zero
    pStripIndices[dwNumStripIndices++] = 0;
    (*ppStripIndices) = pStripIndices;

    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateLongStrip()
// Desc: Merge striplist into one big uberlist with (hopefully) optimal caching
//-----------------------------------------------------------------------------
int CStripper::CreateLongStrip( CStripList* pStripList, WORD** ppwStripIndices )
{
    // Allow room for one strip length plus a possible 3 extra indices per
    // concatenated strip list plus the final 0
    int dwIndexCount = (pStripList->m_dwNumStrips * 3) + 2;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( DWORD i=0; i < pStripList->m_dwNumStrips; i ++ )
    {
        dwIndexCount += pStripList->m_pStrips[i]->m_dwNumIndices;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    int        dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Add first strip
    CStrip** ppStrip = pStripList->begin();
    CStrip*  pStrip = *ppStrip;

    // Note: first strip should be cw

    for( DWORD ivert = 0; ivert < pStrip->m_dwNumIndices; ivert++ )
    {
        pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[ivert];
        VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
    }

    // Kill first dude
    pStripList->RemoveStripFromList( ppStrip );

    // Add all the others
    while( pStripList->m_dwNumStrips )
    {
        ppStrip = FindBestStrip( pStripList, VertexCache );
        pStrip = *ppStrip;
        WORD wLastVertex  = pStripIndices[dwNumStripIndices - 1];
        WORD wFirstVertex = pStrip->m_pIndices[0];

        if( wFirstVertex != wLastVertex )
        {
            // Add degenerate from last strip
            pStripIndices[dwNumStripIndices++] = wLastVertex;

            // Add degenerate from our strip
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // If we're not orientated correctly, we need to add a degenerate
        if( pStrip->m_bIsStripCW != !(dwNumStripIndices & 0x1) )
        {
            // This shouldn't happen - we're currently trying very hard
            // to keep everything oriented correctly.
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // Add these verts
        for( DWORD ivert = 0; ivert < pStrip->m_dwNumIndices; ivert++ )
        {
            pStripIndices[dwNumStripIndices++] = pStrip->m_pIndices[ivert];
            VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
        }

        // Free these guys
        pStripList->RemoveStripFromList( ppStrip );
    }

    (*ppwStripIndices) = pStripIndices;
    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::CreateCachedStrip()
// Desc: Merge striplist into one big uberlist with (hopefully) optimal caching
//-----------------------------------------------------------------------------
int CStripper::CreateCachedStrip( CStripList* pStripList, WORD** ppwStripIndices )
{
    DWORD i;
    WORD pTempVerts[CACHE_SIZE*4];

    // Split up the strips into cache friendly pieces.
    CStripList* pNewList = new CStripList(m_dwNumTris);

    while( pStripList->m_dwNumStrips )
    {
        CStrip** ppStrip = pStripList->begin();
        CStrip* pStrip = *ppStrip;

        int start = 0;
        int ssize = pStrip->m_dwNumTriangles;

        do
        {
            int dsize = ssize;

            if (dsize > CACHE_SIZE)
                dsize = CACHE_SIZE;

            int j = pNewList->m_dwNumStrips++;

            // Create temp triaingle list/index list.
            int num_indices = CreateIndices( pStrip->m_bIsStripCW, dsize, 
                                             pStrip->m_pTriangles + start, 
                                             pTempVerts );
    
            // Make new strip.
            pNewList->m_pStrips[j] = new CStrip( dsize, num_indices );

            pNewList->m_pStrips[j]->m_bIsStripCW = pStrip->m_bIsStripCW;

            // Copy triangles.
            memcpy( pNewList->m_pStrips[j]->m_pTriangles, 
                    pStrip->m_pTriangles + start, dsize * sizeof(int) );

            // Copy indices.
            memcpy( pNewList->m_pStrips[j]->m_pIndices, 
                    pTempVerts, num_indices * sizeof(WORD) );

            start += dsize;
            ssize -= dsize;
        }
        while (ssize > 0);

        pStripList->RemoveStripFromList( ppStrip );
    }

    // Count the number of adjacent triangles to each strip.
    // an edge of the mesh.
    for( i = 0; i < pNewList->m_dwNumStrips; i++ )
    {
        CStrip* pStrip = pNewList->m_pStrips[i];

        DWORD count = 0;

        for( DWORD j = 0; j < pStrip->m_dwNumTriangles; j++ )
        {
            // Count the number of neighbors.
            for( int vert = 0; vert < 3; vert++ )
            {
                if (m_pTriInfo[pStrip->m_pTriangles[j]].neighbortri[vert] != -1)
                    count++;
            }
        }

        pStrip->m_dwNumNeighbors = count;
    }

    // Should we remove/ignore very small strips?

    // Allow room for one strip length plus a possible 3 extra indices per
    // concatenated strip list plus the final 0
    int dwIndexCount = (pNewList->m_dwNumStrips * 3) + 2;

    // We're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for( i = 0; i < pNewList->m_dwNumStrips; i++ )
    {
        dwIndexCount += pNewList->m_pStrips[i]->m_dwNumIndices;
    }

    // Alloc the space for all this stuff
    WORD*      pStripIndices     = new WORD[dwIndexCount];
    DWORD      dwNumStripIndices = 0;
    CVertCache VertexCache;

    // Add the strips.
    while( pNewList->m_dwNumStrips )
    {
        CStrip** ppStrip = FindBestCachedStrip( pNewList, VertexCache );
        CStrip* pStrip = *ppStrip;

        WORD wFirstVertex = pStrip->m_pIndices[0];

        DWORD ivert = 0;

        if (dwNumStripIndices > 0)
        {
            WORD wLastVertex = pStripIndices[dwNumStripIndices - 1];
        
            assert( dwNumStripIndices > 2 );

            if( wLastVertex == pStrip->m_pIndices[1] &&
                pStripIndices[dwNumStripIndices - 2] == wFirstVertex &&
                pStrip->m_bIsStripCW == !(dwNumStripIndices & 0x1) )
            {
                // We are re-stitching strips together, so skip the first two
                // verts of this strip.
                ivert = 2;
            }
            else if( wFirstVertex != wLastVertex )
            {
                // Add degenerate from last strip
                pStripIndices[dwNumStripIndices++] = wLastVertex;

                // Add degenerate from our strip
                pStripIndices[dwNumStripIndices++] = wFirstVertex;
            }
        }

        // If we're not orientated correctly, we need to add a degenerate
        if( pStrip->m_bIsStripCW != !(dwNumStripIndices & 0x1) )
        {
            pStripIndices[dwNumStripIndices++] = wFirstVertex;
        }

        // Add these verts and update cache.
        while( ivert < pStrip->m_dwNumIndices )
        {
            pStripIndices[dwNumStripIndices] = pStrip->m_pIndices[ivert];
            VertexCache.Add( 1, pStrip->m_pIndices[ivert] );
            dwNumStripIndices++;
            ivert++;
        }

        // Free these guys
        pNewList->RemoveStripFromList( ppStrip );
    }

    delete pNewList;

    (*ppwStripIndices) = pStripIndices;
    return dwNumStripIndices;
}




//-----------------------------------------------------------------------------
// Name: CStripper::BuildStrips()
// Desc: Build a (hopefully) optimal set of strips from a trilist
//-----------------------------------------------------------------------------
void CStripper::BuildStrips( CStripList* pStripList, int maxlen, BOOL bLookAhead, 
                             BOOL bNonSequential, BOOL bSwapOrientation )
{
    // temp indices storage
    const int cNumTmpVerts = 1024;
    WORD pStripVerts[cNumTmpVerts + 1];
    int pStripTris[cNumTmpVerts + 1];

    // clear all the used flags for the tris
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );

    BOOL bStartCW = TRUE;

    while( TRUE )
    {
        int   besttri;
        int   bestvert;
        float bestratio = 2.0f;
        int   bestneighborcount = INT_MAX;

        for( int tri = 0; tri < m_dwNumTris; tri++)
        {
            // if used the continue
            if(m_pUsed[tri])
                continue;

            // get the neighbor count
            int curneighborcount = GetNeighborCount(tri);

            // push all the singletons to the very end
            if( !curneighborcount )
                curneighborcount = 4;

            // if this guy has more neighbors than the current best - bail
            if( curneighborcount > bestneighborcount )
                continue;

            // try starting the strip with each of this tris verts
            for( int vert = 0; vert < 3; vert++ )
            {
                int swaps;
                int num_tris = CreateStrip( tri, vert, maxlen, &swaps, bLookAhead, 
                                            bNonSequential, bStartCW, pStripTris );

                int len = 2 + num_tris + swaps;
                float ratio = (len == 3) ? 1.0f : (float)swaps / len;

                // check if this ratio is better than what we've already got for
                // this neighborcount
                if( (curneighborcount < bestneighborcount) ||
                    (curneighborcount == bestneighborcount && ratio < bestratio) )
                {
                    bestneighborcount = curneighborcount;
                    besttri = tri;
                    bestvert = vert;
                    bestratio = ratio;
                }

            }
        }

        // no strips found?
        if( bestneighborcount == INT_MAX )
            break;

        // recreate this strip
        int swaps;
        int num_tris = CreateStrip( besttri, bestvert, maxlen, &swaps, bLookAhead, 
                                    bNonSequential, bStartCW, pStripTris );

        // Mark the tris on the best strip as used
        for( tri = 0; tri < num_tris; tri++ )
            m_pUsed[pStripTris[tri]] = 1;

        // Make the indices from the triangle verts.
        int num_indices = CreateIndices( bStartCW, num_tris, pStripTris, pStripVerts );

        // Create a new CStrip and stuff in the list.
        CStrip* pStrip = new CStrip( num_tris, num_indices );

        pStrip->m_bIsStripCW = bStartCW;

        for( int j = 0; j < num_tris; j++ )
            pStrip->m_pTriangles[j] = pStripTris[j];

        for( int k = 0; k < num_indices; k++ )
            pStrip->m_pIndices[k] = pStripVerts[k];

        // Store the CStrip
        pStripList->AddStripToList( pStrip );

        if( bSwapOrientation )
        {
            // if strip was odd - swap orientation
            if( (num_indices & 0x1) )
              bStartCW = !bStartCW;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: CStripper::InitTriangleInfo()
// Desc: Initialize triangle information (edges, #neighbors, etc.)
//-----------------------------------------------------------------------------
void CStripper::InitTriangleInfo(int tri, int vert)
{
    WORD* ptriverts = &m_pTriangles[tri + 1][0];
    int   vert1     =  m_pTriangles[tri][(vert + 1) % 3];
    int   vert2     =  m_pTriangles[tri][vert];

    for( int itri = tri + 1; itri < m_dwNumTris; itri++, ptriverts += 3 )
    {
        if( m_pUsed[itri] != 0x7 )
        {
            for( int ivert = 0; ivert < 3; ivert++ )
            {
                if( ( ptriverts[ivert] == vert1) &&
                    ( ptriverts[(ivert + 1) % 3] == vert2 ) )
                {
                    // add the triangle info
                    m_pTriInfo[tri].neighbortri[vert]  = itri;
                    m_pTriInfo[tri].neighboredge[vert] = ivert;
                    m_pUsed[tri] |= (1 << vert);

                    m_pTriInfo[itri].neighbortri[ivert]  = tri;
                    m_pTriInfo[itri].neighboredge[ivert] = vert;
                    m_pUsed[itri] |= (1 << ivert);
                    return;
                }
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: CStripper()
// Desc: CStripper ctor
//-----------------------------------------------------------------------------
CStripper::CStripper( int dwNumTris, TRIANGLELIST pTriangles )
{
    // store trilist info
    m_dwNumTris  = dwNumTris;
    m_pTriangles = pTriangles;
    m_pUsed      = new int[dwNumTris];
    m_pTriInfo   = new TRIANGLEINFO[dwNumTris];

    // init triinfo
    for( int itri = 0; itri < dwNumTris; itri++ )
    {
        m_pTriInfo[itri].neighbortri[0] = -1;
        m_pTriInfo[itri].neighbortri[1] = -1;
        m_pTriInfo[itri].neighbortri[2] = -1;
    }

    // Clear the used flag
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );

    // Go through all the triangles and find edges, neighbor counts
    for( itri = 0; itri < dwNumTris; itri++ )
    {
        for( int ivert = 0; ivert < 3; ivert++ )
        {
            if( !(m_pUsed[itri] & (1 << ivert)) )
                InitTriangleInfo( itri, ivert );
        }
    }

    // Clear the used flags from InitTriangleInfo
    ZeroMemory( m_pUsed, m_dwNumTris * sizeof(m_pUsed[0]) );
}




//-----------------------------------------------------------------------------
// Name: ~CStripper
// Desc: CStripper dtor
//-----------------------------------------------------------------------------
CStripper::~CStripper()
{
    // free stuff
    delete[] m_pUsed;
    m_pUsed = NULL;

    delete[] m_pTriInfo;
    m_pTriInfo = NULL;
}




//-----------------------------------------------------------------------------
// Name: CVertCache::Add()
// Desc: Add an index to the cache - returns true if it was added, false otherwise
//-----------------------------------------------------------------------------
int CVertCache::Add( int strip, int vertindex )
{
    // Find index in cache
    for( int iCache = 0; iCache < CACHE_SIZE; iCache++ )
    {
        if( vertindex == m_rgCache[iCache] )
        {
            // If it's in the cache and it's from a different strip
            // change the strip to the new one and count the cache hit
            if( strip != m_rgCacheStrip[iCache] )
            {
                m_cachehits++;
                m_rgCacheStrip[iCache] = strip;
                m_bReUsed[iCache] = true;
            }

            // Item is already in the cache, so no need to add it
            return 0;
        }
    }

    int retval = 1;

    // If we are push one of the verts add by our strip out of the cache, return two.
    if ( m_rgCache[m_iCachePtr] != -1 && m_rgCacheStrip[m_iCachePtr] == strip && 
         !m_bReUsed[m_iCachePtr] )
        retval = 2;

    // Not in cache, add vert and strip
    m_rgCache[m_iCachePtr]      = (WORD)vertindex;
    m_rgCacheStrip[m_iCachePtr] = strip;
    m_bReUsed[m_iCachePtr]      = false;
    m_iCachePtr                 = (m_iCachePtr + 1) % CACHE_SIZE;
    
    return retval;
}




//-----------------------------------------------------------------------------
// Name: CountCacheMisses()
// Desc: Count the number of cache misses for a given strip.
//-----------------------------------------------------------------------------
DWORD CountCacheMisses( DWORD dwIndexCount, WORD *pStripIndices )
{
    CVertCache VertexCache;

    DWORD dwMisses = 0;

    for ( DWORD i = 0; i < dwIndexCount; i++ )
        dwMisses += (VertexCache.Add( 1, pStripIndices[i] ) != 0);

    return dwMisses;
}




//-----------------------------------------------------------------------------
// Name: TriStripToTriList()
// Desc: Convert a tri-strip to a tri-list.
//-----------------------------------------------------------------------------
DWORD TriStripToTriList( DWORD dwNumStripIndices, const WORD *pStripIndices, 
                         WORD *pTriangleIndices )
{
    DWORD dwNumTriangleIndices = 0;
        
    // Unstrip the indices.
    WORD ind0 = 0;
    WORD ind1 = pStripIndices[0];
    WORD ind2 = pStripIndices[1];

    for( DWORD src = 2; src < dwNumStripIndices; src++ )
    {
        ind0 = ind1;
        ind1 = ind2;
        ind2 = pStripIndices[src];
    
        // Check for null-triangles.    
        if( ind0 != ind1 && ind1 != ind2 && ind2 != ind0 )
        {
            if( src & 1 )
            {
                pTriangleIndices[dwNumTriangleIndices] = ind1;
                dwNumTriangleIndices++;

                pTriangleIndices[dwNumTriangleIndices] = ind0;
                dwNumTriangleIndices++;

                // always put the new index last
                pTriangleIndices[dwNumTriangleIndices] = ind2;
                dwNumTriangleIndices++;
            }
            else
            {
                pTriangleIndices[dwNumTriangleIndices] = ind0;
                dwNumTriangleIndices++;

                pTriangleIndices[dwNumTriangleIndices] = ind1;
                dwNumTriangleIndices++;

                // always put the new index last
                pTriangleIndices[dwNumTriangleIndices] = ind2;
                dwNumTriangleIndices++;
            }
        }
    }

    return dwNumTriangleIndices;
}




//-----------------------------------------------------------------------------
// Name: Stripify()
// Desc: Stripify routine
//-----------------------------------------------------------------------------
DWORD Stripify( DWORD dwNumTriangles, WORD* pTriangles, 
                DWORD* pdwNumIndices, WORD** ppStripIndices, DWORD dwFlags )
{
    if( 0 == dwNumTriangles || NULL == pTriangles )
        return 0;

    *ppStripIndices = 0;

    // The stipper, and storage for it's best results
    CStripper   stripper( dwNumTriangles, (TRIANGLELIST)pTriangles );

    DWORD       dwBestCost = 0xffffffff;
    DWORD       dwBestIndexCount = 0;
    WORD*       pTempStripIndices;

    // Map of various args to try stripifying mesh with
    struct ARGMAP
    {
        DWORD   dwMaxLength;    // Maximum length of strips
        BOOL    bLookAhead;     // Whether to use sgi greedy lookahead
        BOOL    bNonSequential; // Take non-sequential exits to lengthen strips.
    };
    
    ARGMAP argmap[] =
    {
        { 1024,  TRUE, TRUE  },
        { 1024,  FALSE, TRUE },
        { 1024,  FALSE, FALSE },
    };
    const int dwNumArgMaps = sizeof(argmap)/sizeof(ARGMAP);

    // Build strips with the various maxlength and lookahead arguments, and
    // pick the one with the least result index count.
    for( int map = 0; map < dwNumArgMaps; map++ )
    {
        // Build the strip with the various maxlength and lookahead arguments
        CStripList* pStripList = new CStripList(dwNumTriangles);

        stripper.BuildStrips( pStripList, argmap[map].dwMaxLength, 
                              argmap[map].bLookAhead, argmap[map].bNonSequential,
                              (dwFlags & OPTIMIZE_FOR_INDICES) != 0 );

        DWORD dwIndexCount;
        DWORD dwCost;

        // Build strip (freeing the strip list).
        if( dwFlags & OPTIMIZE_FOR_INDICES )
        {
            dwIndexCount = stripper.CreateLongStrip( pStripList, &pTempStripIndices );

            // Cost is just the number of indices.
            dwCost = dwIndexCount;
        }
        else
        {
            dwIndexCount = stripper.CreateCachedStrip( pStripList, &pTempStripIndices );

            // Count number of cache misses.
            DWORD dwMisses = CountCacheMisses( dwIndexCount, pTempStripIndices );

            if( dwFlags & OUTPUT_TRILIST )
            {
                // Nulls don't matter for tri-lists.
                dwCost = dwMisses;
            }
            else
            {
                // Cost is the (shader length) / 2 + (# null tris) * 2
                dwCost = dwMisses * (SHADER_CYCLES/2) + 
                         (dwIndexCount - (dwNumTriangles + 2)) * 2;
            }
        }

        if ( dwCost < dwBestCost )
        {
            // Free the old best list
            if( *ppStripIndices )
                delete[] *ppStripIndices;

            // store the new best list
            *ppStripIndices  = pTempStripIndices;
            dwBestCost       = dwCost;
            dwBestIndexCount = dwIndexCount;
        }
        else
        {
            delete[] pTempStripIndices;
        }

        delete pStripList;
    }

    if( dwFlags & OUTPUT_TRILIST )
    {
        // Convert to triangle list.
        WORD* pTempIndices = new WORD[dwNumTriangles*3];

        dwBestIndexCount = TriStripToTriList( dwBestIndexCount, *ppStripIndices, 
                                              pTempIndices );

        assert( dwBestIndexCount <= dwNumTriangles*3 );

        delete[] *ppStripIndices;
        *ppStripIndices = pTempIndices;
    }

    if( pdwNumIndices )
        (*pdwNumIndices) = dwBestIndexCount;
    
    return dwBestIndexCount;
}




//-----------------------------------------------------------------------------
// Name: ComputeVertexPermutation()
// Desc: Reorder the vertices
//-----------------------------------------------------------------------------
VOID ComputeVertexPermutation( DWORD dwNumStripIndices, WORD* pStripIndices,
                               DWORD dwNumVertices, WORD** ppVertexPermutation )
{
    // Sort verts to maximize locality.
    SortEntry* pSortTable = new SortEntry[dwNumVertices];

    // Fill in original index.
    for( DWORD i = 0; i < dwNumVertices; i++ )
    {
        pSortTable[i].iOrigIndex = i;
        pSortTable[i].iFirstUsed = -1;
    }

    // Fill in first used flag.
    for( i = 0; i < dwNumStripIndices; i++ )
    {
        int index = pStripIndices[i];

        if( pSortTable[index].iFirstUsed == -1 )
            pSortTable[index].iFirstUsed = i;
    }

    // Sort the table, using the STL sort() routine.
    std::sort( pSortTable, pSortTable + dwNumVertices );

    // Copy re-mapped to orignal vertex permutaion into output array.
    (*ppVertexPermutation) = new WORD[dwNumVertices];

    for( i = 0; i < dwNumVertices; i++ )
    {
        (*ppVertexPermutation)[i] = (WORD)pSortTable[i].iOrigIndex;
    }

    // Build original to re-mapped permutation.
    WORD* pInversePermutation = new WORD[dwNumVertices];

    for( i = 0; i < dwNumVertices; i++ )
    {
        pInversePermutation[pSortTable[i].iOrigIndex] = (WORD)i;
    }

    // We need to remap indices as well.
    for( i = 0; i < dwNumStripIndices; i++ )
    {
        pStripIndices[i] = pInversePermutation[ pStripIndices[i] ];
    }

    delete[] pSortTable;
    delete[] pInversePermutation;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbSavedGame.cpp ===
//-----------------------------------------------------------------------------
// File: XbSavedGame.cpp
//
// Desc: Saved game container
//
// Hist: 02.05.01 - New for March XDK release
//       03.14.01 - Access image.xbx for game image (April XDK)
//       04.13.01 - GetSize() accounts for directory and cluster overhead
//       05.01.01 - Image.xbx changed to SaveImage.xbx to match specs/docs
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XbSavedGame.h"
#include "Xbapp.h"
#include "Xbutil.h"
#include <xgraphics.h>
#include <cassert>




//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
const CHAR* const strUSER_REGION_HD = "U:\\";
const CHAR* const strGAME_IMAGE = "SaveImage.xbx";
const DWORD IMAGE_HDR_SIZE = 2048;             // 2K
const DWORD IMAGE_WH = 64;                     // width and height
const DWORD IMAGE_DATA_SIZE = (IMAGE_WH * IMAGE_WH) / 2; // DXT1 is 4 bits per pixel
const DWORD BLOCK_SIZE = 16 * 1024; // TCR 3-11 Space Display
                                    




//-----------------------------------------------------------------------------
// Layout of SaveImage.xbx saved game image file
//-----------------------------------------------------------------------------
//
// File is XPR0 format. Since the XPR will always contain only a single
// 256x256 DXT1 image, we know exactly what the header portion will look like

struct XprImageHeader
{
    XPR_HEADER        xpr;           // Standard XPR struct
    IDirect3DTexture8 txt;           // Standard D3D texture struct
    DWORD             dwEndOfHeader; // 0xFFFFFFFF
};

struct XprImage
{
    XprImageHeader hdr;
    CHAR           strPad[ IMAGE_HDR_SIZE - sizeof( XprImageHeader ) ];
    BYTE           pBits[ IMAGE_DATA_SIZE ];     // data bits
};




//-----------------------------------------------------------------------------
// Helper class to wrap FindFirstFile HANDLE
//-----------------------------------------------------------------------------
class FindHandle
{

    HANDLE m_hFind;

public:

    explicit FindHandle( HANDLE h = NULL )
    : 
        m_hFind( h )
    {
    }

    ~FindHandle()
    {
        if( m_hFind != INVALID_HANDLE_VALUE )
            FindClose( m_hFind );
    }

    operator HANDLE() const
    {
        return m_hFind;
    }

};




//-----------------------------------------------------------------------------
// Name: CXBSavedGame()
// Desc: Construct empty saved game
//-----------------------------------------------------------------------------
CXBSavedGame::CXBSavedGame()
:
    m_strName(),
    m_strDir(),
    m_dwSize( DWORD(-1) ),
    m_pImage( NULL ),
    m_bIsValidImage( TRUE ),
    m_qwLastWriteTime( ULONGLONG(0) )
{
    Init();
}




//-----------------------------------------------------------------------------
// Name: CXBSavedGame()
// Desc: Construct from other save
//-----------------------------------------------------------------------------
CXBSavedGame::CXBSavedGame( const CXBSavedGame& rhs )
:
    m_strName        (),
    m_strDir         (),
    m_dwSize         ( rhs.m_dwSize ),
    m_pImage         ( NULL ),
    m_bIsValidImage  ( rhs.m_bIsValidImage ),
    m_qwLastWriteTime( rhs.m_qwLastWriteTime )
{
    lstrcpyW( m_strName, rhs.m_strName );
    lstrcpyA( m_strDir,  rhs.m_strDir );
    if( rhs.m_pImage != NULL )
    {
        m_pImage = rhs.m_pImage;
        m_pImage->AddRef();
    }
}




//-----------------------------------------------------------------------------
// Name: operator =()
// Desc: Copy from other save
//-----------------------------------------------------------------------------
CXBSavedGame& CXBSavedGame::operator =( const CXBSavedGame& rhs )
{
    lstrcpyW( m_strName, rhs.m_strName );
    lstrcpyA( m_strDir,  rhs.m_strDir );

    m_dwSize          = rhs.m_dwSize;
    m_bIsValidImage   = rhs.m_bIsValidImage;
    m_qwLastWriteTime = rhs.m_qwLastWriteTime;

    SAFE_RELEASE( m_pImage );

    if( rhs.m_pImage != NULL )
    {
        m_pImage = rhs.m_pImage;
        m_pImage->AddRef();
    }
    return *this;
}




//-----------------------------------------------------------------------------
// Name: ~CXBSavedGame()
// Desc: Tear down save game
//-----------------------------------------------------------------------------
CXBSavedGame::~CXBSavedGame()
{
    SAFE_RELEASE( m_pImage );
}




//-----------------------------------------------------------------------------
// Name: CXBSavedGame()
// Desc: Construct saved game from XGAME_FIND_DATA (see XFindFirstSaveGame())
//-----------------------------------------------------------------------------
CXBSavedGame::CXBSavedGame( const XGAME_FIND_DATA& XFindData )
:
    m_strName(),
    m_strDir(),
    m_dwSize( DWORD(-1) ),
    m_pImage( NULL ),
    m_bIsValidImage( TRUE ),
    m_ftLastWriteTime( XFindData.wfd.ftLastWriteTime )
{
    lstrcpynW( m_strName, XFindData.szSaveGameName, MAX_GAMENAME );
    lstrcpynA( m_strDir, XFindData.szSaveGameDirectory, MAX_PATH );
}




//-----------------------------------------------------------------------------
// Name: CXBSavedGame()
// Desc: Construct saved game
//-----------------------------------------------------------------------------
CXBSavedGame::CXBSavedGame( const WCHAR* strSaveGameName, 
                            const CHAR* strSaveGameDir )
:
    m_strName(),
    m_strDir(),
    m_dwSize( DWORD(-1) ),
    m_pImage( NULL ),
    m_bIsValidImage( TRUE ),
    m_qwLastWriteTime( ULONGLONG(0) )
{
    assert( strSaveGameName != NULL );
    assert( strSaveGameDir != NULL );
    lstrcpynW( m_strName, strSaveGameName, MAX_GAMENAME );
    lstrcpynA( m_strDir, strSaveGameDir, MAX_PATH );
}




//-----------------------------------------------------------------------------
// Name: CreateGame()
// Desc: TRUE if game container successfully created on the device
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::CreateGame( CHAR chDestDrive, const WCHAR* strSaveGameName )
{
    return OpenGame( chDestDrive, strSaveGameName, CREATE_NEW );
}




//-----------------------------------------------------------------------------
// Name: OpenGame()
// Desc: TRUE if game container exists on the device
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::OpenGame( CHAR chDestDrive, const WCHAR* strSaveGameName,
                             DWORD dwOpenDisposition )
{
    assert( strSaveGameName != NULL );
    Init();

    CHAR strRootPath[4] = "x:\\";
    *strRootPath = chDestDrive;

    // TCR 3-7 Saved Game Management
    DWORD dwSuccess = XCreateSaveGame( strRootPath, strSaveGameName, 
                                       dwOpenDisposition, 0, m_strDir, 
                                       MAX_PATH );
    if( dwSuccess != ERROR_SUCCESS )
        return FALSE;

    lstrcpynW( m_strName, strSaveGameName, MAX_GAMENAME );
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: DeleteGame()
// Desc: TRUE if game container exists and successfully deleted
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::DeleteGame()
{
    assert( !IsEmpty() );
    CHAR strRootPath[4] = "x:\\";
    *strRootPath = GetDrive();

    // TCR 3-7 Saved Game Management
    DWORD dwSuccess = XDeleteSaveGame( strRootPath, m_strName );
    Init();
    return( dwSuccess == ERROR_SUCCESS );
}




//-----------------------------------------------------------------------------
// Name: IsEmpty()
// Desc: TRUE if object doesn't represent an actual saved game
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::IsEmpty() const
{
    return( *m_strName == 0 );
}




//-----------------------------------------------------------------------------
// Name: GetDrive()
// Desc: Saved game drive
//-----------------------------------------------------------------------------
CHAR CXBSavedGame::GetDrive() const
{
    return *m_strDir;
}




//-----------------------------------------------------------------------------
// Name: GetSize()
// Desc: Number of bytes used by save game container and data.
//       The value returned is cluster based, so it includes the total number
//       of bytes allocated by the device, and is always evenly divisible by
//       the cluster size of the device.
//-----------------------------------------------------------------------------
DWORD CXBSavedGame::GetSize() const
{
    if( IsEmpty() )
        return 0;

    // Cache the save game container size if we don't have it already
    if( m_dwSize == DWORD(-1) )
    {
        CHAR strRootPath[4] = "x:\\";
        *strRootPath = GetDrive();

        DWORD dwBlocks = XGetDisplayBlocks( m_strDir );
        m_dwSize = dwBlocks * BLOCK_SIZE;
    }

    return m_dwSize;
}




//-----------------------------------------------------------------------------
// Name: GetLastWriteTime()
// Desc: Time/date when saved game container folder was last written
//-----------------------------------------------------------------------------
FILETIME CXBSavedGame::GetLastWriteTime() const
{
    if( IsEmpty() )
        return FILETIME();

    // Cache the last write time if we don't have it already
    if( m_qwLastWriteTime == ULONGLONG(0) )
    {
        // FindFirstFile() doesn't want trailing backslash
        CHAR strSaveGameDir[ MAX_PATH ];
        lstrcpynA( strSaveGameDir, m_strDir, lstrlenA( m_strDir ) );

        // Get folder last write time
        WIN32_FIND_DATA FolderData;
        FindHandle hFolder( FindFirstFile( strSaveGameDir, &FolderData ) );
        if( hFolder != INVALID_HANDLE_VALUE )
        {
            m_ftLastWriteTime.dwHighDateTime = FolderData.ftLastWriteTime.dwHighDateTime;
            m_ftLastWriteTime.dwLowDateTime = FolderData.ftLastWriteTime.dwLowDateTime;
        }
    }
    return m_ftLastWriteTime;
}




//-----------------------------------------------------------------------------
// Name: GetLastWriteQword()
// Desc: Last write info as ULONGLONG
//-----------------------------------------------------------------------------
ULONGLONG CXBSavedGame::GetLastWriteQword() const
{
    FILETIME ftLastWriteTime = GetLastWriteTime();
    return( *(ULONGLONG*)( &ftLastWriteTime ) );
}




//-----------------------------------------------------------------------------
// Name: GetName()
// Desc: Saved game name
//-----------------------------------------------------------------------------
const WCHAR* CXBSavedGame::GetName() const
{
    return m_strName;
}




//-----------------------------------------------------------------------------
// Name: GetDirectory()
// Desc: Saved game container folder
//-----------------------------------------------------------------------------
const CHAR* CXBSavedGame::GetDirectory() const
{
    return m_strDir;
}




//-----------------------------------------------------------------------------
// Name: GetImage()
// Desc: Returns pointer to texture for game image. Caller is responsible for
//       calling Release() on the pointer.
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::GetImage( LPDIRECT3DTEXTURE8* ppImage ) const
{
    if( IsEmpty() )
        return FALSE;

    // If we already have the image cached, just update the ref count
    if( m_pImage != NULL )
    {
        m_pImage->AddRef();
        *ppImage = m_pImage;
        return TRUE;
    }

    // If we already failed to load the image, bail out
    if( !m_bIsValidImage )
        return FALSE;

    // We don't have the image yet

    // See if the image file for this saved game exists
    CHAR strFile[ MAX_PATH ];
    lstrcpyA( strFile, m_strDir );
    lstrcatA( strFile, strGAME_IMAGE );
    HANDLE hFile = CreateFile( strFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                               0, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        // TCR 2-14a Saved Game Representative Image
        // No specific image found; see if the default save image exists
        // (always on root of user data region on hard disk)
        lstrcpyA( strFile, strUSER_REGION_HD );
        lstrcatA( strFile, strGAME_IMAGE );
        hFile = CreateFile( strFile, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                            0, NULL );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            m_bIsValidImage = FALSE;
            return FALSE;
        }
    }

    // Read the image header from disk
    XprImageHeader XprHeader;
    DWORD dwBytesRead;
    BOOL bSuccess = ReadFile( hFile, &XprHeader, sizeof( XprImageHeader ),
                              &dwBytesRead, NULL );

    // Validate the image
    bSuccess &= dwBytesRead == sizeof( XprImageHeader ) &&
                XprHeader.xpr.dwMagic == XPR_MAGIC_VALUE &&
                XprHeader.xpr.dwTotalSize == IMAGE_HDR_SIZE + IMAGE_DATA_SIZE &&
                XprHeader.xpr.dwHeaderSize == IMAGE_HDR_SIZE &&
                XprHeader.dwEndOfHeader == 0xFFFFFFFF;

    // If image looks good, store the bits in a texture
    if( bSuccess )
    {
        HRESULT hr = g_pd3dDevice->CreateTexture( IMAGE_WH, IMAGE_WH, 
                                                  1, 0, D3DFMT_DXT1,
                                                  D3DPOOL(), &m_pImage );
        bSuccess = SUCCEEDED(hr);
        if( bSuccess )
        {
            D3DLOCKED_RECT lr;
            m_pImage->LockRect( 0, &lr, NULL, D3DLOCK_READONLY );

            // Copy the bits from the file to the texture
            SetFilePointer( hFile, IMAGE_HDR_SIZE, NULL, FILE_BEGIN );
            bSuccess = ReadFile( hFile, lr.pBits, IMAGE_DATA_SIZE, 
                                 &dwBytesRead, NULL );
            bSuccess &= ( dwBytesRead == IMAGE_DATA_SIZE );
            m_pImage->UnlockRect( 0 );

            if( bSuccess )
            {
                m_pImage->AddRef();
                *ppImage = m_pImage;
            }
        }
    }
    else
    {
        m_bIsValidImage = FALSE;
    }

    CloseHandle( hFile );
    return( bSuccess );
}




//-----------------------------------------------------------------------------
// Name: SaveImage()
// Desc: Generates a meta data image file for the save game. Overwrites
//       any existing image. Automatically converts the incoming texture
//       to the proper meta data image format.
//-----------------------------------------------------------------------------
BOOL CXBSavedGame::SaveImage( const LPDIRECT3DTEXTURE8 pSrcTexture )
{
    if( IsEmpty() || pSrcTexture == NULL )
        return FALSE;

    // Determine size of incoming texture
    D3DSURFACE_DESC SrcDesc;
    HRESULT hr = pSrcTexture->GetLevelDesc( 0, &SrcDesc );
    if( FAILED(hr) )
        return FALSE;

    // Generate a 64x64 DXT1 surface
    LPDIRECT3DSURFACE8 pDxt1GameImageSurface = NULL;
    hr = g_pd3dDevice->CreateImageSurface( IMAGE_WH, IMAGE_WH, D3DFMT_DXT1,
                                           &pDxt1GameImageSurface );
    if( FAILED(hr) )
        return FALSE;

    // Copy the source into the DXT1 surface
    LPDIRECT3DSURFACE8 pSrcSurface = NULL;
    hr = pSrcTexture->GetSurfaceLevel( 0, &pSrcSurface );
    hr = D3DXLoadSurfaceFromSurface( pDxt1GameImageSurface, NULL, NULL, 
                                     pSrcSurface, NULL, NULL,
                                     D3DX_DEFAULT, D3DCOLOR( 0 ) );
    SAFE_RELEASE( pSrcSurface );
    if( FAILED(hr) )
    {
        SAFE_RELEASE( pDxt1GameImageSurface );
        return FALSE;
    }

    // Generate the save game image name
    CHAR strMetaDataFile[ MAX_PATH ];
    lstrcpyA( strMetaDataFile, m_strDir );
    lstrcatA( strMetaDataFile, strGAME_IMAGE );

    // Write the compressed texture out to an .XPR file
    hr = XGWriteSurfaceOrTextureToXPR( pDxt1GameImageSurface, strMetaDataFile, TRUE );

    SAFE_RELEASE( pDxt1GameImageSurface );

    if( FAILED(hr) )
        return FALSE;

    m_bIsValidImage = TRUE;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Clear saved game data
//-----------------------------------------------------------------------------
VOID CXBSavedGame::Init()
{
    *m_strName = 0;
    *m_strDir = 0;
    m_qwLastWriteTime = ULONGLONG(0);
    m_dwSize = DWORD(-1);
    SAFE_RELEASE( m_pImage );
    m_bIsValidImage = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\XbVoice.cpp ===
//-----------------------------------------------------------------------------
// File: XbVoice.cpp
//
// Desc: Shortcut macros and helper functions for the Xbox voice samples
//       Requires linking with XVOICE[D].LIB
//
// Hist: 10.21.01 - New for November XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBVoice.h"




//-----------------------------------------------------------------------------
// Name: XBVoice_HasDevice()
// Desc: TRUE if an Xbox Communicator is currently available
//-----------------------------------------------------------------------------
BOOL XBVoice_HasDevice()
{
    DWORD dwConnectedMicrophones = XGetDevices( XDEVICE_TYPE_VOICE_MICROPHONE );
    DWORD dwConnectedHeadphones = XGetDevices( XDEVICE_TYPE_VOICE_HEADPHONE );

    // Voice is available if there's at least one mike and one headphone
    return( dwConnectedMicrophones >= 1 &&
            dwConnectedHeadphones  >= 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xdpvoice.cpp ===
//-----------------------------------------------------------------------------
// File: xdpvoice.cpp
//
// Desc: DVoice common routines
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <string.h>

#include "xdppeer.h"
#include "xdpvoice.h"


//-----------------------------------------------------------------------------
// client and server objects
//-----------------------------------------------------------------------------
IDirectPlayVoiceServer *g_pDVServer;				// server object
IDirectPlayVoiceClient *g_pDVClient;				// client object


//-----------------------------------------------------------------------------
// message handlers
//-----------------------------------------------------------------------------
HRESULT (WINAPI *g_AppDVMsgHandler)(void *, DWORD, void *); // app message handler
HRESULT __stdcall XDVMsgHandler(LPVOID *, DWORD, LPVOID *);	// our message handler


//-----------------------------------------------------------------------------
// voice peripheral stuff
//-----------------------------------------------------------------------------
DWORD XDVFindHawk();								// searches for hawk peripherals
DWORD g_dwHawkPort;									// port hawk is in


//-----------------------------------------------------------------------------
// voice targets
//-----------------------------------------------------------------------------
DVID g_dvidTargets[MAX_TARGETS];					// transmit target array
DWORD g_dwNumTargets;								// # of targets in array


//-----------------------------------------------------------------------------
// Name: XDVInit
// Desc: Initialize Voice subsystem and other relevant stuff.
//-----------------------------------------------------------------------------
HRESULT XDVInit(LONG (WINAPI *DVMsgHandler)(void *, DWORD, void *))
{
	HRESULT hr;

	// Save message handler pointer
	g_AppDVMsgHandler = DVMsgHandler;

	// create server object
	hr = XDirectPlayVoiceCreate(IID_IDirectPlayVoiceServer, (LPVOID *)&g_pDVServer);
	assert(SUCCEEDED(hr));

	// create client object
	hr = XDirectPlayVoiceCreate(IID_IDirectPlayVoiceClient, (LPVOID *)&g_pDVClient);
	assert(SUCCEEDED(hr));

	// find hawk port
	g_dwHawkPort = XDVFindHawk();

	// init target array
	g_dwNumTargets = 0;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVDoWork
// Desc: Does DVoice work.
//-----------------------------------------------------------------------------
HRESULT XDVDoWork()
{
	if(g_pDVClient)
		return g_pDVClient->DoWork();

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVMsgHandler
// Desc: Voice message callback
//-----------------------------------------------------------------------------
HRESULT __stdcall XDVMsgHandler(LPVOID pvUserContext, DWORD dwMsgType, LPVOID pMsg)
{
	switch(dwMsgType)
	{
		// once we are connected, set targets to all players
		// we can override this in our app handler if we want to
        case DVMSGID_CONNECTRESULT:
			XDVAddTransmitTarget(DVID_ALLPLAYERS);
            break;
	}

	// call app DV message handler
	return g_AppDVMsgHandler(pvUserContext, dwMsgType, pMsg);
}

//-----------------------------------------------------------------------------
// Name: XDVCreate
// Desc: Create a DVoice session on the host player
// Params: dwSessionType - DVSESSIONTYPE_PEER, _FORWARDING
//         guidCT - GUID specifying compression for this session
//-----------------------------------------------------------------------------
HRESULT XDVCreate(DWORD dwSessionType, GUID guidCT)
{
	HRESULT hr;
	DVSESSIONDESC dvSession;

	// initialize DVoice server
	hr = g_pDVServer->Initialize(g_pDP, NULL, NULL, NULL, 0);
	assert(SUCCEEDED(hr));

	// initialize the session description
	ZeroMemory(&dvSession, sizeof(DVSESSIONDESC));
	dvSession.dwSize = sizeof(DVSESSIONDESC);
	dvSession.dwFlags = 0;
	dvSession.dwSessionType = dwSessionType;
	dvSession.guidCT = guidCT;

	// start the session
	hr = g_pDVServer->StartSession(&dvSession, 0);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVConnect
// Desc: Connect to an existing DVoice session
//-----------------------------------------------------------------------------
HRESULT XDVConnect(DWORD dwFlags)
{
	HRESULT hr;
	DVCLIENTCONFIG dvConfig;

	// initialize dvoice
	hr = g_pDVClient->Initialize(g_pDP, XDVMsgHandler, NULL, NULL, 0);
	assert(SUCCEEDED(hr));

	// initialize client configuration
	ZeroMemory(&dvConfig, sizeof(DVCLIENTCONFIG));
	dvConfig.dwSize = sizeof(DVCLIENTCONFIG);

	// the flags dword specifies the type of voice activation
	// it can have DVCLIENTCONFIG_MANUALVOICEACTIVATED set or
	// DVCLIENTCONFIG_AUTOVOICEACTIVATED set, or neither of them set.
	dvConfig.dwFlags = dwFlags;

	// if MANUALVOICEACTIVATED is set, we set the threshold manually.
	// if AUTOVOICEACTIVATED is set, we set the threshold to UNUSED.
	// if neither is set, we set to UNUSED, and voice will 
	// be active whenever there is a valid transmit target.
	if(dwFlags&DVCLIENTCONFIG_MANUALVOICEACTIVATED)
		dvConfig.dwThreshold = DVTHRESHOLD_DEFAULT;
	else
		dvConfig.dwThreshold = DVTHRESHOLD_UNUSED;

	// if hawk was not enumerated, pass a valid value to dvoice anyway
    if(g_dwHawkPort==-1) 
        g_dwHawkPort = 0;
	dvConfig.dwPort = g_dwHawkPort;

	// do the connect
	hr = g_pDVClient->Connect(&dvConfig, 0);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVDisconnect
// Desc: Disconnect from a DVoice session
//-----------------------------------------------------------------------------
HRESULT XDVDisconnect()
{
	HRESULT hr;
	
	hr = g_pDVClient->Disconnect(0);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVStopSession
// Desc: Terminates the DVoice session. Does not allow host migration.
//-----------------------------------------------------------------------------
HRESULT XDVStopSession()
{
	HRESULT hr;
	
	hr = g_pDVServer->StopSession(DVFLAGS_NOHOSTMIGRATE);
	assert(SUCCEEDED(hr));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDVFindHawk
// Desc: Finds a usable voice peripheral.
//-----------------------------------------------------------------------------
DWORD XDVFindHawk()
{
	DWORD dwInsertions, i;
	DWORD dwPort, dwSlot;
	DWORD ticks;

	ticks = GetTickCount();

	OutputDebugStringA("xdpvoice: Searching for Hawk voice peripheral\n");
	
	dwInsertions = 0;
	dwPort = -1;
	while(!dwInsertions)
	{
		dwInsertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
		if(dwInsertions)
			for(i=0; i<32; i++)
				if(dwInsertions&(1<<i))
				{
					if(i<16)
					{
						dwPort = i;
						dwSlot = XDEVICE_TOP_SLOT;
					}
					else
					{
						dwPort = i-16;
						dwSlot = XDEVICE_BOTTOM_SLOT;
					}

					if(dwPort>=4)
						OutputDebugStringA("\nxdpvoice: Hawk in illegal port\n\n");
					
					break;
				}

		if((GetTickCount()-ticks)>2000)
		{
			OutputDebugStringA("Hawk search timed out.\n");
			break;
		}
	}

	if(dwPort!=-1)
		OutputDebugStringA("Hawk found...\n");

	return dwPort;
}

//-----------------------------------------------------------------------------
// Name: XDVAddTransmitTarget
// Desc: Adds a transmit target to the current list.
//       If DVID_ALLPLAYERS is added, it sets the array to hold only
//       this single element. If anything besides ALLPLAYERS is added,
//       ALLPLAYERS is removed from the list.
//-----------------------------------------------------------------------------
HRESULT XDVAddTransmitTarget(DVID dvidTarget)
{
	DWORD i;

	if(dvidTarget==DVID_ALLPLAYERS)
	{
		g_dvidTargets[0] = DVID_ALLPLAYERS;
		g_dwNumTargets = 1;
	}
	else if(g_dvidTargets[0]==DVID_ALLPLAYERS || g_dwNumTargets==0)
	{
		g_dvidTargets[0] = dvidTarget;
		g_dwNumTargets = 1;
	}
	else
	{
		for(i=0; i<g_dwNumTargets; i++)
			if(g_dvidTargets[i]==dvidTarget)
				return S_FALSE;

		g_dvidTargets[g_dwNumTargets++] = dvidTarget;
	}

	return XDVSetTransmitTargets();
}

//-----------------------------------------------------------------------------
// Name: XDVRemoveTransmitTarget
// Desc: Removes a target from the transmit list.
//-----------------------------------------------------------------------------
HRESULT XDVRemoveTransmitTarget(DVID dvidTarget)
{
	DWORD i;

	for(i=0; i<g_dwNumTargets; i++)
		if(g_dvidTargets[i]==dvidTarget)
		{
			g_dvidTargets[i] = g_dvidTargets[--g_dwNumTargets];
			return XDVSetTransmitTargets();
		}

	return S_FALSE;
}

//-----------------------------------------------------------------------------
// Name: XDVSetTransmitTargets
// Desc: Sends the current target list to DVoice.
//-----------------------------------------------------------------------------
HRESULT XDVSetTransmitTargets()
{
	HRESULT hr;

	if(g_dwNumTargets!=0)
		hr = g_pDVClient->SetTransmitTargets(g_dvidTargets, g_dwNumTargets, 0);
	else
		hr = g_pDVClient->SetTransmitTargets(NULL, 0, 0);

    assert(SUCCEEDED(hr));

	return hr;
}

//-----------------------------------------------------------------------------
// Name: XDVClearTransmitTargets
// Desc: Clears the transmit target list.
//-----------------------------------------------------------------------------
HRESULT XDVClearTransmitTargets()
{
	HRESULT hr;

	g_dwNumTargets = 0;

    hr = g_pDVClient->SetTransmitTargets(NULL, 0, 0);
    assert(SUCCEEDED(hr));

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xfvf.cpp ===
//-----------------------------------------------------------------------------
// File: xfvf.cpp
//
// Desc: routines for manipulating d3d fixed vertex formats
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "xfvf.h"

//-----------------------------------------------------------------------------
//
// Name: FVF_Get Routines
//
// Desc: gets cnt items starting at vertex first from fvf memory
//       starting at verts which has FVF format of fvf.
//       the vertices are output to vout.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Name: FVF_Set Routines
//
// Desc: sets cnt items starting at vertex first from fvf memory
//       starting at verts which has FVF format of fvf.
//       the vertices are set from vin.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Name: FVF_VSize
// Desc: returns the size of an FVF
//-----------------------------------------------------------------------------
DWORD FVF_VSize(DWORD fvf)
{
	int size;
	
	size = 0;
	
	if(fvf&D3DFVF_XYZ)
		size += sizeof(D3DVECTOR);
	if(fvf&D3DFVF_XYZRHW)
		size += sizeof(D3DVECTOR)+sizeof(float);
	if(fvf&D3DFVF_NORMAL)
		size += sizeof(D3DVECTOR);
	if(fvf&D3DFVF_DIFFUSE)
		size += sizeof(DWORD);
	if(fvf&D3DFVF_TEX1)
		size += 2*sizeof(float);

	return size;
}

void FVF_GetVert(void *verts, D3DVECTOR *vout, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZNORM *fvf2;
	FVFT_XYZTEX1 *fvf3;
	FVFT_XYZRHWTEX1 *fvf4;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf1[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORM:
			fvf2 = (FVFT_XYZNORM *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf2[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZTEX1:
			fvf3 = (FVFT_XYZTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf3[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZRHWTEX1:
			fvf4 = (FVFT_XYZRHWTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf4[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf5[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf6[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf7[i].v, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&vout[idx++], &fvf8[i].v, sizeof(D3DVECTOR));
			break;
	}
}

void FVF_GetNorm(void *verts, D3DVECTOR *nout, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZNORM *fvf2;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZNORM:
			fvf2 = (FVFT_XYZNORM *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&nout[idx++], &fvf2[i].norm, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&nout[idx++], &fvf6[i].norm, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&nout[idx++], &fvf7[i].norm, sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&nout[idx++], &fvf8[i].norm, sizeof(D3DVECTOR));
			break;
	}
}

void FVF_GetDiff(void *verts, DWORD *dout, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				dout[idx++] = fvf1[i].diff;
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				dout[idx++] = fvf5[i].diff;
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				dout[idx++] = fvf7[i].diff;
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				dout[idx++] = fvf8[i].diff;
			break;
	}
}

void FVF_GetUV(void *verts, float *uvout, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZTEX1 *fvf3;
	FVFT_XYZRHWTEX1 *fvf4;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZTEX1:
			fvf3 = (FVFT_XYZTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf3[i].tu;
				uvout[idx*2+1] = fvf3[i].tv;
				idx++;
			}
			break;
		case FVF_XYZRHWTEX1:
			fvf4 = (FVFT_XYZRHWTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf4[i].tu;
				uvout[idx*2+1] = fvf4[i].tv;
				idx++;
			}
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf5[i].tu;
				uvout[idx*2+1] = fvf5[i].tv;
				idx++;
			}
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf6[i].tu;
				uvout[idx*2+1] = fvf6[i].tv;
				idx++;
			}
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				uvout[idx*2] = fvf8[i].tu;
				uvout[idx*2+1] = fvf8[i].tv;
				idx++;
			}
			break;
	}
}

void FVF_SetVert(void *verts, D3DVECTOR *vin, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZNORM *fvf2;
	FVFT_XYZTEX1 *fvf3;
	FVFT_XYZRHWTEX1 *fvf4;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf1[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORM:
			fvf2 = (FVFT_XYZNORM *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf2[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZTEX1:
			fvf3 = (FVFT_XYZTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf3[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZRHWTEX1:
			fvf4 = (FVFT_XYZRHWTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf4[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf5[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf6[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf7[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf8[i].v, &vin[idx++], sizeof(D3DVECTOR));
			break;
	}
}

void FVF_SetNorm(void *verts, D3DVECTOR *nin, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZNORM *fvf2;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZNORM:
			fvf2 = (FVFT_XYZNORM *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf2[i].norm, &nin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf6[i].norm, &nin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf7[i].norm, &nin[idx++], sizeof(D3DVECTOR));
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				memcpy(&fvf8[i].norm, &nin[idx++], sizeof(D3DVECTOR));
			break;
	}
}

void FVF_SetDiff(void *verts, DWORD *din, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				fvf1[i].diff = din[idx++];
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				fvf5[i].diff = din[idx++];
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				fvf7[i].diff = din[idx++];
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				fvf8[i].diff = din[idx++];
			break;
	}
}

void FVF_SetAllDiff(void *verts, DWORD din, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i;

	FVFT_XYZDIFF *fvf1;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMDIFF *fvf7;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	switch(fvf)
	{
		case FVF_XYZDIFF:
			fvf1 = (FVFT_XYZDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				fvf1[i].diff = din;
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				fvf5[i].diff = din;
			break;
		case FVF_XYZNORMDIFF:
			fvf7 = (FVFT_XYZNORMDIFF *)verts;
			for(i=first; i<first+cnt; i++)
				fvf7[i].diff = din;
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
				fvf8[i].diff = din;
			break;
	}
}

void FVF_SetUV(void *verts, float *uvin, DWORD first, DWORD cnt, DWORD fvf)
{
	DWORD i, idx;

	FVFT_XYZTEX1 *fvf3;
	FVFT_XYZRHWTEX1 *fvf4;
	FVFT_XYZDIFFTEX1 *fvf5;
	FVFT_XYZNORMTEX1 *fvf6;
	FVFT_XYZNORMDIFFTEX1 *fvf8;

	idx = 0;

	switch(fvf)
	{
		case FVF_XYZTEX1:
			fvf3 = (FVFT_XYZTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf3[i].tu = uvin[idx*2];
				fvf3[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
		case FVF_XYZRHWTEX1:
			fvf4 = (FVFT_XYZRHWTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf4[i].tu = uvin[idx*2];
				fvf4[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
		case FVF_XYZDIFFTEX1:
			fvf5 = (FVFT_XYZDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf5[i].tu = uvin[idx*2];
				fvf5[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
		case FVF_XYZNORMTEX1:
			fvf6 = (FVFT_XYZNORMTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf6[i].tu = uvin[idx*2];
				fvf6[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
		case FVF_XYZNORMDIFFTEX1:
			fvf8 = (FVFT_XYZNORMDIFFTEX1 *)verts;
			for(i=first; i<first+cnt; i++)
			{
				fvf8[i].tu = uvin[idx*2];
				fvf8[i].tv = uvin[idx*2+1];
				idx++;
			}
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xmenu.cpp ===
#include <xtl.h>
#include "assert.h"
#include "XBUtil.h"
#include "XBInput.h"
#include "xmenu.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

CXBFont *XMenu_Font = NULL;				// pointer to font
DWORD XMenu_FontLoaded = FALSE;			// font loaded flag
XMenu *XMenu_CurMenu = NULL;
int (*XMenu_CurRoutine)(DWORD cmd, XMenuItem *mi);			// called when item selected

void DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor);

void XMenu_SetFont(CXBFont *font)
{
	XMenu_Font = font;
}

XMenu *XMenu_Init(float x, float y, DWORD maxitems, DWORD flags, DWORD (*abortroutine)(DWORD, XMenuItem *))
{
	XMenu *m;
	BYTE *mem;

	assert(XMenu_Font!=NULL);				// make sure font is set

	// allocate memory for menu
	mem = new BYTE[sizeof(XMenu) + maxitems*sizeof(XMenuItem)];
	memset(mem, 0, sizeof(XMenu) + maxitems*sizeof(XMenuItem));

	m = (XMenu *)mem;
	m->items = (XMenuItem *)(mem+sizeof(XMenu));
	m->flags = flags;
	m->topcolor = 0xff000000;
	m->bottomcolor = 0xff0000c0;
	m->seltopcolor = 0xff000000;
	m->selbotcolor = 0xffc00000;
	m->maxitems = maxitems;
	m->abortroutine = abortroutine;
	m->itemcolor = 0xffffffff;

	m->x = x;
	m->y = y;
	m->w = 100.0f;

	XMenu_SetMaxShow(m, m->maxitems);		// sets height

	return m;
}

void XMenu_Delete(XMenu *m)
{
	delete m;
}

void XMenu_SetMaxShow(XMenu *m, DWORD maxshow)
{
	m->maxshow = maxshow;
	m->h = (float)(m->maxshow+1) * XMenu_Font->GetFontHeight();
}

XMenuItem *XMenu_AddItem(XMenu *m, DWORD flags, WCHAR *string, void *action)
{
	XMenuItem *mi;

	assert(m->nitems<m->maxitems);		// make sure we dont overstep our allocation
	mi = &m->items[m->nitems];

	mi->flags = flags;
	mi->action = action;
	mi->val1 = 0;
	mi->val2 = 0;
	mi->menu = m;
	mi->color = m->itemcolor;
	XMenu_SetItemText(&m->items[m->nitems], string);

	m->nitems++;

	return &m->items[m->nitems-1];
}

void XMenu_DeleteItem(XMenuItem *mi)
{
	XMenu *m;
	DWORD i;
	
	// get pointer to the menu that owns this item
	m = mi->menu;

	// find the item to delete
	for(i=0; i<m->nitems; i++)
		if(&m->items[i]==mi)
		{
			// shift em down
			memcpy(&m->items[i], &m->items[i+1], (m->nitems-i-1)*sizeof(XMenuItem));
			m->nitems--;
			break;
		}
}

void XMenu_SetTitle(XMenu *m, WCHAR *string, DWORD color)
{
	float w, h;

	m->titlecolor = color;

	if(string)
	{
		// set string
		wcsncpy(m->title, string, MITEM_STRINGLEN-1);

		// calculate new menu width based on this item
		XMenu_Font->GetTextExtent(string, &w, &h);
		if(m->w<(w+16.0f))
			m->w = w+16.0f;
	
		m->h = ((float)m->maxshow+2.5f) * XMenu_Font->GetFontHeight();
	}
	else
		m->h = (float)(m->maxshow+1) * XMenu_Font->GetFontHeight();
}

void XMenu_SetItemText(XMenuItem *mi, WCHAR *string)
{
	float w, h;

	if(!string || (mi->flags&MITEM_SEPARATOR))
		return;

	// set string
	wcsncpy(mi->string, string, MITEM_STRINGLEN-1);

	// calculate new menu width based on this item
	XMenu_Font->GetTextExtent(string, &w, &h);
	if(mi->menu->w<(w+16.0f))
		mi->menu->w = w+16.0f;
}

DWORD XMenu_Activate(XMenu *m)
{
	XMenu_CurMenu = m;

	return 1;
}

DWORD XMenu_GetCommand(XBGAMEPAD *gamepad)
{
	DWORD command;

	command = 0;

	// get menu command
	if(XMenu_CurMenu || XMenu_CurRoutine)
	{
		if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_A] ||
		   gamepad->wPressedButtons&XINPUT_GAMEPAD_START)
			command = MENU_SELECTITEM;
		else if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
		   gamepad->wPressedButtons&XINPUT_GAMEPAD_BACK)
			command = MENU_BACK;
		else if(gamepad->fY1>0.25f)
			command = MENU_PREVITEM;
		else if(gamepad->fY1<-0.25f)
			command = MENU_NEXTITEM;
	}
	else if(gamepad->wPressedButtons&XINPUT_GAMEPAD_START)
		command = MENU_ACTIVATE;

	return command;
}

DWORD XMenu_Routine(DWORD command)
{
	float menux, menuy;
	float rectx, recty, rectw, recth;
	float itemy, itemh;
	DWORD i, color;
	static float menutime = 0.0f;
	float time;
	XMenu *m;
	XMenuItem *mi;
	DWORD firstitem, nitems;
	WCHAR ddd[16] = L"[--MORE--]";
	WCHAR *str;
	DWORD status;

	// check for menu routine first
	if(XMenu_CurRoutine)
	{
		status = XMenu_CurRoutine(command, NULL);
		if(status==MROUTINE_DIE)
			XMenu_CurRoutine = NULL;
		return 0;
	}

	// no routine so do menu processing
	m = XMenu_CurMenu;
	if(!m)
		return 0;

	// get height of font
	itemh = (float)XMenu_Font->GetFontHeight();

	// draw menu background
	rectx = m->x;
	recty = m->y - itemh/2.0f;
	rectw = m->w;
	recth = m->h;

	if(m->flags&(MENU_LEFT|MENU_RIGHT))
		DrawRect(rectx-8.0f, recty, rectw, recth, m->topcolor, m->bottomcolor);
	else
		DrawRect(rectx-(rectw/2.0f), recty, rectw, recth, m->topcolor, m->bottomcolor);

	menux = m->x;
	menuy = m->y;

	// determine which menu items to show (firstitem, nitems)
	if(m->nitems>m->maxshow)
	{
		if(m->curitem<(m->maxshow/2))
			firstitem = 0;
		else if(m->curitem<(m->nitems-(m->maxshow/2)))
			firstitem = m->curitem-(m->maxshow/2)+1;
		else
			firstitem = m->nitems-m->maxshow;
	}
	else
		firstitem = 0;

	if(m->nitems>m->maxshow)
		nitems = m->maxshow;
	else
		nitems = m->nitems;

	itemy = menuy;

	// draw the menu title
	if(m->title[0])
	{
		if(m->flags&MENU_LEFT)
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title);
		else if(m->flags&MENU_RIGHT)
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title, XBFONT_RIGHT);
		else
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title, XBFONT_CENTER_X);
			
		itemy += 1.5f*itemh;
	}

	// draw the menu items
	for(i=firstitem; i<nitems+firstitem; i++)
	{
		mi = &m->items[i];

		if(!(mi->flags&MITEM_SEPARATOR))
		{
			// do menu scroll
			str = mi->string;
			if(m->nitems>m->maxshow)
			{
				if((i==firstitem) && (firstitem!=0))
					str = ddd;
				if((i==(firstitem+nitems-1)) && (firstitem!=(m->nitems-m->maxshow)))
					str = ddd;
			}

			// draw menu hilight bar
			if(i==m->curitem)
			{
				if(m->flags&(MENU_LEFT|MENU_RIGHT))
					DrawRect(rectx-8.0f, itemy-2.0f, rectw, XMenu_Font->GetFontHeight()+4.0f, m->seltopcolor, m->selbotcolor);
				else
					DrawRect(rectx-(rectw/2.0f), itemy-2.0f, rectw, XMenu_Font->GetFontHeight()+4.0f, m->seltopcolor, m->selbotcolor);
			}

			// set item color
			if(mi->flags&MITEM_DISABLED)
				color = (mi->color&0xffffff) | 0x40000000;	// lower alpha
			else
				color = mi->color;
	
			// draw the menu text
			if(!(m->flags&(MENU_LEFT|MENU_RIGHT)))
				XMenu_Font->DrawText(menux, itemy, color, str, XBFONT_CENTER_X);
			else if(m->flags&MENU_LEFT)
				XMenu_Font->DrawText(menux, itemy, color, str);
			else if(m->flags&MENU_RIGHT)
				XMenu_Font->DrawText(menux, itemy, color, str, XBFONT_RIGHT);
		}

		itemy += XMenu_Font->GetFontHeight();
	}

	time = XBUtil_Timer(TIMER_GETABSOLUTETIME);

	switch(command)
	{
		case MENU_NEXTITEM:
			if((time-menutime)<0.2f)
				return 0;
			menutime = time;

			do
			{
				m->curitem++;
				if(m->curitem==m->nitems)
					if(m->flags&MENU_WRAP)
						m->curitem = 0;
					else
						m->curitem = m->nitems-1;
			} while(m->items[m->curitem].flags&(MITEM_SEPARATOR|MITEM_DISABLED));
			break;

		case MENU_PREVITEM:
			if((time-menutime)<0.2f)
				return 0;
			menutime = time;

			do 
			{
				m->curitem--;
				if(m->curitem==-1)
					if(m->flags&MENU_WRAP)
						m->curitem = m->nitems-1;
					else
						m->curitem = 0;
			} while(m->items[m->curitem].flags&(MITEM_SEPARATOR|MITEM_DISABLED));

			menutime = time;
			break;

		case MENU_SELECTITEM:
			mi = &m->items[m->curitem];

			if(mi->flags&MITEM_ROUTINE)
			{
				// do routine
				XMenu_CurRoutine = (int (*)(DWORD, XMenuItem *))mi->action;
				status = XMenu_CurRoutine(MROUTINE_INIT, mi);

				// check return value... 
				if(status==MROUTINE_DIE)
				{
					XMenu_Activate(NULL);			// kill the current menu
					XMenu_CurRoutine = NULL;		// and the routine
				}
				else if(status==MROUTINE_RETURN)	// just kill the routine
					XMenu_CurRoutine = NULL;
				else if(status==MROUTINE_SLEEP)
					XMenu_Activate(NULL);			// just kill current menu
			}
			else
			{	
				// activate next menu if it exists
				if(mi->action)
				{
					XMenu_Activate((XMenu *)mi->action);
					XMenu_CurMenu->parent = m;		// the menu that called me
				}
				else
				{
					if(m->abortroutine)
						m->abortroutine(MROUTINE_ABORT, NULL);

					XMenu_Activate(NULL);
				}
			}
			break;

		case MENU_BACK:
			if(!(m->flags&MENU_NOBACK))
			{
				if(m->abortroutine)						// call abort routine if it exists
					m->abortroutine(MROUTINE_ABORT, NULL);

				if(m->parent)							// activate parent menu if it exists
					XMenu_Activate(m->parent);
				else
					XMenu_Activate(NULL);
			}
			break;

		default:
			break;
	}

	return 1;
}

//-----------------------------------------------------------------------------
// Name: DrawRect
// Desc: Draws a gradient filled rectangle
//-----------------------------------------------------------------------------
void DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor)
{
    static LPDIRECT3DVERTEXBUFFER8 XMenu_VB = NULL;
    struct BACKGROUNDVERTEX 
    { 
        D3DXVECTOR4 p; 
        D3DCOLOR color; 
    } *v;

    if(XMenu_VB == NULL)
        g_pd3dDevice->CreateVertexBuffer(4*sizeof(BACKGROUNDVERTEX), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &XMenu_VB);

    // Setup vertices for a background-covering quad
    XMenu_VB->Lock(0, 0, (BYTE **)&v, 0L);
    v[0].p = D3DXVECTOR4(x  -0.5f, y  -0.5f, 1.0f, 1.0f);  v[0].color = dwTopColor;
    v[1].p = D3DXVECTOR4(x+w-0.5f, y  -0.5f, 1.0f, 1.0f);  v[1].color = dwTopColor;
    v[2].p = D3DXVECTOR4(x  -0.5f, y+h-0.5f, 1.0f, 1.0f);  v[2].color = dwBottomColor;
    v[3].p = D3DXVECTOR4(x+w-0.5f, y+h-0.5f, 1.0f, 1.0f);  v[3].color = dwBottomColor;
    XMenu_VB->Unlock();

    // set render states
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE); 
    g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);

    // Set states
    g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
    g_pd3dDevice->SetStreamSource(0, XMenu_VB, sizeof(BACKGROUNDVERTEX));

    // Render the quad
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// restore render state
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE); 
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xmodel.cpp ===
//-----------------------------------------------------------------------------
// File: xmodel.cpp
//
// Desc: routines for loading, saving, and building models
//       vertex buffers, etc...
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <assert.h>

#include "XbUtil.h"
#include "xmodel.h"
#include "xparse.h"
#include "xpath.h"
#include "xfvf.h"

#ifndef _XBOX
#include <d3dx8.h>
#endif

float g_fNormLength = 0.005f;
extern LPDIRECT3DDEVICE8 g_pd3dDevice;

CXBPackedResource *g_pModelResource = NULL;


//-----------------------------------------------------------------------------
// Constructor and destructor
//-----------------------------------------------------------------------------
CXModel::CXModel()
{
	m_pVB = NULL;
	m_pIB = NULL;
	m_pTexture = NULL;
	m_dwRefCount = 1;
}

CXModel::~CXModel()
{
	assert(m_dwRefCount==0);

	if(m_pVB)
		m_pVB->Release();
	if(m_pIB)
		m_pIB->Release();
	if(m_pTexture)
		m_pTexture->Release();
}

//-----------------------------------------------------------------------------
// Name: Release
// Desc: Release someones claim to this model
//-----------------------------------------------------------------------------
int CXModel::Release()
{
	if(--m_dwRefCount)
		return m_dwRefCount;

	delete this;
	return 0;
}

//-----------------------------------------------------------------------------
// Name: Build
// Desc: builds a model from vertices, a triangle list, a list
//		 of texture coordinates and an FVF. Vertices and the 
//		 trilist are required. UV's & colors are optional
//-----------------------------------------------------------------------------
DWORD CXModel::Build(DWORD nvert, D3DVECTOR *vert, DWORD ntri, DWORD nidx, WORD *trilist, float *tc, D3DVECTOR *norm, DWORD *diff, DWORD fvf, DWORD flags)
{
	byte *bptr;
	DWORD i;
	D3DVECTOR *norm2 = NULL;
	float r, maxr;

	m_dwNumVertices = nvert;
	m_dwNumTriangles = ntri;
	m_dwFVF = fvf;
	m_dwVShader = fvf;				// set vshader to fixed function (user can chang manually)
	m_dwFlags = flags;

	// calculate radius
	maxr = 0.0f;
	for(i=0; i<nvert; i++)
	{	
		r = vert[i].x*vert[i].x + vert[i].y*vert[i].y + vert[i].z*vert[i].z;
		if(r>maxr)
			maxr = r;
	}
	m_fRadius2 = maxr;
	m_fRadius = (float)sqrt(maxr);

	// crunch normals if desired
	if(m_dwFVF&D3DFVF_NORMAL && !norm)
		norm2 = GenNormals(nvert, vert, ntri, trilist);

	// allocate vertex buffer
	m_dwVBStride = FVF_VSize(m_dwFVF);
	m_dwVBSize = m_dwNumVertices*m_dwVBStride;
#ifdef _XBOX
	g_pd3dDevice->CreateVertexBuffer(m_dwVBSize, 0, m_dwFVF, D3DPOOL_DEFAULT, &m_pVB);
#else
	g_pd3dDevice->CreateVertexBuffer(m_dwVBSize, D3DUSAGE_DYNAMIC, m_dwFVF, D3DPOOL_DEFAULT, &m_pVB);
#endif

	m_dwNumIndices = nidx;

	// allocate index buffer
	m_dwIBSize = m_dwNumIndices*sizeof(WORD);
#ifdef _XBOX
	g_pd3dDevice->CreateIndexBuffer(m_dwIBSize, 0, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB);
#else
	g_pd3dDevice->CreateIndexBuffer(m_dwIBSize, D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pIB);
#endif
	// fill vertex buffer
	LockVB(&bptr, 0L);
	FVF_SetVert(bptr, vert, 0, m_dwNumVertices, m_dwFVF);
	if(m_dwFVF&D3DFVF_DIFFUSE)
		FVF_SetDiff(bptr, diff, 0, m_dwNumVertices, m_dwFVF);
	if(m_dwFVF&D3DFVF_NORMAL)
	{
		if(norm2)
		{
			FVF_SetNorm(bptr, norm2, 0, m_dwNumVertices, m_dwFVF);
			delete[] norm2;		// free up memory allocated from GenNormals
		}
		else		// user specified own normals
			FVF_SetNorm(bptr, norm, 0, m_dwNumVertices, m_dwFVF);
	}
	if(m_dwFVF&D3DFVF_TEX1)
		FVF_SetUV(bptr, tc, 0, m_dwNumVertices, m_dwFVF);
	UnlockVB();
	
	// fill index buffer
	LockIB(&bptr, 0L);
	memcpy(bptr, trilist, m_dwIBSize);
	UnlockIB();

	m_PrimType = D3DPT_TRIANGLELIST;

	return 1;
}

//-----------------------------------------------------------------------------
// Name: GenNormals
// Desc: Generate vertex normals for a model and returns a pointer to
//       the memory allocated to store them.
//       *Note that this routine allocates memory that must be freed
//       manually.
//-----------------------------------------------------------------------------
D3DVECTOR *CXModel::GenNormals(DWORD nvert, D3DVECTOR *vert, DWORD ntri, WORD *trilist)
{
	DWORD i, v0, v1, v2;
	D3DVECTOR *tnorm, *vnorm;
	D3DVECTOR d, e;

	tnorm = new D3DVECTOR[ntri];
	memset(tnorm, 0, ntri*sizeof(D3DVECTOR));
	vnorm = new D3DVECTOR[nvert];
	memset(vnorm, 0, nvert*sizeof(D3DVECTOR));

	// calculate triangle normals
	for(i=0; i<ntri; i++)
	{
		v0 = trilist[i*3+0];
		v1 = trilist[i*3+1];
		v2 = trilist[i*3+2];

		// cross product
		d.x = vert[v1].x - vert[v0].x;
		d.y = vert[v1].y - vert[v0].y;
		d.z = vert[v1].z - vert[v0].z;
		e.x = vert[v2].x - vert[v1].x;
		e.y = vert[v2].y - vert[v1].y;
		e.z = vert[v2].z - vert[v1].z;

		tnorm[i].x = d.y*e.z - d.z*e.y;
		tnorm[i].y = d.z*e.x - d.x*e.z;
		tnorm[i].z = d.x*e.y - d.y*e.x;

		// normalize result
		float ool = 1.0f/(float)sqrt(tnorm[i].x*tnorm[i].x + tnorm[i].y*tnorm[i].y + tnorm[i].z*tnorm[i].z);
		tnorm[i].x *= ool;
		tnorm[i].y *= ool;
		tnorm[i].z *= ool;

		// contribute to vertex normals
		vnorm[v0].x += tnorm[i].x;
		vnorm[v0].y += tnorm[i].y;
		vnorm[v0].z += tnorm[i].z;
		vnorm[v1].x += tnorm[i].x;
		vnorm[v1].y += tnorm[i].y;
		vnorm[v1].z += tnorm[i].z;
		vnorm[v2].x += tnorm[i].x;
		vnorm[v2].y += tnorm[i].y;
		vnorm[v2].z += tnorm[i].z;
	}

	// normalize vertex normals
	for(i=0; i<nvert; i++)
		D3DXVec3Normalize((D3DXVECTOR3 *)&vnorm[i], (D3DXVECTOR3 *)&vnorm[i]);

	delete[] tnorm;
	return vnorm;
}

//-----------------------------------------------------------------------------
// Name: DrawNormals
// Desc: Draw a models normals. Note that g_fNormLength is defined at the
//       top of this file and should be set appropriately based on your world
//       dimensions.
//-----------------------------------------------------------------------------
void CXModel::DrawNormals()
{
	FVFT_XYZDIFF *verts;
	D3DVECTOR *vbuf, *nbuf;
	BYTE *bptr;
	DWORD i;

	verts = new FVFT_XYZDIFF[m_dwNumVertices*2];
	vbuf = new D3DVECTOR[m_dwNumVertices];
	nbuf = new D3DVECTOR[m_dwNumVertices];

	LockVB(&bptr, 0L);
	FVF_GetVert(bptr, vbuf, 0, m_dwNumVertices, m_dwFVF);
	FVF_GetNorm(bptr, nbuf, 0, m_dwNumVertices, m_dwFVF);
	UnlockVB();

	// draw normals
	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);

    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

	for(i=0; i<m_dwNumVertices; i++)
	{
		verts[i*2].v.x = vbuf[i].x;
		verts[i*2].v.y = vbuf[i].y;
		verts[i*2].v.z = vbuf[i].z;
		verts[i*2].diff = 0xffff0000;

		verts[i*2+1].v.x = g_fNormLength*nbuf[i].x + verts[i*2].v.x;
		verts[i*2+1].v.y = g_fNormLength*nbuf[i].y + verts[i*2].v.y;
		verts[i*2+1].v.z = g_fNormLength*nbuf[i].z + verts[i*2].v.z;
		verts[i*2+1].diff = 0xffff0000;
	}

	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, m_dwNumVertices, verts, sizeof(FVFT_XYZDIFF));

	// draw unit vector
	verts[0].v.x = 0.0f;
	verts[0].v.y = 0.0f;
	verts[0].v.z = 0.0f;
	verts[0].diff = 0xffffffff;
	verts[1].v.x = 0.0f;
	verts[1].v.y = 0.0f;
	verts[1].v.z = g_fNormLength;
	verts[1].diff = 0xffffffff;
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, verts, sizeof(FVFT_XYZDIFF));

	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

	delete[] verts;
	delete[] vbuf;
	delete[] nbuf;
}

//-----------------------------------------------------------------------------
// Name: Read_M
// Desc: Read a .m model file.
//-----------------------------------------------------------------------------
#define MAX_MVERTS 32767
#define MAX_MTRIS 65000
DWORD CXModel::Read_M(char *fname, char *imgname, DWORD fvf, DWORD flags, void (*vfunc)(int, int, float))
{
	FILE *fp;
	D3DVECTOR *vert = NULL;
	float *uvv = NULL, f;
	WORD *trilist = NULL;
	DWORD *diff = NULL, d;
	D3DVECTOR *norm = NULL;
	bool bFoundNorm = false;

	char buf[512];
	DWORD nt, vidx, i, nvert = 0;
	DWORD tidx = 0, v0, v1, v2;

	char texname[80];
	
	// load texture
	if(imgname)
		strcpy(texname, imgname);
	else
		texname[0] = '\0';

	// load mesh
	fp = fopen(fname, "rt");
	assert(fp!=NULL);

	vert = new D3DVECTOR[MAX_MVERTS];
	memset(vert, 0, MAX_MVERTS*sizeof(D3DVECTOR));
	trilist = new WORD[MAX_MTRIS*3];
	memset(trilist, 0, MAX_MTRIS*3*sizeof(WORD));
	if(fvf&D3DFVF_NORMAL)
	{
		norm = new D3DVECTOR[MAX_MVERTS];
		memset(norm, 0, MAX_MVERTS*sizeof(D3DVECTOR));
	}
	if(fvf&D3DFVF_TEX1)
	{
		uvv = new float[MAX_MVERTS*2];
		memset(uvv, 0, MAX_MVERTS*2*sizeof(float));
	}
	if(fvf&D3DFVF_DIFFUSE)
	{
		diff = new DWORD[MAX_MVERTS];
		memset(diff, 0, MAX_MVERTS*sizeof(DWORD));
	}

	while(1)
	{
		char* pChk = fgets(buf, 512, fp);
		assert(pChk || feof(fp));

		if(feof(fp))
			break;

		nt = Parse(buf, NULL);
		if(!nt)
			continue;

		if(!strcmp(tokens[0].str, "IMAGE"))
		{
			LoadTexture(tokens[1].str);
		}
		else if(!strcmp(tokens[0].str, "VERTEX"))
		{
			vidx = atoi(tokens[1].str);

			vert[vidx].x = (float)atof(tokens[2].str);
			vert[vidx].y = (float)atof(tokens[3].str);
			vert[vidx].z = (float)atof(tokens[4].str);

			for(i=5; i<nt; i++)
			{
				if(fvf&D3DFVF_NORMAL && (!strcmp(tokens[i].str, "{NORMAL=") || !strcmp(tokens[i].str, "NORMAL=")))
				{
					bFoundNorm = true;
					norm[vidx].x = (float)atof(tokens[i+1].str);
					norm[vidx].y = (float)atof(tokens[i+2].str);
					norm[vidx].z = (float)atof(tokens[i+3].str);
					i+=3;
				}
				else if(fvf&D3DFVF_TEX1 && (!strcmp(tokens[i].str, "{UV=") || !strcmp(tokens[i].str, "UV=")))
				{
					uvv[vidx*2] = (float)atof(tokens[i+1].str);
					uvv[vidx*2+1] = (float)atof(tokens[i+2].str);
					i+=2;
				}
				else if(!strncmp(tokens[i].str, "EYELIDWT", 8) && vfunc)			// check for eyelid weights & receiving function
				{
					f = (float)atof(tokens[i+1].str);
					if(tokens[i].str[8]=='L')
						vfunc(MFP_EYEWT, 0x10000|vidx, -f);
					else
						vfunc(MFP_EYEWT, vidx, f);
					i+=1;
				}
			}

			if(vidx+1>nvert)
				nvert = vidx+1;
		}
		else if(!strcmp(tokens[0].str, "FACE"))
		{
			v0 = atoi(tokens[2].str);
			v1 = atoi(tokens[3].str);
			v2 = atoi(tokens[4].str);

			if(fvf&D3DFVF_DIFFUSE)
				for(i=5; i<nt; i++)
				{
					if(!strcmp(tokens[i].str, "RGB="))
					{
						d = (DWORD)((float)atof(tokens[i+1].str)*255.0f);
						d<<=8;
						d |= (DWORD)((float)atof(tokens[i+2].str)*255.0f);
						d<<=8;
						d |= (DWORD)((float)atof(tokens[i+3].str)*255.0f);

						diff[v0] = d;
						diff[v1] = d;
						diff[v2] = d;

						i+=3;
					}
				}

			trilist[tidx] = (WORD)v0;
			tidx++;
			trilist[tidx] = (WORD)v1;
			tidx++;
			trilist[tidx] = (WORD)v2;
			tidx++;
		}
	}

	fclose(fp);

	Build(nvert, vert, tidx/3, tidx, trilist, uvv, bFoundNorm ? norm : NULL, diff, fvf, flags);
	
	if(texname[0])
		LoadTexture(texname);

	delete[] vert;
	delete[] trilist;
	delete[] norm;
	delete[] uvv;
	delete[] diff;

	return 1;
}
//-----------------------------------------------------------------------------
// Name: Sphere
// Desc: Generate a sphere model and texture it with imgname.
//-----------------------------------------------------------------------------
#define PI 3.14159f
#define TWOPI (2*PI)
DWORD CXModel::Sphere(float radius, DWORD tessx, DWORD tessy, DWORD fvf, char *imgname, float txscale)
{
	DWORD tidx;
	D3DVECTOR *vert;		// vertices
	WORD *tlist;			// triangle indices
	float *tc;				// index texcoords
	DWORD row, col;
	float ra, rr, ss, cc;
	DWORD vidx, *diff;

	vert = new D3DVECTOR[tessx*tessy];
	tlist = new WORD[(tessy-1)*(tessx-1)*6];
	tc = new float[tessx*tessy*2];

	// vertices
	for(row=0; row<tessy; row++)
	{
		ra = (float)row/(float)(tessy-1)*(PI*0.875f)+(PI*0.0625f);
		rr = radius * (float)sin(ra);

		for(col=0; col<tessx; col++)
		{
			vidx = row*tessx+col;
			ss = (float)sin(TWOPI*(float)(col)/(float)(tessx-1));
			cc = (float)cos(TWOPI*(float)(col)/(float)(tessx-1));

			vert[vidx].x = -rr*ss;
			vert[vidx].y = radius*(float)cos(ra);
			vert[vidx].z = rr*cc;

			tc[vidx*2] = txscale*(float)col/(float)(tessx-1);
			tc[vidx*2+1] = txscale*(float)row/(float)(tessy-1);
		}
	}

	// triangles
	tidx = 0;
	for(row=0; row<tessy-1; row++)
		for(col=0; col<tessx-1; col++)
		{
			tlist[tidx++] = (WORD)(row*tessx+col);
			tlist[tidx++] = (WORD)(row*tessx+col+1);
			tlist[tidx++] = (WORD)((row+1)*tessx+col);
			tlist[tidx++] = (WORD)((row+1)*tessx+col);
			tlist[tidx++] = (WORD)(row*tessx+col+1);
			tlist[tidx++] = (WORD)((row+1)*tessx+col+1);
		}

	if(fvf&D3DFVF_DIFFUSE)
	{
		diff = new DWORD[tessx*tessy];
		for(row=0; row<tessx*tessy; row++)
			diff[row] = (rand()<<16) | rand() | 0xff000000; 
	}
	else
		diff = NULL;


	Build(tessx*tessy, vert, tidx/3, tidx, tlist, tc, NULL, diff, fvf, 0);

	if(fvf&D3DFVF_DIFFUSE)
		delete[] diff;

    if(imgname)
		LoadTexture(imgname);

	delete[] vert;
	delete[] tlist;
	delete[] tc;

	return 1;
}

//-----------------------------------------------------------------------------
// Name: GridXZ
// Desc: Generate an XZ grid model.
//-----------------------------------------------------------------------------
DWORD CXModel::GridXZ(DWORD tessx, DWORD tessz, float xsize, float zsize, DWORD fvf, char *imgname, float texx, float texz)
{
	DWORD tidx, i;
	D3DVECTOR *vert;		// vertices
	D3DVECTOR *norm;
	WORD *tlist;			// triangle indices
	float *tc;				// index texcoords
	DWORD row, col;
	DWORD vidx;

	// clear normal flag because GenNormals does not support tristrips
	if(fvf&D3DFVF_NORMAL)
	{
		norm = new D3DVECTOR[tessx*tessz];
		ZeroMemory(norm, tessx*tessz*sizeof(D3DVECTOR));
		for(i=0; i<tessx*tessz; i++)
			norm[i].y = 1.0f;
	}
	else
		norm = NULL;

	vert = new D3DVECTOR[tessx*tessz];
	tlist = new WORD[(tessz-1)*(tessx-1)*6];
	tc = new float[tessx*tessz*2];

	// vertices, texcoords
	for(row=0; row<tessz; row++)
	{
		for(col=0; col<tessx; col++)
		{
			vidx = row*tessx+col;

			vert[vidx].x = (float)col*(xsize/(float)(tessx-1)) - (xsize/2.0f);
			vert[vidx].y = 0.0f;
			vert[vidx].z = (float)row*(zsize/(float)(tessz-1)) - (zsize/2.0f);

			tc[vidx*2] = (vert[vidx].z+(xsize/2.0f))/texz;
			tc[vidx*2+1] = (vert[vidx].x+(zsize/2.0f))/texx;
		}
	}
	
	// triangles
	tidx = 0;
	for(row=0; row<tessz-1; row++)
	{
		for(col=0; col<tessx; col++)
		{
			// add duplicate vertex for new row
			// (except on first row)
			if(col==0 && row!=0)
				tlist[tidx++] = (WORD)((row*tessx+col)&0xffff);

			tlist[tidx++] = (WORD)((row*tessx+col)&0xffff);
			tlist[tidx++] = (WORD)(((row+1)*tessx+col)&0xffff);
		}

		// add duplicate vertex at end of row
		// (except on last row)
		if(row!=(tessz-1))
		{
			tlist[tidx] = tlist[tidx-1];
			tidx++;
		}
	}

	Build(tessx*tessz, vert, tidx-2, tidx, tlist, tc, norm, NULL, fvf, 0);
	m_PrimType = D3DPT_TRIANGLESTRIP;

	if(imgname)
		LoadTexture(imgname);

	if(norm)
		delete[] norm;

	delete[] vert;
	delete[] tlist;
	delete[] tc;

	return 1;
}

//-----------------------------------------------------------------------------
// Name: Cylinder
// Desc: Generate a cylinder model and texture it with imgname.
//-----------------------------------------------------------------------------
DWORD CXModel::Cylinder(float rad0, DWORD diff0, float rad1, DWORD diff1, float len, DWORD tess, DWORD fvf, char *imgname, float txscale)
{
	DWORD tidx;
	D3DVECTOR *vert;		// vertices
	WORD *tlist;			// triangle indices
	float *tc;				// index texcoords
	DWORD col;
	float ss, cc;
	DWORD *diff;

	vert = new D3DVECTOR[tess*2];		// top & bottom disc
	tlist = new WORD[tess*2*3];			// 2 * tess * 3/tri
	tc = new float[tess*2*2];			// 2 * tess * 2/tri

	// vertices
	for(col=0; col<tess; col++)
	{
		ss = (float)sin(TWOPI*(float)(col)/(float)(tess-1));
		cc = (float)cos(TWOPI*(float)(col)/(float)(tess-1));

		// top disc
		vert[col].x = -rad0*ss;
		vert[col].y = rad0*cc;
		vert[col].z = 0.0f;

		// bottom disc
		vert[col+tess].x = -rad1*ss;
		vert[col+tess].y = rad1*cc;
		vert[col+tess].z = len;

		// texture samples
		tc[col*2] = txscale*(float)col/(float)(tess-1);
		tc[col*2+1] = 0.0f;
		tc[(col+tess)*2] = tc[col*2];
		tc[(col+tess)*2+1] = 1.0f;
	}

	// triangles
	tidx = 0;
	for(col=0; col<tess; col++)
	{
		tlist[tidx++] = (WORD)(col);
		tlist[tidx++] = (WORD)((col+1)%tess);
		tlist[tidx++] = (WORD)((col+tess+1)%(tess*2));
		tlist[tidx++] = tlist[tidx-3];
		tlist[tidx++] = tlist[tidx-2];
		tlist[tidx++] = (WORD)((col+tess)%(tess*2));
	}

	if(fvf&D3DFVF_DIFFUSE)
	{
		diff = new DWORD[tess*2];
		for(col=0; col<tess; col++)
		{
			diff[col] = diff0;
			diff[col+tess] = diff1;
		}
	}
	else
		diff = NULL;


	Build(tess*2, vert, tidx/3, tidx, tlist, tc, NULL, diff, fvf, 0);

	if(fvf&D3DFVF_DIFFUSE)
		delete[] diff;

    if(imgname)
		LoadTexture(imgname);

	delete[] vert;
	delete[] tlist;
	delete[] tc;

	return 1;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Render a model. Note that render/texture state needs to be
//       set before you call this routine.
//-----------------------------------------------------------------------------
DWORD CXModel::Render()
{
	g_pd3dDevice->SetTexture(0, m_pTexture);
	g_pd3dDevice->SetVertexShader(m_dwVShader);
	g_pd3dDevice->SetIndices(m_pIB, 0);
	g_pd3dDevice->SetStreamSource(0, m_pVB, m_dwVBStride);
	g_pd3dDevice->DrawIndexedPrimitive(m_PrimType, 0, m_dwNumVertices, 0, m_dwNumTriangles);

	return 1;
}

//-----------------------------------------------------------------------------
// Name: LoadTexture
// Desc: Load a texture for use in a model.
//-----------------------------------------------------------------------------
void CXModel::LoadTexture(char *imgname)
{
	if(g_pModelResource!=NULL)
		m_pTexture = g_pModelResource->GetTexture(imgname);

	if(!m_pTexture)
	{
		OUTPUT_DEBUG_STRING("XModel: Error getting texture from resource file: ");
		OUTPUT_DEBUG_STRING(imgname);
		OUTPUT_DEBUG_STRING("\n");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <cstdio>
#include <cassert>
#include "XBUtil.h"



//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OUTPUT_DEBUG_STRING( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OUTPUT_DEBUG_STRING( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
	HANDLE hFile;
	DWORD dwNumBytesRead;
	hFile = CreateFile(strShaderPath, GENERIC_READ, FILE_SHARE_READ, NULL,
		               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
		return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize(hFile, NULL);
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
	ReadFile(hFile, pData, dwSize, &dwNumBytesRead, 0);
	
	// Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
	CloseHandle(hFile);
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
	HANDLE hFile;
	DWORD dwNumBytesRead;
    hFile = CreateFile(strShaderPath, GENERIC_READ, FILE_SHARE_READ, NULL,
		               OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
		return E_FAIL;


    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwNumBytesRead, NULL );
    
    // Make sure the pixel shader is valid
    if( psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OUTPUT_DEBUG_STRING( "XBUtil_CreatePixelShader(): Invalid pixel shader file\n" );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OUTPUT_DEBUG_STRING( "XBUtil_CreatePixelShader(): Could not create pixel shader\n" );
        return hr;
    }

	// cleanup
	CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName,
                            BOOL bSurfaceIsTiled )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, bSurfaceIsTiled ? D3DLOCK_TILED : 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwTexCoordSize = ( dwFVF & (0x00030000<<(i*2)) );

        DWORD dwNumTexCoords = 0;
        if( dwTexCoordSize == D3DFVF_TEXCOORDSIZE1(i) ) dwNumTexCoords = D3DVSDT_FLOAT1;
        if( dwTexCoordSize == D3DFVF_TEXCOORDSIZE2(i) ) dwNumTexCoords = D3DVSDT_FLOAT2;
        if( dwTexCoordSize == D3DFVF_TEXCOORDSIZE3(i) ) dwNumTexCoords = D3DVSDT_FLOAT3;
        if( dwTexCoordSize == D3DFVF_TEXCOORDSIZE4(i) ) dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetWide()
// Desc: Convert CHAR string to WCHAR string. dwMax includes the null byte.
//       Never copies more than dwMax-1 characters into strWide.
//          Ex: GetWide( "abc", strWide, 3 ) gives strWide = "ab"
//       Typical usage:
//          WCHAR strResult[MAX];
//          XBUtil_GetWide( strThin, strResult, MAX );
//-----------------------------------------------------------------------------
VOID XBUtil_GetWide( const CHAR* strThin, WCHAR* strWide, DWORD dwMax )
{
    assert( strThin != NULL );
    assert( strWide != NULL );

    // dwMax includes the null bytes, so must always be at least one.
    // Furthermore, if dwMax is 0, MultiByteToWideChar doesn't do any 
    // conversion, but returns the number of chars it *would* convert.
    assert( dwMax > 0 );

    // Determine how many characters we will convert. Can never be more
    // than dwMax-1
    INT nChars = lstrlenA( strThin );
    if( nChars > INT(dwMax) - 1 )
        nChars = INT(dwMax) - 1;

    // Perform the conversion
    INT iWide = MultiByteToWideChar( CP_ACP, 0, strThin, nChars, 
                                     strWide, dwMax );
    assert( nChars == iWide - 1 );
    (VOID)iWide; // avoid compiler warning in release mode
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xdppeer.cpp ===
//-----------------------------------------------------------------------------
// File: xdppeer.cpp
//
// Desc: DirectPlay peer routines
//
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

// TODO : do 'connect' timeout

#include <assert.h>
#include "xdppeer.h"

LPDIRECTPLAY8PEER g_pDP;						// DirectPlay peer object
LPDIRECTPLAY8ADDRESS g_pDeviceAddress;			// device address of SP
LPDIRECTPLAY8ADDRESS g_pHostAddress;			// host address of SP

HRESULT (WINAPI *g_AppDPMsgHandler)(void *, DWORD, void *); // apps message handler
HRESULT WINAPI XDPMsgHandler(void *, DWORD, void *);

DPNHANDLE g_hAsyncOp;

DWORD g_dwConnectStatus;						// connection status
WCHAR g_wszXDPPlayerName[32];					// players name
WCHAR g_wszXDPSessionName[32];					// session name

// active game list stuff
ActiveGame *ActiveGames[MAX_ACTIVEGAMES];
DWORD g_dwNumActiveGames;
void XDPDeleteGames();

// DPNID stuff
DPNID g_dpnidLocalPlayer;
DPNID g_dpnidHost;

DWORD g_dwNumPlayers;

//-----------------------------------------------------------------------------
// Name: DPInit
// Desc: Initialize DirectPlay and other relevant stuff.
//-----------------------------------------------------------------------------
HRESULT XDPInit(HRESULT (WINAPI *DPMsgHandler)(void *, DWORD, void *))
{
    HRESULT hr;
	int err;

    OutputDebugStringA("xdppeer: initializing\n");

	// Save message handler pointer
	g_AppDPMsgHandler = DPMsgHandler;

	// initialize Xnet
	err = XNetStartup(NULL);
	assert(err==NO_ERROR);

	// initialize DPlay
	hr = DPlayInitialize(200000);
	assert(SUCCEEDED(hr));

	// create DPlay Peer object & get DVoice interface
    hr = DirectPlay8Create(IID_IDirectPlay8Peer, (void **) &g_pDP, NULL);
	assert(SUCCEEDED(hr));

    // Init IDirectPlay8Peer
    hr = g_pDP->Initialize(NULL, XDPMsgHandler, 0);
	assert(SUCCEEDED(hr));

	// create device address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &g_pDeviceAddress, NULL);
	assert(SUCCEEDED(hr));

	// create host address
    hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (void **) &g_pHostAddress, NULL);
	assert(SUCCEEDED(hr));

	// clear connect state
	g_dwConnectStatus = GAME_NOTCONNECTED;

	// clear active games list
	ZeroMemory(ActiveGames, MAX_ACTIVEGAMES*sizeof(DPN_APPLICATION_DESC *));
	g_dwNumActiveGames = 0;

	// clear # of players
	g_dwNumPlayers = 0;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDPShutdown
// Desc: Close existing connection, do cleanup, release DPlay object,
//       and shut down COM.
//-----------------------------------------------------------------------------
void XDPShutdown()
{
	// close the connection
	// this blocks until all callbacks are completed
	g_pDP->Close(0);

	// release the address objects we are using
    if(g_pDeviceAddress)
		g_pDeviceAddress->Release();
    if(g_pHostAddress)
		g_pHostAddress->Release();

	// release our dplay object
	g_pDP->Release();

	// shut down DPlay
	DPlayCleanup();

	// clean up Xnet
    XNetCleanup();
}

//-----------------------------------------------------------------------------
// Name: XDPDoWork
// Desc: Does DPlay work.
//-----------------------------------------------------------------------------
HRESULT XDPDoWork(DWORD msec)
{
	DWORD time;
	static DWORD dwExpireTime = 0;
	HRESULT hr;

	// get current time in msec
	time = GetTickCount();

	// expire games if we are enumerating
	if(g_dwConnectStatus==GAME_ENUMERATING)
	{
		if(time>dwExpireTime)
		{
			dwExpireTime += 2000;	// 2 sec
			XDPExpireGames();
		}
	}

	// call the dplay DoWork function until work is done
	// or we have used up all available time
	if(msec==0)
	{
		do
			hr = g_pDP->DoWork(0);
		while(hr!=S_FALSE);
	}
	else
	{
		do
			hr = g_pDP->DoWork(0);
		while(hr!=S_FALSE && ((GetTickCount()-time)<msec));
	}

	// check for disconnect
	if(g_dwConnectStatus==GAME_DISCONNECTING)
		return XDPDisconnect();

	return hr;
}

//-----------------------------------------------------------------------------
// Name: XDPMsgHandler
// Desc: Handles some DPlay messages
//-----------------------------------------------------------------------------
HRESULT WINAPI XDPMsgHandler(PVOID pvUserContext, DWORD dwMsgType, PVOID pMsg)
{
	PDPNMSG_HOST_MIGRATE pHostMigrateMsg;

	switch(dwMsgType)
	{
        case DPN_MSGID_CONNECT_COMPLETE:
			g_dwConnectStatus = GAME_CONNECTED;
			break;

        case DPN_MSGID_TERMINATE_SESSION:
			g_dwConnectStatus = GAME_DISCONNECTING;
			break;

        case DPN_MSGID_HOST_MIGRATE:
            pHostMigrateMsg = (DPNMSG_HOST_MIGRATE *)pMsg;
			g_dpnidHost = pHostMigrateMsg->dpnidNewHost;
            if(g_dpnidHost==g_dpnidLocalPlayer)
				g_dwConnectStatus = GAME_HOSTING;
			break;
	}

	// call app DP message handler
	return g_AppDPMsgHandler(pvUserContext, dwMsgType, pMsg);
}

//-----------------------------------------------------------------------------
// Name: XDPEnumHosts
// Desc: Searches for all active games on the network
//-----------------------------------------------------------------------------
HRESULT XDPEnumHosts(DWORD port, GUID *pGuid)
{
    HRESULT hr;
	DWORD dwPort = port;

	// Delete active games
	XDPDeleteGames();

    // Enumerate hosts
    DPN_APPLICATION_DESC dnAppDesc;
    ZeroMemory(&dnAppDesc, sizeof(DPN_APPLICATION_DESC));
    dnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = *pGuid;

	// set port
	hr = g_pHostAddress->AddComponent(DPNA_KEY_PORT, (void *)&dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD);
	assert(SUCCEEDED(hr));

    // Enumerate all the active DirectPlay games on the selected connection
    hr = g_pDP->EnumHosts(&dnAppDesc,                  // application description
                          g_pHostAddress,              // host address
                          g_pDeviceAddress,            // device address
                          NULL,                        // pointer to user data
                          0,                           // user data size
                          INFINITE,                    // retry count (forever)
                          0,                           // retry interval (0=default)
                          INFINITE,                    // time out (forever)
                          NULL,                        // user context
                          &g_hAsyncOp,		           // async handle
                          0							   // flags
                          );

	assert(SUCCEEDED(hr));

	g_dwConnectStatus = GAME_ENUMERATING;

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDPCancelEnumHosts
// Desc: Stops searching for active games on the network.
//-----------------------------------------------------------------------------
void XDPCancelEnumHosts()
{
	g_pDP->CancelAsyncOperation(g_hAsyncOp, 0);				// stop the game search operation
	g_dwConnectStatus = GAME_NOTCONNECTED;
}

//-----------------------------------------------------------------------------
// Name: XDPAddGame
// Desc: Add an active game to the game list
//-----------------------------------------------------------------------------
ActiveGame *XDPAddGame(DPNMSG_ENUM_HOSTS_RESPONSE *pHost)
{
	DWORD i;
	const DPN_APPLICATION_DESC *pApp;
	HRESULT hr;
	ActiveGame *pGame;

	pApp = pHost->pApplicationDescription;

	// See if game already in list
	pGame = NULL;
	for(i=0; i<g_dwNumActiveGames; i++)
		if(ActiveGames[i])
			if(ActiveGames[i]->AppDesc.guidInstance==pApp->guidInstance)
			{
				pGame = ActiveGames[i];
				break;
			}

	// if game not already in list, add a new one
	if(!pGame)
	{
		ActiveGames[g_dwNumActiveGames] = new ActiveGame;
		pGame = ActiveGames[g_dwNumActiveGames];

		// set address information
		hr = pHost->pAddressSender->Duplicate(&pGame->pHostAddr);
		assert(SUCCEEDED(hr));
		hr = pHost->pAddressDevice->Duplicate(&pGame->pDevAddr);
		assert(SUCCEEDED(hr));

		// bump active game count
		g_dwNumActiveGames++;
	}

	// update game information
	memcpy(&pGame->AppDesc, pApp, sizeof(DPN_APPLICATION_DESC));
	pGame->dwPing = pHost->dwRoundTripLatencyMS;

	// set report time
	pGame->dwReportTime = GetTickCount();

	return pGame;
}

//-----------------------------------------------------------------------------
// Name: XDPDeleteGames
// Desc: Deletes active games list.
//-----------------------------------------------------------------------------
void XDPDeleteGames()
{
	DWORD i;

	for(i=0; i<g_dwNumActiveGames; i++)
		if(ActiveGames[i])
		{
			ActiveGames[i]->pHostAddr->Release();		// release address objects
			ActiveGames[i]->pDevAddr->Release();

			delete ActiveGames[i];						// free up the memory
			ActiveGames[i] = NULL;
		}

	g_dwNumActiveGames = 0;
}

//-----------------------------------------------------------------------------
// Name: XDPCreate
// Desc: Creates a multiplayer game with us as a host.
//-----------------------------------------------------------------------------
HRESULT XDPCreate(DWORD port, GUID *pGuid, DWORD dwMaxPlayers, DWORD flags)
{
	HRESULT hr;
    DPN_PLAYER_INFO dpPlayerInfo;
    DPN_APPLICATION_DESC dnAppDesc;
	DWORD dwPort = port;
    DPNHANDLE hAsync;

    OutputDebugStringA("xdppeer: hosting\n");

	// set up player info for ourself as we create the game
    ZeroMemory(&dpPlayerInfo, sizeof(DPN_PLAYER_INFO));
    dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
    dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
    dpPlayerInfo.pwszName = g_wszXDPPlayerName;

	// set peer info. this is sent to all other machines via
	// the CREATE_PLAYER message
    hr = g_pDP->SetPeerInfo(&dpPlayerInfo, NULL, &hAsync, 0);
	assert(SUCCEEDED(hr));

    // Setup the application description
    ZeroMemory(&dnAppDesc, sizeof(DPN_APPLICATION_DESC));
    dnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);
    dnAppDesc.guidApplication = *pGuid;
    dnAppDesc.dwMaxPlayers = dwMaxPlayers;
    dnAppDesc.dwFlags = flags;

	// set the name of the game
    dnAppDesc.pwszSessionName = g_wszXDPSessionName;

    // Host a game on m_pDeviceAddress as described by dnAppDesc
	g_pDeviceAddress->AddComponent(DPNA_KEY_PORT, (void *)&dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD);
	assert(SUCCEEDED(hr));

    hr = g_pDP->Host(&dnAppDesc, &g_pDeviceAddress, 1, NULL, NULL, NULL, 0);
	assert(SUCCEEDED(hr));

	g_dwConnectStatus = GAME_HOSTING;

	return hr;
}

//-----------------------------------------------------------------------------
// Name: XDPConnect
// Desc: Connect to an existing game.
//-----------------------------------------------------------------------------
HRESULT XDPConnect(DPN_APPLICATION_DESC *pAppDesc, IDirectPlay8Address *pHostAddr, IDirectPlay8Address *pDevAddr)
{
	static float time = 0.0f;
	static TCHAR s[80];
	HRESULT hr;
    DPNHANDLE hAsync;

    OutputDebugStringA("xdppeer: connecting\n");

	// cancel host enumeration
	XDPCancelEnumHosts();

	// Set player info
	DPN_PLAYER_INFO dpPlayerInfo;
	ZeroMemory(&dpPlayerInfo, sizeof(DPN_PLAYER_INFO));
	dpPlayerInfo.dwSize = sizeof(DPN_PLAYER_INFO);
	dpPlayerInfo.dwInfoFlags = DPNINFO_NAME;
	dpPlayerInfo.pwszName = g_wszXDPPlayerName;

	// set the peer info for the client
	hr = g_pDP->SetPeerInfo(&dpPlayerInfo, NULL, &hAsync, 0);
	assert(SUCCEEDED(hr));

	// connect to the game
	hr = g_pDP->Connect( pAppDesc,								// the application description
						 pHostAddr,								// address of the host of the session
						 pDevAddr,								// address of the local device the enum responses were received on
						 NULL, NULL,							// DPN_SECURITY_DESC, DPN_SECURITY_CREDENTIALS
						 NULL, 0,								// user data, user data size
						 NULL,									// player context,
						 NULL, &g_hAsyncOp,						// async context, async handle,
						 0);									// flags

	assert(hr==E_PENDING || SUCCEEDED(hr));

	g_dwConnectStatus = GAME_CONNECTING;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: XDPDisconnect
// Desc: Disconnect from the current game
//-----------------------------------------------------------------------------
HRESULT XDPDisconnect()
{
	HRESULT hr;

    OutputDebugStringA("xdppeer: disconnecting\n");

	g_pDP->Close(0);										// close the dplay connection
    hr = g_pDP->Initialize(NULL, XDPMsgHandler, 0);			// reinitialize dplay
	assert(SUCCEEDED(hr));

	g_dwConnectStatus = GAME_NOTCONNECTED;

	return hr;
}

//-----------------------------------------------------------------------------
// Name: XDPTerminate
// Desc: Terminate the current game as the host
//-----------------------------------------------------------------------------
HRESULT XDPTerminate()
{
	// send the terminate session message
	if(g_dwConnectStatus==GAME_HOSTING)
	{
	    OutputDebugStringA("xdppeer: terminating session\n");
		g_pDP->TerminateSession(NULL, 0, 0);
	}

	// and reset DPlay
	return XDPDisconnect();
}

//-----------------------------------------------------------------------------
// Name: XDPExpireGames
// Desc: Thread that expires old games in the ActiveGames list.
//-----------------------------------------------------------------------------
void XDPExpireGames()
{
	DWORD i;

	// search for expired games
	for(i=0; i<g_dwNumActiveGames; i++)
	{
		if((ActiveGames[i]->dwReportTime+3000)<GetTickCount())
		{
			// send delete game message to message handler
			g_AppDPMsgHandler(NULL, DPPEER_MSGID_DELETE_GAME, ActiveGames[i]);

			// delete the expired active game
			ActiveGames[i]->pHostAddr->Release();
			ActiveGames[i]->pDevAddr->Release();
			delete ActiveGames[i];

			// and remove it from our list
			ActiveGames[i] = ActiveGames[g_dwNumActiveGames-1];
			ActiveGames[g_dwNumActiveGames-1] = NULL;
			g_dwNumActiveGames--;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xobj.cpp ===
//-----------------------------------------------------------------------------
// File: xobj.cpp
//
// Desc: routines for displaying objects
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "xmodel.h"
#include "xobj.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//-----------------------------------------------------------------------------
// Constructor and destructor
//-----------------------------------------------------------------------------
CXObject::CXObject()
{
    // clear out relevant fields

    m_Model = NULL;
    m_pXBMesh = NULL;

    SetPosition(0.0f, 0.0f, 0.0f);
    SetRotation(0.0f, 0.0f, 0.0f);
    D3DXMatrixIdentity(&m_matOrientation);
    m_Material = NULL;

    m_dwFlags = 0;
    m_dwType = 0;
    m_pvInfo = NULL;
}

CXObject::~CXObject()
{
    if(m_Model)
        m_Model->Release();
#ifdef _XBOX
    if(m_pXBMesh)
        m_pXBMesh->Release();
#endif
}

//-----------------------------------------------------------------------------
// Name: SetModel
// Desc: Set the model for this object.
//-----------------------------------------------------------------------------
void CXObject::SetModel(CXModel *model)
{
    if(m_Model)                         // release existing model
        m_Model->Release();
#ifdef _XBOX
    else if(m_pXBMesh)
    {
        m_pXBMesh->Release();
        m_pXBMesh = NULL;
    }
#endif

    if(model)
        model->AddRef();                // addref to new model
    m_Model = model;                    // set new model pointer
}


#ifdef _XBOX
//-----------------------------------------------------------------------------
// Name: SetXBG
// Desc: Set the XBMesh for this object.
//-----------------------------------------------------------------------------
void CXObject::SetXBMesh(CXBMesh *xbm)
{
    if(m_pXBMesh)
        m_pXBMesh->Release();
    else if(m_Model)
    {
        m_Model->Release();
        m_Model = NULL;
    }

    if(xbm)
        xbm->AddRef();                  // addref to new xbg
    m_pXBMesh = xbm;                    // set new model pointer
}
#endif

//-----------------------------------------------------------------------------
// Name: GetRadius functions
// Desc: Since objects can be either CXModel or CXBGMesh, we return a
//       radius based on which is active.
//-----------------------------------------------------------------------------
float CXObject::GetRadius()
{
    if(m_Model)
    {
        return m_Model->m_fRadius;
    }
    else if(m_pXBMesh)
    {
        return m_pXBMesh->ComputeRadius();
    }

    return 0.0f;
}

float CXObject::GetRadius2()
{
    if(m_Model)
    {
        return m_Model->m_fRadius2;
    }
    else if(m_pXBMesh)
    {
        float fRadius = m_pXBMesh->ComputeRadius();
        return fRadius*fRadius;
    }

    return 0.0f;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Calculate an objects matrix, set its relevant material, and
//       render its model.
//-----------------------------------------------------------------------------
void CXObject::Render(int flags)
{
    // set the position and orientation of the object
    if(!(flags&OBJ_NOMCALCS))
        CrunchMatrix();

    g_pd3dDevice->SetTransform(D3DTS_WORLD, &m_matOrientation);

    // set material
    if(m_Material)
        g_pd3dDevice->SetMaterial(m_Material);
    
    // render
#ifdef _XBOX
    if(m_Model)
        m_Model->Render();
    else if(m_pXBMesh)
        m_pXBMesh->Render(g_pd3dDevice, 0);
#else
    m_Model->Render();
#endif
}

//-----------------------------------------------------------------------------
// Name: CrunchMatrix
// Desc: Calculate an objects matrix.
//-----------------------------------------------------------------------------
void CXObject::CrunchMatrix()
{
    D3DXMATRIX m;

    D3DXMatrixRotationYawPitchRoll(&m_matOrientation, m_vRotation.y, m_vRotation.x, m_vRotation.z);
    D3DXMatrixTranslation(&m, m_vPosition.x, m_vPosition.y, m_vPosition.z);
    D3DXMatrixMultiply(&m_matOrientation, &m_matOrientation, &m);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xparse.cpp ===
//-----------------------------------------------------------------------------
// File: parse.cpp
//
// Desc: Routines to parse a string into distinct tokens.
//       Should probably be called tokenize...
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <string.h>
#include "xparse.h"

Token tokens[MAX_TOKENS];

//-----------------------------------------------------------------------------
// Name: ParseTok
// Desc: Parse a string into its relevant token from the Parse Block
//-----------------------------------------------------------------------------
int ParseTok(char *string, struct sParseBlk *pb)
{
	int idx;

	idx = 0;

	while(pb[idx].val!=TOK_ERR)
	{
		if(!_stricmp(string, pb[idx].str))
			return pb[idx].val;

		idx++;
	}

	return TOK_ERR;
}

//-----------------------------------------------------------------------------
// Name: Parse
// Desc: Generate distinct tokens from a string
//-----------------------------------------------------------------------------
int	Parse(char *string, struct sParseBlk *pb)
{
	int	i, ntok;
	char *sp, *tp;
	char parsestr[256];

	strncpy(parsestr, string, 256);
	parsestr[255] = '\0';
	_strupr(parsestr);
	sp = parsestr;

	ntok = 0;

	while ((*sp!=0) && (ntok<MAX_TOKENS) && (*sp!=';') && (*sp!='\n')) 
	{
		while(*sp==' ' || *sp=='\t')
			sp++;

		tp = tokens[ntok].str;
		while(  (*sp!=0) && (*sp!=' ') && (*sp!='\t') && 
				(*sp!=',') && (*sp!='\n') && (*sp!='(') &&
				(*sp!=')') && (*sp!=13) )
			*tp++ = *sp++;

		*tp = 0;
		ntok++;

		if(*sp)
			sp++;
	}

	// parse all the tokens
	if(pb)
		for(i=0; i<ntok; i++)
			tokens[i].val = ParseTok(tokens[i].str, pb);

	return ntok;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xpath.cpp ===
//-----------------------------------------------------------------------------
// File: xpath.cpp
//
// Desc: Routines to help us point to the right data files.
//
// Note: If you dont specify an out pointer in GetFileName, the routine
//       will use g_tstrXPathFileName[] to store the resulting file/path
//       info and return a pointer to it. The maximum number of these
//       that can exist at one time is defined by MAX_XPATHS.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif
#include <tchar.h>
#include "xpath.h"

#define MAX_XPATHS 4
DWORD g_dwXPathCurPathIdx = 0;
TCHAR g_tstrXPathBasePathT[MAX_PATH];
char g_tstrXPathBasePathA[MAX_PATH];
WORD g_tstrXPathFileName[MAX_XPATHS][MAX_PATH];

//-----------------------------------------------------------------------------
// Name: XPath_SetBasePath
// Desc: Set the base path for all our files
//-----------------------------------------------------------------------------
void XPath_SetBasePath(TCHAR *path)
{
	_tcsncpy(g_tstrXPathBasePathT, path, MAX_PATH);
	if(sizeof(TCHAR)==sizeof(WCHAR))
		WideCharToMultiByte(CP_ACP, 0, (WCHAR *)path, -1, g_tstrXPathBasePathA, MAX_PATH, NULL, NULL);
	else
		strncpy(g_tstrXPathBasePathA, (char *)path, MAX_PATH);
}

//-----------------------------------------------------------------------------
// Name: XPath_GetFileNameT
// Desc: TCHAR version of GetFileName
//-----------------------------------------------------------------------------
TCHAR *XPath_GetFileNameT(TCHAR *in, TCHAR *out)
{
	if(!out)
	{
		out = (TCHAR *)g_tstrXPathFileName[g_dwXPathCurPathIdx];
		g_dwXPathCurPathIdx = (g_dwXPathCurPathIdx+1)&(MAX_XPATHS-1);
	}

	_tcscpy(out, g_tstrXPathBasePathT);
	_tcscat(out, in);

	return out;
}

//-----------------------------------------------------------------------------
// Name: XPath_GetFileNameA
// Desc: char version of GetFileName
//-----------------------------------------------------------------------------
char *XPath_GetFileNameA(char *in, char *out)
{
	if(!out)
	{
		out = (char *)g_tstrXPathFileName[g_dwXPathCurPathIdx];
		g_dwXPathCurPathIdx = (g_dwXPathCurPathIdx+1)&(MAX_XPATHS-1);
	}

	strcpy(out, g_tstrXPathBasePathA);
	strcat(out, in);

	return out;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xtextbox.cpp ===
#include <xtl.h>
#include <assert.h>

#include "xtextbox.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

CXBFont *XTextBox_Font=NULL;
DWORD XTextBox_FontLoaded = FALSE;
void XTextBox_DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor);

void XTextBox_SetFont(CXBFont *font)
{
	XTextBox_Font = font;
}

XTextBox *XTextBox_Init(float x, float y, float w, DWORD maxitems, DWORD flags)
{
	XTextBox *xbox;		// pun intended
	BYTE *mem;

	assert(XTextBox_Font!=NULL);

	// bump maxitems for circular array padding
	maxitems++;

	// allocate memory for textbox
	mem = new BYTE[sizeof(XTextBox) + maxitems*sizeof(XTextBoxItem)];
	memset(mem, 0, sizeof(XTextBox) + maxitems*sizeof(XTextBoxItem));

	xbox = (XTextBox *)mem;
	xbox->items = (XTextBoxItem *)(mem+sizeof(XTextBox));
	xbox->flags = flags;

	xbox->maxitems = maxitems;
	xbox->maxshow = (maxitems-1);
	xbox->textcolor = 0xffffffff;

	xbox->topcolor = 0x40000000;
	xbox->bottomcolor = 0x40000000;

	xbox->x = x;
	xbox->y = y;
	xbox->w = w;
	xbox->h = (float)(xbox->maxshow+1)*XTextBox_Font->GetFontHeight();

	return xbox;
}

XTextBoxItem *XTextBox_AddItem(XTextBox *xbox, WCHAR *string)
{
	XTextBoxItem *item;

	if(!string)
		return NULL;

	// copy string to tail
	item = &xbox->items[xbox->tail];
	wcsncpy(item->string, string, TBOX_STRINGLEN-1);

	// set color
	item->color = xbox->textcolor;

	// set expire time
	item->expiretime = GetTickCount() + xbox->expiretime;
	
	// bump tail pointer
	xbox->tail++;
	if(xbox->tail==xbox->maxitems)
		xbox->tail = 0;

	// bump head if necessary
	if(xbox->head==xbox->tail)
	{
		xbox->head++;
		if(xbox->head==xbox->maxitems)
			xbox->head = 0;
	}

	// return pointer to the item we just added
	return item;
}

// Draw the textbox
// Only draw the background if it has color specified.
// If TBOX_POPUP is specified, only draw background if there is visible text.
void XTextBox_Display(XTextBox *xbox)
{
	DWORD idx, cnt=0;
	float itemx, itemy;

	// expire stale entries
	if(xbox->expiretime>0)
		XTextBox_Expire(xbox);

	// check for empty textbox and draw background if appropriate
	if(xbox->head==xbox->tail)
	{
		if(!(xbox->flags&TBOX_POPUP) && (xbox->topcolor!=0 && xbox->bottomcolor!=0))
			XTextBox_DrawRect(xbox->x, xbox->y, xbox->w, xbox->h, xbox->topcolor, xbox->bottomcolor);
		return;		// return if no items to display
	}
	else if(xbox->topcolor!=0 && xbox->bottomcolor!=0)
		XTextBox_DrawRect(xbox->x, xbox->y, xbox->w, xbox->h, xbox->topcolor, xbox->bottomcolor);

	// draw the text
	itemx = xbox->x + 8.0f;
	itemy = xbox->y + XTextBox_Font->GetFontHeight()*0.5f;

	idx = xbox->head;
	do
	{
		XTextBox_Font->DrawText(itemx, itemy, xbox->items[idx].color, xbox->items[idx].string);
		itemy += XTextBox_Font->GetFontHeight();
		
		// bump index & count
		idx++;
		if(idx==xbox->maxitems)
			idx = 0;
		cnt++;

	} while((idx!=xbox->tail) && (cnt<xbox->maxshow));
}

void XTextBox_Expire(XTextBox *xbox)
{
	DWORD time;

	if(xbox->head==xbox->tail)
		return;

	time = GetTickCount();

	while((time>xbox->items[xbox->head].expiretime) && (xbox->head!=xbox->tail))
	{
		xbox->head++;
		if(xbox->head==xbox->maxitems)
			xbox->head = 0;
	}
}

//-----------------------------------------------------------------------------
// Name: DrawRect
// Desc: Draws a gradient filled rectangle
//-----------------------------------------------------------------------------
void XTextBox_DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor)
{
    static LPDIRECT3DVERTEXBUFFER8 XMenu_VB = NULL;
    struct BACKGROUNDVERTEX 
    { 
        D3DXVECTOR4 p; 
        D3DCOLOR color; 
    } *v;

    if(XMenu_VB == NULL)
        g_pd3dDevice->CreateVertexBuffer(4*sizeof(BACKGROUNDVERTEX), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &XMenu_VB);

    // Setup vertices for a background-covering quad
    XMenu_VB->Lock(0, 0, (BYTE **)&v, 0L);
    v[0].p = D3DXVECTOR4(x  -0.5f, y  -0.5f, 1.0f, 1.0f);  v[0].color = dwTopColor;
    v[1].p = D3DXVECTOR4(x+w-0.5f, y  -0.5f, 1.0f, 1.0f);  v[1].color = dwTopColor;
    v[2].p = D3DXVECTOR4(x  -0.5f, y+h-0.5f, 1.0f, 1.0f);  v[2].color = dwBottomColor;
    v[3].p = D3DXVECTOR4(x+w-0.5f, y+h-0.5f, 1.0f, 1.0f);  v[3].color = dwBottomColor;
    XMenu_VB->Unlock();

    // set render states
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE); 
    g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);

    // Set states
    g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
    g_pd3dDevice->SetStreamSource(0, XMenu_VB, sizeof(BACKGROUNDVERTEX));

    // Render the quad
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// restore render state
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE); 
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\dsp\AmplitudeModulation\AmplitudeModulation.h ===
; **************************************************************************
;
; AmpMod.h    
;
; **************************************************************************        

; Low Level Data

    IF @DEF('STEREO')

DATASIZE_AMPMOD	equ	(DATASIZE_DSP_FX_STATE_3IN_2OUT)	

    ELSE

DATASIZE_AMPMOD	equ	(DATASIZE_DSP_FX_STATE_2IN_1OUT)	

    ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\dsp\AmplitudeModulation\AmplitudeModulation.asm ===
;***********************************************************************
;
; AmpMod.asm    Amplitude Modulation by Waveform-Selectable Oscillator
;
;***********************************************************************        

        IF @DEF('STANDALONE')
        include "util.h"
        ENDIF

	include 'AmplitudeModulation.h'


StartAmpMod 
        ; register r5 (rD) contains the base offset into x-ram, where the
        ; state variables for this effect reside. The macro below
        ; has a special intruction that must always be the very first one
        ; in the effect. This allows the xgpimage tool to do code fixup
        ; while creating the effect image and replace the r5 load with the actual
        ; xram offset this effect will use

        FXEntryPoint

ComputeFX

	bsr	ComputeAmpMod

        IF @DEF('STEREO')
        FXStereoComputeRightChannel
        ENDIF

        FXExit

;************************************************************
; ComputeAmpMod
;************************************************************
ComputeFXSubroutine
ComputeAmpMod
        ; r5 is loaded with xram offset 



        ; Add bias to oscillator signal before modulation
        ; r0 = audio input
        ; r1 = audio out
        ; r2 = oscillator output(3 input to this fx..)

        IF @DEF('STEREO')

        move    x:(rD+FX_STATE_FLAGS),x0       
        brset   #BIT_FX_STATE_FLAG_PROCESS_STEREO,x0,SETUP_RIGHT_CHANNEL

	move	x:(rD+FX_STATE_IO3_IN0),r0
	move	x:(rD+FX_STATE_IO3_OUT0),r1
        bra     ComputeAmpMod_StartLoop

SETUP_RIGHT_CHANNEL
	move	x:(rD+FX_STATE_IO3_IN1),r0
	move	x:(rD+FX_STATE_IO3_OUT1),r1
        ELSE
        ;
        ; mono case
        ;
	move	x:(rD+FX_STATE_IO2_IN0),r0
	move	x:(rD+FX_STATE_IO2_OUT0),r1
        move	x:(rD+FX_STATE_IO2_IN1),r2        

        ENDIF

ComputeAmpMod_StartLoop

        IF @DEF('STEREO')
	move	x:(rD+FX_STATE_IO3_IN2),r2        
        ENDIF

        dor      #>kFrameLength,ComputeAmpMod_Loop

        ; Shift oscillator output range from [-1..1] to [0..1]
	move	x:(r2)+,a
	asr	#1,a,a
	add	#>0.5,a
	move	a,x0

        ; Modulate input signal using oscillator value
	move	x:(r0)+,y0
	mpy	x0,y0,a

        ; check if we need to mix our result with the existing
        ; data on the output. All effect must support this
        ; if the plan to have spekaer mixbins as output targets

        move    x:(rD+FX_STATE_FLAGS),x1       
        brclr   #BIT_FX_STATE_FLAG_GLOBAL_FX,x1,STOMP_OUTPUT
        move	x:(r1),x0
        add     x0,a            ; mix result to audio Output 
STOMP_OUTPUT
	move	a,x:(r1)+

ComputeAmpMod_Loop
        nop
        rts

        ; this is here once again for XGPIMAGE.EXE use. Effect dont use any
        ; branching but instead exectuion just flows from one effect to the next
        ; during each audio frame. the FXExit macro in the first section of this effect
        ; will alwasy branch to FX_END after the compute routine returns
FX_END
        nop
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\common\src\xshadow.cpp ===
#include "xshadow.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

#define MAX_SHADOWTRIS 32767

// full screen shadow poly
FVFT_XYZRHWDIFF shadowpoly[4] =
{
	{ 0.0f, 0.0f, 0.0f, 1.0f, 0x3f000000 },
	{ 0.0f, 0.0f, 0.0f, 1.0f, 0x3f000000 },
	{ 0.0f, 0.0f, 0.0f, 1.0f, 0x3f000000 },
	{ 0.0f, 0.0f, 0.0f, 1.0f, 0x3f000000 }
};

CXShadowVolume::CXShadowVolume(float w, float h)
{
	memset(this, 0, sizeof(CXShadowVolume));
	m_fWidth = w;
	m_fHeight = h;
}

CXShadowVolume::~CXShadowVolume()
{
}

//
// shadow volume code
//
void CXShadowVolume::AddEdge(DWORD *edgelist, WORD v0, WORD v1)
{
	DWORD i, key;

	if(v0<v1)
		key = (v0<<16)|v1;
	else
		key = (v1<<16)|v0;

	// remove duplicate edges from list		
	for(i=0; i<m_dwNumEdges; i++)
		if(edgelist[i*3]==key)
		{
			m_dwNumEdges--;
			edgelist[i*3+0] = edgelist[3*m_dwNumEdges+0];
			edgelist[i*3+1] = edgelist[3*m_dwNumEdges+1];
			edgelist[i*3+2] = edgelist[3*m_dwNumEdges+2];
			return;
		}

	// no dup found, add this edge
	if(v0<v1)
		edgelist[m_dwNumEdges*3] = (v0<<16)|v1;
	else
		edgelist[m_dwNumEdges*3] = (v1<<16)|v0;

	edgelist[m_dwNumEdges*3+1] = (DWORD)v0;
	edgelist[m_dwNumEdges*3+2] = (DWORD)v1;
	m_dwNumEdges++;
}

void CXShadowVolume::AddObj(CXObject *obj, D3DXVECTOR3 *lightpos)
{
	DWORD *edgelist;
	D3DXMATRIX im;									// inverse matrix
	D3DXVECTOR4 lpos;								// light position
	BYTE *vptr, *iptr;								// vertex/index pointer
	WORD *tris;										// trilist pointer
	DWORD stride, i, nsi, fvf;
	WORD i0, i1, i2, nsvert;
	D3DXVECTOR3 v, v0, v1, v2;
	D3DXVECTOR3 norm, e0, e1;

	// allocate memory for edge list
	edgelist = new DWORD[2*MAX_SHADOWTRIS];

	// calculate inverse matrix (->object space)
	D3DXMatrixInverse(&im, NULL, (D3DXMATRIX *)&obj->m_matOrientation);

	// transform light into object space
	D3DXVec3Transform(&lpos, lightpos, &im);

	// get object info
	obj->m_Model->LockVB(&vptr, 0);
	obj->m_Model->LockIB(&iptr, 0);
	tris = (WORD *)iptr;
	fvf = obj->m_Model->m_dwFVF;
	stride = FVF_VSize(fvf);		// get vertex size

	// add edges
	m_dwNumEdges = 0;
	for(i=0; i<obj->m_Model->m_dwNumTriangles; i++)
	{
		i0 = tris[i*3+0];
		i1 = tris[i*3+1];
		i2 = tris[i*3+2];

		v0 = *((D3DXVECTOR3 *)(vptr + stride*i0));
		v1 = *((D3DXVECTOR3 *)(vptr + stride*i1));
		v2 = *((D3DXVECTOR3 *)(vptr + stride*i2));

		// calc tri normal
		D3DXVec3Cross(&norm, &(v2-v1), &(v1-v0));
		D3DXVec3Normalize(&norm, &norm);

		// dot light vector with tri norm to see if 
		// triangle faces the light
		v.x = lpos.x - v0.x;		// light-vert
		v.y = lpos.y - v0.y;
		v.z = lpos.z - v0.z;

		if(D3DXVec3Dot(&norm, &v)>0.0f)
		{
			AddEdge(edgelist, i0, i1);
			AddEdge(edgelist, i1, i2);
			AddEdge(edgelist, i2, i0);
		}
	}

	// allocate shadowvolume object
	if(m_Vert)
		delete m_Vert;
	if(m_Tris)
		delete m_Tris;

	m_Vert = new FVFT_XYZDIFF[m_dwNumEdges*4];			// allocate vertex memory
	stride = FVF_VSize(FVF_XYZDIFF);
	m_Tris = new WORD[m_dwNumEdges*6];					// allocate triangle memory

	m_dwNumTriangles = m_dwNumEdges*2;
	m_dwNumVertices = m_dwNumEdges*4;
	m_Matrix = obj->m_matOrientation;

	// extrude edges
	nsvert = 0;
	nsi = 0;
	for(i=0; i<m_dwNumEdges; i++)
	{
		FVF_GetVert(vptr, &e0, edgelist[i*3+1], 1, fvf);
		FVF_GetVert(vptr, &e1, edgelist[i*3+2], 1, fvf);

		m_Tris[nsi++] = nsvert+0;
		m_Tris[nsi++] = nsvert+1;
		m_Tris[nsi++] = nsvert+2;
		m_Tris[nsi++] = nsvert+1;
		m_Tris[nsi++] = nsvert+3;
		m_Tris[nsi++] = nsvert+2;

		// e0
		m_Vert[nsvert].v.x = e0.x;
		m_Vert[nsvert].v.y = e0.y;
		m_Vert[nsvert++].v.z = e0.z;

		// e1
		m_Vert[nsvert].v.x = e1.x;
		m_Vert[nsvert].v.y = e1.y;
		m_Vert[nsvert++].v.z = e1.z;

		// e2
		m_Vert[nsvert].v.x = 20*(e0.x - lpos.x);
		m_Vert[nsvert].v.y = 20*(e0.y - lpos.y);
		m_Vert[nsvert++].v.z = 20*(e0.z - lpos.z);

		// e3
		m_Vert[nsvert].v.x = 20*(e1.x - lpos.x);
		m_Vert[nsvert].v.y = 20*(e1.y - lpos.y);
		m_Vert[nsvert++].v.z = 20*(e1.z - lpos.z);
	}

	obj->m_Model->UnlockVB();
	obj->m_Model->UnlockIB();

	delete edgelist;
}

void CXShadowVolume::Render()
{
	shadowpoly[0].v.y = m_fHeight;
	shadowpoly[2].v.x = m_fWidth;
	shadowpoly[2].v.y = m_fHeight;
	shadowpoly[3].v.x = m_fWidth;

	// set up for shadow volume render
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);		// disable writes, tests still occur
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, TRUE);		// enable stencil buffer
	g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);	// dont interpolate colors
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);	// stencil test always passes
																	// dont need fail setup since always passes
	g_pd3dDevice->SetRenderState(D3DRS_STENCILREF, 0x1);			// bump stencil count for each pixel
	g_pd3dDevice->SetRenderState(D3DRS_STENCILMASK, 0Xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILWRITEMASK, 0Xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_INCR);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);		// dont draw any pixels
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

	// draw fronts w/ stencil increment
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetTransform(D3DTS_WORLD, &m_Matrix);

	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_INCR);
	g_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_dwNumVertices, m_dwNumTriangles, m_Tris,
							D3DFMT_INDEX16, m_Vert, sizeof(FVFT_XYZDIFF));

	// draw rears with stencil decrement
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_DECR);
	g_pd3dDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_dwNumVertices, m_dwNumTriangles, m_Tris,
							D3DFMT_INDEX16, m_Vert, sizeof(FVFT_XYZDIFF));

	// attenuate pixels in stencil region (shadow)
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);				// no zbuffer
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, TRUE);		// uses stencil compare
	g_pd3dDevice->SetRenderState(D3DRS_STENCILREF, 0X1);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_LESSEQUAL); // <= 1
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);

	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

	g_pd3dDevice->SetVertexShader(FVF_XYZRHWDIFF);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, shadowpoly, sizeof(FVFT_XYZRHWDIFF));

	// reset render state
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AlphaFog\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AlphaFog\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\dsp\include\util.h ===
;**************************************************************************
;
;  Util.h - Useful includes and defines for DSP programming
;
;**************************************************************************        

	include 'Io.h'

	define rD 	  'r5'		; Standard data structure register
	define rStack 'r6'		; Stack pointer register

kGPMemory_Base_BootROM			equ $FF0000	; X-memory, 128 words
;kGPMemory_Base_PeripheralRegisters	equ $FFFF80	; X-memory, to 0xFFFFFF

INTERRUPT_TABLE_BASE 		equ $FF0000

; VBA at $FF0000 (requires 256 word alignment).  
; The vector table is exactly where the power-up reset starts fetching instructions.
; The first interrupt vector is hardware RESET.
; Only needs up to $24 (36d) .. $44 (68d) interrupts or so, not full 256 word table.

INTERRUPT_REGISTER		equ $FFFFC5	; Interrupt request/clear register
kAbortFrameBit		equ		0			; Bit 0
kStartFrameBit		equ		1			
kPutUpdateBit		equ		2
kMailInUpdateBit	equ		3
kDMAComplete1Bit	equ		4
kDMAComplete2Bit	equ		5
kDMAComplete3Bit	equ		6	
kDMAEndOfListBit	equ		7
kTimer1Bit			equ		8
kTimer2Bit			equ		9
kDMAErrorBit		equ		10
kAddressErrorBit	equ		11

; ==============================================================
;  MailBox Register stuff  
; ==============================================================
MAILBOX_OUT_REGISTER	equ $FFFFC2	; For DSP->Host messages
MAILBOX_IN_REGISTER		equ $FFFFC3	; For DSP<-Host messages

; ==============================================================
;  FIFO stuff  
; ==============================================================
FIFOOUT_CONTROL_REGISTER	equ		$FFFFC8
FIFOIN_CONTROL_REGISTER		equ		$FFFFC9
SAMPLE_CONTROL_REGISTER		equ		$FFFFCA

; Current Value is bits 23:2  (22 bits)	(from dev_apu.ref)
;NV_PAPU_GPOFCUR0  equ	$0000302C 
;NV_PAPU_GPOFCUR1  equ	$0000303C 
;NV_PAPU_GPOFCUR2  equ	$0000304C 
;NV_PAPU_GPOFCUR3  equ	$0000305C 

; End Value is bits 23:8  (16 bits) (from dev_apu.ref)
;NV_PAPU_GPOFEND0  equ	$00003028 
;NV_PAPU_GPOFEND1  equ	$00003038 
;NV_PAPU_GPOFEND2  equ	$00003048 
;NV_PAPU_GPOFEND3  equ	$00003058 

; Base Value is bits 23:8 (16 bits) (from dev_apu.ref)
;NV_PAPU_GPOFBASE0  equ	$00003024 
;NV_PAPU_GPOFBASE1  equ	$00003034 
;NV_PAPU_GPOFBASE2  equ	$00003044 
;NV_PAPU_GPOFBASE3  equ	$00003054 

; ==============================================================
;  Headroom/Valid stuff		Bits 23:4 Zero, Bit 3=Valid, Bits 2:0=Headroom, # right shifts
; ==============================================================
HEADROOM_VALID_REGISTER00	equ		$FFFF90
HEADROOM_VALID_REGISTER01	equ		$FFFF91
HEADROOM_VALID_REGISTER02	equ		$FFFF92
HEADROOM_VALID_REGISTER03	equ		$FFFF93
HEADROOM_VALID_REGISTER04	equ		$FFFF94
HEADROOM_VALID_REGISTER05	equ		$FFFF95
HEADROOM_VALID_REGISTER06	equ		$FFFF96
HEADROOM_VALID_REGISTER07	equ		$FFFF97

HEADROOM_VALID_REGISTER08	equ		$FFFF98
HEADROOM_VALID_REGISTER09	equ		$FFFF99
HEADROOM_VALID_REGISTER10	equ		$FFFF9A
HEADROOM_VALID_REGISTER11	equ		$FFFF9B
HEADROOM_VALID_REGISTER12	equ		$FFFF9C
HEADROOM_VALID_REGISTER13	equ		$FFFF9D
HEADROOM_VALID_REGISTER14	equ		$FFFF9E
HEADROOM_VALID_REGISTER15	equ		$FFFF9F

HEADROOM_VALID_REGISTER16	equ		$FFFFA0
HEADROOM_VALID_REGISTER17	equ		$FFFFA1
HEADROOM_VALID_REGISTER18	equ		$FFFFA2
HEADROOM_VALID_REGISTER19	equ		$FFFFA3
HEADROOM_VALID_REGISTER20	equ		$FFFFA4
HEADROOM_VALID_REGISTER21	equ		$FFFFA5
HEADROOM_VALID_REGISTER22	equ		$FFFFA6
HEADROOM_VALID_REGISTER23	equ		$FFFFA7

HEADROOM_VALID_REGISTER24	equ		$FFFFA8
HEADROOM_VALID_REGISTER25	equ		$FFFFA9
HEADROOM_VALID_REGISTER26	equ		$FFFFAA
HEADROOM_VALID_REGISTER27	equ		$FFFFAB
HEADROOM_VALID_REGISTER28	equ		$FFFFAC
HEADROOM_VALID_REGISTER29	equ		$FFFFAD
HEADROOM_VALID_REGISTER30	equ		$FFFFAE
HEADROOM_VALID_REGISTER31	equ		$FFFFAF

; ==============================================================
;  Timer stuff	
; ==============================================================
TIMER1_CONFIGURATION_REGISTER	equ	$FFFFB0
TIMER1_CONTROL_REGISTER			equ	$FFFFB1
TIMER1_TERMINAL_COUNT_REGISTER	equ	$FFFFB2
TIMER1_COUNT_REGISTER			equ	$FFFFB3
TIMER2_CONFIGURATION_REGISTER	equ	$FFFFB4
TIMER2_CONTROL_REGISTER			equ	$FFFFB5
TIMER2_TERMINAL_COUNT_REGISTER	equ	$FFFFB6
TIMER2_COUNT_REGISTER			equ	$FFFFB7

; ==============================================================
;  Command stuff		Bits 11:2  offset in 4KB circular buffer
; ==============================================================
kGPMemory_Base_CommandCue		equ $FFF000		; Top 4KByte page

COMMAND_GET_REGISTER 		equ $FFFFC0	; Ptr to next read location
COMMAND_PUT_REGISTER 		equ $FFFFC1	; Ptr to 1st empty write location

; ==============================================================
;  Processing control
; ==============================================================
PROCESSING_CONTROL_REGISTER		equ $FFFFC4	
kProcessingControl_SetIdleBit				equ 0		; Bit 0
kProcessingControl_NotifyInterruptBit		equ 1		

; ==============================================================
;  Global Sample Count Register		Bits 23:0
; ==============================================================
GLOBAL_SAMPLE_COUNT_REGISTER		equ $FFFFC6	

k2To7			set		     128.0
k2To8			set		     256.0
k2To15			set		   32768.0
k2To16			set		   65536.0
k2To22			set		 (64.0*k2To16)
k2To23			set		(128.0*k2To16)
k2To24			set		(256.0*k2To16)
k2To31			set		(128.0*k2To24)
k2To32			set		(256.0*k2To24)

k2To15m1		set		 (k2To15-1.0)
k2To16m1		set		 (k2To16-1.0)
k2To23m1		set		 (k2To23-1.0)
k2To24m1		set		 (k2To24-1.0)
k24Normalizer	set		 (k2To23)

Fs			set     48000.0     ; Sampling frequency
SamplingFrequency	set     48000.0              
SamplingPeriod		set     1.0/48000.0              
NormalSamplingFrequency	set     (48000.0/k2To23)              

kFs					equ     48000     
kSamplingFrequency	EQU     kFs              

PI				set     2.0*@asn(1.0)                   
kPi				set     PI                   
kTwoPi			set     2.0*kPi                   
kHalfPi			set     (kPi/2.0)                 
kQuarterPi		set     (kPi/4.0)                   

kDegreeToRadian  set     kPi/180.0   
kDegreeToPi      set	(1.0/180.0)   

kPiOverFs		set		(kPi/Fs)
kTwoPiOverFs	set		(kTwoPi/Fs)

kLog10_2	set 0.3010299956639812
kLog2_10	set (1.0/kLog10_2)	; 1/log2(10) = log10(2)

kLogE_2	    set	0.69314718055994529
kLn_2		set kLogE_2

kLog2_E		set (1.0/kLogE_2)		;  1/logE( 2) = log2(E)

;  FIXXX: go back and get the real numbers !!!
kDetuneRatio_p01CentFraction	set		0.0005777895

kDetuneRatio_m18Cents	set		0.9896566564
kDetuneRatio_m16Cents	set		0.9908006133
kDetuneRatio_m14Cents	set		0.9919458924
kDetuneRatio_m12Cents	set		0.9930924954
kDetuneRatio_m10Cents	set		0.9942404238
kDetuneRatio_m08Cents	set		0.9953896791
kDetuneRatio_m06Cents	set		0.9965402628
kDetuneRatio_m04Cents	set		0.9976921765
kDetuneRatio_m02Cents	set		0.9988454217
kDetuneRatio_m01Cents	set		0.9994225441
kDetuneRatio_m00Cents	set		1.0
kDetuneRatio_p00Cents	set		1.0
kDetuneRatio_p01Cents	set		(1.0+1.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p02Cents	set		(1.0+2.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p03Cents	set		(1.0+3.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p04Cents	set		(1.0+4.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p05Cents	set		(1.0+5.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p06Cents	set		(1.0+6.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p07Cents	set		(1.0+7.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p08Cents	set		(1.0+8.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p09Cents	set		(1.0+9.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p10Cents	set		(1.0+10.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p11Cents	set		(1.0+11.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p12Cents	set		(1.0+12.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p13Cents	set		(1.0+13.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p14Cents	set		(1.0+14.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p15Cents	set		(1.0+15.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p16Cents	set		(1.0+16.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p17Cents	set		(1.0+17.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p18Cents	set		(1.0+18.0*kDetuneRatio_p01CentFraction)

kTuneRatio_p01SemitoneFraction set 0.0594630944
kTuneRatio_p01Semitones	set 1.0594630944
kTuneRatio_p02Semitones	set 1.1224620483
kTuneRatio_p03Semitones	set	1.1892071150
kTuneRatio_p04Semitones	set	1.2599210499
kTuneRatio_p05Semitones	set	1.3348398542
kTuneRatio_p06Semitones	set	1.4142135624
kTuneRatio_p07Semitones	set	1.4983070769
kTuneRatio_p08Semitones	set	1.5874019520
kTuneRatio_p09Semitones	set	1.6817928305
kTuneRatio_p10Semitones	set	1.7817974363
kTuneRatio_p11Semitones	set	1.8877486254
kTuneRatio_p12Semitones	set	2.0

kTmpBufSize equ		1024
kTmpBufMask set		(kTmpBufSize-1)

kMixBufSize equ		32

;************************************************************
; Bound	
;************************************************************
Bound macro
Bound_IsABigger
	cmp		x0,a		; a - x
	ble		Bound_IsASmaller
	move	x0,a
	bra		Bound_AOk
Bound_IsASmaller
	cmp		y0,a		; a - y
	jge		Bound_AOk
	move	y0,a
Bound_AOk
	move	a,r1
	endm

;************************************************************
; Ceiling	
;************************************************************
Ceiling macro
Ceiling_IsABigger
	cmp		x0,a		; a - x
	ble		Ceiling_Bound_AOk
	move	x0,a
Ceiling_Bound_AOk
	move	a,r1
	endm

;************************************************************
; Wrap	
;************************************************************
Wrap macro
Wrap_IsABigger
	cmp		x0,a		; a - x0
	ble		Wrap_IsASmaller
	move	x0,a
	bra		Wrap_AOk
Wrap_IsASmaller
	cmp		y0,a		; a - y0
	jge		Wrap_AOk
	move	y0,a
Wrap_AOk
	move	a,r1
	endm

;************************************************************
; ClearBufferX_R0X0	Clear buffer at address	x:(r0) of length X0
;************************************************************
ClearBufferX_R0X0	macro
	clr		a
	rep		x0
	move	a,x:(r0)+
					endm

;************************************************************
; ClearBufferY_R0X0	Clear buffer at address	y:(r0) of length X0
;************************************************************
ClearBufferY_R0X0	macro
	clr		a
	rep		x0
	move	a,y:(r0)+
					endm

;************************************************************
; GPAddX	Add frames in XRAM
;			b = a + b	
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;************************************************************

GPAddX  macro
    dor      #kFrameLength,GPAddX_Loop             
	move	x:(r0)+,x0
	move	x:(r1),a
	add	x0,a
	move	a,x:(r1)+
GPAddX_Loop
 	endm
; ---- end GPAddX ----

;************************************************************
; GPAddY	Add frames in YRAM	
;			c = a + b
;
;			r0	a YRAM Buffer address
;                       r1	b YRAM Buffer address
;                       r2	c YRAM Buffer address
;************************************************************
GPAddY  macro
    dor      #kFrameLength,GPAddY_Loop             
	move	y:(r0)+,x0
	move	y:(r1)+,a
	add	x0,a
	move	a,y:(r2)+
GPAddY_Loop
 	endm
; ---- end GPAddY ----

;************************************************************
; GPScaleXAddtoY	Scale frames in XRAM then add them to
; in Y ram
;			y:(r4) = x:(r0)*x1+y:(r4)
;
;			r0	XRAM Buffer address
;           r4	YRAM Buffer address
;           x1  scaling
;************************************************************
GPScaleXAddToY macro
	move	x:(r0)+,x0
              
    dor     #kFrameLength,GPScaleXAddToY_Loop             
	mpy     x1,x0,a  x:(r0)+,x0  y:(r4),y0
    add     y0,a
	move	a,y:(r4)+
GPScaleXAddToY_Loop
 	endm

;************************************************************
; GPScaleXtoY	Scale frames in XRAM then then put
; in Y ram
;			y:(r4) = x:(r0)*x1
;
;			r0	XRAM Buffer address
;           r1	YRAM Buffer address
;           x1  scaling
;************************************************************
GPScaleXToY macro
	move	x:(r0)+,x0

    dor     #kFrameLength,GPScaleXToY_Loop             
	mpy     x1,x0,a  x:(r0)+,x0 
	move	a,y:(r1)+
GPScaleXToY_Loop
 	endm

;************************************************************
; GPScaleYAddXtoX	Add frames in YRAM	to X ram then put
; in X ram
;			x:(r2) = y:(r0)*x0 + x:(r1)
;
;			r0	a YRAM Buffer address
;           r1	b XRAM Buffer address
;           r2	c XRAM Buffer address
;           x1  scaling
;************************************************************
GPScaleYAddXToX macro
	move	y:(r4)+,y0

    dor     #kFrameLength,GPScaleYAddXToX_Loop             
	mpy     x1,y0,a  x:(r1)+,x0  y:(r4)+,y0
    add     x0,a
	move	a,y:(r2)+
GPScaleYAddXToX_Loop
 	endm
; ---- end ----

;************************************************************
; GPScaleXAddX	Add frames in XRAM	to X ram then put
; in X ram
;			x:(r1) = x:(r0)*x1 + x:(r1)
;
;			r0	a XRAM Buffer address
;           r1	b XRAM Buffer address
;           r2	c XRAM Buffer address
;           x1  scaling
;************************************************************
GPScaleXAddX macro
	move	x:(r0)+,x0

    dor     #kFrameLength,GPScaleXAddX_Loop             
	mpy     x1,x0,a  x:(r0)+,x0 
    move    x:(r1),y0
    add     y0,a
	move	a,x:(r1)+

GPScaleXAddX_Loop
 	endm
; ---- end GPAddY ----



;************************************************************
; GPAverageX	Average frames in XRAM
;			c = (a+b)/2
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;                       r2	c XRAM Buffer address
;************************************************************
GPAverageX macro
    dor      #kFrameLength,GPAverageX_Loop             
	move	x:(r0)+,a
	move	x:(r1)+,x0
	add	x0,a
	asr	#1,a,a
	move	a,x:(r2)+
GPAverageX_Loop
 	endm
; ---- end GPAverageX ----

;************************************************************
; GPDiffX	Take difference frames in XRAM
;			c = (a-b)/2
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;                       r2	c XRAM Buffer address
;************************************************************
GPDiffX macro
    dor      #kFrameLength,GPDiffX_Loop             
	move	x:(r0)+,a
	move	x:(r1)+,x0
	sub	x0,a
	asr	#1,a,a
	move	a,x:(r2)+
GPDiffX_Loop
 	endm
; ---- end GPDiffX ----

;************************************************************
; GPAccY	Accumulate frames in YRAM
;			b += a
;
;			r0	a YRAM Buffer address
;                       r1	b YRAM Buffer address
;************************************************************
GPAccY  macro
    dor      #kFrameLength,GPAccY_Loop             
	move	y:(r0)+,x0
	move	y:(r1),a
	add	x0,a
	move	a,y:(r1)+
GPAccY_Loop
 	endm
; ---- end GPAccY ----

;************************************************************
; GPAccXtoY	Accumulate XRAM frame to YRAM
;			ax += by
;
;			r0	a XRAM Buffer address
;                       r1	b YRAM Buffer address
;************************************************************
GPAccXtoY macro
    dor      #kFrameLength,GPAccXtoY_Loop             
	move	x:(r0)+,x0
	move	y:(r1),a
	add	x0,a
	move	a,y:(r1)+
GPAccXtoY_Loop
 	endm
; ---- end GPAccYtoX ----

;************************************************************
; GPAccYtoX	Accumulate YRAM frame to XRAM
;			ax += by
;
;			r0	a YRAM Buffer address
;                       r1	b XRAM Buffer address
;************************************************************
GPAccYtoX macro
    dor      #kFrameLength,GPAccYtoX_Loop             
	move	y:(r0)+,x0
	move	x:(r1),a
	add	x0,a
	move	a,x:(r1)+
GPAccYtoX_Loop
 	endm
; ---- end GPAccYtoX ----

;************************************************************
; GPScaleX	Scale frame in XRAM	
;			b = k*a
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;			x0	k scale factor
;************************************************************
GPScaleX macro
    dor      #kFrameLength,GPScaleX_Loop             
	move	x:(r0)+,y0
	mpy	x0,y0,a
	move	a,x:(r1)+
GPScaleX_Loop
 	endm
; ---- end GPScaleX ----

;************************************************************
; GPScaleY	Scale frame in YRAM
;			b = k*a
;
;			r0	a YRAM Buffer address
;                       r1	b YRAM Buffer address
;			x0	k scale factor
;************************************************************
GPScaleY macro
    dor      #kFrameLength,GPScaleY_Loop             
	move	y:(r0)+,y0
	mpy	x0,y0,a
	move	a,y:(r1)+
GPScaleY_Loop
 	endm
; ---- end GPScaleY ----

;************************************************************
; GPMacX	Multiply-accumulate frame in XRAM
;			b += k*a
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;			x0	k scale factor
;************************************************************
GPMacX  macro
    dor      #kFrameLength,GPMacX_Loop             
	move	x:(r0)+,y0
	move	x:(r1),a
	mac	x0,y0,a
	move	a,x:(r1)+
GPMacX_Loop
 	endm
; ---- end GPMacX ----
	
;************************************************************
; GPMacY	Multiply-accumulate frame in YRAM
;			b += k*a
;
;			r0	a YRAM Buffer address
;                       r1	b YRAM Buffer address
;			x0	k scale factor
;************************************************************
GPMacY  macro
    dor      #kFrameLength,GPMacY_Loop             
	move	x:(r0)+,y0
	move	x:(r1),a
	mac	x0,y0,a
	move	a,x:(r1)+
GPMacY_Loop
 	endm
; ---- end GPMacY ----
		  
;************************************************************
; GPMSubX	Multiply-subtract frame in XRAM
;			b -= k*a
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;			x0	k scale factor
;************************************************************
GPMSubX macro
    dor      #kFrameLength,GPMSubX_Loop             
	move	x:(r0)+,y0
	move	x:(r1),a
	mac	-x0,y0,a
	move	a,x:(r1)+
GPMSubX_Loop
 	endm
; ---- end GPMSubX ----

;************************************************************
; GPSubX	Subtract frame in XRAM
;			c = a - b	
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;                       r2	c XRAM Buffer address
;************************************************************
GPSubX  macro
    dor      #kFrameLength,GPSubX_Loop             
	move	x:(r0)+,x0
	move	x:(r1)+,a
	sub	x0,a
	move	a,x:(r2)+
GPSubX_Loop
 	endm
; ---- end GPSubX ----

;************************************************************
; GPClrX	Fill X-RAM frame with zeros
;
;			r0	XRAM Buffer address
;************************************************************
GPClrX  macro
	clr	a
    dor      #kFrameLength,GPClrX_Loop             
	move	a,x:(r0)+
GPClrX_Loop
 	endm
; ---- end GPClrX ----

;************************************************************
; GPClrY	Fill Y-RAM frame with zeros
;
;			r0	YRAM Buffer address
;************************************************************
GPClrY  macro
	clr	a
    dor      #kFrameLength,GPClrY_Loop             
	move	a,y:(r0)+
GPClrY_Loop
 	endm
; ---- end GPClrY ----

;************************************************************
; GPSetX	Fill X-RAM frame with constant
;
;			r0	XRAM Buffer address
;			x0	fill value
;************************************************************
GPSetX  macro
    dor      #kFrameLength,GPSetX_Loop             
	move	x0,x:(r0)+
GPSetX_Loop
 	endm
; ---- end GPSetX ----

;************************************************************
; GPSetY	Fill Y-RAM frame with constant
;
;			r0	YRAM Buffer address
;			x0	fill value
;************************************************************
GPSetY  macro
    dor      #kFrameLength,GPSetY_Loop             
	move	x0,y:(r0)+
GPSetY_Loop
 	endm
; ---- end GPSetY ----

GPCopyXtoXRAM macro
    dor      #kFrameLength,GPCopyXtoXRAM_Loop             
	move	x:(r0)+,x0
	move	x0,x:(r1)+
GPCopyXtoXRAM_Loop
 	endm
			
GPCopyXtoYRAM macro
    dor      #kFrameLength,GPCopyXtoYRAM_Loop             
	move	x:(r0)+,x0     
	move	x0,y:(r1)+
GPCopyXtoYRAM_Loop
 	endm

GPCopyYtoXRAM macro
    dor      #kFrameLength,GPCopyYtoXRAM_Loop             
	move	y:(r0)+,y0     
	move	y0,x:(r1)+
GPCopyYtoXRAM_Loop
 	endm


;************************************************************
; GPClearInterruptRegister	Clear  GP register
;************************************************************
GPClearInterruptRegister macro
      	movep    #$FFF,x:INTERRUPT_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end GPClearInterruptRegister ----

;************************************************************
; GPClearProcessingControlRegister	Clear  GP register
;************************************************************
GPClearProcessingControlRegister macro
      	movep    #$1,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"	
	endm
; ---- end GPClearProcessingControlRegister ----

;************************************************************
; GPClearSampleControlRegister	Clear  GP register
;************************************************************
GPClearSampleControlRegister macro
      	movep    #$0,x:SAMPLE_CONTROL_REGISTER	 
	endm
; ---- end GPClearSampleControlRegister ----

;************************************************************
; GPSetIdleBit		Assert GP Idle signal (Bit 0)
;************************************************************
GPSetIdleBit macro
	movep    #1,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end GPSetIdleBit ----

;************************************************************
; GPClearStartFrameBit		Start Frame (Bit 1)
;************************************************************
GPClearStartFrameBit macro
	movep    #2,x:INTERRUPT_REGISTER  ; "Write-1-To-Clear-One"	
	endm
; ---- end GPClearStartFrameBit ----

;**************************************************************
; entry point standard code for avoiding re-init on every frame
;**************************************************************

FXEntryPoint macro
    IF @DEF('STANDALONE')
    move #>$40,rD
    ENDIF        
    move    x:(rD+FX_STATE_FLAGS),x0
    brset   #BIT_FX_STATE_FLAG_INITIALIZED,x0,ComputeFX               
InitFX
    bset    #BIT_FX_STATE_FLAG_INITIALIZED,x0
    move    x0,x:(rD+FX_STATE_FLAGS)
    endm


;**************************************************************
; entry point standard code assuming no init
;**************************************************************

FXEntryPointNoInit macro
    IF @DEF('STANDALONE')
    move #>$40,rD
    ENDIF        
    endm
    
;**************************************************************
; exit point standard code
;**************************************************************

FXExit macro
    IF @DEF('STANDALONE')
    bra     FX_END  
    ELSE
    rts   
    ENDIF
    endm

;**************************************************************
; macro for computing right channel, by invoking compute routine
; a second time
;**************************************************************


FXStereoComputeRightChannel macro

    ;
    ; stereo processing. set a flag telling the FX
    ; to process the right channel, call compute routine again
    ;

    move    x:(rD+FX_STATE_FLAGS),x0
    bset    #BIT_FX_STATE_FLAG_PROCESS_STEREO,x0
    move    x0,x:(rD+FX_STATE_FLAGS)           

    bsr	ComputeFXSubroutine

    ;
    ; restore flags
    ;

    move    x:(rD+FX_STATE_FLAGS),x0
    bclr    #BIT_FX_STATE_FLAG_PROCESS_STEREO,x0
    move    x0,x:(rD+FX_STATE_FLAGS)
    endm


;**************************************************************
;
; set arithmetic saturation, x0 gets clobbered
;
;**************************************************************

FXSetSMMode macro
        movec   sr,x0            ; Set arithmetic saturation 
        bset    #20,x0
        movec   x0,sr
        endm

;**************************************************************
;
; unset arithmetic saturation, x0 gets clobbered
;
;**************************************************************

FXUnsetSMMode macro
        movec   sr,x0            ; Set arithmetic saturation 
        bclr    #20,x0
        movec   x0,sr
        endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AlphaFog\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AlphaFog\AlphaFog.cpp ===
//-----------------------------------------------------------------------------
// File: AlphaFog.cpp
//
// Desc: Example code showing how to do a type fogging that varies the alpha
//		 value of far away objects. This is useful in scene-culling techniques
//		 to avoid the visible "pop" that occurs when far-away objects (like
//		 trees and buildings) get added to a scene.
//
// Hist: 06.07.01 - New for XFest June, 2001
//		 09.12.01 - Adding to XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <XBResource.h>
#include "Resource.h"


//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
	{ "Seafloor.bmp", Resource_Seafloor_OFFSET },
	{ "SkyBoxXP.bmp", Resource_SkyBoxXP_OFFSET },
	{ "SkyBoxXN.bmp", Resource_SkyBoxXN_OFFSET },
	{ "SkyBoxYP.bmp", Resource_SkyBoxYP_OFFSET },
	{ "SkyBoxYN.bmp", Resource_SkyBoxYN_OFFSET },
	{ "SkyBoxZP.bmp", Resource_SkyBoxZP_OFFSET },
	{ "SkyBoxZN.bmp", Resource_SkyBoxZN_OFFSET },
	{ NULL, 0 },
};


   

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
	{ XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Change alphafog\nstart" },
	{ XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Change alphafog\nend" },
	{ XBHELP_X_BUTTON,	   XBHELP_PLACEMENT_2, L"Toggle\nskybox" },
	{ XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
	{ XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// Structures and Macros
//-----------------------------------------------------------------------------
struct FOGVERTEX
{
	D3DXVECTOR3 p;
	D3DXVECTOR3 n;
	FLOAT		tu, tv;
};

#define NEAR_PLANE	 1.0f
#define FAR_PLANE  250.0f




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//		 functionality we want, so we're just supplying stubs to interface with
//		 the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
	CXBPackedResource  m_xprResource;	   // Packed resources for the app
	CXBFont 		   m_Font;			   // Font class
	CXBHelp 		   m_Help;			   // Help class
	BOOL			   m_bDrawHelp; 	   // Whether to draw help

	// Geometry
	LPDIRECT3DVERTEXBUFFER8 m_pColumnVB;
	DWORD					m_dwNumColumnVertices;

	CXBMesh 		   m_SkyboxObject;
	BOOL			   m_bDrawSkybox;

	CXBMesh 		   m_TerrainObject;
	LPDIRECT3DTEXTURE8 m_pTerrainTexture;

	// Fog parameters
	FLOAT			   m_fFogStartValue;
	FLOAT			   m_fFogEndValue;

	DWORD			   m_dwVertexShader;

	D3DXMATRIX		   m_matWorld;
	D3DXMATRIX		   m_matView;
	D3DXMATRIX		   m_matProj;

	HRESULT GenerateColumn( DWORD dwNumSegments, FLOAT fRadius, FLOAT fHeight );

protected:
	HRESULT Initialize();
	HRESULT Render();
	HRESULT FrameMove();

public:
	CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
	CXBoxSample xbApp;
	if( FAILED( xbApp.Create() ) )
		return;
	xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
			:CXBApplication()
{
	m_bDrawHelp 		   = FALSE;

	m_fFogStartValue	   = 0.8f*FAR_PLANE;
	m_fFogEndValue		   = FAR_PLANE;

	m_pColumnVB 		   = NULL;
	m_pTerrainTexture	   = NULL;

	m_bDrawSkybox		   = TRUE;
}




//----------------------------------------------------------------------------
// Name: GenerateColumn()
// Desc: Generates a trianglestrip for a column
//----------------------------------------------------------------------------
HRESULT CXBoxSample::GenerateColumn( DWORD dwNumSegments, FLOAT fRadius, FLOAT fHeight )
{
	HRESULT hr;

	m_dwNumColumnVertices = 2 * (dwNumSegments+1);

	// Create a vertex buffer
	hr = m_pd3dDevice->CreateVertexBuffer( m_dwNumColumnVertices*sizeof(FOGVERTEX),
										   D3DUSAGE_WRITEONLY, 0,
										   D3DPOOL_DEFAULT, &m_pColumnVB );
	if( FAILED(hr) )
		return hr;

	FOGVERTEX* pVertices = NULL;
	hr = m_pColumnVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
	if( FAILED(hr) )
		return hr;

	// Generate a trianglestrip
	for( DWORD seg=0; seg<=dwNumSegments; seg++ )
	{
		FLOAT fTheta = (2*D3DX_PI*seg)/dwNumSegments;
		FLOAT nx	 = sinf(fTheta);
		FLOAT nz	 = cosf(fTheta);
		FLOAT r 	 = fRadius;
		FLOAT u 	 = (1.0f*seg)/dwNumSegments;

		// Add two vertices to the strip at each step
		pVertices->p.x = r*nx;
		pVertices->p.y = fHeight;
		pVertices->p.z = r*nz;
		pVertices->n.x = nx;
		pVertices->n.y = 0;
		pVertices->n.z = nz;
		pVertices->tu  = u;
		pVertices->tv  = 1;
		pVertices++;

		pVertices->p.x = r*nx;
		pVertices->p.y = -1;
		pVertices->p.z = r*nz;
		pVertices->n.x = nx;
		pVertices->n.y = 0;
		pVertices->n.z = nz;
		pVertices->tu  = u;
		pVertices->tv  = 0;
		pVertices++;
	}

	m_pColumnVB->Unlock();

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
	// Create the font
	if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Create the help
	if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Create the resources
	if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
									  Resource_NUM_RESOURCES, g_ResourceNames ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Create the terrain texture
	m_pTerrainTexture = m_xprResource.GetTexture( "SeaFloor.bmp" );

	// Load the skybox
	if( FAILED( m_SkyboxObject.Create( m_pd3dDevice, "Models\\SkyBox.xbg", &m_xprResource ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Load the terrain
	if( FAILED( m_TerrainObject.Create( m_pd3dDevice, "Models\\Terrain.xbg", &m_xprResource ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Generate some geometry for the app
	GenerateColumn( 30, 1.0f, 10.0f );

	// Set up the object material
	D3DMATERIAL8 mtrl;
	XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
	m_pd3dDevice->SetMaterial( &mtrl );
	m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x44444444 );

	// Set the transform matrices
	D3DXMatrixIdentity( &m_matWorld );
	D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4.0f, 4.0f/3.0f, NEAR_PLANE, FAR_PLANE );
	m_pd3dDevice->SetTransform( D3DTS_WORLD,	  &m_matWorld );
	m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

	// Create the vertex shader
	DWORD dwVertexDecl[] =
	{
		D3DVSD_STREAM( 0 ),
		D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
		D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
		D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
		D3DVSD_END()
	};

	if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\AlphaFog.xvu",
										   dwVertexDecl,
										   &m_dwVertexShader ) ) )
		return E_FAIL;

	// Set up the light
	D3DLIGHT8 light;
	XBUtil_InitLight( light, D3DLIGHT_POINT, 0.0f, 50.0f, 0.0f );
	light.Attenuation0 =  0.1f;
	light.Range 	   = 200.0f;
	m_pd3dDevice->SetLight( 0, &light );
	m_pd3dDevice->LightEnable( 0, TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,	 TRUE );

	// Set misc states
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,		TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,	TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//		 the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	// Toggle help
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
		m_bDrawHelp = !m_bDrawHelp;

	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
		m_bDrawSkybox = !m_bDrawSkybox;

	// Update fog parameters from GamePad input
	m_fFogStartValue += m_DefaultGamepad.fY1*m_fElapsedTime*100.0f;
	if( m_fFogStartValue < NEAR_PLANE ) 	 m_fFogStartValue = NEAR_PLANE;
	if( m_fFogStartValue > FAR_PLANE )		 m_fFogStartValue = FAR_PLANE;
	if( m_fFogStartValue > m_fFogEndValue )  m_fFogStartValue = m_fFogEndValue;

	m_fFogEndValue += m_DefaultGamepad.fY2*m_fElapsedTime*100.0f;
	if( m_fFogEndValue < NEAR_PLANE )		 m_fFogEndValue = NEAR_PLANE;
	if( m_fFogEndValue > FAR_PLANE )		 m_fFogEndValue = FAR_PLANE;
	if( m_fFogEndValue < m_fFogStartValue )  m_fFogEndValue = m_fFogStartValue;
	
	// Move the camera along an ellipse
	D3DXVECTOR3 vFrom( 50*sinf(m_fAppTime/2), 3.0f, 60*cosf(m_fAppTime/2) );
	D3DXVECTOR3 vAt( 50*sinf(m_fAppTime/2+1.5f), 2.0f, 60*cosf(m_fAppTime/2+1.5f) );
	D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );
	D3DXMatrixLookAtLH( &m_matView, &vFrom, &vAt, &vUp );
	m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

	FLOAT g_fLightAngle = 1.0f;
	FLOAT fFogEnd	= m_fFogEndValue;
	FLOAT fFogStart = m_fFogStartValue;

	// Values passed into the vertex shader for lighting, etc.
	D3DXVECTOR4 fConstants0( 0.0f, 0.0f, 0.0f, 0.00f );
	D3DXVECTOR4 fConstants1( 1.0f, 0.5f, 0.2f, 0.05f );
	D3DXVECTOR4 fLight( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f, 0.0f );
	D3DXVECTOR4 fDiffuse( 0.5f, 0.5f, 0.5f, 1.00f );
	D3DXVECTOR4 fAmbient( 0.5f, 0.5f, 0.5f, 1.0f );
	D3DXVECTOR4 fAlphaFog( -1.0f/(fFogEnd-fFogStart), fFogEnd/(fFogEnd-fFogStart), 0.0f, 0.0f );

	D3DXMATRIX matWV, matWVP;
	D3DXMatrixMultiply( &matWV, &m_matWorld, &m_matView );
	D3DXMatrixMultiply( &matWVP, &matWV, &m_matProj );
	D3DXMatrixTranspose( &matWV, &matWV );
	D3DXMatrixTranspose( &matWVP, &matWVP );

	// Set the vertex shader constants
	m_pd3dDevice->SetVertexShaderConstant(	0, &fConstants0, 1 ); // Some constants
	m_pd3dDevice->SetVertexShaderConstant(	1, &fConstants1, 1 ); // More constants
	m_pd3dDevice->SetVertexShaderConstant( 20, &matWV,		 4 ); // Transforms
	m_pd3dDevice->SetVertexShaderConstant( 30, &matWVP, 	 4 ); // Transforms
	m_pd3dDevice->SetVertexShaderConstant( 40, &fLight, 	 1 ); // Light direction
	m_pd3dDevice->SetVertexShaderConstant( 41, &fDiffuse,	 1 ); // Diffuse color
	m_pd3dDevice->SetVertexShaderConstant( 42, &fAmbient,	 1 ); // Ambient color
	m_pd3dDevice->SetVertexShaderConstant( 44, &fAlphaFog,	 1 ); // Alpha fog factors

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	// Clear the viewport
	m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
						 0xff0000ff, 1.0f, 0L );

	// Set default state
	m_pd3dDevice->SetTexture( 0, NULL );
	m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x44444444 );
	m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,		  TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,		  TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,	  TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,	 D3DTOP_MODULATE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,	 D3DTOP_MODULATE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
	m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,	 D3DTOP_DISABLE );
	m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,	 D3DTOP_DISABLE );

	// Render the Skybox
	if( m_bDrawSkybox )
	{
		D3DXMatrixIdentity( &m_matWorld );
		m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
	
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
		m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
		m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
		
		// Center view matrix for skybox and disable zbuffer
		D3DXMATRIX matView, matViewSave;
		m_pd3dDevice->GetTransform( D3DTS_VIEW, 	 &matViewSave );
		matView = matViewSave;
		matView._41 = 0.0f; matView._42 = -0.0f; matView._43 = 0.0f;
		m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
		m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );

		// Render the skybox
		m_SkyboxObject.Render( m_pd3dDevice );

		// Restore the render states
		m_pd3dDevice->SetTransform( D3DTS_VIEW, &matViewSave );
		m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
		m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
	}

	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

	// Turn on alpha blending
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
	m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

	// Build the matrix transforms
	D3DXMatrixIdentity( &m_matWorld );
	m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

	D3DXMATRIX matWV, matWVP;
	D3DXMatrixMultiply( &matWV, &m_matWorld, &m_matView );
	D3DXMatrixMultiply( &matWVP, &matWV, &m_matProj );
	D3DXMatrixTranspose( &matWV, &matWV );
	D3DXMatrixTranspose( &matWVP, &matWVP );
	m_pd3dDevice->SetVertexShaderConstant( 20, &matWV,	4 ); // WorldView Transform
	m_pd3dDevice->SetVertexShaderConstant( 30, &matWVP, 4 ); // WorldViewProj Transform

	// Render the terrain
	m_pd3dDevice->SetTexture( 0, m_pTerrainTexture );
	m_pd3dDevice->SetVertexShader( m_dwVertexShader );
	m_TerrainObject.Render( m_pd3dDevice, XBMESH_NOFVF|XBMESH_NOTEXTURES );

	// Draw the columns
	for( DWORD i=0; i<100; i++ )
	{
		FLOAT tx = (i%50)*20.0f - 500.0f;
		FLOAT ty =	0.0f;
		FLOAT tz = (i<=50) ? 40.0f : -40.0f;

		if( i<50 )
			D3DXMatrixTranslation( &m_matWorld, (i%50)*20.0f - 500.0f, ty, 10.0f );
		else
			D3DXMatrixTranslation( &m_matWorld, 10.0f, ty, (i%50)*20.0f - 500.0f );

		
		m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

		D3DXMATRIX matWV, matWVP;
		D3DXMatrixMultiply( &matWV, &m_matWorld, &m_matView );
		D3DXMatrixMultiply( &matWVP, &matWV, &m_matProj );
		D3DXMatrixTranspose( &matWV, &matWV );
		D3DXMatrixTranspose( &matWVP, &matWVP );
		m_pd3dDevice->SetVertexShaderConstant( 20, &matWV,			4 ); // Transforms
		m_pd3dDevice->SetVertexShaderConstant( 30, &matWVP, 		4 ); // Transforms

		m_pd3dDevice->SetVertexShader( m_dwVertexShader );
		m_pd3dDevice->SetStreamSource( 0, m_pColumnVB, sizeof(FOGVERTEX) );
		m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP,
									 0, m_dwNumColumnVertices-2 );
	}

	// Show title, frame rate, and help
	if( m_bDrawHelp )
		m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
	else
	{
		m_Font.Begin();
		m_Font.DrawText(  64,  48, 0xff000000, L"AlphaFog" );
		m_Font.DrawText( 450,  48, 0xff008000, m_strFrameRate );

		WCHAR strBuffer[80];
		swprintf( strBuffer, L"%0.2f", m_fFogStartValue );
		m_Font.DrawText(  64,  75, 0xff000000, L"Start:" );
		m_Font.DrawText( 150,  75, 0xff008000, strBuffer  );
		swprintf( strBuffer, L"%0.2f", m_fFogEndValue );
		m_Font.DrawText(  64, 100, 0xff000000, L"End:" );
		m_Font.DrawText( 150, 100, 0xff008000, strBuffer  );
		m_Font.End();
	}

	// Present the scene
	m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\dsp\include\Io56kevm.h ===
;*********************************************************************************

;

;     EQUATES for DSP56362 I/O registers and ports

;     Reference: DSP56362 Specifications Revision 0.2 

;

;     Last update: November 6, 1997

;

;*********************************************************************************



    page    132,55,0,0,0

    opt    mex



ioequ   ident   1,0

kRightReceive    equ     0 

kStackBase	equ $40
kStackTop	equ	kStackBase+32

;************************************************************
; mInitStack		
;************************************************************
mInitStack	macro

	ori     #$03,mr                ; mask interrupts

	movep   #$05000b,X:M_PCTL      ; DSP core at 8.192x12=98.3MHz
	move    #0,omr
	movec   #0,sp                  ; reset hardware stack pointer
	movep   #$000003,x:M_IPRP      ; ESAI int's enabled and top Priority
	move    #kStackBase,rStack            ; initialize stack pointer
	move    #-1,m6                 ; linear addressing

	andi    #$FC,mr                 ;enable all interrupt levels
	endm


;------------------------------------------------------------------------

;

;       EQUATES for I/O Port Programming

;

;------------------------------------------------------------------------



;       Register Addresses



M_HDR    EQU     $FFFFC9         ; Host port GPIO data Register

M_HDDR   EQU     $FFFFC8         ; Host port GPIO direction Register

M_PCRC   EQU     $FFFFBF         ; Port C Control Register

M_PRRC   EQU     $FFFFBE         ; Port C Direction Register

M_PDRC   EQU     $FFFFBD         ; Port C GPIO Data Register

M_PCRD   EQU     $FFFFD7         ; Port D Control register

M_PRRD   EQU     $FFFFD6         ; Port D Direction Data Register

M_PDRD   EQU     $FFFFD5         ; Port D GPIO Data Register

M_OGDB   EQU     $FFFFFC         ; OnCE GDB Register 







;------------------------------------------------------------------------

;

;       EQUATES for Exception Processing                                    

;

;------------------------------------------------------------------------



;       Register Addresses



M_IPRC   EQU     $FFFFFF         ; Interrupt Priority Register Core

M_IPRP   EQU     $FFFFFE         ; Interrupt Priority Register Peripheral



;       Interrupt Priority Register Core (IPRC) 



M_IAL    EQU     $7              ; IRQA Mode Mask

M_IAL0   EQU     0               ; IRQA Mode Interrupt Priority Level (low)

M_IAL1   EQU     1               ; IRQA Mode Interrupt Priority Level (high)

M_IAL2   EQU     2               ; IRQA Mode Trigger Mode

M_IBL    EQU     $38             ; IRQB Mode Mask

M_IBL0   EQU     3               ; IRQB Mode Interrupt Priority Level (low)

M_IBL1   EQU     4               ; IRQB Mode Interrupt Priority Level (high)

M_IBL2   EQU     5               ; IRQB Mode Trigger Mode

M_ICL    EQU     $1C0            ; IRQC Mode Mask

M_ICL0   EQU     6               ; IRQC Mode Interrupt Priority Level (low)

M_ICL1   EQU     7               ; IRQC Mode Interrupt Priority Level (high)

M_ICL2   EQU     8               ; IRQC Mode Trigger Mode

M_IDL    EQU     $E00            ; IRQD Mode Mask

M_IDL0   EQU     9               ; IRQD Mode Interrupt Priority Level (low)

M_IDL1   EQU     10              ; IRQD Mode Interrupt Priority Level (high)

M_IDL2   EQU     11              ; IRQD Mode Trigger Mode

M_D0L    EQU     $3000           ; DMA0 Interrupt priority Level Mask

M_D0L0   EQU     12              ; DMA0 Interrupt Priority Level (low)

M_D0L1   EQU     13              ; DMA0 Interrupt Priority Level (high)

M_D1L    EQU     $C000           ; DMA1 Interrupt Priority Level Mask

M_D1L0   EQU     14              ; DMA1 Interrupt Priority Level (low)

M_D1L1   EQU     15              ; DMA1 Interrupt Priority Level (high)

M_D2L    EQU     $30000          ; DMA2 Interrupt priority Level Mask

M_D2L0   EQU     16              ; DMA2 Interrupt Priority Level (low)

M_D2L1   EQU     17              ; DMA2 Interrupt Priority Level (high)

M_D3L    EQU     $C0000          ; DMA3 Interrupt Priority Level Mask

M_D3L0   EQU     18              ; DMA3 Interrupt Priority Level (low)

M_D3L1   EQU     19              ; DMA3 Interrupt Priority Level (high)

M_D4L    EQU     $300000         ; DMA4 Interrupt priority Level Mask

M_D4L0   EQU     20              ; DMA4 Interrupt Priority Level (low)

M_D4L1   EQU     21              ; DMA4 Interrupt Priority Level (high)

M_D5L    EQU     $C00000         ; DMA5 Interrupt priority Level Mask

M_D5L0   EQU     22              ; DMA5 Interrupt Priority Level (low)

M_D5L1   EQU     23              ; DMA5 Interrupt Priority Level (high)



;       Interrupt Priority Register Peripheral (IPRP)



M_ESL    EQU     $3              ; ESAI Interrupt Priority Level Mask

M_ESL0   EQU     0               ; ESAI Interrupt Priority Level (low)

M_ESL1   EQU     1               ; ESAI Interrupt Priority Level (high)

M_SHL    EQU     $C              ; SHI Interrupt Priority Level Mask

M_SHL0   EQU     2               ; SHI Interrupt Priority Level (low)

M_SHL1   EQU     3               ; SHI Interrupt Priority Level (high)

M_HDL    EQU     $30             ; HDI08 Interrupt Priority Level Mask

M_HDL0   EQU     4               ; HDI08 Interrupt Priority Level (low)

M_HDL1   EQU     5               ; HDI08 Interrupt Priority Level (high)

M_DAL    EQU     $C0             ; DAX Interrupt Priority Level  Mask       

M_DAL0   EQU     6               ; DAX Interrupt Priority Level  (low)

M_DAL1   EQU     7               ; DAX Interrupt Priority Level  (high)

M_TAL   EQU     $300             ; Timer Interrupt Priority Level Mask

M_TAL0   EQU     8               ; Timer Interrupt Priority Level (low)

M_TAL1   EQU     9               ; Timer Interrupt Priority Level (high)



;------------------------------------------------------------------------

;

;       EQUATES for Direct Memory Access (DMA)                                


;

;------------------------------------------------------------------------



;       Register Addresses Of DMA



M_DSTR   EQU     $FFFFF4         ; DMA Status Register

M_DOR0   EQU     $FFFFF3         ; DMA Offset Register 0

M_DOR1   EQU     $FFFFF2         ; DMA Offset Register 1

M_DOR2   EQU     $FFFFF1         ; DMA Offset Register 2

M_DOR3   EQU     $FFFFF0         ; DMA Offset Register 3



;       Register Addresses Of DMA0



M_DSR0   EQU     $FFFFEF         ; DMA0 Source Address Register

M_DDR0   EQU     $FFFFEE         ; DMA0 Destination Address Register 

M_DCO0   EQU     $FFFFED         ; DMA0 Counter

M_DCR0   EQU     $FFFFEC         ; DMA0 Control Register 



;       Register Addresses Of DMA1



M_DSR1   EQU     $FFFFEB         ; DMA1 Source Address Register

M_DDR1   EQU     $FFFFEA         ; DMA1 Destination Address Register 

M_DCO1   EQU     $FFFFE9         ; DMA1 Counter

M_DCR1   EQU     $FFFFE8         ; DMA1 Control Register



;       Register Addresses Of DMA2



M_DSR2   EQU     $FFFFE7         ; DMA2 Source Address Register

M_DDR2   EQU     $FFFFE6         ; DMA2 Destination Address Register 

M_DCO2   EQU     $FFFFE5         ; DMA2 Counter

M_DCR2   EQU     $FFFFE4         ; DMA2 Control Register

 

;       Register Addresses Of DMA3



M_DSR3   EQU     $FFFFE3         ; DMA3 Source Address Register

M_DDR3   EQU     $FFFFE2         ; DMA3 Destination Address Register 

M_DCO3   EQU     $FFFFE1         ; DMA3 Counter

M_DCR3   EQU     $FFFFE0         ; DMA3 Control Register



;       Register Addresses Of DMA4



M_DSR4   EQU     $FFFFDF         ; DMA4 Source Address Register

M_DDR4   EQU     $FFFFDE         ; DMA4 Destination Address Register 

M_DCO4   EQU     $FFFFDD         ; DMA4 Counter

M_DCR4   EQU     $FFFFDC         ; DMA4 Control Register 



;       Register Addresses Of DMA5



M_DSR5   EQU     $FFFFDB         ; DMA5 Source Address Register

M_DDR5   EQU     $FFFFDA         ; DMA5 Destination Address Register 

M_DCO5   EQU     $FFFFD9         ; DMA5 Counter

M_DCR5   EQU     $FFFFD8         ; DMA5 Control Register



;       DMA Control Register



M_DSS    EQU     $3              ; DMA Source Space Mask (DSS0-Dss1)

M_DSS0   EQU     0               ; DMA Source Memory space 0

M_DSS1   EQU     1               ; DMA Source Memory space 1    

M_DDS    EQU     $C              ; DMA Destination Space Mask (DDS-DDS1)

M_DDS0   EQU     2               ; DMA Destination Memory Space 0

M_DDS1   EQU     3               ; DMA Destination Memory Space 1

M_DAM    EQU     $3f0            ; DMA Address Mode Mask (DAM5-DAM0)

M_DAM0   EQU     4               ; DMA Address Mode 0

M_DAM1   EQU     5               ; DMA Address Mode 1

M_DAM2   EQU     6               ; DMA Address Mode 2

M_DAM3   EQU     7               ; DMA Address Mode 3

M_DAM4   EQU     8               ; DMA Address Mode 4

M_DAM5   EQU     9               ; DMA Address Mode 5

M_D3D    EQU     10              ; DMA Three Dimensional Mode

M_DRS    EQU     $F800           ; DMA Request Source Mask (DRS0-DRS4)

M_DRS0    EQU     11             ; DMA Request Source bit 0

M_DRS1    EQU     12             ; DMA Request Source bit 1

M_DRS2    EQU     13             ; DMA Request Source bit 2

M_DRS3    EQU     14             ; DMA Request Source bit 3

M_DRS4    EQU     15             ; DMA Request Source bit 4

M_DCON   EQU     16              ; DMA Continuous Mode

M_DPR    EQU     $60000          ; DMA Channel Priority

M_DPR0   EQU     17              ; DMA Channel Priority Level (low)

M_DPR1   EQU     18              ; DMA Channel Priority Level (high)

M_DTM    EQU     $380000         ; DMA Transfer Mode Mask (DTM2-DTM0)

M_DTM0   EQU     19              ; DMA Transfer Mode 0

M_DTM1   EQU     20              ; DMA Transfer Mode 1

M_DTM2   EQU     21              ; DMA Transfer Mode 2

M_DIE    EQU     22              ; DMA Interrupt Enable bit

M_DE     EQU     23              ; DMA Channel Enable bit 



;       DMA Status Register



M_DTD    EQU     $3F             ; Channel Transfer Done Status MASK (DTD0-DTD5)

M_DTD0   EQU     0               ; DMA Channel Transfer Done Status 0

M_DTD1   EQU     1               ; DMA Channel Transfer Done Status 1

M_DTD2   EQU     2               ; DMA Channel Transfer Done Status 2

M_DTD3   EQU     3               ; DMA Channel Transfer Done Status 3

M_DTD4   EQU     4               ; DMA Channel Transfer Done Status 4

M_DTD5   EQU     5               ; DMA Channel Transfer Done Status 5

M_DACT   EQU     8               ; DMA Active State

M_DCH    EQU     $E00            ; DMA Active Channel Mask (DCH0-DCH2)

M_DCH0   EQU     9               ; DMA Active Channel 0

M_DCH1   EQU     10              ; DMA Active Channel 1

M_DCH2   EQU     11              ; DMA Active Channel 2



;------------------------------------------------------------------------

;

;       EQUATES for Phase Locked Loop (PLL) 

;

;------------------------------------------------------------------------



;       Register Addresses Of PLL



M_PCTL   EQU     $FFFFFD         ; PLL Control Register



;       PLL Control Register



M_MF     EQU     $FFF            ; Multiplication Factor Bits Mask (MF0-MF11)

M_MF0    EQU   0                 ; Multiplication Factor bit 0 

M_MF1    EQU   1                 ; Multiplication Factor bit 1 

M_MF2    EQU   2                 ; Multiplication Factor bit 2 

M_MF3    EQU   3                 ; Multiplication Factor bit 3 

M_MF4    EQU   4                 ; Multiplication Factor bit 4

M_MF5    EQU   5                 ; Multiplication Factor bit 5 

M_MF6    EQU   6                 ; Multiplication Factor bit 6 

M_MF7    EQU   7                 ; Multiplication Factor bit 7 

M_MF8    EQU   8                 ; Multiplication Factor bit 8 

M_MF9    EQU   9                 ; Multiplication Factor bit 9 

M_MF10    EQU   10               ; Multiplication Factor bit 10

M_MF11    EQU   11               ; Multiplication Factor bit 11

M_DF     EQU     $7000           ; Division Factor Bits Mask (DF0-DF2)

M_DF0    EQU   12                ; Division Factor bit 0

M_DF1    EQU   13                ; Division Factor bit 1

M_DF2    EQU   14                ; Division Factor bit 2

M_XTLR   EQU     15              ; XTAL Range select bit

M_XTLD   EQU     16              ; XTAL Disable Bit

M_PSTP   EQU     17              ; STOP Processing State Bit 

M_PEN    EQU     18              ; PLL Enable Bit

M_COD   EQU     19               ; PLL Clock Output Disable Bit

M_PD     EQU     $F00000         ; PreDivider Factor Bits Mask (PD0-PD3)

M_PD0    EQU   20                ; PreDivider Factor bit 0

M_PD1    EQU   21                ; PreDivider Factor bit 1

M_PD2    EQU   22                ; PreDivider Factor bit 2

M_PD3    EQU   23                ; PreDivider Factor bit 3



;------------------------------------------------------------------------

;

;       EQUATES for BIU 

;

;------------------------------------------------------------------------



;       Register Addresses Of BIU



M_BCR    EQU     $FFFFFB         ; Bus Control Register

M_DCR    EQU     $FFFFFA         ; DRAM Control Register

M_AAR0   EQU     $FFFFF9         ; Address Attribute Register 0 

M_AAR1   EQU     $FFFFF8         ; Address Attribute Register 1 

M_AAR2   EQU     $FFFFF7         ; Address Attribute Register 2 

M_AAR3   EQU     $FFFFF6         ; Address Attribute Register 3 

M_IDR    EQU     $FFFFF5         ; ID Register



;       Bus Control Register



M_BA0W   EQU     $1F             ; Area 0 Wait Control Mask (BA0W0-BA0W4)

M_BA0W0   EQU   0                ; Area 0 Wait Control Bit 0

M_BA0W1   EQU   1                ; Area 0 Wait Control Bit 1

M_BA0W2   EQU   2                ; Area 0 Wait Control Bit 2

M_BA0W3   EQU   3                ; Area 0 Wait Control Bit 3

M_BA0W4   EQU   4                ; Area 0 Wait Control Bit 4

M_BA1W   EQU     $3E0            ; Area 1 Wait Control Mask (BA1W0-BA14)

M_BA1W0   EQU   5                ; Area 1 Wait Control Bit 0

M_BA1W1   EQU   6                ; Area 1 Wait Control Bit 1

M_BA1W2   EQU   7                ; Area 1 Wait Control Bit 2

M_BA1W3   EQU   8                ; Area 1 Wait Control Bit 3

M_BA1W4   EQU   9                ; Area 1 Wait Control Bit 4

M_BA2W   EQU     $1C00           ; Area 2 Wait Control Mask (BA2W0-BA2W2)

M_BA2W0   EQU   10               ; Area 2 Wait Control Bit 0

M_BA2W1   EQU   11               ; Area 2 Wait Control Bit 1

M_BA2W2   EQU   12               ; Area 2 Wait Control Bit 2

M_BA3W   EQU     $E000           ; Area 3 Wait Control Mask (BA3W0-BA3W3)

M_BA3W0   EQU   13               ; Area 3 Wait Control Bit 0

M_BA3W1   EQU   14               ; Area 3 Wait Control Bit 1

M_BA3W2   EQU   15               ; Area 3 Wait Control Bit 2

M_BDFW   EQU     $1F0000         ; Default Area Wait Control Mask (BDFW0-BDFW4)

M_BDFW0   EQU     16             ; Default Area Wait Control bit 0

M_BDFW1   EQU     17             ; Default Area Wait Control bit 1

M_BDFW2   EQU     18             ; Default Area Wait Control bit 2

M_BDFW3   EQU     19             ; Default Area Wait Control bit 3

M_BDFW4   EQU     20             ; Default Area Wait Control bit 4

M_BBS    EQU     21              ; Bus State

M_BLH    EQU     22              ; Bus Lock Hold

M_BRH    EQU     23              ; Bus Request Hold



;       DRAM Control Register



M_BCW    EQU     $3              ; In Page Wait States Bits Mask (BCW0-BCW1)

M_BCW0    EQU     0              ; In Page Wait States Bit 0

M_BCW1   EQU     1               ; In Page Wait States Bit 1

M_BRW    EQU     $C              ; Out Of Page Wait States Bits Mask (BRW0-BRW1)

M_BRW0    EQU     2              ; Out of Page Wait States bit 0

M_BRW1    EQU     3              ; Out of Page Wait States bit 1

M_BPS    EQU     $300            ; DRAM Page Size Bits Mask (BPS0-BPS1)

M_BPS0    EQU     4              ; DRAM Page Size Bits 0
                                 
M_BPS1    EQU     5              ; DRAM Page Size Bits 1

M_BPLE   EQU     11              ; Page Logic Enable

M_BME    EQU     12              ; Mastership Enable

M_BRE    EQU     13              ; Refresh Enable

M_BSTR   EQU     14              ; Software Triggered Refresh

M_BRF    EQU     $7F8000         ; Refresh Rate Bits Mask (BRF0-BRF7)

M_BRF0    EQU     15             ; Refresh Rate Bit 0

M_BRF1    EQU     16             ; Refresh Rate Bit 1

M_BRF2    EQU     17             ; Refresh Rate Bit 2

M_BRF3    EQU     18             ; Refresh Rate Bit 3

M_BRF4    EQU     19             ; Refresh Rate Bit 4

M_BRF5    EQU     20             ; Refresh Rate Bit 5

M_BRF6    EQU     21             ; Refresh Rate Bit 6

M_BRF7    EQU     22             ; Refresh Rate Bit 7

M_BRP    EQU     23              ; Refresh prescaler



;       Address Attribute Registers



M_BAT    EQU     $3              ; External Access Type and Pin Definition
                                 ; Bits Mask (BAT0-BAT1)

M_BAT0    EQU     0             ; External Access Type and Pin Definition
                                ; Bits 0

M_BAT1    EQU     1             ; External Access Type and Pin Definition
                                ; Bits 1

M_BAAP   EQU     2              ; Address Attribute Pin Polarity

M_BPEN   EQU     3              ; Program Space Enable

M_BXEN   EQU     4              ; X Data Space Enable

M_BYEN   EQU     5              ; Y Data Space Enable

M_BAM    EQU     6              ; Address Muxing

M_BPAC   EQU     7              ; Packing Enable

M_BNC    EQU     $F00           ; Number of Address Bits to Compare Mask
                                ; (BNC0-BNC3)

M_BNC0   EQU     8              ; Number of Address Bits to Compare 0

M_BNC1   EQU     9              ; Number of Address Bits to Compare 1

M_BNC2   EQU     10             ; Number of Address Bits to Compare 2

M_BNC3   EQU     11             ; Number of Address Bits to Compare 3

M_BAC    EQU     $FFF000        ; Address to Compare Bits Mask (BAC0-BAC11)

M_BAC0   EQU     12             ; Address to Compare Bits 0

M_BAC1   EQU     13             ; Address to Compare Bits 1

M_BAC2   EQU     14             ; Address to Compare Bits 2

M_BAC3   EQU     15             ; Address to Compare Bits 3

M_BAC4   EQU     16             ; Address to Compare Bits 4

M_BAC5   EQU     17             ; Address to Compare Bits 5

M_BAC6   EQU     18             ; Address to Compare Bits 6

M_BAC7   EQU     19             ; Address to Compare Bits 7

M_BAC8   EQU     20             ; Address to Compare Bits 8

M_BAC9   EQU     21             ; Address to Compare Bits 9

M_BAC10  EQU    22              ; Address to Compare Bits 10

M_BAC11  EQU    23              ; Address to Compare Bits 11



;       control and status bits in SR



M_C     EQU      0                ; Carry

M_V      EQU     1               ; Overflow      

M_Z      EQU     2               ; Zero

M_N      EQU     3               ; Negative      

M_U      EQU     4               ; Unnormalized

M_E      EQU     5               ; Extension     

M_L      EQU     6               ; Limit

M_S      EQU     7               ; Scaling Bit   

M_I0     EQU     8               ; Interupt Mask Bit 0

M_I1     EQU     9               ; Interupt Mask Bit 1

M_S0     EQU     10              ; Scaling Mode Bit 0

M_S1     EQU     11              ; Scaling Mode Bit 1

M_SC     EQU     13              ; Sixteen_Bit Compatibility

M_DM     EQU     14              ; Double Precision Multiply

M_LF     EQU     15              ; DO-Loop Flag

M_FV     EQU     16              ; DO-Forever Flag

M_SA     EQU     17              ; Sixteen-Bit Arithmetic

M_CE     EQU     19              ; Instruction Cache Enable

M_SM     EQU     20              ; Arithmetic Saturation

M_RM     EQU     21              ; Rounding Mode

M_CP     EQU     $c00000         ; mask for CORE-DMA priority bits in SR 

M_CP0    EQU     22              ; bit 0 of priority bits in SR

M_CP1    EQU     23              ; bit 1 of priority bits in SR



;       control and status bits in OMR



M_MA     EQU     0               ; Operating Mode A

M_MB     EQU     1               ; Operating Mode B

M_MC     EQU     2               ; Operating Mode C

M_MD     EQU     3               ; Operating Mode D

M_EBD    EQU     4               ; External Bus Disable bit in OMR

M_SD     EQU     6               ; Stop Delay 

M_MS     EQU     7               ; Memory Switch Mode 

M_CDP    EQU     $300            ; mask for CORE-DMA priority bits in OMR

M_CDP0   EQU     8               ; bit 0 of priority bits in OMR Core DMA

M_CDP1   EQU     9               ; bit 1 of priority bits in OMR Core DMA

M_BE    EQU     10               ; Burst Enable 

M_TAS    EQU     11              ; TA Synchronize Select

M_BRT    EQU     12              ; Bus Release Timing 

M_ABE   EQU     13               ; Async. Bus Arbitration Enable

M_APD   EQU     14               ; Addess Priority Disable

M_ATE   EQU     15               ; Address Tracing Enable

M_XYS    EQU     16              ; Stack Extension space select bit in OMR.

M_EUN    EQU     17              ; Extensed stack UNderflow flag in OMR.

M_EOV    EQU     18              ; Extended stack OVerflow flag in OMR.

M_WRP    EQU     19              ; Extended WRaP flag in OMR.

M_SEN    EQU     20              ; Stack Extension Enable bit in OMR.

M_PAEN   EQU      23             ; Patch Enable



;------------------------------------------------------------------------

;

;       EQUATES for DAX (SPDIF Tx)

;

;------------------------------------------------------------------------



;       Register Addresses

 

M_XSTR   EQU     $FFFFD4         ; DAX Status Register (XSTR)

M_XADRB  EQU     $FFFFD3         ; DAX Audio Data Register B (XADRB)

M_XADR    EQU     $FFFFD2        ; DAX Audio Data Register (XADR)

M_XADRA  EQU     $FFFFD2         ; DAX Audio Data Register A (XADRA)

M_XNADR  EQU     $FFFFD1         ; DAX Non-Audio Data Register (XNADR)

M_XCTR   EQU     $FFFFD0         ; DAX Control Register (XCTR)



;       status bits in XSTR



M_XADE   EQU     0               ; DAX Audio Data Register Empty (XADE)

M_XAUR   EQU     1               ; DAX Trasmit Underrun Error Flag (XAUR)

M_XBLK   EQU     2               ; DAX Block Transferred (XBLK)



;       non-audio bits in XNADR



M_XVA    EQU     10              ; DAX Channel A Validity (XVA)

M_XUA    EQU     11              ; DAX Channel A User Data (XUA)

M_XCA    EQU     12              ; DAX Channel A Channel Status (XCA)

M_XVB    EQU     13              ; DAX Channel B Validity (XVB)

M_XUB    EQU     14              ; DAX Channel B User Data (XUB)

M_XCB    EQU     15              ; DAX Channel B Channel Status (XCB)



;       control bits in XCTR



M_XDIE   EQU     0               ; DAX Audio Data Register Empty Interrupt
                                 ; Enable (XDIE)

M_XUIE   EQU     1               ; DAX Underrun Error Interrupt Enable (XUIE)

M_XBIE   EQU     2               ; DAX Block Transferred Interrupt Enable
                                 ; (XBIE)

M_XCS0   EQU     3               ; DAX Clock Input Select 0 (XCS0)

M_XCS1   EQU     4               ; DAX Clock Input Select 1 (XCS1)

M_XSB    EQU     5               ; DAX Start Block (XSB)



;------------------------------------------------------------------------

;

;       EQUATES for SHI 

;

;------------------------------------------------------------------------



;       Register Addresses

 

M_HRX    EQU     $FFFF94         ; SHI Receive FIFO (HRX)

M_HTX    EQU     $FFFF93         ; SHI Transmit Register (HTX)

M_HSAR   EQU     $FFFF92         ; SHI I2C Slave Address Register (HSAR)

M_HCSR   EQU     $FFFF91         ; SHI Control/Status Register (HCSR)

M_HCKR   EQU     $FFFF90         ; SHI Clock Control Register (HCKR)



;       HSAR bits



M_HA6    EQU     23              ; SHI I2C Slave Address (HA6)

M_HA5    EQU     22              ; SHI I2C Slave Address (HA5)

M_HA4    EQU     21              ; SHI I2C Slave Address (HA4)

M_HA3    EQU     20              ; SHI I2C Slave Address (HA3)

M_HA1    EQU     18              ; SHI I2C Slave Address (HA1)



;      control and status bits in HCSR



M_HBUSY  EQU     22              ; SHI Host Busy (HBUSY)

M_HBER   EQU     21              ; SHI Bus Error (HBER)

M_HROE   EQU     20              ; SHI Receive Overrun Error (HROE)

M_HRFF   EQU     19              ; SHI Receivr FIFO Full (HRFF)

M_HRNE   EQU     17              ; SHI Receive FIFO Not Empty (HRNE)

M_HTDE   EQU     15              ; SHI Host Transmit data Empty (HTDE)

M_HTUE   EQU     14              ; SHI Host Transmit Underrun Error (HTUE)

M_HRIE1  EQU     13              ; SHI Receive Interrupt Enable (HRIE1)

M_HRIE0  EQU     12              ; SHI Receive Interrupt Enable (HRIE0)

M_HTIE   EQU     11              ; SHI Transmit Interrupt Enable (HTIE)

M_HBIE   EQU     10              ; SHI Bus-Error Interrupt Enable (HBIE)

M_HIDLE  EQU     9               ; SHI Idle (HIDLE)

M_HRQE1  EQU     8               ; SHI Host Request Enable (HRQE1)

M_HRQE0  EQU     7               ; SHI Host Request Enable (HRQE0)

M_HMST   EQU     6               ; SHI Master Mode (HMST)

M_HFIFO  EQU     5               ; SHI FIFO Enable Control (HFIFO)

M_HCKFR  EQU     4               ; SHI Clock Freeze (HCKFR)

M_HM1    EQU     3               ; SHI Serial Host Interface Mode (HM1)

M_HM0    EQU     2               ; SHI Serial Host Interface Mode (HM0)

M_HI2C   EQU     1               ; SHI I2c/SPI Selection (HI2C)

M_HEN    EQU     0               ; SHI Host Enable (HEN)



;       control bits in HCKR



M_HFM1   EQU     13              ; SHI Filter Model (HFM1)

M_HFM0   EQU     12              ; SHI Filter Model (HFM0)

M_HDM7   EQU     10              ; SHI Divider Modulus Select (HDM7)

M_HDM6   EQU     9               ; SHI Divider Modulus Select (HDM6)

M_HDM5   EQU     8               ; SHI Divider Modulus Select (HDM5)

M_HDM4   EQU     7               ; SHI Divider Modulus Select (HDM4)

M_HDM3   EQU     6               ; SHI Divider Modulus Select (HDM3)

M_HDM2   EQU     5               ; SHI Divider Modulus Select (HDM2)

M_HDM1   EQU     4               ; SHI Divider Modulus Select (HDM1)

M_HDM0   EQU     3               ; SHI Divider Modulus Select (HDM0)

M_HRS    EQU     2               ; SHI Prescalar Rate Select (HRS)

M_CPOL   EQU     1               ; SHI Clock Polarity (CPOL)

M_CPHA   EQU     0               ; SHI Clock Phase (CPHA)



;------------------------------------------------------------------------

;

;       EQUATES for ESAI 

;

;------------------------------------------------------------------------



;       Register Addresses

 

M_RSMB   EQU     $FFFFBC         ; ESAI Receive Slot Mask Register B (RSMB)

M_RSMA   EQU     $FFFFBB         ; ESAI Receive Slot Mask Register A (RSMA)

M_TSMB   EQU     $FFFFBA         ; ESAI Transmit Slot Mask Register B (TSMB)

M_TSMA   EQU     $FFFFB9         ; ESAI Transmit Slot Mask Register A (TSMA)

M_RCCR   EQU     $FFFFB8         ; ESAI Receive Clock Control Register (RCCR)

M_RCR    EQU     $FFFFB7         ; ESAI Receive Control Register (RCR)

M_TCCR   EQU     $FFFFB6         ; ESAI Transmit Clock Control Register (TCCR)

M_TCR    EQU     $FFFFB5         ; ESAI Transmit Control Register (TCR)

M_SAICR  EQU     $FFFFB4         ; ESAI Control Register (SAICR)

M_SAISR  EQU     $FFFFB3         ; ESAI Status Register (SAISR)

M_RX3    EQU     $FFFFAB         ; ESAI Receive Data Register 3 (RX3)

M_RX2    EQU     $FFFFAA         ; ESAI Receive Data Register 2 (RX2)

M_RX1    EQU     $FFFFA9         ; ESAI Receive Data Register 1 (RX1)

M_RX0    EQU     $FFFFA8         ; ESAI Receive Data Register 0 (RX0)

M_TSR    EQU     $FFFFA6         ; ESAI Time Slot Register (TSR)

M_TX5    EQU     $FFFFA5         ; ESAI Transmit Data Register 5 (TX5)

M_TX4    EQU     $FFFFA4         ; ESAI Transmit Data Register 4 (TX4)

M_TX3    EQU     $FFFFA3         ; ESAI Transmit Data Register 3 (TX3)

M_TX2    EQU     $FFFFA2         ; ESAI Transmit Data Register 2 (TX2)

M_TX1    EQU     $FFFFA1         ; ESAI Transmit Data Register 1 (TX1)

M_TX0    EQU     $FFFFA0         ; ESAI Transmit Data Register 0 (TX0)



;       RSMB Register bits



M_RS31   EQU     15              ; ESAI 

M_RS30   EQU     14              ; ESAI 

M_RS29   EQU     13              ; ESAI 

M_RS28   EQU     12              ; ESAI 

M_RS27   EQU     11              ; ESAI 

M_RS26   EQU     10              ; ESAI 

M_RS25   EQU     9               ; ESAI 

M_RS24   EQU     8               ; ESAI 

M_RS23   EQU     7               ; ESAI 

M_RS22   EQU     6               ; ESAI 

M_RS21   EQU     5               ; ESAI 

M_RS20   EQU     4               ; ESAI 

M_RS19   EQU     3               ; ESAI 

M_RS18   EQU     2               ; ESAI 

M_RS17   EQU     1               ; ESAI 

M_RS16   EQU     0               ; ESAI 



;       RSMA Register bits



M_RS15   EQU     15              ; ESAI 

M_RS14   EQU     14              ; ESAI 

M_RS13   EQU     13              ; ESAI 

M_RS12   EQU     12              ; ESAI 

M_RS11   EQU     11              ; ESAI 

M_RS10   EQU     10              ; ESAI 

M_RS9    EQU     9               ; ESAI 

M_RS8    EQU     8               ; ESAI 

M_RS7    EQU     7               ; ESAI 

M_RS6    EQU     6               ; ESAI 

M_RS5    EQU     5               ; ESAI 

M_RS4    EQU     4               ; ESAI 

M_RS3    EQU     3               ; ESAI 

M_RS2    EQU     2               ; ESAI 

M_RS1    EQU     1               ; ESAI 

M_RS0    EQU     0               ; ESAI 



;       TSMB Register bits



M_TS31   EQU     15              ; ESAI 

M_TS30   EQU     14              ; ESAI 

M_TS29   EQU     13              ; ESAI 

M_TS28   EQU     12              ; ESAI 

M_TS27   EQU     11              ; ESAI 

M_TS26   EQU     10              ; ESAI 

M_TS25   EQU     9               ; ESAI 

M_TS24   EQU     8               ; ESAI 

M_TS23   EQU     7               ; ESAI 

M_TS22   EQU     6               ; ESAI 

M_TS21   EQU     5               ; ESAI 

M_TS20   EQU     4               ; ESAI 

M_TS19   EQU     3               ; ESAI 

M_TS18   EQU     2               ; ESAI 

M_TS17   EQU     1               ; ESAI 

M_TS16   EQU     0               ; ESAI 



;       TSMA Register bits



M_TS15   EQU     15              ; ESAI 

M_TS14   EQU     14              ; ESAI 

M_TS13   EQU     13              ; ESAI 

M_TS12   EQU     12              ; ESAI 

M_TS11   EQU     11              ; ESAI 

M_TS10   EQU     10              ; ESAI 

M_TS9    EQU     9               ; ESAI 

M_TS8    EQU     8               ; ESAI 

M_TS7    EQU     7               ; ESAI 

M_TS6    EQU     6               ; ESAI 

M_TS5    EQU     5               ; ESAI 

M_TS4    EQU     4               ; ESAI 

M_TS3    EQU     3               ; ESAI 

M_TS2    EQU     2               ; ESAI 

M_TS1    EQU     1               ; ESAI 

M_TS0    EQU     0               ; ESAI 



;       RCCR Register bits



M_RHCKD  EQU     23              ; ESAI 

M_RFSD   EQU     22              ; ESAI 

M_RCKD   EQU     21              ; ESAI 

M_RHCKP   EQU     20             ; ESAI

M_RFSP   EQU     19              ; ESAI

M_RCKP   EQU     18              ; ESAI 

M_RFP     EQU      $3C000        ; ESAI MASK

M_RFP3   EQU     17              ; ESAI 

M_RFP2   EQU     16              ; ESAI 

M_RFP1   EQU     15              ; ESAI 

M_RFP0   EQU     14              ; ESAI

M_RDC     EQU     $3E00          ; ESAI MASK 

M_RDC4   EQU     13              ; ESAI 

M_RDC3   EQU     12              ; ESAI 

M_RDC2   EQU     11              ; ESAI 

M_RDC1   EQU     10              ; ESAI 

M_RDC0   EQU     9               ; ESAI 

M_RPSR   EQU     8               ; ESAI 

M_RPM     EQU    $FF

M_RPM7   EQU     7               ; ESAI 

M_RPM6   EQU     6               ; ESAI 

M_RPM5   EQU     5               ; ESAI 

M_RPM4   EQU     4               ; ESAI 

M_RPM3   EQU     3               ; ESAI 

M_RPM2   EQU     2               ; ESAI 

M_RPM1   EQU     1               ; ESAI 

M_RPM0   EQU     0               ; ESAI 



;       RCR Register bits



M_RLIE   EQU     23              ; ESAI

M_RIE    EQU     22              ; ESAI

M_REDIE  EQU     21              ; ESAI

M_REIE   EQU     20              ; ESAI

M_RFSR   EQU     16              ; ESAI

M_RFSL   EQU     15              ; ESAI

M_RSWS    EQU       $7C00        ; ESAI MASK

M_RSWS4   EQU     14             ; ESAI

M_RSWS3   EQU     13             ; ESAI

M_RSWS2   EQU     12             ; ESAI

M_RSWS1   EQU     11             ; ESAI 

M_RSWS0   EQU     10             ; ESAI 

M_RMOD      EQU       $300

M_RMOD1  EQU     9               ; ESAI

M_RMOD0  EQU     8               ; ESAI

M_RWA   EQU     7                ; ESAI

M_RSHFD  EQU     6               ; ESAI

M_RE      EQU      $F

M_RE3    EQU     3               ; ESAI

M_RE2    EQU     2               ; ESAI

M_RE1    EQU     1               ; ESAI

M_RE0    EQU     0               ; ESAI



;       TCCR Register bits



M_THCKD  EQU     23              ; ESAI 

M_TFSD   EQU     22              ; ESAI 

M_TCKD   EQU     21              ; ESAI 

M_THCKP   EQU     20             ; ESAI 

M_TFSP   EQU     19              ; ESAI 

M_TCKP   EQU     18              ; ESAI

M_TFP    EQU      $3C000

M_TFP3   EQU     17              ; ESAI 

M_TFP2   EQU     16              ; ESAI 

M_TFP1   EQU     15              ; ESAI 

M_TFP0   EQU     14              ; ESAI

M_TDC     EQU     $3E00       

M_TDC4   EQU     13              ; ESAI 

M_TDC3   EQU     12              ; ESAI 

M_TDC2   EQU     11              ; ESAI 

M_TDC1   EQU     10              ; ESAI 

M_TDC0   EQU     9               ; ESAI 

M_TPSR   EQU     8               ; ESAI

M_TPM     EQU    $FF             

M_TPM7   EQU     7               ; ESAI 

M_TPM6   EQU     6               ; ESAI 

M_TPM5   EQU     5               ; ESAI 

M_TPM4   EQU     4               ; ESAI 

M_TPM3   EQU     3               ; ESAI 

M_TPM2   EQU     2               ; ESAI 

M_TPM1   EQU     1               ; ESAI 

M_TPM0   EQU     0               ; ESAI 



;       TCR Register bits



M_TLIE   EQU     23              ; ESAI

M_TIE    EQU     22              ; ESAI

M_TEDIE  EQU     21              ; ESAI

M_TEIE   EQU     20              ; ESAI

M_TFSR   EQU     16              ; ESAI

M_TFSL   EQU     15              ; ESAI

M_TSWS   EQU    $7C00

M_TSWS4   EQU     14             ; ESAI

M_TSWS3   EQU     13             ; ESAI

M_TSWS2   EQU     12             ; ESAI

M_TSWS1   EQU     11             ; ESAI

M_TSWS0   EQU     10             ; ESAI

M_TMOD    EQU      $300

M_TMOD1  EQU     9               ; ESAI

M_TMOD0  EQU     8               ; ESAI

M_TWA   EQU     7                ; ESAI

M_TSHFD  EQU     6               ; ESAI

M_TEM       EQU     $3F

M_TE5    EQU     5               ; ESAI

M_TE4    EQU     4               ; ESAI

M_TE3    EQU     3               ; ESAI

M_TE2    EQU     2               ; ESAI

M_TE1    EQU     1               ; ESAI

M_TE0    EQU     0               ; ESAI



;       control bits of SAICR



M_ALC   EQU   8                  ;ESAI

M_TEBE   EQU     7               ; ESAI 

M_SYN    EQU     6               ; ESAI 

M_OF2    EQU     2               ; ESAI 

M_OF1    EQU     1               ; ESAI 

M_OF0    EQU     0               ; ESAI 



;       status bits of SAISR



M_TODE   EQU     17              ; ESAI

M_TEDE   EQU     16              ; ESAI

M_TDE    EQU     15              ; ESAI

M_TUE    EQU     14              ; ESAI

M_TFS    EQU     13              ; ESAI

M_RODF   EQU     10              ; ESAI

M_REDF   EQU     9               ; ESAI

M_RDF    EQU     8               ; ESAI

M_ROE    EQU     7               ; ESAI

M_RFS    EQU     6               ; ESAI

M_IF2    EQU     2               ; ESAI

M_IF1    EQU     1               ; ESAI

M_IF0    EQU     0               ; ESAI



;------------------------------------------------------------------------

;

;       EQUATES for HDI08 

;

;------------------------------------------------------------------------



;       Register Addresses

 

M_HOTX    EQU     $FFFFC7        ; HOST Transmit Register (HOTX)

M_HORX    EQU     $FFFFC6        ; HOST Receive Register (HORX)

M_HBAR   EQU     $FFFFC5         ; HOST Base Address Register (HBAR)

M_HPCR   EQU     $FFFFC4         ; HOST Polarity Control Register (HPCR)

M_HSR    EQU     $FFFFC3         ; HOST Status Register (HSR)

M_HCR    EQU     $FFFFC2         ; HOST Control Register (HCR)





;       HCR bits



M_HRIE   EQU     $0              ; HOST Receive interrupts Enable

M_HOTIE   EQU     $1             ; HOST Transmit Interrupt Enable

M_HCIE   EQU     $2              ; HOST Command Interrupt Enable

M_HF2    EQU     $3              ; HOST Flag 2

M_HF3    EQU     $4              ; HOST Flag 3

M_HODM0   EQU     $5             ; HOST DMA Mode Control Bit 0

M_HODM1   EQU     $6             ; HOST DMA Mode Control Bit 1

M_HODM2   EQU     $7             ; HOST DMA Mode Control Bit 2

        

;       HSR bits



M_HRDF   EQU     $0              ; HOST Receive Data Full

M_HOTDE   EQU     $1             ; HOST Receive Data Emptiy

M_HCP    EQU     $2              ; HOST Command Pending

M_HF0    EQU     $3              ; HOST Flag 0

M_HF1    EQU     $4              ; HOST Flag 1

M_DMA    EQU     $7              ; HOST DMA Status

        

;       HPCR bits



M_HGEN   EQU     $0              ; HOST Port Enable

M_HA8EN  EQU     $1              ; HOST Address 8 Enable

M_HA9EN  EQU     $2              ; HOST Address 9 Enable

M_HCSEN  EQU     $3              ; HOST Chip Select Enable

M_HREN   EQU     $4              ; HOST Request Enable

M_HAEN   EQU     $5              ; HOST Acknowledge Enable

M_HOEN    EQU     $6             ; HOST Enable

M_HROD    EQU     $8             ; HOST Request Open Dranin mode

M_HDSP   EQU     $9              ; HOST Data Strobe Polarity

M_HASP   EQU     $a              ; HOST Address Strobe Polarity

M_HMUX   EQU     $b              ; HOST Multiplexed bus select

M_HDDS  EQU     $c               ; HOST Double/Single Strobe select

M_HCSP   EQU     $d              ; HOST Chip Select Polarity

M_HRP    EQU     $e              ; HOST Request PolarityPolarity

M_HAP    EQU     $f              ; HOST Acknowledge Polarity



;                  HBAR  BITS



M_BA   EQU   $FF

M_BA10   EQU   7

M_BA9   EQU   6

M_BA8   EQU   5

M_BA7   EQU   4

M_BA6   EQU   3

M_BA5   EQU   2

M_BA4   EQU   1

M_BA3   EQU   0



;-----------------------------------------------------------------------

;

;       EQUATES for TIMER 

;

;------------------------------------------------------------------------



;       Register Addresses Of TIMER0



M_TCSR0  EQU     $FFFF8F         ; TIMER0 Control/Status Register        

M_TLR0   EQU     $FFFF8E         ; TIMER0 Load Reg   

M_TCPR0  EQU     $FFFF8D         ; TIMER0 Compare Register

M_TCR0   EQU     $FFFF8C         ; TIMER0 Count Register



;       Register Addresses Of TIMER1



M_TCSR1  EQU     $FFFF8B         ; TIMER1 Control/Status Register        

M_TLR1   EQU     $FFFF8A         ; TIMER1 Load Reg   

M_TCPR1  EQU     $FFFF89         ; TIMER1 Compare Register

M_TCR1   EQU     $FFFF88         ; TIMER1 Count Register





;       Register Addresses Of TIMER2



M_TCSR2  EQU     $FFFF87         ; TIMER2 Control/Status Register        

M_TLR2   EQU     $FFFF86         ; TIMER2 Load Reg   

M_TCPR2  EQU     $FFFF85         ; TIMER2 Compare Register

M_TCR2   EQU     $FFFF84         ; TIMER2 Count Register

M_TPLR   EQU     $FFFF83         ; TIMER Prescaler Load Register

M_TPCR   EQU     $FFFF82         ; TIMER Prescalar Count Register



;       Timer Control/Status Register Bit Flags        



M_TE     EQU     0               ; Timer Enable 

M_TOIE   EQU     1               ; Timer Overflow Interrupt Enable

M_TCIE   EQU     2               ; Timer Compare Interrupt Enable

M_TC     EQU     $F0             ; Timer Control Mask (TC0-TC3)

M_INV    EQU     8               ; Inverter Bit

M_TRM    EQU     9               ; Timer Restart Mode 

M_DIR    EQU     11              ; Direction Bit

M_DI     EQU     12              ; Data Input

M_DO     EQU     13              ; Data Output

M_PCE    EQU     15              ; Prescaled Clock Enable

M_TOF    EQU     20              ; Timer Overflow Flag

M_TCF    EQU     21              ; Timer Compare Flag 



;       Timer Prescaler Register Bit Flags        



M_PS    EQU  $600000             ; Prescaler Source Mask

M_PS0   EQU  21

M_PS1   EQU  22



;   Timer Control Bits

M_TC0    EQU     4               ; Timer Control 0

M_TC1    EQU     5               ; Timer Control 1

M_TC2    EQU     6               ; Timer Control 2

M_TC3    EQU     7               ; Timer Control 3


; nVidia timer registers

TIMER1_CONFIG               equ $FFFFB0
TIMER2_CONFIG               equ $FFFFB4

TIMER1_CONTROL              equ $FFFFB1
TIMER2_CONTROL              equ $FFFFB5

TIMER1_TERMINAL_COUNT       equ $ffffB2
TIMER2_TERMINAL_COUNT       equ $ffffB6

TIMER1_COUNT                equ $ffffB3
TIMER2_COUNT                equ $ffffB7
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\dsp\include\IO.h ===
;**************************************************************************
;
;  IO.h    

;**************************************************************************        
	include 'io56kevm.h'


kFrameLength	equ		32
kPCValue		equ		0
kCounter		equ		0

;
; NOTE: keep this in sync with dsound.h and the number of fx sends
; dsound mcpx uses
;

NUM_FX_SEND_BINS    equ     20

; ==============================================================
; Global Processor (GP) Address Map as viewed from dma controller
; ==============================================================
; 24 bit words (3 bytes) in 32-bit containers (4 bytes)
;
; Peripheral registers (Control,Status) mapped to upper 128 words
; of X-memory (0xFFFF80 to 0xFFFFFF) (use compact movep instruction)
;
; DSP    memory addresses in words
; System memory address   in bytes 

kGPMemory_Size_XRAM		equ (4*1024)
kGPMemory_Size_YRAM		equ (2*1024)
kGPMemory_Size_PRAM		equ (4*1024)

kGPMemory_Base					equ $000000
kGPMemory_XRAM_Base				equ (kGPMemory_Base+$000000)		; $000000 .. $000BFF
kGPMemory_XRAM_MixBufferTemp	equ (kGPMemory_XRAM_Base+$000C00)	; $000C00 .. $000FFF
kGPMemory_XRAM_Unused			equ (kGPMemory_XRAM_Base+$001000)	; $001000 .. $0013FF
kGPMemory_XRAM_MixBufferRead	equ (kGPMemory_XRAM_Base+$001400)	; $001400 .. $0017FF
kGPMemory_XRAM_PeripheralRegs	equ (kGPMemory_XRAM_Base+$FFFF80)	; $FFFF80 .. $FFFFFF

kGPMemory_Base_YRAM				equ $1800
kGPMemory_Base_PRAM				equ $2800


; Define these so I don't have to update older files
kGPMemory_Base_XRAM	equ kGPMemory_XRAM_Base
kGPMemory_YRAM_Base	equ kGPMemory_Base_YRAM	

; ==============================================================
; Encode Processor (EP) Address Map 
; ==============================================================
; 24 bit words (3 bytes) in 32-bit containers (4 bytes)
;
; Peripheral registers (Control,Status) mapped to upper 128 words
; of X-memory (0xFFFF80 to 0xFFFFFF) (use compact movep instruction)
;
; DSP    memory addresses in words
; System memory address   in bytes 

kEPMemory_Size_XRAM		equ (3*1024)
kEPMemory_Size_YRAM		equ     256
kEPMemory_Size_YROM		equ (2*1024)
kEPMemory_Size_PRAM		equ (4*1024)

kEPMemory_Base				equ $000000
kEPMemory_Base_XRAM			equ (kEPMemory_Base+$000000)		; $000000 .. $000BFF
kEPMemory_Base_XRAM_PeripheralRegs	equ (kEPMemory_Base_XRAM+$FFFF80)	; $FFFF80 .. $FFFFFF

kEPMemory_Base_YRAM			equ (kEPMemory_Base+$001800)
kEPMemory_Base_YROM			equ (kEPMemory_Base_YRAM+$000800)
kEPMemory_Base_PRAM			equ (kEPMemory_Base+$002000)
kEPMemory_Base_PRAM_BootRom		equ (kEPMemory_Base_PRAM+$FF000)	; $FF0000 .. $FF003F

; ==============================================================
; NOTE:Scratch memory offsets for various GP data blocks
; this MUST match what is in tools\xps2\dsp.h!!!!!
; ==============================================================
; Byte Addresses of Command Node data blocks (DMA'd on the fly)
SM_OFFSET_COMMAND_BLOCK		equ		 2048 


; ==============================================================
; Command block : used to communicate with DSP default loader program
; ==============================================================

COMMAND_BLOCK_FIELD_OFFSET      						equ	0
COMMAND_BLOCK_FIELD_CODE_LENGTH							equ	1
COMMAND_BLOCK_FIELD_STATE_OFFSET                        equ 2
COMMAND_BLOCK_FIELD_STATE_LENGTH						equ	3
COMMAND_BLOCK_FIELD_COMMAND_FLAGS						equ	4
COMMAND_BLOCK_FIELD_STATUS   							equ	5

DATASIZE_DWORD                  equ 4
DATASIZE_COMMAND_BLOCK	        equ	(1+COMMAND_BLOCK_FIELD_STATUS)
DATASIZE_BYTES_COMMAND_BLOCK    equ (DATASIZE_COMMAND_BLOCK*4)


;
; the AC3 dma output gets placed right after the end of scratch space
; NOTE: THIS MUST STAY IN SYNC WITH OFFSET CALCULATED IN DSP.H

SM_OFFSET_AC3_DMA_OUTPUT        equ $8000

;
; the number belows comes form the following calc in mcpxhw.h
; #define MCPX_HW_AC3_NUM_INPUT_PAGES     (((AC3_BUFFER_COUNT * AC3_FRAME_SIZE * AC3_CONTAINER_SIZE * AC3_NUM_CHANNELS) + PAGE_SIZE-1)  / PAGE_SIZE)
;

DATASIZE_BYTES_AC3_DMA_OUTPUT   equ (4096*3)

SM_OFFSET_CODE_BLOCK            equ (SM_OFFSET_COMMAND_BLOCK+DATASIZE_BYTES_COMMAND_BLOCK)
SM_OFFSET_MULTIPASS_BUFFER      equ (SM_OFFSET_AC3_DMA_OUTPUT+DATASIZE_BYTES_AC3_DMA_OUTPUT)
DATASIZE_MULTIPASS_BUFFER       equ (kFrameLength*NUM_FX_SEND_BINS)
DATASIZE_BYTES_MULTIPASS_BUFFER equ (DATASIZE_MULTIPASS_BUFFER*DATASIZE_DWORD)

BIT_COMMAND_BLOCK_COMMAND_PRESENT			equ	0
BIT_COMMAND_BLOCK_COMMAND_LOAD_CODE         equ 0
BIT_COMMAND_BLOCK_COMMAND_LOAD_XRAM_STATE   equ 1
BIT_COMMAND_BLOCK_COMMAND_UPDATE_XRAM_STATE equ 2
    
; status definitions

COMMAND_BLOCK_STATUS_IDLE         equ $AA
COMMAND_BLOCK_STATUS_PROCESSED_CMD          equ $FF


; the global block of the concatenated FX state will be placed at the
; the following offset

GLOBAL_FX_STATE_XRAM_BASE_OFFSET   equ 128 ; eq of 512 in SM
DATASIZE_GLOBAL_FX_STATE           equ 512 ; eq. of 2048 bytes in system ram

AC3_BUFFER_SIZE                    equ $800

;
; debug variables
;

DATASIZE_DEBUG_VARIABLES           equ 4
DEBUG_VARIABLES_OFFSET             equ (GLOBAL_FX_STATE_XRAM_BASE_OFFSET-DATASIZE_DEBUG_VARIABLES)


; definition of the DSP_STATE_FIXED data struct that each FX state block
; has at the base of its X-memory state area

FX_STATE_SCRATCH_BASE    equ 0
FX_STATE_SCRATCH_LENGTH  equ 1
FX_STATE_YMEM_BASE       equ 2
FX_STATE_YMEM_LENGTH     equ 3
FX_STATE_FLAGS           equ 4

DATASIZE_FX_STATE_FIXED  equ 5

;
; flag definitions
;

BIT_FX_STATE_FLAG_INITIALIZED equ $0
VALUE_FX_STATE_FLAG_INITIALIZED  equ $1

BIT_FX_STATE_FLAG_GLOBAL_FX   equ $1
VALUE_FX_STATE_FLAG_GLOBAL_FX equ $2

BIT_FX_STATE_FLAG_UPDATE   equ $2
VALUE_FX_STATE_FLAG_UPDATE equ $4

BIT_FX_STATE_FLAG_PROCESS_STEREO   equ $3
VALUE_FX_STATE_FLAG_PROCESS_STEREO equ $8

; zero inputs Data struct

FX_STATE_IO0_OUT0		    equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO0_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO0_OUT2		    equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO0_OUT3		    equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO0_OUT4		    equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO0_OUT5		    equ	(DATASIZE_FX_STATE_FIXED+5)
FX_STATE_IO0_OUT6		    equ	(DATASIZE_FX_STATE_FIXED+6)
FX_STATE_IO0_OUT7		    equ	(DATASIZE_FX_STATE_FIXED+7)



; Mono In, Mono Out Data Structure
FX_STATE_IO1_IN			    equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO1_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO1_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO1_OUT2		    equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO1_OUT3		    equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO1_OUT4		    equ	(DATASIZE_FX_STATE_FIXED+5)
FX_STATE_IO1_OUT5		    equ	(DATASIZE_FX_STATE_FIXED+6)
FX_STATE_IO1_OUT6		    equ	(DATASIZE_FX_STATE_FIXED+7)
FX_STATE_IO1_OUT7		    equ	(DATASIZE_FX_STATE_FIXED+8)


; Stereo In, Stereo Out Data Structure
FX_STATE_IO2_INL			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO2_INR			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO2_OUTL		    equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO2_OUTR		    equ	(DATASIZE_FX_STATE_FIXED+3)

; 2 inputs, 1 outputs
FX_STATE_IO2_IN0			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO2_IN1			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO2_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+2)

; 2 inputs, 4 outputs
FX_STATE_IO2_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO2_OUT2		    equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO2_OUT3		    equ	(DATASIZE_FX_STATE_FIXED+5)

; 3 inputs, 2 outputs
FX_STATE_IO3_IN0			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO3_IN1			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO3_IN2			equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO3_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO3_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+4)

; 4 inputs, 2 outputs
FX_STATE_IO4_IN0			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO4_IN1			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO4_IN2			equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO4_IN3			equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO4_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO4_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+5)

; 4 inputs, 4 outputs
FX_STATE_IO4_OUT2		    equ	(DATASIZE_FX_STATE_FIXED+6)
FX_STATE_IO4_OUT3		    equ	(DATASIZE_FX_STATE_FIXED+7)

; 6 inputs, 1 output
FX_STATE_IO6_IN0			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO6_IN1			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO6_IN2			equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO6_IN3			equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO6_IN4			equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO6_IN5			equ	(DATASIZE_FX_STATE_FIXED+5)
FX_STATE_IO6_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+6)

DATASIZE_DSP_FX_STATE_MONO      equ (FX_STATE_IO1_OUT0+1)
DATASIZE_DSP_FX_STATE_1IN_2OUT  equ (FX_STATE_IO1_OUT1+1)
DATASIZE_DSP_FX_STATE_1IN_4OUT  equ (FX_STATE_IO1_OUT3+1)
DATASIZE_DSP_FX_STATE_1IN_8OUT  equ (FX_STATE_IO1_OUT7+1)

DATASIZE_DSP_FX_STATE_STEREO    equ (FX_STATE_IO2_OUTR+1)

DATASIZE_DSP_FX_STATE_2IN_1OUT  equ (FX_STATE_IO2_OUT0+1)
DATASIZE_DSP_FX_STATE_2IN_4OUT  equ (FX_STATE_IO2_OUT3+1)

DATASIZE_DSP_FX_STATE_3IN_2OUT  equ (FX_STATE_IO3_OUT1+1)

DATASIZE_DSP_FX_STATE_4IN_2OUT  equ (FX_STATE_IO4_OUT1+1)
DATASIZE_DSP_FX_STATE_4IN_4OUT  equ (FX_STATE_IO4_OUT3+1)

DATASIZE_DSP_FX_STATE_6IN_1OUT  equ (FX_STATE_IO6_OUT0+1)


kFxOutShift	equ	2
kFxOutGain	set	32.0
kFxInGain	set	(1.0/2.0)

; **** Mix Buffer definitions
; The 1K of Mix buffer memory can be used as "standard" 
; read/write memory at X-memory address locations 0x0C00 
; through 0x0FFF (24-bit word address).  However, 
; since this memory is "flipped" at each frame, only 
; variables that do not need to persist beyond a frame 
; boundary can be stored here.

; The 1K of Mix buffer memory can be read at a second 
; address region, X-memory address locations 0x1400 through
; 0x17FF.  In this area, the 32 "mix valid" bits are used 
; to force the data to "0" when the bin is "not valid".  
; this guarantees that bins without voices will read "0" 
; samples (quiet audio).

; Lower 16 mix buffers: 512 words, 32 words x 16 buffers
; Address $C00..$DFF = 3072 ..3583
kMixBufBase	equ		$1400		
kMixBuf00	equ		(kMixBufBase)
kMixBuf01	equ		(kMixBuf00+kFrameLength)
kMixBuf02	equ		(kMixBuf01+kFrameLength)
kMixBuf03	equ		(kMixBuf02+kFrameLength)
kMixBuf04	equ		(kMixBuf03+kFrameLength)
kMixBuf05	equ		(kMixBuf04+kFrameLength)
kMixBuf06	equ		(kMixBuf05+kFrameLength)
kMixBuf07	equ		(kMixBuf06+kFrameLength)
kMixBuf08	equ		(kMixBuf07+kFrameLength)
kMixBuf09	equ		(kMixBuf08+kFrameLength)
kMixBuf10	equ		(kMixBuf09+kFrameLength)
kMixBuf11	equ		(kMixBuf10+kFrameLength)
kMixBuf12	equ		(kMixBuf11+kFrameLength)
kMixBuf13	equ		(kMixBuf12+kFrameLength)
kMixBuf14	equ		(kMixBuf13+kFrameLength)
kMixBuf15	equ		(kMixBuf14+kFrameLength)

; Lower 16 mix buffers: 512 words, 32 words x 16 buffers
; Address $E00..$FFF = 3584 ..3FFF
kMixBuf16	equ		(kMixBuf15+kFrameLength)
kMixBuf17	equ		(kMixBuf16+kFrameLength)
kMixBuf18	equ		(kMixBuf17+kFrameLength)
kMixBuf19	equ		(kMixBuf18+kFrameLength)
kMixBuf20	equ		(kMixBuf19+kFrameLength)
kMixBuf21	equ		(kMixBuf20+kFrameLength)
kMixBuf22	equ		(kMixBuf21+kFrameLength)
kMixBuf23	equ		(kMixBuf22+kFrameLength)
kMixBuf24	equ		(kMixBuf23+kFrameLength)
kMixBuf25	equ		(kMixBuf24+kFrameLength)
kMixBuf26	equ		(kMixBuf25+kFrameLength)
kMixBuf27	equ		(kMixBuf26+kFrameLength)
kMixBuf28	equ		(kMixBuf27+kFrameLength)
kMixBuf29	equ		(kMixBuf28+kFrameLength)
kMixBuf30	equ		(kMixBuf29+kFrameLength)
kMixBuf31	equ		(kMixBuf30+kFrameLength)

kMixBuf0	equ		kMixBuf00
kMixBuf1	equ		kMixBuf01
kMixBuf2	equ		kMixBuf02
kMixBuf3	equ		kMixBuf03
kMixBuf4	equ		kMixBuf04
kMixBuf5	equ		kMixBuf05
kMixBuf6	equ		kMixBuf06
kMixBuf7	equ		kMixBuf07
kMixBuf8	equ		kMixBuf08
kMixBuf9	equ		kMixBuf09

kTmpBufBase	equ		(GLOBAL_FX_STATE_XRAM_BASE_OFFSET+DATASIZE_GLOBAL_FX_STATE)	
kTmpBufCount	equ		4	
kTmpBuf00	equ		kTmpBufBase
kTmpBuf01	equ		(kTmpBuf00+kFrameLength)
kTmpBuf02	equ		(kTmpBuf01+kFrameLength)
kTmpBuf03	equ		(kTmpBuf02+kFrameLength)

kTmpBuf0	equ		kTmpBuf00
kTmpBuf1	equ		kTmpBuf01
kTmpBuf2	equ		kTmpBuf02
kTmpBuf3	equ		kTmpBuf03


kReadWriteMixBufBase    equ     $C00
kReadWriteMixBuf00	equ		(kReadWriteMixBufBase)
kReadWriteMixBuf01	equ		(kReadWriteMixBuf00+kFrameLength)
kReadWriteMixBuf02	equ		(kReadWriteMixBuf01+kFrameLength)
kReadWriteMixBuf03	equ		(kReadWriteMixBuf02+kFrameLength)
kReadWriteMixBuf04	equ		(kReadWriteMixBuf03+kFrameLength)
kReadWriteMixBuf05	equ		(kReadWriteMixBuf04+kFrameLength)
kReadWriteMixBuf06	equ		(kReadWriteMixBuf05+kFrameLength)
kReadWriteMixBuf07	equ		(kReadWriteMixBuf06+kFrameLength)
kReadWriteMixBuf08	equ		(kReadWriteMixBuf07+kFrameLength)
kReadWriteMixBuf09	equ		(kReadWriteMixBuf08+kFrameLength)
kReadWriteMixBuf10	equ		(kReadWriteMixBuf09+kFrameLength)
kReadWriteMixBuf11	equ		(kReadWriteMixBuf10+kFrameLength)
kReadWriteMixBuf12	equ		(kReadWriteMixBuf11+kFrameLength)
kReadWriteMixBuf13	equ		(kReadWriteMixBuf12+kFrameLength)
kReadWriteMixBuf14	equ		(kReadWriteMixBuf13+kFrameLength)
kReadWriteMixBuf15	equ		(kReadWriteMixBuf14+kFrameLength)

; Lower 16 mix buffers: 512 words, 32 words x 16 buffers
; Address $E00..$FFF = 3584 ..3FFF
kReadWriteMixBuf16	equ		(kReadWriteMixBuf15+kFrameLength)
kReadWriteMixBuf17	equ		(kReadWriteMixBuf16+kFrameLength)
kReadWriteMixBuf18	equ		(kReadWriteMixBuf17+kFrameLength)
kReadWriteMixBuf19	equ		(kReadWriteMixBuf18+kFrameLength)
kReadWriteMixBuf20	equ		(kReadWriteMixBuf19+kFrameLength)
kReadWriteMixBuf21	equ		(kReadWriteMixBuf20+kFrameLength)
kReadWriteMixBuf22	equ		(kReadWriteMixBuf21+kFrameLength)
kReadWriteMixBuf23	equ		(kReadWriteMixBuf22+kFrameLength)
kReadWriteMixBuf24	equ		(kReadWriteMixBuf23+kFrameLength)
kReadWriteMixBuf25	equ		(kReadWriteMixBuf24+kFrameLength)
kReadWriteMixBuf26	equ		(kReadWriteMixBuf25+kFrameLength)
kReadWriteMixBuf27	equ		(kReadWriteMixBuf26+kFrameLength)
kReadWriteMixBuf28	equ		(kReadWriteMixBuf27+kFrameLength)
kReadWriteMixBuf29	equ		(kReadWriteMixBuf28+kFrameLength)
kReadWriteMixBuf30	equ		(kReadWriteMixBuf29+kFrameLength)
kReadWriteMixBuf31	equ		(kReadWriteMixBuf30+kFrameLength)

;
; friendly names that match mixbins indices in dsound.h
;

kFrontLeftMixBufRW	    equ		(kReadWriteMixBufBase)
kFrontRightMixBufRW	    equ		(kReadWriteMixBuf00+kFrameLength)
kFrontCenterMixBufRW	equ		(kReadWriteMixBuf01+kFrameLength)
kLFEMixBufRW      	    equ		(kReadWriteMixBuf02+kFrameLength)
kBackLeftMixBufRW 	    equ		(kReadWriteMixBuf03+kFrameLength)
kBackRightMixBufRW	    equ		(kReadWriteMixBuf04+kFrameLength)
kXTLKFrontLeftMixBufRW	equ		(kReadWriteMixBuf05+kFrameLength)
kXTLKFrontRightMixBufRW	equ		(kReadWriteMixBuf06+kFrameLength)
kXTLKBackLeftMixBufRW	equ		(kReadWriteMixBuf07+kFrameLength)
kXTLKBackRightMixBufRW	equ		(kReadWriteMixBuf08+kFrameLength)
kI3DL2MixBufRW    	    equ		(kReadWriteMixBuf09+kFrameLength)
kFxSendMixBuf00RW 	    equ		(kReadWriteMixBuf10+kFrameLength)

kFrontLeftMixBuf	    equ		(kMixBufBase)
kFrontRightMixBuf	    equ		(kMixBuf00+kFrameLength)
kFrontCenterMixBuf	    equ		(kMixBuf01+kFrameLength)
kLFEMixBuf      	    equ		(kMixBuf02+kFrameLength)
kBackLeftMixBuf 	    equ		(kMixBuf03+kFrameLength)
kBackRightMixBuf	    equ		(kMixBuf04+kFrameLength)
kXTLKFrontLeftMixBuf	equ		(kMixBuf05+kFrameLength)
kXTLKFrontRightMixBuf	equ		(kMixBuf06+kFrameLength)
kXTLKBackLeftMixBuf 	equ		(kMixBuf07+kFrameLength)
kXTLKBackRightMixBuf	equ		(kMixBuf08+kFrameLength)
kI3DL2MixBuf    	    equ		(kMixBuf09+kFrameLength)
kFxSendMixBuf00 	    equ		(kMixBuf10+kFrameLength)
kFxSendMixBuf01 	    equ		(kMixBuf11+kFrameLength)
kFxSendMixBuf02 	    equ		(kMixBuf12+kFrameLength)
kFxSendMixBuf03 	    equ		(kMixBuf13+kFrameLength)
kFxSendMixBuf04 	    equ		(kMixBuf14+kFrameLength)
kFxSendMixBuf05 	    equ		(kMixBuf15+kFrameLength)
kFxSendMixBuf06 	    equ		(kMixBuf16+kFrameLength)
kFxSendMixBuf07 	    equ		(kMixBuf17+kFrameLength)
kFxSendMixBuf08 	    equ		(kMixBuf18+kFrameLength)
kFxSendMixBuf09 	    equ		(kMixBuf19+kFrameLength)
kFxSendMixBuf10 	    equ		(kMixBuf20+kFrameLength)


;************************************************************
; mSetUpIO		Set up analog I/O for Motorola EVM board
;************************************************************
mSetUpIO	macro

	ori     #$03,mr                ; mask interrupts

; Clear inputs & outputs
	move    #>(ioData+IO_RX_BUFF_BASE),r0      
	move    #>$FFFF,m0
	move    #0,x0
	rep     #4
	move    x0,x:(r0)+              

	move    #>(ioData+IO_RX_BUFF_BASE),x0
	move    x0,x:(ioData+IO_RX_PTR)
	move    #>(ioData+IO_TX_BUFF_BASE),x0
	move    x0,x:(ioData+IO_TX_PTR)

;------------------------------------------------------------
; FST/FSR and SCKT/SCKR are generated from the PLD
; and fed to the DSP, A/D and D/A converters
;------------------------------------------------------------

	movep   #$0c0200,x:M_TCCR
		;FST is input                            (bit22=0)
		;external clock source drives SCKT       (bit21=0)
		;negative FST polarity                   (bit19=1)
		;data & FST clocked out on rising edge  (bit18=1)
		;2 words per frame                       (bit13:9=00001)

	 movep   #$0c0200,x:M_RCCR
			       
       ; movep   #$080200,x:M_RCCR
		;FSR is input                            (bit22=0)
		;external clock source drives SCKR       (bit21=0)
		;negative FSR polarity                   (bit19=1)
		;data & FSR clocked in on rising edge   (bit18=0)BAK(121997)
		;2 words per frame                       (bit13:9=00001)

	movep   #$000000,x:M_SAICR

	movep   #$d17D01,x:M_RCR                        ;RX0 enabled
		;RX1 enabled                             (bit1=1) MLS 12/20/97
		;RX0, RX2, RX3 disabled                  (bit3:2,0=000)
		;reserved                                (bit5:4=00)  
		;MSB shifted first                       (bit6=0)
		;word left-aligned                       (bit7=0)
		;network mode                            (bit9:8=01)
		;32-bit slot length, 24-bit word length  (bit14:10=11111)
		;word-length frame sync                  (bit15=0)
		;frame sync occurs 1 clock cycle earlier (bit16=1)
		;reserved                                (bit19:17=000)
		;RLIE, RIE, REIE enabled                 (bit23:20=0101)
		;bit23 RLIE
		;bit22 RIE
		;bit21 REDIE
		;bit20 REIE

	movep   #$d17d00,x:M_TCR                      ; Mithra 08-09-99
		;TX0, TX1, TX2 enabled                   (bit3:0=0011)
		;TX3, TX4, TX5 disabled                  (bit5:4=00)
		;MSB shifted first                       (bit6=0)
		;word left-aligned                       (bit7=0)
		;network mode                            (bit9:8=01)
		;32-bit slot length, 24-bit word length  (bit14:10=11111)
		;word length frame sync                  (bit15=0)
		;frame sync occurs 1 clock cycle earlier (bit16=0)
		;reserved                                (bit19:17=000)
		;TLIE, TIE, TEIE enabled                 (bit23:20=0101)
		;bit23 TLIE
		;bit22 TIE
		;bit21 TEDIE
		;bit20 TEIE


	movep   #$000fdb,x:M_PCRC       ; SDO0-SDO3 set for ESAI  - Mithra	 09-08-99
	movep   #$000fdb,x:M_PRRC       ; SDO0-SDO3 set for ESAI  - Mithra	 09-08-99


	movep   #$ffffff,x:M_RSMA        ;MLS 12/20/97
	movep   #$ffffff,x:M_RSMB        ;MLS 12/20/97

	movep   #$000003,x:M_TSMA
	movep   #$000003,x:M_TSMB
	movep   #$000000,x:M_TX0        ;zero out transmitter 0
	movep   #$000000,x:M_TX1        ;zero out transmitter 1
	movep   #$000000,x:M_TX2        ;zero out transmitter 2
	movep   #$000000,x:M_TX3        ;zero out transmitter 3
	bset    #0,x:M_TCR              ;now enable TX0
	bset    #1,x:M_TCR              ;now enable TX1
	bset    #2,x:M_TCR              ;now enable TX2
	bset    #3,x:M_TCR              ;now enable TX3

	andi    #$FC,mr                 ;enable all interrupt levels

	endm
; ---- end mSetUpIO ----

;************************************************************
; mWaitForInputData	
;************************************************************
mWaitForInputData	macro
       jclr    #kRightReceive,X:(ioData+IO_FLAGS),*
       bclr    #kRightReceive,X:(ioData+IO_FLAGS)
	endm

;************************************************************
; mMonoOut	Output reg A to left and right channels
;************************************************************
mMonoOut	macro

; Output 
	move    a,x:(ioData+IO_TX_BUFF_BASE)       ; left
	move    a,x:(ioData+IO_TX_BUFF_BASE+1)      ; right
	endm

;************************************************************
; mStereoOut	Output reg A,B to left and right channels
;************************************************************
mStereoOut	macro

; Output 
	move    a,x:(ioData+IO_TX_BUFF_BASE)       ; left
	move    b,x:(ioData+IO_TX_BUFF_BASE+1)      ; right
	endm

;************************************************************
; mFxStereoIn	
;************************************************************
mFxStereoIn	macro
	move	#>kFxInGain,y0
	move	x:(ioData+IO_RX_BUFF_BASE),x0
	mpy		x0,y0,a
	move	a,x:(fxIOData+FXIO_INL)
	move	x:(ioData+IO_RX_BUFF_BASE+1),x0
	mpy		x0,y0,a
	move	a,x:(fxIOData+FXIO_INR)
	endm

;************************************************************
; mFxOutLToIn	
;************************************************************
mFxOutLToIn	macro
	move	x:(fxIOData+FXIO_OUTL),x0
	move	x0,x:(fxIOData+FXIO_INL)
	endm

;************************************************************
; mFxInLToOutL	
;************************************************************
mFxInLToOutL	macro
	move	x:(fxIOData+FXIO_INL),x0
	move	x0,x:(fxIOData+FXIO_OUTL)
	endm

;************************************************************
; mFxOutLToOutR	
;************************************************************
mFxOutLToOutR	macro
	move	x:(fxIOData+FXIO_OUTL),x0
	move	x0,x:(fxIOData+FXIO_OUTR)
	endm

;************************************************************
; mFxMonoOut	Copy left channel to right and output
;************************************************************
mFxMonoOut	macro
;	move	#>0.99,y0
;	move	x:(fxIOData+FXIO_OUTL),x0
;	mpy	x0,y0,a
;	asl	#>kFxOutShift,a,a
;	move	x:(fxIOData+FXIO_OUTR),x0
;	mpy	x0,y0,b
;	asl	#fxOutShift,b,b
	move	x:(fxIOData+FXIO_OUTL),a

; Output 
	move    a,x:(ioData+IO_TX_BUFF_BASE)       ; left
	move    a,x:(ioData+IO_TX_BUFF_BASE+1)      ; right
	endm

;************************************************************
; mFxStereoOut	
;************************************************************
mFxStereoOut	macro
;	move	#>0.99,y0
;	move	x:(fxIOData+FXIO_OUTL),x0
;	mpy	x0,y0,a
;	asl	#>kFxOutShift,a,a
;	move	x:(fxIOData+FXIO_OUTR),x0
;	mpy	x0,y0,b
;	asl	#fxOutShift,b,b

	move	x:(fxIOData+FXIO_OUTL),a
	move	x:(fxIOData+FXIO_OUTR),b
; Output 
	move    a,x:(ioData+IO_TX_BUFF_BASE)       ; left
	move    b,x:(ioData+IO_TX_BUFF_BASE+1)      ; right
	endm

;************************************************************
; mResetFxIn	Clear FX variable state
;************************************************************
mResetFxIn	macro
; Clear Fx Outputs
	move	#0,x0
	move	x0,x:(fxIOData+FXIO_INL)
	move	x0,x:(fxIOData+FXIO_INR)
	endm

;************************************************************
; mResetFxOut	Clear FX variable state
;************************************************************
mResetFxOut	macro
; Clear Fx Outputs
	move	#0,x0
	move	x0,x:(fxIOData+FXIO_OUTL)
	move	x0,x:(fxIOData+FXIO_OUTR)
	endm

;************************************************************
; mResetFxIO	Clear FX variable state
;************************************************************
mResetFxIO	macro
	mResetFxIn
	mResetFxOut
	endm

;************************************************************
; mFxInToModuleIO1	Copy FX input to module input of IO1 structure
;************************************************************
mFxInToModuleIO1	macro
	move	x:(fxIOData+FXIO_INL),x0
	move	x0,x:(rD+IO1_IN)
	endm

;************************************************************
; mFxInToModuleIO2	Copy FX input to module input of IO2 structure
;************************************************************
mFxInToModuleIO2	macro
	move	x:(fxIOData+FXIO_INL),x0
	move	x0,x:(rD+IO2_IN1)
	endm

;************************************************************
; mModuleIO1toFxOutL	Copy output of IO1 structure to FX output
;************************************************************
mModuleIO1toFxOutL	macro
	move	x:(rD+IO1_OUT),x0
	move	x0,x:(fxIOData+FXIO_OUTL)
	endm

;************************************************************
; mModuleIO1AddtoFxOutL	Add output of IO1 structure to FX output
;************************************************************
mModuleIO1AddtoFxOutL	macro
	move	x:(fxIOData+FXIO_OUTL),a
	move	x:(rD+IO1_OUT),x0
	add		x0,a
	move	a,x:(fxIOData+FXIO_OUTL)
	endm

;************************************************************
; mFxOutLToModuleIO1In	Copy output of IO1 structure to FX output
;************************************************************
mFxOutLToModuleIO1In	macro
	move	x:(fxIOData+FXIO_OUTL),x0
	move	x0,x:(rD+IO1_IN)
	endm

;************************************************************
; mModuleIO1toFxOutR	Copy output of IO1 structure to FX output
;************************************************************
mModuleIO1toFxOutR	macro
	move	x:(rD+IO1_OUT),x0
	move	x0,x:(fxIOData+FXIO_OUTR)
	endm

;************************************************************
; mModuleIO1AddtoFxOutR	Add output of IO1 structure to FX output
;************************************************************
mModuleIO1AddtoFxOutR	macro
	move	x:(fxIOData+FXIO_OUTR),a
	move	x:(rD+IO1_OUT),x0
	add		x0,a
	move	a,x:(fxIOData+FXIO_OUTR)
	endm

;************************************************************
; mFxOutRToModuleIO1In	Copy output of IO1 structure to FX output
;************************************************************
mFxOutRToModuleIO1In	macro
	move	x:(fxIOData+FXIO_OUTR),x0
	move	x0,x:(rD+IO1_IN)
	endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AlphaFog\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AlphaFog\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AntiAlias\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AntiAlias\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AlphaFog\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 7UL

#define Resource_Seafloor_OFFSET 0UL
#define Resource_SkyBoxXN_OFFSET 20UL
#define Resource_SkyBoxXP_OFFSET 40UL
#define Resource_SkyBoxYN_OFFSET 60UL
#define Resource_SkyBoxYP_OFFSET 80UL
#define Resource_SkyBoxZN_OFFSET 100UL
#define Resource_SkyBoxZP_OFFSET 120UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AntiAlias\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AntiAlias\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AntiAlias\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BackBufferScale\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BackBufferScale\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AntiAlias\AntiAlias.cpp ===
//-----------------------------------------------------------------------------
// File: AntiAlias.cpp
//
// Desc: Demonstrates the various anti-alias modes
//
// Hist: 11.29.01 - Created
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <xgraphics.h>

#include "Resource.h"

//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Scene.bmp",      resource_Scene_OFFSET },
    { "Scene1.bmp",     resource_Scene1_OFFSET },
    { NULL, 0 },
};

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_A_BUTTON,  XBHELP_PLACEMENT_2, L"Change AntiAlias\nMode" },
    { XBHELP_X_BUTTON,  XBHELP_PLACEMENT_1, L"Change Model" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate Object" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Zoom" },

};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )


#define FAR_PLANE  20.0f
#define EARTH_FAR_PLANE 200000.0f
#define NEAR_PLANE 1.0f

#define XBMESH_RENDERSHAPENUM 0xffff0000 // Render ShapeNumber is MSB portion

#define DRAW_TEAPOT							0
#define DRAW_CAR							1
#define MAX_DRAW_OBJECTS					DRAW_CAR

typedef struct
{
    DWORD           m_dwAntiAliasModeId;
    WCHAR*          m_wstrAntiAliasModeName;
} AntiAliasMode;

AntiAliasMode g_AntiAliasModes[] =
{
    { D3DMULTISAMPLE_NONE,                                    L"None"                                   },
    { D3DMULTISAMPLE_NONE,                                    L"Edge Anti-Alias"                        },
    { D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR,            L"2x MultiSample Linear Filter"           },
    { D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX,          L"2x MultiSample Quincunx Filter"         },
    { D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR, L"2x SuperSample Linear Horizontal Filter"},
    { D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR,   L"2x SuperSample Linear Vertical Filter"  },
    { D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR,            L"4x MultiSample Linear Filter"           },
    { D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN,          L"4x MultiSample Gaussian Filter"         },
    { D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR,            L"4x SuperSample Linear Filter"           },
    { D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN,          L"4x SuperSample Gaussian Filter"         },
    { D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN,          L"9x MultiSample Gaussian Filter"         },
    { D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN,          L"9x SuperSample Gaussian Filter"         },
};

#define EDGE                                1
#define MAX_ANTIALIAS_MODES					11

//-----------------------------------------------------------------------------
// Name: class CCarMesh
// Desc: Class to load and render geometry. Most functionality is inherited
//       from the CXBMesh base class.  Override renderMesh so I can change
//       the materials on the pieces of the car.
//-----------------------------------------------------------------------------
class CCarMesh : public CXBMesh
{

public:

    virtual HRESULT RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                                DWORD dwFlags );

};




//-----------------------------------------------------------------------------
// Name: CCarMesh::RenderMesh()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CCarMesh::RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                             DWORD dwFlags )
{
    D3DVertexBuffer* pVB           = &pMesh->m_VB;
    DWORD            dwNumVertices =  pMesh->m_dwNumVertices;
    D3DIndexBuffer*  pIB           = &pMesh->m_IB;
    DWORD            dwNumIndices  =  pMesh->m_dwNumIndices;
    DWORD            dwFVF         =  pMesh->m_dwFVF;
    DWORD            dwVertexSize  =  pMesh->m_dwVertexSize;
    D3DPRIMITIVETYPE dwPrimType    =  pMesh->m_dwPrimType;
    DWORD            dwNumSubsets  =  pMesh->m_dwNumSubsets;
    XBMESH_SUBSET*   pSubsets      = &pMesh->m_pSubsets[0];

    (VOID)dwNumIndices; // not used

    if( dwNumVertices == 0 )
        return S_OK;

    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, pVB, dwVertexSize );
    pd3dDevice->SetIndices( pIB, 0 );

    // Set the FVF code, unless the user asked us not to
    if( 0 == ( dwFlags & XBMESH_NOFVF ) )
        pd3dDevice->SetVertexShader( dwFVF );

    // Render the subsets
    DWORD dwStartShape = 0;
    DWORD dwEndShape = dwNumSubsets;

    if (dwFlags & XBMESH_RENDERSHAPENUM)
    {
        dwStartShape = (dwFlags >> 16) - 1;
        dwEndShape = dwStartShape + 1;

        // If they passed us in a bad subset,
        // just start drawing at zero and draw all.
        if (dwStartShape >= dwNumSubsets)
        {
            dwStartShape = 0;
            dwEndShape = dwNumSubsets;
        }
    }

    for( DWORD i = dwStartShape; i < dwEndShape; i++ )
    {
        BOOL bRender = FALSE;

        // Render the opaque subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_ALPHAONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    bRender = TRUE;
            }
            else
                bRender = TRUE;
        }

        // Render the transparent subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_OPAQUEONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    bRender = TRUE;
            }
        }

        if( bRender )
        {
            // Set the material, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
                pd3dDevice->SetMaterial( &pSubsets[i].mtrl );

            // Set the texture, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOTEXTURES ) )
                pd3dDevice->SetTexture( 0, pSubsets[i].pTexture );

            // Call the callback, so the app can tweak state before rendering
            // each subset
            BOOL bRenderSubset = RenderCallback( pd3dDevice, i, &pSubsets[i], dwFlags );

            // Draw the mesh subset
            if( bRenderSubset )
            {
                DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == dwPrimType ) ? 
                                    pSubsets[i].dwIndexCount-2 : pSubsets[i].dwIndexCount/3;
                pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, pSubsets[i].dwIndexCount,
                                                  pSubsets[i].dwIndexStart, dwNumPrimitives );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    CXBFont     m_Font;             // Font object
    CXBHelp     m_Help;             // Help object
    BOOL        m_bDrawHelp;        // TRUE to draw help screen


	CXBPackedResource  m_xprResource;      			// Packed resources for the app

    CXBMesh    		   m_Teapot;					// Test Teapot
    LPDIRECT3DTEXTURE8 m_pSphereMapTexture;			// Texture for Sphere mapping

    CCarMesh           m_Car;						// Test Car

    D3DXMATRIX         m_matWorld;					// Transform matrices
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matProj;

	D3DXVECTOR3        m_vCameraPosition;			// Camera position and look vector
	D3DXVECTOR3        m_vLookPosition;

	FLOAT              m_fXObjRotate;				// Rotation values for Teapot
	FLOAT              m_fYObjRotate;

	DWORD              m_dwFresnelShader;           // Handle to the Fresnel Vertex Shader

	DWORD              m_dwCarBody; 	  			// Handle to Pixel Shader for car body
	DWORD              m_dwCarWindow;	  			// Handle to Pixel Shader for car Windows

	DWORD         	   m_dwDrawObject;	  	   		// Tells me which object to draw.

	DWORD			   m_dwAntiAliasMode;           // Tells me what anti-alias mode to use.
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp = FALSE;

    // Do not wait for VSync.  
    // Show changes in framerate from different antiAlias Modes.
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a mesh (vertex and index buffers) for the teapot
    if( FAILED( m_Teapot.Create( m_pd3dDevice, "Models\\Teapot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a mesh (vertex and index buffers) for the car
    if( FAILED( m_Car.Create( m_pd3dDevice, "Models\\GenericSedan.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the spheremap texture
    m_pSphereMapTexture = m_xprResource.GetTexture( "Scene1.bmp" );

    // Set the transform matrices
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixIdentity( &m_matView );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4.0f, 4.0f/3.0f, 
                                NEAR_PLANE, FAR_PLANE );

	// Setup the camera look and position vectors
	m_vLookPosition.x = 
	m_vLookPosition.y = 
	m_vLookPosition.z = 0.f;

	m_vCameraPosition.x = 5.f;
	m_vCameraPosition.y = m_vCameraPosition.z = 0.f;

	// Set initial rotation of object
	m_fXObjRotate = m_fYObjRotate = 0.f;

	// Set which object to draw
	m_dwDrawObject = DRAW_TEAPOT;

    // Set initial Anti-Alias mode to none
    m_dwAntiAliasMode = 0;

    // Create vertex shaders
    {
        DWORD dwDecl[] =
        {
            D3DVSD_STREAM( 0 ),
            D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),
            D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),
			D3DVSD_REG( 2, D3DVSDT_FLOAT2 ),
            D3DVSD_END()
        };

        if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\fresnel.xvu",
                                               dwDecl, &m_dwFresnelShader ) ) )
            return XBAPPERR_MEDIANOTFOUND;
    }

    // Create the pixel shaders
    if( FAILED( XBUtil_CreatePixelShader( m_pd3dDevice, "Shaders\\caropaque.xpu",
                                          &m_dwCarBody ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( XBUtil_CreatePixelShader( m_pd3dDevice, "Shaders\\cartransparent.xpu",
                                          &m_dwCarWindow ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
    }

	//Toggle Anti-Alias mode
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
	{
		++m_dwAntiAliasMode;

		if ( m_dwAntiAliasMode > MAX_ANTIALIAS_MODES)
		{
			m_dwAntiAliasMode = 0;
		}

		// Just reset the MultiSampleType in m_d3dpp.
		m_d3dpp.MultiSampleType = g_AntiAliasModes[m_dwAntiAliasMode].m_dwAntiAliasModeId;

		// Reset the device - Just changes the screen resolution and 
		// Backbuffer size on Xbox.
        HRESULT hr = S_OK;
		if( FAILED( hr = m_pd3dDevice->Reset( &m_d3dpp ) ) )
		{
			return hr;
		}
	}

	//Toggle Object
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
	{
		++m_dwDrawObject;

		if( m_dwDrawObject > MAX_DRAW_OBJECTS )
		{
			m_dwDrawObject = 0;
		}

		switch( m_dwDrawObject )
		{
			case DRAW_TEAPOT:
				m_vCameraPosition.x = m_Teapot.ComputeRadius() * 3.0f;
				break;

			case DRAW_CAR:
				m_vCameraPosition.x = m_Car.ComputeRadius() * 3.0f;
				break;
		}
	}

    // Setup the projection matrix
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4.0f, 4.0f/3.0f, 
        NEAR_PLANE, FAR_PLANE );

	// Setup the view Matrix
	D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f );
	D3DXMatrixLookAtLH( &m_matView, &m_vCameraPosition, &m_vLookPosition, &vUp );

	// Check if we should rotate the object
    m_fXObjRotate += m_DefaultGamepad.fX1 * D3DX_PI * m_fElapsedTime;
    m_fYObjRotate += m_DefaultGamepad.fY1 * D3DX_PI * m_fElapsedTime;

	// Check if we should move the camera in or out.
	FLOAT fCameraZoomFactor = 1.0f;
	m_vCameraPosition.x += m_DefaultGamepad.fY2 * fCameraZoomFactor * m_fElapsedTime;

    // Setup object matrix
    D3DXMATRIX matObjRotate;
    D3DXMatrixRotationYawPitchRoll( &matObjRotate, -m_fXObjRotate, -m_fYObjRotate, 0.0f );
    
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixMultiply( &m_matWorld, &m_matWorld, &matObjRotate );

	// Setup the fresnel rotate matrix
    D3DXMATRIX matFresnelRotate;

	FLOAT fDeterminant = 0.f;
	D3DXMatrixInverse( &matFresnelRotate, &fDeterminant, &matObjRotate );

    // Setup the vertex shader constants
    {
		// Create the World/view/projection matrix concatenation
        D3DXMATRIX mat;
		D3DXMatrixMultiply( &mat, &m_matWorld, &m_matView );
        D3DXMatrixMultiply( &mat, &mat, &m_matProj );
        D3DXMatrixTranspose( &mat, &mat );

		// Rotate the camera normal into the Object's rotational frame.
		// Saves us having to transform all of the vectors on the object in the shader!
		D3DXVECTOR3 vCameraNormal( 1.0f, 0.0f, 0.0f );
		D3DXVECTOR3 vRotatedNormal;
		D3DXVec3TransformNormal( &vRotatedNormal, &vCameraNormal, &matFresnelRotate );

        m_pd3dDevice->SetVertexShaderConstant( 0, &mat, 4 );
        m_pd3dDevice->SetVertexShaderConstant( 4, &vRotatedNormal, 1 );

		// Generate spheremap texture coords from the position
		D3DXMATRIX matTexture;
		D3DXMatrixIdentity( &matTexture );
		matTexture._11 = 0.5f; matTexture._12 = 0.0f;
		matTexture._21 = 0.0f; matTexture._22 =-0.5f;
		matTexture._14 = 0.5f; matTexture._24 = 0.5f;

		D3DXMatrixMultiply( &matTexture, &matTexture, &mat );
		m_pd3dDevice->SetVertexShaderConstant( 15, &matTexture, 4 );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL|D3DCLEAR_TARGET,
                         0x00404040, 1.0f, 0L );

    // Setup render state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

	m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
	m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
	m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );

    // Draw a gradient filled background
    if ( (m_dwDrawObject == DRAW_TEAPOT) || m_bDrawHelp)
        RenderGradientBackground( 0xff404040, 0xff4040C0 );

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );

    // Draw the Object desired
	switch( m_dwDrawObject )
	{
		case DRAW_TEAPOT:
		{
			// If we are in edge anti-alias mode, set the render states
			// Done somewhat redundantly here for clarity.
			if (m_dwAntiAliasMode == EDGE)
			{
                //--------------------------------------------------------------------------------
                // NOTE:  THIS IS VERY IMPORTANT
                //
                // Edge anti-aliasing works by drawing an alpha edge to each triangle and
                // line which is rendered.  For objects which are drawn WITHOUT zBuffer
                // writes and in alpha mode Src Alpha, Dest One, like the teapot, this works 
                // great. For any other kind of object, if you do not draw the object 
                // un-aliased first, you will get a wire frame set of artifacts because the 
                // alphas write to the zbuffer as well as the normal triangles.  The alphaed 
                // edges take on the color behind them which is the background of the 
                // backbuffer.  You need the background color to be the actual object color for
                // that location.  This is still a big win over the normal anit-aliasing modes 
                // because you don't need a giant backbuffer to get the aliasing you want.  
                // Also, you can pick and choose what objects to anti-alias!
                //
                //--------------------------------------------------------------------------------
				m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE );
				m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );
			}

			// Set new constants for this object.
            // Setup constants
            D3DXVECTOR4 vForceColor( 0.45f, 0.45f, 0.45f, 1.0f );
            D3DXVECTOR4 vConstants( 1.0f, 0.5f, 3.0f, 0.15f );
            D3DXVECTOR4 vConstants1( 1.0f, 0.0f, 0.0f, 0.0f );

            m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
            m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
            m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );

			// Set the vertex Shader
			m_pd3dDevice->SetVertexShader( m_dwFresnelShader );

			// Adds in the teapot's sphere map
			m_pd3dDevice->SetTexture( 0, m_pSphereMapTexture );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	
			m_Teapot.Render( m_pd3dDevice, XBMESH_NOTEXTURES | XBMESH_NOFVF );
		}
		break;

		case DRAW_CAR:
		{
			// Set render state changes for the car
    		m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
			m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
            m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESSEQUAL );
	
			// Set new constants for the additional work.
			{
				D3DXVECTOR4 vForceColor( 0.0f, 0.23f, 0.70f, 1.0f );
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.5f, 0.15f );
                D3DXVECTOR4 vConstants1( 0.35f, 0.0f, 0.0f, 0.0f );
	
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
                m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}
	
			// Set the Vertex and Pixel Shader
			m_pd3dDevice->SetVertexShader( m_dwFresnelShader );
            m_pd3dDevice->SetPixelShader( m_dwCarBody );
	
			// Adds in the car's sphere map
			m_pd3dDevice->SetTexture( 0, m_pSphereMapTexture );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
			m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );


            // Draw the roof and sides of car - 
            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (1<<16) );
	
			// If we are in edge anti-alias mode, set the render states
			// Done somewhat redundantly here for clarity.
			if( m_dwAntiAliasMode == EDGE )
			{
				m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE );
				m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

                //--------------------------------------------------------------------------------
                // NOTE:  THIS IS VERY IMPORTANT
                //
                // Edge anti-aliasing works by drawing an alpha edge to each triangle and
                // line which is rendered.  For objects which are drawn WITHOUT zBuffer
                // writes and in alpha mode Src Alpha, Dest One, like the teapot, this works 
                // great. For any other kind of object, if you do not draw the object 
                // un-aliased first, you will get a wire frame set of artifacts because the 
                // alphas write to the zbuffer as well as the normal triangles.  The alphaed 
                // edges take on the color behind them which is the background of the 
                // backbuffer.  You need the background color to be the actual object color for
                // that location.  This is still a big win over the normal anit-aliasing modes 
                // because you don't need a giant backbuffer to get the aliasing you want.  
                // Also, you can pick and choose what objects to anti-alias!
                //
                // To see what happens if you don't do this, comment out the m_Car.RenderMesh
                // call directly above the if( m_dwAntiAlias == EDGE ) statement.
                //
                //--------------------------------------------------------------------------------
                m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                                  XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (1<<16) );

                //Reset the render states to draw the next piece of car.
				m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );
			}

            // Draw the underside of the car - Much darker color
			{
				D3DXVECTOR4 vForceColor( 0.0f, 0.03f, 0.15f, 1.0f );
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.5f, 0.15f );
                D3DXVECTOR4 vConstants1( 0.25f, 0.0f, 0.0f, 0.0f );
	
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
                m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}

            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (2<<16) );

			// If we are in edge anti-alias mode, set the render states
			// Done somewhat redundantly here for clarity.
			if( m_dwAntiAliasMode == EDGE )
			{
				m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE );
				m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

                //--------------------------------------------------------------------------------
                // NOTE:  THIS IS VERY IMPORTANT
                //
                // Edge anti-aliasing works by drawing an alpha edge to each triangle and
                // line which is rendered.  For objects which are drawn WITHOUT zBuffer
                // writes and in alpha mode Src Alpha, Dest One, like the teapot, this works 
                // great. For any other kind of object, if you do not draw the object 
                // un-aliased first, you will get a wire frame set of artifacts because the 
                // alphas write to the zbuffer as well as the normal triangles.  The alphaed 
                // edges take on the color behind them which is the background of the 
                // backbuffer.  You need the background color to be the actual object color for
                // that location.  This is still a big win over the normal anit-aliasing modes 
                // because you don't need a giant backbuffer to get the aliasing you want.  
                // Also, you can pick and choose what objects to anti-alias!
                //
                // To see what happens if you don't do this, comment out the m_Car.RenderMesh
                // call directly above the if( m_dwAntiAlias == EDGE ) statement.
                //
                //--------------------------------------------------------------------------------
                m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                                  XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (2<<16) );

                //Reset the render states to draw the next piece of car.
				m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );
			}

            // Draw the Window seals of the car - Black.  No reflection
			{
				D3DXVECTOR4 vForceColor( 0.0f, 0.0f, 0.0f, 0.0f );
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.5f, 0.15f );
                D3DXVECTOR4 vConstants1( 0.15f, 0.0f, 0.0f, 0.0f );
	
				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
                m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}

            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (5<<16) );

            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (6<<16) );

			// If we are in edge anti-alias mode, set the render states
			// Done somewhat redundantly here for clarity.
			if( m_dwAntiAliasMode == EDGE )
			{
				m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE );
				m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

                //--------------------------------------------------------------------------------
                // NOTE:  THIS IS VERY IMPORTANT
                //
                // Edge anti-aliasing works by drawing an alpha edge to each triangle and
                // line which is rendered.  For objects which are drawn WITHOUT zBuffer
                // writes and in alpha mode Src Alpha, Dest One, like the teapot, this works 
                // great. For any other kind of object, if you do not draw the object 
                // un-aliased first, you will get a wire frame set of artifacts because the 
                // alphas write to the zbuffer as well as the normal triangles.  The alphaed 
                // edges take on the color behind them which is the background of the 
                // backbuffer.  You need the background color to be the actual object color for
                // that location.  This is still a big win over the normal anit-aliasing modes 
                // because you don't need a giant backbuffer to get the aliasing you want.  
                // Also, you can pick and choose what objects to anti-alias!
                //
                // To see what happens if you don't do this, comment out the m_Car.RenderMesh
                // calls directly above the if( m_dwAntiAlias == EDGE ) statement.
                //
                //--------------------------------------------------------------------------------
                m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                                  XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (5<<16) );

                m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                                  XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (6<<16) );

                //Reset the render states to draw the next piece of car.
				m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, TRUE );
				m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS, FALSE );
			}

			// Set the Pixel Shader for the windows and mirrors
            m_pd3dDevice->SetPixelShader( m_dwCarWindow );
	
            // Draw the Windows and mirrors of the car - Not drawn above so transparent
            // There is almost no difference between drawing the windows Edge anti-aliased
            // and drawing them without the edge anti-aliasing.  This is because the "edges"
            // of the windows were already drawn above with edge anti-aliasing on.  Since
            // the zbuffer values for the "edges" are already written, the other edges do
            // not contribute much to the final appearance.  Games should check what parts
            // of an object need aliasing to help performance.
			{
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.5f, 0.85f );
				D3DXVECTOR4 vConstants1( 1.0f, 0.0f, 0.0f, 0.0f );
				D3DXVECTOR4 vForceColor( 0.75f, 0.75f, 0.75f, 1.0f );

				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}

            m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (3<<16) );

			//Make mirrors more reflective then transparent
			{
				D3DXVECTOR4 vConstants( 1.0f, 0.5f, 1.5f, 0.15f );
				D3DXVECTOR4 vConstants1( 0.75f, 0.0f, 0.0f, 0.0f );
				D3DXVECTOR4 vForceColor( 0.75f, 0.75f, 0.75f, 1.0f );

				m_pd3dDevice->SetVertexShaderConstant( 5, &vForceColor, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 6, &vConstants, 1 );
				m_pd3dDevice->SetVertexShaderConstant( 7, &vConstants1, 1 );
			}

  			m_Car.RenderMesh( m_pd3dDevice, m_Car.GetMesh(0),
                              XBMESH_NOTEXTURES | XBMESH_NOMATERIALS | XBMESH_NOFVF | (4<<16) );
		}
		break;

	}

    // Turn off the anti-alias mode so that the fonts look better
    m_pd3dDevice->SetRenderState( D3DRS_MULTISAMPLEANTIALIAS, FALSE );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"AntiAlias" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR msg[1024];
        swprintf(msg,L"AntiAlias Mode - %s",g_AntiAliasModes[m_dwAntiAliasMode].m_wstrAntiAliasModeName);

        m_Font.DrawText(  64, 70, 0xffffffff, msg);

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AntiAlias\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Scene_OFFSET 0UL
#define resource_Scene1_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AlphaFog\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 7UL

#define Resource_Seafloor_OFFSET 0UL
#define Resource_SkyBoxXN_OFFSET 20UL
#define Resource_SkyBoxXP_OFFSET 40UL
#define Resource_SkyBoxYN_OFFSET 60UL
#define Resource_SkyBoxYP_OFFSET 80UL
#define Resource_SkyBoxZN_OFFSET 100UL
#define Resource_SkyBoxZP_OFFSET 120UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\AntiAlias\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Scene_OFFSET 0UL
#define resource_Scene1_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BackBufferScale\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BackBufferScale\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Tree02s_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BackBufferScale\BackBufferScale.cpp ===
//-----------------------------------------------------------------------------
// File: BackBufferScale.cpp
//
// Desc: This sample shows how to use the SetBackBufferScale API to reduce
//       (via a scale factor) the effective size of the backbuffer. Scaling the
//       backbuffer dynamically lessens the fill requirements of the app, so
//       this is a technique that could be useful for fillbound apps that are
//       willing to sacrifice quality in order to maintain framerate.
//
//       To prevent tearing, note that the rendering device is created with
//       two backbuffers. After rendering a scene, the backbuffer is scaled and
//       copied to the next buffer in the chain, via the Swap() API. In between
//       the two swap calls, non-scaled elements (such as for UI objects) are
//       drawn.
//
// Hist: 11.29.01 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBMesh.h>
#include "Resource.h" // Constants for bundled resources




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define NUM_TREES 500

// Custom vertex for the trees
struct TREEVERTEX
{
    D3DXVECTOR3 pos;
    D3DCOLOR    color;
    FLOAT       tu, tv;
};


struct Tree
{
    TREEVERTEX v[4];
};


inline FLOAT GaussianRand( FLOAT min, FLOAT max, FLOAT width )
{
    FLOAT x = (FLOAT)(rand()-rand())/RAND_MAX;
    return (max-min)*expf( -width*x*x) + min;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class

    LPDIRECT3DTEXTURE8 m_pTreeTexture;       // Tree images
    Tree*              m_Trees;              // Array of tree info

    FLOAT              m_fBackBufferScale;   // Amount to scale backbuffer by 

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: TreeSortCB()
// Desc: Callback function for sorting trees in back-to-front order
//-----------------------------------------------------------------------------
int _cdecl TreeSortCB( const VOID* arg1, const VOID* arg2 )
{
    Tree* p1 = (Tree*)arg1;
    Tree* p2 = (Tree*)arg2;

    if( p1->v[0].pos.z < p2->v[0].pos.z )
        return +1;

    return -1;
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // To prevent tearing, use 2 backbuffers
    m_d3dpp.BackBufferCount = 2; 

    // Initialize members
    m_pTreeTexture            = NULL;

    // Initialize the tree data
    m_Trees = new Tree[NUM_TREES];

    for( DWORD i=0; i<NUM_TREES; i++ )
    {
        // Position and size the trees randomly
        FLOAT y = 0.0f;
        FLOAT z = 5.0f + ( 60.0f * rand() ) / RAND_MAX;
        FLOAT x = ( 0.6f * z * (rand()-rand()) ) / RAND_MAX;
        FLOAT w = GaussianRand( 5.0f, 2.0f, 2.0f );
        FLOAT h = GaussianRand( 7.0f, 4.0f, 2.0f );

        // Each tree is a random color between red and green
        DWORD r = (DWORD)(255 * ( (0.25f) + (0.75f*rand())/RAND_MAX) );
        DWORD g = (DWORD)(255 * ( (0.25f) + (0.75f*rand())/RAND_MAX) );
        DWORD b = 0x00;
        DWORD color = (0xff<<24)|(r<<16)|(g<<8)|(b);

        m_Trees[i].v[0].pos = D3DXVECTOR3( x-w, 0, z );
        m_Trees[i].v[1].pos = D3DXVECTOR3( x-w, h, z );
        m_Trees[i].v[2].pos = D3DXVECTOR3( x+w, h, z );
        m_Trees[i].v[3].pos = D3DXVECTOR3( x+w, 0, z );
        m_Trees[i].v[0].color = color;
        m_Trees[i].v[1].color = color;
        m_Trees[i].v[2].color = color;
        m_Trees[i].v[3].color = color;
        m_Trees[i].v[0].tu = 0.0f;   m_Trees[i].v[0].tv = 1.0f; 
        m_Trees[i].v[1].tu = 0.0f;   m_Trees[i].v[1].tv = 0.0f; 
        m_Trees[i].v[2].tu = 1.0f;   m_Trees[i].v[2].tv = 0.0f; 
        m_Trees[i].v[3].tu = 1.0f;   m_Trees[i].v[3].tv = 1.0f; 
    }

    // Sort trees in back-to-front order (depends on global g_vEyePt)
    qsort( m_Trees, NUM_TREES, sizeof(Tree), TreeSortCB );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get access to the tree texture
    m_pTreeTexture = m_xprResource.GetTexture( resource_Tree02s_OFFSET );

    // Set the transform matrices (view matrix is set in FrameMove())
    D3DXMATRIX  matWorld, matView, matProj;
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 7.0f,  0.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 5.0f, 10.0f );
    D3DXVECTOR3 vUp       = D3DXVECTOR3( 0.0f, 1.0f,  0.0f );
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUp );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Scale the viewport to reduce fill requirements
    FLOAT fIn = (m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / 255.0f);
    m_fBackBufferScale = 1.0f - 0.90f * fIn; 

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Before we draw anything, scale the backbuffer
    m_pd3dDevice->SetBackBufferScale( m_fBackBufferScale, m_fBackBufferScale );

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x000000ff, 1.0f, 0L );

    // Draw a bunch of trees to eat up fill
    {
        // Set up the default state
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

        // Set the tree texture
        m_pd3dDevice->SetTexture( 0, m_pTreeTexture );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

        // Turn on z-buffer, and disable alphatest for worse performance (yes,
        // we want worse performance, since we're trying to make this app
        // fill-limitied).
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    
        // Render the trees. With the above states, this should eat plenty of fill
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1 );
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, NUM_TREES, m_Trees, sizeof(TREEVERTEX) );
    }

    // Instead of calling Present(), we call Swap() to swap our scaled-down
    // backbuffer to the next buffer in the chain, and then write UI and other
    // visual elements that we want drawn at full resolution.
    m_pd3dDevice->Swap( D3DSWAP_COPY );

    // Between the D3DSWAP_COPY and D3DSWAP_FINISH calls, draw text and any
    // other screenspace elements that we don't want affected by the viewport
    // scale.
    {
        WCHAR strScale[100];
        swprintf( strScale, L"Backbuffer is %ld x %ld", (DWORD)(m_fBackBufferScale*640), 
                                                        (DWORD)(m_fBackBufferScale*480) );

        m_Font.Begin();
        m_Font.DrawText(  64,  50, 0xffffffff, L"BackBufferScale" );
        m_Font.DrawText( 450,  50, 0xffcccc00, m_strFrameRate );
        m_Font.DrawText(  64,  75, 0xffcccc00, strScale );
        m_Font.DrawText(  64, 100, 0xff00ffff, L"Use the right trigger to change the backbuffer scale" );
        m_Font.End();
    }

    // After drawing non-scaled UI elements, finish the swap
    m_pd3dDevice->Swap( D3DSWAP_FINISH );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BeginPush\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BeginPush\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BeginPush\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BeginPush\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BeginPush\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BackBufferScale\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Tree02s_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\benchmark\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\benchmark\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\benchmark\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BeginPush\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Particle_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\benchmark\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BeginPush\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Particle_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BeginPush\BeginPush.cpp ===
//-----------------------------------------------------------------------------
// File: BeginPush.cpp
//
// Desc: Example code showing how to use the BeginPush() API to write
//       dynamic vertices to the pushbuffer. 
//
//       The CPU time to write the vertices is timed, along with other draw
//       methods (DrawPrimitiveUP() and Begin()) for performance comparison.
//
// Hist: 11.27.01 - New for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include "Resource.h"  // Constants for bundled resources




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Switch draw\nmethods" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Structure and data for Streaks
//-----------------------------------------------------------------------------
#define NUM_STREAKS         13
#define TRAIL_SIZE        100

struct StreakObject
{
    D3DXVECTOR3 vLastPositions[TRAIL_SIZE];

    D3DXVECTOR3 vPos;
    D3DXVECTOR3 vDir;       // Current direction
    D3DXVECTOR3 vDeltaPos;  // Change in position from flock centering
    D3DXVECTOR3 vDeltaDir;  // Change in direction
    WORD        wDeltaCnt;  // Number of streaks that influence this vDeltaDir
    FLOAT       fSpeed;
    FLOAT       fYaw, fPitch, fRoll, fDYaw;
    D3DCOLOR    Color;
    FLOAT       afDist[NUM_STREAKS]; // Array of distances to other streaks
};

StreakObject g_pStreaks[NUM_STREAKS];  // Array of streaks
D3DXVECTOR3  g_vGoal;                  // Goal for each streak to head for
const FLOAT cfInfluenceRadius        = 20.0f;
const FLOAT cfInfluenceRadiusSquared = cfInfluenceRadius * cfInfluenceRadius;
const FLOAT cfCollisionFraction      = 0.8f;
const FLOAT cfInvCollisionFraction   = 1.0f/(1.0f-cfCollisionFraction);
const FLOAT cfParticleSize           = 2.0f;
const FLOAT cfNormalSpeed            = 0.2f;
const FLOAT cfAngleTweak             = 0.02f;
const FLOAT cfPitchToSpeedRatio      = 0.002f;

// Function to update the flock of streaks
VOID UpdateFlock();

// Helper macro
#define rnd()  (((FLOAT)rand() ) / RAND_MAX) 



//-----------------------------------------------------------------------------
// Vertical blank callback to regulate the updating of the flock
//-----------------------------------------------------------------------------
BOOL  g_bFlockNeedsUpdating = FALSE;
BOOL  g_bTimerNeedsUpdating = FALSE;
DWORD g_dwVBlankCount       = 0;

VOID _cdecl VerticalBlankCB( D3DVBLANKDATA* )
{
    // Trigger an update for the flock 60 times per sec.
    g_bFlockNeedsUpdating = TRUE;

    // Trigger an update for the perf-timing code once per sec (60 vblanks = 1 sec)
    if( ++g_dwVBlankCount >= 60 )
    {
        g_dwVBlankCount = 0;
        g_bTimerNeedsUpdating = TRUE;
    }
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;             // Help class
    BOOL               m_bDrawHelp;        // Whether to draw help

    LPDIRECT3DTEXTURE8 m_pParticleTexture;   // Texture for the streak particles

    enum
    {
        USEDRAWPRIMUP,
        USEBEGINPUSH,
        USEBEGIN,
    } m_DrawMethod;                          // Various draw methods 

    LARGE_INTEGER      m_qwElapsedTime;      // For timing the draw method
    int                m_dwRenderCount;
    FLOAT              m_fElapsedTime;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Don't draw help initially
    m_bDrawHelp = FALSE;

    // Seed the random number generator
    srand((DWORD)m_fTime);

    // Init the streaks
    for( WORD i=0; i<NUM_STREAKS; i++ )
    {
        g_pStreaks[i].vPos   = D3DXVECTOR3(100.0f*(rnd()-rnd()), 10.0f*rnd(), 100.0f*(rnd()-rnd()));
        D3DXVec3Normalize( &g_pStreaks[i].vDir, &D3DXVECTOR3(rnd()-rnd(), rnd()-rnd(), rnd()-rnd()));
        g_pStreaks[i].fYaw   = 0.0f;
        g_pStreaks[i].fPitch = 0.0f;
        g_pStreaks[i].fRoll  = 0.0f;
        g_pStreaks[i].fDYaw  = 0.0f;
        g_pStreaks[i].fSpeed = cfNormalSpeed;

        D3DXVECTOR3 rgb( rnd(), rnd(), rnd() );
        D3DXVec3Normalize( &rgb, &rgb );
        g_pStreaks[i].Color = ((DWORD)(255*rgb.x)<<16)|((DWORD)(255*rgb.y)<<8)|((DWORD)(255*rgb.z)<<0);
    }

    // Init the streaks' goal
    g_vGoal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

    // Set a draw method
    m_DrawMethod = USEBEGINPUSH;

    // Initialize the timer variables
    m_qwElapsedTime.QuadPart = 0;
    m_dwRenderCount          = 0;
    m_fElapsedTime           = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create some textures
    m_pParticleTexture = m_xprResource.GetTexture( resource_Particle_OFFSET );

    // Set the transform matrices
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, 0.75f, 4.0f/3.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set a vertical blank callback to regulate the updating of the flock
    m_pd3dDevice->SetVerticalBlankCallback( VerticalBlankCB );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Switch the draw method if the user presses the A button
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] ) 
    {
        switch( m_DrawMethod )
        {
            case USEDRAWPRIMUP: m_DrawMethod = USEBEGINPUSH; break;
            case USEBEGINPUSH:  m_DrawMethod = USEBEGIN; break;
            case USEBEGIN:      m_DrawMethod = USEDRAWPRIMUP; break;
        }

        // Reset the timer variables
        m_qwElapsedTime.QuadPart = 0;
        m_dwRenderCount          = 0;
    }
    
    // Update the flock at 60Hz, regardless of framerate. The trigger variable
    // is set during a VBlank callback to ensure 60Hz.
    if( g_bFlockNeedsUpdating )
    {
        // Update the flock
        if( FALSE == m_bPaused )
            UpdateFlock();

        // Reset the trigger variable
        g_bFlockNeedsUpdating = FALSE;
    }

    // Set the view and projection matrices. Note: these are static since
    // the view changes each frame
    D3DXMATRIX matWorld;
    static D3DXVECTOR3 vEyePt( 0.0f, 30.0f, 100.0f );
    static D3DXVECTOR3 vLookatPt( 0.0f, 0.0f, 50.0f );
    static D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );

    // Compute the lookat point (look at the center of the flock)
    vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    for( WORD i=0; i<NUM_STREAKS; i++)
        vLookatPt += g_pStreaks[i].vPos;
    vLookatPt /= NUM_STREAKS;

    // Move eyepoint in ellipse about the lookat point
    vEyePt.x = vLookatPt.x + ( 30.0f*sinf(m_fAppTime*0.223f) );
    vEyePt.y = vLookatPt.y + ( 21.0f + 20.0f*sinf(m_fAppTime*0.33f) );
    vEyePt.z = vLookatPt.z + ( 30.0f*cosf(m_fAppTime*0.31f) );

    // Move goal in an ellipse
    g_vGoal.x = 105.0f * sinf(m_fAppTime*0.1f);
    g_vGoal.y = 10.0f;
    g_vGoal.z = 105.0f * cosf(m_fAppTime*0.1f);

    // Set the view matrices
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00000000, 1.0f, 0L );

    // Set the render states for using point sprites. Note that pointsprites
    // use texture stage 3 only.
    m_pd3dDevice->SetTexture( 3, m_pParticleTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(cfParticleSize) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_A,      FtoDW(0.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_B,      FtoDW(0.0f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_C,      FtoDW(1.0f) );

    // Turn on alphablending and disable z-writes
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );

    // Set the vertex shader
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_DIFFUSE );

    // Capture the start time, so we can calculate the CPU-time it takes to
    // process the dynamic vertices by the various rendering methods.
    LARGE_INTEGER qwStartTime;
    QueryPerformanceCounter( &qwStartTime );

    // Draw the streaks
    switch( m_DrawMethod )
    {
        case USEDRAWPRIMUP: // Draw the streaks with the DrawPrimitiveUP() API
        {
            struct STREAKVERTEX
            {
                D3DXVECTOR3 vPos;
                D3DCOLOR    color;
            } vertices[TRAIL_SIZE];

            for( WORD i=0; i<NUM_STREAKS; i++)
            {
                StreakObject* pStreak = &g_pStreaks[i];

                for( WORD j=0; j<TRAIL_SIZE; j++ )
                {
                    // Fade the alpha for the streak trail particles
                    DWORD dwAlpha = j*255/(TRAIL_SIZE-1);

                    vertices[j].vPos  = pStreak->vLastPositions[j];
                    vertices[j].color = (dwAlpha<<24) | pStreak->Color;
                }

                // Draw the particles
                m_pd3dDevice->DrawPrimitiveUP( D3DPT_POINTLIST, TRAIL_SIZE, vertices, sizeof(STREAKVERTEX) );
            }
        }
        break;

        case USEBEGINPUSH: // Draw the streaks with the BeginPush() API
        {
            DWORD dwVertexSize       = sizeof(D3DXVECTOR3) + sizeof(D3DCOLOR);
            DWORD dwNumVertices      = TRAIL_SIZE;
            DWORD dwPushSizeInBytes  = dwVertexSize * dwNumVertices;
            DWORD dwPushSizeInDWORDs = dwPushSizeInBytes / sizeof(DWORD);

            for( WORD i=0; i<NUM_STREAKS; i++)
            {
                StreakObject* pStreak = &g_pStreaks[i];

                // Gain direct access to the pushbuffer. Note the "+5", which is
                // to reserve overhead for the encoding parameters.
                DWORD* pPush;
                m_pd3dDevice->BeginPush( dwPushSizeInDWORDs + 5, &pPush );

                // Push the macro that start things off
                *pPush++ = D3DPUSH_ENCODE( D3DPUSH_SET_BEGIN_END, 1 );
                
                // Specify the primitive type of the vertices that follow
                *pPush++ = D3DPT_POINTLIST;

                // Specify that an array of vertices comes next. Note that a max
                // of 2047 dwords can be specified in a INLINE_ARRAY section.
                // For handling more vertex data than that, simply split the data
                // into multiple INLINE_ARRAY sections.
                *pPush++ = D3DPUSH_ENCODE( D3DPUSH_NOINCREMENT_FLAG|D3DPUSH_INLINE_ARRAY, dwPushSizeInDWORDs );

                // Write the dynamic vertices
                for( WORD j=0; j<TRAIL_SIZE; j++ )
                {
                    // Fade the alpha for the streak trail particles
                    DWORD dwAlpha = j*255/(TRAIL_SIZE-1);

                    // Write the position
                    *((D3DXVECTOR3*)pPush) = pStreak->vLastPositions[j];
                    pPush += 3;

                    // Write the diffuse color
                    *((D3DCOLOR*)pPush) = (dwAlpha<<24) | pStreak->Color;
                    pPush += 1;
                }

                // Push the macros that finish things off
                *pPush++ = D3DPUSH_ENCODE( D3DPUSH_SET_BEGIN_END, 1 );
                *pPush++ = 0;

                m_pd3dDevice->EndPush( pPush );
            }
        }
        break;

        case USEBEGIN: // Draw the streaks with the Begin() API
        {
            for( WORD i=0; i<NUM_STREAKS; i++)
            {
                StreakObject* pStreak = &g_pStreaks[i];

                // Begin sending vertex component data
                m_pd3dDevice->Begin( D3DPT_POINTLIST );

                // Write the dynamic vertices
                for( WORD j=0; j<TRAIL_SIZE; j++ )
                {
                    // Fade the alpha for the streak trail particles
                    DWORD dwAlpha = j*255/(TRAIL_SIZE-1);

                    // Write the diffuse color
                    m_pd3dDevice->SetVertexDataColor( D3DVSDE_DIFFUSE, (dwAlpha<<24) | pStreak->Color );

                    // Write the position
                    D3DXVECTOR3* vPos = &pStreak->vLastPositions[j];
                    m_pd3dDevice->SetVertexData4f( D3DVSDE_VERTEX, vPos->x, vPos->y, vPos->z, 1.0f );
                }

                // End sending vertex component data
                m_pd3dDevice->End();
            }
        }
        break;
    }

    // Every few seconds, we will poll the timer variables and report the results
    if( g_bTimerNeedsUpdating )
    {
        // Get the frequency of the timer
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

        m_fElapsedTime = fSecsPerTick * ((FLOAT)(m_qwElapsedTime.QuadPart)) / m_dwRenderCount;
    
        // Reset the timer variables
        m_qwElapsedTime.QuadPart = 0L;
        m_dwRenderCount          = 0;
        g_bTimerNeedsUpdating    = FALSE;
    }

    // Capture the stop time, and calculate the elpased CPU-time it took to
    // process the dynamic vertices by the various rendering methods above.
    LARGE_INTEGER qwStopTime;
    QueryPerformanceCounter( &qwStopTime );
    m_qwElapsedTime.QuadPart += qwStopTime.QuadPart - qwStartTime.QuadPart;
    m_dwRenderCount++;

    // Reset render states
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,      TRUE );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.DrawText(  64, 50, 0xffffff00, L"BeginPush" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Show the perf-timing results
        WCHAR str[80];
        m_Font.DrawText( 64, 80, 0xffffff00, L"Using draw method:" );
        switch( m_DrawMethod )
        {
            case USEDRAWPRIMUP: m_Font.DrawText( 270, 80, 0xffffffff, L"DrawPrimitiveUP()" ); break;
            case USEBEGINPUSH:  m_Font.DrawText( 270, 80, 0xffffffff, L"BeginPush()" ); break;
            case USEBEGIN:      m_Font.DrawText( 270, 80, 0xffffffff, L"Begin()" ); break;
        }
        swprintf( str, L"%.3f ms", 1000*m_fElapsedTime );
        m_Font.DrawText(  64, 105, 0xffffff00, L"Draw method took:" );
        m_Font.DrawText( 270, 105, 0xffffffff, str );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateFlock()
// Desc: Update posiiton of each streak in flock
//-----------------------------------------------------------------------------
VOID UpdateFlock()
{
    FLOAT fDist;

    // First update the dist array 0.0..1.0 with 0.0 being furthest away
    for( WORD i=0; i<NUM_STREAKS; i++ )
    {
        for( WORD j=i+1; j<NUM_STREAKS; j++ )
        {
            fDist = D3DXVec3LengthSq( &(g_pStreaks[i].vPos-g_pStreaks[j].vPos) );
            fDist = cfInfluenceRadiusSquared - fDist;
            if( fDist < 0.0f )
                fDist = 0.0f;
            else
                fDist /= cfInfluenceRadiusSquared;

            g_pStreaks[i].afDist[j] = g_pStreaks[j].afDist[i] = fDist;
        }
        g_pStreaks[i].afDist[i] = 0.0f;
        g_pStreaks[i].vDeltaDir = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
        g_pStreaks[i].vDeltaPos = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
        g_pStreaks[i].wDeltaCnt = 0;
    }

    for( i=0; i<NUM_STREAKS; i++ )
    {
        for( WORD j=i+1; j<NUM_STREAKS; j++ )
        {
            // If i is near j have them influence each other
            if( g_pStreaks[i].afDist[j] > 0.0f )
            {
                D3DXVECTOR3 vDiff;
                D3DXVECTOR3 vDelta;
                FLOAT       fCollWeight = 0.0f;     // Collision weighting

                D3DXVec3Normalize( &vDiff, &(g_pStreaks[i].vPos-g_pStreaks[j].vPos) );

                // Only do collision testing against the nearest ones
                if( g_pStreaks[i].afDist[j] - cfCollisionFraction > 0.0f )
                    fCollWeight = (g_pStreaks[i].afDist[j] - cfCollisionFraction) *
                                  cfInvCollisionFraction;

                // Add in a little flock centering
                if( g_pStreaks[i].afDist[j] - (1.0f-cfCollisionFraction) > 0.0f )
                    fCollWeight -= g_pStreaks[i].afDist[j] * (1.0f-fCollWeight);

                vDelta = fCollWeight * vDiff;

                // Add in the collision avoidance
                g_pStreaks[i].vDeltaPos += vDelta;
                g_pStreaks[j].vDeltaPos -= vDelta;

                // Add in the velocity influences
                g_pStreaks[i].vDeltaDir += g_pStreaks[j].vDir * g_pStreaks[i].afDist[j];
                g_pStreaks[j].vDeltaDir += g_pStreaks[i].vDir * g_pStreaks[i].afDist[j];
                g_pStreaks[i].wDeltaCnt++;
                g_pStreaks[j].wDeltaCnt++;
            }
        }
    }

    // Update the streaks
    for( i=0; i<NUM_STREAKS; i++ )
    {
        if( g_pStreaks[i].wDeltaCnt )
        {
            g_pStreaks[i].vDeltaDir /= (FLOAT)g_pStreaks[i].wDeltaCnt;
            g_pStreaks[i].vDeltaDir -= g_pStreaks[i].vDir;
            g_pStreaks[i].vDeltaDir *= 1.5f;
        }
        D3DXVECTOR3 vDelta = g_pStreaks[i].vDeltaDir + g_pStreaks[i].vDeltaPos;
        D3DXVECTOR3 vOffset;

        // Add in the influence of the global goal
        D3DXVECTOR3 vGoal;
        D3DXVec3Normalize( &vGoal, &(g_vGoal-g_pStreaks[i].vPos) );
        vDelta += 0.5f * vGoal;

        // First deal with pitch changes
        if( vDelta.y > 0.01f )
        {   // We're too low
            g_pStreaks[i].fPitch += cfAngleTweak;
            if( g_pStreaks[i].fPitch > 0.8f )
                g_pStreaks[i].fPitch = 0.8f;
        }
        else if( vDelta.y < -0.01f )
        {   // We're too high
            g_pStreaks[i].fPitch -= cfAngleTweak;
            if( g_pStreaks[i].fPitch < -0.8f )
                g_pStreaks[i].fPitch = -0.8f;
        } 
        else
        {
            // Add damping
            g_pStreaks[i].fPitch *= 0.98f;
        }

        // Speed up or slow down depending on angle of attack
        g_pStreaks[i].fSpeed -= g_pStreaks[i].fPitch * cfPitchToSpeedRatio;
        // Damp back to normal
        g_pStreaks[i].fSpeed = (g_pStreaks[i].fSpeed-cfNormalSpeed)*0.99f + cfNormalSpeed;

        if( g_pStreaks[i].fSpeed < cfNormalSpeed/2 )
            g_pStreaks[i].fSpeed = cfNormalSpeed/2;
        if( g_pStreaks[i].fSpeed > cfNormalSpeed*5 )
            g_pStreaks[i].fSpeed = cfNormalSpeed*5;

        // Now figure out yaw changes
        vOffset    = vDelta;
        vOffset.y  = 0.0f;
        vDelta     = g_pStreaks[i].vDir;
        D3DXVec3Normalize( &vOffset, &vOffset );
        FLOAT fDot = D3DXVec3Dot( &vOffset, &vDelta );
        
        // Speed up slightly if not turning much
        if( fDot > 0.7f )
        {
            fDot -= 0.7f;
            g_pStreaks[i].fSpeed += fDot * 0.005f;
        }
        D3DXVec3Cross( &vOffset, &vOffset, &vDelta );
        fDot = (1.0f-fDot)/2.0f * 0.07f;
        if( vOffset.y > 0.05f )
            g_pStreaks[i].fDYaw = (g_pStreaks[i].fDYaw*19.0f + fDot) * 0.05f;
        else if( vOffset.y < -0.05f )
            g_pStreaks[i].fDYaw = (g_pStreaks[i].fDYaw*19.0f - fDot) * 0.05f;
        else
            g_pStreaks[i].fDYaw *= 0.98f; // damp it

        g_pStreaks[i].fYaw += g_pStreaks[i].fDYaw;
        g_pStreaks[i].fRoll = -g_pStreaks[i].fDYaw * 20.0f;
    }

    // Update the streaks' direction and position
    for( WORD i=0; i<NUM_STREAKS; i++)
    {
        g_pStreaks[i].vDir.x =  cosf( -g_pStreaks[i].fPitch ) * sinf( -g_pStreaks[i].fYaw );
        g_pStreaks[i].vDir.y = -sinf( -g_pStreaks[i].fPitch );
        g_pStreaks[i].vDir.z =  cosf( -g_pStreaks[i].fPitch ) * cosf( -g_pStreaks[i].fYaw );

        g_pStreaks[i].vPos += g_pStreaks[i].vDir * g_pStreaks[i].fSpeed;
    }

    // Update the streaks tails
    for( WORD i=0; i<NUM_STREAKS; i++)
    {
        for( DWORD j=0; j<TRAIL_SIZE-1; j++ )
            g_pStreaks[i].vLastPositions[j] = g_pStreaks[i].vLastPositions[j+1];

        g_pStreaks[i].vLastPositions[j] = g_pStreaks[i].vPos;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\benchmark\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\billboard\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\billboard\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\billboard\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\benchmark\benchmark.cpp ===
//-----------------------------------------------------------------------------
// File: BenchMark.cpp
//
// Desc: Sample to draw a large number of triangles under various conditions
//       (number of textures, number of lights, fill mode, drawprim type, etc.)
//       to benchmark the performance of the graphics pipeline.
//
// Hist: 11.01.00 - Port from NVidia test for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.16.00 - Changes for March XDK release
//
// Copyright (c) 2000 NVIDIA Corporation. All rights reserved.
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\ntri list" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle\nfillmode" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Cycle num\ntextures" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Add/remove\ndir. light" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Add/remove\npt. light" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Add/remove\nspot light" },
    { XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Use to add or\nremove lights" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_2, L"Cycle display\ninfo" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
};

#define NUM_HELP_CALLOUTS 9




//-----------------------------------------------------------------------------
// Options for displaying info
//-----------------------------------------------------------------------------
enum DISPLAY_OPTIONS { DISPLAY_TITLEONLY=0, DISPLAY_INSTANTANEOUSSTATS, 
                       DISPLAY_RENDEROPTIONS, DISPLAY_ENUM_MAX };




//-----------------------------------------------------------------------------
// Geometry Constants
//-----------------------------------------------------------------------------
const DWORD g_dwRibbonCount  = 25;
const FLOAT g_fRibbonCurl    = 30.0f * 2.0f * D3DX_PI;
const FLOAT g_fRibbonPitch   = 3.25f;
const FLOAT g_fRibbonWidth   = 0.04f;
const FLOAT g_fRibbonRadius  = 0.05f;
const DWORD g_dwSubsInLength = 1200;
const DWORD g_dwSubsInWidth  = 5;




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    DWORD       m_dwNumTextures;
    BOOL        m_bUseTriList;

    int         m_dwNumLights;
    int         m_dwNumDirectionalLights;
    int         m_dwNumSpotLights;
    int         m_dwNumPointLights;

    FLOAT       m_fCumulativeTriPerSec;
    FLOAT       m_fMaxTriPerSec;
    FLOAT       m_fMinTriPerSec;
    DWORD       m_dwFrame;

    DISPLAY_OPTIONS m_dwDisplayInfo;

    // Timing stats
    FLOAT       m_fTPS;
    FLOAT       m_fSPS;
    FLOAT       m_fIPS;
    FLOAT       m_fVPS;

private:
    HRESULT InitVBs();
    HRESULT InitLights();
    HRESULT InitMaterials();

    LPDIRECT3DTEXTURE8 CreateTexture( DWORD dwWidth, DWORD dwHeight );

    VOID    DisplayInfo();

    WORD*                   m_pIndices;         // User ptr to indices
    LPDIRECT3DINDEXBUFFER8  m_pIndexBuffer;     // Index buffer

    BYTE*                   m_pRibbon1Vertices; // User ptr to verts
    BYTE*                   m_pRibbon2Vertices; // User ptr to verts
    LPDIRECT3DVERTEXBUFFER8 m_pRibbon1VB;       // VB of verts
    LPDIRECT3DVERTEXBUFFER8 m_pRibbon2VB;       // VB of verts

    LPDIRECT3DTEXTURE8      m_pTexture1;        // Texture 1
    LPDIRECT3DTEXTURE8      m_pTexture2;        // Texture 2

    DWORD                   m_dwFVF;            // Our current FVF
    DWORD                   m_dwFVFSize;        // FVF size

    DWORD                   m_dwNumIndices;     // # indices
    DWORD                   m_dwNumVertices;    // # verts

    D3DFILLMODE             m_wFillMode;        // Current fill mode

    D3DMATERIAL8 m_mtrlInside[g_dwRibbonCount];
    D3DMATERIAL8 m_mtrlOutside[g_dwRibbonCount];

    VOID InitIndices();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
{
    // Initialize base class members
    m_d3dpp.BackBufferFormat       = D3DFMT_R5G6B5;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize members
    m_dwDisplayInfo          = DISPLAY_TITLEONLY;
    m_bDrawHelp              = FALSE;

    m_dwNumLights            = 0L;
    m_dwNumDirectionalLights = 1L;
    m_dwNumSpotLights        = 0L;
    m_dwNumPointLights       = 0L;

    m_pIndices               = NULL;
    m_pIndexBuffer           = NULL;

    m_pRibbon1Vertices       = NULL;
    m_pRibbon2Vertices       = NULL;
    m_pRibbon1VB             = NULL;
    m_pRibbon2VB             = NULL;
    
    m_pTexture1              = NULL;
    m_pTexture2              = NULL;

    m_wFillMode              = D3DFILL_SOLID;

    m_dwNumTextures          = 0;
    m_bUseTriList            = FALSE;

    m_fCumulativeTriPerSec   = 0.0f;
    m_fMaxTriPerSec          = 0.0f;
    m_fMinTriPerSec          = 1e10f;
    m_dwFrame                = 0L;

    m_fTPS                   = 0.0f;
    m_fSPS                   = 0.0f;
    m_fIPS                   = 0.0f;
    m_fVPS                   = 0.0f;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitMaterials()
{
    // set material
    ZeroMemory( m_mtrlInside,  sizeof(D3DMATERIAL8) * g_dwRibbonCount );
    ZeroMemory( m_mtrlOutside, sizeof(D3DMATERIAL8) * g_dwRibbonCount );
    
    for( DWORD i = 0; i<g_dwRibbonCount; i++ )
    {
        FLOAT r = 0.3f + 0.5f * float(rand()) / float(RAND_MAX);
        FLOAT g = 0.3f + 0.5f * float(rand()) / float(RAND_MAX);
        FLOAT b = 0.3f + 0.5f * float(rand()) / float(RAND_MAX);

        m_mtrlOutside[i].Diffuse.r = r;
        m_mtrlOutside[i].Diffuse.g = g;
        m_mtrlOutside[i].Diffuse.b = b;
        m_mtrlOutside[i].Diffuse.a = 1.0f;
        m_mtrlOutside[i].Ambient.r = r * 0.3f;
        m_mtrlOutside[i].Ambient.g = g * 0.3f;
        m_mtrlOutside[i].Ambient.b = b * 0.3f;
        m_mtrlOutside[i].Ambient.a = 1.0f;

        m_mtrlInside[i].Diffuse.r  = 1.0f;
        m_mtrlInside[i].Diffuse.g  = 0.0f;
        m_mtrlInside[i].Diffuse.b  = 0.0f;
        m_mtrlInside[i].Diffuse.a  = 1.0f;
        m_mtrlInside[i].Ambient.r  = 1.0f;
        m_mtrlInside[i].Ambient.g  = 0.0f;
        m_mtrlInside[i].Ambient.b  = 0.0f;
        m_mtrlInside[i].Ambient.a  = 1.0f;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitMaterials()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitLights()
{
    // Setup lights
    FLOAT fIntensity = 1.0f / ( m_dwNumDirectionalLights + m_dwNumPointLights + m_dwNumSpotLights );

    // Disable all our existing lights
    while( m_dwNumLights-- )
        m_pd3dDevice->LightEnable( m_dwNumLights, FALSE );

    // Set the new lights, keeping a count of the number of lights
    m_dwNumLights = 0;

    for( int i = 0; i < m_dwNumDirectionalLights; i++ )
    {
        D3DLIGHT8 light;
        ZeroMemory( &light, sizeof(light) );
        light.Type        = D3DLIGHT_DIRECTIONAL;
        light.Diffuse.r   = fIntensity;
        light.Diffuse.g   = fIntensity;
        light.Diffuse.b   = fIntensity;
        light.Direction.x =  0.2f;
        light.Direction.y =  0.3f;
        light.Direction.z = -0.8f;

        m_pd3dDevice->SetLight( m_dwNumLights, &light );
        m_pd3dDevice->LightEnable( m_dwNumLights, TRUE );
        m_dwNumLights++;
    }
    for( i = 0; i < m_dwNumPointLights; i++ )
    {
        D3DLIGHT8 light;
        ZeroMemory( &light, sizeof(light) );
        light.Type         = D3DLIGHT_POINT;
        light.Diffuse.r    = fIntensity;
        light.Diffuse.g    = fIntensity;
        light.Diffuse.b    = fIntensity;
        light.Position.x   =   0.0f;
        light.Position.y   =   0.0f;
        light.Position.z   =   1.0f;
        light.Range        = 999.0f;
        light.Attenuation0 =   0.0f;
        light.Attenuation1 =   0.0f;
        light.Attenuation2 =   0.8f;

        m_pd3dDevice->SetLight( m_dwNumLights, &light );
        m_pd3dDevice->LightEnable( m_dwNumLights, TRUE );
        m_dwNumLights++;
    }
    for( i = 0; i < m_dwNumSpotLights; i++ )
    {
        D3DLIGHT8 light;
        ZeroMemory( &light, sizeof(light) );
        light.Type         = D3DLIGHT_SPOT;
        light.Diffuse.r    = fIntensity;
        light.Diffuse.g    = fIntensity;
        light.Diffuse.b    = fIntensity;
        light.Position.x   =  -1.0f;
        light.Position.y   =  -5.0f;
        light.Position.z   =   6.0f;
        light.Direction.x  =   0.1f;
        light.Direction.y  =   0.5f;
        light.Direction.z  =  -0.6f;
        light.Range        = 999.0f;
        light.Theta        =   0.1f;
        light.Phi          =   0.5f;
        light.Falloff      =   1.0f;
        light.Attenuation0 =   1.0f;

        m_pd3dDevice->SetLight( m_dwNumLights, &light );
        m_pd3dDevice->LightEnable( m_dwNumLights, TRUE );
        m_dwNumLights++;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitVBs()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitVBs()
{
    // Clean these guys up if they've already been inited
    SAFE_DELETE_ARRAY( m_pIndices );
    SAFE_RELEASE( m_pIndexBuffer );
    SAFE_RELEASE( m_pRibbon1VB );
    SAFE_RELEASE( m_pRibbon1VB );

    // create vertex buffer
    m_dwFVF = D3DFVF_XYZ | D3DFVF_NORMAL;

    if( m_dwNumTextures > 1 )
        m_dwFVF |= D3DFVF_TEX2;
    else if( m_dwNumTextures )
        m_dwFVF |= D3DFVF_TEX1;

    m_dwFVFSize     = D3DXGetFVFVertexSize(m_dwFVF);
    m_dwNumVertices = (g_dwSubsInLength + 1) * (g_dwSubsInWidth + 1);

    // Create our vertex buffers
    m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices * m_dwFVFSize, D3DUSAGE_WRITEONLY, 
		                              m_dwFVF, D3DPOOL_DEFAULT, &m_pRibbon1VB );
    m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices * m_dwFVFSize, D3DUSAGE_WRITEONLY, 
		                              m_dwFVF, D3DPOOL_DEFAULT, &m_pRibbon2VB );

    BYTE* pRibbon1Vertices;
    BYTE* pRibbon2Vertices;
    m_pRibbon1VB->Lock( 0, 0, (BYTE**)&pRibbon1Vertices, 0L );
    m_pRibbon2VB->Lock( 0, 0, (BYTE**)&pRibbon2Vertices, 0L );

    // Populate with vertices
    for( DWORD y = 0; y <= g_dwSubsInLength; y++ )
    {
        for( DWORD x = 0; x <= g_dwSubsInWidth; x++ )
        {
            // Compute point
            FLOAT fAngle    = g_fRibbonCurl  * y / g_dwSubsInLength;
            FLOAT fHeight   = g_fRibbonWidth * x / g_dwSubsInWidth  +
                              g_fRibbonPitch * y / g_dwSubsInLength -
                              g_fRibbonPitch * 0.5f;
            FLOAT fCosAngle = cosf(fAngle);
            FLOAT fSinAngle = sinf(fAngle);

            D3DXVECTOR3 p( fHeight, g_fRibbonRadius * fCosAngle, g_fRibbonRadius * fSinAngle );
	        D3DXVECTOR3 n( 0.0f, fCosAngle, fSinAngle );

            // Copy position
            *(D3DXVECTOR3*)pRibbon1Vertices =  p;   pRibbon1Vertices += 3*sizeof(FLOAT);
            *(D3DXVECTOR3*)pRibbon2Vertices =  p;   pRibbon2Vertices += 3*sizeof(FLOAT);

			// Copy normals
		    *(D3DXVECTOR3*)pRibbon1Vertices =  n;   pRibbon1Vertices += 3*sizeof(FLOAT);
			*(D3DXVECTOR3*)pRibbon2Vertices = -n;   pRibbon2Vertices += 3*sizeof(FLOAT);

			// Copy texture coords
            for( DWORD t=0; t<m_dwNumTextures; t++ )
            {
                FLOAT tv = ((FLOAT)y) / ((FLOAT)g_dwSubsInLength);
                FLOAT tu = ((FLOAT)x) / ((FLOAT)g_dwSubsInWidth);

                *(FLOAT*)pRibbon1Vertices = tu;   pRibbon1Vertices += 1*sizeof(FLOAT);
                *(FLOAT*)pRibbon1Vertices = tv;   pRibbon1Vertices += 1*sizeof(FLOAT);

                *(FLOAT*)pRibbon2Vertices = tu;   pRibbon2Vertices += 1*sizeof(FLOAT);
                *(FLOAT*)pRibbon2Vertices = tv;   pRibbon2Vertices += 1*sizeof(FLOAT);
            }
        }
    }

    m_pRibbon1VB->Unlock();
    m_pRibbon2VB->Unlock();

    // Setup indices
    m_dwNumIndices  = 1 + g_dwSubsInLength * (g_dwSubsInWidth * 2 + 1);
    m_pIndices      = new WORD[m_dwNumIndices];
    WORD* pwIndex   = m_pIndices;
    DWORD dwCurrent = 0;

    pwIndex[0] = 0; pwIndex++;
    for( y = 0; y < g_dwSubsInLength; y++ )
    {
        if( dwCurrent > 0xffff )
        {
            OUTPUT_DEBUG_STRING( "Index out of range - reduce geometry complexity" );
            return E_FAIL;
        }

        pwIndex[0] = WORD(dwCurrent + (g_dwSubsInWidth + 1));
        pwIndex++;
        dwCurrent++;
        for (DWORD x = 0; x < g_dwSubsInWidth; x++)
        {
            pwIndex[0]  = WORD(dwCurrent);
            pwIndex[1]  = WORD(dwCurrent + (g_dwSubsInWidth + 1));
            pwIndex    += 2;
            dwCurrent  ++;
        }

        dwCurrent += (g_dwSubsInWidth + 1) - 1;
        y++;
        if (y < g_dwSubsInLength)
        {
            pwIndex[0] = WORD(dwCurrent + (g_dwSubsInWidth + 1));
            pwIndex++;
            dwCurrent--;
            for (DWORD x = 0; x < g_dwSubsInWidth; x++)
            {
                pwIndex[0]  = WORD(dwCurrent);
                pwIndex[1]  = WORD(dwCurrent + (g_dwSubsInWidth + 1));
                pwIndex+= 2;
                dwCurrent --;
            }

            dwCurrent += (g_dwSubsInWidth + 1) + 1;
        }
    }

    // If we use tri lists, we convert the strip to independent triangles here
    if( m_bUseTriList )
    {
        DWORD dwNewIndexCount = (m_dwNumIndices - 2) * 3;
        WORD *pwNewIndices    = new WORD[dwNewIndexCount];

        DWORD a = m_pIndices[0];
        DWORD b = m_pIndices[1];
        for (DWORD i = 2,j = 0; i < m_dwNumIndices; i++,j+=3)
        {
            DWORD c = m_pIndices[i];
            pwNewIndices[j + 0] = (WORD)a;
            pwNewIndices[j + 1] = (WORD)b;
            pwNewIndices[j + 2] = (WORD)c;
            if (i & 1)
                b = c;
            else
                a = c;
        }

        // adopt new
        SAFE_DELETE_ARRAY( m_pIndices );
        m_dwNumIndices = dwNewIndexCount;
        m_pIndices     = pwNewIndices;
    }

    // Create our index buffer if we're using DrawIndexedPrimitive.
    m_pd3dDevice->CreateIndexBuffer( m_dwNumIndices * sizeof(WORD),
                                     D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                     D3DPOOL_DEFAULT, &m_pIndexBuffer );

    WORD* pIndices;
    m_pIndexBuffer->Lock( 0, m_dwNumIndices * sizeof(WORD),
                          (BYTE**)&pIndices, 0L );

    for( DWORD i = 0; i < m_dwNumIndices; i++ )
        pIndices[i] = m_pIndices[i];

    m_pIndexBuffer->Unlock();

    SAFE_DELETE_ARRAY( m_pIndices );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateTexture()
// Desc: Create a texture with a pattern in it.
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBoxSample::CreateTexture( DWORD dwWidth, DWORD dwHeight )
{
    LPDIRECT3DTEXTURE8 pTexture = NULL;
    D3DSURFACE_DESC    desc;
    D3DLOCKED_RECT     lock;

    // Create a texture
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0, 
                                             D3DFMT_A4R4G4B4, D3DPOOL_DEFAULT, 
                                             &pTexture ) ) )
        return NULL;

    // Lock and fill the texture
    pTexture->GetLevelDesc( 0, &desc );
    pTexture->LockRect( 0, &lock, NULL, 0L );
    WORD* pData16 = (WORD*)lock.pBits;

    for( DWORD y = 0; y < dwHeight; y++ )
    {
        for( DWORD x = 0; x < dwWidth; x++ )
        {
            DWORD c = x + (y>>5);

            if( y & 1 )
                *pData16++ = (WORD)( ( (c<<8) | (c<<4) | (c<<0) | 0xf000) ^ 0x0777 );
            else
                *pData16++ = (WORD)( ( (c<<8) | (c<<4) | (c<<0) | 0xf000) );
        }
    }

    // Swizzle, unlock and return the texture
    XBUtil_SwizzleTexture2D( &lock, &desc );
    pTexture->UnlockRect( 0 );

    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create lights, materials, textures, and vertex buffers
    InitLights();
    InitVBs();
    InitMaterials();
    m_pTexture1 = CreateTexture( 8, 256 );
    m_pTexture2 = CreateTexture( 8, 256 );

    // Set transforms
    D3DXMATRIX matView, matProj;
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, -3.1f );
    D3DXMatrixOrthoRH( &matProj, 3.35f, 2.60f, 1.0f, 20.0f );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    int  dwOldNumDirectionalLights = m_dwNumDirectionalLights;
    int  dwOldNumSpotLights        = m_dwNumSpotLights;
    int  dwOldNumPointLights       = m_dwNumPointLights;
    BOOL bOptionsChanged = FALSE;

    // Toggle triangle lists vs. triangle strips
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] ) 
    {
        m_bUseTriList = !m_bUseTriList;
        InitVBs();
        bOptionsChanged = TRUE;
    }

    // Cycle fill mode options
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] ) 
    {
        switch( m_wFillMode )
        {
            case D3DFILL_POINT:     m_wFillMode = D3DFILL_WIREFRAME; break;
            case D3DFILL_WIREFRAME: m_wFillMode = D3DFILL_SOLID;     break;
            case D3DFILL_SOLID:     m_wFillMode = D3DFILL_POINT;     break;
        }

        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, m_wFillMode );
        bOptionsChanged = TRUE;
    }

    // Cycle number of textures
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] ) 
    {
        m_dwNumTextures = (m_dwNumTextures+1) % 3;
        InitVBs();
        bOptionsChanged = TRUE;
    }

    // Use DPad UP with buttons A,B, and BLACK to add lights
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > 0x00 ) 
            if( m_dwNumDirectionalLights + m_dwNumPointLights + m_dwNumSpotLights < 8 )
                m_dwNumDirectionalLights++;

        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > 0x00 ) 
            if( m_dwNumDirectionalLights + m_dwNumPointLights + m_dwNumSpotLights < 8 )
                m_dwNumPointLights++;

        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > 0x00 ) 
            if( m_dwNumDirectionalLights + m_dwNumPointLights + m_dwNumSpotLights < 8 )
                m_dwNumSpotLights++;
    }

    // Use DPad DOWN with buttons A,B, and BLACK to remove lights
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > 0x00 ) 
            m_dwNumDirectionalLights = max( m_dwNumDirectionalLights-1, 0 );

        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > 0x00 ) 
            m_dwNumPointLights = max( m_dwNumPointLights-1, 0 );

        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > 0x00 ) 
            m_dwNumSpotLights = max( m_dwNumSpotLights-1, 0 );
    }

    // If any lights were added or removed, reinit the lights
    if( ( dwOldNumDirectionalLights != m_dwNumDirectionalLights ) ||
        ( dwOldNumSpotLights        != m_dwNumSpotLights )        ||
        ( dwOldNumPointLights       != m_dwNumPointLights ) )
    {
        InitLights();
        bOptionsChanged = TRUE;
    }

    // Cycle through the information displayed
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START ) 
    {
        m_dwDisplayInfo = (DISPLAY_OPTIONS)( (m_dwDisplayInfo+1) % DISPLAY_ENUM_MAX );
        bOptionsChanged = TRUE;
    }

    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
    {
        m_bDrawHelp = !m_bDrawHelp;
        bOptionsChanged = TRUE;
    }

    // Reset stats counters if the options changed
    if( bOptionsChanged )
    {
        m_dwFrame              = 0L;
        m_fCumulativeTriPerSec = 0.0f;
        m_fMaxTriPerSec        = 0.0f;
        m_fMinTriPerSec        = 1e10f;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Calculate number of primitives (per ribbon) to render
    DWORD            dwTriCount = m_bUseTriList ? m_dwNumIndices/3 : m_dwNumIndices-2;
    D3DPRIMITIVETYPE dwPrimType = m_bUseTriList ? D3DPT_TRIANGLELIST : D3DPT_TRIANGLESTRIP;

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                         0x00000000, 1.0f, 0L );

    // Set states for rendering the outside of the ribbons
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CW );

    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    if( m_dwNumTextures > 0 )
    {
        m_pd3dDevice->SetTexture( 0, m_pTexture1 );

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

        if( m_dwNumTextures > 1 )
        {
            m_pd3dDevice->SetTexture( 1, m_pTexture2 );
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_ADD );
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_ADD );
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_CURRENT );
        }
    }

    // Setup to render vertex buffers before any DrawPrim() calls take place
    m_pd3dDevice->SetVertexShader( m_dwFVF );
    m_pd3dDevice->SetStreamSource( 0, m_pRibbon1VB, m_dwFVFSize );
    m_pd3dDevice->SetIndices( m_pIndexBuffer, 0 );

    // Draw outsides of ribbons
    for( DWORD i = 0; i < g_dwRibbonCount; i++ )
    {
        // Position and rotation of ribbon
        FLOAT y      = 0.75f * g_fRibbonPitch * ( ((FLOAT)i)/(g_dwRibbonCount-1) - 0.5f );
        FLOAT fAngle = ( 3.0f * m_fTime ) + ( i * 0.4f );

        // Set our world transform
        D3DXMATRIX matWorld, matTrans, matRotate;
        D3DXMatrixTranslation( &matTrans, 0.0f, y, 0.0f );
        D3DXMatrixRotationX( &matRotate, fAngle );
        D3DXMatrixMultiply( &matWorld, &matRotate, &matTrans );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

        // Set material
        m_pd3dDevice->SetMaterial( &m_mtrlOutside[i] );

        // Draw outside ribbon
        m_pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, m_dwNumVertices, 0, 
                                            dwTriCount );
    }

    // Set states for rendering the insides of the ribbons
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );

    if( m_dwNumTextures )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    }

    // Setup to render vertex buffers before any DrawPrim() calls take place
    m_pd3dDevice->SetVertexShader( m_dwFVF );
    m_pd3dDevice->SetStreamSource( 0, m_pRibbon2VB, m_dwFVFSize );
    m_pd3dDevice->SetIndices( m_pIndexBuffer, 0 );
    
    // Draw insides of ribbons
    for( i = 0; i < g_dwRibbonCount; i++ )
    {
        // Position and rotation of ribbon
        FLOAT y      = 0.75f * g_fRibbonPitch * ( ((FLOAT)i)/(g_dwRibbonCount-1) - 0.5f );
        FLOAT fAngle = ( 3.0f * m_fTime ) + ( i * 0.4f );

        // Set our world transform
        D3DXMATRIX matWorld, matTrans, matRotate;
        D3DXMatrixTranslation( &matTrans, 0.0f, y, 0.0f );
        D3DXMatrixRotationX( &matRotate, fAngle );
        D3DXMatrixMultiply( &matWorld, &matRotate, &matTrans );
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

        // Set material
        m_pd3dDevice->SetMaterial( &m_mtrlInside[i] );

        // Draw inside ribbon
        m_pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, m_dwNumVertices, 0, 
                                            dwTriCount );
    }

    // Display help/args/stats
    DisplayInfo();

    // Get stats
    DWORD dwNumTrianglesRendered = 2 * g_dwRibbonCount * dwTriCount;
    DWORD dwNumVerticesRendered  = 2 * g_dwRibbonCount * m_dwNumIndices;
    DWORD dwNumBytesForIndices   = dwNumVerticesRendered * sizeof(WORD);
    DWORD dwNumBytesForVertices  = dwNumVerticesRendered * m_dwFVFSize;

    // Get timing stats
    m_fTPS = ((FLOAT)dwNumTrianglesRendered) / m_fElapsedTime;
    m_fSPS = ((FLOAT)dwNumVerticesRendered) / m_fElapsedTime;
    m_fIPS = ((FLOAT)dwNumBytesForIndices) / m_fElapsedTime;
    m_fVPS = ((FLOAT)dwNumBytesForVertices) / m_fElapsedTime;
    m_fCumulativeTriPerSec += m_fTPS;
    m_fMaxTriPerSec = max( m_fTPS, m_fMaxTriPerSec );
    m_fMinTriPerSec = min( m_fTPS, m_fMinTriPerSec );
    m_dwFrame++;

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DisplayInfo()
// Desc
//-----------------------------------------------------------------------------
VOID CXBoxSample::DisplayInfo()
{
    WCHAR str[128];
    FLOAT iY = 90;

    // Begin text drawing
    m_Font.Begin();

    // Draw help or the diaply info
    if( m_bDrawHelp )
    {
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    }
    else
    {
        // Show frame rate
        m_Font.DrawText(  64, 50, 0xffffffff, L"BenchMark" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( m_dwDisplayInfo == DISPLAY_INSTANTANEOUSSTATS )
        {
            m_Font.DrawText(  180, 50, 0xffffffff, L"- Instantaneous Stats" );

            swprintf( str, L"%d x %d", 640, 480 );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Size:" );
            m_Font.DrawText( 384, iY, 0xffffffff, str, XBFONT_RIGHT );
            iY += 20;

            m_Font.DrawText(  64, iY, 0xffffff00, L"Z-Depth:" );
            switch( m_d3dpp.AutoDepthStencilFormat )
            {
                case D3DFMT_D16:
                case D3DFMT_LIN_D16:
                    m_Font.DrawText( 384, iY, 0xffffffff, L"16-bit", XBFONT_RIGHT );
                    break;
                case D3DFMT_D24S8:
                case D3DFMT_LIN_D24S8:
                    m_Font.DrawText( 384, iY, 0xffffffff, L"24-bit w/stencil", XBFONT_RIGHT );
                    break;
                default:
                    m_Font.DrawText( 384, iY, 0xffffffff, L"Unknown", XBFONT_RIGHT );
                    break;
            }
            iY += 40;

            swprintf( str, L"%0.3lf", m_fTPS * 0.000001f );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Triangles per sec:\n" );
            m_Font.DrawText( 384, iY, 0xffffffff, str, XBFONT_RIGHT );
            m_Font.DrawText( 384, iY, 0xffffffff, L" MTris/s" );
            iY += 20;
            swprintf( str, L"%0.3lf", m_fSPS * 0.000001f );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Vertices per sec:\n" );
            m_Font.DrawText( 384, iY, 0xffffffff, str, XBFONT_RIGHT );
            m_Font.DrawText( 384, iY, 0xffffffff, L" MVerts/s" );
            iY += 40;

            swprintf( str, L"%0.3lf", m_fIPS * 0.000001f );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Index traffic:\n" );
            m_Font.DrawText( 384, iY, 0xffffffff, str, XBFONT_RIGHT );
            m_Font.DrawText( 384, iY, 0xffffffff, L" MBytes/s" );
            iY += 20;
            swprintf( str, L"%0.3lf", m_fVPS * 0.000001f );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Vertex traffic:\n" );
            m_Font.DrawText( 384, iY, 0xffffffff, str, XBFONT_RIGHT );
            m_Font.DrawText( 384, iY, 0xffffffff, L" MBytes/s" );
            iY += 20;
        }

        if( m_dwDisplayInfo == DISPLAY_RENDEROPTIONS )
        {
            m_Font.DrawText(  180, 50, 0xffffffff, L"- Rendering Options" );

            m_Font.DrawText(  64, iY, 0xffffff00, L"Primitive Type:" );
            m_Font.DrawText( 264, iY, 0xffffffff, m_bUseTriList ? L"Triangle List" : L"Triangle Strip" );
            iY += 20;
            m_Font.DrawText(  64, iY, 0xffffff00, L"Fillmode:" );
            if( m_wFillMode == D3DFILL_POINT )     m_Font.DrawText( 264, iY, 0xffffffff, L"Point" );
            if( m_wFillMode == D3DFILL_WIREFRAME ) m_Font.DrawText( 264, iY, 0xffffffff, L"Wireframe" );
            if( m_wFillMode == D3DFILL_SOLID )     m_Font.DrawText( 264, iY, 0xffffffff, L"Solid" );
            iY += 20;
            swprintf( str, L"%d", m_dwNumTextures );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Num Textures:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;
            swprintf( str, L"%d", m_dwNumDirectionalLights );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Num Dir Lights:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;
            swprintf( str, L"%d", m_dwNumPointLights );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Num Point Lights:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;
            swprintf( str, L"%d", m_dwNumSpotLights );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Num Spot Lights:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;
            iY += 10;

            DWORD dwTriCount  = m_bUseTriList ? m_dwNumIndices/3 : m_dwNumIndices-2;
            swprintf( str, L"%d triangles", 2 * g_dwRibbonCount * dwTriCount );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Triangles per frame:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;
            swprintf( str, L"%d indices", 2 * g_dwRibbonCount * m_dwNumIndices );
            m_Font.DrawText(  64, iY, 0xffffff00, L"Indices per frame:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;
            swprintf( str, L"%d bytes", m_dwFVFSize );
            m_Font.DrawText(  64, iY, 0xffffff00, L"FVFSize:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;
            iY += 10;
    
            swprintf( str, L"%0.3f Mtps", m_fCumulativeTriPerSec * 0.000001f / m_dwFrame );
            m_Font.DrawText(  64, iY, 0xffffff00, L"AvgTriPerSec:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;

            swprintf( str, L"%0.3f Mtps", m_fMaxTriPerSec * 0.000001f );
            m_Font.DrawText(  64, iY, 0xffffff00, L"MaxTriPerSec:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
            iY += 20;

            swprintf( str, L"%0.3f Mtps", m_fMinTriPerSec * 0.000001f );
            m_Font.DrawText(  64, iY, 0xffffff00, L"MinTriPerSec:" );
            m_Font.DrawText( 264, iY, 0xffffffff, str );
        }
    }

    // End text drawing
    m_Font.End();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\billboard\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\billboard\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BRDF\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\billboard\billboard.cpp ===
//-----------------------------------------------------------------------------
// File: Billboard.cpp
//
// Desc: Example code showing how to do billboarding. The sample uses
//       billboarding to draw some trees.
//
//       Note: this implementation is for billboards that are fixed to rotate
//       about the Y-axis, which is good for things like trees. For
//       unconstrained billboards, like explosions in a flight sim, the
//       technique is the same, but the the billboards are positioned slightly
//       different (use the inverse of the view matrix, a vertex shader, 
//       pre-transformed vertices, or some other technique).
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.05.01 - Changes for XFest art talk
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBMesh.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "SkyBoxXP.bmp", resource_SkyBoxXP_OFFSET },
    { "SkyBoxXN.bmp", resource_SkyBoxXN_OFFSET },
    { "SkyBoxYP.bmp", resource_SkyBoxYP_OFFSET },
    { "SkyBoxYN.bmp", resource_SkyBoxYN_OFFSET },
    { "SkyBoxZP.bmp", resource_SkyBoxZP_OFFSET },
    { "SkyBoxZN.bmp", resource_SkyBoxZN_OFFSET },
    { "Tree02s.tga",  resource_Tree02s_OFFSET },
    { "Hillside.bmp", resource_Hillside_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Rotate trees" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Name: Tree
// Desc: Simple structure to hold data for rendering a tree
//-----------------------------------------------------------------------------
struct Tree
{
    D3DXVECTOR4 vScale;
    D3DXVECTOR4 vPosition;
    D3DXVECTOR4 vColor;
};




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
#define NUM_TREES 2300

// Custom vertex for the trees
struct TREEVERTEX
{
    D3DXVECTOR3 p; // Vertex position
    D3DXVECTOR2 t; // Vertex texture coordinates
};

// Global access of the eye point used by the callback to sort trees
D3DXVECTOR3 g_vEyePt( 0.0f, 0.0f, 0.0f );
D3DXVECTOR3 g_vEyeDir( 0.0f, 0.0f, 1.0f );

// Simple function to define "hilliness" for terrain
inline FLOAT HeightField( FLOAT x, FLOAT y )
{
    return 3*(cosf(x/20+0.2f)*cosf(y/15-0.2f)+1.0f);
}

inline FLOAT GaussianRand( FLOAT min, FLOAT max, FLOAT width )
{
    FLOAT x = (FLOAT)(rand()-rand())/RAND_MAX;
    return (max-min)*expf( -width*x*x) + min;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    CXBMesh            m_TerrainObject;      // Terrain object
    CXBMesh            m_SkyBoxObject;       // Skybox background object

    LPDIRECT3DTEXTURE8 m_pTreeTexture;       // Tree images
    D3DXMATRIX         m_matBillboardMatrix; // Used for billboard orientation
    Tree*              m_Trees;              // Array of tree info

    Tree**             m_pTreeArray;         // Array of tree info

    DWORD              m_dwBillboardVertexShader;

    LPDIRECT3DVERTEXBUFFER8 m_pTreeVB;

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize members
    m_bDrawHelp               = FALSE;
    m_dwBillboardVertexShader = 0L;
    m_pTreeTexture            = NULL;

    // Initialize the tree data
    m_Trees      = new Tree[NUM_TREES];
    m_pTreeArray = new Tree*[NUM_TREES];

    DWORD side = (DWORD)sqrtf( NUM_TREES );

    for( DWORD i=0; i<NUM_TREES; i++ )
    {
        // Position the trees
        FLOAT x = 60.0f * ( (FLOAT)(i%side) - (FLOAT)(side/2) ) / (FLOAT)(side/2);
        FLOAT z = 60.0f * ( (FLOAT)(i/side) - (FLOAT)(side/2) ) / (FLOAT)(side/2);

        x += 60.0f * 0.1f * ((FLOAT)(rand()-rand())/RAND_MAX) / (FLOAT)(side/2);
        z += 60.0f * 0.1f * ((FLOAT)(rand()-rand())/RAND_MAX) / (FLOAT)(side/2);
        
        FLOAT y = HeightField( x, z );

        // Size the trees randomly
        FLOAT fWidth  = GaussianRand( 5.0f, 2.0f, 2.0f );
        FLOAT fHeight = GaussianRand( 7.0f, 4.0f, 2.0f );

        // Each tree is a random color between red and green
        FLOAT r = (1.0f-0.75f) + (0.75f*rand())/RAND_MAX;
        FLOAT g = (1.0f-0.75f) + (0.75f*rand())/RAND_MAX;
        FLOAT b = 0.0f;

        m_Trees[i].vPosition      = D3DXVECTOR4( x, y, z, 1.0f );
        m_Trees[i].vColor         = D3DXVECTOR4( r, g, b, 1.0f );
        m_Trees[i].vScale         = D3DXVECTOR4( fWidth, fHeight, 1.0f, 1.0f );

        m_pTreeArray[i] = &m_Trees[i];
    }
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the tree textures
    m_pTreeTexture = m_xprResource.GetTexture( "Tree02s.tga" );

    // Load the skybox
    if( FAILED( m_SkyBoxObject.Create( m_pd3dDevice, "Models\\SkyBox.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the terrain
    if( FAILED( m_TerrainObject.Create( m_pd3dDevice, "Models\\Hillside.xbg", &m_xprResource  ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Add some "hilliness" to the terrain
    XBMESH_DATA* pMesh = m_TerrainObject.GetMesh(0);
    if( pMesh )
    {
        struct VERTEX { D3DXVECTOR3 p, n; FLOAT tu,tv; };
        VERTEX* pVertices;
        DWORD   dwNumVertices = pMesh->m_dwNumVertices;

        pMesh->m_VB.Lock( 0, 0, (BYTE**)&pVertices, 0 );

        for( DWORD i = 0; i < dwNumVertices; i++ )
        {
            pVertices[i].p.y = HeightField( pVertices[i].p.x, pVertices[i].p.z );
            pVertices[i].tu *= 5.0f;
            pVertices[i].tv *= 5.0f;
        }

        pMesh->m_VB.Unlock();
    }

    // Set the transform matrices (view matrix is set in FrameMove())
    D3DXMATRIX  matWorld, matProj;
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set up the default texture states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );

    // Set up a light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 1.0f, -1.0f, 0.0f );
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0xff444444 );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    // Create vertex shader for the billboards
    DWORD dwBillboardVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),   // v0 = Position
        D3DVSD_REG( 3, D3DVSDT_FLOAT2 ),   // v3 = Texture coords
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Billbrd.xvu",
                                           dwBillboardVertexDecl,
                                           &m_dwBillboardVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4*sizeof(TREEVERTEX), 0, 0,
                                                  D3DPOOL_DEFAULT, &m_pTreeVB ) ) )
        return E_FAIL;

    TREEVERTEX* pVertices;
    m_pTreeVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
    pVertices[0].p = D3DXVECTOR3(-0.5f, 0.0f, 0.0f ); pVertices[0].t = D3DXVECTOR2( 0, 1 );
    pVertices[1].p = D3DXVECTOR3(-0.5f, 1.0f, 0.0f ); pVertices[1].t = D3DXVECTOR2( 0, 0 );
    pVertices[2].p = D3DXVECTOR3( 0.5f, 1.0f, 0.0f ); pVertices[2].t = D3DXVECTOR2( 1, 0 );
    pVertices[3].p = D3DXVECTOR3( 0.5f, 0.0f, 0.0f ); pVertices[3].t = D3DXVECTOR2( 1, 1 );
    m_pTreeVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: TreeSortCB()
// Desc: Callback function for sorting trees in back-to-front order
//-----------------------------------------------------------------------------
int _cdecl TreeSortCB( const VOID* arg1, const VOID* arg2 )
{
    Tree* p1 = *((Tree**)arg1);
    Tree* p2 = *((Tree**)arg2);

    FLOAT dx1 = p1->vPosition.x - g_vEyePt.x;
    FLOAT dx2 = p2->vPosition.x - g_vEyePt.x;
    FLOAT dz1 = p1->vPosition.z - g_vEyePt.z;
    FLOAT dz2 = p2->vPosition.z - g_vEyePt.z;

    if( (dx1*dx1+dz1*dz1) < (dx2*dx2+dz2*dz2) )
        return +1;

    return -1;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Position of camera along the path (the path is a big circle)
    static FLOAT fPathPostion = 0.0f;
    fPathPostion -= m_DefaultGamepad.fY1*m_fElapsedTime*1.00f;

    // User adjusted viewing angle (using GamePad)
    static FLOAT fViewAngle = 0.0f;
    fViewAngle = 0.9f * ( fViewAngle + m_DefaultGamepad.fX1*0.05f );
    
    // User adjusted angle to rotate the trees (using GamePad)
    static FLOAT fTreeRotate = 0.0f;
    fTreeRotate = 0.9f * ( fTreeRotate + m_DefaultGamepad.fX2*0.10f );

    // Set the app view matrix using the new eye point, eye direction, and
    // lookat point
    g_vEyePt.x = 30.0f*sinf( fPathPostion );
    g_vEyePt.z = 30.0f*cosf( fPathPostion );
    g_vEyePt.y = 6 + HeightField( g_vEyePt.x, g_vEyePt.z );

    g_vEyeDir.x = -cosf(fPathPostion+fViewAngle);
    g_vEyeDir.y = 0.0f;
    g_vEyeDir.z = +sinf(fPathPostion+fViewAngle);

    D3DXVECTOR3 vLookatPt;
    vLookatPt   = g_vEyePt + 10*g_vEyeDir;
    vLookatPt.y = g_vEyePt.y - 1.0f;

    // Sort trees in back-to-front order (depends on global g_vEyePt)
    qsort( m_pTreeArray, NUM_TREES, sizeof(Tree*), TreeSortCB );

    // Set up the view matrix
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &g_vEyePt, &vLookatPt, &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set up a rotation matrix to orient the billboard towards the camera.
    D3DXMATRIX matBillboard;
    D3DXMatrixRotationY( &matBillboard, fPathPostion+fViewAngle+fTreeRotate-D3DX_PI/2 );
    
    // Set the vertex shader constants (note that matrices must be transposed)
    D3DXMATRIX matProj, matViewProj, matViewProjTranspose, matBillboardTranspose;
    m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
    D3DXMatrixMultiply( &matViewProj, &matView, &matProj );
    D3DXMatrixTranspose( &matBillboardTranspose, &matBillboard );
    D3DXMatrixTranspose( &matViewProjTranspose,  &matViewProj );
    m_pd3dDevice->SetVertexShaderConstant( 4,  &matBillboardTranspose, 4 );
    m_pd3dDevice->SetVertexShaderConstant( 12, &matViewProjTranspose,  4 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: App_Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00000000, 1.0f, 0L );

    // Set up the default state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC,        D3DCMP_LESSEQUAL );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0xff444444 );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    // Render the Skybox
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
        
        // Center view matrix for skybox and disable zbuffer
        D3DXMATRIX matView, matViewSave;
        m_pd3dDevice->GetTransform( D3DTS_VIEW,      &matViewSave );
        matView = matViewSave;
        matView._41 = 0.0f; matView._42 = -0.0f; matView._43 = 0.0f;
        m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );

        // Render the skybox
        m_SkyBoxObject.Render( m_pd3dDevice );

        // Restore the render states
        m_pd3dDevice->SetTransform( D3DTS_VIEW, &matViewSave );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    }

    // Draw the terrain
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_TerrainObject.Render( m_pd3dDevice );

    // Draw the trees
    {
        // Set diffuse blending for alpha set in vertices.
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

        // Enable alpha testing (skips pixels with less than a certain alpha.)
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,        0x08 );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL );

        // Set the tree texture
        m_pd3dDevice->SetTexture( 0, m_pTreeTexture );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

        // Set the billboarding vertex shader. This does the transformation and
        // lighting, including the rotation to orient the billboard towards the
        // camera
        m_pd3dDevice->SetVertexShader( m_dwBillboardVertexShader );
        m_pd3dDevice->SetStreamSource( 0, m_pTreeVB, sizeof(TREEVERTEX) );

        // Loop through and render all trees

        // First, render front-to-back the opaque pixels
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,  0x80 );
        for( DWORD i=0; i<NUM_TREES; i++ )
        {
            Tree* pTree = m_pTreeArray[(NUM_TREES-1)-i];
            m_pd3dDevice->SetVertexShaderConstant( 0, &pTree->vPosition, 1 );
            m_pd3dDevice->SetVertexShaderConstant( 1, &pTree->vColor,    1 );
            m_pd3dDevice->SetVertexShaderConstant( 2, &pTree->vScale,    1 );
            m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );
        }

        // The render back to front, the alpha pixels
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,  0x08 );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL );
        m_pd3dDevice->SetRenderState( D3DRS_ZFUNC, D3DCMP_LESS );
        for( i=0; i<NUM_TREES; i++ )
        {
            Tree* pTree = m_pTreeArray[i];
            m_pd3dDevice->SetVertexShaderConstant( 0, &pTree->vPosition, 1 );
            m_pd3dDevice->SetVertexShaderConstant( 1, &pTree->vColor,    1 );
            m_pd3dDevice->SetVertexShaderConstant( 2, &pTree->vScale,    1 );
            m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );
        }

        // Restore state
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.DrawText(  64, 50, 0xff808000, L"BillBoard" );
        m_Font.DrawText( 450, 50, 0xff808000, m_strFrameRate );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\billboard\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 8UL

#define resource_SkyBoxXN_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxYN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxZN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_Tree02s_OFFSET 120UL
#define resource_Hillside_OFFSET 140UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\BRDF\BRDF.cpp ===
//-----------------------------------------------------------------------------
// File: PerPixelLighting.cpp
//
// Desc: Example code showing how to do perpixel lighting using vertex shaders.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move point\nlight" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Move dir. light" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle base\ntexture" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle ambient\nlight" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle dir.\nlight" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle pt.\nlight" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 8




//-----------------------------------------------------------------------------
// Name: struct CUSTOMVERTEX
// Desc: A position, normal, and tex coords for each vertex
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 p;         // Position
    D3DXVECTOR3 n;         // Normal
    FLOAT       tu, tv;    // Texture coords
}; 




//-----------------------------------------------------------------------------
// Name: struct TANGENTSPACE
// Desc: Three orthogonal tangent space vectors for each vertex
//-----------------------------------------------------------------------------
struct TANGENTSPACE
{
    D3DXVECTOR3 vTangent;
    D3DXVECTOR3 vBinormal;
    D3DXVECTOR3 vNormal;
}; 




//-----------------------------------------------------------------------------
// Name: class CBumpyObject
// Desc: 
//-----------------------------------------------------------------------------
class CBumpyObject
{
    LPDIRECT3DDEVICE8        m_pd3dDevice;        // Local copy of the d3d device

    LPDIRECT3DVERTEXBUFFER8  m_pTangentSpaceVB;   // Hold tangent space vectors
    LPDIRECT3DVERTEXBUFFER8  m_pSphereVerticesVB; // Hold geometry
    LPDIRECT3DINDEXBUFFER8   m_pSphereIndicesIB;
    DWORD                    m_dwNumVertices;
    DWORD                    m_dwNumIndices;

    LPDIRECT3DTEXTURE8       m_pBaseTexture;          // Base texture
    LPDIRECT3DTEXTURE8       m_pNormalMap;            // Normal texture (bumpmap)
    LPDIRECT3DCUBETEXTURE8   m_pNormalizationCubeMap; // Normalization cubemap
    LPDIRECT3DCUBETEXTURE8   m_pAngularizingCubeMap1; // Angularizing cubemap
    LPDIRECT3DCUBETEXTURE8   m_pAngularizingCubeMap2; // Angularizing cubemap
    LPDIRECT3DVOLUMETEXTURE8 m_pBRDFVolumeTexture;

    DWORD                    m_dwVertexShader;    // Custom vertex shader
    DWORD                    m_dwBRDFPixelShader;

    HRESULT CreateBRDFPixelShader();

public:
    CBumpyObject();
    virtual ~CBumpyObject();

    HRESULT Init( LPDIRECT3DDEVICE8 pd3dDevice, CXBPackedResource* pResource );
    VOID    InitSphere( FLOAT radius, DWORD nLat, DWORD nLong );
    VOID    CreateBasisMatrices();

    VOID    SetVertexShaderConstants( D3DXVECTOR3* pLightPos );

    HRESULT Render( LPDIRECT3DDEVICE8 m_pd3dDevice );
    HRESULT RenderObject( LPDIRECT3DDEVICE8 m_pd3dDevice );
};




//-----------------------------------------------------------------------------
// Globally accessed attributes
//-----------------------------------------------------------------------------
D3DXVECTOR3 g_vPtLightPos;        // Point light position
DWORD       g_dwPtLightColor;     // Point light color
DWORD       g_dwAmbientColor;     // Ambient light value

BOOL        g_bPointFiltering = FALSE;



//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource   m_xprResource;        // Packed resources for the app
    CXBFont             m_Font;               // Font class
    CXBHelp             m_Help;               // Help class
    BOOL                m_bDrawHelp;          // Whether to draw help

    CBumpyObject        m_BumpyObject;

    D3DXMATRIX          m_matWorld;

    VOID DrawLight();

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp          = FALSE;

    // Initial light attributes
    g_vPtLightPos        = D3DXVECTOR3( -1.0f, 1.0f, -2.75f );
    g_dwPtLightColor     = 0x00ff0000;

    g_dwAmbientColor     = 0x00404040;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;
    
    // Create the font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( hr = m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the bumpy object
    if( FAILED( hr = m_BumpyObject.Init( m_pd3dDevice, &m_xprResource ) ) )
        return hr;

    // Set the transform matrices
    D3DXMATRIX matView, matProj;
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixTranslation( &matView, 0.0f, 0.0f, 5.0f );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 640.0f/480.0f, 1.0f, 20.0f );

    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Rotate the scene
    D3DXMATRIX matRotate;
    D3DXMatrixRotationY( &matRotate, -m_fElapsedAppTime/2 );
    D3DXMatrixMultiply( &m_matWorld, &m_matWorld, &matRotate );

    // Toggle options

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
        g_bPointFiltering          = !g_bPointFiltering;
    

    // Adjust the point light's position
    static FLOAT fLightTheta = 0.0f;
    fLightTheta += 3.0f * m_fElapsedTime * m_DefaultGamepad.fX1;
    if( fLightTheta < -3.14f ) fLightTheta = -3.14f;
    if( fLightTheta > +0.00f ) fLightTheta = +0.00f;

    static FLOAT fLightPhi = 0.0f;
    fLightPhi -= 3.0f * m_fElapsedTime * m_DefaultGamepad.fY1;
    if( fLightPhi < +0.00f ) fLightPhi = +0.0f;
    if( fLightPhi > +3.14f ) fLightPhi = +3.14f;

    g_vPtLightPos.x = 2*cosf( fLightTheta );
    g_vPtLightPos.y = 2*cosf( fLightPhi );
    g_vPtLightPos.z = 2*sinf( fLightTheta ) * sinf( fLightPhi );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
VOID CXBoxSample::DrawLight()
{
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

    // Get the inverse of the world matrix
    D3DXMATRIX matInvWorld;
    D3DXMatrixInverse( &matInvWorld, NULL, &m_matWorld );

    // Setup some points to draw crosshairs
    D3DXVECTOR3 line[6];
    D3DXVec3TransformCoord( &line[0], &(g_vPtLightPos+D3DXVECTOR3(+0.2f, 0.0f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[1], &(g_vPtLightPos+D3DXVECTOR3(-0.2f, 0.0f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[2], &(g_vPtLightPos+D3DXVECTOR3( 0.0f,+0.2f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[3], &(g_vPtLightPos+D3DXVECTOR3( 0.0f,-0.2f, 0.0f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[4], &(g_vPtLightPos+D3DXVECTOR3( 0.0f, 0.0f,+0.2f)), &matInvWorld );
    D3DXVec3TransformCoord( &line[5], &(g_vPtLightPos+D3DXVECTOR3( 0.0f, 0.0f,-0.2f)), &matInvWorld );

    // Set the crosshair's color 
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, g_dwPtLightColor );

    // Draw the crosshairs
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 3, line, sizeof(D3DXVECTOR3) );
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff888844 );

    // Draw the main object
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    m_BumpyObject.Render( m_pd3dDevice );

    // Draw the position of the point light
    DrawLight();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  48, 36, 0xffffffff, L"BRDF" );
        m_Font.DrawText( 464, 36, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
CBumpyObject::CBumpyObject()
{
    m_pd3dDevice        = NULL;
    m_pTangentSpaceVB   = NULL;
    m_pSphereVerticesVB = NULL;
    m_pSphereIndicesIB  = NULL;
    m_pBaseTexture      = NULL;
    m_pNormalMap        = NULL;
    m_pNormalizationCubeMap = NULL;
    m_pAngularizingCubeMap1 = NULL;
    m_pAngularizingCubeMap2 = NULL;
    m_dwVertexShader    = 0L;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
CBumpyObject::~CBumpyObject()
{
    SAFE_RELEASE( m_pTangentSpaceVB );
    SAFE_RELEASE( m_pSphereVerticesVB );
    SAFE_RELEASE( m_pSphereIndicesIB );
    SAFE_RELEASE( m_pBaseTexture );
    SAFE_RELEASE( m_pNormalMap );
    SAFE_RELEASE( m_pNormalizationCubeMap );
    SAFE_RELEASE( m_pAngularizingCubeMap1 );
    SAFE_RELEASE( m_pAngularizingCubeMap2 );
    
    if( m_pd3dDevice )
        m_pd3dDevice->DeleteVertexShader( m_dwVertexShader );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateAngularizingCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateAngularizingCubeMap1( LPDIRECT3DDEVICE8 pd3dDevice, 
                                          DWORD dwSize, 
                                          LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map. Texture format doesn't appear to matter, as long as
    // it's 32-bit
//    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_V16U16, 
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_A8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        WORD*       pPixel = (WORD*)pSourceBits;
//        BYTE*       pPixel = (BYTE*)pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Convert the normal to spherical coordinates
                D3DXVec3Normalize( &n, &n );
                FLOAT fTheta = atan2f( n.y, n.x ); // Returns range [-pi, +pi]
                FLOAT fPhi   = acosf( n.z );       // Returns range [0, pi]

                // Write the pixel in HiLo format
                {
                    *pPixel++ = (WORD)(65535.0f * (fPhi/(2*D3DX_PI)));
//                  *pPixel++ = (WORD)(65535.0f * ((fTheta+D3DX_PI)/(2*D3DX_PI)));
//                  *pPixel++ = (WORD)0;
                    *pPixel++ = (WORD)0;
                }
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateAngularizingCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateAngularizingCubeMap2( LPDIRECT3DDEVICE8 pd3dDevice, 
                                          DWORD dwSize, 
                                          LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_V16U16, 
//    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_A8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        WORD*       pPixel = (WORD*)pSourceBits;
//        BYTE*       pPixel = (BYTE*)pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Convert the normal to spherical coordinates
                D3DXVec3Normalize( &n, &n );
                FLOAT fTheta = atan2f( n.y, n.x ); // Returns range [-pi, +pi]
                FLOAT fPhi   = acosf( n.z );       // Returns range [0, pi]

                // Write the pixel in HiLo format
                {
                    *pPixel++ = (WORD)(65535.0f * (fPhi/D3DX_PI));
//                  *pPixel++ = (WORD)(65535.0f * ((fTheta+D3DX_PI)/(2*D3DX_PI)));
                    *pPixel++ = (WORD)0;
                }
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::Init( LPDIRECT3DDEVICE8 pd3dDevice, 
                            CXBPackedResource* pResource )
{
    HRESULT hr;

    // Keep track of the device
    m_pd3dDevice = pd3dDevice;

    // Initialize the sphere's geometry, and create it's basis matrices
    InitSphere( 1.7f, 24, 24 );
    CreateBasisMatrices();

    // Create the base texture
    m_pBaseTexture = pResource->GetTexture( resource_Woman_OFFSET );
    
    // Load grayscale texture to be used for making the normal map
    m_pNormalMap = pResource->GetTexture( resource_Woman_OFFSET );

    // Compute the normal map from the gray scale texture
    D3DSURFACE_DESC desc;
    D3DLOCKED_RECT  lock;
    m_pNormalMap->GetLevelDesc( 0, &desc );
    m_pNormalMap->LockRect( 0, &lock, 0, 0L );
    XBUtil_UnswizzleTexture2D( &lock, &desc );
    DWORD* pBits = (DWORD*)lock.pBits;

    for( DWORD y=0; y<desc.Height; y++ )
    {
        for( DWORD x=0; x<desc.Width; x++ )
        {
            DWORD* p00 = ((DWORD*)pBits) + (x+0) + desc.Width*(y+0);
            DWORD* p10 = ((DWORD*)pBits) + (x+1) + desc.Width*(y+0);
            DWORD* p01 = ((DWORD*)pBits) + (x+0) + desc.Width*(y+1);

            FLOAT fHeight00 = (FLOAT)(((*p00)&0x00ff0000)>>16)/255.0f;
            FLOAT fHeight10 = (FLOAT)(((*p10)&0x00ff0000)>>16)/255.0f;
            FLOAT fHeight01 = (FLOAT)(((*p01)&0x00ff0000)>>16)/255.0f;

            D3DXVECTOR3 vPoint00( x+0.0f, y+0.0f, fHeight00 );
            D3DXVECTOR3 vPoint10( x+0.1f, y+0.0f, fHeight10 );
            D3DXVECTOR3 vPoint01( x+0.0f, y+0.1f, fHeight01 );
            D3DXVECTOR3 v10 = vPoint10 - vPoint00;
            D3DXVECTOR3 v01 = vPoint01 - vPoint00;

            D3DXVECTOR3 v;
            D3DXVec3Cross( &v, &v10, &v01 );
            D3DXVec3Normalize( &v, &v );

            *p00 = XBUtil_VectorToRGBA( &v );
        }
    }

    XBUtil_SwizzleTexture2D( &lock, &desc );
    m_pNormalMap->UnlockRect( 0 );

    // Create the normalization cube map
    hr = XBUtil_CreateNormalizationCubeMap( m_pd3dDevice, 256, &m_pNormalizationCubeMap );
    if( FAILED(hr) )
        return E_FAIL;

    // Create the angularizing cube map
    hr = XBUtil_CreateAngularizingCubeMap1( m_pd3dDevice, 256, &m_pAngularizingCubeMap1 );
    if( FAILED(hr) )
        return E_FAIL;

    // Create the angularizing cube map
    hr = XBUtil_CreateAngularizingCubeMap2( m_pd3dDevice, 256, &m_pAngularizingCubeMap2 );
    if( FAILED(hr) )
        return E_FAIL;

    // Create a vertex shader
    DWORD dwVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),     // v0 = Position
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),     // v1 = Normal
        D3DVSD_REG( 2, D3DVSDT_FLOAT2 ),     // v2 = Base tex coords
        D3DVSD_STREAM( 1 ),
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ),     // v3 = Tangent space tangent
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ),     // v4 = Tangent space binormal
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ),     // v5 = Tangent space normal
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\BRDF.xvu",
                                           dwVertexDecl,
                                           &m_dwVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( CreateBRDFPixelShader() ) )
        return E_FAIL;



    const DWORD VOLTEXSIZE = 64;

    if( FAILED( m_pd3dDevice->CreateVolumeTexture( VOLTEXSIZE, VOLTEXSIZE, VOLTEXSIZE, 
                                                   1, 0, D3DFMT_X8R8G8B8, D3DPOOL_DEFAULT, 
                                                   &m_pBRDFVolumeTexture ) ) )
        return E_FAIL;

    // Fill the volume texture
    {
        D3DVOLUME_DESC  desc;
        D3DLOCKED_BOX   lock;
        m_pBRDFVolumeTexture->GetLevelDesc( 0, &desc );
        m_pBRDFVolumeTexture->LockBox( 0, &lock, 0, 0L );
        DWORD* pBits = (DWORD*)lock.pBits;

        srand( 123456 );

        for( UINT w=0; w<VOLTEXSIZE; w++ )
        {
            for( UINT v=0; v<VOLTEXSIZE; v++ )
            {
                for( UINT u=0; u<VOLTEXSIZE; u++ )
                {
                    FLOAT du = (2.0f*u)/(VOLTEXSIZE-1) - 1.0f;
                    FLOAT dv = (2.0f*v)/(VOLTEXSIZE-1) - 1.0f;
                    FLOAT dw = (2.0f*w)/(VOLTEXSIZE-1) - 1.0f;

                    FLOAT fu = (1.0f*u)/(VOLTEXSIZE-1);
                    FLOAT fv = (1.0f*v)/(VOLTEXSIZE-1);
                    FLOAT fw = (1.0f*w)/(VOLTEXSIZE-1);
                
                    FLOAT fScale = ((FLOAT)v)/(VOLTEXSIZE-1);

                    DWORD r = (DWORD)(0xff*fu);
                    DWORD g = (DWORD)(0xff*fv);
                    DWORD b = (DWORD)(0xff*fw);
                    DWORD a = 0xff;

                    // Write the texel
                    *pBits++ = (a<<24) + (r<<16) + (g<<8) + (b<<0);
                }
            }
        }

        // Swizzle and unlock the texture
        XBUtil_SwizzleTexture3D( &lock, &desc );
        m_pBRDFVolumeTexture->UnlockBox( 0 );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitSphere()
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::InitSphere( FLOAT fRadius, DWORD dwNumSphereRings, 
                               DWORD dwNumSphereSegments )
{
    // Establish constants used in sphere generation
    FLOAT fDeltaRingAngle = ( D3DX_PI / dwNumSphereRings );
    FLOAT fDeltaSegAngle  = ( 2.0f * D3DX_PI / dwNumSphereSegments );

    m_dwNumVertices = dwNumSphereRings*(dwNumSphereSegments+1)*2;
    m_dwNumIndices  = 3*(m_dwNumVertices-2);

    // Create the vertex buffer and fill it
    m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices*sizeof(CUSTOMVERTEX),
                                      D3DUSAGE_WRITEONLY, 0L,
                                      D3DPOOL_MANAGED, &m_pSphereVerticesVB );

    CUSTOMVERTEX* pVertices;
    m_pSphereVerticesVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Generate the group of rings for the sphere
    for( DWORD ring = 0; ring < dwNumSphereRings; ring++ )
    {
        FLOAT r0 = sinf( (ring+0) * fDeltaRingAngle );
        FLOAT r1 = sinf( (ring+1) * fDeltaRingAngle );
        FLOAT y0 = cosf( (ring+0) * fDeltaRingAngle );
        FLOAT y1 = cosf( (ring+1) * fDeltaRingAngle );

        // Generate the group of segments for the current ring
        for( DWORD seg = 0; seg < (dwNumSphereSegments+1); seg++ )
        {
            FLOAT x0 =  r0 * sinf( seg * fDeltaSegAngle );
            FLOAT z0 =  r0 * cosf( seg * fDeltaSegAngle );
            FLOAT x1 =  r1 * sinf( seg * fDeltaSegAngle );
            FLOAT z1 =  r1 * cosf( seg * fDeltaSegAngle );

            // Add two vertices to the strip which makes up the sphere
            // (using the transformed normal to generate texture coords)
            pVertices->p  = fRadius * D3DXVECTOR3(x0,y0,z0);
            pVertices->n  = D3DXVECTOR3(x0,y0,z0);
            pVertices->tu = -((FLOAT)seg)/dwNumSphereSegments;
            pVertices->tv = (ring+0)/(FLOAT)dwNumSphereRings;
            pVertices++;

            pVertices->p  = fRadius * D3DXVECTOR3(x1,y1,z1);
            pVertices->n  = D3DXVECTOR3(x1,y1,z1);
            pVertices->tu = -((FLOAT)seg)/dwNumSphereSegments;
            pVertices->tv = (ring+1)/(FLOAT)dwNumSphereRings;
            pVertices++;
        }
    }

    m_pSphereVerticesVB->Unlock();

    // Create the index buffer and fill it
    m_pd3dDevice->CreateIndexBuffer( m_dwNumIndices*sizeof(WORD),
                                     D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                     D3DPOOL_MANAGED, &m_pSphereIndicesIB );

    WORD* pIndices;
    m_pSphereIndicesIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );

    for( DWORD i=0; i<m_dwNumVertices-2; i++ )
    {
        (*pIndices++) = (WORD)(i+0);
        (*pIndices++) = (WORD)(i+1+(i%2));
        (*pIndices++) = (WORD)(i+2-(i%2));
    }

    m_pSphereIndicesIB->Unlock();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::CreateBasisMatrices()
{
    WORD i,j;

    m_pd3dDevice->CreateVertexBuffer( m_dwNumVertices*sizeof(TANGENTSPACE),
                                      D3DUSAGE_WRITEONLY, 0L,
                                      D3DPOOL_MANAGED, &m_pTangentSpaceVB );


    TANGENTSPACE* pTangentSpace;
    CUSTOMVERTEX* pVertices;
    WORD*         pIndices;
    m_pTangentSpaceVB->Lock( 0, 0, (BYTE**)&pTangentSpace, 0 );
    m_pSphereVerticesVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );
    m_pSphereIndicesIB->Lock( 0, 0, (BYTE**)&pIndices, 0 );

    // Clear out the tangent space area
    ZeroMemory( pTangentSpace, m_dwNumVertices*sizeof(TANGENTSPACE) );

    // Loop through all triangles, accumulating du and dv offsets to build
    // basis vectors
    for( i = 0; i < m_dwNumIndices; i += 3 )
    {       
        WORD i0 = pIndices[i+0];
        WORD i1 = pIndices[i+1];
        WORD i2 = pIndices[i+2];

        if( i0<m_dwNumVertices && i1<m_dwNumVertices  && i2<m_dwNumVertices )
        { 
            CUSTOMVERTEX* v0 = &pVertices[i0];
            CUSTOMVERTEX* v1 = &pVertices[i1];
            CUSTOMVERTEX* v2 = &pVertices[i2];
            D3DXVECTOR3   du, dv;
            D3DXVECTOR3   cp;

            // Skip degnerate triangles
            if( fabs(v0->p.x-v1->p.x)<1e-6 && fabs(v0->p.y-v1->p.y)<1e-6 && fabs(v0->p.z-v1->p.z)<1e-6 )
                continue;
            if( fabs(v1->p.x-v2->p.x)<1e-6 && fabs(v1->p.y-v2->p.y)<1e-6 && fabs(v1->p.z-v2->p.z)<1e-6 )
                continue;
            if( fabs(v2->p.x-v0->p.x)<1e-6 && fabs(v2->p.y-v0->p.y)<1e-6 && fabs(v2->p.z-v0->p.z)<1e-6 )
                continue;

            D3DXVECTOR3 edge01( v1->p.x - v0->p.x, v1->tu - v0->tu, v1->tv - v0->tv );
            D3DXVECTOR3 edge02( v2->p.x - v0->p.x, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.x = -cp.y / cp.x;        
                dv.x = -cp.z / cp.x;
            }

            edge01 = D3DXVECTOR3( v1->p.y - v0->p.y, v1->tu - v0->tu, v1->tv - v0->tv );
            edge02 = D3DXVECTOR3( v2->p.y - v0->p.y, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.y = -cp.y / cp.x;
                dv.y = -cp.z / cp.x;
            }

            edge01 = D3DXVECTOR3( v1->p.z - v0->p.z, v1->tu - v0->tu, v1->tv - v0->tv );
            edge02 = D3DXVECTOR3( v2->p.z - v0->p.z, v2->tu - v0->tu, v2->tv - v0->tv );
            D3DXVec3Cross( &cp, &edge01, &edge02 );
            if( fabs(cp.x) > 1e-8 )
            {
                du.z = -cp.y / cp.x;
                dv.z = -cp.z / cp.x;
            }

            pTangentSpace[i0].vTangent += du;
            pTangentSpace[i1].vTangent += du;
            pTangentSpace[i2].vTangent += du;

            pTangentSpace[i0].vNormal  += dv;
            pTangentSpace[i1].vNormal  += dv;
            pTangentSpace[i2].vNormal  += dv;
        }
    }

    for( i = 0; i < m_dwNumVertices; i++)
    {       
        // vBinormal = vTangent x vNormal
        D3DXVec3Normalize( &pTangentSpace[i].vTangent, &pTangentSpace[i].vTangent );
        D3DXVec3Normalize( &pTangentSpace[i].vNormal,  &pTangentSpace[i].vNormal );
        D3DXVec3Cross( &pTangentSpace[i].vBinormal, &pTangentSpace[i].vTangent, 
                       &pTangentSpace[i].vNormal );

        // Get the vertex normal (make sure it's normalized)
        D3DXVECTOR3 normal;
        D3DXVec3Normalize( &normal, &pVertices[i].n );

        // Make sure the basis vector and normal point in the same direction
        if( D3DXVec3Dot( &pTangentSpace[i].vBinormal, &normal ) < 0.0f )
            pTangentSpace[i].vBinormal = -pTangentSpace[i].vBinormal;
    }

    // Find duplicate vertices in the mesh, and average their tangent spaces
    // together. This is necessary to avoid discontinuities at the seams.
    for( i=0; i < m_dwNumVertices; i++ )
    {
        D3DXVECTOR3 vT = pTangentSpace[i].vTangent;
        D3DXVECTOR3 vB = pTangentSpace[i].vBinormal;
        D3DXVECTOR3 vN = pTangentSpace[i].vNormal;

        for( j=i+1; j < m_dwNumVertices; j++ )
        {
            FLOAT dist = D3DXVec3LengthSq( &(pVertices[i].p - pVertices[j].p) );

            if( dist < 1.0e-8f )
            {
                vT += pTangentSpace[j].vTangent;
                vB += pTangentSpace[j].vBinormal;
                vN += pTangentSpace[j].vNormal;
            }
        }

        // Normalize the vectors of the basis matrix
        D3DXVec3Normalize( &vT, &vT );
        D3DXVec3Normalize( &vB, &vB );
        D3DXVec3Normalize( &vN, &vN );

        for( j=i; j < m_dwNumVertices; j++ )
        {
            FLOAT dist = D3DXVec3LengthSq( &(pVertices[i].p - pVertices[j].p) );

            if( dist < 1.0e-8f )
            {
                pTangentSpace[j].vTangent  = vT;
                pTangentSpace[j].vBinormal = vB;
                pTangentSpace[j].vNormal   = vN;
            }
        }
    }

    m_pTangentSpaceVB->Unlock();
    m_pSphereVerticesVB->Unlock();
    m_pSphereIndicesIB->Unlock();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::RenderObject( LPDIRECT3DDEVICE8 m_pd3dDevice )
{
    // Render the object
    m_pd3dDevice->SetVertexShader( m_dwVertexShader ); 
    m_pd3dDevice->SetStreamSource( 0, m_pSphereVerticesVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetStreamSource( 1, m_pTangentSpaceVB, sizeof(TANGENTSPACE) );
    m_pd3dDevice->SetIndices( m_pSphereIndicesIB, 0 );
    m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, m_dwNumVertices,
                                        0, m_dwNumIndices/3 );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetVertexShaderConstants()
// Desc: 
//-----------------------------------------------------------------------------
VOID CBumpyObject::SetVertexShaderConstants( D3DXVECTOR3* pPtLightPos )
{
    // Compute the matrix set
    D3DXMATRIX matWorldViewProj, matWorldView, matWorld, matView, matProj;
    m_pd3dDevice->GetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
    D3DXMatrixMultiply( &matWorldView, &matWorld, &matView );
    D3DXMatrixMultiply( &matWorldViewProj, &matWorldView, &matProj );
    
    // Get inverse of world matrix
    D3DXMATRIX matInvWorld;
    D3DXMatrixInverse( &matInvWorld, NULL, &matWorld );

    // Transform point light position into object space
    D3DXVECTOR3 vPtLightWorldPos;
    D3DXVec3TransformCoord( &vPtLightWorldPos, pPtLightPos, &matInvWorld );

    // Transform eye position into object space
    D3DXVECTOR3 vPtEyePos( -matView._41, -matView._42, -matView._43 );
    D3DXVECTOR3 vPtEyeWorldPos;
    D3DXVec3TransformCoord( &vPtEyeWorldPos, &vPtEyePos, &matInvWorld );

    // If we are using a vertex shader, we simply pass variables to
    // the vertex shader, and the vertex shader will do the rest.
    D3DXMatrixTranspose( &matWorld, &matWorld );
    D3DXMatrixTranspose( &matWorldView, &matWorldView );
    D3DXMatrixTranspose( &matWorldViewProj, &matWorldViewProj );
    D3DXVECTOR4 vConstants0( 0.0f, 0.0f, 0.0f, 0.0f );
    D3DXVECTOR4 vConstants1( 0.0f, 0.5f, 1.0f, 2.0f );
    m_pd3dDevice->SetVertexShaderConstant(  0, &vConstants0,      1 );
    m_pd3dDevice->SetVertexShaderConstant(  1, &vConstants1,      1 );
    m_pd3dDevice->SetVertexShaderConstant( 11, &vPtEyeWorldPos,   1 );
    m_pd3dDevice->SetVertexShaderConstant( 12, &vPtLightWorldPos, 1 );
    m_pd3dDevice->SetVertexShaderConstant( 20, &matWorld,         4 );
    m_pd3dDevice->SetVertexShaderConstant( 30, &matWorldView,     4 );
    m_pd3dDevice->SetVertexShaderConstant( 40, &matWorldViewProj, 4 );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::Render( LPDIRECT3DDEVICE8 m_pd3dDevice )
{
    m_pd3dDevice->SetRenderState( D3DRS_COLORVERTEX,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );              
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );        
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE );        

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Process the vertices for the perpixel lighting effect.
    SetVertexShaderConstants( &g_vPtLightPos );

    // Set blending to add the upcoming passes to the previous pass
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );  
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );

    // Render the BRDF effect
    {
        m_pd3dDevice->SetTexture( 0, m_pNormalMap );
        m_pd3dDevice->SetTexture( 1, m_pAngularizingCubeMap2 );
        m_pd3dDevice->SetTexture( 2, m_pAngularizingCubeMap1 );
        m_pd3dDevice->SetTexture( 3, m_pBRDFVolumeTexture );
        m_pd3dDevice->SetPixelShader( m_dwBRDFPixelShader );

        // Set clamp mode for the cubemaps
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSW, D3DTADDRESS_CLAMP );

        if( g_bPointFiltering )
        {
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_POINT );
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_POINT );
            m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_POINT );
            m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_POINT );
        }
        else
        {
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
            m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
            m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
            m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
        }

        m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSW, D3DTADDRESS_WRAP );

/*
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, 1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXCOORDINDEX, 2 );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLORARG2, D3DTA_CURRENT );
*/
        RenderObject( m_pd3dDevice );
//        m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );

        m_pd3dDevice->SetPixelShader( NULL );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateBRDFPixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CBumpyObject::CreateBRDFPixelShader()
{
    D3DPIXELSHADERDEF psd;
    ZeroMemory(&psd, sizeof(psd));

    psd.PSCombinerCount=PS_COMBINERCOUNT(
        3,
        PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes=PS_TEXTUREMODES(
        PS_TEXTUREMODES_PROJECT2D,
        PS_TEXTUREMODES_CUBEMAP, 
        PS_TEXTUREMODES_CUBEMAP,
        PS_TEXTUREMODES_BRDF );
    psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
    psd.PSDotMapping=PS_DOTMAPPING(
        0,
        PS_DOTMAPPING_MINUS1_TO_1_D3D,
        PS_DOTMAPPING_MINUS1_TO_1_D3D,
        PS_DOTMAPPING_MINUS1_TO_1_D3D );
    psd.PSCompareMode=PS_COMPAREMODE(
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

    //------------- Stage 0 -------------
    psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
        PS_REGISTER_T3   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ONE  | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
    psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);

    psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_AB_MULTIPLY );
    psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY );

    //------------- Final combiner -------------
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      PS_REGISTER_R0  | PS_CHANNEL_ALPHA,
                                                      0 | 0 | 0 );

    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_ONE   | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_R0    | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO  | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO  | PS_CHANNEL_RGB );

    // Create the pixel shader
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwBRDFPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\gearmodel.cpp ===
//-----------------------------------------------------------------------------
// File: GearModel.cpp
//
// Desc: Model of a gear
//
// Hist: 02.19.00 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <XBUtil.h>
#include "GearModel.h"




//-----------------------------------------------------------------------------
// Custom vertex type
//-----------------------------------------------------------------------------
struct D3DVERTEX
{
    D3DXVECTOR3 pos;
    D3DXVECTOR3 normal;
    FLOAT       tu, tv;
};




//-----------------------------------------------------------------------------
// Basis vectors for a vertex
//-----------------------------------------------------------------------------
struct VERTEXBASIS
{
    D3DXVECTOR3 S;
    D3DXVECTOR3 T;
    D3DXVECTOR3 SxT;
};




inline VOID FILL_VERTEX( D3DVERTEX* v, FLOAT x, FLOAT y, FLOAT z, 
                         FLOAT nx, FLOAT ny, FLOAT nz, FLOAT tu, FLOAT tv )
{
    v->pos    = D3DXVECTOR3( x, y, z );
    v->normal = D3DXVECTOR3( nx, ny, nz );
    v->tu     = tu;
    v->tv     = tv;
}




inline VOID FILL_VERTEX( D3DVERTEX* v, D3DXVECTOR3& p, D3DXVECTOR3& n, 
                         FLOAT tu, FLOAT tv )
{
    v->pos    = p;
    v->normal = n;
    v->tu     = tu;
    v->tv     = tv;
}




//-----------------------------------------------------------------------------
// Name: CreateBasisVectors()
// Desc: Creates basis vectors for a triangle
//-----------------------------------------------------------------------------
VOID CreateBasisVectors( D3DVERTEX& v0, D3DVERTEX& v1, D3DVERTEX& v2, 
                         VERTEXBASIS& b0, VERTEXBASIS& b1, VERTEXBASIS& b2 )
{
    static const float SMALL_FLOAT = 1e-12f;

    float ds1 = v1.tu - v0.tu;
    float dt1 = v1.tv - v0.tv;

    float ds2 = v2.tu - v0.tu;
    float dt2 = v2.tv - v0.tv;

    D3DXVECTOR3 edge01;
    D3DXVECTOR3 edge02;
    D3DXVECTOR3 cp;

    // x, s, t
    edge01 = D3DXVECTOR3( v1.pos.x - v0.pos.x, ds1, dt1 );
    edge02 = D3DXVECTOR3( v2.pos.x - v0.pos.x, ds2, dt2 );

    D3DXVec3Cross(&cp, &edge01, &edge02);
    if ( fabs(cp.x) > SMALL_FLOAT )
    {
        float dsdx = -cp.y / cp.x;
        float dtdx = -cp.z / cp.x;

        b0.S.x += dsdx;
        b0.T.x += dtdx;

        b1.S.x += dsdx;
        b1.T.x += dtdx;

        b2.S.x += dsdx;
        b2.T.x += dtdx;
    }

    // y, s, t
    edge01 = D3DXVECTOR3( v1.pos.y - v0.pos.y, ds1, dt1 );
    edge02 = D3DXVECTOR3( v2.pos.y - v0.pos.y, ds2, dt2 );

    D3DXVec3Cross(&cp, &edge01, &edge02);
    if ( fabs(cp.x) > SMALL_FLOAT )
    {
        float dsdx = -cp.y / cp.x;
        float dtdx = -cp.z / cp.x;

        b0.S.y += dsdx;
        b0.T.y += dtdx;

        b1.S.y += dsdx;
        b1.T.y += dtdx;

        b2.S.y += dsdx;
        b2.T.y += dtdx;
    }

    // z, s, t
    edge01 = D3DXVECTOR3( v1.pos.z - v0.pos.z, ds1, dt1 );
    edge02 = D3DXVECTOR3( v2.pos.z - v0.pos.z, ds2, dt2 );

    D3DXVec3Cross(&cp, &edge01, &edge02);
    if ( fabs(cp.x) > SMALL_FLOAT )
    {
        float dsdx = -cp.y / cp.x;
        float dtdx = -cp.z / cp.x;

        b0.S.z += dsdx;
        b0.T.z += dtdx;

        b1.S.z += dsdx;
        b1.T.z += dtdx;

        b2.S.z += dsdx;
        b2.T.z += dtdx;
    }
}




//-----------------------------------------------------------------------------
// Name: CreateBasisVectorsVB()
// Desc: Creates basis vectors for a mesh
//-----------------------------------------------------------------------------
LPDIRECT3DVERTEXBUFFER8 CreateBasisVectorsVB( LPDIRECT3DDEVICE8 pd3dDevice,
                                              D3DPRIMITIVETYPE dwPrimType, 
                                              D3DVERTEX* pVertices, DWORD dwNumVertices,
                                              WORD* pIndices, DWORD dwNumIndices )
{
    // Create a vertex buffer
    LPDIRECT3DVERTEXBUFFER8 pBasisVB;
    pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(VERTEXBASIS), 0, 0, 0,
                                    &pBasisVB );

    // Fill the VB with the basis vectors
    VERTEXBASIS* pVertexBases;
    pBasisVB->Lock( 0, 0, (BYTE**)&pVertexBases, 0 );

    // Clear the basis vectors
    for( DWORD i = 0; i < dwNumVertices; i++)
    {
        pVertexBases[i].S = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
        pVertexBases[i].T = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    }

    DWORD dwNumPrimitives = 0L;
    if( dwPrimType == D3DPT_TRIANGLELIST )
        dwNumPrimitives = pIndices ? dwNumIndices / 3 : dwNumVertices / 3;
    if( dwPrimType == D3DPT_QUADLIST )
        dwNumPrimitives = pIndices ? dwNumIndices / 4 : dwNumVertices / 4;

    // Walk through the triangle list and calculate gradiants for each triangle.
    // Sum the results into the S and T components.
    for( i = 0; i < dwNumPrimitives; i++ )
    {
        if( dwPrimType == D3DPT_TRIANGLELIST )
        {
            DWORD i0 = pIndices ? pIndices[3*i+0] : 3*i+0;
            DWORD i1 = pIndices ? pIndices[3*i+1] : 3*i+1;
            DWORD i2 = pIndices ? pIndices[3*i+2] : 3*i+2;

            D3DVERTEX&   v0 = pVertices[i0];
            D3DVERTEX&   v1 = pVertices[i1];
            D3DVERTEX&   v2 = pVertices[i2];
            VERTEXBASIS& b0 = pVertexBases[i0];
            VERTEXBASIS& b1 = pVertexBases[i1];
            VERTEXBASIS& b2 = pVertexBases[i2];

            CreateBasisVectors( v0, v1, v2, b0, b1, b2 );
        }

        if( dwPrimType == D3DPT_QUADLIST )
        {
            DWORD i0 = pIndices ? pIndices[4*i+0] : 4*i+0;
            DWORD i1 = pIndices ? pIndices[4*i+1] : 4*i+1;
            DWORD i2 = pIndices ? pIndices[4*i+2] : 4*i+2;
            DWORD i3 = pIndices ? pIndices[4*i+3] : 4*i+3;

            D3DVERTEX&   v0 = pVertices[i0];
            D3DVERTEX&   v1 = pVertices[i1];
            D3DVERTEX&   v2 = pVertices[i2];
            D3DVERTEX&   v3 = pVertices[i3];
            VERTEXBASIS& b0 = pVertexBases[i0];
            VERTEXBASIS& b1 = pVertexBases[i1];
            VERTEXBASIS& b2 = pVertexBases[i2];
            VERTEXBASIS& b3 = pVertexBases[i3];

            CreateBasisVectors( v0, v1, v2, b0, b1, b2 );
            CreateBasisVectors( v0, v2, v3, b0, b2, b3 );
        }
    }

    // Calculate the SxT vector
    for( i = 0; i < dwNumVertices; i++ )
    {
        // Normalize the S, T vectors
        D3DXVec3Normalize( &pVertexBases[i].S, &pVertexBases[i].S );
        D3DXVec3Normalize( &pVertexBases[i].T, &pVertexBases[i].T );

        // Get the cross of the S and T vectors
        D3DXVec3Cross( &pVertexBases[i].SxT, &pVertexBases[i].S, &pVertexBases[i].T );

        // Need a normalized normal
        D3DXVECTOR3 vNormal;
        D3DXVec3Normalize( &vNormal, &pVertices[i].normal );

        // Get the direction of the SxT vector
        if( D3DXVec3Dot( &pVertexBases[i].SxT, &vNormal ) < 0.0f )
            pVertexBases[i].SxT = -pVertexBases[i].SxT;
    }

    pBasisVB->Unlock();
    return pBasisVB;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the geometry of a toothed-gear for the part
//-----------------------------------------------------------------------------
HRESULT CGearMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, FLOAT fRadius, 
                           FLOAT fRotationSpeed, DWORD dwNumTeeth,
                           FLOAT fRotationOffset )
{
    // Set parameters
    m_fRotationSpeed   = fRotationSpeed;
    m_fRotationAngle   = 0.0f;

    // Values used for calculating the geometry of the vertices
    FLOAT TEETH_DEPTH  = 0.1f;
    FLOAT fOuterRadius = fRadius + TEETH_DEPTH/2;
    FLOAT fInnerRadius = fRadius - TEETH_DEPTH/2;
    FLOAT fDepth       = 0.1f; //half-thickness of the gear
    FLOAT fTheta       = 0.0f;
    FLOAT fSubTheta    = ( 2*D3DX_PI / dwNumTeeth )/5;
    FLOAT fAngle;

    m_dwNumBodyVertices  = 4 + (8*dwNumTeeth);
    m_dwNumBodyIndices   = 24*dwNumTeeth;
    m_dwNumTeethVertices = 16*dwNumTeeth;

    // Create the geometry buffers
    pd3dDevice->CreateVertexBuffer( m_dwNumBodyVertices*sizeof(D3DVERTEX), 0, 0, 0,
                                    &m_pBodyVB );
    pd3dDevice->CreateVertexBuffer( m_dwNumTeethVertices*sizeof(D3DVERTEX), 0, 0, 0,
                                    &m_pTeethVB );
    pd3dDevice->CreateIndexBuffer( m_dwNumBodyIndices*sizeof(WORD), 
                                   D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, 
                                   D3DPOOL_DEFAULT, &m_pBodyIB );

    // Lock the geometry buffers so we can fill them
    D3DVERTEX* pBodyVertices;
    WORD*      pBodyIndices;
    D3DVERTEX* pTeethVertices;
    m_pBodyVB->Lock(  0, 0, (BYTE**)&pBodyVertices,  0 );
    m_pTeethVB->Lock( 0, 0, (BYTE**)&pTeethVertices, 0 );
    m_pBodyIB->Lock(  0, 0, (BYTE**)&pBodyIndices,   0 );

    // Create and fill in the vertices for the gear body
    D3DVERTEX* pVertex = pBodyVertices;

    D3DXVECTOR3 vfront = D3DXVECTOR3( 0.0f, fDepth, 0.0f );
    D3DXVECTOR3 vback  = D3DXVECTOR3( 0.0f,-fDepth, 0.0f );
    D3DXVECTOR3 nfront = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 nback  = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
    FILL_VERTEX( pVertex++, vfront, nfront, 0.5f, 0.5f ); 
    FILL_VERTEX( pVertex++, vback,  nback,  0.5f, 0.5f ); 

    for( DWORD i=0; i<dwNumTeeth; i++ )
    {
        fTheta    = (i*2*D3DX_PI) / dwNumTeeth;
        fSubTheta = ( 2*D3DX_PI / dwNumTeeth )/6;
        fTheta += fRotationOffset;
        
        fAngle = fTheta - 2 * fSubTheta;
        vfront = D3DXVECTOR3( fInnerRadius * cosf( fAngle ), +fDepth, fInnerRadius * sinf( fAngle ) );
        vback  = D3DXVECTOR3( fInnerRadius * cosf( fAngle ), -fDepth, fInnerRadius * sinf( fAngle ) );
        FILL_VERTEX( pVertex++, vfront, nfront, (1+vfront.x/fOuterRadius)/2, (1+vfront.z/fOuterRadius)/2 ); 
        FILL_VERTEX( pVertex++, vback,  nback,  (1+vback.x /fOuterRadius)/2, (1+ vback.z/fOuterRadius)/2 ); 

        fAngle = fTheta - 1 * fSubTheta;
        vfront = D3DXVECTOR3( fOuterRadius * cosf( fAngle ), +fDepth, fOuterRadius * sinf( fAngle ) );
        vback  = D3DXVECTOR3( fOuterRadius * cosf( fAngle ), -fDepth, fOuterRadius * sinf( fAngle ) );
        FILL_VERTEX( pVertex++, vfront, nfront, (1+vfront.x/fOuterRadius)/2, (1+vfront.z/fOuterRadius)/2 ); 
        FILL_VERTEX( pVertex++, vback,  nback,  (1+vback.x /fOuterRadius)/2, (1+ vback.z/fOuterRadius)/2 ); 

        fAngle = fTheta + 1 * fSubTheta;
        vfront = D3DXVECTOR3( fOuterRadius * cosf( fAngle ), +fDepth, fOuterRadius * sinf( fAngle ) );
        vback  = D3DXVECTOR3( fOuterRadius * cosf( fAngle ), -fDepth, fOuterRadius * sinf( fAngle ) );
        FILL_VERTEX( pVertex++, vfront, nfront, (1+vfront.x/fOuterRadius)/2, (1+vfront.z/fOuterRadius)/2 ); 
        FILL_VERTEX( pVertex++, vback,  nback,  (1+vback.x /fOuterRadius)/2, (1+ vback.z/fOuterRadius)/2 ); 

        fAngle = fTheta + 2 * fSubTheta;
        vfront = D3DXVECTOR3( fInnerRadius * cosf( fAngle ), +fDepth, fInnerRadius * sinf( fAngle ) );
        vback  = D3DXVECTOR3( fInnerRadius * cosf( fAngle ), -fDepth, fInnerRadius * sinf( fAngle ) );
        FILL_VERTEX( pVertex++, vfront, nfront, (1+vfront.x/fOuterRadius)/2, (1+vfront.z/fOuterRadius)/2 ); 
        FILL_VERTEX( pVertex++, vback,  nback,  (1+vback.x /fOuterRadius)/2, (1+ vback.z/fOuterRadius)/2 ); 
    }

    fAngle = fRotationOffset - 2 * fSubTheta;
    vfront = D3DXVECTOR3( fInnerRadius * cosf( fAngle ), +fDepth, fInnerRadius * sinf( fAngle ) );
    vback  = D3DXVECTOR3( fInnerRadius * cosf( fAngle ), -fDepth, fInnerRadius * sinf( fAngle ) );
    FILL_VERTEX( pVertex++, vfront, nfront, (1+vfront.x/fOuterRadius)/2, (1+vfront.z/fOuterRadius)/2 ); 
    FILL_VERTEX( pVertex++, vback,  nback,  (1+vback.x /fOuterRadius)/2, (1+ vback.z/fOuterRadius)/2 ); 

    // Create and fill in the indices for the gear body
    WORD* pIndex = pBodyIndices;

    for( i = 0; i < dwNumTeeth; i++ )
    {
        WORD v = (WORD)( 2 + 8*i );
        (*pIndex++) = v+0;  (*pIndex++) = v+6;  (*pIndex++) = 0; 
        (*pIndex++) = v+6;  (*pIndex++) = v+8;  (*pIndex++) = 0; 
        (*pIndex++) = v+7;  (*pIndex++) = v+1;  (*pIndex++) = 1; 
        (*pIndex++) = v+9;  (*pIndex++) = v+7;  (*pIndex++) = 1; 

        (*pIndex++) = v+0;  (*pIndex++) = v+2;  (*pIndex++) = v+6; 
        (*pIndex++) = v+2;  (*pIndex++) = v+4;  (*pIndex++) = v+6; 
        (*pIndex++) = v+7;  (*pIndex++) = v+3;  (*pIndex++) = v+1; 
        (*pIndex++) = v+7;  (*pIndex++) = v+5;  (*pIndex++) = v+3; 
    }

    // Create vertices for the gear teeth
    for( i=0; i<dwNumTeeth; i++ )
    {
        FLOAT fSubTheta0 = ( 2*D3DX_PI / dwNumTeeth )/6;
        FLOAT fTheta0   = fRotationOffset + ((i+0)*2*D3DX_PI) / dwNumTeeth;
        FLOAT fTheta1   = fRotationOffset + ((i+1)*2*D3DX_PI) / dwNumTeeth;

        FLOAT fAngle0 = fTheta0 - 2 * fSubTheta0;
        FLOAT fAngle1 = fTheta0 - 1 * fSubTheta0;
        FLOAT fAngle2 = fTheta0 + 1 * fSubTheta0;
        FLOAT fAngle3 = fTheta0 + 2 * fSubTheta0;
        FLOAT fAngle4 = fTheta1 - 2 * fSubTheta0;

        D3DXVECTOR3 v0front = D3DXVECTOR3( fInnerRadius * cosf( fAngle0 ), fDepth, fInnerRadius * sinf( fAngle0 ) );
        D3DXVECTOR3 v0back  = D3DXVECTOR3( fInnerRadius * cosf( fAngle0 ),-fDepth, fInnerRadius * sinf( fAngle0 ) );
        D3DXVECTOR3 v1front = D3DXVECTOR3( fOuterRadius * cosf( fAngle1 ), fDepth, fOuterRadius * sinf( fAngle1 ) );
        D3DXVECTOR3 v1back  = D3DXVECTOR3( fOuterRadius * cosf( fAngle1 ),-fDepth, fOuterRadius * sinf( fAngle1 ) );
        D3DXVECTOR3 v2front = D3DXVECTOR3( fOuterRadius * cosf( fAngle2 ), fDepth, fOuterRadius * sinf( fAngle2 ) );
        D3DXVECTOR3 v2back  = D3DXVECTOR3( fOuterRadius * cosf( fAngle2 ),-fDepth, fOuterRadius * sinf( fAngle2 ) );
        D3DXVECTOR3 v3front = D3DXVECTOR3( fInnerRadius * cosf( fAngle3 ), fDepth, fInnerRadius * sinf( fAngle3 ) );
        D3DXVECTOR3 v3back  = D3DXVECTOR3( fInnerRadius * cosf( fAngle3 ),-fDepth, fInnerRadius * sinf( fAngle3 ) );
        D3DXVECTOR3 v4front = D3DXVECTOR3( fInnerRadius * cosf( fAngle4 ), fDepth, fInnerRadius * sinf( fAngle4 ) );
        D3DXVECTOR3 v4back  = D3DXVECTOR3( fInnerRadius * cosf( fAngle4 ),-fDepth, fInnerRadius * sinf( fAngle4 ) );

        D3DXVECTOR3 n0 = D3DXVECTOR3( cosf( fTheta0-0.5f ),        0.0f, sinf( fTheta0-0.5f ) );
        D3DXVECTOR3 n1 = D3DXVECTOR3( cosf( fTheta0 ),             0.0f, sinf( fTheta0 ) );
        D3DXVECTOR3 n2 = D3DXVECTOR3( cosf( fTheta0+0.5f ),        0.0f, sinf( fTheta0+0.5f ) );
        D3DXVECTOR3 n3 = D3DXVECTOR3( cosf( (fTheta0+fTheta1)/2 ), 0.0f, sinf( (fTheta0+fTheta1)/2 ) );

        FLOAT tu0 = ( 0.50f * fAngle0 );
        FLOAT tu1 = ( 0.50f * fAngle1 );
        FLOAT tu2 = ( 1.50f * fAngle1 );
        FLOAT tu3 = ( 1.50f * fAngle2 );
        FLOAT tu4 = ( 0.50f * fAngle2 );
        FLOAT tu5 = ( 0.50f * fAngle3 );
        FLOAT tu6 = ( 1.50f * fAngle3 );
        FLOAT tu7 = ( 1.50f * fAngle4 );

        FILL_VERTEX( pTeethVertices++, v0front, n0, tu0, 0.00f ); 
        FILL_VERTEX( pTeethVertices++, v0back,  n0, tu0, 0.14f ); 
        FILL_VERTEX( pTeethVertices++, v1back,  n0, tu1, 0.14f ); 
        FILL_VERTEX( pTeethVertices++, v1front, n0, tu1, 0.00f ); 

        FILL_VERTEX( pTeethVertices++, v1front, n1, tu2, 0.00f ); 
        FILL_VERTEX( pTeethVertices++, v1back,  n1, tu2, 0.14f ); 
        FILL_VERTEX( pTeethVertices++, v2back,  n1, tu3, 0.14f ); 
        FILL_VERTEX( pTeethVertices++, v2front, n1, tu3, 0.00f ); 

        FILL_VERTEX( pTeethVertices++, v2front, n2, tu4, 0.00f ); 
        FILL_VERTEX( pTeethVertices++, v2back,  n2, tu4, 0.14f ); 
        FILL_VERTEX( pTeethVertices++, v3back,  n2, tu5, 0.14f ); 
        FILL_VERTEX( pTeethVertices++, v3front, n2, tu5, 0.00f ); 

        FILL_VERTEX( pTeethVertices++, v3front, n3, tu6, 0.00f ); 
        FILL_VERTEX( pTeethVertices++, v3back,  n3, tu6, 0.14f ); 
        FILL_VERTEX( pTeethVertices++, v4back,  n3, tu7, 0.14f ); 
        FILL_VERTEX( pTeethVertices++, v4front, n3, tu7, 0.00f ); 
    }

    m_pBodyVB->Unlock();
    m_pTeethVB->Unlock();
    m_pBodyIB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Animate the gear
//-----------------------------------------------------------------------------
HRESULT CGearMesh::FrameMove( LPDIRECT3DDEVICE8 pd3dDevice, FLOAT fTime )
{
    m_fRotationAngle = fTime * m_fRotationSpeed;
    D3DXMatrixRotationY( &m_matRotation, m_fRotationAngle );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Animate the gear
//-----------------------------------------------------------------------------
HRESULT CGearMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice )
{
    // Orient the geoemtry
    D3DXMATRIX mat, matWorldSaved;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSaved );
    D3DXMatrixMultiply( &mat, &m_matRotation, &m_matPosition );
    D3DXMatrixMultiply( &mat, &mat, &matWorldSaved );
    pd3dDevice->SetTransform( D3DTS_WORLD, &mat );
    
    // Draw the gear body
    pd3dDevice->SetIndices( m_pBodyIB, 0 );
    pd3dDevice->SetStreamSource( 0, m_pBodyVB,      sizeof(D3DVERTEX) );
    pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, m_dwNumBodyVertices, 
                                        0, m_dwNumBodyIndices/3 );
    // Draw the gear teeth edges
    pd3dDevice->SetStreamSource( 0, m_pTeethVB,      sizeof(D3DVERTEX) );
    pd3dDevice->DrawVertices( D3DPT_QUADLIST, 0, m_dwNumTeethVertices );

    // Restore the world matrix
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSaved );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the geometry of a toothed-gear for the part
//-----------------------------------------------------------------------------
HRESULT CBumpyGearMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, FLOAT fRadius, 
                                FLOAT fRotationSpeed, DWORD dwNumTeeth,
                                FLOAT fRotationOffset )
{
    // Create the mesh geometry
    CGearMesh::Create( pd3dDevice, fRadius, fRotationSpeed, dwNumTeeth, fRotationOffset );

    // Create the basis vectors
    D3DVERTEX* pBodyVertices;
    WORD*      pBodyIndices;
    D3DVERTEX* pTeethVertices;
    m_pBodyVB->Lock(  0, 0, (BYTE**)&pBodyVertices,  0 );
    m_pTeethVB->Lock( 0, 0, (BYTE**)&pTeethVertices, 0 );
    m_pBodyIB->Lock(  0, 0, (BYTE**)&pBodyIndices,   0 );

    m_pBodyBasisVB  = CreateBasisVectorsVB( pd3dDevice, D3DPT_TRIANGLELIST, 
                                            pBodyVertices, m_dwNumBodyVertices, 
                                            pBodyIndices, m_dwNumBodyIndices );
    m_pTeethBasisVB = CreateBasisVectorsVB( pd3dDevice, D3DPT_QUADLIST, 
                                            pTeethVertices, m_dwNumTeethVertices, 
                                            NULL, 0L );

    m_pBodyVB->Unlock();
    m_pTeethVB->Unlock();
    m_pBodyIB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Animate the gear
//-----------------------------------------------------------------------------
HRESULT CBumpyGearMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice )
{
    // Orient the geoemtry
    D3DXMATRIX mat, matWorldSaved;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSaved );
    D3DXMatrixMultiply( &mat, &m_matRotation, &m_matPosition );
    D3DXMatrixMultiply( &mat, &mat, &matWorldSaved );
    pd3dDevice->SetTransform( D3DTS_WORLD, &mat );
    
    // Note: when passing matrices to a vertex shader, we transpose them, since
    // matrix multiplies are done with dot product operations on the matrix rows.
    D3DXMATRIX matT;
    D3DXMATRIX matWorld, matView, matProj;
    pd3dDevice->GetTransform( D3DTS_WORLD,      &matWorld );
    pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
    pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );

    // Pass the world matrix to the vertex shader
    D3DXMatrixTranspose( &matT, &matWorld );
    pd3dDevice->SetVertexShaderConstant( 0, &matT, 4 );
    
    // Pass the view * projection matrix to the vertex shader
    D3DXMatrixMultiply( &mat, &matView, &matProj );
    D3DXMatrixTranspose( &matT, &mat );
    pd3dDevice->SetVertexShaderConstant( 4, &matT, 4 );

    // Pass the world space view position to the vertex shader.
    D3DXMATRIX matViewInverse;
    D3DXMatrixInverse( &matViewInverse, 0, &matView );
    D3DXVECTOR4 v4WorldViewPos(0.0f,0.0f,0.0f,1.0f);
    D3DXVec4Transform( &v4WorldViewPos, &v4WorldViewPos, &matViewInverse );
    pd3dDevice->SetVertexShaderConstant( 8, &v4WorldViewPos, 1 );

    D3DXVECTOR4 fTestValues( 0.0f, 0.0f, 1.0f, 0.0f );
    pd3dDevice->SetVertexShaderConstant( 9, fTestValues, 1 );
    
    // Draw the gear body
    pd3dDevice->SetIndices( m_pBodyIB, 0 );
    pd3dDevice->SetStreamSource( 0, m_pBodyVB,      sizeof(D3DVERTEX) );
    pd3dDevice->SetStreamSource( 1, m_pBodyBasisVB, sizeof(VERTEXBASIS) );
    pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, m_dwNumBodyVertices, 
                                        0, m_dwNumBodyIndices/3 );

    // Draw the gear teeth edges
    pd3dDevice->SetStreamSource( 0, m_pTeethVB,      sizeof(D3DVERTEX) );
    pd3dDevice->SetStreamSource( 1, m_pTeethBasisVB, sizeof(VERTEXBASIS) );
    pd3dDevice->DrawVertices( D3DPT_QUADLIST, 0, m_dwNumTeethVertices );

    // Restore the world matrix
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSaved );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\bumpdemo.cpp ===
//-----------------------------------------------------------------------------
// File: BumpDemo.cpp
//
// Desc: 
//
// Hist: 02.19.00 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <xgraphics.h>
#include "GearModel.h"

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Rotate scene" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_1, L"Cycle options" },
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle gloss map" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle pass thru" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 6




//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
static const DWORD rgTex[] = { PS_REGISTER_T0, PS_REGISTER_T1, 
                               PS_REGISTER_T2, PS_REGISTER_T3 };




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource       m_xprResource;      // Packed resources for the app
    CXBFont                 m_Font;             // Font class
    CXBHelp                 m_Help;             // Help class
    BOOL                    m_bDrawHelp;        // Whether to draw help

    D3DXVECTOR3             m_vEye;             // Eye location
    D3DXVECTOR3             m_vAt;              // Eye lookat
    D3DXVECTOR3             m_vUp;              // Eye up direction

    FLOAT                   m_fAngleObjYaw;     // Object rotation angles
    FLOAT                   m_fAngleObjPitch;

    BOOL                    m_bDrawGlossMap;
    BOOL                    m_bPassThru;        // Pass tex coords through to combiner

    LPDIRECT3DTEXTURE8      m_pNormalMap;       // Normal map texture
    LPDIRECT3DTEXTURE8      m_pGlossMap;        // Normal map texture
    LPDIRECT3DCUBETEXTURE8  m_pEnvCubeMap;      // Environment cubemap texture

    DWORD                   m_dwDotMapping;
    DWORD                   m_dwInpTexRegister; // Texture input register (T3)

    DWORD                   m_ShaderHandle;     // Pixel shader handle
    DWORD                   m_dwVertexShader;   // Vertex shader handle

    CBumpyGearMesh          m_Gears[5];

    HRESULT InitPixelShader();

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize members
    m_bDrawHelp        = FALSE;
    
    m_vEye             = D3DXVECTOR3( 0.0f, 0.0f,-5.0f );
    m_vAt              = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vUp              = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    m_fAngleObjYaw     =   0.0f;
    m_fAngleObjPitch   = -90.0f;

    m_bDrawGlossMap    = TRUE;
    m_bPassThru        = FALSE;

    m_pNormalMap       = NULL;
    m_pGlossMap        = NULL;
    m_pEnvCubeMap      = NULL;

    m_dwDotMapping     = PS_DOTMAPPING_MINUS1_TO_1_D3D;
    m_dwInpTexRegister = 3;

    m_ShaderHandle     = 0;
    m_dwVertexShader   = 0;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: Initialize and create our pixel shader
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitPixelShader()
{
    if( m_ShaderHandle )
    {
        m_pd3dDevice->DeletePixelShader( m_ShaderHandle );
        m_ShaderHandle = 0;
    }

    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );

    //---------------------------------------------------------------------------
    //  Texture configuration - The following members of the D3DPixelShaderDef   
    //  structure define the addressing modes of each of the four texture stages 
    //---------------------------------------------------------------------------
    if( m_bPassThru )
    {
        psd.PSTextureModes = PS_TEXTUREMODES( PS_TEXTUREMODES_PASSTHRU,
                                              PS_TEXTUREMODES_PASSTHRU,
                                              PS_TEXTUREMODES_PASSTHRU,
                                              PS_TEXTUREMODES_PASSTHRU );
    }
    else
    {
        psd.PSTextureModes = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D,
                                              PS_TEXTUREMODES_DOTPRODUCT,
                                              PS_TEXTUREMODES_DOTPRODUCT,
                                              PS_TEXTUREMODES_DOT_RFLCT_SPEC );
    }

    psd.PSDotMapping = PS_DOTMAPPING( 0,
                                      m_dwDotMapping,
                                      m_dwDotMapping,
                                      m_dwDotMapping );

    psd.PSInputTexture = PS_INPUTTEXTURE( 0,
                                          0,
                                          0,  // 0 and 1 valid
                                          0 ); // 0, 1, and 2 valid
    psd.PSCompareMode = PS_COMPAREMODE(0, 0, 0, 0);

    //---------------------------------------------------------------------------------
    //  Color combiners - The following members of the D3DPixelShaderDef structure     
    //  define the state for the eight stages of color combiners                       
    //---------------------------------------------------------------------------------
    psd.PSCombinerCount = PS_COMBINERCOUNT(
        1,
        PS_COMBINERCOUNT_MUX_LSB | PS_COMBINERCOUNT_SAME_C0 | PS_COMBINERCOUNT_SAME_C1);

    static DWORD dwC0Color = D3DCOLOR_ARGB(0xff, 0xff, 0xff, 0xff);
    psd.PSConstant0[0] = dwC0Color;
    psd.PSConstant1[0] = 0;

    psd.PSFinalCombinerConstant0 = 0;
    psd.PSFinalCombinerConstant1 = 0;

    m_dwInpTexRegister = min(m_dwInpTexRegister, sizeof(rgTex) / sizeof(rgTex[0]));

    // R0_ALPHA is initialized to T0_ALPHA in stage0

    // a,b,c,d each contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING
    psd.PSRGBInputs[0] = PS_COMBINERINPUTS(
        rgTex[m_dwInpTexRegister] | PS_INPUTMAPPING_SIGNED_IDENTITY | PS_CHANNEL_RGB,   // A
        PS_REGISTER_C0, //PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT,                             // B
        PS_REGISTER_ZERO,                                                               // C
        PS_REGISTER_ZERO);                                                              // D

    // R0_ALPHA is initialized to T0_ALPHA in stage0
    psd.PSAlphaInputs[0] = PS_COMBINERINPUTS(
        PS_REGISTER_T0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,          // A
        PS_REGISTER_ZERO | PS_INPUTMAPPING_UNSIGNED_INVERT,                             // B
        PS_REGISTER_ZERO,                                                               // C
        PS_REGISTER_ZERO);                                                              // D

    // mux_sum must be DISCARD if either AB_DOT_PRODUCT or CD_DOT_PRODUCT are set
    //  ie: Dot / Dot / Discard || Dot / Mult / Discard || Mult / Dot / Discard

    // ab,cd,mux_sum contain a value from PS_REGISTER
    // flags contains values from PS_COMBINEROUTPUT
    psd.PSRGBOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,                                                                 // ab
        PS_REGISTER_DISCARD,                                                            // cd
        PS_REGISTER_DISCARD,                                                            // mux_sum
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY);                    // flags
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,                                                                 // ab
        PS_REGISTER_DISCARD,                                                            // cd
        PS_REGISTER_DISCARD,                                                            // mux_sum
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY);                    // flags

    // FOG ALPHA is only available in final combiner
    // V1R0_SUM and EF_PROD are only available in final combiner A,B,C,D inputs
    // V1R0_SUM_ALPHA and EF_PROD_ALPHA are not available

    // AB + (1-A)C + D
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,                                                               // A
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,            // B
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,            // C
        PS_REGISTER_ZERO);                                                              // D

    // E,F,G contain a value from PS_REGISTER, PS_CHANNEL, and PS_INPUTMAPPING
    // flags contains values from PS_FINALCOMBINERSETTING:
    //    PS_FINALCOMBINERSETTING_CLAMP_SUM         // V1+R0 sum clamped to [0,1]
    //    PS_FINALCOMBINERSETTING_COMPLEMENT_V1     // unsigned invert mapping
    //    PS_FINALCOMBINERSETTING_COMPLEMENT_R0     // unsigned invert mapping
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,                                                               // E
        PS_REGISTER_ZERO,                                                               // F
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,          // G (alpha)
        PS_FINALCOMBINERSETTING_CLAMP_SUM);                                             // flags

    return m_pd3dDevice->CreatePixelShader( &psd, &m_ShaderHandle );
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a texture to render into
    m_pEnvCubeMap     = m_xprResource.GetCubemap( resource_Lobby_OFFSET);
    m_pNormalMap      = m_xprResource.GetTexture( resource_GearBump_OFFSET );
    m_pGlossMap       = m_xprResource.GetTexture( resource_Gear_OFFSET );

    // Initialize pixel shader
    InitPixelShader();

    // Define the shader declaration. Vertex components come in two streams:
    // the first with the typical vertex components (position, normal, and
    // texcoords) and the second with vertex's basis vectors.
    DWORD dwShaderVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ),    // Position
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ),    // Normal
        D3DVSD_REG( 2, D3DVSDT_FLOAT2 ),    // Base texture coordinate
        D3DVSD_STREAM( 1 ),
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ),    // S basis vector
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ),    // T basis vector
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ),    // SxT basis vector
        D3DVSD_END()
    };

    // Init vertex shader
    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\BumpShader.xvu",
                                           dwShaderVertexDecl, &m_dwVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create some geometry
    m_Gears[0].Create( m_pd3dDevice, 0.45f, 3.0f, 15, 0.36f );
    m_Gears[1].Create( m_pd3dDevice, 0.60f,-3.0f, 15, 0.08f );
    m_Gears[2].Create( m_pd3dDevice, 0.90f, 1.5f, 30, 0.00f );
    m_Gears[3].Create( m_pd3dDevice, 0.90f,-0.5f, 30, 0.00f );
    m_Gears[4].Create( m_pd3dDevice, 0.30f, 1.5f, 10, 0.25f );

    // Offset the newly created gears
    D3DXMatrixTranslation( &m_Gears[0].m_matPosition, 1.08f, 0.00f, 1.03f );
    D3DXMatrixTranslation( &m_Gears[1].m_matPosition, 0.00f, 0.00f, 1.03f );
    D3DXMatrixTranslation( &m_Gears[2].m_matPosition, 0.00f, 0.00f,-0.50f );
    D3DXMatrixTranslation( &m_Gears[3].m_matPosition,-1.23f, 0.20f,-0.50f );
    D3DXMatrixTranslation( &m_Gears[4].m_matPosition, 0.00f, 0.20f,-0.50f );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Move scene
    m_fAngleObjYaw   += m_DefaultGamepad.fX1 * m_fElapsedTime * 100.0f;
    m_fAngleObjPitch += m_DefaultGamepad.fY1 * m_fElapsedTime * 100.0f;

    // Toggle options
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] ) 
    {
        m_bDrawGlossMap  = !m_bDrawGlossMap;
        InitPixelShader();
    }
    
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ) 
    {
        m_bPassThru = !m_bPassThru;
        InitPixelShader();
    }

    // X button cycles through modes
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] ) 
    {
        m_dwInpTexRegister = (m_dwInpTexRegister + 1) % (sizeof(rgTex) / sizeof(rgTex[0]));
        InitPixelShader();
    }

    // Update the rotation of the gears
    m_Gears[0].FrameMove( m_pd3dDevice, m_fAppTime );
    m_Gears[1].FrameMove( m_pd3dDevice, m_fAppTime );
    m_Gears[2].FrameMove( m_pd3dDevice, m_fAppTime );
    m_Gears[3].FrameMove( m_pd3dDevice, m_fAppTime );
    m_Gears[4].FrameMove( m_pd3dDevice, m_fAppTime );

    // Set the matrices
    D3DXMATRIX matWorld, matView, matProj;
    D3DXMatrixRotationYawPitchRoll( &matWorld, m_fAngleObjYaw * D3DX_PI / 180.0f,
                                    m_fAngleObjPitch * D3DX_PI / 180.0f, 0.0f );
    D3DXMatrixLookAtRH( &matView, &m_vEye, &m_vAt, &m_vUp );
    D3DXMatrixPerspectiveFovRH( &matProj, D3DX_PI/4, 640.0f/480.0f, 1.0f, 10000.0f );
    
    g_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    g_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x000000ff, 1.0f, 0L );

    // Set default states
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Set states for drawing the bump effect
    m_pd3dDevice->SetTexture( 0, m_pNormalMap );
    m_pd3dDevice->SetTexture( 2, m_pEnvCubeMap );
    m_pd3dDevice->SetTexture( 3, m_pEnvCubeMap );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,       D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,        0x00000001 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetVertexShader( m_dwVertexShader );
    m_pd3dDevice->SetPixelShader( m_ShaderHandle );

    // Render the gears
    m_Gears[0].Render( m_pd3dDevice );
    m_Gears[1].Render( m_pd3dDevice );
    m_Gears[2].Render( m_pd3dDevice );
    m_Gears[3].Render( m_pd3dDevice );
    m_Gears[4].Render( m_pd3dDevice );

    // Restore the state
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetTexture( 2, NULL );
    m_pd3dDevice->SetTexture( 3, NULL );

    // Add the glossmap in a 2nd pass
    if( m_bDrawGlossMap )
    {
        // Draw gloss map
        m_pd3dDevice->SetTexture( 0, m_pGlossMap );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_ZERO );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_SRCCOLOR );

        m_Gears[0].Render( m_pd3dDevice );
        m_Gears[1].Render( m_pd3dDevice );
        m_Gears[2].Render( m_pd3dDevice );
        m_Gears[3].Render( m_pd3dDevice );
        m_Gears[4].Render( m_pd3dDevice );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"BumpDemo" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Output description of what's being displayed
        switch( m_dwInpTexRegister )
        {
            case 0:  m_Font.DrawText( 64, 75, 0xffffff00, L"Normal map only" );  break;
            case 1:  m_Font.DrawText( 64, 75, 0xffffff00, L"1st cubemap only" ); break;
            case 2:  m_Font.DrawText( 64, 75, 0xffffff00, L"2nd cubemap only" ); break;
            default: m_Font.DrawText( 64, 75, 0xffffff00, L"Full effect" );      break;
        }

        // Output state of options
        m_Font.DrawText( 64, 100, 0xffffff00, m_bDrawGlossMap ? L"Glossmap ON" : L"Glossmap OFF" );
        m_Font.DrawText( 64, 125, 0xffffff00, m_bPassThru ? L"Pass thru TRUE" : L"Pass thru FALSE" );
        m_Font.End();
    }
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Lobby_OFFSET 0UL
#define resource_GearBump_OFFSET 20UL
#define resource_Gear_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Lobby_OFFSET 0UL
#define resource_GearBump_OFFSET 20UL
#define resource_Gear_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpEarth\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpDemo\gearmodel.h ===
//-----------------------------------------------------------------------------
// File: GearModel.h
//
// Desc: Model of a gear
//
// Hist: 02.19.00 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef GEARMODEL_H
#define GEARMODEL_H


    

//-----------------------------------------------------------------------------
// Name: class CGearMesh
// Desc: 
//-----------------------------------------------------------------------------
class CGearMesh
{
protected:
    LPDIRECT3DVERTEXBUFFER8 m_pBodyVB;
    LPDIRECT3DINDEXBUFFER8  m_pBodyIB;
    DWORD      m_dwNumBodyVertices;
    DWORD      m_dwNumBodyIndices;

    LPDIRECT3DVERTEXBUFFER8 m_pTeethVB;
    DWORD      m_dwNumTeethVertices;

public:
    FLOAT      m_fRotationSpeed;
    FLOAT      m_fRotationAngle;
    D3DXMATRIX m_matPosition;
    D3DXMATRIX m_matRotation;

public:
    virtual HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, FLOAT fRadius, 
                            FLOAT fRotationSpeed, DWORD dwNumTeeth,
                            FLOAT fRotationOffset );
    virtual HRESULT FrameMove( LPDIRECT3DDEVICE8 pd3dDevice, FLOAT fTime );
    virtual HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice );
};




//-----------------------------------------------------------------------------
// Name: class CBumpyGearMesh
// Desc: 
//-----------------------------------------------------------------------------
class CBumpyGearMesh : public CGearMesh
{
    LPDIRECT3DVERTEXBUFFER8 m_pBodyBasisVB;
    LPDIRECT3DVERTEXBUFFER8 m_pTeethBasisVB;

public:
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, FLOAT fRadius, 
                    FLOAT fRotationSpeed, DWORD dwNumTeeth,
                    FLOAT fRotationOffset );
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice );
};




#endif // GEARMODEL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpEarth\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpEarth\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\billboard\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 8UL

#define resource_SkyBoxXN_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxYN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxZN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_Tree02s_OFFSET 120UL
#define resource_Hillside_OFFSET 140UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpEarth\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpEarth\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpLens\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpLens\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpLens\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpEarth\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 4UL

#define resource_Block_OFFSET 0UL
#define resource_Earth_OFFSET 20UL
#define resource_EarthBump_OFFSET 40UL
#define resource_EarthEnvMap_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpEarth\BumpEarth.cpp ===
//-----------------------------------------------------------------------------
// File: BumpEarth.cpp
//
// Desc: Direct3D environment mapping / bump mapping sample. The technique
//       used perturbs the environment map to simulate bump mapping.
//
// Hist: 03.28.00 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle bumpmap" },
    { XBHELP_B_BUTTON,     XBHELP_PLACEMENT_1, L"Toggle texture" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Block.bmp",       resource_Block_OFFSET },
    { "Earth.bmp",       resource_Earth_OFFSET },
    { "EarthBump.bmp",   resource_EarthBump_OFFSET },
    { "EarthEnvMap.bmp", resource_EarthEnvMap_OFFSET },
    { NULL, 0 },
};


   

//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
struct BUMPVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};

#define D3DFVF_BUMPVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;       // Packed resources for the app
    CXBFont            m_Font;              // Font class
    CXBHelp            m_Help;              // Help class
    BOOL               m_bDrawHelp;         // Whether to draw help

    LPDIRECT3DTEXTURE8 m_pBlockTexture;     // A blank, gray texture
    LPDIRECT3DTEXTURE8 m_pEarthTexture;     // The Earth texture
    LPDIRECT3DTEXTURE8 m_pEnvMapTexture;    // The environment map
    LPDIRECT3DTEXTURE8 m_pEarthBumpTexture; // Source for the bumpmap
    LPDIRECT3DTEXTURE8 m_psBumpMap;         // The actual bumpmap

    D3DFORMAT          m_BumpMapFormat;         // Bumpmap texture format
    LPDIRECT3DVERTEXBUFFER8 m_pEarthVB;    // Geometry for the Earth
    DWORD              m_dwNumSphereVertices;

    BOOL               m_bTextureOn;
    BOOL               m_bBumpMapOn;
    BOOL               m_bEnvMapOn;

    DWORD              m_dwBumpPixelShader;  // Bumpenvmap pixel shader

    HRESULT InitBumpMap();
    HRESULT InitPixelShader();
    HRESULT CreateEarthVertexBuffer();

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize members
    m_bDrawHelp         = FALSE;
    m_psBumpMap         = NULL;
    m_bTextureOn        = TRUE;
    m_bBumpMapOn        = TRUE;
    m_bEnvMapOn         = TRUE;

    m_pBlockTexture     = NULL;
    m_pEarthTexture     = NULL;
    m_pEarthBumpTexture = NULL;
    m_pEnvMapTexture    = NULL;

    m_BumpMapFormat     = D3DFMT_L6V5U5;

    m_pEarthVB          = NULL;
}




//-----------------------------------------------------------------------------
// Name: InitPixelShader()
// Desc: Initialize and create our pixel shader
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitPixelShader()
{
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );

    //---------------------------------------------------------------------------
    //  Texture configuration - The following members of the D3DPixelShaderDef   
    //  structure define the addressing modes of each of the four texture stages 
    //---------------------------------------------------------------------------
    psd.PSTextureModes = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D,
                                          PS_TEXTUREMODES_PROJECT2D,
                                          PS_TEXTUREMODES_BUMPENVMAP_LUM,
                                          PS_TEXTUREMODES_NONE );

    psd.PSDotMapping   = PS_DOTMAPPING( 0, 0, 0, 0 );
    psd.PSInputTexture = PS_INPUTTEXTURE( 0, 0, 1, 0 );
    psd.PSCompareMode  = PS_COMPAREMODE( 0, 0, 0, 0 );

    //---------------------------------------------------------------------------------
    //  Color combiners - The following members of the D3DPixelShaderDef structure     
    //  define the state for the eight stages of color combiners                       
    //---------------------------------------------------------------------------------
    psd.PSCombinerCount = PS_COMBINERCOUNT(
        1,
        PS_COMBINERCOUNT_MUX_LSB | PS_COMBINERCOUNT_SAME_C0 | PS_COMBINERCOUNT_SAME_C1);

    psd.PSRGBInputs[0] = PS_COMBINERINPUTS(
        PS_REGISTER_T0  | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_ONE | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_T2  | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_ONE | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB );

    psd.PSAlphaInputs[0] = PS_COMBINERINPUTS(
        PS_REGISTER_ONE | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
        PS_REGISTER_ONE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO);

    psd.PSRGBOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_REGISTER_R0,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY);
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY);

    // AB + (1-A)C + D
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_ZERO);

    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO,
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
        PS_FINALCOMBINERSETTING_CLAMP_SUM);

    return m_pd3dDevice->CreatePixelShader( &psd, &m_dwBumpPixelShader );
}




//-----------------------------------------------------------------------------
// Name: InitBumpMap()
// Desc: Copies raw bits into the format of bump map requested
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitBumpMap()
{
    // Allocate src and dst bits
    D3DSURFACE_DESC desc;
    m_pEarthBumpTexture->GetLevelDesc( 0, &desc );
    VOID* pSrcBits = new DWORD[desc.Width*desc.Height];
    VOID* pDstBits;

    if( 2 == XGBytesPerPixelFromFormat(m_BumpMapFormat) )
        pDstBits = new WORD[desc.Width*desc.Height];
    else
        pDstBits = new DWORD[desc.Width*desc.Height];

    // Get the unswizzled src bits
    D3DLOCKED_RECT lock;
    m_pEarthBumpTexture->LockRect( 0, &lock, 0, 0 );
    XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL, pSrcBits, lock.Pitch, NULL, 4 );
    m_pEarthBumpTexture->UnlockRect(0);

    BYTE* pDstT  = (BYTE*)pDstBits;
    BYTE* pSrcB0 = (BYTE*)pSrcBits;
    BYTE* pSrcB1 = ( pSrcB0 + lock.Pitch );
    BYTE* pSrcB2 = ( pSrcB0 - lock.Pitch );

    for( DWORD y=0; y<desc.Height; y++ )
    {
        if( y == desc.Height-1 )  // Don't go past the last line
            pSrcB1 = pSrcB0;
        if( y == 0 )               // Don't go before first line
            pSrcB2 = pSrcB0;

        for( DWORD x=0; x<desc.Width; x++ )
        {
            LONG v00 = *(pSrcB0+0); // Get the current pixel
            LONG v01 = *(pSrcB0+4); // and the pixel to the right
            LONG vM1 = *(pSrcB0-4); // and the pixel to the left
            LONG v10 = *(pSrcB1+0); // and the pixel one line below.
            LONG v1M = *(pSrcB2+0); // and the pixel one line above.

            LONG iDu = (vM1-v01); // The delta-u bump value
            LONG iDv = (v1M-v10); // The delta-v bump value

            if( (v00 < vM1) && (v00 < v01) )  // If we are at valley
            {
                iDu = vM1-v00;                 // Choose greater of 1st order diffs
                if( iDu < v00-v01 )
                    iDu = v00-v01;
            }

            // The luminance bump value (land masses are less shiny)
            WORD uL = ( v00>1 ) ? 63 : 127;

            switch( m_BumpMapFormat )
            {
                case D3DFMT_V8U8:
                    *pDstT++ = (BYTE)iDu;
                    *pDstT++ = (BYTE)iDv;
                    break;

                case D3DFMT_L6V5U5:
                    *(WORD*)pDstT  = (WORD)( ( (iDu>>3) & 0x1f ) <<  0 );
                    *(WORD*)pDstT |= (WORD)( ( (iDv>>3) & 0x1f ) <<  5 );
                    *(WORD*)pDstT |= (WORD)( ( ( uL>>2) & 0x3f ) << 10 );
                    pDstT += 2;
                    break;

                case D3DFMT_X8L8V8U8:
                    *pDstT++ = (BYTE)iDu;
                    *pDstT++ = (BYTE)iDv;
                    *pDstT++ = (BYTE)uL;
                    *pDstT++ = (BYTE)0L;
                    break;
            }

            // Move one pixel to the left (src is 32-bpp)
            pSrcB0+=4;   
            pSrcB1+=4;   
            pSrcB2+=4;
        }
    }

    // Create the bumpmap's surface and texture objects
    if( FAILED( m_pd3dDevice->CreateTexture( desc.Width, desc.Height, 1, 0, 
                                             m_BumpMapFormat, D3DPOOL_MANAGED, 
                                             &m_psBumpMap ) ) )
        return E_FAIL;

    m_psBumpMap->LockRect( 0, &lock, 0, 0 );
    XGSwizzleRect( pDstBits, lock.Pitch, NULL, lock.pBits, desc.Width, desc.Height, 
                   NULL, XGBytesPerPixelFromFormat(m_BumpMapFormat) );
    m_psBumpMap->UnlockRect(0);

    delete pSrcBits;
    delete pDstBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateEarthVertexBuffer()
// Desc: Sets up the vertices for a bump-mapped sphere.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateEarthVertexBuffer()
{
    DWORD dwNumSphereRings    = 15;
    DWORD dwNumSphereSegments = 30;
    m_dwNumSphereVertices = 2 * dwNumSphereRings * (dwNumSphereSegments+1);

    // Create the vertex buffer
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( m_dwNumSphereVertices*sizeof(BUMPVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_BUMPVERTEX,
                                                  D3DPOOL_MANAGED, &m_pEarthVB ) ) )
        return E_FAIL;

    // Lock the vertex buffer
    BUMPVERTEX* vtx;
    m_pEarthVB->Lock( 0, 0, (BYTE**)&vtx, 0 );

    // Establish constants used in sphere generation
    FLOAT fDeltaRingAngle = ( D3DX_PI / dwNumSphereRings );
    FLOAT fDeltaSegAngle  = ( 2.0f * D3DX_PI / dwNumSphereSegments );

    // Generate the group of rings for the sphere
    for( DWORD ring = 0; ring < dwNumSphereRings; ring++ )
    {
        FLOAT r0 = sinf( (ring+0) * fDeltaRingAngle );
        FLOAT r1 = sinf( (ring+1) * fDeltaRingAngle );
        FLOAT y0 = cosf( (ring+0) * fDeltaRingAngle );
        FLOAT y1 = cosf( (ring+1) * fDeltaRingAngle );

        // Generate the group of segments for the current ring
        for( DWORD seg = 0; seg < (dwNumSphereSegments+1); seg++ )
        {
            FLOAT x0 = sinf( seg * fDeltaSegAngle );
            FLOAT z0 = cosf( seg * fDeltaSegAngle );
            FLOAT x1 = sinf( seg * fDeltaSegAngle );
            FLOAT z1 = cosf( seg * fDeltaSegAngle );

            // Add two vertices to the strip which makes up the sphere
            // (using the transformed normal to generate texture coords)
            (*vtx).p  = D3DXVECTOR3(r0*x0,y0,r0*z0);
            (*vtx).n  = D3DXVECTOR3(x0,y0,z0);
            (*vtx).tu = -((FLOAT)seg)/dwNumSphereSegments;
            (*vtx).tv = (ring+0)/(FLOAT)dwNumSphereRings;
            vtx++;

            (*vtx).p  = D3DXVECTOR3(r1*x1,y1,r1*z1);
            (*vtx).n  = D3DXVECTOR3(x1,y1,z1);
            (*vtx).tu = -((FLOAT)seg)/dwNumSphereSegments;
            (*vtx).tv = (ring+1)/(FLOAT)dwNumSphereRings;
            vtx++;
        }
    }

    m_pEarthVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the file-based textures
    m_pBlockTexture     = m_xprResource.GetTexture( "Block.bmp" );
    m_pEarthTexture     = m_xprResource.GetTexture( "Earth.bmp" );
    m_pEarthBumpTexture = m_xprResource.GetTexture( "EarthBump.bmp" );
    m_pEnvMapTexture    = m_xprResource.GetTexture( "EarthEnvMap.bmp" );

    // Initialize earth geometry
    if( FAILED( CreateEarthVertexBuffer() ) )
        return E_FAIL;

    // Create and fill the bumpmap
    if( FAILED( InitBumpMap() ) )
        return E_FAIL;

    // Create the pixel shader
    if( FAILED( InitPixelShader() ) )
        return E_FAIL;

    // Set the view matrix
    D3DXMATRIX  matView;
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 1.0f,-4.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 640.0f/480.0f, 0.1f, 25.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Animates the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle options
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] ) 
    {
        m_bBumpMapOn    = !m_bBumpMapOn;
        m_bEnvMapOn     = !m_bEnvMapOn;
    }

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ) 
    {
        m_bTextureOn  = !m_bTextureOn;
    }

    // Update the Earth's rotation angle
    D3DXMATRIX matWorld;
    D3DXMatrixRotationY( &matWorld, -m_fAppTime );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Set default state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

    // Set the textures
    m_pd3dDevice->SetTexture( 0, m_bTextureOn ? m_pEarthTexture  : m_pBlockTexture );
    m_pd3dDevice->SetTexture( 1, m_bBumpMapOn ? m_psBumpMap      : m_pBlockTexture );
    m_pd3dDevice->SetTexture( 2, m_bEnvMapOn  ? m_pEnvMapTexture : m_pBlockTexture );

    // The base texture (stage 0) and bumpmap (stage 1) both use the model's
    // texture coordinates
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, 0 );

    // Generate spheremapping coords for the environment map on stage 2
    D3DXMATRIX mat;
    mat._11 = 0.5f;   mat._12 = 0.0f;
    mat._21 = 0.0f;   mat._22 =-0.5f;
    mat._31 = 0.0f;   mat._32 = 0.0f;
    mat._41 = 0.5f;   mat._42 = 0.5f;
    m_pd3dDevice->SetTransform( D3DTS_TEXTURE2, &mat );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACENORMAL );

    // Enable filtering. It's important not to filter the bumpmap, though,
    // since + and - values would filter incorrectly.
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

    // Set the bumpenvmap matrix and luminance scale values
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_BUMPENVMAT00,   FtoDW(0.5f) );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_BUMPENVMAT01,   FtoDW(0.0f) );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_BUMPENVMAT10,   FtoDW(0.0f) );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_BUMPENVMAT11,   FtoDW(0.5f) );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_BUMPENVLSCALE,  FtoDW(4.0f) );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_BUMPENVLOFFSET, FtoDW(0.0f) );

    // Finally, draw the bumpmapped Earth
    m_pd3dDevice->SetStreamSource( 0, m_pEarthVB, sizeof(BUMPVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_BUMPVERTEX );
    m_pd3dDevice->SetPixelShader( m_dwBumpPixelShader );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, m_dwNumSphereVertices-2 );

    // Restore state
    m_pd3dDevice->SetPixelShader( NULL );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        // Show title, frame rate, and help
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"BumpEarth" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        // Output description of what's being displayed
        m_Font.DrawText( 64,  95, 0xffffff00, m_bTextureOn ? L"Texture ON" : L"Texture OFF" );
        m_Font.DrawText( 64, 120, 0xffffff00, m_bBumpMapOn ? L"Bumpmap ON" : L"Bumpmap OFF" );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpEarth\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 4UL

#define resource_Block_OFFSET 0UL
#define resource_Earth_OFFSET 20UL
#define resource_EarthBump_OFFSET 40UL
#define resource_EarthEnvMap_OFFSET 60UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\dotproduct3\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\dotproduct3\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\dotproduct3\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpLens\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Lake_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpLens\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 1UL

#define resource_Lake_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\dotproduct3\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\dotproduct3\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\dotproduct3\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Wood_OFFSET 0UL
#define resource_FaceNormalMap_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\dotproduct3\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 2UL

#define resource_Wood_OFFSET 0UL
#define resource_FaceNormalMap_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\dotproduct3\dotproduct3.cpp ===
//-----------------------------------------------------------------------------
// File: DotProduct3.cpp
//
// Desc: D3D sample showing how to do bumpmapping using the DotProduct3 
//       texture operation.
// 
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.12.01 - Added Xfest art changes for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Wood.bmp",          resource_Wood_OFFSET },
    { "FaceNormalMap.bmp", resource_FaceNormalMap_OFFSET },
    { NULL, 0 },
};


   

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move light" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Switch normal\nmap" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_1, L"Show normal map" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS 4




//-----------------------------------------------------------------------------
// Name: struct CUSTOMVERTEX
// Desc: 
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 p;
    DWORD       diffuse;
    DWORD       specular;
    FLOAT       tu, tv;
};

#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_SPECULAR|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;      // Packed resources for the app
    CXBFont            m_Font;             // Font class
    CXBHelp            m_Help;             // Help class
    BOOL               m_bDrawHelp;        // Whether to draw help

    CUSTOMVERTEX       m_QuadVertices[4];
    LPDIRECT3DTEXTURE8 m_pCustomNormalMap;
    LPDIRECT3DTEXTURE8 m_pFileBasedNormalMap;
    LPDIRECT3DTEXTURE8 m_pWoodTexture;
    D3DXVECTOR3        m_vLight;

    BOOL               m_bUseFileBasedTexture;
    BOOL               m_bShowNormalMap;

    HRESULT CreateCustomNormalMap();

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: InitVertex()
// Desc: Initializes a vertex
//-----------------------------------------------------------------------------
VOID InitVertex( CUSTOMVERTEX* vtx, FLOAT x, FLOAT y, FLOAT z, FLOAT tu, FLOAT tv )
{
    D3DXVECTOR3 p(1,1,1);
    D3DXVec3Normalize( &p, &p );
    vtx[0].p        = D3DXVECTOR3( x, y, z );
    vtx[0].diffuse  = XBUtil_VectorToRGBA( &p, 1.0f );
    vtx[0].specular = 0x40400000;
    vtx[0].tu       = tu;
    vtx[0].tv       = tv;
}
    



//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp            = FALSE;
    m_bUseFileBasedTexture = TRUE;
    m_bShowNormalMap       = FALSE;

    m_pCustomNormalMap     = NULL;
    m_pFileBasedNormalMap  = NULL;
    m_pWoodTexture         = NULL;

    InitVertex( &m_QuadVertices[0],-1.0f,-1.0f,-1.0f, 1.0f, 1.0f );
    InitVertex( &m_QuadVertices[1], 1.0f,-1.0f,-1.0f, 0.0f, 1.0f );
    InitVertex( &m_QuadVertices[2],-1.0f, 1.0f,-1.0f, 1.0f, 0.0f );
    InitVertex( &m_QuadVertices[3], 1.0f, 1.0f,-1.0f, 0.0f, 0.0f );

    m_vLight = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
}




//-----------------------------------------------------------------------------
// Name: CreateCustomNormalMap()
// Desc: Creates a custom normal map
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateCustomNormalMap()
{
    DWORD   dwWidth  = 512;
    DWORD   dwHeight = 512;
    HRESULT hr;

    // Create a 32-bit texture for the custom normal map
    hr = m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0, 
                                      D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, 
                                      &m_pCustomNormalMap );
    if( FAILED(hr) )
        return hr;

    // Lock the texture to fill it with our custom image
    D3DSURFACE_DESC desc;
    D3DLOCKED_RECT lock;
    m_pCustomNormalMap->GetLevelDesc( 0, &desc );
    m_pCustomNormalMap->LockRect( 0, &lock, 0, 0L );
    XBUtil_UnswizzleTexture2D( &lock, &desc );
    DWORD* pPixel = (DWORD*)lock.pBits;

    // Fill each pixel
    for( DWORD j=0; j<dwHeight; j++  )
    {
        for( DWORD i=0; i<dwWidth; i++ )
        {
            FLOAT xp = ( (5.0f*i) / (dwWidth-1)  );
            FLOAT yp = ( (5.0f*j) / (dwHeight-1) );
            FLOAT x  = 2*(xp-floorf(xp))-1;
            FLOAT y  = 2*(yp-floorf(yp))-1;
            FLOAT z  = sqrtf( 1.0f - x*x - y*y );

            // Make image of raised circle. Outside of circle is gray
            if( (x*x + y*y) <= 1.0f )
            {
                D3DXVECTOR3 vVector( x, y, z );
                *pPixel++ = XBUtil_VectorToRGBA( &vVector, 1.0f );
            }
            else
                *pPixel++ = 0x80808080;
        }
    }

    // Unlock the map and return successful
    XBUtil_SwizzleTexture2D( &lock, &desc );
    m_pCustomNormalMap->UnlockRect(0);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the file-based textures
    m_pFileBasedNormalMap = m_xprResource.GetTexture( "FaceNormalMap.bmp" );
    m_pWoodTexture        = m_xprResource.GetTexture( "Wood.bmp" );

    // Create the custom normal map
    if( FAILED( hr = CreateCustomNormalMap() ) )
        return hr;

    // Set the transform matrices
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f, 2.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMATRIX  matWorld, matView, matProj;
    
    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 500.0f );
    
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Select options
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bUseFileBasedTexture = !m_bUseFileBasedTexture;
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        m_bShowNormalMap = !m_bShowNormalMap;

    // Move the light with the GamePad
    m_vLight.x += m_DefaultGamepad.fX1*0.1f; m_vLight.x *= 0.85f;
    m_vLight.y += m_DefaultGamepad.fY1*0.1f; m_vLight.y *= 0.85f;
    m_vLight.z  = 0.0f;

    if( D3DXVec3Length( &m_vLight ) > 1.0f )
        D3DXVec3Normalize( &m_vLight, &m_vLight );
    else
        m_vLight.z = sqrtf( 1.0f - m_vLight.x*m_vLight.x - m_vLight.y*m_vLight.y );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the render target
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00000000, 1.0f, 0L );

    // Set render states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );

    // Set the textures
    if( m_bUseFileBasedTexture )
        m_pd3dDevice->SetTexture( 0, m_pFileBasedNormalMap );
    else
        m_pd3dDevice->SetTexture( 0, m_pCustomNormalMap );

    // If user wants to view the normal map itself, override the above
    // renderstates and simply show the texture
    if( TRUE == m_bShowNormalMap )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    }
    else
    {
        // Store the light vector, so it can be referenced in D3DTA_TFACTOR
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, XBUtil_VectorToRGBA( &m_vLight, 0.0f ) );

        // Modulate the texture (the normal map) with the light vector (stored
        // above in the texture factor)
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DOTPRODUCT3 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
    }

    // Draw the bumpmapped quad
    m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, m_QuadVertices, 
                                   sizeof(CUSTOMVERTEX) );

    // Blend in the diffuse map
    if( m_bUseFileBasedTexture && FALSE == m_bShowNormalMap )
    {
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_ZERO );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_SRCCOLOR );
        
        m_pd3dDevice->SetTexture( 0, m_pWoodTexture );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );

        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, m_QuadVertices, 
                                       sizeof(CUSTOMVERTEX) );

        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.DrawText(  64, 50, 0xffffffff, L"DotProduct3" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        if( m_bUseFileBasedTexture )
            m_Font.DrawText( 64, 75, 0xffffffff, L"Using file-based normal map" );
        else
            m_Font.DrawText( 64, 75, 0xffffffff, L"Using custom normal map" );
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bumpmapping\BumpLens\BumpLens.cpp ===
//-----------------------------------------------------------------------------
// File: BumpLens.cpp
//
// Desc: Code to simulate a magnifying glass using bumpmapping.
//
// Hist: 03.27.00 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Lake.bmp",    resource_Lake_OFFSET },
    { NULL, 0 },
};


   

//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------
struct BUMPVERTEX          // Vertex type used for bumpmap lens effect
{
    D3DXVECTOR3 p;
    FLOAT       tu, tv;
};

struct BACKGROUNDVERTEX    // Vertex type used for rendering background
{
    D3DXVECTOR4 p;
    FLOAT       tu, tv;
};

#define D3DFVF_BUMPVERTEX       (D3DFVF_XYZ|D3DFVF_TEX1)
#define D3DFVF_BACKGROUNDVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource       m_xprResource;        // Packed resources for the app
    CXBFont                 m_Font;               // Font class

    LPDIRECT3DVERTEXBUFFER8 m_pBackgroundVB;      // Vertices for background
    LPDIRECT3DVERTEXBUFFER8 m_pLensVB;            // Vertices for lens

    FLOAT                   m_fLensX;             // Position of lens
    FLOAT                   m_fLensY;

    LPDIRECT3DTEXTURE8      m_pBumpMapTexture;    // Bumpmap
    LPDIRECT3DTEXTURE8      m_pBackgroundTexture; // Envmap texture

    DWORD                   m_dwBumpPixelShader;  // Bumpenvmap pixel shader

    HRESULT CreateBumpMap( DWORD dwWidth, DWORD dwHeight );
    HRESULT InitPixelShader();

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Initialize members
    m_pBumpMapTexture    = NULL;
    m_pBackgroundTexture = NULL;

    m_pBackgroundVB      = NULL;
    m_pLensVB            = NULL;
}




//-----------------------------------------------------------------------------
// Name: InitPixelShader()
// Desc: Initialize and create our pixel shader
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::InitPixelShader()
{
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );

    //---------------------------------------------------------------------------
    //  Texture configuration - The following members of the D3DPixelShaderDef   
    //  structure define the addressing modes of each of the four texture stages 
    //---------------------------------------------------------------------------
    psd.PSTextureModes = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D,
                                          PS_TEXTUREMODES_BUMPENVMAP,
                                          PS_TEXTUREMODES_NONE,
                                          PS_TEXTUREMODES_NONE );

    psd.PSDotMapping   = PS_DOTMAPPING( 0, 0, 0, 0 );
    psd.PSInputTexture = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSCompareMode  = PS_COMPAREMODE( 0, 0, 0, 0 );

    //---------------------------------------------------------------------------------
    //  Color combiners - The following members of the D3DPixelShaderDef structure     
    //  define the state for the eight stages of color combiners                       
    //---------------------------------------------------------------------------------
    psd.PSCombinerCount = PS_COMBINERCOUNT(
        1,
        PS_COMBINERCOUNT_MUX_LSB | PS_COMBINERCOUNT_SAME_C0 | PS_COMBINERCOUNT_SAME_C1);

    psd.PSRGBInputs[0] = PS_COMBINERINPUTS(
        PS_REGISTER_T1 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_ONE,
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO);

    psd.PSAlphaInputs[0] = PS_COMBINERINPUTS(
        PS_REGISTER_ONE | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
        PS_REGISTER_ONE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO);

    psd.PSRGBOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY);
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY);

    // AB + (1-A)C + D
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_RGB,
        PS_REGISTER_ZERO);

    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
        PS_REGISTER_ZERO,
        PS_REGISTER_ZERO,
        PS_REGISTER_R0 | PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_CHANNEL_ALPHA,
        PS_FINALCOMBINERSETTING_CLAMP_SUM);

    return m_pd3dDevice->CreatePixelShader( &psd, &m_dwBumpPixelShader );
}




//-----------------------------------------------------------------------------
// Name: CreateBumpMap()
// Desc: Creates a bumpmap
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateBumpMap( DWORD dwWidth, DWORD dwHeight )
{
    // Create the bump map texture.
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0,
                                             D3DFMT_V8U8, D3DPOOL_MANAGED,
                                             &m_pBumpMapTexture ) ) )
        return NULL;

    // Lock the surface and write in some bumps for the waves
    DWORD* pBits    = new DWORD[dwWidth*dwHeight];
    WORD*  pPixel16 = (WORD*)pBits;
    CHAR*  pPixel8  = (CHAR*)pBits;
    DWORD  mid      = dwWidth/2;

    for( DWORD y0 = 0; y0 < dwHeight; y0++ )
    {
        for( DWORD x0 = 0; x0 < dwWidth; x0++ )
        {
            DWORD x1 = ( (x0==dwWidth-1)  ? x0 : x0+1 );
            DWORD y1 = ( (x0==dwHeight-1) ? y0 : y0+1 );

            FLOAT fDistSq00 = (FLOAT)( (x0-mid)*(x0-mid) + (y0-mid)*(y0-mid) );
            FLOAT fDistSq01 = (FLOAT)( (x1-mid)*(x1-mid) + (y0-mid)*(y0-mid) );
            FLOAT fDistSq10 = (FLOAT)( (x0-mid)*(x0-mid) + (y1-mid)*(y1-mid) );

            FLOAT v00 = ( fDistSq00 > (mid*mid) ) ? 0.0f : sqrtf( (mid*mid) - fDistSq00 );
            FLOAT v01 = ( fDistSq01 > (mid*mid) ) ? 0.0f : sqrtf( (mid*mid) - fDistSq01 );
            FLOAT v10 = ( fDistSq10 > (mid*mid) ) ? 0.0f : sqrtf( (mid*mid) - fDistSq10 );

            FLOAT fDu = +(127/D3DX_PI)*atanf(v00-v01); // The delta-u bump value
            FLOAT fDv = -(127/D3DX_PI)*atanf(v00-v10); // The delta-v bump value

            BYTE du = (BYTE)( fDu >= 0.0f ? fDu : 256 + fDu );
            BYTE dv = (BYTE)( fDv >= 0.0f ? fDv : 256 + fDv );

            *pPixel16++ = (0xff00&(dv<<8)) | (0x00ff&(du<<0));

        }
    }

    D3DLOCKED_RECT lock;
    m_pBumpMapTexture->LockRect( 0, &lock, 0, 0 );
    XGSwizzleRect( pBits, lock.Pitch, NULL, lock.pBits, dwWidth, dwHeight, NULL, 2 );
    m_pBumpMapTexture->UnlockRect(0);

    delete pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the texture for the background image
    m_pBackgroundTexture = m_xprResource.GetTexture( "Lake.bmp" );

    // Create the bump map texture
    if( FAILED( CreateBumpMap( 256, 256 ) ) )
        return E_FAIL;

    // Create the pixel shader
    if( FAILED( InitPixelShader() ) )
        return E_FAIL;

    // Create a square for rendering the background
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4*sizeof(BACKGROUNDVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_BACKGROUNDVERTEX,
                                                  D3DPOOL_MANAGED, &m_pBackgroundVB ) ) )
        return E_FAIL;

    BACKGROUNDVERTEX* vBackground;
    m_pBackgroundVB->Lock( 0, 0, (BYTE**)&vBackground, 0 );
    vBackground[0].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 0.9f, 1.0f );
    vBackground[1].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 0.9f, 1.0f );
    vBackground[2].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 0.9f, 1.0f );
    vBackground[3].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 0.9f, 1.0f );
    vBackground[0].tu = 0.0f; vBackground[0].tv = 0.0f;
    vBackground[1].tu = 1.0f; vBackground[1].tv = 0.0f;
    vBackground[2].tu = 1.0f; vBackground[2].tv = 1.0f;
    vBackground[3].tu = 0.0f; vBackground[3].tv = 1.0f;
    m_pBackgroundVB->Unlock();

    // Create a square for rendering the lens
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( 4*sizeof(BUMPVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_BUMPVERTEX,
                                                  D3DPOOL_MANAGED, &m_pLensVB ) ) )
        return E_FAIL;

    BUMPVERTEX* vLens;
    m_pLensVB->Lock( 0, 0, (BYTE**)&vLens, 0 );
    vLens[0].p = D3DXVECTOR3(-256.0f, 256.0f, 0.0f );
    vLens[1].p = D3DXVECTOR3( 256.0f, 256.0f, 0.0f );
    vLens[2].p = D3DXVECTOR3( 256.0f,-256.0f, 0.0f );
    vLens[3].p = D3DXVECTOR3(-256.0f,-256.0f, 0.0f );
    vLens[0].tu = 0.0f; vLens[0].tv = 1.0f;
    vLens[1].tu = 1.0f; vLens[1].tv = 1.0f;
    vLens[2].tu = 1.0f; vLens[2].tv = 0.0f;
    vLens[3].tu = 0.0f; vLens[3].tv = 0.0f;
    m_pLensVB->Unlock();

    // Set the transform matrices
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f, -2000.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f,     0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f,     0.0f );
    D3DXMATRIX matWorld, matView, matProj;

    D3DXMatrixIdentity( &matWorld );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 3000.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Bounce the lens about the screen
    m_fLensX = 2 * fabsf( 2 * ( (m_fAppTime/2) - floorf(m_fAppTime/2) ) - 1 ) - 1;
    m_fLensY = 2 * fabsf( sinf( m_fAppTime ) ) - 1;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // This sample does not use the zbuffer or alpha
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );

    // Render the background
    m_pd3dDevice->SetTexture( 0, m_pBackgroundTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetVertexShader( D3DFVF_BACKGROUNDVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pBackgroundVB, sizeof(BACKGROUNDVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );

    // Set states to render the lens
    m_pd3dDevice->SetTexture( 0, m_pBumpMapTexture );
    m_pd3dDevice->SetTexture( 1, m_pBackgroundTexture );
    m_pd3dDevice->SetPixelShader( m_dwBumpPixelShader );

    // Don't filer the bumpamp, otherwise, adjacent values of 0x00 and 0xff will
    // filter to some bogus intermediate value
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );

    // It is okay to filter the envmap, though
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    // Clamp the envmap, so we don't bump past it's edge.
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,   D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,   D3DTADDRESS_CLAMP );

    // Set the bumpenv matrix, which scales and rotates the bumpmap. Here we
    // are just scaling the bumpmap down to produce reasonable bumps. (Since
    // the du and dv values in the bumpmap range from -1 to +1, this scale
    // keeps the max texture shifts in the range of -0.2 to +0.2.)
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_BUMPENVMAT00, FtoDW(0.2f) );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_BUMPENVMAT01, FtoDW(0.0f) );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_BUMPENVMAT10, FtoDW(0.0f) );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_BUMPENVMAT11, FtoDW(0.2f) );

    // Generate texture coords depending on the lens' camera space position
    D3DXMATRIX mat;
    mat._11 = 0.5f; mat._12 = 0.0f;
    mat._21 = 0.0f; mat._22 =-0.5f;
    mat._31 = 0.0f; mat._32 = 0.0f;
    mat._41 = 0.5f; mat._42 = 0.5f;

    // Since the bumpenvmap texaddrop does not deal with projected textures,
    // we scale-by-z here in the texture transform
    D3DXMATRIX matView, matProj;
    m_pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
    D3DXVECTOR3 vEyePt( matView._41, matView._42, matView._43 );
    FLOAT       z = D3DXVec3Length( &vEyePt );
    mat._11 *= ( matProj._11 / ( matProj._33 * z + matProj._34 ) );
    mat._22 *= ( matProj._22 / ( matProj._33 * z + matProj._34 ) );
    
    m_pd3dDevice->SetTransform( D3DTS_TEXTURE1, &mat );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION | 0 );

    // Position the lens
    D3DXMATRIX matWorld;
    D3DXMatrixTranslation( &matWorld, 0.7f * (1000.0f-256.0f)*m_fLensX,
                                      0.7f * (1000.0f-256.0f)*m_fLensY,
                                      0.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Finally, render the bumpmap lens thingie
    m_pd3dDevice->SetVertexShader( D3DFVF_BUMPVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pLensVB, sizeof(BUMPVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );

    // Restore state
    m_pd3dDevice->SetPixelShader( NULL );

    // Show title, frame rate, and help
    m_Font.Begin();
    m_Font.DrawText(  64, 50, 0xffffffff, L"BumpLens" );
    m_Font.DrawText( 450, 50, 0xff808000, m_strFrameRate );
    m_Font.End();
    
    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\bunny.cpp ===
//-----------------------------------------------------------------------------
// File: teddy.cpp
//
// Desc: This is the main file for the teddy demo, which illustrates using
//		 vertex shaders for shell expansion, lighting, and wind.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBUtil.h>
#include <XBHelp.h>
#include <XBSound.h>
#include "xpath.h"
#include "xobj.h"
#include "xfpatch.h"
#include "xfpmesh.h"
#include "util.h"

bool	g_bDrawNormals = false;
bool    g_bDrawTexCoordFrames = false;

bool	g_bDrawFins = true;
bool	g_bDrawShells = true;
bool    g_bMultiShell = false;	// If set, draw multiple shells at once, using the vertex shader to compute the projected offsets.

bool	g_bWind = false;
bool	g_bLocalLighting = true;
bool	g_bSelfShadow = true;

D3DXVECTOR3 g_vLookAt;

D3DXVECTOR4 g_vWind1;
D3DXVECTOR4 g_vWind2;
D3DXVECTOR4 g_vWind3;
float g_fWindChoose;

// help screen definitions
XBHELP_CALLOUT g_NormalHelpCallouts[] =
{
    { XBHELP_LEFTSTICK, XBHELP_PLACEMENT_1, L"Rotate/Zoom the model"},
    { XBHELP_RIGHTSTICK, XBHELP_PLACEMENT_2, L"Rotate the model\nand light source"},
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_2, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Debug lighting mode" },
    { XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_1, L"Right trigger to use blower" },
};
#define MAX_NORMAL_HELP_CALLOUTS (sizeof(g_NormalHelpCallouts)/sizeof(XBHELP_CALLOUT))

XBHELP_CALLOUT g_LightingHelpCallouts[] =
{
    { XBHELP_LEFTSTICK, XBHELP_PLACEMENT_1, L"Rotate/Zoom the model"},
    { XBHELP_RIGHTSTICK, XBHELP_PLACEMENT_2, L"Rotate the model\nand light source"},
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_2, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Debug shell mode" },
    { XBHELP_X_BUTTON, XBHELP_PLACEMENT_1, L"+ TexOP1" },
    { XBHELP_Y_BUTTON, XBHELP_PLACEMENT_1, L"- TexOP1" },
    { XBHELP_A_BUTTON, XBHELP_PLACEMENT_1, L"+ TexOP2" },
    { XBHELP_B_BUTTON, XBHELP_PLACEMENT_1, L"- TexOP2" },
	{ XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Toggle\nNormals" },
    { XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_1, L"Toggle\nLighting" },
};
#define MAX_LIGHTING_HELP_CALLOUTS (sizeof(g_LightingHelpCallouts)/sizeof(XBHELP_CALLOUT))

XBHELP_CALLOUT g_ShellHelpCallouts[] =
{
    { XBHELP_LEFTSTICK, XBHELP_PLACEMENT_1, L"Rotate/Zoom the model"},
    { XBHELP_RIGHTSTICK, XBHELP_PLACEMENT_2, L"Rotate the model\nand light source"},
    { XBHELP_BACK_BUTTON, XBHELP_PLACEMENT_2, L"Display\nhelp" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Default mode" },
    { XBHELP_X_BUTTON, XBHELP_PLACEMENT_1, L"Toggle shells" },
    { XBHELP_Y_BUTTON, XBHELP_PLACEMENT_1, L"Toggle multishell" },
    { XBHELP_A_BUTTON, XBHELP_PLACEMENT_1, L"Toggle fins" },
    { XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_1, L"Reload" },
	{ XBHELP_BLACK_BUTTON, XBHELP_PLACEMENT_2, L"Toggle\nTextures" },
};
#define MAX_SHELL_HELP_CALLOUTS (sizeof(g_ShellHelpCallouts)/sizeof(XBHELP_CALLOUT))


//-----------------------------------------------------------------------------
// Name: class CXBSound2
// Desc: subclass to allow volume setting
//-----------------------------------------------------------------------------
class CXBSound2 : public CXBSound {
    HRESULT SetVolume( LONG lVolume )
	{
		if( NULL == m_pDSoundBuffer )
			return E_INVALIDARG;
		return m_pDSoundBuffer->SetVolume(lVolume);
	}
};


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
	enum {
		DEFAULT_MODE,	// default mode, with just object and light
		DEBUG_LIGHTING_MODE,		// show lighting coordinates, activate pixel shader controls
		DEBUG_SHELL_MODE
	} m_mode;
	
    CXBFont m_Font;
    CXBHelp m_Help;
	BOOL m_bDrawHelp;
	BOOL m_bShowTextures;
	
	D3DVECTOR m_vViewAngle;
	D3DXVECTOR3	m_vCameraPos;		// camera rest position
	D3DXVECTOR3 m_vEyePos;			// eye position
	D3DXMATRIX m_matProjection;		// projection matrix
	D3DXMATRIX m_matView;			// view matrix
	
	D3DXVECTOR3 m_vLightPos;		// current position of light
	D3DLIGHT8 m_Light0;				// d3d8 light
	float m_fLightAngle;			// direction of light around the model
	CXObject m_LightObj;			// light icon
	
	D3DMATERIAL8 m_Material;
	
	CXObject m_teddy, m_teddyEyes, m_teddyNose;
	CXFPatch m_FPatch;
	CXFPatchMesh m_FPatchMesh;

	BOOL m_dwLoadPhase;
	float m_fLOD;
	
#define VS_CONFIGURATIONS 16	 /* four bits: wind local_lighting self_shadowing multishell */
	DWORD m_adwFurVS[VS_CONFIGURATIONS];
	DWORD m_adwFinVS[VS_CONFIGURATIONS];
	
    // CXBSound2   m_BlowerSound;
public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
	HRESULT Cleanup();

    CXBoxSample();
	HRESULT DrawLightIcon();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
void __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
#ifdef _DEBUG	
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
#endif

	m_bDrawHelp = FALSE;
	m_bShowTextures = FALSE;
	m_dwLoadPhase = 0;
	m_fLOD = 0.9f;
	for (UINT iConfig = 0; iConfig < VS_CONFIGURATIONS; iConfig++)
	{
		m_adwFurVS[iConfig] = 0;
		m_adwFinVS[iConfig] = 0;
	}
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize device-dependant objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;
	m_mode = DEFAULT_MODE;

    // Create a font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

	// initialize the help system
    m_Help.Create( m_pd3dDevice, "Gamepad.xpr" );

    // Set projection transform
	float fFOV = D3DX_PI/4;
    D3DXMatrixPerspectiveFovLH(&m_matProjection, fFOV, 640.0f/480.0f, 0.1f, 10.0f);
    m_pd3dDevice->SetTransform(D3DTS_PROJECTION, &m_matProjection);

	// load the fur and fin shaders
	for (UINT iConfig = 0; iConfig < VS_CONFIGURATIONS; iConfig++)
	{
		int iWind = (iConfig >> 2) & 1;
		int iLocal = (iConfig >> 1) & 1;
		int iSelf = iConfig & 1;
		
		// load the fur vertex shader
		if (iConfig < VS_CONFIGURATIONS / 2)
		{
			DWORD vsdecl[] = 
			{
				D3DVSD_STREAM(0),
				D3DVSD_REG(0, D3DVSDT_FLOAT3),		// vertex
				D3DVSD_REG(1, D3DVSDT_FLOAT3),		// normal
				D3DVSD_REG(2, D3DVSDT_FLOAT2),		// texture 0
				D3DVSD_END()
			};
			CHAR name[_MAX_PATH];
			_snprintf(name, _MAX_PATH, "shaders\\fur_wind%d_local%d_self%d.xvu", iWind, iLocal, iSelf);
			XBUtil_CreateVertexShader(m_pd3dDevice, _FNA(name), vsdecl, &m_adwFurVS[iConfig]);
			if (!m_adwFurVS[iConfig])
			{
				OUTPUT_DEBUG_STRING( "Initialize : error loading \"" );
				OUTPUT_DEBUG_STRING(name);
				OUTPUT_DEBUG_STRING( "\"\n" );
			}
		}
		else
		{
			// Multishell shaders need a coordinate frame at each vertex
			DWORD vsdecl[] = 
			{
				D3DVSD_STREAM(0),
				D3DVSD_REG(0, D3DVSDT_FLOAT3),		// vertex
				D3DVSD_REG(1, D3DVSDT_FLOAT3),		// normal
				D3DVSD_REG(2, D3DVSDT_FLOAT2),		// texture 0
				D3DVSD_STREAM(1),
				D3DVSD_REG(3, D3DVSDT_FLOAT3),		// S texture vector
				D3DVSD_REG(4, D3DVSDT_FLOAT3),		// T texture vector
				D3DVSD_END()
			};
			CHAR name[_MAX_PATH];
			_snprintf(name, _MAX_PATH, "shaders\\fur_wind%d_local%d_self%d_multishell.xvu", iWind, iLocal, iSelf);
			XBUtil_CreateVertexShader(m_pd3dDevice, _FNA(name), vsdecl, &m_adwFurVS[iConfig]);
			if (!m_adwFurVS[iConfig])
			{
				OUTPUT_DEBUG_STRING( "Initialize : error loading \"" );
				OUTPUT_DEBUG_STRING(name);
				OUTPUT_DEBUG_STRING( "\"\n" );
			}
		}
		
		// load the fin vertex shader
		{
			DWORD vsdecl[] = 
			{
				D3DVSD_STREAM(0),				// vertex 1
				D3DVSD_REG(0, D3DVSDT_FLOAT3),		// vertex
				D3DVSD_REG(1, D3DVSDT_FLOAT3),		// normal
				D3DVSD_REG(2, D3DVSDT_FLOAT2),		// u,v
				D3DVSD_STREAM(1),				// vertex 2
				D3DVSD_SKIP(4),	// "half-stride", size(FVFT_XYZNORMTEX1) = (3 + 3 + 2) * sizeof(DWORD), so half size = 4 * sizeof(DWORD)
				D3DVSD_REG(3, D3DVSDT_FLOAT3),		// vertex
				D3DVSD_REG(4, D3DVSDT_FLOAT3),		// normal
				D3DVSD_REG(5, D3DVSDT_FLOAT2),		// u,v
				D3DVSD_STREAM(2),
				D3DVSD_REG(6, D3DVSDT_FLOAT1),	// selector
				D3DVSD_END()
			};
			CHAR name[_MAX_PATH];
			_snprintf(name, _MAX_PATH, "shaders\\fin_wind%d_local%d_self%d.xvu", iWind, iLocal, iSelf);
			XBUtil_CreateVertexShader(m_pd3dDevice, _FNA(name), vsdecl, &m_adwFinVS[iConfig]);
			if (!m_adwFinVS[iConfig])
			{
				OUTPUT_DEBUG_STRING( "Initialize : error loading \"" );
				OUTPUT_DEBUG_STRING(name);
				OUTPUT_DEBUG_STRING( "\"\n" );
			}
		}
	}

	// enable lighting
	m_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0x0);
	m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

	// initalize material
	memset(&m_Material, 0, sizeof(D3DMATERIAL8));
	m_Material.Ambient = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f);
	m_Material.Diffuse = D3DXCOLOR(0.4f*0.85f, 0.4f*0.6f, 0.4f*0.55f, 1.f);
	m_Material.Specular = D3DXCOLOR(0.4f*0.85f, 0.4f*0.6f, 0.4f*0.55f, 1.f);
	m_Material.Power = 16.0f;
	m_pd3dDevice->SetMaterial(&m_Material);

	// init the rest of the stuff
	m_vCameraPos = D3DXVECTOR3(0.f, 0.3f, 2.f);
	m_vLightPos = D3DXVECTOR3(0.f, 0.7f, 0.7f);
	m_fLightAngle = 0.f;
	m_vViewAngle = D3DXVECTOR3(0.f, 0.f, 0.f);

	// init light position and color
	memset(&m_Light0, 0, sizeof(D3DLIGHT8));
	m_Light0.Type = D3DLIGHT_SPOT;
	m_Light0.Position = m_vLightPos;
	D3DXVECTOR3 vLightDir;
	D3DXVec3Normalize(&vLightDir, &m_vLightPos);
	m_Light0.Direction = -vLightDir;
	m_Light0.Diffuse.r = 1.0f;
	m_Light0.Diffuse.g = 1.0f;
	m_Light0.Diffuse.b = 1.0f;
	m_Light0.Specular.r = 1.0f;
	m_Light0.Specular.g = 1.0f;
	m_Light0.Specular.b = 1.0f;
	m_Light0.Range = 1000.0f;
	m_Light0.Attenuation0 = 1.0f;
	m_Light0.Phi = D3DX_PI;
	m_Light0.Theta = D3DX_PI/4.0;
	m_Light0.Falloff = 0.f;
	m_pd3dDevice->LightEnable(0, TRUE);
	m_pd3dDevice->SetLight(0, &m_Light0);

	// light
	float fLength = 0.2f;
	float fRadius0 = 0.01f;
	float fRadius1 = fLength * sinf(m_Light0.Theta);	// inner spotlight radius
	m_LightObj.m_Model = new CXModel;
	m_LightObj.m_Model->Cylinder(fRadius0, 0xc0ffffff, fRadius1, 0x00ffffff, fLength, 40, FVF_XYZDIFF, NULL, 1.0f);

	// set base path to our media directory
	// all the _FNA commands use this
	XPath_SetBasePath(_T("d:\\media\\"));

	// Add a sound for the blower
   // m_BlowerSound.Create( "Sounds\\blower.wav", DSBCAPS_CTRL3D );
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Cleanup()
// Desc: Clean up after ourselves.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Cleanup()
{
    m_Help.Destroy();
	m_Font.Destroy();
	SAFE_RELEASE(m_LightObj.m_Model);
	for (UINT iConfig = 0; iConfig < VS_CONFIGURATIONS; iConfig++)
	{
		if (m_adwFurVS[iConfig])
		{
			m_pd3dDevice->DeleteVertexShader(m_adwFurVS[iConfig]);
			m_adwFurVS[iConfig] = 0;
		}
		if (m_adwFinVS[iConfig])
		{
			m_pd3dDevice->DeleteVertexShader(m_adwFinVS[iConfig]);
			m_adwFinVS[iConfig] = 0;
		}
	}
	// m_BlowerSound.Destroy();
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------

// for pixel shader debugging display
DWORD g_iCOLOROP1 = D3DTOP_MODULATE2X;
DWORD g_iCOLOROP2 = D3DTOP_MODULATE2X;

HRESULT CXBoxSample::FrameMove()
{
	// Get input from the keypad
	m_vViewAngle.y -= m_DefaultGamepad.fX1*1.0f*m_fElapsedTime;
	if(m_vViewAngle.y>D3DX_PI*2)
		m_vViewAngle.y -= D3DX_PI*2;
	if(m_vViewAngle.y<0.0f)
		m_vViewAngle.y += D3DX_PI*2;

	m_vViewAngle.x += m_DefaultGamepad.fY2*1.0f*m_fElapsedTime;
	if(m_vViewAngle.x>1.0f)
		m_vViewAngle.x = 1.0f;
	if(m_vViewAngle.x<-1.0f)
		m_vViewAngle.x = -1.0f;

	m_vCameraPos.z -= m_DefaultGamepad.fY1*0.5f*m_fElapsedTime;
	if(m_vCameraPos.z<0.2f)
		m_vCameraPos.z = 0.2f;

	if (m_mode == DEBUG_LIGHTING_MODE)
	{
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X])
		{
			g_iCOLOROP1++;
			if (g_iCOLOROP1 > D3DTOP_BLENDCURRENTALPHA) g_iCOLOROP1 = D3DTOP_BLENDCURRENTALPHA;
		}
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y])
		{
			g_iCOLOROP1--;
			if (g_iCOLOROP1 < D3DTOP_SELECTARG1) g_iCOLOROP1 = D3DTOP_SELECTARG1;
		}
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
		{
			g_iCOLOROP2++;
			if (g_iCOLOROP2 > D3DTOP_BLENDCURRENTALPHA) g_iCOLOROP2 = D3DTOP_BLENDCURRENTALPHA;
		}
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B])
		{
			g_iCOLOROP2--;
			if (g_iCOLOROP2 < D3DTOP_SELECTARG1) g_iCOLOROP2 = D3DTOP_SELECTARG1;
		}

		// toggle normals and tex coord frames
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
		{
			// three states: none, normals, both normals and tex coord frames
			if (g_bDrawNormals)
			{
				if (!g_bDrawTexCoordFrames)	
					g_bDrawTexCoordFrames = true;
				else
					g_bDrawNormals = g_bDrawTexCoordFrames = false;
			}
			else
				g_bDrawNormals = true;
		}

		// advance lighting mode
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
		{
			UINT iConfig = (g_bLocalLighting ? (1 << 1) : 0) | (g_bSelfShadow ? 1 : 0);
			iConfig++;
			g_bLocalLighting = (iConfig >> 1) & 1;
			g_bSelfShadow = iConfig & 1;
		}

		// toggle mode
	    if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_START)
		    m_mode = DEBUG_SHELL_MODE;
	}
	else if (m_mode == DEBUG_SHELL_MODE)
	{
		// toggle fins
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A])
			g_bDrawFins = !g_bDrawFins;

		// toggle shells
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X])
			g_bDrawShells = !g_bDrawShells;

		// toggle multishell
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y])
			g_bMultiShell = !g_bMultiShell;

		// toggle display of textures
		if(m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
			m_bShowTextures = !m_bShowTextures;

		// toggle mode
	    if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_START)
		    m_mode = DEFAULT_MODE;
	}
	else
	{
		// toggle mode
	    if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_START)
		    m_mode = DEBUG_LIGHTING_MODE;
	}

	// toggle help
    if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
        m_bDrawHelp = !m_bDrawHelp;

	// load the bear in chunks so we dont wait several
	// seconds before the app starts up
	switch(m_dwLoadPhase)
	{
		case 0:
			m_dwLoadPhase++;
			break;

		case 1:
		{
			SAFE_RELEASE(m_teddy.m_Model);
			SAFE_DELETE(m_teddy.m_Material);
			SAFE_RELEASE(m_teddyEyes.m_Model);
			SAFE_DELETE(m_teddyEyes.m_Material);
			SAFE_RELEASE(m_teddyNose.m_Model);
			SAFE_DELETE(m_teddyNose.m_Material);

			// increment through several levels of detail and scales of fur
			struct TeddyModel {
				CHAR *Fur;
				CHAR *Eyes;
				CHAR *Nose;
			} rTeddy[] = {	
				{ "Models\\MBFur_scale10.m",     "Models\\MBEyes.m",     "Models\\MBNose.m" },
				{ "Models\\2000a_Fur_scale10.m", "Models\\2000a_Eyes.m", "Models\\2000a_Nose.m" },
				{ "Models\\1000a_Fur_scale10.m", "Models\\1000a_Eyes.m", "Models\\1000a_Nose.m" },
				{ "Models\\800a_Fur_scale10.m",  "Models\\800a_Eyes.m",  "Models\\800a_Nose.m" },
				{ "Models\\600a_Fur_scale10.m",  "Models\\600a_Eyes.m",  "Models\\600a_Nose.m" },
				{ "Models\\400a_Fur_scale10.m",  "Models\\400a_Eyes.m",  "Models\\400a_Nose.m" },
			};
			static int TeddyModelCount = sizeof(rTeddy) / sizeof(TeddyModel);
			static int iModel = 3;
			iModel++;
			if (iModel >= TeddyModelCount)
				iModel = 0;
			
			// load the teddy model
			CXModel *pModel = new CXModel;
			pModel->Read_M(_FNA(rTeddy[iModel].Fur), NULL, FVF_XYZNORMTEX1, 0, NULL);
			D3DMATERIAL8 *pMaterial = new D3DMATERIAL8;
			ZeroMemory(pMaterial, sizeof(D3DMATERIAL8));
			pMaterial->Ambient = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f);
			pMaterial->Diffuse = D3DXCOLOR(0.7f*0.85f, 0.7f*0.6f, 0.7f*0.45f, 1.f);
			pMaterial->Specular = D3DXCOLOR(0.7f*0.85f, 0.7f*0.6f, 0.7f*0.45f, 1.f);
			pMaterial->Power = 16.0f;
			m_teddy.m_Material = pMaterial;
			m_teddy.SetModel(pModel);

			// Add eyes and nose that are not furry
			{
				CXModel *pModelEyes = new CXModel;
				pModelEyes->Read_M(_FNA(rTeddy[iModel].Eyes), NULL, FVF_XYZNORMTEX1, 0, NULL);
				D3DMATERIAL8 *pMaterialEyes = new D3DMATERIAL8;
				ZeroMemory(pMaterialEyes, sizeof(D3DMATERIAL8));
				pMaterialEyes->Ambient  = D3DXCOLOR(0.f, 0.f, 0.f, 1.f);
				pMaterialEyes->Diffuse  = D3DXCOLOR(0.1f, 0.1f, 0.1f, 1.f);
				pMaterialEyes->Specular = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
				pMaterialEyes->Power = 40.0f;
				m_teddyEyes.m_Material = pMaterialEyes;
				m_teddyEyes.SetModel(pModelEyes);
				pModelEyes->Release();
			}
			{
				CXModel *pModelNose = new CXModel;
				pModelNose->Read_M(_FNA(rTeddy[iModel].Nose), NULL, FVF_XYZNORMTEX1, 0, NULL);
				D3DMATERIAL8 *pMaterialNose = new D3DMATERIAL8;
				ZeroMemory(pMaterialNose, sizeof(D3DMATERIAL8));
				pMaterialNose->Ambient = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f);
				pMaterialNose->Diffuse = D3DXCOLOR(0.7f*0.85f, 0.7f*0.6f, 0.7f*0.45f, 1.f);
				pMaterialNose->Specular = D3DXCOLOR(0.7f*0.85f, 0.7f*0.6f, 0.7f*0.45f, 1.f);
				pMaterialNose->Power = 16.0f;
				m_teddyNose.m_Material = pMaterialNose;
				m_teddyNose.SetModel(pModelNose);
				pModelNose->Release();
			}

			// calc bounding sphere
			BYTE *bptr;
			pModel->LockVB(&bptr, 0L);
			D3DXVECTOR3 vCenter;
			float fRadius;
			ComputeBoundingSphere(bptr, pModel->m_dwNumVertices, pModel->m_dwFVF, &vCenter, &fRadius);
			pModel->UnlockVB();
			pModel->Release();
			static D3DXVECTOR3 vCenterOffset(0.f, 0.15f, 0.f);	// move object down, slightly, by moving center of view up
			g_vLookAt = vCenter + vCenterOffset;
			m_dwLoadPhase++;
			break;
		}

		case 2:
			// copy patch mesh from input model and generate hair
			m_FPatchMesh.Initialize(&m_teddy, NULL, -1);
			m_FPatchMesh.ExtractFins();
			DWORD numfuzz = 8000;
			DWORD numfuzzlib = 32;
			DWORD numlayers = 12; // 16;
			DWORD volxsize = 128;
			DWORD volzsize = 128;
			m_FPatch.m_fXSize = 0.1f;
			m_FPatch.m_fYSize = 0.01f;
			m_FPatch.m_fZSize = 0.1f;
			m_FPatch.m_dwNumSegments	= 4;
			m_FPatch.m_fuzzRandom.colorBase = D3DXCOLOR(0.1f, 0.05f, 0.01f, 0.1f);
			m_FPatch.m_fuzzCenter.colorBase = D3DXCOLOR(0.501961f, 0.250980f, 0.1f, 1.f) - m_FPatch.m_fuzzRandom.colorBase;
			m_FPatch.m_fuzzRandom.colorTip = D3DXCOLOR(0.1f, 0.05f, 0.1f, 0.25f);
			m_FPatch.m_fuzzCenter.colorTip = D3DXCOLOR(0.8f, 0.7f, 0.5f, 0.5f) - m_FPatch.m_fuzzRandom.colorTip;
			m_FPatch.m_fuzzCenter.dp = D3DXVECTOR3(0.0f, 4.f, 0.5f);
			m_FPatch.m_fuzzRandom.dp = D3DXVECTOR3(0.25f, 0.25f, 0.25f);
			m_FPatch.m_fuzzCenter.ddp = D3DXVECTOR3(0.f, 0.f, 0.0f);
			m_FPatch.m_fuzzRandom.ddp = D3DXVECTOR3(0.5f, 0.5f, 0.5f);
			m_FPatch.InitFuzz(numfuzz, numfuzzlib);
			m_FPatch.GenVolume(numlayers, volxsize, volzsize);
			D3DMATERIAL8 material;
			ZeroMemory(&material, sizeof(material));
			material.Ambient  = D3DXCOLOR(0.2f, 0.2f, 0.2f, 1.f);
			material.Diffuse  = D3DXCOLOR(0.5f, 0.5f, 0.5f, 1.f);
			material.Specular = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
			material.Power = 40.0f;
			m_FPatch.SetHairLightingMaterial(&material);
			m_dwLoadPhase++;
			break;
	}
	
	// move the camera around the model and always point right at it
	D3DXMATRIX m, m2;
	D3DXMatrixRotationYawPitchRoll(&m, m_vViewAngle.y, m_vViewAngle.x, m_vViewAngle.z);
	D3DXVec3TransformCoord(&m_vEyePos, &m_vCameraPos, &m);
	m_vEyePos += g_vLookAt;
	D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
	D3DXMatrixLookAtLH(&m_matView, &m_vEyePos, &g_vLookAt, &up);
	m_pd3dDevice->SetTransform(D3DTS_VIEW, &m_matView);

	// move the light around the model
	m_fLightAngle -= m_DefaultGamepad.fX2*1.0f*m_fElapsedTime;
	if(m_fLightAngle>D3DX_PI*2)
		m_fLightAngle -= D3DX_PI*2;
	if(m_fLightAngle<0.0f)
		m_fLightAngle += D3DX_PI*2;
	D3DXMatrixRotationY(&m, m_fLightAngle);
	D3DXVECTOR3 lpos;
	D3DXVec3TransformCoord(&lpos, &m_vLightPos, &m);
	D3DXVECTOR3 ldir;
	D3DXVec3Normalize(&ldir, &lpos);
	lpos += g_vLookAt;
	m_Light0.Position = lpos;
	m_Light0.Direction = -ldir;
	m_pd3dDevice->SetLight(0, &m_Light0);
	m_LightObj.SetPosition(m_Light0.Position.x, m_Light0.Position.y, m_Light0.Position.z);

	// set world-space light and eye positions for vertex shader
	g_LightPos = lpos;
	g_EyePos = m_vEyePos;
	
	// light looks at g_vLookAt
	D3DXMatrixLookAtLH(&m_LightObj.m_matOrientation, &m_LightObj.m_vPosition, &g_vLookAt, &up);
	D3DXMatrixInverse(&m_LightObj.m_matOrientation, NULL, &m_LightObj.m_matOrientation);

	// Set wind parameters
	static float fWindAmplitude = 0.01f;
	static float fWindFrequency = 2.f * D3DX_PI / 0.2f;
	static float fWindZero = -0.25f;
	// static float fPenalty = 1.5f;
	static float fTangentPlaneFraction = 0.9f;
	static float fWindStart = -7.f;	// start the wind gradually
	static float fWindDecay = -5.f;	// stop the wind gradually 
	static float fWindSwirlRadius = 0.1f;
	static float fWindSwirlFrequency = 2.f * D3DX_PI / 0.3f;
	g_vWind1.x = g_LightPos.x;
	g_vWind1.y = g_LightPos.y;
	g_vWind1.z = g_LightPos.z;
	D3DXMATRIX *pmat = &m_LightObj.m_matOrientation;	// grab left and up out of light matrix
	D3DXVECTOR3 vX(pmat->m[0][0], pmat->m[0][1], pmat->m[0][2]);
	D3DXVECTOR3 vY(pmat->m[1][0], pmat->m[1][1], pmat->m[1][2]);
	*(D3DXVECTOR3 *)&g_vWind2 = vY;
	g_vWind2.w = fTangentPlaneFraction;
	*(D3DXVECTOR3 *)&g_vWind3 = vX;
	g_vWind3.w = 0.f;
	if(m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
	{
		g_bWind = true;

		// blow-dryer
		float fWind = fWindZero + fWindAmplitude * cosf(m_fTime * fWindFrequency); 
		g_fWindChoose *= expf(fWindStart * m_fElapsedTime);
		g_vWind1.w = (1.f - g_fWindChoose) * fWind;
		// move source in small swirl around light source position
		float fWindSwirlX = fWindSwirlRadius * cosf(m_fTime * fWindSwirlFrequency);
		float fWindSwirlY = fWindSwirlRadius * sinf(m_fTime * fWindSwirlFrequency);
		*(D3DXVECTOR3 *)&g_vWind1 += fWindSwirlX * vX + fWindSwirlY * vY;
		
#if 0
		// update the sound
		D3DXVECTOR3 vSoundPosition( *(D3DXVECTOR3 *)&g_vWind1 );
        D3DXVECTOR3 vSoundVelocity = fWindSwirlX * vY - fWindSwirlY * vX; // velocity is perpendicular
		m_BlowerSound.Play();
        m_BlowerSound.SetPosition( vSoundPosition );
        m_BlowerSound.SetVelocity( vSoundVelocity );
#endif
#if 0
		// ambient wind
		static D3DXVECTOR3 fAmbientWindAmplitude(0.001f, 0.001f, 0.001f);
		static D3DXVECTOR3 fAmbientWindFrequency(2.f * D3DX_PI / 0.25f, 2.f * D3DX_PI / 0.3f, 2.f * D3DX_PI / 0.1f);
		static D3DXVECTOR3 fAmbientWindZero(0.f, 0.f, 0.f);
		g_vWind1.x = fAmbientWindZero.x + fAmbientWindAmplitude.x * cosf(m_fTime * fAmbientWindFrequency.x);
		g_vWind1.y = fAmbientWindZero.y + fAmbientWindAmplitude.y * cosf(m_fTime * fAmbientWindFrequency.y);
		g_vWind1.z = fAmbientWindZero.z + fAmbientWindAmplitude.z * cosf(m_fTime * fAmbientWindFrequency.z);
#endif
	}
	else
	{
		// turn-off wind
		g_fWindChoose = 1.f;
		g_vWind1.w *= expf(fWindDecay * m_fElapsedTime);

		// wait until wind has died out to turn off the wind vertex shader
		float fWindEpsilon = 1e-3f;
		if (fabsf(g_vWind1.w) < fWindEpsilon)
			g_bWind = false;
		
		// m_BlowerSound.Stop();
	}
	D3DXMATRIX matWorldInverse;
	D3DXMatrixInverse(&matWorldInverse, NULL, &g_matWorld);
	D3DXVec3TransformCoord((D3DXVECTOR3 *)&g_vWind1, (D3DXVECTOR3 *)&g_vWind1, &matWorldInverse);
	D3DXVec3TransformNormal((D3DXVECTOR3 *)&g_vWind2, (D3DXVECTOR3 *)&g_vWind2, &matWorldInverse);
	D3DXVec3TransformNormal((D3DXVECTOR3 *)&g_vWind3, (D3DXVECTOR3 *)&g_vWind3, &matWorldInverse);

	// Do reload
	if(m_mode == DEBUG_SHELL_MODE
		&& m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
	{
		m_dwLoadPhase = 0;
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawLightIcon()
// Desc: Draw light as a bright cone
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawLightIcon()
{
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	m_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	m_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	m_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE /*D3DBLEND_INVSRCALPHA*/);
	m_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	m_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	m_LightObj.Render(OBJ_NOMCALCS);
	m_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	m_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	D3DXVECTOR3 L(g_LightPos - g_vLookAt), E(g_EyePos - g_vLookAt);
	bool bLightBehind = (D3DXVec3Dot(&L, &E) < 0.f);

    // Clear the viewport
	RenderGradientBackground(D3DXCOLOR(0.1f, 0.1f, 0.1f, 1.f), D3DXCOLOR(0.3f, 0.3f, 0.4f, 1.f));
    //m_pd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DXCOLOR(0.3f, 0.3f, 0.4f, 1.f), 1.0f, 0L);

    m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
	m_pd3dDevice->SetTransform(D3DTS_WORLD, &m_LightObj.m_matOrientation);
	if (m_mode == DEBUG_LIGHTING_MODE)
		DrawAxes();		// draw coordinate axes for light
	if (bLightBehind) 
		DrawLightIcon();			// draw the light icon behind the fur

	// font code clobbers this state so we reset it here every frame
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
	m_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
	m_pd3dDevice->SetTextureStageState(1, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
	m_pd3dDevice->SetTextureStageState(1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
    m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    m_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW );
	m_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	m_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	
	// render the teddy object
	if(m_dwLoadPhase>1)
	{
		m_teddy.m_Model->m_dwVShader = m_teddy.m_Model->m_dwFVF;
		m_teddy.Render(0);
		if (m_teddyEyes.m_Model)
		{
			m_teddyEyes.m_Model->m_dwVShader = m_teddyEyes.m_Model->m_dwFVF;
			m_teddyEyes.Render(0);
		}
		if (m_teddyNose.m_Model)
		{
			m_teddyNose.m_Model->m_dwVShader = m_teddyNose.m_Model->m_dwFVF;
			m_teddyNose.Render(0);
		}
		if (m_mode != DEFAULT_MODE)
		{
			if (g_bDrawNormals)
			{
				float fNormalScale = m_FPatch.m_fYSize;
				DrawNormals(m_teddy.m_Model->m_dwNumVertices, m_teddy.m_Model->m_pVB, m_teddy.m_Model->m_dwFVF, fNormalScale);
			}
			if (g_bDrawTexCoordFrames && m_dwLoadPhase > 2)
			{
				static float fVectorScale = 0.004f;
				// Draw S vector
				DrawVertexVectors(m_FPatchMesh.m_dwNumVertices,
								  m_FPatchMesh.m_pVB, sizeof(FVFT_XYZNORMTEX1), 0,
								  m_FPatchMesh.m_pVBTex, sizeof(D3DVECTOR) * 2, 0,
								  fVectorScale,
								  D3DCOLOR_RGBA(0x88, 0x00, 0x00, 0xff),
								  D3DCOLOR_RGBA(0xff, 0x00, 0x00, 0xff));
				// Draw T vector
				DrawVertexVectors(m_FPatchMesh.m_dwNumVertices,
								  m_FPatchMesh.m_pVB, sizeof(FVFT_XYZNORMTEX1), 0,
								  m_FPatchMesh.m_pVBTex, sizeof(D3DVECTOR) * 2, sizeof(D3DVECTOR),
								  fVectorScale,
								  D3DCOLOR_RGBA(0x00, 0x88, 0x00, 0xff),
								  D3DCOLOR_RGBA(0x00, 0xff, 0x00, 0xff));
			}
			DrawAxes();	// draw coordinate axes
		}
	}

	// render the patch mesh
	if(m_dwLoadPhase>2)
	{
		g_matWorld = (D3DXMATRIX)m_teddy.m_matOrientation;
		g_matView = m_matView;
		g_matProj = m_matProjection;
		// pick vertex shaders depending on current settings
		UINT iConfig = (g_bMultiShell ? (1 << 3) : 0) | (g_bWind ? (1 << 2) : 0) | (g_bLocalLighting ? (1 << 1) : 0) | (g_bSelfShadow ? 1 : 0);
		g_dwFuzzVS = m_adwFurVS[iConfig];
		g_dwFinVS = m_adwFinVS[iConfig];
		m_FPatch.Render(m_fLOD, &m_FPatchMesh);
	}
	if (!bLightBehind)	
		DrawLightIcon();			// draw light icon to overlay the fur

	// Start text drawing
    m_Font.Begin();

	// show title
    m_Font.DrawText(64, 50, 0xffffffff, L"TEDDY");
#ifdef _DEBUG
    m_Font.DrawText(450, 50, 0xffffff00, m_strFrameRate);
#endif

	// show status
	if(m_dwLoadPhase==1)
		m_Font.DrawText(320, 50, 0xffffff00, L"LOADING MODEL", XBFONT_CENTER_X);
	else if(m_dwLoadPhase==2)
		m_Font.DrawText(320, 50, 0xffffff00, L"GENERATING HAIR", XBFONT_CENTER_X);

	float y = 50, ydelta = 25;
	WCHAR buf[100];
	if (m_mode == DEFAULT_MODE)
	{
		if(m_bDrawHelp)
			m_Help.Render(&m_Font, g_NormalHelpCallouts, MAX_NORMAL_HELP_CALLOUTS);
	}
	else if (m_mode == DEBUG_LIGHTING_MODE)
	{
		m_Font.DrawText(64, y += ydelta, 0xffffffff, L"light");
		_snwprintf(buf, 100, L"%g", g_LightPos.x);
		m_Font.DrawText(64, y += ydelta, 0xffff0000, buf);
		_snwprintf(buf, 100, L"%g", g_LightPos.y);
		m_Font.DrawText(64, y += ydelta, 0xff00ff00, buf);
		_snwprintf(buf, 100, L"%g", g_LightPos.z);
		m_Font.DrawText(64, y += ydelta, 0xff0000ff, buf);
		m_Font.DrawText(64, y += ydelta, 0xffffffff, L"eye");
		_snwprintf(buf, 100, L"%g", g_EyePos.x);
		m_Font.DrawText(64, y += ydelta, 0xffff0000, buf);
		_snwprintf(buf, 100, L"%g", g_EyePos.y);
		m_Font.DrawText(64, y += ydelta, 0xff00ff00, buf);
		_snwprintf(buf, 100, L"%g", g_EyePos.z);
		m_Font.DrawText(64, y += ydelta, 0xff0000ff, buf);
		m_Font.DrawText(64, y += ydelta, 0xffffffff, GetString_D3DTEXTUREOP(g_iCOLOROP1));
		m_Font.DrawText(64, y += ydelta, 0xffffffff, GetString_D3DTEXTUREOP(g_iCOLOROP2));
		m_Font.DrawText(64, y += ydelta, 0xffffffff, g_bLocalLighting ? L"Local lighting" : L"Directional lighting");
		m_Font.DrawText(64, y += ydelta, 0xffffffff, g_bSelfShadow ? L"Self-shadowing" : L"No self-shadowing");

		if(m_bDrawHelp)
			m_Help.Render(&m_Font, g_LightingHelpCallouts, MAX_LIGHTING_HELP_CALLOUTS);
	}
	else if (m_mode == DEBUG_SHELL_MODE)
	{
		m_Font.DrawText(64, y += ydelta, 0xffffffff, L"Debug Shells");
		m_Font.DrawText(64, y += ydelta, 0xffffffff, g_bDrawFins ? L"Draw fins" : L"No fins");
		m_Font.DrawText(64, y += ydelta, 0xffffffff, g_bDrawShells ? L"Draw shells" : L"No shells");
		if (m_bShowTextures)
		{
			// show hair textures
			float fAlpha = 1.f;
			PrepareDeviceForDrawSprite(m_pd3dDevice);
			float fScreenLeft = 640.f * 0.2f;
			float fScreenTop = 480.f * 0.0f;
			float fScreenRight = 640.f * 0.9f;
			float fScreenBottom = 480.f * 0.9f;
			float fScreenWidth = fScreenRight - fScreenLeft;
			float fScreenHeight = fScreenBottom - fScreenTop;
			float fBorder = 5.f;
			float fSpriteWidth = (float)m_FPatch.m_dwVolXSize;
			float fSpriteHeight = (float)m_FPatch.m_dwVolZSize;
			UINT nSprite = m_FPatch.m_dwNumLayers + 1; // one fin texture
			UINT nRow, nColumn = 3;
			float fScaleSprite, fWidth, fHeight;
			do {
				nColumn++;
				nRow = (nSprite + nColumn - 1) / nColumn;
				fWidth = (fScreenWidth - (nColumn - 1) * fBorder) / nColumn;
				fScaleSprite = fWidth / fSpriteWidth;
				fHeight = fSpriteHeight * fScaleSprite;
			} while (nRow * fHeight + (nRow - 1) * fBorder > fScreenHeight);
			UINT iColumn = 0, iRow = 0;
			float fWidthRemaining = fScreenWidth - (nColumn * fWidth + (nColumn - 1) * fBorder);
			float fHeightRemaining = fScreenHeight - (nRow * fHeight + (nRow - 1) * fBorder);
			D3DXVECTOR3 vDest(fScreenLeft + 0.5f*fWidthRemaining, fScreenTop + 0.5f * fHeightRemaining, 0.f);
			LPDIRECT3DTEXTURE8 pTexture;
			for (UINT iLayer = 0; iLayer < m_FPatch.m_dwNumLayers; iLayer++)
			{
				pTexture = m_FPatch.m_pVolTexture[iLayer];
				DrawSpriteSimple(m_pd3dDevice, pTexture, vDest, fAlpha, fScaleSprite, NULL);
				iColumn++;
				if (iColumn == nColumn)
				{
					iColumn = 0;
					iRow++;
					vDest.x = fScreenLeft;
					vDest.y += fHeight + fBorder;
				}
				else
				{
					vDest.x += fWidth + fBorder;
				}
			}

			// Currently, fin texture is the same size as the rest of the layers
			pTexture = m_FPatch.m_pFinTexture;
			DrawSpriteSimple(m_pd3dDevice, pTexture, vDest, fAlpha, fScaleSprite, NULL);
		}

		if(m_bDrawHelp)
			m_Help.Render(&m_Font, g_ShellHelpCallouts, MAX_SHELL_HELP_CALLOUTS);
	}

	// End text drawing
    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\mipmap.h ===
//-----------------------------------------------------------------------------
//  
//  File: mipmap.h
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Mipmap filtering using the GPU
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>

//////////////////////////////////////////////////////////////////////
// Filter coefficients and offsets for separable mipmap filtering.
//
class MipmapFilter {
 public:
	UINT m_nSuperSample;		// number of source samples per destination pixel
	float m_fHalfWidth;			// size of filter support
	UINT m_nSample;				// number of filter samples
	struct Sample {
		float m_fOffset;		// offset in destination pixel coords
		float m_fValue;			// value at offset
	} *m_rSample;
	int m_iSuperMin, m_iSuperMax;	// range of supersamples
 public:
#define MIPMAPFILTER_NORMALIZE_ADD		001 /* add (1-sum)/N to each filter coefficient */
#define MIPMAPFILTER_NORMALIZE_MULTIPLY	002 /* multiply each value by 1/sum */
#define MIPMAPFILTER_STRETCH				010 /* expand filter slightly to make tighter frequency bound */
#define MIPMAPFILTER_KEEPZEROS			020 /* filter values that quantize to zero are usually culled, when 255 * f < 0.5 */
	MipmapFilter(UINT nSuperSample = 2,	// number of source samples per output pixel
		   float fHalfWidth = 2.f,	// in destination pixel coords, filter is assumed to be zero outside this bound
		   float (*pfFilter)(float x, float fHalfWidth) = lanczos,	// filter kernel
		   DWORD dwFlags = MIPMAPFILTER_NORMALIZE_ADD);	// normalization flags
	~MipmapFilter() { delete [] m_rSample; }

	// kernel helper functions
	void NormalizeAdd();		// add (1 - sum)/N to each value
	void NormalizeMultiply();	// multiply each value by 1/sum
	static float triangle(float x, float fHalfWidth);
	static float mitchell(float x, float fHalfWidth);
	static float sinc(float x);							// sin(x) / x
	static float lanczos(float x, float fHalfWidth);	// sinc windowed sinc
	static float hamming(float x, float fHalfWidth);	// hamming-windowed sinc
};

//////////////////////////////////////////////////////////////////////
// Use filter coefficients to resample from higher resolution
// pTextureSrc to lower resolution pSurfaceDst.
// The width of Src must be m_nSuperSample * width of Dst and
// the height of Src must be m_nSuperSample * height of Dst.
// The scratch texture must be swizzled and have width >= Src and height >= Src
// If either pTextureScratchY or pTextureScratchX are NULL, temporary
// textures will be created and then released when done.
//
HRESULT Decimate(LPDIRECT3DSURFACE8 pSurfaceDst,
				 LPDIRECT3DTEXTURE8 pTextureSrc,
				 UINT iSourceLevel,	// index of source miplevel in pTextureSrc
				 D3DTEXTUREADDRESS WrapU = D3DTADDRESS_WRAP, 
				 D3DTEXTUREADDRESS WrapV = D3DTADDRESS_WRAP,
				 LPDIRECT3DTEXTURE8 pTextureScratchY = NULL,	// destination for filtering in Y
				 LPDIRECT3DTEXTURE8 pTextureScratchX = NULL,	// destination for filtering in X
				 MipmapFilter *pFilter = NULL);

//////////////////////////////////////////////////////////////////////
// Compute mipmaps starting from iSourceLevel
// The scratch textures must be swizzled and have width >= Src and height >= Src
// If either pTextureScratchY or pTextureScratchX are NULL, temporary
// textures will be created and then released when done.
// The filter must have nSuperSample = 2.
//
HRESULT GenerateMipmaps(LPDIRECT3DTEXTURE8 pTexture,
						UINT iSourceLevel,
						D3DTEXTUREADDRESS WrapU = D3DTADDRESS_WRAP, 
						D3DTEXTUREADDRESS WrapV = D3DTADDRESS_WRAP,
						LPDIRECT3DTEXTURE8 pTextureScratchY = NULL,
						LPDIRECT3DTEXTURE8 pTextureScratchX = NULL,
						MipmapFilter *pFilter = NULL);

//////////////////////////////////////////////////////////////////////
// Create a new texture the same size as the source texture, with the
// same number of mipmap levels, and then copy the source to the
// destination, with a format change.  This function handles swizzled and
// unswizzled textures.
//
HRESULT CopyTexture(LPDIRECT3DTEXTURE8 *ppTextureDst, D3DFORMAT fmtNew, LPDIRECT3DTEXTURE8 pTextureSrc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\mipmap.cpp ===
//-----------------------------------------------------------------------------
//  
//  File: mipmap.cpp
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//  
//  Mipmap filtering using the GPU
//
//-----------------------------------------------------------------------------
#include "mipmap.h"
#include <XBUtil.h>
#include "SwizzleFormat.h"
#include <assert.h>

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//////////////////////////////////////////////////////////////////////
// Default filter is lanczos with halfwidth 2 and 2 supersamples.  That
// works out to 8 taps per output pixel, with a small negative lobe for
// sharpness.
static MipmapFilter s_MipmapFilterDefault(2, 2.f, MipmapFilter::lanczos, MIPMAPFILTER_NORMALIZE_ADD);

//////////////////////////////////////////////////////////////////////
// Sample filter kernel, weight by super sample area, and normalize.
//
MipmapFilter::MipmapFilter(UINT nSuperSample,
						   float fHalfWidth,
						   float (*pfFilter)(float x, float fHalfWidth),
						   DWORD dwFlags)
{
	if (nSuperSample == 0) nSuperSample = 1;
	m_nSuperSample = nSuperSample;
	m_fHalfWidth = fHalfWidth;

	// If number of supersamples is even, offset by half pixel.
	float fSampleOffset;
	if (nSuperSample % 2)
		fSampleOffset = 0.f;
	else
		fSampleOffset = 0.5f;		

	// Get number of supersamples in support
	int iSuperMin = (int)ceilf(-fHalfWidth * nSuperSample - fSampleOffset);
	int iSuperMax = (int)floorf(fHalfWidth * nSuperSample - fSampleOffset);
	m_nSample = iSuperMax - iSuperMin + 1;

	// Get adjusted filter support width
	float fStretch = 1.f;
	if (dwFlags & MIPMAPFILTER_STRETCH) 
	{
		fStretch = 1.f - 0.5f / fHalfWidth;
		float fStretchWidth = fHalfWidth / fStretch;
		iSuperMin = (int)ceilf(-fHalfWidth * nSuperSample - fSampleOffset);
		iSuperMax = (int)floorf(fHalfWidth * nSuperSample - fSampleOffset);
		m_nSample = iSuperMax - iSuperMin + 1;
	}

	// Allocate sample array
	m_rSample = new Sample [ m_nSample ];

	// Sample filter at supersample positions
	float fStep = 1.f / nSuperSample;
	float fWeight = fStretch * fStep;
	UINT iSample = 0;
	m_iSuperMin = m_iSuperMax = 0;
	for (int iSuper = iSuperMin; iSuper <= iSuperMax; iSuper++)
	{
		float fOffset = (iSuper + fSampleOffset) * fStep;
		float fValue = fWeight * (*pfFilter)(fOffset * fStretch, fHalfWidth);
		if (!(dwFlags & MIPMAPFILTER_KEEPZEROS))
		{
			float fQuant = 255.f * fabsf(fValue);
			if (fQuant < 0.5f) continue; // remove values that quantize to zero
		}
		m_rSample[iSample].m_fOffset = fOffset;
		m_rSample[iSample].m_fValue = fValue;
		iSample++;
		if (iSuper < m_iSuperMin) m_iSuperMin = iSuper;
		if (iSuper > m_iSuperMax) m_iSuperMax = iSuper;
	}

	// Re-allocate sample array after removing zeros
	if (iSample < m_nSample)
	{
		Sample *rSampleOld = m_rSample;
		m_nSample = iSample;
		m_rSample = new Sample [ m_nSample ];
		for (iSample = 0; iSample < m_nSample; iSample++)
			m_rSample[iSample] = rSampleOld[iSample];
		delete [] rSampleOld;
	}

	// Normalize
	if (dwFlags & MIPMAPFILTER_NORMALIZE_MULTIPLY)
		NormalizeMultiply();
	else if (dwFlags & MIPMAPFILTER_NORMALIZE_ADD)
		NormalizeAdd();
}

//////////////////////////////////////////////////////////////////////
// Add (1 - sum)/N to each filter value.
//
void MipmapFilter::NormalizeAdd()
{
	float fSum = 0.f;
	for (UINT iSample = 0; iSample < m_nSample; iSample++)
		fSum += m_rSample[iSample].m_fValue;
	float fOffset = (1.f - fSum) / m_nSample;
	for ( iSample = 0; iSample < m_nSample; iSample++)
		m_rSample[iSample].m_fValue += fOffset;
}

//////////////////////////////////////////////////////////////////////
// Multiply each filter coefficient by 1/sum of the original coefficients.
//
void MipmapFilter::NormalizeMultiply()
{
	float fSum = 0.f;
	for (UINT iSample = 0; iSample < m_nSample; iSample++)
		fSum += m_rSample[iSample].m_fValue;
	float fScale = 1.f/fSum;
	for ( iSample = 0; iSample < m_nSample; iSample++)
		m_rSample[iSample].m_fValue *= fScale;
}

//////////////////////////////////////////////////////////////////////
// Standard sin(pi*x)/(pi*x) function that is the inverse fourier
// transform of a box filter in the frequency domain.  The problem with
// the sinc is that it has infinite extent. The lanczos and hamming filters
// below take a finite window and smoothly "roll off" at the edges.
//
float MipmapFilter::sinc(float x)
{
	if (x == 0.f)
		return 1.f;
	else
		return sinf(D3DX_PI * x) / (D3DX_PI * x);
}

//////////////////////////////////////////////////////////////////////
// Triangle filter is not a too bad approximation to a windowed sinc,
// but doesn't have a negative lobe to make the result sharp.  The
// lanczos, hamming, and mitchell filters are better.
//
float MipmapFilter::triangle(float x, float fHalfWidth)
{
	float r = x / fHalfWidth;
	if (r < -1.f || r > 1.f)
		return 0.0;
	else if (r < 0.0) 
		return (1 + r) / fHalfWidth;
	else 
		return (1 - r) / fHalfWidth;
}

//////////////////////////////////////////////////////////////////////
// Sinc-windowed sinc
//
float MipmapFilter::lanczos(float x, float fHalfWidth)
{
	if (x < -fHalfWidth || x > fHalfWidth)
		return 0.f;
	else
		return sinc(x/fHalfWidth) * sinc(x);
}

//////////////////////////////////////////////////////////////////////
// Hamming-windowed sinc
//
float MipmapFilter::hamming(float x, float fHalfWidth)
{
	if (x < -fHalfWidth || x > fHalfWidth)
		return 0.f;
	else
		return (0.46f * cosf(D3DX_PI * x / fHalfWidth) + 0.54f) * sinc(x);
}

//////////////////////////////////////////////////////////////////////
// Cubic filter that has a shape similar to the lanczos and hamming filters,
// but has slightly smaller negative lobes.
//
float MipmapFilter::mitchell(float x, float fHalfWidth)
{
	const float B = 0.3f;
	const float C = 0.3f;
	float r = (x < 0.f) ? -x : x;
	r /= 0.5f * fHalfWidth;
	if (r <= 1.f)
		return (6 - 2*B + r*r*(-18 + 12*B + 6*C + r*(12 - 9*B - 6*C)))/6;
	else if (r <= 2.f)
		return (8*B + 24*C + r*(-12*B - 48*C + r*(6*B + 30*C + r*(-B - 6*C))))/6;
	else 
		return 0.f;
}

//////////////////////////////////////////////////////////////////////
// CopyRects even if the formats are swizzled.
// 
HRESULT CopyRects(D3DSurface *pSurfaceSrc, CONST RECT *pSrcRectsArray, UINT cRects, D3DSurface *pSurfaceDst, CONST POINT *pDstPointsArray)
{
	HRESULT hr;
	D3DSURFACE_DESC descSrc;
	pSurfaceSrc->GetDesc(&descSrc);
	BOOL bSwizzledSrc = XGIsSwizzledFormat(descSrc.Format);
	D3DSURFACE_DESC descDst;
	pSurfaceDst->GetDesc(&descDst);
	BOOL bSwizzledDst = XGIsSwizzledFormat(descDst.Format);
	if (! bSwizzledSrc && !bSwizzledDst ) // if formats are both unswizzled, use regular CopyRects
		return g_pd3dDevice->CopyRects(pSurfaceSrc, pSrcRectsArray, cRects, pSurfaceDst, pDstPointsArray);
	if (MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descDst.Format))
		return D3DERR_WRONGTEXTUREFORMAT;

	// Otherwise, copy pixel by pixel
	DWORD cbPixel = XGBytesPerPixelFromFormat(descSrc.Format);
	D3DLOCKED_RECT lockedRectSrc;
	hr = pSurfaceSrc->LockRect(&lockedRectSrc, NULL, 0);
	if (FAILED(hr))
		return hr;
	D3DLOCKED_RECT lockedRectDst;
	hr = pSurfaceDst->LockRect(&lockedRectDst, NULL, 0);
	if (FAILED(hr))
	{
		pSurfaceSrc->UnlockRect();
		return hr;
	}
	for (UINT iRect = 0; iRect < cRects; iRect++)
	{
		RECT rectSrc;
		if (pSrcRectsArray)
			rectSrc = pSrcRectsArray[iRect];
		else
		{
			rectSrc.left = 0;
			rectSrc.right = descSrc.Width;
			rectSrc.top = 0;
			rectSrc.bottom = descSrc.Height;
		}
		POINT pointDst;
		if (pDstPointsArray)
			pointDst = pDstPointsArray[iRect];
		else
			pointDst.x = pointDst.y = 0;
		if (bSwizzledSrc && bSwizzledDst)
		{
			Swizzler swizSrc(descSrc.Width, descSrc.Height, 0);
			Swizzler swizDst(descDst.Width, descDst.Height, 0);
			swizSrc.SetV(swizSrc.SwizzleV(rectSrc.top));
			swizDst.SetV(swizDst.SwizzleV(pointDst.y));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				swizSrc.SetU(swizSrc.SwizzleU(rectSrc.left));
				swizDst.SetU(swizDst.SwizzleU(pointDst.x));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + cbPixel * swizSrc.Get2D();
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + cbPixel * swizDst.Get2D();
					memcpy(pDst, pSrc, cbPixel);
					swizSrc.IncU();
					swizDst.IncU();
				}
				swizSrc.IncV();
				swizDst.IncV();
			}
		}
		else if (bSwizzledSrc) // && !bSwizzledDst
		{
			Swizzler swizSrc(descSrc.Width, descSrc.Height, 0);
			swizSrc.SetV(swizSrc.SwizzleV(rectSrc.top));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				long vDst = pointDst.y + v - rectSrc.top;
				swizSrc.SetU(swizSrc.SwizzleU(rectSrc.left));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					long uDst = pointDst.x + u - rectSrc.left;
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + cbPixel * swizSrc.Get2D();
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + vDst * lockedRectDst.Pitch + uDst * cbPixel;
					memcpy(pDst, pSrc, cbPixel);
					swizSrc.IncU();
				}
				swizSrc.IncV();
			}
		}
		else // !bSwizzledSrc && bSwizzledDst
		{
			Swizzler swizDst(descDst.Width, descDst.Height, 0);
			swizDst.SetV(swizDst.SwizzleV(pointDst.y));
			for (long v = rectSrc.top; v < rectSrc.bottom; v++)
			{
				swizDst.SetU(swizDst.SwizzleU(pointDst.x));
				for (long u = rectSrc.left; u < rectSrc.right; u++)
				{
					BYTE *pSrc = (BYTE *)lockedRectSrc.pBits + v * lockedRectSrc.Pitch + u * cbPixel;
					BYTE *pDst = (BYTE *)lockedRectDst.pBits + cbPixel * swizDst.Get2D();
					memcpy(pDst, pSrc, cbPixel);
					swizDst.IncU();
				}
				swizDst.IncV();
			}
		}
	}
	pSurfaceSrc->UnlockRect();
	pSurfaceDst->UnlockRect();
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// Helper function for allocating scratch textures, if needed.
//
static HRESULT AllocScratchYX(MipmapFilter *pFilter,
							  D3DSURFACE_DESC &descSrc,
							  LPDIRECT3DTEXTURE8 &pTextureScratchY,
							  LPDIRECT3DTEXTURE8 &pTextureScratchX)
{
	HRESULT hr;
	if (pTextureScratchY == NULL)
	{
		DWORD width = descSrc.Width;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;	// result will be decimated in Y
		if (height < 1) height = 1;
		if (width * XGBytesPerPixelFromFormat(descSrc.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| width * height < 64)
		{
			width = 64;	// 16 is smallest reasonable render target
			if (height < width)	// if source height is larger use it, otherwise use reasonable default
				height = width;
		}
		hr = g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_RENDERTARGET, descSrc.Format, D3DPOOL_DEFAULT, &pTextureScratchY);
		if (FAILED(hr))
			return hr;
	}
	else
	{
		D3DSURFACE_DESC descScratchY;
		pTextureScratchY->GetLevelDesc(0, &descScratchY);
		if (descScratchY.Width < descSrc.Width										// Y scratch must match _source_ width
			|| descScratchY.Height < descSrc.Height / pFilter->m_nSuperSample		// ... and destination height
			|| descScratchY.Width * XGBytesPerPixelFromFormat(descScratchY.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| descScratchY.Width * descScratchY.Height < 64
			|| MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descScratchY.Format))	// formats must be compatible
			return E_INVALIDARG;
		pTextureScratchY->AddRef();	// to balance Release, below
	}
	if (pTextureScratchX == NULL)
	{
		DWORD width = descSrc.Width / pFilter->m_nSuperSample;		// result will be decimated in X
		if (width < 1) width = 1;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;	// result will be decimated in Y by previous filter pass
		if (height < 1) height = 1;
		if (width * XGBytesPerPixelFromFormat(descSrc.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| width * height < 64)
		{
			width = 64;	// 16 is smallest reasonable render target
			if (height < width)	// if source height is larger use it, otherwise use reasonable default
				height = width;
		}
		hr = g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_RENDERTARGET, descSrc.Format, D3DPOOL_DEFAULT, &pTextureScratchX);
		if (FAILED(hr))
		{
			SAFE_RELEASE(pTextureScratchY);
			return hr;
		}
	}
	else
	{
		D3DSURFACE_DESC descScratchX;
		pTextureScratchX->GetLevelDesc(0, &descScratchX);
		if (descScratchX.Width < descSrc.Width / pFilter->m_nSuperSample			// X scratch must match destination width
			|| descScratchX.Height < descSrc.Height / pFilter->m_nSuperSample		// ... and destination height
			|| descScratchX.Width * XGBytesPerPixelFromFormat(descScratchX.Format) < 64  // Xbox render target must have at least the minimum pitch
			|| descScratchX.Width * descScratchX.Height < 64
			|| MapSwizzledToLinearFormat(descSrc.Format) != MapSwizzledToLinearFormat(descScratchX.Format))	// formats must be compatible
		{
			SAFE_RELEASE(pTextureScratchY);
			return E_INVALIDARG;
		}
		pTextureScratchX->AddRef();	// to balance Release, below
	}
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Uses Decimate to compute mipmaps starting with iSourceLevel
//
HRESULT GenerateMipmaps(LPDIRECT3DTEXTURE8 pTexture,
						UINT iSourceLevel,
						D3DTEXTUREADDRESS WrapU, 
						D3DTEXTUREADDRESS WrapV,
						LPDIRECT3DTEXTURE8 pTextureScratchY,
						LPDIRECT3DTEXTURE8 pTextureScratchX,
						MipmapFilter *pFilter)
{
	HRESULT hr;
	DWORD nMip = pTexture->GetLevelCount();
	if (iSourceLevel >= nMip - 1) return S_FALSE;	// nothing to filter
	if (!pFilter) pFilter = &s_MipmapFilterDefault;
	D3DSURFACE_DESC descSrc;
	hr = pTexture->GetLevelDesc(iSourceLevel, &descSrc);
	if (FAILED(hr))
		return hr;
	hr = AllocScratchYX(pFilter, descSrc, pTextureScratchY, pTextureScratchX);
	if (FAILED(hr))
		return hr;
	LPDIRECT3DSURFACE8 pSurfaceDst = NULL;
	for (UINT iMip = iSourceLevel + 1; iMip < nMip; iMip++)
	{
		hr = pTexture->GetSurfaceLevel(iMip, &pSurfaceDst); // get destination surface
		if (FAILED(hr))
			goto e_Exit;
		hr = Decimate(pSurfaceDst, pTexture, iMip - 1, WrapU, WrapV, pTextureScratchY, pTextureScratchX, pFilter);
		if (FAILED(hr))
			goto e_Exit;
		SAFE_RELEASE(pSurfaceDst);
	}
 e_Exit:
	SAFE_RELEASE(pSurfaceDst);
	SAFE_RELEASE(pTextureScratchX);
	SAFE_RELEASE(pTextureScratchY);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Use filter coefficients to resample from higher resolution
// pSurfaceSrc to lower resolution pSurfaceDst.
// The width of Src must be m_nSuperSample * width of Dst and
// the height of Src must be m_nSuperSample * height of Dst.
// The Y scratch texture must have width >= Src and height >= Src / 2.
// The X scratch texture must have width >= Src / 2 and height >= Src / 2.
HRESULT Decimate(LPDIRECT3DSURFACE8 pSurfaceDst,
				 LPDIRECT3DTEXTURE8 pTextureSrc,
				 UINT iSourceLevel,	// index of source miplevel in pTextureSrc
				 D3DTEXTUREADDRESS WrapU, 
				 D3DTEXTUREADDRESS WrapV,
				 LPDIRECT3DTEXTURE8 pTextureScratchY,
				 LPDIRECT3DTEXTURE8 pTextureScratchX,
				 MipmapFilter *pFilter)
{
	HRESULT hr;
	if (!pFilter) pFilter = &s_MipmapFilterDefault;

	// Get sizes of intermediate and final render targets
	D3DSURFACE_DESC descSrc;
	pTextureSrc->GetLevelDesc(iSourceLevel, &descSrc);
	D3DSURFACE_DESC descDst;
	pSurfaceDst->GetDesc(&descDst);
	if ((descDst.Width != 1 && descDst.Width > descSrc.Width / pFilter->m_nSuperSample)
		|| (descDst.Height != 1 && descDst.Height > descSrc.Height / pFilter->m_nSuperSample))
		return E_INVALIDARG;	// texture sizes don't match
	hr = AllocScratchYX(pFilter, descSrc, pTextureScratchY, pTextureScratchX);
	if (FAILED(hr))
		return hr;
	D3DSURFACE_DESC descScratchY, descScratchX;
	pTextureScratchY->GetLevelDesc(0, &descScratchY);
	pTextureScratchX->GetLevelDesc(0, &descScratchX);
	DWORD dwStateBlock = -1;
	hr = g_pd3dDevice->CreateStateBlock(D3DSBT_ALL, &dwStateBlock);
	if (FAILED(hr))
		return hr;
	
	// save current back buffer, z buffer, and pixel shader
	struct {
		IDirect3DSurface8 *pBackBuffer, *pZBuffer;
	} save;
	g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);

	// set render state for filtering
	g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX4);	// for screen-space texture-mapped quadrilateral
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);

	// use pixel shaders to add contributions from four samples at a time
	DWORD dwPS = 0;
#include "mipmap.inl"
	g_pd3dDevice->CreatePixelShader(&psd, &dwPS);
	g_pd3dDevice->SetPixelShader(dwPS);

	// set texture stage state
	UINT xx; // texture stage index
	for (xx = 0; xx < 4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, pTextureSrc);	// use our source texture for all four stages
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);	// pass texture coords without transformation
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXCOORDINDEX, xx); // each texture has different tex coords
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSU, WrapU);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSV, WrapV);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAXMIPLEVEL, iSourceLevel);	// set most-detailed level to the desired source texture
		float fBias = -1000.f; 														// bias mipmap toward the most detailed level
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, *((LPDWORD) (&fBias)));
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MINFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAGFILTER, D3DTEXF_POINT);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORSIGN, 0);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE);
	}

	//
	// Pass 1: Filter in Y from Src to ScratchY
	//
	{
		LPDIRECT3DSURFACE8 pSurfaceScratchY = NULL;
		pTextureScratchY->GetSurfaceLevel(0, &pSurfaceScratchY);
		hr = g_pd3dDevice->SetRenderTarget(pSurfaceScratchY, NULL); // no depth buffering
		pSurfaceScratchY->Release();
		if (FAILED(hr))
			goto e_Exit;
		DWORD width = descSrc.Width;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;
		if (height < 1) height = 1;
		struct quad {
			float x, y, z, w1;
			struct uv {
				float u, v;
			} tex[4];	// each texture has different offset
		} aQuad[4] =
		  { //   X             Y              Z   1/W     u0  v0      u1  v1      u2  v2      u3  v3
			  {-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f},
			  {width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f},
			  {-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
			  {width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f}
		  };
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);	// on first rendering, copy new value over current render target contents
		xx = 0;	// current texture stage
		float rfZero[4] = {0.f, 0.f, 0.f, 0.f};
		float fOffsetScale = (float)pFilter->m_nSuperSample / (float)descSrc.Height;	// source texture coords
		for (UINT iSample = 0; iSample < pFilter->m_nSample; iSample++)
		{
			// set filter coefficients
			float fValue = pFilter->m_rSample[iSample].m_fValue;
			if (fValue > 0.f)
			{
				float rf[4] = {fValue, fValue, fValue, fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rf, 1);			// positive coeff
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			else
			{
				float rf[4] = {-fValue, -fValue, -fValue, -fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rf, 1);		// negative coeff
			}
			// Align supersamples with center of destination pixels
			float fOffset = pFilter->m_rSample[iSample].m_fOffset * fOffsetScale;
			aQuad[0].tex[xx].u = 0.f;
			aQuad[0].tex[xx].v = fOffset;
			aQuad[1].tex[xx].u = 1.f;
			aQuad[1].tex[xx].v = fOffset;
			aQuad[2].tex[xx].u = 0.f;
			aQuad[2].tex[xx].v = 1.f + fOffset;
			aQuad[3].tex[xx].u = 1.f;
			aQuad[3].tex[xx].v = 1.f + fOffset;
			if (!XGIsSwizzledFormat(descSrc.Format))
			{
				for (int i = 0; i < 4; i++)
				{
					aQuad[i].tex[xx].u *= descSrc.Width;
					aQuad[i].tex[xx].v *= descSrc.Height;
				}
			}
			xx++;
			if (xx == 4)	// max texture stages
			{
				// draw the quad to filter the coefficients so far
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
				g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); // on subsequent renderings, add to what's in the render target
				xx = 0;
			}
		}
		if (xx != 0) // add in results of final filter coefficients
		{
			// zero out rest of texture stage coefficients
			for (xx; xx < 4; xx++)
			{
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
		}
	}

	//
	// Pass 2: Filter in X from ScratchY to ScratchX
	//
	{
		DWORD width = descSrc.Width / pFilter->m_nSuperSample;
		if (width < 1) width = 1;
		DWORD height = descSrc.Height / pFilter->m_nSuperSample;
		if (height < 1) height = 1;
		for (xx = 0; xx < 4; xx++)
			g_pd3dDevice->SetTexture(xx, pTextureScratchY);	// use the Y scratch texture as source for all four stages
		// Adjust scratch texture coords to include just the used region
		D3DXVECTOR2 vOrigin(0.f, 0.f);
		D3DXVECTOR2 vSize((float)descSrc.Width/(float)descScratchY.Width, (float)height/(float)descScratchY.Height);
#if 0
		if (descDst.Width * XGBytesPerPixelFromFormat(descDst.Format) >= 64  // Xbox render target must have at least the minimum pitch
			&& descDst.Width * descDst.Height >= 64)
		{
			// If destination surface is large enough, use it as a render target.
			hr = g_pd3dDevice->SetRenderTarget(pSurfaceDst, NULL); // no depth buffering
			if (FAILED(hr))
				goto e_Exit;
		}
		else
#endif
		{
			// Set scratchX as render target
			LPDIRECT3DSURFACE8 pSurfaceScratchX = NULL;
			pTextureScratchX->GetSurfaceLevel(0, &pSurfaceScratchX);
			hr = g_pd3dDevice->SetRenderTarget(pSurfaceScratchX, NULL); // no depth buffering
			pSurfaceScratchX->Release();
			if (FAILED(hr))
				goto e_Exit;
		}
		struct quad {
			float x, y, z, w1;
			struct uv {
				float u, v;
			} tex[4];	// each texture has different offset
		} aQuad[4] =
		  { //   X             Y              Z   1/W     u0  v0      u1  v1      u2  v2      u3  v3
			  {-0.5f,        -0.5f,         1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f},
			  {width - 0.5f, -0.5f,         1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f},
			  {-0.5f,        height - 0.5f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f},
			  {width - 0.5f, height - 0.5f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f}
		  };
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);	// on first rendering, copy new value over current render target contents
		xx = 0;	// current texture stage
		float rfZero[4] = {0.f, 0.f, 0.f, 0.f};
		// TODO: review offset scale when width gets close to 1
		float fOffsetScale = (float)pFilter->m_nSuperSample / (float)descScratchY.Width;	// source texture coords
		for (UINT iSample = 0; iSample < pFilter->m_nSample; iSample++)
		{
			// set filter coefficients
			float fValue = pFilter->m_rSample[iSample].m_fValue;
			if (fValue > 0.f)
			{
				float rf[4] = {fValue, fValue, fValue, fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rf, 1);			// positive coeff
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			else
			{
				float rf[4] = {-fValue, -fValue, -fValue, -fValue};
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rf, 1);		// negative coeff
			}
			// Align supersamples with center of destination pixels
			float fOffset = pFilter->m_rSample[iSample].m_fOffset * fOffsetScale;
			aQuad[0].tex[xx].u = vOrigin.x + fOffset;
			aQuad[0].tex[xx].v = vOrigin.y;
			aQuad[1].tex[xx].u = vOrigin.x + vSize.x + fOffset;
			aQuad[1].tex[xx].v = vOrigin.y;
			aQuad[2].tex[xx].u = vOrigin.x + fOffset;
			aQuad[2].tex[xx].v = vOrigin.y + vSize.y;
			aQuad[3].tex[xx].u = vOrigin.x + vSize.x + fOffset;
			aQuad[3].tex[xx].v = vOrigin.y + vSize.y;
			if (!XGIsSwizzledFormat(descScratchY.Format))
			{
				for (int i = 0; i < 4; i++)
				{
					aQuad[i].tex[xx].u *= descScratchY.Width;
					aQuad[i].tex[xx].v *= descScratchY.Height;
				}
			}
			xx++;
			if (xx == 4)	// max texture stages
			{
				// draw the quad to filter the coefficients so far
				g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
				g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); // on subsequent renderings, add to what's in the render target
				xx = 0;
			}
		}
		if (xx != 0) // add in results of final filter coefficients
		{
			// zero out rest of texture stage coefficients
			for (xx; xx < 4; xx++)
			{
				g_pd3dDevice->SetPixelShaderConstant(xx, rfZero, 1);		// positive coeff set to zero
				g_pd3dDevice->SetPixelShaderConstant(xx + 4, rfZero, 1);	// negative coeff set to zero
			}
			g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
		}
	}

	// 
	// Copy result to output
	//
	{
		DWORD width = descDst.Width;
		DWORD height = descDst.Height;
		
		// Stop using the scratch texture
		g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
		for (xx = 0; xx < 4; xx++)
			g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->BlockUntilIdle();

		// Copy result from scratch texture to destination surface
		LPDIRECT3DSURFACE8 pSurfaceScratchX = NULL;
		pTextureScratchX->GetSurfaceLevel(0, &pSurfaceScratchX);
		RECT rect = { 0, 0, width, height };
		POINT point = { 0, 0 };
		hr = CopyRects(pSurfaceScratchX, &rect, 1, pSurfaceDst, &point);
		pSurfaceScratchX->Release();
		if (FAILED(hr))
			goto e_Exit;
	}

e_Exit:
	SAFE_RELEASE(pTextureScratchX);
	SAFE_RELEASE(pTextureScratchY);

	// clean up pixel shaders
	g_pd3dDevice->SetPixelShader(0);
	g_pd3dDevice->DeletePixelShader(dwPS);
	
	// restore render states
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);

	// clear texture stages
	for (xx=0; xx<4; xx++)
	{
		g_pd3dDevice->SetTexture(xx, NULL);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, 0);
	}

	// restore back buffer and z buffer
	g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
	SAFE_RELEASE(save.pBackBuffer);
	SAFE_RELEASE(save.pZBuffer);
	g_pd3dDevice->ApplyStateBlock(dwStateBlock);
	g_pd3dDevice->DeleteStateBlock(dwStateBlock);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Create a new texture and copy the current texture to the new
// texture, with a format conversion.
//
HRESULT CopyTexture(LPDIRECT3DTEXTURE8 *ppTextureDst, D3DFORMAT fmtNew, LPDIRECT3DTEXTURE8 pTextureSrc)
{
	HRESULT hr;
	if (!pTextureSrc)
		return S_FALSE;
	*ppTextureDst = NULL;
	UINT nLevel = pTextureSrc->GetLevelCount();
	BYTE *pUnswizzledSrc = NULL;
	BYTE *pUnswizzledDst = NULL;
	LPDIRECT3DTEXTURE8 pTextureDst = NULL;
	LPDIRECT3DSURFACE8 pSurfaceSrc = NULL;
	LPDIRECT3DSURFACE8 pSurfaceDst = NULL;
	D3DSURFACE_DESC desc0;
	pTextureSrc->GetLevelDesc(0, &desc0);
	hr = g_pd3dDevice->CreateTexture(desc0.Width, desc0.Height, nLevel, 0, fmtNew, 0, &pTextureDst);
	if (FAILED(hr))
		goto e_Exit;
	if (XGIsSwizzledFormat(desc0.Format))
	{
		pUnswizzledSrc = new BYTE [ desc0.Width * desc0.Height * XGBytesPerPixelFromFormat(desc0.Format)]; 
		if (pUnswizzledSrc == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}
	}
	if (XGIsSwizzledFormat(fmtNew))
	{
		pUnswizzledDst = new BYTE [ desc0.Width * desc0.Height * XGBytesPerPixelFromFormat(fmtNew)];
		if (pUnswizzledDst == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}
	}
	for (UINT iLevel = 0; iLevel < nLevel; iLevel++)
	{
		D3DSURFACE_DESC desc;
		pTextureSrc->GetLevelDesc(iLevel, &desc);
		assert(desc.Format == desc0.Format);
		assert(desc.Width <= desc0.Width);
		assert(desc.Height <= desc0.Height);
		hr = pTextureSrc->GetSurfaceLevel(iLevel, &pSurfaceSrc);
		if (FAILED(hr))
			goto e_Exit;
		hr = pTextureDst->GetSurfaceLevel(iLevel, &pSurfaceDst);
		if (FAILED(hr))
			goto e_Exit;
		D3DLOCKED_RECT lockedRectSrc;
		hr = pSurfaceSrc->LockRect(&lockedRectSrc, NULL, D3DLOCK_READONLY);
		if (FAILED(hr))
			goto e_Exit;
		D3DLOCKED_RECT lockedRectDst;
		hr = pSurfaceDst->LockRect(&lockedRectDst, NULL, 0);
		if (FAILED(hr))
		{
			pSurfaceSrc->UnlockRect();
			goto e_Exit;
		}
		VOID *pBufSrc;
		DWORD dwPitchSrc;
		D3DFORMAT fmtSrc;
		if (XGIsSwizzledFormat(desc.Format))
		{
			XGUnswizzleRect(lockedRectSrc.pBits, desc.Width, desc.Height, NULL, pUnswizzledSrc, 0, NULL, XGBytesPerPixelFromFormat(desc.Format));
			pBufSrc = pUnswizzledSrc;
			dwPitchSrc = 0;
			fmtSrc = MapSwizzledToLinearFormat(desc.Format);
		}
		else
		{
			pBufSrc = lockedRectSrc.pBits;
			dwPitchSrc = lockedRectSrc.Pitch;
			fmtSrc = desc.Format;
		}
		VOID *pBufDst;
		DWORD dwPitchDst;
		D3DFORMAT fmtDst;
		if (XGIsSwizzledFormat(fmtNew))
		{
			pBufDst = pUnswizzledDst;
			dwPitchDst = 0;
			fmtDst = MapSwizzledToLinearFormat(fmtNew);
		}
		else
		{
			pBufDst = lockedRectDst.pBits;
			dwPitchDst = lockedRectDst.Pitch;
			fmtDst = fmtNew;
		}
		hr = XGCompressRect(pBufDst, fmtDst, dwPitchDst, desc.Width, desc.Height, pBufSrc, fmtSrc, dwPitchSrc, 0.f, 0 );
		if (FAILED(hr))
		{
			pSurfaceSrc->UnlockRect();
			pSurfaceDst->UnlockRect();
			goto e_Exit;
		}
		if (XGIsSwizzledFormat(fmtNew))
			XGSwizzleRect(pBufDst /* compressed result from XGCompressRect */, dwPitchDst, NULL, lockedRectDst.pBits, desc.Width, desc.Height, NULL, XGBytesPerPixelFromFormat(fmtNew));
		pSurfaceSrc->UnlockRect();
		pSurfaceDst->UnlockRect();
		SAFE_RELEASE(pSurfaceSrc);
		SAFE_RELEASE(pSurfaceDst);
	}
	*ppTextureDst = pTextureDst;	// already AddRef'd
	pTextureDst = NULL;	// to avoid a Release below
 e_Exit:
	SAFE_RELEASE(pTextureDst);
	SAFE_DELETE(pUnswizzledSrc);
	SAFE_DELETE(pUnswizzledDst);
	SAFE_RELEASE(pSurfaceSrc);
	SAFE_RELEASE(pSurfaceDst);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\util.cpp ===
//-----------------------------------------------------------------------------
// File: util.cpp
// Desc: Handy utility functions
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "util.h"
#include <tchar.h>

extern LPDIRECT3DDEVICE8 g_pd3dDevice;	// Defined by XbApp

//-----------------------------------------------------------------------------
// Macros for setting state and restoring on scope exit, which are
// used to set just the state needed for a debug routine.
//-----------------------------------------------------------------------------
#define SET_D3DTSS(STAGE, NAME, VALUE)\
	struct _D3DTSS_STAGE##STAGE##_##NAME {\
 		DWORD dw; \
		 _D3DTSS_STAGE##STAGE##_##NAME() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTextureStageState(STAGE, NAME, &dw);\
			g_pd3dDevice->SetTextureStageState(STAGE, NAME, VALUE);\
		}\
		 ~_D3DTSS_STAGE##STAGE##_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTextureStageState(STAGE, NAME, dw);\
		}\
	} __D3DTSS_STAGE##STAGE##_##NAME
#define SET_D3DTEXTURE(STAGE, TEXTURE)\
	struct _D3DTEXTURE_STAGE##STAGE {\
 		D3DBaseTexture *__pTexture; \
		 _D3DTEXTURE_STAGE##STAGE(D3DBaseTexture *pTexture) { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetTexture(STAGE, &__pTexture);\
			g_pd3dDevice->SetTexture(STAGE, pTexture);\
		}\
		 ~_D3DTEXTURE_STAGE##STAGE() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetTexture(STAGE, __pTexture);\
			 if (__pTexture != NULL) __pTexture->Release();\
		}\
	} __D3DTEXTURE_STAGE##STAGE(TEXTURE)
#define SET_D3DRS(NAME, VALUE)\
	struct _D3DRS_##NAME {\
 		DWORD dw; \
		 _D3DRS_##NAME() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetRenderState(NAME, &dw);\
			g_pd3dDevice->SetRenderState(NAME, VALUE);\
		}\
		 ~_D3DRS_##NAME() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetRenderState(NAME, dw);\
		}\
	} __D3DRS_##NAME
#define SET_D3DVS(VALUE)\
	struct _D3DVS {\
 		DWORD dw; \
		 _D3DVS() { /* constructor is called to save current value and set new value */ \
 			g_pd3dDevice->GetVertexShader(&dw);\
			g_pd3dDevice->SetVertexShader(VALUE);\
		}\
		 ~_D3DVS() { /* on scope exit, saved value is restored */ \
			 g_pd3dDevice->SetVertexShader(dw);\
		}\
	} __D3DVS

//-----------------------------------------------------------------------------
// Macros used by the bounding sphere calculation routine
//-----------------------------------------------------------------------------
inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }

//-----------------------------------------------------------------------------
//  Take the union of two spheres
//-----------------------------------------------------------------------------
void UnionSphere(D3DXVECTOR3 *pvCenter, float *pfRadius, 
				 const D3DXVECTOR3 &vCenter, const float &fRadius)
{
	D3DXVECTOR3 v =  vCenter - *pvCenter;
	float vlen = D3DXVec3Length(&v);
	float a = MIN(-*pfRadius, vlen - fRadius);
	float b = MAX(*pfRadius, vlen + fRadius);
	*pfRadius = 0.5f * (b - a);
	*pvCenter += (0.5f * (b + a) / vlen) * v;
}

//-----------------------------------------------------------------------------
//  Find the bounding sphere for the vertices
//-----------------------------------------------------------------------------
HRESULT ComputeBoundingSphere(
        PVOID pPointsFVF, 
        DWORD NumVertices, 
        DWORD FVF,
        D3DXVECTOR3 *pvCenter, 
        FLOAT *pfRadius)
{
	if (NumVertices == 0)
	{
		pvCenter->x = pvCenter->y = pvCenter->z = 0.f;
		*pfRadius = 0;
		return S_FALSE;
	}
	UINT cbVertexSize = D3DXGetFVFVertexSize(FVF);
	// use first vertex as starting point
	float feps = 1e-6f;  // use a small epsilon as zero radius
	*pvCenter = *(D3DXVECTOR3 *)pPointsFVF;
	*pfRadius = feps;
	// union in the rest of the points as zero-radius spheres
	for (UINT iVertex = 1; iVertex < NumVertices; iVertex++)
		UnionSphere(pvCenter, pfRadius, *(D3DXVECTOR3 *)((BYTE *)pPointsFVF + cbVertexSize * iVertex), feps);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Draw hedgehog vectors with origin at each vertex.
// Lines go from Position to Position + fVectorScale * Vector.
//-----------------------------------------------------------------------------
HRESULT DrawVertexVectors(DWORD nVertex,		// number of lines to draw
						  LPDIRECT3DVERTEXBUFFER8 pVBPosition, DWORD cbPositionSize, DWORD cbPositionOffset,	// origin of lines
						  LPDIRECT3DVERTEXBUFFER8 pVBVector, DWORD cbVectorSize, DWORD cbVectorOffset,		// offset of lines
						  float fVectorScale,	// scale
						  DWORD color0,		// color at base
						  DWORD color1)		// color at tip
{
	HRESULT hr = S_OK;
	const UINT nLineBuf = 1000;
	struct Vertex {
		float x, y, z;
		D3DCOLOR diffuse;
	} aVertex[nLineBuf*2];
	Vertex *pVertex = &aVertex[0];
	BYTE *pVertexPosition = NULL;
	BYTE *pVertexVector = NULL;
	UINT nLine = 0;
	SET_D3DRS( D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	SET_D3DRS( D3DRS_ZWRITEENABLE, TRUE);
	SET_D3DRS( D3DRS_ALPHATESTENABLE, FALSE);
	SET_D3DRS( D3DRS_NORMALIZENORMALS, FALSE);
	SET_D3DRS( D3DRS_ALPHABLENDENABLE, FALSE );
	SET_D3DRS( D3DRS_LIGHTING, FALSE);
	SET_D3DVS(D3DFVF_XYZ | D3DFVF_DIFFUSE);
	SET_D3DTEXTURE( 0, NULL);
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL);
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL);
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL);
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	hr = pVBPosition->Lock(NULL, NULL, (BYTE **)&pVertexPosition, 0l );
	if (FAILED(hr))
		goto e_Exit;
	hr = pVBVector->Lock(NULL, NULL, (BYTE **)&pVertexVector, 0l );
	if (FAILED(hr))
		goto e_Exit;
	UINT iVertex;
	for (iVertex = 0; iVertex < nVertex; iVertex++)
	{
		float *pfPosition = (float *)(pVertexPosition + cbPositionSize * iVertex + cbPositionOffset);
		float *pfVector = (float *)(pVertexVector + cbVectorSize * iVertex + cbVectorOffset);
		pVertex[0].x = pfPosition[0];
		pVertex[0].y = pfPosition[1];
		pVertex[0].z = pfPosition[2];
		pVertex[0].diffuse = color0;
		pVertex[1].x = pVertex[0].x + pfVector[0] * fVectorScale;
		pVertex[1].y = pVertex[0].y + pfVector[1] * fVectorScale;
		pVertex[1].z = pVertex[0].z + pfVector[2] * fVectorScale;
		pVertex[1].diffuse = color1;
		pVertex += 2;
		nLine++;
		if (nLine == nLineBuf)
		{
			// buffer is full, so draw what we have
			hr = g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, nLine, aVertex, sizeof(Vertex));
			if (FAILED(hr))
				goto e_Exit;
			nLine = 0;
			pVertex = &aVertex[0];
		}
	}
	if (nLine != 0)
	{
		// draw any left over lines
		hr = g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINELIST, nLine, aVertex, sizeof(Vertex));
		if (FAILED(hr))
			goto e_Exit;
	}
e_Exit:
	if (pVertexPosition)
		pVBPosition->Unlock();
	if (pVertexVector)
		pVBVector->Unlock();
	return hr;
}

HRESULT DrawNormals(DWORD nVertex, LPDIRECT3DVERTEXBUFFER8 pVB, DWORD dwFVF, float fNormalScale)
{
	if (!((dwFVF & D3DFVF_XYZ) && (dwFVF & D3DFVF_NORMAL)))
		return S_FALSE; // no normals to draw
	UINT cbVertexSize = D3DXGetFVFVertexSize(dwFVF);
	return DrawVertexVectors(nVertex,
							 pVB, cbVertexSize, 0 /* position offset */,
							 pVB, cbVertexSize, 12 /* normal offset */,
							 fNormalScale,
							 D3DCOLOR_RGBA(0x00, 0xff, 0x00, 0xff),
							 D3DCOLOR_RGBA(0x00, 0xff, 0xff, 0xff));
}

//-----------------------------------------------------------------------------
//  Draw coordinate axes.
//-----------------------------------------------------------------------------
HRESULT DrawAxes()
{
	const float fAxisRodRadius = 0.05f;
	const float fAxisRodLength = 0.8f;
	const float fAxisConeRadius = fAxisRodRadius * 3.f;
	const float fAxisConeLength = 1.f;
	static struct AxisVertex {
		float x, y, z;
		D3DCOLOR color;
	} XAxis[] = {
		{ 0.f,             0.f,				 0.f }, 
		{ fAxisRodLength,  fAxisRodRadius,   0.f }, 
		{ fAxisRodLength,  fAxisConeRadius,  0.f }, 
		{ fAxisConeLength, 0.f,              0.f }, 
		{ fAxisRodLength,  0.f,              fAxisConeRadius }, 
		{ fAxisRodLength,  0.f,              fAxisRodRadius }, 
		{ 0.f,             0.f,              0.f },
		{ fAxisConeLength, 0.f,              0.f }, 
	};
	const int nVertex = sizeof(XAxis)/sizeof(AxisVertex);
	static AxisVertex YAxis[nVertex];
	static AxisVertex ZAxis[nVertex];
	static bool bInitialized = false;
	if (!bInitialized)
	{
		const D3DCOLOR XColor = 0xffff0000;
		const D3DCOLOR YColor = 0xff00ff00;
		const D3DCOLOR ZColor = 0xff0000ff;
		for (UINT i = 0; i < nVertex; i++)
		{
			XAxis[i].color = XColor;
			YAxis[i].x = XAxis[i].y; YAxis[i].y = XAxis[i].x; YAxis[i].z = XAxis[i].z; // swap x and y
			YAxis[i].color = YColor;
			ZAxis[i].x = XAxis[i].z; ZAxis[i].y = XAxis[i].y; ZAxis[i].z = XAxis[i].x; // swap x and z
			ZAxis[i].color = ZColor;
		}
		bInitialized = true;
	}
	
	// set and save state
	SET_D3DRS(D3DRS_LIGHTING, FALSE);
	SET_D3DRS(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_COLOR1);
	SET_D3DVS(D3DFVF_XYZ|D3DFVF_DIFFUSE); // vertex shader
	SET_D3DTEXTURE( 0, NULL);
	SET_D3DTSS( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
	SET_D3DTSS( 0,D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	SET_D3DTSS( 0,D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
	SET_D3DTSS( 0,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 1, NULL);
	SET_D3DTSS( 1,D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 1,D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 1,D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 2, NULL);
	SET_D3DTSS( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 2, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	SET_D3DTEXTURE( 3, NULL);
	SET_D3DTSS( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
	SET_D3DTSS( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	SET_D3DTSS( 3, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );

	// draw the axes
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, XAxis, sizeof(AxisVertex));
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, YAxis, sizeof(AxisVertex));
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_LINESTRIP, nVertex - 1, ZAxis, sizeof(AxisVertex));	
	return S_OK;
}

//=========================================================================
// Prepare a device for a DrawSpriteSimple operation
//=========================================================================
void PrepareDeviceForDrawSprite(IDirect3DDevice8* pDevice)
{
    pDevice->SetPixelShader(0);

    pDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

    pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
    pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL);
    pDevice->SetRenderState(D3DRS_ALPHAREF, 0x00000001);

    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

    pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);
    pDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

    pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE);
    pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);

    pDevice->SetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
    pDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_PASSTHRU);

    pDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_POINT);
    pDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_POINT);
}

//=========================================================================
// Draw a screen space texture sprite
//=========================================================================
void DrawSpriteSimple(LPDIRECT3DDEVICE8 pDevice,
    LPDIRECT3DTEXTURE8 pTexture, const D3DXVECTOR3 &ptDest,
    float alpha, float scale, const RECT *pSourceRect)
{
    SIZE size;
    RECT rcSrc;
    D3DSURFACE_DESC Desc;

    (void)pTexture->GetLevelDesc(0, &Desc);
    if(!pSourceRect)
    {
        rcSrc.left = 0;
        rcSrc.top = 0;
        rcSrc.right = Desc.Width;
        rcSrc.bottom = Desc.Height;

        pSourceRect = &rcSrc;
    }

    size.cx = pSourceRect->right - pSourceRect->left;
    size.cy = pSourceRect->bottom - pSourceRect->top;

    // Coordinates for Rendering Target in Screen space
    float left   = ptDest.x;
    float right  = ptDest.x + (float)size.cx*scale;
    float top    = ptDest.y;
    float bottom = ptDest.y + (float)size.cy*scale;

    // Setup texture coordinates to use
    float fTexLeft   = (float)pSourceRect->left   / (float)Desc.Width;
    float fTexTop    = (float)pSourceRect->top    / (float)Desc.Height;
    float fTexRight  = (float)pSourceRect->right  / (float)Desc.Width;
    float fTexBottom = (float)pSourceRect->bottom / (float)Desc.Height;

    // Setup alpha term to modulate in
    DWORD dwColor = ((DWORD)(alpha * 255.0f) << 24) | 0x00FFFFFF;

    struct MYD3DTLVERTEX
    {
        float   sx, sy, sz; // Screen coordinates
        float   rhw;        // Reciprocal of homogeneous w
        DWORD   color;      // Vertex color
        float   tu, tv;     // Texture coordinates
    } pvSprite[4] =
    {
        { left-0.5f,    top-0.5f, ptDest.z, 1.0f, dwColor, fTexLeft,  fTexTop},
        {right-0.5f,    top-0.5f, ptDest.z, 1.0f, dwColor, fTexRight, fTexTop},
        {right-0.5f, bottom-0.5f, ptDest.z, 1.0f, dwColor, fTexRight, fTexBottom},
        { left-0.5f, bottom-0.5f, ptDest.z, 1.0f, dwColor, fTexLeft,  fTexBottom},
    };

    pDevice->SetTexture(0, pTexture);
    pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1);

    // Display the sprite
    pDevice->DrawVerticesUP(D3DPT_QUADLIST, 4, pvSprite, sizeof(pvSprite[0]));
}

//-----------------------------------------------------------------------------
//  Return string corresponding to texture op
//-----------------------------------------------------------------------------
WCHAR *GetString_D3DTEXTUREOP(DWORD d3dtop)
{
	switch (d3dtop)
	{
	case 0:
		return L"<NONE>";
    case D3DTOP_DISABLE:
		 return L"D3DTOP_DISABLE";
    case D3DTOP_SELECTARG1:
		 return L"D3DTOP_SELECTARG1";
    case D3DTOP_SELECTARG2:
		 return L"D3DTOP_SELECTARG2";
    case D3DTOP_MODULATE:
		 return L"D3DTOP_MODULATE";
    case D3DTOP_MODULATE2X:
		 return L"D3DTOP_MODULATE2X";
    case D3DTOP_MODULATE4X:
		 return L"D3DTOP_MODULATE4X";
    case D3DTOP_ADD:
		 return L"D3DTOP_ADD";
    case D3DTOP_ADDSIGNED:
		 return L"D3DTOP_ADDSIGNED";
    case D3DTOP_ADDSIGNED2X:
		 return L"D3DTOP_ADDSIGNED2X";
    case D3DTOP_SUBTRACT:
		 return L"D3DTOP_SUBTRACT";
    case D3DTOP_ADDSMOOTH:
		 return L"D3DTOP_ADDSMOOTH";
    case D3DTOP_BLENDDIFFUSEALPHA:
		 return L"D3DTOP_BLENDDIFFUSEALPHA";
    case D3DTOP_BLENDTEXTUREALPHA:
		 return L"D3DTOP_BLENDTEXTUREALPHA";
    case D3DTOP_BLENDFACTORALPHA:
		 return L"D3DTOP_BLENDFACTORALPHA";
    case D3DTOP_BLENDTEXTUREALPHAPM:
		 return L"D3DTOP_BLENDTEXTUREALPHAPM";
    case D3DTOP_BLENDCURRENTALPHA:
		 return L"D3DTOP_BLENDCURRENTALPHA";
    case D3DTOP_PREMODULATE:
		 return L"D3DTOP_PREMODULATE";
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
		 return L"D3DTOP_MODULATEALPHA_ADDCOLOR";
    case D3DTOP_MODULATECOLOR_ADDALPHA:
		 return L"D3DTOP_MODULATECOLOR_ADDALPHA";
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
		 return L"D3DTOP_MODULATEINVALPHA_ADDCOLOR";
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
		 return L"D3DTOP_MODULATEINVCOLOR_ADDALPHA";
    case D3DTOP_BUMPENVMAP:
		 return L"D3DTOP_BUMPENVMAP";
    case D3DTOP_BUMPENVMAPLUMINANCE:
		 return L"D3DTOP_BUMPENVMAPLUMINANCE";
    case D3DTOP_DOTPRODUCT3:
		 return L"D3DTOP_DOTPRODUCT3";
    case D3DTOP_MULTIPLYADD:
		 return L"D3DTOP_MULTIPLYADD";
    case D3DTOP_LERP:
		 return L"D3DTOP_LERP";
	default:
		return L"<UNKNOWN>";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\swizzleformat.h ===
//////////////////////////////////////////////////////////////////////
// Swizzled to linear and back format mapping.
//
//  Copyright (C) 2001 Microsoft Corporation
//  All rights reserved.
//////////////////////////////////////////////////////////////////////
inline D3DFORMAT MapLinearToSwizzledFormat(D3DFORMAT fmt)
{
	switch (fmt)
	{
    case D3DFMT_LIN_A1R5G5B5: 	return D3DFMT_A1R5G5B5;
    case D3DFMT_LIN_A4R4G4B4: 	return D3DFMT_A4R4G4B4;
    case D3DFMT_LIN_A8: 		return D3DFMT_A8;
    case D3DFMT_LIN_A8B8G8R8: 	return D3DFMT_A8B8G8R8;
    case D3DFMT_LIN_A8R8G8B8: 	return D3DFMT_A8R8G8B8;
    case D3DFMT_LIN_B8G8R8A8: 	return D3DFMT_B8G8R8A8;
    case D3DFMT_LIN_G8B8: 		return D3DFMT_G8B8;
    case D3DFMT_LIN_R4G4B4A4: 	return D3DFMT_R4G4B4A4;
    case D3DFMT_LIN_R5G5B5A1: 	return D3DFMT_R5G5B5A1;
    case D3DFMT_LIN_R5G6B5: 	return D3DFMT_R5G6B5;
    case D3DFMT_LIN_R6G5B5: 	return D3DFMT_R6G5B5;
    case D3DFMT_LIN_R8B8: 		return D3DFMT_R8B8;
    case D3DFMT_LIN_R8G8B8A8: 	return D3DFMT_R8G8B8A8;
    case D3DFMT_LIN_X1R5G5B5: 	return D3DFMT_X1R5G5B5;
    case D3DFMT_LIN_X8R8G8B8: 	return D3DFMT_X8R8G8B8;
    case D3DFMT_LIN_A8L8: 		return D3DFMT_A8L8;
    case D3DFMT_LIN_AL8: 		return D3DFMT_AL8;
    case D3DFMT_LIN_L16: 		return D3DFMT_L16;
    case D3DFMT_LIN_L8: 		return D3DFMT_L8;
    case D3DFMT_LIN_V16U16: 	return D3DFMT_V16U16;
    case D3DFMT_LIN_D24S8: 		return D3DFMT_D24S8;
    case D3DFMT_LIN_F24S8: 		return D3DFMT_F24S8;
    case D3DFMT_LIN_D16: 		return D3DFMT_D16;
    case D3DFMT_LIN_F16: 		return D3DFMT_F16;
	default:
		return fmt;
	}
}

inline D3DFORMAT MapSwizzledToLinearFormat(D3DFORMAT fmt)
{
	switch (fmt)
	{
    case D3DFMT_A1R5G5B5: 	return D3DFMT_LIN_A1R5G5B5;
    case D3DFMT_A4R4G4B4: 	return D3DFMT_LIN_A4R4G4B4;
    case D3DFMT_A8: 		return D3DFMT_LIN_A8;
    case D3DFMT_A8B8G8R8: 	return D3DFMT_LIN_A8B8G8R8;
    case D3DFMT_A8R8G8B8: 	return D3DFMT_LIN_A8R8G8B8;
    case D3DFMT_B8G8R8A8: 	return D3DFMT_LIN_B8G8R8A8;
    case D3DFMT_G8B8: 		return D3DFMT_LIN_G8B8;
    case D3DFMT_R4G4B4A4: 	return D3DFMT_LIN_R4G4B4A4;
    case D3DFMT_R5G5B5A1: 	return D3DFMT_LIN_R5G5B5A1;
    case D3DFMT_R5G6B5: 	return D3DFMT_LIN_R5G6B5;
    case D3DFMT_R6G5B5: 	return D3DFMT_LIN_R6G5B5;
    case D3DFMT_R8B8: 		return D3DFMT_LIN_R8B8;
    case D3DFMT_R8G8B8A8: 	return D3DFMT_LIN_R8G8B8A8;
    case D3DFMT_X1R5G5B5: 	return D3DFMT_LIN_X1R5G5B5;
    case D3DFMT_X8R8G8B8: 	return D3DFMT_LIN_X8R8G8B8;
    case D3DFMT_A8L8: 		return D3DFMT_LIN_A8L8;
    case D3DFMT_AL8: 		return D3DFMT_LIN_AL8;
    case D3DFMT_L16: 		return D3DFMT_LIN_L16;
    case D3DFMT_L8: 		return D3DFMT_LIN_L8;
    case D3DFMT_V16U16: 	return D3DFMT_LIN_V16U16;
    case D3DFMT_D24S8: 		return D3DFMT_LIN_D24S8;
    case D3DFMT_F24S8: 		return D3DFMT_LIN_F24S8;
    case D3DFMT_D16: 		return D3DFMT_LIN_D16;
    case D3DFMT_F16: 		return D3DFMT_LIN_F16;
	default:
		return fmt;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\mipmap.inl ===
// Xbox Shader Assembler 1.00.3710.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    8,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x40404040;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x40404040;
psd.PSConstant1[1] = 0x00000000;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x40404040;
psd.PSConstant1[2] = 0x00000000;

//------------- Stage 3 -------------
psd.PSRGBInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[3] = 0x40404040;
psd.PSConstant1[3] = 0x00000000;

//------------- Stage 4 -------------
psd.PSRGBInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[4] = 0x00000000;
psd.PSConstant1[4] = 0x00000000;

//------------- Stage 5 -------------
psd.PSRGBInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[5] = 0x00000000;
psd.PSConstant1[5] = 0x00000000;

//------------- Stage 6 -------------
psd.PSRGBInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[6] = 0x00000000;
psd.PSConstant1[6] = 0x00000000;

//------------- Stage 7 -------------
psd.PSRGBInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_NEGATE,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[7] = 0x00000000;
psd.PSConstant1[7] = 0x00000000;

psd.PSC0Mapping = 0x76543210;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\cartoon\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\util.h ===
//-----------------------------------------------------------------------------
// File: util.h
// Desc: Handy utility functions
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>

void UnionSphere(D3DXVECTOR3 *pvCenter, float *pfRadius, const D3DXVECTOR3 &vCenter, const float &fRadius);
HRESULT ComputeBoundingSphere(
        PVOID pPointsFVF, 
        DWORD NumVertices, 
        DWORD FVF,
        D3DXVECTOR3 *pvCenter, 
        FLOAT *pfRadius);

HRESULT DrawVertexVectors(DWORD nVertex,        // number of lines to draw
                          LPDIRECT3DVERTEXBUFFER8 pVBPosition, DWORD cbVertexSize, DWORD cbPositionOffset,  // origin of lines
                          LPDIRECT3DVERTEXBUFFER8 pVBVector, DWORD cbVectorSize, DWORD cbVectorOffset,      // offset of lines
                          float fVectorScale,   // scale
                          DWORD color0,         // color at base
                          DWORD color1);        // color at tip
HRESULT DrawNormals(DWORD nVertex, LPDIRECT3DVERTEXBUFFER8 pVB, DWORD dwFVF, float fNormalScale);

HRESULT DrawAxes();

void PrepareDeviceForDrawSprite(IDirect3DDevice8* pDevice);
void DrawSpriteSimple(LPDIRECT3DDEVICE8 pDevice,
					  LPDIRECT3DTEXTURE8 pTexture, 
					  const D3DXVECTOR3 &ptDest,
					  float alpha,
					  float scale,
					  const RECT *pSourceRect);

WCHAR *GetString_D3DTEXTUREOP(DWORD d3dtop);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\fur.inl ===
// Xbox Shader Assembler 1.00.3812.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    8,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_V0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x00000000;
psd.PSConstant1[1] = 0x00000000;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_V0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x00000000;
psd.PSConstant1[2] = 0x00000000;

//------------- Stage 3 -------------
psd.PSRGBInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[3] = 0x00000000;
psd.PSConstant1[3] = 0x00000000;

//------------- Stage 4 -------------
psd.PSRGBInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[4] = 0x00000000;
psd.PSConstant1[4] = 0x00000000;

//------------- Stage 5 -------------
psd.PSRGBInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_V0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[5] = 0x00000000;
psd.PSConstant1[5] = 0x00000000;

//------------- Stage 6 -------------
psd.PSRGBInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_BLUE | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[6] = 0x00000000;
psd.PSConstant1[6] = 0x00000000;

//------------- Stage 7 -------------
psd.PSRGBInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[7] = 0x00000000;
psd.PSConstant1[7] = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\cartoon\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\cartoon\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\cartoon\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\cartoon\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\xfpmesh.h ===
//-----------------------------------------------------------------------------
// File: xfpmesh.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __PMESH_H
#define __PMESH_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include "xobj.h"

class CXFPatch;
struct TriangleFind;
struct GeometryTexture;

class CXFPatchMesh
{
public:
	CXObject *m_Obj;						// the object we are attached to

	DWORD m_dwNumIndices;					// # of indices
	DWORD m_dwMaxIndices;					// max # of indices
	WORD *m_Indices;						// triangle indices
	float *m_UVs;							// texture samples

	BOOL m_bBuildFlag;						// set to rebuild object
	DWORD m_dwNumVertices;					// current # of vertices in pmesh
	WORD m_wMaxIndex;						// max vertex index in m_pIB
	IDirect3DVertexBuffer8 *m_pVB;			// vertex buffer
	IDirect3DVertexBuffer8 *m_pVBTex;		// vertex buffer for texture coordinate frames
	IDirect3DIndexBuffer8 *m_pIB;			// index buffer
    IDirect3DTexture8 *m_pTexture;			// texture
	DWORD m_dwVShader;						// vertex shader

	DWORD m_dwNumFins;
	IDirect3DIndexBuffer8 *m_pFinIB;		// fin index buffer (indices are into m_pVB, but with 2X factor)
 	IDirect3DVertexBuffer8 *m_pFinVB;		// fin selection stream (alternating 0's and 1's)

	// mapping info
	D3DVECTOR m_TextureCenter;				// volume texture center
	D3DVECTOR m_TextureSize;				// volume texture size
	DWORD m_dwMapping;						// mapping type (0=planar, 1=cyl, 2=sphere)
	DWORD m_dwAxis;							// mapping axis (0=z, 1=y, 2=x)

	// volume info
	char m_strFPatchName[32];				// name of fpatch used for this mesh

	CXFPatchMesh();
	~CXFPatchMesh();

	HRESULT Initialize(CXObject *obj, WORD *aIndices, DWORD dwNumIndices); // initialize from object and selection. If aIndices==NULL, do whole mesh.
	HRESULT CalculateTextureCoordinateFrames();
	HRESULT ExtractFins();
	DWORD PickTriangle(CXObject *obj, POINT p, DWORD flag, D3DVIEWPORT8 *Viewport, 
						D3DXMATRIX *ProjMatrix, D3DXMATRIX *ViewMatrix, D3DXMATRIX *WorldMatrix);
	void BuildIndexBuffer();
	void Build(int firstflag);
	void Render();

	void Save(char *fname);
	void Load(char *fname);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\xfpatch.cpp ===
//-----------------------------------------------------------------------------
// File: xfpatch.cpp
//
// Desc: routines for generating and displaying a 'fuzz' patch.
//       which is a series of layers that give the appearance of
//       hair, fur, grass, or other fuzzy things.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#ifdef _XBOX
#include <xtl.h>
#include <xgraphics.h>
#else
#include <d3d8.h>
#endif
#include "xfpatch.h"
#include "xbutil.h"
#include "mipmap.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

#define irand(a) ((rand()*(a))>>15)
#define frand(a) ((float)rand()*(a)/32768.0f)

float g_fOneInch = 0.01f;

D3DXMATRIX g_matProj;					// current projection matrix
D3DXMATRIX g_matView;					// current view matrix
D3DXMATRIX g_matWorld;					// current world matrix
D3DXMATRIX g_matDisplay;				// current display matrix (View*World*Proj)
D3DXVECTOR3 g_LightPos;					// current light position
D3DXVECTOR3 g_EyePos;					// current eye position

DWORD g_dwFuzzVS;						// fuzz vertex shader
DWORD g_dwFinVS;						// fin vertex shader

//-----------------------------------------------------------------------------
// Name: Constructor
// Desc: 
//-----------------------------------------------------------------------------
CXFPatch::CXFPatch()
{
	DWORD i;
	ZeroMemory(this, sizeof(CXFPatch));

	// init default patch
	m_fXSize = 0.1f;
	m_fZSize = 0.1f;

	// init default fuzzlib
	m_dwNumFuzzLib = 0;
	m_pFuzzLib = NULL;
	m_fuzzCenter.colorBase = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
	m_fuzzCenter.colorTip = D3DXCOLOR(1.f, 1.f, 1.f, 0.f);
	m_fuzzCenter.dp.y = 1.0f;

	// init default fuzz
	m_dwNumSegments = 4;
	m_pFuzz = NULL;

	// init default volume
	m_dwNumLayers = 0;
	m_dwVolXSize = 0;
	m_dwVolZSize = 0;

	for(i=0; i<MAX_VLEVEL; i++)
		m_pVolTexture[i] = NULL;
	m_pTexture = NULL;
	m_pHairLightingTexture = NULL;
	m_pFinTexture = NULL;

	InitFuzz(1, 1);
}

//-----------------------------------------------------------------------------
// Name: Destructor
// Desc: 
//-----------------------------------------------------------------------------
CXFPatch::~CXFPatch()
{
	DWORD i;
	if(m_pFuzzLib)
		delete m_pFuzzLib;
	if(m_pFuzz)
		delete m_pFuzz;
	for(i=0; i<m_dwNumLayers; i++)
		SAFE_RELEASE(m_pVolTexture[i]);
	SAFE_RELEASE(m_pTexture);
	SAFE_RELEASE(m_pHairLightingTexture);
}

//-----------------------------------------------------------------------------
// Name: InitFuzz
// Desc: Initializes the individual strands of fuzz in the patch.
//       Only a small number of individual fuzzes are generated
//       (determined by m_dwNumFuzzLib) because each one in the patch
//       does not need to be unique.
//-----------------------------------------------------------------------------
void CXFPatch::InitFuzz(DWORD nfuzz, DWORD nfuzzlib)
{
	DWORD i;
	float y;

	if(nfuzz<=0 || nfuzzlib<0)
		return;
		
	// handle memory allocation
	if(m_dwNumFuzz!=nfuzz)				// if nfuzz has changed
	{
		if(m_pFuzz)
			delete m_pFuzz;				// nuke existing
		m_pFuzz = new SFuzzInst[nfuzz];	// and get new fuzz memory
	}

	if(m_dwNumFuzzLib!=nfuzzlib)
	{
		if(m_pFuzzLib)
			delete m_pFuzzLib;

		m_pFuzzLib = new SFuzz[nfuzzlib];
	}

	m_dwNumFuzz = nfuzz;
	m_dwNumFuzzLib = nfuzzlib;

	// generate the individual fuzzes in the library
	m_fYSize = 0.0f;
	srand(m_dwSeed);
	for(i=0; i<m_dwNumFuzzLib; i++)
	{
		m_pFuzzLib[i].dp.x = (m_fuzzCenter.dp.x + m_fuzzRandom.dp.x*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].dp.y = (m_fuzzCenter.dp.y + m_fuzzRandom.dp.y*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].dp.z = (m_fuzzCenter.dp.z + m_fuzzRandom.dp.z*(2*frand(1.0f)-1.0f))*g_fOneInch;

		m_pFuzzLib[i].ddp.x = (m_fuzzCenter.ddp.x + m_fuzzRandom.ddp.x*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].ddp.y = (m_fuzzCenter.ddp.y + m_fuzzRandom.ddp.y*(2*frand(1.0f)-1.0f))*g_fOneInch;
		m_pFuzzLib[i].ddp.z = (m_fuzzCenter.ddp.z + m_fuzzRandom.ddp.z*(2*frand(1.0f)-1.0f))*g_fOneInch;

		m_pFuzzLib[i].colorBase = m_fuzzCenter.colorBase + (2*frand(1.f)-1.f)*m_fuzzRandom.colorBase;
		m_pFuzzLib[i].colorTip = m_fuzzCenter.colorTip + (2*frand(1.f)-1.f)*m_fuzzRandom.colorTip;

		y = m_pFuzzLib[i].dp.y + 0.5f*m_pFuzzLib[i].ddp.y;
		if(y>m_fYSize)
			m_fYSize = y;
	}

 	// initialize the fuzz locations & pick a random fuzz from the library
	srand(m_dwSeed*54795);
	for(i=0; i<m_dwNumFuzz; i++)
	{
		m_pFuzz[i].x = (frand(1.0f)-0.5f)*m_fXSize;
		m_pFuzz[i].z = (frand(1.0f)-0.5f)*m_fZSize;
		m_pFuzz[i].lidx = irand(m_dwNumFuzzLib);
	}
}

//-----------------------------------------------------------------------------
// Name: GenVolume
// Desc: Generate the fuzz volume. This is done by 'growing' a fuzz 
//       through several layers of texture (determined by nlayers)
//       and 'splatting' it in to the relevant layer with the proper alpha.
//       This is done in two stages at present. The first stage builds
//       a floating point 'volume' of rgb and alpha. The next stage
//       puts the proper values into our texture layers.
//-----------------------------------------------------------------------------
void CXFPatch::GenVolume(DWORD nlayers, DWORD volxsize, DWORD volzsize)
{
#define USE_HW 1
#define DRAW_LOWEST_LOD 1
#if !USE_HW
	float x0, y0, z0;
	float dx, dy, dz;
	float ddx, ddy, ddz;
	float step, cp, scalex, scaley, scalez;
	DWORD b, i, j, lidx, *tex;
	DWORD x, y, z, idx, dwcolor;
	D3DXVECTOR4 *vlayer;
	D3DVECTOR v, color;
	D3DLOCKED_RECT lr;
	float nsplotch;
#ifdef _XBOX
	Swizzler *swiz;
#endif
#endif
	FVFT_XYZRHWTEX1 quad[4*sizeof(FVFT_XYZRHWTEX1)] =
	{
		{0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f},
		{(float)volxsize, 0.0f, 1.0f, 1.0f, 1.0f, 0.0f},
		{0.0f, (float)volzsize, 1.0f, 1.0f, 0.0f, 1.0f},
		{(float)volxsize, (float)volzsize, 1.0f, 1.0f, 1.0f, 1.0f}
	};

	// make sure volume info is up to date
	if(m_dwVolXSize!=volxsize || m_dwVolZSize!=volzsize)
	{
		for(UINT i=0; i<m_dwNumLayers; i++)
		{
			if(m_pVolTexture[i])
				m_pVolTexture[i]->Release();
			m_pVolTexture[i] = NULL;
		}
		
		if(m_pTexture)
			m_pTexture->Release();
		m_pTexture = NULL;
		m_dwNumLayers = 0;

		if(m_pFinTexture)
			m_pFinTexture->Release();
		m_pFinTexture = NULL;
	}

	m_dwVolXSize = volxsize;
	m_dwVolZSize = volzsize;
	m_dwVolSize = volxsize*volzsize;

	// create textures if necessary
	DWORD finWidth = 256; // 512; // volxsize; /* TODO: add parameters for fin texture size */
	DWORD finHeight = volzsize;
	if(m_dwNumLayers!=nlayers)
	{
		UINT i;

		// create new layers
		for(i=0; i<nlayers; i++)
			if(!m_pVolTexture[i])
				g_pd3dDevice->CreateTexture(volxsize, volzsize, 0, 0, D3DFMT_A8R8G8B8, 0, &m_pVolTexture[i]);

		// release unused layers
		for(i=nlayers; i<m_dwNumLayers; i++)
		{
			if (m_pVolTexture[i])
			{
				m_pVolTexture[i]->Release();
				m_pVolTexture[i] = NULL;
			}
		}

		// create lowest LOD texture
		if (m_pTexture) m_pTexture->Release();
		g_pd3dDevice->CreateTexture(volxsize, volzsize, 0, 0, D3DFMT_A8R8G8B8, 0, &m_pTexture);
		
		// Create fin texture
		g_pd3dDevice->CreateTexture(finWidth, finHeight, 0, 0, D3DFMT_A8R8G8B8, 0, &m_pFinTexture);
	}
	m_dwNumLayers = nlayers;

#if USE_HW
	// Render into volume slices
	{
		// save current back buffer, z buffer, and transforms
		struct {
			IDirect3DSurface8 *pBackBuffer, *pZBuffer;
			D3DMATRIX matWorld, matView, matProjection;
		} save;
		g_pd3dDevice->GetRenderTarget(&save.pBackBuffer);
		g_pd3dDevice->GetDepthStencilSurface(&save.pZBuffer);
		g_pd3dDevice->GetTransform( D3DTS_WORLD, &save.matWorld);
		g_pd3dDevice->GetTransform( D3DTS_VIEW, &save.matView);
		g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &save.matProjection);
		// make a new depth buffer
		IDirect3DSurface8 *pZBuffer = NULL;
		g_pd3dDevice->CreateDepthStencilSurface(volxsize, volzsize, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pZBuffer);
#if 0
		// compute bounds of fuzz patch
		D3DXVECTOR3 va, vb;
		{
			DWORD i, j, lidx;
			float x0, y0, z0;
			float dx, dy, dz;
			float ddx, ddy, ddz;
			float step, cp;
			UINT startseg = 0;
			step = 1.0f/(float)m_dwNumSegments;
			// init bound from first fuzz
			D3DXVECTOR3 v(m_pFuzz[0].x, 0.f, m_pFuzz[0].z);
			va = vb = v;
			for(i=0; i<m_dwNumFuzz; i++)
			{
				// get location and index from fuzz instances
				lidx = m_pFuzz[i].lidx;
				x0 = m_pFuzz[i].x;
				y0 = 0.0f;
				z0 = m_pFuzz[i].z;

				// get params from fuzz lib
				dx = m_pFuzzLib[lidx].dp.x;
				dy = m_pFuzzLib[lidx].dp.y;
				dz = m_pFuzzLib[lidx].dp.z;
				ddx = m_pFuzzLib[lidx].ddp.x;
				ddy = m_pFuzzLib[lidx].ddp.y;
				ddz = m_pFuzzLib[lidx].ddp.z;

				// compute line points
				cp = (float)startseg*step;
				for(j=startseg; j<=m_dwNumSegments; j++)
				{
					v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
					v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
					v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
					D3DXVec3Minimize(&va, &va, &v);
					D3DXVec3Maximize(&vb, &vb, &v);
					cp += step;
				}
			}
		}
#else
		D3DXVECTOR3 va(-0.5f*m_fXSize, 0.f, -0.5f*m_fZSize), vb(0.5f*m_fXSize, m_fYSize, 0.5f*m_fZSize); // bounds of fuzz patch
#endif
		D3DXVECTOR3 vwidth(vb-va), vcenter(0.5f*(vb+va)); // width and center of fuzz patch
		// set world transformation to scale model to unit cube [-1,1] in all dimensions
		D3DXMATRIX matWorld, matTranslate, matScale;
		D3DXMatrixTranslation(&matTranslate, -vcenter.x, -vcenter.y, -vcenter.z);
		D3DXMatrixScaling(&matScale, 2.f/vwidth.x, 2.f/vwidth.y, 2.f/vwidth.z);
		matWorld = matTranslate * matScale;
		g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld);
		// set view transformation to flip z and look down y axis, with bottom-most slice scaled and translated to map to [0,1]
		D3DMATRIX matView;
		matView.m[0][0] = 1.f;	matView.m[0][1] =  0.f;	matView.m[0][2] = 0.f;				matView.m[0][3] = 0.f;
		matView.m[1][0] = 0.f;	matView.m[1][1] =  0.f;	matView.m[1][2] = 0.5f * nlayers;	matView.m[1][3] = 0.f;
		matView.m[2][0] = 0.f;	matView.m[2][1] = -1.f;	matView.m[2][2] = 0.f;				matView.m[2][3] = 0.f;
		matView.m[3][0] = 0.f;	matView.m[3][1] =  0.f;	matView.m[3][2] = 0.5f * nlayers;	matView.m[3][3] = 1.f;
		// set projection matrix to orthographic
		D3DXMATRIX matProjection;
		D3DXMatrixIdentity(&matProjection);
		g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjection);
		UINT numLines = m_dwNumFuzz*m_dwNumSegments;
		IDirect3DVertexBuffer8 *pVB;
		GetLinesVertexBuffer(&pVB);
		g_pd3dDevice->SetTexture(0, NULL);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
		g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
		g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE /*FALSE*/);
		g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
		g_pd3dDevice->SetStreamSource(0, pVB, sizeof(FVFT_XYZDIFF));
		// draw each slice
		for (int i = 0/*-1*/; i < (int)nlayers; i++)
		{
			// get destination surface & set as render target, then draw the fuzz slice
			LPDIRECT3DTEXTURE8 pTexture = m_pVolTexture[i];
			IDirect3DSurface8 *pSurface;
			pTexture->GetSurfaceLevel(0, &pSurface);
			g_pd3dDevice->SetRenderTarget(pSurface, pZBuffer);
			g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, D3DCOLOR_RGBA(0,0,0,0), 1.0f, 0);
			matView.m[1][2] = 0.5f * nlayers;
			matView.m[3][2] = 0.5f * nlayers - (float)i;	// offset to next slice
			// We want the texture to wrap, so draw multiple times with offsets in the plane so that 
			// the boundaries will be filled in by the overlapping geometry.
			for (int iX = -1; iX <= 1; iX++)
			{
				for (int iY = -1; iY <= 1; iY++)
				{
					matView.m[3][0] = 2.f * iX;
					matView.m[3][1] = 2.f * iY;
					g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView);
					g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
				}
			}
			pSurface->Release();
			GenerateMipmaps(pTexture, 0);
		}

#if DRAW_LOWEST_LOD
		// draw all the hairs into the lowest LOD texture
		{
			// get destination surface & set as render target, then draw the fuzz slice
			LPDIRECT3DTEXTURE8 pTexture = m_pTexture;
			IDirect3DSurface8 *pSurface;
			pTexture->GetSurfaceLevel(0, &pSurface);
			g_pd3dDevice->SetRenderTarget(pSurface, pZBuffer);
			g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_RGBA(0,0,0,0), 1.0f, 0);
			// scale and translate to cover whole z range [0,1]
			matView.m[1][2] = 0.5f; // 4.f
			matView.m[3][2] = 0.5f; // 4.f;
			// We want the texture to wrap, so draw multiple times with offsets in the plane so that 
			// the boundaries will be filled in by the overlapping geometry.
			for (int iX = -1; iX <= 1; iX++)
			{
				for (int iY = -1; iY <= 1; iY++)
				{
					matView.m[3][0] = 2.f * iX;
					matView.m[3][1] = 2.f * iY;
					g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView);
					g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
				}
			}
			pSurface->Release();
			GenerateMipmaps(pTexture, 0);
		}
#endif		

#if 1
		// draw fuzz into the fin texture, looking from the side
		{
			LPDIRECT3DTEXTURE8 pTexture = m_pFinTexture;
			IDirect3DSurface8 *pSurface;
			pTexture->GetSurfaceLevel(0, &pSurface);
			if (finWidth != volxsize
				|| finHeight != volzsize)
			{
				// make a zbuffer that's the right size for the render target.  TODO: do we even need a zbuffer?
				pZBuffer->Release();
				g_pd3dDevice->CreateDepthStencilSurface(finWidth, finHeight, D3DFMT_LIN_D24S8, D3DMULTISAMPLE_NONE, &pZBuffer);
			}
			g_pd3dDevice->SetRenderTarget(pSurface, pZBuffer);
			g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_RGBA(0,0,0,0), 1.0f, 0);
			// set view transformation to look down z axis, with z range [0,1]
			float fXFraction = 0.25f;
			float fYFraction = 1.f;
			float fZFraction = 0.05f;
			float fXScale = 1.f / fXFraction;
			float fYScale = 1.f / fYFraction;
			float fZScale = 1.f / fZFraction;
			matView.m[0][0] = fXScale;	matView.m[0][1] =  0.f;		matView.m[0][2] = 0.f;				matView.m[0][3] = 0.f;
			matView.m[1][0] = 0.f;		matView.m[1][1] =  fYScale;	matView.m[1][2] = 0.f;				matView.m[1][3] = 0.f;
			matView.m[2][0] = 0.f;		matView.m[2][1] =  0.f;		matView.m[2][2] = 0.5f * fZScale;	matView.m[2][3] = 0.f;
			matView.m[3][0] = 0.f;		matView.m[3][1] =  0.f;		matView.m[3][2] = 0.5f * fZScale;	matView.m[3][3] = 1.f;
			g_pd3dDevice->SetTransform( D3DTS_VIEW, &matView);
			g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
			pSurface->Release();
			GenerateMipmaps(pTexture, 0, D3DTADDRESS_WRAP, D3DTADDRESS_CLAMP);
		}
#endif		

		pVB->Release();
		pZBuffer->Release();
		// restore back and z buffer and transforms
		g_pd3dDevice->SetRenderTarget(save.pBackBuffer, save.pZBuffer);
		save.pBackBuffer->Release();
		save.pZBuffer->Release();
		g_pd3dDevice->SetTransform( D3DTS_WORLD, &save.matWorld);
		g_pd3dDevice->SetTransform( D3DTS_VIEW, &save.matView);
		g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &save.matProjection);
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
		g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	}
#else

	// now splat into volume texture
	D3DXVECTOR4 *pVolume = NULL;					// used for generating volume
	pVolume = new D3DXVECTOR4[m_dwNumLayers*m_dwVolSize];
	memset(pVolume, 0, m_dwNumLayers*m_dwVolSize*sizeof(D3DXVECTOR4));

	nsplotch = 200;
	step = 1.0f/nsplotch;
	color = m_vFuzzColor;
	scalex = (float)m_dwVolXSize/m_fXSize;
	scaley = (float)m_dwNumLayers/m_fYSize;
	scalez = (float)m_dwVolZSize/m_fZSize;

	for(i=0; i<m_dwNumFuzz; i++)
	{
		// get location and index from fuzz instances
		lidx = m_pFuzz[i].lidx;

		x0 = m_pFuzz[i].x;		// scale source location
		y0 = 0.0f;
		z0 = m_pFuzz[i].z;		// and offset

		// get params from fuzz lib
		dx = m_pFuzzLib[lidx].dp.x;
		dy = m_pFuzzLib[lidx].dp.y;
		dz = m_pFuzzLib[lidx].dp.z;
		ddx = m_pFuzzLib[lidx].ddp.x;
		ddy = m_pFuzzLib[lidx].ddp.y;
		ddz = m_pFuzzLib[lidx].ddp.z;

		cp = 0.0f;
		for(j=0; j<nsplotch; j++)
		{
			v.x = (x0 + cp*dx + 0.5f*cp*cp*ddx) * scalex + m_dwVolXSize/2.0f;
			v.y = (y0 + cp*dy + 0.5f*cp*cp*ddy) * scaley;
			v.z = (z0 + cp*dz + 0.5f*cp*cp*ddz) * scalez + m_dwVolZSize/2.0f;
			Splat(v, 1.0f-cp, color, pVolume);					// splat into the texture
			cp += step;
		}
	}

#ifdef _XBOX
	swiz = new Swizzler(m_dwVolXSize, m_dwVolZSize, 0);
#endif

	// put the floating point volume into the textures
	for(y=0; y<m_dwNumLayers; y++)
	{
		m_pVolTexture[y]->LockRect(0, &lr, NULL, 0);	// lock this layer
		tex = (DWORD *)lr.pBits;						// get a pointer to its bits

		vlayer = &pVolume[y*m_dwVolSize];				// find ourselves in the fp volume
		idx = 0;

#ifdef _XBOX
		swiz->SetV(0);									// set swizzle v = 0
#endif
		for(z=0; z<m_dwVolZSize; z++)					// fill it
		{
#ifdef _XBOX
			swiz->SetU(0);								// set swizzle u = 0
#endif

			for(x=0; x<m_dwVolXSize; x++)
			{
				// convert to non-pre-multiplied alpha
				float w1 = 255.0f/vlayer[idx].w;

				b = (DWORD)(vlayer[idx].x*w1);
				if(b>255) b = 255;
				dwcolor = b<<16;

				b = (DWORD)(vlayer[idx].y*w1);
				if(b>255) b = 255;
				dwcolor |= b<<8;

				b = (DWORD)(vlayer[idx].z*w1);
				if(b>255) b = 255;
				dwcolor |= b;

				b = (DWORD)(vlayer[idx].w*255.0f);
				if(b>255) b = 255;
				dwcolor |= b<<24;

#ifdef _XBOX
				tex[swiz->Get2D()] = dwcolor;
				swiz->IncU();							// bump swizzle u
#else
				tex[idx] = dwcolor;
#endif
				idx++;
			}

#ifdef _XBOX
			swiz->IncV();								// bump swizzle v
#endif
		}

		m_pVolTexture[y]->UnlockRect(0);

		// have d3dx do all the mip filtering
		GenerateMipmaps(m_pVolTexture[y], 0);
	}
	
	delete pVolume;
#endif


#if !DRAW_LOWEST_LOD

	// now generate lowest lod texture by rendering 
	// the existing layers into it
	IDirect3DSurface8 *surf, *pBackBuffer, *pZBuffer;

	// get current back and z buffers
	g_pd3dDevice->GetRenderTarget(&pBackBuffer);
	g_pd3dDevice->GetDepthStencilSurface(&pZBuffer);

	// get destination surface & set as render target
	m_pTexture->GetSurfaceLevel(0, &surf);
	g_pd3dDevice->SetRenderTarget(surf, NULL);

	// set up for rendering
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_TEXTUREFACTOR, 0 /*0x00c0a070*/);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
	g_pd3dDevice->SetVertexShader(FVF_XYZRHWTEX1);

	//g_pd3dDevice->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA|D3DCOLORWRITEENABLE_RED|D3DCOLORWRITEENABLE_GREEN|D3DCOLORWRITEENABLE_BLUE);

	// render background color into the texture to clear it out
	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, quad, sizeof(FVFT_XYZRHWTEX1));

	// set up for alpha blending
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	//g_pd3dDevice->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA);	// just alpha

	for(y=0; y<m_dwNumLayers; y++)
	{
		// render it
		g_pd3dDevice->SetTexture(0, m_pVolTexture[y]);
		g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, quad, sizeof(FVFT_XYZRHWTEX1));
	}

	// release destination surface
	surf->Release();

	// restore original render states
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderTarget(pBackBuffer, pZBuffer);
	pBackBuffer->Release();
	pZBuffer->Release();

	// have d3dx do all the mip filtering
	GenerateMipmaps(m_pTexture, 0);
#endif
}

//-----------------------------------------------------------------------------
// Name: Splat
// Desc: Splat a fuzz into the texture. This function attempts to take
//       a very small 'sphere' and splat it into our texture volume by
//       specifying an rgb color and alpha. 
//-----------------------------------------------------------------------------
void CXFPatch::Splat(D3DVECTOR p, float falpha, D3DVECTOR fcolor, D3DXVECTOR4 *pVolume)
{
	D3DVECTOR pmin, pmax;
	float dx, dy, dz;
	float yscale;
	DWORD idx;
	int x0, x1, y0, y1, z0, z1;
	int x, y, z, xx, zz;
	float r2, e;
	float cx, cy, cz;
	D3DXVECTOR4 *vlayer;

	float fscale = ((float)m_dwVolXSize+(float)m_dwVolZSize)/1024.0f;
	yscale = 1.0f/m_dwNumLayers;

	// find region of pixels covered by point
	pmin.x = p.x - 2.0f*fscale;
	pmin.y = p.y - 2.0f*fscale;
	pmin.z = p.z - 2.0f*fscale;
	pmax.x = p.x + 2.0f*fscale;
	pmax.y = p.y + 2.0f*fscale;
	pmax.z = p.z + 2.0f*fscale;

	// make sure level in range
	if(pmax.y<0.0f || pmin.y>m_dwNumLayers)
		return;

	// find range of points that this splat touches
	x0 = (int)floor(pmin.x);
	y0 = (int)floor(pmin.y);
	z0 = (int)floor(pmin.z);
	x1 = (int)ceil(pmax.x);
	y1 = (int)ceil(pmax.y);
	z1 = (int)ceil(pmax.z);

	// splat into volume
	for(y=y0; y<y1; y++)
	{
		if(y<0)
			continue;
		if(y>=(int)m_dwNumLayers)
			continue;

		vlayer = &pVolume[y*m_dwVolSize];

		for(z=z0; z<z1; z++)
		{
			for(x=x0; x<=x1; x++)
			{
				dx = (float)x-p.x;
				dy = ((float)y-p.y); // *yscale;
				dz = (float)z-p.z;
				r2 = dx*dx + dy*dy + dz*dz;
				e = r2/(fscale*fscale);
				if(e>15.0)
					continue;

				// Wrap pixel coordinates
				xx = x & (m_dwVolXSize-1);
				zz = z & (m_dwVolZSize-1);

				// calc color contribution
				e = falpha * expf(-e);
				cx = fcolor.x*e;
				cy = fcolor.y*e;
				cz = fcolor.z*e;

				// add into volume
				idx = zz*m_dwVolXSize+xx;
				vlayer[idx].x += cx;
				vlayer[idx].y += cy;
				vlayer[idx].z += cz;
				vlayer[idx].w += e;
			}
		}
	}
}

//-----------------------------------------------------------------------------
// Desc: File routines for saving and loading patch files.
//       Saving is only relevant if used on a Windows platform.
//-----------------------------------------------------------------------------
struct _fphdr
{
	char sig[5];
	int flags;
};

void CXFPatch::Save(char *fname, int flags)
{
	FILE *fp;
	struct _fphdr hdr;

	fp = fopen(fname, "wb");

	// write file header
	strcpy(hdr.sig, "FUZ2");
	hdr.flags = flags;
	fwrite(&hdr, sizeof(struct _fphdr), 1, fp);

	// write fpatch data
	fwrite(&m_dwSeed, sizeof(DWORD), 1, fp);
	
	fwrite(&m_fXSize, sizeof(float), 1, fp);
	fwrite(&m_fYSize, sizeof(float), 1, fp);
	fwrite(&m_fZSize, sizeof(float), 1, fp);

	fwrite(&m_dwNumSegments, sizeof(DWORD), 1, fp);
	fwrite(&m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), 1, fp);
	fwrite(&m_fuzzRandom.colorBase, sizeof(D3DXCOLOR), 1, fp);
	fwrite(&m_fuzzCenter.colorTip, sizeof(D3DXCOLOR), 1, fp);
	fwrite(&m_fuzzRandom.colorTip, sizeof(D3DXCOLOR), 1, fp);
	
	fwrite(&m_fuzzCenter.dp, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_fuzzRandom.dp, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_fuzzCenter.ddp, sizeof(D3DVECTOR), 1, fp);
	fwrite(&m_fuzzRandom.ddp, sizeof(D3DVECTOR), 1, fp);

	fwrite(&m_dwNumFuzzLib, sizeof(DWORD), 1, fp);
	fwrite(&m_dwNumFuzz, sizeof(DWORD), 1, fp);

	fwrite(&m_dwNumLayers, sizeof(DWORD), 1, fp);
	fwrite(&m_dwVolXSize, sizeof(DWORD), 1, fp);
	fwrite(&m_dwVolZSize, sizeof(DWORD), 1, fp);

	// write volume data if available and flag is set
	{
	}

	fclose(fp);
}

void CXFPatch::Load(char *fname)
{
	FILE *fp;
	struct _fphdr hdr;
	DWORD numfuzzlib, numfuzz;
	DWORD numlayers, volxsize, volzsize;

	fp = fopen(fname, "rb");
	if(!fp)
		return;

	// read file header
	fread(&hdr, sizeof(struct _fphdr), 1, fp);

	// verify signature
	bool bFUZ1 = !strcmp(hdr.sig, "FUZ1");
	bool bFUZ2 = !strcmp(hdr.sig, "FUZ2");
	if (!bFUZ1 && !bFUZ2)
		return;	// signature not understood

	// read patch data
	fread(&m_dwSeed, sizeof(DWORD), 1, fp);
	
	fread(&m_fXSize, sizeof(float), 1, fp);
	fread(&m_fYSize, sizeof(float), 1, fp);
	fread(&m_fZSize, sizeof(float), 1, fp);

	fread(&m_dwNumSegments, sizeof(DWORD), 1, fp);
	if (bFUZ1)
	{
		fread(&m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), 1, fp);
		m_fuzzCenter.colorTip = m_fuzzCenter.colorBase;
		m_fuzzRandom.colorBase = m_fuzzRandom.colorTip = 0ul;
	}
	else
	{
		fread(&m_fuzzCenter.colorBase, sizeof(D3DXCOLOR), 1, fp);
		fread(&m_fuzzRandom.colorBase, sizeof(D3DXCOLOR), 1, fp);
		fread(&m_fuzzCenter.colorTip, sizeof(D3DXCOLOR), 1, fp);
		fread(&m_fuzzRandom.colorTip, sizeof(D3DXCOLOR), 1, fp);
	}

	fread(&m_fuzzCenter.dp, sizeof(D3DVECTOR), 1, fp);	// velocity center
	fread(&m_fuzzRandom.dp, sizeof(D3DVECTOR), 1, fp);	// velocity random
	fread(&m_fuzzCenter.ddp, sizeof(D3DVECTOR), 1, fp);	// acceleration center
	fread(&m_fuzzRandom.ddp, sizeof(D3DVECTOR), 1, fp);	// acceleration random

	fread(&numfuzzlib, sizeof(DWORD), 1, fp);
	fread(&numfuzz, sizeof(DWORD), 1, fp);

	fread(&numlayers, sizeof(DWORD), 1, fp);
	fread(&volxsize, sizeof(DWORD), 1, fp);
	fread(&volzsize, sizeof(DWORD), 1, fp);

	// read volume data if available and flag is set
	{
	}

	fclose(fp);

	InitFuzz(numfuzz, numfuzzlib);
	GenVolume(numlayers, volxsize, volzsize);
}

//////////////////////////////////////////////////////////////////////
// Lighting Model
//////////////////////////////////////////////////////////////////////

inline float
Luminance(const D3DXCOLOR &c)
{
    return (0.229f * c.r) + (0.587f * c.g) + (0.114f * c.b);
}

inline float
MaxChannel(const D3DXCOLOR &c)
{
	if (c.r > c.g)
	{
		if (c.r > c.b)
			return c.r;
		else
			return c.b;
	}
	else
	{
		if (c.g > c.b)
			return c.g;
		else
			return c.b;
	}
}

inline D3DXCOLOR 
Lerp(const D3DXCOLOR &c1, const D3DXCOLOR &c2, float s)
{
    return c1 + s * (c2 - c1);
}

inline D3DXCOLOR
Desaturate(const D3DXCOLOR &rgba)
{
    float alpha = rgba.a;
    if (alpha > 1.f)
        alpha = 1.f;
    float fMaxChan = MaxChannel(rgba);
    if (fMaxChan > alpha) 
    {
        D3DXCOLOR rgbGray(alpha, alpha, alpha, alpha);
        float fYOld = Luminance(rgba);
        if (fYOld >= alpha)
            return rgbGray;
        // scale color to preserve hue
        D3DXCOLOR rgbNew;
        float fInvMaxChan = 1.f / fMaxChan;
        rgbNew.r = rgba.r * fInvMaxChan;
        rgbNew.g = rgba.g * fInvMaxChan;
        rgbNew.b = rgba.b * fInvMaxChan;
		rgbNew.a = alpha;
        float fYNew = Luminance(rgbNew);
        // add gray to preserve luminance
        return Lerp(rgbNew, rgbGray, (fYOld - fYNew) / (alpha - fYNew));
    }
    return rgba;
}

inline D3DXCOLOR &operator *=(D3DXCOLOR &p, const D3DXCOLOR &q)
{
	p.r *= q.r;
	p.g *= q.g;
	p.b *= q.b;
	p.a *= q.a;
	return p;
}

inline D3DXCOLOR operator *(const D3DXCOLOR &p, const D3DXCOLOR &q)
{
	D3DXCOLOR r;
	r.r = p.r * q.r;
	r.g = p.g * q.g;
	r.b = p.b * q.b;
	r.a = p.a * q.a;
	return r;
}

//-----------------------------------------------------------------------------
//  CHairLighting
//-----------------------------------------------------------------------------
struct CHairLighting {
	// like D3DMATERIAL8, except populated with D3DXCOLOR's so that color arithmetic works
	D3DXCOLOR m_colorDiffuse;
	D3DXCOLOR m_colorSpecular;
	float m_fSpecularExponent;
	D3DXCOLOR m_colorAmbient;
	D3DXCOLOR m_colorEmissive;

	HRESULT Initialize(LPDIRECT3DDEVICE8 pDevice, D3DMATERIAL8 *pMaterial);
	HRESULT CalculateColor(D3DXCOLOR *pColor, float LT, float HT);
	HRESULT CalculateClampedColor(D3DXCOLOR *pColor, float LT, float HT);
	
	static HRESULT FillTexture(D3DMATERIAL8 *pMaterial, LPDIRECT3DTEXTURE8 pTexture);
};

HRESULT CHairLighting::Initialize(LPDIRECT3DDEVICE8 pDevice, D3DMATERIAL8 *pMaterial)
{
	// Get current colors modulated by light 0 and global ambient
	// ignore current alphas
	m_colorDiffuse = D3DXCOLOR(pMaterial->Diffuse.r, pMaterial->Diffuse.g, pMaterial->Diffuse.b, 1.f);
	m_colorSpecular = D3DXCOLOR(pMaterial->Specular.r, pMaterial->Specular.g, pMaterial->Specular.b, 1.f);
	m_fSpecularExponent = pMaterial->Power;
	m_colorAmbient = D3DXCOLOR(pMaterial->Ambient.r, pMaterial->Ambient.g, pMaterial->Ambient.b, 1.f);
	m_colorEmissive = D3DXCOLOR(pMaterial->Emissive.r, pMaterial->Emissive.g, pMaterial->Emissive.b, 1.f);
#if 0
	D3DLIGHT8 light;
	(void)pDevice->GetLight(0, &light);		
	D3DXCOLOR colorLightSpecular(light.Specular.r, light.Specular.g, light.Specular.b, 1.f);
	D3DXCOLOR colorLightDiffuse(light.Diffuse.r, light.Diffuse.g, light.Diffuse.b, 1.f);
	D3DXCOLOR colorLightAmbient(light.Ambient.r, light.Ambient.g, light.Ambient.b, 1.f);
	D3DCOLOR dcGlobalAmbient;
	(void)pDevice->GetRenderState(D3DRS_AMBIENT, &dcGlobalAmbient);
	D3DXCOLOR colorGlobalAmbient(dcGlobalAmbient);
	colorGlobalAmbient.a = 1.f;
	m_colorSpecular *= colorLightSpecular;
	m_colorDiffuse *= colorLightDiffuse;
	m_colorAmbient *= colorLightAmbient;
	m_colorEmissive += colorLightAmbient * colorGlobalAmbient;	// why do we add this term?
#endif
	return S_OK;
}

/* Zockler et al's technique worked with streamlines, and used dot(V,T) instead of the simpler dot(H,T) */
#define ZOCKLER 0 
#if ZOCKLER

HRESULT CHairLighting::CalculateColor(D3DXCOLOR *pColor, float LT, float VT)
{
	// Zockler et al 1996
	float fDiffuseExponent = 2.f;	// Banks used 4.8
	float fDiffuse = powf(sqrtf(1.f - LT*LT), fDiffuseExponent);
	float VR = LT*VT - sqrtf(1.f - LT*LT) * sqrtf(1.f - VT*VT);
	float fSpecular = powf(VR, m_fSpecularExponent);
	*pColor = m_colorEmissive + m_colorAmbient + fSpecular * m_colorSpecular + fDiffuse * m_colorDiffuse;
	return S_OK;
}

#else

HRESULT CHairLighting::CalculateColor(D3DXCOLOR *pColor, float LT, float HT)
{
	float fDiffuseExponent = 2.f;	// Banks used 4.8
	float fDiffuse = powf(sqrtf(1.f - LT*LT), fDiffuseExponent);
	float fSpecular = powf(sqrtf(1.f - HT*HT), m_fSpecularExponent);
	*pColor = m_colorEmissive + m_colorAmbient + fSpecular * m_colorSpecular + fDiffuse * m_colorDiffuse;
	return S_OK;
}

#endif

HRESULT CHairLighting::CalculateClampedColor(D3DXCOLOR *pColor, float LT, float HT)
{
	D3DXCOLOR color;
	HRESULT hr = CalculateColor(&color, LT, HT);
	*pColor = Desaturate(color);	// bring back to 0,1 range
	return hr;
}

//////////////////////////////////////////////////////////////////////
// 
// Fill the hair lighting lookup-table texture
// 
//////////////////////////////////////////////////////////////////////
HRESULT CHairLighting::FillTexture(D3DMATERIAL8 *pMaterial, LPDIRECT3DTEXTURE8 pTexture)
{
	/* 
	The hair lighting texture maps U as the dot product of the hair
	tangent T with the light direction L and maps V as the dot product
	of the tangent with the half vector H.  Since the lighting is a
	maximum when the tangent is perpendicular to L (or H), the maximum
	is at zero.  The minimum is at 0.5, 0.5 (or -0.5, -0.5, since
	wrapping is turned on.)  For the mapped T.H, we raise the map
	value to a specular power.
	*/
	HRESULT hr;
	D3DSURFACE_DESC desc;
	pTexture->GetLevelDesc(0, &desc);
	if (desc.Format != D3DFMT_A8R8G8B8)
		return E_NOTIMPL;
	DWORD dwPixelStride = 4;
	D3DLOCKED_RECT lockedRect;
	hr = pTexture->LockRect(0, &lockedRect, NULL, 0L);
	if (FAILED(hr))
		return hr;
	CHairLighting lighting;
	lighting.Initialize(g_pd3dDevice, pMaterial);
	Swizzler s(desc.Width, desc.Height, 0);
	s.SetV(s.SwizzleV(0));
	s.SetU(s.SwizzleU(0));
	for (UINT v = 0; v < desc.Height; v++)
	{
		for (UINT u = 0; u < desc.Width; u++)
		{
			BYTE *p = (BYTE *)lockedRect.pBits + dwPixelStride * s.Get2D();
			// vertical is specular lighting
			// horizontal is diffuse lighting
			D3DXCOLOR color;
#if ZOCKLER
			// Zockler et al 1996
			float LT = 2.f * u / desc.Width - 1.0f;
			float VT = 2.f * v / desc.Height - 1.0f;
			lighting.CalculateClampedColor(&color, LT, VT);
#else
			float LT = 2.f * u / desc.Width;
			if (LT > 1.f) LT -= 2.f;
			float HT = 2.f * v / desc.Height;
			if (HT > 1.f) HT -= 2.f;
			lighting.CalculateClampedColor(&color, LT, HT);
#endif
			int r, g, b;
			r = (BYTE)(255 * color.r);
			g = (BYTE)(255 * color.g);
			b = (BYTE)(255 * color.b);
			*p++ = (BYTE)b;
			*p++ = (BYTE)g;
			*p++ = (BYTE)r;
			*p++ = 255;	// alpha
			s.IncU();
		}
		s.IncV();
	}
	pTexture->UnlockRect(0);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SetHairLightingMaterial
// Desc: Create and fill the hair lighting texture
//-----------------------------------------------------------------------------
HRESULT CXFPatch::SetHairLightingMaterial(D3DMATERIAL8 *pMaterial)
{
	// Create and fill the hair lighting texture
	HRESULT hr;
	m_HairLightingMaterial = *pMaterial;
	if (!m_pHairLightingTexture)
	{
		DWORD dwFlags = 0;
		DWORD dwWidth = 128;
		DWORD dwHeight = 128;
		D3DFORMAT surfaceFormat = D3DFMT_A8R8G8B8;
		DWORD nMipMap = 1;
		hr = D3DXCreateTexture(g_pd3dDevice, dwWidth, dwHeight, nMipMap, 0, surfaceFormat, 0, &m_pHairLightingTexture);
		if (FAILED(hr)) goto e_Exit;
	}
	hr = CHairLighting::FillTexture(pMaterial, m_pHairLightingTexture);
	if (FAILED(hr)) goto e_Exit;
e_Exit:
	if (FAILED(hr))
		SAFE_RELEASE(m_pHairLightingTexture);
	return hr;
}


//-----------------------------------------------------------------------------
// Name: GetLinesVertexBuffer
// Desc: Create and fill in a vertex buffer as a series of individual lines from the fuzz library.
//-----------------------------------------------------------------------------
void CXFPatch::GetLinesVertexBuffer(IDirect3DVertexBuffer8 **ppVB)
{
	IDirect3DVertexBuffer8 *pVB;
	UINT numVertices = m_dwNumFuzz*m_dwNumSegments*2;
	g_pd3dDevice->CreateVertexBuffer(numVertices*sizeof(FVFT_XYZDIFF), 0, FVF_XYZDIFF, 0, &pVB);
	assert(pVB!=NULL);
	DWORD i, j, vidx, lidx;
	DWORD alpha0 = 128;
	FVFT_XYZDIFF *verts;
	float x0, y0, z0;
	float dx, dy, dz;
	float ddx, ddy, ddz;
	float step, cp;
	UINT startseg = 0;
	step = 1.0f/(float)m_dwNumSegments;
	pVB->Lock(0, numVertices*sizeof(FVFT_XYZDIFF), (BYTE **)&verts, 0);
	vidx = 0;
	D3DXCOLOR colorBase, colorDelta;
	for(i=0; i<m_dwNumFuzz; i++)
	{
		// get location and index from fuzz instances
		lidx = m_pFuzz[i].lidx;
		x0 = m_pFuzz[i].x;
		y0 = 0.0f;
		z0 = m_pFuzz[i].z;

		// get params from fuzz lib
		dx = m_pFuzzLib[lidx].dp.x;
		dy = m_pFuzzLib[lidx].dp.y;
		dz = m_pFuzzLib[lidx].dp.z;
		ddx = m_pFuzzLib[lidx].ddp.x;
		ddy = m_pFuzzLib[lidx].ddp.y;
		ddz = m_pFuzzLib[lidx].ddp.z;
		colorBase = m_pFuzzLib[lidx].colorBase;
		colorDelta = m_pFuzzLib[lidx].colorTip - colorBase;

		// build linelist
		cp = (float)startseg*step;

		for(j=startseg; j<m_dwNumSegments; j++)
		{
			verts[vidx].v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
			verts[vidx].v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
			verts[vidx].v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
			verts[vidx].diff = colorBase + cp * cp * colorDelta;
			vidx++;
			cp += step;

			verts[vidx].v.x = x0 + cp*dx + 0.5f*cp*cp*ddx;
			verts[vidx].v.y = y0 + cp*dy + 0.5f*cp*cp*ddy;
			verts[vidx].v.z = z0 + cp*dz + 0.5f*cp*cp*ddz;
			verts[vidx].diff = colorBase + cp * cp * colorDelta;
			vidx++;
		}
	}
	pVB->Unlock();
	*ppVB = pVB;
}

//-----------------------------------------------------------------------------
// Name: RenderLines
// Desc: Draw the fuzz patch as a series of individual lines.
//-----------------------------------------------------------------------------
void CXFPatch::RenderLines()
{
	UINT numLines = m_dwNumFuzz*m_dwNumSegments;
	IDirect3DVertexBuffer8 *pVB;
	GetLinesVertexBuffer(&pVB);
	g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
	g_pd3dDevice->SetVertexShader(FVF_XYZDIFF);
	g_pd3dDevice->SetStreamSource(0, pVB, sizeof(FVFT_XYZDIFF));
	g_pd3dDevice->DrawPrimitive(D3DPT_LINELIST, 0, numLines);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	pVB->Release();
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Draw the fuzz patch as layers of texture
//       lod varies from 0 to 1 where 1 = highest LOD (most detail)
//       and 0 = lowest LOD (least detail)
//-----------------------------------------------------------------------------
void CXFPatch::Render(float lod, CXFPatchMesh *pmesh)
{
	DWORD i, lflag;
	// if lod==1.0f render the individual fuzzes
	if(lod==1.0f)
	{
		RenderLines();
		return;
	}

	DWORD iTexStage;
	extern bool g_bMultiShell;

	// Set up volume texture state.  The texture is set per-shell below.
	DWORD iTexStageVolumeTexture = 0;
	iTexStage= 0;
	//g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAKILL, D3DTALPHAKILL_ENABLE );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_TEXCOORDINDEX, 0);
	extern DWORD g_iCOLOROP1;
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_COLOROP, g_iCOLOROP1);
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->GetRenderState(D3DRS_LIGHTING, &lflag);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	static DWORD dwAlphaRef = 0;
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAREF, dwAlphaRef);

	// Set up hair lighting texture state
	iTexStage = 1;
	g_pd3dDevice->SetTexture( iTexStage, m_pHairLightingTexture);
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_TEXCOORDINDEX, 1);
#if ZOCKLER
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ADDRESSU, D3DTADDRESS_MIRROR );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ADDRESSV, D3DTADDRESS_MIRROR );
#else
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
#endif
	extern DWORD g_iCOLOROP2;
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_COLOROP, g_iCOLOROP2);
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_COLORARG2, D3DTA_CURRENT );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
	g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );

	{
		// Default disables the 2 and 3 stages
		g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
	}
	
	
	// VERTEX SHADER SETUP
#define VSC_OFFSET 12
#define VSC_EYE 13
#define VSC_LIGHT 14
#define VSC_HALF 15 /* used only for directional lighting */
#define VSC_DIFFUSE 16
#define VSC_AMBIENT 17
#define VSC_SELFSHADOW 18
#define VSC_MULTISHELL 19
#define VSC_WIND1 20
#define VSC_WIND2 21
#define VSC_WIND3 22

	// set display matrix
	D3DXMATRIX matWorldView;
	D3DXMatrixMultiply(&matWorldView, &g_matWorld, &g_matView);
	D3DXMatrixMultiply(&g_matDisplay, &matWorldView, &g_matProj);
	D3DXMatrixTranspose(&g_matDisplay, &g_matDisplay);
	g_pd3dDevice->SetVertexShaderConstant(0, &g_matDisplay, 4);

	// set vertex shader light and eye positions in object coords
	D3DXMATRIX matWorldInverse;
	D3DXMatrixInverse(&matWorldInverse, NULL, &g_matWorld);
	D3DXVECTOR4 vEye;
	D3DXVec3TransformCoord((D3DXVECTOR3 *)&vEye, &g_EyePos, &matWorldInverse);
	vEye.w = 1.f;
	D3DXVECTOR4 vLight;
	D3DXVec3TransformCoord((D3DXVECTOR3 *)&vLight, &g_LightPos, &matWorldInverse);
	vLight.w = 1.f;
	extern bool g_bLocalLighting;	// DEBUG
	if (!g_bLocalLighting)
	{
		// directional lighting
		extern D3DXVECTOR3 g_vLookAt;
		D3DXVECTOR4 vAt;
		D3DXVec3TransformCoord((D3DXVECTOR3 *)&vAt, &g_vLookAt, &matWorldInverse);
		vAt.w = 1.f;
		vEye -= vAt;
		D3DXVec4Normalize(&vEye, &vEye);
		vLight -= vAt;
		D3DXVec4Normalize(&vLight, &vLight);
		D3DXVECTOR4 vHalf = (vEye + vLight) * 0.5f;
		D3DXVec4Normalize(&vHalf, &vHalf);
		g_pd3dDevice->SetVertexShaderConstant(VSC_HALF, &vHalf, 1);
	}
	g_pd3dDevice->SetVertexShaderConstant(VSC_EYE, &vEye, 1);
	g_pd3dDevice->SetVertexShaderConstant(VSC_LIGHT, &vLight, 1);
	static D3DXCOLOR diffuseConditioning(0.8f, 0.8f, 0.8f, 1.f);
	g_pd3dDevice->SetVertexShaderConstant(VSC_DIFFUSE, &diffuseConditioning, 1);
	static D3DXCOLOR ambientConditioning(0.125f, 0.125f, 0.125f, 1.f);
	g_pd3dDevice->SetVertexShaderConstant(VSC_AMBIENT, &ambientConditioning, 1);
	static float fExtra = 1.25f;
	D3DXVECTOR4 vOffset(m_fYSize, fExtra * m_fYSize, 0.5f, 0.f);

	// For the Banks' self-shadowing attenuation factor, inside the vertex shader, 
	// we want (1-p)^d, where d = h / NdotL.   Since we have only expp which gives 
	// the result to the power of two, we use 2^(log2(1-p)*d), 
	// Since expp doesn't accept negative exponents, we negate it here and divide 
	// by the factor inside the shader.
	D3DXVECTOR4 vSelfShadow;
	static float fEps = 0.1f;
	static float fRho = 0.02f;	// attenuation factor, Banks
	static float fDEBUGSCALE = 255.f;
	float fSelfShadowLOG2Attenuation = -logf(1.f-fRho)/logf(2.f);
	float h = fDEBUGSCALE*(vOffset.y - vOffset.x);
	vSelfShadow.x = fEps;	// min value for N dot L
	extern bool g_bSelfShadow;	// DEBUG
	if (!g_bSelfShadow)
		vSelfShadow.y = 0.f;
	else
		vSelfShadow.y = h * fSelfShadowLOG2Attenuation;
	g_pd3dDevice->SetVertexShaderConstant(VSC_SELFSHADOW, &vSelfShadow, 1);

	extern D3DXVECTOR4 g_vWind1; // source position in x,y,z, local magnitude in w
	extern D3DXVECTOR4 g_vWind2; // source up, w = out-of-tangent plane fraction
	extern D3DXVECTOR4 g_vWind3; // source left
	g_pd3dDevice->SetVertexShaderConstant(VSC_WIND1, &g_vWind1, 1);
	g_pd3dDevice->SetVertexShaderConstant(VSC_WIND2, &g_vWind2, 1);
	g_pd3dDevice->SetVertexShaderConstant(VSC_WIND3, &g_vWind3, 1);

	if(lod>0.25f)	// render m_dwNumLayers of textures using alpha blending
	{
		// Draw the fins
		extern bool g_bDrawFins;	// DEBUG
		if (g_bDrawFins && pmesh->m_pFinIB)
		{
			// This is a hack that might be "too clever".   We use the same vertex buffer as the underlying mesh, but 
			// we use it twice: Once for the base points and once for the points extruded along the normals. To
			// make the indexing work, the IB indices are doubled and the stride given to SetStreamSource is halved.
			// Then, using the fin selection stream, we can choose which vertex to use.
			vOffset.x = (float)m_fYSize/(float)m_dwNumLayers;	// use one-layer epsilon off the surface for the fin
			g_pd3dDevice->SetVertexShaderConstant(VSC_OFFSET, &vOffset, 1);
			g_pd3dDevice->SetVertexShader(g_dwFinVS);
			g_pd3dDevice->SetIndices(pmesh->m_pFinIB, 0);
			assert(2 * (sizeof(FVFT_XYZNORMTEX1) / 2) == sizeof(FVFT_XYZNORMTEX1));	// size must be divisible by 2
			g_pd3dDevice->SetStreamSource(0, pmesh->m_pVB, sizeof(FVFT_XYZNORMTEX1) / 2);
			g_pd3dDevice->SetStreamSource(1, pmesh->m_pVB, sizeof(FVFT_XYZNORMTEX1) / 2);
			g_pd3dDevice->SetStreamSource(2, pmesh->m_pFinVB, sizeof(float));	 // selector
			g_pd3dDevice->SetTexture(iTexStageVolumeTexture, m_pFinTexture);
			g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
			g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
			g_pd3dDevice->SetTextureStageState( iTexStageVolumeTexture, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
			g_pd3dDevice->DrawIndexedPrimitive(D3DPT_QUADLIST, 0, pmesh->m_dwNumVertices * 2, 0, pmesh->m_dwNumFins);
			g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
			g_pd3dDevice->SetTextureStageState( iTexStageVolumeTexture, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
		}
		// Draw the shells
		extern bool g_bDrawShells;	// DEBUG
		if (g_bDrawShells)
		{
			if (g_bMultiShell)
			{
				// Set up blending of multiple texture layers at once
				for (iTexStage = 2; iTexStage <= 3; iTexStage++)
				{
					// g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAKILL, D3DTALPHAKILL_ENABLE );
					g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_TEXCOORDINDEX, iTexStage );
					g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
					g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
					g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
					g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
					g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
				}

				// Overwrite texture function with pixel shader
#include "fur.inl"
				g_pd3dDevice->SetPixelShaderProgram(&psd);
			}

			g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
			g_pd3dDevice->SetVertexShader(g_dwFuzzVS);
			if (pmesh->m_pIB) g_pd3dDevice->SetIndices(pmesh->m_pIB, 0);
			g_pd3dDevice->SetStreamSource(0, pmesh->m_pVB, sizeof(FVFT_XYZNORMTEX1));
			float fYSizeDelta = m_fYSize/(float)m_dwNumLayers;
			if (g_bMultiShell)
			{
				D3DXVECTOR4 vShellOffsetDeltas(fYSizeDelta, 0.f, -1.f*fYSizeDelta, -2.f*fYSizeDelta);
				g_pd3dDevice->SetVertexShaderConstant(VSC_MULTISHELL, &vShellOffsetDeltas, 1);
				g_pd3dDevice->SetStreamSource(1, pmesh->m_pVBTex, sizeof(D3DVECTOR) * 2);
			}
/*			
			UINT iStart = 0;
			UINT iEnd = m_dwNumLayers - 1;
bool bRange = true;
UINT iStart0 = 5;
UINT iStart1 = 5;
if (bRange)
{
	iStart = iStart0;
	iEnd = iEnd0;
}
*/
static bool bFlatten = true;
			for(i=0; i<m_dwNumLayers; i++)
			{
				UINT ShellCount;
				if (g_bMultiShell)
				{
					// skip two extra shells each time, for a total of 3 each pass
					UINT iStart = i;
					i += 2;
					if (i >= m_dwNumLayers)
						i = m_dwNumLayers - 1;
					ShellCount = i - iStart + 1;
					vOffset.x = (float)(i)*fYSizeDelta;
				}
				else
					vOffset.x = (float)(i+1)*fYSizeDelta;
				g_pd3dDevice->SetVertexShaderConstant(VSC_OFFSET, &vOffset, 1);
				if (g_bSelfShadow)
				{
					float h = fDEBUGSCALE*(vOffset.y - vOffset.x);
					vSelfShadow.y = h * fSelfShadowLOG2Attenuation;
					g_pd3dDevice->SetVertexShaderConstant(VSC_SELFSHADOW, &vSelfShadow, 1);
				}
				g_pd3dDevice->SetTexture(iTexStageVolumeTexture, m_pVolTexture[bFlatten ? (i / 3)*3 : i]);
				if (g_bMultiShell)
				{
					// Set textures to do multiple shells at once
					if (ShellCount > 1)
						g_pd3dDevice->SetTexture(2, m_pVolTexture[bFlatten ? ((i - 1) / 3) * 3 : (i-1)]);
					else
						g_pd3dDevice->SetTexture(2, NULL);
					if (ShellCount > 2)
						g_pd3dDevice->SetTexture(3, m_pVolTexture[bFlatten ? ((i - 2) / 3) * 3 : (i-2)]);
					else
						g_pd3dDevice->SetTexture(3, NULL);
				}
				if (!pmesh->m_pIB)
					g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, pmesh->m_dwNumIndices/3);
				else
					g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, pmesh->m_dwNumVertices, 0, pmesh->m_dwNumIndices/3);
			}

			g_pd3dDevice->SetPixelShader(NULL);		// use legacy pixel shader
		}
	}
	else // lowest LOD render
	{
		g_pd3dDevice->SetVertexShader(g_dwFuzzVS);
		g_pd3dDevice->SetStreamSource(0, pmesh->m_pVB, sizeof(FVFT_XYZNORMTEX1));
		if (pmesh->m_pIB) g_pd3dDevice->SetIndices(pmesh->m_pIB, 0);
		g_pd3dDevice->SetTexture(iTexStageVolumeTexture, m_pTexture);
		if (!pmesh->m_pIB)
			g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, pmesh->m_dwNumIndices/3);
		else
			g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, pmesh->m_dwNumVertices, 0, pmesh->m_dwNumIndices/3);
	}

	// Cleanup render and texture stage states.  These may be redundant if multiple calls to patch render are used
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, lflag);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	for (iTexStage = 0; iTexStage < 4; iTexStage++)
	{
		g_pd3dDevice->SetTexture( iTexStage, NULL);
		g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_MIPFILTER, D3DTEXF_NONE);
		g_pd3dDevice->SetTextureStageState( iTexStage, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\cartoon\cartoon.cpp ===
//-----------------------------------------------------------------------------
// File: Cartoon.cpp
//
// Desc: Draws a model, simulating cartoon lighting by using a 1D texture map.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       01.10.00 - Changes for February XDK release
//       02.06.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBMesh.h>
#include <XBHelp.h>
#include <xgraphics.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Move\nmodel" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Move\nlight" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Name: class CXBCartoonMesh
// Desc: Overridden mesh class for rendering file-based meshes. The base mesh
//       class is overridden in order to replace the render callback function,
//       which here is used to pass values to the vertex shader.
//-----------------------------------------------------------------------------
class CXBCartoonMesh: public CXBMesh
{
public:
    BOOL RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                         XBMESH_SUBSET* pSubset, DWORD dwFlags );
};




//-----------------------------------------------------------------------------
// Name: RenderCallback()
// Desc: Called before each mesh subset is rendered, this function passes 
//       values to the cartoon vertex shader.
//-----------------------------------------------------------------------------
BOOL CXBCartoonMesh::RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                                     XBMESH_SUBSET* pSubset, DWORD dwFlags )
{
    // Set matrices for the vertex shader
    D3DXMATRIX matWorld, matView, matProj, matAll;
    pd3dDevice->GetTransform( D3DTS_WORLD,      &matWorld );
    pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
    pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
    D3DXMatrixMultiply( &matAll, &matWorld, &matView );
    D3DXMatrixMultiply( &matAll, &matAll, &matProj );
    D3DXMatrixTranspose( &matAll, &matAll );
    D3DXMatrixTranspose( &matWorld, &matWorld );
    pd3dDevice->SetVertexShaderConstant( 4, &matAll, 4 );
    pd3dDevice->SetVertexShaderConstant( 8, &matWorld, 4 );

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont                 m_Font;
    CXBHelp                 m_Help;
    BOOL                    m_bDrawHelp;

    D3DXMATRIX              m_matWorld;         // Local transform of the model
    D3DXMATRIX              m_matLight;         // Transform for the light

    LPDIRECT3DTEXTURE8      m_pCartoonTexture;       // Texture surface
    DWORD                   m_dwCartoonVertexShader; // Custom vertex shader

    CXBCartoonMesh          m_Mesh;

    HRESULT CreateCartoonTexture();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    m_bDrawHelp         = FALSE;

    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixIdentity( &m_matLight );

    // Initial light direction used in the texture coordinate generation for
    // the cartoon effect.
    m_pCartoonTexture       = NULL;
    m_dwCartoonVertexShader = 0L;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a mesh (vertex and index buffers) for the model
    if( FAILED( m_Mesh.Create( m_pd3dDevice, "Models\\Robot.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set the view matrix
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f,-7.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp       = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMATRIX  matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUp );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Setup a yellow material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 0.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // The texture used by this renderer is procedurally generated.
    if( FAILED( CreateCartoonTexture() ) )
        return E_FAIL;

    // Create a vertex shader for doing the cartoon effect
    DWORD dwCartoonVertexDecl[MAX_FVF_DECL_SIZE];
    XBUtil_DeclaratorFromFVF( m_Mesh.GetMesh(0)->m_dwFVF, dwCartoonVertexDecl );

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Cartoon.xvu",
                                           dwCartoonVertexDecl,
                                           &m_dwCartoonVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CreateCartoonTexture()
// Desc: Creates the 1D texture map used as a modulation map based on vertex
//       lighting. This map holds quantized gray-scale values which are applied
//       to the underlying interpolated vertex color.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateCartoonTexture()
{
    if( FAILED( m_pd3dDevice->CreateTexture( 32, 1, 1, 0, 
                                             D3DFMT_X8R8G8B8, D3DPOOL_MANAGED, 
                                             &m_pCartoonTexture ) ) )
        return E_FAIL;

    // Get the pointer to the bits.
    D3DLOCKED_RECT lock;
    m_pCartoonTexture->LockRect( 0, &lock, NULL, 0L );
    DWORD* pTextureData = (DWORD*)lock.pBits;

    for( int i = 0; i<32; i++ )
    {
        if( i<8 )       pTextureData[i] = 0xff606060;
        else if( i<18 ) pTextureData[i] = 0xffa2a2a2;
        else if( i<29 ) pTextureData[i] = 0xffe5e5e5;
        else            pTextureData[i] = 0xffffffff;
    }

    m_pCartoonTexture->UnlockRect( 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Perform object rotation
    D3DXMATRIX matRotate;
    FLOAT fXRotate1 = m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate1 = m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate1, -fYRotate1, 0.0f );
    D3DXMatrixMultiply( &m_matWorld, &m_matWorld, &matRotate );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

    // Perform light rotation
    FLOAT fXRotate2 = fXRotate1 + m_DefaultGamepad.fX2*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate2 = fYRotate1 - m_DefaultGamepad.fY2*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate2, -fYRotate2, 0.0f );
    D3DXMatrixMultiply( &m_matLight, &m_matLight, &matRotate );

    // Set constants for the vertex shader
    D3DXVECTOR4 vColor( 1.0f, 1.0f, 0.0f, 0.0f );
    m_pd3dDevice->SetVertexShaderConstant( 0, &vColor, 1 );

    // Set light position for the vertex shader
    D3DXMATRIX  matWorldInv, matLightInv;
    D3DXVECTOR3 vRotLight;
    D3DXVec3Normalize( &vRotLight, &D3DXVECTOR3( 3.0f, 1.0f, -8.0f ) );
    D3DXMatrixInverse( &matLightInv, NULL, &m_matLight );
    D3DXMatrixInverse( &matWorldInv, NULL, &m_matWorld );
    D3DXVec3TransformCoord( &vRotLight, &vRotLight, &m_matLight );
    D3DXVec3TransformCoord( &vRotLight, &vRotLight, &matWorldInv );
    m_pd3dDevice->SetVertexShaderConstant( 1, &vRotLight, 1 );

    // Set matrices for the vertex shader
    D3DXMATRIX matWorld, matView, matProj, matAll, matAllTranspose;
    m_pd3dDevice->GetTransform( D3DTS_WORLD,      &matWorld );
    m_pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
    m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
    D3DXMatrixMultiply( &matAll, &matWorld, &matView );
    D3DXMatrixMultiply( &matAll, &matAll, &matProj );
    D3DXMatrixTranspose( &matAll, &matAll );
    m_pd3dDevice->SetVertexShaderConstant( 4, &matAll, 4 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff00ffff );

    // Set default states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,     TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,     0xffffffff );

    // Set filtering to point sampling; otherwise we lose the sharp
    // transistions in the lighting that we wanted.
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );

    // Set the texture coordinates to be clamped so we do not have to clamp the
    // result of the dot product in the texture gen code. We only really need
    // to clamp U because V is fixed at 0.0.
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    // Draw the first pass, the textured visible polygons. We want to modulate 
    // the texture with the diffuse at stage 0. The texture is a banded gray 
    // scale to give the lighting and the diffuse is used as specified in the
    // vertex because vertex lighting is disabled. This is a useful way to set
    // things up because the base color can be changed without having to
    // change render state and therefore without having to break primitives.
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    
    // Bind the cartoon texture and custom vertex shader
    m_pd3dDevice->SetTexture( 0, m_pCartoonTexture );
    m_pd3dDevice->SetVertexShader( m_dwCartoonVertexShader );

    // Draw the geometry
    m_Mesh.Render( m_pd3dDevice, XBMESH_NOFVF | XBMESH_NOMATERIALS | XBMESH_NOTEXTURES );

    // Draw the second pass, the black silhouette. Basically, scale the world
    // matrix up a little and then redraw in black.
    D3DXMATRIX matScale;
    D3DXMatrixScaling( &matScale, 1.025f, 1.025f, 1.025f );
    D3DXMatrixMultiply( &matScale, &matScale, &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matScale );

    // When we draw the silhouette we derive it from the back-facing polygons; we
    // draw these polygons scaled through the above scale matrix. We should only
    // see black around edges where the culling order changes and therefore the
    // direction of the polygons changes.
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );

    // Finally, before we draw the silhouette we want to set the color combiners
    // in such a way that they produce black with the minimal work and without
    // changing the diffuse color of the mesh. The simplest way is to use the
    // texture constant directly as a color; doing this also prevents any texture
    // reads.
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff000000 );

    // Turn off the texture and custom vertex shader
    m_pd3dDevice->SetTexture( 0, NULL );

    // Draw the geometry
    m_Mesh.Render( m_pd3dDevice, XBMESH_NOMATERIALS | XBMESH_NOTEXTURES );

    // Restore modified states
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"Cartoon" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\CompressedNormals\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\xfpmesh.cpp ===
//-----------------------------------------------------------------------------
// File: xfpmesh.cpp
//
// Desc: Facilitates drawing of 'fuzz' patches (hair, fur, grass, etc.)
//       by allowing you to 'paint' on an existing mesh and use those
//       triangles for the fuzz.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <assert.h>
#include "xfpmesh.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//-----------------------------------------------------------------------------
// Name: Constructor & Destructor
//-----------------------------------------------------------------------------
CXFPatchMesh::CXFPatchMesh()
{
	memset(this, 0, sizeof(CXFPatchMesh));
	m_dwVShader = FVF_XYZNORMTEX1;
}

CXFPatchMesh::~CXFPatchMesh()
{
	if(m_pVB)
		m_pVB->Release();
	if(m_pVBTex)
		m_pVBTex->Release();
	if(m_pIB)
		m_pIB->Release();
	if(m_Indices)
		delete m_Indices;
	if(m_UVs)
		delete m_UVs;
	if(m_pTexture)
		m_pTexture->Release();
}

//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Keep pointer to object and fill initial arrays from selection.
//       If aIndices==NULL, do whole mesh.
//       This routine does the work of Build, but skips the creation of
//       the m_Indices and m_UVs arrays.			BUGBUG: save won't work
//-----------------------------------------------------------------------------
HRESULT CXFPatchMesh::Initialize(CXObject *obj, WORD *aIndices, DWORD dwNumIndices)
{
	HRESULT hr;
	m_Obj = obj;
	assert(m_Obj->m_Model->m_dwFVF==FVF_XYZNORMTEX1);	// make sure we are using correct FVF type
	if (aIndices)
		return E_NOTIMPL;	// all or nothing at the moment
	m_dwNumVertices = m_Obj->m_Model->m_dwNumVertices;
	m_dwNumIndices = 3 * m_Obj->m_Model->m_dwNumTriangles;
	if(m_pVB) m_pVB->Release();
	m_pVB = m_Obj->m_Model->m_pVB;
	m_pVB->AddRef();
	if (m_pIB) m_pIB->Release();
	m_pIB = m_Obj->m_Model->m_pIB;
	m_pIB->AddRef();

	// Create texture coordinate frame vertex buffer
	if (m_pVBTex)
		SAFE_RELEASE(m_pVBTex);
	hr = g_pd3dDevice->CreateVertexBuffer(m_dwNumVertices * 2 * sizeof(D3DVECTOR), 0, 0, 0, &m_pVBTex);
	if (FAILED(hr))
		return E_FAIL;
	hr = CalculateTextureCoordinateFrames();
	if (FAILED(hr))
		return hr;
	
	m_bBuildFlag = FALSE;
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CalculateTextureCoordinateFrames
// Desc: Compute S and T vectors for all the vertices, based on the
//       local triangle coordinate frames.
//-----------------------------------------------------------------------------
HRESULT CXFPatchMesh::CalculateTextureCoordinateFrames()
{
	HRESULT hr;

	// Keep a count of how many times each vertex was touched.
	UINT *rCount = new UINT [ m_dwNumVertices ];
	if (rCount == NULL)
		return E_OUTOFMEMORY;
	ZeroMemory(rCount, m_dwNumVertices * sizeof(UINT));

	// Lock the buffers we need to iterate over
	struct XYZNORMTEX1 { 
		D3DXVECTOR3 v;
		D3DXVECTOR3 norm;
		D3DXVECTOR2 tex1;
	} *rVertex = NULL;
	struct TEXCOORDFRAME {
		D3DXVECTOR3 S;
		D3DXVECTOR3 T;
	} *rTexCoordFrame = NULL;
	WORD *riFace = NULL;
	
	hr = m_pVB->Lock(0, m_dwNumVertices, (BYTE **)&rVertex, 0);
	if (FAILED(hr))
		goto e_Exit;

	hr = m_pVBTex->Lock(0, m_dwNumVertices, (BYTE **)&rTexCoordFrame, 0);
	if (FAILED(hr))
		goto e_Exit;
	ZeroMemory(rTexCoordFrame, m_dwNumVertices * sizeof(TEXCOORDFRAME));

	hr = m_pIB->Lock(0, m_dwNumIndices*sizeof(WORD), (BYTE **)&riFace, 0);
	if (FAILED(hr))
		goto e_Exit;

	// Iterate through the triangles, updating the texture
	// coordinate frame for each touched vertex.
	static bool bAverage = false;
	for (UINT iFace = 0; iFace < m_dwNumIndices/3; iFace++)
	{
// DEBUG
#if 0
static UINT iFaceStart = 400;
static UINT nFace = 1;
if (iFace < iFaceStart) continue;
if (iFace >= iFaceStart + nFace) break;
#endif
		WORD *aiv = riFace + iFace * 3;
		for (UINT iCorner = 0; iCorner < 3; iCorner++)
		{
			WORD iVertex0 = aiv[iCorner];
			WORD iVertex1 = aiv[(iCorner + 1) % 3];
			WORD iVertex2 = aiv[(iCorner + 2) % 3];
			
			// A, B, C is coordinate frame in 3D object coords
			D3DXVECTOR3 A = rVertex[iVertex1].v - rVertex[iVertex0].v;
			D3DXVECTOR3 B = rVertex[iVertex2].v - rVertex[iVertex0].v;
			D3DXVECTOR3 C;
			D3DXVec3Cross(&C, &A, &B);
			float CLengthSq = D3DXVec3LengthSq(&C);

			// a, b, c is coordinate frame in texture coords
			D3DXVECTOR2 a = rVertex[iVertex1].tex1 - rVertex[iVertex0].tex1;
			D3DXVECTOR2 b = rVertex[iVertex2].tex1 - rVertex[iVertex0].tex1;
			float cz = D3DXVec2CCW( &a, &b );	// c has just one component out of the texture plane

            // Texture matrix M maps from texture coords to object coords.
            //
            // [ ax ay 0  ] M = [ Ax Ay Az ]
            // [ bx by 0  ]     [ Bx By Bz ]
            // [ 0  0  cz ]     [ Cx Cy Cz ]
			//
			// Get M by inverting texture coord matrix and multiplying by triangle frame.
            //
            // M = (1/cz) * [  by -ay 0 ] [ Ax Ay Az ]
            //              [ -bx  ax 0 ] [ Bx By Bz ]
            //              [  0   0  1 ] [ Cx Cy Cz ]
			//
			// Then, pretend matrix M is a scale * rotation (which will be the
			// case if the texture mapping is reasonable) and use scaled
			// transpose as inverse to transform from object coords back
			// to texture coords.
			//
			float fScale = cz * cz / CLengthSq;
			D3DXVECTOR3 S = (b.y * A - a.y * B) * fScale;
			D3DXVECTOR3 T = (-b.x * A + a.x * B) * fScale;
#ifdef _DEBUG
			// The simple solution is not working. Do the
			// full blown inverse to compare.
			D3DXMATRIX X(
				A.x, A.y, A.z, 0.f,
				B.x, B.y, B.z, 0.f,
				C.x, C.y, C.z, 0.f,
				0.f, 0.f, 0.f, 1.f);
			D3DXMATRIX XInv;
			float fXDet;
			D3DXMatrixInverse(&XInv, &fXDet, &X);
			D3DXMATRIX I;
			D3DXMatrixMultiply(&I, &XInv, &X);
			D3DXMATRIX Tex(
				a.x, a.y, 0.f, 0.f,
				b.x, b.y, 0.f, 0.f,
				0.f, 0.f, cz, 0.f,
				0.f, 0.f, 0.f, 1.f);
			D3DXMATRIX MInv;
			D3DXMatrixMultiply(&MInv, &XInv, &Tex);
			D3DXMATRIX Tex2;
			D3DXMatrixMultiply(&Tex2, &X, &MInv);
			static enum { SIMPLE, FULL, AB } e = FULL;
			if (e == FULL)
			{
				S = D3DXVECTOR3(MInv._11, MInv._21, MInv._31);
				T = D3DXVECTOR3(MInv._12, MInv._22, MInv._32);
			}
			else if (e == AB)
			{
				// For debugging, stick in A and B vectors instead of S and T
				S = A;
				T = B;
			}
#endif

			// To get texture coordinates for object space point p, use
			//     q = p - v0			// v0 is vertex position
			//     s = dot(S, q) + s0	// s0 and t0 are the vertex texture coords
			//     t = dot(T, q) + t0
			
#ifdef _DEBUG
			// Debug checking
			D3DXVECTOR3 SxT;
			D3DXVec3Cross(&SxT, &S, &T);
			float AdotS = D3DXVec3Dot(&A, &S);
			float AdotT = D3DXVec3Dot(&A, &T);
			float AdotSxT = D3DXVec3Dot(&A, &SxT);
			float BdotS = D3DXVec3Dot(&B, &S);
			float BdotT = D3DXVec3Dot(&B, &T);
			float BdotSxT = D3DXVec3Dot(&B, &SxT);
			float CdotS = D3DXVec3Dot(&C, &S);
			float CdotT = D3DXVec3Dot(&C, &T);
			float CdotSxT = D3DXVec3Dot(&C, &SxT);
#endif
			
			// Assign or accumulate S and T frames
			if (bAverage)
			{
				rTexCoordFrame[iVertex0].S += S;
				rTexCoordFrame[iVertex0].T += T;
			}
			else
			{
				rTexCoordFrame[iVertex0].S = S;
				rTexCoordFrame[iVertex0].T = T;
			}
			rCount[iVertex0]++;
		}
	}

	// Take average value for final frame
	if (bAverage)
	{
		for (UINT iVertex = 0; iVertex < m_dwNumVertices; iVertex++)
		{
			if (rCount[iVertex] == 0)
				continue;	// vertex was not touched
			float fScale = 1.f / (float)rCount[iVertex];
			rTexCoordFrame[iVertex].S *= fScale;
			rTexCoordFrame[iVertex].T *= fScale;
		}
	}
	
 e_Exit:
	if (rVertex != NULL)
		m_pVB->Unlock();
	if (rTexCoordFrame != NULL)
		m_pVBTex->Unlock();
	if (riFace != NULL)
		m_pIB->Unlock();
	delete [] rCount;
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ExtractFins
// Desc: Find all the edges of the mesh and create an IB to draw them.
//-----------------------------------------------------------------------------
HRESULT CXFPatchMesh::ExtractFins()
{
	HRESULT hr = S_OK;
	if (!m_pVB || !m_pIB) 
		return E_FAIL;
	UINT nFin = 0;
	UINT nFinMax = m_dwNumIndices; // 3 * nFace
	DWORD *aFin = new DWORD [nFinMax];
	if (aFin == NULL)
		return E_OUTOFMEMORY;

	// count the number of fins by adding all the edges to a set
	WORD *piFace;
	hr = m_pIB->Lock(0, m_dwNumIndices*sizeof(WORD), (BYTE **)&piFace, 0);
	if (FAILED(hr))
		goto e_Exit;
	for (UINT iFace = 0; iFace < m_dwNumIndices/3; iFace++)
	{
		WORD *aiv = piFace + iFace * 3;
		for (UINT iCorner = 0; iCorner < 3; iCorner++)
		{
			WORD iVertex0 = aiv[iCorner];
			WORD iVertex1 = aiv[(iCorner + 1) % 3];
			if (iVertex0 > iVertex1)
			{
				// swap so the iVertex0 is always lower than iVertex1
				WORD iVertexSave = iVertex0;
				iVertex0 = iVertex1;
				iVertex1 = iVertexSave;
			}
			DWORD finKey = (((DWORD)iVertex0) << 16) | iVertex1;
			// find the right position
			UINT i = 0, j, k = nFin;
			while (i != k)
			{
				j = (i + k) >> 1;
				if (aFin[j] < finKey)
					i = j + 1;
				else if (aFin[j] > finKey)
					k = j;
				else // (m_aFin[i] == key)
					break; // already in table
			}
			if (i == k)
			{
				// move all the slots one up, then add new key
				assert(nFin < nFinMax);
				for (j = nFin; j > i; j--)
					aFin[j] = aFin[j-1];
				aFin[i] = finKey;
				nFin++;
			}
		}
	}
	m_pIB->Unlock();

	// create the fin index buffer
	m_dwNumFins = nFin;
	if (m_pFinIB)
		SAFE_RELEASE(m_pFinIB);
	hr = g_pd3dDevice->CreateIndexBuffer(4*m_dwNumFins*sizeof(WORD), 0, D3DFMT_INDEX16, 0, &m_pFinIB);
	if (FAILED(hr))
		goto e_Exit;
	WORD *piFin;
	hr = m_pFinIB->Lock(0, m_dwNumFins*4*sizeof(WORD), (BYTE **)&piFin, 0);
	if (FAILED(hr))
		goto e_Exit;
	UINT iFin;
	for (iFin = 0; iFin < nFin; iFin++)
	{	
		DWORD finKey = aFin[iFin];
		WORD iVertex0 = (WORD)(finKey >> 16);
		WORD iVertex1 = (WORD)(finKey & 0xffff);
		// Indices are times two so drawing with half-stride and selector stream works.
		// This assumes that the indices are base-1, with 0 never actually used.
		assert(iVertex0 > 0 && iVertex1 > 0);
		*piFin++ = iVertex0 * 2;
		*piFin++ = iVertex1 * 2;
		*piFin++ = iVertex1 * 2 - 1;
		*piFin++ = iVertex0 * 2 - 1;
	}
	m_pFinIB->Unlock();

	// Create the fin selection stream.
	if (m_pFinVB)
		SAFE_RELEASE(m_pFinVB);
	hr = g_pd3dDevice->CreateVertexBuffer(m_dwNumVertices*2*sizeof(float), 0, 0, 0, &m_pFinVB);
	if (FAILED(hr))
		goto e_Exit;
	float *pfSelector;
	hr = m_pFinVB->Lock(0, m_dwNumVertices*2*sizeof(float), (BYTE **)&pfSelector, 0);
	if (FAILED(hr))
		goto e_Exit;
	for (UINT iVertex = 0; iVertex < m_dwNumVertices; iVertex++)
	{	
		*pfSelector++ = 1.f;	// select base point
		*pfSelector++ = 0.f;	// select base point + offset normal
	}
	m_pFinVB->Unlock();
e_Exit:
	if (aFin) delete [] aFin;
	return hr;
}

//-----------------------------------------------------------------------------
// Name: LineEQ
// Desc: Determines a line equation to facilitate picking triangles
//-----------------------------------------------------------------------------
void LineEQ(D3DXVECTOR3 *p1, D3DXVECTOR3 *p2, float *a, float *b, float *c)
{
	*a = -(p1->y - p2->y);
	*b = p1->x - p2->x;
	*c = -(*a*p1->x + *b*p1->y);
}

//-----------------------------------------------------------------------------
// Name: PickTriangle
// Desc: Searches an objects model for a triangle that contains the point
//       specified in p (in screen space).
//
// Note: This routine would be used in a tool to pick which triangles
//       you want for this pmesh.
//-----------------------------------------------------------------------------
DWORD CXFPatchMesh::PickTriangle(CXObject *obj, POINT p, DWORD flag, D3DVIEWPORT8 *Viewport, D3DXMATRIX *matProj, D3DXMATRIX *matView, D3DXMATRIX *matWorld)
{
	BYTE *vptr, *iptr;
	DWORD i, j, ret;
	int dup;
	D3DVECTOR v1, v2, v3;
	D3DXVECTOR3 vp1, vp2, vp3;
	WORD i1, i2, i3, *tris;
	float a, b, c, d;

	obj->m_Model->LockVB(&vptr, 0);
	obj->m_Model->LockIB(&iptr, 0);
	tris = (WORD *)iptr;

	for(i=0; i<obj->m_Model->m_dwNumIndices/3; i++)
	{
		i1 = tris[i*3];
		i2 = tris[i*3+1];
		i3 = tris[i*3+2];

		FVF_GetVert(vptr, &v1, i1, 1, obj->m_Model->m_dwFVF);
		FVF_GetVert(vptr, &v2, i2, 1, obj->m_Model->m_dwFVF);
		FVF_GetVert(vptr, &v3, i3, 1, obj->m_Model->m_dwFVF);

		D3DXVec3Project(&vp1, (D3DXVECTOR3 *)&v1, Viewport, matProj, matView, matWorld);
		D3DXVec3Project(&vp2, (D3DXVECTOR3 *)&v2, Viewport, matProj, matView, matWorld);
		D3DXVec3Project(&vp3, (D3DXVECTOR3 *)&v3, Viewport, matProj, matView, matWorld);

		// check if point inside triangle
		LineEQ(&vp1, &vp2, &a, &b, &c);
		d = a*(float)p.x + b*(float)p.y + c;
		if(d>0)
			continue;
		LineEQ(&vp2, &vp3, &a, &b, &c);
		d = a*(float)p.x + b*(float)p.y + c;
		if(d>0)
			continue;
		LineEQ(&vp3, &vp1, &a, &b, &c);
		d = a*(float)p.x + b*(float)p.y + c;
		if(d>0)
			continue;

		// check for duplicate tri
		dup = -1;
		for(j=0; j<m_dwNumIndices/3; j++)
		{
			if((m_Indices[j*3]==i1) && (m_Indices[j*3+1]==i2) && (m_Indices[j*3+2]==i3))
			{
				dup = j;
				break;
			}
		}

		// flag==0, do add or delete
		// flag==1, do only add
		// flag==2, do only delete
		if((flag==0 || flag==1) && (dup==-1))			// do add
		{
			// make sure we have space
			if(m_dwNumIndices>=(m_dwMaxIndices-5))
			{
				// expand index space
				m_dwMaxIndices = m_dwNumIndices+300;

				// copy indices
				WORD *newindices = new WORD[m_dwMaxIndices];
				memcpy(newindices, m_Indices, m_dwNumIndices*sizeof(WORD));
				if(m_Indices)
					delete m_Indices;
				m_Indices = newindices;
	
				// copy texture samples
				float *newuvs = new float[m_dwMaxIndices*2];
				memcpy(newuvs, m_UVs, m_dwNumIndices*2*sizeof(float));
				if(m_UVs)
					delete m_UVs;
				m_UVs = newuvs;
			}

			// add triangle
			m_Indices[m_dwNumIndices++] = i1;
			m_Indices[m_dwNumIndices++] = i2;
			m_Indices[m_dwNumIndices++] = i3;

			ret = 1;
			m_bBuildFlag = TRUE;
			goto bail;
		}
		else if((flag==0 || flag==2) && (dup>=0))		// do delete
		{
			m_Indices[dup*3+2] = m_Indices[--m_dwNumIndices];
			m_Indices[dup*3+1] = m_Indices[--m_dwNumIndices];
			m_Indices[dup*3] = m_Indices[--m_dwNumIndices];

			ret = 2;
			m_bBuildFlag = TRUE;
			goto bail;
		}
	}

bail:
	obj->m_Model->UnlockVB();
	obj->m_Model->UnlockIB();

	return ret;											// return last op
}

//-----------------------------------------------------------------------------
// Name: File routines
// Desc: Routines to save and load patch mesh descriptions
//-----------------------------------------------------------------------------
struct _pmhdr
{
	char sig[4];
	char fpatchname[32];
	DWORD nidx;
	D3DVECTOR texcenter;
	D3DVECTOR texsize;
	DWORD mapping;
	DWORD axis;
};

void CXFPatchMesh::Save(char *fname)
{
	FILE *fp;
	struct _pmhdr hdr;

	fp = fopen(fname, "wb");
	if(!fp)
		return;

	strcpy(hdr.sig, "PMSH");
	strcpy(hdr.fpatchname, m_strFPatchName);

	hdr.nidx = m_dwNumIndices;

	hdr.texcenter = m_TextureCenter;
	hdr.texsize = m_TextureSize;
	hdr.mapping = m_dwMapping;
	hdr.axis = m_dwAxis;

	fwrite(&hdr, sizeof(struct _pmhdr), 1, fp);
	fwrite(m_Indices, sizeof(WORD), m_dwNumIndices, fp);
	fwrite(m_UVs, sizeof(float), m_dwNumIndices*2, fp);

	fclose(fp);
}

void CXFPatchMesh::Load(char *fname)
{
	FILE *fp;
	struct _pmhdr hdr;

	fp = fopen(fname, "rb");
	if(!fp)
		return;

	fread(&hdr, sizeof(struct _pmhdr), 1, fp);
	if(strncmp(hdr.sig, "PMSH", 4))
	{
		fclose(fp);
		return;
	}

	strcpy(m_strFPatchName, hdr.fpatchname);

	m_dwNumIndices = hdr.nidx;
	m_dwMaxIndices = hdr.nidx;

	m_TextureCenter = hdr.texcenter;
	m_TextureSize = hdr.texsize;
	m_dwMapping = hdr.mapping;
	m_dwAxis = hdr.axis;

	// allocate memory
	if(m_Indices)
		delete m_Indices;
	m_Indices = new WORD[m_dwNumIndices];

	if(m_UVs)
		delete m_UVs;
	m_UVs = new float[2*m_dwNumIndices];

	// read in the data
	fread(m_Indices, sizeof(WORD), m_dwNumIndices, fp);
	fread(m_UVs, sizeof(float), m_dwNumIndices*2, fp);
	fclose(fp);

	// build index buffer
	BuildIndexBuffer();

	m_bBuildFlag = TRUE;
}

//-----------------------------------------------------------------------------
// Name: BuildIndexBuffer
// Desc: Builds the pmesh index buffer for rendering
//-----------------------------------------------------------------------------
void CXFPatchMesh::BuildIndexBuffer()
{
/*
	WORD idx, *ibuf, *tbuf;
	WORD wMaxIndex;
	DWORD i;

	// scan indices to get max index
	wMaxIndex = 0;
	for(i=0; i<m_dwNumIndices; i++)
		if(m_Indices[i]>wMaxIndex)
			wMaxIndex = m_Indices[i];

	tbuf = new WORD[wMaxIndex];
	memset(tbuf, 0xffffffff, wMaxIndex*sizeof(WORD));

	g_pd3dDevice->CreateIndexBuffer(m_dwNumIndices*sizeof(WORD), 0, D3DFMT_INDEX16, 0, &m_pIB);
	m_pIB->Lock(0, m_dwNumIndices*sizeof(WORD), (BYTE **)&ibuf, 0);

	idx = 0;
	for(i=0; i<m_dwNumIndices; i++)
	{
		if(tbuf[m_Indices[i]]==0xffff)
		{
			tbuf[m_Indices[i]] = idx;
			ibuf[i] = idx++;
		}
		else
			ibuf[i] = tbuf[m_Indices[i]];
	}

	m_wMaxIndex = idx;			// keep track of biggest index
	m_pIB->Unlock();

	delete tbuf;
*/
}

//-----------------------------------------------------------------------------
// Name: Build
// Desc: Gets vertices and normals from the underlying object for our
//       patch mesh.
//-----------------------------------------------------------------------------
void CXFPatchMesh::Build(int firstflag)
{
	FVFT_XYZNORMTEX1 *vptr, *vptr2;
	DWORD i;

	if(!m_dwNumIndices || !m_bBuildFlag)
		return;

	// make sure we are using correct FVF type
	assert(m_Obj->m_Model->m_dwFVF==FVF_XYZNORMTEX1);

	// get memory for our vertices
	if(m_dwNumVertices<m_dwNumIndices)
	{
		if(m_pVB)
			m_pVB->Release();

		m_dwNumVertices = m_dwNumIndices;
		g_pd3dDevice->CreateVertexBuffer(m_dwNumVertices*sizeof(FVFT_XYZNORMTEX1), 0, FVF_XYZNORMTEX1, 0, &m_pVB);
	}

	// get the vertices and normals from our underlying model
	m_pVB->Lock(0, m_dwNumVertices*sizeof(FVFT_XYZNORMTEX1), (BYTE **)&vptr, 0);
	m_Obj->m_Model->LockVB((BYTE **)&vptr2, 0);
	for(i=0; i<m_dwNumIndices; i++)
	{
		vptr[i].v = vptr2[m_Indices[i]].v;
		vptr[i].norm = vptr2[m_Indices[i]].norm;
	}

	// if this is the first build, copy the UV's into the PMesh VB
	if(firstflag)
		for(i=0; i<m_dwNumIndices; i++)
		{
			vptr[i].tu = m_UVs[i<<1];
			vptr[i].tv = m_UVs[(i<<1)+1];
		}

	// unlock vertex buffers
	m_pVB->Unlock();
	m_Obj->m_Model->UnlockVB();

	m_bBuildFlag = FALSE;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Draw the patch mesh on its own. Used to see exactly which triangles
//       are selected. (Normally, another class would use the pmesh data only
//       to do its rendering)
//-----------------------------------------------------------------------------
void CXFPatchMesh::Render()
{
	if(!m_dwNumIndices)			// make sure we have stuff to draw
		return;
	g_pd3dDevice->SetTexture(0, m_pTexture);
	g_pd3dDevice->SetVertexShader(m_dwVShader);
	g_pd3dDevice->SetStreamSource(0, m_pVB, sizeof(FVFT_XYZNORMTEX1));
	if (!m_pIB)
		g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumIndices/3);
	else
	{
		g_pd3dDevice->SetIndices(m_pIB, 0);
		g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumVertices, 0, m_dwNumIndices/3);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\bunny\xfpatch.h ===
//-----------------------------------------------------------------------------
// File: xfpatch.h
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __FUZZ_H
#define __FUZZ_H

#ifdef _XBOX
#include <xtl.h>
#else
#include <d3d8.h>
#endif
#include "xfvf.h"
#include "xfpmesh.h"

#define MAX_VLEVEL 32

extern D3DXMATRIX g_matProj;
extern D3DXMATRIX g_matView;
extern D3DXMATRIX g_matWorld;
extern DWORD g_dwFuzzVS;
extern DWORD g_dwFinVS;
extern D3DXVECTOR3 g_LightPos;
extern D3DXVECTOR3 g_EyePos;

extern float g_fOneInch;

// patch generation

// a fuzz is a single hair follicle, blade of grass, etc.
struct SFuzz
{
	D3DVECTOR dp;			// velocity
	D3DVECTOR ddp;			// acceleration
	D3DXCOLOR colorBase;
	D3DXCOLOR colorTip;
};

// a fuzz instance is a single instance of a fuzz
// located at x, z on the patch
// we create only a limited number of unique fuzzes
// and index the library with lidx.
struct SFuzzInst
{
	float x, z;				// fuzz location
	int lidx;				// library index
};

// a fuzz patch is a volume that holds fuzzes.
// xsize and zsize are chosen by the user
// ysize is calculated using the height of the 
// tallest fuzz
class CXFPatch
{
public:
	DWORD m_dwSeed;			// patch seed
	
	float m_fXSize;			// patch size in world coords
	float m_fYSize;
	float m_fZSize;

	// fuzz library
	DWORD m_dwNumSegments;	// # of segments in highest LOD
	SFuzz m_fuzzCenter;		// fuzz constant
	SFuzz m_fuzzRandom;		// random offset around center
	DWORD m_dwNumFuzzLib;	// # of fuzz in the library
	SFuzz *m_pFuzzLib;		// fuzz library

	// fuzz instances
	DWORD m_dwNumFuzz;		// # of fuzz in this patch
	SFuzzInst *m_pFuzz;

	// patch volume
	DWORD m_dwNumLayers;	// # of layers in the volume
	DWORD m_dwVolSize;		// width*depth
	DWORD m_dwVolXSize;		// width of volume texture
	DWORD m_dwVolZSize;		// depth of volume texture
	LPDIRECT3DTEXTURE8 m_pVolTexture[MAX_VLEVEL];	// volume texture

	// highest LOD texture
	LPDIRECT3DTEXTURE8 m_pTexture;

	// hair lighting texture
	D3DMATERIAL8 m_HairLightingMaterial;
	LPDIRECT3DTEXTURE8 m_pHairLightingTexture;

	// fin texture
	LPDIRECT3DTEXTURE8 m_pFinTexture;	// texture projected from the side

	CXFPatch();
	~CXFPatch();

	void InitFuzz(DWORD nfuzz, DWORD nfuzzlib);
	void GenVolume(DWORD nlayers, DWORD volxsize, DWORD volzsize);
	void Splat(D3DVECTOR p, float falpha, D3DVECTOR fcolor,	D3DXVECTOR4 *pVolume); // used by GenVolume
	HRESULT SetHairLightingMaterial(D3DMATERIAL8 *pMaterial);
	void GetLinesVertexBuffer(IDirect3DVertexBuffer8 **ppVB);
	void RenderLines();
	void RenderGeometryTexture(CXFPatchMesh *pmesh);
	void Render(float lod, CXFPatchMesh *pmesh);
	void Save(char *fname, int flags);
	void Load(char *fname);


	
	void SetPatchSize(float x, float z)
	{
		m_fXSize = x;
		m_fZSize = z;
		InitFuzz(m_dwNumFuzz, m_dwNumFuzzLib);	// re-init the fuzz. automatically sets ysize
	};

	void SetFVel(float cx, float cy, float cz, float rx, float ry, float rz)
	{
		m_fuzzCenter.dp.x = cx; m_fuzzCenter.dp.y = cy; m_fuzzCenter.dp.z = cz;
		m_fuzzRandom.dp.x = rx; m_fuzzRandom.dp.y = ry; m_fuzzRandom.dp.z = rz;
	};

	void SetFAcc(float cx, float cy, float cz, float rx, float ry, float rz)
	{
		m_fuzzCenter.ddp.x = cx; m_fuzzCenter.ddp.y = cy; m_fuzzCenter.ddp.z = cz;
		m_fuzzRandom.ddp.x = rx; m_fuzzRandom.ddp.y = ry; m_fuzzRandom.ddp.z = rz;
	};
	
};

HRESULT FillHairLightingTexture(D3DMATERIAL8 *pMaterial, LPDIRECT3DTEXTURE8 pTexture);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 3UL

#define Resource_BaseOctave1_OFFSET 0UL
#define Resource_Octave2_OFFSET 20UL
#define Resource_Octave3_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\DisplacementMap.cpp ===
//-----------------------------------------------------------------------------
// File: DisplacementMap.cpp
//
// Desc: Displacement mapping on the Xbox GPU takes advantage of the
//  unified memory architecture.
// 
//  A preprocess step is required to split the "carrier" mesh into
//  small neighborhoods of vertices that can fit into vertex shader
//  constants.
//
//  Instead of using vertex shader constants to do indexed skinning,
//  we use the constants as a way to apply a "geometry texture."  The
//  carrier mesh vertices define a local, warped coordinate system
//  that maps the displacement height field to the surface of the
//  carrier mesh.
//
//  The weights and indices are obtained by rendering to three small
//  textures. The first texture sets the blending weights for each
//  triangle in the carrier mesh.  The second texture sets the palette
//  indices for each triangle.  The third texture samples the
//  displacement map at the current region and level-of-detail.
//  
//  Finally, the blending weights, indices, and offsets calculated in
//  the previous step are passed as textures through the displacement
//  vertex shader. The output position is a blend of the carrier mesh
//  vertices plus the displacement map offset times a blend of the
//  carrier mesh normals.
//
//  NOTE: The weight, index, and sampled displacement textures
//  are used as vertex buffer data and sent through the vertex shader.
//
// Hist: 11.14.01 - Created
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>
#include "Media/Shaders/Displacement.h"

#ifdef _DEBUG
// DebugPixels is useful to see the intermediate texture results.  Set
// a breakpoint in the RenderToDisplacementTextures function, and then
// in a watch window, type DebugPixels(m_pWeightTexture, 0) to display
// the weight texture, or DebugPixels(m_pIndexTexture, 0) to display
// the indices, or DebugPixels(m_pDisplacementTexture, 0) to display
// the displacements.
#pragma comment( linker, "/include:_DebugPixels" )
#include <XBMediaDebug.h>
#endif


// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"


//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
	{ XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate\nObject" },
	{ XBHELP_A_BUTTON,     XBHELP_PLACEMENT_2, L"Next\nDraw Mode" },
	{ XBHELP_B_BUTTON,     XBHELP_PLACEMENT_2, L"Previous\nDraw Mode" },
	{ XBHELP_WHITE_BUTTON, XBHELP_PLACEMENT_2, L"Toggle\nPoint Drawing" },
	{ XBHELP_DPAD,         XBHELP_PLACEMENT_2, L"Select Parameter\nand Channel" },
	{ XBHELP_LEFT_BUTTON,  XBHELP_PLACEMENT_2, L"Decrease\nParameter" },
	{ XBHELP_RIGHT_BUTTON, XBHELP_PLACEMENT_2, L"Increase\nParameter" },
	{ XBHELP_MISC_CALLOUT, XBHELP_PLACEMENT_2, L"Triggers adjust current parameter" },
	{ XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
};

#define NUM_HELP_CALLOUTS ( sizeof( g_HelpCallouts ) / sizeof( g_HelpCallouts[0] ) )


//-----------------------------------------------------------------------------
// Vertex for carrier mesh
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 position;   // The position
    D3DXVECTOR3 normal;     // The vertex normals
	FLOAT tu, tv;			// texture coords
};

// Our custom FVF, which describes our custom vertex structure
#define FVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)


struct WEIGHTVERTEX {
	D3DXVECTOR4 xyzrhw;
	D3DCOLOR diffuse;
};

#define FVF_WEIGHTVERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)

struct INDEXVERTEX {
	D3DXVECTOR4 xyzrhw;
	D3DCOLOR diffuse;
};
#define FVF_INDEXVERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)



//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//		 from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
	CXBPackedResource  m_xprResource;	   // Packed resources for the app
	CXBFont			   m_Font;			   // Font object
	CXBHelp			   m_Help;			   // Help object
	BOOL		m_bDrawHelp;		    // TRUE to draw help screen
	
    LPDIRECT3DTEXTURE8 m_rpDisplacementMap[4];	   // Displacement maps
    LPDIRECT3DVERTEXBUFFER8 m_pCarrierVB;  // carrier mesh vertices
    LPDIRECT3DINDEXBUFFER8  m_pCarrierIB;  // carrier mesh triangles
    LPDIRECT3DVERTEXBUFFER8 m_pWeightVB;  // carrier mesh weight vertices
    LPDIRECT3DVERTEXBUFFER8 m_pIndexVB;  // carrier mesh index vertices
#define WIDTH 128
#define HEIGHT 128	
    LPDIRECT3DTEXTURE8 m_pWeightTexture;	// render target for weight texture
	LPDIRECT3DSURFACE8 m_pWeightSurface;	// most detailed weight texture level
	D3DVertexBuffer m_WeightVertexBuffer;	// fake vertex buffer header that points to the weight texture data
	
    LPDIRECT3DTEXTURE8 m_pIndexTexture;	 	// render target for Index texture
	LPDIRECT3DSURFACE8 m_pIndexSurface;	 	// most detailed Index texture level
	D3DVertexBuffer m_IndexVertexBuffer; 	// fake vertex buffer header that points to the index texture data
	
    LPDIRECT3DTEXTURE8 m_pDisplacementTexture;	 	// render target for Displacement texture
	LPDIRECT3DSURFACE8 m_pDisplacementSurface;	 	// most detailed Displacement texture level
	D3DVertexBuffer m_DisplacementVertexBuffer; 	// fake vertex buffer header that points to the index texture data
	LPDIRECT3DINDEXBUFFER8 m_pDisplacementIndexBuffer;	// index buffer to draw quads
	
	DWORD m_dwDisplacementVertexShader;  	// displacement vertex shader
	FLOAT m_rfDisplacementScale[4];
	FLOAT m_rfDisplacementOffset[4];
	FLOAT m_rfMipmapBias[4];
	
	UINT m_iCurrentDisplacementMap;
	enum DrawMode {
		DRAW_DISPLACED_MESH,
		DRAW_MESH,
		DRAW_WEIGHTS,
		DRAW_INDICES,
		_DRAW_MAX
	} m_DrawMode;
	BOOL		m_bDrawPoints;		// TRUE to draw displaced points instead of mesh
	enum TweakMode {
		TWEAK_DISPLACEMENT_SCALE,
		TWEAK_DISPLACEMENT_OFFSET,
		TWEAK_MIPMAP_BIAS,
		_TWEAK_MAX
	} m_TweakMode;					// tweak mode detrmines what triggers do
	FLOAT		m_TweakActive;		// tweaking in progess if > zero
public:
	CXBoxSample();

	HRESULT RenderToDisplacementTextures();
	HRESULT DrawMesh();
	HRESULT DrawWeights();
	HRESULT DrawIndices();
	HRESULT DrawDisplacedMesh();
	

	virtual HRESULT Initialize();
	virtual HRESULT Render();
	virtual HRESULT FrameMove();	
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
	CXBoxSample xbApp;
	if( FAILED( xbApp.Create() ) )
		return;
	xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
			:CXBApplication()
{
#ifdef _DEBUG
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;	// Allow unlimited frame rate
#endif
	m_bDrawHelp = FALSE;
	m_dwDisplacementVertexShader = 0;
	m_rpDisplacementMap[0] = NULL;
	m_rpDisplacementMap[1] = NULL;
	m_rpDisplacementMap[2] = NULL;
	m_rpDisplacementMap[3] = NULL;
	m_pCarrierVB = NULL;
	m_pCarrierIB = NULL;
	m_pWeightVB = NULL;
	m_pIndexVB = NULL;
	m_pWeightTexture = NULL;
	m_pWeightSurface = NULL;
	m_pIndexTexture = NULL;
	m_pIndexSurface = NULL;
	m_pDisplacementTexture = NULL;
	m_pDisplacementSurface = NULL;
	m_pDisplacementIndexBuffer = NULL;
	m_dwDisplacementVertexShader = 0;
	m_rfDisplacementScale[0] = 0.1f;
	m_rfDisplacementScale[1] = 0.05f;
	m_rfDisplacementScale[2] = 0.025f;
	m_rfDisplacementScale[3] = 0.0125f;
	m_rfDisplacementOffset[0] = -0.5f * m_rfDisplacementScale[0];
	m_rfDisplacementOffset[1] = -0.5f * m_rfDisplacementScale[1];
	m_rfDisplacementOffset[2] = -0.5f * m_rfDisplacementScale[2];
	m_rfDisplacementOffset[3] = -0.5f * m_rfDisplacementScale[3];
	m_rfMipmapBias[0] =
		m_rfMipmapBias[1] =
		m_rfMipmapBias[2] =
		m_rfMipmapBias[3] = -2.f; // bias displacement maps mip level to be sharper
	m_iCurrentDisplacementMap = 0;
	m_DrawMode = DRAW_DISPLACED_MESH;
	m_bDrawPoints = FALSE;
	m_TweakMode = TWEAK_DISPLACEMENT_SCALE;
	m_TweakActive = 0.f;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
	HRESULT hr;
	
	// Create a font
	if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Create help
	if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
		return XBAPPERR_MEDIANOTFOUND;

	// Create the resources
	if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
									  Resource_NUM_RESOURCES, NULL) ) )
		return XBAPPERR_MEDIANOTFOUND;

    // Get texture pointers
    m_rpDisplacementMap[0] = m_xprResource.GetTexture( Resource_BaseOctave1_OFFSET );
	m_rpDisplacementMap[1] = m_xprResource.GetTexture( Resource_Octave2_OFFSET );
	m_rpDisplacementMap[2] = m_xprResource.GetTexture( Resource_Octave3_OFFSET );
	m_rpDisplacementMap[3] = m_xprResource.GetTexture( Resource_Octave2_OFFSET );	// Use scaled version of octave 2 for octave 4

	// Set the carrier mesh vertices
#define SAMPLE_COUNT 8
#define VERTEX_COUNT (SAMPLE_COUNT * SAMPLE_COUNT)
#define TRIANGLE_COUNT ((SAMPLE_COUNT - 1)*(SAMPLE_COUNT - 1)*2)
#define INDEX_COUNT (3*TRIANGLE_COUNT)
	if( FAILED( m_pd3dDevice->CreateVertexBuffer( VERTEX_COUNT*sizeof(CUSTOMVERTEX),
                                                  0, FVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &m_pCarrierVB ) ) )
        return E_FAIL;
    CUSTOMVERTEX *rVertex;
    if( FAILED( m_pCarrierVB->Lock( 0, 0, (BYTE**)&rVertex, 0 ) ) )
        return E_FAIL;
	FLOAT fScale = 1.f / (SAMPLE_COUNT - 1);
	FLOAT fRadius = 1.2f;
    for(UINT i=0; i<SAMPLE_COUNT; i++ )
	{
		FLOAT theta = 0.6f * D3DX_PI * (i * fScale - 1.2f);
		FLOAT s = sinf(theta);
		FLOAT c = cosf(theta);
		for(UINT j=0; j<SAMPLE_COUNT; j++ )
		{
			CUSTOMVERTEX *pv = &rVertex[ i * SAMPLE_COUNT + j ];
			pv->position = D3DXVECTOR3( fScale * j * 2.f - 1.f, fRadius * c, fRadius * s);
			pv->normal = D3DXVECTOR3( 0, fRadius * c, fRadius * s);
			pv->tu = fScale * j;
			pv->tv = fScale * i;
		}
	}

	// Keep the carrier vertex buffer locked to copy out the weight and index vertices
    // m_pCarrierVB->Unlock();

	// Set the carrier mesh indices
	if( FAILED( m_pd3dDevice->CreateIndexBuffer( INDEX_COUNT*sizeof(WORD),
												 0, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pCarrierIB ) ) )
        return E_FAIL;
	WORD *pIndices;
	if( FAILED( m_pCarrierIB->Lock( 0, 0, (BYTE**)&pIndices, 0 ) ) )
		return E_FAIL;
	UINT iiTri = 0;
	for (WORD iY = 0; iY < SAMPLE_COUNT - 1; iY++ )
	{
		for (WORD iX = 0; iX < SAMPLE_COUNT - 1; iX++ )
		{
			WORD iVertex = iY * SAMPLE_COUNT + iX;

			// tri 0
			pIndices[iiTri] = iVertex;
			pIndices[iiTri+1] = iVertex + SAMPLE_COUNT;
			pIndices[iiTri+2] = iVertex + SAMPLE_COUNT + 1;
			
			// tri 1
			pIndices[iiTri+3] = iVertex;
			pIndices[iiTri+4] = iVertex + SAMPLE_COUNT + 1;
			pIndices[iiTri+5] = iVertex + 1;

			iiTri += 6;
		}
	}
	// Keep the carrier index buffer locked to copy out the weight and index vertices
	// m_pCarrierIB->Unlock();

	// Set the weight mesh, which consists of all the triangles
	// of the base mesh annotated with blend weights r,g,b.
	if( FAILED( m_pd3dDevice->CreateVertexBuffer( INDEX_COUNT*sizeof(CUSTOMVERTEX),
                                                  0, FVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &m_pWeightVB ) ) )
        return E_FAIL;
	WEIGHTVERTEX *pWeightVertex;
	if( FAILED( m_pWeightVB->Lock( 0, 0, (BYTE**)&pWeightVertex, 0 ) ) )
		return E_FAIL;
	FLOAT fXScale = WIDTH;
	FLOAT fXOffset = 0.f;
	FLOAT fYScale = HEIGHT;
	FLOAT fYOffset = 0.f;
	WORD *pIndex = pIndices;
	for (UINT iTriangle = 0; iTriangle < TRIANGLE_COUNT; iTriangle++)
	{
		CUSTOMVERTEX *pV0 = &rVertex[*pIndex++];
		CUSTOMVERTEX *pV1 = &rVertex[*pIndex++];
		CUSTOMVERTEX *pV2 = &rVertex[*pIndex++];
		pWeightVertex->xyzrhw = D3DXVECTOR4(pV0->tu * fXScale + fXOffset, pV0->tv * fYScale + fYOffset, 0.5f, 1.f);
		pWeightVertex->diffuse = D3DXCOLOR( 1.f, 0.f, 0.f, 1.f );
		pWeightVertex++;
		pWeightVertex->xyzrhw = D3DXVECTOR4(pV1->tu * fXScale + fXOffset, pV1->tv * fYScale + fYOffset, 0.5f, 1.f);
		pWeightVertex->diffuse = D3DXCOLOR( 0.f, 1.f, 0.f, 1.f );
		pWeightVertex++;
		pWeightVertex->xyzrhw = D3DXVECTOR4(pV2->tu * fXScale + fXOffset, pV2->tv * fYScale + fYOffset, 0.5f, 1.f);
		pWeightVertex->diffuse = D3DXCOLOR( 0.f, 0.f, 1.f, 1.f );
		pWeightVertex++;
	}
	m_pWeightVB->Unlock();
	
	// Set the index mesh, which consists of all the triangles
	// of the base mesh annotated with blend indices
	if( FAILED( m_pd3dDevice->CreateVertexBuffer( INDEX_COUNT*sizeof(CUSTOMVERTEX),
                                                  0, FVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &m_pIndexVB ) ) )
        return E_FAIL;
	INDEXVERTEX *pIndexVertex;
	if( FAILED( m_pIndexVB->Lock( 0, 0, (BYTE**)&pIndexVertex, 0 ) ) )
		return E_FAIL;
	pIndex = pIndices;
	FLOAT fIndexScale = 1.f / VERTEX_COUNT;
	for (UINT iTriangle = 0; iTriangle < TRIANGLE_COUNT; iTriangle++)
	{
		FLOAT fIndex0 = (*pIndex + 0.5f) * fIndexScale;
		CUSTOMVERTEX *pV0 = &rVertex[*pIndex++];
		FLOAT fIndex1 = (*pIndex + 0.5f) * fIndexScale;
		CUSTOMVERTEX *pV1 = &rVertex[*pIndex++];
		FLOAT fIndex2 = (*pIndex + 0.5f) * fIndexScale;
		CUSTOMVERTEX *pV2 = &rVertex[*pIndex++];
		D3DCOLOR IndexColor = D3DXCOLOR(fIndex0, fIndex1, fIndex2, 1.f);
		pIndexVertex->xyzrhw = D3DXVECTOR4(pV0->tu * fXScale + fXOffset, pV0->tv * fYScale + fYOffset, 0.5f, 1.f);
		pIndexVertex->diffuse = IndexColor;
		pIndexVertex++;
		pIndexVertex->xyzrhw = D3DXVECTOR4(pV1->tu * fXScale + fXOffset, pV1->tv * fYScale + fYOffset, 0.5f, 1.f);
		pIndexVertex->diffuse = IndexColor;
		pIndexVertex++;
		pIndexVertex->xyzrhw = D3DXVECTOR4(pV2->tu * fXScale + fXOffset, pV2->tv * fYScale + fYOffset, 0.5f, 1.f);
		pIndexVertex->diffuse = IndexColor;
		pIndexVertex++;
	}
	m_pIndexVB->Unlock();
	
	// Unlock the carrier mesh vertex and index buffers
	m_pCarrierIB->Unlock();
    m_pCarrierVB->Unlock();

	// Create the weight texture
	D3DFORMAT Format = D3DFMT_A8R8G8B8;	// must use swizzled format texture, otherwise memory may have a stride
	hr = m_pd3dDevice->CreateTexture(WIDTH, HEIGHT, 1, D3DUSAGE_RENDERTARGET, Format, 0, &m_pWeightTexture);
	if (FAILED(hr))
		return hr;
	hr = m_pWeightTexture->GetSurfaceLevel(0, &m_pWeightSurface);
	if (FAILED(hr))
		return hr;
	ZeroMemory( &m_WeightVertexBuffer, sizeof(D3DVertexBuffer) );
	XGSetVertexBufferHeader( WIDTH * HEIGHT * 4, 0, D3DFVF_DIFFUSE, 0, &m_WeightVertexBuffer, m_pWeightSurface->Data);
		
	// Create the index texture
	hr = m_pd3dDevice->CreateTexture(WIDTH, HEIGHT, 1, D3DUSAGE_RENDERTARGET, Format, 0, &m_pIndexTexture);
	if (FAILED(hr))
		return hr;
	hr = m_pIndexTexture->GetSurfaceLevel(0, &m_pIndexSurface);
	if (FAILED(hr))
		return hr;
	ZeroMemory( &m_IndexVertexBuffer, sizeof(D3DVertexBuffer) );
	XGSetVertexBufferHeader( WIDTH * HEIGHT * 4, 0, D3DFVF_DIFFUSE, 0, &m_IndexVertexBuffer, m_pIndexSurface->Data);

	// Create the displacement texture
	hr = m_pd3dDevice->CreateTexture(WIDTH, HEIGHT, 1, D3DUSAGE_RENDERTARGET, Format, 0, &m_pDisplacementTexture);
	if (FAILED(hr))
		return hr;
	hr = m_pDisplacementTexture->GetSurfaceLevel(0, &m_pDisplacementSurface);
	if (FAILED(hr))
		return hr;
	ZeroMemory( &m_DisplacementVertexBuffer, sizeof(D3DVertexBuffer) );
	XGSetVertexBufferHeader( WIDTH * HEIGHT * 4, 0, D3DFVF_DIFFUSE, 0, &m_DisplacementVertexBuffer, m_pDisplacementSurface->Data);

	// Create and fill the displacement index buffer for drawing quads.
	// Since the textures above are swizzled, we have to account for
	// this in the quad-drawing index buffer.  We should have good memory
	// locality by following the swizzled order.
#define QUAD_COUNT ((WIDTH-1)*(HEIGHT-1))
	if( FAILED( m_pd3dDevice->CreateIndexBuffer( 4*QUAD_COUNT*sizeof(WORD),
												 0, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &m_pDisplacementIndexBuffer ) ) )
		return E_FAIL;
	Swizzler s(WIDTH, HEIGHT, 0);
	WORD *pQuadIndices;
	if( FAILED( m_pDisplacementIndexBuffer->Lock( 0, 0, (BYTE**)&pQuadIndices, 0 ) ) )
		return E_FAIL;
	// walk through vertices in swizzled order
	UINT iiQuad = 0;
	for (SWIZNUM iVertex = 0; iVertex < WIDTH * HEIGHT; iVertex++)
	{
		DWORD U = s.UnswizzleU(iVertex);
		if (U == WIDTH - 1)
			continue; // skip U boundary
		DWORD V = s.UnswizzleV(iVertex);
		if (V == HEIGHT - 1)
			continue; // skip V boundary
		pQuadIndices[iiQuad++] = (WORD)iVertex; // s.Swizzle(U, V, 0);
		pQuadIndices[iiQuad++] = (WORD)s.Swizzle(U + 1, V, 0);
		pQuadIndices[iiQuad++] = (WORD)s.Swizzle(U + 1, V + 1, 0);
		pQuadIndices[iiQuad++] = (WORD)s.Swizzle(    U, V + 1, 0);
	}
	m_pDisplacementIndexBuffer->Unlock();

	// Load the displacement vertex shader
	DWORD vsdecl[] = 
	{
		D3DVSD_STREAM(0),
		D3DVSD_REG(0, D3DVSDT_D3DCOLOR),    // indices
		D3DVSD_STREAM(1),
		D3DVSD_REG(1, D3DVSDT_D3DCOLOR),    // weights
		D3DVSD_STREAM(2),
		D3DVSD_REG(2, D3DVSDT_D3DCOLOR),    // displacement
		D3DVSD_END()
	};
	XBUtil_CreateVertexShader(g_pd3dDevice, "Shaders\\displacement.xvu", vsdecl, &m_dwDisplacementVertexShader );
	if (m_dwDisplacementVertexShader == 0)
		return E_FAIL;
				
    // Setup a base material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

	// Perform object rotation
	D3DXMATRIX matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
	m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

	// Set up view matrix
	D3DXMATRIX	matView;
	D3DXVECTOR3 vEyePt	  = D3DXVECTOR3( 0.0f, 0.0f,-4.0f );
	D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
	D3DXVECTOR3 vUpVec	  = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
	D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
	m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

	// Set up proj matrix
	D3DXMATRIX matProj;
	D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
	m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	// Toggle help
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
	{
		m_bDrawHelp = !m_bDrawHelp;
	}

    // Cycle through draw modes
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
		m_DrawMode = (DrawMode)((INT)m_DrawMode + 1);
		if (m_DrawMode == _DRAW_MAX)
			m_DrawMode = (DrawMode)0;
    }
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
    {
		if (m_DrawMode == (DrawMode)0)
			m_DrawMode = (DrawMode)((INT)_DRAW_MAX - 1);
		else
			m_DrawMode = (DrawMode)((INT)m_DrawMode - 1);
    }

	// Toggle point drawing
	if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
    {
		m_bDrawPoints = !m_bDrawPoints;
    }

	// Cycle through displacement maps
	if ( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
	{
		if (m_iCurrentDisplacementMap == 3)
			m_iCurrentDisplacementMap = 0;
		else
			m_iCurrentDisplacementMap++;
	}
	if ( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT )
	{
		if (m_iCurrentDisplacementMap == 0)
			m_iCurrentDisplacementMap = 3;
		else
			m_iCurrentDisplacementMap--;
	}

	// Cycle through tweak modes
	if ( m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP 
		 || m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN 
		 || m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT 
		 || m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT )
		m_TweakActive = 2.f; // keep tweak display showing while DPAD is pressed
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN )
    {
		m_TweakMode = (TweakMode)((INT)m_TweakMode + 1);
		if (m_TweakMode == _TWEAK_MAX)
			m_TweakMode = (TweakMode)0;
    }
	if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP )
    {
		if (m_TweakMode == (TweakMode)0)
			m_TweakMode = (TweakMode)((INT)_TWEAK_MAX - 1);
		else
			m_TweakMode = (TweakMode)((INT)m_TweakMode - 1);
    }


	// Handling parameter tweaking
	int delta = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] 
		- m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER];
	if (delta)
	{
		if (m_TweakMode == TWEAK_DISPLACEMENT_SCALE)
		{
			static float fDeltaScale = 0.001f;
			m_rfDisplacementScale[m_iCurrentDisplacementMap] += m_fElapsedTime * delta * fDeltaScale;
			m_TweakActive = 1.f;
		}
		else if (m_TweakMode == TWEAK_DISPLACEMENT_OFFSET)
		{
			static float fDeltaScale = 0.001f;
			m_rfDisplacementOffset[m_iCurrentDisplacementMap] += m_fElapsedTime * delta * fDeltaScale;
			m_TweakActive = 1.f;
		}
		else if (m_TweakMode == TWEAK_MIPMAP_BIAS)
		{
			static float fDeltaScale = 0.01f;
			m_rfMipmapBias[m_iCurrentDisplacementMap] += m_fElapsedTime * delta * fDeltaScale;
			m_TweakActive = 1.f;
		}
	}
	else if (m_TweakActive > 0.f)	// keep the tweaking debug display active for a while
		m_TweakActive -= m_fElapsedTime;

	// Perform object rotation
	static D3DXMATRIX matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
	D3DXMATRIX matRotate;
	FLOAT fXRotate = m_DefaultGamepad.fX1 * m_fElapsedTime * D3DX_PI * 0.5f;
	FLOAT fYRotate = m_DefaultGamepad.fY1 * m_fElapsedTime * D3DX_PI * 0.5f;
	D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, fYRotate, 0.0f );
	D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );
	m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

	return S_OK;
}



//-----------------------------------------------------------------------------
// Name: RenderToDisplacementTextures
// Desc: Draw the UV triangles into the weight and index textures
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderToDisplacementTextures()
{
    // Set render state
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,	  FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,		  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,		  D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_COLORVERTEX,      TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTexture( 0, 0 );

	// To the weight texture, render the mesh UV triangles with
	// interpolated RGB weights.
	m_pd3dDevice->SetRenderTarget(m_pWeightSurface, NULL);
	m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xffff00ff, 1.0f, 0L );
    m_pd3dDevice->SetStreamSource( 0, m_pWeightVB, sizeof(WEIGHTVERTEX) );
	m_pd3dDevice->SetVertexShader( FVF_WEIGHTVERTEX );
	m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, TRIANGLE_COUNT);
	
	// To the index texture, render the mesh UV triangles with vertex
	// index colors constant across the triangle.
	m_pd3dDevice->SetRenderTarget(m_pIndexSurface, NULL);
	m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xff00ff00, 1.0f, 0L );
    m_pd3dDevice->SetStreamSource( 0, m_pIndexVB, sizeof(INDEXVERTEX) );
	m_pd3dDevice->SetVertexShader( FVF_INDEXVERTEX );
	m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, TRIANGLE_COUNT);

	// To the displacement texture, render current displacement region.
	m_pd3dDevice->SetRenderTarget(m_pDisplacementSurface, NULL);
	FLOAT WIDTHOFFSET = 0.5f / WIDTH;
	FLOAT HEIGHTOFFSET = 0.5f / HEIGHT;
	struct Vertex {
		FLOAT xyzrhw[4];
		FLOAT tex1[2];
		FLOAT tex2[2];
		FLOAT tex3[2];
		FLOAT tex4[2];
	} rVertex[4] = {
		// The texture scaling should also be tweakable to change the
		// character of how the displacements scales interact.  Here
		// we hard-code powers of two.
		{       - WIDTHOFFSET,        - HEIGHTOFFSET, 0.5f, 1.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f },
		{ WIDTH - WIDTHOFFSET,        - HEIGHTOFFSET, 0.5f, 1.f, 1.f, 0.f, 2.f, 0.f, 4.f, 0.f, 8.f, 0.f },
		{ WIDTH - WIDTHOFFSET, HEIGHT - HEIGHTOFFSET, 0.5f, 1.f, 1.f, 1.f, 2.f, 2.f, 4.f, 4.f, 8.f, 8.f },
		{       - WIDTHOFFSET, HEIGHT - HEIGHTOFFSET, 0.5f, 1.f, 0.f, 1.f, 0.f, 2.f, 0.f, 4.f, 0.f, 8.f },
	};
	m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_TEX4 );
	{
#pragma warning( push )
#pragma warning( disable : 4245 )	// ignore conversion of int to DWORD
		
		// Use pre-compiled channel pixel shader that maps texture 0
		// to red, 1 to green, 2 to blue, and 3 to alpha.
#include "Media/Shaders/channel.lst"
		m_pd3dDevice->SetPixelShaderProgram( &psd );
		
#pragma warning( pop )
	}
	UINT i;
	for (i = 0; i < 4; i++)
	{
		m_pd3dDevice->SetTexture( i, m_rpDisplacementMap[i] );
		m_pd3dDevice->SetTextureStageState( i, D3DTSS_TEXCOORDINDEX, i );
		m_pd3dDevice->SetTextureStageState( i, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
		m_pd3dDevice->SetTextureStageState( i, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
		m_pd3dDevice->SetTextureStageState( i, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
		m_pd3dDevice->SetTextureStageState( i, D3DTSS_MIPMAPLODBIAS, FtoDW(m_rfMipmapBias[i]));
		m_pd3dDevice->SetTextureStageState( i, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
		m_pd3dDevice->SetTextureStageState( i, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
	}
	m_pd3dDevice->DrawPrimitiveUP(D3DPT_QUADLIST, 1, rVertex, sizeof(Vertex));

	// Reset state
	m_pd3dDevice->SetPixelShader(0);
	for (i = 0; i < 4; i++)
	{
		m_pd3dDevice->SetTexture( i, NULL );
	}
	return S_OK;
}



//-----------------------------------------------------------------------------
// Name: DrawDisplacedMesh
// Desc: Send the displacement textures through the vertex shader
//       to draw the displaced mesh.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawDisplacedMesh()
{
	// Larger mesh objects need to be broken into contiguous vertex
	// neighborhoods that will fit into the vertex shader constants
	// for this technique to work.
	//
	// Here, we have a relative small number of vertices in the
	// carrier mesh, so we need just one pass.
	m_pd3dDevice->SetShaderConstantMode(D3DSCM_192CONSTANTS);
	
	m_pd3dDevice->SetVertexShader( m_dwDisplacementVertexShader );
	
	// Set the vertex shader transformation matrix
	D3DXMATRIX matWorld;
	m_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorld );
	D3DXMATRIX matView;
	m_pd3dDevice->GetTransform( D3DTS_VIEW, &matView);
	D3DXMATRIX matProjection;
	m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProjection);
	D3DXMATRIX matComposite;
	D3DXMatrixMultiply( &matComposite, &matWorld, &matView );
	D3DXMatrixMultiply( &matComposite, &matComposite, &matProjection );
	D3DXMatrixTranspose( &matComposite, &matComposite );
	m_pd3dDevice->SetVertexShaderConstant( VSC_WORLDVIEWPROJECTION, &matComposite, 4 );

	// Set index scaling
	D3DXVECTOR4 Index( VERTEX_COUNT, 0, 0, 0 );
	m_pd3dDevice->SetVertexShaderConstant( VSC_INDEX, &Index, 1 );

	// Set displacement scaling and offset
	for (UINT i = 0; i < 4; i++)
	{
		D3DXVECTOR4 Displacement( m_rfDisplacementScale[i], m_rfDisplacementOffset[i], 0, 0 );
		m_pd3dDevice->SetVertexShaderConstant( VSC_DISPLACEMENT + i, &Displacement, 1 );
	}

	// Set other vertex shader constants
	D3DXVECTOR4 Ones(1.f, 1.f, 1.f, 1.f);
	m_pd3dDevice->SetVertexShaderConstant( VSC_ONES, &Ones, 1 );
	FLOAT fScale = (FLOAT)(1 << m_iCurrentDisplacementMap);
	D3DXVECTOR4 Scale(fScale, fScale, fScale, fScale);
	m_pd3dDevice->SetVertexShaderConstant( VSC_TEXTURESCALE, &Scale, 1 );

	// Set vertex palette
	// TODO: create a PushBuffer resource with all of this data once to
	// avoid all this copying.
    CUSTOMVERTEX *pVertex;
    if( FAILED( m_pCarrierVB->Lock( 0, 0, (BYTE**)&pVertex, 0 ) ) )
        return E_FAIL;
    for(INT i=0; i<VERTEX_COUNT; i++ )
    {
		CUSTOMVERTEX *pv = pVertex++;
		D3DXVECTOR4 c0(pv->position.x, pv->position.y, pv->position.z, pv->tu);
		m_pd3dDevice->SetVertexShaderConstant( VSC_CARRIER_VERTEX_PALETTE + i, &c0, 1);
		D3DXVECTOR4 c1(pv->normal.x, pv->normal.y, pv->normal.z, pv->tv);
		m_pd3dDevice->SetVertexShaderConstant( VSC_CARRIER_NORMAL_PALETTE + i, &c1, 1);
	}
    m_pCarrierVB->Unlock();
	
    // Set render state
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,	TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,		TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,   TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR,	0xffffffff );
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,		D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,       FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTexture( 0, m_rpDisplacementMap[m_iCurrentDisplacementMap] );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPMAPLODBIAS, FtoDW(m_rfMipmapBias[m_iCurrentDisplacementMap]) );	
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
 
    // Draw the object
    m_pd3dDevice->SetStreamSource( 0, &m_IndexVertexBuffer, sizeof(D3DCOLOR) );
    m_pd3dDevice->SetStreamSource( 1, &m_WeightVertexBuffer, sizeof(D3DCOLOR) );
    m_pd3dDevice->SetStreamSource( 2, &m_DisplacementVertexBuffer, sizeof(D3DCOLOR) );
	
	if (m_bDrawPoints)
	{
		// Draw as points for showing the sampling grid
		static float fPointSize = 2.f;
		m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE, FtoDW(fPointSize) );
		m_pd3dDevice->DrawPrimitive( D3DPT_POINTLIST, 0, WIDTH * HEIGHT);
	}
	else
	{
		// Draw as quads
		m_pd3dDevice->SetIndices(m_pDisplacementIndexBuffer, 0);
		m_pd3dDevice->DrawIndexedPrimitive( D3DPT_QUADLIST, 0, 4*QUAD_COUNT, 0, QUAD_COUNT);
	}

	m_pd3dDevice->SetShaderConstantMode(D3DSCM_96CONSTANTS);
	return S_OK;
}



//-----------------------------------------------------------------------------
// Name: DrawMesh
// Desc: Draws the carrier mesh.  This is used to demonstrate the visual 
//       difference and the performace difference between standard texture
//       mapping and displacement mapping.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawMesh()
{
    // Set render state
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,	TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,		TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,   TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,		0xffffffff );
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,		D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,       TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPMAPLODBIAS, FtoDW(m_rfMipmapBias[m_iCurrentDisplacementMap]));	
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTexture( 0, m_rpDisplacementMap[m_iCurrentDisplacementMap] );
	D3DXMATRIX matTexture;
	FLOAT fScale = (FLOAT)(1 << m_iCurrentDisplacementMap);
	D3DXMatrixScaling(&matTexture, fScale, fScale, fScale);
	m_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &matTexture );

    // Draw the object
    m_pd3dDevice->SetStreamSource( 0, m_pCarrierVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetIndices( m_pCarrierIB, 0 );
	m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
	m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, INDEX_COUNT, 0, TRIANGLE_COUNT);

	// Restore state
	m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawWeights
// Desc: Draws the carrier mesh colored with the weight assignments. This 
//       is used to demonstrate the per-displaced-vertex weight computed
//       on the fly using the GPU.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawWeights()
{
    // Set render state
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,	TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,		TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,   TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR,	0xffffffff );
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,		D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,       FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTexture( 0, m_pWeightTexture );

    // Draw the object
    m_pd3dDevice->SetStreamSource( 0, m_pCarrierVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetIndices( m_pCarrierIB, 0 );
	m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
	m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, INDEX_COUNT, 0, TRIANGLE_COUNT);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawIndices
// Desc: Draws the carrier mesh textures with the index assignments. This 
//       is used to demonstrate the computed per-displaced-vertex indices.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawIndices()
{
    // Set render state
	m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,	TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,		TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,   TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR,	0xffffffff );
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,		D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,       FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTexture( 0, m_pIndexTexture );

    // Draw the object
    m_pd3dDevice->SetStreamSource( 0, m_pCarrierVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetIndices( m_pCarrierIB, 0 );
	m_pd3dDevice->SetVertexShader( FVF_CUSTOMVERTEX );
	m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, INDEX_COUNT, 0, TRIANGLE_COUNT);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	// Draw into the current displacement map textures
	RenderToDisplacementTextures();

	// Set the render target to the backbuffer
	m_pd3dDevice->SetRenderTarget(m_pBackBuffer, m_pDepthBuffer);
	
	// Clear the zbuffer
	m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

	// Draw a gradient filled background
	RenderGradientBackground( 0xff404040, 0xff404080 );

	// Draw the object
	if (m_DrawMode == DRAW_MESH)
		DrawMesh();
	else if (m_DrawMode == DRAW_WEIGHTS)
		DrawWeights();
	else if (m_DrawMode == DRAW_INDICES)
		DrawIndices();
	else if (m_DrawMode == DRAW_DISPLACED_MESH)
		DrawDisplacedMesh();
	
	// Show title, frame rate, and help
	if( m_bDrawHelp )
		m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
	else
	{
		m_Font.Begin();
		if (m_DrawMode == DRAW_MESH)
			m_Font.DrawText(  64, 50, 0xffffffff, L"Texture Map" );
		else if (m_DrawMode == DRAW_WEIGHTS)
			m_Font.DrawText(  64, 50, 0xffffffff, L"Weight Map" );
		else if (m_DrawMode == DRAW_INDICES)
			m_Font.DrawText(  64, 50, 0xffffffff, L"Index Map" );
		else if (m_DrawMode == DRAW_DISPLACED_MESH)
			m_Font.DrawText(  64, 50, 0xffffffff, L"Displacement Map" );
		m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
		if (m_TweakActive > 0.f)
		{
			WCHAR buf[200];
			FLOAT x = 64, y = 50, dy = 30;
			swprintf(buf, L"scale[%d]=%f", m_iCurrentDisplacementMap, m_rfDisplacementScale[m_iCurrentDisplacementMap]);
			m_Font.DrawText(x, y += dy, (m_TweakMode == TWEAK_DISPLACEMENT_SCALE) ? 0xffffffff : 0xff00ff00 , buf);
			swprintf(buf, L"offset[%d]=%f", m_iCurrentDisplacementMap, m_rfDisplacementOffset[m_iCurrentDisplacementMap]);
			m_Font.DrawText(x, y += dy, (m_TweakMode == TWEAK_DISPLACEMENT_OFFSET) ? 0xffffffff : 0xff00ff00 , buf);
			swprintf(buf, L"mipmap bias[%d]=%f", m_iCurrentDisplacementMap, m_rfMipmapBias[m_iCurrentDisplacementMap]);
			m_Font.DrawText(x, y += dy, (m_TweakMode == TWEAK_MIPMAP_BIAS) ? 0xffffffff : 0xff00ff00 , buf);
		}
		m_Font.End();
	}

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define Resource_NUM_RESOURCES 3UL

#define Resource_BaseOctave1_OFFSET 0UL
#define Resource_Octave2_OFFSET 20UL
#define Resource_Octave3_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DisplacementMap\media\Shaders\displacement.h ===
// Vertex shader constants

// Avoid the special -37 and -38. This gives us 192 - 36 = 156 vertex palette
// slots to work with, which corresponds to a 78 vertex region, with xyz normal and uvs.
// If we want more, we should change to a screenspace vertex shader and use
// the slots below -36
#define VSC_WORLDVIEWPROJECTION -96
#define VSC_INDEX -92
#define VSC_DISPLACEMENT -91
#define VSC_DISPLACEMENT0 -91
#define VSC_DISPLACEMENT1 -90
#define VSC_DISPLACEMENT2 -89
#define VSC_DISPLACEMENT3 -88
#define VSC_ONES -87
#define VSC_TEXTURESCALE -86
#define VSC_CARRIER_VERTEX_PALETTE -36
#define VSC_CARRIER_NORMAL_PALETTE 28
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\dolphin\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\dolphin\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\dolphin\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\CompressedNormals\CompressedNormals.cpp ===
//-----------------------------------------------------------------------------
// File: CompressedNormals.cpp
//
// Desc: Example code showing how to use compressed normals.
//
// Hist: 05.02.00 - New for June XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle vertex\nshader" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 3




//-----------------------------------------------------------------------------
// Custom vertex structures
//-----------------------------------------------------------------------------
struct MODELVERTEX
{
    D3DXVECTOR3 p;       // Referenced as v0 in the vertex shader
    D3DXVECTOR3 n;       // Referenced as v2 in the vertex shader
};

// Same as model vertex, but with compressed normals
struct COMPRESSEDVERTEX
{
    D3DXVECTOR3 p;
    DWORD       n;
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBFont      m_Font;                         // Font class
    CXBHelp      m_Help;                         // Help class
    BOOL         m_bDrawHelp;                    // Whether to draw help

    BOOL         m_bUseProgrammableVertexShader; // Whether to use vertex shader

    DWORD        m_dwProgrammableVertexShader;   // Programmable vertex shader
    DWORD        m_dwFixedFunctionVertexShader;  // Fixed function vertex shader

    D3DXMATRIX   m_matWorld;

    CXBMesh*                m_pObject;           // Main geometry object
    LPDIRECT3DVERTEXBUFFER8 m_pObjectVB;         // Object components for rendering
    LPDIRECT3DINDEXBUFFER8  m_pObjectIB;
    D3DPRIMITIVETYPE        m_dwObjectPrimType;
    DWORD                   m_dwNumObjectSubsets;
    XBMESH_SUBSET*          m_pObjectSubsets;

    HRESULT CreateCompressedGeometry();

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp                    = FALSE;
    m_bUseProgrammableVertexShader = FALSE;
    
    m_pObject                      = new CXBMesh();
    
    m_dwProgrammableVertexShader   = 0L;
    m_dwFixedFunctionVertexShader  = 0L;
}




//-----------------------------------------------------------------------------
// Name: CreateCompressedGeometry()
// Desc: Clones the main geometry object, and compressed the vertex normals.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreateCompressedGeometry()
{
    // Gain acces to the mesh's vertices
    LPDIRECT3DVERTEXBUFFER8 pVB = &m_pObject->GetMesh(0)->m_VB;
    DWORD dwNumVertices = m_pObject->GetMesh(0)->m_dwNumVertices;

    // Create the destination vertex buffer
    m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(COMPRESSEDVERTEX), 
                                      D3DUSAGE_WRITEONLY, 0, D3DPOOL_DEFAULT, 
                                      &m_pObjectVB );
    
    // Lock vertices for copying
    MODELVERTEX*      pSrcVertices;
    COMPRESSEDVERTEX* pDstVertices;
    pVB->Lock( 0, 0, (BYTE**)&pSrcVertices, 0 );
    m_pObjectVB->Lock( 0, 0, (BYTE**)&pDstVertices, 0 );

    // Copy vertices
    for( DWORD i=0; i<dwNumVertices; i++ )
    {
        // Copy position
        pDstVertices[i].p = pSrcVertices[i].p;

        // Compress the normal
        pDstVertices[i].n = ( ( ((DWORD)(pSrcVertices[i].n.z *  511.0f)) & 0x3ff ) << 22L ) |
                            ( ( ((DWORD)(pSrcVertices[i].n.y * 1023.0f)) & 0x7ff ) << 11L ) |
                            ( ( ((DWORD)(pSrcVertices[i].n.x * 1023.0f)) & 0x7ff ) <<  0L );
    }

    // Unlock vertex buffers
    m_pObjectVB->Unlock();
    pVB->Unlock();

    // Setup the vertex declaration
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( D3DVSDE_POSITION,    D3DVSDT_FLOAT3 ),      // v0 = Position
        D3DVSD_REG( D3DVSDE_NORMAL,      D3DVSDT_NORMPACKED3 ), // v2 = Compressed normal
        D3DVSD_END()
    };

    // Create programmable vertex shader from a file
    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Shader.xvu", 
                                           dwDecl, &m_dwProgrammableVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a fixed-function vertex shader
    if( FAILED( m_pd3dDevice->CreateVertexShader( dwDecl, NULL, 
                                                  &m_dwFixedFunctionVertexShader, 0 ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load an object to render.
    if( FAILED( m_pObject->Create( m_pd3dDevice, "Models\\Light.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Store object components for rendering
    m_pObjectIB          = &m_pObject->GetMesh(0)->m_IB;
    m_dwObjectPrimType   =  m_pObject->GetMesh(0)->m_dwPrimType;
    m_dwNumObjectSubsets =  m_pObject->GetMesh(0)->m_dwNumSubsets;
    m_pObjectSubsets     =  m_pObject->GetMesh(0)->m_pSubsets;

    // Copy the geometry into a separate vertex buffer
    CreateCompressedGeometry();

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 0.1f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Set the app view matrix for normal viewing
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set a default material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // Create a directional light. (Use yellow light for fixed-function to
	// distinguish from vertex shader case which will be red.)
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, -0.5f, -1.0f, 1.0f );
    light.Diffuse.r = 1.0f;
    light.Diffuse.g = 1.0f;
    light.Diffuse.b = 0.0f;
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Toggle use of vertex shader
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bUseProgrammableVertexShader = !m_bUseProgrammableVertexShader; 

    // Set the world matrix
    D3DXVECTOR3 vAxis( 2+sinf(m_fAppTime*3.1f), 2+sinf(m_fAppTime*3.3f), sinf(m_fAppTime*3.5f) ); 
    D3DXMatrixRotationAxis( &m_matWorld, &vAxis, sinf(3*m_fAppTime) );

    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );

    // Set the vertex shader constants. 
    {
        // Some basic constants
        D3DXVECTOR4 vZero(0,0,0,0);
        D3DXVECTOR4 vOne(1,1,1,1);

        // Lighting vector (normalized) and material colors. (Use red light
        // to show difference from non-vertex shader case.)
        D3DXVECTOR4 fDiffuse( 1.00f, 0.00f, 0.00f, 1.00f );
        D3DXVECTOR4 fAmbient( 0.25f, 0.25f, 0.25f, 0.25f );
        D3DXVECTOR4 vLight( 0.5f, 1.0f, -1.0f, 0.0f );
        D3DXVec4Normalize( &vLight, &vLight );

        // Vertex shader operations use transposed matrices
        D3DXMATRIX matView, matProj, matViewProj;
        D3DXMATRIX matWorldTranspose, matViewProjTranspose;
        m_pd3dDevice->GetTransform( D3DTS_VIEW,       &matView );
        m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
        D3DXMatrixMultiply( &matViewProj, &matView, &matProj );
        D3DXMatrixTranspose( &matWorldTranspose,    &m_matWorld );
        D3DXMatrixTranspose( &matViewProjTranspose, &matViewProj );

        // Set the vertex shader constants
        m_pd3dDevice->SetVertexShaderConstant(  0, &vZero,    1 );
        m_pd3dDevice->SetVertexShaderConstant(  1, &vOne,     1 );
        m_pd3dDevice->SetVertexShaderConstant(  4, &matWorldTranspose,    4 );
        m_pd3dDevice->SetVertexShaderConstant( 12, &matViewProjTranspose, 4 );
        m_pd3dDevice->SetVertexShaderConstant( 20, &vLight,   1 );
        m_pd3dDevice->SetVertexShaderConstant( 21, &fDiffuse, 1 );
        m_pd3dDevice->SetVertexShaderConstant( 22, &fAmbient, 1 );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Render a background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set miscellaneous render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x00404040 );

    // Set the shader (programmable or fixed-function)
    if( m_bUseProgrammableVertexShader )        
        m_pd3dDevice->SetVertexShader( m_dwProgrammableVertexShader );
    else
        m_pd3dDevice->SetVertexShader( m_dwFixedFunctionVertexShader );

    // Display the object.
    m_pd3dDevice->SetStreamSource( 0, m_pObjectVB, sizeof(COMPRESSEDVERTEX) );
    m_pd3dDevice->SetIndices( m_pObjectIB, 0 );
    for( DWORD i = 0; i < m_dwNumObjectSubsets; i++ )
    {
        m_pd3dDevice->DrawIndexedVertices( m_dwObjectPrimType, m_pObjectSubsets[i].dwIndexCount, 
                                           D3D__IndexData + m_pObjectSubsets[i].dwIndexStart );
    }

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"CompressedNormals" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        if( m_bUseProgrammableVertexShader )        
            m_Font.DrawText( 64, 75, 0xffffffff, L"Using programmable vertex shader" );
        else
            m_Font.DrawText( 64, 75, 0xffffffff, L"Using fixed-function pipeline" );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinClassic\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinClassic\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\dolphin\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 35UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_BubbleTexture_OFFSET 40UL
#define resource_WaterCaustic00_OFFSET 60UL
#define resource_WaterCaustic01_OFFSET 80UL
#define resource_WaterCaustic02_OFFSET 100UL
#define resource_WaterCaustic03_OFFSET 120UL
#define resource_WaterCaustic04_OFFSET 140UL
#define resource_WaterCaustic05_OFFSET 160UL
#define resource_WaterCaustic06_OFFSET 180UL
#define resource_WaterCaustic07_OFFSET 200UL
#define resource_WaterCaustic08_OFFSET 220UL
#define resource_WaterCaustic09_OFFSET 240UL
#define resource_WaterCaustic10_OFFSET 260UL
#define resource_WaterCaustic11_OFFSET 280UL
#define resource_WaterCaustic12_OFFSET 300UL
#define resource_WaterCaustic13_OFFSET 320UL
#define resource_WaterCaustic14_OFFSET 340UL
#define resource_WaterCaustic15_OFFSET 360UL
#define resource_WaterCaustic16_OFFSET 380UL
#define resource_WaterCaustic17_OFFSET 400UL
#define resource_WaterCaustic18_OFFSET 420UL
#define resource_WaterCaustic19_OFFSET 440UL
#define resource_WaterCaustic20_OFFSET 460UL
#define resource_WaterCaustic21_OFFSET 480UL
#define resource_WaterCaustic22_OFFSET 500UL
#define resource_WaterCaustic23_OFFSET 520UL
#define resource_WaterCaustic24_OFFSET 540UL
#define resource_WaterCaustic25_OFFSET 560UL
#define resource_WaterCaustic26_OFFSET 580UL
#define resource_WaterCaustic27_OFFSET 600UL
#define resource_WaterCaustic28_OFFSET 620UL
#define resource_WaterCaustic29_OFFSET 640UL
#define resource_WaterCaustic30_OFFSET 660UL
#define resource_WaterCaustic31_OFFSET 680UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinClassic\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\dolphin\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 35UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_BubbleTexture_OFFSET 40UL
#define resource_WaterCaustic00_OFFSET 60UL
#define resource_WaterCaustic01_OFFSET 80UL
#define resource_WaterCaustic02_OFFSET 100UL
#define resource_WaterCaustic03_OFFSET 120UL
#define resource_WaterCaustic04_OFFSET 140UL
#define resource_WaterCaustic05_OFFSET 160UL
#define resource_WaterCaustic06_OFFSET 180UL
#define resource_WaterCaustic07_OFFSET 200UL
#define resource_WaterCaustic08_OFFSET 220UL
#define resource_WaterCaustic09_OFFSET 240UL
#define resource_WaterCaustic10_OFFSET 260UL
#define resource_WaterCaustic11_OFFSET 280UL
#define resource_WaterCaustic12_OFFSET 300UL
#define resource_WaterCaustic13_OFFSET 320UL
#define resource_WaterCaustic14_OFFSET 340UL
#define resource_WaterCaustic15_OFFSET 360UL
#define resource_WaterCaustic16_OFFSET 380UL
#define resource_WaterCaustic17_OFFSET 400UL
#define resource_WaterCaustic18_OFFSET 420UL
#define resource_WaterCaustic19_OFFSET 440UL
#define resource_WaterCaustic20_OFFSET 460UL
#define resource_WaterCaustic21_OFFSET 480UL
#define resource_WaterCaustic22_OFFSET 500UL
#define resource_WaterCaustic23_OFFSET 520UL
#define resource_WaterCaustic24_OFFSET 540UL
#define resource_WaterCaustic25_OFFSET 560UL
#define resource_WaterCaustic26_OFFSET 580UL
#define resource_WaterCaustic27_OFFSET 600UL
#define resource_WaterCaustic28_OFFSET 620UL
#define resource_WaterCaustic29_OFFSET 640UL
#define resource_WaterCaustic30_OFFSET 660UL
#define resource_WaterCaustic31_OFFSET 680UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinHDTV\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\dolphin\dolphin.cpp ===
//-----------------------------------------------------------------------------
// File: Dolphin.cpp
//
// Desc: Xbox sample of a swimming dolphin using vertex shaders and animated
//       textures for some nice underwater effects.
//
// Hist: 11.01.00 - Port for XBox for November XDK release
//       12.15.00 - Now using shaders for December release
//       12.20.00 - Added pixel shader, spline path and better models
//       03.10.01 - Using new geometry functions
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------
DWORD g_dwWaterColor = 0x00004080;

FLOAT g_fCycle      = 120.0f;     // Time for dolphin to complete a path cycle
FLOAT g_fLightAngle = D3DX_PI/4;  // Orientation of light from above



#define SHADOW_SIZE  256
DWORD g_dwShadowColor = 0xff000000;


// Vertex for the 3D meshes
struct D3DVERTEX
{
    D3DXVECTOR3 p;           // Position
    D3DXVECTOR3 n;           // Normal
    FLOAT       tu, tv;      // Tex coords
};

#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)


// Structure for the bubbles
struct BUBBLE
{
    FLOAT       age, lifespan;
    FLOAT       angle, spread, wobble;
    D3DXVECTOR3 vPos;
    D3DXVECTOR3 vPos0;
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font
    CXBFont                 m_Font;

    CXBPackedResource       m_xprResources;

    // Transform matrices
    D3DXMATRIX              m_matWorld;
    D3DXMATRIX              m_matView;
    D3DXMATRIX              m_matProj;

    // Dolphin object
    LPDIRECT3DTEXTURE8      m_pDolphinTexture;
    DWORD                   m_dwDolphinVertexShader;
    CXBMesh                 m_DolphinObject1;
    CXBMesh                 m_DolphinObject2;
    CXBMesh                 m_DolphinObject3;
    XBMESH_DATA*            m_pDolphinMesh1;
    XBMESH_DATA*            m_pDolphinMesh2;
    XBMESH_DATA*            m_pDolphinMesh3;

    // Seafloor object
    LPDIRECT3DTEXTURE8      m_pSeaFloorTexture;
    DWORD                   m_dwSeaFloorVertexShader;
    CXBMesh                 m_SeaFloorObject;
    XBMESH_DATA*            m_pSeaFloorMesh;

    // Water caustics
    LPDIRECT3DTEXTURE8      m_pCausticTextures[32];
    LPDIRECT3DTEXTURE8      m_pCurrentCausticTexture;
    DWORD                   m_dwDolphinPixelShader;
    DWORD                   m_dwSeaFloorPixelShader;

    // Dolphin shadow
    LPDIRECT3DTEXTURE8      m_pShadowTexture;
    LPDIRECT3DSURFACE8      m_pShadowSurface;

    // Bubbles
    D3DXVECTOR3        m_vBubbleEmitterPos;
    BUBBLE*            m_pBubbles;
    DWORD              m_dwNumBubbles;
    LPDIRECT3DVERTEXBUFFER8 m_pBubbleVB;
    LPDIRECT3DTEXTURE8 m_pBubbleTexture;

    HRESULT CreatePixelShader();
    HRESULT UpdateBubbles( FLOAT fAddBubbles );
    HRESULT RenderBubbles();

    // Spline path for the dolphin
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinSplineVB;
    D3DXVECTOR3* m_DolphinSpline;
    DWORD        m_dwNumDolphinSplinePts;

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Dolphin object
    m_dwDolphinVertexShader  = 0L;

    // SeaFloor object
    m_dwSeaFloorVertexShader = 0L;

    // Water caustics
    m_dwDolphinPixelShader  = 0L;
    m_dwSeaFloorPixelShader = 0L;

    m_pBubbleTexture     = NULL;
    m_pBubbleVB          = NULL;
    m_dwNumBubbles       = 100;
    m_pBubbles           = new BUBBLE[m_dwNumBubbles];
    m_vBubbleEmitterPos  = D3DXVECTOR3( 0, -1, -6 );

    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        m_pBubbles[i].lifespan = 5.0f + ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f;
        m_pBubbles[i].age      = (i*m_pBubbles[i].lifespan)/m_dwNumBubbles;
        m_pBubbles[i].angle    = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f * D3DX_PI;
        m_pBubbles[i].spread   = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 1.0f;
        m_pBubbles[i].wobble   = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f * D3DX_PI - D3DX_PI;

        FLOAT y = m_pBubbles[i].age;
        FLOAT r = m_pBubbles[i].spread * sqrtf( y / 10.0f );
        FLOAT x = r*sinf( m_pBubbles[i].angle );
        FLOAT z = r*cosf( m_pBubbles[i].angle );

        x += 0.1f*sqrtf( y / 4.0f ) * sinf( 1 * y * m_pBubbles[i].wobble );
        z += 0.1f*sqrtf( y / 4.0f ) * cosf( 1 * y * m_pBubbles[i].wobble );

        m_pBubbles[i].vPos0 = m_vBubbleEmitterPos;

        m_pBubbles[i].vPos.x = m_pBubbles[i].vPos0.x + x;
        m_pBubbles[i].vPos.y = m_pBubbles[i].vPos0.y + y;
        m_pBubbles[i].vPos.z = m_pBubbles[i].vPos0.z + z;
    }
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    // Setup the pixel shader for the dolphin. To blend in water caustics, we
    // want the following effect:
    //    result = t0 * ( v0 + t1 * v1 )
    // where:
    //    t0 = Base texture
    //    t1 = Water caustics texture
    //    v0 = Ambient light contribution
    //    v1 = Directional light contribution
    //
    // This can be encoded into a pixel shader with:
    //    1st stage: r0 = (t1*v1 + v0*1)
    //    Final:     A*B + (1-A)*C + D
    //               E*F = r0 * t0
    // where:
    //    A = Fog factor
    //    B = EF
    //    C = Fog color
    //    D = 0
    //    E = r0
    //    F = t0
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_ZERO_TO_ONE,
                                         PS_DOTMAPPING_ZERO_TO_ONE, PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V1 + V0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwDolphinPixelShader ) ) )
        return E_FAIL;


    
    // Setup the pixel shader for the seafloor. This is the same as above,
    // except we're also modulating in the dolphin shadow, stored in t2.
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 2,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_NONE );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V1, R1=V0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_R1,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_R1,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Stage 1 -------------
    // Build factor from caustics and lighting (R0 = R0 * T2 + R1 )
    psd.PSRGBInputs[1]    = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_T2  | PS_CHANNEL_RGB,
                                               PS_REGISTER_R1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[1]  = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_T2  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_R1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[1]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwSeaFloorPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT    hr;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the file-based mesh objects for the dolphin
    if( FAILED( m_DolphinObject1.Create( m_pd3dDevice, "Models\\Dolphin1.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_DolphinObject2.Create( m_pd3dDevice, "Models\\Dolphin2.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_DolphinObject3.Create( m_pd3dDevice, "Models\\Dolphin3.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get access to the mesh data (VB, IB, num indices, etc.). Note that we
    // can safely do this because we know this file contains only one mesh.
    m_pDolphinMesh1 = m_DolphinObject1.GetMesh(0);
    m_pDolphinMesh2 = m_DolphinObject2.GetMesh(0);
    m_pDolphinMesh3 = m_DolphinObject3.GetMesh(0);

    // Create vertex shader for the dolphin
    DWORD dwDolphinVertexDecl[] =
    {
        // First dolphin position
        D3DVSD_STREAM( 0 ),              // This data comes from stream 0
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // v3 = Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // v6 = Tex coords

        // Second dolphin position
        D3DVSD_STREAM( 1 ),              // This data comes from stream 1
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = Position of second mesh
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ), // v4 = Normal
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Tex coords

        // Third dolphin position
        D3DVSD_STREAM( 2 ),              // This data comes from stream 2
        D3DVSD_REG( 2, D3DVSDT_FLOAT3 ), // v2 = Position of second mesh
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ), // v5 = Normal
        D3DVSD_REG( 8, D3DVSDT_FLOAT2 ), // v8 = Tex coords
        D3DVSD_END()
    };

    hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Dolphin.xvu",
                                    dwDolphinVertexDecl, &m_dwDolphinVertexShader );
    if( FAILED(hr) )
        return hr;

    // Load the file-based mesh object for the seafloor
    if( FAILED( m_SeaFloorObject.Create( m_pd3dDevice, "Models\\SeaFloor.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get access to the mesh data (VB, IB, num indices, etc.). Note that we
    // can safely do this because we know this file contains only one mesh.
    m_pSeaFloorMesh = m_SeaFloorObject.GetMesh(0);

    // Create vertex shader for the seafloor
    DWORD dwSeaFloorVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
        D3DVSD_END()
    };

    if( FAILED( hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\SeaFloor.xvu",
                                                dwSeaFloorVertexDecl,
                                                &m_dwSeaFloorVertexShader ) ) )
        return hr;

    // Create a pixel shader for the underwater effect
    hr = CreatePixelShader();
    if( FAILED(hr) )
        return hr;

    // Set the transform matrices
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( 0.0f, 0.0f,-10.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f, 1.0f,  0.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 1000.0f );

    // Create the particle system's vertex buffer
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( m_dwNumBubbles*sizeof(D3DXVECTOR3),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_XYZ,
                                                  D3DPOOL_MANAGED, &m_pBubbleVB ) ) )
        return E_FAIL;


    // Load the file-based mesh object which holds the dolphin path
    CXBMesh xbgPath;
    if( FAILED( xbgPath.Create( m_pd3dDevice, "Models\\Path.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_dwNumDolphinSplinePts = xbgPath.GetMesh(0)->m_dwNumVertices/2;
    m_DolphinSpline         = new D3DXVECTOR3[m_dwNumDolphinSplinePts];

    D3DXVECTOR3* pPathData;
    xbgPath.GetMesh(0)->m_VB.Lock( 0, 0, (BYTE**)&pPathData, 0 );
    for( DWORD i = 0; i < m_dwNumDolphinSplinePts; i++ )
    {
        m_DolphinSpline[i] = pPathData[i];
    }
    xbgPath.GetMesh(0)->m_VB.Unlock();

    // Create the dolphin's shadow texture
    if( FAILED( m_pd3dDevice->CreateTexture( SHADOW_SIZE, SHADOW_SIZE, 1, 0, 
                                             D3DFMT_X8R8G8B8, 0, &m_pShadowTexture ) ) )
        return E_FAIL;
    m_pShadowTexture->GetSurfaceLevel( 0, &m_pShadowSurface );

    // Load resources from the packed resource file. Resources (textures, vertex
    // buffers,etc.) can be packed this way so they load super quick and require
    // no load-time processing (like parsing a .bmp file, changing formats,
    // swizzling, etc.). See the code in XBResource.cpp to see how simple it is.
    if( FAILED( m_xprResources.Create( m_pd3dDevice, "Resource.xpr", 
                                       resource_NUM_RESOURCES ) ) )
        return E_FAIL;

    // Get pointers to our textures
    m_pDolphinTexture      = m_xprResources.GetTexture( resource_DolphinTexture_OFFSET );
    m_pSeaFloorTexture     = m_xprResources.GetTexture( resource_SeaFloorTexture_OFFSET );
    m_pBubbleTexture       = m_xprResources.GetTexture( resource_BubbleTexture_OFFSET );
    m_pCausticTextures[ 0] = m_xprResources.GetTexture( resource_WaterCaustic00_OFFSET );
    m_pCausticTextures[ 1] = m_xprResources.GetTexture( resource_WaterCaustic01_OFFSET );
    m_pCausticTextures[ 2] = m_xprResources.GetTexture( resource_WaterCaustic02_OFFSET );
    m_pCausticTextures[ 3] = m_xprResources.GetTexture( resource_WaterCaustic03_OFFSET );
    m_pCausticTextures[ 4] = m_xprResources.GetTexture( resource_WaterCaustic04_OFFSET );
    m_pCausticTextures[ 5] = m_xprResources.GetTexture( resource_WaterCaustic05_OFFSET );
    m_pCausticTextures[ 6] = m_xprResources.GetTexture( resource_WaterCaustic06_OFFSET );
    m_pCausticTextures[ 7] = m_xprResources.GetTexture( resource_WaterCaustic07_OFFSET );
    m_pCausticTextures[ 8] = m_xprResources.GetTexture( resource_WaterCaustic08_OFFSET );
    m_pCausticTextures[ 9] = m_xprResources.GetTexture( resource_WaterCaustic09_OFFSET );
    m_pCausticTextures[10] = m_xprResources.GetTexture( resource_WaterCaustic10_OFFSET );
    m_pCausticTextures[11] = m_xprResources.GetTexture( resource_WaterCaustic11_OFFSET );
    m_pCausticTextures[12] = m_xprResources.GetTexture( resource_WaterCaustic12_OFFSET );
    m_pCausticTextures[13] = m_xprResources.GetTexture( resource_WaterCaustic13_OFFSET );
    m_pCausticTextures[14] = m_xprResources.GetTexture( resource_WaterCaustic14_OFFSET );
    m_pCausticTextures[15] = m_xprResources.GetTexture( resource_WaterCaustic15_OFFSET );
    m_pCausticTextures[16] = m_xprResources.GetTexture( resource_WaterCaustic16_OFFSET );
    m_pCausticTextures[17] = m_xprResources.GetTexture( resource_WaterCaustic17_OFFSET );
    m_pCausticTextures[18] = m_xprResources.GetTexture( resource_WaterCaustic18_OFFSET );
    m_pCausticTextures[19] = m_xprResources.GetTexture( resource_WaterCaustic19_OFFSET );
    m_pCausticTextures[20] = m_xprResources.GetTexture( resource_WaterCaustic20_OFFSET );
    m_pCausticTextures[21] = m_xprResources.GetTexture( resource_WaterCaustic21_OFFSET );
    m_pCausticTextures[22] = m_xprResources.GetTexture( resource_WaterCaustic22_OFFSET );
    m_pCausticTextures[23] = m_xprResources.GetTexture( resource_WaterCaustic23_OFFSET );
    m_pCausticTextures[24] = m_xprResources.GetTexture( resource_WaterCaustic24_OFFSET );
    m_pCausticTextures[25] = m_xprResources.GetTexture( resource_WaterCaustic25_OFFSET );
    m_pCausticTextures[26] = m_xprResources.GetTexture( resource_WaterCaustic26_OFFSET );
    m_pCausticTextures[27] = m_xprResources.GetTexture( resource_WaterCaustic27_OFFSET );
    m_pCausticTextures[28] = m_xprResources.GetTexture( resource_WaterCaustic28_OFFSET );
    m_pCausticTextures[29] = m_xprResources.GetTexture( resource_WaterCaustic29_OFFSET );
    m_pCausticTextures[30] = m_xprResources.GetTexture( resource_WaterCaustic30_OFFSET );
    m_pCausticTextures[31] = m_xprResources.GetTexture( resource_WaterCaustic31_OFFSET );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Animation attributes for the dolphin
    FLOAT fPhase       = m_fAppTime/3;
    FLOAT fKickFreq    = 6*fPhase;
    FLOAT fBlendWeight = sinf( fKickFreq );

    // Get the parametric value u for the time-based dolphin position on it's
    // path, where 0 < u < NUM_SPLINE_POINTS.
    FLOAT u = m_dwNumDolphinSplinePts * ((m_fAppTime/g_fCycle) - floorf(m_fAppTime/g_fCycle));

    // Get the dolphin position and tangent from the spline path
    D3DXVECTOR3 vDolphinPos, vDolphinDir;
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u, 
                           &vDolphinPos, &vDolphinDir );

    // Scale and orient the dolphin model
    D3DXMATRIX matScale, matRotateY, matDolphin;
    D3DXMatrixScaling( &matScale, 0.01f, 0.01f, 0.01f );
    D3DXMatrixRotationY( &matRotateY, D3DX_PI/2 );
    D3DXMatrixMultiply( &matDolphin, &matScale, &matRotateY );

    // Add the rotation and translation for the dolphin kick
    D3DXMATRIX matKickRotate;
    D3DXMatrixRotationX( &matKickRotate, -cosf(fKickFreq)/6 );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matKickRotate );
    vDolphinPos.y += sinf(fKickFreq)/2;

    // Add the spline path. We can use the inverse of a lookat matrix to generate the
    // position and orientation of the dolphin on the path
    D3DXMATRIX matPathLookAt, matDolphinRotate, matDolphinTrans;
    D3DXMatrixLookAtLH( &matPathLookAt, &D3DXVECTOR3(0,0,0), &vDolphinDir, &D3DXVECTOR3(0,1,0) );
    D3DXMatrixInverse( &matDolphinRotate, NULL, &matPathLookAt );
    D3DXMatrixTranslation( &matDolphinTrans, vDolphinPos.x, vDolphinPos.y, vDolphinPos.z );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matDolphinRotate );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matDolphinTrans );

    // Position the bubble emitter position to correspond to the dolphin's blowhole.
    D3DXVECTOR3 vBlowHole( -150.0f, 40.0f, 0.0f );
    D3DXVec3TransformCoord( &m_vBubbleEmitterPos, &vBlowHole, &matDolphin );

    // Position the camera
    FLOAT u0 = m_dwNumDolphinSplinePts * (((m_fAppTime-1.5f)/g_fCycle) - floorf((m_fAppTime-1.5f)/g_fCycle));
    FLOAT u1 = m_dwNumDolphinSplinePts * (((m_fAppTime+0.2f)/g_fCycle) - floorf((m_fAppTime+0.2f)/g_fCycle));
    D3DXVECTOR3 vEyePt, vLookatPt;
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u0, &vEyePt,    NULL );
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u1, &vLookatPt, NULL );
    vEyePt *= 0.9f;
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &D3DXVECTOR3(0,1,0) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Vary the fog range, color, and ambient lighting based on depth
    FLOAT fDepthFactor = 1.0f + vEyePt.y/51.0f;
    FLOAT fFogEnd   = 50.0f + 100.0f * fDepthFactor;
    FLOAT fFogStart = 1.0f/(fFogEnd-1.0f);
    DWORD green = 0x0000ff00 & (DWORD)(0x00008000 * fDepthFactor);
    DWORD blue  = 0x000000ff & (DWORD)(0x000000ff * fDepthFactor);
    g_dwWaterColor = ( green | blue );

    DWORD dwColorFactor = (DWORD)( 255.0f * (1.0f-0.5f*fDepthFactor) );
    g_dwShadowColor = (dwColorFactor<<16) | (dwColorFactor<<8) | (dwColorFactor<<0);

    // Blend weight for vertex tweening
    FLOAT fWeight1 = ( fBlendWeight > 0.0f ) ? fabsf(fBlendWeight) : 0.0f;
    FLOAT fWeight2 = 1.0f - fabsf(fBlendWeight);
    FLOAT fWeight3 = ( fBlendWeight > 0.0f ) ? 0.0f : fabsf(fBlendWeight);

    // Values passed into the vertex shader for lighting, etc.
    D3DXVECTOR4 fConstants0( 0.0f, 0.0f, 0.0f, 0.00f );
    D3DXVECTOR4 fConstants1( 1.0f, 0.5f, 0.2f, 0.05f );
    D3DXVECTOR4 fLight( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f, 0.0f );
    D3DXVECTOR4 fDiffuse( 1.00f, 1.00f, 1.00f, 1.00f );
    D3DXVECTOR4 fAmbient( 0.5f*fDepthFactor, 0.5f*fDepthFactor, 0.5f*fDepthFactor, 1.0f );
    D3DXVECTOR4 fFog( 0.5f, fFogEnd*fFogStart, fFogStart, 0.0f );
    D3DXVECTOR4 fCaustics( 0.05f, 0.05f, sinf(m_fAppTime)/8, cosf(m_fAppTime)/10 - m_fAppTime/10 );
    D3DXVECTOR4 fWeight( fWeight1, fWeight2, fWeight3, 0.0f );

    // Build matrix sets (and transpose them) for the vertex shaders
    D3DXMATRIX matDolphinWV, matDolphinWVP;
    D3DXMatrixMultiply( &matDolphinWV, &matDolphin, &m_matView );
    D3DXMatrixMultiply( &matDolphinWVP, &matDolphinWV, &m_matProj );
    D3DXMatrixTranspose( &matDolphinWV,  &matDolphinWV );
    D3DXMatrixTranspose( &matDolphinWVP,  &matDolphinWVP );

    D3DXMATRIX matSeaFloorWVP;
    D3DXMatrixMultiply( &matSeaFloorWVP, &m_matView, &m_matProj );
    D3DXMatrixTranspose( &matSeaFloorWVP,  &matSeaFloorWVP );

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant(  0, &fConstants0,    1 ); // Some constants
    m_pd3dDevice->SetVertexShaderConstant(  1, &fConstants1,    1 ); // More constants
    m_pd3dDevice->SetVertexShaderConstant(  2, &fWeight,        1 );
    m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinWV,   4 ); // Dolphin WV matrix set
    m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinWVP,  4 ); // Dolphin WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 30, &matSeaFloorWVP, 4 ); // Seafloor WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 40, &fLight,         1 ); // Light direction
    m_pd3dDevice->SetVertexShaderConstant( 41, &fDiffuse,       1 ); // Diffuse color
    m_pd3dDevice->SetVertexShaderConstant( 42, &fAmbient,       1 ); // Ambient color
    m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,           1 ); // Fog factors
    m_pd3dDevice->SetVertexShaderConstant( 44, &fCaustics,      1 ); // Misc constants

    // Animate the caustic textures
    DWORD tex = ((DWORD)(m_fAppTime*32))%32;
    m_pCurrentCausticTexture = m_pCausticTextures[tex];

    // Make this into a curve!
    FLOAT fAddBubbles = 0.0f;
    if( ((DWORD)m_fAppTime)%7 < 2 )
        fAddBubbles = m_fElapsedAppTime*50;

    UpdateBubbles( fAddBubbles );

    // Render the dolphin's shadow
    {
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwShadowColor );

        // Get the current backbuffer and zbuffer
        LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
        m_pd3dDevice->GetRenderTarget( &pBackBuffer );
        m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

        // Set the shadow texture as the rendertarget
        m_pd3dDevice->SetRenderTarget( m_pShadowSurface, NULL );

        // Set the viewport to be the correct size and clear it
        D3DVIEWPORT8 vpShadow = { 0, 0, SHADOW_SIZE, SHADOW_SIZE, 0.0f, 1.0f };
        m_pd3dDevice->SetViewport( &vpShadow );
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xffffffff, 1.0f, 0L );

        // Set new vertex shader constants so that (a) the camera is at the
        // light position, looking at the dolphin and (b) we use fog to control
        // the only color that gets written is the shadow color.
        D3DXVECTOR3 vShadowEyePt = vDolphinPos + 10 * D3DXVECTOR3( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f );
        D3DXMATRIX  matShadowView;
        D3DXMATRIX  matShadowProj;
        D3DXMatrixLookAtLH( &matShadowView, &vShadowEyePt, &vDolphinPos, &vDolphinDir );
        D3DXMatrixOrthoLH( &matShadowProj, 3.5f, 7.0f, 1.0f, 200.0f );
        D3DXVECTOR4 fFog( 0.5f, 0.1f, 0.0f, 0.0f );
                   
        D3DXMATRIX matDolphinShadowWV, matDolphinShadowWVP;
        D3DXMatrixMultiply( &matDolphinShadowWV,  &matDolphin,         &matShadowView );
        D3DXMatrixMultiply( &matDolphinShadowWVP, &matDolphinShadowWV, &matShadowProj );
        D3DXMatrixTranspose( &matDolphinShadowWV,  &matDolphinShadowWV );
        D3DXMatrixTranspose( &matDolphinShadowWVP, &matDolphinShadowWVP );

        m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinShadowWV,  4 ); // Dolphin WV matrix set
        m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinShadowWVP, 4 ); // Dolphin WVP matrix set
        m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,                1 ); // Fog factors

        // Render the dolphin into the shadow texture
        m_pd3dDevice->SetPixelShader( NULL );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
        m_pd3dDevice->SetStreamSource( 0, &m_pDolphinMesh1->m_VB, m_pDolphinMesh1->m_dwVertexSize );
        m_pd3dDevice->SetStreamSource( 1, &m_pDolphinMesh2->m_VB, m_pDolphinMesh2->m_dwVertexSize );
        m_pd3dDevice->SetStreamSource( 2, &m_pDolphinMesh3->m_VB, m_pDolphinMesh3->m_dwVertexSize );
        m_pd3dDevice->SetIndices( &m_pDolphinMesh1->m_IB, 0 );
        m_pd3dDevice->DrawIndexedVertices( m_pDolphinMesh1->m_dwPrimType, 
                                           m_pDolphinMesh1->m_dwNumIndices,
                                           D3D__IndexData );

        // Change the rendertarget back to the main backbuffer
        D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
        m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
        m_pd3dDevice->SetViewport( &vpBackBuffer );
        pBackBuffer->Release();
        pZBuffer->Release();

        // Now, generate the texture matrix to project shadow onto the
        // seafloor. Here we just set up the matrix, and the vertex shader will
        // do the per-vertex computation for the texture coordinates.

        // Build shadow projection matrix
        D3DXMatrixOrthoLH( &matShadowProj, 15.0f*3.5f, 15.0f*7.0f, 1.0f, 200.0f );

        // Build matrix to shift coordinates from viewport space (-1,+1) to
        // texture space (0,1)
        D3DXMATRIX matTexShift;
        D3DXMatrixIdentity( &matTexShift );
        matTexShift._11 = +0.5f;   matTexShift._12 =  0.0f;
        matTexShift._21 =  0.0f;   matTexShift._22 = -0.5f;
        matTexShift._31 = +0.5f;   matTexShift._32 = +0.5f;

        // Concat the pieces to make the final texture matrix
        D3DXMATRIX matTexProj;
        D3DXMatrixIdentity( &matTexProj );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matShadowView );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matShadowProj );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matTexShift );

        // Pass the matrix to the vertex shader via a vertex shader constant
        D3DXMATRIX matTexProjT;
        D3DXMatrixTranspose( &matTexProjT, &matTexProj );
        m_pd3dDevice->SetVertexShaderConstant( 50, &matTexProjT, 4 );
    }

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinWV,  4 ); // Dolphin WV matrix set
    m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinWVP, 4 ); // Dolphin WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,          1 ); // Fog factors

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::UpdateBubbles( FLOAT fAddBubbles )
{
    static FLOAT fBubblesToAdd = 0.0f;
    fBubblesToAdd += fAddBubbles;

    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        if( m_pBubbles[i].age > m_pBubbles[i].lifespan )
        {
            if( fBubblesToAdd > 1.0f )
            {
                fBubblesToAdd -= 1.0f;

                m_pBubbles[i].age      = m_pBubbles[i].age - m_pBubbles[i].lifespan;
                m_pBubbles[i].lifespan = 3.0f + ((FLOAT)rand()/(FLOAT)RAND_MAX) * 1.0f;
                m_pBubbles[i].vPos0    = m_vBubbleEmitterPos;
            }
        }
        else
            m_pBubbles[i].age += m_fElapsedAppTime;

        BUBBLE* pBubble = &m_pBubbles[i];

        FLOAT y = 1.2f*m_pBubbles[i].age;
        FLOAT r = m_pBubbles[i].spread * sqrtf( y / 10.0f );
        FLOAT x = r*sinf( m_pBubbles[i].angle );
        FLOAT z = r*cosf( m_pBubbles[i].angle );

        x += 0.1f*sqrtf( y / 4.0f ) * sinf( 1 * y * m_pBubbles[i].wobble );
        z += 0.1f*sqrtf( y / 4.0f ) * cosf( 1 * y * m_pBubbles[i].wobble );

        m_pBubbles[i].vPos.x = m_pBubbles[i].vPos0.x + x;
        m_pBubbles[i].vPos.y = m_pBubbles[i].vPos0.y + y;
        m_pBubbles[i].vPos.z = m_pBubbles[i].vPos0.z + z;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderBubbles()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderBubbles()
{
    // Set the world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set the view matrix
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Set projection matrix
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );
    
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );

    // Set states for rendering the particles. Note that point sprites use 
    // stage 3.
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCCOLOR );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
    m_pd3dDevice->SetTexture( 3, m_pBubbleTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

    // Set the render states for using point sprites
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(0.15f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_A,      FtoDW(0.00f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_B,      FtoDW(0.00f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_C,      FtoDW(1.00f) );

    // Set up the vertex buffer to be rendered
    D3DXVECTOR3* pVertices;
    DWORD        dwNumParticlesToRender = 0;
    m_pBubbleVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Render each particle
    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        if( m_pBubbles[i].age < m_pBubbles[i].lifespan )
        {
            pVertices->x = m_pBubbles[i].vPos.x;
            pVertices->y = m_pBubbles[i].vPos.y;
            pVertices->z = m_pBubbles[i].vPos.z;
            pVertices++;

            dwNumParticlesToRender++;
        }
    }

    // Unlock the vertex buffer
    m_pBubbleVB->Unlock();
    if( dwNumParticlesToRender > 0 )
    {
        m_pd3dDevice->SetStreamSource( 0, m_pBubbleVB, sizeof(D3DXVECTOR3) );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
        m_pd3dDevice->DrawPrimitive( D3DPT_POINTLIST, 0, dwNumParticlesToRender );
    }

    // Reset render states
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  FALSE );
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         g_dwWaterColor, 1.0f, 0L );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwWaterColor );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    // Turn on the pixel shader for the underwater effect, which blends in the
    // current caustic texture and the dolphin's shadow. Note that specular
    // must be enabled for the pixel shader to use the v1 register.
    m_pd3dDevice->SetTexture( 1, m_pCurrentCausticTexture );
    m_pd3dDevice->SetTexture( 2, m_pShadowTexture );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   TRUE );

    // Render the seafloor. The vertex shader does the transformation, texture
    // projection (for the water caustics) and fog calculations.
    m_pd3dDevice->SetTexture( 0, m_pSeaFloorTexture );
    m_pd3dDevice->SetPixelShader( m_dwSeaFloorPixelShader );
    m_pd3dDevice->SetVertexShader( m_dwSeaFloorVertexShader );
    m_pd3dDevice->SetStreamSource( 0, &m_pSeaFloorMesh->m_VB, m_pSeaFloorMesh->m_dwVertexSize );
    m_pd3dDevice->SetIndices( &m_pSeaFloorMesh->m_IB, 0 );
    m_pd3dDevice->DrawIndexedVertices( m_pSeaFloorMesh->m_dwPrimType, 
                                       m_pSeaFloorMesh->m_dwNumIndices,
                                       D3D__IndexData );

    // Render the dolphin. The vertex shader does the vertex tweening, 
    // transformation, texture projection (for the water caustics) and fog
    // calculations.
    m_pd3dDevice->SetTexture( 0, m_pDolphinTexture );
    m_pd3dDevice->SetPixelShader( m_dwDolphinPixelShader );
    m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
    m_pd3dDevice->SetStreamSource( 0, &m_pDolphinMesh1->m_VB, m_pDolphinMesh1->m_dwVertexSize );
    m_pd3dDevice->SetStreamSource( 1, &m_pDolphinMesh2->m_VB, m_pDolphinMesh2->m_dwVertexSize );
    m_pd3dDevice->SetStreamSource( 2, &m_pDolphinMesh3->m_VB, m_pDolphinMesh3->m_dwVertexSize );
    m_pd3dDevice->SetIndices( &m_pDolphinMesh1->m_IB, 0 );
    m_pd3dDevice->DrawIndexedVertices( m_pDolphinMesh1->m_dwPrimType, 
                                       m_pDolphinMesh1->m_dwNumIndices,
                                       D3D__IndexData );

    // Render the bubble system
    RenderBubbles();

    // Show frame rate
    m_Font.Begin();
    m_Font.DrawText(  64, 50, 0xffffffff, L"Dolphin" );
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinClassic\DolphinClassic.cpp ===
//-----------------------------------------------------------------------------
// File: DolphinClassic.cpp
//
// Desc: Xbox sample of a swimming dolphin using vertex shaders and animated
//       textures for some nice underwater effects.
//
// Hist: 11.01.00 - Port for XBox for November XDK release
//       12.15.00 - Now using shaders for December release
//       12.20.00 - Added pixel shader
//       12.20.00 - Added spline path and better models
//       10.08.01 - Moved startup transition effect to PersistDisplay sample
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------
DWORD g_dwWaterColor     = 0x00004080; // Color of the water
FLOAT g_fLightAngle      = 0.0f;       // Orientation of light from above


// Vertex for the 3D meshes
struct SEAFLOORVERTEX
{
    D3DXVECTOR3 p;           // Position
    D3DXVECTOR3 n;           // Normal
    FLOAT       tu, tv;      // Tex coords
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Packed resources for the app
    CXBPackedResource       m_xprResource;

    // Font
    CXBFont                 m_Font;

    // Transform matrices
    D3DXMATRIX              m_matWorld;
    D3DXMATRIX              m_matView;
    D3DXMATRIX              m_matProj;

    // Dolphin object
    LPDIRECT3DTEXTURE8      m_pDolphinTexture;
    CXBMesh                 m_DolphinMesh1;
    CXBMesh                 m_DolphinMesh2;
    CXBMesh                 m_DolphinMesh3;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB1;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB2;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB3;
    LPDIRECT3DINDEXBUFFER8  m_pDolphinIB;
    DWORD                   m_dwNumDolphinVertices;
    DWORD                   m_dwNumDolphinIndices;
    DWORD                   m_dwDolphinVertexShader;
    DWORD                   m_dwDolphinVertexSize;

    LPDIRECT3DVERTEXBUFFER8 m_pDolphinStream1;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinStream2;

    // Seafloor object
    LPDIRECT3DTEXTURE8      m_pSeaFloorTexture;
    CXBMesh                 m_SeaFloorMesh;
    LPDIRECT3DVERTEXBUFFER8 m_pSeaFloorVB;
    LPDIRECT3DINDEXBUFFER8  m_pSeaFloorIB;
    DWORD                   m_dwNumSeaFloorVertices;
    DWORD                   m_dwNumSeaFloorIndices;
    DWORD                   m_dwSeaFloorVertexShader;
    DWORD                   m_dwSeaFloorVertexSize;

    // Water caustics
    LPDIRECT3DTEXTURE8      m_pCausticTextures[32];
    LPDIRECT3DTEXTURE8      m_pCurrentCausticTexture;
    DWORD                   m_dwUnderWaterPixelShader;
    HRESULT CreatePixelShader();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Dolphin object
    m_pDolphinTexture        = NULL;
    m_pDolphinVB1            = NULL;
    m_pDolphinVB2            = NULL;
    m_pDolphinVB3            = NULL;
    m_pDolphinIB             = NULL;
    m_dwDolphinVertexShader  = 0L;

    // SeaFloor object
    m_pSeaFloorTexture       = NULL;
    m_pSeaFloorVB            = NULL;
    m_pSeaFloorIB            = NULL;
    m_dwSeaFloorVertexShader = 0L;

    // Water caustics
    for( DWORD t=0; t<32; t++ )
        m_pCausticTextures[t] = NULL;
    m_dwUnderWaterPixelShader = 0L;
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    //
    // Setup the pixel shader. To blend in water caustics, we want the
    // following effect:
    //    result = t0 * ( t1 * v0 + c0 )
    // where:
    //    t0 = Base texture
    //    t1 = Water caustics texture
    //    c0 = Ambient light contribution
    //    v0 = Directional light contribution
    //
    // This can be encoded into a pixel shader with:
    //    1st stage: r0 = (t1*v0 + c0*1)
    //    Final:     A*B + (1-A)*C + D
    //               E*F = r0 * t0
    // where:
    //    A = Fog factor
    //    B = EF
    //    C = Fog color
    //    D = 0
    //    E = r0
    //    F = t0
    //
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_ZERO_TO_ONE,
                                         PS_DOTMAPPING_ZERO_TO_ONE, PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V0 + C0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_C0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_C0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    psd.PSC0Mapping = 0xfffffff0;
    psd.PSC1Mapping = 0xffffffff;

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwUnderWaterPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create texture for the dolphin
    m_pDolphinTexture = m_xprResource.GetTexture( resource_DolphinTexture_OFFSET );

    // Load the file-based mesh objects for the dolphin
    if( FAILED( m_DolphinMesh1.Create( m_pd3dDevice, "Models\\Dolphin1.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_DolphinMesh2.Create( m_pd3dDevice, "Models\\Dolphin2.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_DolphinMesh3.Create( m_pd3dDevice, "Models\\Dolphin3.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_pDolphinVB1 = &m_DolphinMesh1.GetMesh(0)->m_VB;
    m_pDolphinVB2 = &m_DolphinMesh2.GetMesh(0)->m_VB;
    m_pDolphinVB3 = &m_DolphinMesh3.GetMesh(0)->m_VB;
    m_pDolphinIB  = &m_DolphinMesh1.GetMesh(0)->m_IB;
    m_dwNumDolphinVertices = m_DolphinMesh1.GetMesh(0)->m_dwNumVertices;
    m_dwNumDolphinIndices  = m_DolphinMesh1.GetMesh(0)->m_dwNumIndices;
    m_dwDolphinVertexSize  = m_DolphinMesh1.GetMesh(0)->m_dwVertexSize;

    // Create vertex shader for the dolphin
    DWORD dwDolphinVertexDecl[] =
    {
        // m_pDolphinVB1
        D3DVSD_STREAM( 0 ),              // This data comes from stream 0
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // v3 = Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // v6 = Tex coords

        // m_pDolphinVB2
        D3DVSD_STREAM( 1 ),              // This data comes from stream 1
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = Position of second mesh
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ), // v4 = Normal
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Tex coords

        // m_pDolphinVB3
        D3DVSD_STREAM( 2 ),              // This data comes from stream 2
        D3DVSD_REG( 2, D3DVSDT_FLOAT3 ), // v2 = Position of second mesh
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ), // v5 = Normal
        D3DVSD_REG( 8, D3DVSDT_FLOAT2 ), // v8 = Tex coords
        D3DVSD_END()
    };

    hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Dolphin.xvu",
                                    dwDolphinVertexDecl, &m_dwDolphinVertexShader );
    if( FAILED(hr) )
        return hr;

    // Create textures for the seafloor
    m_pSeaFloorTexture = m_xprResource.GetTexture( resource_SeaFloorTexture_OFFSET );
    
    // Load the file-based mesh object for the seafloor
    if( FAILED( m_SeaFloorMesh.Create( m_pd3dDevice, "Models\\SeaFloor.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_pSeaFloorVB = &m_SeaFloorMesh.GetMesh(0)->m_VB;
    m_pSeaFloorIB = &m_SeaFloorMesh.GetMesh(0)->m_IB;
    m_dwNumSeaFloorVertices = m_SeaFloorMesh.GetMesh(0)->m_dwNumVertices;
    m_dwNumSeaFloorIndices  = m_SeaFloorMesh.GetMesh(0)->m_dwNumIndices;
    m_dwSeaFloorVertexSize  = m_SeaFloorMesh.GetMesh(0)->m_dwVertexSize;

    // Add some bumpiness to the seafloor mesh
    SEAFLOORVERTEX* pDst;
    m_pSeaFloorVB->Lock( 0, 0, (BYTE**)&pDst, 0 );
    srand(5);
    for( DWORD i=0; i<m_dwNumSeaFloorVertices; i++ )
    {
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].tu  *= 10;
        pDst[i].tv  *= 10;
    }
    m_pSeaFloorVB->Unlock();

    // Create vertex shader for the seafloor
    DWORD dwSeaFloorVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
        D3DVSD_END()
    };

    hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\SeaFloor.xvu",
                                    dwSeaFloorVertexDecl, &m_dwSeaFloorVertexShader );
    if( FAILED(hr) )
        return hr;

    // Create a pixel shader for the underwater effect
    hr = CreatePixelShader();
    if( FAILED(hr) )
        return hr;

    // Create textures for the water caustics
    m_pCausticTextures[ 0] = m_xprResource.GetTexture( resource_WaterCaustic00_OFFSET );
    m_pCausticTextures[ 1] = m_xprResource.GetTexture( resource_WaterCaustic01_OFFSET );
    m_pCausticTextures[ 2] = m_xprResource.GetTexture( resource_WaterCaustic02_OFFSET );
    m_pCausticTextures[ 3] = m_xprResource.GetTexture( resource_WaterCaustic03_OFFSET );
    m_pCausticTextures[ 4] = m_xprResource.GetTexture( resource_WaterCaustic04_OFFSET );
    m_pCausticTextures[ 5] = m_xprResource.GetTexture( resource_WaterCaustic05_OFFSET );
    m_pCausticTextures[ 6] = m_xprResource.GetTexture( resource_WaterCaustic06_OFFSET );
    m_pCausticTextures[ 7] = m_xprResource.GetTexture( resource_WaterCaustic07_OFFSET );
    m_pCausticTextures[ 8] = m_xprResource.GetTexture( resource_WaterCaustic08_OFFSET );
    m_pCausticTextures[ 9] = m_xprResource.GetTexture( resource_WaterCaustic09_OFFSET );
    m_pCausticTextures[10] = m_xprResource.GetTexture( resource_WaterCaustic10_OFFSET );
    m_pCausticTextures[11] = m_xprResource.GetTexture( resource_WaterCaustic11_OFFSET );
    m_pCausticTextures[12] = m_xprResource.GetTexture( resource_WaterCaustic12_OFFSET );
    m_pCausticTextures[13] = m_xprResource.GetTexture( resource_WaterCaustic13_OFFSET );
    m_pCausticTextures[14] = m_xprResource.GetTexture( resource_WaterCaustic14_OFFSET );
    m_pCausticTextures[15] = m_xprResource.GetTexture( resource_WaterCaustic15_OFFSET );
    m_pCausticTextures[16] = m_xprResource.GetTexture( resource_WaterCaustic16_OFFSET );
    m_pCausticTextures[17] = m_xprResource.GetTexture( resource_WaterCaustic17_OFFSET );
    m_pCausticTextures[18] = m_xprResource.GetTexture( resource_WaterCaustic18_OFFSET );
    m_pCausticTextures[19] = m_xprResource.GetTexture( resource_WaterCaustic19_OFFSET );
    m_pCausticTextures[20] = m_xprResource.GetTexture( resource_WaterCaustic20_OFFSET );
    m_pCausticTextures[21] = m_xprResource.GetTexture( resource_WaterCaustic21_OFFSET );
    m_pCausticTextures[22] = m_xprResource.GetTexture( resource_WaterCaustic22_OFFSET );
    m_pCausticTextures[23] = m_xprResource.GetTexture( resource_WaterCaustic23_OFFSET );
    m_pCausticTextures[24] = m_xprResource.GetTexture( resource_WaterCaustic24_OFFSET );
    m_pCausticTextures[25] = m_xprResource.GetTexture( resource_WaterCaustic25_OFFSET );
    m_pCausticTextures[26] = m_xprResource.GetTexture( resource_WaterCaustic26_OFFSET );
    m_pCausticTextures[27] = m_xprResource.GetTexture( resource_WaterCaustic27_OFFSET );
    m_pCausticTextures[28] = m_xprResource.GetTexture( resource_WaterCaustic28_OFFSET );
    m_pCausticTextures[29] = m_xprResource.GetTexture( resource_WaterCaustic29_OFFSET );
    m_pCausticTextures[30] = m_xprResource.GetTexture( resource_WaterCaustic30_OFFSET );
    m_pCausticTextures[31] = m_xprResource.GetTexture( resource_WaterCaustic31_OFFSET );

    // Set the transform matrices
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( 0.0f, 0.0f,-5.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/3, 4.0f/3.0f, 1.0f, 10000.0f );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Animation attributes for the dolphin
    FLOAT fKickFreq    = 2*m_fAppTime;
    FLOAT fPhase       = m_fAppTime/3-1.3f;
    FLOAT fBlendWeight = sinf( fKickFreq );

    // Move the dolphin in a circle
    D3DXMATRIX matDolphin, matTrans, matRotate1, matRotate2;
    D3DXMatrixScaling( &matDolphin, 0.01f, 0.01f, 0.01f );
    D3DXMatrixRotationZ( &matRotate1, -cosf(fKickFreq)/6 );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matRotate1 );
    D3DXMatrixRotationY( &matRotate2, fPhase );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matRotate2 );
    D3DXMatrixTranslation( &matTrans, -5*sinf(fPhase), sinf(fKickFreq)/2, 10-10*cosf(fPhase) );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matTrans );

    // Blend weight and vertex buffer selection for vertex tweening
    FLOAT fWeight1, fWeight2;
    if( fBlendWeight > 0.0f )
    {
        // Use vertex sets one the two.
        fWeight1 = fBlendWeight;
        fWeight2 = 1.0f - fBlendWeight;

        m_pDolphinStream1 = m_pDolphinVB1;
        m_pDolphinStream2 = m_pDolphinVB2;
    }
    else
    {
        // Use vertex sets two and three.
        fWeight1 = 1.0f + fBlendWeight;
        fWeight2 = -fBlendWeight;

        m_pDolphinStream1 = m_pDolphinVB2;
        m_pDolphinStream2 = m_pDolphinVB3;
    }

    // Values passed into the vertex shader for lighting, etc.
    D3DXVECTOR4 fConstants0( 0.0f, 0.0f, 0.0f, 0.00f );
    D3DXVECTOR4 fConstants1( 1.0f, 0.5f, 0.2f, 0.05f );
    D3DXVECTOR4 fLight( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f, 0.0f );
    D3DXVECTOR4 fDiffuse( 1.00f, 1.00f, 1.00f, 1.00f );
    D3DXVECTOR4 fAmbient( 0.25f, 0.25f, 0.25f, 0.25f );
    D3DXVECTOR4 fFog( 0.5f, 50.0f, 1.0f/(50.0f-1.0f), 0.0f );
    D3DXVECTOR4 fCaustics( 0.05f, 0.05f, sinf(m_fAppTime)/8, cosf(m_fAppTime)/10 - m_fAppTime/10 );
    D3DXVECTOR4 fWeight( fWeight1, fWeight2, 0.0f, 0.0f );

    // Calculate and set composite matrix for dolphin.
    D3DXMATRIX matComposite;
    D3DXMatrixMultiply( &matComposite, &matDolphin, &m_matView );
    D3DXMatrixMultiply( &matComposite, &matComposite, &m_matProj );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 4, &matComposite, 4 );

    // Scale and offset fog start and end by values from projection matrix.
    float fFogStart = 1.0f;
    float fFogEnd = 50.0f;

    fFogStart = fFogStart * m_matProj._33 + m_matProj._43;
    fFogEnd = fFogEnd * m_matProj._33 + m_matProj._43;

    fFog[2] = 1.0f / (fFogEnd - fFogStart);
    fFog[1] = fFogEnd * fFog[2];

    // Calculate and set composite matrix for seafloor.
    D3DXMatrixMultiply( &matComposite, &m_matView, &m_matProj );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 8, &matComposite, 4 );

    // Calculate and set texgen matrix for dolphin.
    D3DXMatrixMultiply( &matComposite, &matDolphin, &m_matView );
    matComposite *= 0.5f;
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 12, &matComposite, 4 );

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant(  0, &fConstants0, 1 ); // Some constants
    m_pd3dDevice->SetVertexShaderConstant(  1, &fConstants1, 1 ); // More constants
    m_pd3dDevice->SetVertexShaderConstant(  2, &fWeight,     1 ); // Tweening weight

    m_pd3dDevice->SetVertexShaderConstant( 20, &fLight,      1 ); // Light direction
    m_pd3dDevice->SetVertexShaderConstant( 21, &fDiffuse,    1 ); // Diffuse color
    m_pd3dDevice->SetVertexShaderConstant( 23, &fFog,        1 ); // Fog factors
    m_pd3dDevice->SetVertexShaderConstant( 24, &fCaustics,   1 ); // Misc constants
    
    // Animate the caustic textures
    DWORD tex = ((DWORD)(m_fAppTime*32))%32;
    m_pCurrentCausticTexture = m_pCausticTextures[tex];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Sets up render states, clears the viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         g_dwWaterColor, 1.0f, 0L );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwWaterColor );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP );

    // Turn on the pixel shader for the underwater effect, which blends in the
    // current caustic texture.
    m_pd3dDevice->SetPixelShader( m_dwUnderWaterPixelShader );
    m_pd3dDevice->SetTexture( 1, m_pCurrentCausticTexture );

    // Set the ambient color input to the pixel shader.
    // Note: This must be done after the pixel shader is set.
    D3DXVECTOR4 fAmbient( 0.25f, 0.25f, 0.25f, 0.25f );
    m_pd3dDevice->SetPixelShaderConstant( 0, &fAmbient, 1 );

    // Render the seafloor. The vertex shader does the transformation, texture
    // projection (for the water caustics) and fog calculations.
    m_pd3dDevice->SetTexture( 0, m_pSeaFloorTexture );
    m_pd3dDevice->SetVertexShader( m_dwSeaFloorVertexShader );
    m_pd3dDevice->SetStreamSource( 0, m_pSeaFloorVB, m_dwSeaFloorVertexSize );
    m_pd3dDevice->SetIndices( m_pSeaFloorIB, 0 );
    m_pd3dDevice->DrawIndexedVertices( D3DPT_TRIANGLESTRIP, m_dwNumSeaFloorIndices, 
                                       D3D__IndexData );

    // Render the dolphin. The vertex shader does the vertex tweening, 
    // transformation, texture projection (for the water caustics) and fog
    // calculations.
    m_pd3dDevice->SetTexture( 0, m_pDolphinTexture );
    m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
    m_pd3dDevice->SetStreamSource( 0, m_pDolphinStream1, m_dwDolphinVertexSize );
    m_pd3dDevice->SetStreamSource( 1, m_pDolphinStream2, m_dwDolphinVertexSize );
    m_pd3dDevice->SetIndices( m_pDolphinIB, 0 );
    m_pd3dDevice->DrawIndexedVertices( D3DPT_TRIANGLESTRIP, m_dwNumDolphinIndices, 
                                       D3D__IndexData );

    // Draw the title and framerate
    m_Font.Begin();
    m_Font.DrawText(  64, 50, 0xffffffff, L"DolphinClassic" );
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinClassic\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 34UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_WaterCaustic00_OFFSET 40UL
#define resource_WaterCaustic01_OFFSET 60UL
#define resource_WaterCaustic02_OFFSET 80UL
#define resource_WaterCaustic03_OFFSET 100UL
#define resource_WaterCaustic04_OFFSET 120UL
#define resource_WaterCaustic05_OFFSET 140UL
#define resource_WaterCaustic06_OFFSET 160UL
#define resource_WaterCaustic07_OFFSET 180UL
#define resource_WaterCaustic08_OFFSET 200UL
#define resource_WaterCaustic09_OFFSET 220UL
#define resource_WaterCaustic10_OFFSET 240UL
#define resource_WaterCaustic11_OFFSET 260UL
#define resource_WaterCaustic12_OFFSET 280UL
#define resource_WaterCaustic13_OFFSET 300UL
#define resource_WaterCaustic14_OFFSET 320UL
#define resource_WaterCaustic15_OFFSET 340UL
#define resource_WaterCaustic16_OFFSET 360UL
#define resource_WaterCaustic17_OFFSET 380UL
#define resource_WaterCaustic18_OFFSET 400UL
#define resource_WaterCaustic19_OFFSET 420UL
#define resource_WaterCaustic20_OFFSET 440UL
#define resource_WaterCaustic21_OFFSET 460UL
#define resource_WaterCaustic22_OFFSET 480UL
#define resource_WaterCaustic23_OFFSET 500UL
#define resource_WaterCaustic24_OFFSET 520UL
#define resource_WaterCaustic25_OFFSET 540UL
#define resource_WaterCaustic26_OFFSET 560UL
#define resource_WaterCaustic27_OFFSET 580UL
#define resource_WaterCaustic28_OFFSET 600UL
#define resource_WaterCaustic29_OFFSET 620UL
#define resource_WaterCaustic30_OFFSET 640UL
#define resource_WaterCaustic31_OFFSET 660UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinHDTV\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinHDTV\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinHDTV\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 35UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_BubbleTexture_OFFSET 40UL
#define resource_WaterCaustic00_OFFSET 60UL
#define resource_WaterCaustic01_OFFSET 80UL
#define resource_WaterCaustic02_OFFSET 100UL
#define resource_WaterCaustic03_OFFSET 120UL
#define resource_WaterCaustic04_OFFSET 140UL
#define resource_WaterCaustic05_OFFSET 160UL
#define resource_WaterCaustic06_OFFSET 180UL
#define resource_WaterCaustic07_OFFSET 200UL
#define resource_WaterCaustic08_OFFSET 220UL
#define resource_WaterCaustic09_OFFSET 240UL
#define resource_WaterCaustic10_OFFSET 260UL
#define resource_WaterCaustic11_OFFSET 280UL
#define resource_WaterCaustic12_OFFSET 300UL
#define resource_WaterCaustic13_OFFSET 320UL
#define resource_WaterCaustic14_OFFSET 340UL
#define resource_WaterCaustic15_OFFSET 360UL
#define resource_WaterCaustic16_OFFSET 380UL
#define resource_WaterCaustic17_OFFSET 400UL
#define resource_WaterCaustic18_OFFSET 420UL
#define resource_WaterCaustic19_OFFSET 440UL
#define resource_WaterCaustic20_OFFSET 460UL
#define resource_WaterCaustic21_OFFSET 480UL
#define resource_WaterCaustic22_OFFSET 500UL
#define resource_WaterCaustic23_OFFSET 520UL
#define resource_WaterCaustic24_OFFSET 540UL
#define resource_WaterCaustic25_OFFSET 560UL
#define resource_WaterCaustic26_OFFSET 580UL
#define resource_WaterCaustic27_OFFSET 600UL
#define resource_WaterCaustic28_OFFSET 620UL
#define resource_WaterCaustic29_OFFSET 640UL
#define resource_WaterCaustic30_OFFSET 660UL
#define resource_WaterCaustic31_OFFSET 680UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinHDTV\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinClassic\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 34UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_WaterCaustic00_OFFSET 40UL
#define resource_WaterCaustic01_OFFSET 60UL
#define resource_WaterCaustic02_OFFSET 80UL
#define resource_WaterCaustic03_OFFSET 100UL
#define resource_WaterCaustic04_OFFSET 120UL
#define resource_WaterCaustic05_OFFSET 140UL
#define resource_WaterCaustic06_OFFSET 160UL
#define resource_WaterCaustic07_OFFSET 180UL
#define resource_WaterCaustic08_OFFSET 200UL
#define resource_WaterCaustic09_OFFSET 220UL
#define resource_WaterCaustic10_OFFSET 240UL
#define resource_WaterCaustic11_OFFSET 260UL
#define resource_WaterCaustic12_OFFSET 280UL
#define resource_WaterCaustic13_OFFSET 300UL
#define resource_WaterCaustic14_OFFSET 320UL
#define resource_WaterCaustic15_OFFSET 340UL
#define resource_WaterCaustic16_OFFSET 360UL
#define resource_WaterCaustic17_OFFSET 380UL
#define resource_WaterCaustic18_OFFSET 400UL
#define resource_WaterCaustic19_OFFSET 420UL
#define resource_WaterCaustic20_OFFSET 440UL
#define resource_WaterCaustic21_OFFSET 460UL
#define resource_WaterCaustic22_OFFSET 480UL
#define resource_WaterCaustic23_OFFSET 500UL
#define resource_WaterCaustic24_OFFSET 520UL
#define resource_WaterCaustic25_OFFSET 540UL
#define resource_WaterCaustic26_OFFSET 560UL
#define resource_WaterCaustic27_OFFSET 580UL
#define resource_WaterCaustic28_OFFSET 600UL
#define resource_WaterCaustic29_OFFSET 620UL
#define resource_WaterCaustic30_OFFSET 640UL
#define resource_WaterCaustic31_OFFSET 660UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinHDTV\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 35UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_BubbleTexture_OFFSET 40UL
#define resource_WaterCaustic00_OFFSET 60UL
#define resource_WaterCaustic01_OFFSET 80UL
#define resource_WaterCaustic02_OFFSET 100UL
#define resource_WaterCaustic03_OFFSET 120UL
#define resource_WaterCaustic04_OFFSET 140UL
#define resource_WaterCaustic05_OFFSET 160UL
#define resource_WaterCaustic06_OFFSET 180UL
#define resource_WaterCaustic07_OFFSET 200UL
#define resource_WaterCaustic08_OFFSET 220UL
#define resource_WaterCaustic09_OFFSET 240UL
#define resource_WaterCaustic10_OFFSET 260UL
#define resource_WaterCaustic11_OFFSET 280UL
#define resource_WaterCaustic12_OFFSET 300UL
#define resource_WaterCaustic13_OFFSET 320UL
#define resource_WaterCaustic14_OFFSET 340UL
#define resource_WaterCaustic15_OFFSET 360UL
#define resource_WaterCaustic16_OFFSET 380UL
#define resource_WaterCaustic17_OFFSET 400UL
#define resource_WaterCaustic18_OFFSET 420UL
#define resource_WaterCaustic19_OFFSET 440UL
#define resource_WaterCaustic20_OFFSET 460UL
#define resource_WaterCaustic21_OFFSET 480UL
#define resource_WaterCaustic22_OFFSET 500UL
#define resource_WaterCaustic23_OFFSET 520UL
#define resource_WaterCaustic24_OFFSET 540UL
#define resource_WaterCaustic25_OFFSET 560UL
#define resource_WaterCaustic26_OFFSET 580UL
#define resource_WaterCaustic27_OFFSET 600UL
#define resource_WaterCaustic28_OFFSET 620UL
#define resource_WaterCaustic29_OFFSET 640UL
#define resource_WaterCaustic30_OFFSET 660UL
#define resource_WaterCaustic31_OFFSET 680UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinHDTV\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\DolphinHDTV\DolphinHDTV.cpp ===
//-----------------------------------------------------------------------------
// File: DolphinHDTV.cpp
//
// Desc: Shows how to check for and use HDTV modes
//
// Hist: 8.21.01 - New for November release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <XBHelp.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_A_BUTTON,     XBHELP_PLACEMENT_1, L"Next video mode" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 2



//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------
DWORD g_dwWaterColor = 0x00004080;

FLOAT g_fCycle      = 120.0f;     // Time for dolphin to complete a path cycle
FLOAT g_fLightAngle = D3DX_PI/4;  // Orientation of light from above



#define SHADOW_SIZE  256
DWORD g_dwShadowColor = 0xff000000;


// Vertex for the 3D meshes
struct D3DVERTEX
{
    D3DXVECTOR3 p;           // Position
    D3DXVECTOR3 n;           // Normal
    FLOAT       tu, tv;      // Tex coords
};

#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)


// Structure for the bubbles
struct BUBBLE
{
    FLOAT       age, lifespan;
    FLOAT       angle, spread, wobble;
    D3DXVECTOR3 vPos;
    D3DXVECTOR3 vPos0;
};

typedef struct {
    DWORD dwWidth;
    DWORD dwHeight;
    BOOL  fProgressive;
    BOOL  fWideScreen;
} DISPLAY_MODE;

DISPLAY_MODE g_aDisplayModes[] =
{
//    Width  Height Progressive Widescreen
    {   640,    480,    FALSE,  FALSE },        // 640x480 interlaced 4x3
    {   640,    480,    FALSE,  TRUE },         // 640x480 interlaced 16x9
    {   640,    480,    TRUE,   FALSE },        // 640x480 progressive 4x3
    {   640,    480,    TRUE,   TRUE },         // 640x480 progressive 16x9
    {   720,    480,    FALSE,  FALSE },        // 720x480 interlaced 4x3
    {   720,    480,    FALSE,  TRUE },         // 720x480 interlaced 16x9
    {   720,    480,    TRUE,   FALSE },        // 720x480 progressive 4x3
    {   720,    480,    TRUE,   TRUE },         // 720x480 progressive 16x9
    {  1280,    720,    TRUE,   TRUE },         // 720x480 progressive 16x9
    {  1920,   1080,    FALSE,  TRUE },         // 1920x1080 interlaced 16x9 
};
#define NUM_MODES ( sizeof( g_aDisplayModes ) / sizeof( g_aDisplayModes[0] ) )


//-----------------------------------------------------------------------------
// Name: SupportsMode
// Desc: Returns TRUE if we can support the given mode, based off the
//       currently plugged in AV pack and video flags
//-----------------------------------------------------------------------------
BOOL SupportsMode( DISPLAY_MODE mode, DWORD dwVideoFlags )
{
    // Need to check for widescreen on 480 modes only - 
    // 720p and 1080i are by definition widescreen.
    if( mode.dwHeight == 480 && mode.fWideScreen && !(dwVideoFlags & XC_VIDEO_FLAGS_WIDESCREEN ) )
        return FALSE;

    // Explicit check for 480p
    if( mode.dwHeight == 480 && mode.fProgressive && !(dwVideoFlags & XC_VIDEO_FLAGS_HDTV_480p) )
        return FALSE;

    // Explicit check for 720p (only 720 mode)
    if( mode.dwHeight == 720 && !(dwVideoFlags & XC_VIDEO_FLAGS_HDTV_720p) )
        return FALSE;

    // Explicit check for 1080i (only 1080 mode)
    if( mode.dwHeight == 1080 && !(dwVideoFlags & XC_VIDEO_FLAGS_HDTV_1080i) )
        return FALSE;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font
    CXBFont                 m_Font;
    CXBHelp                 m_Help;             // Help class
    BOOL                    m_bDrawHelp;        // Whether to draw help

    CXBPackedResource       m_xprResources;

    // Transform matrices
    D3DXMATRIX              m_matWorld;
    D3DXMATRIX              m_matView;
    D3DXMATRIX              m_matProj;

    // Dolphin object
    LPDIRECT3DTEXTURE8      m_pDolphinTexture;
    DWORD                   m_dwDolphinVertexShader;
    CXBMesh                 m_DolphinObject1;
    CXBMesh                 m_DolphinObject2;
    CXBMesh                 m_DolphinObject3;
    XBMESH_DATA*            m_pDolphinMesh1;
    XBMESH_DATA*            m_pDolphinMesh2;
    XBMESH_DATA*            m_pDolphinMesh3;

    // Seafloor object
    LPDIRECT3DTEXTURE8      m_pSeaFloorTexture;
    DWORD                   m_dwSeaFloorVertexShader;
    CXBMesh                 m_SeaFloorObject;
    XBMESH_DATA*            m_pSeaFloorMesh;

    // Water caustics
    LPDIRECT3DTEXTURE8      m_pCausticTextures[32];
    LPDIRECT3DTEXTURE8      m_pCurrentCausticTexture;
    DWORD                   m_dwDolphinPixelShader;
    DWORD                   m_dwSeaFloorPixelShader;

    // Dolphin shadow
    LPDIRECT3DTEXTURE8      m_pShadowTexture;
    LPDIRECT3DSURFACE8      m_pShadowSurface;

    // Bubbles
    D3DXVECTOR3        m_vBubbleEmitterPos;
    BUBBLE*            m_pBubbles;
    DWORD              m_dwNumBubbles;
    LPDIRECT3DVERTEXBUFFER8 m_pBubbleVB;
    LPDIRECT3DTEXTURE8 m_pBubbleTexture;

    HRESULT CreatePixelShader();
    HRESULT UpdateBubbles( FLOAT fAddBubbles );
    HRESULT RenderBubbles();

    // Spline path for the dolphin
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinSplineVB;
    D3DXVECTOR3* m_DolphinSpline;
    DWORD        m_dwNumDolphinSplinePts;

    DWORD            m_dwVideoFlags;
    DWORD            m_dwCurrentMode;

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Unless the user has the HDTV AV pack plugged in, the only
    // interesting thing we can do is widescreen.  We could check
    // the letterbox flag and manually letterbox, but it's not as
    // interesting.

    // Note:
    // Prior to the November release of the XDK, it was important
    // to mask off any video flags that didn't match the AV pack
    // that was connected (eg, no HDTV modes if the HDTV pack is
    // not connected).  That's no longer necessary, because
    // XGetVideoFlags will do that for us.
    DWORD dwPack = XGetAVPack();
    m_dwVideoFlags = XGetVideoFlags();

    // Start out in 640x480 interlaced 4x3
    m_d3dpp.BackBufferWidth = 640;
    m_d3dpp.BackBufferHeight = 480;
    m_d3dpp.Flags = D3DPRESENTFLAG_INTERLACED;
    m_dwCurrentMode = 0;

    // Dolphin object
    m_dwDolphinVertexShader  = 0L;

    // SeaFloor object
    m_dwSeaFloorVertexShader = 0L;

    // Water caustics
    m_dwDolphinPixelShader  = 0L;
    m_dwSeaFloorPixelShader = 0L;

    m_pBubbleTexture     = NULL;
    m_pBubbleVB          = NULL;
    m_dwNumBubbles       = 100;
    m_pBubbles           = new BUBBLE[m_dwNumBubbles];
    m_vBubbleEmitterPos  = D3DXVECTOR3( 0, -1, -6 );

    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        m_pBubbles[i].lifespan = 5.0f + ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f;
        m_pBubbles[i].age      = (i*m_pBubbles[i].lifespan)/m_dwNumBubbles;
        m_pBubbles[i].angle    = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f * D3DX_PI;
        m_pBubbles[i].spread   = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 1.0f;
        m_pBubbles[i].wobble   = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f * D3DX_PI - D3DX_PI;

        FLOAT y = m_pBubbles[i].age;
        FLOAT r = m_pBubbles[i].spread * sqrtf( y / 10.0f );
        FLOAT x = r*sinf( m_pBubbles[i].angle );
        FLOAT z = r*cosf( m_pBubbles[i].angle );

        x += 0.1f*sqrtf( y / 4.0f ) * sinf( 1 * y * m_pBubbles[i].wobble );
        z += 0.1f*sqrtf( y / 4.0f ) * cosf( 1 * y * m_pBubbles[i].wobble );

        m_pBubbles[i].vPos0 = m_vBubbleEmitterPos;

        m_pBubbles[i].vPos.x = m_pBubbles[i].vPos0.x + x;
        m_pBubbles[i].vPos.y = m_pBubbles[i].vPos0.y + y;
        m_pBubbles[i].vPos.z = m_pBubbles[i].vPos0.z + z;
    }

    m_bDrawHelp = FALSE;
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    // Setup the pixel shader for the dolphin. To blend in water caustics, we
    // want the following effect:
    //    result = t0 * ( v0 + t1 * v1 )
    // where:
    //    t0 = Base texture
    //    t1 = Water caustics texture
    //    v0 = Ambient light contribution
    //    v1 = Directional light contribution
    //
    // This can be encoded into a pixel shader with:
    //    1st stage: r0 = (t1*v1 + v0*1)
    //    Final:     A*B + (1-A)*C + D
    //               E*F = r0 * t0
    // where:
    //    A = Fog factor
    //    B = EF
    //    C = Fog color
    //    D = 0
    //    E = r0
    //    F = t0
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_ZERO_TO_ONE,
                                         PS_DOTMAPPING_ZERO_TO_ONE, PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V1 + V0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwDolphinPixelShader ) ) )
        return E_FAIL;


    
    // Setup the pixel shader for the seafloor. This is the same as above,
    // except we're also modulating in the dolphin shadow, stored in t2.
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 2,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_NONE );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V1, R1=V0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_R1,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_R1,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Stage 1 -------------
    // Build factor from caustics and lighting (R0 = R0 * T2 + R1 )
    psd.PSRGBInputs[1]    = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_T2  | PS_CHANNEL_RGB,
                                               PS_REGISTER_R1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[1]  = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_T2  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_R1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[1]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwSeaFloorPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT    hr;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the file-based mesh objects for the dolphin
    if( FAILED( m_DolphinObject1.Create( m_pd3dDevice, "Models\\Dolphin1.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_DolphinObject2.Create( m_pd3dDevice, "Models\\Dolphin2.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_DolphinObject3.Create( m_pd3dDevice, "Models\\Dolphin3.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get access to the mesh data (VB, IB, num indices, etc.). Note that we
    // can safely do this because we know this file contains only one mesh.
    m_pDolphinMesh1 = m_DolphinObject1.GetMesh(0);
    m_pDolphinMesh2 = m_DolphinObject2.GetMesh(0);
    m_pDolphinMesh3 = m_DolphinObject3.GetMesh(0);

    // Create vertex shader for the dolphin
    DWORD dwDolphinVertexDecl[] =
    {
        // First dolphin position
        D3DVSD_STREAM( 0 ),              // This data comes from stream 0
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // v3 = Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // v6 = Tex coords

        // Second dolphin position
        D3DVSD_STREAM( 1 ),              // This data comes from stream 1
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = Position of second mesh
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ), // v4 = Normal
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Tex coords

        // Third dolphin position
        D3DVSD_STREAM( 2 ),              // This data comes from stream 2
        D3DVSD_REG( 2, D3DVSDT_FLOAT3 ), // v2 = Position of second mesh
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ), // v5 = Normal
        D3DVSD_REG( 8, D3DVSDT_FLOAT2 ), // v8 = Tex coords
        D3DVSD_END()
    };

    hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Dolphin.xvu",
                                    dwDolphinVertexDecl, &m_dwDolphinVertexShader );
    if( FAILED(hr) )
        return hr;

    // Load the file-based mesh object for the seafloor
    if( FAILED( m_SeaFloorObject.Create( m_pd3dDevice, "Models\\SeaFloor.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get access to the mesh data (VB, IB, num indices, etc.). Note that we
    // can safely do this because we know this file contains only one mesh.
    m_pSeaFloorMesh = m_SeaFloorObject.GetMesh(0);

    // Create vertex shader for the seafloor
    DWORD dwSeaFloorVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
        D3DVSD_END()
    };

    if( FAILED( hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\SeaFloor.xvu",
                                                dwSeaFloorVertexDecl,
                                                &m_dwSeaFloorVertexShader ) ) )
        return hr;

    // Create a pixel shader for the underwater effect
    hr = CreatePixelShader();
    if( FAILED(hr) )
        return hr;

    // Set the transform matrices
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( 0.0f, 0.0f,-10.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f, 1.0f,  0.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 1000.0f );

    // Create the particle system's vertex buffer
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( m_dwNumBubbles*sizeof(D3DXVECTOR3),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_XYZ,
                                                  D3DPOOL_MANAGED, &m_pBubbleVB ) ) )
        return E_FAIL;


    // Load the file-based mesh object which holds the dolphin path
    CXBMesh xbgPath;
    if( FAILED( xbgPath.Create( m_pd3dDevice, "Models\\Path.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_dwNumDolphinSplinePts = xbgPath.GetMesh(0)->m_dwNumVertices/2;
    m_DolphinSpline         = new D3DXVECTOR3[m_dwNumDolphinSplinePts];

    D3DXVECTOR3* pPathData;
    xbgPath.GetMesh(0)->m_VB.Lock( 0, 0, (BYTE**)&pPathData, 0 );
    for( DWORD i = 0; i < m_dwNumDolphinSplinePts; i++ )
    {
        m_DolphinSpline[i] = pPathData[i];
    }
    xbgPath.GetMesh(0)->m_VB.Unlock();

    // Create the dolphin's shadow texture
    if( FAILED( m_pd3dDevice->CreateTexture( SHADOW_SIZE, SHADOW_SIZE, 1, 0, 
                                             D3DFMT_X8R8G8B8, 0, &m_pShadowTexture ) ) )
        return E_FAIL;
    m_pShadowTexture->GetSurfaceLevel( 0, &m_pShadowSurface );

    // Load resources from the packed resource file. Resources (textures, vertex
    // buffers,etc.) can be packed this way so they load super quick and require
    // no load-time processing (like parsing a .bmp file, changing formats,
    // swizzling, etc.). See the code in XBResource.cpp to see how simple it is.
    if( FAILED( m_xprResources.Create( m_pd3dDevice, "Resource.xpr", 
                                       resource_NUM_RESOURCES ) ) )
        return E_FAIL;

    // Get pointers to our textures
    m_pDolphinTexture      = m_xprResources.GetTexture( resource_DolphinTexture_OFFSET );
    m_pSeaFloorTexture     = m_xprResources.GetTexture( resource_SeaFloorTexture_OFFSET );
    m_pBubbleTexture       = m_xprResources.GetTexture( resource_BubbleTexture_OFFSET );
    m_pCausticTextures[ 0] = m_xprResources.GetTexture( resource_WaterCaustic00_OFFSET );
    m_pCausticTextures[ 1] = m_xprResources.GetTexture( resource_WaterCaustic01_OFFSET );
    m_pCausticTextures[ 2] = m_xprResources.GetTexture( resource_WaterCaustic02_OFFSET );
    m_pCausticTextures[ 3] = m_xprResources.GetTexture( resource_WaterCaustic03_OFFSET );
    m_pCausticTextures[ 4] = m_xprResources.GetTexture( resource_WaterCaustic04_OFFSET );
    m_pCausticTextures[ 5] = m_xprResources.GetTexture( resource_WaterCaustic05_OFFSET );
    m_pCausticTextures[ 6] = m_xprResources.GetTexture( resource_WaterCaustic06_OFFSET );
    m_pCausticTextures[ 7] = m_xprResources.GetTexture( resource_WaterCaustic07_OFFSET );
    m_pCausticTextures[ 8] = m_xprResources.GetTexture( resource_WaterCaustic08_OFFSET );
    m_pCausticTextures[ 9] = m_xprResources.GetTexture( resource_WaterCaustic09_OFFSET );
    m_pCausticTextures[10] = m_xprResources.GetTexture( resource_WaterCaustic10_OFFSET );
    m_pCausticTextures[11] = m_xprResources.GetTexture( resource_WaterCaustic11_OFFSET );
    m_pCausticTextures[12] = m_xprResources.GetTexture( resource_WaterCaustic12_OFFSET );
    m_pCausticTextures[13] = m_xprResources.GetTexture( resource_WaterCaustic13_OFFSET );
    m_pCausticTextures[14] = m_xprResources.GetTexture( resource_WaterCaustic14_OFFSET );
    m_pCausticTextures[15] = m_xprResources.GetTexture( resource_WaterCaustic15_OFFSET );
    m_pCausticTextures[16] = m_xprResources.GetTexture( resource_WaterCaustic16_OFFSET );
    m_pCausticTextures[17] = m_xprResources.GetTexture( resource_WaterCaustic17_OFFSET );
    m_pCausticTextures[18] = m_xprResources.GetTexture( resource_WaterCaustic18_OFFSET );
    m_pCausticTextures[19] = m_xprResources.GetTexture( resource_WaterCaustic19_OFFSET );
    m_pCausticTextures[20] = m_xprResources.GetTexture( resource_WaterCaustic20_OFFSET );
    m_pCausticTextures[21] = m_xprResources.GetTexture( resource_WaterCaustic21_OFFSET );
    m_pCausticTextures[22] = m_xprResources.GetTexture( resource_WaterCaustic22_OFFSET );
    m_pCausticTextures[23] = m_xprResources.GetTexture( resource_WaterCaustic23_OFFSET );
    m_pCausticTextures[24] = m_xprResources.GetTexture( resource_WaterCaustic24_OFFSET );
    m_pCausticTextures[25] = m_xprResources.GetTexture( resource_WaterCaustic25_OFFSET );
    m_pCausticTextures[26] = m_xprResources.GetTexture( resource_WaterCaustic26_OFFSET );
    m_pCausticTextures[27] = m_xprResources.GetTexture( resource_WaterCaustic27_OFFSET );
    m_pCausticTextures[28] = m_xprResources.GetTexture( resource_WaterCaustic28_OFFSET );
    m_pCausticTextures[29] = m_xprResources.GetTexture( resource_WaterCaustic29_OFFSET );
    m_pCausticTextures[30] = m_xprResources.GetTexture( resource_WaterCaustic30_OFFSET );
    m_pCausticTextures[31] = m_xprResources.GetTexture( resource_WaterCaustic31_OFFSET );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Animation attributes for the dolphin
    FLOAT fPhase       = m_fAppTime/3;
    FLOAT fKickFreq    = 6*fPhase;
    FLOAT fBlendWeight = sinf( fKickFreq );

    // Get the parametric value u for the time-based dolphin position on it's
    // path, where 0 < u < NUM_SPLINE_POINTS.
    FLOAT u = m_dwNumDolphinSplinePts * ((m_fAppTime/g_fCycle) - floorf(m_fAppTime/g_fCycle));

    // Get the dolphin position and tangent from the spline path
    D3DXVECTOR3 vDolphinPos, vDolphinDir;
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u, 
                           &vDolphinPos, &vDolphinDir );

    // Scale and orient the dolphin model
    D3DXMATRIX matScale, matRotateY, matDolphin;
    D3DXMatrixScaling( &matScale, 0.01f, 0.01f, 0.01f );
    D3DXMatrixRotationY( &matRotateY, D3DX_PI/2 );
    D3DXMatrixMultiply( &matDolphin, &matScale, &matRotateY );

    // Add the rotation and translation for the dolphin kick
    D3DXMATRIX matKickRotate;
    D3DXMatrixRotationX( &matKickRotate, -cosf(fKickFreq)/6 );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matKickRotate );
    vDolphinPos.y += sinf(fKickFreq)/2;

    // Add the spline path. We can use the inverse of a lookat matrix to generate the
    // position and orientation of the dolphin on the path
    D3DXMATRIX matPathLookAt, matDolphinRotate, matDolphinTrans;
    D3DXMatrixLookAtLH( &matPathLookAt, &D3DXVECTOR3(0,0,0), &vDolphinDir, &D3DXVECTOR3(0,1,0) );
    D3DXMatrixInverse( &matDolphinRotate, NULL, &matPathLookAt );
    D3DXMatrixTranslation( &matDolphinTrans, vDolphinPos.x, vDolphinPos.y, vDolphinPos.z );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matDolphinRotate );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matDolphinTrans );

    // Position the bubble emitter position to correspond to the dolphin's blowhole.
    D3DXVECTOR3 vBlowHole( -150.0f, 40.0f, 0.0f );
    D3DXVec3TransformCoord( &m_vBubbleEmitterPos, &vBlowHole, &matDolphin );

    // Position the camera
    FLOAT u0 = m_dwNumDolphinSplinePts * (((m_fAppTime-1.5f)/g_fCycle) - floorf((m_fAppTime-1.5f)/g_fCycle));
    FLOAT u1 = m_dwNumDolphinSplinePts * (((m_fAppTime+0.2f)/g_fCycle) - floorf((m_fAppTime+0.2f)/g_fCycle));
    D3DXVECTOR3 vEyePt, vLookatPt;
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u0, &vEyePt,    NULL );
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u1, &vLookatPt, NULL );
    vEyePt *= 0.9f;
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &D3DXVECTOR3(0,1,0) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Vary the fog range, color, and ambient lighting based on depth
    FLOAT fDepthFactor = 1.0f + vEyePt.y/51.0f;
    FLOAT fFogEnd   = 50.0f + 100.0f * fDepthFactor;
    FLOAT fFogStart = 1.0f/(fFogEnd-1.0f);
    DWORD green = 0x0000ff00 & (DWORD)(0x00008000 * fDepthFactor);
    DWORD blue  = 0x000000ff & (DWORD)(0x000000ff * fDepthFactor);
    g_dwWaterColor = ( green | blue );

    DWORD dwColorFactor = (DWORD)( 255.0f * (1.0f-0.5f*fDepthFactor) );
    g_dwShadowColor = (dwColorFactor<<16) | (dwColorFactor<<8) | (dwColorFactor<<0);

    // Blend weight for vertex tweening
    FLOAT fWeight1 = ( fBlendWeight > 0.0f ) ? fabsf(fBlendWeight) : 0.0f;
    FLOAT fWeight2 = 1.0f - fabsf(fBlendWeight);
    FLOAT fWeight3 = ( fBlendWeight > 0.0f ) ? 0.0f : fabsf(fBlendWeight);

    // Values passed into the vertex shader for lighting, etc.
    D3DXVECTOR4 fConstants0( 0.0f, 0.0f, 0.0f, 0.00f );
    D3DXVECTOR4 fConstants1( 1.0f, 0.5f, 0.2f, 0.05f );
    D3DXVECTOR4 fLight( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f, 0.0f );
    D3DXVECTOR4 fDiffuse( 1.00f, 1.00f, 1.00f, 1.00f );
    D3DXVECTOR4 fAmbient( 0.5f*fDepthFactor, 0.5f*fDepthFactor, 0.5f*fDepthFactor, 1.0f );
    D3DXVECTOR4 fFog( 0.5f, fFogEnd*fFogStart, fFogStart, 0.0f );
    D3DXVECTOR4 fCaustics( 0.05f, 0.05f, sinf(m_fAppTime)/8, cosf(m_fAppTime)/10 - m_fAppTime/10 );
    D3DXVECTOR4 fWeight( fWeight1, fWeight2, fWeight3, 0.0f );

    // Build matrix sets (and transpose them) for the vertex shaders
    D3DXMATRIX matDolphinWV, matDolphinWVP;
    D3DXMatrixMultiply( &matDolphinWV, &matDolphin, &m_matView );
    D3DXMatrixMultiply( &matDolphinWVP, &matDolphinWV, &m_matProj );
    D3DXMatrixTranspose( &matDolphinWV,  &matDolphinWV );
    D3DXMatrixTranspose( &matDolphinWVP,  &matDolphinWVP );

    D3DXMATRIX matSeaFloorWVP;
    D3DXMatrixMultiply( &matSeaFloorWVP, &m_matView, &m_matProj );
    D3DXMatrixTranspose( &matSeaFloorWVP,  &matSeaFloorWVP );

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant(  0, &fConstants0,    1 ); // Some constants
    m_pd3dDevice->SetVertexShaderConstant(  1, &fConstants1,    1 ); // More constants
    m_pd3dDevice->SetVertexShaderConstant(  2, &fWeight,        1 );
    m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinWV,   4 ); // Dolphin WV matrix set
    m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinWVP,  4 ); // Dolphin WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 30, &matSeaFloorWVP, 4 ); // Seafloor WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 40, &fLight,         1 ); // Light direction
    m_pd3dDevice->SetVertexShaderConstant( 41, &fDiffuse,       1 ); // Diffuse color
    m_pd3dDevice->SetVertexShaderConstant( 42, &fAmbient,       1 ); // Ambient color
    m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,           1 ); // Fog factors
    m_pd3dDevice->SetVertexShaderConstant( 44, &fCaustics,      1 ); // Misc constants

    // Animate the caustic textures
    DWORD tex = ((DWORD)(m_fAppTime*32))%32;
    m_pCurrentCausticTexture = m_pCausticTextures[tex];

    // Make this into a curve!
    FLOAT fAddBubbles = 0.0f;
    if( ((DWORD)m_fAppTime)%7 < 2 )
        fAddBubbles = m_fElapsedAppTime*50;

    UpdateBubbles( fAddBubbles );

    // Render the dolphin's shadow
    {
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwShadowColor );

        // Get the current backbuffer and zbuffer
        LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
        m_pd3dDevice->GetRenderTarget( &pBackBuffer );
        m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

        // Set the shadow texture as the rendertarget
        m_pd3dDevice->SetRenderTarget( m_pShadowSurface, NULL );

        // Set the viewport to be the correct size and clear it
        D3DVIEWPORT8 vpShadow = { 0, 0, SHADOW_SIZE, SHADOW_SIZE, 0.0f, 1.0f };
        m_pd3dDevice->SetViewport( &vpShadow );
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xffffffff, 1.0f, 0L );

        // Set new vertex shader constants so that (a) the camera is at the
        // light position, looking at the dolphin and (b) we use fog to control
        // the only color that gets written is the shadow color.
        D3DXVECTOR3 vShadowEyePt = vDolphinPos + 10 * D3DXVECTOR3( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f );
        D3DXMATRIX  matShadowView;
        D3DXMATRIX  matShadowProj;
        D3DXMatrixLookAtLH( &matShadowView, &vShadowEyePt, &vDolphinPos, &vDolphinDir );
        D3DXMatrixOrthoLH( &matShadowProj, 3.5f, 7.0f, 1.0f, 200.0f );
        D3DXVECTOR4 fFog( 0.5f, 0.1f, 0.0f, 0.0f );
                   
        D3DXMATRIX matDolphinShadowWV, matDolphinShadowWVP;
        D3DXMatrixMultiply( &matDolphinShadowWV,  &matDolphin,         &matShadowView );
        D3DXMatrixMultiply( &matDolphinShadowWVP, &matDolphinShadowWV, &matShadowProj );
        D3DXMatrixTranspose( &matDolphinShadowWV,  &matDolphinShadowWV );
        D3DXMatrixTranspose( &matDolphinShadowWVP, &matDolphinShadowWVP );

        m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinShadowWV,  4 ); // Dolphin WV matrix set
        m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinShadowWVP, 4 ); // Dolphin WVP matrix set
        m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,                1 ); // Fog factors

        // Render the dolphin into the shadow texture
        m_pd3dDevice->SetPixelShader( NULL );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
        m_pd3dDevice->SetStreamSource( 0, &m_pDolphinMesh1->m_VB, m_pDolphinMesh1->m_dwVertexSize );
        m_pd3dDevice->SetStreamSource( 1, &m_pDolphinMesh2->m_VB, m_pDolphinMesh2->m_dwVertexSize );
        m_pd3dDevice->SetStreamSource( 2, &m_pDolphinMesh3->m_VB, m_pDolphinMesh3->m_dwVertexSize );
        m_pd3dDevice->SetIndices( &m_pDolphinMesh1->m_IB, 0 );
        m_pd3dDevice->DrawIndexedVertices( m_pDolphinMesh1->m_dwPrimType, 
                                           m_pDolphinMesh1->m_dwNumIndices,
                                           D3D__IndexData );

        // Change the rendertarget back to the main backbuffer
        D3DVIEWPORT8 vpBackBuffer = { 0, 0, g_aDisplayModes[ m_dwCurrentMode ].dwWidth, g_aDisplayModes[ m_dwCurrentMode ].dwHeight, 0.0f, 1.0f };
        m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
        m_pd3dDevice->SetViewport( &vpBackBuffer );
        pBackBuffer->Release();
        pZBuffer->Release();

        // Now, generate the texture matrix to project shadow onto the
        // seafloor. Here we just set up the matrix, and the vertex shader will
        // do the per-vertex computation for the texture coordinates.

        // Build shadow projection matrix
        D3DXMatrixOrthoLH( &matShadowProj, 15.0f*3.5f, 15.0f*7.0f, 1.0f, 200.0f );

        // Build matrix to shift coordinates from viewport space (-1,+1) to
        // texture space (0,1)
        D3DXMATRIX matTexShift;
        D3DXMatrixIdentity( &matTexShift );
        matTexShift._11 = +0.5f;   matTexShift._12 =  0.0f;
        matTexShift._21 =  0.0f;   matTexShift._22 = -0.5f;
        matTexShift._31 = +0.5f;   matTexShift._32 = +0.5f;

        // Concat the pieces to make the final texture matrix
        D3DXMATRIX matTexProj;
        D3DXMatrixIdentity( &matTexProj );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matShadowView );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matShadowProj );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matTexShift );

        // Pass the matrix to the vertex shader via a vertex shader constant
        D3DXMATRIX matTexProjT;
        D3DXMatrixTranspose( &matTexProjT, &matTexProj );
        m_pd3dDevice->SetVertexShaderConstant( 50, &matTexProjT, 4 );
    }

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinWV,  4 ); // Dolphin WV matrix set
    m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinWVP, 4 ); // Dolphin WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,          1 ); // Fog factors

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
        // Find the next mode that can be supported
        do
        {
            m_dwCurrentMode = ( m_dwCurrentMode + 1 ) % NUM_MODES;
        } while( !SupportsMode( g_aDisplayModes[ m_dwCurrentMode ], m_dwVideoFlags ) );

        // Adjust presentation parameters
        m_d3dpp.BackBufferWidth = g_aDisplayModes[ m_dwCurrentMode ].dwWidth;
        m_d3dpp.BackBufferHeight = g_aDisplayModes[ m_dwCurrentMode ].dwHeight;
        m_d3dpp.Flags = g_aDisplayModes[ m_dwCurrentMode ].fProgressive ? D3DPRESENTFLAG_PROGRESSIVE : D3DPRESENTFLAG_INTERLACED;
        m_d3dpp.Flags |= g_aDisplayModes[ m_dwCurrentMode ].fWideScreen ? D3DPRESENTFLAG_WIDESCREEN : 0;

        // Reset the device
        m_pd3dDevice->Reset( &m_d3dpp );

        // Set up projection matrix properly for widescreen modes
        if( g_aDisplayModes[ m_dwCurrentMode ].fWideScreen )
            D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 16.0f/9.0f, 1.0f, 1000.0f );
        else
            D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 1000.0f );

    }

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::UpdateBubbles( FLOAT fAddBubbles )
{
    static FLOAT fBubblesToAdd = 0.0f;
    fBubblesToAdd += fAddBubbles;

    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        if( m_pBubbles[i].age > m_pBubbles[i].lifespan )
        {
            if( fBubblesToAdd > 1.0f )
            {
                fBubblesToAdd -= 1.0f;

                m_pBubbles[i].age      = m_pBubbles[i].age - m_pBubbles[i].lifespan;
                m_pBubbles[i].lifespan = 3.0f + ((FLOAT)rand()/(FLOAT)RAND_MAX) * 1.0f;
                m_pBubbles[i].vPos0    = m_vBubbleEmitterPos;
            }
        }
        else
            m_pBubbles[i].age += m_fElapsedAppTime;

        BUBBLE* pBubble = &m_pBubbles[i];

        FLOAT y = 1.2f*m_pBubbles[i].age;
        FLOAT r = m_pBubbles[i].spread * sqrtf( y / 10.0f );
        FLOAT x = r*sinf( m_pBubbles[i].angle );
        FLOAT z = r*cosf( m_pBubbles[i].angle );

        x += 0.1f*sqrtf( y / 4.0f ) * sinf( 1 * y * m_pBubbles[i].wobble );
        z += 0.1f*sqrtf( y / 4.0f ) * cosf( 1 * y * m_pBubbles[i].wobble );

        m_pBubbles[i].vPos.x = m_pBubbles[i].vPos0.x + x;
        m_pBubbles[i].vPos.y = m_pBubbles[i].vPos0.y + y;
        m_pBubbles[i].vPos.z = m_pBubbles[i].vPos0.z + z;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderBubbles()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderBubbles()
{
    // Set the world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set the view matrix
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Set projection matrix
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );
    
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );

    // Set states for rendering the particles. Note that point sprites use 
    // stage 3.
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCCOLOR );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
    m_pd3dDevice->SetTexture( 3, m_pBubbleTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

    // Set the render states for using point sprites
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(0.15f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_A,      FtoDW(0.00f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_B,      FtoDW(0.00f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_C,      FtoDW(1.00f) );

    // Set up the vertex buffer to be rendered
    D3DXVECTOR3* pVertices;
    DWORD        dwNumParticlesToRender = 0;
    m_pBubbleVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Render each particle
    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        if( m_pBubbles[i].age < m_pBubbles[i].lifespan )
        {
            pVertices->x = m_pBubbles[i].vPos.x;
            pVertices->y = m_pBubbles[i].vPos.y;
            pVertices->z = m_pBubbles[i].vPos.z;
            pVertices++;

            dwNumParticlesToRender++;
        }
    }

    // Unlock the vertex buffer
    m_pBubbleVB->Unlock();
    if( dwNumParticlesToRender > 0 )
    {
        m_pd3dDevice->SetStreamSource( 0, m_pBubbleVB, sizeof(D3DXVECTOR3) );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
        m_pd3dDevice->DrawPrimitive( D3DPT_POINTLIST, 0, dwNumParticlesToRender );
    }

    // Reset render states
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  FALSE );
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         g_dwWaterColor, 1.0f, 0L );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwWaterColor );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    // Turn on the pixel shader for the underwater effect, which blends in the
    // current caustic texture and the dolphin's shadow. Note that specular
    // must be enabled for the pixel shader to use the v1 register.
    m_pd3dDevice->SetTexture( 1, m_pCurrentCausticTexture );
    m_pd3dDevice->SetTexture( 2, m_pShadowTexture );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   TRUE );

    // Render the seafloor. The vertex shader does the transformation, texture
    // projection (for the water caustics) and fog calculations.
    m_pd3dDevice->SetTexture( 0, m_pSeaFloorTexture );
    m_pd3dDevice->SetPixelShader( m_dwSeaFloorPixelShader );
    m_pd3dDevice->SetVertexShader( m_dwSeaFloorVertexShader );
    m_pd3dDevice->SetStreamSource( 0, &m_pSeaFloorMesh->m_VB, m_pSeaFloorMesh->m_dwVertexSize );
    m_pd3dDevice->SetIndices( &m_pSeaFloorMesh->m_IB, 0 );
    m_pd3dDevice->DrawIndexedVertices( m_pSeaFloorMesh->m_dwPrimType, 
                                       m_pSeaFloorMesh->m_dwNumIndices,
                                       D3D__IndexData );

    // Render the dolphin. The vertex shader does the vertex tweening, 
    // transformation, texture projection (for the water caustics) and fog
    // calculations.
    m_pd3dDevice->SetTexture( 0, m_pDolphinTexture );
    m_pd3dDevice->SetPixelShader( m_dwDolphinPixelShader );
    m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
    m_pd3dDevice->SetStreamSource( 0, &m_pDolphinMesh1->m_VB, m_pDolphinMesh1->m_dwVertexSize );
    m_pd3dDevice->SetStreamSource( 1, &m_pDolphinMesh2->m_VB, m_pDolphinMesh2->m_dwVertexSize );
    m_pd3dDevice->SetStreamSource( 2, &m_pDolphinMesh3->m_VB, m_pDolphinMesh3->m_dwVertexSize );
    m_pd3dDevice->SetIndices( &m_pDolphinMesh1->m_IB, 0 );
    m_pd3dDevice->DrawIndexedVertices( m_pDolphinMesh1->m_dwPrimType, 
                                       m_pDolphinMesh1->m_dwNumIndices,
                                       D3D__IndexData );

    // Render the bubble system
    RenderBubbles();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"DolphinHDTV " );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR sz[100];
        swprintf( sz, L"Mode: %dx%d %s %s", g_aDisplayModes[ m_dwCurrentMode ].dwWidth, 
                                            g_aDisplayModes[ m_dwCurrentMode ].dwHeight, 
                                            g_aDisplayModes[ m_dwCurrentMode ].fProgressive ? L"Progressive" : L"Interlaced", 
                                            g_aDisplayModes[ m_dwCurrentMode ].fWideScreen ? L"16x9" : L"4x3" );
        m_Font.DrawText( 90, 80, 0xffffff00, sz );

        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Donuts3D\Resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 10UL

#define resource_SkyBoxXP_OFFSET 0UL
#define resource_SkyBoxXN_OFFSET 20UL
#define resource_SkyBoxYP_OFFSET 40UL
#define resource_SkyBoxYN_OFFSET 60UL
#define resource_SkyBoxZP_OFFSET 80UL
#define resource_SkyBoxZN_OFFSET 100UL
#define resource_Splash_OFFSET 120UL
#define resource_Donuts1_OFFSET 140UL
#define resource_Donuts2_OFFSET 160UL
#define resource_Seafloor_OFFSET 180UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Donuts3D\gamemenu.cpp ===
//-----------------------------------------------------------------------------
// File: GameMenu.cpp
//
// Desc: Code for in-game menus
//
// Copyright (C) Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <XBUtil.h>
#include "GameMenu.h"




//-----------------------------------------------------------------------------
// Name: CMenuItem()
// Desc: 
//-----------------------------------------------------------------------------
CMenuItem::CMenuItem( LPDIRECT3DTEXTURE8 pTexture, DWORD dwID )
{
	m_pTexture       = pTexture;
	m_dwID           = dwID;
	m_pParent        = NULL;
	m_dwNumChildren  = 0L;
	m_dwSelectedMenu = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CMenuItem()
// Desc: 
//-----------------------------------------------------------------------------
CMenuItem::~CMenuItem()
{
	SAFE_RELEASE( m_pTexture );

	while( m_dwNumChildren )
		delete m_pChild[--m_dwNumChildren];
}




//-----------------------------------------------------------------------------
// Name: Add()
// Desc: 
//-----------------------------------------------------------------------------
CMenuItem* CMenuItem::Add( CMenuItem* pNewChild )
{
	m_pChild[m_dwNumChildren++] = pNewChild;
	pNewChild->m_pParent        = this;

	return pNewChild;
}



//-----------------------------------------------------------------------------
// Name: RenderLabel()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CMenuItem::RenderLabel( LPDIRECT3DDEVICE8 pd3dDevice )
{
	// Get texture dimensions
	D3DSURFACE_DESC desc;
	m_pTexture->GetLevelDesc( 0, &desc );
	FLOAT fWidth  = (FLOAT)desc.Width;
	FLOAT fHeight = (FLOAT)desc.Height;

	struct VERTEX { D3DXVECTOR3 p; FLOAT tu, tv; } v[4];
	v[0].p = D3DXVECTOR3( -fWidth/2, +fHeight/2, 0.0f ); v[0].tu = 0.0f; v[0].tv = 0.0f; 
	v[1].p = D3DXVECTOR3( +fWidth/2, +fHeight/2, 0.0f ); v[1].tu = 1.0f; v[1].tv = 0.0f; 
	v[2].p = D3DXVECTOR3( -fWidth/2, -fHeight/2, 0.0f ); v[2].tu = 0.0f; v[2].tv = 1.0f; 
	v[3].p = D3DXVECTOR3( +fWidth/2, -fHeight/2, 0.0f ); v[3].tu = 1.0f; v[3].tv = 1.0f; 

	// Scale tex coordinates for linear textures
	if( FALSE == XGIsSwizzledFormat( desc.Format ) )
	{
		v[0].tu *= fWidth;   v[0].tv *= fHeight; 
		v[1].tu *= fWidth;   v[1].tv *= fHeight; 
		v[2].tu *= fWidth;   v[2].tv *= fHeight; 
		v[3].tu *= fWidth;   v[3].tv *= fHeight; 
	}
	
	// Render the menuitem's label
	pd3dDevice->SetTexture( 0, m_pTexture );
	pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
	pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
	pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_TEX1 );
	pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(VERTEX) );

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CMenuItem::Render( LPDIRECT3DDEVICE8 pd3dDevice )
{
	// Save current matrices
	D3DXMATRIX matViewSaved, matProjSaved;
	pd3dDevice->GetTransform( D3DTS_VIEW,       &matViewSaved );
	pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProjSaved );


	FLOAT z = 320.0f / tanf(D3DX_PI/8);

	// Setup new view and proj matrices for head-on viewing
	D3DXMATRIX matView, matProj;
	D3DXMatrixLookAtLH( &matView, &D3DXVECTOR3( 0.0f, 0.0f,-30.0f ),
								  &D3DXVECTOR3( 0.0f, 0.0f,  0.0f ),
				 				  &D3DXVECTOR3( 0.0f, 1.0f,  0.0f ) );
	D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 1.0f, 1.0f, 1000.0f );
	pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
	pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// Establish colors for selected vs. normal menu items
	D3DMATERIAL8 mtrlNormal, mtrlSelected, mtrlTitle;
	XBUtil_InitMaterial( mtrlTitle,    1.0f, 0.0f, 0.0f, 1.0f );
	XBUtil_InitMaterial( mtrlNormal,   1.0f, 1.0f, 1.0f, 0.5f );
	XBUtil_InitMaterial( mtrlSelected, 1.0f, 1.0f, 0.0f, 1.0f );

	pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
	pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0xffffffff );

	// Translate the menuitem into place
	D3DXMATRIX matWorld;
	D3DXMatrixScaling( &matWorld, 20.0f/320.0f, 20.0f/240.0f, 20.0f/320.0f );
	matWorld._42 = (m_dwNumChildren*1.0f) + 2.0f;
	pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

	pd3dDevice->SetMaterial( &mtrlTitle );

	// Render the menuitem's label
	RenderLabel( pd3dDevice );

	// Loop through and render all menuitem lables
	for( DWORD i=0; i<m_dwNumChildren; i++ )
	{
		D3DXMATRIX matWorld;
		D3DXMatrixScaling( &matWorld, 15.0f/320.0f, 15.0f/240.0f, 15.0f/320.0f );
		pd3dDevice->SetMaterial( &mtrlNormal );

		// Give a different effect for selected items
		if( m_dwSelectedMenu == i )
		{
			D3DXMATRIX matRotate;
			D3DXMatrixRotationY( &matRotate, (D3DX_PI/3)*sinf(timeGetTime()/200.0f) );
			D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );
			pd3dDevice->SetMaterial( &mtrlSelected );
		}

		// Translate the menuitem into place
		matWorld._42 = (m_dwNumChildren*1.0f) - (i*2.0f);
		pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

		// Render the menuitem's label
		m_pChild[i]->RenderLabel( pd3dDevice );
	}

	// Restore matrices
	pd3dDevice->SetTransform( D3DTS_VIEW,       &matViewSaved );
	pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProjSaved );

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Donuts3D\donuts.cpp ===
//-----------------------------------------------------------------------------
// File: Donuts.cpp
//
// Desc: DirectInput semantic mapper version of Donuts3D game
//
// Copyright (C) 1995-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <XBApp.h>
#include "XBCamera.h"
#include <XBFont.h>
#include <XBInput.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBSound.h>
#include <XBUtil.h>
#include "donuts.h"
#include "gamemenu.h"
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "SkyBoxXN.bmp", resource_SkyBoxXN_OFFSET },
    { "SkyBoxXP.bmp", resource_SkyBoxXP_OFFSET },
    { "SkyBoxYN.bmp", resource_SkyBoxYN_OFFSET },
    { "SkyBoxYP.bmp", resource_SkyBoxYP_OFFSET },
    { "SkyBoxZN.bmp", resource_SkyBoxZN_OFFSET },
    { "SkyBoxZP.bmp", resource_SkyBoxZP_OFFSET },
    { "Splash.bmp",   resource_Splash_OFFSET },
    { "Seafloor.bmp", resource_Seafloor_OFFSET },
    { "Donuts1.tga",  resource_Donuts1_OFFSET },
    { "Donuts2.tga",  resource_Donuts2_OFFSET },
    { NULL, 0 },
};

CXBPackedResource  g_xprResource;      // Packed resources for the app

   



extern XBGAMEPAD g_Gamepads[4];


FLOAT g_fMaxTerrainX = -1e10f;
FLOAT g_fMinTerrainX = +1e10f;
FLOAT g_fMaxTerrainY = -1e10f;
FLOAT g_fMinTerrainY = +1e10f;
FLOAT g_fMaxTerrainZ = -1e10f;
FLOAT g_fMinTerrainZ = +1e10f;


LPDIRECT3DTEXTURE8 g_pLevelTexture  = NULL;
LPDIRECT3DTEXTURE8 g_pPausedTexture = NULL;




//-----------------------------------------------------------------------------
// Custom Direct3D vertex types
//-----------------------------------------------------------------------------
struct SCREENVERTEX
{
    D3DXVECTOR4 p;
    DWORD       color;
};

struct SPRITEVERTEX
{
    D3DXVECTOR3 p;
    DWORD       color;
    FLOAT       tu, tv;
};

struct TERRAINVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};

#define D3DFVF_SCREENVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)
#define D3DFVF_SPRITEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Application globals
//-----------------------------------------------------------------------------
BOOL                 g_bDisplayReady  = FALSE; // Whether display class is initialized
DWORD                g_dwAppState;              // Current state the app is in
DWORD                g_dwLevel        = 0;      // Current game level
DWORD                g_dwScore        = 0;      // Current game score

// Player view mode
#define NUMVIEWMODES 3
CXBCamera            g_Camera;                       // Camera used for 3D scene
DWORD                g_dwViewMode           = 0;     // Which view mode is being used
FLOAT                g_fViewTransition      = 0.0f;  // Amount used to transittion views
BOOL                 g_bAnimatingViewChange = FALSE; // Whether view is transitioning
BOOL                 g_bFirstPersonView     = TRUE;  // Whether view is first-person

// Bullet mode
FLOAT                g_fBulletRechargeTime  = 0.0f;  // Recharge time for firing bullets
DWORD                g_dwBulletType         = 0L;    // Current bullet type

// Display list and player ship
DisplayObject*       g_pDisplayList = NULL;          // Global display list
CShip*               g_pShip        = NULL;          // Player's display object

// DirectDraw/Direct3D objects
LPDIRECT3DVERTEXBUFFER8 g_pViewportVB       = NULL;
LPDIRECT3DVERTEXBUFFER8 g_pSpriteVB         = NULL;


// Support for the ship model
CXBMesh*             g_pShipFileObject   = NULL;      // Geometry model of player's ship
DWORD                g_dwNumShipTypes    = 10L;
DWORD                g_dwCurrentShipType = 0L;
CHAR*                g_strShipFiles[]    = { "Models\\Heli.xbg",            "Models\\Spaceship 2.xbg", "Models\\Shusui.xbg",
                                             "Models\\Space Station 7.xbg", "Models\\Spaceship 8.xbg", "Models\\Orbiter.xbg",
                                             "Models\\Spaceship 13.xbg",    "Models\\Spaceship 5.xbg", "Models\\Star Sail.xbg", 
                                             "Models\\Concept Plane 3.xbg", };
WCHAR*               g_strShipNames[]    = { L"Helicopter",    L"Green Machine",  L"Purple Prowler",
                                             L"Drone Clone",   L"Canyon Fighter", L"Roundabout",
                                             L"Tie-X7",        L"Gunner",         L"Star Sail", 
                                             L"Concept Plane", };

// Sound objects
#ifdef SOUND_ACTUALLY_WORKS
CXBSound             g_BeginLevelSound;  // Sounds for the app
CXBSound             g_EngineIdleSound;
CXBSound             g_EngineRevSound;
CXBSound             g_ShieldBuzzSound;
CXBSound             g_ShipExplodeSound;
CXBSound             g_FireBulletSound;
CXBSound             g_ShipBounceSound;
CXBSound             g_DonutExplodeSound;
CXBSound             g_PyramidExplodeSound;
CXBSound             g_CubeExplodeSound;
CXBSound             g_SphereExplodeSound;
#endif // SOUND_ACTUALLY_WORKS

// Game objects
LPDIRECT3DTEXTURE8   g_pSplashTexture  = NULL;    // Texture with game object animations
LPDIRECT3DTEXTURE8   g_pGameTexture1   = NULL;    // Texture with game object animations
LPDIRECT3DTEXTURE8   g_pGameTexture2   = NULL;    // Texture with game object animations
CXBMesh              g_SkyBoxObject;              // Skybox object
CXBMesh*             g_pTerrain        = NULL;    // Geometry model of terrain
CXBFont              g_GameFont;                  // Font for displaying score, etc.
CXBFont              g_MenuFont;                  // Font for displaying in-game menus


// Menu objects
CMenuItem*           g_pMainMenu       = NULL;    // Menu class for in-game menus
CMenuItem*           g_pQuitMenu       = NULL;
CMenuItem*           g_pCurrentMenu    = NULL;

// Defines for the in-game menu
#define MENU_MAIN           1
#define MENU_SOUND          2
#define MENU_VIDEO          3
#define MENU_INPUT          4
#define MENU_VIEWDEVICES    5
#define MENU_CONFIGDEVICES  6
#define MENU_WINDOWED       7
#define MENU_640x480        8
#define MENU_800x600        9
#define MENU_1024x768      10
#define MENU_BACK          11
#define MENU_SOUNDON       12
#define MENU_SOUNDOFF      13
#define MENU_QUIT          14


// Game input variables
FLOAT                g_fBank           = 0.0f;
FLOAT                g_fThrust         = 0.0f;
BOOL                 g_bFiringWeapons  = FALSE;
BOOL                 g_bChangeView     = FALSE;
BOOL                 g_bPaused         = FALSE;

// Menu input variables
BOOL                 g_bMenuLeft       = FALSE;
BOOL                 g_bMenuRight      = FALSE;
BOOL                 g_bMenuUp         = FALSE;
BOOL                 g_bMenuDown       = FALSE;
BOOL                 g_bMenuSelect     = FALSE;




//-----------------------------------------------------------------------------
// Inline helper functions
//-----------------------------------------------------------------------------

// Simple function to define "hilliness" for terrain
inline FLOAT HeightField( FLOAT x, FLOAT z )
{
    return (cosf(x/2.0f+0.2f)*cosf(z/1.5f-0.2f)+1.0f) - 2.0f;
}

// Simple function for generating random numbers
inline FLOAT rnd( FLOAT low, FLOAT high )
{
    return low + ( high - low ) * ( (FLOAT)rand() ) / RAND_MAX;
}




//-----------------------------------------------------------------------------
// Name: GameInitialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT GameInitialize()
{
    HRESULT hr;

    // Initialize the DirectSound stuff.
    if( FAILED( hr = CreateSoundObjects() ) )
        return hr;

    // Create the display objects
    if( FAILED( hr = CreateDisplayObjects() ) )
        return hr;

    // Add a ship to the displaylist
    g_pShip        = new CShip( D3DXVECTOR3(0.0f,0.0f,0.0f) );
    g_pDisplayList = g_pShip;

    // Construct the game menus
    ConstructMenus();

    // Initial program state is to display the splash screen
    g_dwAppState = APPSTATE_LOADSPLASH;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GameFrameMove()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT GameFrameMove()
{
    switch( g_dwAppState )
    {
        case APPSTATE_LOADSPLASH:
            // load the splash bitmap
			g_pSplashTexture = g_xprResource.GetTexture( "Splash.bmp" );
            
            // Set the app state to displaying splash
            g_dwAppState = APPSTATE_DISPLAYSPLASH;

            break;

        case APPSTATE_DISPLAYSPLASH:
            // Move from splash screen when user presses a button
            if( g_Gamepads[0].wPressedButtons )
            {
                // Advance to the first level
                AdvanceLevel();
                XBUtil_Timer( TIMER_START );

                g_dwAppState = APPSTATE_BEGINLEVELSCREEN;
            }
            break;

        case APPSTATE_BEGINLEVELSCREEN:
            {
                WCHAR strLevel[80];
                swprintf( strLevel, L"Level %ld", g_dwLevel );
                g_pLevelTexture = g_GameFont.CreateTexture( strLevel );
            }
#ifdef SOUND_ACTUALLY_WORKS
            g_BeginLevelSound.Play();
#endif // SOUND_ACTUALLY_WORKS
            XBUtil_Timer( TIMER_RESET );
            g_dwAppState = APPSTATE_DISPLAYLEVELSCREEN;
            break;

        case APPSTATE_DISPLAYLEVELSCREEN:
            // Only show the Level intro screen for 3 seconds
            if( XBUtil_Timer( TIMER_GETAPPTIME ) > 3.0f )
            {
                g_dwAppState = APPSTATE_ACTIVE;

                SAFE_RELEASE( g_pLevelTexture );            

                SAFE_RELEASE( g_pPausedTexture );            
                g_pPausedTexture = g_GameFont.CreateTexture( L"Paused" );
            }
            break;

        case APPSTATE_ACTIVE:
            UpdateDisplayList();
            CheckForHits();

            if( IsDisplayListEmpty() )
            {
                AdvanceLevel();
                g_dwAppState = APPSTATE_BEGINLEVELSCREEN;
            }
            break;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DestroyGameObjects()
// Desc:
//-----------------------------------------------------------------------------
VOID DestroyGameObjects()
{
    DestroyDisplayObjects();
    DestroySoundObjects();
    DestroyMenus();
}




//-----------------------------------------------------------------------------
// Name: AdvanceLevel()
// Desc:
//-----------------------------------------------------------------------------
VOID AdvanceLevel()
{
    // Up the level
    g_dwLevel++;

    srand( timeGetTime() );

    // Clear any stray objects (anything but the ship) out of the display list
    while( g_pShip->pNext )
    {
        DeleteFromList( g_pShip->pNext );
    }

    // Create donuts for the new level
    for( WORD i=0; i<(2*g_dwLevel+3); i++ )
    {
        D3DVECTOR vPosition = 3.0f * D3DXVECTOR3( rnd(), 0.0f, rnd() );
        D3DVECTOR vVelocity = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );

        AddToList( new CDonut( vPosition, vVelocity ) );
    }

    // Delay for 2 seconds before displaying ship
    g_pShip->vPos       = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    g_pShip->vVel       = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    g_pShip->bVisible   = FALSE;
    g_pShip->bExploded  = FALSE;
    g_pShip->fShowDelay = 2.0f;

    // Clear out iput states
    g_fBank          = 0.0f;
    g_fThrust        = 0.0f;
    g_bFiringWeapons = FALSE;

    // Stop engine sounds
#ifdef SOUND_ACTUALLY_WORKS
    g_EngineIdleSound.Stop();
    g_EngineRevSound.Stop();
#endif // SOUND_ACTUALLY_WORKS
}




//-----------------------------------------------------------------------------
// Name: DisplayObject()
// Desc:
//-----------------------------------------------------------------------------
DisplayObject::DisplayObject( DWORD type, D3DVECTOR p, D3DVECTOR v )
{
    // Set object attributes
    pNext    = NULL;
    pPrev    = NULL;
    bVisible = TRUE;
    dwType   = type;
    vPos     = p;
    vVel     = v;
}




//-----------------------------------------------------------------------------
// Name: C3DSprite()
// Desc:
//-----------------------------------------------------------------------------
C3DSprite::C3DSprite( DWORD type, D3DVECTOR p, D3DVECTOR v )
          :DisplayObject( type, p, v )
{
    dwColor = 0xffffffff;
}




//-----------------------------------------------------------------------------
// Name: CDonut()
// Desc:
//-----------------------------------------------------------------------------
CDonut::CDonut( D3DVECTOR p, D3DVECTOR v )
       :C3DSprite( OBJ_DONUT, p, v )
{
    // Set object attributes
    dwTextureWidth   = DONUT_WIDTH;
    dwTextureHeight  = DONUT_HEIGHT;
    dwTextureOffsetX = 0;
    dwTextureOffsetY = 0;

    fSize           = dwTextureWidth / 256.0f;
    vVel            += 0.5f * D3DXVECTOR3( rnd(), 0.0f, rnd() );

    delay           = rnd( 3.0f, 12.0f );
    dwFramesPerLine = 8;
    frame           = rnd( 0.0f, 30.0f );
    fMaxFrame       = NUM_DONUT_FRAMES;
}




//-----------------------------------------------------------------------------
// Name: CPyramid()
// Desc:
//-----------------------------------------------------------------------------
CPyramid::CPyramid( D3DVECTOR p, D3DVECTOR v )
         :C3DSprite( OBJ_PYRAMID, p, v )
{
    // Set object attributes
    dwTextureWidth   = PYRAMID_WIDTH;
    dwTextureHeight  = PYRAMID_HEIGHT;
    dwTextureOffsetX = 0;
    dwTextureOffsetY = 0;

    fSize           = dwTextureWidth / 256.0f;
    vVel            += 0.5f * D3DXVECTOR3( rnd(), 0.0f, rnd() );

    delay           = rnd( 12.0f, 40.0f );
    dwFramesPerLine = 8;
    frame           = rnd( 0.0f, 30.0f );
    fMaxFrame       = NUM_PYRAMID_FRAMES;

}




//-----------------------------------------------------------------------------
// Name: CSphere()
// Desc:
//-----------------------------------------------------------------------------
CSphere::CSphere( D3DVECTOR p, D3DVECTOR v )
        :C3DSprite( OBJ_SPHERE, p, v )
{
    // Set object attributes
    dwTextureWidth   = SPHERE_WIDTH;
    dwTextureHeight  = SPHERE_HEIGHT;
    dwTextureOffsetX = 0;
    dwTextureOffsetY = 128;

    fSize           = dwTextureWidth / 256.0f;
    vVel            += 0.5f * D3DXVECTOR3( rnd(), 0.0f, rnd() );

    delay           = rnd( 60.0f, 80.0f );
    dwFramesPerLine = 16;
    frame           = rnd( 0.0f, 30.0f );
    fMaxFrame       = NUM_SPHERE_FRAMES;
}





//-----------------------------------------------------------------------------
// Name: CCube()
// Desc:
//-----------------------------------------------------------------------------
CCube::CCube( D3DVECTOR p, D3DVECTOR v )
      :C3DSprite( OBJ_CUBE, p, v )
{
    // Set object attributes
    dwTextureWidth   = CUBE_WIDTH;
    dwTextureHeight  = CUBE_HEIGHT;
    dwTextureOffsetX = 0;
    dwTextureOffsetY = 176;

    fSize           = dwTextureWidth / 256.0f;
    vVel            += 0.5f * D3DXVECTOR3( rnd(), 0.0f, rnd() );

    delay           = rnd( 32.0f, 80.0f );
    dwFramesPerLine = 16;
    frame           = rnd( 0.0f, 30.0f );
    fMaxFrame       = NUM_CUBE_FRAMES;
}




//-----------------------------------------------------------------------------
// Name: CCloud()
// Desc:
//-----------------------------------------------------------------------------
CCloud::CCloud( D3DVECTOR p, D3DVECTOR v )
       :C3DSprite( OBJ_CLOUD, p, v )
{
    // Set object attributes
    dwTextureWidth   = CLOUD_WIDTH;
    dwTextureHeight  = CLOUD_WIDTH;
    dwTextureOffsetX = 224;
    dwTextureOffsetY = 224;

    fSize           = dwTextureWidth / 256.0f;
    delay           = rnd( 1.0f, 3.0f );
    dwFramesPerLine = 1;
    frame           = 0.0f;
    fMaxFrame       = 1;
}




//-----------------------------------------------------------------------------
// Name: CBullet()
// Desc:
//-----------------------------------------------------------------------------
CBullet::CBullet( D3DVECTOR p, D3DVECTOR v, DWORD dwCType )
        :C3DSprite( OBJ_BULLET, p, v )
{
    // Set object attributes
    dwTextureWidth   = CLOUD_WIDTH;
    dwTextureHeight  = CLOUD_HEIGHT;
    dwTextureOffsetX = 224;
    dwTextureOffsetY = 224;

    if( dwCType == 0 )
        dwColor = 0xff2020ff;
    if( dwCType == 1 )
        dwColor = 0xff208020;
    if( dwCType == 2 )
        dwColor = 0xff208080;
    if( dwCType == 3 )
        dwColor = 0xff802020;

    fSize           = 4 / 256.0f;
    fMaxFrame       = NUM_BULLET_FRAMES;

    delay           = 1000.0f;
    dwFramesPerLine = 1;
    frame           = 0.0f;
}




//-----------------------------------------------------------------------------
// Name: CShip()
// Desc:
//-----------------------------------------------------------------------------
CShip::CShip( D3DVECTOR p )
      :DisplayObject( OBJ_SHIP, p, D3DXVECTOR3(0,0,0) )
{
    fSize           = 10.0f / 256.0f;
    bExploded       = FALSE;
    fShowDelay      = 0.0f;

    fRoll           = 0.0f;
    fAngle          = 0.0f;
}




//-----------------------------------------------------------------------------
// Name: AddToList()
// Desc:
//-----------------------------------------------------------------------------
VOID AddToList( DisplayObject* pObject )
{
    pObject->pNext = g_pDisplayList->pNext;
    pObject->pPrev = g_pDisplayList;

    if( g_pDisplayList->pNext )
        g_pDisplayList->pNext->pPrev = pObject;
    g_pDisplayList->pNext = pObject;
}




//-----------------------------------------------------------------------------
// Name: IsDisplayListEmpty()
// Desc:
//-----------------------------------------------------------------------------
BOOL IsDisplayListEmpty()
{
    DisplayObject* pObject = g_pDisplayList->pNext;

    while( pObject )
    {
        if( pObject->dwType != OBJ_BULLET )
            return FALSE;

        pObject = pObject->pNext;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: LoadTerrainModel()
// Desc: Loads the 3D geometry for the terrain
//-----------------------------------------------------------------------------
HRESULT LoadTerrainModel()
{
    LPDIRECT3DVERTEXBUFFER8 pVB;
    DWORD          dwNumVertices;
    TERRAINVERTEX* pVertices;

    // Delete old object
    SAFE_DELETE( g_pTerrain );

    // Create new object
    g_pTerrain = new CXBMesh();
    if( FAILED( g_pTerrain->Create( g_pd3dDevice, "Models\\SeaFloor.xbg", &g_xprResource ) ) )
        return E_FAIL;

    // Gain access to the model's vertices
    dwNumVertices =  g_pTerrain->GetMesh(0)->m_dwNumVertices;
    pVB           = &g_pTerrain->GetMesh(0)->m_VB;
    pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    for( DWORD i=0; i<dwNumVertices; i++ )
    {
        pVertices[i].p.x *= 0.1f;
        pVertices[i].p.z *= 0.1f;
        pVertices[i].p.y = HeightField( pVertices[i].p.x, pVertices[i].p.z );

        if( pVertices[i].p.x > g_fMaxTerrainX )   g_fMaxTerrainX = pVertices[i].p.x;
        if( pVertices[i].p.x < g_fMinTerrainX )   g_fMinTerrainX = pVertices[i].p.x;
        if( pVertices[i].p.y > g_fMaxTerrainY )   g_fMaxTerrainY = pVertices[i].p.y;
        if( pVertices[i].p.y < g_fMinTerrainY )   g_fMinTerrainY = pVertices[i].p.y;
        if( pVertices[i].p.z > g_fMaxTerrainZ )   g_fMaxTerrainZ = pVertices[i].p.z;
        if( pVertices[i].p.z < g_fMinTerrainZ )   g_fMinTerrainZ = pVertices[i].p.z;
    }

    // Done with the vertex buffer
    pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadShipModel()
// Desc: Loads the 3D geometry for the player's ship
//-----------------------------------------------------------------------------
HRESULT LoadShipModel()
{
    LPDIRECT3DVERTEXBUFFER8 pVB;
    DWORD        dwNumVertices;
    BYTE*        pVertices;
    D3DXVECTOR3  vCenter;
    FLOAT        fRadius;
    DWORD        dwFVF;
    DWORD        dwVertexSize;

    // Make sure the ship is not selected
    g_pd3dDevice->SetStreamSource( 0, NULL, 0 );
    g_pd3dDevice->SetIndices( NULL, 0 );

    // Delete old object
    SAFE_DELETE( g_pShipFileObject );

    // Create new object
    g_pShipFileObject = new CXBMesh();
    if( FAILED( g_pShipFileObject->Create( g_pd3dDevice, g_strShipFiles[g_dwCurrentShipType], &g_xprResource ) ) )
        return E_FAIL;

    // Gain access to the model's vertices
    pVB           = &g_pShipFileObject->GetMesh(0)->m_VB;
    dwNumVertices =  g_pShipFileObject->GetMesh(0)->m_dwNumVertices;
    dwFVF         =  g_pShipFileObject->GetMesh(0)->m_dwFVF;
    dwVertexSize  =  g_pShipFileObject->GetMesh(0)->m_dwVertexSize;
    pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Scale the new object to a standard size  
    D3DXComputeBoundingSphere( pVertices, dwNumVertices, dwFVF, 
                               &vCenter, &fRadius );
    for( DWORD i=0; i<dwNumVertices; i++ )
    {
        *((D3DXVECTOR3*)pVertices) /= 12*fRadius;
        pVertices += dwVertexSize;
    }

    // Done with the vertex buffer
    pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SwitchModel()
// Desc:
//-----------------------------------------------------------------------------
HRESULT SwitchModel()
{
    // Select next model
    g_dwCurrentShipType++;
    if( g_dwCurrentShipType >= g_dwNumShipTypes )
        g_dwCurrentShipType = 0L;

    // Create new object
    if( FAILED( LoadShipModel() ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderFrame()
// Desc:
//-----------------------------------------------------------------------------
HRESULT DisplaySplash()
{
    struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
    v[0].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 1.0f, 1.0f );  v[0].tu = 0.0f; v[0].tv = 0.0f; 
    v[1].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 1.0f, 1.0f );  v[1].tu = 1.0f; v[1].tv = 0.0f; 
    v[2].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 1.0f, 1.0f );  v[2].tu = 0.0f; v[2].tv = 1.0f; 
    v[3].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 1.0f, 1.0f );  v[3].tu = 1.0f; v[3].tv = 1.0f; 

    // Set states
    g_pd3dDevice->SetTexture( 0, g_pSplashTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GameRender()
// Desc:
//-----------------------------------------------------------------------------
HRESULT GameRender()
{
    // Render the scene based on current state of the app
    switch( g_dwAppState )
    {
        case APPSTATE_LOADSPLASH:
            // Nothing to render while loading the splash screen
            break;

        case APPSTATE_DISPLAYSPLASH:
            DisplaySplash();
            break;

        case APPSTATE_BEGINLEVELSCREEN:
            // Nothing to render while starting sound to advance a level
            break;

        case APPSTATE_DISPLAYLEVELSCREEN:
            DisplayLevelIntroScreen();
            break;

        case APPSTATE_ACTIVE:
            DrawDisplayList();
            break;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DarkenScene()
// Desc:
//-----------------------------------------------------------------------------
VOID DarkenScene( FLOAT fAmount )
{
    if( g_pd3dDevice==NULL )
        return;

    // Setup a dark square to cover the scene
    DWORD dwAlpha = (fAmount<1.0f) ? ((DWORD)(255*fAmount))<<24L : 0xff000000;
    SCREENVERTEX* v;
    g_pViewportVB->Lock( 0, 0, (BYTE**)&v, 0 );
    v[0].color = v[1].color = v[2].color = v[3].color = dwAlpha;
    g_pViewportVB->Unlock();

    // Set renderstates
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE,   FALSE );
    g_pd3dDevice->SetTexture( 0, NULL );

    // Draw a big, gray square
    g_pd3dDevice->SetVertexShader( D3DFVF_SCREENVERTEX );
    g_pd3dDevice->SetStreamSource( 0, g_pViewportVB, sizeof(SCREENVERTEX) );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP,0, 2 );

    // Restore states
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
}


struct MYVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
    



//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
VOID RenderFieryEffect( LPDIRECT3DTEXTURE8 pTexture, FLOAT fScale )
{
    // Get texture dimensions
    D3DSURFACE_DESC desc;
    pTexture->GetLevelDesc( 0, &desc );
    FLOAT fWidth  = fScale * 0.5f * ((FLOAT)desc.Width);
    FLOAT fHeight = fScale * 0.5f * ((FLOAT)desc.Height);

    MYVERTEX vtx[4];
    vtx[0].p = D3DXVECTOR4( 320-fWidth - 0.5f, 240-fHeight - 0.5f, 1.0f, 1.0f ); 
    vtx[1].p = D3DXVECTOR4( 320+fWidth - 0.5f, 240-fHeight - 0.5f, 1.0f, 1.0f ); 
    vtx[2].p = D3DXVECTOR4( 320+fWidth - 0.5f, 240+fHeight - 0.5f, 1.0f, 1.0f ); 
    vtx[3].p = D3DXVECTOR4( 320-fWidth - 0.5f, 240+fHeight - 0.5f, 1.0f, 1.0f ); 
    vtx[0].tu = 0.0f; vtx[0].tv = 0.0f; 
    vtx[1].tu = 1.0f; vtx[1].tv = 0.0f; 
    vtx[2].tu = 1.0f; vtx[2].tv = 1.0f; 
    vtx[3].tu = 0.0f; vtx[3].tv = 1.0f; 

    // Scale tex coordinates for linear textures
    if( FALSE == XGIsSwizzledFormat( desc.Format ) )
    {
        vtx[0].tu *= ((FLOAT)desc.Width);   vtx[0].tv *= ((FLOAT)desc.Height); 
        vtx[1].tu *= ((FLOAT)desc.Width);   vtx[1].tv *= ((FLOAT)desc.Height); 
        vtx[2].tu *= ((FLOAT)desc.Width);   vtx[2].tv *= ((FLOAT)desc.Height); 
        vtx[3].tu *= ((FLOAT)desc.Width);   vtx[3].tv *= ((FLOAT)desc.Height); 
    }
    
    g_pd3dDevice->SetTexture( 0, pTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );

    // Render the fiery portion of the text
    for( DWORD i=0; i<20; i++ )
    {
        FLOAT a1 = rnd(0.0f, 2*D3DX_PI);
        FLOAT r1 = rnd(0.0f, 1.0f);


        FLOAT x = 320.0f + 10.0f * r1 * sinf(a1);
        FLOAT y = 240.0f + 10.0f * r1 * cosf(a1);

        if( cosf(a1) < 0.0f )
            y -= 2 * 10.0f * r1 * cosf(a1) * cosf(a1);

        vtx[0].p = D3DXVECTOR4( x-fWidth - 0.5f, y-fHeight - 0.5f, 1.0f, 1.0f ); 
        vtx[1].p = D3DXVECTOR4( x+fWidth - 0.5f, y-fHeight - 0.5f, 1.0f, 1.0f ); 
        vtx[2].p = D3DXVECTOR4( x+fWidth - 0.5f, y+fHeight - 0.5f, 1.0f, 1.0f ); 
        vtx[3].p = D3DXVECTOR4( x-fWidth - 0.5f, y+fHeight - 0.5f, 1.0f, 1.0f ); 

        DWORD r = (CHAR)( 256.0f * ( 1.0f-r1*r1*r1 ) );
        DWORD g = (CHAR)( 256.0f * ( 1.0f-r1*r1 ) );
        DWORD b = (CHAR)( 256.0f * ( 1.0f-r1 ) );
        DWORD dwColor = 0xff000000 + (r<<16) + (g<<8) + b;
        g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );

        g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, vtx, sizeof(vtx[0]) );
    }

    // Render the plain, black portion of the text
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    FLOAT x = -0.5f;
    FLOAT y =  1.8f;

    vtx[0].p = D3DXVECTOR4( 320-fWidth - 0.5f, 240-fHeight - 0.5f, 1.0f, 1.0f ); 
    vtx[1].p = D3DXVECTOR4( 320+fWidth - 0.5f, 240-fHeight - 0.5f, 1.0f, 1.0f ); 
    vtx[2].p = D3DXVECTOR4( 320+fWidth - 0.5f, 240+fHeight - 0.5f, 1.0f, 1.0f ); 
    vtx[3].p = D3DXVECTOR4( 320-fWidth - 0.5f, 240+fHeight - 0.5f, 1.0f, 1.0f ); 

    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff000000 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADLIST, 1, vtx, sizeof(vtx[0]) );
}




//-----------------------------------------------------------------------------
// Name: DisplayLevelIntroScreen()
// Desc:
//-----------------------------------------------------------------------------
VOID DisplayLevelIntroScreen()
{
    // Erase the screen
    g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0L, 1.0f, 0L );

    RenderFieryEffect( g_pLevelTexture, 2.0f );

    DarkenScene( 1.0f - sinf(D3DX_PI*XBUtil_Timer( TIMER_GETAPPTIME )/3.0f) );
}




//-----------------------------------------------------------------------------
// Name: UpdateDisplayList()
// Desc:
//-----------------------------------------------------------------------------
VOID UpdateDisplayList()
{
    DisplayObject* pObject;

        // Get the time lapsed since the last frame
        static FLOAT fLastTime = 0.0f;
    FLOAT fTimeLapsed = XBUtil_Timer( TIMER_GETAPPTIME ) - fLastTime;
        if( fTimeLapsed <= 0.0f )
                fTimeLapsed = 0.01f;
        fLastTime = XBUtil_Timer( TIMER_GETAPPTIME );

    // Read input from the joystick/keyboard/etc
    GetInput();

    // Check for game menu condition
    if( g_pCurrentMenu )
    {
        UpdateMenus();
        return;
    }

    if( g_bPaused )
        return;

    if( g_pShip->fShowDelay > 0.0f )
    {
        g_pShip->fShowDelay -= fTimeLapsed;

        if( g_pShip->fShowDelay <= 0.0f )
        {
            g_pShip->vVel       = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
            g_pShip->fShowDelay = 0.0f;
            g_pShip->bVisible   = TRUE;
            g_pShip->bExploded  = FALSE;
        }
    }

    // Update the ship
    if( g_pShip->bVisible )
    {
        g_pShip->vPos += g_pShip->vVel * fTimeLapsed;
    }

    // Apply banking motion
    g_pShip->fRoll += g_fBank * 1.0f * fTimeLapsed;
    if( g_pShip->fRoll > 0.5f )
        g_pShip->fRoll = 0.5f;
    if( g_pShip->fRoll < -0.5f )
        g_pShip->fRoll = -0.5f;

    g_pShip->fAngle += 5 * g_pShip->fRoll * fTimeLapsed;

    if( g_fBank < 0.2f && g_fBank > -0.2f )
    {
        g_pShip->fRoll *= 0.95f;
    }

    // Slow the ship down
    g_pShip->vVel.x *= 0.97f;
    g_pShip->vVel.z *= 0.97f;

    // Apply thrust
    g_pShip->vVel.x +=  sinf( g_pShip->fAngle ) * g_fThrust * 5.0f * fTimeLapsed;
    g_pShip->vVel.z += -cosf( g_pShip->fAngle ) * g_fThrust * 5.0f * fTimeLapsed;

    // Play thrusting sounds
    {
        static bPlayingEngineRevSound = FALSE;

        if( g_fThrust > 0.5f )
        {
            if( FALSE == bPlayingEngineRevSound )
            {
                bPlayingEngineRevSound = TRUE;
            }
        }
        else
        {
            if( TRUE == bPlayingEngineRevSound )
            {
#ifdef SOUND_ACTUALLY_WORKS
                g_EngineRevSound.Stop();
#endif // SOUND_ACTUALLY_WORKS
                bPlayingEngineRevSound = FALSE;
            }
        }
    }

    g_fBulletRechargeTime -= fTimeLapsed;

     // Fire a bullet
    if( g_bFiringWeapons && g_fBulletRechargeTime <= 0.0f )
    {
        // Ship must be visible and have no shields on to fire
        if( g_pShip->bVisible )
        {
            // Bullets cost one score point
            if( g_dwScore )
                g_dwScore--;

            // Play the "fire" effects
#ifdef SOUND_ACTUALLY_WORKS
            g_FireBulletSound.Play();
#endif // SOUND_ACTUALLY_WORKS

            // Add a bullet to the display list
            if( g_dwBulletType == 0 )
            {
                D3DXVECTOR3 vDir = D3DXVECTOR3( sinf( g_pShip->fAngle ), 0.0f, -cosf( g_pShip->fAngle ) );

                AddToList( new CBullet( g_pShip->vPos, g_pShip->vVel + 5*vDir, 0 ) );
                g_fBulletRechargeTime = 0.05f;
            }
            else if( g_dwBulletType == 1 )
            {
                D3DXVECTOR3 vOffset = 0.02f * D3DXVECTOR3( cosf(g_pShip->fAngle), 0.0f, sinf(g_pShip->fAngle) );
                D3DXVECTOR3 vDir    = 1.00f * D3DXVECTOR3( sinf(g_pShip->fAngle), 0.0f, -cosf(g_pShip->fAngle) );

                AddToList( new CBullet( g_pShip->vPos + vOffset, g_pShip->vVel + 5*vDir, 1 ) );
                AddToList( new CBullet( g_pShip->vPos - vOffset, g_pShip->vVel + 5*vDir, 1 ) );
                g_fBulletRechargeTime = 0.10f;
            }
            else if( g_dwBulletType == 2 )
            {
                FLOAT fBulletAngle = g_pShip->fAngle + 0.2f*rnd();
                D3DXVECTOR3 vDir = D3DXVECTOR3( sinf(fBulletAngle), 0.0f, -cosf(fBulletAngle) );

                AddToList( new CBullet( g_pShip->vPos, g_pShip->vVel + 5*vDir, 2 ) );
                g_fBulletRechargeTime = 0.01f;
            }
            else
            {
                for( DWORD i=0; i<50; i++ )
                {
                    FLOAT fBulletAngle = g_pShip->fAngle + D3DX_PI*rnd();
                    D3DXVECTOR3 vDir = D3DXVECTOR3( sinf(fBulletAngle), 0.0f, -cosf(fBulletAngle) );

                    AddToList( new CBullet( g_pShip->vPos, 5*vDir, 3 ) );
                }

                g_fBulletRechargeTime = 1.0f;
            }
        }
    }

    // Keep ship in bounds
    if( g_pShip->vPos.x < g_fMinTerrainX || g_pShip->vPos.x > g_fMaxTerrainX ||
        g_pShip->vPos.z < g_fMinTerrainZ || g_pShip->vPos.z > g_fMaxTerrainZ )
    {
         D3DXVec3Normalize( &g_pShip->vVel, &g_pShip->vPos );
         g_pShip->vVel.x *= -1.0f;
         g_pShip->vVel.y *= -1.0f;
         g_pShip->vVel.z *= -1.0f;
    }

    // Finally, move all objects on the screen
    for( pObject = g_pDisplayList; pObject; pObject = pObject->pNext )
    {
        // The ship is moved by the code above
        if( pObject->dwType == OBJ_SHIP )
            continue;

        C3DSprite* pSprite = (C3DSprite*)pObject;

        // Update the position and animation frame
        pSprite->vPos  += pSprite->vVel * fTimeLapsed;
        pSprite->frame += pSprite->delay * fTimeLapsed;

        // If this is an "expired" cloud, removed it from list
        if( pObject->dwType == OBJ_CLOUD )
        {
            if( pSprite->frame >= pSprite->fMaxFrame )
            {
                DisplayObject* pVictim = pObject;
                pObject = pObject->pPrev;
                DeleteFromList( pVictim );
            }
        }
        else if( pObject->dwType == OBJ_BULLET )
        {
            // Remove bullets when they leave the scene
            if( pObject->vPos.x < g_fMinTerrainX || pObject->vPos.x > g_fMaxTerrainX ||
                pObject->vPos.z < g_fMinTerrainZ || pObject->vPos.z > g_fMaxTerrainZ )
            {
                DisplayObject* pVictim = pObject;
                pObject = pObject->pPrev;
                DeleteFromList( pVictim );
            }
        }
        else if( pObject->dwType != OBJ_CLOUD )
        {
            // Keep object in bounds in X
            if( pObject->vPos.x < g_fMinTerrainX || pObject->vPos.x > g_fMaxTerrainX )
            {
                if( pObject->vPos.x < g_fMinTerrainX ) pObject->vPos.x = g_fMinTerrainX;
                if( pObject->vPos.x > g_fMaxTerrainZ ) pObject->vPos.x = g_fMaxTerrainX;
                pObject->vVel.x = -pObject->vVel.x;
            }

            // Keep object in bounds in Z
            if( pObject->vPos.z < g_fMinTerrainZ || pObject->vPos.z > g_fMaxTerrainZ )
            {
                if( pObject->vPos.z < g_fMinTerrainZ ) pObject->vPos.z = g_fMinTerrainZ;
                if( pObject->vPos.z > g_fMaxTerrainZ ) pObject->vPos.z = g_fMaxTerrainZ;
                pObject->vVel.z = -pObject->vVel.z;
            }

            // Keep animation frame in bounds
            if( pSprite->frame < 0.0f )
                pSprite->frame += pSprite->fMaxFrame;
            if( pSprite->frame >= pSprite->fMaxFrame )
                pSprite->frame -= pSprite->fMaxFrame;
        }
    }

    D3DXVECTOR3 vEyePt[NUMVIEWMODES];
    D3DXVECTOR3 vLookatPt[NUMVIEWMODES];
    D3DXVECTOR3 vUpVec[NUMVIEWMODES];

    // Update the view
    if( g_bChangeView )
    {
        g_bAnimatingViewChange = TRUE;
        g_bChangeView = FALSE;
    }

    if( g_bAnimatingViewChange )
    {
        g_fViewTransition += fTimeLapsed;

        if( g_fViewTransition >= 1.0f )
        {
            g_dwViewMode++;
            if( g_dwViewMode >= NUMVIEWMODES )
                g_dwViewMode = 0;

            g_fViewTransition      = 0.0f;
            g_bAnimatingViewChange = FALSE;
        }
    }

    FLOAT fX =  g_pShip->vPos.x;
    FLOAT fZ = -g_pShip->vPos.z;
    FLOAT fY = 0.1f + HeightField( fX, fZ );

    // View mode 0 (third person)
    vEyePt[0]      = D3DXVECTOR3( fX-sinf(g_pShip->fAngle)/2, fY+0.2f, fZ-cosf(g_pShip->fAngle)/2 );
    vLookatPt[0]   = D3DXVECTOR3( fX+sinf(g_pShip->fAngle)/2, fY, fZ+cosf(g_pShip->fAngle)/2 );
    vUpVec[0]      = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    // View mode 1 (first person)
    FLOAT fX2 = fX+sinf(g_pShip->fAngle);
    FLOAT fZ2 = fZ+cosf(g_pShip->fAngle);
    FLOAT fY2 = 0.1f + HeightField( fX2, fZ2 );
    vEyePt[1]    = D3DXVECTOR3( fX, fY+0.1f, fZ );
    vLookatPt[1] = D3DXVECTOR3( fX2, fY2+0.1f, fZ2 );
    vUpVec[1]    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    // View mode 2 (top down view)
    vEyePt[2]    = D3DXVECTOR3( fX+1.5f, fY+1.5f, fZ+1.5f );
    vLookatPt[2] = D3DXVECTOR3( fX, fY, fZ );
    vUpVec[2]    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    DWORD start = g_dwViewMode;
    DWORD end   = ( start < (NUMVIEWMODES-1) ) ? g_dwViewMode+1: 0;

    if( start == 1 && g_fViewTransition<0.2f)
        g_bFirstPersonView = TRUE;
    else
        g_bFirstPersonView = FALSE;

    D3DXVECTOR3 vEyePt0    = (1.0f-g_fViewTransition)*vEyePt[start]    + g_fViewTransition*vEyePt[end];
    D3DXVECTOR3 vLookatPt0 = (1.0f-g_fViewTransition)*vLookatPt[start] + g_fViewTransition*vLookatPt[end];
    D3DXVECTOR3 vUpVec0    = (1.0f-g_fViewTransition)*vUpVec[start]    + g_fViewTransition*vUpVec[end];

    // Shake screen if ship exploded
    if( g_pShip->bExploded == TRUE )
        vEyePt0 += D3DXVECTOR3( rnd(), rnd(), rnd() ) * g_pShip->fShowDelay / 50.0f;

    g_Camera.SetViewParams( vEyePt0, vLookatPt0, vUpVec0 );
}




//-----------------------------------------------------------------------------
// Name: CheckForHits()
// Desc:
//-----------------------------------------------------------------------------
VOID CheckForHits()
{
    DisplayObject* pObject;
    DisplayObject* pBullet;

    for( pBullet = g_pDisplayList; pBullet; pBullet = pBullet->pNext )
    {
        BOOL bBulletHit = FALSE;

        // Only bullet objects and the ship (if shieleds are on) can hit
        // other objects. Skip all others.
        if( (pBullet->dwType != OBJ_BULLET) && (pBullet->dwType != OBJ_SHIP) )
            continue;

        for( pObject = g_pDisplayList->pNext; pObject; pObject = pObject->pNext )
        {
            // Only trying to hit explodable targets
            if( ( pObject->dwType != OBJ_DONUT ) &&
                ( pObject->dwType != OBJ_PYRAMID ) &&
                ( pObject->dwType != OBJ_SPHERE ) &&
                ( pObject->dwType != OBJ_CUBE ) )
                continue;

            // Check if bullet is in radius of object
            FLOAT fDistance = D3DXVec3Length( &(pBullet->vPos - pObject->vPos) );

            if( fDistance < (pObject->fSize+pBullet->fSize) )
            {
                // The object was hit
                switch( pObject->dwType )
                {
                    case OBJ_DONUT:
#ifdef SOUND_ACTUALLY_WORKS
                        g_DonutExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS
                        AddToList( new CPyramid( pObject->vPos, pObject->vVel ) );
                        AddToList( new CPyramid( pObject->vPos, pObject->vVel ) );
                        AddToList( new CPyramid( pObject->vPos, pObject->vVel ) );
                        AddToList( new CPyramid( pObject->vPos, pObject->vVel ) );
                        g_dwScore += 10;
                        break;

                    case OBJ_PYRAMID:
#ifdef SOUND_ACTUALLY_WORKS
                        g_PyramidExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS
                        AddToList( new CCube( pObject->vPos, pObject->vVel ) );
                        AddToList( new CCube( pObject->vPos, pObject->vVel ) );
                        AddToList( new CCube( pObject->vPos, pObject->vVel ) );
                        AddToList( new CCube( pObject->vPos, pObject->vVel ) );
                        g_dwScore += 20;
                        break;

                    case OBJ_CUBE:
#ifdef SOUND_ACTUALLY_WORKS
                        g_CubeExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS
                        AddToList( new CSphere( pObject->vPos, pObject->vVel ) );
                        g_dwScore += 40;
                        break;

                    case OBJ_SPHERE:
#ifdef SOUND_ACTUALLY_WORKS
                        g_SphereExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS
                        g_dwScore += 20;
                        break;
                }

                // Add explosion effects to scene
                for( DWORD c=0; c<4; c++ )
                    AddToList( new CCloud( pObject->vPos, 0.05f*D3DXVECTOR3(rnd(),0.0f,rnd()) ) );

                // Remove the victim from the scene
                DisplayObject* pVictim = pObject;
                pObject = pObject->pPrev;
                DeleteFromList( pVictim );

                bBulletHit = TRUE;
            }

            if( bBulletHit )
            {
                if( pBullet->dwType == OBJ_SHIP )
                {
                    bBulletHit = FALSE;

                    if( g_pShip->bVisible )
                    {
                        // Ship has exploded
#ifdef SOUND_ACTUALLY_WORKS
                        g_ShipExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS

                        if( g_dwScore < 150 )
                            g_dwScore = 0;
                        else
                            g_dwScore -= 150;

                        // Add explosion debris to scene
                        for( DWORD sphere=0; sphere<4; sphere++ )
                            AddToList( new CSphere( g_pShip->vPos, pObject->vVel ) );

                        for( DWORD bullet=0; bullet<20; bullet++ )
                        {
                            FLOAT     angle     = D3DX_PI * rnd();
                            D3DVECTOR vDir      = D3DXVECTOR3(cosf(angle),0.0f,sinf(angle));
                            AddToList( new CBullet( g_pShip->vPos, 500.0f*vDir, 0 ) );
                        }

                        for( DWORD cloud=0; cloud<100; cloud++ )
                        {
                            FLOAT     magnitude = 1.0f + 0.1f*rnd();
                            FLOAT     angle     = D3DX_PI * rnd();
                            D3DVECTOR vDir      = D3DXVECTOR3(cosf(angle),0.0f,sinf(angle));

                            AddToList( new CCloud( g_pShip->vPos, magnitude*vDir ) );
                        }

                        // Clear out ship params
                        g_pShip->vVel.x   = 0.0f;
                        g_pShip->vVel.z   = 0.0f;
                        g_fThrust         = 0.0f;
                        g_fBank           = 0.0f;
                        g_bFiringWeapons  = FALSE;

                        // Delay for 2 seconds before displaying ship
                        g_pShip->fShowDelay = 2.0f;
                        g_pShip->bVisible   = FALSE;
                        g_pShip->bExploded  = TRUE;
                    }
                }

                break;
            }
        }

        if( bBulletHit )
        {
            DisplayObject* pLastBullet = pBullet;
            pBullet = pBullet->pPrev;
            DeleteFromList( pLastBullet );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: DrawDisplayList()
// Desc:
//-----------------------------------------------------------------------------
VOID DrawDisplayList()
{
    WCHAR strBuffer[80];

    // Set the world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set the app view matrix for normal viewing
    g_pd3dDevice->SetTransform( D3DTS_VIEW, &g_Camera.GetViewMatrix() );

    // Set up the default state
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );

    // Render the Skybox
    {
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
        g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
        g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
        
        // Center view matrix for skybox
        D3DXMATRIX matView, matViewSave;
        g_pd3dDevice->GetTransform( D3DTS_VIEW,      &matViewSave );
        matView = matViewSave;
        matView._41 = 0.0f; matView._42 = -0.0f; matView._43 = 0.0f;
        g_pd3dDevice->SetTransform( D3DTS_VIEW,      &matView );

        // Render the skybox
        g_SkyBoxObject.Render( g_pd3dDevice );

        // Restore the render states
        g_pd3dDevice->SetTransform( D3DTS_VIEW,      &matViewSave );
    }

    // Set default state
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x33333333 );

    // Begin the scene
    {
        // Draw the terrain
        g_pTerrain->Render( g_pd3dDevice );

        // Render the ship
        if( g_pShip->bVisible && g_bFirstPersonView == FALSE )
        {
            // Point of ship, on terrain
            D3DXVECTOR3 vShipPt;
            vShipPt.x =  g_pShip->vPos.x;
            vShipPt.z = -g_pShip->vPos.z;
            vShipPt.y = 0.1f + HeightField( vShipPt.x, vShipPt.z );

            // Point ahead of ship, on terrain
            D3DXVECTOR3 vForwardPt;
            vForwardPt.x = vShipPt.x+sinf(g_pShip->fAngle);
            vForwardPt.z = vShipPt.z+cosf(g_pShip->fAngle);
            vForwardPt.y = 0.1f + HeightField( vForwardPt.x, vForwardPt.z );

            // Point to side of ship, on terrain
            D3DXVECTOR3 vSidePt;
            vSidePt.x = vShipPt.x+sinf(g_pShip->fAngle + D3DX_PI/2.0f);
            vSidePt.z = vShipPt.z+cosf(g_pShip->fAngle + D3DX_PI/2.0f);
            vSidePt.y = 0.1f + HeightField( vSidePt.x, vSidePt.z );

            // Compute vectors of the ship's orientation
            D3DXVECTOR3 vForwardDir = vForwardPt - vShipPt;
            D3DXVECTOR3 vSideDir    = vSidePt - vShipPt;
            D3DXVECTOR3 vNormalDir;
            D3DXVec3Cross( &vNormalDir, &vForwardDir, &vSideDir );

            // Construct matrix to orient ship
            D3DXMATRIX matWorld, matLookAt, matRotateZ;
            D3DXMatrixRotationZ( &matRotateZ, g_pShip->fRoll );
            D3DXMatrixLookAtLH( &matLookAt, &vShipPt, &(vShipPt-vForwardDir), &vNormalDir );
            D3DXMatrixInverse( &matLookAt, NULL, &matLookAt );
            D3DXMatrixIdentity( &matWorld );
            D3DXMatrixMultiply( &matWorld, &matWorld, &matRotateZ );
            D3DXMatrixMultiply( &matWorld, &matWorld, &matLookAt );

            // Set renderstates for rendering the ship
            g_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
            g_pd3dDevice->SetRenderState( D3DRS_LIGHTING,           TRUE );
            g_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS,   TRUE );
            g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   FALSE );
            g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,    FALSE );

            // Render the ship - opaque parts
            g_pShipFileObject->Render( g_pd3dDevice, XBMESH_OPAQUEONLY );

            // Render the ship - transparent parts
            g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,   TRUE );
            g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
            g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,     D3DBLEND_ONE );
            g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,    D3DBLEND_ONE );
            g_pShipFileObject->Render( g_pd3dDevice, XBMESH_ALPHAONLY );
            g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
        }

        // Remaining objects don't need lighting
        g_pd3dDevice->SetRenderState( D3DRS_LIGHTING,           FALSE );

        // Enable alpha blending and testing
        g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
        g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATEREQUAL );

        // Display all visible objects in the display list
        for( DisplayObject* pObject = g_pDisplayList; pObject; pObject = pObject->pNext )
        {
            if( !pObject->bVisible )
                continue;
            if( pObject->dwType == OBJ_SHIP )
                continue;
            if( pObject->dwType == OBJ_BULLET )
                continue;

            // This is really a 3D sprite
            C3DSprite* pSprite = (C3DSprite*)pObject;

            FLOAT fX =  pObject->vPos.x;
            FLOAT fZ = -pObject->vPos.z;
            FLOAT fY =  HeightField( fX, fZ );

            FLOAT x1 = -pObject->fSize;
            FLOAT x2 =  pObject->fSize;
            FLOAT y1 = -pObject->fSize;
            FLOAT y2 =  pObject->fSize;

            FLOAT u1 = (FLOAT)(pSprite->dwTextureOffsetX + pSprite->dwTextureWidth *(((int)pSprite->frame)%pSprite->dwFramesPerLine));
            FLOAT v1 = (FLOAT)(pSprite->dwTextureOffsetY + pSprite->dwTextureHeight*(((int)pSprite->frame)/pSprite->dwFramesPerLine));

            FLOAT tu1 = u1 / (256.0f-1.0f);
            FLOAT tv1 = v1 / (256.0f-1.0f);
            FLOAT tu2 = (u1 + pSprite->dwTextureWidth -1) / (256.0f-1.0f);
            FLOAT tv2 = (v1 + pSprite->dwTextureHeight-1) / (256.0f-1.0f);

            // Set the game texture
            switch( pObject->dwType )
            {
                case OBJ_DONUT:
                case OBJ_CUBE:
                case OBJ_SPHERE:
                    g_pd3dDevice->SetTexture( 0, g_pGameTexture1 );
                    break;
                case OBJ_PYRAMID:
                case OBJ_CLOUD:
                    g_pd3dDevice->SetTexture( 0, g_pGameTexture2 );
                    break;
            }

            // Translate the billboard into place
            D3DXMATRIX mat = g_Camera.GetBillboardMatrix();
            mat._41 = fX;
            mat._42 = fY;
            mat._43 = fZ;
            g_pd3dDevice->SetTransform( D3DTS_WORLD, &mat );

            DWORD dwColor = pSprite->dwColor;

            g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
            g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
            g_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
            g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );

            if( pObject->dwType == OBJ_CLOUD )
            {
                DWORD red = 255-(int)(pSprite->frame*255.0f);
                DWORD grn = 255-(int)(pSprite->frame*511.0f);
                DWORD blu = 255-(int)(pSprite->frame*1023.0f);
                if( grn > 255 ) grn = 0;
                if( blu > 255 ) blu = 0;
                dwColor = 0xff000000 + (red<<16) + (grn<<8) + blu;

                g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_ONE );
                g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
                g_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
                g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
            }

            FLOAT h = 300.0f*pObject->vPos.y + 0.1f;

            SPRITEVERTEX* v;
            g_pSpriteVB->Lock( 0, 0, (BYTE**)&v, 0 );
            v[0].p = D3DXVECTOR3(x1,y1+h,0); v[0].color=dwColor; v[0].tu=tu1; v[0].tv=tv2;
            v[1].p = D3DXVECTOR3(x1,y2+h,0); v[1].color=dwColor; v[1].tu=tu1; v[1].tv=tv1;
            v[2].p = D3DXVECTOR3(x2,y1+h,0); v[2].color=dwColor; v[2].tu=tu2; v[2].tv=tv2;
            v[3].p = D3DXVECTOR3(x2,y2+h,0); v[3].color=dwColor; v[3].tu=tu2; v[3].tv=tv1;
            g_pSpriteVB->Unlock();

            // Render the billboarded sprite
            g_pd3dDevice->SetVertexShader( D3DFVF_SPRITEVERTEX );
            g_pd3dDevice->SetStreamSource( 0, g_pSpriteVB, sizeof(SPRITEVERTEX) );
            g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
        }

        // Display all bullets
        for( pObject = g_pDisplayList; pObject; pObject = pObject->pNext )
        {
            if( pObject->dwType != OBJ_BULLET )
                continue;

            // This is really a 3D sprite
            C3DSprite* pSprite = (C3DSprite*)pObject;

            FLOAT u1 = (FLOAT)(pSprite->dwTextureOffsetX + pSprite->dwTextureWidth *(((int)pSprite->frame)%pSprite->dwFramesPerLine));
            FLOAT v1 = (FLOAT)(pSprite->dwTextureOffsetY + pSprite->dwTextureHeight*(((int)pSprite->frame)/pSprite->dwFramesPerLine));
            u1 = (FLOAT)(pSprite->dwTextureOffsetX);
            v1 = (FLOAT)(pSprite->dwTextureOffsetY);

            FLOAT tu1 = u1 / (256.0f-1.0f);
            FLOAT tv1 = v1 / (256.0f-1.0f);
            FLOAT tu2 = (u1 + pSprite->dwTextureWidth -1) / (256.0f-1.0f);
            FLOAT tv2 = (v1 + pSprite->dwTextureHeight-1) / (256.0f-1.0f);

            // Set render states
            g_pd3dDevice->SetTexture( 0, g_pGameTexture2 );
            g_pd3dDevice->SetVertexShader( D3DFVF_SPRITEVERTEX );
            g_pd3dDevice->SetStreamSource( 0, g_pSpriteVB, sizeof(SPRITEVERTEX) );
            g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,     D3DBLEND_ONE );
            g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,    D3DBLEND_ONE );
            g_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
            g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );

            FLOAT x1 = -0.01f;
            FLOAT x2 =  0.01f;
            FLOAT y1 = -0.01f;
            FLOAT y2 =  0.01f;

            DWORD dwColor = pSprite->dwColor;

            for( DWORD a=0; a<6; a++ )
            {
                FLOAT fX =  pObject->vPos.x - a*a*0.0005f*pObject->vVel.x;
                FLOAT fZ = -pObject->vPos.z + a*a*0.0005f*pObject->vVel.z;
                FLOAT fY =  HeightField( fX, fZ );

                // Translate the billboard into place
                D3DXMATRIX mat = g_Camera.GetBillboardMatrix();
                mat._41 = fX;
                mat._42 = fY;
                mat._43 = fZ;
                g_pd3dDevice->SetTransform( D3DTS_WORLD, &mat );

                FLOAT h = 300.0f*pObject->vPos.y + 0.1f;

                SPRITEVERTEX* v;
                g_pSpriteVB->Lock( 0, 0, (BYTE**)&v, 0 );
                v[0].p = D3DXVECTOR3(x1,y1+h,0); v[0].color=dwColor; v[0].tu=tu1; v[0].tv=tv2;
                v[1].p = D3DXVECTOR3(x1,y2+h,0); v[1].color=dwColor; v[1].tu=tu1; v[1].tv=tv1;
                v[2].p = D3DXVECTOR3(x2,y1+h,0); v[2].color=dwColor; v[2].tu=tu2; v[2].tv=tv2;
                v[3].p = D3DXVECTOR3(x2,y2+h,0); v[3].color=dwColor; v[3].tu=tu2; v[3].tv=tv1;
                g_pSpriteVB->Unlock();

                // Render the billboarded sprite
                g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
            }
        }

        // Restore state
        g_pd3dDevice->SetRenderState( D3DRS_ZENABLE,      TRUE );
        g_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );

        // Display score
        swprintf( strBuffer, L"Score: %08ld", g_dwScore );
        g_GameFont.DrawText( 64.0f, 50.0f, 0xffffff00, strBuffer );

        // Display ship type
        swprintf( strBuffer, L"Ship: %s", g_strShipNames[g_dwCurrentShipType] );
        g_GameFont.DrawText( 64.0f, 75.0f, 0xffffff00, strBuffer );

        // Display weapon type
        WCHAR* strWeapon;
        if( g_dwBulletType == 0 )      strWeapon = L"Weapon: Blaster";
        else if( g_dwBulletType == 1 ) strWeapon = L"Weapon: Double blaster";
        else if( g_dwBulletType == 2 ) strWeapon = L"Weapon: Spray gun";
        else                           strWeapon = L"Weapon: Proximity killer";
        g_GameFont.DrawText( 64.0f, 100.0f, 0xffffff00, strWeapon );

        // Render "Paused" text if game is paused
        if( g_bPaused )
        {
            DarkenScene( 0.5f );
            RenderFieryEffect( g_pPausedTexture, 2.0f );
        }

        if( g_pShip->fShowDelay > 0.0f )
            DarkenScene( g_pShip->fShowDelay/2.0f );

        // Render game menu
        if( g_pCurrentMenu )
        {
            DarkenScene( 0.5f );
            g_pCurrentMenu->Render( g_pd3dDevice );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: DeleteFromList()
// Desc:
//-----------------------------------------------------------------------------
VOID DeleteFromList( DisplayObject* pObject )
{
    if( pObject->pNext )
        pObject->pNext->pPrev = pObject->pPrev;
    if( pObject->pPrev )
        pObject->pPrev->pNext = pObject->pNext;
    delete( pObject );
}



//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
VOID ConstructMenus()
{
    // Build video sub menu
    CMenuItem* pVideoSubMenu = new CMenuItem( g_MenuFont.CreateTexture( L"Video Menu" ), MENU_VIDEO );
    pVideoSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Windowed" ), MENU_WINDOWED ) );
    pVideoSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"640x480" ),  MENU_640x480 ) );
    pVideoSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"800x600" ),  MENU_800x600 ) );
    pVideoSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"1024x768" ), MENU_1024x768 ) );
    pVideoSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Back" ),     MENU_BACK ) );

    // Build sound menu
    CMenuItem* pSoundSubMenu = new CMenuItem( g_MenuFont.CreateTexture( L"Sound Menu" ), MENU_SOUND );
    pSoundSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Sound On" ),  MENU_SOUNDON ) );
    pSoundSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Sound Off" ), MENU_SOUNDOFF ) );
    pSoundSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Back" ),      MENU_BACK ) );

    // Build input menu
    CMenuItem* pInputSubMenu = new CMenuItem( g_MenuFont.CreateTexture( L"Input Menu" ), MENU_INPUT );
    pInputSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"View Devices" ),   MENU_VIEWDEVICES ) );
    pInputSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Config Devices" ), MENU_CONFIGDEVICES ) );
    pInputSubMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Back" ),           MENU_BACK ) );

    // Build main menu
    g_pMainMenu = new CMenuItem( g_MenuFont.CreateTexture( L"Main Menu" ),  MENU_MAIN );
    g_pMainMenu->Add( pVideoSubMenu );
    g_pMainMenu->Add( pSoundSubMenu );
    g_pMainMenu->Add( pInputSubMenu );
    g_pMainMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Back to Game" ), MENU_BACK ) );

    // Build "quit game?" menu
    g_pQuitMenu = new CMenuItem( g_MenuFont.CreateTexture( L"Quit Game?" ), MENU_MAIN );
    g_pQuitMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"Yes" ), MENU_QUIT ) );
    g_pQuitMenu->Add( new CMenuItem( g_MenuFont.CreateTexture( L"No" ),  MENU_BACK ) );

    return;
}




//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
VOID DestroyMenus()
{
    SAFE_DELETE( g_pQuitMenu );
    SAFE_DELETE( g_pMainMenu );
}




//-----------------------------------------------------------------------------
// Name: UpdateMenus()
// Desc:
//-----------------------------------------------------------------------------
VOID UpdateMenus()
{
    if( g_pCurrentMenu == NULL )
        return;

    // Check for menu up/down input
    if( g_bMenuUp )
    {
        if( g_pCurrentMenu->GetSelectedMenu() > 0 )
        {
            g_pCurrentMenu->SetSelectedMenu( g_pCurrentMenu->GetSelectedMenu() - 1 );
#ifdef SOUND_ACTUALLY_WORKS
            g_SphereExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS
        }
    }
    else if( g_bMenuDown )
    {
        if( g_pCurrentMenu->GetSelectedMenu() + 1 < g_pCurrentMenu->GetNumChildren()  )
        {
            g_pCurrentMenu->SetSelectedMenu( g_pCurrentMenu->GetSelectedMenu() + 1 );
#ifdef SOUND_ACTUALLY_WORKS
            g_SphereExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS
        }
    }

    if( g_bMenuSelect )
    {
#ifdef SOUND_ACTUALLY_WORKS
        g_SphereExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS

        DWORD dwID = g_pCurrentMenu->GetSelectedChild()->GetID();

        switch( dwID )
        {
            case MENU_BACK:
                g_pCurrentMenu = g_pCurrentMenu->GetParent();
                break;

            case MENU_VIDEO:
            case MENU_SOUND:
            case MENU_INPUT:
                g_pCurrentMenu = g_pCurrentMenu->GetSelectedChild();
                break;

            case MENU_WINDOWED:
                g_pCurrentMenu = NULL;
                break;

            case MENU_640x480:
                g_pCurrentMenu = NULL;
                break;

            case MENU_800x600:
                g_pCurrentMenu = NULL;
                break;

            case MENU_1024x768:
                g_pCurrentMenu = NULL;
                break;

            case MENU_SOUNDON:
                g_pCurrentMenu = NULL;
                break;

            case MENU_SOUNDOFF:
                g_pCurrentMenu = NULL;
                break;

            case MENU_QUIT:
                XLaunchNewImage( NULL, NULL );
                g_pCurrentMenu = NULL;
                break;
        }
    }

    // Clear menu inputs
    g_bMenuUp     = FALSE;
    g_bMenuDown   = FALSE;
    g_bMenuSelect = FALSE;
}




//-----------------------------------------------------------------------------
// Name: CreateDisplayObjects()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CreateDisplayObjects()
{
    HRESULT hr;

    // Create the resources
    if( FAILED( g_xprResource.Create( g_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the game and menu fonts
    if( FAILED( hr = g_GameFont.Create( g_pd3dDevice, "FontTahoma.xpr" ) ) )
        return hr;

    if( FAILED( hr = g_MenuFont.Create( g_pd3dDevice, "FontImpact.xpr" ) ) )
        return hr;

    // Load the game textures
	g_pGameTexture1 = g_xprResource.GetTexture( "Donuts1.tga" );
	g_pGameTexture2 = g_xprResource.GetTexture( "Donuts2.tga" );

    // Load the geometry models
    if( FAILED( hr = LoadShipModel() ) )
        return hr;
    if( FAILED( hr = LoadTerrainModel() ) )
        return hr;

    // Create a viewport covering sqaure
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 4*sizeof(SCREENVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_SCREENVERTEX,
                                                  D3DPOOL_MANAGED, &g_pViewportVB ) ) )
        return E_FAIL;

    // Create a sqaure for rendering the sprites
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 4*sizeof(SPRITEVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_SPRITEVERTEX,
                                                  D3DPOOL_MANAGED, &g_pSpriteVB ) ) )
        return E_FAIL;

    // Setup dimensions for the viewport covering sqaure
    SCREENVERTEX* v;
    g_pViewportVB->Lock( 0, 0, (BYTE**)&v, 0 );
    v[0].p = D3DXVECTOR4(   0 - 0.5f, 480 - 0.5f, 0.0f, 1.0f );
    v[1].p = D3DXVECTOR4(   0 - 0.5f,   0 - 0.5f, 0.0f, 1.0f );
    v[2].p = D3DXVECTOR4( 640 - 0.5f, 480 - 0.5f, 0.0f, 1.0f );
    v[3].p = D3DXVECTOR4( 640 - 0.5f,   0 - 0.5f, 0.0f, 1.0f );
    g_pViewportVB->Unlock();

    // Load the skybox
    if( FAILED( g_SkyBoxObject.Create( g_pd3dDevice, "Models\\SkyBox.xbg", &g_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Set up the camera
    g_Camera.SetViewParams( D3DXVECTOR3(0.0f,0.0f,0.0f), D3DXVECTOR3(0.0f,0.0f,1.0f),
                            D3DXVECTOR3(0.0f,1.0f,0.0f) );
    g_Camera.SetProjParams( D3DX_PI/4, 1.0f, 0.1f, 100.0f );

    // Set up default matrices (using the CD3DCamera class)
    g_pd3dDevice->SetTransform( D3DTS_VIEW,       &g_Camera.GetViewMatrix() );
    g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &g_Camera.GetProjMatrix() );

    // Setup a material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f );
    g_pd3dDevice->SetMaterial( &mtrl );

    // Set up lighting states
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 1.0f, -1.0f, 1.0f );
    g_pd3dDevice->SetLight( 0, &light );
    g_pd3dDevice->LightEnable( 0, TRUE );

    g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0x33333333 );

    // Set miscellaneous render states
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );

    // The display is now ready
    g_bDisplayReady = TRUE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DestroyDisplayObjects()
// Desc:
//-----------------------------------------------------------------------------
HRESULT DestroyDisplayObjects()
{
    DisplayObject* pDO;
    while( g_pDisplayList != NULL )
    {
        pDO = g_pDisplayList;
        g_pDisplayList = g_pDisplayList->pNext;
        delete pDO;
        if( g_pDisplayList != NULL)
            g_pDisplayList->pPrev = NULL;
    }
    
    if( g_pShipFileObject != NULL )
        delete g_pShipFileObject;
    if( g_pTerrain != NULL )
        delete g_pTerrain;

    SAFE_DELETE( g_pTerrain );
    SAFE_DELETE( g_pShipFileObject );

    SAFE_RELEASE( g_pViewportVB );
    SAFE_RELEASE( g_pSpriteVB );
    SAFE_RELEASE( g_pd3dDevice );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Sound support code (using DMusic functionality from DMUtil.h)
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// Name: CreateSoundObjects()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CreateSoundObjects()
{
#ifdef SOUND_ACTUALLY_WORKS
    // Create the sounds
    g_BeginLevelSound.Create( "Sounds\\BEGINLEVEL.wav", DSBCAPS_CTRL3D );
    g_EngineIdleSound.Create( "Sounds\\ENGINEIDLE.wav", DSBCAPS_CTRL3D );
    g_EngineRevSound.Create( "Sounds\\ENGINEREV.wav", DSBCAPS_CTRL3D );
    g_ShieldBuzzSound.Create( "Sounds\\SHIELDBUZZ.wav", DSBCAPS_CTRL3D );
    g_ShipExplodeSound.Create( "Sounds\\SHIPEXPLODE.wav", DSBCAPS_CTRL3D );
    g_FireBulletSound.Create( "Sounds\\GUNFIRE.wav", DSBCAPS_CTRL3D );
    g_ShipBounceSound.Create( "Sounds\\SHIPBOUNCE.wav", DSBCAPS_CTRL3D );
    g_DonutExplodeSound.Create( "Sounds\\DONUTEXPLODE.wav", DSBCAPS_CTRL3D );
    g_PyramidExplodeSound.Create( "Sounds\\PYRAMIDEXPLODE.wav", DSBCAPS_CTRL3D );
    g_CubeExplodeSound.Create( "Sounds\\CUBEEXPLODE.wav", DSBCAPS_CTRL3D );
    g_SphereExplodeSound.Create( "Sounds\\SPHEREEXPLODE.wav", DSBCAPS_CTRL3D );
#endif // SOUND_ACTUALLY_WORKS

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DestroySoundObjects()
// Desc:
//-----------------------------------------------------------------------------
VOID DestroySoundObjects()
{
#ifdef SOUND_ACTUALLY_WORKS
    g_BeginLevelSound.Destroy();
    g_EngineIdleSound.Destroy();
    g_EngineRevSound.Destroy();
    g_ShieldBuzzSound.Destroy();
    g_ShipExplodeSound.Destroy();
    g_FireBulletSound.Destroy();
    g_ShipBounceSound.Destroy();
    g_DonutExplodeSound.Destroy();
    g_PyramidExplodeSound.Destroy();
    g_CubeExplodeSound.Destroy();
    g_SphereExplodeSound.Destroy();
#endif // SOUND_ACTUALLY_WORKS
}




//-----------------------------------------------------------------------------
// Name: GetInput()
// Desc: Processes data from the input device.  Uses GetDeviceState().
//-----------------------------------------------------------------------------
VOID GetInput()
{
    static FLOAT fLeftThrust    = 0.0f;
    static FLOAT fRightThrust   = 0.0f;
    static FLOAT fForwardThrust = 0.0f;
    static FLOAT fReverseThrust = 0.0f;

    if( g_pCurrentMenu )
    {
        g_bMenuLeft   = ( 0 != ( g_Gamepads[0].wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT ) );
        g_bMenuRight  = ( 0 != ( g_Gamepads[0].wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT ) );
        g_bMenuUp     = ( 0 != ( g_Gamepads[0].wPressedButtons & XINPUT_GAMEPAD_DPAD_UP ) );
        g_bMenuDown   = ( 0 != ( g_Gamepads[0].wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN ) );
        g_bMenuSelect = ( 0 != ( g_Gamepads[0].wPressedButtons & XINPUT_GAMEPAD_START ) );

        // End menu
        if( g_Gamepads[0].wPressedButtons & XINPUT_GAMEPAD_BACK )
        {
#ifdef SOUND_ACTUALLY_WORKS
            g_SphereExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS
            g_pCurrentMenu = NULL;
        }
    }
    else
    {
        if( g_pShip->bVisible  )
        {
            g_fBank          = g_Gamepads[0].fX1;
            g_fThrust        = g_Gamepads[0].fY1;
            g_bFiringWeapons = ( g_Gamepads[0].bAnalogButtons[XINPUT_GAMEPAD_A] > 0 );
            g_bChangeView    = ( g_Gamepads[0].bPressedAnalogButtons[XINPUT_GAMEPAD_B] );

            if( g_Gamepads[0].bPressedAnalogButtons[XINPUT_GAMEPAD_X] ) 
            {
                if( ++g_dwBulletType > 3 )
                    g_dwBulletType = 0L;
            }
    
            if( g_Gamepads[0].bPressedAnalogButtons[XINPUT_GAMEPAD_Y] ) 
                SwitchModel();
        }

        // Pause
        if( g_Gamepads[0].wPressedButtons & XINPUT_GAMEPAD_BACK )
            g_bPaused = !g_bPaused;
    
        // Display menu
        if( g_Gamepads[0].wPressedButtons & XINPUT_GAMEPAD_START )
        {
#ifdef SOUND_ACTUALLY_WORKS
            g_SphereExplodeSound.Play();
#endif // SOUND_ACTUALLY_WORKS
            g_pCurrentMenu = g_pMainMenu;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Donuts3D\gamemenu.h ===
//-----------------------------------------------------------------------------
// File: GameMenu.h
//
// Desc: Code for in-game menus
//
// Copyright (C) Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef GAMEMENU_H
#define GAMEMENU_H




//-----------------------------------------------------------------------------
// Name: class CMenuItem
// Desc: Helper class for displaying menus. Each menu has a texture, an ID,
//       and children. An app can build menus with the constructor and the 
//       Add() function, and display the menu on top of a 3D scene with the
//       Render() function.
//-----------------------------------------------------------------------------
class CMenuItem
{
	LPDIRECT3DTEXTURE8 m_pTexture;
	DWORD              m_dwID;

	CMenuItem*         m_pParent;
	CMenuItem*         m_pChild[10];
	DWORD              m_dwNumChildren;
	DWORD              m_dwSelectedMenu;

public:
	
	// Construction / destruction
	CMenuItem( LPDIRECT3DTEXTURE8 pTexture, DWORD dwID );
	~CMenuItem();

	// Hierarchial build functions
	CMenuItem* Add( CMenuItem* );

	// Access functions
	VOID       SetID( DWORD dwID )             { m_dwID = dwID; }
	DWORD      GetID()                         { return m_dwID; }
	CMenuItem* GetParent()                     { return m_pParent; }
	CMenuItem* GetSelectedChild()              { return m_pChild[m_dwSelectedMenu]; }
	DWORD      GetNumChildren()                { return m_dwNumChildren; }
	VOID       SetSelectedMenu( DWORD dwMenu ) { m_dwSelectedMenu = dwMenu; }
	DWORD      GetSelectedMenu()               { return m_dwSelectedMenu; }

	// Render functions
	HRESULT    Render( LPDIRECT3DDEVICE8 pd3dDevice );
	HRESULT    RenderLabel( LPDIRECT3DDEVICE8 pd3dDevice );
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\cubemap\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\cubemap\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\cubemap\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Donuts3D\donuts.h ===
//-----------------------------------------------------------------------------
// File: Donuts.h
//
// Desc: Header for Donuts3D game
//
// Copyright (C) 1995-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

// Error codes
#define DONUTS3DERR_NODIRECT3D       0x00000001
#define DONUTS3DERR_NOD3DDEVICE      0x00000002
#define DONUTS3DERR_NOTEXTURES       0x00000003
#define DONUTS3DERR_NOGEOMETRY       0x00000004
#define DONUTS3DERR_NO3DRESOURCES    0x00000005
#define DONUTS3DERR_NOINPUT          0x00000006


// States the app can be in
enum{ APPSTATE_LOADSPLASH, APPSTATE_DISPLAYSPLASH, APPSTATE_ACTIVE, 
      APPSTATE_BEGINLEVELSCREEN, APPSTATE_DISPLAYLEVELSCREEN };


// Game object types
enum{ OBJ_DONUT=0, OBJ_PYRAMID, OBJ_CUBE, OBJ_SPHERE, OBJ_CLOUD, OBJ_SHIP,
      OBJ_BULLET };


// Object dimensions and fixed properties
#define DONUT_WIDTH        32
#define DONUT_HEIGHT       32
#define PYRAMID_WIDTH      32
#define PYRAMID_HEIGHT     32
#define SPHERE_WIDTH       16
#define SPHERE_HEIGHT      16
#define CUBE_WIDTH         16
#define CUBE_HEIGHT        16
#define CLOUD_WIDTH        32
#define CLOUD_HEIGHT       32
#define BULLET_WIDTH        3
#define BULLET_HEIGHT       3

#define NUM_DONUT_FRAMES   30
#define NUM_PYRAMID_FRAMES 40
#define NUM_SPHERE_FRAMES  40
#define NUM_CUBE_FRAMES    40
#define NUM_BULLET_FRAMES 400

#define BULLET_XOFFSET    304
#define BULLET_YOFFSET      0




//-----------------------------------------------------------------------------
// Name: struct DisplayObject
// Desc: A game object that goes in the display list
//-----------------------------------------------------------------------------
struct DisplayObject
{
    DisplayObject* pNext;          // Link to next object
    DisplayObject* pPrev;          // Link to previous object
    
    DWORD          dwType;            // Type of object
    BOOL           bVisible;          // Whether the object is visible
    D3DXVECTOR3    vPos;              // Position
    D3DXVECTOR3    vVel;              // Velocity
    FLOAT          fSize;
    
    // Constructor
    DisplayObject( DWORD type, D3DVECTOR p, D3DVECTOR v );
};




//-----------------------------------------------------------------------------
// Derived classes for displayable game objects
//-----------------------------------------------------------------------------
struct C3DSprite : public DisplayObject
{
    DWORD dwFramesPerLine;   // How anim frames are packed in bitmap
    FLOAT frame;             // Current animation frame
    FLOAT fMaxFrame;         // Max animation frame value
    FLOAT delay;             // Frame/second
    
    DWORD dwColor;

    DWORD dwTextureOffsetX; // Pixel offsets into the game texture
    DWORD dwTextureOffsetY;
    DWORD dwTextureWidth;   // Width and height in pixels
    DWORD dwTextureHeight; 
    
    C3DSprite( DWORD type, D3DVECTOR p, D3DVECTOR v );
};


class CDonut : public C3DSprite
{
public:
    CDonut( D3DVECTOR p, D3DVECTOR v );
};


class CPyramid : public C3DSprite
{
public:
    CPyramid( D3DVECTOR p, D3DVECTOR v );
};


class CSphere : public C3DSprite
{
public:
    CSphere( D3DVECTOR p, D3DVECTOR v );
};


class CCube : public C3DSprite
{
public:
    CCube( D3DVECTOR p, D3DVECTOR v );
};


class CCloud : public C3DSprite
{
public:
    CCloud( D3DVECTOR p, D3DVECTOR v );
};


class CBullet : public C3DSprite
{
public:
    CBullet( D3DVECTOR p, D3DVECTOR v, DWORD dwType );
};


class CShip : public DisplayObject
{
public:
    FLOAT fRoll;

    FLOAT fAngle;

    BOOL  bExploded;
    FLOAT fShowDelay;

public:
    CShip( D3DVECTOR p );
};




//-----------------------------------------------------------------------------
// Function prototypes
//-----------------------------------------------------------------------------

// Main game functions
HRESULT          CreateGameObjects();
VOID             DestroyGameObjects();

// Sound functions
HRESULT          CreateSoundObjects();
VOID             DestroySoundObjects();

// Input functions
HRESULT          CreateInputObjects();
VOID             DestroyInputObjects();
VOID             GetInput();

// Display functions
HRESULT          CreateDisplayObjects();
HRESULT          RestoreDisplayObjects();
HRESULT          InvalidateDisplayObjects();
HRESULT          DestroyDisplayObjects();

// Menu functions
VOID             ConstructMenus();
VOID             DestroyMenus();
VOID             UpdateMenus();


// Rendering functions
HRESULT          FrameMove();
HRESULT          RenderFrame();
VOID             UpdateDisplayList();
VOID             DrawDisplayList();
VOID             ShowFrame();

// Misc game functions
VOID             DisplayLevelIntroScreen();
VOID             AdvanceLevel();
BOOL             IsDisplayListEmpty();
VOID             AddToList( DisplayObject* pObject );
VOID             DeleteFromList( DisplayObject* pObject );
VOID             CheckForHits();
FLOAT            rnd( FLOAT low=-1.0f, FLOAT high=1.0f );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\cubemap\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\cubemap\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Donuts3D\Donuts3D.cpp ===
//-----------------------------------------------------------------------------
// File: Donuts3D.cpp
//
// Desc: Donuts3D game.
//
// Hist: 02.15.00 - New
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBUtil.h>




//-----------------------------------------------------------------------------
// Game control functions
//-----------------------------------------------------------------------------
HRESULT GameInitialize();
HRESULT GameFrameMove();
HRESULT GameRender();




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Initialize members
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
	HRESULT hr;

    // Initialize the game
    if( FAILED( hr = GameInitialize() ) )
        return hr;

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
	GameFrameMove();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: This function sets up render states, clears the viewport, and renders
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

	GameRender();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\spheremap\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\spheremap\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\spheremap\makefile.inc ===
!include "..\..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\cubemap\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 8UL

#define resource_LobbyXP_OFFSET 0UL
#define resource_LobbyXN_OFFSET 20UL
#define resource_LobbyYP_OFFSET 40UL
#define resource_LobbyYN_OFFSET 60UL
#define resource_LobbyZP_OFFSET 80UL
#define resource_LobbyZN_OFFSET 100UL
#define resource_BiHull_OFFSET 120UL
#define resource_Wings_OFFSET 140UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\cubemap\cubemap.cpp ===
//-----------------------------------------------------------------------------
// File: CubeMap.cpp
//
// Desc: Sample code showing how to do environment cube-mapping.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <XBResource.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "LobbyXP.bmp",    resource_LobbyXP_OFFSET },
    { "LobbyXN.bmp",    resource_LobbyXN_OFFSET },
    { "LobbyYP.bmp",    resource_LobbyYP_OFFSET },
    { "LobbyYN.bmp",    resource_LobbyYN_OFFSET },
    { "LobbyZP.bmp",    resource_LobbyZP_OFFSET },
    { "LobbyZN.bmp",    resource_LobbyZN_OFFSET },
    { "BiHull.bmp",     resource_BiHull_OFFSET },
    { "Wings.bmp",      resource_Wings_OFFSET },
    { NULL, 0 },
};


   

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate around\nteapot" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Rotate scene" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display\nhelp" },
};

#define NUM_HELP_CALLOUTS 4




// CUBEMAP_RESOLUTION indicates how big to make the cubemap texture.
#define CUBEMAP_RESOLUTION 256




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource m_xprResource;      // Packed resources for the app
    CXBFont           m_Font;             // Font class
    CXBHelp           m_Help;             // Help class
    BOOL              m_bDrawHelp;        // Whether to draw help

    CXBMesh           m_ShinyTeapot;      // A teapot (made shiny with the envmap)
    CXBMesh           m_SkyBox;           // A skybox of a lobby
    CXBMesh           m_Object;           // An object to fly around the scene
    D3DXMATRIX        m_matObject;        // Matrix to position object

    LPDIRECT3DCUBETEXTURE8 m_pCubeMap;    // The cubemap, and access to its surfaces
    LPDIRECT3DSURFACE8     m_pCubeMapFaces[6];

    D3DXMATRIX        m_matIdentity;      // Transform matrices
    D3DXMATRIX        m_matView;
    D3DXMATRIX        m_matProj;

protected:
    BOOL              m_bRenderTeapot;    // To toggle the teapot (so it doesn't render
                                          // its own reflection)
    HRESULT RenderSceneIntoCubeMap();     // Functions to render the scene
    HRESULT RenderScene();

public:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp         = FALSE;
    m_pCubeMap          = NULL;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT hr;

    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the file objects
    if( FAILED( m_SkyBox.Create( m_pd3dDevice, "Models\\Lobby.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_ShinyTeapot.Create( m_pd3dDevice, "Models\\Teapot.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_Object.Create( m_pd3dDevice, "Models\\Airplane.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the cubemap, with a format that matches the backbuffer, since
    // we'll be rendering into it
    if( FAILED( hr = m_pd3dDevice->CreateCubeTexture( CUBEMAP_RESOLUTION, 1, 
                                         D3DUSAGE_RENDERTARGET, D3DFMT_X8R8G8B8, 
                                         D3DPOOL_DEFAULT, &m_pCubeMap ) ) )
        return E_FAIL;

    // Get access the the cube map's surfaces (so we can render into them)
    for( DWORD i=0; i<6; i++ )
        m_pCubeMap->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &m_pCubeMapFaces[i] );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x00aaaaaa );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    // Set the transform matrices
    D3DXMatrixIdentity( &m_matIdentity );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 0.5f, 100.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matIdentity );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Setup a material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    // Set up a light
    D3DLIGHT8 light;
    XBUtil_InitLight( light, D3DLIGHT_DIRECTIONAL, 0.0f, 0.0f, 1.0f );
    light.Ambient.r = 0.3f;
    light.Ambient.g = 0.3f;
    light.Ambient.b = 0.3f;
    m_pd3dDevice->SetLight( 0, &light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Animate the object
    D3DXMATRIX  mat1;
    D3DXMatrixScaling( &m_matObject, 0.2f, 0.2f, 0.2f );
    D3DXMatrixTranslation( &mat1, 0.0f, 2.0f, 0.0f );
    D3DXMatrixMultiply( &m_matObject, &m_matObject, &mat1 );
    D3DXMatrixRotationX( &mat1, -2.9f*m_fAppTime );
    D3DXMatrixMultiply( &m_matObject, &m_matObject, &mat1 );
    D3DXMatrixRotationY( &mat1, 1.055f*m_fAppTime );
    D3DXMatrixMultiply( &m_matObject, &m_matObject, &mat1 );

    // Rotate the camera with the gamepad
    static D3DXMATRIX matTrackBall( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    D3DXMATRIX matRotate, matTrans;

    FLOAT fXRotate =  m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate = -m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fZRotate =  m_DefaultGamepad.fX2*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, fXRotate, fYRotate, fZRotate );
    D3DXMatrixMultiply( &matTrackBall, &matTrackBall, &matRotate );

    D3DXMatrixTranslation( &matTrans, 0.0f, 0.0f, 5.0f );
    D3DXMatrixMultiply( &m_matView, &matTrackBall, &matTrans );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Render the scene into the surfaces of the cubemap. Note: don' render the
    // teapot, since it won't reflect into itself
    m_bRenderTeapot = FALSE;
    RenderSceneIntoCubeMap();
    m_bRenderTeapot = TRUE;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderSceneIntoCubeMap()
// Desc: Renders the scene to each of the 6 faces of the cube map
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderSceneIntoCubeMap()
{
    // Save the transforms that will be overwritten
    D3DXMATRIX matViewSave = m_matView;
    D3DXMATRIX matProjSave = m_matProj;

    // Get the current view matrix rotations, to concat it with the view matrix
    // for rendering into the cubemap's surfaces
    D3DXMATRIX matViewDir = m_matView;
    matViewDir._41 = 0.0f; matViewDir._42 = 0.0f; matViewDir._43 = 0.0f;

    // Set the projection matrix for a field of view of 90 degrees
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/2, 1.0f, 0.5f, 100.0f );

    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Render to the six faces of the cube map
    for( DWORD i=0; i<6; i++ )
    {
        // Set the i'th cubemap surface as the rendertarget
        m_pd3dDevice->SetRenderTarget( m_pCubeMapFaces[i], pZBuffer );

        // Set the viewport to be the correct size
        D3DVIEWPORT8 vpCubeMap = { 0, 0, CUBEMAP_RESOLUTION, CUBEMAP_RESOLUTION, 0.0f, 1.0f };
        m_pd3dDevice->SetViewport( &vpCubeMap );

        // Set the view transform for this cubemap surface
        m_matView = XBUtil_GetCubeMapViewMatrix( (D3DCUBEMAP_FACES)i );
        D3DXMatrixMultiply( &m_matView, &matViewDir, &m_matView );

        // Render the scene
        RenderScene();
    }

    // Change the rendertarget back to the main backbuffer
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    pBackBuffer->Release();
    pZBuffer->Release();

    // Restore the viewport to the backbuffer's dimensions
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetViewport( &vpBackBuffer );

    // Restore the modified transforms
    m_matView = matViewSave;
    m_matProj = matProjSave;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderScene()
// Desc: Renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderScene()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 
                         0x00000000, 1.0f, 0L );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,  0x00aaaaaa );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );

    // Render the Skybox
    {
        // Disable zbuffer
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );

        // Center view matrix, and set FOV to 90 degrees
        D3DXMATRIX matView, matProj;
        matView = m_matView; matView._41 = matView._42 = matView._43 = 0.0f;
        D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/2, 1.0f, 0.5f, 10000.0f );
        m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matIdentity );
        m_pd3dDevice->SetTransform( D3DTS_VIEW,       &matView );
        m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

        // Render the skybox
        m_SkyBox.Render( m_pd3dDevice );

        // Restore the render states
        m_pd3dDevice->SetTransform( D3DTS_VIEW,       &m_matView );
        m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  TRUE );
    }

    // Render the Object
    {
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matObject );
        m_Object.Render( m_pd3dDevice );
    }

    // Render the object with the environment-mapped body
    if( m_bRenderTeapot )
    {
        // Turn on texture-coord generation for cubemapping
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT3 );
        m_pd3dDevice->SetTexture( 0, m_pCubeMap );

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );

        // Render the object with the environment-mapped body
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matIdentity );
        m_ShinyTeapot.Render( m_pd3dDevice, XBMESH_NOMATERIALS|XBMESH_NOTEXTURES );

        // Restore the render states
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_PASSTHRU );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, this call renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Render the scene
    RenderScene();

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"CubeMap" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\cubemap\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 8UL

#define resource_LobbyXP_OFFSET 0UL
#define resource_LobbyXN_OFFSET 20UL
#define resource_LobbyYP_OFFSET 40UL
#define resource_LobbyYN_OFFSET 60UL
#define resource_LobbyZP_OFFSET 80UL
#define resource_LobbyZN_OFFSET 100UL
#define resource_BiHull_OFFSET 120UL
#define resource_Wings_OFFSET 140UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Donuts3D\XBCamera.h ===
//-----------------------------------------------------------------------------
// File: XBCamera.h
//
// Desc: Camera class.
//
// Copyright (C) Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBCamera
// Desc:
//-----------------------------------------------------------------------------
class CXBCamera
{
    D3DXVECTOR3 m_vEyePt;       // Attributes for view matrix
    D3DXVECTOR3 m_vLookatPt;
    D3DXVECTOR3 m_vUpVec;
    D3DXVECTOR3 m_vView;
    D3DXVECTOR3 m_vCross;

    FLOAT       m_fFOV;         // Attributes for projection matrix
    FLOAT       m_fAspect;
    FLOAT       m_fNearPlane;
    FLOAT       m_fFarPlane;

    D3DXMATRIX  m_matView;      // Resulting view matrix
    D3DXMATRIX  m_matBillboard; // Special view matrix for billboards
    D3DXMATRIX  m_matProj;      // Resulting projection matrix

public:
    //-------------------------------------------------------------------------
    // Access functions
    //-------------------------------------------------------------------------
    D3DXVECTOR3 GetEyePt()           { return m_vEyePt; }
    D3DXVECTOR3 GetLookatPt()        { return m_vLookatPt; }
    D3DXVECTOR3 GetUpVec()           { return m_vUpVec; }
    D3DXVECTOR3 GetViewDir()         { return m_vView; }
    D3DXVECTOR3 GetCross()           { return m_vCross; }

    D3DXMATRIX  GetViewMatrix()      { return m_matView; }
    D3DXMATRIX  GetBillboardMatrix() { return m_matBillboard; }
    D3DXMATRIX  GetProjMatrix()      { return m_matProj; }

    //-------------------------------------------------------------------------
    // Set attributes for the view matrix
    //-------------------------------------------------------------------------
    VOID SetViewParams( D3DXVECTOR3 &vEyePt, D3DXVECTOR3& vLookatPt,
                        D3DXVECTOR3& vUpVec )
    {
        m_vEyePt    = vEyePt;
        m_vLookatPt = vLookatPt;
        m_vUpVec    = vUpVec;
        D3DXVec3Normalize( &m_vView, &(m_vLookatPt - m_vEyePt) );
        D3DXVec3Cross( &m_vCross, &m_vView, &m_vUpVec );
        D3DXMatrixLookAtLH( &m_matView, &m_vEyePt, &m_vLookatPt, &m_vUpVec );
        D3DXMatrixInverse( &m_matBillboard, NULL, &m_matView );
        m_matBillboard._41 = 0.0f;
        m_matBillboard._42 = 0.0f;
        m_matBillboard._43 = 0.0f;
    }

    //-------------------------------------------------------------------------
    // Set attributes for the projection matrix
    //-------------------------------------------------------------------------
    VOID SetProjParams( FLOAT fFOV, FLOAT fAspect, FLOAT fNearPlane,
                        FLOAT fFarPlane )
    {
        m_fFOV        = fFOV;
        m_fAspect     = fAspect;
        m_fNearPlane  = fNearPlane;
        m_fFarPlane   = fFarPlane;
        D3DXMatrixPerspectiveFovLH( &m_matProj, fFOV, fAspect, fNearPlane, fFarPlane );
    }

    //-------------------------------------------------------------------------
    // Constructor
    //-------------------------------------------------------------------------
    CXBCamera()
    {
        SetViewParams( D3DXVECTOR3(0.0f,0.0f,0.0f), D3DXVECTOR3(0.0f,0.0f,1.0f),
                       D3DXVECTOR3(0.0f,1.0f,0.0f) );
        SetProjParams( D3DX_PI/4, 1.0f, 1.0f, 1000.0f );
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\spheremap\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\spheremap\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\spheremap\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Scene_OFFSET 0UL
#define resource_SphMap1_OFFSET 20UL
#define resource_SphMap2_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 7UL

#define resource_Ground_OFFSET 0UL
#define resource_Exp1_OFFSET 20UL
#define resource_Exp1d_OFFSET 40UL
#define resource_Exp2_OFFSET 60UL
#define resource_Exp2d_OFFSET 80UL
#define resource_Exp3_OFFSET 100UL
#define resource_Exp3d_OFFSET 120UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\spheremap\spheremap.cpp ===
//-----------------------------------------------------------------------------
// File: SphereMap.cpp
//
// Desc: Example code showing how to use sphere-mapping in D3D, using generated 
//       texture coordinates.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>
#include <XBResource.h>
#include <xgraphics.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Scene.bmp",      resource_Scene_OFFSET },
    { "SphMap1.bmp",    resource_SphMap1_OFFSET },
    { "SphMap2.bmp",    resource_SphMap2_OFFSET },
    { NULL, 0 },
};


   

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Rotate\nteapot" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Change\ntransparency" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Change\neffect" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Change\ntexture" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Toggle help" },
};

#define NUM_HELP_CALLOUTS 5




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class. The base class provides just about all the
//       functionality we want, so we're just supplying stubs to interface with
//       the non-C++ functions of the app.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;      // Packed resources for the app
    CXBFont            m_Font;             // Font class
    CXBHelp            m_Help;             // Help class
    BOOL               m_bDrawHelp;        // Whether to draw help

    CXBMesh*           m_pTeapot;
    LPDIRECT3DTEXTURE8 m_pSphereMapTexture;
    BOOL               m_bGlassEffect;

protected:
    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();

public:
    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application constructor. Sets attributes for the app.
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    m_bDrawHelp          = FALSE;
    m_pTeapot            = new CXBMesh();
    m_pSphereMapTexture  = NULL;
    m_bGlassEffect       = FALSE;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: This creates all device-dependant display objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the spheremap texture
    m_pSphereMapTexture = m_xprResource.GetTexture( "SphMap1.bmp" );

    // Load the teapot object
    if( FAILED( m_pTeapot->Create( m_pd3dDevice, "Models\\Teapot.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Misc render states
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,   TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,        0xffffffff );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,       D3DCULL_NONE );

    // Set up world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up view matrix
    D3DXMATRIX  matView;
    D3DXVECTOR3 vEyePt    = D3DXVECTOR3( 0.0f, 0.0f,-5.0f );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set up proj matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 200.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

    // Setup a base material
    D3DMATERIAL8 mtrl;
    XBUtil_InitMaterial( mtrl, 1.0f, 1.0f, 1.0f, 1.0f );
    m_pd3dDevice->SetMaterial( &mtrl );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Select options
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        m_bGlassEffect = !m_bGlassEffect;

    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
    {
        static DWORD dwTexture = 0;
        dwTexture = (dwTexture+1)%3;

        CHAR* strTextures[] = { "SphMap1.bmp", "SphMap2.bmp", "Scene.bmp" };
        m_pSphereMapTexture = m_xprResource.GetTexture( strTextures[dwTexture] );
    }

    // Perform object rotation
    static D3DXMATRIX matWorld( 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 );
    D3DXMATRIX matRotate;
    FLOAT fXRotate = m_DefaultGamepad.fX1*m_fElapsedTime*D3DX_PI*0.5f;
    FLOAT fYRotate = m_DefaultGamepad.fY1*m_fElapsedTime*D3DX_PI*0.5f;
    D3DXMatrixRotationYawPitchRoll( &matRotate, -fXRotate, -fYRotate, 0.0f );
    D3DXMatrixMultiply( &matWorld, &matWorld, &matRotate );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff000000, 0xff0000ff );

    // Set state
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT,          0x00ffffff );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,         TRUE );

    // Adds in the spheremap texture
    m_pd3dDevice->SetTexture( 0, m_pSphereMapTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );

    // Generate spheremap texture coords from the position
    D3DXMATRIX mat;
    mat._11 = 0.5f; mat._12 = 0.0f;
    mat._21 = 0.0f; mat._22 =-0.5f;
    mat._31 = 0.0f; mat._32 = 0.0f;
    mat._41 = 0.5f; mat._42 = 0.5f;
    m_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &mat );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACENORMAL );

    // A glass effect can be achieved by turning on alpha-blending, and
    // rendering both sides of the object
    if( m_bGlassEffect )
    {
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,     D3DBLEND_SRCCOLOR );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,    D3DBLEND_ONE );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,     D3DCULL_NONE );
        m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,     TRUE );

        // Set the transparency
        DWORD a = (DWORD)((m_DefaultGamepad.fY2+1)*127.9f);
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0x01010101 * a );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TFACTOR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    }

    // Finally, draw the teapot
    m_pTeapot->Render( m_pd3dDevice, XBMESH_NOTEXTURES );

    // Restore render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE,     TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_PASSTHRU );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"SphereMap" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\envmapping\spheremap\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Scene_OFFSET 0UL
#define resource_SphMap1_OFFSET 20UL
#define resource_SphMap2_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\xbterrain.h ===
//-----------------------------------------------------------------------------
// File: XBTerrain.h
//
// Desc: Defines the CXBTerrain object, which provides an application-
//       customizable terrain
//
// Hist: 04.03.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBTERRAIN_H
#define XBTERRAIN_H

#include <xtl.h>

typedef FLOAT (__stdcall FNHEIGHTFUNCTION( FLOAT fX, FLOAT fZ ));

typedef struct {
    D3DXVECTOR3 p;
    D3DXVECTOR2 t;
} XBTERRAIN_VERTEX;
#define FVF_XBTERRAIN_VERTEX (D3DFVF_XYZ|D3DFVF_TEX1)

FLOAT WINAPI fDummy( FLOAT fX, FLOAT fZ );

class CXBTerrain
{
public:
    CXBTerrain();
    ~CXBTerrain();

    HRESULT Initialize( LPDIRECT3DDEVICE8 pDevice );
    HRESULT Generate( DWORD dwXSlices, 
                      DWORD dwZSlices,
                      D3DXVECTOR2 vXZMin, 
                      D3DXVECTOR2 vXZMax, 
                      LPDIRECT3DTEXTURE8 pTexture,
                      FNHEIGHTFUNCTION pfnHeight = fDummy,
                      FLOAT fXRepeat = 1.0f,
                      FLOAT fZRepeat = 1.0f );
    HRESULT Render();

private:
    LPDIRECT3DDEVICE8           m_pd3dDevice;
    LPDIRECT3DTEXTURE8          m_pTexture;
    D3DXVECTOR2                 m_vXZMin;
    D3DXVECTOR2                 m_vXZMax;
    FLOAT                       m_fXTextureRepeat;
    FLOAT                       m_fZTextureRepeat;
    FNHEIGHTFUNCTION *          m_pfnHeight;
    DWORD                       m_dwNumIndices;

    LPDIRECT3DVERTEXBUFFER8     m_pvbTerrain;
    WORD *                      m_pibTerrain;
};

#endif // XBTERRAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\xbterrain.cpp ===
//-----------------------------------------------------------------------------
// File: XBTerrain.cpp
//
// Desc: Implements the CXBTerrain object, which provides an application-
//       customizable terrain
//
// Hist: 04.03.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "xbterrain.h"

//-----------------------------------------------------------------------------
// Name: CXBTerrain (constructor)
// Desc: Zeros out our members
//-----------------------------------------------------------------------------
CXBTerrain::CXBTerrain( )
{
    ZeroMemory( this, sizeof( CXBTerrain ) );
}


//-----------------------------------------------------------------------------
// Name: ~CXBTerrain (destructor)
// Desc: Releases resource held/allocated
//-----------------------------------------------------------------------------
CXBTerrain::~CXBTerrain()
{
    m_pd3dDevice->Release();
    m_pTexture->Release();
    if( m_pvbTerrain )
        m_pvbTerrain->Release();
    if( m_pibTerrain )
        delete[] m_pibTerrain;
}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: One-time initialization to set the device
//-----------------------------------------------------------------------------
HRESULT
CXBTerrain::Initialize( LPDIRECT3DDEVICE8 pDevice )
{
    m_pd3dDevice = pDevice;
    m_pd3dDevice->AddRef();

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Generate
// Desc: Sets up the terrain object's state based off the parameters.  Can set
//       # of slices in both X and Z, near X/Z corner, far X/Z corner, texture
//       height field function, and repetitions of the texture
//-----------------------------------------------------------------------------
HRESULT 
CXBTerrain::Generate( DWORD dwXSlices, 
                      DWORD dwZSlices,
                      D3DXVECTOR2 vXZMin, 
                      D3DXVECTOR2 vXZMax, 
                      LPDIRECT3DTEXTURE8 pTexture,
                      FNHEIGHTFUNCTION pfnHeight,
                      FLOAT fXRepeat,
                      FLOAT fZRepeat )
{
    HRESULT hr;
    DWORD dwNumVertices;
    XBTERRAIN_VERTEX * pVertices;
    FLOAT fX, fZ, fY;
    FLOAT fXUnit, fZUnit;
    DWORD x, z;
    D3DXVECTOR2 vWidth = vXZMax - vXZMin;

    //
    // Free up old resources
    //
    if( m_pvbTerrain )
    {
        m_pvbTerrain->Release();
        m_pvbTerrain = NULL;
    }
    if( m_pibTerrain )
    {
        delete[] m_pibTerrain;
        m_pibTerrain = NULL;
    }
    if( m_pTexture )
    {
        m_pTexture->Release();
        m_pTexture = NULL;
    }

    // Calculate how many vertices & indices we need
    dwNumVertices = ( dwXSlices + 1 ) * ( dwZSlices + 1 );
    m_dwNumIndices = 6 * dwXSlices * dwZSlices;

    // Create vertex buffer for terrain
    hr = m_pd3dDevice->CreateVertexBuffer( dwNumVertices * sizeof( XBTERRAIN_VERTEX ),
                                           0,
                                           0,
                                           0,
                                           &m_pvbTerrain );
    if( FAILED( hr ) )
        return hr;

    // Create index buffer for terrain
    m_pibTerrain = new WORD[ m_dwNumIndices ];
    if( m_pibTerrain == NULL )
    {
        m_pvbTerrain->Release();
        m_pvbTerrain = NULL;
        return E_OUTOFMEMORY;
    }

    // Now that our allocations have succeeded, we can get to business
    m_vXZMin            = vXZMin;
    m_vXZMax            = vXZMax;
    m_pfnHeight         = pfnHeight;
    m_fXTextureRepeat   = fXRepeat;
    m_fZTextureRepeat   = fZRepeat;
    m_pTexture          = pTexture;
    m_pTexture->AddRef();    

    // Caculate size of each grid square
    fXUnit = vWidth.x / dwXSlices;
    fZUnit = vWidth.y / dwZSlices;

    //
    // Fill vertex buffer
    //
    m_pvbTerrain->Lock( 0, 0, (BYTE **)&pVertices, NULL );
    for( z = 0; z <= dwZSlices; z++ )
    {
        // Calculate Z of top of terrain grid
        fZ = m_vXZMin.y + z * fZUnit;
        for( x = 0; x <= dwXSlices; x++ )
        {
            // Calculate X of left of terrain grid
            fX = m_vXZMin.x + x * fXUnit;

            // Get height of point
            fY = m_pfnHeight( fX, fZ );

            // Set up position and texture coordinates
            pVertices[ z * ( dwXSlices + 1 ) + x ].p = D3DXVECTOR3( fX, fY, fZ );
            pVertices[ z * ( dwXSlices + 1 ) + x ].t = D3DXVECTOR2( m_fXTextureRepeat * x / dwXSlices, m_fZTextureRepeat * z / dwZSlices );
        }
    }
    m_pvbTerrain->Unlock();

    //
    // Fill index buffer
    //
    for( z = 0; z < dwZSlices; z++ )
    {
        for( x = 0; x < dwXSlices; x++ )
        {
            DWORD dwSquare = z * dwXSlices + x;

            // Bottom Left -> Top Left -> Top Right
            m_pibTerrain[ dwSquare * 6 ]     = WORD( ( z + 1 ) * ( dwXSlices + 1 ) + x );
            m_pibTerrain[ dwSquare * 6 + 1 ] = WORD( z * ( dwXSlices + 1 ) + x );
            m_pibTerrain[ dwSquare * 6 + 2 ] = WORD( z * ( dwXSlices + 1 ) + x + 1 );

            // Bottom Left -> Top Right -> Bottom Right
            m_pibTerrain[ dwSquare * 6 + 3 ] = WORD( ( z + 1 ) * ( dwXSlices + 1 ) + x );
            m_pibTerrain[ dwSquare * 6 + 4 ] = WORD( z * ( dwXSlices + 1 ) + x + 1 );
            m_pibTerrain[ dwSquare * 6 + 5 ] = WORD( ( z + 1) * ( dwXSlices + 1 ) + ( x + 1 ) );
        }
    }

    return S_OK;
}


                      
//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the terrain
//-----------------------------------------------------------------------------
HRESULT 
CXBTerrain::Render()
{
    D3DXMATRIX matWorld, matWorldSave;

    // Save old transform
    m_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSave );

    // Set identity for world transform
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set up to render
    m_pd3dDevice->SetStreamSource( 0, m_pvbTerrain, sizeof( XBTERRAIN_VERTEX ) );
    m_pd3dDevice->SetVertexShader( FVF_XBTERRAIN_VERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Render
    m_pd3dDevice->DrawIndexedVertices( D3DPT_TRIANGLELIST, m_dwNumIndices, m_pibTerrain );

    // Restore old state
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSave );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: fDummy
// Desc: Dummy height-field function for flat terrain
//-----------------------------------------------------------------------------
FLOAT WINAPI fDummy( FLOAT fX, FLOAT fZ )
{
    return 0.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 7UL

#define resource_Ground_OFFSET 0UL
#define resource_Exp1_OFFSET 20UL
#define resource_Exp1d_OFFSET 40UL
#define resource_Exp2_OFFSET 60UL
#define resource_Exp2d_OFFSET 80UL
#define resource_Exp3_OFFSET 100UL
#define resource_Exp3d_OFFSET 120UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FieldRender\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FieldRender\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FieldRender\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 35UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_BubbleTexture_OFFSET 40UL
#define resource_WaterCaustic00_OFFSET 60UL
#define resource_WaterCaustic01_OFFSET 80UL
#define resource_WaterCaustic02_OFFSET 100UL
#define resource_WaterCaustic03_OFFSET 120UL
#define resource_WaterCaustic04_OFFSET 140UL
#define resource_WaterCaustic05_OFFSET 160UL
#define resource_WaterCaustic06_OFFSET 180UL
#define resource_WaterCaustic07_OFFSET 200UL
#define resource_WaterCaustic08_OFFSET 220UL
#define resource_WaterCaustic09_OFFSET 240UL
#define resource_WaterCaustic10_OFFSET 260UL
#define resource_WaterCaustic11_OFFSET 280UL
#define resource_WaterCaustic12_OFFSET 300UL
#define resource_WaterCaustic13_OFFSET 320UL
#define resource_WaterCaustic14_OFFSET 340UL
#define resource_WaterCaustic15_OFFSET 360UL
#define resource_WaterCaustic16_OFFSET 380UL
#define resource_WaterCaustic17_OFFSET 400UL
#define resource_WaterCaustic18_OFFSET 420UL
#define resource_WaterCaustic19_OFFSET 440UL
#define resource_WaterCaustic20_OFFSET 460UL
#define resource_WaterCaustic21_OFFSET 480UL
#define resource_WaterCaustic22_OFFSET 500UL
#define resource_WaterCaustic23_OFFSET 520UL
#define resource_WaterCaustic24_OFFSET 540UL
#define resource_WaterCaustic25_OFFSET 560UL
#define resource_WaterCaustic26_OFFSET 580UL
#define resource_WaterCaustic27_OFFSET 600UL
#define resource_WaterCaustic28_OFFSET 620UL
#define resource_WaterCaustic29_OFFSET 640UL
#define resource_WaterCaustic30_OFFSET 660UL
#define resource_WaterCaustic31_OFFSET 680UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Explosion\Explosion.cpp ===
//-----------------------------------------------------------------------------
// File: Explosion.cpp
//
// Desc: Demonstrates a way of using ZSprites (see ZSprite sample) to create
//       an explosion effect.  Typical billboarded explosions suffer from 
//       artifacts when intersecting with objects - because the billboard is
//       a simple quad it intersects in a line.  Using ZSprites to give
//       depth to these billboards, the intersection appears more correct
//
// Hist: 04.03.01 - New for May XDK
//       04.09.01 - Added bundling of resources
//       04.30.01 - Updated comments, added texture coord transformation
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>
#include <xgraphics.h>
#include "xbterrain.h"

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "Ground.bmp",  resource_Ground_OFFSET },
    { "Exp1.tga",    resource_Exp1_OFFSET },
    { "Exp1d.bmp",   resource_Exp1d_OFFSET },
    { "Exp2.tga",    resource_Exp2_OFFSET },
    { "Exp2d.bmp",   resource_Exp2d_OFFSET },
    { "Exp3.tga",    resource_Exp3_OFFSET },
    { "Exp3d.bmp",   resource_Exp3d_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Zoom" },
    { XBHELP_X_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle quad\nwireframes" },
    { XBHELP_Y_BUTTON,     XBHELP_PLACEMENT_2, L"Toggle ZSprite/\nBillboard" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
};

#define NUM_HELP_CALLOUTS 6


//-----------------------------------------------------------------------------
// Name: fHeightFn
// Desc: Height field function for our terrain
//-----------------------------------------------------------------------------
FLOAT __stdcall fHeightFn( FLOAT fX, FLOAT fZ )
{
    return 1.5f * ( cosf( fX / 4 + 0.2f ) * cosf( fZ / 3 - 0.2f ) - 0.5f );
}


//-----------------------------------------------------------------------------
// Externals and globals
//-----------------------------------------------------------------------------

class CExplosion;
#define MAX_EXPLOSIONS 150

D3DXVECTOR3 g_vEyePos;              // Global viewer position
D3DXVECTOR3 g_vViewAngle;           // View angle of camera
D3DXMATRIX  g_matView;              // View transform
D3DXMATRIX  g_matProj;              // Projection transform
BOOL        g_bWireFrame = FALSE;   // Render wireframe quads
BOOL        g_bZSprite = TRUE;      // Render Zsprite or billboard




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont            m_Font;               // Font class
    CXBHelp            m_Help;               // Help class
    BOOL               m_bDrawHelp;          // Whether to draw help

    D3DXVECTOR3        m_vCameraPos;         // Camera position, untransformed

    LPDIRECT3DTEXTURE8 m_pGroundTex;
    LPDIRECT3DTEXTURE8 m_pExp[3];
    LPDIRECT3DTEXTURE8 m_pExpD[3];

    VOID    SetViewTransform();         // Sets the view transform

    CXBTerrain m_Terrain;

    CExplosion * m_apExplosion[MAX_EXPLOSIONS];

public:
    HRESULT Initialize();       // Initialize the sample
    HRESULT Render();           // Render the scene
    HRESULT FrameMove();        // Perform per-frame updates

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: class CExplosion
// Desc: Contains data for one instance of an explosion.
//-----------------------------------------------------------------------------
class CExplosion
{
public:
    CExplosion( LPDIRECT3DDEVICE8 pDevice,
                LPDIRECT3DTEXTURE8 pExplosionImage, 
                LPDIRECT3DTEXTURE8 pExplosionDepth,
                D3DXVECTOR3 vCenter,
                FLOAT fMaxRadius,
                FLOAT fDuration );
    ~CExplosion();
    HRESULT Render();

    HRESULT InitPixelShader();          // Initialize and create pixel shader
    HRESULT InitVertexShader();         // Initialize and create vertex shader

    // Member data
    LPDIRECT3DDEVICE8 m_pd3dDevice;     // Device to render to

    LPDIRECT3DTEXTURE8 m_pImage;        // Image texture
    LPDIRECT3DTEXTURE8 m_pDepth;        // Depth texture

    D3DXVECTOR3 m_vPos;                 // Center of explosion
    D3DXVECTOR3 m_vCorrectedPos;        // Center of quad 
    FLOAT m_fCurrentRadius;             // Current radius of explosion
    FLOAT m_fMaxRadius;                 // Maximum size
    FLOAT m_fDuration;                  // Duration of explosion
    FLOAT m_fStartTime;                 // When explosion began
    FLOAT m_fAlpha;                     // Fade-out alpha of explosion
    D3DXVECTOR4 m_vTransform1;          // Texture coords transform
    D3DXVECTOR4 m_vTransform2;          // (2 x 2) matrix

    static LPDIRECT3DVERTEXBUFFER8 m_pvbQuad;   // Pointer to quad VB
    static DWORD    m_dwPixelShader;            // Pixel shader handle
    static DWORD    m_dwVertexShader;           // Vertex shader handle


    typedef struct 
    {
        D3DXVECTOR3 p;
        D3DXVECTOR2 t;
    } EXPLOSION_QUAD_VERTEX;
#define FVF_EXPLOSION_QUAD_VERTEX (D3DFVF_XYZ|D3DFVF_TEX1)

};
LPDIRECT3DVERTEXBUFFER8 CExplosion::m_pvbQuad = NULL;
DWORD CExplosion::m_dwPixelShader = 0;
DWORD CExplosion::m_dwVertexShader = 0;




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
            
{
    m_bDrawHelp  = FALSE;
    memset( m_apExplosion, 0, MAX_EXPLOSIONS * sizeof(void *) );
}




//-----------------------------------------------------------------------------
// Name: InitPixelShader
// Desc: Sets up our hard-coded pixel shader
//
// Texture Stage 0: 2-D texture lookup of explosion image
// Texture Stage 1: 2-D texture lookup into depth texture
// Texture Stage 2: DotProduct for numerator of Z / W.  The texture coords
//      came from the vertex shader, and are < 0, ZScale, ZBias >
// Texture Stage 3: DotProduct for denominator and division of Z / W.  The
//      texture coords here were a constant passed through the vertex shader
//      and are < 0, 0, 1 >
// Since texture stages 2 and 3 use the HILO_1 dot mapping, the <A, R, G, B>
//      lookup from Stage 1 is converted to <AR, GB, 1>.  So our Z / W
//      calculation looks like:
//      < AR, GB, 1 > . < 0, ZScale, ZBias > / < AR, GB, 1 > . < 0, 0, 1 >
//    = ZScale * GB + ZBias / 1
//      GB is the depth value from the depth texture scaled to [0, 1], so we
//      end up with
//      ZScale * Depth + ZBias
//
// Combiner Stage 0: RO.rgb = T0.rgb(explosion image) * V0.rgb(vertex color)
//                   R0.a   = T0.a(explosion alpha) * C0(alpha fade)
//-----------------------------------------------------------------------------
HRESULT CExplosion::InitPixelShader()
{
    D3DPIXELSHADERDEF psd;

    ZeroMemory( &psd, sizeof( D3DPIXELSHADERDEF ) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1, 0 );
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D,  // Real texture
                                           PS_TEXTUREMODES_PROJECT2D,  // ZW texture
                                           PS_TEXTUREMODES_DOTPRODUCT, // (s0, t0, r0).(z, w, 1)
                                           PS_TEXTUREMODES_DOT_ZW );   // (s1, t1, r1).(z, w, 1)

    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 1, 1 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0,
                                         0,
                                         PS_DOTMAPPING_HILO_1,
                                         PS_DOTMAPPING_HILO_1 );
    psd.PSCompareMode   = PS_COMPAREMODE( 
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
        PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //--------------------------
    // Stage 0 
    //--------------------------

    // A=T0.rgb, B=V0, C=0, D=0 (so that AB.rgb = T0*V0 and CD = 0 )
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_V0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );
    
    // A=T0.a, B=C0, C=0, D=0 (so that AB.a = T0.a*C0.a and CD = 0 )
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS(
        PS_REGISTER_T0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_C0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // R0.rgb = AB
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    // R0.a = AB
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS(
        PS_REGISTER_R0,
        PS_REGISTER_DISCARD,
        PS_REGISTER_DISCARD,
        PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    
    psd.PSConstant0[0]    = 0x00000000;
    psd.PSConstant1[0]    = 0x00000000;

    //--------------------------
    // Final combiner
    //--------------------------
    psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY );

    // E = 0, F = 0, G = 1. (From above, EF is not used. G is alpha and is set to R0.a.)
    psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        PS_REGISTER_R0   | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
        0 | 0 | 0 );
    psd.PSC0Mapping = 0x00000000;
    psd.PSC1Mapping = 0x00000000;

    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwPixelShader ) ) )
    {
        OUTPUT_DEBUG_STRING( "Couldn't create pixel shader.\n" );
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitVertexShader
// Desc: Initializes and creates our vertex shader.  Also sets up vertex
//       shader constants that don't change:
//       * texture coordinates for stages 2 and 3
//       * diffuse color
//-----------------------------------------------------------------------------
HRESULT CExplosion::InitVertexShader()
{
    // Setup the vertex declaration
    DWORD dwDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Texcoords
        D3DVSD_END()
    };

    // Create the vertex shader
    XBUtil_CreateVertexShader( m_pd3dDevice, "shaders\\zsprite.xvu", dwDecl, &m_dwVertexShader );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load all our textures
    m_pGroundTex = m_xprResource.GetTexture( "Ground.bmp" );
    m_pExp[0]    = m_xprResource.GetTexture( "exp1.tga" );
    m_pExpD[0]   = m_xprResource.GetTexture( "exp1d.bmp" );
    m_pExp[1]    = m_xprResource.GetTexture( "exp2.tga" );
    m_pExpD[1]   = m_xprResource.GetTexture( "exp2d.bmp" );
    m_pExp[2]    = m_xprResource.GetTexture( "exp3.tga" );
    m_pExpD[2]   = m_xprResource.GetTexture( "exp3d.bmp" );

    // Create our terrain
    m_Terrain.Initialize( m_pd3dDevice );
    m_Terrain.Generate( 12, 12,
                        D3DXVECTOR2( -10.0f, -10.0f ),
                        D3DXVECTOR2( 10.0f, 10.0f ),
                        m_pGroundTex,
                        fHeightFn );

    // Set up stuff for view transform
    g_vViewAngle = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    m_vCameraPos = D3DXVECTOR3( 0.0f, 0.0f, -14.0f );

    // World transform is just identity
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set the view transform based on view angle
    SetViewTransform();

    // Projection transform
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, D3DX_PI/3, 4.0f/3.0f, 1.0f, 30.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
    g_matProj = matProj;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetViewTransform
// Desc: Sets the view transform based on the view angle
//-----------------------------------------------------------------------------
VOID CXBoxSample::SetViewTransform()
{
    D3DXMATRIX matView;
    D3DXMATRIX m;
    D3DXVECTOR3 vLookAt( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUp( 0.0f, 1.0f, 0.0f);

    // Create a rotation matrix for our view angle
    D3DXMatrixRotationYawPitchRoll(&m, g_vViewAngle.y, g_vViewAngle.x, g_vViewAngle.z);

    // Transform our camera position (on the Z axis)
    D3DXVec3TransformCoord(&g_vEyePos, &m_vCameraPos, &m);
    
    // Use that eye position and look at the origin
    D3DXMatrixLookAtLH(&matView, &g_vEyePos, &vLookAt, &vUp);

    m_pd3dDevice->SetTransform(D3DTS_VIEW, &matView);
    g_matView = matView;
}




//-----------------------------------------------------------------------------
// Name: ExpSortCB()
// Desc: Callback function for sorting explosions in back-to-front order
// Note: Even though we're sorting the explosions back-to-front, that doesn't
//       mean that each _pixel_ will be rendered back-to-front, so there still
//       may be alpha-blending artifacts when explosions overlap.  Sorting 
//       minimizes these artifacts greatly.
//-----------------------------------------------------------------------------
int _cdecl ExpSortCB( const VOID* arg1, const VOID* arg2 )
{
    CExplosion * p1 = *( (CExplosion **) arg1 );
    CExplosion * p2 = *( (CExplosion **) arg2 );

#if 0
    FLOAT dx1 = p1->m_vPos.x - g_vEyePos.x;
    FLOAT dx2 = p2->m_vPos.x - g_vEyePos.x;
    FLOAT dy1 = p1->m_vPos.y - g_vEyePos.y;
    FLOAT dy2 = p2->m_vPos.y - g_vEyePos.y;
    FLOAT dz1 = p1->m_vPos.z - g_vEyePos.z;
    FLOAT dz2 = p2->m_vPos.z - g_vEyePos.z;
#else
    FLOAT dx1 = p1->m_vCorrectedPos.x - g_vEyePos.x;
    FLOAT dx2 = p2->m_vCorrectedPos.x - g_vEyePos.x;
    FLOAT dy1 = p1->m_vCorrectedPos.y - g_vEyePos.y;
    FLOAT dy2 = p2->m_vCorrectedPos.y - g_vEyePos.y;
    FLOAT dz1 = p1->m_vCorrectedPos.z - g_vEyePos.z;
    FLOAT dz2 = p2->m_vCorrectedPos.z - g_vEyePos.z;
#endif

    if( ( dx1 * dx1 + dy1 * dy1 + dz1 * dz1 ) < ( dx2 * dx2 + dy2 * dy2 + dz2 * dz2 ) )
        return +1;

    return -1;
}




//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
        m_bDrawHelp = !m_bDrawHelp;

    //
    // Move the camera based off the gamepad
    //
    g_vViewAngle.y -= m_DefaultGamepad.fX1*1.0f*m_fElapsedTime;
    if( g_vViewAngle.y > D3DX_PI*2 )
        g_vViewAngle.y -= D3DX_PI*2;
    if( g_vViewAngle.y < 0.0f)
        g_vViewAngle.y += D3DX_PI*2;

    g_vViewAngle.x += m_DefaultGamepad.fY1*1.0f*m_fElapsedTime;
    if( g_vViewAngle.x > D3DX_PI / 2.1f )
        g_vViewAngle.x = D3DX_PI / 2.1f;
    if( g_vViewAngle.x < -D3DX_PI / 2.1f )
        g_vViewAngle.x = -D3DX_PI / 2.1f;

    m_vCameraPos.z += m_DefaultGamepad.fY2*1.0f*m_fElapsedTime;
    if( m_vCameraPos.z > -0.1f )
        m_vCameraPos.z = -0.1f;

    // Update the view transform
    SetViewTransform();

    // Update each explosion - if it's faded out, recreate it
    for( int i = 0; i < MAX_EXPLOSIONS; i++ )
    {
        // No explosion here - make a new one.
        if( m_apExplosion[i] == NULL ||
            m_fAppTime - m_apExplosion[i]->m_fStartTime > m_apExplosion[i]->m_fDuration )
        {
            delete m_apExplosion[i];

            D3DXVECTOR3 vPos;
            FLOAT fRadius;
            FLOAT fDuration;
            DWORD dwExp;

            // 3rd explosion texture doesn't look very good
            // when rotated, so we'll just use the first 2.
            dwExp = rand() % 2;

            vPos.x = 20.0f * rand() / RAND_MAX - 10.0f;
            vPos.z = 20.0f * rand() / RAND_MAX - 10.0f;
            vPos.y = fHeightFn( vPos.x, vPos.z );

            fRadius = 0.6f + 0.5f * rand() / RAND_MAX;
            fDuration = 4.0f * rand() / RAND_MAX + 3.0f;

            m_apExplosion[i] = new CExplosion( m_pd3dDevice,
                                               m_pExp[ dwExp ],
                                               m_pExpD[ dwExp ],
                                               vPos,
                                               fRadius,
                                               fDuration );
            m_apExplosion[i]->m_fStartTime = m_fAppTime;
        }

        //
        // Update explosion parameters
        //

        // Radius is based off of time
        FLOAT fExpTime = m_fAppTime - m_apExplosion[i]->m_fStartTime;
        m_apExplosion[i]->m_fCurrentRadius = fExpTime / m_apExplosion[i]->m_fDuration * m_apExplosion[i]->m_fMaxRadius;

        // Update corrected position of quad based off current eye position
        D3DXVECTOR3 vEyeToCenter = m_apExplosion[i]->m_vPos - g_vEyePos;
        D3DXVec3Normalize( &vEyeToCenter, &vEyeToCenter );
        m_apExplosion[i]->m_vCorrectedPos = m_apExplosion[i]->m_vPos - m_apExplosion[i]->m_fCurrentRadius * vEyeToCenter;

        // Adjust alpha for time
        m_apExplosion[i]->m_fAlpha = fExpTime < m_apExplosion[i]->m_fDuration / 2.0f ?
                                        1.0f :
                                        ( m_apExplosion[i]->m_fDuration - fExpTime ) * 2.0f / m_apExplosion[i]->m_fDuration;

    }

    // Sort explosions in back-to-front order (depends on global g_vEyePos)
    qsort( m_apExplosion, MAX_EXPLOSIONS, sizeof(CExplosion *), ExpSortCB );

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_Y ] )
    {
        g_bZSprite = !g_bZSprite;
    }
    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        g_bWireFrame = !g_bWireFrame;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Set our render state
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    // Render the terrain
    m_Terrain.Render();

    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    // Render each explosion
    for( int i = 0; i < MAX_EXPLOSIONS; i++ )
        if( m_apExplosion[i] )
            m_apExplosion[i]->Render();
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"Explosion" );
        m_Font.DrawText(  64, 80, 0xffffff00, g_bZSprite ? L"Rendering with ZSprites" : L"Rendering with Billboards" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CExplosion (constructor)
// Desc: Sets up an instance of the explosion.
//-----------------------------------------------------------------------------
CExplosion::CExplosion( LPDIRECT3DDEVICE8 pDevice,
                        LPDIRECT3DTEXTURE8 pExplosionImage, 
                        LPDIRECT3DTEXTURE8 pExplosionDepth,
                        D3DXVECTOR3 vCenter,
                        FLOAT fMaxRadius,
                        FLOAT fDuration )
{
    m_pd3dDevice = pDevice;
    m_pd3dDevice->AddRef();
    m_pImage = pExplosionImage;
    m_pImage->AddRef();
    m_pDepth = pExplosionDepth;
    m_pDepth->AddRef();

    m_vPos = vCenter;
    m_fMaxRadius = fMaxRadius;
    m_fDuration = fDuration;

    // First explosion gets to create the quad and set up shaders
    if( m_pvbQuad == NULL )
    {
        EXPLOSION_QUAD_VERTEX * pVertices;
        m_pd3dDevice->CreateVertexBuffer( 4 * sizeof( EXPLOSION_QUAD_VERTEX ), 0, 0, 0, &m_pvbQuad );
        m_pvbQuad->Lock( 0, 0, (BYTE **)&pVertices, 0 );
        pVertices[0].p = D3DXVECTOR3( -1.0f, -1.0f, 0.0f ); pVertices[0].t = D3DXVECTOR2( 0.0f, 1.0f );
        pVertices[1].p = D3DXVECTOR3( -1.0f,  1.0f, 0.0f ); pVertices[1].t = D3DXVECTOR2( 0.0f, 0.0f );
        pVertices[2].p = D3DXVECTOR3(  1.0f, -1.0f, 0.0f ); pVertices[2].t = D3DXVECTOR2( 1.0f, 1.0f );
        pVertices[3].p = D3DXVECTOR3(  1.0f,  1.0f, 0.0f ); pVertices[3].t = D3DXVECTOR2( 1.0f, 0.0f );
        m_pvbQuad->Unlock();

        // Create our shaders
        InitVertexShader();
        InitPixelShader();
    }

    switch( rand() * 4 / RAND_MAX )
    {
    case 0:
        m_vTransform1 = D3DXVECTOR4( 0.0f, -1.0f, 0.0f, 0.0f );
        m_vTransform2 = D3DXVECTOR4( 1.0f, 0.0f, 0.0f, 0.0f );
        break;
    case 1:
        m_vTransform1 = D3DXVECTOR4( -1.0f, 0.0f, 0.0f, 0.0f );
        m_vTransform2 = D3DXVECTOR4( 0.0f, -1.0f, 0.0f, 0.0f );
        break;
    case 2:
        m_vTransform1 = D3DXVECTOR4( 0.0f, 1.0f, 0.0f, 0.0f );
        m_vTransform2 = D3DXVECTOR4( -1.0f, 0.0f, 0.0f, 0.0f );
        break;
    case 3:
        m_vTransform1 = D3DXVECTOR4( 1.0f, 0.0f, 0.0f, 0.0f );
        m_vTransform2 = D3DXVECTOR4( 0.0f, 1.0f, 0.0f, 0.0f );
        break;
    }
}




//-----------------------------------------------------------------------------
// Name: ~CExplosion (destructor)
// Desc: Releases resources held by the object
//-----------------------------------------------------------------------------
CExplosion::~CExplosion()
{
    m_pImage->Release();
    m_pDepth->Release();
    m_pd3dDevice->Release();
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the explosion
// Consider: Transforming stage 0/1 texture coords to get different explosions
//-----------------------------------------------------------------------------
HRESULT CExplosion::Render()
{
    D3DXMATRIX matWorldSave;
    D3DXMATRIX matScale, matRotate, matTranslate, matWorld, matView, matProj;
    D3DXVECTOR3 vEyeToCenter = m_vPos - g_vEyePos;
    D3DXVECTOR3 vCorrectedPos;

    // Scale by our radius
    D3DXMatrixScaling( &matScale, m_fCurrentRadius, m_fCurrentRadius, 0.0f );

    // Rotate to face viewer
    D3DXMatrixRotationYawPitchRoll(&matRotate, g_vViewAngle.y, g_vViewAngle.x, g_vViewAngle.z);

    // Translate to center - fRadius * vEyeToCenter
    D3DXMatrixTranslation( &matTranslate, m_vCorrectedPos.x, m_vCorrectedPos.y, m_vCorrectedPos.z );

    // Caculate our world transform 
    D3DXMatrixMultiply( &matWorld, &matScale, &matRotate );
    D3DXMatrixMultiply( &matWorld, &matWorld, &matTranslate );

    // For ZSprites, we have to do some additional work for
    // our vertex shader
    if( g_bZSprite )
    {

        // For transforming vertices, we'll need (WVP)t
        // For transforming world positions, we'll need (VP)t
        // Calculate World * View * Projection and transposes
        D3DXMATRIX matVP, matVPt;
        D3DXMATRIX matWVP, matWVPt;
        D3DXMatrixMultiply( &matVP, &g_matView, &g_matProj );
        D3DXMatrixMultiply( &matWVP, &matWorld, &matVP );
        D3DXMatrixTranspose( &matVPt, &matVP );
        D3DXMatrixTranspose( &matWVPt, &matWVP );

        // We use Vec3's internally, but need to give vec4's to
        // the vertex shader
        D3DXVECTOR4 vCorrect, vPos;
        vCorrect.x = m_vCorrectedPos.x;
        vCorrect.y = m_vCorrectedPos.y;
        vCorrect.z = m_vCorrectedPos.z;
        vCorrect.w = 1.0f;
        vPos.x = m_vPos.x;
        vPos.y = m_vPos.y;
        vPos.z = m_vPos.z;
        vPos.w = 1.0f;

        // More vertex shader constant initialization
        D3DXVECTOR3 c4(0,0,0);
        D3DXVECTOR3 c5 = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
        D3DXVECTOR3 c6 = D3DXVECTOR3( 1.0f, 1.0f, 1.0f );
        D3DXVECTOR4 c9 = D3DXVECTOR4( D3DZ_MAX_D24S8, D3DZ_MAX_D24S8, D3DZ_MAX_D24S8, D3DZ_MAX_D24S8 );
        D3DXVECTOR4 c16 = D3DXVECTOR4( 0.5f, 0.5f, 0.0f, 0.0f );

        // Set vertex shader constants
        m_pd3dDevice->SetVertexShaderConstant( 0, &matWVPt, 4 );   // WVP(transpose)
        m_pd3dDevice->SetVertexShaderConstant( 4, &c4, 1 );        // 0 vector for initial T2 coords
        m_pd3dDevice->SetVertexShaderConstant( 5, &c5, 1 );        // T3 coords
        m_pd3dDevice->SetVertexShaderConstant( 6, &c6, 1 );        // Diffuse color
        m_pd3dDevice->SetVertexShaderConstant( 7, &vPos, 1 );      // Center of explosion
        m_pd3dDevice->SetVertexShaderConstant( 8, &vCorrect, 1 );  // Center of quad
        m_pd3dDevice->SetVertexShaderConstant( 9, &c9, 1 );        // Scale vector
        m_pd3dDevice->SetVertexShaderConstant( 10, &matVPt, 4 );   // VP(transpose)
        m_pd3dDevice->SetVertexShaderConstant( 14, &m_vTransform1, 1 );
        m_pd3dDevice->SetVertexShaderConstant( 15, &m_vTransform2, 1 );
        m_pd3dDevice->SetVertexShaderConstant( 16, &c16, 1 );
    }

    // Set state for rendering
    m_pd3dDevice->SetStreamSource( 0, m_pvbQuad, sizeof( EXPLOSION_QUAD_VERTEX ) );
    m_pd3dDevice->SetTexture( 0, m_pImage );

    // Save old transform, set new one
    m_pd3dDevice->GetTransform( D3DTS_WORLD, &matWorldSave );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    if( g_bZSprite )
    {
        // Set up to render our ZSprite
        m_pd3dDevice->SetTexture( 1, m_pDepth );
        m_pd3dDevice->SetTexture( 2, m_pDepth );
        m_pd3dDevice->SetTexture( 3, m_pDepth );

        // Select our shaders
        m_pd3dDevice->SetVertexShader( m_dwVertexShader );
        m_pd3dDevice->SetPixelShader( m_dwPixelShader );

        // Calculate alpha constant for pixel shader based on fade of explosion
        DWORD dwC0 = DWORD(m_fAlpha * 255.0f) << 24;
        m_pd3dDevice->SetRenderState( D3DRS_PSCONSTANT0_0, dwC0 );

    }
    else
    {
        // Set up to render a billboard
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZ|D3DFVF_TEX1 );
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, DWORD( m_fAlpha * 255 ) << 24 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
    }

    // Actually draw the quad
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
    m_pd3dDevice->SetPixelShader( NULL );

    if( g_bWireFrame )
    {
        // Render wireframe quad
        m_pd3dDevice->SetStreamSource( 0, m_pvbQuad, sizeof( EXPLOSION_QUAD_VERTEX ) );
        m_pd3dDevice->SetVertexShader( FVF_EXPLOSION_QUAD_VERTEX );
        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_WIREFRAME );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xFF00FF00 );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );
        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
    }

    // Restore transform
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorldSave );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FieldRender\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FieldRender\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 35UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_BubbleTexture_OFFSET 40UL
#define resource_WaterCaustic00_OFFSET 60UL
#define resource_WaterCaustic01_OFFSET 80UL
#define resource_WaterCaustic02_OFFSET 100UL
#define resource_WaterCaustic03_OFFSET 120UL
#define resource_WaterCaustic04_OFFSET 140UL
#define resource_WaterCaustic05_OFFSET 160UL
#define resource_WaterCaustic06_OFFSET 180UL
#define resource_WaterCaustic07_OFFSET 200UL
#define resource_WaterCaustic08_OFFSET 220UL
#define resource_WaterCaustic09_OFFSET 240UL
#define resource_WaterCaustic10_OFFSET 260UL
#define resource_WaterCaustic11_OFFSET 280UL
#define resource_WaterCaustic12_OFFSET 300UL
#define resource_WaterCaustic13_OFFSET 320UL
#define resource_WaterCaustic14_OFFSET 340UL
#define resource_WaterCaustic15_OFFSET 360UL
#define resource_WaterCaustic16_OFFSET 380UL
#define resource_WaterCaustic17_OFFSET 400UL
#define resource_WaterCaustic18_OFFSET 420UL
#define resource_WaterCaustic19_OFFSET 440UL
#define resource_WaterCaustic20_OFFSET 460UL
#define resource_WaterCaustic21_OFFSET 480UL
#define resource_WaterCaustic22_OFFSET 500UL
#define resource_WaterCaustic23_OFFSET 520UL
#define resource_WaterCaustic24_OFFSET 540UL
#define resource_WaterCaustic25_OFFSET 560UL
#define resource_WaterCaustic26_OFFSET 580UL
#define resource_WaterCaustic27_OFFSET 600UL
#define resource_WaterCaustic28_OFFSET 620UL
#define resource_WaterCaustic29_OFFSET 640UL
#define resource_WaterCaustic30_OFFSET 660UL
#define resource_WaterCaustic31_OFFSET 680UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Fire\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Fire\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Fire\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Fire\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Fire\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FieldRender\FieldRender.cpp ===
//-----------------------------------------------------------------------------
// File: FieldRender.cpp
//
// Desc: Xbox sample to show how to do field rendering. In field rendering, 
//       a 60 Hz presentation interval is used to alernate between alternate
//       fields displaying odd and even buffers that are 640x240 in size. This
//       is specified in the device creation parameters. The only addition step
//       is to toggle the viewport Y offset by 1 scan line for the odd fields.
//
//       The advantage of the technique is 50% less pixels to draw. The
//       disadvantages are that (1) you must be at 60 fps, (2) the quality is
//       degraded somewhat, and (3) the (normally present) hardware flicker
//       filter is not used.
//
//       This sample is a modified version of the Xbox Dolphin sample, to show
//       off field rendering. The changes to the sample are small, and may be
//       easy to overlook. So, search for "FIELD RENDERING CHANGE" for comments
//       that preceed the few actual changes.
//
// Hist: 10.06.01 - New for November XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBMesh.h>
#include <XBResource.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------
DWORD g_dwWaterColor = 0x00004080;

FLOAT g_fCycle      = 120.0f;     // Time for dolphin to complete a path cycle
FLOAT g_fLightAngle = D3DX_PI/4;  // Orientation of light from above



#define SHADOW_SIZE  256
DWORD g_dwShadowColor = 0xff000000;


// Vertex for the 3D meshes
struct D3DVERTEX
{
    D3DXVECTOR3 p;           // Position
    D3DXVECTOR3 n;           // Normal
    FLOAT       tu, tv;      // Tex coords
};

#define D3DFVF_D3DVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)


// Structure for the bubbles
struct BUBBLE
{
    FLOAT       age, lifespan;
    FLOAT       angle, spread, wobble;
    D3DXVECTOR3 vPos;
    D3DXVECTOR3 vPos0;
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font
    CXBFont                 m_Font;

    CXBPackedResource       m_xprResources;

    // Transform matrices
    D3DXMATRIX              m_matWorld;
    D3DXMATRIX              m_matView;
    D3DXMATRIX              m_matProj;

    // Dolphin object
    LPDIRECT3DTEXTURE8      m_pDolphinTexture;
    DWORD                   m_dwDolphinVertexShader;
    CXBMesh                 m_DolphinObject1;
    CXBMesh                 m_DolphinObject2;
    CXBMesh                 m_DolphinObject3;
    XBMESH_DATA*            m_pDolphinMesh1;
    XBMESH_DATA*            m_pDolphinMesh2;
    XBMESH_DATA*            m_pDolphinMesh3;

    // Seafloor object
    LPDIRECT3DTEXTURE8      m_pSeaFloorTexture;
    DWORD                   m_dwSeaFloorVertexShader;
    CXBMesh                 m_SeaFloorObject;
    XBMESH_DATA*            m_pSeaFloorMesh;

    // Water caustics
    LPDIRECT3DTEXTURE8      m_pCausticTextures[32];
    LPDIRECT3DTEXTURE8      m_pCurrentCausticTexture;
    DWORD                   m_dwDolphinPixelShader;
    DWORD                   m_dwSeaFloorPixelShader;

    // Dolphin shadow
    LPDIRECT3DTEXTURE8      m_pShadowTexture;
    LPDIRECT3DSURFACE8      m_pShadowSurface;

    // Bubbles
    D3DXVECTOR3        m_vBubbleEmitterPos;
    BUBBLE*            m_pBubbles;
    DWORD              m_dwNumBubbles;
    LPDIRECT3DVERTEXBUFFER8 m_pBubbleVB;
    LPDIRECT3DTEXTURE8 m_pBubbleTexture;

    HRESULT CreatePixelShader();
    HRESULT UpdateBubbles( FLOAT fAddBubbles );
    HRESULT RenderBubbles();

    // Spline path for the dolphin
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinSplineVB;
    D3DXVECTOR3* m_DolphinSpline;
    DWORD        m_dwNumDolphinSplinePts;

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // FIELD RENDERING CHANGE: Set device creation parameters for field
    // rendering. The refresh rate should be left at it's default, and, since
    // we are synchronizing our rendering on the flips then there is no reason
    // for more than one back buffer.
    m_d3dpp.Flags            = D3DPRESENTFLAG_FIELD;
    m_d3dpp.BackBufferCount  = 1;

    // Set the backbuffer vertical size to half of normal. NTSC needs to set
    // the back buffer size to 640x240 while PAL must use 640x288 (576 lines/2).
    if( XGetVideoStandard() == XC_VIDEO_STANDARD_PAL_I )
    {
        m_d3dpp.BackBufferWidth  = 640;
        m_d3dpp.BackBufferHeight = 288;
    }
    else
    {
        m_d3dpp.BackBufferWidth  = 640;
        m_d3dpp.BackBufferHeight = 240;
    }

    // Dolphin object
    m_dwDolphinVertexShader  = 0L;

    // SeaFloor object
    m_dwSeaFloorVertexShader = 0L;

    // Water caustics
    m_dwDolphinPixelShader  = 0L;
    m_dwSeaFloorPixelShader = 0L;

    m_pBubbleTexture     = NULL;
    m_pBubbleVB          = NULL;
    m_dwNumBubbles       = 100;
    m_pBubbles           = new BUBBLE[m_dwNumBubbles];
    m_vBubbleEmitterPos  = D3DXVECTOR3( 0, -1, -6 );

    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        m_pBubbles[i].lifespan = 5.0f + ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f;
        m_pBubbles[i].age      = (i*m_pBubbles[i].lifespan)/m_dwNumBubbles;
        m_pBubbles[i].angle    = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f * D3DX_PI;
        m_pBubbles[i].spread   = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 1.0f;
        m_pBubbles[i].wobble   = ((FLOAT)rand()/(FLOAT)RAND_MAX) * 2.0f * D3DX_PI - D3DX_PI;

        FLOAT y = m_pBubbles[i].age;
        FLOAT r = m_pBubbles[i].spread * sqrtf( y / 10.0f );
        FLOAT x = r*sinf( m_pBubbles[i].angle );
        FLOAT z = r*cosf( m_pBubbles[i].angle );

        x += 0.1f*sqrtf( y / 4.0f ) * sinf( 1 * y * m_pBubbles[i].wobble );
        z += 0.1f*sqrtf( y / 4.0f ) * cosf( 1 * y * m_pBubbles[i].wobble );

        m_pBubbles[i].vPos0 = m_vBubbleEmitterPos;

        m_pBubbles[i].vPos.x = m_pBubbles[i].vPos0.x + x;
        m_pBubbles[i].vPos.y = m_pBubbles[i].vPos0.y + y;
        m_pBubbles[i].vPos.z = m_pBubbles[i].vPos0.z + z;
    }
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    // Setup the pixel shader for the dolphin. To blend in water caustics, we
    // want the following effect:
    //    result = t0 * ( v0 + t1 * v1 )
    // where:
    //    t0 = Base texture
    //    t1 = Water caustics texture
    //    v0 = Ambient light contribution
    //    v1 = Directional light contribution
    //
    // This can be encoded into a pixel shader with:
    //    1st stage: r0 = (t1*v1 + v0*1)
    //    Final:     A*B + (1-A)*C + D
    //               E*F = r0 * t0
    // where:
    //    A = Fog factor
    //    B = EF
    //    C = Fog color
    //    D = 0
    //    E = r0
    //    F = t0
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_ZERO_TO_ONE,
                                         PS_DOTMAPPING_ZERO_TO_ONE, PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V1 + V0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwDolphinPixelShader ) ) )
        return E_FAIL;


    
    // Setup the pixel shader for the seafloor. This is the same as above,
    // except we're also modulating in the dolphin shadow, stored in t2.
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 2,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_NONE );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V1, R1=V0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_R1,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_R0,
                                                PS_REGISTER_R1,
                                                PS_REGISTER_DISCARD,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Stage 1 -------------
    // Build factor from caustics and lighting (R0 = R0 * T2 + R1 )
    psd.PSRGBInputs[1]    = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_T2  | PS_CHANNEL_RGB,
                                               PS_REGISTER_R1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[1]  = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_T2  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_R1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[1]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwSeaFloorPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT    hr;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // FIELD RENDERING CHANGE: Because we are field rendering to a surface
    // that is 1/2 normal height, we need to also shrink the factor which
    // scales our font texture. Also, when we render text (which happens in
    // screen space, we will also need to halve the start Y offset).
    m_Font.m_dwFontHeight >>= 1;

    // Load the file-based mesh objects for the dolphin
    if( FAILED( m_DolphinObject1.Create( m_pd3dDevice, "Models\\Dolphin1.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_DolphinObject2.Create( m_pd3dDevice, "Models\\Dolphin2.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;
    if( FAILED( m_DolphinObject3.Create( m_pd3dDevice, "Models\\Dolphin3.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get access to the mesh data (VB, IB, num indices, etc.). Note that we
    // can safely do this because we know this file contains only one mesh.
    m_pDolphinMesh1 = m_DolphinObject1.GetMesh(0);
    m_pDolphinMesh2 = m_DolphinObject2.GetMesh(0);
    m_pDolphinMesh3 = m_DolphinObject3.GetMesh(0);

    // Create vertex shader for the dolphin
    DWORD dwDolphinVertexDecl[] =
    {
        // First dolphin position
        D3DVSD_STREAM( 0 ),              // This data comes from stream 0
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // v3 = Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // v6 = Tex coords

        // Second dolphin position
        D3DVSD_STREAM( 1 ),              // This data comes from stream 1
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = Position of second mesh
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ), // v4 = Normal
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Tex coords

        // Third dolphin position
        D3DVSD_STREAM( 2 ),              // This data comes from stream 2
        D3DVSD_REG( 2, D3DVSDT_FLOAT3 ), // v2 = Position of second mesh
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ), // v5 = Normal
        D3DVSD_REG( 8, D3DVSDT_FLOAT2 ), // v8 = Tex coords
        D3DVSD_END()
    };

    hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Dolphin.xvu",
                                    dwDolphinVertexDecl, &m_dwDolphinVertexShader );
    if( FAILED(hr) )
        return hr;

    // Load the file-based mesh object for the seafloor
    if( FAILED( m_SeaFloorObject.Create( m_pd3dDevice, "Models\\SeaFloor.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get access to the mesh data (VB, IB, num indices, etc.). Note that we
    // can safely do this because we know this file contains only one mesh.
    m_pSeaFloorMesh = m_SeaFloorObject.GetMesh(0);

    // Create vertex shader for the seafloor
    DWORD dwSeaFloorVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
        D3DVSD_END()
    };

    if( FAILED( hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\SeaFloor.xvu",
                                                dwSeaFloorVertexDecl,
                                                &m_dwSeaFloorVertexShader ) ) )
        return hr;

    // Create a pixel shader for the underwater effect
    hr = CreatePixelShader();
    if( FAILED(hr) )
        return hr;

    // Set the transform matrices
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( 0.0f, 0.0f,-10.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( 0.0f, 0.0f,  0.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f, 1.0f,  0.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 1000.0f );

    // Create the particle system's vertex buffer
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( m_dwNumBubbles*sizeof(D3DXVECTOR3),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_XYZ,
                                                  D3DPOOL_MANAGED, &m_pBubbleVB ) ) )
        return E_FAIL;


    // Load the file-based mesh object which holds the dolphin path
    CXBMesh xbgPath;
    if( FAILED( xbgPath.Create( m_pd3dDevice, "Models\\Path.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_dwNumDolphinSplinePts = xbgPath.GetMesh(0)->m_dwNumVertices/2;
    m_DolphinSpline         = new D3DXVECTOR3[m_dwNumDolphinSplinePts];

    D3DXVECTOR3* pPathData;
    xbgPath.GetMesh(0)->m_VB.Lock( 0, 0, (BYTE**)&pPathData, 0 );
    for( DWORD i = 0; i < m_dwNumDolphinSplinePts; i++ )
    {
        m_DolphinSpline[i] = pPathData[i];
    }
    xbgPath.GetMesh(0)->m_VB.Unlock();

    // Create the dolphin's shadow texture
    if( FAILED( m_pd3dDevice->CreateTexture( SHADOW_SIZE, SHADOW_SIZE, 1, 0, 
                                             D3DFMT_X8R8G8B8, 0, &m_pShadowTexture ) ) )
        return E_FAIL;
    m_pShadowTexture->GetSurfaceLevel( 0, &m_pShadowSurface );

    // Load resources from the packed resource file. Resources (textures, vertex
    // buffers,etc.) can be packed this way so they load super quick and require
    // no load-time processing (like parsing a .bmp file, changing formats,
    // swizzling, etc.). See the code in XBResource.cpp to see how simple it is.
    if( FAILED( m_xprResources.Create( m_pd3dDevice, "Resource.xpr", 
                                       resource_NUM_RESOURCES ) ) )
        return E_FAIL;

    // Get pointers to our textures
    m_pDolphinTexture      = m_xprResources.GetTexture( resource_DolphinTexture_OFFSET );
    m_pSeaFloorTexture     = m_xprResources.GetTexture( resource_SeaFloorTexture_OFFSET );
    m_pBubbleTexture       = m_xprResources.GetTexture( resource_BubbleTexture_OFFSET );
    m_pCausticTextures[ 0] = m_xprResources.GetTexture( resource_WaterCaustic00_OFFSET );
    m_pCausticTextures[ 1] = m_xprResources.GetTexture( resource_WaterCaustic01_OFFSET );
    m_pCausticTextures[ 2] = m_xprResources.GetTexture( resource_WaterCaustic02_OFFSET );
    m_pCausticTextures[ 3] = m_xprResources.GetTexture( resource_WaterCaustic03_OFFSET );
    m_pCausticTextures[ 4] = m_xprResources.GetTexture( resource_WaterCaustic04_OFFSET );
    m_pCausticTextures[ 5] = m_xprResources.GetTexture( resource_WaterCaustic05_OFFSET );
    m_pCausticTextures[ 6] = m_xprResources.GetTexture( resource_WaterCaustic06_OFFSET );
    m_pCausticTextures[ 7] = m_xprResources.GetTexture( resource_WaterCaustic07_OFFSET );
    m_pCausticTextures[ 8] = m_xprResources.GetTexture( resource_WaterCaustic08_OFFSET );
    m_pCausticTextures[ 9] = m_xprResources.GetTexture( resource_WaterCaustic09_OFFSET );
    m_pCausticTextures[10] = m_xprResources.GetTexture( resource_WaterCaustic10_OFFSET );
    m_pCausticTextures[11] = m_xprResources.GetTexture( resource_WaterCaustic11_OFFSET );
    m_pCausticTextures[12] = m_xprResources.GetTexture( resource_WaterCaustic12_OFFSET );
    m_pCausticTextures[13] = m_xprResources.GetTexture( resource_WaterCaustic13_OFFSET );
    m_pCausticTextures[14] = m_xprResources.GetTexture( resource_WaterCaustic14_OFFSET );
    m_pCausticTextures[15] = m_xprResources.GetTexture( resource_WaterCaustic15_OFFSET );
    m_pCausticTextures[16] = m_xprResources.GetTexture( resource_WaterCaustic16_OFFSET );
    m_pCausticTextures[17] = m_xprResources.GetTexture( resource_WaterCaustic17_OFFSET );
    m_pCausticTextures[18] = m_xprResources.GetTexture( resource_WaterCaustic18_OFFSET );
    m_pCausticTextures[19] = m_xprResources.GetTexture( resource_WaterCaustic19_OFFSET );
    m_pCausticTextures[20] = m_xprResources.GetTexture( resource_WaterCaustic20_OFFSET );
    m_pCausticTextures[21] = m_xprResources.GetTexture( resource_WaterCaustic21_OFFSET );
    m_pCausticTextures[22] = m_xprResources.GetTexture( resource_WaterCaustic22_OFFSET );
    m_pCausticTextures[23] = m_xprResources.GetTexture( resource_WaterCaustic23_OFFSET );
    m_pCausticTextures[24] = m_xprResources.GetTexture( resource_WaterCaustic24_OFFSET );
    m_pCausticTextures[25] = m_xprResources.GetTexture( resource_WaterCaustic25_OFFSET );
    m_pCausticTextures[26] = m_xprResources.GetTexture( resource_WaterCaustic26_OFFSET );
    m_pCausticTextures[27] = m_xprResources.GetTexture( resource_WaterCaustic27_OFFSET );
    m_pCausticTextures[28] = m_xprResources.GetTexture( resource_WaterCaustic28_OFFSET );
    m_pCausticTextures[29] = m_xprResources.GetTexture( resource_WaterCaustic29_OFFSET );
    m_pCausticTextures[30] = m_xprResources.GetTexture( resource_WaterCaustic30_OFFSET );
    m_pCausticTextures[31] = m_xprResources.GetTexture( resource_WaterCaustic31_OFFSET );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Animation attributes for the dolphin
    FLOAT fPhase       = m_fAppTime/3;
    FLOAT fKickFreq    = 6*fPhase;
    FLOAT fBlendWeight = sinf( fKickFreq );

    // Get the parametric value u for the time-based dolphin position on it's
    // path, where 0 < u < NUM_SPLINE_POINTS.
    FLOAT u = m_dwNumDolphinSplinePts * ((m_fAppTime/g_fCycle) - floorf(m_fAppTime/g_fCycle));

    // Get the dolphin position and tangent from the spline path
    D3DXVECTOR3 vDolphinPos, vDolphinDir;
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u, 
                           &vDolphinPos, &vDolphinDir );

    // Scale and orient the dolphin model
    D3DXMATRIX matScale, matRotateY, matDolphin;
    D3DXMatrixScaling( &matScale, 0.01f, 0.01f, 0.01f );
    D3DXMatrixRotationY( &matRotateY, D3DX_PI/2 );
    D3DXMatrixMultiply( &matDolphin, &matScale, &matRotateY );

    // Add the rotation and translation for the dolphin kick
    D3DXMATRIX matKickRotate;
    D3DXMatrixRotationX( &matKickRotate, -cosf(fKickFreq)/6 );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matKickRotate );
    vDolphinPos.y += sinf(fKickFreq)/2;

    // Add the spline path. We can use the inverse of a lookat matrix to generate the
    // position and orientation of the dolphin on the path
    D3DXMATRIX matPathLookAt, matDolphinRotate, matDolphinTrans;
    D3DXMatrixLookAtLH( &matPathLookAt, &D3DXVECTOR3(0,0,0), &vDolphinDir, &D3DXVECTOR3(0,1,0) );
    D3DXMatrixInverse( &matDolphinRotate, NULL, &matPathLookAt );
    D3DXMatrixTranslation( &matDolphinTrans, vDolphinPos.x, vDolphinPos.y, vDolphinPos.z );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matDolphinRotate );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matDolphinTrans );

    // Position the bubble emitter position to correspond to the dolphin's blowhole.
    D3DXVECTOR3 vBlowHole( -150.0f, 40.0f, 0.0f );
    D3DXVec3TransformCoord( &m_vBubbleEmitterPos, &vBlowHole, &matDolphin );

    // Position the camera
    FLOAT u0 = m_dwNumDolphinSplinePts * (((m_fAppTime-1.5f)/g_fCycle) - floorf((m_fAppTime-1.5f)/g_fCycle));
    FLOAT u1 = m_dwNumDolphinSplinePts * (((m_fAppTime+0.2f)/g_fCycle) - floorf((m_fAppTime+0.2f)/g_fCycle));
    D3DXVECTOR3 vEyePt, vLookatPt;
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u0, &vEyePt,    NULL );
    XBUtil_GetSplinePoint( m_DolphinSpline, m_dwNumDolphinSplinePts, u1, &vLookatPt, NULL );
    vEyePt *= 0.9f;
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &D3DXVECTOR3(0,1,0) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Vary the fog range, color, and ambient lighting based on depth
    FLOAT fDepthFactor = 1.0f + vEyePt.y/51.0f;
    FLOAT fFogEnd   = 50.0f + 100.0f * fDepthFactor;
    FLOAT fFogStart = 1.0f/(fFogEnd-1.0f);
    DWORD green = 0x0000ff00 & (DWORD)(0x00008000 * fDepthFactor);
    DWORD blue  = 0x000000ff & (DWORD)(0x000000ff * fDepthFactor);
    g_dwWaterColor = ( green | blue );

    DWORD dwColorFactor = (DWORD)( 255.0f * (1.0f-0.5f*fDepthFactor) );
    g_dwShadowColor = (dwColorFactor<<16) | (dwColorFactor<<8) | (dwColorFactor<<0);

    // Blend weight for vertex tweening
    FLOAT fWeight1 = ( fBlendWeight > 0.0f ) ? fabsf(fBlendWeight) : 0.0f;
    FLOAT fWeight2 = 1.0f - fabsf(fBlendWeight);
    FLOAT fWeight3 = ( fBlendWeight > 0.0f ) ? 0.0f : fabsf(fBlendWeight);

    // Values passed into the vertex shader for lighting, etc.
    D3DXVECTOR4 fConstants0( 0.0f, 0.0f, 0.0f, 0.00f );
    D3DXVECTOR4 fConstants1( 1.0f, 0.5f, 0.2f, 0.05f );
    D3DXVECTOR4 fLight( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f, 0.0f );
    D3DXVECTOR4 fDiffuse( 1.00f, 1.00f, 1.00f, 1.00f );
    D3DXVECTOR4 fAmbient( 0.5f*fDepthFactor, 0.5f*fDepthFactor, 0.5f*fDepthFactor, 1.0f );
    D3DXVECTOR4 fFog( 0.5f, fFogEnd*fFogStart, fFogStart, 0.0f );
    D3DXVECTOR4 fCaustics( 0.05f, 0.05f, sinf(m_fAppTime)/8, cosf(m_fAppTime)/10 - m_fAppTime/10 );
    D3DXVECTOR4 fWeight( fWeight1, fWeight2, fWeight3, 0.0f );

    // Build matrix sets (and transpose them) for the vertex shaders
    D3DXMATRIX matDolphinWV, matDolphinWVP;
    D3DXMatrixMultiply( &matDolphinWV, &matDolphin, &m_matView );
    D3DXMatrixMultiply( &matDolphinWVP, &matDolphinWV, &m_matProj );
    D3DXMatrixTranspose( &matDolphinWV,  &matDolphinWV );
    D3DXMatrixTranspose( &matDolphinWVP,  &matDolphinWVP );

    D3DXMATRIX matSeaFloorWVP;
    D3DXMatrixMultiply( &matSeaFloorWVP, &m_matView, &m_matProj );
    D3DXMatrixTranspose( &matSeaFloorWVP,  &matSeaFloorWVP );

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant(  0, &fConstants0,    1 ); // Some constants
    m_pd3dDevice->SetVertexShaderConstant(  1, &fConstants1,    1 ); // More constants
    m_pd3dDevice->SetVertexShaderConstant(  2, &fWeight,        1 );
    m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinWV,   4 ); // Dolphin WV matrix set
    m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinWVP,  4 ); // Dolphin WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 30, &matSeaFloorWVP, 4 ); // Seafloor WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 40, &fLight,         1 ); // Light direction
    m_pd3dDevice->SetVertexShaderConstant( 41, &fDiffuse,       1 ); // Diffuse color
    m_pd3dDevice->SetVertexShaderConstant( 42, &fAmbient,       1 ); // Ambient color
    m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,           1 ); // Fog factors
    m_pd3dDevice->SetVertexShaderConstant( 44, &fCaustics,      1 ); // Misc constants

    // Animate the caustic textures
    DWORD tex = ((DWORD)(m_fAppTime*32))%32;
    m_pCurrentCausticTexture = m_pCausticTextures[tex];

    // Make this into a curve!
    FLOAT fAddBubbles = 0.0f;
    if( ((DWORD)m_fAppTime)%7 < 2 )
        fAddBubbles = m_fElapsedAppTime*50;

    UpdateBubbles( fAddBubbles );

    // Render the dolphin's shadow
    {
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwShadowColor );

        // Get the current backbuffer and zbuffer
        LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
        m_pd3dDevice->GetRenderTarget( &pBackBuffer );
        m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

        // Set the shadow texture as the rendertarget
        m_pd3dDevice->SetRenderTarget( m_pShadowSurface, NULL );

        // Set the viewport to be the correct size and clear it
        D3DVIEWPORT8 vpShadow = { 0, 0, SHADOW_SIZE, SHADOW_SIZE, 0.0f, 1.0f };
        m_pd3dDevice->SetViewport( &vpShadow );
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xffffffff, 1.0f, 0L );

        // Set new vertex shader constants so that (a) the camera is at the
        // light position, looking at the dolphin and (b) we use fog to control
        // the only color that gets written is the shadow color.
        D3DXVECTOR3 vShadowEyePt = vDolphinPos + 10 * D3DXVECTOR3( sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f );
        D3DXMATRIX  matShadowView;
        D3DXMATRIX  matShadowProj;
        D3DXMatrixLookAtLH( &matShadowView, &vShadowEyePt, &vDolphinPos, &vDolphinDir );
        D3DXMatrixOrthoLH( &matShadowProj, 3.5f, 7.0f, 1.0f, 200.0f );
        D3DXVECTOR4 fFog( 0.5f, 0.1f, 0.0f, 0.0f );
                   
        D3DXMATRIX matDolphinShadowWV, matDolphinShadowWVP;
        D3DXMatrixMultiply( &matDolphinShadowWV,  &matDolphin,         &matShadowView );
        D3DXMatrixMultiply( &matDolphinShadowWVP, &matDolphinShadowWV, &matShadowProj );
        D3DXMatrixTranspose( &matDolphinShadowWV,  &matDolphinShadowWV );
        D3DXMatrixTranspose( &matDolphinShadowWVP, &matDolphinShadowWVP );

        m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinShadowWV,  4 ); // Dolphin WV matrix set
        m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinShadowWVP, 4 ); // Dolphin WVP matrix set
        m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,                1 ); // Fog factors

        // Render the dolphin into the shadow texture
        m_pd3dDevice->SetPixelShader( NULL );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
        m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
        m_pd3dDevice->SetStreamSource( 0, &m_pDolphinMesh1->m_VB, m_pDolphinMesh1->m_dwVertexSize );
        m_pd3dDevice->SetStreamSource( 1, &m_pDolphinMesh2->m_VB, m_pDolphinMesh2->m_dwVertexSize );
        m_pd3dDevice->SetStreamSource( 2, &m_pDolphinMesh3->m_VB, m_pDolphinMesh3->m_dwVertexSize );
        m_pd3dDevice->SetIndices( &m_pDolphinMesh1->m_IB, 0 );
        m_pd3dDevice->DrawIndexedVertices( m_pDolphinMesh1->m_dwPrimType, 
                                           m_pDolphinMesh1->m_dwNumIndices,
                                           D3D__IndexData );

        // Change the rendertarget back to the main backbuffer
        D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
        m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
        m_pd3dDevice->SetViewport( &vpBackBuffer );
        pBackBuffer->Release();
        pZBuffer->Release();

        // Now, generate the texture matrix to project shadow onto the
        // seafloor. Here we just set up the matrix, and the vertex shader will
        // do the per-vertex computation for the texture coordinates.

        // Build shadow projection matrix
        D3DXMatrixOrthoLH( &matShadowProj, 15.0f*3.5f, 15.0f*7.0f, 1.0f, 200.0f );

        // Build matrix to shift coordinates from viewport space (-1,+1) to
        // texture space (0,1)
        D3DXMATRIX matTexShift;
        D3DXMatrixIdentity( &matTexShift );
        matTexShift._11 = +0.5f;   matTexShift._12 =  0.0f;
        matTexShift._21 =  0.0f;   matTexShift._22 = -0.5f;
        matTexShift._31 = +0.5f;   matTexShift._32 = +0.5f;

        // Concat the pieces to make the final texture matrix
        D3DXMATRIX matTexProj;
        D3DXMatrixIdentity( &matTexProj );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matShadowView );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matShadowProj );
        D3DXMatrixMultiply( &matTexProj, &matTexProj, &matTexShift );

        // Pass the matrix to the vertex shader via a vertex shader constant
        D3DXMATRIX matTexProjT;
        D3DXMatrixTranspose( &matTexProjT, &matTexProj );
        m_pd3dDevice->SetVertexShaderConstant( 50, &matTexProjT, 4 );
    }

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant( 20, &matDolphinWV,  4 ); // Dolphin WV matrix set
    m_pd3dDevice->SetVertexShaderConstant( 24, &matDolphinWVP, 4 ); // Dolphin WVP matrix set
    m_pd3dDevice->SetVertexShaderConstant( 43, &fFog,          1 ); // Fog factors

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name:
// Desc:
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::UpdateBubbles( FLOAT fAddBubbles )
{
    static FLOAT fBubblesToAdd = 0.0f;
    fBubblesToAdd += fAddBubbles;

    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        if( m_pBubbles[i].age > m_pBubbles[i].lifespan )
        {
            if( fBubblesToAdd > 1.0f )
            {
                fBubblesToAdd -= 1.0f;

                m_pBubbles[i].age      = m_pBubbles[i].age - m_pBubbles[i].lifespan;
                m_pBubbles[i].lifespan = 3.0f + ((FLOAT)rand()/(FLOAT)RAND_MAX) * 1.0f;
                m_pBubbles[i].vPos0    = m_vBubbleEmitterPos;
            }
        }
        else
            m_pBubbles[i].age += m_fElapsedAppTime;

        BUBBLE* pBubble = &m_pBubbles[i];

        FLOAT y = 1.2f*m_pBubbles[i].age;
        FLOAT r = m_pBubbles[i].spread * sqrtf( y / 10.0f );
        FLOAT x = r*sinf( m_pBubbles[i].angle );
        FLOAT z = r*cosf( m_pBubbles[i].angle );

        x += 0.1f*sqrtf( y / 4.0f ) * sinf( 1 * y * m_pBubbles[i].wobble );
        z += 0.1f*sqrtf( y / 4.0f ) * cosf( 1 * y * m_pBubbles[i].wobble );

        m_pBubbles[i].vPos.x = m_pBubbles[i].vPos0.x + x;
        m_pBubbles[i].vPos.y = m_pBubbles[i].vPos0.y + y;
        m_pBubbles[i].vPos.z = m_pBubbles[i].vPos0.z + z;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderBubbles()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::RenderBubbles()
{
    // Set the world matrix
    D3DXMATRIX matWorld;
    D3DXMatrixIdentity( &matWorld );
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Set the view matrix
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Set projection matrix
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );
    
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );

    // Set states for rendering the particles. Note that point sprites use 
    // stage 3.
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCCOLOR );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ONE );
    m_pd3dDevice->SetTexture( 3, m_pBubbleTexture );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_MINFILTER, D3DTEXF_LINEAR );

    // Set the render states for using point sprites
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSIZE,         FtoDW(0.15f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_A,      FtoDW(0.00f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_B,      FtoDW(0.00f) );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALE_C,      FtoDW(1.00f) );

    // Set up the vertex buffer to be rendered
    D3DXVECTOR3* pVertices;
    DWORD        dwNumParticlesToRender = 0;
    m_pBubbleVB->Lock( 0, 0, (BYTE**)&pVertices, 0 );

    // Render each particle
    for( DWORD i=0; i<m_dwNumBubbles; i++ )
    {
        if( m_pBubbles[i].age < m_pBubbles[i].lifespan )
        {
            pVertices->x = m_pBubbles[i].vPos.x;
            pVertices->y = m_pBubbles[i].vPos.y;
            pVertices->z = m_pBubbles[i].vPos.z;
            pVertices++;

            dwNumParticlesToRender++;
        }
    }

    // Unlock the vertex buffer
    m_pBubbleVB->Unlock();
    if( dwNumParticlesToRender > 0 )
    {
        m_pd3dDevice->SetStreamSource( 0, m_pBubbleVB, sizeof(D3DXVECTOR3) );
        m_pd3dDevice->SetVertexShader( D3DFVF_XYZ );
        m_pd3dDevice->DrawPrimitive( D3DPT_POINTLIST, 0, dwNumParticlesToRender );
    }

    // Reset render states
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSCALEENABLE,  FALSE );
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // FIELD RENDERING CHANGE: GetDisplayFieldStatus always returns
    // the field that is currently being displayed.  If we allowed the 
    // rendering to get ahead of our flips then it will be difficult to figure
    // out exactly what field we should be rendering for.  This block
    // waits until the last frame gets flipped so that GetDisplayFieldStatus
    // will always return the field that is currently being displayed so
    // that we can properly render the NEXT frame.
    //
    // This gives us from now until the next vertical blank to fully render
    // our scene...exactly one frame's worth.  If we go over our time budget
    // then the previous frame will be displayed twice, shifted down one
    // line the second time, this frame will be displayed on the wrong line
    // but the next frame will sync back up.  An ugly, unfortunate momentary
    // glitch but not fatal.  
    //
    // The following does a hard block that will allow other threads to run.
    // You can get the same effect by waiting for the VBlankCount returned
    // by GetDisplayFieldStatus to change.

    m_pd3dDevice->BlockUntilVerticalBlank();

    // FIELD RENDERING CHANGE: Alternate the screen space offset so that even
    // fields are rendered one half a line down.  Remember that this returns
    // the field being displayed now while we're rendering the next frame so
    // we need to do the shift on the odd frame (which starts at line 1) 
    // instead of the even frame (which starts at line 2).

    D3DFIELD_STATUS FieldStatus;
    m_pd3dDevice->GetDisplayFieldStatus( &FieldStatus );

    FLOAT fYOffset = ( FieldStatus.Field == D3DFIELD_ODD ) ? -0.5f : 0.0f;
    m_pd3dDevice->SetScreenSpaceOffset( 0, fYOffset );

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         g_dwWaterColor, 1.0f, 0L );

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwWaterColor );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    // Turn on the pixel shader for the underwater effect, which blends in the
    // current caustic texture and the dolphin's shadow. Note that specular
    // must be enabled for the pixel shader to use the v1 register.
    m_pd3dDevice->SetTexture( 1, m_pCurrentCausticTexture );
    m_pd3dDevice->SetTexture( 2, m_pShadowTexture );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,   TRUE );

    // Render the seafloor. The vertex shader does the transformation, texture
    // projection (for the water caustics) and fog calculations.
    m_pd3dDevice->SetTexture( 0, m_pSeaFloorTexture );
    m_pd3dDevice->SetPixelShader( m_dwSeaFloorPixelShader );
    m_pd3dDevice->SetVertexShader( m_dwSeaFloorVertexShader );
    m_pd3dDevice->SetStreamSource( 0, &m_pSeaFloorMesh->m_VB, m_pSeaFloorMesh->m_dwVertexSize );
    m_pd3dDevice->SetIndices( &m_pSeaFloorMesh->m_IB, 0 );
    m_pd3dDevice->DrawIndexedVertices( m_pSeaFloorMesh->m_dwPrimType, 
                                       m_pSeaFloorMesh->m_dwNumIndices,
                                       D3D__IndexData );

    // Render the dolphin. The vertex shader does the vertex tweening, 
    // transformation, texture projection (for the water caustics) and fog
    // calculations.
    m_pd3dDevice->SetTexture( 0, m_pDolphinTexture );
    m_pd3dDevice->SetPixelShader( m_dwDolphinPixelShader );
    m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
    m_pd3dDevice->SetStreamSource( 0, &m_pDolphinMesh1->m_VB, m_pDolphinMesh1->m_dwVertexSize );
    m_pd3dDevice->SetStreamSource( 1, &m_pDolphinMesh2->m_VB, m_pDolphinMesh2->m_dwVertexSize );
    m_pd3dDevice->SetStreamSource( 2, &m_pDolphinMesh3->m_VB, m_pDolphinMesh3->m_dwVertexSize );
    m_pd3dDevice->SetIndices( &m_pDolphinMesh1->m_IB, 0 );
    m_pd3dDevice->DrawIndexedVertices( m_pDolphinMesh1->m_dwPrimType, 
                                       m_pDolphinMesh1->m_dwNumIndices,
                                       D3D__IndexData );

    // Render the bubble system
    RenderBubbles();

    // FIELD RENDERING CHANGE: Because we are field rendering to a surface
    // that is 1/2 normal height, we need to halve the start Y offset) of any
    // text or HUD elements we draw.
    m_Font.Begin();
    m_Font.DrawText(  64, 25, 0xffffffff, L"Dolphin" );
    m_Font.DrawText( 450, 25, 0xffffff00, m_strFrameRate );
    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Fire\Fire.cpp ===
//-----------------------------------------------------------------------------
// File: Fire.cpp
//
// Desc: Demonstrates a cool fire effect, using a scrolling noise texture. See
//       the inline comments for how this is done. In a nutshell, billboarded
//       geometry is lit with a static fire texture that is modulated with a
//       scrolling noise texture.
//
// Hist: 03.07.01 - New for April XDK
//       04.05.01 - Converted to bundled resources
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBMesh.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// ASCII names for the resources used by the app
//-----------------------------------------------------------------------------
XBRESOURCE g_ResourceNames[] = 
{
    { "SkyBoxXP.bmp",   resource_SkyBoxXP_OFFSET },
    { "SkyBoxXN.bmp",   resource_SkyBoxXN_OFFSET },
    { "SkyBoxYP.bmp",   resource_SkyBoxYP_OFFSET },
    { "SkyBoxYN.bmp",   resource_SkyBoxYN_OFFSET },
    { "SkyBoxZP.bmp",   resource_SkyBoxZP_OFFSET },
    { "SkyBoxZN.bmp",   resource_SkyBoxZN_OFFSET },
    { "Fireground.bmp", resource_Fireground_OFFSET },
    { "FlameColor.bmp", resource_FlameColor_OFFSET },
    { "FireNoise.bmp",  resource_FireNoise_OFFSET },
    { "NoiseAlpha.bmp", resource_NoiseAlpha_OFFSET },
    { NULL, 0 },
};




//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Rotate camera" },
    { XBHELP_START_BUTTON, XBHELP_PLACEMENT_1, L"Pause" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Display help" },
};

#define NUM_HELP_CALLOUTS 4




struct PLANEVERTEX
{
    D3DXVECTOR3 p; // World position
    D3DCOLOR    c; // Color
    FLOAT       tu, tv;
};

#define D3DFVF_PLANEVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;    // Packed resources for the app
    CXBFont            m_Font;           // Font class
    CXBHelp            m_Help;           // Help class
    BOOL               m_bDrawHelp;      // Whether to draw help

    D3DXVECTOR3 m_vViewAngle;            // View angle of camera
    D3DXMATRIX  m_matWorld;              // World matrix
    D3DXMATRIX  m_matView;               // View matrix
    D3DXMATRIX  m_matProj;               // Projection matrix

    CXBMesh     m_SkyBoxObject;          // Skybox
    D3DXMATRIX  m_matSkyboxView;         // View matrix for rendering skybox

    LPDIRECT3DVERTEXBUFFER8 m_pPlaneVB;  // Geometry for ground plane
    LPDIRECT3DTEXTURE8 m_pGroundTexture; // Texture for the ground

    CXBMesh     m_FlameObject;           // Geometry for flame
    DWORD       m_dwFireVertexShader;    // Vertex shader for the fire effect
    DWORD       m_dwFirePixelShader;     // Handle for pixel shader 1
    LPDIRECT3DTEXTURE8 m_pFireBaseTexture;  // Textures for the fire effect
    LPDIRECT3DTEXTURE8 m_pFireNoiseTexture;
    LPDIRECT3DTEXTURE8 m_pFireNoiseMaskTexture;

public:
    HRESULT Initialize();       // Initialize the sample
    HRESULT Render();           // Render the scene
    HRESULT FrameMove();        // Perform per-frame updates

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :CXBApplication()
{
    m_bDrawHelp  = FALSE;
    m_vViewAngle = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES, g_ResourceNames ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load our geometry
    if( FAILED( m_SkyBoxObject.Create( m_pd3dDevice, "Models\\SkyBox.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_FlameObject.Create( m_pd3dDevice, "Models\\Flame.xbg", &m_xprResource ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a quad for our intersecting plane
    m_pd3dDevice->CreateVertexBuffer( 4*sizeof(PLANEVERTEX), D3DUSAGE_WRITEONLY, 
                                      0, D3DPOOL_MANAGED, &m_pPlaneVB );
    {
        PLANEVERTEX* v;
        m_pPlaneVB->Lock( 0, 0, (BYTE **)&v, 0 );
        v[0].p = D3DXVECTOR3( -30.0f, 0.0f, -30.0f );  v[0].c = 0xffffffff; v[0].tu = 0.000f; v[0].tv = 0.000f;
        v[1].p = D3DXVECTOR3( -30.0f, 0.0f,  30.0f );  v[1].c = 0xffffffff; v[1].tu = 0.000f; v[1].tv = 1.062f;
        v[2].p = D3DXVECTOR3(  30.0f, 0.0f, -30.0f );  v[2].c = 0xffffffff; v[2].tu = 1.066f; v[2].tv = 0.000f;
        v[3].p = D3DXVECTOR3(  30.0f, 0.0f,  30.0f );  v[3].c = 0xffffffff; v[3].tu = 1.066f; v[3].tv = 1.062f;
        m_pPlaneVB->Unlock();
    }

    // Create a texture to render into
    m_pGroundTexture        = m_xprResource.GetTexture( "FireGround.bmp" );
    m_pFireBaseTexture      = m_xprResource.GetTexture( "FlameColor.bmp" );
    m_pFireNoiseTexture     = m_xprResource.GetTexture( "FireNoise.bmp" );
    m_pFireNoiseMaskTexture = m_xprResource.GetTexture( "NoiseAlpha.bmp" );

    // Set up transforms
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixIdentity( &m_matView );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/4, 4.0f/3.0f, 1.0f, 1000.0f );
    m_pd3dDevice->SetTransform( D3DTS_WORLD,      &m_matWorld );
    m_pd3dDevice->SetTransform( D3DTS_VIEW,       &m_matView );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProj );

    // Create vertex shader for the fire
    DWORD dwFireVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // v6 = Tex coords
        D3DVSD_END()
    };

    if( FAILED( XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Fire.xvu",
                                           dwFireVertexDecl, &m_dwFireVertexShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    
    if( FAILED( XBUtil_CreatePixelShader( m_pd3dDevice, "Shaders\\Fire.xpu",
                                          &m_dwFirePixelShader ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    return S_OK;
}


D3DXVECTOR3 vCameraPos( 0.0f, 2.0f, -20.0f );


//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK ) 
        m_bDrawHelp = !m_bDrawHelp;

    // Move the camera
    m_vViewAngle.y += m_DefaultGamepad.fX2*1.0f*m_fElapsedTime;
    if( m_vViewAngle.y > D3DX_PI*2 )
        m_vViewAngle.y -= D3DX_PI*2;
    if( m_vViewAngle.y < 0.0f )
        m_vViewAngle.y += D3DX_PI*2;

    m_vViewAngle.x += m_DefaultGamepad.fY2*1.0f*m_fElapsedTime;
    if( m_vViewAngle.x > D3DX_PI/8 )
        m_vViewAngle.x = D3DX_PI/8;
    if( m_vViewAngle.x < 0.0f )
        m_vViewAngle.x = 0.0f;

    // Create a rotation matrix for our view angle
    D3DXMATRIX  matRotate, matRotateX, matRotateY;
    D3DXMatrixRotationY( &matRotateX, m_vViewAngle.x );
    D3DXMatrixRotationY( &matRotateY, m_vViewAngle.y );
    D3DXMatrixRotationYawPitchRoll( &matRotate, m_vViewAngle.y, m_vViewAngle.x, m_vViewAngle.z );

    // Move the camera
    D3DXVECTOR3 vForward, vRight;
    D3DXVec3TransformCoord( &vForward, &D3DXVECTOR3(0,0,1), &matRotateY );
    D3DXVec3TransformCoord( &vRight,   &D3DXVECTOR3(1,0,0), &matRotateY );
    vCameraPos += vRight * m_DefaultGamepad.fX1*10.0f*m_fElapsedTime;
    vCameraPos += vForward * m_DefaultGamepad.fY1*10.0f*m_fElapsedTime;

    // Use the camera position and lookat direction to setup the view matrix
    D3DXVECTOR3 vLookat;
    D3DXVec3TransformCoord( &vLookat,  &D3DXVECTOR3(0,0,1), &matRotate );
    D3DXMatrixLookAtLH( &m_matView, &vCameraPos, 
                                    &(vCameraPos + vLookat),
                                    &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Remove the translation to get the skybox view matrix
    m_matSkyboxView = m_matView;
    m_matSkyboxView._41 = 0.0f; m_matSkyboxView._42 = 0.0f; m_matSkyboxView._43 = 0.0f;

    // Compute the billboard matrix (constrained form of the view matrix)
    D3DXMATRIX matBillboard;
    D3DXMatrixLookAtLH( &matBillboard, &D3DXVECTOR3( 0.0f, 0.0f, 0.0f ),
                                       &D3DXVECTOR3( -vCameraPos.x, 0.0f, -vCameraPos.z ),
                                       &D3DXVECTOR3( 0.0f, 1.0f, 0.0f ) );
    D3DXMatrixInverse( &matBillboard, NULL, &matBillboard );

    // Pass constants to the vertex shader.
    // c0 and c1 are used to scroll the noise texture's tex coords
    D3DXVECTOR4 c0( 1.00f, 0.35f, 0.0f, 1.0f );
    D3DXVECTOR4 c1( 0.0f, 0.30f*m_fAppTime, 0.0f, 0.0f );
    m_pd3dDevice->SetVertexShaderConstant(  0, &c0,     1 );
    m_pd3dDevice->SetVertexShaderConstant(  1, &c1,     1 );

    // Pass the transform set to the vertex shader
    D3DXMATRIX matWVP;
    D3DXMatrixMultiply( &matWVP, &matBillboard, &m_matView );
    D3DXMatrixMultiply( &matWVP, &matWVP, &m_matProj );
    D3DXMatrixTranspose( &matWVP,&matWVP );
    m_pd3dDevice->SetVertexShaderConstant(  4, &matWVP, 4 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER, 0x00000000, 1.0f, 0L );

    // Set state for rendering the skybox
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matSkyboxView );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

    // Render the skybox
    m_SkyBoxObject.Render( m_pd3dDevice );

    // Set state for rendering the ground plane
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );
    m_pd3dDevice->SetTexture( 0, m_pGroundTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );

    // Render the ground plane
    m_pd3dDevice->SetVertexShader( D3DFVF_PLANEVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pPlaneVB, sizeof(PLANEVERTEX) );
    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Set state for rendering the fire    
    m_pd3dDevice->SetTexture( 0, m_pFireBaseTexture );
    m_pd3dDevice->SetTexture( 1, m_pFireNoiseTexture );
    m_pd3dDevice->SetTexture( 2, m_pFireNoiseMaskTexture );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );

    // Render the fire.
    //
    // The vertex shader transforms the vertices (nothing fancy), and sets up
    // the texture coordinates for three texture stages. Stage 0 is the base
    // fire texture and is stationary. Stage 1 is a long, skinny, noise texture
    // with scrolling texture coordinates. Stage 2 is a stationary texture used
    // to mask the noise texture.
    //
    // The pixel shader brings everything together. The rgb data from the base
    // texture is used, while the alpha channel is a combination of the three
    // textures, most notably the noise texture, which gives the effect of
    // rolling, animated flames.
    //
    // Note: also crucial to effect is the geometry itself. The folds and
    // ripples in the geometry make the scrolling of the noise texture look
    // more chaotic. (Using a flat plane for the fire effect, would look okay,
    // except that the flames would go 100% in the up direction, with no
    // deviation. The end result would be not as cool for that case.)
    m_pd3dDevice->SetVertexShader( m_dwFireVertexShader );
    m_pd3dDevice->SetPixelShader( m_dwFirePixelShader );
    m_FlameObject.Render( m_pd3dDevice, XBMESH_NOFVF|XBMESH_NOMATERIALS|XBMESH_NOTEXTURES );

    m_pd3dDevice->SetPixelShader( NULL );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"Fire" );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Fire\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define resource_NUM_RESOURCES 10UL

#define resource_SkyBoxXN_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxYN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxZN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_Fireground_OFFSET 120UL
#define resource_FlameColor_OFFSET 140UL
#define resource_FireNoise_OFFSET 160UL
#define resource_NoiseAlpha_OFFSET 180UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\Fire\obj\i386\Resource.h ===
// Automatically generated by the bundler tool from Resource.rdf

#define resource_NUM_RESOURCES 10UL

#define resource_SkyBoxXN_OFFSET 0UL
#define resource_SkyBoxXP_OFFSET 20UL
#define resource_SkyBoxYN_OFFSET 40UL
#define resource_SkyBoxYP_OFFSET 60UL
#define resource_SkyBoxZN_OFFSET 80UL
#define resource_SkyBoxZP_OFFSET 100UL
#define resource_Fireground_OFFSET 120UL
#define resource_FlameColor_OFFSET 140UL
#define resource_FireNoise_OFFSET 160UL
#define resource_NoiseAlpha_OFFSET 180UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\depth.inl ===
// Xbox Shader Assembler 1.00.4232.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    8,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0xff000000;
psd.PSConstant1[1] = 0x00000000;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x00000000;
psd.PSConstant1[2] = 0x00000000;

//------------- Stage 3 -------------
psd.PSRGBInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[3] = 0x000000ff;
psd.PSConstant1[3] = 0x00000000;

//------------- Stage 4 -------------
psd.PSRGBInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL);
psd.PSRGBOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[4] = 0x7fffffff;
psd.PSConstant1[4] = 0x00000000;

//------------- Stage 5 -------------
psd.PSRGBInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_BLUE | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSRGBOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX);
psd.PSConstant0[5] = 0x00000000;
psd.PSConstant1[5] = 0x00000000;

//------------- Stage 6 -------------
psd.PSRGBInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSRGBOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[6] = 0x00000000;
psd.PSConstant1[6] = 0x00000000;

//------------- Stage 7 -------------
psd.PSRGBInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[7] = 0x00000000;
psd.PSConstant1[7] = 0x00000000;

//------------- FinalCombiner -------------
psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_FINALCOMBINERSETTING_CLAMP_SUM | 0 | 0);
psd.PSFinalCombinerConstant0 = 0xffffffff;
psd.PSFinalCombinerConstant1 = 0x00000000;

psd.PSC0Mapping = 0xfff51230;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001f4;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\FocusBlur.cpp ===
//-----------------------------------------------------------------------------
// File: FocusBlur.cpp
//
// Desc: Two pass focus blur effect.  First, use the backbuffer as a
//   	 texture and draw to a separate blur texture with a blur pixel
//   	 shader.  For computing the blurred back buffer, this sample
//   	 shows several different filters of varying visual quality and
//   	 performance. Second, use the depthbuffer as a texture to
//   	 choose a range of z values to show in sharp focus vs blurry
//   	 focus.
//
// Copyright (c) 2001-2002 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <XBUtil.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"

#ifndef ASSERT
#define ASSERT(X) { if (!(X)) { __asm int 3 } }
#endif

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_1, L"Move camera" },
    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_1, L"Rotate camera" },
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_1, L"Help" },
    { XBHELP_START_BUTTON,  XBHELP_PLACEMENT_2, L"Timing\nBaseline" },
    { XBHELP_A_BUTTON,  XBHELP_PLACEMENT_2, L"Next\nMode" },
    { XBHELP_B_BUTTON,  XBHELP_PLACEMENT_2, L"Previous\nMode" },
    { XBHELP_X_BUTTON,  XBHELP_PLACEMENT_2, L"Next\nFilter" },
    { XBHELP_Y_BUTTON,  XBHELP_PLACEMENT_2, L"Previous\nFilter" },
    { XBHELP_WHITE_BUTTON,  XBHELP_PLACEMENT_2, L"Filter\nComparison" },
    { XBHELP_BLACK_BUTTON,  XBHELP_PLACEMENT_2, L"Depth\nMode" },
    { XBHELP_LEFT_BUTTON,   XBHELP_PLACEMENT_1, L"Focus -" },
    { XBHELP_RIGHT_BUTTON,  XBHELP_PLACEMENT_1, L"Focus +" },
    
};
#define NUM_HELP_CALLOUTS (sizeof(g_HelpCallouts)/sizeof(XBHELP_CALLOUT))


//-----------------------------------------------------------------------------
// Vertex type for the cylinder objects in the simple scene.
//-----------------------------------------------------------------------------
struct CUSTOMVERTEX
{
    D3DXVECTOR3 position;   // The position
    D3DXVECTOR3 normal;     // The vertex normals
    float tu, tv;           // texture coords
};
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

//-----------------------------------------------------------------------------
// A filter sample holds a subpixel offset and a filter value
// to be multiplied by a source texture to compute an arbitrary
// filter.  See FilterCopy for more details.
//-----------------------------------------------------------------------------
struct FilterSample {
    float fValue;               // coefficient
    float fOffsetX, fOffsetY;   // subpixel offsets of supersamples in destination coordinates
};

//-----------------------------------------------------------------------------
// The depth-mapping pixel shader attempts to do higher precision
// math with eight-bit color registers.  The _x4 instruction modifier
// is used twice to get a 16x range of values.
//-----------------------------------------------------------------------------
float g_fPixelShaderScale = 16.f;   // to get into the right range, we scale up the value in the pixel shader

//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    CXBPackedResource  m_xprResource;        // Packed resources for the app
    CXBFont      m_Font;
    CXBHelp      m_Help;
    bool         m_bDrawHelp;
    FLOAT        m_fFPSBase; // frames-per-second starting point for comparing the efficiency of different techniques

    //////////////////////////////////////////////////////////////////////
    // To demonstrate the focus blur effect, this sample draws a simple
    // scene with texture-mapped cylinders.
    // 
    D3DVertexBuffer *m_pCylinderVB;          // Buffer for cylinder vertices, which is the basic object
    UINT m_nObjectCount;
    struct Object {                         // put a few objects around in the scene
        D3DXVECTOR3 m_vPosition;
        D3DXCOLOR m_color;
        UINT m_iTexture;                    // texture index
    } *m_rObjects;
#define TEXTURE_COUNT 3
    D3DTexture *m_rpTexture[TEXTURE_COUNT]; // object textures, use several for variety
    
    //////////////////////////////////////////////////////////////////////
    // Current viewing parameters
    //
    D3DXVECTOR3     m_vFrom, m_vAt, m_vUp;  // Viewing parameters
    D3DXMATRIX      m_matWorld;
    D3DXMATRIX      m_matView;
    D3DXMATRIX      m_matViewInverse;
    D3DXMATRIX      m_matProjection;
    
    //////////////////////////////////////////////////////////////////////
    // Some of the blur filters are multipass and need temporary space.
    //
#define BLUR_COUNT 5
    D3DTexture *m_rpBlur[BLUR_COUNT];   // textures of decreasing size, used for blurring the backbuffer
    D3DTexture *m_pBlur;                // current blur texture, set by Blur function

    //////////////////////////////////////////////////////////////////////
    // Techniques for mapping the z-buffer to the in-focus range
    //
    enum DEPTHMODE {
        DM_RAW,         // show the raw z-buffer for demonstration purposes
        DM_RANGE,       // use arithmetic in the pixel shader to map z 
        DM_LOOKUP,      // use a dependent-texture read to map z
        _DM_MAX } m_eDepthMode;
    
    //////////////////////////////////////////////////////////////////////
    // Overall modes for the sample.
    // 
    enum EFFECTMODE { 
        EM_NOEFFECT,    // draw the basic scene, with no focus effect
        EM_BLUR,        // show the blurred back-buffer texture
        EM_DEPTH,       // show the mapping of z-values to in-focus areas
        EM_FOCUS,       // the full focus effect
        _EM_MAX } m_eEffectMode;
	
    //////////////////////////////////////////////////////////////////////
    // Enumeration of blur filters available in this sample to compare
    // the speed and quality of different types of blur filters for
    // the out-of-focus parts of the scene.
    //
    enum FILTERMODE {
        FM_VERT2_HORIZ2,
        FM_HORIZ2_VERT2,
        FM_VERT2_HORIZ,
        FM_HORIZ2_VERT,
        FM_IDENTITY,
        FM_BOX,
        FM_VERT,
        FM_HORIZ, 
        FM_BOX2,
        FM_VERT2,
        FM_HORIZ2,
        FM_BOX2_BOX2,
        FM_VERT2_HORIZ2_BOX2,
        FM_BOX2_BOX2_BOX2,
        FM_VERT2_HORIZ2_VERT2,
        FM_HORIZ2_VERT2_HORIZ2,
        FM_VERT2_HORIZ2_VERT2_HORIZ2,
        FM_HORIZ2_VERT2_HORIZ2_VERT2,
        FM_BOX2_BOX2_BOX2_BOX2,
        _FM_MAX
    } m_eFilterMode, m_eFilterMode2;    // keep two indices to visually compare the blur filters
	WCHAR *m_strFilterName;			// name of filter
	WCHAR *m_strFilterDescription;	// description of filter

    //////////////////////////////////////////////////////////////////////
    // Constants to choose the focus range. The lookup texture maps z
    // to focus values when DM_LOOKUP is active (for
    // FocusLookupPixelShader or DepthLookupPixelShader).
    //
    float m_fDepth0, m_fDepth1;         // range of depths to map
    float m_fFraction0, m_fFraction1;   // fractions of (at-from) vector to use for setting focus depths
    D3DTexture *m_pTextureFocusRange;   // lookup table for range of z values to use

    //////////////////////////////////////////////////////////////////////
    // Pixel shader handles
    // 
    DWORD m_dwBlurPixelShader;          // blur the back-buffer
    DWORD m_dwDepthPixelShader;         // use pixel shader arithmetic to map z to focus value
    DWORD m_dwDepthLookupPixelShader;   // use a lookup texture to map z to the focus value
    // Blend the in-focus back-buffer with the blurred texture...
    DWORD m_dwFocusPixelShader;         // ... based on DepthPixelShader focus value
    DWORD m_dwFocusLookupPixelShader;   // ... or based on DepthLookupPixelShader focus value

    //////////////////////////////////////////////////////////////////////
    // Main filtering routine that draws the source texture multiple
    // times, with sub-pixel offsets and filter coefficients.
    // 
    HRESULT FilterCopy(LPDIRECT3DTEXTURE8 pTextureDst,
                       LPDIRECT3DTEXTURE8 pTextureSrc,
                       UINT nSample,
                       FilterSample rSample[],
                       UINT nSuperSampleX,
                       UINT nSuperSampleY,
                       RECT *pRectDst = NULL,  // The destination texture is written only within this region.
                       RECT *pRectSrc = NULL); // The source texture is read outside of this region by the halfwidth of the filter.
    
    //////////////////////////////////////////////////////////////////////
    // Blur backbuffer and set m_pBlur.  Calls FilterCopy with
    // different filter coefficients and offsets, based on the current
    // FILTERMODE setting.
	//
    HRESULT Blur();
    
    //////////////////////////////////////////////////////////////////////
	// The z-values from the depth buffer are mapped to a focus range
	// based on the current range of depths m_fDepth0 and m_fDepth1,
	// which are set based on a fraction (m_fFraction0, m_fFraction1)
	// of the distance of the near and far z-clip planes.
	//
    HRESULT FillFocusRangeTexture(bool bRamp);	// fill texture using current focus mapping 
    HRESULT CalculateFocusDepths();     // Use fractions along viewing vector to set focus depths
    HRESULT CalculateDepth(float *pfDepth, const D3DXVECTOR3 &vPosition);	// calculate the depth value of the 3D point
    HRESULT CalculateDepthMapping(float fDepth0,		// compute constants for pixel shader arithmetic
                                  float fDepth1,
                                  float *pfAlphaOffset,
                                  float *pfAlphaSlope, 
                                  float *pfBlueOffset,
                                  float *pfBlueSlope);
	
    //////////////////////////////////////////////////////////////////////
    // For demonstrating the inputs to the full focus effect, the sample
	// can draw just the blurred texture or the z-buffer as a texture.
	//
    HRESULT DrawBlur();			// draw blurred texture
    HRESULT DrawDepthRaw();		// draw raw z values as rgb
    HRESULT DrawDepthRange();	// map z to focus values using pixel shader arithmetic
    HRESULT DrawDepthLookup();	// map z to focus values using a lookup texture
	
    //////////////////////////////////////////////////////////////////////
    // Full focus blur effect, using either of the two z-to-focus mapping
	// techniques.
	//
    HRESULT DrawFocusRange();	// use pixel shader arithmetic for mapping z to focus value
    HRESULT DrawFocusLookup();	// map z through lookup texture to focus value

    //////////////////////////////////////////////////////////////////////
	// Set current transformation matrices based on current view
	// position and orientation.
	//
    HRESULT SetCameraTransformations();
public:

	// Overrides of XbApp framework functions
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};




//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
#ifdef _DEBUG
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;    // Allow unlimited frame rate
#endif
    m_bDrawHelp     = false;
    m_fFPSBase = 0.f;
    m_eDepthMode = DM_RANGE;
    m_eEffectMode   = EM_FOCUS;
    m_eFilterMode   = m_eFilterMode2 = (FILTERMODE)0;
	m_strFilterName = NULL;
	m_strFilterDescription = NULL;
    ZeroMemory(m_rpTexture, sizeof(m_rpTexture));
    m_pCylinderVB      = NULL;
    ZeroMemory(m_rpBlur, sizeof(m_rpBlur));
    m_pBlur = NULL;
    m_pTextureFocusRange = NULL;
    m_dwBlurPixelShader = 0;
    m_dwDepthPixelShader = 0;
    m_dwDepthLookupPixelShader = 0;
    m_dwFocusPixelShader = 0;
    m_dwFocusLookupPixelShader = 0;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    // Create the font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create the help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Get size of render target
    LPDIRECT3DSURFACE8 pRenderTarget;
    g_pd3dDevice->GetRenderTarget(&pRenderTarget);
    D3DSURFACE_DESC descRenderTarget;
    pRenderTarget->GetDesc(&descRenderTarget);
    UINT Width = descRenderTarget.Width;
    UINT Height = descRenderTarget.Height;
    D3DFORMAT Format = descRenderTarget.Format;
    pRenderTarget->Release();

    // Create the blur textures
    for (UINT i = 0; i < BLUR_COUNT; i++)
    {
        // make the size a factor of 2 smaller each time
        m_pd3dDevice->CreateTexture(Width >> i, Height >> i, 1, D3DUSAGE_RENDERTARGET, Format, 0, &m_rpBlur[i]);
    }

    // Create the pixel shaders
#pragma warning( push )
#pragma warning( disable : 4245 )   // ignore conversion of int to DWORD
    {
#include "blur.inl"
        g_pd3dDevice->CreatePixelShader(&psd, &m_dwBlurPixelShader);
    }
    {
#include "depth.inl"
        g_pd3dDevice->CreatePixelShader(&psd, &m_dwDepthPixelShader);
    }
    {
#include "depthlookup.inl"
        g_pd3dDevice->CreatePixelShader(&psd, &m_dwDepthLookupPixelShader);
    }
    {
#include "focus.inl"
        g_pd3dDevice->CreatePixelShader(&psd, &m_dwFocusPixelShader);
    }
    {
#include "focuslookup.inl"
        g_pd3dDevice->CreatePixelShader(&psd, &m_dwFocusLookupPixelShader);
    }
#pragma warning( pop )
    
    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", resource_NUM_RESOURCES, NULL ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Load the textures
    m_rpTexture[0] = m_xprResource.GetTexture( resource_Texture0_OFFSET );
    m_rpTexture[1] = m_xprResource.GetTexture( resource_Texture1_OFFSET );
    m_rpTexture[2] = m_xprResource.GetTexture( resource_Checker_OFFSET );
    
    // Create geometry for a cylinder
#define NSAMPLE 25
   if( FAILED( m_pd3dDevice->CreateVertexBuffer( NSAMPLE*2*sizeof(CUSTOMVERTEX),
                                                  0, D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_DEFAULT, &m_pCylinderVB ) ) )
        return E_FAIL;
    // Fill the vertex buffer. We are setting the tu and tv texture
    // coordinates, which range from 0.0 to 1.0
    CUSTOMVERTEX* v;
    if( FAILED( m_pCylinderVB->Lock( 0, 0, (BYTE**)&v, 0 ) ) )
        return E_FAIL;
    for(UINT i=0; i<NSAMPLE; i++ )
    {
        FLOAT theta = (2*D3DX_PI*i)/(NSAMPLE-1);

        v[2*i+0].position = D3DXVECTOR3( sinf(theta),-1.2f, cosf(theta) );
        v[2*i+0].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        v[2*i+0].tu = ((FLOAT)i*2.0f)/(NSAMPLE-1);
        v[2*i+0].tv = 1.0f;
        
        v[2*i+1].position = D3DXVECTOR3( sinf(theta), 1.2f, cosf(theta) );
        v[2*i+1].normal   = D3DXVECTOR3( sinf(theta), 0.0f, cosf(theta) );
        v[2*i+1].tu = ((FLOAT)i*2.0f)/(NSAMPLE-1);
        v[2*i+1].tv = 0.0f;
    }
    m_pCylinderVB->Unlock();

    // Position the objects
    m_nObjectCount = 100;
    m_rObjects = new Object [ m_nObjectCount ];
    if (m_rObjects == NULL)
        return E_OUTOFMEMORY;
#define irand(a) ((rand()*(a))>>15)
#define frand(a) ((float)rand()*(a)/32768.0f)
    float fScale = 100.f;
    srand(123456);
    for (UINT i = 0; i < m_nObjectCount; i++)
    {
        m_rObjects[i].m_vPosition = D3DXVECTOR3( frand(fScale), 0.f, frand(fScale));
        m_rObjects[i].m_color = D3DXCOLOR( frand(1.f), frand(1.f), frand(1.f), 1.f);
        m_rObjects[i].m_iTexture = irand(TEXTURE_COUNT);
    }
    
    // Set camera parameters and initialize camera matrices
    m_vAt = m_rObjects[0].m_vPosition;
    m_vFrom = m_vAt - D3DXVECTOR3(8.f, 0.f, 0.f);
    m_vUp = D3DXVECTOR3( 0.0f, 1.0f , 0.0f);
    SetCameraTransformations();

    // Set focus range to be around the object we're looking at
    m_fFraction0 = 0.9f;
    m_fFraction1 = 1.1f;
    CalculateFocusDepths();

    // Create and fill the focus range texture
    FillFocusRangeTexture(false);

    // Setup the light
    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = D3DLIGHT_DIRECTIONAL;
    light.Ambient      = D3DXCOLOR(0.3f, 0.3f, 0.3f, 1.f);
    light.Diffuse      = D3DXCOLOR(1.f, 1.f, 1.f, 1.f);
    light.Direction    = D3DXVECTOR3( 1.f, 1.f, 1.f );
    light.Range        = 1000.0f;
    light.Attenuation0 = 1.0f;
    g_pd3dDevice->SetLight( 0, &light );
    g_pd3dDevice->LightEnable( 0, TRUE );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SetCameraTransformations()
// Desc: Calculate camera matrices and set transformation state
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::SetCameraTransformations()
{
    // Set world matrix to identity
    D3DXMatrixIdentity(&m_matWorld);
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &m_matWorld );
    
    // Set our view matrix.
    D3DXMatrixLookAtLH( &m_matView, &m_vFrom, &m_vAt, &m_vUp);
    D3DXMatrixInverse( &m_matViewInverse, NULL, &m_matView);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_matView );

    // Set projection 
    static float fNear = 1.f;
    static float fFar = 50.f;
    D3DXMatrixPerspectiveFovLH( &m_matProjection, D3DX_PI/4, 640.f / 480.f, fNear, fFar);
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &m_matProjection );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    bool bUpdateDepth = false;
    
    // Toggle help
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_BACK )
        m_bDrawHelp = !m_bDrawHelp;

    // Set base FPS
    if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        // alternate between showing FPS delta and not
        if (m_fFPSBase == 0.f)
            m_fFPSBase = m_fFPS;
        else
            m_fFPSBase = 0.f;
    }

    // Toggle depth mode when in depth or focus mode
    if (m_eEffectMode == EM_DEPTH
        || m_eEffectMode == EM_FOCUS)
    {
        if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
        {
            int iDepthMode = (int)m_eDepthMode + 1;
            if (iDepthMode >= (int)_DM_MAX)
                iDepthMode = 0;
            m_eDepthMode = (DEPTHMODE)iDepthMode;
            bUpdateDepth = true;
        }
    }

    // Change filter type only in the blur and focus modes
    if (m_eEffectMode == EM_BLUR 
        || m_eEffectMode == EM_FOCUS)
    {
        // Swap filter modes
        if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
        {
            FILTERMODE fm = m_eFilterMode2;
            m_eFilterMode2 = m_eFilterMode;
            m_eFilterMode = fm;
        }

        // Go to next filter mode
        if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_X] )
        {
            int iFilterMode = (int)m_eFilterMode + 1;
            if (iFilterMode >= (int)_FM_MAX)
                iFilterMode = 0;
            m_eFilterMode = (FILTERMODE)iFilterMode;
        }

        // Go to previous filter mode
        if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y] )
        {
            int iFilterMode = (int)m_eFilterMode - 1;
            if (iFilterMode < 0)
                iFilterMode = (int)_FM_MAX - 1;
            m_eFilterMode = (FILTERMODE)iFilterMode;
        }

		// Name and description is set by Blur()
		m_strFilterName = NULL;
		m_strFilterDescription = NULL;
    }

    // Go to next effect mode
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_A] )
    {
        int iEffectMode = (int)m_eEffectMode + 1;
        if (iEffectMode >= (int)_EM_MAX)
            iEffectMode = 0;
        m_eEffectMode = (EFFECTMODE)iEffectMode;
        bUpdateDepth = true;
    }

    // Go to previous effect mode
    if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_B] )
    {
        int iEffectMode = (int)m_eEffectMode - 1;
        if (iEffectMode < 0)
            iEffectMode = (int)_EM_MAX - 1;
        m_eEffectMode = (EFFECTMODE)iEffectMode;
        bUpdateDepth = true;
    }

    // update view position
    static float fOffsetScale = 3.f;
    float fX1 = m_DefaultGamepad.fX1;
    fX1 *= fX1 * fX1; // fX1 cubed
    float fY1 = m_DefaultGamepad.fY1;
    fY1 *= fY1 * fY1; // fY1 cubed
    D3DXVECTOR3 vOffset(fX1, 0.f, fY1); // screen space offset, X moves left-right, Y moves in-out in depth
    D3DXVec3TransformNormal(&vOffset, &vOffset, &m_matViewInverse);
    D3DXVec3Normalize(&m_vUp, &m_vUp);
    vOffset -= D3DXVec3Dot(&vOffset, &m_vUp) * m_vUp; // don't move up or down with thumb sticks
    D3DXVec3Normalize(&vOffset, &vOffset);
    vOffset *= fOffsetScale * m_fElapsedTime;
    m_vFrom += vOffset;
    m_vAt += vOffset;

    // update view angle
    static float fAtOffsetScale = 8.f;
    D3DXVECTOR3 vAtOffset(0.f, 0.f, 0.f);
    float fX2 = m_DefaultGamepad.fX2;
    fX2 *= fX2 * fX2; // fX2 cubed
    float fY2 = m_DefaultGamepad.fY2;
    fY2 *= fY2 * fY2; // fY2 cubed
    vAtOffset.x += fAtOffsetScale * fX2 * m_fElapsedTime;
    D3DXVECTOR3 vE = m_vAt - m_vFrom;
    D3DXVec3Normalize(&vE, &vE);
    float fThreshold = 0.99f;
    float fEdotU = D3DXVec3Dot(&vE, &m_vUp);
    if ((fEdotU < -fThreshold && fY2 < 0.f) // near -vUp, but positive movement
        || (fEdotU > fThreshold && fY2 > 0.f)   // near vUp, but negative movement
        || (fEdotU > -fThreshold && fEdotU < fThreshold))       // ordinary case
        vAtOffset.y -= fAtOffsetScale * fY2 * m_fElapsedTime;   // screen-space Y displacement means up-down view turn
    D3DXVec3TransformNormal(&vAtOffset, &vAtOffset, &m_matViewInverse);
    m_vAt += vAtOffset;

    // Set focus depths
    int delta = m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] 
        - m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER];
    if (delta)
    {
        static float fDeltaScale = 0.001f;
        float fScale = 1.f + m_fElapsedTime * delta * fDeltaScale;
        m_fFraction0 *= fScale;
        m_fFraction1 *= fScale;
        if (m_fFraction0 < 0.1f) m_fFraction0 = 0.1f;
        if (m_fFraction0 > 10.f) m_fFraction0 = 10.f;
        if (m_fFraction1 < 0.1f) m_fFraction1 = 0.1f;
        if (m_fFraction1 > 10.f) m_fFraction1 = 10.f;
        bUpdateDepth = true;
    }

    if (bUpdateDepth)
    {
        if (m_eDepthMode == DM_RAW
            && m_eEffectMode == EM_FOCUS)
        {
            // skip raw depths when in focus effect mode
            m_eDepthMode = DM_RANGE;
        }

        // Set focus depths from m_vFrom, m_vAt, m_fFraction0, and m_fFraction1
        CalculateFocusDepths();

        // Fill the lookup texture, if needed
        if (m_eDepthMode == DM_LOOKUP)
            FillFocusRangeTexture(false);
    }

    SetCameraTransformations();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    // Draw a gradient filled background
    RenderGradientBackground( 0xff0000ff, 0xff000000 );

    // Set default state
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTexture( 1, NULL );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTexture( 2, NULL );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTexture( 3, NULL );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,         TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );

    // Render some geometry
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetStreamSource( 0, m_pCylinderVB, sizeof(CUSTOMVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    D3DXMATRIX matWorld;
    D3DMATERIAL8 material;
    XBUtil_InitMaterial( material, 1.0f, 1.0f, 1.0f );
    for (UINT i = 0; i < m_nObjectCount; i++)
    {
        m_pd3dDevice->SetTexture(0, m_rpTexture[m_rObjects[i].m_iTexture] );
        material.Diffuse = material.Ambient = m_rObjects[i].m_color;
        m_pd3dDevice->SetMaterial( &material );
        D3DXMatrixTranslation(&matWorld, m_rObjects[i].m_vPosition.x, m_rObjects[i].m_vPosition.y, m_rObjects[i].m_vPosition.z);
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2*NSAMPLE-2 );
    }

    // Draw the current effect
    switch (m_eEffectMode)
    {
    case EM_NOEFFECT:
        break;

    case EM_BLUR:
        Blur();                 // blur back buffer
        DrawBlur();             // display blurred texture
        break;
        
    case EM_DEPTH:
        switch (m_eDepthMode)
        {
        case DM_RAW:
            DrawDepthRaw();         // raw depths
            break;
        case DM_RANGE:
            DrawDepthRange();       // depths mapped with range in pixel shader
            break;
        case DM_LOOKUP:
            DrawDepthLookup();      // depths mapped through lookup table texture
            break;
        }
        break;

    case EM_FOCUS:
        Blur();                 // blur back buffer
        switch (m_eDepthMode)
        {
        case DM_RAW:    // this should not happen, but just in case, fall through to range depth mapping
        case DM_RANGE:
            DrawFocusRange();       // blur the backbuffer into a texture, then use current depth range to choose between sharp or blurred focus
            break;

        case DM_LOOKUP:
            DrawFocusLookup();      // blur the backbuffer into a texture, then use current depth mapped through a lookup table to choose between sharp or blurred focus
            break;
        }
        break;
    }

    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING,        FALSE );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_Font, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        static WCHAR *rstrEffectMode[] = {
            L"No effect",
            L"Blur texture",
            L"Depth",
            L"Focus effect",
        };
        ASSERT(sizeof(rstrEffectMode)/sizeof(WCHAR *) == _EM_MAX);
        WCHAR str[200];
        m_Font.Begin();
        swprintf( str, L"FocusBlur: %s", rstrEffectMode[m_eEffectMode] );
        m_Font.DrawText(  64, 50, 0xffffffff, str );
        m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
        if (m_fFPSBase != 0.f)
        {
            FLOAT msDelta = 1000.f / m_fFPS - 1000.f / m_fFPSBase;  // milliseconds
            swprintf( str, L"%+0.02f ms", msDelta);
            m_Font.DrawText( 450, 110, 0xff00ff00, str);
        }
        if (m_eEffectMode == EM_FOCUS
            || m_eEffectMode == EM_DEPTH)
        {
            static WCHAR *rstrDepthMode[] = {
                L"Raw Depth",
                L"Depth Range",
                L"Depth Lookup",
            };
            m_Font.DrawText( 64, 80, 0xffffff00, rstrDepthMode[m_eDepthMode]);
            static WCHAR *rstrDepthModeDescription[] = {
                L"Z values are draw as red, green, blue.",
				
                L"Z values are mapped to focus value with\n"
				L"pixel shader arithmetic. Use triggers to change\n"
				L"focus range and black button to toggle Z mode.",
				
                L"Z values are mapped to focus values using\n"
				L"a lookup texture. Use triggers to change\n"
				L"focus range and black button to toggle Z mode.",
            };
			if (m_eEffectMode == EM_DEPTH)
				m_Font.DrawText( 64, 330, 0xffaaaa10, rstrDepthModeDescription[m_eDepthMode]);
        }
        if ( m_eEffectMode == EM_BLUR )
        {
			if (m_strFilterName != NULL)
				m_Font.DrawText( 64, 110, 0xffffff00, m_strFilterName);
			if (m_strFilterDescription != NULL)
				m_Font.DrawText( 64, 330, 0xffaaaa10, m_strFilterDescription);
			m_Font.DrawText( 64, 400, 0xffaaaa10, L"Use X and Y to choose blur filter." );
        }
		else if ( m_eEffectMode == EM_FOCUS )
		{
			if (m_strFilterName != NULL)
				m_Font.DrawText( 64, 110, 0xffffff00, m_strFilterName);
		}
        else if (m_eEffectMode == EM_DEPTH)
        {
            static bool bDebugDepth = false;    // set this in the debugger to see depth mapping values
            if (bDebugDepth)
            {
                float fAlphaOffset, fAlphaSlope, fBlueOffset, fBlueSlope;
                CalculateDepthMapping(m_fDepth0, m_fDepth1, &fAlphaOffset, &fAlphaSlope, &fBlueOffset, &fBlueSlope);
                swprintf( str, L"fAlphaOffset %f 0x%02x", fAlphaOffset, (int)(fAlphaOffset * 255 + 0.5f));
                m_Font.DrawText( 64, 140, 0xff00ff00, str);
                swprintf( str, L"fAlphaSlope %f 0x%02x", fAlphaSlope, (int)(fAlphaSlope * 255 + 0.5f));
                m_Font.DrawText( 64, 170, 0xff00ff00, str);
                swprintf( str, L"fBlueOffset %f 0x%02x", fBlueOffset, (int)(fBlueOffset * 255 + 0.5f));
                m_Font.DrawText( 64, 200, 0xff00ff00, str);
                swprintf( str, L"fBlueSlope %f 0x%02x", fBlueSlope, (int)(fBlueSlope * 255 + 0.5f));
                m_Font.DrawText( 64, 230, 0xff00ff00, str);
                swprintf( str, L"m_fDepth0 %f 0x%x", m_fDepth0, (int)(m_fDepth0 * 65536 + 0.5f));
                m_Font.DrawText( 64, 260, 0xff00ff00, str);
                swprintf( str, L"m_fDepth1 %f 0x%x", m_fDepth1, (int)(m_fDepth1 * 65536 + 0.5f));
                m_Font.DrawText( 64, 290, 0xff00ff00, str);
            }
        }
        m_Font.End();
    }

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}



//-----------------------------------------------------------------------------
// Filter the source texture by rendering into the destination texture
// with subpixel offsets. Does 4 filter coefficients at a time, using
// all the stages of the pixel shader.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FilterCopy(LPDIRECT3DTEXTURE8 pTextureDst,
                                LPDIRECT3DTEXTURE8 pTextureSrc,
                                UINT nSample,
                                FilterSample rSample[],
                                UINT nSuperSampleX,
                                UINT nSuperSampleY,
                                RECT *pRectDst,
                                RECT *pRectSrc )
{
    // Save current render target and depth buffer
    LPDIRECT3DSURFACE8 pRenderTarget, pZBuffer;
    g_pd3dDevice->GetRenderTarget(&pRenderTarget);
    g_pd3dDevice->GetDepthStencilSurface(&pZBuffer);

    // Set destination as render target
    LPDIRECT3DSURFACE8 pSurface = NULL;
    pTextureDst->GetSurfaceLevel(0, &pSurface);
    g_pd3dDevice->SetRenderTarget(pSurface, NULL);  // no depth-buffering
    pSurface->Release();

    // Get descriptions of source and destination
    D3DSURFACE_DESC descSrc;
    pTextureSrc->GetLevelDesc(0, &descSrc);
    D3DSURFACE_DESC descDst;
    pTextureDst->GetLevelDesc(0, &descDst);

    // Setup rectangles if not specified on input
    RECT rectSrc = { 0, 0, descSrc.Width, descSrc.Height };
    if (pRectSrc == NULL) pRectSrc = &rectSrc;
    RECT rectDst = { 0, 0, descDst.Width, descDst.Height };
    if (pRectDst == NULL)
    {
        // If the destination rectangle is not specified, we change it to match the source rectangle
        rectDst.right = (pRectSrc->right - pRectSrc->left) / nSuperSampleX;
        rectDst.bottom = (pRectSrc->bottom - pRectSrc->top) / nSuperSampleY;
        pRectDst = &rectDst;
    }
    ASSERT((pRectDst->right - pRectDst->left) == (pRectSrc->right - pRectDst->left) / (INT)nSuperSampleX );
    ASSERT((pRectDst->bottom - pRectDst->top) == (pRectSrc->bottom - pRectDst->top) / (INT)nSuperSampleY );
    
    // set render state for filtering
    g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
    g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
    g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
    g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
    g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);    // on first rendering, copy new value over current render target contents
    g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);    // setup subsequent renderings to add to previous value
    g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

    // set texture state
    UINT xx; // texture stage index
    for (xx = 0; xx < 4; xx++)
    {
        g_pd3dDevice->SetTexture(xx, pTextureSrc);  // use our source texture for all four stages
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);  // pass texture coords without transformation
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_TEXCOORDINDEX, xx); // each texture has different tex coords
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAXMIPLEVEL, 0);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPFILTER, D3DTEXF_POINT);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLORSIGN, 0);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAKILL, D3DTALPHAKILL_DISABLE);
    }
    
    g_pd3dDevice->SetPixelShader(m_dwBlurPixelShader);          // use blur pixel shader
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_TEX4);   // for screen-space texture-mapped quadrilateral

    // Prepare quadrilateral vertices
    float x0 = (float)pRectDst->left - 0.5f;
    float y0 = (float)pRectDst->top - 0.5f;
    float x1 = (float)pRectDst->right - 0.5f;
    float y1 = (float)pRectDst->bottom - 0.5f;
    struct quad {
        float x, y, z, w1;
        struct uv {
            float u, v;
        } tex[4];   // each texture has different offset
    } aQuad[4] =
      { //  X   Y     Z   1/W     u0  v0      u1  v1      u2  v2      u3  v3
          {x0, y0, 1.0f, 1.0f, }, // texture coords are set below
          {x1, y0, 1.0f, 1.0f, },
          {x0, y1, 1.0f, 1.0f, },
          {x1, y1, 1.0f, 1.0f, }
      };

    // Set rendering to just the destination rect
    g_pd3dDevice->SetScissors(1, FALSE, (D3DRECT *)pRectDst);

    // Draw a quad for each block of 4 filter coefficients
    xx = 0; // current texture stage
    float fOffsetScaleX, fOffsetScaleY; // convert destination coords to source texture coords
    float u0, v0, u1, v1;   // base source rectangle.
    if (XGIsSwizzledFormat(descSrc.Format))
    {
        float fWidthScale = 1.f / (float)descSrc.Width;
        float fHeightScale = 1.f / (float)descSrc.Height;
        fOffsetScaleX = (float)nSuperSampleX * fWidthScale;
        fOffsetScaleY = (float)nSuperSampleY * fHeightScale;
        u0 = (float)pRectSrc->left * fWidthScale;
        v0 = (float)pRectSrc->top * fHeightScale;
        u1 = (float)pRectSrc->right * fWidthScale;
        v1 = (float)pRectSrc->bottom * fHeightScale;
    }
    else
    {
        fOffsetScaleX = (float)nSuperSampleX;
        fOffsetScaleY = (float)nSuperSampleY;
        u0 = (float)pRectSrc->left;
        v0 = (float)pRectSrc->top;
        u1 = (float)pRectSrc->right;
        v1 = (float)pRectSrc->bottom;
    }
    D3DCOLOR rColor[4];
    DWORD rPSInput[4];
    for (UINT iSample = 0; iSample < nSample; iSample++)
    {
        // Set filter coefficients
        float fValue = rSample[iSample].fValue;
        /*
        float rf[4] = {fValue, fValue, fValue, fValue};
        g_pd3dDevice->SetPixelShaderConstant(xx, rf, 1);            // positive coeff
        */
        if (fValue < 0.f)
        {
            rColor[xx] = D3DXCOLOR(-fValue, -fValue, -fValue, -fValue);
            rPSInput[xx] = PS_INPUTMAPPING_SIGNED_NEGATE | ((xx % 2) ? PS_REGISTER_C1 : PS_REGISTER_C0);
        }
        else
        {
            rColor[xx] = D3DXCOLOR(fValue, fValue, fValue, fValue);
            rPSInput[xx] = PS_INPUTMAPPING_SIGNED_IDENTITY | ((xx % 2) ? PS_REGISTER_C1 : PS_REGISTER_C0);
        }

        // Align supersamples with center of destination pixels
        float fOffsetX = rSample[iSample].fOffsetX * fOffsetScaleX;
        float fOffsetY = rSample[iSample].fOffsetY * fOffsetScaleY;
        aQuad[0].tex[xx].u = u0 + fOffsetX;
        aQuad[0].tex[xx].v = v0 + fOffsetY;
        aQuad[1].tex[xx].u = u1 + fOffsetX;
        aQuad[1].tex[xx].v = v0 + fOffsetY;
        aQuad[2].tex[xx].u = u0 + fOffsetX;
        aQuad[2].tex[xx].v = v1 + fOffsetY;
        aQuad[3].tex[xx].u = u1 + fOffsetX;
        aQuad[3].tex[xx].v = v1 + fOffsetY;
        
        xx++; // Go to next stage
        if (xx == 4 || iSample == nSample - 1)  // max texture stages or last sample
        {
            // zero out unused texture stage coefficients 
            // (only for last filter sample, when number of samples is not divisible by 4)
            for (; xx < 4; xx++)
            {
                g_pd3dDevice->SetTexture(xx, NULL);
                rColor[xx] = 0;
                rPSInput[xx] = PS_INPUTMAPPING_UNSIGNED_IDENTITY | PS_REGISTER_ZERO;
            }
        
            // Set coefficients
            g_pd3dDevice->SetRenderState(D3DRS_PSCONSTANT0_0, rColor[0] );
            g_pd3dDevice->SetRenderState(D3DRS_PSCONSTANT1_0, rColor[1] );
            g_pd3dDevice->SetRenderState(D3DRS_PSCONSTANT0_1, rColor[2] );
            g_pd3dDevice->SetRenderState(D3DRS_PSCONSTANT1_1, rColor[3] );

            // Remap coefficients to proper sign
            g_pd3dDevice->SetRenderState(
                D3DRS_PSRGBINPUTS0,
                PS_COMBINERINPUTS( rPSInput[0] | PS_CHANNEL_RGB,   PS_REGISTER_T0 | PS_CHANNEL_RGB   | PS_INPUTMAPPING_SIGNED_IDENTITY,
                                   rPSInput[1] | PS_CHANNEL_RGB,   PS_REGISTER_T1 | PS_CHANNEL_RGB   | PS_INPUTMAPPING_SIGNED_IDENTITY ) );
            g_pd3dDevice->SetRenderState(
                D3DRS_PSALPHAINPUTS0,
                PS_COMBINERINPUTS( rPSInput[0] | PS_CHANNEL_ALPHA, PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
                                   rPSInput[1] | PS_CHANNEL_ALPHA, PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY ) );
            g_pd3dDevice->SetRenderState(
                D3DRS_PSRGBINPUTS1,
                PS_COMBINERINPUTS( rPSInput[2] | PS_CHANNEL_RGB,   PS_REGISTER_T2 | PS_CHANNEL_RGB   | PS_INPUTMAPPING_SIGNED_IDENTITY,
                                   rPSInput[3] | PS_CHANNEL_RGB,   PS_REGISTER_T3 | PS_CHANNEL_RGB   | PS_INPUTMAPPING_SIGNED_IDENTITY ) );
            g_pd3dDevice->SetRenderState(
                D3DRS_PSALPHAINPUTS1,
                PS_COMBINERINPUTS( rPSInput[2] | PS_CHANNEL_ALPHA, PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
                                   rPSInput[3] | PS_CHANNEL_ALPHA, PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY ) );
            
            // draw the quad to filter the coefficients so far
            g_pd3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, aQuad, sizeof(quad)); // one quad blends 4 textures
            g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE); // on subsequent renderings, add to what's in the render target 
            xx = 0;
        }
    }

    // clear texture stages
    for (xx=0; xx<4; xx++)
    {
        g_pd3dDevice->SetTexture(xx, NULL);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_COLOROP, D3DTOP_DISABLE);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        g_pd3dDevice->SetTextureStageState(xx, D3DTSS_MIPMAPLODBIAS, 0);
    }

    // Restore render target and zbuffer
    g_pd3dDevice->SetRenderTarget( pRenderTarget, pZBuffer );
    if (pRenderTarget != NULL) pRenderTarget->Release();
    if (pZBuffer != NULL) pZBuffer->Release();
    return S_OK;
}

//-----------------------------------------------------------------------------
// Blur backbuffer and set m_pBlur to the current blur texture.  Calls
// FilterCopy with different filter coefficients and offsets, based on
// the current FILTERMODE setting.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Blur()
{
    // Make D3DTexture wrapper around current render target
    LPDIRECT3DSURFACE8 pRenderTarget;
    g_pd3dDevice->GetRenderTarget(&pRenderTarget);
    D3DSURFACE_DESC descRenderTarget;
    pRenderTarget->GetDesc(&descRenderTarget);
    D3DTexture RenderTargetTexture;
    ZeroMemory( &RenderTargetTexture, sizeof(RenderTargetTexture) );
    XGSetTextureHeader( descRenderTarget.Width, descRenderTarget.Height, 1, 0, descRenderTarget.Format, 0, &RenderTargetTexture, pRenderTarget->Data, descRenderTarget.Width * 4);
    pRenderTarget->Release();
    
    // Filters align to blurriest point in supersamples, on the 0.5 boundaries.
    // This takes advantage of the bilinear filtering in the texture map lookup.
    static FilterSample BoxFilter[] = {     // for 2x2 downsampling
        { 0.25f, -0.5f, -0.5f },
        { 0.25f,  0.5f, -0.5f },
        { 0.25f, -0.5f,  0.5f },
        { 0.25f,  0.5f,  0.5f },
    };
    static FilterSample YFilter[] = {       // 1221 4-tap filter in Y
        { 1.f/6.f, 0.f, -1.5f },
        { 2.f/6.f, 0.f, -0.5f },
        { 2.f/6.f, 0.f,  0.5f },
        { 1.f/6.f, 0.f,  1.5f },
    };
    static FilterSample XFilter[] = {       // 1221 4-tap filter in X
        { 1.f/6.f, -1.5f, 0.f },
        { 2.f/6.f, -0.5f, 0.f },
        { 2.f/6.f,  0.5f, 0.f },
        { 1.f/6.f,  1.5f, 0.f },
    };
    static FilterSample Y141Filter[] = {    // 141 3-tap filter in Y
        { 1.f/6.f, 0.f, -1.0f },
        { 4.f/6.f, 0.f,  0.0f },
        { 1.f/6.f, 0.f,  1.0f },
    };
    static FilterSample X141Filter[] = {        // 141 3-tap filter in X
        { 1.f/6.f, -1.0f, 0.f },
        { 4.f/6.f,  0.0f, 0.f },
        { 1.f/6.f,  1.0f, 0.f },
    };
    m_pBlur = NULL;
    switch (m_eFilterMode)
    {
    case FM_IDENTITY:
    {
		m_strFilterName = L"FM_IDENTITY";
		m_strFilterDescription =
			L"Identity filter.";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[0];
        static FilterSample IdentityFilter[] = {
            { 1.f, 0.f, 0.f },
        };
        FilterCopy(pTextureDst, pTextureSrc, 1, IdentityFilter, 1, 1);
        m_pBlur = pTextureDst;
        break;
    }

    case FM_BOX:
    {
		m_strFilterName = L"FM_BOX";
		m_strFilterDescription =
			L"2x2 box filter, no decimation";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[0];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 1, 1);
        m_pBlur = pTextureDst;
        break;
    }

    case FM_VERT:
    {
		m_strFilterName = L"FM_VERT";
		m_strFilterDescription =
			L"Vertical gaussian (1221), no decimation";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[0];
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 1, 1);
        m_pBlur = pTextureDst;
        break;
    }

    case FM_HORIZ:
    {
		m_strFilterName = L"FM_HORIZ";
		m_strFilterDescription =
			L"Horizontal gaussian (1221), no decimation";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[0];
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 1, 1);
        m_pBlur = pTextureDst;
        break;
    }

    case FM_BOX2:
    {
		m_strFilterName = L"FM_BOX2";
		m_strFilterDescription =
			L"2x2 box filter, 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }

    case FM_VERT2:
    {
		m_strFilterName = L"FM_VERT2";
		m_strFilterDescription =
			L"Vertical gaussian (1221), 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }

    case FM_HORIZ2:
    {
		m_strFilterName = L"FM_HORIZ2";
		m_strFilterDescription =
			L"Horizontal gaussian (1221), 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }

    case FM_VERT2_HORIZ2:
    {
		m_strFilterName = L"FM_VERT2_HORIZ2";
		m_strFilterDescription =
			L"2 passes: Vertical gaussian (1221) followed by\n"
			L"horizontal gaussian (1221), with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        pTextureSrc = pTextureDst;  // source is previous blur texture
        pTextureDst = m_rpBlur[2];  // destination is next blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_HORIZ2_VERT2:
    {
		m_strFilterName = L"FM_HORIZ2_VERT2";
		m_strFilterDescription =
			L"2 passes: Horizontal gaussian (1221) followed by\n"
			L"vertical gaussian (1221), with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        pTextureSrc = pTextureDst;  // source is previous blur texture
        pTextureDst = m_rpBlur[2];  // destination is next blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_VERT2_HORIZ:
    {
		m_strFilterName = L"FM_VERT2_HORIZ";
		m_strFilterDescription =
			L"2 passes: Vertical gaussian (1221) followed by\n"
			L"narrow horizontal gaussian (141), with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        pTextureSrc = pTextureDst;  // source is previous blur texture
        pTextureDst = m_rpBlur[2];  // destination is next blur texture
        FilterCopy(pTextureDst, pTextureSrc, 3, X141Filter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_HORIZ2_VERT:
    {
		m_strFilterName = L"FM_HORIZ2_VERT";
		m_strFilterDescription =
			L"2 passes: Horizontal gaussian (1221) followed by\n"
			L"narrow vertical gaussian (141), with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        pTextureSrc = pTextureDst;  // source is previous blur texture
        pTextureDst = m_rpBlur[2];  // destination is next blur texture
        FilterCopy(pTextureDst, pTextureSrc, 3, Y141Filter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_BOX2_BOX2:
    {
		m_strFilterName = L"FM_BOX2_BOX2";
		m_strFilterDescription =
			L"2 passes: Box filter followed by box filter,\n"
			L"with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[2];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_VERT2_HORIZ2_BOX2:
    {
		m_strFilterName = L"FM_VERT2_HORIZ2_BOX2";
		m_strFilterDescription =
			L"3 passes: Vertical gaussian (1441) followed by\n"
			L"horizontal gaussian (1441) followed by box filter,\n"
			L"with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[2];
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[3];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_BOX2_BOX2_BOX2:
    {
		m_strFilterName = L"FM_BOX2_BOX2_BOX2";
		m_strFilterDescription =
			L"3 passes: Box filter followed by box filter\n"
			L"followed by box filter, with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[2];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[3];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_VERT2_HORIZ2_VERT2:
    {
		m_strFilterName = L"FM_VERT2_HORIZ2_VERT2";
		m_strFilterDescription =
			L"3 passes: Vertical gaussian (1441) then horizontal\n"
			L"gaussian (1441) then vertical gaussian (1441)\n"
			L"with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[2];
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[3];
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_HORIZ2_VERT2_HORIZ2:
    {
		m_strFilterName = L"FM_HORIZ2_VERT2_HORIZ2";
		m_strFilterDescription =
			L"3 passes: Horizontal gaussian (1441) then vertical\n"
			L"gaussian (1441) then horizontal gaussian (1441)\n"
			L"with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[2];
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[3];
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_VERT2_HORIZ2_VERT2_HORIZ2:
    {
		m_strFilterName = L"FM_VERT2_HORIZ2_VERT2_HORIZ2";
		m_strFilterDescription =
			L"4 passes, alternating vertical gaussian (1441)\n"
			L"then horizontal gaussian (1441), with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[2];
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[3];
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[4];
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_HORIZ2_VERT2_HORIZ2_VERT2:
    {
		m_strFilterName = L"FM_HORIZ2_VERT2_HORIZ2_VERT2";
		m_strFilterDescription =
			L"4 passes, alternating horizontal gaussian (1441)\n"
			L"then vertical gaussian (1441), with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[2];
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[3];
        FilterCopy(pTextureDst, pTextureSrc, 4, XFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[4];
        FilterCopy(pTextureDst, pTextureSrc, 4, YFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    case FM_BOX2_BOX2_BOX2_BOX2:
    {
		m_strFilterName = L"FM_BOX2_BOX2_BOX2_BOX2";
		m_strFilterDescription =
			L"4 passes of box filter with 2x2 downsampling";
        D3DTexture *pTextureSrc = &RenderTargetTexture; // source is backbuffer 
        D3DTexture *pTextureDst = m_rpBlur[1];      // destination is blur texture
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[2];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[3];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        pTextureSrc = pTextureDst;
        pTextureDst = m_rpBlur[4];
        FilterCopy(pTextureDst, pTextureSrc, 4, BoxFilter, 2, 2);
        m_pBlur = pTextureDst;
        break;
    }
    }
    return S_OK;
}
    
//-----------------------------------------------------------------------------
// Display the blurry texture
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawBlur()
{
    static D3DCOLOR colorBlend = 0xffffffff;
    if (!m_pBlur)
        return S_FALSE;
    LPDIRECT3DTEXTURE8 pTexture = m_pBlur;
    
    // Get size of backbuffer
    LPDIRECT3DSURFACE8 pRenderTarget;
    g_pd3dDevice->GetRenderTarget(&pRenderTarget);
    D3DSURFACE_DESC descRenderTarget;
    pRenderTarget->GetDesc(&descRenderTarget);
    UINT Width = descRenderTarget.Width;
    UINT Height = descRenderTarget.Height;
    pRenderTarget->Release();

    // Texture coordinates in linear format textures go from 0 to n-1 rather
    // than the 0 to 1 that is used for swizzled textures.
    D3DSURFACE_DESC desc;
    pTexture->GetLevelDesc(0, &desc);
    struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
    v[0].p = D3DXVECTOR4( -0.5f,        -0.5f,         1.0f, 1.0f ); v[0].tu = 0.0f;              v[0].tv = 0.0f;
    v[1].p = D3DXVECTOR4( Width - 0.5f, -0.5f,         1.0f, 1.0f ); v[1].tu = (float)desc.Width; v[1].tv = 0.0f;
    v[2].p = D3DXVECTOR4( -0.5f,        Height - 0.5f, 1.0f, 1.0f ); v[2].tu = 0.0f;              v[2].tv = (float)desc.Height;
    v[3].p = D3DXVECTOR4( Width - 0.5f, Height - 0.5f, 1.0f, 1.0f ); v[3].tu = (float)desc.Width; v[3].tv = (float)desc.Height;
    
    // Set states
    g_pd3dDevice->SetPixelShader( 0 );
    g_pd3dDevice->SetTexture( 0, pTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin0 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag0 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, dwMin0 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, dwMag0 );
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, colorBlend );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, 0 );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);

    // Render the screen-aligned quadrilateral
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );

    // Reset render states
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    // Remove linear texture before setting address mode to Wrap
    g_pd3dDevice->SetTexture( 0, NULL );
    return S_OK;
}

//-----------------------------------------------------------------------------
// Display the depth buffer as color values, with the
// most significant bits in red and green
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawDepthRaw()
{
    // Make a D3DTexture wrapper around the depth buffer surface
    D3DSURFACE_DESC desc;
    D3DSurface *pZBuffer;
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );
    pZBuffer->GetDesc(&desc);
    D3DTexture ZBufferTexture;
    ZeroMemory( &ZBufferTexture, sizeof(ZBufferTexture) );
    static D3DFORMAT fmtOverride = D3DFMT_LIN_R8G8B8A8;     // Put the most significant bits in the red and green channels
    XGSetTextureHeader( desc.Width, desc.Height, 1, 0, fmtOverride, 0, &ZBufferTexture, pZBuffer->Data, desc.Width * 4);
    pZBuffer->Release();

    D3DTexture *pTexture = &ZBufferTexture;
    static D3DCOLOR colorBlend = 0xffffffff;

    struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
    v[0].p = D3DXVECTOR4( -0.5f,             -0.5f,              1.0f, 1.0f ); v[0].tu = 0.0f;              v[0].tv = 0.0f;
    v[1].p = D3DXVECTOR4( desc.Width - 0.5f, -0.5f,              1.0f, 1.0f ); v[1].tu = (float)desc.Width; v[1].tv = 0.0f;
    v[2].p = D3DXVECTOR4( -0.5f,             desc.Height - 0.5f, 1.0f, 1.0f ); v[2].tu = 0.0f;              v[2].tv = (float)desc.Height;
    v[3].p = D3DXVECTOR4( desc.Width - 0.5f, desc.Height - 0.5f, 1.0f, 1.0f ); v[3].tu = (float)desc.Width; v[3].tv = (float)desc.Height;
    
    // Set states
    g_pd3dDevice->SetPixelShader( 0 );
    g_pd3dDevice->SetTexture( 0, pTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    static DWORD dwColorArg1 = D3DTA_TEXTURE;
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, dwColorArg1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TFACTOR );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, colorBlend );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);

    // Render the screen-aligned quadrilateral
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );

    // Reset render states
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTexture( 1, NULL );
    g_pd3dDevice->SetPixelShader( 0 );

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// For mapping from the depth buffer to blend values using
// a texture map lookup. See media\shaders\depthlookup.psh
//
// This is more general than computing the range as in
// media\shaders\depth.psh, since the ramp can be filled in
// arbitrarily, but may be more expensive due to the extra texture
// lookup.
//
float FUnitMap(float fAlpha, float fBlue, float fAlphaOffset, float fAlphaSlope, float fBlueOffset, float fBlueSlope)
{
    //return g_fPixelShaderScale * fAlphaSlope * (fAlpha - fAlphaOffset) + fBlueSlope * fBlue + fBlueOffset - 0.5f;
    return g_fPixelShaderScale * fAlphaSlope * (fAlpha - fAlphaOffset) + fBlueSlope * (fBlue - fBlueOffset);
}

float FQuantizedDepth(float fDepth, float *pfAlpha, float *pfBlue)
{
    float fDepth16 = fDepth * (float)(1 << 16);
    DWORD dwDepth16 = (DWORD)(fDepth16 /*+ 0.5f*/);
    *pfAlpha = (dwDepth16 >> 8) * (1.f / 255.f);
    *pfBlue = (dwDepth16 & 0xff) * (1.f / 255.f);
    return (float)dwDepth16 / (float)(1 << 16);
}

HRESULT CXBoxSample::FillFocusRangeTexture(bool bRamp)
{
    HRESULT hr;
    static UINT Width = 256;
    static UINT Height = 64;
    if (m_pTextureFocusRange)
        m_pTextureFocusRange->Release();
    m_pd3dDevice->CreateTexture( Width, Height, 1, 0, D3DFMT_A8, 0, &m_pTextureFocusRange);
    
    D3DLOCKED_RECT lockedRect;
    hr = m_pTextureFocusRange->LockRect(0, &lockedRect, NULL, 0l);
    if (FAILED(hr))
        return hr;
    DWORD dwPixelStride = 1;
    Swizzler s(Width, Height, 0);
    s.SetV(s.SwizzleV(0));
    s.SetU(s.SwizzleU(0));
    if (bRamp)
    {
        for (UINT j = 0; j < Height; j++)
        {
            for (UINT i = 0; i < Width; i++)
            {
                BYTE *p = (BYTE *)lockedRect.pBits + dwPixelStride * s.Get2D();
                *p = (BYTE)i;
                s.IncU();
            }
            s.IncV();
        }
    }
    else
    {
        float fAlphaOffset, fAlphaSlope, fBlueOffset, fBlueSlope;
        CalculateDepthMapping(m_fDepth0, m_fDepth1, &fAlphaOffset, &fAlphaSlope, &fBlueOffset, &fBlueSlope);
        for (UINT i = 0; i < Width; i++)
        {
            for (UINT j = 0; j < Height; j++)
            {
                BYTE *p = (BYTE *)lockedRect.pBits + dwPixelStride * s.Get2D();
                float fAlpha = (float)i / (Width - 1);
                float fBlue = (float)j / (Height - 1);
                float fUnit = 2.f * (FUnitMap(fAlpha, fBlue, fAlphaOffset, fAlphaSlope, fBlueOffset, fBlueSlope) - 0.5f);
                float fMap = 1.f - fUnit * fUnit;
                if (fMap < 0.f) fMap = 0.f;
                if (fMap > 1.f) fMap = 1.f;
                *p = (BYTE)(255 * fMap + 0.5f);
                s.IncV();   // vertical is minor axis
            }
            s.IncU();   // horizontal is major axis
        }
    }
    m_pTextureFocusRange->UnlockRect(0);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Use fractions along viewing vector to set focus depths
//
HRESULT CXBoxSample::CalculateFocusDepths()
{
    D3DXVECTOR3 vEye = m_vAt - m_vFrom;
    D3DXVECTOR3 v0 = m_vFrom + m_fFraction0 * vEye;
    D3DXVECTOR3 v1 = m_vFrom + m_fFraction1 * vEye;
    CalculateDepth(&m_fDepth0, v0);
    CalculateDepth(&m_fDepth1, v1);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Transform a point through our world, view, and projection 
// matrices to obtain a depth value.
//
HRESULT CXBoxSample::CalculateDepth(float *pfDepth, const D3DXVECTOR3 &vPosition)
{
    D3DXVECTOR4 v(vPosition.x, vPosition.y, vPosition.z, 1.f);
    D3DXVec4Transform(&v, &v, &m_matWorld);
    D3DXVec4Transform(&v, &v, &m_matView);
    D3DXVec4Transform(&v, &v, &m_matProjection);
    *pfDepth = v.z / v.w;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Calculate offsets and slope to map given z range to 0,1 in
// the depth and focus pixel shaders.
//
HRESULT CXBoxSample::CalculateDepthMapping(float fDepth0,
                                           float fDepth1,
                                           float *pfAlphaOffset,
                                           float *pfAlphaSlope, 
                                           float *pfBlueOffset,
                                           float *pfBlueSlope)
{
    // check range of args
    if (fDepth0 < 0.f) fDepth0 = 0.f;
    if (fDepth0 > 1.f) fDepth0 = 1.f;
    if (fDepth1 < 0.f) fDepth1 = 0.f;
    if (fDepth1 > 1.f) fDepth1 = 1.f;
    if (fDepth1 < fDepth0)
    {
        // swap depth to make fDepth0 <= fDepth1
        float t = fDepth1;
        fDepth1 = fDepth0;
        fDepth0 = t;
    }
    
    // calculate quantized values
    float fAlpha0, fBlue0;
    float fQuantizedDepth0 = FQuantizedDepth(fDepth0, &fAlpha0, &fBlue0);
    float fAlpha1, fBlue1;
    float fQuantizedDepth1 = FQuantizedDepth(fDepth1, &fAlpha1, &fBlue1);

    // calculate offset and slopes
    float fScale = 1.f / (fQuantizedDepth1 - fQuantizedDepth0);
    if (fScale > g_fPixelShaderScale)
    {
        fScale = g_fPixelShaderScale; // this is the steepest slope we can handle
        fDepth0 = 0.5f * (fDepth0 + fDepth1) - 0.5f / fScale; // move start so that peak is in middle of fDepth0 and fDepth1
        fDepth1 = fDepth0 + 1.f / fScale;
        fQuantizedDepth0 = FQuantizedDepth(fDepth0, &fAlpha0, &fBlue0);
        fQuantizedDepth1 = FQuantizedDepth(fDepth1, &fAlpha1, &fBlue1);
    }
    *pfAlphaOffset = fAlpha0;
    *pfAlphaSlope = fScale / g_fPixelShaderScale;
    *pfBlueSlope = fScale * (1.f/255.f); // blue ramp adds more levels to the ramp

    // align peak of map to center by calculating the quantized alpha value
    /*
    *pfBlueOffset = 0.5f;   // zero biased up by 0.5f
    float fZeroDesired = (fQuantizedDepth0 - fDepth0) / (fDepth1 - fDepth0);
    float fZero = FUnitMap(fAlpha0, fBlue0, *pfAlphaOffset, *pfAlphaSlope, *pfBlueOffset, *pfBlueSlope);
    float fOneDesired = (fQuantizedDepth1 - fDepth0) / (fDepth1 - fDepth0);
    float fOne = FUnitMap(fAlpha1, fBlue1, *pfAlphaOffset, *pfAlphaSlope, *pfBlueOffset, *pfBlueSlope);
    *pfBlueOffset = 0.5f * (fZeroDesired-fZero + fOneDesired-fOne) + 0.5f;  // biased up by 0.5f
    */
    *pfBlueOffset = fBlue0;
    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawDepthRange
// Desc: Display the depth buffer mapped to focus values using pixel shader
//       arithmetic.  See media/shaders/depth.psh for more details.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawDepthRange()
{
    // Make a D3DTexture wrapper around the depth buffer surface
    D3DSURFACE_DESC desc;
    D3DSurface *pZBuffer;
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );
    pZBuffer->GetDesc(&desc);
    D3DTexture ZBufferTexture;
    ZeroMemory( &ZBufferTexture, sizeof(ZBufferTexture) );
    static D3DFORMAT fmtOverride = D3DFMT_LIN_A8B8G8R8;
    XGSetTextureHeader( desc.Width, desc.Height, 1, 0, fmtOverride, 0, &ZBufferTexture, pZBuffer->Data, desc.Width * 4);
    pZBuffer->Release();

    D3DTexture *pTexture = &ZBufferTexture;
    static D3DCOLOR colorBlend = 0xffffffff;

    struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
    v[0].p = D3DXVECTOR4( -0.5f,             -0.5f,              1.0f, 1.0f ); v[0].tu = 0.0f;              v[0].tv = 0.0f;
    v[1].p = D3DXVECTOR4( desc.Width - 0.5f, -0.5f,              1.0f, 1.0f ); v[1].tu = (float)desc.Width; v[1].tv = 0.0f;
    v[2].p = D3DXVECTOR4( -0.5f,             desc.Height - 0.5f, 1.0f, 1.0f ); v[2].tu = 0.0f;              v[2].tv = (float)desc.Height;
    v[3].p = D3DXVECTOR4( desc.Width - 0.5f, desc.Height - 0.5f, 1.0f, 1.0f ); v[3].tu = (float)desc.Width; v[3].tv = (float)desc.Height;
    
    // Set pixel shader states
    g_pd3dDevice->SetPixelShader( m_dwDepthPixelShader );
    float fAlphaOffset, fAlphaSlope, fBlueOffset, fBlueSlope;
    CalculateDepthMapping(m_fDepth0, m_fDepth1, &fAlphaOffset, &fAlphaSlope, &fBlueOffset, &fBlueSlope);
    float rfConstants[] = {
        0.f, 0.f, fBlueOffset, fAlphaOffset,        // offset
        0.f, 0.f, fBlueSlope, 0.f,                  // 1x
        0.f, 0.f, 0.f, 0.f,                         // 4x
        0.f, 0.f, 0.f, fAlphaSlope,                 // 16x
    };
    g_pd3dDevice->SetPixelShaderConstant( 0, rfConstants, 4 );
    D3DXCOLOR blend(colorBlend);
    g_pd3dDevice->SetPixelShaderConstant( 4, &blend, 1 );

    g_pd3dDevice->SetTexture( 0, pTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, 0 );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);

    // Render the screen-aligned quadrilateral
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );

    // Reset render states
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTexture( 1, NULL );
    g_pd3dDevice->SetPixelShader( 0 );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawDepthLookup
// Desc: Display the depth buffer mapped through the lookup texture. This
//       function is for demonstrating the range of z values mapped to
//       focus values.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawDepthLookup()
{
    // Make a D3DTexture wrapper around the depth buffer surface
    D3DSURFACE_DESC desc;
    D3DSurface *pZBuffer;
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );
    pZBuffer->GetDesc(&desc);
    D3DTexture ZBufferTexture;
    ZeroMemory( &ZBufferTexture, sizeof(ZBufferTexture) );
    static D3DFORMAT fmtOverride = D3DFMT_LIN_A8R8G8B8;
    XGSetTextureHeader( desc.Width, desc.Height, 1, 0, fmtOverride, 0, &ZBufferTexture, pZBuffer->Data, desc.Width * 4);
    pZBuffer->Release();

    D3DTexture *pTexture = &ZBufferTexture;
    static D3DCOLOR colorBlend = 0xffffffff;

    struct BACKGROUNDVERTEX { D3DXVECTOR4 p; FLOAT tu, tv; } v[4];
    v[0].p = D3DXVECTOR4( -0.5f,             -0.5f,              1.0f, 1.0f ); v[0].tu = 0.0f;              v[0].tv = 0.0f;
    v[1].p = D3DXVECTOR4( desc.Width - 0.5f, -0.5f,              1.0f, 1.0f ); v[1].tu = (float)desc.Width; v[1].tv = 0.0f;
    v[2].p = D3DXVECTOR4( -0.5f,             desc.Height - 0.5f, 1.0f, 1.0f ); v[2].tu = 0.0f;              v[2].tv = (float)desc.Height;
    v[3].p = D3DXVECTOR4( desc.Width - 0.5f, desc.Height - 0.5f, 1.0f, 1.0f ); v[3].tu = (float)desc.Width; v[3].tv = (float)desc.Height;

    // Set the filter modes
    D3DXCOLOR blend(colorBlend);
    g_pd3dDevice->SetTexture( 0, pTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin0 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag0 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, dwMin0 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, dwMag0 );
    g_pd3dDevice->SetTexture( 1, m_pTextureFocusRange );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin1 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag1 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, dwMin1 );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, dwMag1 );
    g_pd3dDevice->SetPixelShader( m_dwDepthLookupPixelShader );
    g_pd3dDevice->SetPixelShaderConstant( 0, &blend, 1 );

    // Set render state
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, 0 );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);

    // Render the screen-aligned quadrilateral
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(BACKGROUNDVERTEX) );

    // Reset render states
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTexture( 1, NULL );
    g_pd3dDevice->SetPixelShader( 0 );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawFocusRange
//
// Desc: Choose the focus range by mapping z to a focus value using pixel
//       shader arithmetic.  See media/shaders/focus.psh for more details.
//
//       High focus values leave the back-buffer unchanged.
//       Low focus values blend in the blurred texture computed by Blur().
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawFocusRange()
{
    // Make a D3DTexture wrapper around the depth buffer surface
    D3DSURFACE_DESC desc;
    D3DSurface *pZBuffer;
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );
    pZBuffer->GetDesc(&desc);
    D3DTexture ZBufferTexture;
    ZeroMemory( &ZBufferTexture, sizeof(ZBufferTexture) );
    static D3DFORMAT fmtOverride = D3DFMT_LIN_A8B8G8R8;
    XGSetTextureHeader( desc.Width, desc.Height, 1, 0, fmtOverride, 0, &ZBufferTexture, pZBuffer->Data, desc.Width * 4);
    pZBuffer->Release();
    D3DTexture *pZBufferTexture = &ZBufferTexture;

    // Get size of blur texture for setting texture coords of final blur
    D3DSURFACE_DESC descBlur;
    m_pBlur->GetLevelDesc(0, &descBlur);
    float fOffsetX = 0.f;
    float fOffsetY = 0.5f / (float)descBlur.Height; // vertical blur
    struct VERTEX {
        D3DXVECTOR4 p;
        FLOAT tu0, tv0;
        FLOAT tu1, tv1;
    } v[4];
    v[0].p = D3DXVECTOR4( -0.5f,             -0.5f,              1.0f, 1.0f );
    v[1].p = D3DXVECTOR4( desc.Width - 0.5f, -0.5f,              1.0f, 1.0f );
    v[2].p = D3DXVECTOR4( -0.5f,             desc.Height - 0.5f, 1.0f, 1.0f );
    v[3].p = D3DXVECTOR4( desc.Width - 0.5f, desc.Height - 0.5f, 1.0f, 1.0f );
    v[0].tu0 = 0.0f;              v[0].tv0 = 0.0f;
    v[1].tu0 = (float)desc.Width; v[1].tv0 = 0.0f;
    v[2].tu0 = 0.0f;              v[2].tv0 = (float)desc.Height;
    v[3].tu0 = (float)desc.Width; v[3].tv0 = (float)desc.Height;
    v[0].tu1 = fOffsetX;                         v[0].tv1 = fOffsetY;
    v[1].tu1 = fOffsetX + (float)descBlur.Width; v[1].tv1 = fOffsetY;
    v[2].tu1 = fOffsetX;                         v[2].tv1 = fOffsetY + (float)descBlur.Height;
    v[3].tu1 = fOffsetX + (float)descBlur.Width; v[3].tv1 = fOffsetY + (float)descBlur.Height;
    
    // Set pixel shader state
    g_pd3dDevice->SetPixelShader( m_dwFocusPixelShader );
    float fAlphaOffset, fAlphaSlope, fBlueOffset, fBlueSlope;
    CalculateDepthMapping(m_fDepth0, m_fDepth1, &fAlphaOffset, &fAlphaSlope, &fBlueOffset, &fBlueSlope);
    float rfConstants[] = {
        0.f, 0.f, fBlueOffset, fAlphaOffset,        // offset
        0.f, 0.f, fBlueSlope, 0.f,                  // 1x
        0.f, 0.f, 0.f, 0.f,                         // 4x
        0.f, 0.f, 0.f, fAlphaSlope,                 // 16x
    };
    g_pd3dDevice->SetPixelShaderConstant( 0, rfConstants, 4 );
    
    // Set render state
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, 0 );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_ONE );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);

    // Set texture state
    g_pd3dDevice->SetTexture( 0, pZBufferTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin0 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag0 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, dwMin0 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, dwMag0 );
    g_pd3dDevice->SetTexture( 1, m_pBlur );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1 );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin1 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag1 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, dwMin1 );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, dwMag1 );

    // Disable texture stages 2 and 3
    g_pd3dDevice->SetTexture( 2, NULL );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
    g_pd3dDevice->SetTexture( 3, NULL );
    g_pd3dDevice->SetTextureStageState( 3, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP, D3DTOP_DISABLE );
    
    // Render the screen-aligned quadrilateral
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX4 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(VERTEX) );

    // Reset render states
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTexture( 1, NULL );
    g_pd3dDevice->SetTexture( 2, NULL );
    g_pd3dDevice->SetTexture( 3, NULL );
    g_pd3dDevice->SetPixelShader( 0 );

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DrawFocusLookup
//
// Desc: Choose the focus range by mapping z through a lookup texture.
//
//       See media/shaders/focuslookup.psh for more detail.
//
//       This technique has lower performance than using DrawFocus(),
//       but the focus values can be arbitrary, rather than the
//       limited types of z-to-focus value mappings available with
//       pixel shader arithmetic.
//
//       High focus values leave the back-buffer unchanged.
//       Low focus values blend in the blurred texture computed by Blur().
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DrawFocusLookup()
{
    // Make a D3DTexture wrapper around the depth buffer surface
    D3DSURFACE_DESC desc;
    D3DSurface *pZBuffer;
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );
    pZBuffer->GetDesc(&desc);
    D3DTexture ZBufferTexture;
    ZeroMemory( &ZBufferTexture, sizeof(ZBufferTexture) );
    static D3DFORMAT fmtOverride = D3DFMT_LIN_A8R8G8B8;
    XGSetTextureHeader( desc.Width, desc.Height, 1, 0, fmtOverride, 0, &ZBufferTexture, pZBuffer->Data, desc.Width * 4);
    pZBuffer->Release();
    D3DTexture *pZBufferTexture = &ZBufferTexture;

    // Get size of blur texture for setting texture coords of final blur
    D3DSURFACE_DESC descBlur;
    m_pBlur->GetLevelDesc(0, &descBlur);
    float fOffsetX = 0.f;
    float fOffsetY = 0.5f / (float)descBlur.Height; // vertical blur

    struct VERTEX {
        D3DXVECTOR4 p;
        FLOAT tu0, tv0;
        FLOAT tu1, tv1;
        FLOAT tu2, tv2;
        FLOAT tu3, tv3;
    } v[4];
    v[0].p = D3DXVECTOR4( -0.5f,             -0.5f,              1.0f, 1.0f );
    v[1].p = D3DXVECTOR4( desc.Width - 0.5f, -0.5f,              1.0f, 1.0f );
    v[2].p = D3DXVECTOR4( -0.5f,             desc.Height - 0.5f, 1.0f, 1.0f );
    v[3].p = D3DXVECTOR4( desc.Width - 0.5f, desc.Height - 0.5f, 1.0f, 1.0f );
    v[0].tu0 = 0.0f;              v[0].tv0 = 0.0f;
    v[1].tu0 = (float)desc.Width; v[1].tv0 = 0.0f;
    v[2].tu0 = 0.0f;              v[2].tv0 = (float)desc.Height;
    v[3].tu0 = (float)desc.Width; v[3].tv0 = (float)desc.Height;
    // tu1 and tv1 are ignored
    // offset final set of texture coords to apply an additional blur
    v[0].tu2 = -fOffsetX;                         v[0].tv2 = -fOffsetY;
    v[1].tu2 = -fOffsetX + (float)descBlur.Width; v[1].tv2 = -fOffsetY;
    v[2].tu2 = -fOffsetX;                         v[2].tv2 = -fOffsetY + (float)descBlur.Height;
    v[3].tu2 = -fOffsetX + (float)descBlur.Width; v[3].tv2 = -fOffsetY + (float)descBlur.Height;
    v[0].tu3 =  fOffsetX;                         v[0].tv3 =  fOffsetY;
    v[1].tu3 =  fOffsetX + (float)descBlur.Width; v[1].tv3 =  fOffsetY;
    v[2].tu3 =  fOffsetX;                         v[2].tv3 =  fOffsetY + (float)descBlur.Height;
    v[3].tu3 =  fOffsetX + (float)descBlur.Width; v[3].tv3 =  fOffsetY + (float)descBlur.Height;

    // Set pixel shader
    g_pd3dDevice->SetPixelShader( m_dwFocusLookupPixelShader );

    // Set render state
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAREF, 0 );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC, D3DCMP_GREATER );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    g_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_ONE );
    g_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    g_pd3dDevice->SetRenderState( D3DRS_FILLMODE, D3DFILL_SOLID);

    // Set texture state
    g_pd3dDevice->SetTexture( 0, pZBufferTexture );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin0 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag0 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, dwMin0 );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, dwMag0 );
    g_pd3dDevice->SetTexture( 1, m_pTextureFocusRange );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin1 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag1 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, dwMin1 );
    g_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, dwMag1 );
    g_pd3dDevice->SetTexture( 2, m_pBlur );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin2 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag2 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_MINFILTER, dwMin2 );
    g_pd3dDevice->SetTextureStageState( 2, D3DTSS_MAGFILTER, dwMag2 );
    g_pd3dDevice->SetTexture( 3, m_pBlur );
    g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    g_pd3dDevice->SetTextureStageState( 3, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    static D3DTEXTUREFILTERTYPE dwMin3 = D3DTEXF_LINEAR;
    static D3DTEXTUREFILTERTYPE dwMag3 = D3DTEXF_LINEAR;
    g_pd3dDevice->SetTextureStageState( 3, D3DTSS_MINFILTER, dwMin3 );
    g_pd3dDevice->SetTextureStageState( 3, D3DTSS_MAGFILTER, dwMag3 );
    
    // Render the screen-aligned quadrilateral
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX4 );
    g_pd3dDevice->DrawPrimitiveUP( D3DPT_QUADSTRIP, 1, v, sizeof(VERTEX) );

    // Reset render states
    g_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTexture( 1, NULL );
    g_pd3dDevice->SetTexture( 2, NULL );
    g_pd3dDevice->SetTexture( 3, NULL );
    g_pd3dDevice->SetPixelShader( 0 );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\focuslookup.inl ===
// Xbox Shader Assembler 1.00.4232.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    1,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_DPNDNT_AR,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x80808080;
psd.PSConstant1[0] = 0x00000000;

//------------- FinalCombiner -------------
psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_FINALCOMBINERSETTING_CLAMP_SUM | 0 | 0);
psd.PSFinalCombinerConstant0 = 0x00000000;
psd.PSFinalCombinerConstant1 = 0x00000000;

psd.PSC0Mapping = 0xfffffff0;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\blur.inl ===
// Xbox Shader Assembler 1.00.4030.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    3,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x40404040;
psd.PSConstant1[0] = 0x40404040;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T2 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T3 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T2 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_C1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_T3 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_SHIFTLEFT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0x40404040;
psd.PSConstant1[1] = 0x40404040;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_SHIFTRIGHT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_SHIFTRIGHT_1 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x00000000;
psd.PSConstant1[2] = 0x00000000;

//------------- FinalCombiner -------------
psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_FINALCOMBINERSETTING_CLAMP_SUM | 0 | 0);
psd.PSFinalCombinerConstant0 = 0x00000000;
psd.PSFinalCombinerConstant1 = 0x00000000;

psd.PSC0Mapping = 0xffffff20;
psd.PSC1Mapping = 0xffffff31;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\focus.inl ===
// Xbox Shader Assembler 1.00.4232.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    8,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_EXPAND_NORMAL);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- Stage 1 -------------
psd.PSRGBInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[1]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[1]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[1] = 0xff000000;
psd.PSConstant1[1] = 0x00000000;

//------------- Stage 2 -------------
psd.PSRGBInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[2]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[2]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_SHIFTLEFT_2 | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[2] = 0x00000000;
psd.PSConstant1[2] = 0x00000000;

//------------- Stage 3 -------------
psd.PSRGBInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSAlphaInputs[3]=PS_COMBINERINPUTS(
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY);
psd.PSRGBOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[3]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[3] = 0x000000ff;
psd.PSConstant1[3] = 0x00000000;

//------------- Stage 4 -------------
psd.PSRGBInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[4]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL);
psd.PSRGBOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[4]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[4] = 0x7fffffff;
psd.PSConstant1[4] = 0x00000000;

//------------- Stage 5 -------------
psd.PSRGBInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[5]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_BLUE | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSRGBOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[5]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R0,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_MUX);
psd.PSConstant0[5] = 0x00000000;
psd.PSConstant1[5] = 0x00000000;

//------------- Stage 6 -------------
psd.PSRGBInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[6]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_R0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT);
psd.PSRGBOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[6]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_R1,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[6] = 0x00000000;
psd.PSConstant1[6] = 0x00000000;

//------------- Stage 7 -------------
psd.PSRGBInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[7]=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_EXPAND_NORMAL,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[7]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R1,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[7] = 0x00000000;
psd.PSConstant1[7] = 0x00000000;

//------------- FinalCombiner -------------
psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_T1 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_R1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_FINALCOMBINERSETTING_CLAMP_SUM | 0 | 0);
psd.PSFinalCombinerConstant0 = 0x00000000;
psd.PSFinalCombinerConstant1 = 0x00000000;

psd.PSC0Mapping = 0xfff41230;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001ff;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\depthlookup.inl ===
// Xbox Shader Assembler 1.00.4232.1
D3DPIXELSHADERDEF psd;
ZeroMemory(&psd, sizeof(psd));
psd.PSCombinerCount=PS_COMBINERCOUNT(
    1,
    PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
psd.PSTextureModes=PS_TEXTUREMODES(
    PS_TEXTUREMODES_PROJECT2D,
    PS_TEXTUREMODES_DPNDNT_AR,
    PS_TEXTUREMODES_NONE,
    PS_TEXTUREMODES_NONE);
psd.PSInputTexture=PS_INPUTTEXTURE(0,0,0,0);
psd.PSDotMapping=PS_DOTMAPPING(
    0,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE,
    PS_DOTMAPPING_ZERO_TO_ONE);
psd.PSCompareMode=PS_COMPAREMODE(
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
    PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT);

//------------- Stage 0 -------------
psd.PSRGBInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSAlphaInputs[0]=PS_COMBINERINPUTS(
    PS_REGISTER_T1 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_SIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSRGBOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSAlphaOutputs[0]=PS_COMBINEROUTPUTS(
    PS_REGISTER_R0,
    PS_REGISTER_DISCARD,
    PS_REGISTER_DISCARD,
    PS_COMBINEROUTPUT_IDENTITY | PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM);
psd.PSConstant0[0] = 0x00000000;
psd.PSConstant1[0] = 0x00000000;

//------------- FinalCombiner -------------
psd.PSFinalCombinerInputsABCD=PS_COMBINERINPUTS(
    PS_REGISTER_R0 | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_INVERT,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY);
psd.PSFinalCombinerInputsEFG=PS_COMBINERINPUTS(
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_ZERO | PS_CHANNEL_RGB | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_REGISTER_C0 | PS_CHANNEL_ALPHA | PS_INPUTMAPPING_UNSIGNED_IDENTITY,
    PS_FINALCOMBINERSETTING_CLAMP_SUM | 0 | 0);
psd.PSFinalCombinerConstant0 = 0xffffffff;
psd.PSFinalCombinerConstant1 = 0x00000000;

psd.PSC0Mapping = 0xffffffff;
psd.PSC1Mapping = 0xffffffff;
psd.PSFinalCombinerConstants = 0x000001f0;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\obj\i386\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fog\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fog\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fog\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\obj\i386\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Texture0_OFFSET 0UL
#define resource_Texture1_OFFSET 20UL
#define resource_Checker_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\FocusBlur\resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 3UL

#define resource_Texture0_OFFSET 0UL
#define resource_Texture1_OFFSET 20UL
#define resource_Checker_OFFSET 40UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fog\obj\i386\Font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\atg\samples\graphics\fog\fog.cpp ===
//-----------------------------------------------------------------------------
// File: Fog.cpp
//
// Desc: Example code showing how to do fog in D3D
//
// Perf: Note that this sample has not been performance optimized. It has been
//       structured as is (redundant state setting, etc.) to illustrate the
//       usage of the API.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       07.05.01 - Added a vertex shader
//
// Copyright (c) Microsoft Corporati